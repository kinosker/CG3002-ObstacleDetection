
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002d1a  00002dae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d1a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000709  0080023e  0080023e  00002dec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002dec  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000548  00000000  00000000  00002e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005d2a  00000000  00000000  00003364  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001679  00000000  00000000  0000908e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000374f  00000000  00000000  0000a707  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000ed0  00000000  00000000  0000de58  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000016bb  00000000  00000000  0000ed28  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003fbf  00000000  00000000  000103e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004d8  00000000  00000000  000143a2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	5d c3       	rjmp	.+1722   	; 0x6e0 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 dc 09 	jmp	0x13b8	; 0x13b8 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	94 c6       	rjmp	.+3368   	; 0xd8e <__vector_25>
      66:	00 00       	nop
      68:	00 c7       	rjmp	.+3584   	; 0xe6a <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	ea c3       	rjmp	.+2004   	; 0x84a <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	46 c6       	rjmp	.+3212   	; 0xd1e <__vector_36>
      92:	00 00       	nop
      94:	b4 c6       	rjmp	.+3432   	; 0xdfe <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myADC_readADC+0x1a>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ea e1       	ldi	r30, 0x1A	; 26
     17e:	fd e2       	ldi	r31, 0x2D	; 45
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 34       	cpi	r26, 0x47	; 71
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c7 d0       	rcall	.+398    	; 0x330 <main>
     1a2:	0c 94 8b 16 	jmp	0x2d16	; 0x2d16 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	75 d7       	rcall	.+3818   	; 0x1094 <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	61 d7       	rcall	.+3778   	; 0x1070 <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	23 d7       	rcall	.+3654   	; 0xffa <myUSART_receiveUSART1>
     1b4:	52 d7       	rcall	.+3748   	; 0x105a <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	66 d7       	rcall	.+3788   	; 0x1088 <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	11 f0       	breq	.+4      	; 0x1c4 <RPI_receiveTask+0x1c>
     1c0:	1c d7       	rcall	.+3640   	; 0xffa <myUSART_receiveUSART1>
     1c2:	f2 cf       	rjmp	.-28     	; 0x1a8 <RPI_receiveTask>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	5a d7       	rcall	.+3764   	; 0x107c <myUSART_receiveHandShakeStart>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <RPI_receiveTask+0x28>
     1cc:	37 d7       	rcall	.+3694   	; 0x103c <myUSART_waitForHandshake>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	14 d7       	rcall	.+3624   	; 0xffa <myUSART_receiveUSART1>
     1d2:	ea cf       	rjmp	.-44     	; 0x1a8 <RPI_receiveTask>

000001d4 <RPI_sendTask>:
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <RPI_sendTask+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <RPI_sendTask+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	4f ef       	ldi	r20, 0xFF	; 255
     1e4:	5f ef       	ldi	r21, 0xFF	; 255
     1e6:	be 01       	movw	r22, r28
     1e8:	6a 5f       	subi	r22, 0xFA	; 250
     1ea:	7f 4f       	sbci	r23, 0xFF	; 255
     1ec:	80 91 8f 08 	lds	r24, 0x088F
     1f0:	90 91 90 08 	lds	r25, 0x0890
     1f4:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <xQueueGenericReceive>
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	80 5d       	subi	r24, 0xD0	; 208
     1fc:	cb d6       	rcall	.+3478   	; 0xf94 <myUSART_transmitUSART1_c>
     1fe:	8a e0       	ldi	r24, 0x0A	; 10
     200:	c9 d6       	rcall	.+3474   	; 0xf94 <myUSART_transmitUSART1_c>
     202:	8e 81       	ldd	r24, Y+6	; 0x06
     204:	9f ef       	ldi	r25, 0xFF	; 255
     206:	98 0f       	add	r25, r24
     208:	9e 83       	std	Y+6, r25	; 0x06
     20a:	88 23       	and	r24, r24
     20c:	21 f1       	breq	.+72     	; 0x256 <RPI_sendTask+0x82>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	4f ef       	ldi	r20, 0xFF	; 255
     212:	5f ef       	ldi	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 91 08 	lds	r24, 0x0891
     21e:	90 91 92 08 	lds	r25, 0x0892
     222:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <xQueueGenericReceive>
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	9e d6       	rcall	.+3388   	; 0xf66 <myUSART_transmitUSART0_c>
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	b3 d6       	rcall	.+3430   	; 0xf94 <myUSART_transmitUSART1_c>
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	92 e0       	ldi	r25, 0x02	; 2
     232:	d5 d6       	rcall	.+3498   	; 0xfde <myUSART_transmitUSART0>
     234:	ce 01       	movw	r24, r28
     236:	02 96       	adiw	r24, 0x02	; 2
     238:	d2 d6       	rcall	.+3492   	; 0xfde <myUSART_transmitUSART0>
     23a:	ce 01       	movw	r24, r28
     23c:	02 96       	adiw	r24, 0x02	; 2
     23e:	c1 d6       	rcall	.+3458   	; 0xfc2 <myUSART_transmitUSART1>
     240:	8a e0       	ldi	r24, 0x0A	; 10
     242:	a8 d6       	rcall	.+3408   	; 0xf94 <myUSART_transmitUSART1_c>
     244:	89 e0       	ldi	r24, 0x09	; 9
     246:	92 e0       	ldi	r25, 0x02	; 2
     248:	ca d6       	rcall	.+3476   	; 0xfde <myUSART_transmitUSART0>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f ef       	ldi	r25, 0xFF	; 255
     24e:	98 0f       	add	r25, r24
     250:	9e 83       	std	Y+6, r25	; 0x06
     252:	81 11       	cpse	r24, r1
     254:	dc cf       	rjmp	.-72     	; 0x20e <RPI_sendTask+0x3a>
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	86 d6       	rcall	.+3340   	; 0xf66 <myUSART_transmitUSART0_c>
     25a:	c2 cf       	rjmp	.-124    	; 0x1e0 <RPI_sendTask+0xc>

0000025c <myTimerTask>:
     25c:	b1 d4       	rcall	.+2402   	; 0xbc0 <myTimer_Init>
     25e:	f0 d4       	rcall	.+2528   	; 0xc40 <myTimer_DelayChecker>
     260:	fe cf       	rjmp	.-4      	; 0x25e <myTimerTask+0x2>

00000262 <task1>:
     262:	26 9a       	sbi	0x04, 6	; 4
     264:	2e 9a       	sbi	0x05, 6	; 5
     266:	88 ee       	ldi	r24, 0xE8	; 232
     268:	93 e0       	ldi	r25, 0x03	; 3
     26a:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vTaskDelay>
     26e:	85 b1       	in	r24, 0x05	; 5
     270:	15 b8       	out	0x05, r1	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <vTaskDelay>
     27a:	f4 cf       	rjmp	.-24     	; 0x264 <task1+0x2>

0000027c <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     27c:	8f ef       	ldi	r24, 0xFF	; 255
     27e:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     282:	ef e7       	ldi	r30, 0x7F	; 127
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	90 81       	ld	r25, Z
     288:	93 60       	ori	r25, 0x03	; 3
     28a:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     28c:	80 93 7d 00 	sts	0x007D, r24
     290:	08 95       	ret

00000292 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     292:	8c ec       	ldi	r24, 0xCC	; 204
     294:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     298:	8e e3       	ldi	r24, 0x3E	; 62
     29a:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     29e:	ee cf       	rjmp	.-36     	; 0x27c <setDigitalInputPowerReduction>
     2a0:	08 95       	ret

000002a2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2a2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2a6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2aa:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ae:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2b2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2b6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ba:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2be:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2c2:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2c6:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2ca:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2ce:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2d2:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2d6:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2da:	10 92 73 00 	sts	0x0073, r1
     2de:	08 95       	ret

000002e0 <init>:
}

void init()
{
     2e0:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2e2:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2e4:	f8 94       	cli
	{
		clearTimer();
     2e6:	dd df       	rcall	.-70     	; 0x2a2 <clearTimer>
		setPowerReduction();
     2e8:	d4 df       	rcall	.-88     	; 0x292 <setPowerReduction>
		myUSART_USART0_Init();
     2ea:	f5 d5       	rcall	.+3050   	; 0xed6 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2ec:	14 d6       	rcall	.+3112   	; 0xf16 <myUSART_USART1_Init>
		myADC_Init();
     2ee:	e5 d2       	rcall	.+1482   	; 0x8ba <myADC_Init>
		
		MaxSonar_Init();
     2f0:	83 b3       	in	r24, 0x13	; 19
     2f2:	83 60       	ori	r24, 0x03	; 3
     2f4:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     2f6:	7e d2       	rcall	.+1276   	; 0x7f4 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2f8:	40 e0       	ldi	r20, 0x00	; 0
     2fa:	61 e0       	ldi	r22, 0x01	; 1
     2fc:	85 e0       	ldi	r24, 0x05	; 5
     2fe:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <xQueueGenericCreate>
     302:	90 93 90 08 	sts	0x0890, r25
     306:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     30a:	40 e0       	ldi	r20, 0x00	; 0
     30c:	65 e0       	ldi	r22, 0x05	; 5
     30e:	84 e1       	ldi	r24, 0x14	; 20
     310:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <xQueueGenericCreate>
     314:	90 93 92 08 	sts	0x0892, r25
     318:	80 93 91 08 	sts	0x0891, r24
		
		MOTOR_LEFT_INIT();
     31c:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     31e:	e1 e0       	ldi	r30, 0x01	; 1
     320:	f1 e0       	ldi	r31, 0x01	; 1
     322:	80 81       	ld	r24, Z
     324:	80 61       	ori	r24, 0x10	; 16
     326:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     328:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     32a:	78 94       	sei
}
     32c:	cf 91       	pop	r28
     32e:	08 95       	ret

00000330 <main>:
	
	// do nth
}

int main(void)
{
     330:	cf 93       	push	r28
     332:	df 93       	push	r29
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
     338:	2a 97       	sbiw	r28, 0x0a	; 10
     33a:	0f b6       	in	r0, 0x3f	; 63
     33c:	f8 94       	cli
     33e:	de bf       	out	0x3e, r29	; 62
     340:	0f be       	out	0x3f, r0	; 63
     342:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     344:	cd df       	rcall	.-102    	; 0x2e0 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     346:	a1 2c       	mov	r10, r1
     348:	b1 2c       	mov	r11, r1
     34a:	c1 2c       	mov	r12, r1
     34c:	d1 2c       	mov	r13, r1
     34e:	ce 01       	movw	r24, r28
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	7c 01       	movw	r14, r24
     354:	01 e0       	ldi	r16, 0x01	; 1
     356:	20 e0       	ldi	r18, 0x00	; 0
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	45 e5       	ldi	r20, 0x55	; 85
     35c:	50 e0       	ldi	r21, 0x00	; 0
     35e:	6c e0       	ldi	r22, 0x0C	; 12
     360:	72 e0       	ldi	r23, 0x02	; 2
     362:	81 e3       	ldi	r24, 0x31	; 49
     364:	91 e0       	ldi	r25, 0x01	; 1
     366:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     36a:	ce 01       	movw	r24, r28
     36c:	03 96       	adiw	r24, 0x03	; 3
     36e:	7c 01       	movw	r14, r24
     370:	04 e0       	ldi	r16, 0x04	; 4
     372:	9c 01       	movw	r18, r24
     374:	49 e6       	ldi	r20, 0x69	; 105
     376:	50 e0       	ldi	r21, 0x00	; 0
     378:	63 e1       	ldi	r22, 0x13	; 19
     37a:	72 e0       	ldi	r23, 0x02	; 2
     37c:	8e e2       	ldi	r24, 0x2E	; 46
     37e:	91 e0       	ldi	r25, 0x01	; 1
     380:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     384:	ce 01       	movw	r24, r28
     386:	09 96       	adiw	r24, 0x09	; 9
     388:	7c 01       	movw	r14, r24
     38a:	02 e0       	ldi	r16, 0x02	; 2
     38c:	20 e0       	ldi	r18, 0x00	; 0
     38e:	30 e0       	ldi	r19, 0x00	; 0
     390:	4f e4       	ldi	r20, 0x4F	; 79
     392:	51 e0       	ldi	r21, 0x01	; 1
     394:	6b e1       	ldi	r22, 0x1B	; 27
     396:	72 e0       	ldi	r23, 0x02	; 2
     398:	8c e5       	ldi	r24, 0x5C	; 92
     39a:	92 e0       	ldi	r25, 0x02	; 2
     39c:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a0:	ce 01       	movw	r24, r28
     3a2:	07 96       	adiw	r24, 0x07	; 7
     3a4:	7c 01       	movw	r14, r24
     3a6:	03 e0       	ldi	r16, 0x03	; 3
     3a8:	20 e0       	ldi	r18, 0x00	; 0
     3aa:	30 e0       	ldi	r19, 0x00	; 0
     3ac:	47 e8       	ldi	r20, 0x87	; 135
     3ae:	50 e0       	ldi	r21, 0x00	; 0
     3b0:	64 e2       	ldi	r22, 0x24	; 36
     3b2:	72 e0       	ldi	r23, 0x02	; 2
     3b4:	84 ed       	ldi	r24, 0xD4	; 212
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3bc:	ce 01       	movw	r24, r28
     3be:	05 96       	adiw	r24, 0x05	; 5
     3c0:	7c 01       	movw	r14, r24
     3c2:	01 e0       	ldi	r16, 0x01	; 1
     3c4:	20 e0       	ldi	r18, 0x00	; 0
     3c6:	30 e0       	ldi	r19, 0x00	; 0
     3c8:	47 e8       	ldi	r20, 0x87	; 135
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	60 e3       	ldi	r22, 0x30	; 48
     3ce:	72 e0       	ldi	r23, 0x02	; 2
     3d0:	8a ee       	ldi	r24, 0xEA	; 234
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3d8:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vTaskStartScheduler>
     3dc:	b3 cf       	rjmp	.-154    	; 0x344 <main+0x14>

000003de <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     3de:	1f 93       	push	r17
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	00 d0       	rcall	.+0      	; 0x3e6 <obstacleSend+0x8>
     3e6:	1f 92       	push	r1
     3e8:	1f 92       	push	r1
     3ea:	cd b7       	in	r28, 0x3d	; 61
     3ec:	de b7       	in	r29, 0x3e	; 62
     3ee:	18 2f       	mov	r17, r24
     3f0:	cb 01       	movw	r24, r22
	obstacleData queueData;
	
	
	
	if(deviceBlocked)
     3f2:	11 23       	and	r17, r17
     3f4:	99 f0       	breq	.+38     	; 0x41c <obstacleSend+0x3e>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     3f6:	4a e0       	ldi	r20, 0x0A	; 10
     3f8:	be 01       	movw	r22, r28
     3fa:	6e 5f       	subi	r22, 0xFE	; 254
     3fc:	7f 4f       	sbci	r23, 0xFF	; 255
     3fe:	0e 94 58 16 	call	0x2cb0	; 0x2cb0 <__itoa_ncheck>
	{
		itoa(reading, queueData.data, 10); // convert to ascii
		
		queueData.deviceID = deviceBlocked;
     402:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &queueData, portMAX_DELAY); // send data to queueData
     404:	20 e0       	ldi	r18, 0x00	; 0
     406:	4f ef       	ldi	r20, 0xFF	; 255
     408:	5f ef       	ldi	r21, 0xFF	; 255
     40a:	be 01       	movw	r22, r28
     40c:	6f 5f       	subi	r22, 0xFF	; 255
     40e:	7f 4f       	sbci	r23, 0xFF	; 255
     410:	80 91 91 08 	lds	r24, 0x0891
     414:	90 91 92 08 	lds	r25, 0x0892
     418:	0e 94 06 0b 	call	0x160c	; 0x160c <xQueueGenericSend>
	}
}
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	0f 90       	pop	r0
     424:	0f 90       	pop	r0
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	08 95       	ret

0000042e <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     42e:	6f 92       	push	r6
     430:	7f 92       	push	r7
     432:	8f 92       	push	r8
     434:	9f 92       	push	r9
     436:	af 92       	push	r10
     438:	bf 92       	push	r11
     43a:	cf 92       	push	r12
     43c:	df 92       	push	r13
     43e:	ef 92       	push	r14
     440:	ff 92       	push	r15
     442:	0f 93       	push	r16
     444:	1f 93       	push	r17
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	1f 92       	push	r1
     44c:	cd b7       	in	r28, 0x3d	; 61
     44e:	de b7       	in	r29, 0x3e	; 62
     450:	89 83       	std	Y+1, r24	; 0x01
     452:	5b 01       	movw	r10, r22
     454:	3a 01       	movw	r6, r20
     456:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     458:	20 e0       	ldi	r18, 0x00	; 0
     45a:	4f ef       	ldi	r20, 0xFF	; 255
     45c:	5f ef       	ldi	r21, 0xFF	; 255
     45e:	be 01       	movw	r22, r28
     460:	6f 5f       	subi	r22, 0xFF	; 255
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	80 91 8f 08 	lds	r24, 0x088F
     468:	90 91 90 08 	lds	r25, 0x0890
     46c:	0e 94 06 0b 	call	0x160c	; 0x160c <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     470:	b3 01       	movw	r22, r6
     472:	f5 01       	movw	r30, r10
     474:	80 81       	ld	r24, Z
     476:	b3 df       	rcall	.-154    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     478:	b4 01       	movw	r22, r8
     47a:	f5 01       	movw	r30, r10
     47c:	81 81       	ldd	r24, Z+1	; 0x01
     47e:	af df       	rcall	.-162    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     480:	b8 01       	movw	r22, r16
     482:	f5 01       	movw	r30, r10
     484:	82 81       	ldd	r24, Z+2	; 0x02
     486:	ab df       	rcall	.-170    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     488:	b7 01       	movw	r22, r14
     48a:	f5 01       	movw	r30, r10
     48c:	83 81       	ldd	r24, Z+3	; 0x03
     48e:	a7 df       	rcall	.-178    	; 0x3de <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     490:	b6 01       	movw	r22, r12
     492:	f5 01       	movw	r30, r10
     494:	84 81       	ldd	r24, Z+4	; 0x04
     496:	a3 df       	rcall	.-186    	; 0x3de <obstacleSend>
		
	}
}
     498:	0f 90       	pop	r0
     49a:	df 91       	pop	r29
     49c:	cf 91       	pop	r28
     49e:	1f 91       	pop	r17
     4a0:	0f 91       	pop	r16
     4a2:	ff 90       	pop	r15
     4a4:	ef 90       	pop	r14
     4a6:	df 90       	pop	r13
     4a8:	cf 90       	pop	r12
     4aa:	bf 90       	pop	r11
     4ac:	af 90       	pop	r10
     4ae:	9f 90       	pop	r9
     4b0:	8f 90       	pop	r8
     4b2:	7f 90       	pop	r7
     4b4:	6f 90       	pop	r6
     4b6:	08 95       	ret

000004b8 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4b8:	cf 93       	push	r28
     4ba:	df 93       	push	r29
     4bc:	cd b7       	in	r28, 0x3d	; 61
     4be:	de b7       	in	r29, 0x3e	; 62
     4c0:	29 97       	sbiw	r28, 0x09	; 9
     4c2:	0f b6       	in	r0, 0x3f	; 63
     4c4:	f8 94       	cli
     4c6:	de bf       	out	0x3e, r29	; 62
     4c8:	0f be       	out	0x3f, r0	; 63
     4ca:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     4cc:	fe 01       	movw	r30, r28
     4ce:	33 96       	adiw	r30, 0x03	; 3
     4d0:	85 e0       	ldi	r24, 0x05	; 5
     4d2:	df 01       	movw	r26, r30
     4d4:	1d 92       	st	X+, r1
     4d6:	8a 95       	dec	r24
     4d8:	e9 f7       	brne	.-6      	; 0x4d4 <Sonar_Task+0x1c>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     4da:	84 e2       	ldi	r24, 0x24	; 36
     4dc:	d4 d2       	rcall	.+1448   	; 0xa86 <mySharpIR_Read>
     4de:	99 87       	std	Y+9, r25	; 0x09
     4e0:	88 87       	std	Y+8, r24	; 0x08
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     4e2:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xTaskGetTickCount>
     4e6:	9a 83       	std	Y+2, r25	; 0x02
     4e8:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		// why i need delay?	
		//vTaskDelay(10);
		myMaxSonar_TopStart();
     4ea:	9f d1       	rcall	.+830    	; 0x82a <myMaxSonar_TopStart>
		topSonar = myMaxSonar_Read(AN11);
     4ec:	83 e2       	ldi	r24, 0x23	; 35
     4ee:	a3 d1       	rcall	.+838    	; 0x836 <myMaxSonar_Read>
     4f0:	6c 01       	movw	r12, r24
	
		myMaxSonar_BtmStart();
     4f2:	95 d1       	rcall	.+810    	; 0x81e <myMaxSonar_BtmStart>
		
		frontSonar	= myMaxSonar_Read(AN15);
     4f4:	87 e2       	ldi	r24, 0x27	; 39
     4f6:	9f d1       	rcall	.+830    	; 0x836 <myMaxSonar_Read>
     4f8:	5c 01       	movw	r10, r24
		leftSonar	= myMaxSonar_Read(AN14);
     4fa:	86 e2       	ldi	r24, 0x26	; 38
     4fc:	9c d1       	rcall	.+824    	; 0x836 <myMaxSonar_Read>
     4fe:	4c 01       	movw	r8, r24
		rightSonar	= myMaxSonar_Read(AN13); 
     500:	85 e2       	ldi	r24, 0x25	; 37
     502:	99 d1       	rcall	.+818    	; 0x836 <myMaxSonar_Read>
     504:	3c 01       	movw	r6, r24
		btmIR		= mySharpIR_Read(AN12);	
     506:	84 e2       	ldi	r24, 0x24	; 36
     508:	be d2       	rcall	.+1404   	; 0xa86 <mySharpIR_Read>
     50a:	2c 01       	movw	r4, r24
		
	
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     50c:	bc 01       	movw	r22, r24
     50e:	ce 01       	movw	r24, r28
     510:	08 96       	adiw	r24, 0x08	; 8
     512:	f2 d2       	rcall	.+1508   	; 0xaf8 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar);
     514:	76 01       	movw	r14, r12
     516:	83 01       	movw	r16, r6
     518:	94 01       	movw	r18, r8
     51a:	ae 01       	movw	r20, r28
     51c:	4d 5f       	subi	r20, 0xFD	; 253
     51e:	5f 4f       	sbci	r21, 0xFF	; 255
     520:	60 e0       	ldi	r22, 0x00	; 0
     522:	c5 01       	movw	r24, r10
     524:	a2 d2       	rcall	.+1348   	; 0xa6a <obstacleDetection>
     526:	38 2e       	mov	r3, r24
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, calibratedBtmIR);
     528:	08 85       	ldd	r16, Y+8	; 0x08
     52a:	19 85       	ldd	r17, Y+9	; 0x09
     52c:	92 01       	movw	r18, r4
     52e:	a3 01       	movw	r20, r6
     530:	b4 01       	movw	r22, r8
     532:	c5 01       	movw	r24, r10
     534:	43 d2       	rcall	.+1158   	; 0x9bc <obstacleAvoidance>
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     536:	72 01       	movw	r14, r4
     538:	83 01       	movw	r16, r6
     53a:	94 01       	movw	r18, r8
     53c:	a5 01       	movw	r20, r10
     53e:	be 01       	movw	r22, r28
     540:	6d 5f       	subi	r22, 0xFD	; 253
     542:	7f 4f       	sbci	r23, 0xFF	; 255
     544:	83 2d       	mov	r24, r3
     546:	73 df       	rcall	.-282    	; 0x42e <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     548:	1f 82       	std	Y+7, r1	; 0x07
     54a:	1e 82       	std	Y+6, r1	; 0x06
     54c:	1d 82       	std	Y+5, r1	; 0x05
     54e:	1c 82       	std	Y+4, r1	; 0x04
     550:	1b 82       	std	Y+3, r1	; 0x03
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     552:	66 e9       	ldi	r22, 0x96	; 150
     554:	70 e0       	ldi	r23, 0x00	; 0
     556:	ce 01       	movw	r24, r28
     558:	01 96       	adiw	r24, 0x01	; 1
     55a:	0e 94 2d 10 	call	0x205a	; 0x205a <vTaskDelayUntil>
     55e:	c5 cf       	rjmp	.-118    	; 0x4ea <Sonar_Task+0x32>

00000560 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     566:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     56a:	80 91 3e 02 	lds	r24, 0x023E
     56e:	90 91 3f 02 	lds	r25, 0x023F
     572:	89 2b       	or	r24, r25
     574:	31 f4       	brne	.+12     	; 0x582 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     576:	83 e4       	ldi	r24, 0x43	; 67
     578:	92 e0       	ldi	r25, 0x02	; 2
     57a:	90 93 3f 02 	sts	0x023F, r25
     57e:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     582:	40 91 40 02 	lds	r20, 0x0240
     586:	50 91 41 02 	lds	r21, 0x0241
     58a:	9e 01       	movw	r18, r28
     58c:	24 0f       	add	r18, r20
     58e:	35 1f       	adc	r19, r21
     590:	2b 3d       	cpi	r18, 0xDB	; 219
     592:	85 e0       	ldi	r24, 0x05	; 5
     594:	38 07       	cpc	r19, r24
     596:	70 f4       	brcc	.+28     	; 0x5b4 <pvPortMalloc+0x54>
     598:	42 17       	cp	r20, r18
     59a:	53 07       	cpc	r21, r19
     59c:	70 f4       	brcc	.+28     	; 0x5ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     59e:	c0 91 3e 02 	lds	r28, 0x023E
     5a2:	d0 91 3f 02 	lds	r29, 0x023F
     5a6:	c4 0f       	add	r28, r20
     5a8:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5aa:	30 93 41 02 	sts	0x0241, r19
     5ae:	20 93 40 02 	sts	0x0240, r18
     5b2:	05 c0       	rjmp	.+10     	; 0x5be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5b4:	c0 e0       	ldi	r28, 0x00	; 0
     5b6:	d0 e0       	ldi	r29, 0x00	; 0
     5b8:	02 c0       	rjmp	.+4      	; 0x5be <pvPortMalloc+0x5e>
     5ba:	c0 e0       	ldi	r28, 0x00	; 0
     5bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5be:	0e 94 ac 0f 	call	0x1f58	; 0x1f58 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5c2:	ce 01       	movw	r24, r28
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	08 95       	ret

000005ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5ca:	08 95       	ret

000005cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ce:	03 96       	adiw	r24, 0x03	; 3
     5d0:	92 83       	std	Z+2, r25	; 0x02
     5d2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5d4:	2f ef       	ldi	r18, 0xFF	; 255
     5d6:	3f ef       	ldi	r19, 0xFF	; 255
     5d8:	34 83       	std	Z+4, r19	; 0x04
     5da:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5dc:	96 83       	std	Z+6, r25	; 0x06
     5de:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5e0:	90 87       	std	Z+8, r25	; 0x08
     5e2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5e4:	10 82       	st	Z, r1
     5e6:	08 95       	ret

000005e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5e8:	fc 01       	movw	r30, r24
     5ea:	11 86       	std	Z+9, r1	; 0x09
     5ec:	10 86       	std	Z+8, r1	; 0x08
     5ee:	08 95       	ret

000005f0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5f0:	cf 93       	push	r28
     5f2:	df 93       	push	r29
     5f4:	9c 01       	movw	r18, r24
     5f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     5f8:	dc 01       	movw	r26, r24
     5fa:	11 96       	adiw	r26, 0x01	; 1
     5fc:	cd 91       	ld	r28, X+
     5fe:	dc 91       	ld	r29, X
     600:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     602:	d3 83       	std	Z+3, r29	; 0x03
     604:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     606:	8c 81       	ldd	r24, Y+4	; 0x04
     608:	9d 81       	ldd	r25, Y+5	; 0x05
     60a:	95 83       	std	Z+5, r25	; 0x05
     60c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     60e:	8c 81       	ldd	r24, Y+4	; 0x04
     610:	9d 81       	ldd	r25, Y+5	; 0x05
     612:	dc 01       	movw	r26, r24
     614:	13 96       	adiw	r26, 0x03	; 3
     616:	7c 93       	st	X, r23
     618:	6e 93       	st	-X, r22
     61a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     61c:	7d 83       	std	Y+5, r23	; 0x05
     61e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     620:	31 87       	std	Z+9, r19	; 0x09
     622:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     624:	f9 01       	movw	r30, r18
     626:	80 81       	ld	r24, Z
     628:	8f 5f       	subi	r24, 0xFF	; 255
     62a:	80 83       	st	Z, r24
}
     62c:	df 91       	pop	r29
     62e:	cf 91       	pop	r28
     630:	08 95       	ret

00000632 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     632:	cf 93       	push	r28
     634:	df 93       	push	r29
     636:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     638:	48 81       	ld	r20, Y
     63a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     63c:	4f 3f       	cpi	r20, 0xFF	; 255
     63e:	2f ef       	ldi	r18, 0xFF	; 255
     640:	52 07       	cpc	r21, r18
     642:	21 f4       	brne	.+8      	; 0x64c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     644:	fc 01       	movw	r30, r24
     646:	a7 81       	ldd	r26, Z+7	; 0x07
     648:	b0 85       	ldd	r27, Z+8	; 0x08
     64a:	0d c0       	rjmp	.+26     	; 0x666 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     64c:	dc 01       	movw	r26, r24
     64e:	13 96       	adiw	r26, 0x03	; 3
     650:	12 96       	adiw	r26, 0x02	; 2
     652:	ed 91       	ld	r30, X+
     654:	fc 91       	ld	r31, X
     656:	13 97       	sbiw	r26, 0x03	; 3
     658:	20 81       	ld	r18, Z
     65a:	31 81       	ldd	r19, Z+1	; 0x01
     65c:	42 17       	cp	r20, r18
     65e:	53 07       	cpc	r21, r19
     660:	10 f0       	brcs	.+4      	; 0x666 <vListInsert+0x34>
     662:	df 01       	movw	r26, r30
     664:	f5 cf       	rjmp	.-22     	; 0x650 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     666:	12 96       	adiw	r26, 0x02	; 2
     668:	ed 91       	ld	r30, X+
     66a:	fc 91       	ld	r31, X
     66c:	13 97       	sbiw	r26, 0x03	; 3
     66e:	fb 83       	std	Y+3, r31	; 0x03
     670:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     672:	d5 83       	std	Z+5, r29	; 0x05
     674:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     676:	bd 83       	std	Y+5, r27	; 0x05
     678:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     67a:	13 96       	adiw	r26, 0x03	; 3
     67c:	dc 93       	st	X, r29
     67e:	ce 93       	st	-X, r28
     680:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     682:	99 87       	std	Y+9, r25	; 0x09
     684:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     686:	fc 01       	movw	r30, r24
     688:	20 81       	ld	r18, Z
     68a:	2f 5f       	subi	r18, 0xFF	; 255
     68c:	20 83       	st	Z, r18
}
     68e:	df 91       	pop	r29
     690:	cf 91       	pop	r28
     692:	08 95       	ret

00000694 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     694:	cf 93       	push	r28
     696:	df 93       	push	r29
     698:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     69a:	a0 85       	ldd	r26, Z+8	; 0x08
     69c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     69e:	c2 81       	ldd	r28, Z+2	; 0x02
     6a0:	d3 81       	ldd	r29, Z+3	; 0x03
     6a2:	84 81       	ldd	r24, Z+4	; 0x04
     6a4:	95 81       	ldd	r25, Z+5	; 0x05
     6a6:	9d 83       	std	Y+5, r25	; 0x05
     6a8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6aa:	c4 81       	ldd	r28, Z+4	; 0x04
     6ac:	d5 81       	ldd	r29, Z+5	; 0x05
     6ae:	82 81       	ldd	r24, Z+2	; 0x02
     6b0:	93 81       	ldd	r25, Z+3	; 0x03
     6b2:	9b 83       	std	Y+3, r25	; 0x03
     6b4:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6b6:	11 96       	adiw	r26, 0x01	; 1
     6b8:	cd 91       	ld	r28, X+
     6ba:	dc 91       	ld	r29, X
     6bc:	12 97       	sbiw	r26, 0x02	; 2
     6be:	ce 17       	cp	r28, r30
     6c0:	df 07       	cpc	r29, r31
     6c2:	31 f4       	brne	.+12     	; 0x6d0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6c4:	8c 81       	ldd	r24, Y+4	; 0x04
     6c6:	9d 81       	ldd	r25, Y+5	; 0x05
     6c8:	12 96       	adiw	r26, 0x02	; 2
     6ca:	9c 93       	st	X, r25
     6cc:	8e 93       	st	-X, r24
     6ce:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6d0:	11 86       	std	Z+9, r1	; 0x09
     6d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6d4:	8c 91       	ld	r24, X
     6d6:	81 50       	subi	r24, 0x01	; 1
     6d8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6da:	df 91       	pop	r29
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     6e0:	1f 92       	push	r1
     6e2:	0f 92       	push	r0
     6e4:	0f b6       	in	r0, 0x3f	; 63
     6e6:	0f 92       	push	r0
     6e8:	11 24       	eor	r1, r1
     6ea:	0b b6       	in	r0, 0x3b	; 59
     6ec:	0f 92       	push	r0
     6ee:	2f 93       	push	r18
     6f0:	3f 93       	push	r19
     6f2:	4f 93       	push	r20
     6f4:	5f 93       	push	r21
     6f6:	6f 93       	push	r22
     6f8:	7f 93       	push	r23
     6fa:	8f 93       	push	r24
     6fc:	9f 93       	push	r25
     6fe:	af 93       	push	r26
     700:	bf 93       	push	r27
     702:	ef 93       	push	r30
     704:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     706:	1b 9b       	sbis	0x03, 3	; 3
     708:	0d c0       	rjmp	.+26     	; 0x724 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     70a:	74 d2       	rcall	.+1256   	; 0xbf4 <myTimer_Read>
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	90 93 98 08 	sts	0x0898, r25
     712:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     716:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <xTaskGetTickCountFromISR>
     71a:	90 93 94 08 	sts	0x0894, r25
     71e:	80 93 93 08 	sts	0x0893, r24
     722:	55 c0       	rjmp	.+170    	; 0x7ce <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     724:	1b 99       	sbic	0x03, 3	; 3
     726:	53 c0       	rjmp	.+166    	; 0x7ce <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     728:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <xTaskGetTickCountFromISR>
     72c:	90 93 9e 08 	sts	0x089E, r25
     730:	80 93 9d 08 	sts	0x089D, r24
     734:	20 91 93 08 	lds	r18, 0x0893
     738:	30 91 94 08 	lds	r19, 0x0894
     73c:	82 17       	cp	r24, r18
     73e:	93 07       	cpc	r25, r19
     740:	4c f4       	brge	.+18     	; 0x754 <__vector_9+0x74>
			ms_tickEnd += 65535;
     742:	80 91 9d 08 	lds	r24, 0x089D
     746:	90 91 9e 08 	lds	r25, 0x089E
     74a:	01 97       	sbiw	r24, 0x01	; 1
     74c:	90 93 9e 08 	sts	0x089E, r25
     750:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     754:	4f d2       	rcall	.+1182   	; 0xbf4 <myTimer_Read>
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	90 93 a0 08 	sts	0x08A0, r25
     75c:	80 93 9f 08 	sts	0x089F, r24
     760:	20 91 97 08 	lds	r18, 0x0897
     764:	30 91 98 08 	lds	r19, 0x0898
     768:	82 17       	cp	r24, r18
     76a:	93 07       	cpc	r25, r19
     76c:	54 f4       	brge	.+20     	; 0x782 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     76e:	80 91 9f 08 	lds	r24, 0x089F
     772:	90 91 a0 08 	lds	r25, 0x08A0
     776:	86 50       	subi	r24, 0x06	; 6
     778:	9f 4f       	sbci	r25, 0xFF	; 255
     77a:	90 93 a0 08 	sts	0x08A0, r25
     77e:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     782:	80 91 9f 08 	lds	r24, 0x089F
     786:	90 91 a0 08 	lds	r25, 0x08A0
     78a:	20 91 97 08 	lds	r18, 0x0897
     78e:	30 91 98 08 	lds	r19, 0x0898
     792:	82 1b       	sub	r24, r18
     794:	93 0b       	sbc	r25, r19
     796:	90 93 9a 08 	sts	0x089A, r25
     79a:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     79e:	80 91 9d 08 	lds	r24, 0x089D
     7a2:	90 91 9e 08 	lds	r25, 0x089E
     7a6:	20 91 93 08 	lds	r18, 0x0893
     7aa:	30 91 94 08 	lds	r19, 0x0894
     7ae:	82 1b       	sub	r24, r18
     7b0:	93 0b       	sbc	r25, r19
     7b2:	90 93 96 08 	sts	0x0896, r25
     7b6:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	40 e0       	ldi	r20, 0x00	; 0
     7be:	50 e0       	ldi	r21, 0x00	; 0
     7c0:	60 e0       	ldi	r22, 0x00	; 0
     7c2:	70 e0       	ldi	r23, 0x00	; 0
     7c4:	80 91 9b 08 	lds	r24, 0x089B
     7c8:	90 91 9c 08 	lds	r25, 0x089C
     7cc:	dd d7       	rcall	.+4026   	; 0x1788 <xQueueGenericSendFromISR>
	}	
}
     7ce:	ff 91       	pop	r31
     7d0:	ef 91       	pop	r30
     7d2:	bf 91       	pop	r27
     7d4:	af 91       	pop	r26
     7d6:	9f 91       	pop	r25
     7d8:	8f 91       	pop	r24
     7da:	7f 91       	pop	r23
     7dc:	6f 91       	pop	r22
     7de:	5f 91       	pop	r21
     7e0:	4f 91       	pop	r20
     7e2:	3f 91       	pop	r19
     7e4:	2f 91       	pop	r18
     7e6:	0f 90       	pop	r0
     7e8:	0b be       	out	0x3b, r0	; 59
     7ea:	0f 90       	pop	r0
     7ec:	0f be       	out	0x3f, r0	; 63
     7ee:	0f 90       	pop	r0
     7f0:	1f 90       	pop	r1
     7f2:	18 95       	reti

000007f4 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     7f4:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     7f6:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     7f8:	e8 e6       	ldi	r30, 0x68	; 104
     7fa:	f0 e0       	ldi	r31, 0x00	; 0
     7fc:	80 81       	ld	r24, Z
     7fe:	81 60       	ori	r24, 0x01	; 1
     800:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     802:	eb e6       	ldi	r30, 0x6B	; 107
     804:	f0 e0       	ldi	r31, 0x00	; 0
     806:	80 81       	ld	r24, Z
     808:	88 60       	ori	r24, 0x08	; 8
     80a:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     80c:	43 e0       	ldi	r20, 0x03	; 3
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	cf d6       	rcall	.+3486   	; 0x15b2 <xQueueGenericCreate>
     814:	90 93 9c 08 	sts	0x089C, r25
     818:	80 93 9b 08 	sts	0x089B, r24
     81c:	08 95       	ret

0000081e <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     81e:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     820:	89 e1       	ldi	r24, 0x19	; 25
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	e9 d1       	rcall	.+978    	; 0xbf8 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     826:	a1 98       	cbi	0x14, 1	; 20
     828:	08 95       	ret

0000082a <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     82a:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     82c:	89 e1       	ldi	r24, 0x19	; 25
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	e3 d1       	rcall	.+966    	; 0xbf8 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     832:	a0 98       	cbi	0x14, 0	; 20
     834:	08 95       	ret

00000836 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     836:	ab d0       	rcall	.+342    	; 0x98e <myADC_analogRead>
     838:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     83a:	63 e0       	ldi	r22, 0x03	; 3
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	0e 94 28 16 	call	0x2c50	; 0x2c50 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     842:	cb 01       	movw	r24, r22
     844:	82 0f       	add	r24, r18
     846:	93 1f       	adc	r25, r19
     848:	08 95       	ret

0000084a <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     84a:	1f 92       	push	r1
     84c:	0f 92       	push	r0
     84e:	0f b6       	in	r0, 0x3f	; 63
     850:	0f 92       	push	r0
     852:	11 24       	eor	r1, r1
     854:	0b b6       	in	r0, 0x3b	; 59
     856:	0f 92       	push	r0
     858:	2f 93       	push	r18
     85a:	3f 93       	push	r19
     85c:	4f 93       	push	r20
     85e:	5f 93       	push	r21
     860:	6f 93       	push	r22
     862:	7f 93       	push	r23
     864:	8f 93       	push	r24
     866:	9f 93       	push	r25
     868:	af 93       	push	r26
     86a:	bf 93       	push	r27
     86c:	ef 93       	push	r30
     86e:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     870:	80 91 78 00 	lds	r24, 0x0078
     874:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     878:	80 91 79 00 	lds	r24, 0x0079
     87c:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     880:	20 e0       	ldi	r18, 0x00	; 0
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	80 91 a5 08 	lds	r24, 0x08A5
     88e:	90 91 a6 08 	lds	r25, 0x08A6
     892:	7a d7       	rcall	.+3828   	; 0x1788 <xQueueGenericSendFromISR>
}
     894:	ff 91       	pop	r31
     896:	ef 91       	pop	r30
     898:	bf 91       	pop	r27
     89a:	af 91       	pop	r26
     89c:	9f 91       	pop	r25
     89e:	8f 91       	pop	r24
     8a0:	7f 91       	pop	r23
     8a2:	6f 91       	pop	r22
     8a4:	5f 91       	pop	r21
     8a6:	4f 91       	pop	r20
     8a8:	3f 91       	pop	r19
     8aa:	2f 91       	pop	r18
     8ac:	0f 90       	pop	r0
     8ae:	0b be       	out	0x3b, r0	; 59
     8b0:	0f 90       	pop	r0
     8b2:	0f be       	out	0x3f, r0	; 63
     8b4:	0f 90       	pop	r0
     8b6:	1f 90       	pop	r1
     8b8:	18 95       	reti

000008ba <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     8ba:	8f e8       	ldi	r24, 0x8F	; 143
     8bc:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     8c0:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     8c4:	80 e4       	ldi	r24, 0x40	; 64
     8c6:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     8ca:	43 e0       	ldi	r20, 0x03	; 3
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	70 d6       	rcall	.+3296   	; 0x15b2 <xQueueGenericCreate>
     8d2:	90 93 a6 08 	sts	0x08A6, r25
     8d6:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	2a d7       	rcall	.+3668   	; 0x1732 <xQueueCreateMutex>
     8de:	90 93 a4 08 	sts	0x08A4, r25
     8e2:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	40 e0       	ldi	r20, 0x00	; 0
     8ea:	50 e0       	ldi	r21, 0x00	; 0
     8ec:	60 e0       	ldi	r22, 0x00	; 0
     8ee:	70 e0       	ldi	r23, 0x00	; 0
     8f0:	8d c6       	rjmp	.+3354   	; 0x160c <xQueueGenericSend>
     8f2:	08 95       	ret

000008f4 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     8f4:	cf 93       	push	r28
     8f6:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     8f8:	20 e0       	ldi	r18, 0x00	; 0
     8fa:	4f ef       	ldi	r20, 0xFF	; 255
     8fc:	5f ef       	ldi	r21, 0xFF	; 255
     8fe:	60 e0       	ldi	r22, 0x00	; 0
     900:	70 e0       	ldi	r23, 0x00	; 0
     902:	80 91 a3 08 	lds	r24, 0x08A3
     906:	90 91 a4 08 	lds	r25, 0x08A4
     90a:	78 d7       	rcall	.+3824   	; 0x17fc <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     90c:	ec e7       	ldi	r30, 0x7C	; 124
     90e:	f0 e0       	ldi	r31, 0x00	; 0
     910:	80 81       	ld	r24, Z
     912:	9c 2f       	mov	r25, r28
     914:	9f 71       	andi	r25, 0x1F	; 31
     916:	80 76       	andi	r24, 0x60	; 96
     918:	89 2b       	or	r24, r25
     91a:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     91c:	eb e7       	ldi	r30, 0x7B	; 123
     91e:	f0 e0       	ldi	r31, 0x00	; 0
     920:	20 81       	ld	r18, Z
     922:	c0 72       	andi	r28, 0x20	; 32
     924:	8c 2f       	mov	r24, r28
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	95 95       	asr	r25
     92a:	87 95       	ror	r24
     92c:	95 95       	asr	r25
     92e:	87 95       	ror	r24
     930:	92 2f       	mov	r25, r18
     932:	90 76       	andi	r25, 0x60	; 96
     934:	89 2b       	or	r24, r25
     936:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     938:	ea e7       	ldi	r30, 0x7A	; 122
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	80 81       	ld	r24, Z
     93e:	80 64       	ori	r24, 0x40	; 64
     940:	80 83       	st	Z, r24
}
     942:	cf 91       	pop	r28
     944:	08 95       	ret

00000946 <myADC_readADC>:

int myADC_readADC(char channel)
{
     946:	cf 93       	push	r28
     948:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     94a:	20 e0       	ldi	r18, 0x00	; 0
     94c:	4f ef       	ldi	r20, 0xFF	; 255
     94e:	5f ef       	ldi	r21, 0xFF	; 255
     950:	60 e0       	ldi	r22, 0x00	; 0
     952:	70 e0       	ldi	r23, 0x00	; 0
     954:	80 91 a5 08 	lds	r24, 0x08A5
     958:	90 91 a6 08 	lds	r25, 0x08A6
     95c:	4f d7       	rcall	.+3742   	; 0x17fc <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     95e:	c0 91 a2 08 	lds	r28, 0x08A2
     962:	c3 70       	andi	r28, 0x03	; 3
     964:	d0 e0       	ldi	r29, 0x00	; 0
     966:	dc 2f       	mov	r29, r28
     968:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     96a:	80 91 a1 08 	lds	r24, 0x08A1
     96e:	c8 0f       	add	r28, r24
     970:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     972:	20 e0       	ldi	r18, 0x00	; 0
     974:	40 e0       	ldi	r20, 0x00	; 0
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	60 e0       	ldi	r22, 0x00	; 0
     97a:	70 e0       	ldi	r23, 0x00	; 0
     97c:	80 91 a3 08 	lds	r24, 0x08A3
     980:	90 91 a4 08 	lds	r25, 0x08A4
     984:	43 d6       	rcall	.+3206   	; 0x160c <xQueueGenericSend>
	
	return adcReading;
     986:	ce 01       	movw	r24, r28
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     98e:	cf 93       	push	r28
     990:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     992:	b0 df       	rcall	.-160    	; 0x8f4 <myADC_startADC>
	return myADC_readADC(channel);
     994:	8c 2f       	mov	r24, r28
     996:	d7 df       	rcall	.-82     	; 0x946 <myADC_readADC>
}
     998:	cf 91       	pop	r28
     99a:	08 95       	ret

0000099c <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     99c:	9c 01       	movw	r18, r24
     99e:	21 5f       	subi	r18, 0xF1	; 241
     9a0:	3f 4f       	sbci	r19, 0xFF	; 255
     9a2:	26 17       	cp	r18, r22
     9a4:	37 07       	cpc	r19, r23
     9a6:	44 f0       	brlt	.+16     	; 0x9b8 <detectStairs+0x1c>
     9a8:	2e 51       	subi	r18, 0x1E	; 30
     9aa:	31 09       	sbc	r19, r1
     9ac:	81 e0       	ldi	r24, 0x01	; 1
     9ae:	62 17       	cp	r22, r18
     9b0:	73 07       	cpc	r23, r19
     9b2:	1c f0       	brlt	.+6      	; 0x9ba <detectStairs+0x1e>
     9b4:	80 e0       	ldi	r24, 0x00	; 0
     9b6:	08 95       	ret
	{
		return 1; // stairs found
     9b8:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     9ba:	08 95       	ret

000009bc <obstacleAvoidance>:

void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, int calibratedBtmIR)
{
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     9c0:	86 34       	cpi	r24, 0x46	; 70
     9c2:	91 05       	cpc	r25, r1
     9c4:	1c f5       	brge	.+70     	; 0xa0c <obstacleAvoidance+0x50>
	{
		if(leftSonar < SIDE_OBSTACLE_DISTANCE && rightSonar < SIDE_OBSTACLE_DISTANCE)
     9c6:	6e 31       	cpi	r22, 0x1E	; 30
     9c8:	71 05       	cpc	r23, r1
     9ca:	54 f4       	brge	.+20     	; 0x9e0 <obstacleAvoidance+0x24>
     9cc:	4e 31       	cpi	r20, 0x1E	; 30
     9ce:	51 05       	cpc	r21, r1
     9d0:	3c f4       	brge	.+14     	; 0x9e0 <obstacleAvoidance+0x24>
		{
			// dead end... block on 3 side...
			MOTOR_LEFT_START();
     9d2:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     9d4:	e2 e0       	ldi	r30, 0x02	; 2
     9d6:	f1 e0       	ldi	r31, 0x01	; 1
     9d8:	80 81       	ld	r24, Z
     9da:	80 61       	ori	r24, 0x10	; 16
     9dc:	80 83       	st	Z, r24
     9de:	42 c0       	rjmp	.+132    	; 0xa64 <obstacleAvoidance+0xa8>
		}
		else if( (leftSonar+10) > rightSonar)
     9e0:	66 5f       	subi	r22, 0xF6	; 246
     9e2:	7f 4f       	sbci	r23, 0xFF	; 255
     9e4:	46 17       	cp	r20, r22
     9e6:	57 07       	cpc	r21, r23
     9e8:	3c f4       	brge	.+14     	; 0x9f8 <obstacleAvoidance+0x3c>
		{
			MOTOR_RIGHT_STOP();
     9ea:	e2 e0       	ldi	r30, 0x02	; 2
     9ec:	f1 e0       	ldi	r31, 0x01	; 1
     9ee:	80 81       	ld	r24, Z
     9f0:	8f 7e       	andi	r24, 0xEF	; 239
     9f2:	80 83       	st	Z, r24
			MOTOR_LEFT_START();
     9f4:	74 9a       	sbi	0x0e, 4	; 14
     9f6:	36 c0       	rjmp	.+108    	; 0xa64 <obstacleAvoidance+0xa8>
		}
		else if (rightSonar > (leftSonar+10))
     9f8:	64 17       	cp	r22, r20
     9fa:	75 07       	cpc	r23, r21
     9fc:	9c f5       	brge	.+102    	; 0xa64 <obstacleAvoidance+0xa8>
		{
			MOTOR_LEFT_STOP();
     9fe:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     a00:	e2 e0       	ldi	r30, 0x02	; 2
     a02:	f1 e0       	ldi	r31, 0x01	; 1
     a04:	80 81       	ld	r24, Z
     a06:	80 61       	ori	r24, 0x10	; 16
     a08:	80 83       	st	Z, r24
     a0a:	2c c0       	rjmp	.+88     	; 0xa64 <obstacleAvoidance+0xa8>
		}
		
	}
	else if (rightSonar < SIDE_OBSTACLE_DISTANCE && leftSonar > SIDE_OBSTACLE_DISTANCE)
     a0c:	4e 31       	cpi	r20, 0x1E	; 30
     a0e:	51 05       	cpc	r21, r1
     a10:	54 f4       	brge	.+20     	; 0xa26 <obstacleAvoidance+0x6a>
     a12:	6f 31       	cpi	r22, 0x1F	; 31
     a14:	71 05       	cpc	r23, r1
     a16:	3c f0       	brlt	.+14     	; 0xa26 <obstacleAvoidance+0x6a>
	{
		// too close to right
		MOTOR_RIGHT_STOP();
     a18:	e2 e0       	ldi	r30, 0x02	; 2
     a1a:	f1 e0       	ldi	r31, 0x01	; 1
     a1c:	80 81       	ld	r24, Z
     a1e:	8f 7e       	andi	r24, 0xEF	; 239
     a20:	80 83       	st	Z, r24
		MOTOR_LEFT_START();
     a22:	74 9a       	sbi	0x0e, 4	; 14
     a24:	1f c0       	rjmp	.+62     	; 0xa64 <obstacleAvoidance+0xa8>
	}
	else if (leftSonar < SIDE_OBSTACLE_DISTANCE && rightSonar > SIDE_OBSTACLE_DISTANCE)
     a26:	6e 31       	cpi	r22, 0x1E	; 30
     a28:	71 05       	cpc	r23, r1
     a2a:	54 f4       	brge	.+20     	; 0xa40 <obstacleAvoidance+0x84>
     a2c:	4f 31       	cpi	r20, 0x1F	; 31
     a2e:	51 05       	cpc	r21, r1
     a30:	3c f0       	brlt	.+14     	; 0xa40 <obstacleAvoidance+0x84>
	{
		// too close to left
		MOTOR_RIGHT_START();
     a32:	e2 e0       	ldi	r30, 0x02	; 2
     a34:	f1 e0       	ldi	r31, 0x01	; 1
     a36:	80 81       	ld	r24, Z
     a38:	80 61       	ori	r24, 0x10	; 16
     a3a:	80 83       	st	Z, r24
		MOTOR_LEFT_STOP();
     a3c:	74 98       	cbi	0x0e, 4	; 14
     a3e:	12 c0       	rjmp	.+36     	; 0xa64 <obstacleAvoidance+0xa8>
	}
	else if (detectStairs(calibratedBtmIR, btmIR))
     a40:	b9 01       	movw	r22, r18
     a42:	c8 01       	movw	r24, r16
     a44:	ab df       	rcall	.-170    	; 0x99c <detectStairs>
     a46:	88 23       	and	r24, r24
     a48:	39 f0       	breq	.+14     	; 0xa58 <obstacleAvoidance+0x9c>
	{
		// stairs detection
		MOTOR_LEFT_START();
     a4a:	74 9a       	sbi	0x0e, 4	; 14
		MOTOR_RIGHT_START();
     a4c:	e2 e0       	ldi	r30, 0x02	; 2
     a4e:	f1 e0       	ldi	r31, 0x01	; 1
     a50:	80 81       	ld	r24, Z
     a52:	80 61       	ori	r24, 0x10	; 16
     a54:	80 83       	st	Z, r24
     a56:	06 c0       	rjmp	.+12     	; 0xa64 <obstacleAvoidance+0xa8>
	}
	else
	{
		// narrow path or no obstacle infront.
		MOTOR_RIGHT_STOP();
     a58:	e2 e0       	ldi	r30, 0x02	; 2
     a5a:	f1 e0       	ldi	r31, 0x01	; 1
     a5c:	80 81       	ld	r24, Z
     a5e:	8f 7e       	andi	r24, 0xEF	; 239
     a60:	80 83       	st	Z, r24
		MOTOR_LEFT_STOP();
     a62:	74 98       	cbi	0x0e, 4	; 14
	}
}
     a64:	1f 91       	pop	r17
     a66:	0f 91       	pop	r16
     a68:	08 95       	ret

00000a6a <obstacleDetection>:

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar)
{
     a6a:	fa 01       	movw	r30, r20
	// Commented out when debuggin.

	//	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     a6c:	86 e4       	ldi	r24, 0x46	; 70
     a6e:	80 83       	st	Z, r24
	}
	//	if (leftSonar < SIDE_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     a70:	8c e4       	ldi	r24, 0x4C	; 76
     a72:	81 83       	std	Z+1, r24	; 0x01
	}
	//	if (rightSonar < SIDE_OBSTACLE_DISTANCE)
	{
		obstacleDetected++;
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     a74:	82 e5       	ldi	r24, 0x52	; 82
     a76:	82 83       	std	Z+2, r24	; 0x02
	}
	//	if (detectStairs(calibratedBtmIR, btmIR))
	{
		obstacleDetected++;
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     a78:	82 e4       	ldi	r24, 0x42	; 66
     a7a:	83 83       	std	Z+3, r24	; 0x03
	}
	// if (...)
	{
		
		obstacleDetected++;
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     a7c:	84 e5       	ldi	r24, 0x54	; 84
     a7e:	84 83       	std	Z+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     a80:	85 e0       	ldi	r24, 0x05	; 5
     a82:	86 0f       	add	r24, r22
     a84:	08 95       	ret

00000a86 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     a86:	83 df       	rcall	.-250    	; 0x98e <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     a88:	bc 01       	movw	r22, r24
     a8a:	88 27       	eor	r24, r24
     a8c:	77 fd       	sbrc	r23, 7
     a8e:	80 95       	com	r24
     a90:	98 2f       	mov	r25, r24
     a92:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <__floatsisf>
     a96:	29 e2       	ldi	r18, 0x29	; 41
     a98:	3c e5       	ldi	r19, 0x5C	; 92
     a9a:	4f e6       	ldi	r20, 0x6F	; 111
     a9c:	5f eb       	ldi	r21, 0xBF	; 191
     a9e:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <pow>
     aa2:	22 e5       	ldi	r18, 0x52	; 82
     aa4:	38 e6       	ldi	r19, 0x68	; 104
     aa6:	46 e2       	ldi	r20, 0x26	; 38
     aa8:	56 e4       	ldi	r21, 0x46	; 70
     aaa:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <__mulsf3>
     aae:	20 e0       	ldi	r18, 0x00	; 0
     ab0:	30 e0       	ldi	r19, 0x00	; 0
     ab2:	40 e2       	ldi	r20, 0x20	; 32
     ab4:	51 e4       	ldi	r21, 0x41	; 65
     ab6:	0e 94 d4 12 	call	0x25a8	; 0x25a8 <__subsf3>
     aba:	0e 94 39 13 	call	0x2672	; 0x2672 <__fixsfsi>
     abe:	cb 01       	movw	r24, r22
     ac0:	68 3e       	cpi	r22, 0xE8	; 232
     ac2:	23 e0       	ldi	r18, 0x03	; 3
     ac4:	72 07       	cpc	r23, r18
     ac6:	14 f0       	brlt	.+4      	; 0xacc <mySharpIR_Read+0x46>
     ac8:	87 ee       	ldi	r24, 0xE7	; 231
     aca:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
}
     acc:	08 95       	ret

00000ace <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     ace:	fb 01       	movw	r30, r22
     ad0:	20 81       	ld	r18, Z
     ad2:	31 81       	ldd	r19, Z+1	; 0x01
     ad4:	50 e0       	ldi	r21, 0x00	; 0
     ad6:	b9 01       	movw	r22, r18
     ad8:	64 0f       	add	r22, r20
     ada:	75 1f       	adc	r23, r21
     adc:	68 17       	cp	r22, r24
     ade:	79 07       	cpc	r23, r25
     ae0:	4c f0       	brlt	.+18     	; 0xaf4 <checkWithinRange+0x26>
     ae2:	24 1b       	sub	r18, r20
     ae4:	35 0b       	sbc	r19, r21
     ae6:	41 e0       	ldi	r20, 0x01	; 1
     ae8:	82 17       	cp	r24, r18
     aea:	93 07       	cpc	r25, r19
     aec:	0c f0       	brlt	.+2      	; 0xaf0 <checkWithinRange+0x22>
     aee:	40 e0       	ldi	r20, 0x00	; 0
     af0:	84 2f       	mov	r24, r20
     af2:	08 95       	ret
     af4:	81 e0       	ldi	r24, 0x01	; 1
}
     af6:	08 95       	ret

00000af8 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     af8:	0f 93       	push	r16
     afa:	1f 93       	push	r17
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
     b00:	8c 01       	movw	r16, r24
     b02:	eb 01       	movw	r28, r22
	static const char range = 5; // put at header file later...
	static const char CALIBRATE_COUNT = 20; // put at header file later...
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, range) && i == 0)
     b04:	45 e0       	ldi	r20, 0x05	; 5
     b06:	bc 01       	movw	r22, r24
     b08:	ce 01       	movw	r24, r28
     b0a:	e1 df       	rcall	.-62     	; 0xace <checkWithinRange>
     b0c:	88 23       	and	r24, r24
     b0e:	41 f0       	breq	.+16     	; 0xb20 <mySharpIR_ReCalibrate+0x28>
     b10:	20 91 22 08 	lds	r18, 0x0822
     b14:	30 91 23 08 	lds	r19, 0x0823
     b18:	21 15       	cp	r18, r1
     b1a:	31 05       	cpc	r19, r1
     b1c:	69 f4       	brne	.+26     	; 0xb38 <mySharpIR_ReCalibrate+0x40>
     b1e:	4b c0       	rjmp	.+150    	; 0xbb6 <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     b20:	20 91 22 08 	lds	r18, 0x0822
     b24:	30 91 23 08 	lds	r19, 0x0823
     b28:	21 15       	cp	r18, r1
     b2a:	31 05       	cpc	r19, r1
     b2c:	29 f4       	brne	.+10     	; 0xb38 <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     b2e:	d0 93 1f 08 	sts	0x081F, r29
     b32:	c0 93 1e 08 	sts	0x081E, r28
     b36:	32 c0       	rjmp	.+100    	; 0xb9c <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     b38:	2a 30       	cpi	r18, 0x0A	; 10
     b3a:	31 05       	cpc	r19, r1
     b3c:	a9 f4       	brne	.+42     	; 0xb68 <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, range))
     b3e:	45 e0       	ldi	r20, 0x05	; 5
     b40:	6e e1       	ldi	r22, 0x1E	; 30
     b42:	78 e0       	ldi	r23, 0x08	; 8
     b44:	ce 01       	movw	r24, r28
     b46:	c3 df       	rcall	.-122    	; 0xace <checkWithinRange>
     b48:	88 23       	and	r24, r24
     b4a:	49 f0       	breq	.+18     	; 0xb5e <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     b4c:	d0 93 1f 08 	sts	0x081F, r29
     b50:	c0 93 1e 08 	sts	0x081E, r28
			i = 0; // reset to count...
     b54:	10 92 23 08 	sts	0x0823, r1
     b58:	10 92 22 08 	sts	0x0822, r1
     b5c:	1f c0       	rjmp	.+62     	; 0xb9c <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     b5e:	d0 93 21 08 	sts	0x0821, r29
     b62:	c0 93 20 08 	sts	0x0820, r28
     b66:	1a c0       	rjmp	.+52     	; 0xb9c <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     b68:	24 31       	cpi	r18, 0x14	; 20
     b6a:	31 05       	cpc	r19, r1
     b6c:	b9 f4       	brne	.+46     	; 0xb9c <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     b6e:	10 92 23 08 	sts	0x0823, r1
     b72:	10 92 22 08 	sts	0x0822, r1

		if(checkWithinRange(reading, checkReading, range))
     b76:	45 e0       	ldi	r20, 0x05	; 5
     b78:	6e e1       	ldi	r22, 0x1E	; 30
     b7a:	78 e0       	ldi	r23, 0x08	; 8
     b7c:	ce 01       	movw	r24, r28
     b7e:	a7 df       	rcall	.-178    	; 0xace <checkWithinRange>
     b80:	88 23       	and	r24, r24
     b82:	29 f0       	breq	.+10     	; 0xb8e <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     b84:	d0 93 1f 08 	sts	0x081F, r29
     b88:	c0 93 1e 08 	sts	0x081E, r28
     b8c:	07 c0       	rjmp	.+14     	; 0xb9c <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     b8e:	80 91 1e 08 	lds	r24, 0x081E
     b92:	90 91 1f 08 	lds	r25, 0x081F
     b96:	f8 01       	movw	r30, r16
     b98:	91 83       	std	Z+1, r25	; 0x01
     b9a:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     b9c:	80 91 22 08 	lds	r24, 0x0822
     ba0:	90 91 23 08 	lds	r25, 0x0823
     ba4:	01 96       	adiw	r24, 0x01	; 1
     ba6:	64 e1       	ldi	r22, 0x14	; 20
     ba8:	70 e0       	ldi	r23, 0x00	; 0
     baa:	0e 94 28 16 	call	0x2c50	; 0x2c50 <__divmodhi4>
     bae:	90 93 23 08 	sts	0x0823, r25
     bb2:	80 93 22 08 	sts	0x0822, r24
}
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	1f 91       	pop	r17
     bbc:	0f 91       	pop	r16
     bbe:	08 95       	ret

00000bc0 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     bc0:	90 93 ac 08 	sts	0x08AC, r25
     bc4:	80 93 ab 08 	sts	0x08AB, r24
     bc8:	fc 01       	movw	r30, r24
     bca:	80 81       	ld	r24, Z
     bcc:	91 81       	ldd	r25, Z+1	; 0x01
     bce:	0e 94 1e 11 	call	0x223c	; 0x223c <vTaskSuspend>
     bd2:	43 e0       	ldi	r20, 0x03	; 3
     bd4:	60 e0       	ldi	r22, 0x00	; 0
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	ec d4       	rcall	.+2520   	; 0x15b2 <xQueueGenericCreate>
     bda:	90 93 a8 08 	sts	0x08A8, r25
     bde:	80 93 a7 08 	sts	0x08A7, r24
     be2:	43 e0       	ldi	r20, 0x03	; 3
     be4:	60 e0       	ldi	r22, 0x00	; 0
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	e4 d4       	rcall	.+2504   	; 0x15b2 <xQueueGenericCreate>
     bea:	90 93 aa 08 	sts	0x08AA, r25
     bee:	80 93 a9 08 	sts	0x08A9, r24
     bf2:	08 95       	ret

00000bf4 <myTimer_Read>:
     bf4:	86 b5       	in	r24, 0x26	; 38
     bf6:	08 95       	ret

00000bf8 <myTimer_DelayMicro>:
     bf8:	46 b5       	in	r20, 0x26	; 38
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	9c 01       	movw	r18, r24
     bfe:	99 23       	and	r25, r25
     c00:	14 f4       	brge	.+4      	; 0xc06 <myTimer_DelayMicro+0xe>
     c02:	2d 5f       	subi	r18, 0xFD	; 253
     c04:	3f 4f       	sbci	r19, 0xFF	; 255
     c06:	35 95       	asr	r19
     c08:	27 95       	ror	r18
     c0a:	35 95       	asr	r19
     c0c:	27 95       	ror	r18
     c0e:	24 0f       	add	r18, r20
     c10:	35 1f       	adc	r19, r21
     c12:	30 93 03 02 	sts	0x0203, r19
     c16:	20 93 02 02 	sts	0x0202, r18
     c1a:	e0 91 ab 08 	lds	r30, 0x08AB
     c1e:	f0 91 ac 08 	lds	r31, 0x08AC
     c22:	80 81       	ld	r24, Z
     c24:	91 81       	ldd	r25, Z+1	; 0x01
     c26:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vTaskResume>
     c2a:	20 e0       	ldi	r18, 0x00	; 0
     c2c:	42 e0       	ldi	r20, 0x02	; 2
     c2e:	50 e0       	ldi	r21, 0x00	; 0
     c30:	60 e0       	ldi	r22, 0x00	; 0
     c32:	70 e0       	ldi	r23, 0x00	; 0
     c34:	80 91 a7 08 	lds	r24, 0x08A7
     c38:	90 91 a8 08 	lds	r25, 0x08A8
     c3c:	df c5       	rjmp	.+3006   	; 0x17fc <xQueueGenericReceive>
     c3e:	08 95       	ret

00000c40 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     c44:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     c46:	c1 11       	cpse	r28, r1
     c48:	22 c0       	rjmp	.+68     	; 0xc8e <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     c4a:	80 91 02 02 	lds	r24, 0x0202
     c4e:	90 91 03 02 	lds	r25, 0x0203
     c52:	88 38       	cpi	r24, 0x88	; 136
     c54:	93 41       	sbci	r25, 0x13	; 19
     c56:	51 f0       	breq	.+20     	; 0xc6c <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     c58:	80 91 02 02 	lds	r24, 0x0202
     c5c:	90 91 03 02 	lds	r25, 0x0203
     c60:	8a 5f       	subi	r24, 0xFA	; 250
     c62:	91 09       	sbc	r25, r1
     c64:	90 93 03 02 	sts	0x0203, r25
     c68:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     c6c:	80 91 00 02 	lds	r24, 0x0200
     c70:	90 91 01 02 	lds	r25, 0x0201
     c74:	88 38       	cpi	r24, 0x88	; 136
     c76:	93 41       	sbci	r25, 0x13	; 19
     c78:	51 f0       	breq	.+20     	; 0xc8e <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     c7a:	80 91 00 02 	lds	r24, 0x0200
     c7e:	90 91 01 02 	lds	r25, 0x0201
     c82:	8a 5f       	subi	r24, 0xFA	; 250
     c84:	91 09       	sbc	r25, r1
     c86:	90 93 01 02 	sts	0x0201, r25
     c8a:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     c8e:	d0 e0       	ldi	r29, 0x00	; 0
     c90:	80 91 02 02 	lds	r24, 0x0202
     c94:	90 91 03 02 	lds	r25, 0x0203
     c98:	8c 17       	cp	r24, r28
     c9a:	9d 07       	cpc	r25, r29
     c9c:	84 f4       	brge	.+32     	; 0xcbe <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     c9e:	88 e8       	ldi	r24, 0x88	; 136
     ca0:	93 e1       	ldi	r25, 0x13	; 19
     ca2:	90 93 03 02 	sts	0x0203, r25
     ca6:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	40 e0       	ldi	r20, 0x00	; 0
     cae:	50 e0       	ldi	r21, 0x00	; 0
     cb0:	60 e0       	ldi	r22, 0x00	; 0
     cb2:	70 e0       	ldi	r23, 0x00	; 0
     cb4:	80 91 a7 08 	lds	r24, 0x08A7
     cb8:	90 91 a8 08 	lds	r25, 0x08A8
     cbc:	a7 d4       	rcall	.+2382   	; 0x160c <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     cbe:	80 91 00 02 	lds	r24, 0x0200
     cc2:	90 91 01 02 	lds	r25, 0x0201
     cc6:	8c 17       	cp	r24, r28
     cc8:	9d 07       	cpc	r25, r29
     cca:	84 f4       	brge	.+32     	; 0xcec <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     ccc:	88 e8       	ldi	r24, 0x88	; 136
     cce:	93 e1       	ldi	r25, 0x13	; 19
     cd0:	90 93 01 02 	sts	0x0201, r25
     cd4:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	40 e0       	ldi	r20, 0x00	; 0
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	60 e0       	ldi	r22, 0x00	; 0
     ce0:	70 e0       	ldi	r23, 0x00	; 0
     ce2:	80 91 a9 08 	lds	r24, 0x08A9
     ce6:	90 91 aa 08 	lds	r25, 0x08AA
     cea:	90 d4       	rcall	.+2336   	; 0x160c <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     cec:	80 91 02 02 	lds	r24, 0x0202
     cf0:	90 91 03 02 	lds	r25, 0x0203
     cf4:	88 38       	cpi	r24, 0x88	; 136
     cf6:	93 41       	sbci	r25, 0x13	; 19
     cf8:	79 f4       	brne	.+30     	; 0xd18 <myTimer_DelayChecker+0xd8>
     cfa:	80 91 00 02 	lds	r24, 0x0200
     cfe:	90 91 01 02 	lds	r25, 0x0201
     d02:	88 38       	cpi	r24, 0x88	; 136
     d04:	93 41       	sbci	r25, 0x13	; 19
     d06:	41 f4       	brne	.+16     	; 0xd18 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     d08:	e0 91 ab 08 	lds	r30, 0x08AB
     d0c:	f0 91 ac 08 	lds	r31, 0x08AC
     d10:	80 81       	ld	r24, Z
     d12:	91 81       	ldd	r25, Z+1	; 0x01
     d14:	0e 94 1e 11 	call	0x223c	; 0x223c <vTaskSuspend>
	}
     d18:	df 91       	pop	r29
     d1a:	cf 91       	pop	r28
     d1c:	08 95       	ret

00000d1e <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     d1e:	1f 92       	push	r1
     d20:	0f 92       	push	r0
     d22:	0f b6       	in	r0, 0x3f	; 63
     d24:	0f 92       	push	r0
     d26:	11 24       	eor	r1, r1
     d28:	0b b6       	in	r0, 0x3b	; 59
     d2a:	0f 92       	push	r0
     d2c:	2f 93       	push	r18
     d2e:	3f 93       	push	r19
     d30:	4f 93       	push	r20
     d32:	5f 93       	push	r21
     d34:	6f 93       	push	r22
     d36:	7f 93       	push	r23
     d38:	8f 93       	push	r24
     d3a:	9f 93       	push	r25
     d3c:	af 93       	push	r26
     d3e:	bf 93       	push	r27
     d40:	ef 93       	push	r30
     d42:	ff 93       	push	r31
     d44:	60 91 ce 00 	lds	r22, 0x00CE
     d48:	82 e4       	ldi	r24, 0x42	; 66
     d4a:	99 e0       	ldi	r25, 0x09	; 9
     d4c:	2d d6       	rcall	.+3162   	; 0x19a8 <ringBufferPush>
     d4e:	20 e0       	ldi	r18, 0x00	; 0
     d50:	40 e0       	ldi	r20, 0x00	; 0
     d52:	50 e0       	ldi	r21, 0x00	; 0
     d54:	60 e0       	ldi	r22, 0x00	; 0
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	80 91 36 09 	lds	r24, 0x0936
     d5c:	90 91 37 09 	lds	r25, 0x0937
     d60:	13 d5       	rcall	.+2598   	; 0x1788 <xQueueGenericSendFromISR>
     d62:	82 e4       	ldi	r24, 0x42	; 66
     d64:	99 e0       	ldi	r25, 0x09	; 9
     d66:	37 d6       	rcall	.+3182   	; 0x19d6 <ringBufferFull>
     d68:	ff 91       	pop	r31
     d6a:	ef 91       	pop	r30
     d6c:	bf 91       	pop	r27
     d6e:	af 91       	pop	r26
     d70:	9f 91       	pop	r25
     d72:	8f 91       	pop	r24
     d74:	7f 91       	pop	r23
     d76:	6f 91       	pop	r22
     d78:	5f 91       	pop	r21
     d7a:	4f 91       	pop	r20
     d7c:	3f 91       	pop	r19
     d7e:	2f 91       	pop	r18
     d80:	0f 90       	pop	r0
     d82:	0b be       	out	0x3b, r0	; 59
     d84:	0f 90       	pop	r0
     d86:	0f be       	out	0x3f, r0	; 63
     d88:	0f 90       	pop	r0
     d8a:	1f 90       	pop	r1
     d8c:	18 95       	reti

00000d8e <__vector_25>:
     d8e:	1f 92       	push	r1
     d90:	0f 92       	push	r0
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	0f 92       	push	r0
     d96:	11 24       	eor	r1, r1
     d98:	0b b6       	in	r0, 0x3b	; 59
     d9a:	0f 92       	push	r0
     d9c:	2f 93       	push	r18
     d9e:	3f 93       	push	r19
     da0:	4f 93       	push	r20
     da2:	5f 93       	push	r21
     da4:	6f 93       	push	r22
     da6:	7f 93       	push	r23
     da8:	8f 93       	push	r24
     daa:	9f 93       	push	r25
     dac:	af 93       	push	r26
     dae:	bf 93       	push	r27
     db0:	ef 93       	push	r30
     db2:	ff 93       	push	r31
     db4:	60 91 c6 00 	lds	r22, 0x00C6
     db8:	8d ec       	ldi	r24, 0xCD	; 205
     dba:	98 e0       	ldi	r25, 0x08	; 8
     dbc:	f5 d5       	rcall	.+3050   	; 0x19a8 <ringBufferPush>
     dbe:	20 e0       	ldi	r18, 0x00	; 0
     dc0:	40 e0       	ldi	r20, 0x00	; 0
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	60 e0       	ldi	r22, 0x00	; 0
     dc6:	70 e0       	ldi	r23, 0x00	; 0
     dc8:	80 91 36 09 	lds	r24, 0x0936
     dcc:	90 91 37 09 	lds	r25, 0x0937
     dd0:	db d4       	rcall	.+2486   	; 0x1788 <xQueueGenericSendFromISR>
     dd2:	8d ec       	ldi	r24, 0xCD	; 205
     dd4:	98 e0       	ldi	r25, 0x08	; 8
     dd6:	ff d5       	rcall	.+3070   	; 0x19d6 <ringBufferFull>
     dd8:	ff 91       	pop	r31
     dda:	ef 91       	pop	r30
     ddc:	bf 91       	pop	r27
     dde:	af 91       	pop	r26
     de0:	9f 91       	pop	r25
     de2:	8f 91       	pop	r24
     de4:	7f 91       	pop	r23
     de6:	6f 91       	pop	r22
     de8:	5f 91       	pop	r21
     dea:	4f 91       	pop	r20
     dec:	3f 91       	pop	r19
     dee:	2f 91       	pop	r18
     df0:	0f 90       	pop	r0
     df2:	0b be       	out	0x3b, r0	; 59
     df4:	0f 90       	pop	r0
     df6:	0f be       	out	0x3f, r0	; 63
     df8:	0f 90       	pop	r0
     dfa:	1f 90       	pop	r1
     dfc:	18 95       	reti

00000dfe <__vector_37>:
     dfe:	1f 92       	push	r1
     e00:	0f 92       	push	r0
     e02:	0f b6       	in	r0, 0x3f	; 63
     e04:	0f 92       	push	r0
     e06:	11 24       	eor	r1, r1
     e08:	0b b6       	in	r0, 0x3b	; 59
     e0a:	0f 92       	push	r0
     e0c:	2f 93       	push	r18
     e0e:	3f 93       	push	r19
     e10:	4f 93       	push	r20
     e12:	5f 93       	push	r21
     e14:	6f 93       	push	r22
     e16:	7f 93       	push	r23
     e18:	8f 93       	push	r24
     e1a:	9f 93       	push	r25
     e1c:	af 93       	push	r26
     e1e:	bf 93       	push	r27
     e20:	ef 93       	push	r30
     e22:	ff 93       	push	r31
     e24:	88 e3       	ldi	r24, 0x38	; 56
     e26:	99 e0       	ldi	r25, 0x09	; 9
     e28:	dd d5       	rcall	.+3002   	; 0x19e4 <ringBufferNotEmpty>
     e2a:	88 23       	and	r24, r24
     e2c:	31 f0       	breq	.+12     	; 0xe3a <__vector_37+0x3c>
     e2e:	88 e3       	ldi	r24, 0x38	; 56
     e30:	99 e0       	ldi	r25, 0x09	; 9
     e32:	a8 d5       	rcall	.+2896   	; 0x1984 <ringBufferPop>
     e34:	80 93 ce 00 	sts	0x00CE, r24
     e38:	05 c0       	rjmp	.+10     	; 0xe44 <__vector_37+0x46>
     e3a:	e9 ec       	ldi	r30, 0xC9	; 201
     e3c:	f0 e0       	ldi	r31, 0x00	; 0
     e3e:	80 81       	ld	r24, Z
     e40:	8f 7d       	andi	r24, 0xDF	; 223
     e42:	80 83       	st	Z, r24
     e44:	ff 91       	pop	r31
     e46:	ef 91       	pop	r30
     e48:	bf 91       	pop	r27
     e4a:	af 91       	pop	r26
     e4c:	9f 91       	pop	r25
     e4e:	8f 91       	pop	r24
     e50:	7f 91       	pop	r23
     e52:	6f 91       	pop	r22
     e54:	5f 91       	pop	r21
     e56:	4f 91       	pop	r20
     e58:	3f 91       	pop	r19
     e5a:	2f 91       	pop	r18
     e5c:	0f 90       	pop	r0
     e5e:	0b be       	out	0x3b, r0	; 59
     e60:	0f 90       	pop	r0
     e62:	0f be       	out	0x3f, r0	; 63
     e64:	0f 90       	pop	r0
     e66:	1f 90       	pop	r1
     e68:	18 95       	reti

00000e6a <__vector_26>:
     e6a:	1f 92       	push	r1
     e6c:	0f 92       	push	r0
     e6e:	0f b6       	in	r0, 0x3f	; 63
     e70:	0f 92       	push	r0
     e72:	11 24       	eor	r1, r1
     e74:	0b b6       	in	r0, 0x3b	; 59
     e76:	0f 92       	push	r0
     e78:	2f 93       	push	r18
     e7a:	3f 93       	push	r19
     e7c:	4f 93       	push	r20
     e7e:	5f 93       	push	r21
     e80:	6f 93       	push	r22
     e82:	7f 93       	push	r23
     e84:	8f 93       	push	r24
     e86:	9f 93       	push	r25
     e88:	af 93       	push	r26
     e8a:	bf 93       	push	r27
     e8c:	ef 93       	push	r30
     e8e:	ff 93       	push	r31
     e90:	8d e3       	ldi	r24, 0x3D	; 61
     e92:	99 e0       	ldi	r25, 0x09	; 9
     e94:	a7 d5       	rcall	.+2894   	; 0x19e4 <ringBufferNotEmpty>
     e96:	88 23       	and	r24, r24
     e98:	31 f0       	breq	.+12     	; 0xea6 <__vector_26+0x3c>
     e9a:	8d e3       	ldi	r24, 0x3D	; 61
     e9c:	99 e0       	ldi	r25, 0x09	; 9
     e9e:	72 d5       	rcall	.+2788   	; 0x1984 <ringBufferPop>
     ea0:	80 93 c6 00 	sts	0x00C6, r24
     ea4:	05 c0       	rjmp	.+10     	; 0xeb0 <__vector_26+0x46>
     ea6:	e1 ec       	ldi	r30, 0xC1	; 193
     ea8:	f0 e0       	ldi	r31, 0x00	; 0
     eaa:	80 81       	ld	r24, Z
     eac:	8f 7d       	andi	r24, 0xDF	; 223
     eae:	80 83       	st	Z, r24
     eb0:	ff 91       	pop	r31
     eb2:	ef 91       	pop	r30
     eb4:	bf 91       	pop	r27
     eb6:	af 91       	pop	r26
     eb8:	9f 91       	pop	r25
     eba:	8f 91       	pop	r24
     ebc:	7f 91       	pop	r23
     ebe:	6f 91       	pop	r22
     ec0:	5f 91       	pop	r21
     ec2:	4f 91       	pop	r20
     ec4:	3f 91       	pop	r19
     ec6:	2f 91       	pop	r18
     ec8:	0f 90       	pop	r0
     eca:	0b be       	out	0x3b, r0	; 59
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63
     ed0:	0f 90       	pop	r0
     ed2:	1f 90       	pop	r1
     ed4:	18 95       	reti

00000ed6 <myUSART_USART0_Init>:
     ed6:	10 92 c5 00 	sts	0x00C5, r1
     eda:	87 e6       	ldi	r24, 0x67	; 103
     edc:	80 93 c4 00 	sts	0x00C4, r24
     ee0:	88 eb       	ldi	r24, 0xB8	; 184
     ee2:	80 93 c1 00 	sts	0x00C1, r24
     ee6:	86 e0       	ldi	r24, 0x06	; 6
     ee8:	80 93 c2 00 	sts	0x00C2, r24
     eec:	40 e2       	ldi	r20, 0x20	; 32
     eee:	64 ef       	ldi	r22, 0xF4	; 244
     ef0:	78 e0       	ldi	r23, 0x08	; 8
     ef2:	8d ec       	ldi	r24, 0xCD	; 205
     ef4:	98 e0       	ldi	r25, 0x08	; 8
     ef6:	35 d5       	rcall	.+2666   	; 0x1962 <ringBufferInit>
     ef8:	40 e2       	ldi	r20, 0x20	; 32
     efa:	62 ed       	ldi	r22, 0xD2	; 210
     efc:	78 e0       	ldi	r23, 0x08	; 8
     efe:	8d e3       	ldi	r24, 0x3D	; 61
     f00:	99 e0       	ldi	r25, 0x09	; 9
     f02:	2f d5       	rcall	.+2654   	; 0x1962 <ringBufferInit>
     f04:	43 e0       	ldi	r20, 0x03	; 3
     f06:	60 e0       	ldi	r22, 0x00	; 0
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	53 d3       	rcall	.+1702   	; 0x15b2 <xQueueGenericCreate>
     f0c:	90 93 35 09 	sts	0x0935, r25
     f10:	80 93 34 09 	sts	0x0934, r24
     f14:	08 95       	ret

00000f16 <myUSART_USART1_Init>:
     f16:	10 92 cd 00 	sts	0x00CD, r1
     f1a:	87 e6       	ldi	r24, 0x67	; 103
     f1c:	80 93 cc 00 	sts	0x00CC, r24
     f20:	88 eb       	ldi	r24, 0xB8	; 184
     f22:	80 93 c9 00 	sts	0x00C9, r24
     f26:	86 e0       	ldi	r24, 0x06	; 6
     f28:	80 93 ca 00 	sts	0x00CA, r24
     f2c:	40 e2       	ldi	r20, 0x20	; 32
     f2e:	6d ea       	ldi	r22, 0xAD	; 173
     f30:	78 e0       	ldi	r23, 0x08	; 8
     f32:	82 e4       	ldi	r24, 0x42	; 66
     f34:	99 e0       	ldi	r25, 0x09	; 9
     f36:	15 d5       	rcall	.+2602   	; 0x1962 <ringBufferInit>
     f38:	40 e2       	ldi	r20, 0x20	; 32
     f3a:	64 e1       	ldi	r22, 0x14	; 20
     f3c:	79 e0       	ldi	r23, 0x09	; 9
     f3e:	88 e3       	ldi	r24, 0x38	; 56
     f40:	99 e0       	ldi	r25, 0x09	; 9
     f42:	0f d5       	rcall	.+2590   	; 0x1962 <ringBufferInit>
     f44:	43 e0       	ldi	r20, 0x03	; 3
     f46:	60 e0       	ldi	r22, 0x00	; 0
     f48:	81 e0       	ldi	r24, 0x01	; 1
     f4a:	33 d3       	rcall	.+1638   	; 0x15b2 <xQueueGenericCreate>
     f4c:	90 93 37 09 	sts	0x0937, r25
     f50:	80 93 36 09 	sts	0x0936, r24
     f54:	43 e0       	ldi	r20, 0x03	; 3
     f56:	60 e0       	ldi	r22, 0x00	; 0
     f58:	81 e0       	ldi	r24, 0x01	; 1
     f5a:	2b d3       	rcall	.+1622   	; 0x15b2 <xQueueGenericCreate>
     f5c:	90 93 f3 08 	sts	0x08F3, r25
     f60:	80 93 f2 08 	sts	0x08F2, r24
     f64:	08 95       	ret

00000f66 <myUSART_transmitUSART0_c>:
     f66:	cf 93       	push	r28
     f68:	c8 2f       	mov	r28, r24
     f6a:	8d e3       	ldi	r24, 0x3D	; 61
     f6c:	99 e0       	ldi	r25, 0x09	; 9
     f6e:	33 d5       	rcall	.+2662   	; 0x19d6 <ringBufferFull>
     f70:	81 11       	cpse	r24, r1
     f72:	fb cf       	rjmp	.-10     	; 0xf6a <myUSART_transmitUSART0_c+0x4>
     f74:	6c 2f       	mov	r22, r28
     f76:	8d e3       	ldi	r24, 0x3D	; 61
     f78:	99 e0       	ldi	r25, 0x09	; 9
     f7a:	16 d5       	rcall	.+2604   	; 0x19a8 <ringBufferPush>
     f7c:	e1 ec       	ldi	r30, 0xC1	; 193
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	80 81       	ld	r24, Z
     f82:	80 62       	ori	r24, 0x20	; 32
     f84:	80 83       	st	Z, r24
     f86:	e0 ec       	ldi	r30, 0xC0	; 192
     f88:	f0 e0       	ldi	r31, 0x00	; 0
     f8a:	80 81       	ld	r24, Z
     f8c:	80 64       	ori	r24, 0x40	; 64
     f8e:	80 83       	st	Z, r24
     f90:	cf 91       	pop	r28
     f92:	08 95       	ret

00000f94 <myUSART_transmitUSART1_c>:
     f94:	cf 93       	push	r28
     f96:	c8 2f       	mov	r28, r24
     f98:	88 e3       	ldi	r24, 0x38	; 56
     f9a:	99 e0       	ldi	r25, 0x09	; 9
     f9c:	1c d5       	rcall	.+2616   	; 0x19d6 <ringBufferFull>
     f9e:	81 11       	cpse	r24, r1
     fa0:	fb cf       	rjmp	.-10     	; 0xf98 <myUSART_transmitUSART1_c+0x4>
     fa2:	6c 2f       	mov	r22, r28
     fa4:	88 e3       	ldi	r24, 0x38	; 56
     fa6:	99 e0       	ldi	r25, 0x09	; 9
     fa8:	ff d4       	rcall	.+2558   	; 0x19a8 <ringBufferPush>
     faa:	e9 ec       	ldi	r30, 0xC9	; 201
     fac:	f0 e0       	ldi	r31, 0x00	; 0
     fae:	80 81       	ld	r24, Z
     fb0:	80 62       	ori	r24, 0x20	; 32
     fb2:	80 83       	st	Z, r24
     fb4:	e8 ec       	ldi	r30, 0xC8	; 200
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	80 64       	ori	r24, 0x40	; 64
     fbc:	80 83       	st	Z, r24
     fbe:	cf 91       	pop	r28
     fc0:	08 95       	ret

00000fc2 <myUSART_transmitUSART1>:
     fc2:	cf 93       	push	r28
     fc4:	df 93       	push	r29
     fc6:	ec 01       	movw	r28, r24
     fc8:	88 81       	ld	r24, Y
     fca:	88 23       	and	r24, r24
     fcc:	29 f0       	breq	.+10     	; 0xfd8 <myUSART_transmitUSART1+0x16>
     fce:	21 96       	adiw	r28, 0x01	; 1
     fd0:	e1 df       	rcall	.-62     	; 0xf94 <myUSART_transmitUSART1_c>
     fd2:	89 91       	ld	r24, Y+
     fd4:	81 11       	cpse	r24, r1
     fd6:	fc cf       	rjmp	.-8      	; 0xfd0 <myUSART_transmitUSART1+0xe>
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	08 95       	ret

00000fde <myUSART_transmitUSART0>:
     fde:	cf 93       	push	r28
     fe0:	df 93       	push	r29
     fe2:	ec 01       	movw	r28, r24
     fe4:	88 81       	ld	r24, Y
     fe6:	88 23       	and	r24, r24
     fe8:	29 f0       	breq	.+10     	; 0xff4 <myUSART_transmitUSART0+0x16>
     fea:	21 96       	adiw	r28, 0x01	; 1
     fec:	bc df       	rcall	.-136    	; 0xf66 <myUSART_transmitUSART0_c>
     fee:	89 91       	ld	r24, Y+
     ff0:	81 11       	cpse	r24, r1
     ff2:	fc cf       	rjmp	.-8      	; 0xfec <myUSART_transmitUSART0+0xe>
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	08 95       	ret

00000ffa <myUSART_receiveUSART1>:
     ffa:	cf 93       	push	r28
     ffc:	20 e0       	ldi	r18, 0x00	; 0
     ffe:	4f ef       	ldi	r20, 0xFF	; 255
    1000:	5f ef       	ldi	r21, 0xFF	; 255
    1002:	60 e0       	ldi	r22, 0x00	; 0
    1004:	70 e0       	ldi	r23, 0x00	; 0
    1006:	80 91 36 09 	lds	r24, 0x0936
    100a:	90 91 37 09 	lds	r25, 0x0937
    100e:	f6 d3       	rcall	.+2028   	; 0x17fc <xQueueGenericReceive>
    1010:	82 e4       	ldi	r24, 0x42	; 66
    1012:	99 e0       	ldi	r25, 0x09	; 9
    1014:	b7 d4       	rcall	.+2414   	; 0x1984 <ringBufferPop>
    1016:	c8 2f       	mov	r28, r24
    1018:	82 e4       	ldi	r24, 0x42	; 66
    101a:	99 e0       	ldi	r25, 0x09	; 9
    101c:	e3 d4       	rcall	.+2502   	; 0x19e4 <ringBufferNotEmpty>
    101e:	88 23       	and	r24, r24
    1020:	51 f0       	breq	.+20     	; 0x1036 <myUSART_receiveUSART1+0x3c>
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	40 e0       	ldi	r20, 0x00	; 0
    1026:	50 e0       	ldi	r21, 0x00	; 0
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	70 e0       	ldi	r23, 0x00	; 0
    102c:	80 91 36 09 	lds	r24, 0x0936
    1030:	90 91 37 09 	lds	r25, 0x0937
    1034:	eb d2       	rcall	.+1494   	; 0x160c <xQueueGenericSend>
    1036:	8c 2f       	mov	r24, r28
    1038:	cf 91       	pop	r28
    103a:	08 95       	ret

0000103c <myUSART_waitForHandshake>:
    103c:	de df       	rcall	.-68     	; 0xffa <myUSART_receiveUSART1>
    103e:	86 31       	cpi	r24, 0x16	; 22
    1040:	51 f4       	brne	.+20     	; 0x1056 <myUSART_waitForHandshake+0x1a>
    1042:	85 e0       	ldi	r24, 0x05	; 5
    1044:	a7 df       	rcall	.-178    	; 0xf94 <myUSART_transmitUSART1_c>
    1046:	d9 df       	rcall	.-78     	; 0xffa <myUSART_receiveUSART1>
    1048:	91 e0       	ldi	r25, 0x01	; 1
    104a:	86 31       	cpi	r24, 0x16	; 22
    104c:	09 f4       	brne	.+2      	; 0x1050 <myUSART_waitForHandshake+0x14>
    104e:	90 e0       	ldi	r25, 0x00	; 0
    1050:	89 2f       	mov	r24, r25
    1052:	81 95       	neg	r24
    1054:	08 95       	ret
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	08 95       	ret

0000105a <myUSART_completeHandShake>:
    105a:	20 e0       	ldi	r18, 0x00	; 0
    105c:	40 e0       	ldi	r20, 0x00	; 0
    105e:	50 e0       	ldi	r21, 0x00	; 0
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	70 e0       	ldi	r23, 0x00	; 0
    1064:	80 91 f2 08 	lds	r24, 0x08F2
    1068:	90 91 f3 08 	lds	r25, 0x08F3
    106c:	cf c2       	rjmp	.+1438   	; 0x160c <xQueueGenericSend>
    106e:	08 95       	ret

00001070 <myUSART_receiveHandShakeAck>:
    1070:	91 e0       	ldi	r25, 0x01	; 1
    1072:	85 30       	cpi	r24, 0x05	; 5
    1074:	09 f0       	breq	.+2      	; 0x1078 <myUSART_receiveHandShakeAck+0x8>
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	89 2f       	mov	r24, r25
    107a:	08 95       	ret

0000107c <myUSART_receiveHandShakeStart>:
    107c:	91 e0       	ldi	r25, 0x01	; 1
    107e:	86 31       	cpi	r24, 0x16	; 22
    1080:	09 f0       	breq	.+2      	; 0x1084 <myUSART_receiveHandShakeStart+0x8>
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	89 2f       	mov	r24, r25
    1086:	08 95       	ret

00001088 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1088:	91 e0       	ldi	r25, 0x01	; 1
    108a:	86 30       	cpi	r24, 0x06	; 6
    108c:	09 f0       	breq	.+2      	; 0x1090 <myUSART_receiveMessageACK+0x8>
    108e:	90 e0       	ldi	r25, 0x00	; 0
}
    1090:	89 2f       	mov	r24, r25
    1092:	08 95       	ret

00001094 <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    1094:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    1096:	20 e0       	ldi	r18, 0x00	; 0
    1098:	4f ef       	ldi	r20, 0xFF	; 255
    109a:	5f ef       	ldi	r21, 0xFF	; 255
    109c:	60 e0       	ldi	r22, 0x00	; 0
    109e:	70 e0       	ldi	r23, 0x00	; 0
    10a0:	80 91 36 09 	lds	r24, 0x0936
    10a4:	90 91 37 09 	lds	r25, 0x0937
    10a8:	a9 d3       	rcall	.+1874   	; 0x17fc <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    10aa:	82 e4       	ldi	r24, 0x42	; 66
    10ac:	99 e0       	ldi	r25, 0x09	; 9
    10ae:	60 d4       	rcall	.+2240   	; 0x1970 <ringBufferPeek>
    10b0:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    10b2:	82 e4       	ldi	r24, 0x42	; 66
    10b4:	99 e0       	ldi	r25, 0x09	; 9
    10b6:	96 d4       	rcall	.+2348   	; 0x19e4 <ringBufferNotEmpty>
    10b8:	88 23       	and	r24, r24
    10ba:	51 f0       	breq	.+20     	; 0x10d0 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    10bc:	20 e0       	ldi	r18, 0x00	; 0
    10be:	40 e0       	ldi	r20, 0x00	; 0
    10c0:	50 e0       	ldi	r21, 0x00	; 0
    10c2:	60 e0       	ldi	r22, 0x00	; 0
    10c4:	70 e0       	ldi	r23, 0x00	; 0
    10c6:	80 91 36 09 	lds	r24, 0x0936
    10ca:	90 91 37 09 	lds	r25, 0x0937
    10ce:	9e d2       	rcall	.+1340   	; 0x160c <xQueueGenericSend>
	}
	
	return data;
    10d0:	8c 2f       	mov	r24, r28
    10d2:	cf 91       	pop	r28
    10d4:	08 95       	ret

000010d6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    10d6:	31 e1       	ldi	r19, 0x11	; 17
    10d8:	fc 01       	movw	r30, r24
    10da:	30 83       	st	Z, r19
    10dc:	31 97       	sbiw	r30, 0x01	; 1
    10de:	22 e2       	ldi	r18, 0x22	; 34
    10e0:	20 83       	st	Z, r18
    10e2:	31 97       	sbiw	r30, 0x01	; 1
    10e4:	a3 e3       	ldi	r26, 0x33	; 51
    10e6:	a0 83       	st	Z, r26
    10e8:	31 97       	sbiw	r30, 0x01	; 1
    10ea:	60 83       	st	Z, r22
    10ec:	31 97       	sbiw	r30, 0x01	; 1
    10ee:	70 83       	st	Z, r23
    10f0:	31 97       	sbiw	r30, 0x01	; 1
    10f2:	10 82       	st	Z, r1
    10f4:	31 97       	sbiw	r30, 0x01	; 1
    10f6:	10 82       	st	Z, r1
    10f8:	31 97       	sbiw	r30, 0x01	; 1
    10fa:	60 e8       	ldi	r22, 0x80	; 128
    10fc:	60 83       	st	Z, r22
    10fe:	31 97       	sbiw	r30, 0x01	; 1
    1100:	10 82       	st	Z, r1
    1102:	31 97       	sbiw	r30, 0x01	; 1
    1104:	10 82       	st	Z, r1
    1106:	31 97       	sbiw	r30, 0x01	; 1
    1108:	10 82       	st	Z, r1
    110a:	31 97       	sbiw	r30, 0x01	; 1
    110c:	62 e0       	ldi	r22, 0x02	; 2
    110e:	60 83       	st	Z, r22
    1110:	31 97       	sbiw	r30, 0x01	; 1
    1112:	63 e0       	ldi	r22, 0x03	; 3
    1114:	60 83       	st	Z, r22
    1116:	31 97       	sbiw	r30, 0x01	; 1
    1118:	64 e0       	ldi	r22, 0x04	; 4
    111a:	60 83       	st	Z, r22
    111c:	31 97       	sbiw	r30, 0x01	; 1
    111e:	65 e0       	ldi	r22, 0x05	; 5
    1120:	60 83       	st	Z, r22
    1122:	31 97       	sbiw	r30, 0x01	; 1
    1124:	66 e0       	ldi	r22, 0x06	; 6
    1126:	60 83       	st	Z, r22
    1128:	31 97       	sbiw	r30, 0x01	; 1
    112a:	67 e0       	ldi	r22, 0x07	; 7
    112c:	60 83       	st	Z, r22
    112e:	31 97       	sbiw	r30, 0x01	; 1
    1130:	68 e0       	ldi	r22, 0x08	; 8
    1132:	60 83       	st	Z, r22
    1134:	31 97       	sbiw	r30, 0x01	; 1
    1136:	69 e0       	ldi	r22, 0x09	; 9
    1138:	60 83       	st	Z, r22
    113a:	31 97       	sbiw	r30, 0x01	; 1
    113c:	60 e1       	ldi	r22, 0x10	; 16
    113e:	60 83       	st	Z, r22
    1140:	31 97       	sbiw	r30, 0x01	; 1
    1142:	30 83       	st	Z, r19
    1144:	31 97       	sbiw	r30, 0x01	; 1
    1146:	32 e1       	ldi	r19, 0x12	; 18
    1148:	30 83       	st	Z, r19
    114a:	31 97       	sbiw	r30, 0x01	; 1
    114c:	33 e1       	ldi	r19, 0x13	; 19
    114e:	30 83       	st	Z, r19
    1150:	31 97       	sbiw	r30, 0x01	; 1
    1152:	34 e1       	ldi	r19, 0x14	; 20
    1154:	30 83       	st	Z, r19
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	35 e1       	ldi	r19, 0x15	; 21
    115a:	30 83       	st	Z, r19
    115c:	31 97       	sbiw	r30, 0x01	; 1
    115e:	36 e1       	ldi	r19, 0x16	; 22
    1160:	30 83       	st	Z, r19
    1162:	31 97       	sbiw	r30, 0x01	; 1
    1164:	37 e1       	ldi	r19, 0x17	; 23
    1166:	30 83       	st	Z, r19
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	38 e1       	ldi	r19, 0x18	; 24
    116c:	30 83       	st	Z, r19
    116e:	31 97       	sbiw	r30, 0x01	; 1
    1170:	39 e1       	ldi	r19, 0x19	; 25
    1172:	30 83       	st	Z, r19
    1174:	31 97       	sbiw	r30, 0x01	; 1
    1176:	30 e2       	ldi	r19, 0x20	; 32
    1178:	30 83       	st	Z, r19
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	31 e2       	ldi	r19, 0x21	; 33
    117e:	30 83       	st	Z, r19
    1180:	31 97       	sbiw	r30, 0x01	; 1
    1182:	20 83       	st	Z, r18
    1184:	31 97       	sbiw	r30, 0x01	; 1
    1186:	23 e2       	ldi	r18, 0x23	; 35
    1188:	20 83       	st	Z, r18
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	40 83       	st	Z, r20
    118e:	31 97       	sbiw	r30, 0x01	; 1
    1190:	50 83       	st	Z, r21
    1192:	31 97       	sbiw	r30, 0x01	; 1
    1194:	26 e2       	ldi	r18, 0x26	; 38
    1196:	20 83       	st	Z, r18
    1198:	31 97       	sbiw	r30, 0x01	; 1
    119a:	27 e2       	ldi	r18, 0x27	; 39
    119c:	20 83       	st	Z, r18
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	28 e2       	ldi	r18, 0x28	; 40
    11a2:	20 83       	st	Z, r18
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	29 e2       	ldi	r18, 0x29	; 41
    11a8:	20 83       	st	Z, r18
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	20 e3       	ldi	r18, 0x30	; 48
    11ae:	20 83       	st	Z, r18
    11b0:	31 97       	sbiw	r30, 0x01	; 1
    11b2:	21 e3       	ldi	r18, 0x31	; 49
    11b4:	20 83       	st	Z, r18
    11b6:	89 97       	sbiw	r24, 0x29	; 41
    11b8:	08 95       	ret

000011ba <xPortStartScheduler>:
    11ba:	82 e0       	ldi	r24, 0x02	; 2
    11bc:	84 bd       	out	0x24, r24	; 36
    11be:	16 bc       	out	0x26, r1	; 38
    11c0:	80 e3       	ldi	r24, 0x30	; 48
    11c2:	87 bd       	out	0x27, r24	; 39
    11c4:	ee e6       	ldi	r30, 0x6E	; 110
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
    11c8:	80 81       	ld	r24, Z
    11ca:	82 60       	ori	r24, 0x02	; 2
    11cc:	80 83       	st	Z, r24
    11ce:	83 e0       	ldi	r24, 0x03	; 3
    11d0:	85 bd       	out	0x25, r24	; 37
    11d2:	a0 91 8d 08 	lds	r26, 0x088D
    11d6:	b0 91 8e 08 	lds	r27, 0x088E
    11da:	cd 91       	ld	r28, X+
    11dc:	cd bf       	out	0x3d, r28	; 61
    11de:	dd 91       	ld	r29, X+
    11e0:	de bf       	out	0x3e, r29	; 62
    11e2:	ff 91       	pop	r31
    11e4:	ef 91       	pop	r30
    11e6:	df 91       	pop	r29
    11e8:	cf 91       	pop	r28
    11ea:	bf 91       	pop	r27
    11ec:	af 91       	pop	r26
    11ee:	9f 91       	pop	r25
    11f0:	8f 91       	pop	r24
    11f2:	7f 91       	pop	r23
    11f4:	6f 91       	pop	r22
    11f6:	5f 91       	pop	r21
    11f8:	4f 91       	pop	r20
    11fa:	3f 91       	pop	r19
    11fc:	2f 91       	pop	r18
    11fe:	1f 91       	pop	r17
    1200:	0f 91       	pop	r16
    1202:	ff 90       	pop	r15
    1204:	ef 90       	pop	r14
    1206:	df 90       	pop	r13
    1208:	cf 90       	pop	r12
    120a:	bf 90       	pop	r11
    120c:	af 90       	pop	r10
    120e:	9f 90       	pop	r9
    1210:	8f 90       	pop	r8
    1212:	7f 90       	pop	r7
    1214:	6f 90       	pop	r6
    1216:	5f 90       	pop	r5
    1218:	4f 90       	pop	r4
    121a:	3f 90       	pop	r3
    121c:	2f 90       	pop	r2
    121e:	1f 90       	pop	r1
    1220:	0f 90       	pop	r0
    1222:	0c be       	out	0x3c, r0	; 60
    1224:	0f 90       	pop	r0
    1226:	0b be       	out	0x3b, r0	; 59
    1228:	0f 90       	pop	r0
    122a:	0f be       	out	0x3f, r0	; 63
    122c:	0f 90       	pop	r0
    122e:	08 95       	ret
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	08 95       	ret

00001234 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1234:	0f 92       	push	r0
    1236:	0f b6       	in	r0, 0x3f	; 63
    1238:	f8 94       	cli
    123a:	0f 92       	push	r0
    123c:	0b b6       	in	r0, 0x3b	; 59
    123e:	0f 92       	push	r0
    1240:	0c b6       	in	r0, 0x3c	; 60
    1242:	0f 92       	push	r0
    1244:	1f 92       	push	r1
    1246:	11 24       	eor	r1, r1
    1248:	2f 92       	push	r2
    124a:	3f 92       	push	r3
    124c:	4f 92       	push	r4
    124e:	5f 92       	push	r5
    1250:	6f 92       	push	r6
    1252:	7f 92       	push	r7
    1254:	8f 92       	push	r8
    1256:	9f 92       	push	r9
    1258:	af 92       	push	r10
    125a:	bf 92       	push	r11
    125c:	cf 92       	push	r12
    125e:	df 92       	push	r13
    1260:	ef 92       	push	r14
    1262:	ff 92       	push	r15
    1264:	0f 93       	push	r16
    1266:	1f 93       	push	r17
    1268:	2f 93       	push	r18
    126a:	3f 93       	push	r19
    126c:	4f 93       	push	r20
    126e:	5f 93       	push	r21
    1270:	6f 93       	push	r22
    1272:	7f 93       	push	r23
    1274:	8f 93       	push	r24
    1276:	9f 93       	push	r25
    1278:	af 93       	push	r26
    127a:	bf 93       	push	r27
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	ef 93       	push	r30
    1282:	ff 93       	push	r31
    1284:	a0 91 8d 08 	lds	r26, 0x088D
    1288:	b0 91 8e 08 	lds	r27, 0x088E
    128c:	0d b6       	in	r0, 0x3d	; 61
    128e:	0d 92       	st	X+, r0
    1290:	0e b6       	in	r0, 0x3e	; 62
    1292:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1294:	75 d7       	rcall	.+3818   	; 0x2180 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1296:	a0 91 8d 08 	lds	r26, 0x088D
    129a:	b0 91 8e 08 	lds	r27, 0x088E
    129e:	cd 91       	ld	r28, X+
    12a0:	cd bf       	out	0x3d, r28	; 61
    12a2:	dd 91       	ld	r29, X+
    12a4:	de bf       	out	0x3e, r29	; 62
    12a6:	ff 91       	pop	r31
    12a8:	ef 91       	pop	r30
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	bf 91       	pop	r27
    12b0:	af 91       	pop	r26
    12b2:	9f 91       	pop	r25
    12b4:	8f 91       	pop	r24
    12b6:	7f 91       	pop	r23
    12b8:	6f 91       	pop	r22
    12ba:	5f 91       	pop	r21
    12bc:	4f 91       	pop	r20
    12be:	3f 91       	pop	r19
    12c0:	2f 91       	pop	r18
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	ff 90       	pop	r15
    12c8:	ef 90       	pop	r14
    12ca:	df 90       	pop	r13
    12cc:	cf 90       	pop	r12
    12ce:	bf 90       	pop	r11
    12d0:	af 90       	pop	r10
    12d2:	9f 90       	pop	r9
    12d4:	8f 90       	pop	r8
    12d6:	7f 90       	pop	r7
    12d8:	6f 90       	pop	r6
    12da:	5f 90       	pop	r5
    12dc:	4f 90       	pop	r4
    12de:	3f 90       	pop	r3
    12e0:	2f 90       	pop	r2
    12e2:	1f 90       	pop	r1
    12e4:	0f 90       	pop	r0
    12e6:	0c be       	out	0x3c, r0	; 60
    12e8:	0f 90       	pop	r0
    12ea:	0b be       	out	0x3b, r0	; 59
    12ec:	0f 90       	pop	r0
    12ee:	0f be       	out	0x3f, r0	; 63
    12f0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12f2:	08 95       	ret

000012f4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12f4:	0f 92       	push	r0
    12f6:	0f b6       	in	r0, 0x3f	; 63
    12f8:	f8 94       	cli
    12fa:	0f 92       	push	r0
    12fc:	0b b6       	in	r0, 0x3b	; 59
    12fe:	0f 92       	push	r0
    1300:	0c b6       	in	r0, 0x3c	; 60
    1302:	0f 92       	push	r0
    1304:	1f 92       	push	r1
    1306:	11 24       	eor	r1, r1
    1308:	2f 92       	push	r2
    130a:	3f 92       	push	r3
    130c:	4f 92       	push	r4
    130e:	5f 92       	push	r5
    1310:	6f 92       	push	r6
    1312:	7f 92       	push	r7
    1314:	8f 92       	push	r8
    1316:	9f 92       	push	r9
    1318:	af 92       	push	r10
    131a:	bf 92       	push	r11
    131c:	cf 92       	push	r12
    131e:	df 92       	push	r13
    1320:	ef 92       	push	r14
    1322:	ff 92       	push	r15
    1324:	0f 93       	push	r16
    1326:	1f 93       	push	r17
    1328:	2f 93       	push	r18
    132a:	3f 93       	push	r19
    132c:	4f 93       	push	r20
    132e:	5f 93       	push	r21
    1330:	6f 93       	push	r22
    1332:	7f 93       	push	r23
    1334:	8f 93       	push	r24
    1336:	9f 93       	push	r25
    1338:	af 93       	push	r26
    133a:	bf 93       	push	r27
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	ef 93       	push	r30
    1342:	ff 93       	push	r31
    1344:	a0 91 8d 08 	lds	r26, 0x088D
    1348:	b0 91 8e 08 	lds	r27, 0x088E
    134c:	0d b6       	in	r0, 0x3d	; 61
    134e:	0d 92       	st	X+, r0
    1350:	0e b6       	in	r0, 0x3e	; 62
    1352:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1354:	43 d5       	rcall	.+2694   	; 0x1ddc <xTaskIncrementTick>
    1356:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1358:	13 d7       	rcall	.+3622   	; 0x2180 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    135a:	a0 91 8d 08 	lds	r26, 0x088D
    135e:	b0 91 8e 08 	lds	r27, 0x088E
    1362:	cd 91       	ld	r28, X+
    1364:	cd bf       	out	0x3d, r28	; 61
    1366:	dd 91       	ld	r29, X+
    1368:	de bf       	out	0x3e, r29	; 62
    136a:	ff 91       	pop	r31
    136c:	ef 91       	pop	r30
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	bf 91       	pop	r27
    1374:	af 91       	pop	r26
    1376:	9f 91       	pop	r25
    1378:	8f 91       	pop	r24
    137a:	7f 91       	pop	r23
    137c:	6f 91       	pop	r22
    137e:	5f 91       	pop	r21
    1380:	4f 91       	pop	r20
    1382:	3f 91       	pop	r19
    1384:	2f 91       	pop	r18
    1386:	1f 91       	pop	r17
    1388:	0f 91       	pop	r16
    138a:	ff 90       	pop	r15
    138c:	ef 90       	pop	r14
    138e:	df 90       	pop	r13
    1390:	cf 90       	pop	r12
    1392:	bf 90       	pop	r11
    1394:	af 90       	pop	r10
    1396:	9f 90       	pop	r9
    1398:	8f 90       	pop	r8
    139a:	7f 90       	pop	r7
    139c:	6f 90       	pop	r6
    139e:	5f 90       	pop	r5
    13a0:	4f 90       	pop	r4
    13a2:	3f 90       	pop	r3
    13a4:	2f 90       	pop	r2
    13a6:	1f 90       	pop	r1
    13a8:	0f 90       	pop	r0
    13aa:	0c be       	out	0x3c, r0	; 60
    13ac:	0f 90       	pop	r0
    13ae:	0b be       	out	0x3b, r0	; 59
    13b0:	0f 90       	pop	r0
    13b2:	0f be       	out	0x3f, r0	; 63
    13b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13b6:	08 95       	ret

000013b8 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    13b8:	9d df       	rcall	.-198    	; 0x12f4 <vPortYieldFromTick>
		 asm volatile ("reti");
    13ba:	18 95       	reti

000013bc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    13bc:	1f 93       	push	r17
    13be:	cf 93       	push	r28
    13c0:	df 93       	push	r29
    13c2:	ec 01       	movw	r28, r24
    13c4:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    13c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    13c8:	81 11       	cpse	r24, r1
    13ca:	0c c0       	rjmp	.+24     	; 0x13e4 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13cc:	88 81       	ld	r24, Y
    13ce:	99 81       	ldd	r25, Y+1	; 0x01
    13d0:	89 2b       	or	r24, r25
    13d2:	09 f0       	breq	.+2      	; 0x13d6 <prvCopyDataToQueue+0x1a>
    13d4:	47 c0       	rjmp	.+142    	; 0x1464 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    13d6:	8a 81       	ldd	r24, Y+2	; 0x02
    13d8:	9b 81       	ldd	r25, Y+3	; 0x03
    13da:	0e 94 83 12 	call	0x2506	; 0x2506 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    13de:	1b 82       	std	Y+3, r1	; 0x03
    13e0:	1a 82       	std	Y+2, r1	; 0x02
    13e2:	47 c0       	rjmp	.+142    	; 0x1472 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    13e4:	41 11       	cpse	r20, r1
    13e6:	18 c0       	rjmp	.+48     	; 0x1418 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    13e8:	48 2f       	mov	r20, r24
    13ea:	50 e0       	ldi	r21, 0x00	; 0
    13ec:	8c 81       	ldd	r24, Y+4	; 0x04
    13ee:	9d 81       	ldd	r25, Y+5	; 0x05
    13f0:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13f6:	8c 81       	ldd	r24, Y+4	; 0x04
    13f8:	9d 81       	ldd	r25, Y+5	; 0x05
    13fa:	82 0f       	add	r24, r18
    13fc:	91 1d       	adc	r25, r1
    13fe:	9d 83       	std	Y+5, r25	; 0x05
    1400:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1402:	2a 81       	ldd	r18, Y+2	; 0x02
    1404:	3b 81       	ldd	r19, Y+3	; 0x03
    1406:	82 17       	cp	r24, r18
    1408:	93 07       	cpc	r25, r19
    140a:	70 f1       	brcs	.+92     	; 0x1468 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    140c:	88 81       	ld	r24, Y
    140e:	99 81       	ldd	r25, Y+1	; 0x01
    1410:	9d 83       	std	Y+5, r25	; 0x05
    1412:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	2d c0       	rjmp	.+90     	; 0x1472 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1418:	48 2f       	mov	r20, r24
    141a:	50 e0       	ldi	r21, 0x00	; 0
    141c:	8e 81       	ldd	r24, Y+6	; 0x06
    141e:	9f 81       	ldd	r25, Y+7	; 0x07
    1420:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1424:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	31 95       	neg	r19
    142a:	21 95       	neg	r18
    142c:	31 09       	sbc	r19, r1
    142e:	8e 81       	ldd	r24, Y+6	; 0x06
    1430:	9f 81       	ldd	r25, Y+7	; 0x07
    1432:	82 0f       	add	r24, r18
    1434:	93 1f       	adc	r25, r19
    1436:	9f 83       	std	Y+7, r25	; 0x07
    1438:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    143a:	68 81       	ld	r22, Y
    143c:	79 81       	ldd	r23, Y+1	; 0x01
    143e:	86 17       	cp	r24, r22
    1440:	97 07       	cpc	r25, r23
    1442:	30 f4       	brcc	.+12     	; 0x1450 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1444:	8a 81       	ldd	r24, Y+2	; 0x02
    1446:	9b 81       	ldd	r25, Y+3	; 0x03
    1448:	28 0f       	add	r18, r24
    144a:	39 1f       	adc	r19, r25
    144c:	3f 83       	std	Y+7, r19	; 0x07
    144e:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1450:	12 30       	cpi	r17, 0x02	; 2
    1452:	61 f4       	brne	.+24     	; 0x146c <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1454:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1456:	88 23       	and	r24, r24
    1458:	59 f0       	breq	.+22     	; 0x1470 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    145a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    145c:	81 50       	subi	r24, 0x01	; 1
    145e:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	07 c0       	rjmp	.+14     	; 0x1472 <prvCopyDataToQueue+0xb6>
    1464:	80 e0       	ldi	r24, 0x00	; 0
    1466:	05 c0       	rjmp	.+10     	; 0x1472 <prvCopyDataToQueue+0xb6>
    1468:	80 e0       	ldi	r24, 0x00	; 0
    146a:	03 c0       	rjmp	.+6      	; 0x1472 <prvCopyDataToQueue+0xb6>
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	01 c0       	rjmp	.+2      	; 0x1472 <prvCopyDataToQueue+0xb6>
    1470:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1472:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1474:	9f 5f       	subi	r25, 0xFF	; 255
    1476:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	08 95       	ret

00001480 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1480:	fc 01       	movw	r30, r24
    1482:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1484:	44 8d       	ldd	r20, Z+28	; 0x1c
    1486:	44 23       	and	r20, r20
    1488:	a1 f0       	breq	.+40     	; 0x14b2 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    148a:	50 e0       	ldi	r21, 0x00	; 0
    148c:	26 81       	ldd	r18, Z+6	; 0x06
    148e:	37 81       	ldd	r19, Z+7	; 0x07
    1490:	24 0f       	add	r18, r20
    1492:	35 1f       	adc	r19, r21
    1494:	37 83       	std	Z+7, r19	; 0x07
    1496:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1498:	62 81       	ldd	r22, Z+2	; 0x02
    149a:	73 81       	ldd	r23, Z+3	; 0x03
    149c:	26 17       	cp	r18, r22
    149e:	37 07       	cpc	r19, r23
    14a0:	20 f0       	brcs	.+8      	; 0x14aa <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    14a2:	20 81       	ld	r18, Z
    14a4:	31 81       	ldd	r19, Z+1	; 0x01
    14a6:	37 83       	std	Z+7, r19	; 0x07
    14a8:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    14aa:	66 81       	ldd	r22, Z+6	; 0x06
    14ac:	77 81       	ldd	r23, Z+7	; 0x07
    14ae:	0c 94 4f 16 	jmp	0x2c9e	; 0x2c9e <memcpy>
    14b2:	08 95       	ret

000014b4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14c6:	18 16       	cp	r1, r24
    14c8:	a4 f4       	brge	.+40     	; 0x14f2 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14ca:	89 89       	ldd	r24, Y+17	; 0x11
    14cc:	88 23       	and	r24, r24
    14ce:	89 f0       	breq	.+34     	; 0x14f2 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14d0:	8e 01       	movw	r16, r28
    14d2:	0f 5e       	subi	r16, 0xEF	; 239
    14d4:	1f 4f       	sbci	r17, 0xFF	; 255
    14d6:	03 c0       	rjmp	.+6      	; 0x14de <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14d8:	89 89       	ldd	r24, Y+17	; 0x11
    14da:	88 23       	and	r24, r24
    14dc:	51 f0       	breq	.+20     	; 0x14f2 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14de:	c8 01       	movw	r24, r16
    14e0:	25 d7       	rcall	.+3658   	; 0x232c <xTaskRemoveFromEventList>
    14e2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    14e4:	ae d7       	rcall	.+3932   	; 0x2442 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    14e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14e8:	81 50       	subi	r24, 0x01	; 1
    14ea:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14ec:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14ee:	18 16       	cp	r1, r24
    14f0:	9c f3       	brlt	.-26     	; 0x14d8 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    14f2:	8f ef       	ldi	r24, 0xFF	; 255
    14f4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    14f6:	0f 90       	pop	r0
    14f8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	f8 94       	cli
    14fe:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1500:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1502:	18 16       	cp	r1, r24
    1504:	a4 f4       	brge	.+40     	; 0x152e <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1506:	88 85       	ldd	r24, Y+8	; 0x08
    1508:	88 23       	and	r24, r24
    150a:	89 f0       	breq	.+34     	; 0x152e <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    150c:	8e 01       	movw	r16, r28
    150e:	08 5f       	subi	r16, 0xF8	; 248
    1510:	1f 4f       	sbci	r17, 0xFF	; 255
    1512:	03 c0       	rjmp	.+6      	; 0x151a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1514:	88 85       	ldd	r24, Y+8	; 0x08
    1516:	88 23       	and	r24, r24
    1518:	51 f0       	breq	.+20     	; 0x152e <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    151a:	c8 01       	movw	r24, r16
    151c:	07 d7       	rcall	.+3598   	; 0x232c <xTaskRemoveFromEventList>
    151e:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1520:	90 d7       	rcall	.+3872   	; 0x2442 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1522:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1524:	81 50       	subi	r24, 0x01	; 1
    1526:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1528:	8d 8d       	ldd	r24, Y+29	; 0x1d
    152a:	18 16       	cp	r1, r24
    152c:	9c f3       	brlt	.-26     	; 0x1514 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    152e:	8f ef       	ldi	r24, 0xFF	; 255
    1530:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63
}
    1536:	df 91       	pop	r29
    1538:	cf 91       	pop	r28
    153a:	1f 91       	pop	r17
    153c:	0f 91       	pop	r16
    153e:	08 95       	ret

00001540 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1540:	cf 93       	push	r28
    1542:	df 93       	push	r29
    1544:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1546:	0f b6       	in	r0, 0x3f	; 63
    1548:	f8 94       	cli
    154a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    154c:	88 81       	ld	r24, Y
    154e:	99 81       	ldd	r25, Y+1	; 0x01
    1550:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1552:	30 e0       	ldi	r19, 0x00	; 0
    1554:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1556:	72 9f       	mul	r23, r18
    1558:	a0 01       	movw	r20, r0
    155a:	73 9f       	mul	r23, r19
    155c:	50 0d       	add	r21, r0
    155e:	11 24       	eor	r1, r1
    1560:	fc 01       	movw	r30, r24
    1562:	e4 0f       	add	r30, r20
    1564:	f5 1f       	adc	r31, r21
    1566:	fb 83       	std	Y+3, r31	; 0x03
    1568:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    156a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    156c:	9d 83       	std	Y+5, r25	; 0x05
    156e:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1570:	42 1b       	sub	r20, r18
    1572:	53 0b       	sbc	r21, r19
    1574:	84 0f       	add	r24, r20
    1576:	95 1f       	adc	r25, r21
    1578:	9f 83       	std	Y+7, r25	; 0x07
    157a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    157c:	8f ef       	ldi	r24, 0xFF	; 255
    157e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1580:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1582:	61 11       	cpse	r22, r1
    1584:	0a c0       	rjmp	.+20     	; 0x159a <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1586:	88 85       	ldd	r24, Y+8	; 0x08
    1588:	88 23       	and	r24, r24
    158a:	69 f0       	breq	.+26     	; 0x15a6 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    158c:	ce 01       	movw	r24, r28
    158e:	08 96       	adiw	r24, 0x08	; 8
    1590:	cd d6       	rcall	.+3482   	; 0x232c <xTaskRemoveFromEventList>
    1592:	81 30       	cpi	r24, 0x01	; 1
    1594:	41 f4       	brne	.+16     	; 0x15a6 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1596:	4e de       	rcall	.-868    	; 0x1234 <vPortYield>
    1598:	06 c0       	rjmp	.+12     	; 0x15a6 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    159a:	ce 01       	movw	r24, r28
    159c:	08 96       	adiw	r24, 0x08	; 8
    159e:	16 d8       	rcall	.-4052   	; 0x5cc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    15a0:	ce 01       	movw	r24, r28
    15a2:	41 96       	adiw	r24, 0x11	; 17
    15a4:	13 d8       	rcall	.-4058   	; 0x5cc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    15a6:	0f 90       	pop	r0
    15a8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	08 95       	ret

000015b2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    15b2:	0f 93       	push	r16
    15b4:	1f 93       	push	r17
    15b6:	cf 93       	push	r28
    15b8:	df 93       	push	r29
    15ba:	18 2f       	mov	r17, r24
    15bc:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    15be:	88 23       	and	r24, r24
    15c0:	e9 f0       	breq	.+58     	; 0x15fc <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    15c2:	8f e1       	ldi	r24, 0x1F	; 31
    15c4:	90 e0       	ldi	r25, 0x00	; 0
    15c6:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    15ca:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    15cc:	00 97       	sbiw	r24, 0x00	; 0
    15ce:	c1 f0       	breq	.+48     	; 0x1600 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15d0:	10 9f       	mul	r17, r16
    15d2:	c0 01       	movw	r24, r0
    15d4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    15d6:	01 96       	adiw	r24, 0x01	; 1
    15d8:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    15dc:	99 83       	std	Y+1, r25	; 0x01
    15de:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    15e0:	89 2b       	or	r24, r25
    15e2:	31 f0       	breq	.+12     	; 0x15f0 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    15e4:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    15e6:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    15e8:	61 e0       	ldi	r22, 0x01	; 1
    15ea:	ce 01       	movw	r24, r28
    15ec:	a9 df       	rcall	.-174    	; 0x1540 <xQueueGenericReset>
    15ee:	08 c0       	rjmp	.+16     	; 0x1600 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    15f0:	ce 01       	movw	r24, r28
    15f2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    15f6:	c0 e0       	ldi	r28, 0x00	; 0
    15f8:	d0 e0       	ldi	r29, 0x00	; 0
    15fa:	02 c0       	rjmp	.+4      	; 0x1600 <xQueueGenericCreate+0x4e>
    15fc:	c0 e0       	ldi	r28, 0x00	; 0
    15fe:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1600:	ce 01       	movw	r24, r28
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	1f 91       	pop	r17
    1608:	0f 91       	pop	r16
    160a:	08 95       	ret

0000160c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    160c:	9f 92       	push	r9
    160e:	af 92       	push	r10
    1610:	bf 92       	push	r11
    1612:	cf 92       	push	r12
    1614:	df 92       	push	r13
    1616:	ef 92       	push	r14
    1618:	ff 92       	push	r15
    161a:	0f 93       	push	r16
    161c:	1f 93       	push	r17
    161e:	cf 93       	push	r28
    1620:	df 93       	push	r29
    1622:	00 d0       	rcall	.+0      	; 0x1624 <xQueueGenericSend+0x18>
    1624:	1f 92       	push	r1
    1626:	1f 92       	push	r1
    1628:	cd b7       	in	r28, 0x3d	; 61
    162a:	de b7       	in	r29, 0x3e	; 62
    162c:	8c 01       	movw	r16, r24
    162e:	6b 01       	movw	r12, r22
    1630:	5d 83       	std	Y+5, r21	; 0x05
    1632:	4c 83       	std	Y+4, r20	; 0x04
    1634:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1636:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1638:	99 24       	eor	r9, r9
    163a:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    163c:	7c 01       	movw	r14, r24
    163e:	88 e0       	ldi	r24, 0x08	; 8
    1640:	e8 0e       	add	r14, r24
    1642:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1644:	0f b6       	in	r0, 0x3f	; 63
    1646:	f8 94       	cli
    1648:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    164a:	f8 01       	movw	r30, r16
    164c:	92 8d       	ldd	r25, Z+26	; 0x1a
    164e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1650:	98 17       	cp	r25, r24
    1652:	18 f0       	brcs	.+6      	; 0x165a <xQueueGenericSend+0x4e>
    1654:	f2 e0       	ldi	r31, 0x02	; 2
    1656:	af 12       	cpse	r10, r31
    1658:	15 c0       	rjmp	.+42     	; 0x1684 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    165a:	4a 2d       	mov	r20, r10
    165c:	b6 01       	movw	r22, r12
    165e:	c8 01       	movw	r24, r16
    1660:	ad de       	rcall	.-678    	; 0x13bc <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1662:	f8 01       	movw	r30, r16
    1664:	91 89       	ldd	r25, Z+17	; 0x11
    1666:	99 23       	and	r25, r25
    1668:	39 f0       	breq	.+14     	; 0x1678 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    166a:	c8 01       	movw	r24, r16
    166c:	41 96       	adiw	r24, 0x11	; 17
    166e:	5e d6       	rcall	.+3260   	; 0x232c <xTaskRemoveFromEventList>
    1670:	81 30       	cpi	r24, 0x01	; 1
    1672:	21 f4       	brne	.+8      	; 0x167c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1674:	df dd       	rcall	.-1090   	; 0x1234 <vPortYield>
    1676:	02 c0       	rjmp	.+4      	; 0x167c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1678:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    167a:	dc dd       	rcall	.-1096   	; 0x1234 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	46 c0       	rjmp	.+140    	; 0x1710 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1684:	ec 81       	ldd	r30, Y+4	; 0x04
    1686:	fd 81       	ldd	r31, Y+5	; 0x05
    1688:	ef 2b       	or	r30, r31
    168a:	21 f4       	brne	.+8      	; 0x1694 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    168c:	0f 90       	pop	r0
    168e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	3e c0       	rjmp	.+124    	; 0x1710 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1694:	b1 10       	cpse	r11, r1
    1696:	04 c0       	rjmp	.+8      	; 0x16a0 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1698:	ce 01       	movw	r24, r28
    169a:	01 96       	adiw	r24, 0x01	; 1
    169c:	8f d6       	rcall	.+3358   	; 0x23bc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    169e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16a4:	86 d3       	rcall	.+1804   	; 0x1db2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	0f 92       	push	r0
    16ac:	f8 01       	movw	r30, r16
    16ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    16b0:	8f 3f       	cpi	r24, 0xFF	; 255
    16b2:	09 f4       	brne	.+2      	; 0x16b6 <xQueueGenericSend+0xaa>
    16b4:	15 8e       	std	Z+29, r1	; 0x1d
    16b6:	f8 01       	movw	r30, r16
    16b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    16ba:	8f 3f       	cpi	r24, 0xFF	; 255
    16bc:	09 f4       	brne	.+2      	; 0x16c0 <xQueueGenericSend+0xb4>
    16be:	16 8e       	std	Z+30, r1	; 0x1e
    16c0:	0f 90       	pop	r0
    16c2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16c4:	be 01       	movw	r22, r28
    16c6:	6c 5f       	subi	r22, 0xFC	; 252
    16c8:	7f 4f       	sbci	r23, 0xFF	; 255
    16ca:	ce 01       	movw	r24, r28
    16cc:	01 96       	adiw	r24, 0x01	; 1
    16ce:	81 d6       	rcall	.+3330   	; 0x23d2 <xTaskCheckForTimeOut>
    16d0:	81 11       	cpse	r24, r1
    16d2:	1a c0       	rjmp	.+52     	; 0x1708 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    16d4:	0f b6       	in	r0, 0x3f	; 63
    16d6:	f8 94       	cli
    16d8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    16da:	f8 01       	movw	r30, r16
    16dc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16e2:	f8 01       	movw	r30, r16
    16e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    16e6:	98 13       	cpse	r25, r24
    16e8:	0b c0       	rjmp	.+22     	; 0x1700 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16ea:	6c 81       	ldd	r22, Y+4	; 0x04
    16ec:	7d 81       	ldd	r23, Y+5	; 0x05
    16ee:	c7 01       	movw	r24, r14
    16f0:	f2 d5       	rcall	.+3044   	; 0x22d6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16f2:	c8 01       	movw	r24, r16
    16f4:	df de       	rcall	.-578    	; 0x14b4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    16f6:	30 d4       	rcall	.+2144   	; 0x1f58 <xTaskResumeAll>
    16f8:	81 11       	cpse	r24, r1
    16fa:	a4 cf       	rjmp	.-184    	; 0x1644 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    16fc:	9b dd       	rcall	.-1226   	; 0x1234 <vPortYield>
    16fe:	a2 cf       	rjmp	.-188    	; 0x1644 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1700:	c8 01       	movw	r24, r16
    1702:	d8 de       	rcall	.-592    	; 0x14b4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1704:	29 d4       	rcall	.+2130   	; 0x1f58 <xTaskResumeAll>
    1706:	9e cf       	rjmp	.-196    	; 0x1644 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1708:	c8 01       	movw	r24, r16
    170a:	d4 de       	rcall	.-600    	; 0x14b4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    170c:	25 d4       	rcall	.+2122   	; 0x1f58 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    170e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1710:	0f 90       	pop	r0
    1712:	0f 90       	pop	r0
    1714:	0f 90       	pop	r0
    1716:	0f 90       	pop	r0
    1718:	0f 90       	pop	r0
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	1f 91       	pop	r17
    1720:	0f 91       	pop	r16
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	bf 90       	pop	r11
    172c:	af 90       	pop	r10
    172e:	9f 90       	pop	r9
    1730:	08 95       	ret

00001732 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1736:	8f e1       	ldi	r24, 0x1F	; 31
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    173e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1740:	00 97       	sbiw	r24, 0x00	; 0
    1742:	f1 f0       	breq	.+60     	; 0x1780 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1744:	1b 82       	std	Y+3, r1	; 0x03
    1746:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1748:	19 82       	std	Y+1, r1	; 0x01
    174a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    174c:	1d 82       	std	Y+5, r1	; 0x05
    174e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1750:	1f 82       	std	Y+7, r1	; 0x07
    1752:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1754:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    175a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    175c:	8f ef       	ldi	r24, 0xFF	; 255
    175e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1760:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1762:	ce 01       	movw	r24, r28
    1764:	08 96       	adiw	r24, 0x08	; 8
    1766:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    176a:	ce 01       	movw	r24, r28
    176c:	41 96       	adiw	r24, 0x11	; 17
    176e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1772:	20 e0       	ldi	r18, 0x00	; 0
    1774:	40 e0       	ldi	r20, 0x00	; 0
    1776:	50 e0       	ldi	r21, 0x00	; 0
    1778:	60 e0       	ldi	r22, 0x00	; 0
    177a:	70 e0       	ldi	r23, 0x00	; 0
    177c:	ce 01       	movw	r24, r28
    177e:	46 df       	rcall	.-372    	; 0x160c <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1780:	ce 01       	movw	r24, r28
    1782:	df 91       	pop	r29
    1784:	cf 91       	pop	r28
    1786:	08 95       	ret

00001788 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1788:	0f 93       	push	r16
    178a:	1f 93       	push	r17
    178c:	cf 93       	push	r28
    178e:	df 93       	push	r29
    1790:	ec 01       	movw	r28, r24
    1792:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1794:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1796:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1798:	98 17       	cp	r25, r24
    179a:	10 f0       	brcs	.+4      	; 0x17a0 <xQueueGenericSendFromISR+0x18>
    179c:	22 30       	cpi	r18, 0x02	; 2
    179e:	11 f5       	brne	.+68     	; 0x17e4 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    17a0:	42 2f       	mov	r20, r18
    17a2:	ce 01       	movw	r24, r28
    17a4:	0b de       	rcall	.-1002   	; 0x13bc <prvCopyDataToQueue>
    17a6:	88 23       	and	r24, r24
    17a8:	31 f0       	breq	.+12     	; 0x17b6 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    17aa:	01 15       	cp	r16, r1
    17ac:	11 05       	cpc	r17, r1
    17ae:	19 f0       	breq	.+6      	; 0x17b6 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	f8 01       	movw	r30, r16
    17b4:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    17b6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17b8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ba:	79 f4       	brne	.+30     	; 0x17da <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17bc:	89 89       	ldd	r24, Y+17	; 0x11
    17be:	88 23       	and	r24, r24
    17c0:	99 f0       	breq	.+38     	; 0x17e8 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17c2:	ce 01       	movw	r24, r28
    17c4:	41 96       	adiw	r24, 0x11	; 17
    17c6:	b2 d5       	rcall	.+2916   	; 0x232c <xTaskRemoveFromEventList>
    17c8:	88 23       	and	r24, r24
    17ca:	81 f0       	breq	.+32     	; 0x17ec <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    17cc:	01 15       	cp	r16, r1
    17ce:	11 05       	cpc	r17, r1
    17d0:	79 f0       	breq	.+30     	; 0x17f0 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    17d2:	81 e0       	ldi	r24, 0x01	; 1
    17d4:	f8 01       	movw	r30, r16
    17d6:	80 83       	st	Z, r24
    17d8:	0c c0       	rjmp	.+24     	; 0x17f2 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17dc:	8f 5f       	subi	r24, 0xFF	; 255
    17de:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    17e0:	81 e0       	ldi	r24, 0x01	; 1
    17e2:	07 c0       	rjmp	.+14     	; 0x17f2 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17e4:	80 e0       	ldi	r24, 0x00	; 0
    17e6:	05 c0       	rjmp	.+10     	; 0x17f2 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    17e8:	81 e0       	ldi	r24, 0x01	; 1
    17ea:	03 c0       	rjmp	.+6      	; 0x17f2 <xQueueGenericSendFromISR+0x6a>
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	01 c0       	rjmp	.+2      	; 0x17f2 <xQueueGenericSendFromISR+0x6a>
    17f0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17f2:	df 91       	pop	r29
    17f4:	cf 91       	pop	r28
    17f6:	1f 91       	pop	r17
    17f8:	0f 91       	pop	r16
    17fa:	08 95       	ret

000017fc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    17fc:	9f 92       	push	r9
    17fe:	af 92       	push	r10
    1800:	bf 92       	push	r11
    1802:	cf 92       	push	r12
    1804:	df 92       	push	r13
    1806:	ef 92       	push	r14
    1808:	ff 92       	push	r15
    180a:	0f 93       	push	r16
    180c:	1f 93       	push	r17
    180e:	cf 93       	push	r28
    1810:	df 93       	push	r29
    1812:	00 d0       	rcall	.+0      	; 0x1814 <xQueueGenericReceive+0x18>
    1814:	1f 92       	push	r1
    1816:	1f 92       	push	r1
    1818:	cd b7       	in	r28, 0x3d	; 61
    181a:	de b7       	in	r29, 0x3e	; 62
    181c:	8c 01       	movw	r16, r24
    181e:	6b 01       	movw	r12, r22
    1820:	5d 83       	std	Y+5, r21	; 0x05
    1822:	4c 83       	std	Y+4, r20	; 0x04
    1824:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1826:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1828:	99 24       	eor	r9, r9
    182a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    182c:	7c 01       	movw	r14, r24
    182e:	81 e1       	ldi	r24, 0x11	; 17
    1830:	e8 0e       	add	r14, r24
    1832:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    183a:	f8 01       	movw	r30, r16
    183c:	82 8d       	ldd	r24, Z+26	; 0x1a
    183e:	88 23       	and	r24, r24
    1840:	69 f1       	breq	.+90     	; 0x189c <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1842:	e6 80       	ldd	r14, Z+6	; 0x06
    1844:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1846:	b6 01       	movw	r22, r12
    1848:	c8 01       	movw	r24, r16
    184a:	1a de       	rcall	.-972    	; 0x1480 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    184c:	b1 10       	cpse	r11, r1
    184e:	17 c0       	rjmp	.+46     	; 0x187e <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1850:	f8 01       	movw	r30, r16
    1852:	82 8d       	ldd	r24, Z+26	; 0x1a
    1854:	81 50       	subi	r24, 0x01	; 1
    1856:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1858:	80 81       	ld	r24, Z
    185a:	91 81       	ldd	r25, Z+1	; 0x01
    185c:	89 2b       	or	r24, r25
    185e:	21 f4       	brne	.+8      	; 0x1868 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1860:	91 d6       	rcall	.+3362   	; 0x2584 <pvTaskIncrementMutexHeldCount>
    1862:	f8 01       	movw	r30, r16
    1864:	93 83       	std	Z+3, r25	; 0x03
    1866:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1868:	f8 01       	movw	r30, r16
    186a:	80 85       	ldd	r24, Z+8	; 0x08
    186c:	88 23       	and	r24, r24
    186e:	91 f0       	breq	.+36     	; 0x1894 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1870:	c8 01       	movw	r24, r16
    1872:	08 96       	adiw	r24, 0x08	; 8
    1874:	5b d5       	rcall	.+2742   	; 0x232c <xTaskRemoveFromEventList>
    1876:	81 30       	cpi	r24, 0x01	; 1
    1878:	69 f4       	brne	.+26     	; 0x1894 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    187a:	dc dc       	rcall	.-1608   	; 0x1234 <vPortYield>
    187c:	0b c0       	rjmp	.+22     	; 0x1894 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    187e:	f8 01       	movw	r30, r16
    1880:	f7 82       	std	Z+7, r15	; 0x07
    1882:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1884:	81 89       	ldd	r24, Z+17	; 0x11
    1886:	88 23       	and	r24, r24
    1888:	29 f0       	breq	.+10     	; 0x1894 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    188a:	c8 01       	movw	r24, r16
    188c:	41 96       	adiw	r24, 0x11	; 17
    188e:	4e d5       	rcall	.+2716   	; 0x232c <xTaskRemoveFromEventList>
    1890:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1892:	d0 dc       	rcall	.-1632   	; 0x1234 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1894:	0f 90       	pop	r0
    1896:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1898:	81 e0       	ldi	r24, 0x01	; 1
    189a:	52 c0       	rjmp	.+164    	; 0x1940 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    189c:	4c 81       	ldd	r20, Y+4	; 0x04
    189e:	5d 81       	ldd	r21, Y+5	; 0x05
    18a0:	45 2b       	or	r20, r21
    18a2:	21 f4       	brne	.+8      	; 0x18ac <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18a4:	0f 90       	pop	r0
    18a6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    18a8:	80 e0       	ldi	r24, 0x00	; 0
    18aa:	4a c0       	rjmp	.+148    	; 0x1940 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    18ac:	a1 10       	cpse	r10, r1
    18ae:	04 c0       	rjmp	.+8      	; 0x18b8 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18b0:	ce 01       	movw	r24, r28
    18b2:	01 96       	adiw	r24, 0x01	; 1
    18b4:	83 d5       	rcall	.+2822   	; 0x23bc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18b6:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18b8:	0f 90       	pop	r0
    18ba:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18bc:	7a d2       	rcall	.+1268   	; 0x1db2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18be:	0f b6       	in	r0, 0x3f	; 63
    18c0:	f8 94       	cli
    18c2:	0f 92       	push	r0
    18c4:	f8 01       	movw	r30, r16
    18c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    18c8:	8f 3f       	cpi	r24, 0xFF	; 255
    18ca:	09 f4       	brne	.+2      	; 0x18ce <xQueueGenericReceive+0xd2>
    18cc:	15 8e       	std	Z+29, r1	; 0x1d
    18ce:	f8 01       	movw	r30, r16
    18d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    18d2:	8f 3f       	cpi	r24, 0xFF	; 255
    18d4:	09 f4       	brne	.+2      	; 0x18d8 <xQueueGenericReceive+0xdc>
    18d6:	16 8e       	std	Z+30, r1	; 0x1e
    18d8:	0f 90       	pop	r0
    18da:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18dc:	be 01       	movw	r22, r28
    18de:	6c 5f       	subi	r22, 0xFC	; 252
    18e0:	7f 4f       	sbci	r23, 0xFF	; 255
    18e2:	ce 01       	movw	r24, r28
    18e4:	01 96       	adiw	r24, 0x01	; 1
    18e6:	75 d5       	rcall	.+2794   	; 0x23d2 <xTaskCheckForTimeOut>
    18e8:	81 11       	cpse	r24, r1
    18ea:	26 c0       	rjmp	.+76     	; 0x1938 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18ec:	0f b6       	in	r0, 0x3f	; 63
    18ee:	f8 94       	cli
    18f0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    18f2:	f8 01       	movw	r30, r16
    18f4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18f6:	0f 90       	pop	r0
    18f8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18fa:	81 11       	cpse	r24, r1
    18fc:	19 c0       	rjmp	.+50     	; 0x1930 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18fe:	f8 01       	movw	r30, r16
    1900:	80 81       	ld	r24, Z
    1902:	91 81       	ldd	r25, Z+1	; 0x01
    1904:	89 2b       	or	r24, r25
    1906:	49 f4       	brne	.+18     	; 0x191a <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    190e:	f8 01       	movw	r30, r16
    1910:	82 81       	ldd	r24, Z+2	; 0x02
    1912:	93 81       	ldd	r25, Z+3	; 0x03
    1914:	9a d5       	rcall	.+2868   	; 0x244a <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1916:	0f 90       	pop	r0
    1918:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    191a:	6c 81       	ldd	r22, Y+4	; 0x04
    191c:	7d 81       	ldd	r23, Y+5	; 0x05
    191e:	c7 01       	movw	r24, r14
    1920:	da d4       	rcall	.+2484   	; 0x22d6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1922:	c8 01       	movw	r24, r16
    1924:	c7 dd       	rcall	.-1138   	; 0x14b4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1926:	18 d3       	rcall	.+1584   	; 0x1f58 <xTaskResumeAll>
    1928:	81 11       	cpse	r24, r1
    192a:	84 cf       	rjmp	.-248    	; 0x1834 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    192c:	83 dc       	rcall	.-1786   	; 0x1234 <vPortYield>
    192e:	82 cf       	rjmp	.-252    	; 0x1834 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1930:	c8 01       	movw	r24, r16
    1932:	c0 dd       	rcall	.-1152   	; 0x14b4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1934:	11 d3       	rcall	.+1570   	; 0x1f58 <xTaskResumeAll>
    1936:	7e cf       	rjmp	.-260    	; 0x1834 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1938:	c8 01       	movw	r24, r16
    193a:	bc dd       	rcall	.-1160   	; 0x14b4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    193c:	0d d3       	rcall	.+1562   	; 0x1f58 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    193e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1940:	0f 90       	pop	r0
    1942:	0f 90       	pop	r0
    1944:	0f 90       	pop	r0
    1946:	0f 90       	pop	r0
    1948:	0f 90       	pop	r0
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	1f 91       	pop	r17
    1950:	0f 91       	pop	r16
    1952:	ff 90       	pop	r15
    1954:	ef 90       	pop	r14
    1956:	df 90       	pop	r13
    1958:	cf 90       	pop	r12
    195a:	bf 90       	pop	r11
    195c:	af 90       	pop	r10
    195e:	9f 90       	pop	r9
    1960:	08 95       	ret

00001962 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1962:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1964:	71 83       	std	Z+1, r23	; 0x01
    1966:	60 83       	st	Z, r22
	ring->rSize = size;
    1968:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    196a:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    196c:	13 82       	std	Z+3, r1	; 0x03
    196e:	08 95       	ret

00001970 <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1970:	dc 01       	movw	r26, r24
    1972:	14 96       	adiw	r26, 0x04	; 4
    1974:	2c 91       	ld	r18, X
    1976:	14 97       	sbiw	r26, 0x04	; 4
    1978:	ed 91       	ld	r30, X+
    197a:	fc 91       	ld	r31, X
    197c:	e2 0f       	add	r30, r18
    197e:	f1 1d       	adc	r31, r1
}
    1980:	80 81       	ld	r24, Z
    1982:	08 95       	ret

00001984 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1984:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1986:	94 81       	ldd	r25, Z+4	; 0x04
    1988:	a0 81       	ld	r26, Z
    198a:	b1 81       	ldd	r27, Z+1	; 0x01
    198c:	a9 0f       	add	r26, r25
    198e:	b1 1d       	adc	r27, r1
    1990:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1992:	9f 5f       	subi	r25, 0xFF	; 255
    1994:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1996:	22 81       	ldd	r18, Z+2	; 0x02
    1998:	92 17       	cp	r25, r18
    199a:	10 f0       	brcs	.+4      	; 0x19a0 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    199c:	92 1b       	sub	r25, r18
    199e:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    19a0:	93 81       	ldd	r25, Z+3	; 0x03
    19a2:	91 50       	subi	r25, 0x01	; 1
    19a4:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    19a6:	08 95       	ret

000019a8 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    19a8:	fc 01       	movw	r30, r24
    19aa:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    19ac:	83 81       	ldd	r24, Z+3	; 0x03
    19ae:	22 81       	ldd	r18, Z+2	; 0x02
    19b0:	82 17       	cp	r24, r18
    19b2:	80 f4       	brcc	.+32     	; 0x19d4 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    19b4:	34 81       	ldd	r19, Z+4	; 0x04
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	83 0f       	add	r24, r19
    19ba:	91 1d       	adc	r25, r1
    19bc:	62 2f       	mov	r22, r18
    19be:	70 e0       	ldi	r23, 0x00	; 0
    19c0:	0e 94 28 16 	call	0x2c50	; 0x2c50 <__divmodhi4>
    19c4:	a0 81       	ld	r26, Z
    19c6:	b1 81       	ldd	r27, Z+1	; 0x01
    19c8:	a8 0f       	add	r26, r24
    19ca:	b9 1f       	adc	r27, r25
    19cc:	4c 93       	st	X, r20
            ring->rLength++;
    19ce:	83 81       	ldd	r24, Z+3	; 0x03
    19d0:	8f 5f       	subi	r24, 0xFF	; 255
    19d2:	83 83       	std	Z+3, r24	; 0x03
    19d4:	08 95       	ret

000019d6 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    19d6:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	22 81       	ldd	r18, Z+2	; 0x02
    19dc:	93 81       	ldd	r25, Z+3	; 0x03
    19de:	29 13       	cpse	r18, r25
    19e0:	80 e0       	ldi	r24, 0x00	; 0
}
    19e2:	08 95       	ret

000019e4 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    19e4:	21 e0       	ldi	r18, 0x01	; 1
    19e6:	fc 01       	movw	r30, r24
    19e8:	83 81       	ldd	r24, Z+3	; 0x03
    19ea:	81 11       	cpse	r24, r1
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <ringBufferNotEmpty+0xc>
    19ee:	20 e0       	ldi	r18, 0x00	; 0
}
    19f0:	82 2f       	mov	r24, r18
    19f2:	08 95       	ret

000019f4 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    19f4:	e0 91 4c 08 	lds	r30, 0x084C
    19f8:	f0 91 4d 08 	lds	r31, 0x084D
    19fc:	80 81       	ld	r24, Z
    19fe:	81 11       	cpse	r24, r1
    1a00:	07 c0       	rjmp	.+14     	; 0x1a10 <prvResetNextTaskUnblockTime+0x1c>
    1a02:	8f ef       	ldi	r24, 0xFF	; 255
    1a04:	9f ef       	ldi	r25, 0xFF	; 255
    1a06:	90 93 05 02 	sts	0x0205, r25
    1a0a:	80 93 04 02 	sts	0x0204, r24
    1a0e:	08 95       	ret
    1a10:	e0 91 4c 08 	lds	r30, 0x084C
    1a14:	f0 91 4d 08 	lds	r31, 0x084D
    1a18:	05 80       	ldd	r0, Z+5	; 0x05
    1a1a:	f6 81       	ldd	r31, Z+6	; 0x06
    1a1c:	e0 2d       	mov	r30, r0
    1a1e:	06 80       	ldd	r0, Z+6	; 0x06
    1a20:	f7 81       	ldd	r31, Z+7	; 0x07
    1a22:	e0 2d       	mov	r30, r0
    1a24:	82 81       	ldd	r24, Z+2	; 0x02
    1a26:	93 81       	ldd	r25, Z+3	; 0x03
    1a28:	90 93 05 02 	sts	0x0205, r25
    1a2c:	80 93 04 02 	sts	0x0204, r24
    1a30:	08 95       	ret

00001a32 <prvAddCurrentTaskToDelayedList>:
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
    1a36:	ec 01       	movw	r28, r24
    1a38:	e0 91 8d 08 	lds	r30, 0x088D
    1a3c:	f0 91 8e 08 	lds	r31, 0x088E
    1a40:	93 83       	std	Z+3, r25	; 0x03
    1a42:	82 83       	std	Z+2, r24	; 0x02
    1a44:	80 91 2b 08 	lds	r24, 0x082B
    1a48:	90 91 2c 08 	lds	r25, 0x082C
    1a4c:	c8 17       	cp	r28, r24
    1a4e:	d9 07       	cpc	r29, r25
    1a50:	68 f4       	brcc	.+26     	; 0x1a6c <prvAddCurrentTaskToDelayedList+0x3a>
    1a52:	60 91 8d 08 	lds	r22, 0x088D
    1a56:	70 91 8e 08 	lds	r23, 0x088E
    1a5a:	80 91 4a 08 	lds	r24, 0x084A
    1a5e:	90 91 4b 08 	lds	r25, 0x084B
    1a62:	6e 5f       	subi	r22, 0xFE	; 254
    1a64:	7f 4f       	sbci	r23, 0xFF	; 255
    1a66:	0e 94 19 03 	call	0x632	; 0x632 <vListInsert>
    1a6a:	17 c0       	rjmp	.+46     	; 0x1a9a <prvAddCurrentTaskToDelayedList+0x68>
    1a6c:	60 91 8d 08 	lds	r22, 0x088D
    1a70:	70 91 8e 08 	lds	r23, 0x088E
    1a74:	80 91 4c 08 	lds	r24, 0x084C
    1a78:	90 91 4d 08 	lds	r25, 0x084D
    1a7c:	6e 5f       	subi	r22, 0xFE	; 254
    1a7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a80:	0e 94 19 03 	call	0x632	; 0x632 <vListInsert>
    1a84:	80 91 04 02 	lds	r24, 0x0204
    1a88:	90 91 05 02 	lds	r25, 0x0205
    1a8c:	c8 17       	cp	r28, r24
    1a8e:	d9 07       	cpc	r29, r25
    1a90:	20 f4       	brcc	.+8      	; 0x1a9a <prvAddCurrentTaskToDelayedList+0x68>
    1a92:	d0 93 05 02 	sts	0x0205, r29
    1a96:	c0 93 04 02 	sts	0x0204, r28
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	08 95       	ret

00001aa0 <xTaskGenericCreate>:
    1aa0:	4f 92       	push	r4
    1aa2:	5f 92       	push	r5
    1aa4:	6f 92       	push	r6
    1aa6:	7f 92       	push	r7
    1aa8:	8f 92       	push	r8
    1aaa:	9f 92       	push	r9
    1aac:	af 92       	push	r10
    1aae:	bf 92       	push	r11
    1ab0:	cf 92       	push	r12
    1ab2:	df 92       	push	r13
    1ab4:	ef 92       	push	r14
    1ab6:	ff 92       	push	r15
    1ab8:	0f 93       	push	r16
    1aba:	1f 93       	push	r17
    1abc:	cf 93       	push	r28
    1abe:	df 93       	push	r29
    1ac0:	4c 01       	movw	r8, r24
    1ac2:	5b 01       	movw	r10, r22
    1ac4:	2a 01       	movw	r4, r20
    1ac6:	39 01       	movw	r6, r18
    1ac8:	83 e2       	ldi	r24, 0x23	; 35
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    1ad0:	ec 01       	movw	r28, r24
    1ad2:	00 97       	sbiw	r24, 0x00	; 0
    1ad4:	09 f4       	brne	.+2      	; 0x1ad8 <xTaskGenericCreate+0x38>
    1ad6:	e7 c0       	rjmp	.+462    	; 0x1ca6 <xTaskGenericCreate+0x206>
    1ad8:	c1 14       	cp	r12, r1
    1ada:	d1 04       	cpc	r13, r1
    1adc:	09 f0       	breq	.+2      	; 0x1ae0 <xTaskGenericCreate+0x40>
    1ade:	cc c0       	rjmp	.+408    	; 0x1c78 <xTaskGenericCreate+0x1d8>
    1ae0:	c2 01       	movw	r24, r4
    1ae2:	0e 94 b0 02 	call	0x560	; 0x560 <pvPortMalloc>
    1ae6:	98 8f       	std	Y+24, r25	; 0x18
    1ae8:	8f 8b       	std	Y+23, r24	; 0x17
    1aea:	89 2b       	or	r24, r25
    1aec:	09 f0       	breq	.+2      	; 0x1af0 <xTaskGenericCreate+0x50>
    1aee:	c6 c0       	rjmp	.+396    	; 0x1c7c <xTaskGenericCreate+0x1dc>
    1af0:	ce 01       	movw	r24, r28
    1af2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
    1af6:	d7 c0       	rjmp	.+430    	; 0x1ca6 <xTaskGenericCreate+0x206>
    1af8:	cf 01       	movw	r24, r30
    1afa:	31 91       	ld	r19, Z+
    1afc:	da 01       	movw	r26, r20
    1afe:	3d 93       	st	X+, r19
    1b00:	ad 01       	movw	r20, r26
    1b02:	dc 01       	movw	r26, r24
    1b04:	8c 91       	ld	r24, X
    1b06:	88 23       	and	r24, r24
    1b08:	11 f0       	breq	.+4      	; 0x1b0e <xTaskGenericCreate+0x6e>
    1b0a:	21 50       	subi	r18, 0x01	; 1
    1b0c:	a9 f7       	brne	.-22     	; 0x1af8 <xTaskGenericCreate+0x58>
    1b0e:	18 a2       	std	Y+32, r1	; 0x20
    1b10:	10 2f       	mov	r17, r16
    1b12:	05 30       	cpi	r16, 0x05	; 5
    1b14:	08 f0       	brcs	.+2      	; 0x1b18 <xTaskGenericCreate+0x78>
    1b16:	14 e0       	ldi	r17, 0x04	; 4
    1b18:	1e 8b       	std	Y+22, r17	; 0x16
    1b1a:	19 a3       	std	Y+33, r17	; 0x21
    1b1c:	1a a2       	std	Y+34, r1	; 0x22
    1b1e:	5e 01       	movw	r10, r28
    1b20:	b2 e0       	ldi	r27, 0x02	; 2
    1b22:	ab 0e       	add	r10, r27
    1b24:	b1 1c       	adc	r11, r1
    1b26:	c5 01       	movw	r24, r10
    1b28:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vListInitialiseItem>
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	0c 96       	adiw	r24, 0x0c	; 12
    1b30:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vListInitialiseItem>
    1b34:	d9 87       	std	Y+9, r29	; 0x09
    1b36:	c8 87       	std	Y+8, r28	; 0x08
    1b38:	85 e0       	ldi	r24, 0x05	; 5
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	81 1b       	sub	r24, r17
    1b3e:	91 09       	sbc	r25, r1
    1b40:	9d 87       	std	Y+13, r25	; 0x0d
    1b42:	8c 87       	std	Y+12, r24	; 0x0c
    1b44:	db 8b       	std	Y+19, r29	; 0x13
    1b46:	ca 8b       	std	Y+18, r28	; 0x12
    1b48:	a3 01       	movw	r20, r6
    1b4a:	b4 01       	movw	r22, r8
    1b4c:	c6 01       	movw	r24, r12
    1b4e:	c3 da       	rcall	.-2682   	; 0x10d6 <pxPortInitialiseStack>
    1b50:	99 83       	std	Y+1, r25	; 0x01
    1b52:	88 83       	st	Y, r24
    1b54:	e1 14       	cp	r14, r1
    1b56:	f1 04       	cpc	r15, r1
    1b58:	19 f0       	breq	.+6      	; 0x1b60 <xTaskGenericCreate+0xc0>
    1b5a:	f7 01       	movw	r30, r14
    1b5c:	d1 83       	std	Z+1, r29	; 0x01
    1b5e:	c0 83       	st	Z, r28
    1b60:	0f b6       	in	r0, 0x3f	; 63
    1b62:	f8 94       	cli
    1b64:	0f 92       	push	r0
    1b66:	80 91 2d 08 	lds	r24, 0x082D
    1b6a:	8f 5f       	subi	r24, 0xFF	; 255
    1b6c:	80 93 2d 08 	sts	0x082D, r24
    1b70:	80 91 8d 08 	lds	r24, 0x088D
    1b74:	90 91 8e 08 	lds	r25, 0x088E
    1b78:	89 2b       	or	r24, r25
    1b7a:	09 f0       	breq	.+2      	; 0x1b7e <xTaskGenericCreate+0xde>
    1b7c:	3f c0       	rjmp	.+126    	; 0x1bfc <xTaskGenericCreate+0x15c>
    1b7e:	d0 93 8e 08 	sts	0x088E, r29
    1b82:	c0 93 8d 08 	sts	0x088D, r28
    1b86:	80 91 2d 08 	lds	r24, 0x082D
    1b8a:	81 30       	cpi	r24, 0x01	; 1
    1b8c:	09 f0       	breq	.+2      	; 0x1b90 <xTaskGenericCreate+0xf0>
    1b8e:	45 c0       	rjmp	.+138    	; 0x1c1a <xTaskGenericCreate+0x17a>
    1b90:	0f 2e       	mov	r0, r31
    1b92:	f0 e6       	ldi	r31, 0x60	; 96
    1b94:	ef 2e       	mov	r14, r31
    1b96:	f8 e0       	ldi	r31, 0x08	; 8
    1b98:	ff 2e       	mov	r15, r31
    1b9a:	f0 2d       	mov	r31, r0
    1b9c:	0f 2e       	mov	r0, r31
    1b9e:	fd e8       	ldi	r31, 0x8D	; 141
    1ba0:	cf 2e       	mov	r12, r31
    1ba2:	f8 e0       	ldi	r31, 0x08	; 8
    1ba4:	df 2e       	mov	r13, r31
    1ba6:	f0 2d       	mov	r31, r0
    1ba8:	c7 01       	movw	r24, r14
    1baa:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1bae:	f9 e0       	ldi	r31, 0x09	; 9
    1bb0:	ef 0e       	add	r14, r31
    1bb2:	f1 1c       	adc	r15, r1
    1bb4:	ec 14       	cp	r14, r12
    1bb6:	fd 04       	cpc	r15, r13
    1bb8:	b9 f7       	brne	.-18     	; 0x1ba8 <xTaskGenericCreate+0x108>
    1bba:	87 e5       	ldi	r24, 0x57	; 87
    1bbc:	98 e0       	ldi	r25, 0x08	; 8
    1bbe:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1bc2:	8e e4       	ldi	r24, 0x4E	; 78
    1bc4:	98 e0       	ldi	r25, 0x08	; 8
    1bc6:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1bca:	81 e4       	ldi	r24, 0x41	; 65
    1bcc:	98 e0       	ldi	r25, 0x08	; 8
    1bce:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1bd2:	88 e3       	ldi	r24, 0x38	; 56
    1bd4:	98 e0       	ldi	r25, 0x08	; 8
    1bd6:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1bda:	8e e2       	ldi	r24, 0x2E	; 46
    1bdc:	98 e0       	ldi	r25, 0x08	; 8
    1bde:	0e 94 e6 02 	call	0x5cc	; 0x5cc <vListInitialise>
    1be2:	87 e5       	ldi	r24, 0x57	; 87
    1be4:	98 e0       	ldi	r25, 0x08	; 8
    1be6:	90 93 4d 08 	sts	0x084D, r25
    1bea:	80 93 4c 08 	sts	0x084C, r24
    1bee:	8e e4       	ldi	r24, 0x4E	; 78
    1bf0:	98 e0       	ldi	r25, 0x08	; 8
    1bf2:	90 93 4b 08 	sts	0x084B, r25
    1bf6:	80 93 4a 08 	sts	0x084A, r24
    1bfa:	0f c0       	rjmp	.+30     	; 0x1c1a <xTaskGenericCreate+0x17a>
    1bfc:	80 91 29 08 	lds	r24, 0x0829
    1c00:	81 11       	cpse	r24, r1
    1c02:	0b c0       	rjmp	.+22     	; 0x1c1a <xTaskGenericCreate+0x17a>
    1c04:	e0 91 8d 08 	lds	r30, 0x088D
    1c08:	f0 91 8e 08 	lds	r31, 0x088E
    1c0c:	86 89       	ldd	r24, Z+22	; 0x16
    1c0e:	08 17       	cp	r16, r24
    1c10:	20 f0       	brcs	.+8      	; 0x1c1a <xTaskGenericCreate+0x17a>
    1c12:	d0 93 8e 08 	sts	0x088E, r29
    1c16:	c0 93 8d 08 	sts	0x088D, r28
    1c1a:	80 91 25 08 	lds	r24, 0x0825
    1c1e:	8f 5f       	subi	r24, 0xFF	; 255
    1c20:	80 93 25 08 	sts	0x0825, r24
    1c24:	8e 89       	ldd	r24, Y+22	; 0x16
    1c26:	90 91 2a 08 	lds	r25, 0x082A
    1c2a:	98 17       	cp	r25, r24
    1c2c:	10 f4       	brcc	.+4      	; 0x1c32 <xTaskGenericCreate+0x192>
    1c2e:	80 93 2a 08 	sts	0x082A, r24
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	9c 01       	movw	r18, r24
    1c36:	22 0f       	add	r18, r18
    1c38:	33 1f       	adc	r19, r19
    1c3a:	22 0f       	add	r18, r18
    1c3c:	33 1f       	adc	r19, r19
    1c3e:	22 0f       	add	r18, r18
    1c40:	33 1f       	adc	r19, r19
    1c42:	82 0f       	add	r24, r18
    1c44:	93 1f       	adc	r25, r19
    1c46:	b5 01       	movw	r22, r10
    1c48:	80 5a       	subi	r24, 0xA0	; 160
    1c4a:	97 4f       	sbci	r25, 0xF7	; 247
    1c4c:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    1c50:	0f 90       	pop	r0
    1c52:	0f be       	out	0x3f, r0	; 63
    1c54:	80 91 29 08 	lds	r24, 0x0829
    1c58:	88 23       	and	r24, r24
    1c5a:	51 f0       	breq	.+20     	; 0x1c70 <xTaskGenericCreate+0x1d0>
    1c5c:	e0 91 8d 08 	lds	r30, 0x088D
    1c60:	f0 91 8e 08 	lds	r31, 0x088E
    1c64:	86 89       	ldd	r24, Z+22	; 0x16
    1c66:	80 17       	cp	r24, r16
    1c68:	28 f4       	brcc	.+10     	; 0x1c74 <xTaskGenericCreate+0x1d4>
    1c6a:	e4 da       	rcall	.-2616   	; 0x1234 <vPortYield>
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	1c c0       	rjmp	.+56     	; 0x1ca8 <xTaskGenericCreate+0x208>
    1c70:	81 e0       	ldi	r24, 0x01	; 1
    1c72:	1a c0       	rjmp	.+52     	; 0x1ca8 <xTaskGenericCreate+0x208>
    1c74:	81 e0       	ldi	r24, 0x01	; 1
    1c76:	18 c0       	rjmp	.+48     	; 0x1ca8 <xTaskGenericCreate+0x208>
    1c78:	d8 8e       	std	Y+24, r13	; 0x18
    1c7a:	cf 8a       	std	Y+23, r12	; 0x17
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
    1c7e:	48 1a       	sub	r4, r24
    1c80:	51 08       	sbc	r5, r1
    1c82:	cf 88       	ldd	r12, Y+23	; 0x17
    1c84:	d8 8c       	ldd	r13, Y+24	; 0x18
    1c86:	c4 0c       	add	r12, r4
    1c88:	d5 1c       	adc	r13, r5
    1c8a:	d5 01       	movw	r26, r10
    1c8c:	8c 91       	ld	r24, X
    1c8e:	89 8f       	std	Y+25, r24	; 0x19
    1c90:	8c 91       	ld	r24, X
    1c92:	88 23       	and	r24, r24
    1c94:	09 f4       	brne	.+2      	; 0x1c98 <xTaskGenericCreate+0x1f8>
    1c96:	3b cf       	rjmp	.-394    	; 0x1b0e <xTaskGenericCreate+0x6e>
    1c98:	ae 01       	movw	r20, r28
    1c9a:	46 5e       	subi	r20, 0xE6	; 230
    1c9c:	5f 4f       	sbci	r21, 0xFF	; 255
    1c9e:	f5 01       	movw	r30, r10
    1ca0:	31 96       	adiw	r30, 0x01	; 1
    1ca2:	27 e0       	ldi	r18, 0x07	; 7
    1ca4:	29 cf       	rjmp	.-430    	; 0x1af8 <xTaskGenericCreate+0x58>
    1ca6:	8f ef       	ldi	r24, 0xFF	; 255
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	1f 91       	pop	r17
    1cae:	0f 91       	pop	r16
    1cb0:	ff 90       	pop	r15
    1cb2:	ef 90       	pop	r14
    1cb4:	df 90       	pop	r13
    1cb6:	cf 90       	pop	r12
    1cb8:	bf 90       	pop	r11
    1cba:	af 90       	pop	r10
    1cbc:	9f 90       	pop	r9
    1cbe:	8f 90       	pop	r8
    1cc0:	7f 90       	pop	r7
    1cc2:	6f 90       	pop	r6
    1cc4:	5f 90       	pop	r5
    1cc6:	4f 90       	pop	r4
    1cc8:	08 95       	ret

00001cca <vTaskResume>:
    1cca:	0f 93       	push	r16
    1ccc:	1f 93       	push	r17
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
    1cd2:	ec 01       	movw	r28, r24
    1cd4:	00 97       	sbiw	r24, 0x00	; 0
    1cd6:	09 f4       	brne	.+2      	; 0x1cda <vTaskResume+0x10>
    1cd8:	3e c0       	rjmp	.+124    	; 0x1d56 <vTaskResume+0x8c>
    1cda:	80 91 8d 08 	lds	r24, 0x088D
    1cde:	90 91 8e 08 	lds	r25, 0x088E
    1ce2:	c8 17       	cp	r28, r24
    1ce4:	d9 07       	cpc	r29, r25
    1ce6:	b9 f1       	breq	.+110    	; 0x1d56 <vTaskResume+0x8c>
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	f8 94       	cli
    1cec:	0f 92       	push	r0
    1cee:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cf0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cf2:	8e 52       	subi	r24, 0x2E	; 46
    1cf4:	98 40       	sbci	r25, 0x08	; 8
    1cf6:	69 f5       	brne	.+90     	; 0x1d52 <vTaskResume+0x88>
    1cf8:	8c 89       	ldd	r24, Y+20	; 0x14
    1cfa:	9d 89       	ldd	r25, Y+21	; 0x15
    1cfc:	28 e0       	ldi	r18, 0x08	; 8
    1cfe:	81 34       	cpi	r24, 0x41	; 65
    1d00:	92 07       	cpc	r25, r18
    1d02:	39 f1       	breq	.+78     	; 0x1d52 <vTaskResume+0x88>
    1d04:	89 2b       	or	r24, r25
    1d06:	29 f5       	brne	.+74     	; 0x1d52 <vTaskResume+0x88>
    1d08:	8e 01       	movw	r16, r28
    1d0a:	0e 5f       	subi	r16, 0xFE	; 254
    1d0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0e:	c8 01       	movw	r24, r16
    1d10:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    1d14:	8e 89       	ldd	r24, Y+22	; 0x16
    1d16:	90 91 2a 08 	lds	r25, 0x082A
    1d1a:	98 17       	cp	r25, r24
    1d1c:	10 f4       	brcc	.+4      	; 0x1d22 <vTaskResume+0x58>
    1d1e:	80 93 2a 08 	sts	0x082A, r24
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	9c 01       	movw	r18, r24
    1d26:	22 0f       	add	r18, r18
    1d28:	33 1f       	adc	r19, r19
    1d2a:	22 0f       	add	r18, r18
    1d2c:	33 1f       	adc	r19, r19
    1d2e:	22 0f       	add	r18, r18
    1d30:	33 1f       	adc	r19, r19
    1d32:	82 0f       	add	r24, r18
    1d34:	93 1f       	adc	r25, r19
    1d36:	b8 01       	movw	r22, r16
    1d38:	80 5a       	subi	r24, 0xA0	; 160
    1d3a:	97 4f       	sbci	r25, 0xF7	; 247
    1d3c:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    1d40:	e0 91 8d 08 	lds	r30, 0x088D
    1d44:	f0 91 8e 08 	lds	r31, 0x088E
    1d48:	9e 89       	ldd	r25, Y+22	; 0x16
    1d4a:	86 89       	ldd	r24, Z+22	; 0x16
    1d4c:	98 17       	cp	r25, r24
    1d4e:	08 f0       	brcs	.+2      	; 0x1d52 <vTaskResume+0x88>
    1d50:	71 da       	rcall	.-2846   	; 0x1234 <vPortYield>
    1d52:	0f 90       	pop	r0
    1d54:	0f be       	out	0x3f, r0	; 63
    1d56:	df 91       	pop	r29
    1d58:	cf 91       	pop	r28
    1d5a:	1f 91       	pop	r17
    1d5c:	0f 91       	pop	r16
    1d5e:	08 95       	ret

00001d60 <vTaskStartScheduler>:
    1d60:	af 92       	push	r10
    1d62:	bf 92       	push	r11
    1d64:	cf 92       	push	r12
    1d66:	df 92       	push	r13
    1d68:	ef 92       	push	r14
    1d6a:	ff 92       	push	r15
    1d6c:	0f 93       	push	r16
    1d6e:	a1 2c       	mov	r10, r1
    1d70:	b1 2c       	mov	r11, r1
    1d72:	c1 2c       	mov	r12, r1
    1d74:	d1 2c       	mov	r13, r1
    1d76:	e1 2c       	mov	r14, r1
    1d78:	f1 2c       	mov	r15, r1
    1d7a:	00 e0       	ldi	r16, 0x00	; 0
    1d7c:	20 e0       	ldi	r18, 0x00	; 0
    1d7e:	30 e0       	ldi	r19, 0x00	; 0
    1d80:	45 e5       	ldi	r20, 0x55	; 85
    1d82:	50 e0       	ldi	r21, 0x00	; 0
    1d84:	69 e3       	ldi	r22, 0x39	; 57
    1d86:	72 e0       	ldi	r23, 0x02	; 2
    1d88:	87 e8       	ldi	r24, 0x87	; 135
    1d8a:	90 e1       	ldi	r25, 0x10	; 16
    1d8c:	89 de       	rcall	.-750    	; 0x1aa0 <xTaskGenericCreate>
    1d8e:	81 30       	cpi	r24, 0x01	; 1
    1d90:	41 f4       	brne	.+16     	; 0x1da2 <vTaskStartScheduler+0x42>
    1d92:	f8 94       	cli
    1d94:	80 93 29 08 	sts	0x0829, r24
    1d98:	10 92 2c 08 	sts	0x082C, r1
    1d9c:	10 92 2b 08 	sts	0x082B, r1
    1da0:	0c da       	rcall	.-3048   	; 0x11ba <xPortStartScheduler>
    1da2:	0f 91       	pop	r16
    1da4:	ff 90       	pop	r15
    1da6:	ef 90       	pop	r14
    1da8:	df 90       	pop	r13
    1daa:	cf 90       	pop	r12
    1dac:	bf 90       	pop	r11
    1dae:	af 90       	pop	r10
    1db0:	08 95       	ret

00001db2 <vTaskSuspendAll>:
    1db2:	80 91 24 08 	lds	r24, 0x0824
    1db6:	8f 5f       	subi	r24, 0xFF	; 255
    1db8:	80 93 24 08 	sts	0x0824, r24
    1dbc:	08 95       	ret

00001dbe <xTaskGetTickCount>:
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	0f 92       	push	r0
    1dc4:	80 91 2b 08 	lds	r24, 0x082B
    1dc8:	90 91 2c 08 	lds	r25, 0x082C
    1dcc:	0f 90       	pop	r0
    1dce:	0f be       	out	0x3f, r0	; 63
    1dd0:	08 95       	ret

00001dd2 <xTaskGetTickCountFromISR>:
    1dd2:	80 91 2b 08 	lds	r24, 0x082B
    1dd6:	90 91 2c 08 	lds	r25, 0x082C
    1dda:	08 95       	ret

00001ddc <xTaskIncrementTick>:
    1ddc:	cf 92       	push	r12
    1dde:	df 92       	push	r13
    1de0:	ef 92       	push	r14
    1de2:	ff 92       	push	r15
    1de4:	0f 93       	push	r16
    1de6:	1f 93       	push	r17
    1de8:	cf 93       	push	r28
    1dea:	df 93       	push	r29
    1dec:	80 91 24 08 	lds	r24, 0x0824
    1df0:	81 11       	cpse	r24, r1
    1df2:	99 c0       	rjmp	.+306    	; 0x1f26 <xTaskIncrementTick+0x14a>
    1df4:	80 91 2b 08 	lds	r24, 0x082B
    1df8:	90 91 2c 08 	lds	r25, 0x082C
    1dfc:	01 96       	adiw	r24, 0x01	; 1
    1dfe:	90 93 2c 08 	sts	0x082C, r25
    1e02:	80 93 2b 08 	sts	0x082B, r24
    1e06:	e0 90 2b 08 	lds	r14, 0x082B
    1e0a:	f0 90 2c 08 	lds	r15, 0x082C
    1e0e:	e1 14       	cp	r14, r1
    1e10:	f1 04       	cpc	r15, r1
    1e12:	b1 f4       	brne	.+44     	; 0x1e40 <xTaskIncrementTick+0x64>
    1e14:	80 91 4c 08 	lds	r24, 0x084C
    1e18:	90 91 4d 08 	lds	r25, 0x084D
    1e1c:	20 91 4a 08 	lds	r18, 0x084A
    1e20:	30 91 4b 08 	lds	r19, 0x084B
    1e24:	30 93 4d 08 	sts	0x084D, r19
    1e28:	20 93 4c 08 	sts	0x084C, r18
    1e2c:	90 93 4b 08 	sts	0x084B, r25
    1e30:	80 93 4a 08 	sts	0x084A, r24
    1e34:	80 91 26 08 	lds	r24, 0x0826
    1e38:	8f 5f       	subi	r24, 0xFF	; 255
    1e3a:	80 93 26 08 	sts	0x0826, r24
    1e3e:	da dd       	rcall	.-1100   	; 0x19f4 <prvResetNextTaskUnblockTime>
    1e40:	80 91 04 02 	lds	r24, 0x0204
    1e44:	90 91 05 02 	lds	r25, 0x0205
    1e48:	e8 16       	cp	r14, r24
    1e4a:	f9 06       	cpc	r15, r25
    1e4c:	08 f4       	brcc	.+2      	; 0x1e50 <xTaskIncrementTick+0x74>
    1e4e:	54 c0       	rjmp	.+168    	; 0x1ef8 <xTaskIncrementTick+0x11c>
    1e50:	d1 2c       	mov	r13, r1
    1e52:	cc 24       	eor	r12, r12
    1e54:	c3 94       	inc	r12
    1e56:	01 c0       	rjmp	.+2      	; 0x1e5a <xTaskIncrementTick+0x7e>
    1e58:	dc 2c       	mov	r13, r12
    1e5a:	e0 91 4c 08 	lds	r30, 0x084C
    1e5e:	f0 91 4d 08 	lds	r31, 0x084D
    1e62:	80 81       	ld	r24, Z
    1e64:	81 11       	cpse	r24, r1
    1e66:	07 c0       	rjmp	.+14     	; 0x1e76 <xTaskIncrementTick+0x9a>
    1e68:	8f ef       	ldi	r24, 0xFF	; 255
    1e6a:	9f ef       	ldi	r25, 0xFF	; 255
    1e6c:	90 93 05 02 	sts	0x0205, r25
    1e70:	80 93 04 02 	sts	0x0204, r24
    1e74:	42 c0       	rjmp	.+132    	; 0x1efa <xTaskIncrementTick+0x11e>
    1e76:	e0 91 4c 08 	lds	r30, 0x084C
    1e7a:	f0 91 4d 08 	lds	r31, 0x084D
    1e7e:	05 80       	ldd	r0, Z+5	; 0x05
    1e80:	f6 81       	ldd	r31, Z+6	; 0x06
    1e82:	e0 2d       	mov	r30, r0
    1e84:	c6 81       	ldd	r28, Z+6	; 0x06
    1e86:	d7 81       	ldd	r29, Z+7	; 0x07
    1e88:	2a 81       	ldd	r18, Y+2	; 0x02
    1e8a:	3b 81       	ldd	r19, Y+3	; 0x03
    1e8c:	e2 16       	cp	r14, r18
    1e8e:	f3 06       	cpc	r15, r19
    1e90:	28 f4       	brcc	.+10     	; 0x1e9c <xTaskIncrementTick+0xc0>
    1e92:	30 93 05 02 	sts	0x0205, r19
    1e96:	20 93 04 02 	sts	0x0204, r18
    1e9a:	2f c0       	rjmp	.+94     	; 0x1efa <xTaskIncrementTick+0x11e>
    1e9c:	8e 01       	movw	r16, r28
    1e9e:	0e 5f       	subi	r16, 0xFE	; 254
    1ea0:	1f 4f       	sbci	r17, 0xFF	; 255
    1ea2:	c8 01       	movw	r24, r16
    1ea4:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    1ea8:	8c 89       	ldd	r24, Y+20	; 0x14
    1eaa:	9d 89       	ldd	r25, Y+21	; 0x15
    1eac:	89 2b       	or	r24, r25
    1eae:	21 f0       	breq	.+8      	; 0x1eb8 <xTaskIncrementTick+0xdc>
    1eb0:	ce 01       	movw	r24, r28
    1eb2:	0c 96       	adiw	r24, 0x0c	; 12
    1eb4:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    1eb8:	2e 89       	ldd	r18, Y+22	; 0x16
    1eba:	80 91 2a 08 	lds	r24, 0x082A
    1ebe:	82 17       	cp	r24, r18
    1ec0:	10 f4       	brcc	.+4      	; 0x1ec6 <xTaskIncrementTick+0xea>
    1ec2:	20 93 2a 08 	sts	0x082A, r18
    1ec6:	30 e0       	ldi	r19, 0x00	; 0
    1ec8:	c9 01       	movw	r24, r18
    1eca:	88 0f       	add	r24, r24
    1ecc:	99 1f       	adc	r25, r25
    1ece:	88 0f       	add	r24, r24
    1ed0:	99 1f       	adc	r25, r25
    1ed2:	88 0f       	add	r24, r24
    1ed4:	99 1f       	adc	r25, r25
    1ed6:	82 0f       	add	r24, r18
    1ed8:	93 1f       	adc	r25, r19
    1eda:	b8 01       	movw	r22, r16
    1edc:	80 5a       	subi	r24, 0xA0	; 160
    1ede:	97 4f       	sbci	r25, 0xF7	; 247
    1ee0:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    1ee4:	e0 91 8d 08 	lds	r30, 0x088D
    1ee8:	f0 91 8e 08 	lds	r31, 0x088E
    1eec:	9e 89       	ldd	r25, Y+22	; 0x16
    1eee:	86 89       	ldd	r24, Z+22	; 0x16
    1ef0:	98 17       	cp	r25, r24
    1ef2:	08 f0       	brcs	.+2      	; 0x1ef6 <xTaskIncrementTick+0x11a>
    1ef4:	b1 cf       	rjmp	.-158    	; 0x1e58 <xTaskIncrementTick+0x7c>
    1ef6:	b1 cf       	rjmp	.-158    	; 0x1e5a <xTaskIncrementTick+0x7e>
    1ef8:	d1 2c       	mov	r13, r1
    1efa:	e0 91 8d 08 	lds	r30, 0x088D
    1efe:	f0 91 8e 08 	lds	r31, 0x088E
    1f02:	86 89       	ldd	r24, Z+22	; 0x16
    1f04:	90 e0       	ldi	r25, 0x00	; 0
    1f06:	fc 01       	movw	r30, r24
    1f08:	ee 0f       	add	r30, r30
    1f0a:	ff 1f       	adc	r31, r31
    1f0c:	ee 0f       	add	r30, r30
    1f0e:	ff 1f       	adc	r31, r31
    1f10:	ee 0f       	add	r30, r30
    1f12:	ff 1f       	adc	r31, r31
    1f14:	8e 0f       	add	r24, r30
    1f16:	9f 1f       	adc	r25, r31
    1f18:	fc 01       	movw	r30, r24
    1f1a:	e0 5a       	subi	r30, 0xA0	; 160
    1f1c:	f7 4f       	sbci	r31, 0xF7	; 247
    1f1e:	80 81       	ld	r24, Z
    1f20:	82 30       	cpi	r24, 0x02	; 2
    1f22:	40 f4       	brcc	.+16     	; 0x1f34 <xTaskIncrementTick+0x158>
    1f24:	09 c0       	rjmp	.+18     	; 0x1f38 <xTaskIncrementTick+0x15c>
    1f26:	80 91 28 08 	lds	r24, 0x0828
    1f2a:	8f 5f       	subi	r24, 0xFF	; 255
    1f2c:	80 93 28 08 	sts	0x0828, r24
    1f30:	d1 2c       	mov	r13, r1
    1f32:	02 c0       	rjmp	.+4      	; 0x1f38 <xTaskIncrementTick+0x15c>
    1f34:	dd 24       	eor	r13, r13
    1f36:	d3 94       	inc	r13
    1f38:	80 91 27 08 	lds	r24, 0x0827
    1f3c:	88 23       	and	r24, r24
    1f3e:	11 f0       	breq	.+4      	; 0x1f44 <xTaskIncrementTick+0x168>
    1f40:	dd 24       	eor	r13, r13
    1f42:	d3 94       	inc	r13
    1f44:	8d 2d       	mov	r24, r13
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	ff 90       	pop	r15
    1f50:	ef 90       	pop	r14
    1f52:	df 90       	pop	r13
    1f54:	cf 90       	pop	r12
    1f56:	08 95       	ret

00001f58 <xTaskResumeAll>:
    1f58:	df 92       	push	r13
    1f5a:	ef 92       	push	r14
    1f5c:	ff 92       	push	r15
    1f5e:	0f 93       	push	r16
    1f60:	1f 93       	push	r17
    1f62:	cf 93       	push	r28
    1f64:	df 93       	push	r29
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	0f 92       	push	r0
    1f6c:	80 91 24 08 	lds	r24, 0x0824
    1f70:	81 50       	subi	r24, 0x01	; 1
    1f72:	80 93 24 08 	sts	0x0824, r24
    1f76:	80 91 24 08 	lds	r24, 0x0824
    1f7a:	81 11       	cpse	r24, r1
    1f7c:	5f c0       	rjmp	.+190    	; 0x203c <xTaskResumeAll+0xe4>
    1f7e:	80 91 2d 08 	lds	r24, 0x082D
    1f82:	88 23       	and	r24, r24
    1f84:	09 f4       	brne	.+2      	; 0x1f88 <xTaskResumeAll+0x30>
    1f86:	5c c0       	rjmp	.+184    	; 0x2040 <xTaskResumeAll+0xe8>
    1f88:	0f 2e       	mov	r0, r31
    1f8a:	f1 e4       	ldi	r31, 0x41	; 65
    1f8c:	ef 2e       	mov	r14, r31
    1f8e:	f8 e0       	ldi	r31, 0x08	; 8
    1f90:	ff 2e       	mov	r15, r31
    1f92:	f0 2d       	mov	r31, r0
    1f94:	dd 24       	eor	r13, r13
    1f96:	d3 94       	inc	r13
    1f98:	30 c0       	rjmp	.+96     	; 0x1ffa <xTaskResumeAll+0xa2>
    1f9a:	e0 91 46 08 	lds	r30, 0x0846
    1f9e:	f0 91 47 08 	lds	r31, 0x0847
    1fa2:	c6 81       	ldd	r28, Z+6	; 0x06
    1fa4:	d7 81       	ldd	r29, Z+7	; 0x07
    1fa6:	ce 01       	movw	r24, r28
    1fa8:	0c 96       	adiw	r24, 0x0c	; 12
    1faa:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    1fae:	8e 01       	movw	r16, r28
    1fb0:	0e 5f       	subi	r16, 0xFE	; 254
    1fb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb4:	c8 01       	movw	r24, r16
    1fb6:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    1fba:	8e 89       	ldd	r24, Y+22	; 0x16
    1fbc:	90 91 2a 08 	lds	r25, 0x082A
    1fc0:	98 17       	cp	r25, r24
    1fc2:	10 f4       	brcc	.+4      	; 0x1fc8 <xTaskResumeAll+0x70>
    1fc4:	80 93 2a 08 	sts	0x082A, r24
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	9c 01       	movw	r18, r24
    1fcc:	22 0f       	add	r18, r18
    1fce:	33 1f       	adc	r19, r19
    1fd0:	22 0f       	add	r18, r18
    1fd2:	33 1f       	adc	r19, r19
    1fd4:	22 0f       	add	r18, r18
    1fd6:	33 1f       	adc	r19, r19
    1fd8:	82 0f       	add	r24, r18
    1fda:	93 1f       	adc	r25, r19
    1fdc:	b8 01       	movw	r22, r16
    1fde:	80 5a       	subi	r24, 0xA0	; 160
    1fe0:	97 4f       	sbci	r25, 0xF7	; 247
    1fe2:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    1fe6:	e0 91 8d 08 	lds	r30, 0x088D
    1fea:	f0 91 8e 08 	lds	r31, 0x088E
    1fee:	9e 89       	ldd	r25, Y+22	; 0x16
    1ff0:	86 89       	ldd	r24, Z+22	; 0x16
    1ff2:	98 17       	cp	r25, r24
    1ff4:	10 f0       	brcs	.+4      	; 0x1ffa <xTaskResumeAll+0xa2>
    1ff6:	d0 92 27 08 	sts	0x0827, r13
    1ffa:	f7 01       	movw	r30, r14
    1ffc:	80 81       	ld	r24, Z
    1ffe:	81 11       	cpse	r24, r1
    2000:	cc cf       	rjmp	.-104    	; 0x1f9a <xTaskResumeAll+0x42>
    2002:	80 91 28 08 	lds	r24, 0x0828
    2006:	88 23       	and	r24, r24
    2008:	91 f0       	breq	.+36     	; 0x202e <xTaskResumeAll+0xd6>
    200a:	80 91 28 08 	lds	r24, 0x0828
    200e:	88 23       	and	r24, r24
    2010:	71 f0       	breq	.+28     	; 0x202e <xTaskResumeAll+0xd6>
    2012:	c1 e0       	ldi	r28, 0x01	; 1
    2014:	e3 de       	rcall	.-570    	; 0x1ddc <xTaskIncrementTick>
    2016:	81 11       	cpse	r24, r1
    2018:	c0 93 27 08 	sts	0x0827, r28
    201c:	80 91 28 08 	lds	r24, 0x0828
    2020:	81 50       	subi	r24, 0x01	; 1
    2022:	80 93 28 08 	sts	0x0828, r24
    2026:	80 91 28 08 	lds	r24, 0x0828
    202a:	81 11       	cpse	r24, r1
    202c:	f3 cf       	rjmp	.-26     	; 0x2014 <xTaskResumeAll+0xbc>
    202e:	80 91 27 08 	lds	r24, 0x0827
    2032:	81 30       	cpi	r24, 0x01	; 1
    2034:	39 f4       	brne	.+14     	; 0x2044 <xTaskResumeAll+0xec>
    2036:	fe d8       	rcall	.-3588   	; 0x1234 <vPortYield>
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	05 c0       	rjmp	.+10     	; 0x2046 <xTaskResumeAll+0xee>
    203c:	80 e0       	ldi	r24, 0x00	; 0
    203e:	03 c0       	rjmp	.+6      	; 0x2046 <xTaskResumeAll+0xee>
    2040:	80 e0       	ldi	r24, 0x00	; 0
    2042:	01 c0       	rjmp	.+2      	; 0x2046 <xTaskResumeAll+0xee>
    2044:	80 e0       	ldi	r24, 0x00	; 0
    2046:	0f 90       	pop	r0
    2048:	0f be       	out	0x3f, r0	; 63
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	1f 91       	pop	r17
    2050:	0f 91       	pop	r16
    2052:	ff 90       	pop	r15
    2054:	ef 90       	pop	r14
    2056:	df 90       	pop	r13
    2058:	08 95       	ret

0000205a <vTaskDelayUntil>:
    205a:	0f 93       	push	r16
    205c:	1f 93       	push	r17
    205e:	cf 93       	push	r28
    2060:	df 93       	push	r29
    2062:	8c 01       	movw	r16, r24
    2064:	eb 01       	movw	r28, r22
    2066:	a5 de       	rcall	.-694    	; 0x1db2 <vTaskSuspendAll>
    2068:	80 91 2b 08 	lds	r24, 0x082B
    206c:	90 91 2c 08 	lds	r25, 0x082C
    2070:	f8 01       	movw	r30, r16
    2072:	20 81       	ld	r18, Z
    2074:	31 81       	ldd	r19, Z+1	; 0x01
    2076:	c2 0f       	add	r28, r18
    2078:	d3 1f       	adc	r29, r19
    207a:	82 17       	cp	r24, r18
    207c:	93 07       	cpc	r25, r19
    207e:	48 f4       	brcc	.+18     	; 0x2092 <vTaskDelayUntil+0x38>
    2080:	c2 17       	cp	r28, r18
    2082:	d3 07       	cpc	r29, r19
    2084:	f8 f4       	brcc	.+62     	; 0x20c4 <vTaskDelayUntil+0x6a>
    2086:	d1 83       	std	Z+1, r29	; 0x01
    2088:	c0 83       	st	Z, r28
    208a:	8c 17       	cp	r24, r28
    208c:	9d 07       	cpc	r25, r29
    208e:	88 f4       	brcc	.+34     	; 0x20b2 <vTaskDelayUntil+0x58>
    2090:	07 c0       	rjmp	.+14     	; 0x20a0 <vTaskDelayUntil+0x46>
    2092:	c2 17       	cp	r28, r18
    2094:	d3 07       	cpc	r29, r19
    2096:	90 f0       	brcs	.+36     	; 0x20bc <vTaskDelayUntil+0x62>
    2098:	8c 17       	cp	r24, r28
    209a:	9d 07       	cpc	r25, r29
    209c:	78 f0       	brcs	.+30     	; 0x20bc <vTaskDelayUntil+0x62>
    209e:	12 c0       	rjmp	.+36     	; 0x20c4 <vTaskDelayUntil+0x6a>
    20a0:	80 91 8d 08 	lds	r24, 0x088D
    20a4:	90 91 8e 08 	lds	r25, 0x088E
    20a8:	02 96       	adiw	r24, 0x02	; 2
    20aa:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    20ae:	ce 01       	movw	r24, r28
    20b0:	c0 dc       	rcall	.-1664   	; 0x1a32 <prvAddCurrentTaskToDelayedList>
    20b2:	52 df       	rcall	.-348    	; 0x1f58 <xTaskResumeAll>
    20b4:	81 11       	cpse	r24, r1
    20b6:	0a c0       	rjmp	.+20     	; 0x20cc <vTaskDelayUntil+0x72>
    20b8:	bd d8       	rcall	.-3718   	; 0x1234 <vPortYield>
    20ba:	08 c0       	rjmp	.+16     	; 0x20cc <vTaskDelayUntil+0x72>
    20bc:	f8 01       	movw	r30, r16
    20be:	d1 83       	std	Z+1, r29	; 0x01
    20c0:	c0 83       	st	Z, r28
    20c2:	ee cf       	rjmp	.-36     	; 0x20a0 <vTaskDelayUntil+0x46>
    20c4:	f8 01       	movw	r30, r16
    20c6:	d1 83       	std	Z+1, r29	; 0x01
    20c8:	c0 83       	st	Z, r28
    20ca:	f3 cf       	rjmp	.-26     	; 0x20b2 <vTaskDelayUntil+0x58>
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	1f 91       	pop	r17
    20d2:	0f 91       	pop	r16
    20d4:	08 95       	ret

000020d6 <vTaskDelay>:
    20d6:	cf 93       	push	r28
    20d8:	df 93       	push	r29
    20da:	ec 01       	movw	r28, r24
    20dc:	00 97       	sbiw	r24, 0x00	; 0
    20de:	99 f0       	breq	.+38     	; 0x2106 <vTaskDelay+0x30>
    20e0:	68 de       	rcall	.-816    	; 0x1db2 <vTaskSuspendAll>
    20e2:	80 91 2b 08 	lds	r24, 0x082B
    20e6:	90 91 2c 08 	lds	r25, 0x082C
    20ea:	c8 0f       	add	r28, r24
    20ec:	d9 1f       	adc	r29, r25
    20ee:	80 91 8d 08 	lds	r24, 0x088D
    20f2:	90 91 8e 08 	lds	r25, 0x088E
    20f6:	02 96       	adiw	r24, 0x02	; 2
    20f8:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    20fc:	ce 01       	movw	r24, r28
    20fe:	99 dc       	rcall	.-1742   	; 0x1a32 <prvAddCurrentTaskToDelayedList>
    2100:	2b df       	rcall	.-426    	; 0x1f58 <xTaskResumeAll>
    2102:	81 11       	cpse	r24, r1
    2104:	01 c0       	rjmp	.+2      	; 0x2108 <vTaskDelay+0x32>
    2106:	96 d8       	rcall	.-3796   	; 0x1234 <vPortYield>
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	08 95       	ret

0000210e <prvIdleTask>:
    210e:	0f 2e       	mov	r0, r31
    2110:	f0 e6       	ldi	r31, 0x60	; 96
    2112:	ef 2e       	mov	r14, r31
    2114:	f8 e0       	ldi	r31, 0x08	; 8
    2116:	ff 2e       	mov	r15, r31
    2118:	f0 2d       	mov	r31, r0
    211a:	c8 e3       	ldi	r28, 0x38	; 56
    211c:	d8 e0       	ldi	r29, 0x08	; 8
    211e:	26 c0       	rjmp	.+76     	; 0x216c <prvIdleTask+0x5e>
    2120:	48 de       	rcall	.-880    	; 0x1db2 <vTaskSuspendAll>
    2122:	18 81       	ld	r17, Y
    2124:	19 df       	rcall	.-462    	; 0x1f58 <xTaskResumeAll>
    2126:	11 23       	and	r17, r17
    2128:	09 f1       	breq	.+66     	; 0x216c <prvIdleTask+0x5e>
    212a:	0f b6       	in	r0, 0x3f	; 63
    212c:	f8 94       	cli
    212e:	0f 92       	push	r0
    2130:	e0 91 3d 08 	lds	r30, 0x083D
    2134:	f0 91 3e 08 	lds	r31, 0x083E
    2138:	06 81       	ldd	r16, Z+6	; 0x06
    213a:	17 81       	ldd	r17, Z+7	; 0x07
    213c:	c8 01       	movw	r24, r16
    213e:	02 96       	adiw	r24, 0x02	; 2
    2140:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    2144:	80 91 2d 08 	lds	r24, 0x082D
    2148:	81 50       	subi	r24, 0x01	; 1
    214a:	80 93 2d 08 	sts	0x082D, r24
    214e:	80 91 37 08 	lds	r24, 0x0837
    2152:	81 50       	subi	r24, 0x01	; 1
    2154:	80 93 37 08 	sts	0x0837, r24
    2158:	0f 90       	pop	r0
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	f8 01       	movw	r30, r16
    215e:	87 89       	ldd	r24, Z+23	; 0x17
    2160:	90 8d       	ldd	r25, Z+24	; 0x18
    2162:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
    2166:	c8 01       	movw	r24, r16
    2168:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortFree>
    216c:	80 91 37 08 	lds	r24, 0x0837
    2170:	81 11       	cpse	r24, r1
    2172:	d6 cf       	rjmp	.-84     	; 0x2120 <prvIdleTask+0x12>
    2174:	f7 01       	movw	r30, r14
    2176:	80 81       	ld	r24, Z
    2178:	82 30       	cpi	r24, 0x02	; 2
    217a:	c0 f3       	brcs	.-16     	; 0x216c <prvIdleTask+0x5e>
    217c:	5b d8       	rcall	.-3914   	; 0x1234 <vPortYield>
    217e:	f6 cf       	rjmp	.-20     	; 0x216c <prvIdleTask+0x5e>

00002180 <vTaskSwitchContext>:
    2180:	80 91 24 08 	lds	r24, 0x0824
    2184:	88 23       	and	r24, r24
    2186:	21 f0       	breq	.+8      	; 0x2190 <vTaskSwitchContext+0x10>
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	80 93 27 08 	sts	0x0827, r24
    218e:	08 95       	ret
    2190:	10 92 27 08 	sts	0x0827, r1
    2194:	80 91 2a 08 	lds	r24, 0x082A
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	fc 01       	movw	r30, r24
    219c:	ee 0f       	add	r30, r30
    219e:	ff 1f       	adc	r31, r31
    21a0:	ee 0f       	add	r30, r30
    21a2:	ff 1f       	adc	r31, r31
    21a4:	ee 0f       	add	r30, r30
    21a6:	ff 1f       	adc	r31, r31
    21a8:	8e 0f       	add	r24, r30
    21aa:	9f 1f       	adc	r25, r31
    21ac:	fc 01       	movw	r30, r24
    21ae:	e0 5a       	subi	r30, 0xA0	; 160
    21b0:	f7 4f       	sbci	r31, 0xF7	; 247
    21b2:	80 81       	ld	r24, Z
    21b4:	81 11       	cpse	r24, r1
    21b6:	17 c0       	rjmp	.+46     	; 0x21e6 <vTaskSwitchContext+0x66>
    21b8:	80 91 2a 08 	lds	r24, 0x082A
    21bc:	81 50       	subi	r24, 0x01	; 1
    21be:	80 93 2a 08 	sts	0x082A, r24
    21c2:	80 91 2a 08 	lds	r24, 0x082A
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	fc 01       	movw	r30, r24
    21ca:	ee 0f       	add	r30, r30
    21cc:	ff 1f       	adc	r31, r31
    21ce:	ee 0f       	add	r30, r30
    21d0:	ff 1f       	adc	r31, r31
    21d2:	ee 0f       	add	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	8e 0f       	add	r24, r30
    21d8:	9f 1f       	adc	r25, r31
    21da:	fc 01       	movw	r30, r24
    21dc:	e0 5a       	subi	r30, 0xA0	; 160
    21de:	f7 4f       	sbci	r31, 0xF7	; 247
    21e0:	80 81       	ld	r24, Z
    21e2:	88 23       	and	r24, r24
    21e4:	49 f3       	breq	.-46     	; 0x21b8 <vTaskSwitchContext+0x38>
    21e6:	e0 91 2a 08 	lds	r30, 0x082A
    21ea:	f0 e0       	ldi	r31, 0x00	; 0
    21ec:	cf 01       	movw	r24, r30
    21ee:	88 0f       	add	r24, r24
    21f0:	99 1f       	adc	r25, r25
    21f2:	88 0f       	add	r24, r24
    21f4:	99 1f       	adc	r25, r25
    21f6:	88 0f       	add	r24, r24
    21f8:	99 1f       	adc	r25, r25
    21fa:	e8 0f       	add	r30, r24
    21fc:	f9 1f       	adc	r31, r25
    21fe:	e0 5a       	subi	r30, 0xA0	; 160
    2200:	f7 4f       	sbci	r31, 0xF7	; 247
    2202:	a1 81       	ldd	r26, Z+1	; 0x01
    2204:	b2 81       	ldd	r27, Z+2	; 0x02
    2206:	12 96       	adiw	r26, 0x02	; 2
    2208:	0d 90       	ld	r0, X+
    220a:	bc 91       	ld	r27, X
    220c:	a0 2d       	mov	r26, r0
    220e:	b2 83       	std	Z+2, r27	; 0x02
    2210:	a1 83       	std	Z+1, r26	; 0x01
    2212:	cf 01       	movw	r24, r30
    2214:	03 96       	adiw	r24, 0x03	; 3
    2216:	a8 17       	cp	r26, r24
    2218:	b9 07       	cpc	r27, r25
    221a:	31 f4       	brne	.+12     	; 0x2228 <__stack+0x29>
    221c:	12 96       	adiw	r26, 0x02	; 2
    221e:	8d 91       	ld	r24, X+
    2220:	9c 91       	ld	r25, X
    2222:	13 97       	sbiw	r26, 0x03	; 3
    2224:	92 83       	std	Z+2, r25	; 0x02
    2226:	81 83       	std	Z+1, r24	; 0x01
    2228:	01 80       	ldd	r0, Z+1	; 0x01
    222a:	f2 81       	ldd	r31, Z+2	; 0x02
    222c:	e0 2d       	mov	r30, r0
    222e:	86 81       	ldd	r24, Z+6	; 0x06
    2230:	97 81       	ldd	r25, Z+7	; 0x07
    2232:	90 93 8e 08 	sts	0x088E, r25
    2236:	80 93 8d 08 	sts	0x088D, r24
    223a:	08 95       	ret

0000223c <vTaskSuspend>:
    223c:	0f 93       	push	r16
    223e:	1f 93       	push	r17
    2240:	cf 93       	push	r28
    2242:	df 93       	push	r29
    2244:	ec 01       	movw	r28, r24
    2246:	0f b6       	in	r0, 0x3f	; 63
    2248:	f8 94       	cli
    224a:	0f 92       	push	r0
    224c:	00 97       	sbiw	r24, 0x00	; 0
    224e:	21 f4       	brne	.+8      	; 0x2258 <vTaskSuspend+0x1c>
    2250:	c0 91 8d 08 	lds	r28, 0x088D
    2254:	d0 91 8e 08 	lds	r29, 0x088E
    2258:	8e 01       	movw	r16, r28
    225a:	0e 5f       	subi	r16, 0xFE	; 254
    225c:	1f 4f       	sbci	r17, 0xFF	; 255
    225e:	c8 01       	movw	r24, r16
    2260:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    2264:	8c 89       	ldd	r24, Y+20	; 0x14
    2266:	9d 89       	ldd	r25, Y+21	; 0x15
    2268:	89 2b       	or	r24, r25
    226a:	21 f0       	breq	.+8      	; 0x2274 <vTaskSuspend+0x38>
    226c:	ce 01       	movw	r24, r28
    226e:	0c 96       	adiw	r24, 0x0c	; 12
    2270:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    2274:	b8 01       	movw	r22, r16
    2276:	8e e2       	ldi	r24, 0x2E	; 46
    2278:	98 e0       	ldi	r25, 0x08	; 8
    227a:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    227e:	0f 90       	pop	r0
    2280:	0f be       	out	0x3f, r0	; 63
    2282:	80 91 8d 08 	lds	r24, 0x088D
    2286:	90 91 8e 08 	lds	r25, 0x088E
    228a:	c8 17       	cp	r28, r24
    228c:	d9 07       	cpc	r29, r25
    228e:	a1 f4       	brne	.+40     	; 0x22b8 <vTaskSuspend+0x7c>
    2290:	80 91 29 08 	lds	r24, 0x0829
    2294:	88 23       	and	r24, r24
    2296:	19 f0       	breq	.+6      	; 0x229e <vTaskSuspend+0x62>
    2298:	0e 94 1a 09 	call	0x1234	; 0x1234 <vPortYield>
    229c:	17 c0       	rjmp	.+46     	; 0x22cc <vTaskSuspend+0x90>
    229e:	80 91 2d 08 	lds	r24, 0x082D
    22a2:	90 91 2e 08 	lds	r25, 0x082E
    22a6:	98 13       	cpse	r25, r24
    22a8:	05 c0       	rjmp	.+10     	; 0x22b4 <vTaskSuspend+0x78>
    22aa:	10 92 8e 08 	sts	0x088E, r1
    22ae:	10 92 8d 08 	sts	0x088D, r1
    22b2:	0c c0       	rjmp	.+24     	; 0x22cc <vTaskSuspend+0x90>
    22b4:	65 df       	rcall	.-310    	; 0x2180 <vTaskSwitchContext>
    22b6:	0a c0       	rjmp	.+20     	; 0x22cc <vTaskSuspend+0x90>
    22b8:	80 91 29 08 	lds	r24, 0x0829
    22bc:	88 23       	and	r24, r24
    22be:	31 f0       	breq	.+12     	; 0x22cc <vTaskSuspend+0x90>
    22c0:	0f b6       	in	r0, 0x3f	; 63
    22c2:	f8 94       	cli
    22c4:	0f 92       	push	r0
    22c6:	96 db       	rcall	.-2260   	; 0x19f4 <prvResetNextTaskUnblockTime>
    22c8:	0f 90       	pop	r0
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	df 91       	pop	r29
    22ce:	cf 91       	pop	r28
    22d0:	1f 91       	pop	r17
    22d2:	0f 91       	pop	r16
    22d4:	08 95       	ret

000022d6 <vTaskPlaceOnEventList>:
    22d6:	cf 93       	push	r28
    22d8:	df 93       	push	r29
    22da:	eb 01       	movw	r28, r22
    22dc:	60 91 8d 08 	lds	r22, 0x088D
    22e0:	70 91 8e 08 	lds	r23, 0x088E
    22e4:	64 5f       	subi	r22, 0xF4	; 244
    22e6:	7f 4f       	sbci	r23, 0xFF	; 255
    22e8:	0e 94 19 03 	call	0x632	; 0x632 <vListInsert>
    22ec:	80 91 8d 08 	lds	r24, 0x088D
    22f0:	90 91 8e 08 	lds	r25, 0x088E
    22f4:	02 96       	adiw	r24, 0x02	; 2
    22f6:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    22fa:	cf 3f       	cpi	r28, 0xFF	; 255
    22fc:	8f ef       	ldi	r24, 0xFF	; 255
    22fe:	d8 07       	cpc	r29, r24
    2300:	59 f4       	brne	.+22     	; 0x2318 <vTaskPlaceOnEventList+0x42>
    2302:	60 91 8d 08 	lds	r22, 0x088D
    2306:	70 91 8e 08 	lds	r23, 0x088E
    230a:	6e 5f       	subi	r22, 0xFE	; 254
    230c:	7f 4f       	sbci	r23, 0xFF	; 255
    230e:	8e e2       	ldi	r24, 0x2E	; 46
    2310:	98 e0       	ldi	r25, 0x08	; 8
    2312:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    2316:	07 c0       	rjmp	.+14     	; 0x2326 <vTaskPlaceOnEventList+0x50>
    2318:	80 91 2b 08 	lds	r24, 0x082B
    231c:	90 91 2c 08 	lds	r25, 0x082C
    2320:	8c 0f       	add	r24, r28
    2322:	9d 1f       	adc	r25, r29
    2324:	86 db       	rcall	.-2292   	; 0x1a32 <prvAddCurrentTaskToDelayedList>
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	08 95       	ret

0000232c <xTaskRemoveFromEventList>:
    232c:	0f 93       	push	r16
    232e:	1f 93       	push	r17
    2330:	cf 93       	push	r28
    2332:	df 93       	push	r29
    2334:	dc 01       	movw	r26, r24
    2336:	15 96       	adiw	r26, 0x05	; 5
    2338:	ed 91       	ld	r30, X+
    233a:	fc 91       	ld	r31, X
    233c:	16 97       	sbiw	r26, 0x06	; 6
    233e:	c6 81       	ldd	r28, Z+6	; 0x06
    2340:	d7 81       	ldd	r29, Z+7	; 0x07
    2342:	8e 01       	movw	r16, r28
    2344:	04 5f       	subi	r16, 0xF4	; 244
    2346:	1f 4f       	sbci	r17, 0xFF	; 255
    2348:	c8 01       	movw	r24, r16
    234a:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    234e:	80 91 24 08 	lds	r24, 0x0824
    2352:	81 11       	cpse	r24, r1
    2354:	1c c0       	rjmp	.+56     	; 0x238e <xTaskRemoveFromEventList+0x62>
    2356:	0a 50       	subi	r16, 0x0A	; 10
    2358:	11 09       	sbc	r17, r1
    235a:	c8 01       	movw	r24, r16
    235c:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    2360:	8e 89       	ldd	r24, Y+22	; 0x16
    2362:	90 91 2a 08 	lds	r25, 0x082A
    2366:	98 17       	cp	r25, r24
    2368:	10 f4       	brcc	.+4      	; 0x236e <xTaskRemoveFromEventList+0x42>
    236a:	80 93 2a 08 	sts	0x082A, r24
    236e:	90 e0       	ldi	r25, 0x00	; 0
    2370:	9c 01       	movw	r18, r24
    2372:	22 0f       	add	r18, r18
    2374:	33 1f       	adc	r19, r19
    2376:	22 0f       	add	r18, r18
    2378:	33 1f       	adc	r19, r19
    237a:	22 0f       	add	r18, r18
    237c:	33 1f       	adc	r19, r19
    237e:	82 0f       	add	r24, r18
    2380:	93 1f       	adc	r25, r19
    2382:	b8 01       	movw	r22, r16
    2384:	80 5a       	subi	r24, 0xA0	; 160
    2386:	97 4f       	sbci	r25, 0xF7	; 247
    2388:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    238c:	05 c0       	rjmp	.+10     	; 0x2398 <xTaskRemoveFromEventList+0x6c>
    238e:	b8 01       	movw	r22, r16
    2390:	81 e4       	ldi	r24, 0x41	; 65
    2392:	98 e0       	ldi	r25, 0x08	; 8
    2394:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    2398:	e0 91 8d 08 	lds	r30, 0x088D
    239c:	f0 91 8e 08 	lds	r31, 0x088E
    23a0:	9e 89       	ldd	r25, Y+22	; 0x16
    23a2:	86 89       	ldd	r24, Z+22	; 0x16
    23a4:	89 17       	cp	r24, r25
    23a6:	20 f4       	brcc	.+8      	; 0x23b0 <xTaskRemoveFromEventList+0x84>
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	80 93 27 08 	sts	0x0827, r24
    23ae:	01 c0       	rjmp	.+2      	; 0x23b2 <xTaskRemoveFromEventList+0x86>
    23b0:	80 e0       	ldi	r24, 0x00	; 0
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	08 95       	ret

000023bc <vTaskSetTimeOutState>:
    23bc:	20 91 26 08 	lds	r18, 0x0826
    23c0:	fc 01       	movw	r30, r24
    23c2:	20 83       	st	Z, r18
    23c4:	20 91 2b 08 	lds	r18, 0x082B
    23c8:	30 91 2c 08 	lds	r19, 0x082C
    23cc:	32 83       	std	Z+2, r19	; 0x02
    23ce:	21 83       	std	Z+1, r18	; 0x01
    23d0:	08 95       	ret

000023d2 <xTaskCheckForTimeOut>:
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	f8 94       	cli
    23d6:	0f 92       	push	r0
    23d8:	40 91 2b 08 	lds	r20, 0x082B
    23dc:	50 91 2c 08 	lds	r21, 0x082C
    23e0:	db 01       	movw	r26, r22
    23e2:	2d 91       	ld	r18, X+
    23e4:	3c 91       	ld	r19, X
    23e6:	2f 3f       	cpi	r18, 0xFF	; 255
    23e8:	bf ef       	ldi	r27, 0xFF	; 255
    23ea:	3b 07       	cpc	r19, r27
    23ec:	11 f1       	breq	.+68     	; 0x2432 <xTaskCheckForTimeOut+0x60>
    23ee:	e0 91 26 08 	lds	r30, 0x0826
    23f2:	dc 01       	movw	r26, r24
    23f4:	fc 91       	ld	r31, X
    23f6:	fe 17       	cp	r31, r30
    23f8:	39 f0       	breq	.+14     	; 0x2408 <xTaskCheckForTimeOut+0x36>
    23fa:	11 96       	adiw	r26, 0x01	; 1
    23fc:	ed 91       	ld	r30, X+
    23fe:	fc 91       	ld	r31, X
    2400:	12 97       	sbiw	r26, 0x02	; 2
    2402:	4e 17       	cp	r20, r30
    2404:	5f 07       	cpc	r21, r31
    2406:	b8 f4       	brcc	.+46     	; 0x2436 <xTaskCheckForTimeOut+0x64>
    2408:	dc 01       	movw	r26, r24
    240a:	11 96       	adiw	r26, 0x01	; 1
    240c:	ed 91       	ld	r30, X+
    240e:	fc 91       	ld	r31, X
    2410:	12 97       	sbiw	r26, 0x02	; 2
    2412:	da 01       	movw	r26, r20
    2414:	ae 1b       	sub	r26, r30
    2416:	bf 0b       	sbc	r27, r31
    2418:	a2 17       	cp	r26, r18
    241a:	b3 07       	cpc	r27, r19
    241c:	70 f4       	brcc	.+28     	; 0x243a <xTaskCheckForTimeOut+0x68>
    241e:	e4 1b       	sub	r30, r20
    2420:	f5 0b       	sbc	r31, r21
    2422:	2e 0f       	add	r18, r30
    2424:	3f 1f       	adc	r19, r31
    2426:	fb 01       	movw	r30, r22
    2428:	31 83       	std	Z+1, r19	; 0x01
    242a:	20 83       	st	Z, r18
    242c:	c7 df       	rcall	.-114    	; 0x23bc <vTaskSetTimeOutState>
    242e:	80 e0       	ldi	r24, 0x00	; 0
    2430:	05 c0       	rjmp	.+10     	; 0x243c <xTaskCheckForTimeOut+0x6a>
    2432:	80 e0       	ldi	r24, 0x00	; 0
    2434:	03 c0       	rjmp	.+6      	; 0x243c <xTaskCheckForTimeOut+0x6a>
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	01 c0       	rjmp	.+2      	; 0x243c <xTaskCheckForTimeOut+0x6a>
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	0f 90       	pop	r0
    243e:	0f be       	out	0x3f, r0	; 63
    2440:	08 95       	ret

00002442 <vTaskMissedYield>:
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	80 93 27 08 	sts	0x0827, r24
    2448:	08 95       	ret

0000244a <vTaskPriorityInherit>:
    244a:	0f 93       	push	r16
    244c:	1f 93       	push	r17
    244e:	cf 93       	push	r28
    2450:	df 93       	push	r29
    2452:	ec 01       	movw	r28, r24
    2454:	00 97       	sbiw	r24, 0x00	; 0
    2456:	09 f4       	brne	.+2      	; 0x245a <vTaskPriorityInherit+0x10>
    2458:	51 c0       	rjmp	.+162    	; 0x24fc <vTaskPriorityInherit+0xb2>
    245a:	8e 89       	ldd	r24, Y+22	; 0x16
    245c:	e0 91 8d 08 	lds	r30, 0x088D
    2460:	f0 91 8e 08 	lds	r31, 0x088E
    2464:	96 89       	ldd	r25, Z+22	; 0x16
    2466:	89 17       	cp	r24, r25
    2468:	08 f0       	brcs	.+2      	; 0x246c <vTaskPriorityInherit+0x22>
    246a:	48 c0       	rjmp	.+144    	; 0x24fc <vTaskPriorityInherit+0xb2>
    246c:	2c 85       	ldd	r18, Y+12	; 0x0c
    246e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2470:	33 23       	and	r19, r19
    2472:	5c f0       	brlt	.+22     	; 0x248a <vTaskPriorityInherit+0x40>
    2474:	e0 91 8d 08 	lds	r30, 0x088D
    2478:	f0 91 8e 08 	lds	r31, 0x088E
    247c:	96 89       	ldd	r25, Z+22	; 0x16
    247e:	25 e0       	ldi	r18, 0x05	; 5
    2480:	30 e0       	ldi	r19, 0x00	; 0
    2482:	29 1b       	sub	r18, r25
    2484:	31 09       	sbc	r19, r1
    2486:	3d 87       	std	Y+13, r19	; 0x0d
    2488:	2c 87       	std	Y+12, r18	; 0x0c
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	9c 01       	movw	r18, r24
    248e:	22 0f       	add	r18, r18
    2490:	33 1f       	adc	r19, r19
    2492:	22 0f       	add	r18, r18
    2494:	33 1f       	adc	r19, r19
    2496:	22 0f       	add	r18, r18
    2498:	33 1f       	adc	r19, r19
    249a:	82 0f       	add	r24, r18
    249c:	93 1f       	adc	r25, r19
    249e:	80 5a       	subi	r24, 0xA0	; 160
    24a0:	97 4f       	sbci	r25, 0xF7	; 247
    24a2:	2a 85       	ldd	r18, Y+10	; 0x0a
    24a4:	3b 85       	ldd	r19, Y+11	; 0x0b
    24a6:	28 17       	cp	r18, r24
    24a8:	39 07       	cpc	r19, r25
    24aa:	11 f5       	brne	.+68     	; 0x24f0 <vTaskPriorityInherit+0xa6>
    24ac:	8e 01       	movw	r16, r28
    24ae:	0e 5f       	subi	r16, 0xFE	; 254
    24b0:	1f 4f       	sbci	r17, 0xFF	; 255
    24b2:	c8 01       	movw	r24, r16
    24b4:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    24b8:	e0 91 8d 08 	lds	r30, 0x088D
    24bc:	f0 91 8e 08 	lds	r31, 0x088E
    24c0:	86 89       	ldd	r24, Z+22	; 0x16
    24c2:	8e 8b       	std	Y+22, r24	; 0x16
    24c4:	90 91 2a 08 	lds	r25, 0x082A
    24c8:	98 17       	cp	r25, r24
    24ca:	10 f4       	brcc	.+4      	; 0x24d0 <vTaskPriorityInherit+0x86>
    24cc:	80 93 2a 08 	sts	0x082A, r24
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	9c 01       	movw	r18, r24
    24d4:	22 0f       	add	r18, r18
    24d6:	33 1f       	adc	r19, r19
    24d8:	22 0f       	add	r18, r18
    24da:	33 1f       	adc	r19, r19
    24dc:	22 0f       	add	r18, r18
    24de:	33 1f       	adc	r19, r19
    24e0:	82 0f       	add	r24, r18
    24e2:	93 1f       	adc	r25, r19
    24e4:	b8 01       	movw	r22, r16
    24e6:	80 5a       	subi	r24, 0xA0	; 160
    24e8:	97 4f       	sbci	r25, 0xF7	; 247
    24ea:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    24ee:	06 c0       	rjmp	.+12     	; 0x24fc <vTaskPriorityInherit+0xb2>
    24f0:	e0 91 8d 08 	lds	r30, 0x088D
    24f4:	f0 91 8e 08 	lds	r31, 0x088E
    24f8:	86 89       	ldd	r24, Z+22	; 0x16
    24fa:	8e 8b       	std	Y+22, r24	; 0x16
    24fc:	df 91       	pop	r29
    24fe:	cf 91       	pop	r28
    2500:	1f 91       	pop	r17
    2502:	0f 91       	pop	r16
    2504:	08 95       	ret

00002506 <xTaskPriorityDisinherit>:
    2506:	0f 93       	push	r16
    2508:	1f 93       	push	r17
    250a:	cf 93       	push	r28
    250c:	df 93       	push	r29
    250e:	ec 01       	movw	r28, r24
    2510:	00 97       	sbiw	r24, 0x00	; 0
    2512:	71 f1       	breq	.+92     	; 0x2570 <xTaskPriorityDisinherit+0x6a>
    2514:	8a a1       	ldd	r24, Y+34	; 0x22
    2516:	81 50       	subi	r24, 0x01	; 1
    2518:	8a a3       	std	Y+34, r24	; 0x22
    251a:	2e 89       	ldd	r18, Y+22	; 0x16
    251c:	99 a1       	ldd	r25, Y+33	; 0x21
    251e:	29 17       	cp	r18, r25
    2520:	49 f1       	breq	.+82     	; 0x2574 <xTaskPriorityDisinherit+0x6e>
    2522:	81 11       	cpse	r24, r1
    2524:	29 c0       	rjmp	.+82     	; 0x2578 <xTaskPriorityDisinherit+0x72>
    2526:	8e 01       	movw	r16, r28
    2528:	0e 5f       	subi	r16, 0xFE	; 254
    252a:	1f 4f       	sbci	r17, 0xFF	; 255
    252c:	c8 01       	movw	r24, r16
    252e:	0e 94 4a 03 	call	0x694	; 0x694 <uxListRemove>
    2532:	89 a1       	ldd	r24, Y+33	; 0x21
    2534:	8e 8b       	std	Y+22, r24	; 0x16
    2536:	25 e0       	ldi	r18, 0x05	; 5
    2538:	30 e0       	ldi	r19, 0x00	; 0
    253a:	28 1b       	sub	r18, r24
    253c:	31 09       	sbc	r19, r1
    253e:	3d 87       	std	Y+13, r19	; 0x0d
    2540:	2c 87       	std	Y+12, r18	; 0x0c
    2542:	90 91 2a 08 	lds	r25, 0x082A
    2546:	98 17       	cp	r25, r24
    2548:	10 f4       	brcc	.+4      	; 0x254e <xTaskPriorityDisinherit+0x48>
    254a:	80 93 2a 08 	sts	0x082A, r24
    254e:	90 e0       	ldi	r25, 0x00	; 0
    2550:	9c 01       	movw	r18, r24
    2552:	22 0f       	add	r18, r18
    2554:	33 1f       	adc	r19, r19
    2556:	22 0f       	add	r18, r18
    2558:	33 1f       	adc	r19, r19
    255a:	22 0f       	add	r18, r18
    255c:	33 1f       	adc	r19, r19
    255e:	82 0f       	add	r24, r18
    2560:	93 1f       	adc	r25, r19
    2562:	b8 01       	movw	r22, r16
    2564:	80 5a       	subi	r24, 0xA0	; 160
    2566:	97 4f       	sbci	r25, 0xF7	; 247
    2568:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <vListInsertEnd>
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	05 c0       	rjmp	.+10     	; 0x257a <xTaskPriorityDisinherit+0x74>
    2570:	80 e0       	ldi	r24, 0x00	; 0
    2572:	03 c0       	rjmp	.+6      	; 0x257a <xTaskPriorityDisinherit+0x74>
    2574:	80 e0       	ldi	r24, 0x00	; 0
    2576:	01 c0       	rjmp	.+2      	; 0x257a <xTaskPriorityDisinherit+0x74>
    2578:	80 e0       	ldi	r24, 0x00	; 0
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	08 95       	ret

00002584 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2584:	80 91 8d 08 	lds	r24, 0x088D
    2588:	90 91 8e 08 	lds	r25, 0x088E
    258c:	89 2b       	or	r24, r25
    258e:	39 f0       	breq	.+14     	; 0x259e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2590:	e0 91 8d 08 	lds	r30, 0x088D
    2594:	f0 91 8e 08 	lds	r31, 0x088E
    2598:	82 a1       	ldd	r24, Z+34	; 0x22
    259a:	8f 5f       	subi	r24, 0xFF	; 255
    259c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    259e:	80 91 8d 08 	lds	r24, 0x088D
    25a2:	90 91 8e 08 	lds	r25, 0x088E
	}
    25a6:	08 95       	ret

000025a8 <__subsf3>:
    25a8:	50 58       	subi	r21, 0x80	; 128

000025aa <__addsf3>:
    25aa:	bb 27       	eor	r27, r27
    25ac:	aa 27       	eor	r26, r26
    25ae:	0e d0       	rcall	.+28     	; 0x25cc <__addsf3x>
    25b0:	e5 c0       	rjmp	.+458    	; 0x277c <__fp_round>
    25b2:	d6 d0       	rcall	.+428    	; 0x2760 <__fp_pscA>
    25b4:	30 f0       	brcs	.+12     	; 0x25c2 <__addsf3+0x18>
    25b6:	db d0       	rcall	.+438    	; 0x276e <__fp_pscB>
    25b8:	20 f0       	brcs	.+8      	; 0x25c2 <__addsf3+0x18>
    25ba:	31 f4       	brne	.+12     	; 0x25c8 <__addsf3+0x1e>
    25bc:	9f 3f       	cpi	r25, 0xFF	; 255
    25be:	11 f4       	brne	.+4      	; 0x25c4 <__addsf3+0x1a>
    25c0:	1e f4       	brtc	.+6      	; 0x25c8 <__addsf3+0x1e>
    25c2:	cb c0       	rjmp	.+406    	; 0x275a <__fp_nan>
    25c4:	0e f4       	brtc	.+2      	; 0x25c8 <__addsf3+0x1e>
    25c6:	e0 95       	com	r30
    25c8:	e7 fb       	bst	r30, 7
    25ca:	c1 c0       	rjmp	.+386    	; 0x274e <__fp_inf>

000025cc <__addsf3x>:
    25cc:	e9 2f       	mov	r30, r25
    25ce:	e7 d0       	rcall	.+462    	; 0x279e <__fp_split3>
    25d0:	80 f3       	brcs	.-32     	; 0x25b2 <__addsf3+0x8>
    25d2:	ba 17       	cp	r27, r26
    25d4:	62 07       	cpc	r22, r18
    25d6:	73 07       	cpc	r23, r19
    25d8:	84 07       	cpc	r24, r20
    25da:	95 07       	cpc	r25, r21
    25dc:	18 f0       	brcs	.+6      	; 0x25e4 <__addsf3x+0x18>
    25de:	71 f4       	brne	.+28     	; 0x25fc <__addsf3x+0x30>
    25e0:	9e f5       	brtc	.+102    	; 0x2648 <__addsf3x+0x7c>
    25e2:	ff c0       	rjmp	.+510    	; 0x27e2 <__fp_zero>
    25e4:	0e f4       	brtc	.+2      	; 0x25e8 <__addsf3x+0x1c>
    25e6:	e0 95       	com	r30
    25e8:	0b 2e       	mov	r0, r27
    25ea:	ba 2f       	mov	r27, r26
    25ec:	a0 2d       	mov	r26, r0
    25ee:	0b 01       	movw	r0, r22
    25f0:	b9 01       	movw	r22, r18
    25f2:	90 01       	movw	r18, r0
    25f4:	0c 01       	movw	r0, r24
    25f6:	ca 01       	movw	r24, r20
    25f8:	a0 01       	movw	r20, r0
    25fa:	11 24       	eor	r1, r1
    25fc:	ff 27       	eor	r31, r31
    25fe:	59 1b       	sub	r21, r25
    2600:	99 f0       	breq	.+38     	; 0x2628 <__addsf3x+0x5c>
    2602:	59 3f       	cpi	r21, 0xF9	; 249
    2604:	50 f4       	brcc	.+20     	; 0x261a <__addsf3x+0x4e>
    2606:	50 3e       	cpi	r21, 0xE0	; 224
    2608:	68 f1       	brcs	.+90     	; 0x2664 <__addsf3x+0x98>
    260a:	1a 16       	cp	r1, r26
    260c:	f0 40       	sbci	r31, 0x00	; 0
    260e:	a2 2f       	mov	r26, r18
    2610:	23 2f       	mov	r18, r19
    2612:	34 2f       	mov	r19, r20
    2614:	44 27       	eor	r20, r20
    2616:	58 5f       	subi	r21, 0xF8	; 248
    2618:	f3 cf       	rjmp	.-26     	; 0x2600 <__addsf3x+0x34>
    261a:	46 95       	lsr	r20
    261c:	37 95       	ror	r19
    261e:	27 95       	ror	r18
    2620:	a7 95       	ror	r26
    2622:	f0 40       	sbci	r31, 0x00	; 0
    2624:	53 95       	inc	r21
    2626:	c9 f7       	brne	.-14     	; 0x261a <__addsf3x+0x4e>
    2628:	7e f4       	brtc	.+30     	; 0x2648 <__addsf3x+0x7c>
    262a:	1f 16       	cp	r1, r31
    262c:	ba 0b       	sbc	r27, r26
    262e:	62 0b       	sbc	r22, r18
    2630:	73 0b       	sbc	r23, r19
    2632:	84 0b       	sbc	r24, r20
    2634:	ba f0       	brmi	.+46     	; 0x2664 <__addsf3x+0x98>
    2636:	91 50       	subi	r25, 0x01	; 1
    2638:	a1 f0       	breq	.+40     	; 0x2662 <__addsf3x+0x96>
    263a:	ff 0f       	add	r31, r31
    263c:	bb 1f       	adc	r27, r27
    263e:	66 1f       	adc	r22, r22
    2640:	77 1f       	adc	r23, r23
    2642:	88 1f       	adc	r24, r24
    2644:	c2 f7       	brpl	.-16     	; 0x2636 <__addsf3x+0x6a>
    2646:	0e c0       	rjmp	.+28     	; 0x2664 <__addsf3x+0x98>
    2648:	ba 0f       	add	r27, r26
    264a:	62 1f       	adc	r22, r18
    264c:	73 1f       	adc	r23, r19
    264e:	84 1f       	adc	r24, r20
    2650:	48 f4       	brcc	.+18     	; 0x2664 <__addsf3x+0x98>
    2652:	87 95       	ror	r24
    2654:	77 95       	ror	r23
    2656:	67 95       	ror	r22
    2658:	b7 95       	ror	r27
    265a:	f7 95       	ror	r31
    265c:	9e 3f       	cpi	r25, 0xFE	; 254
    265e:	08 f0       	brcs	.+2      	; 0x2662 <__addsf3x+0x96>
    2660:	b3 cf       	rjmp	.-154    	; 0x25c8 <__addsf3+0x1e>
    2662:	93 95       	inc	r25
    2664:	88 0f       	add	r24, r24
    2666:	08 f0       	brcs	.+2      	; 0x266a <__addsf3x+0x9e>
    2668:	99 27       	eor	r25, r25
    266a:	ee 0f       	add	r30, r30
    266c:	97 95       	ror	r25
    266e:	87 95       	ror	r24
    2670:	08 95       	ret

00002672 <__fixsfsi>:
    2672:	04 d0       	rcall	.+8      	; 0x267c <__fixunssfsi>
    2674:	68 94       	set
    2676:	b1 11       	cpse	r27, r1
    2678:	b5 c0       	rjmp	.+362    	; 0x27e4 <__fp_szero>
    267a:	08 95       	ret

0000267c <__fixunssfsi>:
    267c:	98 d0       	rcall	.+304    	; 0x27ae <__fp_splitA>
    267e:	88 f0       	brcs	.+34     	; 0x26a2 <__fixunssfsi+0x26>
    2680:	9f 57       	subi	r25, 0x7F	; 127
    2682:	90 f0       	brcs	.+36     	; 0x26a8 <__fixunssfsi+0x2c>
    2684:	b9 2f       	mov	r27, r25
    2686:	99 27       	eor	r25, r25
    2688:	b7 51       	subi	r27, 0x17	; 23
    268a:	a0 f0       	brcs	.+40     	; 0x26b4 <__fixunssfsi+0x38>
    268c:	d1 f0       	breq	.+52     	; 0x26c2 <__fixunssfsi+0x46>
    268e:	66 0f       	add	r22, r22
    2690:	77 1f       	adc	r23, r23
    2692:	88 1f       	adc	r24, r24
    2694:	99 1f       	adc	r25, r25
    2696:	1a f0       	brmi	.+6      	; 0x269e <__fixunssfsi+0x22>
    2698:	ba 95       	dec	r27
    269a:	c9 f7       	brne	.-14     	; 0x268e <__fixunssfsi+0x12>
    269c:	12 c0       	rjmp	.+36     	; 0x26c2 <__fixunssfsi+0x46>
    269e:	b1 30       	cpi	r27, 0x01	; 1
    26a0:	81 f0       	breq	.+32     	; 0x26c2 <__fixunssfsi+0x46>
    26a2:	9f d0       	rcall	.+318    	; 0x27e2 <__fp_zero>
    26a4:	b1 e0       	ldi	r27, 0x01	; 1
    26a6:	08 95       	ret
    26a8:	9c c0       	rjmp	.+312    	; 0x27e2 <__fp_zero>
    26aa:	67 2f       	mov	r22, r23
    26ac:	78 2f       	mov	r23, r24
    26ae:	88 27       	eor	r24, r24
    26b0:	b8 5f       	subi	r27, 0xF8	; 248
    26b2:	39 f0       	breq	.+14     	; 0x26c2 <__fixunssfsi+0x46>
    26b4:	b9 3f       	cpi	r27, 0xF9	; 249
    26b6:	cc f3       	brlt	.-14     	; 0x26aa <__fixunssfsi+0x2e>
    26b8:	86 95       	lsr	r24
    26ba:	77 95       	ror	r23
    26bc:	67 95       	ror	r22
    26be:	b3 95       	inc	r27
    26c0:	d9 f7       	brne	.-10     	; 0x26b8 <__fixunssfsi+0x3c>
    26c2:	3e f4       	brtc	.+14     	; 0x26d2 <__fixunssfsi+0x56>
    26c4:	90 95       	com	r25
    26c6:	80 95       	com	r24
    26c8:	70 95       	com	r23
    26ca:	61 95       	neg	r22
    26cc:	7f 4f       	sbci	r23, 0xFF	; 255
    26ce:	8f 4f       	sbci	r24, 0xFF	; 255
    26d0:	9f 4f       	sbci	r25, 0xFF	; 255
    26d2:	08 95       	ret

000026d4 <__floatunsisf>:
    26d4:	e8 94       	clt
    26d6:	09 c0       	rjmp	.+18     	; 0x26ea <__floatsisf+0x12>

000026d8 <__floatsisf>:
    26d8:	97 fb       	bst	r25, 7
    26da:	3e f4       	brtc	.+14     	; 0x26ea <__floatsisf+0x12>
    26dc:	90 95       	com	r25
    26de:	80 95       	com	r24
    26e0:	70 95       	com	r23
    26e2:	61 95       	neg	r22
    26e4:	7f 4f       	sbci	r23, 0xFF	; 255
    26e6:	8f 4f       	sbci	r24, 0xFF	; 255
    26e8:	9f 4f       	sbci	r25, 0xFF	; 255
    26ea:	99 23       	and	r25, r25
    26ec:	a9 f0       	breq	.+42     	; 0x2718 <__floatsisf+0x40>
    26ee:	f9 2f       	mov	r31, r25
    26f0:	96 e9       	ldi	r25, 0x96	; 150
    26f2:	bb 27       	eor	r27, r27
    26f4:	93 95       	inc	r25
    26f6:	f6 95       	lsr	r31
    26f8:	87 95       	ror	r24
    26fa:	77 95       	ror	r23
    26fc:	67 95       	ror	r22
    26fe:	b7 95       	ror	r27
    2700:	f1 11       	cpse	r31, r1
    2702:	f8 cf       	rjmp	.-16     	; 0x26f4 <__floatsisf+0x1c>
    2704:	fa f4       	brpl	.+62     	; 0x2744 <__floatsisf+0x6c>
    2706:	bb 0f       	add	r27, r27
    2708:	11 f4       	brne	.+4      	; 0x270e <__floatsisf+0x36>
    270a:	60 ff       	sbrs	r22, 0
    270c:	1b c0       	rjmp	.+54     	; 0x2744 <__floatsisf+0x6c>
    270e:	6f 5f       	subi	r22, 0xFF	; 255
    2710:	7f 4f       	sbci	r23, 0xFF	; 255
    2712:	8f 4f       	sbci	r24, 0xFF	; 255
    2714:	9f 4f       	sbci	r25, 0xFF	; 255
    2716:	16 c0       	rjmp	.+44     	; 0x2744 <__floatsisf+0x6c>
    2718:	88 23       	and	r24, r24
    271a:	11 f0       	breq	.+4      	; 0x2720 <__floatsisf+0x48>
    271c:	96 e9       	ldi	r25, 0x96	; 150
    271e:	11 c0       	rjmp	.+34     	; 0x2742 <__floatsisf+0x6a>
    2720:	77 23       	and	r23, r23
    2722:	21 f0       	breq	.+8      	; 0x272c <__floatsisf+0x54>
    2724:	9e e8       	ldi	r25, 0x8E	; 142
    2726:	87 2f       	mov	r24, r23
    2728:	76 2f       	mov	r23, r22
    272a:	05 c0       	rjmp	.+10     	; 0x2736 <__floatsisf+0x5e>
    272c:	66 23       	and	r22, r22
    272e:	71 f0       	breq	.+28     	; 0x274c <__floatsisf+0x74>
    2730:	96 e8       	ldi	r25, 0x86	; 134
    2732:	86 2f       	mov	r24, r22
    2734:	70 e0       	ldi	r23, 0x00	; 0
    2736:	60 e0       	ldi	r22, 0x00	; 0
    2738:	2a f0       	brmi	.+10     	; 0x2744 <__floatsisf+0x6c>
    273a:	9a 95       	dec	r25
    273c:	66 0f       	add	r22, r22
    273e:	77 1f       	adc	r23, r23
    2740:	88 1f       	adc	r24, r24
    2742:	da f7       	brpl	.-10     	; 0x273a <__floatsisf+0x62>
    2744:	88 0f       	add	r24, r24
    2746:	96 95       	lsr	r25
    2748:	87 95       	ror	r24
    274a:	97 f9       	bld	r25, 7
    274c:	08 95       	ret

0000274e <__fp_inf>:
    274e:	97 f9       	bld	r25, 7
    2750:	9f 67       	ori	r25, 0x7F	; 127
    2752:	80 e8       	ldi	r24, 0x80	; 128
    2754:	70 e0       	ldi	r23, 0x00	; 0
    2756:	60 e0       	ldi	r22, 0x00	; 0
    2758:	08 95       	ret

0000275a <__fp_nan>:
    275a:	9f ef       	ldi	r25, 0xFF	; 255
    275c:	80 ec       	ldi	r24, 0xC0	; 192
    275e:	08 95       	ret

00002760 <__fp_pscA>:
    2760:	00 24       	eor	r0, r0
    2762:	0a 94       	dec	r0
    2764:	16 16       	cp	r1, r22
    2766:	17 06       	cpc	r1, r23
    2768:	18 06       	cpc	r1, r24
    276a:	09 06       	cpc	r0, r25
    276c:	08 95       	ret

0000276e <__fp_pscB>:
    276e:	00 24       	eor	r0, r0
    2770:	0a 94       	dec	r0
    2772:	12 16       	cp	r1, r18
    2774:	13 06       	cpc	r1, r19
    2776:	14 06       	cpc	r1, r20
    2778:	05 06       	cpc	r0, r21
    277a:	08 95       	ret

0000277c <__fp_round>:
    277c:	09 2e       	mov	r0, r25
    277e:	03 94       	inc	r0
    2780:	00 0c       	add	r0, r0
    2782:	11 f4       	brne	.+4      	; 0x2788 <__fp_round+0xc>
    2784:	88 23       	and	r24, r24
    2786:	52 f0       	brmi	.+20     	; 0x279c <__fp_round+0x20>
    2788:	bb 0f       	add	r27, r27
    278a:	40 f4       	brcc	.+16     	; 0x279c <__fp_round+0x20>
    278c:	bf 2b       	or	r27, r31
    278e:	11 f4       	brne	.+4      	; 0x2794 <__fp_round+0x18>
    2790:	60 ff       	sbrs	r22, 0
    2792:	04 c0       	rjmp	.+8      	; 0x279c <__fp_round+0x20>
    2794:	6f 5f       	subi	r22, 0xFF	; 255
    2796:	7f 4f       	sbci	r23, 0xFF	; 255
    2798:	8f 4f       	sbci	r24, 0xFF	; 255
    279a:	9f 4f       	sbci	r25, 0xFF	; 255
    279c:	08 95       	ret

0000279e <__fp_split3>:
    279e:	57 fd       	sbrc	r21, 7
    27a0:	90 58       	subi	r25, 0x80	; 128
    27a2:	44 0f       	add	r20, r20
    27a4:	55 1f       	adc	r21, r21
    27a6:	59 f0       	breq	.+22     	; 0x27be <__fp_splitA+0x10>
    27a8:	5f 3f       	cpi	r21, 0xFF	; 255
    27aa:	71 f0       	breq	.+28     	; 0x27c8 <__fp_splitA+0x1a>
    27ac:	47 95       	ror	r20

000027ae <__fp_splitA>:
    27ae:	88 0f       	add	r24, r24
    27b0:	97 fb       	bst	r25, 7
    27b2:	99 1f       	adc	r25, r25
    27b4:	61 f0       	breq	.+24     	; 0x27ce <__fp_splitA+0x20>
    27b6:	9f 3f       	cpi	r25, 0xFF	; 255
    27b8:	79 f0       	breq	.+30     	; 0x27d8 <__fp_splitA+0x2a>
    27ba:	87 95       	ror	r24
    27bc:	08 95       	ret
    27be:	12 16       	cp	r1, r18
    27c0:	13 06       	cpc	r1, r19
    27c2:	14 06       	cpc	r1, r20
    27c4:	55 1f       	adc	r21, r21
    27c6:	f2 cf       	rjmp	.-28     	; 0x27ac <__fp_split3+0xe>
    27c8:	46 95       	lsr	r20
    27ca:	f1 df       	rcall	.-30     	; 0x27ae <__fp_splitA>
    27cc:	08 c0       	rjmp	.+16     	; 0x27de <__fp_splitA+0x30>
    27ce:	16 16       	cp	r1, r22
    27d0:	17 06       	cpc	r1, r23
    27d2:	18 06       	cpc	r1, r24
    27d4:	99 1f       	adc	r25, r25
    27d6:	f1 cf       	rjmp	.-30     	; 0x27ba <__fp_splitA+0xc>
    27d8:	86 95       	lsr	r24
    27da:	71 05       	cpc	r23, r1
    27dc:	61 05       	cpc	r22, r1
    27de:	08 94       	sec
    27e0:	08 95       	ret

000027e2 <__fp_zero>:
    27e2:	e8 94       	clt

000027e4 <__fp_szero>:
    27e4:	bb 27       	eor	r27, r27
    27e6:	66 27       	eor	r22, r22
    27e8:	77 27       	eor	r23, r23
    27ea:	cb 01       	movw	r24, r22
    27ec:	97 f9       	bld	r25, 7
    27ee:	08 95       	ret

000027f0 <__mulsf3>:
    27f0:	0b d0       	rcall	.+22     	; 0x2808 <__mulsf3x>
    27f2:	c4 cf       	rjmp	.-120    	; 0x277c <__fp_round>
    27f4:	b5 df       	rcall	.-150    	; 0x2760 <__fp_pscA>
    27f6:	28 f0       	brcs	.+10     	; 0x2802 <__mulsf3+0x12>
    27f8:	ba df       	rcall	.-140    	; 0x276e <__fp_pscB>
    27fa:	18 f0       	brcs	.+6      	; 0x2802 <__mulsf3+0x12>
    27fc:	95 23       	and	r25, r21
    27fe:	09 f0       	breq	.+2      	; 0x2802 <__mulsf3+0x12>
    2800:	a6 cf       	rjmp	.-180    	; 0x274e <__fp_inf>
    2802:	ab cf       	rjmp	.-170    	; 0x275a <__fp_nan>
    2804:	11 24       	eor	r1, r1
    2806:	ee cf       	rjmp	.-36     	; 0x27e4 <__fp_szero>

00002808 <__mulsf3x>:
    2808:	ca df       	rcall	.-108    	; 0x279e <__fp_split3>
    280a:	a0 f3       	brcs	.-24     	; 0x27f4 <__mulsf3+0x4>

0000280c <__mulsf3_pse>:
    280c:	95 9f       	mul	r25, r21
    280e:	d1 f3       	breq	.-12     	; 0x2804 <__mulsf3+0x14>
    2810:	95 0f       	add	r25, r21
    2812:	50 e0       	ldi	r21, 0x00	; 0
    2814:	55 1f       	adc	r21, r21
    2816:	62 9f       	mul	r22, r18
    2818:	f0 01       	movw	r30, r0
    281a:	72 9f       	mul	r23, r18
    281c:	bb 27       	eor	r27, r27
    281e:	f0 0d       	add	r31, r0
    2820:	b1 1d       	adc	r27, r1
    2822:	63 9f       	mul	r22, r19
    2824:	aa 27       	eor	r26, r26
    2826:	f0 0d       	add	r31, r0
    2828:	b1 1d       	adc	r27, r1
    282a:	aa 1f       	adc	r26, r26
    282c:	64 9f       	mul	r22, r20
    282e:	66 27       	eor	r22, r22
    2830:	b0 0d       	add	r27, r0
    2832:	a1 1d       	adc	r26, r1
    2834:	66 1f       	adc	r22, r22
    2836:	82 9f       	mul	r24, r18
    2838:	22 27       	eor	r18, r18
    283a:	b0 0d       	add	r27, r0
    283c:	a1 1d       	adc	r26, r1
    283e:	62 1f       	adc	r22, r18
    2840:	73 9f       	mul	r23, r19
    2842:	b0 0d       	add	r27, r0
    2844:	a1 1d       	adc	r26, r1
    2846:	62 1f       	adc	r22, r18
    2848:	83 9f       	mul	r24, r19
    284a:	a0 0d       	add	r26, r0
    284c:	61 1d       	adc	r22, r1
    284e:	22 1f       	adc	r18, r18
    2850:	74 9f       	mul	r23, r20
    2852:	33 27       	eor	r19, r19
    2854:	a0 0d       	add	r26, r0
    2856:	61 1d       	adc	r22, r1
    2858:	23 1f       	adc	r18, r19
    285a:	84 9f       	mul	r24, r20
    285c:	60 0d       	add	r22, r0
    285e:	21 1d       	adc	r18, r1
    2860:	82 2f       	mov	r24, r18
    2862:	76 2f       	mov	r23, r22
    2864:	6a 2f       	mov	r22, r26
    2866:	11 24       	eor	r1, r1
    2868:	9f 57       	subi	r25, 0x7F	; 127
    286a:	50 40       	sbci	r21, 0x00	; 0
    286c:	8a f0       	brmi	.+34     	; 0x2890 <__mulsf3_pse+0x84>
    286e:	e1 f0       	breq	.+56     	; 0x28a8 <__mulsf3_pse+0x9c>
    2870:	88 23       	and	r24, r24
    2872:	4a f0       	brmi	.+18     	; 0x2886 <__mulsf3_pse+0x7a>
    2874:	ee 0f       	add	r30, r30
    2876:	ff 1f       	adc	r31, r31
    2878:	bb 1f       	adc	r27, r27
    287a:	66 1f       	adc	r22, r22
    287c:	77 1f       	adc	r23, r23
    287e:	88 1f       	adc	r24, r24
    2880:	91 50       	subi	r25, 0x01	; 1
    2882:	50 40       	sbci	r21, 0x00	; 0
    2884:	a9 f7       	brne	.-22     	; 0x2870 <__mulsf3_pse+0x64>
    2886:	9e 3f       	cpi	r25, 0xFE	; 254
    2888:	51 05       	cpc	r21, r1
    288a:	70 f0       	brcs	.+28     	; 0x28a8 <__mulsf3_pse+0x9c>
    288c:	60 cf       	rjmp	.-320    	; 0x274e <__fp_inf>
    288e:	aa cf       	rjmp	.-172    	; 0x27e4 <__fp_szero>
    2890:	5f 3f       	cpi	r21, 0xFF	; 255
    2892:	ec f3       	brlt	.-6      	; 0x288e <__mulsf3_pse+0x82>
    2894:	98 3e       	cpi	r25, 0xE8	; 232
    2896:	dc f3       	brlt	.-10     	; 0x288e <__mulsf3_pse+0x82>
    2898:	86 95       	lsr	r24
    289a:	77 95       	ror	r23
    289c:	67 95       	ror	r22
    289e:	b7 95       	ror	r27
    28a0:	f7 95       	ror	r31
    28a2:	e7 95       	ror	r30
    28a4:	9f 5f       	subi	r25, 0xFF	; 255
    28a6:	c1 f7       	brne	.-16     	; 0x2898 <__mulsf3_pse+0x8c>
    28a8:	fe 2b       	or	r31, r30
    28aa:	88 0f       	add	r24, r24
    28ac:	91 1d       	adc	r25, r1
    28ae:	96 95       	lsr	r25
    28b0:	87 95       	ror	r24
    28b2:	97 f9       	bld	r25, 7
    28b4:	08 95       	ret

000028b6 <pow>:
    28b6:	fa 01       	movw	r30, r20
    28b8:	ee 0f       	add	r30, r30
    28ba:	ff 1f       	adc	r31, r31
    28bc:	30 96       	adiw	r30, 0x00	; 0
    28be:	21 05       	cpc	r18, r1
    28c0:	31 05       	cpc	r19, r1
    28c2:	99 f1       	breq	.+102    	; 0x292a <pow+0x74>
    28c4:	61 15       	cp	r22, r1
    28c6:	71 05       	cpc	r23, r1
    28c8:	61 f4       	brne	.+24     	; 0x28e2 <pow+0x2c>
    28ca:	80 38       	cpi	r24, 0x80	; 128
    28cc:	bf e3       	ldi	r27, 0x3F	; 63
    28ce:	9b 07       	cpc	r25, r27
    28d0:	49 f1       	breq	.+82     	; 0x2924 <pow+0x6e>
    28d2:	68 94       	set
    28d4:	90 38       	cpi	r25, 0x80	; 128
    28d6:	81 05       	cpc	r24, r1
    28d8:	61 f0       	breq	.+24     	; 0x28f2 <pow+0x3c>
    28da:	80 38       	cpi	r24, 0x80	; 128
    28dc:	bf ef       	ldi	r27, 0xFF	; 255
    28de:	9b 07       	cpc	r25, r27
    28e0:	41 f0       	breq	.+16     	; 0x28f2 <pow+0x3c>
    28e2:	99 23       	and	r25, r25
    28e4:	42 f5       	brpl	.+80     	; 0x2936 <pow+0x80>
    28e6:	ff 3f       	cpi	r31, 0xFF	; 255
    28e8:	e1 05       	cpc	r30, r1
    28ea:	31 05       	cpc	r19, r1
    28ec:	21 05       	cpc	r18, r1
    28ee:	11 f1       	breq	.+68     	; 0x2934 <pow+0x7e>
    28f0:	e8 94       	clt
    28f2:	08 94       	sec
    28f4:	e7 95       	ror	r30
    28f6:	d9 01       	movw	r26, r18
    28f8:	aa 23       	and	r26, r26
    28fa:	29 f4       	brne	.+10     	; 0x2906 <pow+0x50>
    28fc:	ab 2f       	mov	r26, r27
    28fe:	be 2f       	mov	r27, r30
    2900:	f8 5f       	subi	r31, 0xF8	; 248
    2902:	d0 f3       	brcs	.-12     	; 0x28f8 <pow+0x42>
    2904:	10 c0       	rjmp	.+32     	; 0x2926 <pow+0x70>
    2906:	ff 5f       	subi	r31, 0xFF	; 255
    2908:	70 f4       	brcc	.+28     	; 0x2926 <pow+0x70>
    290a:	a6 95       	lsr	r26
    290c:	e0 f7       	brcc	.-8      	; 0x2906 <pow+0x50>
    290e:	f7 39       	cpi	r31, 0x97	; 151
    2910:	50 f0       	brcs	.+20     	; 0x2926 <pow+0x70>
    2912:	19 f0       	breq	.+6      	; 0x291a <pow+0x64>
    2914:	ff 3a       	cpi	r31, 0xAF	; 175
    2916:	38 f4       	brcc	.+14     	; 0x2926 <pow+0x70>
    2918:	9f 77       	andi	r25, 0x7F	; 127
    291a:	9f 93       	push	r25
    291c:	0c d0       	rcall	.+24     	; 0x2936 <pow+0x80>
    291e:	0f 90       	pop	r0
    2920:	07 fc       	sbrc	r0, 7
    2922:	90 58       	subi	r25, 0x80	; 128
    2924:	08 95       	ret
    2926:	3e f0       	brts	.+14     	; 0x2936 <pow+0x80>
    2928:	18 cf       	rjmp	.-464    	; 0x275a <__fp_nan>
    292a:	60 e0       	ldi	r22, 0x00	; 0
    292c:	70 e0       	ldi	r23, 0x00	; 0
    292e:	80 e8       	ldi	r24, 0x80	; 128
    2930:	9f e3       	ldi	r25, 0x3F	; 63
    2932:	08 95       	ret
    2934:	4f e7       	ldi	r20, 0x7F	; 127
    2936:	9f 77       	andi	r25, 0x7F	; 127
    2938:	5f 93       	push	r21
    293a:	4f 93       	push	r20
    293c:	3f 93       	push	r19
    293e:	2f 93       	push	r18
    2940:	9e d0       	rcall	.+316    	; 0x2a7e <log>
    2942:	2f 91       	pop	r18
    2944:	3f 91       	pop	r19
    2946:	4f 91       	pop	r20
    2948:	5f 91       	pop	r21
    294a:	52 df       	rcall	.-348    	; 0x27f0 <__mulsf3>
    294c:	05 c0       	rjmp	.+10     	; 0x2958 <exp>
    294e:	19 f4       	brne	.+6      	; 0x2956 <pow+0xa0>
    2950:	0e f0       	brts	.+2      	; 0x2954 <pow+0x9e>
    2952:	fd ce       	rjmp	.-518    	; 0x274e <__fp_inf>
    2954:	46 cf       	rjmp	.-372    	; 0x27e2 <__fp_zero>
    2956:	01 cf       	rjmp	.-510    	; 0x275a <__fp_nan>

00002958 <exp>:
    2958:	2a df       	rcall	.-428    	; 0x27ae <__fp_splitA>
    295a:	c8 f3       	brcs	.-14     	; 0x294e <pow+0x98>
    295c:	96 38       	cpi	r25, 0x86	; 134
    295e:	c0 f7       	brcc	.-16     	; 0x2950 <pow+0x9a>
    2960:	07 f8       	bld	r0, 7
    2962:	0f 92       	push	r0
    2964:	e8 94       	clt
    2966:	2b e3       	ldi	r18, 0x3B	; 59
    2968:	3a ea       	ldi	r19, 0xAA	; 170
    296a:	48 eb       	ldi	r20, 0xB8	; 184
    296c:	5f e7       	ldi	r21, 0x7F	; 127
    296e:	4e df       	rcall	.-356    	; 0x280c <__mulsf3_pse>
    2970:	0f 92       	push	r0
    2972:	0f 92       	push	r0
    2974:	0f 92       	push	r0
    2976:	4d b7       	in	r20, 0x3d	; 61
    2978:	5e b7       	in	r21, 0x3e	; 62
    297a:	0f 92       	push	r0
    297c:	c0 d0       	rcall	.+384    	; 0x2afe <modf>
    297e:	e4 ee       	ldi	r30, 0xE4	; 228
    2980:	f0 e0       	ldi	r31, 0x00	; 0
    2982:	16 d0       	rcall	.+44     	; 0x29b0 <__fp_powser>
    2984:	4f 91       	pop	r20
    2986:	5f 91       	pop	r21
    2988:	ef 91       	pop	r30
    298a:	ff 91       	pop	r31
    298c:	e5 95       	asr	r30
    298e:	ee 1f       	adc	r30, r30
    2990:	ff 1f       	adc	r31, r31
    2992:	49 f0       	breq	.+18     	; 0x29a6 <exp+0x4e>
    2994:	fe 57       	subi	r31, 0x7E	; 126
    2996:	e0 68       	ori	r30, 0x80	; 128
    2998:	44 27       	eor	r20, r20
    299a:	ee 0f       	add	r30, r30
    299c:	44 1f       	adc	r20, r20
    299e:	fa 95       	dec	r31
    29a0:	e1 f7       	brne	.-8      	; 0x299a <exp+0x42>
    29a2:	41 95       	neg	r20
    29a4:	55 0b       	sbc	r21, r21
    29a6:	32 d0       	rcall	.+100    	; 0x2a0c <ldexp>
    29a8:	0f 90       	pop	r0
    29aa:	07 fe       	sbrs	r0, 7
    29ac:	26 c0       	rjmp	.+76     	; 0x29fa <inverse>
    29ae:	08 95       	ret

000029b0 <__fp_powser>:
    29b0:	df 93       	push	r29
    29b2:	cf 93       	push	r28
    29b4:	1f 93       	push	r17
    29b6:	0f 93       	push	r16
    29b8:	ff 92       	push	r15
    29ba:	ef 92       	push	r14
    29bc:	df 92       	push	r13
    29be:	7b 01       	movw	r14, r22
    29c0:	8c 01       	movw	r16, r24
    29c2:	68 94       	set
    29c4:	05 c0       	rjmp	.+10     	; 0x29d0 <__fp_powser+0x20>
    29c6:	da 2e       	mov	r13, r26
    29c8:	ef 01       	movw	r28, r30
    29ca:	1e df       	rcall	.-452    	; 0x2808 <__mulsf3x>
    29cc:	fe 01       	movw	r30, r28
    29ce:	e8 94       	clt
    29d0:	a5 91       	lpm	r26, Z+
    29d2:	25 91       	lpm	r18, Z+
    29d4:	35 91       	lpm	r19, Z+
    29d6:	45 91       	lpm	r20, Z+
    29d8:	55 91       	lpm	r21, Z+
    29da:	ae f3       	brts	.-22     	; 0x29c6 <__fp_powser+0x16>
    29dc:	ef 01       	movw	r28, r30
    29de:	f6 dd       	rcall	.-1044   	; 0x25cc <__addsf3x>
    29e0:	fe 01       	movw	r30, r28
    29e2:	97 01       	movw	r18, r14
    29e4:	a8 01       	movw	r20, r16
    29e6:	da 94       	dec	r13
    29e8:	79 f7       	brne	.-34     	; 0x29c8 <__fp_powser+0x18>
    29ea:	df 90       	pop	r13
    29ec:	ef 90       	pop	r14
    29ee:	ff 90       	pop	r15
    29f0:	0f 91       	pop	r16
    29f2:	1f 91       	pop	r17
    29f4:	cf 91       	pop	r28
    29f6:	df 91       	pop	r29
    29f8:	08 95       	ret

000029fa <inverse>:
    29fa:	9b 01       	movw	r18, r22
    29fc:	ac 01       	movw	r20, r24
    29fe:	60 e0       	ldi	r22, 0x00	; 0
    2a00:	70 e0       	ldi	r23, 0x00	; 0
    2a02:	80 e8       	ldi	r24, 0x80	; 128
    2a04:	9f e3       	ldi	r25, 0x3F	; 63
    2a06:	ae c0       	rjmp	.+348    	; 0x2b64 <__divsf3>
    2a08:	a2 ce       	rjmp	.-700    	; 0x274e <__fp_inf>
    2a0a:	14 c1       	rjmp	.+552    	; 0x2c34 <__fp_mpack>

00002a0c <ldexp>:
    2a0c:	d0 de       	rcall	.-608    	; 0x27ae <__fp_splitA>
    2a0e:	e8 f3       	brcs	.-6      	; 0x2a0a <inverse+0x10>
    2a10:	99 23       	and	r25, r25
    2a12:	d9 f3       	breq	.-10     	; 0x2a0a <inverse+0x10>
    2a14:	94 0f       	add	r25, r20
    2a16:	51 1d       	adc	r21, r1
    2a18:	bb f3       	brvs	.-18     	; 0x2a08 <inverse+0xe>
    2a1a:	91 50       	subi	r25, 0x01	; 1
    2a1c:	50 40       	sbci	r21, 0x00	; 0
    2a1e:	94 f0       	brlt	.+36     	; 0x2a44 <ldexp+0x38>
    2a20:	59 f0       	breq	.+22     	; 0x2a38 <ldexp+0x2c>
    2a22:	88 23       	and	r24, r24
    2a24:	32 f0       	brmi	.+12     	; 0x2a32 <ldexp+0x26>
    2a26:	66 0f       	add	r22, r22
    2a28:	77 1f       	adc	r23, r23
    2a2a:	88 1f       	adc	r24, r24
    2a2c:	91 50       	subi	r25, 0x01	; 1
    2a2e:	50 40       	sbci	r21, 0x00	; 0
    2a30:	c1 f7       	brne	.-16     	; 0x2a22 <ldexp+0x16>
    2a32:	9e 3f       	cpi	r25, 0xFE	; 254
    2a34:	51 05       	cpc	r21, r1
    2a36:	44 f7       	brge	.-48     	; 0x2a08 <inverse+0xe>
    2a38:	88 0f       	add	r24, r24
    2a3a:	91 1d       	adc	r25, r1
    2a3c:	96 95       	lsr	r25
    2a3e:	87 95       	ror	r24
    2a40:	97 f9       	bld	r25, 7
    2a42:	08 95       	ret
    2a44:	5f 3f       	cpi	r21, 0xFF	; 255
    2a46:	ac f0       	brlt	.+42     	; 0x2a72 <ldexp+0x66>
    2a48:	98 3e       	cpi	r25, 0xE8	; 232
    2a4a:	9c f0       	brlt	.+38     	; 0x2a72 <ldexp+0x66>
    2a4c:	bb 27       	eor	r27, r27
    2a4e:	86 95       	lsr	r24
    2a50:	77 95       	ror	r23
    2a52:	67 95       	ror	r22
    2a54:	b7 95       	ror	r27
    2a56:	08 f4       	brcc	.+2      	; 0x2a5a <ldexp+0x4e>
    2a58:	b1 60       	ori	r27, 0x01	; 1
    2a5a:	93 95       	inc	r25
    2a5c:	c1 f7       	brne	.-16     	; 0x2a4e <ldexp+0x42>
    2a5e:	bb 0f       	add	r27, r27
    2a60:	58 f7       	brcc	.-42     	; 0x2a38 <ldexp+0x2c>
    2a62:	11 f4       	brne	.+4      	; 0x2a68 <ldexp+0x5c>
    2a64:	60 ff       	sbrs	r22, 0
    2a66:	e8 cf       	rjmp	.-48     	; 0x2a38 <ldexp+0x2c>
    2a68:	6f 5f       	subi	r22, 0xFF	; 255
    2a6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a6c:	8f 4f       	sbci	r24, 0xFF	; 255
    2a6e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a70:	e3 cf       	rjmp	.-58     	; 0x2a38 <ldexp+0x2c>
    2a72:	b8 ce       	rjmp	.-656    	; 0x27e4 <__fp_szero>
    2a74:	0e f0       	brts	.+2      	; 0x2a78 <ldexp+0x6c>
    2a76:	de c0       	rjmp	.+444    	; 0x2c34 <__fp_mpack>
    2a78:	70 ce       	rjmp	.-800    	; 0x275a <__fp_nan>
    2a7a:	68 94       	set
    2a7c:	68 ce       	rjmp	.-816    	; 0x274e <__fp_inf>

00002a7e <log>:
    2a7e:	97 de       	rcall	.-722    	; 0x27ae <__fp_splitA>
    2a80:	c8 f3       	brcs	.-14     	; 0x2a74 <ldexp+0x68>
    2a82:	99 23       	and	r25, r25
    2a84:	d1 f3       	breq	.-12     	; 0x2a7a <ldexp+0x6e>
    2a86:	c6 f3       	brts	.-16     	; 0x2a78 <ldexp+0x6c>
    2a88:	df 93       	push	r29
    2a8a:	cf 93       	push	r28
    2a8c:	1f 93       	push	r17
    2a8e:	0f 93       	push	r16
    2a90:	ff 92       	push	r15
    2a92:	c9 2f       	mov	r28, r25
    2a94:	dd 27       	eor	r29, r29
    2a96:	88 23       	and	r24, r24
    2a98:	2a f0       	brmi	.+10     	; 0x2aa4 <log+0x26>
    2a9a:	21 97       	sbiw	r28, 0x01	; 1
    2a9c:	66 0f       	add	r22, r22
    2a9e:	77 1f       	adc	r23, r23
    2aa0:	88 1f       	adc	r24, r24
    2aa2:	da f7       	brpl	.-10     	; 0x2a9a <log+0x1c>
    2aa4:	20 e0       	ldi	r18, 0x00	; 0
    2aa6:	30 e0       	ldi	r19, 0x00	; 0
    2aa8:	40 e8       	ldi	r20, 0x80	; 128
    2aaa:	5f eb       	ldi	r21, 0xBF	; 191
    2aac:	9f e3       	ldi	r25, 0x3F	; 63
    2aae:	88 39       	cpi	r24, 0x98	; 152
    2ab0:	20 f0       	brcs	.+8      	; 0x2aba <log+0x3c>
    2ab2:	80 3e       	cpi	r24, 0xE0	; 224
    2ab4:	30 f0       	brcs	.+12     	; 0x2ac2 <log+0x44>
    2ab6:	21 96       	adiw	r28, 0x01	; 1
    2ab8:	8f 77       	andi	r24, 0x7F	; 127
    2aba:	77 dd       	rcall	.-1298   	; 0x25aa <__addsf3>
    2abc:	ec e0       	ldi	r30, 0x0C	; 12
    2abe:	f1 e0       	ldi	r31, 0x01	; 1
    2ac0:	03 c0       	rjmp	.+6      	; 0x2ac8 <log+0x4a>
    2ac2:	73 dd       	rcall	.-1306   	; 0x25aa <__addsf3>
    2ac4:	e9 e3       	ldi	r30, 0x39	; 57
    2ac6:	f1 e0       	ldi	r31, 0x01	; 1
    2ac8:	73 df       	rcall	.-282    	; 0x29b0 <__fp_powser>
    2aca:	8b 01       	movw	r16, r22
    2acc:	be 01       	movw	r22, r28
    2ace:	ec 01       	movw	r28, r24
    2ad0:	fb 2e       	mov	r15, r27
    2ad2:	6f 57       	subi	r22, 0x7F	; 127
    2ad4:	71 09       	sbc	r23, r1
    2ad6:	75 95       	asr	r23
    2ad8:	77 1f       	adc	r23, r23
    2ada:	88 0b       	sbc	r24, r24
    2adc:	99 0b       	sbc	r25, r25
    2ade:	fc dd       	rcall	.-1032   	; 0x26d8 <__floatsisf>
    2ae0:	28 e1       	ldi	r18, 0x18	; 24
    2ae2:	32 e7       	ldi	r19, 0x72	; 114
    2ae4:	41 e3       	ldi	r20, 0x31	; 49
    2ae6:	5f e3       	ldi	r21, 0x3F	; 63
    2ae8:	8f de       	rcall	.-738    	; 0x2808 <__mulsf3x>
    2aea:	af 2d       	mov	r26, r15
    2aec:	98 01       	movw	r18, r16
    2aee:	ae 01       	movw	r20, r28
    2af0:	ff 90       	pop	r15
    2af2:	0f 91       	pop	r16
    2af4:	1f 91       	pop	r17
    2af6:	cf 91       	pop	r28
    2af8:	df 91       	pop	r29
    2afa:	68 dd       	rcall	.-1328   	; 0x25cc <__addsf3x>
    2afc:	3f ce       	rjmp	.-898    	; 0x277c <__fp_round>

00002afe <modf>:
    2afe:	fa 01       	movw	r30, r20
    2b00:	dc 01       	movw	r26, r24
    2b02:	aa 0f       	add	r26, r26
    2b04:	bb 1f       	adc	r27, r27
    2b06:	9b 01       	movw	r18, r22
    2b08:	ac 01       	movw	r20, r24
    2b0a:	bf 57       	subi	r27, 0x7F	; 127
    2b0c:	28 f4       	brcc	.+10     	; 0x2b18 <modf+0x1a>
    2b0e:	22 27       	eor	r18, r18
    2b10:	33 27       	eor	r19, r19
    2b12:	44 27       	eor	r20, r20
    2b14:	50 78       	andi	r21, 0x80	; 128
    2b16:	1f c0       	rjmp	.+62     	; 0x2b56 <modf+0x58>
    2b18:	b7 51       	subi	r27, 0x17	; 23
    2b1a:	88 f4       	brcc	.+34     	; 0x2b3e <modf+0x40>
    2b1c:	ab 2f       	mov	r26, r27
    2b1e:	00 24       	eor	r0, r0
    2b20:	46 95       	lsr	r20
    2b22:	37 95       	ror	r19
    2b24:	27 95       	ror	r18
    2b26:	01 1c       	adc	r0, r1
    2b28:	a3 95       	inc	r26
    2b2a:	d2 f3       	brmi	.-12     	; 0x2b20 <modf+0x22>
    2b2c:	00 20       	and	r0, r0
    2b2e:	69 f0       	breq	.+26     	; 0x2b4a <modf+0x4c>
    2b30:	22 0f       	add	r18, r18
    2b32:	33 1f       	adc	r19, r19
    2b34:	44 1f       	adc	r20, r20
    2b36:	b3 95       	inc	r27
    2b38:	da f3       	brmi	.-10     	; 0x2b30 <modf+0x32>
    2b3a:	0d d0       	rcall	.+26     	; 0x2b56 <modf+0x58>
    2b3c:	35 cd       	rjmp	.-1430   	; 0x25a8 <__subsf3>
    2b3e:	61 30       	cpi	r22, 0x01	; 1
    2b40:	71 05       	cpc	r23, r1
    2b42:	a0 e8       	ldi	r26, 0x80	; 128
    2b44:	8a 07       	cpc	r24, r26
    2b46:	b9 46       	sbci	r27, 0x69	; 105
    2b48:	30 f4       	brcc	.+12     	; 0x2b56 <modf+0x58>
    2b4a:	9b 01       	movw	r18, r22
    2b4c:	ac 01       	movw	r20, r24
    2b4e:	66 27       	eor	r22, r22
    2b50:	77 27       	eor	r23, r23
    2b52:	88 27       	eor	r24, r24
    2b54:	90 78       	andi	r25, 0x80	; 128
    2b56:	30 96       	adiw	r30, 0x00	; 0
    2b58:	21 f0       	breq	.+8      	; 0x2b62 <modf+0x64>
    2b5a:	20 83       	st	Z, r18
    2b5c:	31 83       	std	Z+1, r19	; 0x01
    2b5e:	42 83       	std	Z+2, r20	; 0x02
    2b60:	53 83       	std	Z+3, r21	; 0x03
    2b62:	08 95       	ret

00002b64 <__divsf3>:
    2b64:	0c d0       	rcall	.+24     	; 0x2b7e <__divsf3x>
    2b66:	0a ce       	rjmp	.-1004   	; 0x277c <__fp_round>
    2b68:	02 de       	rcall	.-1020   	; 0x276e <__fp_pscB>
    2b6a:	40 f0       	brcs	.+16     	; 0x2b7c <__divsf3+0x18>
    2b6c:	f9 dd       	rcall	.-1038   	; 0x2760 <__fp_pscA>
    2b6e:	30 f0       	brcs	.+12     	; 0x2b7c <__divsf3+0x18>
    2b70:	21 f4       	brne	.+8      	; 0x2b7a <__divsf3+0x16>
    2b72:	5f 3f       	cpi	r21, 0xFF	; 255
    2b74:	19 f0       	breq	.+6      	; 0x2b7c <__divsf3+0x18>
    2b76:	eb cd       	rjmp	.-1066   	; 0x274e <__fp_inf>
    2b78:	51 11       	cpse	r21, r1
    2b7a:	34 ce       	rjmp	.-920    	; 0x27e4 <__fp_szero>
    2b7c:	ee cd       	rjmp	.-1060   	; 0x275a <__fp_nan>

00002b7e <__divsf3x>:
    2b7e:	0f de       	rcall	.-994    	; 0x279e <__fp_split3>
    2b80:	98 f3       	brcs	.-26     	; 0x2b68 <__divsf3+0x4>

00002b82 <__divsf3_pse>:
    2b82:	99 23       	and	r25, r25
    2b84:	c9 f3       	breq	.-14     	; 0x2b78 <__divsf3+0x14>
    2b86:	55 23       	and	r21, r21
    2b88:	b1 f3       	breq	.-20     	; 0x2b76 <__divsf3+0x12>
    2b8a:	95 1b       	sub	r25, r21
    2b8c:	55 0b       	sbc	r21, r21
    2b8e:	bb 27       	eor	r27, r27
    2b90:	aa 27       	eor	r26, r26
    2b92:	62 17       	cp	r22, r18
    2b94:	73 07       	cpc	r23, r19
    2b96:	84 07       	cpc	r24, r20
    2b98:	38 f0       	brcs	.+14     	; 0x2ba8 <__divsf3_pse+0x26>
    2b9a:	9f 5f       	subi	r25, 0xFF	; 255
    2b9c:	5f 4f       	sbci	r21, 0xFF	; 255
    2b9e:	22 0f       	add	r18, r18
    2ba0:	33 1f       	adc	r19, r19
    2ba2:	44 1f       	adc	r20, r20
    2ba4:	aa 1f       	adc	r26, r26
    2ba6:	a9 f3       	breq	.-22     	; 0x2b92 <__divsf3_pse+0x10>
    2ba8:	33 d0       	rcall	.+102    	; 0x2c10 <__divsf3_pse+0x8e>
    2baa:	0e 2e       	mov	r0, r30
    2bac:	3a f0       	brmi	.+14     	; 0x2bbc <__divsf3_pse+0x3a>
    2bae:	e0 e8       	ldi	r30, 0x80	; 128
    2bb0:	30 d0       	rcall	.+96     	; 0x2c12 <__divsf3_pse+0x90>
    2bb2:	91 50       	subi	r25, 0x01	; 1
    2bb4:	50 40       	sbci	r21, 0x00	; 0
    2bb6:	e6 95       	lsr	r30
    2bb8:	00 1c       	adc	r0, r0
    2bba:	ca f7       	brpl	.-14     	; 0x2bae <__divsf3_pse+0x2c>
    2bbc:	29 d0       	rcall	.+82     	; 0x2c10 <__divsf3_pse+0x8e>
    2bbe:	fe 2f       	mov	r31, r30
    2bc0:	27 d0       	rcall	.+78     	; 0x2c10 <__divsf3_pse+0x8e>
    2bc2:	66 0f       	add	r22, r22
    2bc4:	77 1f       	adc	r23, r23
    2bc6:	88 1f       	adc	r24, r24
    2bc8:	bb 1f       	adc	r27, r27
    2bca:	26 17       	cp	r18, r22
    2bcc:	37 07       	cpc	r19, r23
    2bce:	48 07       	cpc	r20, r24
    2bd0:	ab 07       	cpc	r26, r27
    2bd2:	b0 e8       	ldi	r27, 0x80	; 128
    2bd4:	09 f0       	breq	.+2      	; 0x2bd8 <__divsf3_pse+0x56>
    2bd6:	bb 0b       	sbc	r27, r27
    2bd8:	80 2d       	mov	r24, r0
    2bda:	bf 01       	movw	r22, r30
    2bdc:	ff 27       	eor	r31, r31
    2bde:	93 58       	subi	r25, 0x83	; 131
    2be0:	5f 4f       	sbci	r21, 0xFF	; 255
    2be2:	2a f0       	brmi	.+10     	; 0x2bee <__divsf3_pse+0x6c>
    2be4:	9e 3f       	cpi	r25, 0xFE	; 254
    2be6:	51 05       	cpc	r21, r1
    2be8:	68 f0       	brcs	.+26     	; 0x2c04 <__divsf3_pse+0x82>
    2bea:	b1 cd       	rjmp	.-1182   	; 0x274e <__fp_inf>
    2bec:	fb cd       	rjmp	.-1034   	; 0x27e4 <__fp_szero>
    2bee:	5f 3f       	cpi	r21, 0xFF	; 255
    2bf0:	ec f3       	brlt	.-6      	; 0x2bec <__divsf3_pse+0x6a>
    2bf2:	98 3e       	cpi	r25, 0xE8	; 232
    2bf4:	dc f3       	brlt	.-10     	; 0x2bec <__divsf3_pse+0x6a>
    2bf6:	86 95       	lsr	r24
    2bf8:	77 95       	ror	r23
    2bfa:	67 95       	ror	r22
    2bfc:	b7 95       	ror	r27
    2bfe:	f7 95       	ror	r31
    2c00:	9f 5f       	subi	r25, 0xFF	; 255
    2c02:	c9 f7       	brne	.-14     	; 0x2bf6 <__divsf3_pse+0x74>
    2c04:	88 0f       	add	r24, r24
    2c06:	91 1d       	adc	r25, r1
    2c08:	96 95       	lsr	r25
    2c0a:	87 95       	ror	r24
    2c0c:	97 f9       	bld	r25, 7
    2c0e:	08 95       	ret
    2c10:	e1 e0       	ldi	r30, 0x01	; 1
    2c12:	66 0f       	add	r22, r22
    2c14:	77 1f       	adc	r23, r23
    2c16:	88 1f       	adc	r24, r24
    2c18:	bb 1f       	adc	r27, r27
    2c1a:	62 17       	cp	r22, r18
    2c1c:	73 07       	cpc	r23, r19
    2c1e:	84 07       	cpc	r24, r20
    2c20:	ba 07       	cpc	r27, r26
    2c22:	20 f0       	brcs	.+8      	; 0x2c2c <__divsf3_pse+0xaa>
    2c24:	62 1b       	sub	r22, r18
    2c26:	73 0b       	sbc	r23, r19
    2c28:	84 0b       	sbc	r24, r20
    2c2a:	ba 0b       	sbc	r27, r26
    2c2c:	ee 1f       	adc	r30, r30
    2c2e:	88 f7       	brcc	.-30     	; 0x2c12 <__divsf3_pse+0x90>
    2c30:	e0 95       	com	r30
    2c32:	08 95       	ret

00002c34 <__fp_mpack>:
    2c34:	9f 3f       	cpi	r25, 0xFF	; 255
    2c36:	31 f0       	breq	.+12     	; 0x2c44 <__fp_mpack_finite+0xc>

00002c38 <__fp_mpack_finite>:
    2c38:	91 50       	subi	r25, 0x01	; 1
    2c3a:	20 f4       	brcc	.+8      	; 0x2c44 <__fp_mpack_finite+0xc>
    2c3c:	87 95       	ror	r24
    2c3e:	77 95       	ror	r23
    2c40:	67 95       	ror	r22
    2c42:	b7 95       	ror	r27
    2c44:	88 0f       	add	r24, r24
    2c46:	91 1d       	adc	r25, r1
    2c48:	96 95       	lsr	r25
    2c4a:	87 95       	ror	r24
    2c4c:	97 f9       	bld	r25, 7
    2c4e:	08 95       	ret

00002c50 <__divmodhi4>:
    2c50:	97 fb       	bst	r25, 7
    2c52:	07 2e       	mov	r0, r23
    2c54:	16 f4       	brtc	.+4      	; 0x2c5a <__divmodhi4+0xa>
    2c56:	00 94       	com	r0
    2c58:	06 d0       	rcall	.+12     	; 0x2c66 <__divmodhi4_neg1>
    2c5a:	77 fd       	sbrc	r23, 7
    2c5c:	08 d0       	rcall	.+16     	; 0x2c6e <__divmodhi4_neg2>
    2c5e:	0b d0       	rcall	.+22     	; 0x2c76 <__udivmodhi4>
    2c60:	07 fc       	sbrc	r0, 7
    2c62:	05 d0       	rcall	.+10     	; 0x2c6e <__divmodhi4_neg2>
    2c64:	3e f4       	brtc	.+14     	; 0x2c74 <__divmodhi4_exit>

00002c66 <__divmodhi4_neg1>:
    2c66:	90 95       	com	r25
    2c68:	81 95       	neg	r24
    2c6a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c6c:	08 95       	ret

00002c6e <__divmodhi4_neg2>:
    2c6e:	70 95       	com	r23
    2c70:	61 95       	neg	r22
    2c72:	7f 4f       	sbci	r23, 0xFF	; 255

00002c74 <__divmodhi4_exit>:
    2c74:	08 95       	ret

00002c76 <__udivmodhi4>:
    2c76:	aa 1b       	sub	r26, r26
    2c78:	bb 1b       	sub	r27, r27
    2c7a:	51 e1       	ldi	r21, 0x11	; 17
    2c7c:	07 c0       	rjmp	.+14     	; 0x2c8c <__udivmodhi4_ep>

00002c7e <__udivmodhi4_loop>:
    2c7e:	aa 1f       	adc	r26, r26
    2c80:	bb 1f       	adc	r27, r27
    2c82:	a6 17       	cp	r26, r22
    2c84:	b7 07       	cpc	r27, r23
    2c86:	10 f0       	brcs	.+4      	; 0x2c8c <__udivmodhi4_ep>
    2c88:	a6 1b       	sub	r26, r22
    2c8a:	b7 0b       	sbc	r27, r23

00002c8c <__udivmodhi4_ep>:
    2c8c:	88 1f       	adc	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	5a 95       	dec	r21
    2c92:	a9 f7       	brne	.-22     	; 0x2c7e <__udivmodhi4_loop>
    2c94:	80 95       	com	r24
    2c96:	90 95       	com	r25
    2c98:	bc 01       	movw	r22, r24
    2c9a:	cd 01       	movw	r24, r26
    2c9c:	08 95       	ret

00002c9e <memcpy>:
    2c9e:	fb 01       	movw	r30, r22
    2ca0:	dc 01       	movw	r26, r24
    2ca2:	02 c0       	rjmp	.+4      	; 0x2ca8 <memcpy+0xa>
    2ca4:	01 90       	ld	r0, Z+
    2ca6:	0d 92       	st	X+, r0
    2ca8:	41 50       	subi	r20, 0x01	; 1
    2caa:	50 40       	sbci	r21, 0x00	; 0
    2cac:	d8 f7       	brcc	.-10     	; 0x2ca4 <memcpy+0x6>
    2cae:	08 95       	ret

00002cb0 <__itoa_ncheck>:
    2cb0:	bb 27       	eor	r27, r27
    2cb2:	4a 30       	cpi	r20, 0x0A	; 10
    2cb4:	31 f4       	brne	.+12     	; 0x2cc2 <__itoa_ncheck+0x12>
    2cb6:	99 23       	and	r25, r25
    2cb8:	22 f4       	brpl	.+8      	; 0x2cc2 <__itoa_ncheck+0x12>
    2cba:	bd e2       	ldi	r27, 0x2D	; 45
    2cbc:	90 95       	com	r25
    2cbe:	81 95       	neg	r24
    2cc0:	9f 4f       	sbci	r25, 0xFF	; 255
    2cc2:	01 c0       	rjmp	.+2      	; 0x2cc6 <__utoa_common>

00002cc4 <__utoa_ncheck>:
    2cc4:	bb 27       	eor	r27, r27

00002cc6 <__utoa_common>:
    2cc6:	fb 01       	movw	r30, r22
    2cc8:	55 27       	eor	r21, r21
    2cca:	aa 27       	eor	r26, r26
    2ccc:	88 0f       	add	r24, r24
    2cce:	99 1f       	adc	r25, r25
    2cd0:	aa 1f       	adc	r26, r26
    2cd2:	a4 17       	cp	r26, r20
    2cd4:	10 f0       	brcs	.+4      	; 0x2cda <__utoa_common+0x14>
    2cd6:	a4 1b       	sub	r26, r20
    2cd8:	83 95       	inc	r24
    2cda:	50 51       	subi	r21, 0x10	; 16
    2cdc:	b9 f7       	brne	.-18     	; 0x2ccc <__utoa_common+0x6>
    2cde:	a0 5d       	subi	r26, 0xD0	; 208
    2ce0:	aa 33       	cpi	r26, 0x3A	; 58
    2ce2:	08 f0       	brcs	.+2      	; 0x2ce6 <__utoa_common+0x20>
    2ce4:	a9 5d       	subi	r26, 0xD9	; 217
    2ce6:	a1 93       	st	Z+, r26
    2ce8:	00 97       	sbiw	r24, 0x00	; 0
    2cea:	79 f7       	brne	.-34     	; 0x2cca <__utoa_common+0x4>
    2cec:	b1 11       	cpse	r27, r1
    2cee:	b1 93       	st	Z+, r27
    2cf0:	11 92       	st	Z+, r1
    2cf2:	cb 01       	movw	r24, r22
    2cf4:	00 c0       	rjmp	.+0      	; 0x2cf6 <strrev>

00002cf6 <strrev>:
    2cf6:	dc 01       	movw	r26, r24
    2cf8:	fc 01       	movw	r30, r24
    2cfa:	67 2f       	mov	r22, r23
    2cfc:	71 91       	ld	r23, Z+
    2cfe:	77 23       	and	r23, r23
    2d00:	e1 f7       	brne	.-8      	; 0x2cfa <strrev+0x4>
    2d02:	32 97       	sbiw	r30, 0x02	; 2
    2d04:	04 c0       	rjmp	.+8      	; 0x2d0e <strrev+0x18>
    2d06:	7c 91       	ld	r23, X
    2d08:	6d 93       	st	X+, r22
    2d0a:	70 83       	st	Z, r23
    2d0c:	62 91       	ld	r22, -Z
    2d0e:	ae 17       	cp	r26, r30
    2d10:	bf 07       	cpc	r27, r31
    2d12:	c8 f3       	brcs	.-14     	; 0x2d06 <strrev+0x10>
    2d14:	08 95       	ret

00002d16 <_exit>:
    2d16:	f8 94       	cli

00002d18 <__stop_program>:
    2d18:	ff cf       	rjmp	.-2      	; 0x2d18 <__stop_program>
