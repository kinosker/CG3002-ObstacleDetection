
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002ed8  00002f6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ed8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000709  0080023e  0080023e  00002faa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002faa  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000568  00000000  00000000  00002fda  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006077  00000000  00000000  00003542  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001734  00000000  00000000  000095b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003872  00000000  00000000  0000aced  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f54  00000000  00000000  0000e560  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017b5  00000000  00000000  0000f4b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000424e  00000000  00000000  00010c69  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f8  00000000  00000000  00014eb7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	b6 c3       	rjmp	.+1900   	; 0x792 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 b9 0a 	jmp	0x1572	; 0x1572 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	71 c7       	rjmp	.+3810   	; 0xf48 <__vector_25>
      66:	00 00       	nop
      68:	dd c7       	rjmp	.+4026   	; 0x1024 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	86 c4       	rjmp	.+2316   	; 0x982 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	23 c7       	rjmp	.+3654   	; 0xed8 <__vector_36>
      92:	00 00       	nop
      94:	91 c7       	rjmp	.+3874   	; 0xfb8 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_getMedian+0x24>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e8 ed       	ldi	r30, 0xD8	; 216
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 34       	cpi	r26, 0x47	; 71
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	cd d0       	rcall	.+410    	; 0x33c <main>
     1a2:	0c 94 6a 17 	jmp	0x2ed4	; 0x2ed4 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	0e 94 27 09 	call	0x124e	; 0x124e <myUSART_peekReceiveUSART1>
     1ac:	c8 2f       	mov	r28, r24
     1ae:	0e 94 15 09 	call	0x122a	; 0x122a <myUSART_receiveHandShakeAck>
     1b2:	88 23       	and	r24, r24
     1b4:	21 f0       	breq	.+8      	; 0x1be <RPI_receiveTask+0x16>
     1b6:	fe d7       	rcall	.+4092   	; 0x11b4 <myUSART_receiveUSART1>
     1b8:	0e 94 0a 09 	call	0x1214	; 0x1214 <myUSART_completeHandShake>
     1bc:	f5 cf       	rjmp	.-22     	; 0x1a8 <RPI_receiveTask>
     1be:	8c 2f       	mov	r24, r28
     1c0:	0e 94 21 09 	call	0x1242	; 0x1242 <myUSART_receiveMessageACK>
     1c4:	88 23       	and	r24, r24
     1c6:	11 f0       	breq	.+4      	; 0x1cc <RPI_receiveTask+0x24>
     1c8:	f5 d7       	rcall	.+4074   	; 0x11b4 <myUSART_receiveUSART1>
     1ca:	ee cf       	rjmp	.-36     	; 0x1a8 <RPI_receiveTask>
     1cc:	8c 2f       	mov	r24, r28
     1ce:	0e 94 1b 09 	call	0x1236	; 0x1236 <myUSART_receiveHandShakeStart>
     1d2:	88 23       	and	r24, r24
     1d4:	19 f0       	breq	.+6      	; 0x1dc <RPI_receiveTask+0x34>
     1d6:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <myUSART_waitForHandshake>
     1da:	e6 cf       	rjmp	.-52     	; 0x1a8 <RPI_receiveTask>
     1dc:	eb d7       	rcall	.+4054   	; 0x11b4 <myUSART_receiveUSART1>
     1de:	e4 cf       	rjmp	.-56     	; 0x1a8 <RPI_receiveTask>

000001e0 <RPI_sendTask>:
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	00 d0       	rcall	.+0      	; 0x1e6 <RPI_sendTask+0x6>
     1e6:	00 d0       	rcall	.+0      	; 0x1e8 <RPI_sendTask+0x8>
     1e8:	cd b7       	in	r28, 0x3d	; 61
     1ea:	de b7       	in	r29, 0x3e	; 62
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	4f ef       	ldi	r20, 0xFF	; 255
     1f0:	5f ef       	ldi	r21, 0xFF	; 255
     1f2:	be 01       	movw	r22, r28
     1f4:	6a 5f       	subi	r22, 0xFA	; 250
     1f6:	7f 4f       	sbci	r23, 0xFF	; 255
     1f8:	80 91 8f 08 	lds	r24, 0x088F
     1fc:	90 91 90 08 	lds	r25, 0x0890
     200:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <xQueueGenericReceive>
     204:	8e 81       	ldd	r24, Y+6	; 0x06
     206:	80 5d       	subi	r24, 0xD0	; 208
     208:	a2 d7       	rcall	.+3908   	; 0x114e <myUSART_transmitUSART1_c>
     20a:	8a e0       	ldi	r24, 0x0A	; 10
     20c:	a0 d7       	rcall	.+3904   	; 0x114e <myUSART_transmitUSART1_c>
     20e:	8e 81       	ldd	r24, Y+6	; 0x06
     210:	9f ef       	ldi	r25, 0xFF	; 255
     212:	98 0f       	add	r25, r24
     214:	9e 83       	std	Y+6, r25	; 0x06
     216:	88 23       	and	r24, r24
     218:	21 f1       	breq	.+72     	; 0x262 <RPI_sendTask+0x82>
     21a:	20 e0       	ldi	r18, 0x00	; 0
     21c:	4f ef       	ldi	r20, 0xFF	; 255
     21e:	5f ef       	ldi	r21, 0xFF	; 255
     220:	be 01       	movw	r22, r28
     222:	6f 5f       	subi	r22, 0xFF	; 255
     224:	7f 4f       	sbci	r23, 0xFF	; 255
     226:	80 91 91 08 	lds	r24, 0x0891
     22a:	90 91 92 08 	lds	r25, 0x0892
     22e:	0e 94 dd 0c 	call	0x19ba	; 0x19ba <xQueueGenericReceive>
     232:	89 81       	ldd	r24, Y+1	; 0x01
     234:	75 d7       	rcall	.+3818   	; 0x1120 <myUSART_transmitUSART0_c>
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	8a d7       	rcall	.+3860   	; 0x114e <myUSART_transmitUSART1_c>
     23a:	86 e0       	ldi	r24, 0x06	; 6
     23c:	92 e0       	ldi	r25, 0x02	; 2
     23e:	ac d7       	rcall	.+3928   	; 0x1198 <myUSART_transmitUSART0>
     240:	ce 01       	movw	r24, r28
     242:	02 96       	adiw	r24, 0x02	; 2
     244:	a9 d7       	rcall	.+3922   	; 0x1198 <myUSART_transmitUSART0>
     246:	ce 01       	movw	r24, r28
     248:	02 96       	adiw	r24, 0x02	; 2
     24a:	98 d7       	rcall	.+3888   	; 0x117c <myUSART_transmitUSART1>
     24c:	8a e0       	ldi	r24, 0x0A	; 10
     24e:	7f d7       	rcall	.+3838   	; 0x114e <myUSART_transmitUSART1_c>
     250:	89 e0       	ldi	r24, 0x09	; 9
     252:	92 e0       	ldi	r25, 0x02	; 2
     254:	a1 d7       	rcall	.+3906   	; 0x1198 <myUSART_transmitUSART0>
     256:	8e 81       	ldd	r24, Y+6	; 0x06
     258:	9f ef       	ldi	r25, 0xFF	; 255
     25a:	98 0f       	add	r25, r24
     25c:	9e 83       	std	Y+6, r25	; 0x06
     25e:	81 11       	cpse	r24, r1
     260:	dc cf       	rjmp	.-72     	; 0x21a <RPI_sendTask+0x3a>
     262:	8a e0       	ldi	r24, 0x0A	; 10
     264:	5d d7       	rcall	.+3770   	; 0x1120 <myUSART_transmitUSART0_c>
     266:	c2 cf       	rjmp	.-124    	; 0x1ec <RPI_sendTask+0xc>

00000268 <myTimerTask>:
     268:	88 d5       	rcall	.+2832   	; 0xd7a <myTimer_Init>
     26a:	c7 d5       	rcall	.+2958   	; 0xdfa <myTimer_DelayChecker>
     26c:	fe cf       	rjmp	.-4      	; 0x26a <myTimerTask+0x2>

0000026e <task1>:
     26e:	26 9a       	sbi	0x04, 6	; 4
     270:	2e 9a       	sbi	0x05, 6	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 4a 11 	call	0x2294	; 0x2294 <vTaskDelay>
     27a:	85 b1       	in	r24, 0x05	; 5
     27c:	15 b8       	out	0x05, r1	; 5
     27e:	88 ee       	ldi	r24, 0xE8	; 232
     280:	93 e0       	ldi	r25, 0x03	; 3
     282:	0e 94 4a 11 	call	0x2294	; 0x2294 <vTaskDelay>
     286:	f4 cf       	rjmp	.-24     	; 0x270 <task1+0x2>

00000288 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     288:	8f ef       	ldi	r24, 0xFF	; 255
     28a:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     28e:	ef e7       	ldi	r30, 0x7F	; 127
     290:	f0 e0       	ldi	r31, 0x00	; 0
     292:	90 81       	ld	r25, Z
     294:	93 60       	ori	r25, 0x03	; 3
     296:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     298:	80 93 7d 00 	sts	0x007D, r24
     29c:	08 95       	ret

0000029e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     29e:	8c ec       	ldi	r24, 0xCC	; 204
     2a0:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2a4:	8e e3       	ldi	r24, 0x3E	; 62
     2a6:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2aa:	ee cf       	rjmp	.-36     	; 0x288 <setDigitalInputPowerReduction>
     2ac:	08 95       	ret

000002ae <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2ae:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2b2:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2b6:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ba:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2be:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2c2:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2c6:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2ca:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2ce:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2d2:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2d6:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2da:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2de:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2e2:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2e6:	10 92 73 00 	sts	0x0073, r1
     2ea:	08 95       	ret

000002ec <init>:
}

void init()
{
     2ec:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2ee:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2f0:	f8 94       	cli
	{
		clearTimer();
     2f2:	dd df       	rcall	.-70     	; 0x2ae <clearTimer>
		setPowerReduction();
     2f4:	d4 df       	rcall	.-88     	; 0x29e <setPowerReduction>
		myUSART_USART0_Init();
     2f6:	cc d6       	rcall	.+3480   	; 0x1090 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2f8:	eb d6       	rcall	.+3542   	; 0x10d0 <myUSART_USART1_Init>
		myADC_Init();
     2fa:	7b d3       	rcall	.+1782   	; 0x9f2 <myADC_Init>
		
		MaxSonar_Init();
     2fc:	83 b3       	in	r24, 0x13	; 19
     2fe:	83 60       	ori	r24, 0x03	; 3
     300:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     302:	d2 d2       	rcall	.+1444   	; 0x8a8 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     304:	40 e0       	ldi	r20, 0x00	; 0
     306:	61 e0       	ldi	r22, 0x01	; 1
     308:	85 e0       	ldi	r24, 0x05	; 5
     30a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xQueueGenericCreate>
     30e:	90 93 90 08 	sts	0x0890, r25
     312:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     316:	40 e0       	ldi	r20, 0x00	; 0
     318:	65 e0       	ldi	r22, 0x05	; 5
     31a:	84 e1       	ldi	r24, 0x14	; 20
     31c:	0e 94 b8 0b 	call	0x1770	; 0x1770 <xQueueGenericCreate>
     320:	90 93 92 08 	sts	0x0892, r25
     324:	80 93 91 08 	sts	0x0891, r24
		
		MOTOR_LEFT_INIT();
     328:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     32a:	e1 e0       	ldi	r30, 0x01	; 1
     32c:	f1 e0       	ldi	r31, 0x01	; 1
     32e:	80 81       	ld	r24, Z
     330:	80 61       	ori	r24, 0x10	; 16
     332:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     334:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     336:	78 94       	sei
}
     338:	cf 91       	pop	r28
     33a:	08 95       	ret

0000033c <main>:
	
	// do nth
}

int main(void)
{
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	cd b7       	in	r28, 0x3d	; 61
     342:	de b7       	in	r29, 0x3e	; 62
     344:	2a 97       	sbiw	r28, 0x0a	; 10
     346:	0f b6       	in	r0, 0x3f	; 63
     348:	f8 94       	cli
     34a:	de bf       	out	0x3e, r29	; 62
     34c:	0f be       	out	0x3f, r0	; 63
     34e:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     350:	cd df       	rcall	.-102    	; 0x2ec <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     352:	a1 2c       	mov	r10, r1
     354:	b1 2c       	mov	r11, r1
     356:	c1 2c       	mov	r12, r1
     358:	d1 2c       	mov	r13, r1
     35a:	ce 01       	movw	r24, r28
     35c:	01 96       	adiw	r24, 0x01	; 1
     35e:	7c 01       	movw	r14, r24
     360:	01 e0       	ldi	r16, 0x01	; 1
     362:	20 e0       	ldi	r18, 0x00	; 0
     364:	30 e0       	ldi	r19, 0x00	; 0
     366:	45 e5       	ldi	r20, 0x55	; 85
     368:	50 e0       	ldi	r21, 0x00	; 0
     36a:	6c e0       	ldi	r22, 0x0C	; 12
     36c:	72 e0       	ldi	r23, 0x02	; 2
     36e:	87 e3       	ldi	r24, 0x37	; 55
     370:	91 e0       	ldi	r25, 0x01	; 1
     372:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     376:	ce 01       	movw	r24, r28
     378:	03 96       	adiw	r24, 0x03	; 3
     37a:	7c 01       	movw	r14, r24
     37c:	04 e0       	ldi	r16, 0x04	; 4
     37e:	9c 01       	movw	r18, r24
     380:	49 e6       	ldi	r20, 0x69	; 105
     382:	50 e0       	ldi	r21, 0x00	; 0
     384:	63 e1       	ldi	r22, 0x13	; 19
     386:	72 e0       	ldi	r23, 0x02	; 2
     388:	84 e3       	ldi	r24, 0x34	; 52
     38a:	91 e0       	ldi	r25, 0x01	; 1
     38c:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     390:	ce 01       	movw	r24, r28
     392:	09 96       	adiw	r24, 0x09	; 9
     394:	7c 01       	movw	r14, r24
     396:	02 e0       	ldi	r16, 0x02	; 2
     398:	20 e0       	ldi	r18, 0x00	; 0
     39a:	30 e0       	ldi	r19, 0x00	; 0
     39c:	4f e4       	ldi	r20, 0x4F	; 79
     39e:	51 e0       	ldi	r21, 0x01	; 1
     3a0:	6b e1       	ldi	r22, 0x1B	; 27
     3a2:	72 e0       	ldi	r23, 0x02	; 2
     3a4:	82 e6       	ldi	r24, 0x62	; 98
     3a6:	92 e0       	ldi	r25, 0x02	; 2
     3a8:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3ac:	ce 01       	movw	r24, r28
     3ae:	07 96       	adiw	r24, 0x07	; 7
     3b0:	7c 01       	movw	r14, r24
     3b2:	03 e0       	ldi	r16, 0x03	; 3
     3b4:	20 e0       	ldi	r18, 0x00	; 0
     3b6:	30 e0       	ldi	r19, 0x00	; 0
     3b8:	47 e8       	ldi	r20, 0x87	; 135
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	64 e2       	ldi	r22, 0x24	; 36
     3be:	72 e0       	ldi	r23, 0x02	; 2
     3c0:	84 ed       	ldi	r24, 0xD4	; 212
     3c2:	90 e0       	ldi	r25, 0x00	; 0
     3c4:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3c8:	ce 01       	movw	r24, r28
     3ca:	05 96       	adiw	r24, 0x05	; 5
     3cc:	7c 01       	movw	r14, r24
     3ce:	01 e0       	ldi	r16, 0x01	; 1
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	47 e8       	ldi	r20, 0x87	; 135
     3d6:	50 e0       	ldi	r21, 0x00	; 0
     3d8:	60 e3       	ldi	r22, 0x30	; 48
     3da:	72 e0       	ldi	r23, 0x02	; 2
     3dc:	80 ef       	ldi	r24, 0xF0	; 240
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3e4:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <vTaskStartScheduler>
     3e8:	b3 cf       	rjmp	.-154    	; 0x350 <main+0x14>

000003ea <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     3ea:	1f 93       	push	r17
     3ec:	cf 93       	push	r28
     3ee:	df 93       	push	r29
     3f0:	00 d0       	rcall	.+0      	; 0x3f2 <obstacleSend+0x8>
     3f2:	1f 92       	push	r1
     3f4:	1f 92       	push	r1
     3f6:	cd b7       	in	r28, 0x3d	; 61
     3f8:	de b7       	in	r29, 0x3e	; 62
     3fa:	18 2f       	mov	r17, r24
     3fc:	cb 01       	movw	r24, r22
	obstacleData queueData;
	
	
	
	if(deviceBlocked)
     3fe:	11 23       	and	r17, r17
     400:	99 f0       	breq	.+38     	; 0x428 <obstacleSend+0x3e>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     402:	4a e0       	ldi	r20, 0x0A	; 10
     404:	be 01       	movw	r22, r28
     406:	6e 5f       	subi	r22, 0xFE	; 254
     408:	7f 4f       	sbci	r23, 0xFF	; 255
     40a:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <__itoa_ncheck>
	{
		itoa(reading, queueData.data, 10); // convert to ascii
		
		queueData.deviceID = deviceBlocked;
     40e:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &queueData, portMAX_DELAY); // send data to queueData
     410:	20 e0       	ldi	r18, 0x00	; 0
     412:	4f ef       	ldi	r20, 0xFF	; 255
     414:	5f ef       	ldi	r21, 0xFF	; 255
     416:	be 01       	movw	r22, r28
     418:	6f 5f       	subi	r22, 0xFF	; 255
     41a:	7f 4f       	sbci	r23, 0xFF	; 255
     41c:	80 91 91 08 	lds	r24, 0x0891
     420:	90 91 92 08 	lds	r25, 0x0892
     424:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <xQueueGenericSend>
	}
}
     428:	0f 90       	pop	r0
     42a:	0f 90       	pop	r0
     42c:	0f 90       	pop	r0
     42e:	0f 90       	pop	r0
     430:	0f 90       	pop	r0
     432:	df 91       	pop	r29
     434:	cf 91       	pop	r28
     436:	1f 91       	pop	r17
     438:	08 95       	ret

0000043a <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     43a:	6f 92       	push	r6
     43c:	7f 92       	push	r7
     43e:	8f 92       	push	r8
     440:	9f 92       	push	r9
     442:	af 92       	push	r10
     444:	bf 92       	push	r11
     446:	cf 92       	push	r12
     448:	df 92       	push	r13
     44a:	ef 92       	push	r14
     44c:	ff 92       	push	r15
     44e:	0f 93       	push	r16
     450:	1f 93       	push	r17
     452:	cf 93       	push	r28
     454:	df 93       	push	r29
     456:	1f 92       	push	r1
     458:	cd b7       	in	r28, 0x3d	; 61
     45a:	de b7       	in	r29, 0x3e	; 62
     45c:	89 83       	std	Y+1, r24	; 0x01
     45e:	5b 01       	movw	r10, r22
     460:	3a 01       	movw	r6, r20
     462:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     464:	20 e0       	ldi	r18, 0x00	; 0
     466:	4f ef       	ldi	r20, 0xFF	; 255
     468:	5f ef       	ldi	r21, 0xFF	; 255
     46a:	be 01       	movw	r22, r28
     46c:	6f 5f       	subi	r22, 0xFF	; 255
     46e:	7f 4f       	sbci	r23, 0xFF	; 255
     470:	80 91 8f 08 	lds	r24, 0x088F
     474:	90 91 90 08 	lds	r25, 0x0890
     478:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     47c:	b3 01       	movw	r22, r6
     47e:	f5 01       	movw	r30, r10
     480:	80 81       	ld	r24, Z
     482:	b3 df       	rcall	.-154    	; 0x3ea <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     484:	b4 01       	movw	r22, r8
     486:	f5 01       	movw	r30, r10
     488:	81 81       	ldd	r24, Z+1	; 0x01
     48a:	af df       	rcall	.-162    	; 0x3ea <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     48c:	b8 01       	movw	r22, r16
     48e:	f5 01       	movw	r30, r10
     490:	82 81       	ldd	r24, Z+2	; 0x02
     492:	ab df       	rcall	.-170    	; 0x3ea <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     494:	b7 01       	movw	r22, r14
     496:	f5 01       	movw	r30, r10
     498:	83 81       	ldd	r24, Z+3	; 0x03
     49a:	a7 df       	rcall	.-178    	; 0x3ea <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     49c:	b6 01       	movw	r22, r12
     49e:	f5 01       	movw	r30, r10
     4a0:	84 81       	ldd	r24, Z+4	; 0x04
     4a2:	a3 df       	rcall	.-186    	; 0x3ea <obstacleSend>
		
	}
}
     4a4:	0f 90       	pop	r0
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	1f 91       	pop	r17
     4ac:	0f 91       	pop	r16
     4ae:	ff 90       	pop	r15
     4b0:	ef 90       	pop	r14
     4b2:	df 90       	pop	r13
     4b4:	cf 90       	pop	r12
     4b6:	bf 90       	pop	r11
     4b8:	af 90       	pop	r10
     4ba:	9f 90       	pop	r9
     4bc:	8f 90       	pop	r8
     4be:	7f 90       	pop	r7
     4c0:	6f 90       	pop	r6
     4c2:	08 95       	ret

000004c4 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	cd b7       	in	r28, 0x3d	; 61
     4ca:	de b7       	in	r29, 0x3e	; 62
     4cc:	ac 97       	sbiw	r28, 0x2c	; 44
     4ce:	0f b6       	in	r0, 0x3f	; 63
     4d0:	f8 94       	cli
     4d2:	de bf       	out	0x3e, r29	; 62
     4d4:	0f be       	out	0x3f, r0	; 63
     4d6:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     4d8:	1b 82       	std	Y+3, r1	; 0x03
	int prevTopSonar = 0, prevFrontSonar = 0, prevLeftSonar = 0, prevRightSonar = 0;
     4da:	1d 82       	std	Y+5, r1	; 0x05
     4dc:	1c 82       	std	Y+4, r1	; 0x04
     4de:	1f 82       	std	Y+7, r1	; 0x07
     4e0:	1e 82       	std	Y+6, r1	; 0x06
     4e2:	19 86       	std	Y+9, r1	; 0x09
     4e4:	18 86       	std	Y+8, r1	; 0x08
     4e6:	1b 86       	std	Y+11, r1	; 0x0b
     4e8:	1a 86       	std	Y+10, r1	; 0x0a
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[3] = {0}, frontSonarSample[3] = {0}, leftSonarSample[3] = {0}, rightSonarSample[3] = {0};
     4ea:	86 e0       	ldi	r24, 0x06	; 6
     4ec:	fe 01       	movw	r30, r28
     4ee:	3c 96       	adiw	r30, 0x0c	; 12
     4f0:	df 01       	movw	r26, r30
     4f2:	98 2f       	mov	r25, r24
     4f4:	1d 92       	st	X+, r1
     4f6:	9a 95       	dec	r25
     4f8:	e9 f7       	brne	.-6      	; 0x4f4 <Sonar_Task+0x30>
     4fa:	36 96       	adiw	r30, 0x06	; 6
     4fc:	df 01       	movw	r26, r30
     4fe:	98 2f       	mov	r25, r24
     500:	1d 92       	st	X+, r1
     502:	9a 95       	dec	r25
     504:	e9 f7       	brne	.-6      	; 0x500 <Sonar_Task+0x3c>
     506:	36 96       	adiw	r30, 0x06	; 6
     508:	df 01       	movw	r26, r30
     50a:	98 2f       	mov	r25, r24
     50c:	1d 92       	st	X+, r1
     50e:	9a 95       	dec	r25
     510:	e9 f7       	brne	.-6      	; 0x50c <Sonar_Task+0x48>
     512:	36 96       	adiw	r30, 0x06	; 6
     514:	df 01       	movw	r26, r30
     516:	1d 92       	st	X+, r1
     518:	8a 95       	dec	r24
     51a:	e9 f7       	brne	.-6      	; 0x516 <Sonar_Task+0x52>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     51c:	36 96       	adiw	r30, 0x06	; 6
     51e:	85 e0       	ldi	r24, 0x05	; 5
     520:	df 01       	movw	r26, r30
     522:	1d 92       	st	X+, r1
     524:	8a 95       	dec	r24
     526:	e9 f7       	brne	.-6      	; 0x522 <Sonar_Task+0x5e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     528:	84 e2       	ldi	r24, 0x24	; 36
     52a:	8a d3       	rcall	.+1812   	; 0xc40 <mySharpIR_Read>
     52c:	9a a7       	std	Y+42, r25	; 0x2a
     52e:	89 a7       	std	Y+41, r24	; 0x29
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     530:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <xTaskGetTickCount>
     534:	9a 83       	std	Y+2, r25	; 0x02
     536:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     538:	d2 d1       	rcall	.+932    	; 0x8de <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getMedian(myMaxSonar_Read(AN11), &prevTopSonar, topSonarSample, 3);
     53a:	83 e2       	ldi	r24, 0x23	; 35
     53c:	18 d2       	rcall	.+1072   	; 0x96e <myMaxSonar_Read>
     53e:	23 e0       	ldi	r18, 0x03	; 3
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	ae 01       	movw	r20, r28
     544:	44 5f       	subi	r20, 0xF4	; 244
     546:	5f 4f       	sbci	r21, 0xFF	; 255
     548:	be 01       	movw	r22, r28
     54a:	6c 5f       	subi	r22, 0xFC	; 252
     54c:	7f 4f       	sbci	r23, 0xFF	; 255
     54e:	f6 d1       	rcall	.+1004   	; 0x93c <myMaxSonar_getMedian>
     550:	9c a7       	std	Y+44, r25	; 0x2c
     552:	8b a7       	std	Y+43, r24	; 0x2b
		
		myMaxSonar_BtmStart();
     554:	be d1       	rcall	.+892    	; 0x8d2 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getMedian(myMaxSonar_Read(AN15), &prevFrontSonar, frontSonarSample, 3);
     556:	87 e2       	ldi	r24, 0x27	; 39
     558:	0a d2       	rcall	.+1044   	; 0x96e <myMaxSonar_Read>
     55a:	23 e0       	ldi	r18, 0x03	; 3
     55c:	30 e0       	ldi	r19, 0x00	; 0
     55e:	ae 01       	movw	r20, r28
     560:	4e 5e       	subi	r20, 0xEE	; 238
     562:	5f 4f       	sbci	r21, 0xFF	; 255
     564:	be 01       	movw	r22, r28
     566:	6a 5f       	subi	r22, 0xFA	; 250
     568:	7f 4f       	sbci	r23, 0xFF	; 255
     56a:	e8 d1       	rcall	.+976    	; 0x93c <myMaxSonar_getMedian>
     56c:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getMedian(myMaxSonar_Read(AN14), &prevLeftSonar, leftSonarSample, 3);
     56e:	86 e2       	ldi	r24, 0x26	; 38
     570:	fe d1       	rcall	.+1020   	; 0x96e <myMaxSonar_Read>
     572:	23 e0       	ldi	r18, 0x03	; 3
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	ae 01       	movw	r20, r28
     578:	48 5e       	subi	r20, 0xE8	; 232
     57a:	5f 4f       	sbci	r21, 0xFF	; 255
     57c:	be 01       	movw	r22, r28
     57e:	68 5f       	subi	r22, 0xF8	; 248
     580:	7f 4f       	sbci	r23, 0xFF	; 255
     582:	dc d1       	rcall	.+952    	; 0x93c <myMaxSonar_getMedian>
     584:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getMedian(myMaxSonar_Read(AN13), &prevRightSonar, rightSonarSample, 3); 
     586:	85 e2       	ldi	r24, 0x25	; 37
     588:	f2 d1       	rcall	.+996    	; 0x96e <myMaxSonar_Read>
     58a:	23 e0       	ldi	r18, 0x03	; 3
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	ae 01       	movw	r20, r28
     590:	42 5e       	subi	r20, 0xE2	; 226
     592:	5f 4f       	sbci	r21, 0xFF	; 255
     594:	be 01       	movw	r22, r28
     596:	66 5f       	subi	r22, 0xF6	; 246
     598:	7f 4f       	sbci	r23, 0xFF	; 255
     59a:	d0 d1       	rcall	.+928    	; 0x93c <myMaxSonar_getMedian>
     59c:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     59e:	84 e2       	ldi	r24, 0x24	; 36
     5a0:	4f d3       	rcall	.+1694   	; 0xc40 <mySharpIR_Read>
     5a2:	4c 01       	movw	r8, r24
		//frontSonar = myMaxSonar_Stabilizer(frontSonar, &prevFrontSonar);
		//leftSonar = myMaxSonar_Stabilizer(leftSonar, &prevLeftSonar);
		//rightSonar = myMaxSonar_Stabilizer(rightSonar, &prevRightSonar);
		
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5a4:	bc 01       	movw	r22, r24
     5a6:	ce 01       	movw	r24, r28
     5a8:	89 96       	adiw	r24, 0x29	; 41
     5aa:	83 d3       	rcall	.+1798   	; 0xcb2 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5ac:	c9 a4       	ldd	r12, Y+41	; 0x29
     5ae:	da a4       	ldd	r13, Y+42	; 0x2a
     5b0:	54 01       	movw	r10, r8
     5b2:	eb a4       	ldd	r14, Y+43	; 0x2b
     5b4:	fc a4       	ldd	r15, Y+44	; 0x2c
     5b6:	82 01       	movw	r16, r4
     5b8:	91 01       	movw	r18, r2
     5ba:	ae 01       	movw	r20, r28
     5bc:	4c 5d       	subi	r20, 0xDC	; 220
     5be:	5f 4f       	sbci	r21, 0xFF	; 255
     5c0:	6b 81       	ldd	r22, Y+3	; 0x03
     5c2:	c3 01       	movw	r24, r6
     5c4:	0d d3       	rcall	.+1562   	; 0xbe0 <obstacleDetection>
     5c6:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5c8:	8e 01       	movw	r16, r28
     5ca:	0c 5d       	subi	r16, 0xDC	; 220
     5cc:	1f 4f       	sbci	r17, 0xFF	; 255
     5ce:	94 01       	movw	r18, r8
     5d0:	a2 01       	movw	r20, r4
     5d2:	b1 01       	movw	r22, r2
     5d4:	c3 01       	movw	r24, r6
     5d6:	8e d2       	rcall	.+1308   	; 0xaf4 <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5d8:	be 01       	movw	r22, r28
     5da:	6d 5f       	subi	r22, 0xFD	; 253
     5dc:	7f 4f       	sbci	r23, 0xFF	; 255
     5de:	c8 01       	movw	r24, r16
     5e0:	f0 d2       	rcall	.+1504   	; 0xbc2 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5e2:	cb a4       	ldd	r12, Y+43	; 0x2b
     5e4:	dc a4       	ldd	r13, Y+44	; 0x2c
     5e6:	74 01       	movw	r14, r8
     5e8:	82 01       	movw	r16, r4
     5ea:	91 01       	movw	r18, r2
     5ec:	a3 01       	movw	r20, r6
     5ee:	be 01       	movw	r22, r28
     5f0:	6c 5d       	subi	r22, 0xDC	; 220
     5f2:	7f 4f       	sbci	r23, 0xFF	; 255
     5f4:	8b 81       	ldd	r24, Y+3	; 0x03
     5f6:	21 df       	rcall	.-446    	; 0x43a <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     5f8:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     5fa:	18 a6       	std	Y+40, r1	; 0x28
     5fc:	1f a2       	std	Y+39, r1	; 0x27
     5fe:	1e a2       	std	Y+38, r1	; 0x26
     600:	1d a2       	std	Y+37, r1	; 0x25
     602:	1c a2       	std	Y+36, r1	; 0x24
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     604:	66 e9       	ldi	r22, 0x96	; 150
     606:	70 e0       	ldi	r23, 0x00	; 0
     608:	ce 01       	movw	r24, r28
     60a:	01 96       	adiw	r24, 0x01	; 1
     60c:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskDelayUntil>
     610:	93 cf       	rjmp	.-218    	; 0x538 <Sonar_Task+0x74>

00000612 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     612:	cf 93       	push	r28
     614:	df 93       	push	r29
     616:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     618:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     61c:	80 91 3e 02 	lds	r24, 0x023E
     620:	90 91 3f 02 	lds	r25, 0x023F
     624:	89 2b       	or	r24, r25
     626:	31 f4       	brne	.+12     	; 0x634 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     628:	83 e4       	ldi	r24, 0x43	; 67
     62a:	92 e0       	ldi	r25, 0x02	; 2
     62c:	90 93 3f 02 	sts	0x023F, r25
     630:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     634:	40 91 40 02 	lds	r20, 0x0240
     638:	50 91 41 02 	lds	r21, 0x0241
     63c:	9e 01       	movw	r18, r28
     63e:	24 0f       	add	r18, r20
     640:	35 1f       	adc	r19, r21
     642:	2b 3d       	cpi	r18, 0xDB	; 219
     644:	85 e0       	ldi	r24, 0x05	; 5
     646:	38 07       	cpc	r19, r24
     648:	70 f4       	brcc	.+28     	; 0x666 <pvPortMalloc+0x54>
     64a:	42 17       	cp	r20, r18
     64c:	53 07       	cpc	r21, r19
     64e:	70 f4       	brcc	.+28     	; 0x66c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     650:	c0 91 3e 02 	lds	r28, 0x023E
     654:	d0 91 3f 02 	lds	r29, 0x023F
     658:	c4 0f       	add	r28, r20
     65a:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     65c:	30 93 41 02 	sts	0x0241, r19
     660:	20 93 40 02 	sts	0x0240, r18
     664:	05 c0       	rjmp	.+10     	; 0x670 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     666:	c0 e0       	ldi	r28, 0x00	; 0
     668:	d0 e0       	ldi	r29, 0x00	; 0
     66a:	02 c0       	rjmp	.+4      	; 0x670 <pvPortMalloc+0x5e>
     66c:	c0 e0       	ldi	r28, 0x00	; 0
     66e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     670:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     674:	ce 01       	movw	r24, r28
     676:	df 91       	pop	r29
     678:	cf 91       	pop	r28
     67a:	08 95       	ret

0000067c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     67c:	08 95       	ret

0000067e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     67e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     680:	03 96       	adiw	r24, 0x03	; 3
     682:	92 83       	std	Z+2, r25	; 0x02
     684:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     686:	2f ef       	ldi	r18, 0xFF	; 255
     688:	3f ef       	ldi	r19, 0xFF	; 255
     68a:	34 83       	std	Z+4, r19	; 0x04
     68c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     68e:	96 83       	std	Z+6, r25	; 0x06
     690:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     692:	90 87       	std	Z+8, r25	; 0x08
     694:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     696:	10 82       	st	Z, r1
     698:	08 95       	ret

0000069a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     69a:	fc 01       	movw	r30, r24
     69c:	11 86       	std	Z+9, r1	; 0x09
     69e:	10 86       	std	Z+8, r1	; 0x08
     6a0:	08 95       	ret

000006a2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	9c 01       	movw	r18, r24
     6a8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6aa:	dc 01       	movw	r26, r24
     6ac:	11 96       	adiw	r26, 0x01	; 1
     6ae:	cd 91       	ld	r28, X+
     6b0:	dc 91       	ld	r29, X
     6b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6b4:	d3 83       	std	Z+3, r29	; 0x03
     6b6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6b8:	8c 81       	ldd	r24, Y+4	; 0x04
     6ba:	9d 81       	ldd	r25, Y+5	; 0x05
     6bc:	95 83       	std	Z+5, r25	; 0x05
     6be:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6c0:	8c 81       	ldd	r24, Y+4	; 0x04
     6c2:	9d 81       	ldd	r25, Y+5	; 0x05
     6c4:	dc 01       	movw	r26, r24
     6c6:	13 96       	adiw	r26, 0x03	; 3
     6c8:	7c 93       	st	X, r23
     6ca:	6e 93       	st	-X, r22
     6cc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6ce:	7d 83       	std	Y+5, r23	; 0x05
     6d0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6d2:	31 87       	std	Z+9, r19	; 0x09
     6d4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6d6:	f9 01       	movw	r30, r18
     6d8:	80 81       	ld	r24, Z
     6da:	8f 5f       	subi	r24, 0xFF	; 255
     6dc:	80 83       	st	Z, r24
}
     6de:	df 91       	pop	r29
     6e0:	cf 91       	pop	r28
     6e2:	08 95       	ret

000006e4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6e4:	cf 93       	push	r28
     6e6:	df 93       	push	r29
     6e8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6ea:	48 81       	ld	r20, Y
     6ec:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6ee:	4f 3f       	cpi	r20, 0xFF	; 255
     6f0:	2f ef       	ldi	r18, 0xFF	; 255
     6f2:	52 07       	cpc	r21, r18
     6f4:	21 f4       	brne	.+8      	; 0x6fe <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6f6:	fc 01       	movw	r30, r24
     6f8:	a7 81       	ldd	r26, Z+7	; 0x07
     6fa:	b0 85       	ldd	r27, Z+8	; 0x08
     6fc:	0d c0       	rjmp	.+26     	; 0x718 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6fe:	dc 01       	movw	r26, r24
     700:	13 96       	adiw	r26, 0x03	; 3
     702:	12 96       	adiw	r26, 0x02	; 2
     704:	ed 91       	ld	r30, X+
     706:	fc 91       	ld	r31, X
     708:	13 97       	sbiw	r26, 0x03	; 3
     70a:	20 81       	ld	r18, Z
     70c:	31 81       	ldd	r19, Z+1	; 0x01
     70e:	42 17       	cp	r20, r18
     710:	53 07       	cpc	r21, r19
     712:	10 f0       	brcs	.+4      	; 0x718 <vListInsert+0x34>
     714:	df 01       	movw	r26, r30
     716:	f5 cf       	rjmp	.-22     	; 0x702 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     718:	12 96       	adiw	r26, 0x02	; 2
     71a:	ed 91       	ld	r30, X+
     71c:	fc 91       	ld	r31, X
     71e:	13 97       	sbiw	r26, 0x03	; 3
     720:	fb 83       	std	Y+3, r31	; 0x03
     722:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     724:	d5 83       	std	Z+5, r29	; 0x05
     726:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     728:	bd 83       	std	Y+5, r27	; 0x05
     72a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     72c:	13 96       	adiw	r26, 0x03	; 3
     72e:	dc 93       	st	X, r29
     730:	ce 93       	st	-X, r28
     732:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     734:	99 87       	std	Y+9, r25	; 0x09
     736:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     738:	fc 01       	movw	r30, r24
     73a:	20 81       	ld	r18, Z
     73c:	2f 5f       	subi	r18, 0xFF	; 255
     73e:	20 83       	st	Z, r18
}
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	08 95       	ret

00000746 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     746:	cf 93       	push	r28
     748:	df 93       	push	r29
     74a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     74c:	a0 85       	ldd	r26, Z+8	; 0x08
     74e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     750:	c2 81       	ldd	r28, Z+2	; 0x02
     752:	d3 81       	ldd	r29, Z+3	; 0x03
     754:	84 81       	ldd	r24, Z+4	; 0x04
     756:	95 81       	ldd	r25, Z+5	; 0x05
     758:	9d 83       	std	Y+5, r25	; 0x05
     75a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     75c:	c4 81       	ldd	r28, Z+4	; 0x04
     75e:	d5 81       	ldd	r29, Z+5	; 0x05
     760:	82 81       	ldd	r24, Z+2	; 0x02
     762:	93 81       	ldd	r25, Z+3	; 0x03
     764:	9b 83       	std	Y+3, r25	; 0x03
     766:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     768:	11 96       	adiw	r26, 0x01	; 1
     76a:	cd 91       	ld	r28, X+
     76c:	dc 91       	ld	r29, X
     76e:	12 97       	sbiw	r26, 0x02	; 2
     770:	ce 17       	cp	r28, r30
     772:	df 07       	cpc	r29, r31
     774:	31 f4       	brne	.+12     	; 0x782 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     776:	8c 81       	ldd	r24, Y+4	; 0x04
     778:	9d 81       	ldd	r25, Y+5	; 0x05
     77a:	12 96       	adiw	r26, 0x02	; 2
     77c:	9c 93       	st	X, r25
     77e:	8e 93       	st	-X, r24
     780:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     782:	11 86       	std	Z+9, r1	; 0x09
     784:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     786:	8c 91       	ld	r24, X
     788:	81 50       	subi	r24, 0x01	; 1
     78a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     78c:	df 91       	pop	r29
     78e:	cf 91       	pop	r28
     790:	08 95       	ret

00000792 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     792:	1f 92       	push	r1
     794:	0f 92       	push	r0
     796:	0f b6       	in	r0, 0x3f	; 63
     798:	0f 92       	push	r0
     79a:	11 24       	eor	r1, r1
     79c:	0b b6       	in	r0, 0x3b	; 59
     79e:	0f 92       	push	r0
     7a0:	2f 93       	push	r18
     7a2:	3f 93       	push	r19
     7a4:	4f 93       	push	r20
     7a6:	5f 93       	push	r21
     7a8:	6f 93       	push	r22
     7aa:	7f 93       	push	r23
     7ac:	8f 93       	push	r24
     7ae:	9f 93       	push	r25
     7b0:	af 93       	push	r26
     7b2:	bf 93       	push	r27
     7b4:	ef 93       	push	r30
     7b6:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7b8:	1b 9b       	sbis	0x03, 3	; 3
     7ba:	0d c0       	rjmp	.+26     	; 0x7d6 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7bc:	f8 d2       	rcall	.+1520   	; 0xdae <myTimer_Read>
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	90 93 98 08 	sts	0x0898, r25
     7c4:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7c8:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xTaskGetTickCountFromISR>
     7cc:	90 93 94 08 	sts	0x0894, r25
     7d0:	80 93 93 08 	sts	0x0893, r24
     7d4:	56 c0       	rjmp	.+172    	; 0x882 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7d6:	1b 99       	sbic	0x03, 3	; 3
     7d8:	54 c0       	rjmp	.+168    	; 0x882 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7da:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xTaskGetTickCountFromISR>
     7de:	90 93 9e 08 	sts	0x089E, r25
     7e2:	80 93 9d 08 	sts	0x089D, r24
     7e6:	20 91 93 08 	lds	r18, 0x0893
     7ea:	30 91 94 08 	lds	r19, 0x0894
     7ee:	82 17       	cp	r24, r18
     7f0:	93 07       	cpc	r25, r19
     7f2:	4c f4       	brge	.+18     	; 0x806 <__vector_9+0x74>
			ms_tickEnd += 65535;
     7f4:	80 91 9d 08 	lds	r24, 0x089D
     7f8:	90 91 9e 08 	lds	r25, 0x089E
     7fc:	01 97       	sbiw	r24, 0x01	; 1
     7fe:	90 93 9e 08 	sts	0x089E, r25
     802:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     806:	d3 d2       	rcall	.+1446   	; 0xdae <myTimer_Read>
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	90 93 a0 08 	sts	0x08A0, r25
     80e:	80 93 9f 08 	sts	0x089F, r24
     812:	20 91 97 08 	lds	r18, 0x0897
     816:	30 91 98 08 	lds	r19, 0x0898
     81a:	82 17       	cp	r24, r18
     81c:	93 07       	cpc	r25, r19
     81e:	54 f4       	brge	.+20     	; 0x834 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     820:	80 91 9f 08 	lds	r24, 0x089F
     824:	90 91 a0 08 	lds	r25, 0x08A0
     828:	86 50       	subi	r24, 0x06	; 6
     82a:	9f 4f       	sbci	r25, 0xFF	; 255
     82c:	90 93 a0 08 	sts	0x08A0, r25
     830:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     834:	80 91 9f 08 	lds	r24, 0x089F
     838:	90 91 a0 08 	lds	r25, 0x08A0
     83c:	20 91 97 08 	lds	r18, 0x0897
     840:	30 91 98 08 	lds	r19, 0x0898
     844:	82 1b       	sub	r24, r18
     846:	93 0b       	sbc	r25, r19
     848:	90 93 9a 08 	sts	0x089A, r25
     84c:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     850:	80 91 9d 08 	lds	r24, 0x089D
     854:	90 91 9e 08 	lds	r25, 0x089E
     858:	20 91 93 08 	lds	r18, 0x0893
     85c:	30 91 94 08 	lds	r19, 0x0894
     860:	82 1b       	sub	r24, r18
     862:	93 0b       	sbc	r25, r19
     864:	90 93 96 08 	sts	0x0896, r25
     868:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     86c:	20 e0       	ldi	r18, 0x00	; 0
     86e:	40 e0       	ldi	r20, 0x00	; 0
     870:	50 e0       	ldi	r21, 0x00	; 0
     872:	60 e0       	ldi	r22, 0x00	; 0
     874:	70 e0       	ldi	r23, 0x00	; 0
     876:	80 91 9b 08 	lds	r24, 0x089B
     87a:	90 91 9c 08 	lds	r25, 0x089C
     87e:	0e 94 a3 0c 	call	0x1946	; 0x1946 <xQueueGenericSendFromISR>
	}	
}
     882:	ff 91       	pop	r31
     884:	ef 91       	pop	r30
     886:	bf 91       	pop	r27
     888:	af 91       	pop	r26
     88a:	9f 91       	pop	r25
     88c:	8f 91       	pop	r24
     88e:	7f 91       	pop	r23
     890:	6f 91       	pop	r22
     892:	5f 91       	pop	r21
     894:	4f 91       	pop	r20
     896:	3f 91       	pop	r19
     898:	2f 91       	pop	r18
     89a:	0f 90       	pop	r0
     89c:	0b be       	out	0x3b, r0	; 59
     89e:	0f 90       	pop	r0
     8a0:	0f be       	out	0x3f, r0	; 63
     8a2:	0f 90       	pop	r0
     8a4:	1f 90       	pop	r1
     8a6:	18 95       	reti

000008a8 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     8a8:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     8aa:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     8ac:	e8 e6       	ldi	r30, 0x68	; 104
     8ae:	f0 e0       	ldi	r31, 0x00	; 0
     8b0:	80 81       	ld	r24, Z
     8b2:	81 60       	ori	r24, 0x01	; 1
     8b4:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     8b6:	eb e6       	ldi	r30, 0x6B	; 107
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	80 81       	ld	r24, Z
     8bc:	88 60       	ori	r24, 0x08	; 8
     8be:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     8c0:	43 e0       	ldi	r20, 0x03	; 3
     8c2:	60 e0       	ldi	r22, 0x00	; 0
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	54 d7       	rcall	.+3752   	; 0x1770 <xQueueGenericCreate>
     8c8:	90 93 9c 08 	sts	0x089C, r25
     8cc:	80 93 9b 08 	sts	0x089B, r24
     8d0:	08 95       	ret

000008d2 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8d2:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8d4:	89 e1       	ldi	r24, 0x19	; 25
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	6c d2       	rcall	.+1240   	; 0xdb2 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8da:	a1 98       	cbi	0x14, 1	; 20
     8dc:	08 95       	ret

000008de <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8de:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8e0:	89 e1       	ldi	r24, 0x19	; 25
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	66 d2       	rcall	.+1228   	; 0xdb2 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8e6:	a0 98       	cbi	0x14, 0	; 20
     8e8:	08 95       	ret

000008ea <myMaxSonar_AddSample>:
void myMaxSonar_AddSample(int currentReading ,int *sample, int sampleSize)
{
	int i;
	int temp;
	
	for( i = 0 ; i < sampleSize ; i++)
     8ea:	14 16       	cp	r1, r20
     8ec:	15 06       	cpc	r1, r21
     8ee:	8c f4       	brge	.+34     	; 0x912 <myMaxSonar_AddSample+0x28>
     8f0:	fb 01       	movw	r30, r22
     8f2:	44 0f       	add	r20, r20
     8f4:	55 1f       	adc	r21, r21
     8f6:	64 0f       	add	r22, r20
     8f8:	75 1f       	adc	r23, r21
	{
		if(currentReading < sample[i])
     8fa:	20 81       	ld	r18, Z
     8fc:	31 81       	ldd	r19, Z+1	; 0x01
     8fe:	82 17       	cp	r24, r18
     900:	93 07       	cpc	r25, r19
     902:	1c f4       	brge	.+6      	; 0x90a <myMaxSonar_AddSample+0x20>
		{
			temp = sample[i];
			sample[i] = currentReading;
     904:	91 83       	std	Z+1, r25	; 0x01
     906:	80 83       	st	Z, r24
			currentReading = temp;
     908:	c9 01       	movw	r24, r18
     90a:	32 96       	adiw	r30, 0x02	; 2
void myMaxSonar_AddSample(int currentReading ,int *sample, int sampleSize)
{
	int i;
	int temp;
	
	for( i = 0 ; i < sampleSize ; i++)
     90c:	e6 17       	cp	r30, r22
     90e:	f7 07       	cpc	r31, r23
     910:	a1 f7       	brne	.-24     	; 0x8fa <myMaxSonar_AddSample+0x10>
     912:	08 95       	ret

00000914 <myMaxSonar_Stabilizer>:
		}
	}
}

int myMaxSonar_Stabilizer(const int currentReading, int* prevReading)
{
     914:	9c 01       	movw	r18, r24
	if(currentReading > (*prevReading + NOISE_RANGE) || currentReading < (*prevReading - NOISE_RANGE))
     916:	fb 01       	movw	r30, r22
     918:	80 81       	ld	r24, Z
     91a:	91 81       	ldd	r25, Z+1	; 0x01
     91c:	ac 01       	movw	r20, r24
     91e:	48 5f       	subi	r20, 0xF8	; 248
     920:	5f 4f       	sbci	r21, 0xFF	; 255
     922:	42 17       	cp	r20, r18
     924:	53 07       	cpc	r21, r19
     926:	2c f0       	brlt	.+10     	; 0x932 <myMaxSonar_Stabilizer+0x1e>
     928:	40 51       	subi	r20, 0x10	; 16
     92a:	51 09       	sbc	r21, r1
     92c:	24 17       	cp	r18, r20
     92e:	35 07       	cpc	r19, r21
     930:	24 f4       	brge	.+8      	; 0x93a <myMaxSonar_Stabilizer+0x26>
	{
		*prevReading = currentReading;
     932:	fb 01       	movw	r30, r22
     934:	31 83       	std	Z+1, r19	; 0x01
     936:	20 83       	st	Z, r18
		return currentReading; // when current reading exceed noise range.... return current reading
     938:	c9 01       	movw	r24, r18
	}
	else
		return *prevReading; // return prevReading if in noise range..
}
     93a:	08 95       	ret

0000093c <myMaxSonar_getMedian>:
	MaxSonar_TopTriggerStop();
}


int myMaxSonar_getMedian(int currentReading, int* prevReading, int *sample, int sampleSize)
{
     93c:	0f 93       	push	r16
     93e:	1f 93       	push	r17
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	8a 01       	movw	r16, r20
     946:	e9 01       	movw	r28, r18
	currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
     948:	e5 df       	rcall	.-54     	; 0x914 <myMaxSonar_Stabilizer>
	myMaxSonar_AddSample(currentReading, sample, sampleSize);
     94a:	ae 01       	movw	r20, r28
     94c:	b8 01       	movw	r22, r16
     94e:	cd df       	rcall	.-102    	; 0x8ea <myMaxSonar_AddSample>
	return sample[sampleSize/2];
     950:	ce 01       	movw	r24, r28
     952:	dd 23       	and	r29, r29
     954:	0c f4       	brge	.+2      	; 0x958 <myMaxSonar_getMedian+0x1c>
     956:	01 96       	adiw	r24, 0x01	; 1
     958:	8e 7f       	andi	r24, 0xFE	; 254
     95a:	f8 01       	movw	r30, r16
     95c:	e8 0f       	add	r30, r24
     95e:	f9 1f       	adc	r31, r25
}
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	1f 91       	pop	r17
     96a:	0f 91       	pop	r16
     96c:	08 95       	ret

0000096e <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     96e:	ab d0       	rcall	.+342    	; 0xac6 <myADC_analogRead>
     970:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     972:	63 e0       	ldi	r22, 0x03	; 3
     974:	70 e0       	ldi	r23, 0x00	; 0
     976:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     97a:	cb 01       	movw	r24, r22
     97c:	82 0f       	add	r24, r18
     97e:	93 1f       	adc	r25, r19
     980:	08 95       	ret

00000982 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     982:	1f 92       	push	r1
     984:	0f 92       	push	r0
     986:	0f b6       	in	r0, 0x3f	; 63
     988:	0f 92       	push	r0
     98a:	11 24       	eor	r1, r1
     98c:	0b b6       	in	r0, 0x3b	; 59
     98e:	0f 92       	push	r0
     990:	2f 93       	push	r18
     992:	3f 93       	push	r19
     994:	4f 93       	push	r20
     996:	5f 93       	push	r21
     998:	6f 93       	push	r22
     99a:	7f 93       	push	r23
     99c:	8f 93       	push	r24
     99e:	9f 93       	push	r25
     9a0:	af 93       	push	r26
     9a2:	bf 93       	push	r27
     9a4:	ef 93       	push	r30
     9a6:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9a8:	80 91 78 00 	lds	r24, 0x0078
     9ac:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9b0:	80 91 79 00 	lds	r24, 0x0079
     9b4:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9b8:	20 e0       	ldi	r18, 0x00	; 0
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	70 e0       	ldi	r23, 0x00	; 0
     9c2:	80 91 a5 08 	lds	r24, 0x08A5
     9c6:	90 91 a6 08 	lds	r25, 0x08A6
     9ca:	bd d7       	rcall	.+3962   	; 0x1946 <xQueueGenericSendFromISR>
}
     9cc:	ff 91       	pop	r31
     9ce:	ef 91       	pop	r30
     9d0:	bf 91       	pop	r27
     9d2:	af 91       	pop	r26
     9d4:	9f 91       	pop	r25
     9d6:	8f 91       	pop	r24
     9d8:	7f 91       	pop	r23
     9da:	6f 91       	pop	r22
     9dc:	5f 91       	pop	r21
     9de:	4f 91       	pop	r20
     9e0:	3f 91       	pop	r19
     9e2:	2f 91       	pop	r18
     9e4:	0f 90       	pop	r0
     9e6:	0b be       	out	0x3b, r0	; 59
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
     9ec:	0f 90       	pop	r0
     9ee:	1f 90       	pop	r1
     9f0:	18 95       	reti

000009f2 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     9f2:	8f e8       	ldi	r24, 0x8F	; 143
     9f4:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     9f8:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     9fc:	80 e4       	ldi	r24, 0x40	; 64
     9fe:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a02:	43 e0       	ldi	r20, 0x03	; 3
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	81 e0       	ldi	r24, 0x01	; 1
     a08:	b3 d6       	rcall	.+3430   	; 0x1770 <xQueueGenericCreate>
     a0a:	90 93 a6 08 	sts	0x08A6, r25
     a0e:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	6d d7       	rcall	.+3802   	; 0x18f0 <xQueueCreateMutex>
     a16:	90 93 a4 08 	sts	0x08A4, r25
     a1a:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a1e:	20 e0       	ldi	r18, 0x00	; 0
     a20:	40 e0       	ldi	r20, 0x00	; 0
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	d0 c6       	rjmp	.+3488   	; 0x17ca <xQueueGenericSend>
     a2a:	08 95       	ret

00000a2c <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a2c:	cf 93       	push	r28
     a2e:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	4f ef       	ldi	r20, 0xFF	; 255
     a34:	5f ef       	ldi	r21, 0xFF	; 255
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	70 e0       	ldi	r23, 0x00	; 0
     a3a:	80 91 a3 08 	lds	r24, 0x08A3
     a3e:	90 91 a4 08 	lds	r25, 0x08A4
     a42:	bb d7       	rcall	.+3958   	; 0x19ba <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a44:	ec e7       	ldi	r30, 0x7C	; 124
     a46:	f0 e0       	ldi	r31, 0x00	; 0
     a48:	80 81       	ld	r24, Z
     a4a:	9c 2f       	mov	r25, r28
     a4c:	9f 71       	andi	r25, 0x1F	; 31
     a4e:	80 76       	andi	r24, 0x60	; 96
     a50:	89 2b       	or	r24, r25
     a52:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a54:	eb e7       	ldi	r30, 0x7B	; 123
     a56:	f0 e0       	ldi	r31, 0x00	; 0
     a58:	20 81       	ld	r18, Z
     a5a:	c0 72       	andi	r28, 0x20	; 32
     a5c:	8c 2f       	mov	r24, r28
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	95 95       	asr	r25
     a62:	87 95       	ror	r24
     a64:	95 95       	asr	r25
     a66:	87 95       	ror	r24
     a68:	92 2f       	mov	r25, r18
     a6a:	90 76       	andi	r25, 0x60	; 96
     a6c:	89 2b       	or	r24, r25
     a6e:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a70:	ea e7       	ldi	r30, 0x7A	; 122
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	80 81       	ld	r24, Z
     a76:	80 64       	ori	r24, 0x40	; 64
     a78:	80 83       	st	Z, r24
}
     a7a:	cf 91       	pop	r28
     a7c:	08 95       	ret

00000a7e <myADC_readADC>:

int myADC_readADC(char channel)
{
     a7e:	cf 93       	push	r28
     a80:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a82:	20 e0       	ldi	r18, 0x00	; 0
     a84:	4f ef       	ldi	r20, 0xFF	; 255
     a86:	5f ef       	ldi	r21, 0xFF	; 255
     a88:	60 e0       	ldi	r22, 0x00	; 0
     a8a:	70 e0       	ldi	r23, 0x00	; 0
     a8c:	80 91 a5 08 	lds	r24, 0x08A5
     a90:	90 91 a6 08 	lds	r25, 0x08A6
     a94:	92 d7       	rcall	.+3876   	; 0x19ba <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     a96:	c0 91 a2 08 	lds	r28, 0x08A2
     a9a:	c3 70       	andi	r28, 0x03	; 3
     a9c:	d0 e0       	ldi	r29, 0x00	; 0
     a9e:	dc 2f       	mov	r29, r28
     aa0:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     aa2:	80 91 a1 08 	lds	r24, 0x08A1
     aa6:	c8 0f       	add	r28, r24
     aa8:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     aaa:	20 e0       	ldi	r18, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	60 e0       	ldi	r22, 0x00	; 0
     ab2:	70 e0       	ldi	r23, 0x00	; 0
     ab4:	80 91 a3 08 	lds	r24, 0x08A3
     ab8:	90 91 a4 08 	lds	r25, 0x08A4
     abc:	86 d6       	rcall	.+3340   	; 0x17ca <xQueueGenericSend>
	
	return adcReading;
     abe:	ce 01       	movw	r24, r28
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     ac6:	cf 93       	push	r28
     ac8:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     aca:	b0 df       	rcall	.-160    	; 0xa2c <myADC_startADC>
	return myADC_readADC(channel);
     acc:	8c 2f       	mov	r24, r28
     ace:	d7 df       	rcall	.-82     	; 0xa7e <myADC_readADC>
}
     ad0:	cf 91       	pop	r28
     ad2:	08 95       	ret

00000ad4 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     ad4:	9c 01       	movw	r18, r24
     ad6:	24 5f       	subi	r18, 0xF4	; 244
     ad8:	3f 4f       	sbci	r19, 0xFF	; 255
     ada:	26 17       	cp	r18, r22
     adc:	37 07       	cpc	r19, r23
     ade:	44 f0       	brlt	.+16     	; 0xaf0 <detectStairs+0x1c>
     ae0:	28 51       	subi	r18, 0x18	; 24
     ae2:	31 09       	sbc	r19, r1
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	62 17       	cp	r22, r18
     ae8:	73 07       	cpc	r23, r19
     aea:	1c f0       	brlt	.+6      	; 0xaf2 <detectStairs+0x1e>
     aec:	80 e0       	ldi	r24, 0x00	; 0
     aee:	08 95       	ret
	{
		return 1; // stairs found
     af0:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     af2:	08 95       	ret

00000af4 <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     afa:	83 81       	ldd	r24, Z+3	; 0x03
     afc:	88 23       	and	r24, r24
     afe:	39 f0       	breq	.+14     	; 0xb0e <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b00:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b02:	e2 e0       	ldi	r30, 0x02	; 2
     b04:	f1 e0       	ldi	r31, 0x01	; 1
     b06:	80 81       	ld	r24, Z
     b08:	80 61       	ori	r24, 0x10	; 16
     b0a:	80 83       	st	Z, r24
     b0c:	57 c0       	rjmp	.+174    	; 0xbbc <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b0e:	80 81       	ld	r24, Z
     b10:	88 23       	and	r24, r24
     b12:	b1 f1       	breq	.+108    	; 0xb80 <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b14:	81 81       	ldd	r24, Z+1	; 0x01
     b16:	81 11       	cpse	r24, r1
     b18:	18 c0       	rjmp	.+48     	; 0xb4a <obstacleAvoidance+0x56>
     b1a:	82 81       	ldd	r24, Z+2	; 0x02
     b1c:	81 11       	cpse	r24, r1
     b1e:	24 c0       	rjmp	.+72     	; 0xb68 <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar + 14) // if right sonar greater than....
     b20:	cb 01       	movw	r24, r22
     b22:	0e 96       	adiw	r24, 0x0e	; 14
     b24:	84 17       	cp	r24, r20
     b26:	95 07       	cpc	r25, r21
     b28:	3c f4       	brge	.+14     	; 0xb38 <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b2a:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b2c:	a2 e0       	ldi	r26, 0x02	; 2
     b2e:	b1 e0       	ldi	r27, 0x01	; 1
     b30:	8c 91       	ld	r24, X
     b32:	80 61       	ori	r24, 0x10	; 16
     b34:	8c 93       	st	X, r24
     b36:	06 c0       	rjmp	.+12     	; 0xb44 <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b38:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b3a:	a2 e0       	ldi	r26, 0x02	; 2
     b3c:	b1 e0       	ldi	r27, 0x01	; 1
     b3e:	8c 91       	ld	r24, X
     b40:	8f 7e       	andi	r24, 0xEF	; 239
     b42:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b44:	81 81       	ldd	r24, Z+1	; 0x01
     b46:	88 23       	and	r24, r24
     b48:	b1 f1       	breq	.+108    	; 0xbb6 <obstacleAvoidance+0xc2>
     b4a:	82 81       	ldd	r24, Z+2	; 0x02
     b4c:	81 11       	cpse	r24, r1
     b4e:	36 c0       	rjmp	.+108    	; 0xbbc <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b50:	46 1b       	sub	r20, r22
     b52:	57 0b       	sbc	r21, r23
     b54:	49 30       	cpi	r20, 0x09	; 9
     b56:	51 05       	cpc	r21, r1
     b58:	8c f1       	brlt	.+98     	; 0xbbc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     b5a:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     b5c:	e2 e0       	ldi	r30, 0x02	; 2
     b5e:	f1 e0       	ldi	r31, 0x01	; 1
     b60:	80 81       	ld	r24, Z
     b62:	80 61       	ori	r24, 0x10	; 16
     b64:	80 83       	st	Z, r24
     b66:	2a c0       	rjmp	.+84     	; 0xbbc <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     b68:	64 1b       	sub	r22, r20
     b6a:	75 0b       	sbc	r23, r21
     b6c:	69 30       	cpi	r22, 0x09	; 9
     b6e:	71 05       	cpc	r23, r1
     b70:	2c f1       	brlt	.+74     	; 0xbbc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     b72:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     b74:	e2 e0       	ldi	r30, 0x02	; 2
     b76:	f1 e0       	ldi	r31, 0x01	; 1
     b78:	80 81       	ld	r24, Z
     b7a:	8f 7e       	andi	r24, 0xEF	; 239
     b7c:	80 83       	st	Z, r24
     b7e:	1e c0       	rjmp	.+60     	; 0xbbc <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     b80:	66 32       	cpi	r22, 0x26	; 38
     b82:	71 05       	cpc	r23, r1
     b84:	3c f4       	brge	.+14     	; 0xb94 <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     b86:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     b88:	e2 e0       	ldi	r30, 0x02	; 2
     b8a:	f1 e0       	ldi	r31, 0x01	; 1
     b8c:	80 81       	ld	r24, Z
     b8e:	80 61       	ori	r24, 0x10	; 16
     b90:	80 83       	st	Z, r24
     b92:	14 c0       	rjmp	.+40     	; 0xbbc <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     b94:	44 31       	cpi	r20, 0x14	; 20
     b96:	51 05       	cpc	r21, r1
     b98:	3c f4       	brge	.+14     	; 0xba8 <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     b9a:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     b9c:	e2 e0       	ldi	r30, 0x02	; 2
     b9e:	f1 e0       	ldi	r31, 0x01	; 1
     ba0:	80 81       	ld	r24, Z
     ba2:	8f 7e       	andi	r24, 0xEF	; 239
     ba4:	80 83       	st	Z, r24
     ba6:	0a c0       	rjmp	.+20     	; 0xbbc <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     ba8:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     baa:	e2 e0       	ldi	r30, 0x02	; 2
     bac:	f1 e0       	ldi	r31, 0x01	; 1
     bae:	80 81       	ld	r24, Z
     bb0:	8f 7e       	andi	r24, 0xEF	; 239
     bb2:	80 83       	st	Z, r24
     bb4:	03 c0       	rjmp	.+6      	; 0xbbc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     bb6:	82 81       	ldd	r24, Z+2	; 0x02
     bb8:	81 11       	cpse	r24, r1
     bba:	d6 cf       	rjmp	.-84     	; 0xb68 <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     bbc:	1f 91       	pop	r17
     bbe:	0f 91       	pop	r16
     bc0:	08 95       	ret

00000bc2 <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     bc2:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     bc4:	85 e0       	ldi	r24, 0x05	; 5
     bc6:	db 01       	movw	r26, r22
     bc8:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     bca:	86 e4       	ldi	r24, 0x46	; 70
     bcc:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     bce:	8c e4       	ldi	r24, 0x4C	; 76
     bd0:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     bd2:	82 e5       	ldi	r24, 0x52	; 82
     bd4:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     bd6:	82 e4       	ldi	r24, 0x42	; 66
     bd8:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     bda:	84 e5       	ldi	r24, 0x54	; 84
     bdc:	84 83       	std	Z+4, r24	; 0x04
     bde:	08 95       	ret

00000be0 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     be0:	af 92       	push	r10
     be2:	bf 92       	push	r11
     be4:	cf 92       	push	r12
     be6:	df 92       	push	r13
     be8:	ff 92       	push	r15
     bea:	0f 93       	push	r16
     bec:	1f 93       	push	r17
     bee:	cf 93       	push	r28
     bf0:	df 93       	push	r29
     bf2:	f6 2e       	mov	r15, r22
     bf4:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     bf6:	86 34       	cpi	r24, 0x46	; 70
     bf8:	91 05       	cpc	r25, r1
     bfa:	1c f4       	brge	.+6      	; 0xc02 <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     bfc:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     bfe:	86 e4       	ldi	r24, 0x46	; 70
     c00:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c02:	2e 31       	cpi	r18, 0x1E	; 30
     c04:	31 05       	cpc	r19, r1
     c06:	1c f4       	brge	.+6      	; 0xc0e <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     c08:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c0a:	8c e4       	ldi	r24, 0x4C	; 76
     c0c:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c0e:	0e 31       	cpi	r16, 0x1E	; 30
     c10:	11 05       	cpc	r17, r1
     c12:	1c f4       	brge	.+6      	; 0xc1a <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     c14:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c16:	82 e5       	ldi	r24, 0x52	; 82
     c18:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c1a:	b5 01       	movw	r22, r10
     c1c:	c6 01       	movw	r24, r12
     c1e:	5a df       	rcall	.-332    	; 0xad4 <detectStairs>
     c20:	88 23       	and	r24, r24
     c22:	19 f0       	breq	.+6      	; 0xc2a <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c24:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c26:	82 e4       	ldi	r24, 0x42	; 66
     c28:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     c2a:	8f 2d       	mov	r24, r15
     c2c:	df 91       	pop	r29
     c2e:	cf 91       	pop	r28
     c30:	1f 91       	pop	r17
     c32:	0f 91       	pop	r16
     c34:	ff 90       	pop	r15
     c36:	df 90       	pop	r13
     c38:	cf 90       	pop	r12
     c3a:	bf 90       	pop	r11
     c3c:	af 90       	pop	r10
     c3e:	08 95       	ret

00000c40 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c40:	42 df       	rcall	.-380    	; 0xac6 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c42:	bc 01       	movw	r22, r24
     c44:	88 27       	eor	r24, r24
     c46:	77 fd       	sbrc	r23, 7
     c48:	80 95       	com	r24
     c4a:	98 2f       	mov	r25, r24
     c4c:	0e 94 4b 14 	call	0x2896	; 0x2896 <__floatsisf>
     c50:	29 e2       	ldi	r18, 0x29	; 41
     c52:	3c e5       	ldi	r19, 0x5C	; 92
     c54:	4f e6       	ldi	r20, 0x6F	; 111
     c56:	5f eb       	ldi	r21, 0xBF	; 191
     c58:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <pow>
     c5c:	22 e5       	ldi	r18, 0x52	; 82
     c5e:	38 e6       	ldi	r19, 0x68	; 104
     c60:	46 e2       	ldi	r20, 0x26	; 38
     c62:	56 e4       	ldi	r21, 0x46	; 70
     c64:	0e 94 d7 14 	call	0x29ae	; 0x29ae <__mulsf3>
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	40 e2       	ldi	r20, 0x20	; 32
     c6e:	51 e4       	ldi	r21, 0x41	; 65
     c70:	0e 94 b3 13 	call	0x2766	; 0x2766 <__subsf3>
     c74:	0e 94 18 14 	call	0x2830	; 0x2830 <__fixsfsi>
     c78:	cb 01       	movw	r24, r22
     c7a:	68 3e       	cpi	r22, 0xE8	; 232
     c7c:	23 e0       	ldi	r18, 0x03	; 3
     c7e:	72 07       	cpc	r23, r18
     c80:	14 f0       	brlt	.+4      	; 0xc86 <mySharpIR_Read+0x46>
     c82:	87 ee       	ldi	r24, 0xE7	; 231
     c84:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
}
     c86:	08 95       	ret

00000c88 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     c88:	fb 01       	movw	r30, r22
     c8a:	20 81       	ld	r18, Z
     c8c:	31 81       	ldd	r19, Z+1	; 0x01
     c8e:	50 e0       	ldi	r21, 0x00	; 0
     c90:	b9 01       	movw	r22, r18
     c92:	64 0f       	add	r22, r20
     c94:	75 1f       	adc	r23, r21
     c96:	68 17       	cp	r22, r24
     c98:	79 07       	cpc	r23, r25
     c9a:	4c f0       	brlt	.+18     	; 0xcae <checkWithinRange+0x26>
     c9c:	24 1b       	sub	r18, r20
     c9e:	35 0b       	sbc	r19, r21
     ca0:	41 e0       	ldi	r20, 0x01	; 1
     ca2:	82 17       	cp	r24, r18
     ca4:	93 07       	cpc	r25, r19
     ca6:	0c f0       	brlt	.+2      	; 0xcaa <checkWithinRange+0x22>
     ca8:	40 e0       	ldi	r20, 0x00	; 0
     caa:	84 2f       	mov	r24, r20
     cac:	08 95       	ret
     cae:	81 e0       	ldi	r24, 0x01	; 1
}
     cb0:	08 95       	ret

00000cb2 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	8c 01       	movw	r16, r24
     cbc:	eb 01       	movw	r28, r22
	static const char range = 5; // put at header file later...
	static const char CALIBRATE_COUNT = 20; // put at header file later...
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, range) && i == 0)
     cbe:	45 e0       	ldi	r20, 0x05	; 5
     cc0:	bc 01       	movw	r22, r24
     cc2:	ce 01       	movw	r24, r28
     cc4:	e1 df       	rcall	.-62     	; 0xc88 <checkWithinRange>
     cc6:	88 23       	and	r24, r24
     cc8:	41 f0       	breq	.+16     	; 0xcda <mySharpIR_ReCalibrate+0x28>
     cca:	20 91 22 08 	lds	r18, 0x0822
     cce:	30 91 23 08 	lds	r19, 0x0823
     cd2:	21 15       	cp	r18, r1
     cd4:	31 05       	cpc	r19, r1
     cd6:	69 f4       	brne	.+26     	; 0xcf2 <mySharpIR_ReCalibrate+0x40>
     cd8:	4b c0       	rjmp	.+150    	; 0xd70 <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     cda:	20 91 22 08 	lds	r18, 0x0822
     cde:	30 91 23 08 	lds	r19, 0x0823
     ce2:	21 15       	cp	r18, r1
     ce4:	31 05       	cpc	r19, r1
     ce6:	29 f4       	brne	.+10     	; 0xcf2 <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     ce8:	d0 93 1f 08 	sts	0x081F, r29
     cec:	c0 93 1e 08 	sts	0x081E, r28
     cf0:	32 c0       	rjmp	.+100    	; 0xd56 <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     cf2:	2a 30       	cpi	r18, 0x0A	; 10
     cf4:	31 05       	cpc	r19, r1
     cf6:	a9 f4       	brne	.+42     	; 0xd22 <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, range))
     cf8:	45 e0       	ldi	r20, 0x05	; 5
     cfa:	6e e1       	ldi	r22, 0x1E	; 30
     cfc:	78 e0       	ldi	r23, 0x08	; 8
     cfe:	ce 01       	movw	r24, r28
     d00:	c3 df       	rcall	.-122    	; 0xc88 <checkWithinRange>
     d02:	88 23       	and	r24, r24
     d04:	49 f0       	breq	.+18     	; 0xd18 <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d06:	d0 93 1f 08 	sts	0x081F, r29
     d0a:	c0 93 1e 08 	sts	0x081E, r28
			i = 0; // reset to count...
     d0e:	10 92 23 08 	sts	0x0823, r1
     d12:	10 92 22 08 	sts	0x0822, r1
     d16:	1f c0       	rjmp	.+62     	; 0xd56 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d18:	d0 93 21 08 	sts	0x0821, r29
     d1c:	c0 93 20 08 	sts	0x0820, r28
     d20:	1a c0       	rjmp	.+52     	; 0xd56 <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d22:	24 31       	cpi	r18, 0x14	; 20
     d24:	31 05       	cpc	r19, r1
     d26:	b9 f4       	brne	.+46     	; 0xd56 <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     d28:	10 92 23 08 	sts	0x0823, r1
     d2c:	10 92 22 08 	sts	0x0822, r1

		if(checkWithinRange(reading, checkReading, range))
     d30:	45 e0       	ldi	r20, 0x05	; 5
     d32:	6e e1       	ldi	r22, 0x1E	; 30
     d34:	78 e0       	ldi	r23, 0x08	; 8
     d36:	ce 01       	movw	r24, r28
     d38:	a7 df       	rcall	.-178    	; 0xc88 <checkWithinRange>
     d3a:	88 23       	and	r24, r24
     d3c:	29 f0       	breq	.+10     	; 0xd48 <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d3e:	d0 93 1f 08 	sts	0x081F, r29
     d42:	c0 93 1e 08 	sts	0x081E, r28
     d46:	07 c0       	rjmp	.+14     	; 0xd56 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     d48:	80 91 1e 08 	lds	r24, 0x081E
     d4c:	90 91 1f 08 	lds	r25, 0x081F
     d50:	f8 01       	movw	r30, r16
     d52:	91 83       	std	Z+1, r25	; 0x01
     d54:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     d56:	80 91 22 08 	lds	r24, 0x0822
     d5a:	90 91 23 08 	lds	r25, 0x0823
     d5e:	01 96       	adiw	r24, 0x01	; 1
     d60:	64 e1       	ldi	r22, 0x14	; 20
     d62:	70 e0       	ldi	r23, 0x00	; 0
     d64:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <__divmodhi4>
     d68:	90 93 23 08 	sts	0x0823, r25
     d6c:	80 93 22 08 	sts	0x0822, r24
}
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	08 95       	ret

00000d7a <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     d7a:	90 93 ac 08 	sts	0x08AC, r25
     d7e:	80 93 ab 08 	sts	0x08AB, r24
     d82:	fc 01       	movw	r30, r24
     d84:	80 81       	ld	r24, Z
     d86:	91 81       	ldd	r25, Z+1	; 0x01
     d88:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskSuspend>
     d8c:	43 e0       	ldi	r20, 0x03	; 3
     d8e:	60 e0       	ldi	r22, 0x00	; 0
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	ee d4       	rcall	.+2524   	; 0x1770 <xQueueGenericCreate>
     d94:	90 93 a8 08 	sts	0x08A8, r25
     d98:	80 93 a7 08 	sts	0x08A7, r24
     d9c:	43 e0       	ldi	r20, 0x03	; 3
     d9e:	60 e0       	ldi	r22, 0x00	; 0
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	e6 d4       	rcall	.+2508   	; 0x1770 <xQueueGenericCreate>
     da4:	90 93 aa 08 	sts	0x08AA, r25
     da8:	80 93 a9 08 	sts	0x08A9, r24
     dac:	08 95       	ret

00000dae <myTimer_Read>:
     dae:	86 b5       	in	r24, 0x26	; 38
     db0:	08 95       	ret

00000db2 <myTimer_DelayMicro>:
     db2:	46 b5       	in	r20, 0x26	; 38
     db4:	50 e0       	ldi	r21, 0x00	; 0
     db6:	9c 01       	movw	r18, r24
     db8:	99 23       	and	r25, r25
     dba:	14 f4       	brge	.+4      	; 0xdc0 <myTimer_DelayMicro+0xe>
     dbc:	2d 5f       	subi	r18, 0xFD	; 253
     dbe:	3f 4f       	sbci	r19, 0xFF	; 255
     dc0:	35 95       	asr	r19
     dc2:	27 95       	ror	r18
     dc4:	35 95       	asr	r19
     dc6:	27 95       	ror	r18
     dc8:	24 0f       	add	r18, r20
     dca:	35 1f       	adc	r19, r21
     dcc:	30 93 03 02 	sts	0x0203, r19
     dd0:	20 93 02 02 	sts	0x0202, r18
     dd4:	e0 91 ab 08 	lds	r30, 0x08AB
     dd8:	f0 91 ac 08 	lds	r31, 0x08AC
     ddc:	80 81       	ld	r24, Z
     dde:	91 81       	ldd	r25, Z+1	; 0x01
     de0:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <vTaskResume>
     de4:	20 e0       	ldi	r18, 0x00	; 0
     de6:	42 e0       	ldi	r20, 0x02	; 2
     de8:	50 e0       	ldi	r21, 0x00	; 0
     dea:	60 e0       	ldi	r22, 0x00	; 0
     dec:	70 e0       	ldi	r23, 0x00	; 0
     dee:	80 91 a7 08 	lds	r24, 0x08A7
     df2:	90 91 a8 08 	lds	r25, 0x08A8
     df6:	e1 c5       	rjmp	.+3010   	; 0x19ba <xQueueGenericReceive>
     df8:	08 95       	ret

00000dfa <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     dfa:	cf 93       	push	r28
     dfc:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     dfe:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e00:	c1 11       	cpse	r28, r1
     e02:	22 c0       	rjmp	.+68     	; 0xe48 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e04:	80 91 02 02 	lds	r24, 0x0202
     e08:	90 91 03 02 	lds	r25, 0x0203
     e0c:	88 38       	cpi	r24, 0x88	; 136
     e0e:	93 41       	sbci	r25, 0x13	; 19
     e10:	51 f0       	breq	.+20     	; 0xe26 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e12:	80 91 02 02 	lds	r24, 0x0202
     e16:	90 91 03 02 	lds	r25, 0x0203
     e1a:	8a 5f       	subi	r24, 0xFA	; 250
     e1c:	91 09       	sbc	r25, r1
     e1e:	90 93 03 02 	sts	0x0203, r25
     e22:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e26:	80 91 00 02 	lds	r24, 0x0200
     e2a:	90 91 01 02 	lds	r25, 0x0201
     e2e:	88 38       	cpi	r24, 0x88	; 136
     e30:	93 41       	sbci	r25, 0x13	; 19
     e32:	51 f0       	breq	.+20     	; 0xe48 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e34:	80 91 00 02 	lds	r24, 0x0200
     e38:	90 91 01 02 	lds	r25, 0x0201
     e3c:	8a 5f       	subi	r24, 0xFA	; 250
     e3e:	91 09       	sbc	r25, r1
     e40:	90 93 01 02 	sts	0x0201, r25
     e44:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e48:	d0 e0       	ldi	r29, 0x00	; 0
     e4a:	80 91 02 02 	lds	r24, 0x0202
     e4e:	90 91 03 02 	lds	r25, 0x0203
     e52:	8c 17       	cp	r24, r28
     e54:	9d 07       	cpc	r25, r29
     e56:	84 f4       	brge	.+32     	; 0xe78 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     e58:	88 e8       	ldi	r24, 0x88	; 136
     e5a:	93 e1       	ldi	r25, 0x13	; 19
     e5c:	90 93 03 02 	sts	0x0203, r25
     e60:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     e64:	20 e0       	ldi	r18, 0x00	; 0
     e66:	40 e0       	ldi	r20, 0x00	; 0
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	60 e0       	ldi	r22, 0x00	; 0
     e6c:	70 e0       	ldi	r23, 0x00	; 0
     e6e:	80 91 a7 08 	lds	r24, 0x08A7
     e72:	90 91 a8 08 	lds	r25, 0x08A8
     e76:	a9 d4       	rcall	.+2386   	; 0x17ca <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     e78:	80 91 00 02 	lds	r24, 0x0200
     e7c:	90 91 01 02 	lds	r25, 0x0201
     e80:	8c 17       	cp	r24, r28
     e82:	9d 07       	cpc	r25, r29
     e84:	84 f4       	brge	.+32     	; 0xea6 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     e86:	88 e8       	ldi	r24, 0x88	; 136
     e88:	93 e1       	ldi	r25, 0x13	; 19
     e8a:	90 93 01 02 	sts	0x0201, r25
     e8e:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     e92:	20 e0       	ldi	r18, 0x00	; 0
     e94:	40 e0       	ldi	r20, 0x00	; 0
     e96:	50 e0       	ldi	r21, 0x00	; 0
     e98:	60 e0       	ldi	r22, 0x00	; 0
     e9a:	70 e0       	ldi	r23, 0x00	; 0
     e9c:	80 91 a9 08 	lds	r24, 0x08A9
     ea0:	90 91 aa 08 	lds	r25, 0x08AA
     ea4:	92 d4       	rcall	.+2340   	; 0x17ca <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     ea6:	80 91 02 02 	lds	r24, 0x0202
     eaa:	90 91 03 02 	lds	r25, 0x0203
     eae:	88 38       	cpi	r24, 0x88	; 136
     eb0:	93 41       	sbci	r25, 0x13	; 19
     eb2:	79 f4       	brne	.+30     	; 0xed2 <myTimer_DelayChecker+0xd8>
     eb4:	80 91 00 02 	lds	r24, 0x0200
     eb8:	90 91 01 02 	lds	r25, 0x0201
     ebc:	88 38       	cpi	r24, 0x88	; 136
     ebe:	93 41       	sbci	r25, 0x13	; 19
     ec0:	41 f4       	brne	.+16     	; 0xed2 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     ec2:	e0 91 ab 08 	lds	r30, 0x08AB
     ec6:	f0 91 ac 08 	lds	r31, 0x08AC
     eca:	80 81       	ld	r24, Z
     ecc:	91 81       	ldd	r25, Z+1	; 0x01
     ece:	0e 94 fd 11 	call	0x23fa	; 0x23fa <vTaskSuspend>
	}
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	08 95       	ret

00000ed8 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     ed8:	1f 92       	push	r1
     eda:	0f 92       	push	r0
     edc:	0f b6       	in	r0, 0x3f	; 63
     ede:	0f 92       	push	r0
     ee0:	11 24       	eor	r1, r1
     ee2:	0b b6       	in	r0, 0x3b	; 59
     ee4:	0f 92       	push	r0
     ee6:	2f 93       	push	r18
     ee8:	3f 93       	push	r19
     eea:	4f 93       	push	r20
     eec:	5f 93       	push	r21
     eee:	6f 93       	push	r22
     ef0:	7f 93       	push	r23
     ef2:	8f 93       	push	r24
     ef4:	9f 93       	push	r25
     ef6:	af 93       	push	r26
     ef8:	bf 93       	push	r27
     efa:	ef 93       	push	r30
     efc:	ff 93       	push	r31
     efe:	60 91 ce 00 	lds	r22, 0x00CE
     f02:	82 e4       	ldi	r24, 0x42	; 66
     f04:	99 e0       	ldi	r25, 0x09	; 9
     f06:	2f d6       	rcall	.+3166   	; 0x1b66 <ringBufferPush>
     f08:	20 e0       	ldi	r18, 0x00	; 0
     f0a:	40 e0       	ldi	r20, 0x00	; 0
     f0c:	50 e0       	ldi	r21, 0x00	; 0
     f0e:	60 e0       	ldi	r22, 0x00	; 0
     f10:	70 e0       	ldi	r23, 0x00	; 0
     f12:	80 91 36 09 	lds	r24, 0x0936
     f16:	90 91 37 09 	lds	r25, 0x0937
     f1a:	15 d5       	rcall	.+2602   	; 0x1946 <xQueueGenericSendFromISR>
     f1c:	82 e4       	ldi	r24, 0x42	; 66
     f1e:	99 e0       	ldi	r25, 0x09	; 9
     f20:	39 d6       	rcall	.+3186   	; 0x1b94 <ringBufferFull>
     f22:	ff 91       	pop	r31
     f24:	ef 91       	pop	r30
     f26:	bf 91       	pop	r27
     f28:	af 91       	pop	r26
     f2a:	9f 91       	pop	r25
     f2c:	8f 91       	pop	r24
     f2e:	7f 91       	pop	r23
     f30:	6f 91       	pop	r22
     f32:	5f 91       	pop	r21
     f34:	4f 91       	pop	r20
     f36:	3f 91       	pop	r19
     f38:	2f 91       	pop	r18
     f3a:	0f 90       	pop	r0
     f3c:	0b be       	out	0x3b, r0	; 59
     f3e:	0f 90       	pop	r0
     f40:	0f be       	out	0x3f, r0	; 63
     f42:	0f 90       	pop	r0
     f44:	1f 90       	pop	r1
     f46:	18 95       	reti

00000f48 <__vector_25>:
     f48:	1f 92       	push	r1
     f4a:	0f 92       	push	r0
     f4c:	0f b6       	in	r0, 0x3f	; 63
     f4e:	0f 92       	push	r0
     f50:	11 24       	eor	r1, r1
     f52:	0b b6       	in	r0, 0x3b	; 59
     f54:	0f 92       	push	r0
     f56:	2f 93       	push	r18
     f58:	3f 93       	push	r19
     f5a:	4f 93       	push	r20
     f5c:	5f 93       	push	r21
     f5e:	6f 93       	push	r22
     f60:	7f 93       	push	r23
     f62:	8f 93       	push	r24
     f64:	9f 93       	push	r25
     f66:	af 93       	push	r26
     f68:	bf 93       	push	r27
     f6a:	ef 93       	push	r30
     f6c:	ff 93       	push	r31
     f6e:	60 91 c6 00 	lds	r22, 0x00C6
     f72:	8d ec       	ldi	r24, 0xCD	; 205
     f74:	98 e0       	ldi	r25, 0x08	; 8
     f76:	f7 d5       	rcall	.+3054   	; 0x1b66 <ringBufferPush>
     f78:	20 e0       	ldi	r18, 0x00	; 0
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	60 e0       	ldi	r22, 0x00	; 0
     f80:	70 e0       	ldi	r23, 0x00	; 0
     f82:	80 91 36 09 	lds	r24, 0x0936
     f86:	90 91 37 09 	lds	r25, 0x0937
     f8a:	dd d4       	rcall	.+2490   	; 0x1946 <xQueueGenericSendFromISR>
     f8c:	8d ec       	ldi	r24, 0xCD	; 205
     f8e:	98 e0       	ldi	r25, 0x08	; 8
     f90:	01 d6       	rcall	.+3074   	; 0x1b94 <ringBufferFull>
     f92:	ff 91       	pop	r31
     f94:	ef 91       	pop	r30
     f96:	bf 91       	pop	r27
     f98:	af 91       	pop	r26
     f9a:	9f 91       	pop	r25
     f9c:	8f 91       	pop	r24
     f9e:	7f 91       	pop	r23
     fa0:	6f 91       	pop	r22
     fa2:	5f 91       	pop	r21
     fa4:	4f 91       	pop	r20
     fa6:	3f 91       	pop	r19
     fa8:	2f 91       	pop	r18
     faa:	0f 90       	pop	r0
     fac:	0b be       	out	0x3b, r0	; 59
     fae:	0f 90       	pop	r0
     fb0:	0f be       	out	0x3f, r0	; 63
     fb2:	0f 90       	pop	r0
     fb4:	1f 90       	pop	r1
     fb6:	18 95       	reti

00000fb8 <__vector_37>:
     fb8:	1f 92       	push	r1
     fba:	0f 92       	push	r0
     fbc:	0f b6       	in	r0, 0x3f	; 63
     fbe:	0f 92       	push	r0
     fc0:	11 24       	eor	r1, r1
     fc2:	0b b6       	in	r0, 0x3b	; 59
     fc4:	0f 92       	push	r0
     fc6:	2f 93       	push	r18
     fc8:	3f 93       	push	r19
     fca:	4f 93       	push	r20
     fcc:	5f 93       	push	r21
     fce:	6f 93       	push	r22
     fd0:	7f 93       	push	r23
     fd2:	8f 93       	push	r24
     fd4:	9f 93       	push	r25
     fd6:	af 93       	push	r26
     fd8:	bf 93       	push	r27
     fda:	ef 93       	push	r30
     fdc:	ff 93       	push	r31
     fde:	88 e3       	ldi	r24, 0x38	; 56
     fe0:	99 e0       	ldi	r25, 0x09	; 9
     fe2:	df d5       	rcall	.+3006   	; 0x1ba2 <ringBufferNotEmpty>
     fe4:	88 23       	and	r24, r24
     fe6:	31 f0       	breq	.+12     	; 0xff4 <__vector_37+0x3c>
     fe8:	88 e3       	ldi	r24, 0x38	; 56
     fea:	99 e0       	ldi	r25, 0x09	; 9
     fec:	aa d5       	rcall	.+2900   	; 0x1b42 <ringBufferPop>
     fee:	80 93 ce 00 	sts	0x00CE, r24
     ff2:	05 c0       	rjmp	.+10     	; 0xffe <__vector_37+0x46>
     ff4:	e9 ec       	ldi	r30, 0xC9	; 201
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	8f 7d       	andi	r24, 0xDF	; 223
     ffc:	80 83       	st	Z, r24
     ffe:	ff 91       	pop	r31
    1000:	ef 91       	pop	r30
    1002:	bf 91       	pop	r27
    1004:	af 91       	pop	r26
    1006:	9f 91       	pop	r25
    1008:	8f 91       	pop	r24
    100a:	7f 91       	pop	r23
    100c:	6f 91       	pop	r22
    100e:	5f 91       	pop	r21
    1010:	4f 91       	pop	r20
    1012:	3f 91       	pop	r19
    1014:	2f 91       	pop	r18
    1016:	0f 90       	pop	r0
    1018:	0b be       	out	0x3b, r0	; 59
    101a:	0f 90       	pop	r0
    101c:	0f be       	out	0x3f, r0	; 63
    101e:	0f 90       	pop	r0
    1020:	1f 90       	pop	r1
    1022:	18 95       	reti

00001024 <__vector_26>:
    1024:	1f 92       	push	r1
    1026:	0f 92       	push	r0
    1028:	0f b6       	in	r0, 0x3f	; 63
    102a:	0f 92       	push	r0
    102c:	11 24       	eor	r1, r1
    102e:	0b b6       	in	r0, 0x3b	; 59
    1030:	0f 92       	push	r0
    1032:	2f 93       	push	r18
    1034:	3f 93       	push	r19
    1036:	4f 93       	push	r20
    1038:	5f 93       	push	r21
    103a:	6f 93       	push	r22
    103c:	7f 93       	push	r23
    103e:	8f 93       	push	r24
    1040:	9f 93       	push	r25
    1042:	af 93       	push	r26
    1044:	bf 93       	push	r27
    1046:	ef 93       	push	r30
    1048:	ff 93       	push	r31
    104a:	8d e3       	ldi	r24, 0x3D	; 61
    104c:	99 e0       	ldi	r25, 0x09	; 9
    104e:	a9 d5       	rcall	.+2898   	; 0x1ba2 <ringBufferNotEmpty>
    1050:	88 23       	and	r24, r24
    1052:	31 f0       	breq	.+12     	; 0x1060 <__vector_26+0x3c>
    1054:	8d e3       	ldi	r24, 0x3D	; 61
    1056:	99 e0       	ldi	r25, 0x09	; 9
    1058:	74 d5       	rcall	.+2792   	; 0x1b42 <ringBufferPop>
    105a:	80 93 c6 00 	sts	0x00C6, r24
    105e:	05 c0       	rjmp	.+10     	; 0x106a <__vector_26+0x46>
    1060:	e1 ec       	ldi	r30, 0xC1	; 193
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	8f 7d       	andi	r24, 0xDF	; 223
    1068:	80 83       	st	Z, r24
    106a:	ff 91       	pop	r31
    106c:	ef 91       	pop	r30
    106e:	bf 91       	pop	r27
    1070:	af 91       	pop	r26
    1072:	9f 91       	pop	r25
    1074:	8f 91       	pop	r24
    1076:	7f 91       	pop	r23
    1078:	6f 91       	pop	r22
    107a:	5f 91       	pop	r21
    107c:	4f 91       	pop	r20
    107e:	3f 91       	pop	r19
    1080:	2f 91       	pop	r18
    1082:	0f 90       	pop	r0
    1084:	0b be       	out	0x3b, r0	; 59
    1086:	0f 90       	pop	r0
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	0f 90       	pop	r0
    108c:	1f 90       	pop	r1
    108e:	18 95       	reti

00001090 <myUSART_USART0_Init>:
    1090:	10 92 c5 00 	sts	0x00C5, r1
    1094:	87 e6       	ldi	r24, 0x67	; 103
    1096:	80 93 c4 00 	sts	0x00C4, r24
    109a:	88 eb       	ldi	r24, 0xB8	; 184
    109c:	80 93 c1 00 	sts	0x00C1, r24
    10a0:	86 e0       	ldi	r24, 0x06	; 6
    10a2:	80 93 c2 00 	sts	0x00C2, r24
    10a6:	40 e2       	ldi	r20, 0x20	; 32
    10a8:	64 ef       	ldi	r22, 0xF4	; 244
    10aa:	78 e0       	ldi	r23, 0x08	; 8
    10ac:	8d ec       	ldi	r24, 0xCD	; 205
    10ae:	98 e0       	ldi	r25, 0x08	; 8
    10b0:	37 d5       	rcall	.+2670   	; 0x1b20 <ringBufferInit>
    10b2:	40 e2       	ldi	r20, 0x20	; 32
    10b4:	62 ed       	ldi	r22, 0xD2	; 210
    10b6:	78 e0       	ldi	r23, 0x08	; 8
    10b8:	8d e3       	ldi	r24, 0x3D	; 61
    10ba:	99 e0       	ldi	r25, 0x09	; 9
    10bc:	31 d5       	rcall	.+2658   	; 0x1b20 <ringBufferInit>
    10be:	43 e0       	ldi	r20, 0x03	; 3
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	81 e0       	ldi	r24, 0x01	; 1
    10c4:	55 d3       	rcall	.+1706   	; 0x1770 <xQueueGenericCreate>
    10c6:	90 93 35 09 	sts	0x0935, r25
    10ca:	80 93 34 09 	sts	0x0934, r24
    10ce:	08 95       	ret

000010d0 <myUSART_USART1_Init>:
    10d0:	10 92 cd 00 	sts	0x00CD, r1
    10d4:	87 e6       	ldi	r24, 0x67	; 103
    10d6:	80 93 cc 00 	sts	0x00CC, r24
    10da:	88 eb       	ldi	r24, 0xB8	; 184
    10dc:	80 93 c9 00 	sts	0x00C9, r24
    10e0:	86 e0       	ldi	r24, 0x06	; 6
    10e2:	80 93 ca 00 	sts	0x00CA, r24
    10e6:	40 e2       	ldi	r20, 0x20	; 32
    10e8:	6d ea       	ldi	r22, 0xAD	; 173
    10ea:	78 e0       	ldi	r23, 0x08	; 8
    10ec:	82 e4       	ldi	r24, 0x42	; 66
    10ee:	99 e0       	ldi	r25, 0x09	; 9
    10f0:	17 d5       	rcall	.+2606   	; 0x1b20 <ringBufferInit>
    10f2:	40 e2       	ldi	r20, 0x20	; 32
    10f4:	64 e1       	ldi	r22, 0x14	; 20
    10f6:	79 e0       	ldi	r23, 0x09	; 9
    10f8:	88 e3       	ldi	r24, 0x38	; 56
    10fa:	99 e0       	ldi	r25, 0x09	; 9
    10fc:	11 d5       	rcall	.+2594   	; 0x1b20 <ringBufferInit>
    10fe:	43 e0       	ldi	r20, 0x03	; 3
    1100:	60 e0       	ldi	r22, 0x00	; 0
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	35 d3       	rcall	.+1642   	; 0x1770 <xQueueGenericCreate>
    1106:	90 93 37 09 	sts	0x0937, r25
    110a:	80 93 36 09 	sts	0x0936, r24
    110e:	43 e0       	ldi	r20, 0x03	; 3
    1110:	60 e0       	ldi	r22, 0x00	; 0
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	2d d3       	rcall	.+1626   	; 0x1770 <xQueueGenericCreate>
    1116:	90 93 f3 08 	sts	0x08F3, r25
    111a:	80 93 f2 08 	sts	0x08F2, r24
    111e:	08 95       	ret

00001120 <myUSART_transmitUSART0_c>:
    1120:	cf 93       	push	r28
    1122:	c8 2f       	mov	r28, r24
    1124:	8d e3       	ldi	r24, 0x3D	; 61
    1126:	99 e0       	ldi	r25, 0x09	; 9
    1128:	35 d5       	rcall	.+2666   	; 0x1b94 <ringBufferFull>
    112a:	81 11       	cpse	r24, r1
    112c:	fb cf       	rjmp	.-10     	; 0x1124 <myUSART_transmitUSART0_c+0x4>
    112e:	6c 2f       	mov	r22, r28
    1130:	8d e3       	ldi	r24, 0x3D	; 61
    1132:	99 e0       	ldi	r25, 0x09	; 9
    1134:	18 d5       	rcall	.+2608   	; 0x1b66 <ringBufferPush>
    1136:	e1 ec       	ldi	r30, 0xC1	; 193
    1138:	f0 e0       	ldi	r31, 0x00	; 0
    113a:	80 81       	ld	r24, Z
    113c:	80 62       	ori	r24, 0x20	; 32
    113e:	80 83       	st	Z, r24
    1140:	e0 ec       	ldi	r30, 0xC0	; 192
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	80 64       	ori	r24, 0x40	; 64
    1148:	80 83       	st	Z, r24
    114a:	cf 91       	pop	r28
    114c:	08 95       	ret

0000114e <myUSART_transmitUSART1_c>:
    114e:	cf 93       	push	r28
    1150:	c8 2f       	mov	r28, r24
    1152:	88 e3       	ldi	r24, 0x38	; 56
    1154:	99 e0       	ldi	r25, 0x09	; 9
    1156:	1e d5       	rcall	.+2620   	; 0x1b94 <ringBufferFull>
    1158:	81 11       	cpse	r24, r1
    115a:	fb cf       	rjmp	.-10     	; 0x1152 <myUSART_transmitUSART1_c+0x4>
    115c:	6c 2f       	mov	r22, r28
    115e:	88 e3       	ldi	r24, 0x38	; 56
    1160:	99 e0       	ldi	r25, 0x09	; 9
    1162:	01 d5       	rcall	.+2562   	; 0x1b66 <ringBufferPush>
    1164:	e9 ec       	ldi	r30, 0xC9	; 201
    1166:	f0 e0       	ldi	r31, 0x00	; 0
    1168:	80 81       	ld	r24, Z
    116a:	80 62       	ori	r24, 0x20	; 32
    116c:	80 83       	st	Z, r24
    116e:	e8 ec       	ldi	r30, 0xC8	; 200
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	80 81       	ld	r24, Z
    1174:	80 64       	ori	r24, 0x40	; 64
    1176:	80 83       	st	Z, r24
    1178:	cf 91       	pop	r28
    117a:	08 95       	ret

0000117c <myUSART_transmitUSART1>:
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	ec 01       	movw	r28, r24
    1182:	88 81       	ld	r24, Y
    1184:	88 23       	and	r24, r24
    1186:	29 f0       	breq	.+10     	; 0x1192 <myUSART_transmitUSART1+0x16>
    1188:	21 96       	adiw	r28, 0x01	; 1
    118a:	e1 df       	rcall	.-62     	; 0x114e <myUSART_transmitUSART1_c>
    118c:	89 91       	ld	r24, Y+
    118e:	81 11       	cpse	r24, r1
    1190:	fc cf       	rjmp	.-8      	; 0x118a <myUSART_transmitUSART1+0xe>
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
    1196:	08 95       	ret

00001198 <myUSART_transmitUSART0>:
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	ec 01       	movw	r28, r24
    119e:	88 81       	ld	r24, Y
    11a0:	88 23       	and	r24, r24
    11a2:	29 f0       	breq	.+10     	; 0x11ae <myUSART_transmitUSART0+0x16>
    11a4:	21 96       	adiw	r28, 0x01	; 1
    11a6:	bc df       	rcall	.-136    	; 0x1120 <myUSART_transmitUSART0_c>
    11a8:	89 91       	ld	r24, Y+
    11aa:	81 11       	cpse	r24, r1
    11ac:	fc cf       	rjmp	.-8      	; 0x11a6 <myUSART_transmitUSART0+0xe>
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	08 95       	ret

000011b4 <myUSART_receiveUSART1>:
    11b4:	cf 93       	push	r28
    11b6:	20 e0       	ldi	r18, 0x00	; 0
    11b8:	4f ef       	ldi	r20, 0xFF	; 255
    11ba:	5f ef       	ldi	r21, 0xFF	; 255
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	70 e0       	ldi	r23, 0x00	; 0
    11c0:	80 91 36 09 	lds	r24, 0x0936
    11c4:	90 91 37 09 	lds	r25, 0x0937
    11c8:	f8 d3       	rcall	.+2032   	; 0x19ba <xQueueGenericReceive>
    11ca:	82 e4       	ldi	r24, 0x42	; 66
    11cc:	99 e0       	ldi	r25, 0x09	; 9
    11ce:	b9 d4       	rcall	.+2418   	; 0x1b42 <ringBufferPop>
    11d0:	c8 2f       	mov	r28, r24
    11d2:	82 e4       	ldi	r24, 0x42	; 66
    11d4:	99 e0       	ldi	r25, 0x09	; 9
    11d6:	e5 d4       	rcall	.+2506   	; 0x1ba2 <ringBufferNotEmpty>
    11d8:	88 23       	and	r24, r24
    11da:	51 f0       	breq	.+20     	; 0x11f0 <myUSART_receiveUSART1+0x3c>
    11dc:	20 e0       	ldi	r18, 0x00	; 0
    11de:	40 e0       	ldi	r20, 0x00	; 0
    11e0:	50 e0       	ldi	r21, 0x00	; 0
    11e2:	60 e0       	ldi	r22, 0x00	; 0
    11e4:	70 e0       	ldi	r23, 0x00	; 0
    11e6:	80 91 36 09 	lds	r24, 0x0936
    11ea:	90 91 37 09 	lds	r25, 0x0937
    11ee:	ed d2       	rcall	.+1498   	; 0x17ca <xQueueGenericSend>
    11f0:	8c 2f       	mov	r24, r28
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <myUSART_waitForHandshake>:
    11f6:	de df       	rcall	.-68     	; 0x11b4 <myUSART_receiveUSART1>
    11f8:	86 31       	cpi	r24, 0x16	; 22
    11fa:	51 f4       	brne	.+20     	; 0x1210 <myUSART_waitForHandshake+0x1a>
    11fc:	85 e0       	ldi	r24, 0x05	; 5
    11fe:	a7 df       	rcall	.-178    	; 0x114e <myUSART_transmitUSART1_c>
    1200:	d9 df       	rcall	.-78     	; 0x11b4 <myUSART_receiveUSART1>
    1202:	91 e0       	ldi	r25, 0x01	; 1
    1204:	86 31       	cpi	r24, 0x16	; 22
    1206:	09 f4       	brne	.+2      	; 0x120a <myUSART_waitForHandshake+0x14>
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	89 2f       	mov	r24, r25
    120c:	81 95       	neg	r24
    120e:	08 95       	ret
    1210:	8f ef       	ldi	r24, 0xFF	; 255
    1212:	08 95       	ret

00001214 <myUSART_completeHandShake>:
    1214:	20 e0       	ldi	r18, 0x00	; 0
    1216:	40 e0       	ldi	r20, 0x00	; 0
    1218:	50 e0       	ldi	r21, 0x00	; 0
    121a:	60 e0       	ldi	r22, 0x00	; 0
    121c:	70 e0       	ldi	r23, 0x00	; 0
    121e:	80 91 f2 08 	lds	r24, 0x08F2
    1222:	90 91 f3 08 	lds	r25, 0x08F3
    1226:	d1 c2       	rjmp	.+1442   	; 0x17ca <xQueueGenericSend>
    1228:	08 95       	ret

0000122a <myUSART_receiveHandShakeAck>:
    122a:	91 e0       	ldi	r25, 0x01	; 1
    122c:	85 30       	cpi	r24, 0x05	; 5
    122e:	09 f0       	breq	.+2      	; 0x1232 <myUSART_receiveHandShakeAck+0x8>
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	89 2f       	mov	r24, r25
    1234:	08 95       	ret

00001236 <myUSART_receiveHandShakeStart>:
    1236:	91 e0       	ldi	r25, 0x01	; 1
    1238:	86 31       	cpi	r24, 0x16	; 22
    123a:	09 f0       	breq	.+2      	; 0x123e <myUSART_receiveHandShakeStart+0x8>
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	89 2f       	mov	r24, r25
    1240:	08 95       	ret

00001242 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1242:	91 e0       	ldi	r25, 0x01	; 1
    1244:	86 30       	cpi	r24, 0x06	; 6
    1246:	09 f0       	breq	.+2      	; 0x124a <myUSART_receiveMessageACK+0x8>
    1248:	90 e0       	ldi	r25, 0x00	; 0
}
    124a:	89 2f       	mov	r24, r25
    124c:	08 95       	ret

0000124e <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    124e:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	4f ef       	ldi	r20, 0xFF	; 255
    1254:	5f ef       	ldi	r21, 0xFF	; 255
    1256:	60 e0       	ldi	r22, 0x00	; 0
    1258:	70 e0       	ldi	r23, 0x00	; 0
    125a:	80 91 36 09 	lds	r24, 0x0936
    125e:	90 91 37 09 	lds	r25, 0x0937
    1262:	ab d3       	rcall	.+1878   	; 0x19ba <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    1264:	82 e4       	ldi	r24, 0x42	; 66
    1266:	99 e0       	ldi	r25, 0x09	; 9
    1268:	62 d4       	rcall	.+2244   	; 0x1b2e <ringBufferPeek>
    126a:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    126c:	82 e4       	ldi	r24, 0x42	; 66
    126e:	99 e0       	ldi	r25, 0x09	; 9
    1270:	98 d4       	rcall	.+2352   	; 0x1ba2 <ringBufferNotEmpty>
    1272:	88 23       	and	r24, r24
    1274:	51 f0       	breq	.+20     	; 0x128a <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    1276:	20 e0       	ldi	r18, 0x00	; 0
    1278:	40 e0       	ldi	r20, 0x00	; 0
    127a:	50 e0       	ldi	r21, 0x00	; 0
    127c:	60 e0       	ldi	r22, 0x00	; 0
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	80 91 36 09 	lds	r24, 0x0936
    1284:	90 91 37 09 	lds	r25, 0x0937
    1288:	a0 d2       	rcall	.+1344   	; 0x17ca <xQueueGenericSend>
	}
	
	return data;
    128a:	8c 2f       	mov	r24, r28
    128c:	cf 91       	pop	r28
    128e:	08 95       	ret

00001290 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1290:	31 e1       	ldi	r19, 0x11	; 17
    1292:	fc 01       	movw	r30, r24
    1294:	30 83       	st	Z, r19
    1296:	31 97       	sbiw	r30, 0x01	; 1
    1298:	22 e2       	ldi	r18, 0x22	; 34
    129a:	20 83       	st	Z, r18
    129c:	31 97       	sbiw	r30, 0x01	; 1
    129e:	a3 e3       	ldi	r26, 0x33	; 51
    12a0:	a0 83       	st	Z, r26
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	60 83       	st	Z, r22
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	70 83       	st	Z, r23
    12aa:	31 97       	sbiw	r30, 0x01	; 1
    12ac:	10 82       	st	Z, r1
    12ae:	31 97       	sbiw	r30, 0x01	; 1
    12b0:	10 82       	st	Z, r1
    12b2:	31 97       	sbiw	r30, 0x01	; 1
    12b4:	60 e8       	ldi	r22, 0x80	; 128
    12b6:	60 83       	st	Z, r22
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	10 82       	st	Z, r1
    12bc:	31 97       	sbiw	r30, 0x01	; 1
    12be:	10 82       	st	Z, r1
    12c0:	31 97       	sbiw	r30, 0x01	; 1
    12c2:	10 82       	st	Z, r1
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	62 e0       	ldi	r22, 0x02	; 2
    12c8:	60 83       	st	Z, r22
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	63 e0       	ldi	r22, 0x03	; 3
    12ce:	60 83       	st	Z, r22
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	64 e0       	ldi	r22, 0x04	; 4
    12d4:	60 83       	st	Z, r22
    12d6:	31 97       	sbiw	r30, 0x01	; 1
    12d8:	65 e0       	ldi	r22, 0x05	; 5
    12da:	60 83       	st	Z, r22
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	66 e0       	ldi	r22, 0x06	; 6
    12e0:	60 83       	st	Z, r22
    12e2:	31 97       	sbiw	r30, 0x01	; 1
    12e4:	67 e0       	ldi	r22, 0x07	; 7
    12e6:	60 83       	st	Z, r22
    12e8:	31 97       	sbiw	r30, 0x01	; 1
    12ea:	68 e0       	ldi	r22, 0x08	; 8
    12ec:	60 83       	st	Z, r22
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	69 e0       	ldi	r22, 0x09	; 9
    12f2:	60 83       	st	Z, r22
    12f4:	31 97       	sbiw	r30, 0x01	; 1
    12f6:	60 e1       	ldi	r22, 0x10	; 16
    12f8:	60 83       	st	Z, r22
    12fa:	31 97       	sbiw	r30, 0x01	; 1
    12fc:	30 83       	st	Z, r19
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	32 e1       	ldi	r19, 0x12	; 18
    1302:	30 83       	st	Z, r19
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	33 e1       	ldi	r19, 0x13	; 19
    1308:	30 83       	st	Z, r19
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	34 e1       	ldi	r19, 0x14	; 20
    130e:	30 83       	st	Z, r19
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	35 e1       	ldi	r19, 0x15	; 21
    1314:	30 83       	st	Z, r19
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	36 e1       	ldi	r19, 0x16	; 22
    131a:	30 83       	st	Z, r19
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	37 e1       	ldi	r19, 0x17	; 23
    1320:	30 83       	st	Z, r19
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	38 e1       	ldi	r19, 0x18	; 24
    1326:	30 83       	st	Z, r19
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	39 e1       	ldi	r19, 0x19	; 25
    132c:	30 83       	st	Z, r19
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	30 e2       	ldi	r19, 0x20	; 32
    1332:	30 83       	st	Z, r19
    1334:	31 97       	sbiw	r30, 0x01	; 1
    1336:	31 e2       	ldi	r19, 0x21	; 33
    1338:	30 83       	st	Z, r19
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	20 83       	st	Z, r18
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	23 e2       	ldi	r18, 0x23	; 35
    1342:	20 83       	st	Z, r18
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	40 83       	st	Z, r20
    1348:	31 97       	sbiw	r30, 0x01	; 1
    134a:	50 83       	st	Z, r21
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	26 e2       	ldi	r18, 0x26	; 38
    1350:	20 83       	st	Z, r18
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	27 e2       	ldi	r18, 0x27	; 39
    1356:	20 83       	st	Z, r18
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	28 e2       	ldi	r18, 0x28	; 40
    135c:	20 83       	st	Z, r18
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	29 e2       	ldi	r18, 0x29	; 41
    1362:	20 83       	st	Z, r18
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	20 e3       	ldi	r18, 0x30	; 48
    1368:	20 83       	st	Z, r18
    136a:	31 97       	sbiw	r30, 0x01	; 1
    136c:	21 e3       	ldi	r18, 0x31	; 49
    136e:	20 83       	st	Z, r18
    1370:	89 97       	sbiw	r24, 0x29	; 41
    1372:	08 95       	ret

00001374 <xPortStartScheduler>:
    1374:	82 e0       	ldi	r24, 0x02	; 2
    1376:	84 bd       	out	0x24, r24	; 36
    1378:	16 bc       	out	0x26, r1	; 38
    137a:	80 e3       	ldi	r24, 0x30	; 48
    137c:	87 bd       	out	0x27, r24	; 39
    137e:	ee e6       	ldi	r30, 0x6E	; 110
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	80 81       	ld	r24, Z
    1384:	82 60       	ori	r24, 0x02	; 2
    1386:	80 83       	st	Z, r24
    1388:	83 e0       	ldi	r24, 0x03	; 3
    138a:	85 bd       	out	0x25, r24	; 37
    138c:	a0 91 8d 08 	lds	r26, 0x088D
    1390:	b0 91 8e 08 	lds	r27, 0x088E
    1394:	cd 91       	ld	r28, X+
    1396:	cd bf       	out	0x3d, r28	; 61
    1398:	dd 91       	ld	r29, X+
    139a:	de bf       	out	0x3e, r29	; 62
    139c:	ff 91       	pop	r31
    139e:	ef 91       	pop	r30
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	bf 91       	pop	r27
    13a6:	af 91       	pop	r26
    13a8:	9f 91       	pop	r25
    13aa:	8f 91       	pop	r24
    13ac:	7f 91       	pop	r23
    13ae:	6f 91       	pop	r22
    13b0:	5f 91       	pop	r21
    13b2:	4f 91       	pop	r20
    13b4:	3f 91       	pop	r19
    13b6:	2f 91       	pop	r18
    13b8:	1f 91       	pop	r17
    13ba:	0f 91       	pop	r16
    13bc:	ff 90       	pop	r15
    13be:	ef 90       	pop	r14
    13c0:	df 90       	pop	r13
    13c2:	cf 90       	pop	r12
    13c4:	bf 90       	pop	r11
    13c6:	af 90       	pop	r10
    13c8:	9f 90       	pop	r9
    13ca:	8f 90       	pop	r8
    13cc:	7f 90       	pop	r7
    13ce:	6f 90       	pop	r6
    13d0:	5f 90       	pop	r5
    13d2:	4f 90       	pop	r4
    13d4:	3f 90       	pop	r3
    13d6:	2f 90       	pop	r2
    13d8:	1f 90       	pop	r1
    13da:	0f 90       	pop	r0
    13dc:	0c be       	out	0x3c, r0	; 60
    13de:	0f 90       	pop	r0
    13e0:	0b be       	out	0x3b, r0	; 59
    13e2:	0f 90       	pop	r0
    13e4:	0f be       	out	0x3f, r0	; 63
    13e6:	0f 90       	pop	r0
    13e8:	08 95       	ret
    13ea:	81 e0       	ldi	r24, 0x01	; 1
    13ec:	08 95       	ret

000013ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13ee:	0f 92       	push	r0
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	0f 92       	push	r0
    13f6:	0b b6       	in	r0, 0x3b	; 59
    13f8:	0f 92       	push	r0
    13fa:	0c b6       	in	r0, 0x3c	; 60
    13fc:	0f 92       	push	r0
    13fe:	1f 92       	push	r1
    1400:	11 24       	eor	r1, r1
    1402:	2f 92       	push	r2
    1404:	3f 92       	push	r3
    1406:	4f 92       	push	r4
    1408:	5f 92       	push	r5
    140a:	6f 92       	push	r6
    140c:	7f 92       	push	r7
    140e:	8f 92       	push	r8
    1410:	9f 92       	push	r9
    1412:	af 92       	push	r10
    1414:	bf 92       	push	r11
    1416:	cf 92       	push	r12
    1418:	df 92       	push	r13
    141a:	ef 92       	push	r14
    141c:	ff 92       	push	r15
    141e:	0f 93       	push	r16
    1420:	1f 93       	push	r17
    1422:	2f 93       	push	r18
    1424:	3f 93       	push	r19
    1426:	4f 93       	push	r20
    1428:	5f 93       	push	r21
    142a:	6f 93       	push	r22
    142c:	7f 93       	push	r23
    142e:	8f 93       	push	r24
    1430:	9f 93       	push	r25
    1432:	af 93       	push	r26
    1434:	bf 93       	push	r27
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	ef 93       	push	r30
    143c:	ff 93       	push	r31
    143e:	a0 91 8d 08 	lds	r26, 0x088D
    1442:	b0 91 8e 08 	lds	r27, 0x088E
    1446:	0d b6       	in	r0, 0x3d	; 61
    1448:	0d 92       	st	X+, r0
    144a:	0e b6       	in	r0, 0x3e	; 62
    144c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    144e:	77 d7       	rcall	.+3822   	; 0x233e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1450:	a0 91 8d 08 	lds	r26, 0x088D
    1454:	b0 91 8e 08 	lds	r27, 0x088E
    1458:	cd 91       	ld	r28, X+
    145a:	cd bf       	out	0x3d, r28	; 61
    145c:	dd 91       	ld	r29, X+
    145e:	de bf       	out	0x3e, r29	; 62
    1460:	ff 91       	pop	r31
    1462:	ef 91       	pop	r30
    1464:	df 91       	pop	r29
    1466:	cf 91       	pop	r28
    1468:	bf 91       	pop	r27
    146a:	af 91       	pop	r26
    146c:	9f 91       	pop	r25
    146e:	8f 91       	pop	r24
    1470:	7f 91       	pop	r23
    1472:	6f 91       	pop	r22
    1474:	5f 91       	pop	r21
    1476:	4f 91       	pop	r20
    1478:	3f 91       	pop	r19
    147a:	2f 91       	pop	r18
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	cf 90       	pop	r12
    1488:	bf 90       	pop	r11
    148a:	af 90       	pop	r10
    148c:	9f 90       	pop	r9
    148e:	8f 90       	pop	r8
    1490:	7f 90       	pop	r7
    1492:	6f 90       	pop	r6
    1494:	5f 90       	pop	r5
    1496:	4f 90       	pop	r4
    1498:	3f 90       	pop	r3
    149a:	2f 90       	pop	r2
    149c:	1f 90       	pop	r1
    149e:	0f 90       	pop	r0
    14a0:	0c be       	out	0x3c, r0	; 60
    14a2:	0f 90       	pop	r0
    14a4:	0b be       	out	0x3b, r0	; 59
    14a6:	0f 90       	pop	r0
    14a8:	0f be       	out	0x3f, r0	; 63
    14aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14ac:	08 95       	ret

000014ae <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14ae:	0f 92       	push	r0
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	0f 92       	push	r0
    14b6:	0b b6       	in	r0, 0x3b	; 59
    14b8:	0f 92       	push	r0
    14ba:	0c b6       	in	r0, 0x3c	; 60
    14bc:	0f 92       	push	r0
    14be:	1f 92       	push	r1
    14c0:	11 24       	eor	r1, r1
    14c2:	2f 92       	push	r2
    14c4:	3f 92       	push	r3
    14c6:	4f 92       	push	r4
    14c8:	5f 92       	push	r5
    14ca:	6f 92       	push	r6
    14cc:	7f 92       	push	r7
    14ce:	8f 92       	push	r8
    14d0:	9f 92       	push	r9
    14d2:	af 92       	push	r10
    14d4:	bf 92       	push	r11
    14d6:	cf 92       	push	r12
    14d8:	df 92       	push	r13
    14da:	ef 92       	push	r14
    14dc:	ff 92       	push	r15
    14de:	0f 93       	push	r16
    14e0:	1f 93       	push	r17
    14e2:	2f 93       	push	r18
    14e4:	3f 93       	push	r19
    14e6:	4f 93       	push	r20
    14e8:	5f 93       	push	r21
    14ea:	6f 93       	push	r22
    14ec:	7f 93       	push	r23
    14ee:	8f 93       	push	r24
    14f0:	9f 93       	push	r25
    14f2:	af 93       	push	r26
    14f4:	bf 93       	push	r27
    14f6:	cf 93       	push	r28
    14f8:	df 93       	push	r29
    14fa:	ef 93       	push	r30
    14fc:	ff 93       	push	r31
    14fe:	a0 91 8d 08 	lds	r26, 0x088D
    1502:	b0 91 8e 08 	lds	r27, 0x088E
    1506:	0d b6       	in	r0, 0x3d	; 61
    1508:	0d 92       	st	X+, r0
    150a:	0e b6       	in	r0, 0x3e	; 62
    150c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    150e:	45 d5       	rcall	.+2698   	; 0x1f9a <xTaskIncrementTick>
    1510:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1512:	15 d7       	rcall	.+3626   	; 0x233e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1514:	a0 91 8d 08 	lds	r26, 0x088D
    1518:	b0 91 8e 08 	lds	r27, 0x088E
    151c:	cd 91       	ld	r28, X+
    151e:	cd bf       	out	0x3d, r28	; 61
    1520:	dd 91       	ld	r29, X+
    1522:	de bf       	out	0x3e, r29	; 62
    1524:	ff 91       	pop	r31
    1526:	ef 91       	pop	r30
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	bf 91       	pop	r27
    152e:	af 91       	pop	r26
    1530:	9f 91       	pop	r25
    1532:	8f 91       	pop	r24
    1534:	7f 91       	pop	r23
    1536:	6f 91       	pop	r22
    1538:	5f 91       	pop	r21
    153a:	4f 91       	pop	r20
    153c:	3f 91       	pop	r19
    153e:	2f 91       	pop	r18
    1540:	1f 91       	pop	r17
    1542:	0f 91       	pop	r16
    1544:	ff 90       	pop	r15
    1546:	ef 90       	pop	r14
    1548:	df 90       	pop	r13
    154a:	cf 90       	pop	r12
    154c:	bf 90       	pop	r11
    154e:	af 90       	pop	r10
    1550:	9f 90       	pop	r9
    1552:	8f 90       	pop	r8
    1554:	7f 90       	pop	r7
    1556:	6f 90       	pop	r6
    1558:	5f 90       	pop	r5
    155a:	4f 90       	pop	r4
    155c:	3f 90       	pop	r3
    155e:	2f 90       	pop	r2
    1560:	1f 90       	pop	r1
    1562:	0f 90       	pop	r0
    1564:	0c be       	out	0x3c, r0	; 60
    1566:	0f 90       	pop	r0
    1568:	0b be       	out	0x3b, r0	; 59
    156a:	0f 90       	pop	r0
    156c:	0f be       	out	0x3f, r0	; 63
    156e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1570:	08 95       	ret

00001572 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1572:	9d df       	rcall	.-198    	; 0x14ae <vPortYieldFromTick>
		 asm volatile ("reti");
    1574:	18 95       	reti

00001576 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1576:	1f 93       	push	r17
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	ec 01       	movw	r28, r24
    157e:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1580:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1582:	81 11       	cpse	r24, r1
    1584:	0c c0       	rjmp	.+24     	; 0x159e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1586:	88 81       	ld	r24, Y
    1588:	99 81       	ldd	r25, Y+1	; 0x01
    158a:	89 2b       	or	r24, r25
    158c:	09 f0       	breq	.+2      	; 0x1590 <prvCopyDataToQueue+0x1a>
    158e:	47 c0       	rjmp	.+142    	; 0x161e <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1590:	8a 81       	ldd	r24, Y+2	; 0x02
    1592:	9b 81       	ldd	r25, Y+3	; 0x03
    1594:	0e 94 62 13 	call	0x26c4	; 0x26c4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1598:	1b 82       	std	Y+3, r1	; 0x03
    159a:	1a 82       	std	Y+2, r1	; 0x02
    159c:	47 c0       	rjmp	.+142    	; 0x162c <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    159e:	41 11       	cpse	r20, r1
    15a0:	18 c0       	rjmp	.+48     	; 0x15d2 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    15a2:	48 2f       	mov	r20, r24
    15a4:	50 e0       	ldi	r21, 0x00	; 0
    15a6:	8c 81       	ldd	r24, Y+4	; 0x04
    15a8:	9d 81       	ldd	r25, Y+5	; 0x05
    15aa:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15ae:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15b0:	8c 81       	ldd	r24, Y+4	; 0x04
    15b2:	9d 81       	ldd	r25, Y+5	; 0x05
    15b4:	82 0f       	add	r24, r18
    15b6:	91 1d       	adc	r25, r1
    15b8:	9d 83       	std	Y+5, r25	; 0x05
    15ba:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15bc:	2a 81       	ldd	r18, Y+2	; 0x02
    15be:	3b 81       	ldd	r19, Y+3	; 0x03
    15c0:	82 17       	cp	r24, r18
    15c2:	93 07       	cpc	r25, r19
    15c4:	70 f1       	brcs	.+92     	; 0x1622 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15c6:	88 81       	ld	r24, Y
    15c8:	99 81       	ldd	r25, Y+1	; 0x01
    15ca:	9d 83       	std	Y+5, r25	; 0x05
    15cc:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    15ce:	80 e0       	ldi	r24, 0x00	; 0
    15d0:	2d c0       	rjmp	.+90     	; 0x162c <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15d2:	48 2f       	mov	r20, r24
    15d4:	50 e0       	ldi	r21, 0x00	; 0
    15d6:	8e 81       	ldd	r24, Y+6	; 0x06
    15d8:	9f 81       	ldd	r25, Y+7	; 0x07
    15da:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    15de:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15e0:	30 e0       	ldi	r19, 0x00	; 0
    15e2:	31 95       	neg	r19
    15e4:	21 95       	neg	r18
    15e6:	31 09       	sbc	r19, r1
    15e8:	8e 81       	ldd	r24, Y+6	; 0x06
    15ea:	9f 81       	ldd	r25, Y+7	; 0x07
    15ec:	82 0f       	add	r24, r18
    15ee:	93 1f       	adc	r25, r19
    15f0:	9f 83       	std	Y+7, r25	; 0x07
    15f2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15f4:	68 81       	ld	r22, Y
    15f6:	79 81       	ldd	r23, Y+1	; 0x01
    15f8:	86 17       	cp	r24, r22
    15fa:	97 07       	cpc	r25, r23
    15fc:	30 f4       	brcc	.+12     	; 0x160a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    15fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1600:	9b 81       	ldd	r25, Y+3	; 0x03
    1602:	28 0f       	add	r18, r24
    1604:	39 1f       	adc	r19, r25
    1606:	3f 83       	std	Y+7, r19	; 0x07
    1608:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    160a:	12 30       	cpi	r17, 0x02	; 2
    160c:	61 f4       	brne	.+24     	; 0x1626 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    160e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1610:	88 23       	and	r24, r24
    1612:	59 f0       	breq	.+22     	; 0x162a <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1614:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1616:	81 50       	subi	r24, 0x01	; 1
    1618:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    161a:	80 e0       	ldi	r24, 0x00	; 0
    161c:	07 c0       	rjmp	.+14     	; 0x162c <prvCopyDataToQueue+0xb6>
    161e:	80 e0       	ldi	r24, 0x00	; 0
    1620:	05 c0       	rjmp	.+10     	; 0x162c <prvCopyDataToQueue+0xb6>
    1622:	80 e0       	ldi	r24, 0x00	; 0
    1624:	03 c0       	rjmp	.+6      	; 0x162c <prvCopyDataToQueue+0xb6>
    1626:	80 e0       	ldi	r24, 0x00	; 0
    1628:	01 c0       	rjmp	.+2      	; 0x162c <prvCopyDataToQueue+0xb6>
    162a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    162c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    162e:	9f 5f       	subi	r25, 0xFF	; 255
    1630:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	08 95       	ret

0000163a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    163a:	fc 01       	movw	r30, r24
    163c:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    163e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1640:	44 23       	and	r20, r20
    1642:	a1 f0       	breq	.+40     	; 0x166c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	26 81       	ldd	r18, Z+6	; 0x06
    1648:	37 81       	ldd	r19, Z+7	; 0x07
    164a:	24 0f       	add	r18, r20
    164c:	35 1f       	adc	r19, r21
    164e:	37 83       	std	Z+7, r19	; 0x07
    1650:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1652:	62 81       	ldd	r22, Z+2	; 0x02
    1654:	73 81       	ldd	r23, Z+3	; 0x03
    1656:	26 17       	cp	r18, r22
    1658:	37 07       	cpc	r19, r23
    165a:	20 f0       	brcs	.+8      	; 0x1664 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    165c:	20 81       	ld	r18, Z
    165e:	31 81       	ldd	r19, Z+1	; 0x01
    1660:	37 83       	std	Z+7, r19	; 0x07
    1662:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1664:	66 81       	ldd	r22, Z+6	; 0x06
    1666:	77 81       	ldd	r23, Z+7	; 0x07
    1668:	0c 94 2e 17 	jmp	0x2e5c	; 0x2e5c <memcpy>
    166c:	08 95       	ret

0000166e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1678:	0f b6       	in	r0, 0x3f	; 63
    167a:	f8 94       	cli
    167c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    167e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1680:	18 16       	cp	r1, r24
    1682:	a4 f4       	brge	.+40     	; 0x16ac <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1684:	89 89       	ldd	r24, Y+17	; 0x11
    1686:	88 23       	and	r24, r24
    1688:	89 f0       	breq	.+34     	; 0x16ac <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    168a:	8e 01       	movw	r16, r28
    168c:	0f 5e       	subi	r16, 0xEF	; 239
    168e:	1f 4f       	sbci	r17, 0xFF	; 255
    1690:	03 c0       	rjmp	.+6      	; 0x1698 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1692:	89 89       	ldd	r24, Y+17	; 0x11
    1694:	88 23       	and	r24, r24
    1696:	51 f0       	breq	.+20     	; 0x16ac <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1698:	c8 01       	movw	r24, r16
    169a:	27 d7       	rcall	.+3662   	; 0x24ea <xTaskRemoveFromEventList>
    169c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    169e:	b0 d7       	rcall	.+3936   	; 0x2600 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    16a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16a2:	81 50       	subi	r24, 0x01	; 1
    16a4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16a6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16a8:	18 16       	cp	r1, r24
    16aa:	9c f3       	brlt	.-26     	; 0x1692 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    16ac:	8f ef       	ldi	r24, 0xFF	; 255
    16ae:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    16b0:	0f 90       	pop	r0
    16b2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    16b4:	0f b6       	in	r0, 0x3f	; 63
    16b6:	f8 94       	cli
    16b8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16ba:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16bc:	18 16       	cp	r1, r24
    16be:	a4 f4       	brge	.+40     	; 0x16e8 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16c0:	88 85       	ldd	r24, Y+8	; 0x08
    16c2:	88 23       	and	r24, r24
    16c4:	89 f0       	breq	.+34     	; 0x16e8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16c6:	8e 01       	movw	r16, r28
    16c8:	08 5f       	subi	r16, 0xF8	; 248
    16ca:	1f 4f       	sbci	r17, 0xFF	; 255
    16cc:	03 c0       	rjmp	.+6      	; 0x16d4 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16ce:	88 85       	ldd	r24, Y+8	; 0x08
    16d0:	88 23       	and	r24, r24
    16d2:	51 f0       	breq	.+20     	; 0x16e8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16d4:	c8 01       	movw	r24, r16
    16d6:	09 d7       	rcall	.+3602   	; 0x24ea <xTaskRemoveFromEventList>
    16d8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    16da:	92 d7       	rcall	.+3876   	; 0x2600 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    16dc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16de:	81 50       	subi	r24, 0x01	; 1
    16e0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16e2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16e4:	18 16       	cp	r1, r24
    16e6:	9c f3       	brlt	.-26     	; 0x16ce <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    16e8:	8f ef       	ldi	r24, 0xFF	; 255
    16ea:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    16ec:	0f 90       	pop	r0
    16ee:	0f be       	out	0x3f, r0	; 63
}
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	1f 91       	pop	r17
    16f6:	0f 91       	pop	r16
    16f8:	08 95       	ret

000016fa <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    16fa:	cf 93       	push	r28
    16fc:	df 93       	push	r29
    16fe:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1700:	0f b6       	in	r0, 0x3f	; 63
    1702:	f8 94       	cli
    1704:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1706:	88 81       	ld	r24, Y
    1708:	99 81       	ldd	r25, Y+1	; 0x01
    170a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    170c:	30 e0       	ldi	r19, 0x00	; 0
    170e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1710:	72 9f       	mul	r23, r18
    1712:	a0 01       	movw	r20, r0
    1714:	73 9f       	mul	r23, r19
    1716:	50 0d       	add	r21, r0
    1718:	11 24       	eor	r1, r1
    171a:	fc 01       	movw	r30, r24
    171c:	e4 0f       	add	r30, r20
    171e:	f5 1f       	adc	r31, r21
    1720:	fb 83       	std	Y+3, r31	; 0x03
    1722:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1724:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1726:	9d 83       	std	Y+5, r25	; 0x05
    1728:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    172a:	42 1b       	sub	r20, r18
    172c:	53 0b       	sbc	r21, r19
    172e:	84 0f       	add	r24, r20
    1730:	95 1f       	adc	r25, r21
    1732:	9f 83       	std	Y+7, r25	; 0x07
    1734:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1736:	8f ef       	ldi	r24, 0xFF	; 255
    1738:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    173a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    173c:	61 11       	cpse	r22, r1
    173e:	0a c0       	rjmp	.+20     	; 0x1754 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1740:	88 85       	ldd	r24, Y+8	; 0x08
    1742:	88 23       	and	r24, r24
    1744:	79 f0       	breq	.+30     	; 0x1764 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1746:	ce 01       	movw	r24, r28
    1748:	08 96       	adiw	r24, 0x08	; 8
    174a:	cf d6       	rcall	.+3486   	; 0x24ea <xTaskRemoveFromEventList>
    174c:	81 30       	cpi	r24, 0x01	; 1
    174e:	51 f4       	brne	.+20     	; 0x1764 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1750:	4e de       	rcall	.-868    	; 0x13ee <vPortYield>
    1752:	08 c0       	rjmp	.+16     	; 0x1764 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1754:	ce 01       	movw	r24, r28
    1756:	08 96       	adiw	r24, 0x08	; 8
    1758:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    175c:	ce 01       	movw	r24, r28
    175e:	41 96       	adiw	r24, 0x11	; 17
    1760:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1764:	0f 90       	pop	r0
    1766:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1768:	81 e0       	ldi	r24, 0x01	; 1
    176a:	df 91       	pop	r29
    176c:	cf 91       	pop	r28
    176e:	08 95       	ret

00001770 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1770:	0f 93       	push	r16
    1772:	1f 93       	push	r17
    1774:	cf 93       	push	r28
    1776:	df 93       	push	r29
    1778:	18 2f       	mov	r17, r24
    177a:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    177c:	88 23       	and	r24, r24
    177e:	e9 f0       	breq	.+58     	; 0x17ba <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1780:	8f e1       	ldi	r24, 0x1F	; 31
    1782:	90 e0       	ldi	r25, 0x00	; 0
    1784:	0e 94 09 03 	call	0x612	; 0x612 <pvPortMalloc>
    1788:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    178a:	00 97       	sbiw	r24, 0x00	; 0
    178c:	c1 f0       	breq	.+48     	; 0x17be <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    178e:	10 9f       	mul	r17, r16
    1790:	c0 01       	movw	r24, r0
    1792:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1794:	01 96       	adiw	r24, 0x01	; 1
    1796:	0e 94 09 03 	call	0x612	; 0x612 <pvPortMalloc>
    179a:	99 83       	std	Y+1, r25	; 0x01
    179c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    179e:	89 2b       	or	r24, r25
    17a0:	31 f0       	breq	.+12     	; 0x17ae <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    17a2:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    17a4:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    17a6:	61 e0       	ldi	r22, 0x01	; 1
    17a8:	ce 01       	movw	r24, r28
    17aa:	a7 df       	rcall	.-178    	; 0x16fa <xQueueGenericReset>
    17ac:	08 c0       	rjmp	.+16     	; 0x17be <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    17ae:	ce 01       	movw	r24, r28
    17b0:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    17b4:	c0 e0       	ldi	r28, 0x00	; 0
    17b6:	d0 e0       	ldi	r29, 0x00	; 0
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <xQueueGenericCreate+0x4e>
    17ba:	c0 e0       	ldi	r28, 0x00	; 0
    17bc:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    17be:	ce 01       	movw	r24, r28
    17c0:	df 91       	pop	r29
    17c2:	cf 91       	pop	r28
    17c4:	1f 91       	pop	r17
    17c6:	0f 91       	pop	r16
    17c8:	08 95       	ret

000017ca <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    17ca:	9f 92       	push	r9
    17cc:	af 92       	push	r10
    17ce:	bf 92       	push	r11
    17d0:	cf 92       	push	r12
    17d2:	df 92       	push	r13
    17d4:	ef 92       	push	r14
    17d6:	ff 92       	push	r15
    17d8:	0f 93       	push	r16
    17da:	1f 93       	push	r17
    17dc:	cf 93       	push	r28
    17de:	df 93       	push	r29
    17e0:	00 d0       	rcall	.+0      	; 0x17e2 <xQueueGenericSend+0x18>
    17e2:	1f 92       	push	r1
    17e4:	1f 92       	push	r1
    17e6:	cd b7       	in	r28, 0x3d	; 61
    17e8:	de b7       	in	r29, 0x3e	; 62
    17ea:	8c 01       	movw	r16, r24
    17ec:	6b 01       	movw	r12, r22
    17ee:	5d 83       	std	Y+5, r21	; 0x05
    17f0:	4c 83       	std	Y+4, r20	; 0x04
    17f2:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    17f4:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17f6:	99 24       	eor	r9, r9
    17f8:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17fa:	7c 01       	movw	r14, r24
    17fc:	88 e0       	ldi	r24, 0x08	; 8
    17fe:	e8 0e       	add	r14, r24
    1800:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1808:	f8 01       	movw	r30, r16
    180a:	92 8d       	ldd	r25, Z+26	; 0x1a
    180c:	83 8d       	ldd	r24, Z+27	; 0x1b
    180e:	98 17       	cp	r25, r24
    1810:	18 f0       	brcs	.+6      	; 0x1818 <xQueueGenericSend+0x4e>
    1812:	f2 e0       	ldi	r31, 0x02	; 2
    1814:	af 12       	cpse	r10, r31
    1816:	15 c0       	rjmp	.+42     	; 0x1842 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1818:	4a 2d       	mov	r20, r10
    181a:	b6 01       	movw	r22, r12
    181c:	c8 01       	movw	r24, r16
    181e:	ab de       	rcall	.-682    	; 0x1576 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1820:	f8 01       	movw	r30, r16
    1822:	91 89       	ldd	r25, Z+17	; 0x11
    1824:	99 23       	and	r25, r25
    1826:	39 f0       	breq	.+14     	; 0x1836 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1828:	c8 01       	movw	r24, r16
    182a:	41 96       	adiw	r24, 0x11	; 17
    182c:	5e d6       	rcall	.+3260   	; 0x24ea <xTaskRemoveFromEventList>
    182e:	81 30       	cpi	r24, 0x01	; 1
    1830:	21 f4       	brne	.+8      	; 0x183a <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1832:	dd dd       	rcall	.-1094   	; 0x13ee <vPortYield>
    1834:	02 c0       	rjmp	.+4      	; 0x183a <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1836:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1838:	da dd       	rcall	.-1100   	; 0x13ee <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    183a:	0f 90       	pop	r0
    183c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	46 c0       	rjmp	.+140    	; 0x18ce <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1842:	ec 81       	ldd	r30, Y+4	; 0x04
    1844:	fd 81       	ldd	r31, Y+5	; 0x05
    1846:	ef 2b       	or	r30, r31
    1848:	21 f4       	brne	.+8      	; 0x1852 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    184a:	0f 90       	pop	r0
    184c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    184e:	80 e0       	ldi	r24, 0x00	; 0
    1850:	3e c0       	rjmp	.+124    	; 0x18ce <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1852:	b1 10       	cpse	r11, r1
    1854:	04 c0       	rjmp	.+8      	; 0x185e <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1856:	ce 01       	movw	r24, r28
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	8f d6       	rcall	.+3358   	; 0x257a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    185c:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1862:	86 d3       	rcall	.+1804   	; 0x1f70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1864:	0f b6       	in	r0, 0x3f	; 63
    1866:	f8 94       	cli
    1868:	0f 92       	push	r0
    186a:	f8 01       	movw	r30, r16
    186c:	85 8d       	ldd	r24, Z+29	; 0x1d
    186e:	8f 3f       	cpi	r24, 0xFF	; 255
    1870:	09 f4       	brne	.+2      	; 0x1874 <xQueueGenericSend+0xaa>
    1872:	15 8e       	std	Z+29, r1	; 0x1d
    1874:	f8 01       	movw	r30, r16
    1876:	86 8d       	ldd	r24, Z+30	; 0x1e
    1878:	8f 3f       	cpi	r24, 0xFF	; 255
    187a:	09 f4       	brne	.+2      	; 0x187e <xQueueGenericSend+0xb4>
    187c:	16 8e       	std	Z+30, r1	; 0x1e
    187e:	0f 90       	pop	r0
    1880:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1882:	be 01       	movw	r22, r28
    1884:	6c 5f       	subi	r22, 0xFC	; 252
    1886:	7f 4f       	sbci	r23, 0xFF	; 255
    1888:	ce 01       	movw	r24, r28
    188a:	01 96       	adiw	r24, 0x01	; 1
    188c:	81 d6       	rcall	.+3330   	; 0x2590 <xTaskCheckForTimeOut>
    188e:	81 11       	cpse	r24, r1
    1890:	1a c0       	rjmp	.+52     	; 0x18c6 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1898:	f8 01       	movw	r30, r16
    189a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    189c:	0f 90       	pop	r0
    189e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18a0:	f8 01       	movw	r30, r16
    18a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    18a4:	98 13       	cpse	r25, r24
    18a6:	0b c0       	rjmp	.+22     	; 0x18be <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18a8:	6c 81       	ldd	r22, Y+4	; 0x04
    18aa:	7d 81       	ldd	r23, Y+5	; 0x05
    18ac:	c7 01       	movw	r24, r14
    18ae:	f2 d5       	rcall	.+3044   	; 0x2494 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    18b0:	c8 01       	movw	r24, r16
    18b2:	dd de       	rcall	.-582    	; 0x166e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    18b4:	30 d4       	rcall	.+2144   	; 0x2116 <xTaskResumeAll>
    18b6:	81 11       	cpse	r24, r1
    18b8:	a4 cf       	rjmp	.-184    	; 0x1802 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    18ba:	99 dd       	rcall	.-1230   	; 0x13ee <vPortYield>
    18bc:	a2 cf       	rjmp	.-188    	; 0x1802 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18be:	c8 01       	movw	r24, r16
    18c0:	d6 de       	rcall	.-596    	; 0x166e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18c2:	29 d4       	rcall	.+2130   	; 0x2116 <xTaskResumeAll>
    18c4:	9e cf       	rjmp	.-196    	; 0x1802 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18c6:	c8 01       	movw	r24, r16
    18c8:	d2 de       	rcall	.-604    	; 0x166e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18ca:	25 d4       	rcall	.+2122   	; 0x2116 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18cc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    18ce:	0f 90       	pop	r0
    18d0:	0f 90       	pop	r0
    18d2:	0f 90       	pop	r0
    18d4:	0f 90       	pop	r0
    18d6:	0f 90       	pop	r0
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	1f 91       	pop	r17
    18de:	0f 91       	pop	r16
    18e0:	ff 90       	pop	r15
    18e2:	ef 90       	pop	r14
    18e4:	df 90       	pop	r13
    18e6:	cf 90       	pop	r12
    18e8:	bf 90       	pop	r11
    18ea:	af 90       	pop	r10
    18ec:	9f 90       	pop	r9
    18ee:	08 95       	ret

000018f0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    18f0:	cf 93       	push	r28
    18f2:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    18f4:	8f e1       	ldi	r24, 0x1F	; 31
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	0e 94 09 03 	call	0x612	; 0x612 <pvPortMalloc>
    18fc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18fe:	00 97       	sbiw	r24, 0x00	; 0
    1900:	f1 f0       	breq	.+60     	; 0x193e <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1902:	1b 82       	std	Y+3, r1	; 0x03
    1904:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1906:	19 82       	std	Y+1, r1	; 0x01
    1908:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    190a:	1d 82       	std	Y+5, r1	; 0x05
    190c:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    190e:	1f 82       	std	Y+7, r1	; 0x07
    1910:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1912:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1914:	81 e0       	ldi	r24, 0x01	; 1
    1916:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1918:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    191a:	8f ef       	ldi	r24, 0xFF	; 255
    191c:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    191e:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1920:	ce 01       	movw	r24, r28
    1922:	08 96       	adiw	r24, 0x08	; 8
    1924:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1928:	ce 01       	movw	r24, r28
    192a:	41 96       	adiw	r24, 0x11	; 17
    192c:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1930:	20 e0       	ldi	r18, 0x00	; 0
    1932:	40 e0       	ldi	r20, 0x00	; 0
    1934:	50 e0       	ldi	r21, 0x00	; 0
    1936:	60 e0       	ldi	r22, 0x00	; 0
    1938:	70 e0       	ldi	r23, 0x00	; 0
    193a:	ce 01       	movw	r24, r28
    193c:	46 df       	rcall	.-372    	; 0x17ca <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    193e:	ce 01       	movw	r24, r28
    1940:	df 91       	pop	r29
    1942:	cf 91       	pop	r28
    1944:	08 95       	ret

00001946 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1946:	0f 93       	push	r16
    1948:	1f 93       	push	r17
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	ec 01       	movw	r28, r24
    1950:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1952:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1954:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1956:	98 17       	cp	r25, r24
    1958:	10 f0       	brcs	.+4      	; 0x195e <xQueueGenericSendFromISR+0x18>
    195a:	22 30       	cpi	r18, 0x02	; 2
    195c:	11 f5       	brne	.+68     	; 0x19a2 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    195e:	42 2f       	mov	r20, r18
    1960:	ce 01       	movw	r24, r28
    1962:	09 de       	rcall	.-1006   	; 0x1576 <prvCopyDataToQueue>
    1964:	88 23       	and	r24, r24
    1966:	31 f0       	breq	.+12     	; 0x1974 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1968:	01 15       	cp	r16, r1
    196a:	11 05       	cpc	r17, r1
    196c:	19 f0       	breq	.+6      	; 0x1974 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    196e:	81 e0       	ldi	r24, 0x01	; 1
    1970:	f8 01       	movw	r30, r16
    1972:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1974:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1976:	8f 3f       	cpi	r24, 0xFF	; 255
    1978:	79 f4       	brne	.+30     	; 0x1998 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    197a:	89 89       	ldd	r24, Y+17	; 0x11
    197c:	88 23       	and	r24, r24
    197e:	99 f0       	breq	.+38     	; 0x19a6 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1980:	ce 01       	movw	r24, r28
    1982:	41 96       	adiw	r24, 0x11	; 17
    1984:	b2 d5       	rcall	.+2916   	; 0x24ea <xTaskRemoveFromEventList>
    1986:	88 23       	and	r24, r24
    1988:	81 f0       	breq	.+32     	; 0x19aa <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    198a:	01 15       	cp	r16, r1
    198c:	11 05       	cpc	r17, r1
    198e:	79 f0       	breq	.+30     	; 0x19ae <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	f8 01       	movw	r30, r16
    1994:	80 83       	st	Z, r24
    1996:	0c c0       	rjmp	.+24     	; 0x19b0 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1998:	8e 8d       	ldd	r24, Y+30	; 0x1e
    199a:	8f 5f       	subi	r24, 0xFF	; 255
    199c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	07 c0       	rjmp	.+14     	; 0x19b0 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19a2:	80 e0       	ldi	r24, 0x00	; 0
    19a4:	05 c0       	rjmp	.+10     	; 0x19b0 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    19a6:	81 e0       	ldi	r24, 0x01	; 1
    19a8:	03 c0       	rjmp	.+6      	; 0x19b0 <xQueueGenericSendFromISR+0x6a>
    19aa:	81 e0       	ldi	r24, 0x01	; 1
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <xQueueGenericSendFromISR+0x6a>
    19ae:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19b0:	df 91       	pop	r29
    19b2:	cf 91       	pop	r28
    19b4:	1f 91       	pop	r17
    19b6:	0f 91       	pop	r16
    19b8:	08 95       	ret

000019ba <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    19ba:	9f 92       	push	r9
    19bc:	af 92       	push	r10
    19be:	bf 92       	push	r11
    19c0:	cf 92       	push	r12
    19c2:	df 92       	push	r13
    19c4:	ef 92       	push	r14
    19c6:	ff 92       	push	r15
    19c8:	0f 93       	push	r16
    19ca:	1f 93       	push	r17
    19cc:	cf 93       	push	r28
    19ce:	df 93       	push	r29
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <xQueueGenericReceive+0x18>
    19d2:	1f 92       	push	r1
    19d4:	1f 92       	push	r1
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	8c 01       	movw	r16, r24
    19dc:	6b 01       	movw	r12, r22
    19de:	5d 83       	std	Y+5, r21	; 0x05
    19e0:	4c 83       	std	Y+4, r20	; 0x04
    19e2:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    19e4:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    19e6:	99 24       	eor	r9, r9
    19e8:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19ea:	7c 01       	movw	r14, r24
    19ec:	81 e1       	ldi	r24, 0x11	; 17
    19ee:	e8 0e       	add	r14, r24
    19f0:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19f8:	f8 01       	movw	r30, r16
    19fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    19fc:	88 23       	and	r24, r24
    19fe:	69 f1       	breq	.+90     	; 0x1a5a <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a00:	e6 80       	ldd	r14, Z+6	; 0x06
    1a02:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a04:	b6 01       	movw	r22, r12
    1a06:	c8 01       	movw	r24, r16
    1a08:	18 de       	rcall	.-976    	; 0x163a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a0a:	b1 10       	cpse	r11, r1
    1a0c:	17 c0       	rjmp	.+46     	; 0x1a3c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a0e:	f8 01       	movw	r30, r16
    1a10:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a12:	81 50       	subi	r24, 0x01	; 1
    1a14:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a16:	80 81       	ld	r24, Z
    1a18:	91 81       	ldd	r25, Z+1	; 0x01
    1a1a:	89 2b       	or	r24, r25
    1a1c:	21 f4       	brne	.+8      	; 0x1a26 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1a1e:	91 d6       	rcall	.+3362   	; 0x2742 <pvTaskIncrementMutexHeldCount>
    1a20:	f8 01       	movw	r30, r16
    1a22:	93 83       	std	Z+3, r25	; 0x03
    1a24:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a26:	f8 01       	movw	r30, r16
    1a28:	80 85       	ldd	r24, Z+8	; 0x08
    1a2a:	88 23       	and	r24, r24
    1a2c:	91 f0       	breq	.+36     	; 0x1a52 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a2e:	c8 01       	movw	r24, r16
    1a30:	08 96       	adiw	r24, 0x08	; 8
    1a32:	5b d5       	rcall	.+2742   	; 0x24ea <xTaskRemoveFromEventList>
    1a34:	81 30       	cpi	r24, 0x01	; 1
    1a36:	69 f4       	brne	.+26     	; 0x1a52 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1a38:	da dc       	rcall	.-1612   	; 0x13ee <vPortYield>
    1a3a:	0b c0       	rjmp	.+22     	; 0x1a52 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	f7 82       	std	Z+7, r15	; 0x07
    1a40:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a42:	81 89       	ldd	r24, Z+17	; 0x11
    1a44:	88 23       	and	r24, r24
    1a46:	29 f0       	breq	.+10     	; 0x1a52 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a48:	c8 01       	movw	r24, r16
    1a4a:	41 96       	adiw	r24, 0x11	; 17
    1a4c:	4e d5       	rcall	.+2716   	; 0x24ea <xTaskRemoveFromEventList>
    1a4e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1a50:	ce dc       	rcall	.-1636   	; 0x13ee <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1a52:	0f 90       	pop	r0
    1a54:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	52 c0       	rjmp	.+164    	; 0x1afe <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a5a:	4c 81       	ldd	r20, Y+4	; 0x04
    1a5c:	5d 81       	ldd	r21, Y+5	; 0x05
    1a5e:	45 2b       	or	r20, r21
    1a60:	21 f4       	brne	.+8      	; 0x1a6a <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a66:	80 e0       	ldi	r24, 0x00	; 0
    1a68:	4a c0       	rjmp	.+148    	; 0x1afe <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a6a:	a1 10       	cpse	r10, r1
    1a6c:	04 c0       	rjmp	.+8      	; 0x1a76 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a6e:	ce 01       	movw	r24, r28
    1a70:	01 96       	adiw	r24, 0x01	; 1
    1a72:	83 d5       	rcall	.+2822   	; 0x257a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a74:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a7a:	7a d2       	rcall	.+1268   	; 0x1f70 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a7c:	0f b6       	in	r0, 0x3f	; 63
    1a7e:	f8 94       	cli
    1a80:	0f 92       	push	r0
    1a82:	f8 01       	movw	r30, r16
    1a84:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a86:	8f 3f       	cpi	r24, 0xFF	; 255
    1a88:	09 f4       	brne	.+2      	; 0x1a8c <xQueueGenericReceive+0xd2>
    1a8a:	15 8e       	std	Z+29, r1	; 0x1d
    1a8c:	f8 01       	movw	r30, r16
    1a8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a90:	8f 3f       	cpi	r24, 0xFF	; 255
    1a92:	09 f4       	brne	.+2      	; 0x1a96 <xQueueGenericReceive+0xdc>
    1a94:	16 8e       	std	Z+30, r1	; 0x1e
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a9a:	be 01       	movw	r22, r28
    1a9c:	6c 5f       	subi	r22, 0xFC	; 252
    1a9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa0:	ce 01       	movw	r24, r28
    1aa2:	01 96       	adiw	r24, 0x01	; 1
    1aa4:	75 d5       	rcall	.+2794   	; 0x2590 <xTaskCheckForTimeOut>
    1aa6:	81 11       	cpse	r24, r1
    1aa8:	26 c0       	rjmp	.+76     	; 0x1af6 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1aaa:	0f b6       	in	r0, 0x3f	; 63
    1aac:	f8 94       	cli
    1aae:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ab0:	f8 01       	movw	r30, r16
    1ab2:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ab4:	0f 90       	pop	r0
    1ab6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ab8:	81 11       	cpse	r24, r1
    1aba:	19 c0       	rjmp	.+50     	; 0x1aee <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1abc:	f8 01       	movw	r30, r16
    1abe:	80 81       	ld	r24, Z
    1ac0:	91 81       	ldd	r25, Z+1	; 0x01
    1ac2:	89 2b       	or	r24, r25
    1ac4:	49 f4       	brne	.+18     	; 0x1ad8 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1acc:	f8 01       	movw	r30, r16
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	9a d5       	rcall	.+2868   	; 0x2608 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ad8:	6c 81       	ldd	r22, Y+4	; 0x04
    1ada:	7d 81       	ldd	r23, Y+5	; 0x05
    1adc:	c7 01       	movw	r24, r14
    1ade:	da d4       	rcall	.+2484   	; 0x2494 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ae0:	c8 01       	movw	r24, r16
    1ae2:	c5 dd       	rcall	.-1142   	; 0x166e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ae4:	18 d3       	rcall	.+1584   	; 0x2116 <xTaskResumeAll>
    1ae6:	81 11       	cpse	r24, r1
    1ae8:	84 cf       	rjmp	.-248    	; 0x19f2 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1aea:	81 dc       	rcall	.-1790   	; 0x13ee <vPortYield>
    1aec:	82 cf       	rjmp	.-252    	; 0x19f2 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1aee:	c8 01       	movw	r24, r16
    1af0:	be dd       	rcall	.-1156   	; 0x166e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1af2:	11 d3       	rcall	.+1570   	; 0x2116 <xTaskResumeAll>
    1af4:	7e cf       	rjmp	.-260    	; 0x19f2 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1af6:	c8 01       	movw	r24, r16
    1af8:	ba dd       	rcall	.-1164   	; 0x166e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1afa:	0d d3       	rcall	.+1562   	; 0x2116 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1afc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1afe:	0f 90       	pop	r0
    1b00:	0f 90       	pop	r0
    1b02:	0f 90       	pop	r0
    1b04:	0f 90       	pop	r0
    1b06:	0f 90       	pop	r0
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	1f 91       	pop	r17
    1b0e:	0f 91       	pop	r16
    1b10:	ff 90       	pop	r15
    1b12:	ef 90       	pop	r14
    1b14:	df 90       	pop	r13
    1b16:	cf 90       	pop	r12
    1b18:	bf 90       	pop	r11
    1b1a:	af 90       	pop	r10
    1b1c:	9f 90       	pop	r9
    1b1e:	08 95       	ret

00001b20 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1b20:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1b22:	71 83       	std	Z+1, r23	; 0x01
    1b24:	60 83       	st	Z, r22
	ring->rSize = size;
    1b26:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1b28:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1b2a:	13 82       	std	Z+3, r1	; 0x03
    1b2c:	08 95       	ret

00001b2e <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1b2e:	dc 01       	movw	r26, r24
    1b30:	14 96       	adiw	r26, 0x04	; 4
    1b32:	2c 91       	ld	r18, X
    1b34:	14 97       	sbiw	r26, 0x04	; 4
    1b36:	ed 91       	ld	r30, X+
    1b38:	fc 91       	ld	r31, X
    1b3a:	e2 0f       	add	r30, r18
    1b3c:	f1 1d       	adc	r31, r1
}
    1b3e:	80 81       	ld	r24, Z
    1b40:	08 95       	ret

00001b42 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1b42:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1b44:	94 81       	ldd	r25, Z+4	; 0x04
    1b46:	a0 81       	ld	r26, Z
    1b48:	b1 81       	ldd	r27, Z+1	; 0x01
    1b4a:	a9 0f       	add	r26, r25
    1b4c:	b1 1d       	adc	r27, r1
    1b4e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1b50:	9f 5f       	subi	r25, 0xFF	; 255
    1b52:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1b54:	22 81       	ldd	r18, Z+2	; 0x02
    1b56:	92 17       	cp	r25, r18
    1b58:	10 f0       	brcs	.+4      	; 0x1b5e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1b5a:	92 1b       	sub	r25, r18
    1b5c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1b5e:	93 81       	ldd	r25, Z+3	; 0x03
    1b60:	91 50       	subi	r25, 0x01	; 1
    1b62:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1b64:	08 95       	ret

00001b66 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1b66:	fc 01       	movw	r30, r24
    1b68:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1b6a:	83 81       	ldd	r24, Z+3	; 0x03
    1b6c:	22 81       	ldd	r18, Z+2	; 0x02
    1b6e:	82 17       	cp	r24, r18
    1b70:	80 f4       	brcc	.+32     	; 0x1b92 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1b72:	34 81       	ldd	r19, Z+4	; 0x04
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	83 0f       	add	r24, r19
    1b78:	91 1d       	adc	r25, r1
    1b7a:	62 2f       	mov	r22, r18
    1b7c:	70 e0       	ldi	r23, 0x00	; 0
    1b7e:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <__divmodhi4>
    1b82:	a0 81       	ld	r26, Z
    1b84:	b1 81       	ldd	r27, Z+1	; 0x01
    1b86:	a8 0f       	add	r26, r24
    1b88:	b9 1f       	adc	r27, r25
    1b8a:	4c 93       	st	X, r20
            ring->rLength++;
    1b8c:	83 81       	ldd	r24, Z+3	; 0x03
    1b8e:	8f 5f       	subi	r24, 0xFF	; 255
    1b90:	83 83       	std	Z+3, r24	; 0x03
    1b92:	08 95       	ret

00001b94 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1b94:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	22 81       	ldd	r18, Z+2	; 0x02
    1b9a:	93 81       	ldd	r25, Z+3	; 0x03
    1b9c:	29 13       	cpse	r18, r25
    1b9e:	80 e0       	ldi	r24, 0x00	; 0
}
    1ba0:	08 95       	ret

00001ba2 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1ba2:	21 e0       	ldi	r18, 0x01	; 1
    1ba4:	fc 01       	movw	r30, r24
    1ba6:	83 81       	ldd	r24, Z+3	; 0x03
    1ba8:	81 11       	cpse	r24, r1
    1baa:	01 c0       	rjmp	.+2      	; 0x1bae <ringBufferNotEmpty+0xc>
    1bac:	20 e0       	ldi	r18, 0x00	; 0
}
    1bae:	82 2f       	mov	r24, r18
    1bb0:	08 95       	ret

00001bb2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1bb2:	e0 91 4c 08 	lds	r30, 0x084C
    1bb6:	f0 91 4d 08 	lds	r31, 0x084D
    1bba:	80 81       	ld	r24, Z
    1bbc:	81 11       	cpse	r24, r1
    1bbe:	07 c0       	rjmp	.+14     	; 0x1bce <prvResetNextTaskUnblockTime+0x1c>
    1bc0:	8f ef       	ldi	r24, 0xFF	; 255
    1bc2:	9f ef       	ldi	r25, 0xFF	; 255
    1bc4:	90 93 05 02 	sts	0x0205, r25
    1bc8:	80 93 04 02 	sts	0x0204, r24
    1bcc:	08 95       	ret
    1bce:	e0 91 4c 08 	lds	r30, 0x084C
    1bd2:	f0 91 4d 08 	lds	r31, 0x084D
    1bd6:	05 80       	ldd	r0, Z+5	; 0x05
    1bd8:	f6 81       	ldd	r31, Z+6	; 0x06
    1bda:	e0 2d       	mov	r30, r0
    1bdc:	06 80       	ldd	r0, Z+6	; 0x06
    1bde:	f7 81       	ldd	r31, Z+7	; 0x07
    1be0:	e0 2d       	mov	r30, r0
    1be2:	82 81       	ldd	r24, Z+2	; 0x02
    1be4:	93 81       	ldd	r25, Z+3	; 0x03
    1be6:	90 93 05 02 	sts	0x0205, r25
    1bea:	80 93 04 02 	sts	0x0204, r24
    1bee:	08 95       	ret

00001bf0 <prvAddCurrentTaskToDelayedList>:
    1bf0:	cf 93       	push	r28
    1bf2:	df 93       	push	r29
    1bf4:	ec 01       	movw	r28, r24
    1bf6:	e0 91 8d 08 	lds	r30, 0x088D
    1bfa:	f0 91 8e 08 	lds	r31, 0x088E
    1bfe:	93 83       	std	Z+3, r25	; 0x03
    1c00:	82 83       	std	Z+2, r24	; 0x02
    1c02:	80 91 2b 08 	lds	r24, 0x082B
    1c06:	90 91 2c 08 	lds	r25, 0x082C
    1c0a:	c8 17       	cp	r28, r24
    1c0c:	d9 07       	cpc	r29, r25
    1c0e:	68 f4       	brcc	.+26     	; 0x1c2a <prvAddCurrentTaskToDelayedList+0x3a>
    1c10:	60 91 8d 08 	lds	r22, 0x088D
    1c14:	70 91 8e 08 	lds	r23, 0x088E
    1c18:	80 91 4a 08 	lds	r24, 0x084A
    1c1c:	90 91 4b 08 	lds	r25, 0x084B
    1c20:	6e 5f       	subi	r22, 0xFE	; 254
    1c22:	7f 4f       	sbci	r23, 0xFF	; 255
    1c24:	0e 94 72 03 	call	0x6e4	; 0x6e4 <vListInsert>
    1c28:	17 c0       	rjmp	.+46     	; 0x1c58 <prvAddCurrentTaskToDelayedList+0x68>
    1c2a:	60 91 8d 08 	lds	r22, 0x088D
    1c2e:	70 91 8e 08 	lds	r23, 0x088E
    1c32:	80 91 4c 08 	lds	r24, 0x084C
    1c36:	90 91 4d 08 	lds	r25, 0x084D
    1c3a:	6e 5f       	subi	r22, 0xFE	; 254
    1c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3e:	0e 94 72 03 	call	0x6e4	; 0x6e4 <vListInsert>
    1c42:	80 91 04 02 	lds	r24, 0x0204
    1c46:	90 91 05 02 	lds	r25, 0x0205
    1c4a:	c8 17       	cp	r28, r24
    1c4c:	d9 07       	cpc	r29, r25
    1c4e:	20 f4       	brcc	.+8      	; 0x1c58 <prvAddCurrentTaskToDelayedList+0x68>
    1c50:	d0 93 05 02 	sts	0x0205, r29
    1c54:	c0 93 04 02 	sts	0x0204, r28
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	08 95       	ret

00001c5e <xTaskGenericCreate>:
    1c5e:	4f 92       	push	r4
    1c60:	5f 92       	push	r5
    1c62:	6f 92       	push	r6
    1c64:	7f 92       	push	r7
    1c66:	8f 92       	push	r8
    1c68:	9f 92       	push	r9
    1c6a:	af 92       	push	r10
    1c6c:	bf 92       	push	r11
    1c6e:	cf 92       	push	r12
    1c70:	df 92       	push	r13
    1c72:	ef 92       	push	r14
    1c74:	ff 92       	push	r15
    1c76:	0f 93       	push	r16
    1c78:	1f 93       	push	r17
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	4c 01       	movw	r8, r24
    1c80:	5b 01       	movw	r10, r22
    1c82:	2a 01       	movw	r4, r20
    1c84:	39 01       	movw	r6, r18
    1c86:	83 e2       	ldi	r24, 0x23	; 35
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	0e 94 09 03 	call	0x612	; 0x612 <pvPortMalloc>
    1c8e:	ec 01       	movw	r28, r24
    1c90:	00 97       	sbiw	r24, 0x00	; 0
    1c92:	09 f4       	brne	.+2      	; 0x1c96 <xTaskGenericCreate+0x38>
    1c94:	e7 c0       	rjmp	.+462    	; 0x1e64 <xTaskGenericCreate+0x206>
    1c96:	c1 14       	cp	r12, r1
    1c98:	d1 04       	cpc	r13, r1
    1c9a:	09 f0       	breq	.+2      	; 0x1c9e <xTaskGenericCreate+0x40>
    1c9c:	cc c0       	rjmp	.+408    	; 0x1e36 <xTaskGenericCreate+0x1d8>
    1c9e:	c2 01       	movw	r24, r4
    1ca0:	0e 94 09 03 	call	0x612	; 0x612 <pvPortMalloc>
    1ca4:	98 8f       	std	Y+24, r25	; 0x18
    1ca6:	8f 8b       	std	Y+23, r24	; 0x17
    1ca8:	89 2b       	or	r24, r25
    1caa:	09 f0       	breq	.+2      	; 0x1cae <xTaskGenericCreate+0x50>
    1cac:	c6 c0       	rjmp	.+396    	; 0x1e3a <xTaskGenericCreate+0x1dc>
    1cae:	ce 01       	movw	r24, r28
    1cb0:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortFree>
    1cb4:	d7 c0       	rjmp	.+430    	; 0x1e64 <xTaskGenericCreate+0x206>
    1cb6:	cf 01       	movw	r24, r30
    1cb8:	31 91       	ld	r19, Z+
    1cba:	da 01       	movw	r26, r20
    1cbc:	3d 93       	st	X+, r19
    1cbe:	ad 01       	movw	r20, r26
    1cc0:	dc 01       	movw	r26, r24
    1cc2:	8c 91       	ld	r24, X
    1cc4:	88 23       	and	r24, r24
    1cc6:	11 f0       	breq	.+4      	; 0x1ccc <xTaskGenericCreate+0x6e>
    1cc8:	21 50       	subi	r18, 0x01	; 1
    1cca:	a9 f7       	brne	.-22     	; 0x1cb6 <xTaskGenericCreate+0x58>
    1ccc:	18 a2       	std	Y+32, r1	; 0x20
    1cce:	10 2f       	mov	r17, r16
    1cd0:	05 30       	cpi	r16, 0x05	; 5
    1cd2:	08 f0       	brcs	.+2      	; 0x1cd6 <xTaskGenericCreate+0x78>
    1cd4:	14 e0       	ldi	r17, 0x04	; 4
    1cd6:	1e 8b       	std	Y+22, r17	; 0x16
    1cd8:	19 a3       	std	Y+33, r17	; 0x21
    1cda:	1a a2       	std	Y+34, r1	; 0x22
    1cdc:	5e 01       	movw	r10, r28
    1cde:	b2 e0       	ldi	r27, 0x02	; 2
    1ce0:	ab 0e       	add	r10, r27
    1ce2:	b1 1c       	adc	r11, r1
    1ce4:	c5 01       	movw	r24, r10
    1ce6:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialiseItem>
    1cea:	ce 01       	movw	r24, r28
    1cec:	0c 96       	adiw	r24, 0x0c	; 12
    1cee:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialiseItem>
    1cf2:	d9 87       	std	Y+9, r29	; 0x09
    1cf4:	c8 87       	std	Y+8, r28	; 0x08
    1cf6:	85 e0       	ldi	r24, 0x05	; 5
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	81 1b       	sub	r24, r17
    1cfc:	91 09       	sbc	r25, r1
    1cfe:	9d 87       	std	Y+13, r25	; 0x0d
    1d00:	8c 87       	std	Y+12, r24	; 0x0c
    1d02:	db 8b       	std	Y+19, r29	; 0x13
    1d04:	ca 8b       	std	Y+18, r28	; 0x12
    1d06:	a3 01       	movw	r20, r6
    1d08:	b4 01       	movw	r22, r8
    1d0a:	c6 01       	movw	r24, r12
    1d0c:	c1 da       	rcall	.-2686   	; 0x1290 <pxPortInitialiseStack>
    1d0e:	99 83       	std	Y+1, r25	; 0x01
    1d10:	88 83       	st	Y, r24
    1d12:	e1 14       	cp	r14, r1
    1d14:	f1 04       	cpc	r15, r1
    1d16:	19 f0       	breq	.+6      	; 0x1d1e <xTaskGenericCreate+0xc0>
    1d18:	f7 01       	movw	r30, r14
    1d1a:	d1 83       	std	Z+1, r29	; 0x01
    1d1c:	c0 83       	st	Z, r28
    1d1e:	0f b6       	in	r0, 0x3f	; 63
    1d20:	f8 94       	cli
    1d22:	0f 92       	push	r0
    1d24:	80 91 2d 08 	lds	r24, 0x082D
    1d28:	8f 5f       	subi	r24, 0xFF	; 255
    1d2a:	80 93 2d 08 	sts	0x082D, r24
    1d2e:	80 91 8d 08 	lds	r24, 0x088D
    1d32:	90 91 8e 08 	lds	r25, 0x088E
    1d36:	89 2b       	or	r24, r25
    1d38:	09 f0       	breq	.+2      	; 0x1d3c <xTaskGenericCreate+0xde>
    1d3a:	3f c0       	rjmp	.+126    	; 0x1dba <xTaskGenericCreate+0x15c>
    1d3c:	d0 93 8e 08 	sts	0x088E, r29
    1d40:	c0 93 8d 08 	sts	0x088D, r28
    1d44:	80 91 2d 08 	lds	r24, 0x082D
    1d48:	81 30       	cpi	r24, 0x01	; 1
    1d4a:	09 f0       	breq	.+2      	; 0x1d4e <xTaskGenericCreate+0xf0>
    1d4c:	45 c0       	rjmp	.+138    	; 0x1dd8 <xTaskGenericCreate+0x17a>
    1d4e:	0f 2e       	mov	r0, r31
    1d50:	f0 e6       	ldi	r31, 0x60	; 96
    1d52:	ef 2e       	mov	r14, r31
    1d54:	f8 e0       	ldi	r31, 0x08	; 8
    1d56:	ff 2e       	mov	r15, r31
    1d58:	f0 2d       	mov	r31, r0
    1d5a:	0f 2e       	mov	r0, r31
    1d5c:	fd e8       	ldi	r31, 0x8D	; 141
    1d5e:	cf 2e       	mov	r12, r31
    1d60:	f8 e0       	ldi	r31, 0x08	; 8
    1d62:	df 2e       	mov	r13, r31
    1d64:	f0 2d       	mov	r31, r0
    1d66:	c7 01       	movw	r24, r14
    1d68:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1d6c:	f9 e0       	ldi	r31, 0x09	; 9
    1d6e:	ef 0e       	add	r14, r31
    1d70:	f1 1c       	adc	r15, r1
    1d72:	ec 14       	cp	r14, r12
    1d74:	fd 04       	cpc	r15, r13
    1d76:	b9 f7       	brne	.-18     	; 0x1d66 <xTaskGenericCreate+0x108>
    1d78:	87 e5       	ldi	r24, 0x57	; 87
    1d7a:	98 e0       	ldi	r25, 0x08	; 8
    1d7c:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1d80:	8e e4       	ldi	r24, 0x4E	; 78
    1d82:	98 e0       	ldi	r25, 0x08	; 8
    1d84:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1d88:	81 e4       	ldi	r24, 0x41	; 65
    1d8a:	98 e0       	ldi	r25, 0x08	; 8
    1d8c:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1d90:	88 e3       	ldi	r24, 0x38	; 56
    1d92:	98 e0       	ldi	r25, 0x08	; 8
    1d94:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1d98:	8e e2       	ldi	r24, 0x2E	; 46
    1d9a:	98 e0       	ldi	r25, 0x08	; 8
    1d9c:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialise>
    1da0:	87 e5       	ldi	r24, 0x57	; 87
    1da2:	98 e0       	ldi	r25, 0x08	; 8
    1da4:	90 93 4d 08 	sts	0x084D, r25
    1da8:	80 93 4c 08 	sts	0x084C, r24
    1dac:	8e e4       	ldi	r24, 0x4E	; 78
    1dae:	98 e0       	ldi	r25, 0x08	; 8
    1db0:	90 93 4b 08 	sts	0x084B, r25
    1db4:	80 93 4a 08 	sts	0x084A, r24
    1db8:	0f c0       	rjmp	.+30     	; 0x1dd8 <xTaskGenericCreate+0x17a>
    1dba:	80 91 29 08 	lds	r24, 0x0829
    1dbe:	81 11       	cpse	r24, r1
    1dc0:	0b c0       	rjmp	.+22     	; 0x1dd8 <xTaskGenericCreate+0x17a>
    1dc2:	e0 91 8d 08 	lds	r30, 0x088D
    1dc6:	f0 91 8e 08 	lds	r31, 0x088E
    1dca:	86 89       	ldd	r24, Z+22	; 0x16
    1dcc:	08 17       	cp	r16, r24
    1dce:	20 f0       	brcs	.+8      	; 0x1dd8 <xTaskGenericCreate+0x17a>
    1dd0:	d0 93 8e 08 	sts	0x088E, r29
    1dd4:	c0 93 8d 08 	sts	0x088D, r28
    1dd8:	80 91 25 08 	lds	r24, 0x0825
    1ddc:	8f 5f       	subi	r24, 0xFF	; 255
    1dde:	80 93 25 08 	sts	0x0825, r24
    1de2:	8e 89       	ldd	r24, Y+22	; 0x16
    1de4:	90 91 2a 08 	lds	r25, 0x082A
    1de8:	98 17       	cp	r25, r24
    1dea:	10 f4       	brcc	.+4      	; 0x1df0 <xTaskGenericCreate+0x192>
    1dec:	80 93 2a 08 	sts	0x082A, r24
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	9c 01       	movw	r18, r24
    1df4:	22 0f       	add	r18, r18
    1df6:	33 1f       	adc	r19, r19
    1df8:	22 0f       	add	r18, r18
    1dfa:	33 1f       	adc	r19, r19
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	82 0f       	add	r24, r18
    1e02:	93 1f       	adc	r25, r19
    1e04:	b5 01       	movw	r22, r10
    1e06:	80 5a       	subi	r24, 0xA0	; 160
    1e08:	97 4f       	sbci	r25, 0xF7	; 247
    1e0a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    1e0e:	0f 90       	pop	r0
    1e10:	0f be       	out	0x3f, r0	; 63
    1e12:	80 91 29 08 	lds	r24, 0x0829
    1e16:	88 23       	and	r24, r24
    1e18:	51 f0       	breq	.+20     	; 0x1e2e <xTaskGenericCreate+0x1d0>
    1e1a:	e0 91 8d 08 	lds	r30, 0x088D
    1e1e:	f0 91 8e 08 	lds	r31, 0x088E
    1e22:	86 89       	ldd	r24, Z+22	; 0x16
    1e24:	80 17       	cp	r24, r16
    1e26:	28 f4       	brcc	.+10     	; 0x1e32 <xTaskGenericCreate+0x1d4>
    1e28:	e2 da       	rcall	.-2620   	; 0x13ee <vPortYield>
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	1c c0       	rjmp	.+56     	; 0x1e66 <xTaskGenericCreate+0x208>
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	1a c0       	rjmp	.+52     	; 0x1e66 <xTaskGenericCreate+0x208>
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	18 c0       	rjmp	.+48     	; 0x1e66 <xTaskGenericCreate+0x208>
    1e36:	d8 8e       	std	Y+24, r13	; 0x18
    1e38:	cf 8a       	std	Y+23, r12	; 0x17
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
    1e3c:	48 1a       	sub	r4, r24
    1e3e:	51 08       	sbc	r5, r1
    1e40:	cf 88       	ldd	r12, Y+23	; 0x17
    1e42:	d8 8c       	ldd	r13, Y+24	; 0x18
    1e44:	c4 0c       	add	r12, r4
    1e46:	d5 1c       	adc	r13, r5
    1e48:	d5 01       	movw	r26, r10
    1e4a:	8c 91       	ld	r24, X
    1e4c:	89 8f       	std	Y+25, r24	; 0x19
    1e4e:	8c 91       	ld	r24, X
    1e50:	88 23       	and	r24, r24
    1e52:	09 f4       	brne	.+2      	; 0x1e56 <xTaskGenericCreate+0x1f8>
    1e54:	3b cf       	rjmp	.-394    	; 0x1ccc <xTaskGenericCreate+0x6e>
    1e56:	ae 01       	movw	r20, r28
    1e58:	46 5e       	subi	r20, 0xE6	; 230
    1e5a:	5f 4f       	sbci	r21, 0xFF	; 255
    1e5c:	f5 01       	movw	r30, r10
    1e5e:	31 96       	adiw	r30, 0x01	; 1
    1e60:	27 e0       	ldi	r18, 0x07	; 7
    1e62:	29 cf       	rjmp	.-430    	; 0x1cb6 <xTaskGenericCreate+0x58>
    1e64:	8f ef       	ldi	r24, 0xFF	; 255
    1e66:	df 91       	pop	r29
    1e68:	cf 91       	pop	r28
    1e6a:	1f 91       	pop	r17
    1e6c:	0f 91       	pop	r16
    1e6e:	ff 90       	pop	r15
    1e70:	ef 90       	pop	r14
    1e72:	df 90       	pop	r13
    1e74:	cf 90       	pop	r12
    1e76:	bf 90       	pop	r11
    1e78:	af 90       	pop	r10
    1e7a:	9f 90       	pop	r9
    1e7c:	8f 90       	pop	r8
    1e7e:	7f 90       	pop	r7
    1e80:	6f 90       	pop	r6
    1e82:	5f 90       	pop	r5
    1e84:	4f 90       	pop	r4
    1e86:	08 95       	ret

00001e88 <vTaskResume>:
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	ec 01       	movw	r28, r24
    1e92:	00 97       	sbiw	r24, 0x00	; 0
    1e94:	09 f4       	brne	.+2      	; 0x1e98 <vTaskResume+0x10>
    1e96:	3e c0       	rjmp	.+124    	; 0x1f14 <vTaskResume+0x8c>
    1e98:	80 91 8d 08 	lds	r24, 0x088D
    1e9c:	90 91 8e 08 	lds	r25, 0x088E
    1ea0:	c8 17       	cp	r28, r24
    1ea2:	d9 07       	cpc	r29, r25
    1ea4:	b9 f1       	breq	.+110    	; 0x1f14 <vTaskResume+0x8c>
    1ea6:	0f b6       	in	r0, 0x3f	; 63
    1ea8:	f8 94       	cli
    1eaa:	0f 92       	push	r0
    1eac:	8a 85       	ldd	r24, Y+10	; 0x0a
    1eae:	9b 85       	ldd	r25, Y+11	; 0x0b
    1eb0:	8e 52       	subi	r24, 0x2E	; 46
    1eb2:	98 40       	sbci	r25, 0x08	; 8
    1eb4:	69 f5       	brne	.+90     	; 0x1f10 <vTaskResume+0x88>
    1eb6:	8c 89       	ldd	r24, Y+20	; 0x14
    1eb8:	9d 89       	ldd	r25, Y+21	; 0x15
    1eba:	28 e0       	ldi	r18, 0x08	; 8
    1ebc:	81 34       	cpi	r24, 0x41	; 65
    1ebe:	92 07       	cpc	r25, r18
    1ec0:	39 f1       	breq	.+78     	; 0x1f10 <vTaskResume+0x88>
    1ec2:	89 2b       	or	r24, r25
    1ec4:	29 f5       	brne	.+74     	; 0x1f10 <vTaskResume+0x88>
    1ec6:	8e 01       	movw	r16, r28
    1ec8:	0e 5f       	subi	r16, 0xFE	; 254
    1eca:	1f 4f       	sbci	r17, 0xFF	; 255
    1ecc:	c8 01       	movw	r24, r16
    1ece:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    1ed2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ed4:	90 91 2a 08 	lds	r25, 0x082A
    1ed8:	98 17       	cp	r25, r24
    1eda:	10 f4       	brcc	.+4      	; 0x1ee0 <vTaskResume+0x58>
    1edc:	80 93 2a 08 	sts	0x082A, r24
    1ee0:	90 e0       	ldi	r25, 0x00	; 0
    1ee2:	9c 01       	movw	r18, r24
    1ee4:	22 0f       	add	r18, r18
    1ee6:	33 1f       	adc	r19, r19
    1ee8:	22 0f       	add	r18, r18
    1eea:	33 1f       	adc	r19, r19
    1eec:	22 0f       	add	r18, r18
    1eee:	33 1f       	adc	r19, r19
    1ef0:	82 0f       	add	r24, r18
    1ef2:	93 1f       	adc	r25, r19
    1ef4:	b8 01       	movw	r22, r16
    1ef6:	80 5a       	subi	r24, 0xA0	; 160
    1ef8:	97 4f       	sbci	r25, 0xF7	; 247
    1efa:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    1efe:	e0 91 8d 08 	lds	r30, 0x088D
    1f02:	f0 91 8e 08 	lds	r31, 0x088E
    1f06:	9e 89       	ldd	r25, Y+22	; 0x16
    1f08:	86 89       	ldd	r24, Z+22	; 0x16
    1f0a:	98 17       	cp	r25, r24
    1f0c:	08 f0       	brcs	.+2      	; 0x1f10 <vTaskResume+0x88>
    1f0e:	6f da       	rcall	.-2850   	; 0x13ee <vPortYield>
    1f10:	0f 90       	pop	r0
    1f12:	0f be       	out	0x3f, r0	; 63
    1f14:	df 91       	pop	r29
    1f16:	cf 91       	pop	r28
    1f18:	1f 91       	pop	r17
    1f1a:	0f 91       	pop	r16
    1f1c:	08 95       	ret

00001f1e <vTaskStartScheduler>:
    1f1e:	af 92       	push	r10
    1f20:	bf 92       	push	r11
    1f22:	cf 92       	push	r12
    1f24:	df 92       	push	r13
    1f26:	ef 92       	push	r14
    1f28:	ff 92       	push	r15
    1f2a:	0f 93       	push	r16
    1f2c:	a1 2c       	mov	r10, r1
    1f2e:	b1 2c       	mov	r11, r1
    1f30:	c1 2c       	mov	r12, r1
    1f32:	d1 2c       	mov	r13, r1
    1f34:	e1 2c       	mov	r14, r1
    1f36:	f1 2c       	mov	r15, r1
    1f38:	00 e0       	ldi	r16, 0x00	; 0
    1f3a:	20 e0       	ldi	r18, 0x00	; 0
    1f3c:	30 e0       	ldi	r19, 0x00	; 0
    1f3e:	45 e5       	ldi	r20, 0x55	; 85
    1f40:	50 e0       	ldi	r21, 0x00	; 0
    1f42:	69 e3       	ldi	r22, 0x39	; 57
    1f44:	72 e0       	ldi	r23, 0x02	; 2
    1f46:	86 e6       	ldi	r24, 0x66	; 102
    1f48:	91 e1       	ldi	r25, 0x11	; 17
    1f4a:	89 de       	rcall	.-750    	; 0x1c5e <xTaskGenericCreate>
    1f4c:	81 30       	cpi	r24, 0x01	; 1
    1f4e:	41 f4       	brne	.+16     	; 0x1f60 <vTaskStartScheduler+0x42>
    1f50:	f8 94       	cli
    1f52:	80 93 29 08 	sts	0x0829, r24
    1f56:	10 92 2c 08 	sts	0x082C, r1
    1f5a:	10 92 2b 08 	sts	0x082B, r1
    1f5e:	0a da       	rcall	.-3052   	; 0x1374 <xPortStartScheduler>
    1f60:	0f 91       	pop	r16
    1f62:	ff 90       	pop	r15
    1f64:	ef 90       	pop	r14
    1f66:	df 90       	pop	r13
    1f68:	cf 90       	pop	r12
    1f6a:	bf 90       	pop	r11
    1f6c:	af 90       	pop	r10
    1f6e:	08 95       	ret

00001f70 <vTaskSuspendAll>:
    1f70:	80 91 24 08 	lds	r24, 0x0824
    1f74:	8f 5f       	subi	r24, 0xFF	; 255
    1f76:	80 93 24 08 	sts	0x0824, r24
    1f7a:	08 95       	ret

00001f7c <xTaskGetTickCount>:
    1f7c:	0f b6       	in	r0, 0x3f	; 63
    1f7e:	f8 94       	cli
    1f80:	0f 92       	push	r0
    1f82:	80 91 2b 08 	lds	r24, 0x082B
    1f86:	90 91 2c 08 	lds	r25, 0x082C
    1f8a:	0f 90       	pop	r0
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	08 95       	ret

00001f90 <xTaskGetTickCountFromISR>:
    1f90:	80 91 2b 08 	lds	r24, 0x082B
    1f94:	90 91 2c 08 	lds	r25, 0x082C
    1f98:	08 95       	ret

00001f9a <xTaskIncrementTick>:
    1f9a:	cf 92       	push	r12
    1f9c:	df 92       	push	r13
    1f9e:	ef 92       	push	r14
    1fa0:	ff 92       	push	r15
    1fa2:	0f 93       	push	r16
    1fa4:	1f 93       	push	r17
    1fa6:	cf 93       	push	r28
    1fa8:	df 93       	push	r29
    1faa:	80 91 24 08 	lds	r24, 0x0824
    1fae:	81 11       	cpse	r24, r1
    1fb0:	99 c0       	rjmp	.+306    	; 0x20e4 <xTaskIncrementTick+0x14a>
    1fb2:	80 91 2b 08 	lds	r24, 0x082B
    1fb6:	90 91 2c 08 	lds	r25, 0x082C
    1fba:	01 96       	adiw	r24, 0x01	; 1
    1fbc:	90 93 2c 08 	sts	0x082C, r25
    1fc0:	80 93 2b 08 	sts	0x082B, r24
    1fc4:	e0 90 2b 08 	lds	r14, 0x082B
    1fc8:	f0 90 2c 08 	lds	r15, 0x082C
    1fcc:	e1 14       	cp	r14, r1
    1fce:	f1 04       	cpc	r15, r1
    1fd0:	b1 f4       	brne	.+44     	; 0x1ffe <xTaskIncrementTick+0x64>
    1fd2:	80 91 4c 08 	lds	r24, 0x084C
    1fd6:	90 91 4d 08 	lds	r25, 0x084D
    1fda:	20 91 4a 08 	lds	r18, 0x084A
    1fde:	30 91 4b 08 	lds	r19, 0x084B
    1fe2:	30 93 4d 08 	sts	0x084D, r19
    1fe6:	20 93 4c 08 	sts	0x084C, r18
    1fea:	90 93 4b 08 	sts	0x084B, r25
    1fee:	80 93 4a 08 	sts	0x084A, r24
    1ff2:	80 91 26 08 	lds	r24, 0x0826
    1ff6:	8f 5f       	subi	r24, 0xFF	; 255
    1ff8:	80 93 26 08 	sts	0x0826, r24
    1ffc:	da dd       	rcall	.-1100   	; 0x1bb2 <prvResetNextTaskUnblockTime>
    1ffe:	80 91 04 02 	lds	r24, 0x0204
    2002:	90 91 05 02 	lds	r25, 0x0205
    2006:	e8 16       	cp	r14, r24
    2008:	f9 06       	cpc	r15, r25
    200a:	08 f4       	brcc	.+2      	; 0x200e <xTaskIncrementTick+0x74>
    200c:	54 c0       	rjmp	.+168    	; 0x20b6 <xTaskIncrementTick+0x11c>
    200e:	d1 2c       	mov	r13, r1
    2010:	cc 24       	eor	r12, r12
    2012:	c3 94       	inc	r12
    2014:	01 c0       	rjmp	.+2      	; 0x2018 <xTaskIncrementTick+0x7e>
    2016:	dc 2c       	mov	r13, r12
    2018:	e0 91 4c 08 	lds	r30, 0x084C
    201c:	f0 91 4d 08 	lds	r31, 0x084D
    2020:	80 81       	ld	r24, Z
    2022:	81 11       	cpse	r24, r1
    2024:	07 c0       	rjmp	.+14     	; 0x2034 <xTaskIncrementTick+0x9a>
    2026:	8f ef       	ldi	r24, 0xFF	; 255
    2028:	9f ef       	ldi	r25, 0xFF	; 255
    202a:	90 93 05 02 	sts	0x0205, r25
    202e:	80 93 04 02 	sts	0x0204, r24
    2032:	42 c0       	rjmp	.+132    	; 0x20b8 <xTaskIncrementTick+0x11e>
    2034:	e0 91 4c 08 	lds	r30, 0x084C
    2038:	f0 91 4d 08 	lds	r31, 0x084D
    203c:	05 80       	ldd	r0, Z+5	; 0x05
    203e:	f6 81       	ldd	r31, Z+6	; 0x06
    2040:	e0 2d       	mov	r30, r0
    2042:	c6 81       	ldd	r28, Z+6	; 0x06
    2044:	d7 81       	ldd	r29, Z+7	; 0x07
    2046:	2a 81       	ldd	r18, Y+2	; 0x02
    2048:	3b 81       	ldd	r19, Y+3	; 0x03
    204a:	e2 16       	cp	r14, r18
    204c:	f3 06       	cpc	r15, r19
    204e:	28 f4       	brcc	.+10     	; 0x205a <xTaskIncrementTick+0xc0>
    2050:	30 93 05 02 	sts	0x0205, r19
    2054:	20 93 04 02 	sts	0x0204, r18
    2058:	2f c0       	rjmp	.+94     	; 0x20b8 <xTaskIncrementTick+0x11e>
    205a:	8e 01       	movw	r16, r28
    205c:	0e 5f       	subi	r16, 0xFE	; 254
    205e:	1f 4f       	sbci	r17, 0xFF	; 255
    2060:	c8 01       	movw	r24, r16
    2062:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2066:	8c 89       	ldd	r24, Y+20	; 0x14
    2068:	9d 89       	ldd	r25, Y+21	; 0x15
    206a:	89 2b       	or	r24, r25
    206c:	21 f0       	breq	.+8      	; 0x2076 <xTaskIncrementTick+0xdc>
    206e:	ce 01       	movw	r24, r28
    2070:	0c 96       	adiw	r24, 0x0c	; 12
    2072:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2076:	2e 89       	ldd	r18, Y+22	; 0x16
    2078:	80 91 2a 08 	lds	r24, 0x082A
    207c:	82 17       	cp	r24, r18
    207e:	10 f4       	brcc	.+4      	; 0x2084 <xTaskIncrementTick+0xea>
    2080:	20 93 2a 08 	sts	0x082A, r18
    2084:	30 e0       	ldi	r19, 0x00	; 0
    2086:	c9 01       	movw	r24, r18
    2088:	88 0f       	add	r24, r24
    208a:	99 1f       	adc	r25, r25
    208c:	88 0f       	add	r24, r24
    208e:	99 1f       	adc	r25, r25
    2090:	88 0f       	add	r24, r24
    2092:	99 1f       	adc	r25, r25
    2094:	82 0f       	add	r24, r18
    2096:	93 1f       	adc	r25, r19
    2098:	b8 01       	movw	r22, r16
    209a:	80 5a       	subi	r24, 0xA0	; 160
    209c:	97 4f       	sbci	r25, 0xF7	; 247
    209e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    20a2:	e0 91 8d 08 	lds	r30, 0x088D
    20a6:	f0 91 8e 08 	lds	r31, 0x088E
    20aa:	9e 89       	ldd	r25, Y+22	; 0x16
    20ac:	86 89       	ldd	r24, Z+22	; 0x16
    20ae:	98 17       	cp	r25, r24
    20b0:	08 f0       	brcs	.+2      	; 0x20b4 <xTaskIncrementTick+0x11a>
    20b2:	b1 cf       	rjmp	.-158    	; 0x2016 <xTaskIncrementTick+0x7c>
    20b4:	b1 cf       	rjmp	.-158    	; 0x2018 <xTaskIncrementTick+0x7e>
    20b6:	d1 2c       	mov	r13, r1
    20b8:	e0 91 8d 08 	lds	r30, 0x088D
    20bc:	f0 91 8e 08 	lds	r31, 0x088E
    20c0:	86 89       	ldd	r24, Z+22	; 0x16
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	fc 01       	movw	r30, r24
    20c6:	ee 0f       	add	r30, r30
    20c8:	ff 1f       	adc	r31, r31
    20ca:	ee 0f       	add	r30, r30
    20cc:	ff 1f       	adc	r31, r31
    20ce:	ee 0f       	add	r30, r30
    20d0:	ff 1f       	adc	r31, r31
    20d2:	8e 0f       	add	r24, r30
    20d4:	9f 1f       	adc	r25, r31
    20d6:	fc 01       	movw	r30, r24
    20d8:	e0 5a       	subi	r30, 0xA0	; 160
    20da:	f7 4f       	sbci	r31, 0xF7	; 247
    20dc:	80 81       	ld	r24, Z
    20de:	82 30       	cpi	r24, 0x02	; 2
    20e0:	40 f4       	brcc	.+16     	; 0x20f2 <xTaskIncrementTick+0x158>
    20e2:	09 c0       	rjmp	.+18     	; 0x20f6 <xTaskIncrementTick+0x15c>
    20e4:	80 91 28 08 	lds	r24, 0x0828
    20e8:	8f 5f       	subi	r24, 0xFF	; 255
    20ea:	80 93 28 08 	sts	0x0828, r24
    20ee:	d1 2c       	mov	r13, r1
    20f0:	02 c0       	rjmp	.+4      	; 0x20f6 <xTaskIncrementTick+0x15c>
    20f2:	dd 24       	eor	r13, r13
    20f4:	d3 94       	inc	r13
    20f6:	80 91 27 08 	lds	r24, 0x0827
    20fa:	88 23       	and	r24, r24
    20fc:	11 f0       	breq	.+4      	; 0x2102 <xTaskIncrementTick+0x168>
    20fe:	dd 24       	eor	r13, r13
    2100:	d3 94       	inc	r13
    2102:	8d 2d       	mov	r24, r13
    2104:	df 91       	pop	r29
    2106:	cf 91       	pop	r28
    2108:	1f 91       	pop	r17
    210a:	0f 91       	pop	r16
    210c:	ff 90       	pop	r15
    210e:	ef 90       	pop	r14
    2110:	df 90       	pop	r13
    2112:	cf 90       	pop	r12
    2114:	08 95       	ret

00002116 <xTaskResumeAll>:
    2116:	df 92       	push	r13
    2118:	ef 92       	push	r14
    211a:	ff 92       	push	r15
    211c:	0f 93       	push	r16
    211e:	1f 93       	push	r17
    2120:	cf 93       	push	r28
    2122:	df 93       	push	r29
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	0f 92       	push	r0
    212a:	80 91 24 08 	lds	r24, 0x0824
    212e:	81 50       	subi	r24, 0x01	; 1
    2130:	80 93 24 08 	sts	0x0824, r24
    2134:	80 91 24 08 	lds	r24, 0x0824
    2138:	81 11       	cpse	r24, r1
    213a:	5f c0       	rjmp	.+190    	; 0x21fa <xTaskResumeAll+0xe4>
    213c:	80 91 2d 08 	lds	r24, 0x082D
    2140:	88 23       	and	r24, r24
    2142:	09 f4       	brne	.+2      	; 0x2146 <xTaskResumeAll+0x30>
    2144:	5c c0       	rjmp	.+184    	; 0x21fe <xTaskResumeAll+0xe8>
    2146:	0f 2e       	mov	r0, r31
    2148:	f1 e4       	ldi	r31, 0x41	; 65
    214a:	ef 2e       	mov	r14, r31
    214c:	f8 e0       	ldi	r31, 0x08	; 8
    214e:	ff 2e       	mov	r15, r31
    2150:	f0 2d       	mov	r31, r0
    2152:	dd 24       	eor	r13, r13
    2154:	d3 94       	inc	r13
    2156:	30 c0       	rjmp	.+96     	; 0x21b8 <xTaskResumeAll+0xa2>
    2158:	e0 91 46 08 	lds	r30, 0x0846
    215c:	f0 91 47 08 	lds	r31, 0x0847
    2160:	c6 81       	ldd	r28, Z+6	; 0x06
    2162:	d7 81       	ldd	r29, Z+7	; 0x07
    2164:	ce 01       	movw	r24, r28
    2166:	0c 96       	adiw	r24, 0x0c	; 12
    2168:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    216c:	8e 01       	movw	r16, r28
    216e:	0e 5f       	subi	r16, 0xFE	; 254
    2170:	1f 4f       	sbci	r17, 0xFF	; 255
    2172:	c8 01       	movw	r24, r16
    2174:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2178:	8e 89       	ldd	r24, Y+22	; 0x16
    217a:	90 91 2a 08 	lds	r25, 0x082A
    217e:	98 17       	cp	r25, r24
    2180:	10 f4       	brcc	.+4      	; 0x2186 <xTaskResumeAll+0x70>
    2182:	80 93 2a 08 	sts	0x082A, r24
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	9c 01       	movw	r18, r24
    218a:	22 0f       	add	r18, r18
    218c:	33 1f       	adc	r19, r19
    218e:	22 0f       	add	r18, r18
    2190:	33 1f       	adc	r19, r19
    2192:	22 0f       	add	r18, r18
    2194:	33 1f       	adc	r19, r19
    2196:	82 0f       	add	r24, r18
    2198:	93 1f       	adc	r25, r19
    219a:	b8 01       	movw	r22, r16
    219c:	80 5a       	subi	r24, 0xA0	; 160
    219e:	97 4f       	sbci	r25, 0xF7	; 247
    21a0:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    21a4:	e0 91 8d 08 	lds	r30, 0x088D
    21a8:	f0 91 8e 08 	lds	r31, 0x088E
    21ac:	9e 89       	ldd	r25, Y+22	; 0x16
    21ae:	86 89       	ldd	r24, Z+22	; 0x16
    21b0:	98 17       	cp	r25, r24
    21b2:	10 f0       	brcs	.+4      	; 0x21b8 <xTaskResumeAll+0xa2>
    21b4:	d0 92 27 08 	sts	0x0827, r13
    21b8:	f7 01       	movw	r30, r14
    21ba:	80 81       	ld	r24, Z
    21bc:	81 11       	cpse	r24, r1
    21be:	cc cf       	rjmp	.-104    	; 0x2158 <xTaskResumeAll+0x42>
    21c0:	80 91 28 08 	lds	r24, 0x0828
    21c4:	88 23       	and	r24, r24
    21c6:	91 f0       	breq	.+36     	; 0x21ec <xTaskResumeAll+0xd6>
    21c8:	80 91 28 08 	lds	r24, 0x0828
    21cc:	88 23       	and	r24, r24
    21ce:	71 f0       	breq	.+28     	; 0x21ec <xTaskResumeAll+0xd6>
    21d0:	c1 e0       	ldi	r28, 0x01	; 1
    21d2:	e3 de       	rcall	.-570    	; 0x1f9a <xTaskIncrementTick>
    21d4:	81 11       	cpse	r24, r1
    21d6:	c0 93 27 08 	sts	0x0827, r28
    21da:	80 91 28 08 	lds	r24, 0x0828
    21de:	81 50       	subi	r24, 0x01	; 1
    21e0:	80 93 28 08 	sts	0x0828, r24
    21e4:	80 91 28 08 	lds	r24, 0x0828
    21e8:	81 11       	cpse	r24, r1
    21ea:	f3 cf       	rjmp	.-26     	; 0x21d2 <xTaskResumeAll+0xbc>
    21ec:	80 91 27 08 	lds	r24, 0x0827
    21f0:	81 30       	cpi	r24, 0x01	; 1
    21f2:	39 f4       	brne	.+14     	; 0x2202 <__stack+0x3>
    21f4:	fc d8       	rcall	.-3592   	; 0x13ee <vPortYield>
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	05 c0       	rjmp	.+10     	; 0x2204 <__stack+0x5>
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	03 c0       	rjmp	.+6      	; 0x2204 <__stack+0x5>
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	01 c0       	rjmp	.+2      	; 0x2204 <__stack+0x5>
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63
    2208:	df 91       	pop	r29
    220a:	cf 91       	pop	r28
    220c:	1f 91       	pop	r17
    220e:	0f 91       	pop	r16
    2210:	ff 90       	pop	r15
    2212:	ef 90       	pop	r14
    2214:	df 90       	pop	r13
    2216:	08 95       	ret

00002218 <vTaskDelayUntil>:
    2218:	0f 93       	push	r16
    221a:	1f 93       	push	r17
    221c:	cf 93       	push	r28
    221e:	df 93       	push	r29
    2220:	8c 01       	movw	r16, r24
    2222:	eb 01       	movw	r28, r22
    2224:	a5 de       	rcall	.-694    	; 0x1f70 <vTaskSuspendAll>
    2226:	80 91 2b 08 	lds	r24, 0x082B
    222a:	90 91 2c 08 	lds	r25, 0x082C
    222e:	f8 01       	movw	r30, r16
    2230:	20 81       	ld	r18, Z
    2232:	31 81       	ldd	r19, Z+1	; 0x01
    2234:	c2 0f       	add	r28, r18
    2236:	d3 1f       	adc	r29, r19
    2238:	82 17       	cp	r24, r18
    223a:	93 07       	cpc	r25, r19
    223c:	48 f4       	brcc	.+18     	; 0x2250 <vTaskDelayUntil+0x38>
    223e:	c2 17       	cp	r28, r18
    2240:	d3 07       	cpc	r29, r19
    2242:	f8 f4       	brcc	.+62     	; 0x2282 <vTaskDelayUntil+0x6a>
    2244:	d1 83       	std	Z+1, r29	; 0x01
    2246:	c0 83       	st	Z, r28
    2248:	8c 17       	cp	r24, r28
    224a:	9d 07       	cpc	r25, r29
    224c:	88 f4       	brcc	.+34     	; 0x2270 <vTaskDelayUntil+0x58>
    224e:	07 c0       	rjmp	.+14     	; 0x225e <vTaskDelayUntil+0x46>
    2250:	c2 17       	cp	r28, r18
    2252:	d3 07       	cpc	r29, r19
    2254:	90 f0       	brcs	.+36     	; 0x227a <vTaskDelayUntil+0x62>
    2256:	8c 17       	cp	r24, r28
    2258:	9d 07       	cpc	r25, r29
    225a:	78 f0       	brcs	.+30     	; 0x227a <vTaskDelayUntil+0x62>
    225c:	12 c0       	rjmp	.+36     	; 0x2282 <vTaskDelayUntil+0x6a>
    225e:	80 91 8d 08 	lds	r24, 0x088D
    2262:	90 91 8e 08 	lds	r25, 0x088E
    2266:	02 96       	adiw	r24, 0x02	; 2
    2268:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    226c:	ce 01       	movw	r24, r28
    226e:	c0 dc       	rcall	.-1664   	; 0x1bf0 <prvAddCurrentTaskToDelayedList>
    2270:	52 df       	rcall	.-348    	; 0x2116 <xTaskResumeAll>
    2272:	81 11       	cpse	r24, r1
    2274:	0a c0       	rjmp	.+20     	; 0x228a <vTaskDelayUntil+0x72>
    2276:	bb d8       	rcall	.-3722   	; 0x13ee <vPortYield>
    2278:	08 c0       	rjmp	.+16     	; 0x228a <vTaskDelayUntil+0x72>
    227a:	f8 01       	movw	r30, r16
    227c:	d1 83       	std	Z+1, r29	; 0x01
    227e:	c0 83       	st	Z, r28
    2280:	ee cf       	rjmp	.-36     	; 0x225e <vTaskDelayUntil+0x46>
    2282:	f8 01       	movw	r30, r16
    2284:	d1 83       	std	Z+1, r29	; 0x01
    2286:	c0 83       	st	Z, r28
    2288:	f3 cf       	rjmp	.-26     	; 0x2270 <vTaskDelayUntil+0x58>
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	1f 91       	pop	r17
    2290:	0f 91       	pop	r16
    2292:	08 95       	ret

00002294 <vTaskDelay>:
    2294:	cf 93       	push	r28
    2296:	df 93       	push	r29
    2298:	ec 01       	movw	r28, r24
    229a:	00 97       	sbiw	r24, 0x00	; 0
    229c:	99 f0       	breq	.+38     	; 0x22c4 <vTaskDelay+0x30>
    229e:	68 de       	rcall	.-816    	; 0x1f70 <vTaskSuspendAll>
    22a0:	80 91 2b 08 	lds	r24, 0x082B
    22a4:	90 91 2c 08 	lds	r25, 0x082C
    22a8:	c8 0f       	add	r28, r24
    22aa:	d9 1f       	adc	r29, r25
    22ac:	80 91 8d 08 	lds	r24, 0x088D
    22b0:	90 91 8e 08 	lds	r25, 0x088E
    22b4:	02 96       	adiw	r24, 0x02	; 2
    22b6:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    22ba:	ce 01       	movw	r24, r28
    22bc:	99 dc       	rcall	.-1742   	; 0x1bf0 <prvAddCurrentTaskToDelayedList>
    22be:	2b df       	rcall	.-426    	; 0x2116 <xTaskResumeAll>
    22c0:	81 11       	cpse	r24, r1
    22c2:	01 c0       	rjmp	.+2      	; 0x22c6 <vTaskDelay+0x32>
    22c4:	94 d8       	rcall	.-3800   	; 0x13ee <vPortYield>
    22c6:	df 91       	pop	r29
    22c8:	cf 91       	pop	r28
    22ca:	08 95       	ret

000022cc <prvIdleTask>:
    22cc:	0f 2e       	mov	r0, r31
    22ce:	f0 e6       	ldi	r31, 0x60	; 96
    22d0:	ef 2e       	mov	r14, r31
    22d2:	f8 e0       	ldi	r31, 0x08	; 8
    22d4:	ff 2e       	mov	r15, r31
    22d6:	f0 2d       	mov	r31, r0
    22d8:	c8 e3       	ldi	r28, 0x38	; 56
    22da:	d8 e0       	ldi	r29, 0x08	; 8
    22dc:	26 c0       	rjmp	.+76     	; 0x232a <prvIdleTask+0x5e>
    22de:	48 de       	rcall	.-880    	; 0x1f70 <vTaskSuspendAll>
    22e0:	18 81       	ld	r17, Y
    22e2:	19 df       	rcall	.-462    	; 0x2116 <xTaskResumeAll>
    22e4:	11 23       	and	r17, r17
    22e6:	09 f1       	breq	.+66     	; 0x232a <prvIdleTask+0x5e>
    22e8:	0f b6       	in	r0, 0x3f	; 63
    22ea:	f8 94       	cli
    22ec:	0f 92       	push	r0
    22ee:	e0 91 3d 08 	lds	r30, 0x083D
    22f2:	f0 91 3e 08 	lds	r31, 0x083E
    22f6:	06 81       	ldd	r16, Z+6	; 0x06
    22f8:	17 81       	ldd	r17, Z+7	; 0x07
    22fa:	c8 01       	movw	r24, r16
    22fc:	02 96       	adiw	r24, 0x02	; 2
    22fe:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2302:	80 91 2d 08 	lds	r24, 0x082D
    2306:	81 50       	subi	r24, 0x01	; 1
    2308:	80 93 2d 08 	sts	0x082D, r24
    230c:	80 91 37 08 	lds	r24, 0x0837
    2310:	81 50       	subi	r24, 0x01	; 1
    2312:	80 93 37 08 	sts	0x0837, r24
    2316:	0f 90       	pop	r0
    2318:	0f be       	out	0x3f, r0	; 63
    231a:	f8 01       	movw	r30, r16
    231c:	87 89       	ldd	r24, Z+23	; 0x17
    231e:	90 8d       	ldd	r25, Z+24	; 0x18
    2320:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortFree>
    2324:	c8 01       	movw	r24, r16
    2326:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortFree>
    232a:	80 91 37 08 	lds	r24, 0x0837
    232e:	81 11       	cpse	r24, r1
    2330:	d6 cf       	rjmp	.-84     	; 0x22de <prvIdleTask+0x12>
    2332:	f7 01       	movw	r30, r14
    2334:	80 81       	ld	r24, Z
    2336:	82 30       	cpi	r24, 0x02	; 2
    2338:	c0 f3       	brcs	.-16     	; 0x232a <prvIdleTask+0x5e>
    233a:	59 d8       	rcall	.-3918   	; 0x13ee <vPortYield>
    233c:	f6 cf       	rjmp	.-20     	; 0x232a <prvIdleTask+0x5e>

0000233e <vTaskSwitchContext>:
    233e:	80 91 24 08 	lds	r24, 0x0824
    2342:	88 23       	and	r24, r24
    2344:	21 f0       	breq	.+8      	; 0x234e <vTaskSwitchContext+0x10>
    2346:	81 e0       	ldi	r24, 0x01	; 1
    2348:	80 93 27 08 	sts	0x0827, r24
    234c:	08 95       	ret
    234e:	10 92 27 08 	sts	0x0827, r1
    2352:	80 91 2a 08 	lds	r24, 0x082A
    2356:	90 e0       	ldi	r25, 0x00	; 0
    2358:	fc 01       	movw	r30, r24
    235a:	ee 0f       	add	r30, r30
    235c:	ff 1f       	adc	r31, r31
    235e:	ee 0f       	add	r30, r30
    2360:	ff 1f       	adc	r31, r31
    2362:	ee 0f       	add	r30, r30
    2364:	ff 1f       	adc	r31, r31
    2366:	8e 0f       	add	r24, r30
    2368:	9f 1f       	adc	r25, r31
    236a:	fc 01       	movw	r30, r24
    236c:	e0 5a       	subi	r30, 0xA0	; 160
    236e:	f7 4f       	sbci	r31, 0xF7	; 247
    2370:	80 81       	ld	r24, Z
    2372:	81 11       	cpse	r24, r1
    2374:	17 c0       	rjmp	.+46     	; 0x23a4 <vTaskSwitchContext+0x66>
    2376:	80 91 2a 08 	lds	r24, 0x082A
    237a:	81 50       	subi	r24, 0x01	; 1
    237c:	80 93 2a 08 	sts	0x082A, r24
    2380:	80 91 2a 08 	lds	r24, 0x082A
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	fc 01       	movw	r30, r24
    2388:	ee 0f       	add	r30, r30
    238a:	ff 1f       	adc	r31, r31
    238c:	ee 0f       	add	r30, r30
    238e:	ff 1f       	adc	r31, r31
    2390:	ee 0f       	add	r30, r30
    2392:	ff 1f       	adc	r31, r31
    2394:	8e 0f       	add	r24, r30
    2396:	9f 1f       	adc	r25, r31
    2398:	fc 01       	movw	r30, r24
    239a:	e0 5a       	subi	r30, 0xA0	; 160
    239c:	f7 4f       	sbci	r31, 0xF7	; 247
    239e:	80 81       	ld	r24, Z
    23a0:	88 23       	and	r24, r24
    23a2:	49 f3       	breq	.-46     	; 0x2376 <vTaskSwitchContext+0x38>
    23a4:	e0 91 2a 08 	lds	r30, 0x082A
    23a8:	f0 e0       	ldi	r31, 0x00	; 0
    23aa:	cf 01       	movw	r24, r30
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	88 0f       	add	r24, r24
    23b2:	99 1f       	adc	r25, r25
    23b4:	88 0f       	add	r24, r24
    23b6:	99 1f       	adc	r25, r25
    23b8:	e8 0f       	add	r30, r24
    23ba:	f9 1f       	adc	r31, r25
    23bc:	e0 5a       	subi	r30, 0xA0	; 160
    23be:	f7 4f       	sbci	r31, 0xF7	; 247
    23c0:	a1 81       	ldd	r26, Z+1	; 0x01
    23c2:	b2 81       	ldd	r27, Z+2	; 0x02
    23c4:	12 96       	adiw	r26, 0x02	; 2
    23c6:	0d 90       	ld	r0, X+
    23c8:	bc 91       	ld	r27, X
    23ca:	a0 2d       	mov	r26, r0
    23cc:	b2 83       	std	Z+2, r27	; 0x02
    23ce:	a1 83       	std	Z+1, r26	; 0x01
    23d0:	cf 01       	movw	r24, r30
    23d2:	03 96       	adiw	r24, 0x03	; 3
    23d4:	a8 17       	cp	r26, r24
    23d6:	b9 07       	cpc	r27, r25
    23d8:	31 f4       	brne	.+12     	; 0x23e6 <vTaskSwitchContext+0xa8>
    23da:	12 96       	adiw	r26, 0x02	; 2
    23dc:	8d 91       	ld	r24, X+
    23de:	9c 91       	ld	r25, X
    23e0:	13 97       	sbiw	r26, 0x03	; 3
    23e2:	92 83       	std	Z+2, r25	; 0x02
    23e4:	81 83       	std	Z+1, r24	; 0x01
    23e6:	01 80       	ldd	r0, Z+1	; 0x01
    23e8:	f2 81       	ldd	r31, Z+2	; 0x02
    23ea:	e0 2d       	mov	r30, r0
    23ec:	86 81       	ldd	r24, Z+6	; 0x06
    23ee:	97 81       	ldd	r25, Z+7	; 0x07
    23f0:	90 93 8e 08 	sts	0x088E, r25
    23f4:	80 93 8d 08 	sts	0x088D, r24
    23f8:	08 95       	ret

000023fa <vTaskSuspend>:
    23fa:	0f 93       	push	r16
    23fc:	1f 93       	push	r17
    23fe:	cf 93       	push	r28
    2400:	df 93       	push	r29
    2402:	ec 01       	movw	r28, r24
    2404:	0f b6       	in	r0, 0x3f	; 63
    2406:	f8 94       	cli
    2408:	0f 92       	push	r0
    240a:	00 97       	sbiw	r24, 0x00	; 0
    240c:	21 f4       	brne	.+8      	; 0x2416 <vTaskSuspend+0x1c>
    240e:	c0 91 8d 08 	lds	r28, 0x088D
    2412:	d0 91 8e 08 	lds	r29, 0x088E
    2416:	8e 01       	movw	r16, r28
    2418:	0e 5f       	subi	r16, 0xFE	; 254
    241a:	1f 4f       	sbci	r17, 0xFF	; 255
    241c:	c8 01       	movw	r24, r16
    241e:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2422:	8c 89       	ldd	r24, Y+20	; 0x14
    2424:	9d 89       	ldd	r25, Y+21	; 0x15
    2426:	89 2b       	or	r24, r25
    2428:	21 f0       	breq	.+8      	; 0x2432 <vTaskSuspend+0x38>
    242a:	ce 01       	movw	r24, r28
    242c:	0c 96       	adiw	r24, 0x0c	; 12
    242e:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2432:	b8 01       	movw	r22, r16
    2434:	8e e2       	ldi	r24, 0x2E	; 46
    2436:	98 e0       	ldi	r25, 0x08	; 8
    2438:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    243c:	0f 90       	pop	r0
    243e:	0f be       	out	0x3f, r0	; 63
    2440:	80 91 8d 08 	lds	r24, 0x088D
    2444:	90 91 8e 08 	lds	r25, 0x088E
    2448:	c8 17       	cp	r28, r24
    244a:	d9 07       	cpc	r29, r25
    244c:	a1 f4       	brne	.+40     	; 0x2476 <vTaskSuspend+0x7c>
    244e:	80 91 29 08 	lds	r24, 0x0829
    2452:	88 23       	and	r24, r24
    2454:	19 f0       	breq	.+6      	; 0x245c <vTaskSuspend+0x62>
    2456:	0e 94 f7 09 	call	0x13ee	; 0x13ee <vPortYield>
    245a:	17 c0       	rjmp	.+46     	; 0x248a <vTaskSuspend+0x90>
    245c:	80 91 2d 08 	lds	r24, 0x082D
    2460:	90 91 2e 08 	lds	r25, 0x082E
    2464:	98 13       	cpse	r25, r24
    2466:	05 c0       	rjmp	.+10     	; 0x2472 <vTaskSuspend+0x78>
    2468:	10 92 8e 08 	sts	0x088E, r1
    246c:	10 92 8d 08 	sts	0x088D, r1
    2470:	0c c0       	rjmp	.+24     	; 0x248a <vTaskSuspend+0x90>
    2472:	65 df       	rcall	.-310    	; 0x233e <vTaskSwitchContext>
    2474:	0a c0       	rjmp	.+20     	; 0x248a <vTaskSuspend+0x90>
    2476:	80 91 29 08 	lds	r24, 0x0829
    247a:	88 23       	and	r24, r24
    247c:	31 f0       	breq	.+12     	; 0x248a <vTaskSuspend+0x90>
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	f8 94       	cli
    2482:	0f 92       	push	r0
    2484:	96 db       	rcall	.-2260   	; 0x1bb2 <prvResetNextTaskUnblockTime>
    2486:	0f 90       	pop	r0
    2488:	0f be       	out	0x3f, r0	; 63
    248a:	df 91       	pop	r29
    248c:	cf 91       	pop	r28
    248e:	1f 91       	pop	r17
    2490:	0f 91       	pop	r16
    2492:	08 95       	ret

00002494 <vTaskPlaceOnEventList>:
    2494:	cf 93       	push	r28
    2496:	df 93       	push	r29
    2498:	eb 01       	movw	r28, r22
    249a:	60 91 8d 08 	lds	r22, 0x088D
    249e:	70 91 8e 08 	lds	r23, 0x088E
    24a2:	64 5f       	subi	r22, 0xF4	; 244
    24a4:	7f 4f       	sbci	r23, 0xFF	; 255
    24a6:	0e 94 72 03 	call	0x6e4	; 0x6e4 <vListInsert>
    24aa:	80 91 8d 08 	lds	r24, 0x088D
    24ae:	90 91 8e 08 	lds	r25, 0x088E
    24b2:	02 96       	adiw	r24, 0x02	; 2
    24b4:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    24b8:	cf 3f       	cpi	r28, 0xFF	; 255
    24ba:	8f ef       	ldi	r24, 0xFF	; 255
    24bc:	d8 07       	cpc	r29, r24
    24be:	59 f4       	brne	.+22     	; 0x24d6 <vTaskPlaceOnEventList+0x42>
    24c0:	60 91 8d 08 	lds	r22, 0x088D
    24c4:	70 91 8e 08 	lds	r23, 0x088E
    24c8:	6e 5f       	subi	r22, 0xFE	; 254
    24ca:	7f 4f       	sbci	r23, 0xFF	; 255
    24cc:	8e e2       	ldi	r24, 0x2E	; 46
    24ce:	98 e0       	ldi	r25, 0x08	; 8
    24d0:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    24d4:	07 c0       	rjmp	.+14     	; 0x24e4 <vTaskPlaceOnEventList+0x50>
    24d6:	80 91 2b 08 	lds	r24, 0x082B
    24da:	90 91 2c 08 	lds	r25, 0x082C
    24de:	8c 0f       	add	r24, r28
    24e0:	9d 1f       	adc	r25, r29
    24e2:	86 db       	rcall	.-2292   	; 0x1bf0 <prvAddCurrentTaskToDelayedList>
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	08 95       	ret

000024ea <xTaskRemoveFromEventList>:
    24ea:	0f 93       	push	r16
    24ec:	1f 93       	push	r17
    24ee:	cf 93       	push	r28
    24f0:	df 93       	push	r29
    24f2:	dc 01       	movw	r26, r24
    24f4:	15 96       	adiw	r26, 0x05	; 5
    24f6:	ed 91       	ld	r30, X+
    24f8:	fc 91       	ld	r31, X
    24fa:	16 97       	sbiw	r26, 0x06	; 6
    24fc:	c6 81       	ldd	r28, Z+6	; 0x06
    24fe:	d7 81       	ldd	r29, Z+7	; 0x07
    2500:	8e 01       	movw	r16, r28
    2502:	04 5f       	subi	r16, 0xF4	; 244
    2504:	1f 4f       	sbci	r17, 0xFF	; 255
    2506:	c8 01       	movw	r24, r16
    2508:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    250c:	80 91 24 08 	lds	r24, 0x0824
    2510:	81 11       	cpse	r24, r1
    2512:	1c c0       	rjmp	.+56     	; 0x254c <xTaskRemoveFromEventList+0x62>
    2514:	0a 50       	subi	r16, 0x0A	; 10
    2516:	11 09       	sbc	r17, r1
    2518:	c8 01       	movw	r24, r16
    251a:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    251e:	8e 89       	ldd	r24, Y+22	; 0x16
    2520:	90 91 2a 08 	lds	r25, 0x082A
    2524:	98 17       	cp	r25, r24
    2526:	10 f4       	brcc	.+4      	; 0x252c <xTaskRemoveFromEventList+0x42>
    2528:	80 93 2a 08 	sts	0x082A, r24
    252c:	90 e0       	ldi	r25, 0x00	; 0
    252e:	9c 01       	movw	r18, r24
    2530:	22 0f       	add	r18, r18
    2532:	33 1f       	adc	r19, r19
    2534:	22 0f       	add	r18, r18
    2536:	33 1f       	adc	r19, r19
    2538:	22 0f       	add	r18, r18
    253a:	33 1f       	adc	r19, r19
    253c:	82 0f       	add	r24, r18
    253e:	93 1f       	adc	r25, r19
    2540:	b8 01       	movw	r22, r16
    2542:	80 5a       	subi	r24, 0xA0	; 160
    2544:	97 4f       	sbci	r25, 0xF7	; 247
    2546:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    254a:	05 c0       	rjmp	.+10     	; 0x2556 <xTaskRemoveFromEventList+0x6c>
    254c:	b8 01       	movw	r22, r16
    254e:	81 e4       	ldi	r24, 0x41	; 65
    2550:	98 e0       	ldi	r25, 0x08	; 8
    2552:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    2556:	e0 91 8d 08 	lds	r30, 0x088D
    255a:	f0 91 8e 08 	lds	r31, 0x088E
    255e:	9e 89       	ldd	r25, Y+22	; 0x16
    2560:	86 89       	ldd	r24, Z+22	; 0x16
    2562:	89 17       	cp	r24, r25
    2564:	20 f4       	brcc	.+8      	; 0x256e <xTaskRemoveFromEventList+0x84>
    2566:	81 e0       	ldi	r24, 0x01	; 1
    2568:	80 93 27 08 	sts	0x0827, r24
    256c:	01 c0       	rjmp	.+2      	; 0x2570 <xTaskRemoveFromEventList+0x86>
    256e:	80 e0       	ldi	r24, 0x00	; 0
    2570:	df 91       	pop	r29
    2572:	cf 91       	pop	r28
    2574:	1f 91       	pop	r17
    2576:	0f 91       	pop	r16
    2578:	08 95       	ret

0000257a <vTaskSetTimeOutState>:
    257a:	20 91 26 08 	lds	r18, 0x0826
    257e:	fc 01       	movw	r30, r24
    2580:	20 83       	st	Z, r18
    2582:	20 91 2b 08 	lds	r18, 0x082B
    2586:	30 91 2c 08 	lds	r19, 0x082C
    258a:	32 83       	std	Z+2, r19	; 0x02
    258c:	21 83       	std	Z+1, r18	; 0x01
    258e:	08 95       	ret

00002590 <xTaskCheckForTimeOut>:
    2590:	0f b6       	in	r0, 0x3f	; 63
    2592:	f8 94       	cli
    2594:	0f 92       	push	r0
    2596:	40 91 2b 08 	lds	r20, 0x082B
    259a:	50 91 2c 08 	lds	r21, 0x082C
    259e:	db 01       	movw	r26, r22
    25a0:	2d 91       	ld	r18, X+
    25a2:	3c 91       	ld	r19, X
    25a4:	2f 3f       	cpi	r18, 0xFF	; 255
    25a6:	bf ef       	ldi	r27, 0xFF	; 255
    25a8:	3b 07       	cpc	r19, r27
    25aa:	11 f1       	breq	.+68     	; 0x25f0 <xTaskCheckForTimeOut+0x60>
    25ac:	e0 91 26 08 	lds	r30, 0x0826
    25b0:	dc 01       	movw	r26, r24
    25b2:	fc 91       	ld	r31, X
    25b4:	fe 17       	cp	r31, r30
    25b6:	39 f0       	breq	.+14     	; 0x25c6 <xTaskCheckForTimeOut+0x36>
    25b8:	11 96       	adiw	r26, 0x01	; 1
    25ba:	ed 91       	ld	r30, X+
    25bc:	fc 91       	ld	r31, X
    25be:	12 97       	sbiw	r26, 0x02	; 2
    25c0:	4e 17       	cp	r20, r30
    25c2:	5f 07       	cpc	r21, r31
    25c4:	b8 f4       	brcc	.+46     	; 0x25f4 <xTaskCheckForTimeOut+0x64>
    25c6:	dc 01       	movw	r26, r24
    25c8:	11 96       	adiw	r26, 0x01	; 1
    25ca:	ed 91       	ld	r30, X+
    25cc:	fc 91       	ld	r31, X
    25ce:	12 97       	sbiw	r26, 0x02	; 2
    25d0:	da 01       	movw	r26, r20
    25d2:	ae 1b       	sub	r26, r30
    25d4:	bf 0b       	sbc	r27, r31
    25d6:	a2 17       	cp	r26, r18
    25d8:	b3 07       	cpc	r27, r19
    25da:	70 f4       	brcc	.+28     	; 0x25f8 <xTaskCheckForTimeOut+0x68>
    25dc:	e4 1b       	sub	r30, r20
    25de:	f5 0b       	sbc	r31, r21
    25e0:	2e 0f       	add	r18, r30
    25e2:	3f 1f       	adc	r19, r31
    25e4:	fb 01       	movw	r30, r22
    25e6:	31 83       	std	Z+1, r19	; 0x01
    25e8:	20 83       	st	Z, r18
    25ea:	c7 df       	rcall	.-114    	; 0x257a <vTaskSetTimeOutState>
    25ec:	80 e0       	ldi	r24, 0x00	; 0
    25ee:	05 c0       	rjmp	.+10     	; 0x25fa <xTaskCheckForTimeOut+0x6a>
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	03 c0       	rjmp	.+6      	; 0x25fa <xTaskCheckForTimeOut+0x6a>
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	01 c0       	rjmp	.+2      	; 0x25fa <xTaskCheckForTimeOut+0x6a>
    25f8:	81 e0       	ldi	r24, 0x01	; 1
    25fa:	0f 90       	pop	r0
    25fc:	0f be       	out	0x3f, r0	; 63
    25fe:	08 95       	ret

00002600 <vTaskMissedYield>:
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	80 93 27 08 	sts	0x0827, r24
    2606:	08 95       	ret

00002608 <vTaskPriorityInherit>:
    2608:	0f 93       	push	r16
    260a:	1f 93       	push	r17
    260c:	cf 93       	push	r28
    260e:	df 93       	push	r29
    2610:	ec 01       	movw	r28, r24
    2612:	00 97       	sbiw	r24, 0x00	; 0
    2614:	09 f4       	brne	.+2      	; 0x2618 <vTaskPriorityInherit+0x10>
    2616:	51 c0       	rjmp	.+162    	; 0x26ba <vTaskPriorityInherit+0xb2>
    2618:	8e 89       	ldd	r24, Y+22	; 0x16
    261a:	e0 91 8d 08 	lds	r30, 0x088D
    261e:	f0 91 8e 08 	lds	r31, 0x088E
    2622:	96 89       	ldd	r25, Z+22	; 0x16
    2624:	89 17       	cp	r24, r25
    2626:	08 f0       	brcs	.+2      	; 0x262a <vTaskPriorityInherit+0x22>
    2628:	48 c0       	rjmp	.+144    	; 0x26ba <vTaskPriorityInherit+0xb2>
    262a:	2c 85       	ldd	r18, Y+12	; 0x0c
    262c:	3d 85       	ldd	r19, Y+13	; 0x0d
    262e:	33 23       	and	r19, r19
    2630:	5c f0       	brlt	.+22     	; 0x2648 <vTaskPriorityInherit+0x40>
    2632:	e0 91 8d 08 	lds	r30, 0x088D
    2636:	f0 91 8e 08 	lds	r31, 0x088E
    263a:	96 89       	ldd	r25, Z+22	; 0x16
    263c:	25 e0       	ldi	r18, 0x05	; 5
    263e:	30 e0       	ldi	r19, 0x00	; 0
    2640:	29 1b       	sub	r18, r25
    2642:	31 09       	sbc	r19, r1
    2644:	3d 87       	std	Y+13, r19	; 0x0d
    2646:	2c 87       	std	Y+12, r18	; 0x0c
    2648:	90 e0       	ldi	r25, 0x00	; 0
    264a:	9c 01       	movw	r18, r24
    264c:	22 0f       	add	r18, r18
    264e:	33 1f       	adc	r19, r19
    2650:	22 0f       	add	r18, r18
    2652:	33 1f       	adc	r19, r19
    2654:	22 0f       	add	r18, r18
    2656:	33 1f       	adc	r19, r19
    2658:	82 0f       	add	r24, r18
    265a:	93 1f       	adc	r25, r19
    265c:	80 5a       	subi	r24, 0xA0	; 160
    265e:	97 4f       	sbci	r25, 0xF7	; 247
    2660:	2a 85       	ldd	r18, Y+10	; 0x0a
    2662:	3b 85       	ldd	r19, Y+11	; 0x0b
    2664:	28 17       	cp	r18, r24
    2666:	39 07       	cpc	r19, r25
    2668:	11 f5       	brne	.+68     	; 0x26ae <vTaskPriorityInherit+0xa6>
    266a:	8e 01       	movw	r16, r28
    266c:	0e 5f       	subi	r16, 0xFE	; 254
    266e:	1f 4f       	sbci	r17, 0xFF	; 255
    2670:	c8 01       	movw	r24, r16
    2672:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    2676:	e0 91 8d 08 	lds	r30, 0x088D
    267a:	f0 91 8e 08 	lds	r31, 0x088E
    267e:	86 89       	ldd	r24, Z+22	; 0x16
    2680:	8e 8b       	std	Y+22, r24	; 0x16
    2682:	90 91 2a 08 	lds	r25, 0x082A
    2686:	98 17       	cp	r25, r24
    2688:	10 f4       	brcc	.+4      	; 0x268e <vTaskPriorityInherit+0x86>
    268a:	80 93 2a 08 	sts	0x082A, r24
    268e:	90 e0       	ldi	r25, 0x00	; 0
    2690:	9c 01       	movw	r18, r24
    2692:	22 0f       	add	r18, r18
    2694:	33 1f       	adc	r19, r19
    2696:	22 0f       	add	r18, r18
    2698:	33 1f       	adc	r19, r19
    269a:	22 0f       	add	r18, r18
    269c:	33 1f       	adc	r19, r19
    269e:	82 0f       	add	r24, r18
    26a0:	93 1f       	adc	r25, r19
    26a2:	b8 01       	movw	r22, r16
    26a4:	80 5a       	subi	r24, 0xA0	; 160
    26a6:	97 4f       	sbci	r25, 0xF7	; 247
    26a8:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    26ac:	06 c0       	rjmp	.+12     	; 0x26ba <vTaskPriorityInherit+0xb2>
    26ae:	e0 91 8d 08 	lds	r30, 0x088D
    26b2:	f0 91 8e 08 	lds	r31, 0x088E
    26b6:	86 89       	ldd	r24, Z+22	; 0x16
    26b8:	8e 8b       	std	Y+22, r24	; 0x16
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	1f 91       	pop	r17
    26c0:	0f 91       	pop	r16
    26c2:	08 95       	ret

000026c4 <xTaskPriorityDisinherit>:
    26c4:	0f 93       	push	r16
    26c6:	1f 93       	push	r17
    26c8:	cf 93       	push	r28
    26ca:	df 93       	push	r29
    26cc:	ec 01       	movw	r28, r24
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	71 f1       	breq	.+92     	; 0x272e <xTaskPriorityDisinherit+0x6a>
    26d2:	8a a1       	ldd	r24, Y+34	; 0x22
    26d4:	81 50       	subi	r24, 0x01	; 1
    26d6:	8a a3       	std	Y+34, r24	; 0x22
    26d8:	2e 89       	ldd	r18, Y+22	; 0x16
    26da:	99 a1       	ldd	r25, Y+33	; 0x21
    26dc:	29 17       	cp	r18, r25
    26de:	49 f1       	breq	.+82     	; 0x2732 <xTaskPriorityDisinherit+0x6e>
    26e0:	81 11       	cpse	r24, r1
    26e2:	29 c0       	rjmp	.+82     	; 0x2736 <xTaskPriorityDisinherit+0x72>
    26e4:	8e 01       	movw	r16, r28
    26e6:	0e 5f       	subi	r16, 0xFE	; 254
    26e8:	1f 4f       	sbci	r17, 0xFF	; 255
    26ea:	c8 01       	movw	r24, r16
    26ec:	0e 94 a3 03 	call	0x746	; 0x746 <uxListRemove>
    26f0:	89 a1       	ldd	r24, Y+33	; 0x21
    26f2:	8e 8b       	std	Y+22, r24	; 0x16
    26f4:	25 e0       	ldi	r18, 0x05	; 5
    26f6:	30 e0       	ldi	r19, 0x00	; 0
    26f8:	28 1b       	sub	r18, r24
    26fa:	31 09       	sbc	r19, r1
    26fc:	3d 87       	std	Y+13, r19	; 0x0d
    26fe:	2c 87       	std	Y+12, r18	; 0x0c
    2700:	90 91 2a 08 	lds	r25, 0x082A
    2704:	98 17       	cp	r25, r24
    2706:	10 f4       	brcc	.+4      	; 0x270c <xTaskPriorityDisinherit+0x48>
    2708:	80 93 2a 08 	sts	0x082A, r24
    270c:	90 e0       	ldi	r25, 0x00	; 0
    270e:	9c 01       	movw	r18, r24
    2710:	22 0f       	add	r18, r18
    2712:	33 1f       	adc	r19, r19
    2714:	22 0f       	add	r18, r18
    2716:	33 1f       	adc	r19, r19
    2718:	22 0f       	add	r18, r18
    271a:	33 1f       	adc	r19, r19
    271c:	82 0f       	add	r24, r18
    271e:	93 1f       	adc	r25, r19
    2720:	b8 01       	movw	r22, r16
    2722:	80 5a       	subi	r24, 0xA0	; 160
    2724:	97 4f       	sbci	r25, 0xF7	; 247
    2726:	0e 94 51 03 	call	0x6a2	; 0x6a2 <vListInsertEnd>
    272a:	81 e0       	ldi	r24, 0x01	; 1
    272c:	05 c0       	rjmp	.+10     	; 0x2738 <xTaskPriorityDisinherit+0x74>
    272e:	80 e0       	ldi	r24, 0x00	; 0
    2730:	03 c0       	rjmp	.+6      	; 0x2738 <xTaskPriorityDisinherit+0x74>
    2732:	80 e0       	ldi	r24, 0x00	; 0
    2734:	01 c0       	rjmp	.+2      	; 0x2738 <xTaskPriorityDisinherit+0x74>
    2736:	80 e0       	ldi	r24, 0x00	; 0
    2738:	df 91       	pop	r29
    273a:	cf 91       	pop	r28
    273c:	1f 91       	pop	r17
    273e:	0f 91       	pop	r16
    2740:	08 95       	ret

00002742 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2742:	80 91 8d 08 	lds	r24, 0x088D
    2746:	90 91 8e 08 	lds	r25, 0x088E
    274a:	89 2b       	or	r24, r25
    274c:	39 f0       	breq	.+14     	; 0x275c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    274e:	e0 91 8d 08 	lds	r30, 0x088D
    2752:	f0 91 8e 08 	lds	r31, 0x088E
    2756:	82 a1       	ldd	r24, Z+34	; 0x22
    2758:	8f 5f       	subi	r24, 0xFF	; 255
    275a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    275c:	80 91 8d 08 	lds	r24, 0x088D
    2760:	90 91 8e 08 	lds	r25, 0x088E
	}
    2764:	08 95       	ret

00002766 <__subsf3>:
    2766:	50 58       	subi	r21, 0x80	; 128

00002768 <__addsf3>:
    2768:	bb 27       	eor	r27, r27
    276a:	aa 27       	eor	r26, r26
    276c:	0e d0       	rcall	.+28     	; 0x278a <__addsf3x>
    276e:	e5 c0       	rjmp	.+458    	; 0x293a <__fp_round>
    2770:	d6 d0       	rcall	.+428    	; 0x291e <__fp_pscA>
    2772:	30 f0       	brcs	.+12     	; 0x2780 <__addsf3+0x18>
    2774:	db d0       	rcall	.+438    	; 0x292c <__fp_pscB>
    2776:	20 f0       	brcs	.+8      	; 0x2780 <__addsf3+0x18>
    2778:	31 f4       	brne	.+12     	; 0x2786 <__addsf3+0x1e>
    277a:	9f 3f       	cpi	r25, 0xFF	; 255
    277c:	11 f4       	brne	.+4      	; 0x2782 <__addsf3+0x1a>
    277e:	1e f4       	brtc	.+6      	; 0x2786 <__addsf3+0x1e>
    2780:	cb c0       	rjmp	.+406    	; 0x2918 <__fp_nan>
    2782:	0e f4       	brtc	.+2      	; 0x2786 <__addsf3+0x1e>
    2784:	e0 95       	com	r30
    2786:	e7 fb       	bst	r30, 7
    2788:	c1 c0       	rjmp	.+386    	; 0x290c <__fp_inf>

0000278a <__addsf3x>:
    278a:	e9 2f       	mov	r30, r25
    278c:	e7 d0       	rcall	.+462    	; 0x295c <__fp_split3>
    278e:	80 f3       	brcs	.-32     	; 0x2770 <__addsf3+0x8>
    2790:	ba 17       	cp	r27, r26
    2792:	62 07       	cpc	r22, r18
    2794:	73 07       	cpc	r23, r19
    2796:	84 07       	cpc	r24, r20
    2798:	95 07       	cpc	r25, r21
    279a:	18 f0       	brcs	.+6      	; 0x27a2 <__addsf3x+0x18>
    279c:	71 f4       	brne	.+28     	; 0x27ba <__addsf3x+0x30>
    279e:	9e f5       	brtc	.+102    	; 0x2806 <__addsf3x+0x7c>
    27a0:	ff c0       	rjmp	.+510    	; 0x29a0 <__fp_zero>
    27a2:	0e f4       	brtc	.+2      	; 0x27a6 <__addsf3x+0x1c>
    27a4:	e0 95       	com	r30
    27a6:	0b 2e       	mov	r0, r27
    27a8:	ba 2f       	mov	r27, r26
    27aa:	a0 2d       	mov	r26, r0
    27ac:	0b 01       	movw	r0, r22
    27ae:	b9 01       	movw	r22, r18
    27b0:	90 01       	movw	r18, r0
    27b2:	0c 01       	movw	r0, r24
    27b4:	ca 01       	movw	r24, r20
    27b6:	a0 01       	movw	r20, r0
    27b8:	11 24       	eor	r1, r1
    27ba:	ff 27       	eor	r31, r31
    27bc:	59 1b       	sub	r21, r25
    27be:	99 f0       	breq	.+38     	; 0x27e6 <__addsf3x+0x5c>
    27c0:	59 3f       	cpi	r21, 0xF9	; 249
    27c2:	50 f4       	brcc	.+20     	; 0x27d8 <__addsf3x+0x4e>
    27c4:	50 3e       	cpi	r21, 0xE0	; 224
    27c6:	68 f1       	brcs	.+90     	; 0x2822 <__addsf3x+0x98>
    27c8:	1a 16       	cp	r1, r26
    27ca:	f0 40       	sbci	r31, 0x00	; 0
    27cc:	a2 2f       	mov	r26, r18
    27ce:	23 2f       	mov	r18, r19
    27d0:	34 2f       	mov	r19, r20
    27d2:	44 27       	eor	r20, r20
    27d4:	58 5f       	subi	r21, 0xF8	; 248
    27d6:	f3 cf       	rjmp	.-26     	; 0x27be <__addsf3x+0x34>
    27d8:	46 95       	lsr	r20
    27da:	37 95       	ror	r19
    27dc:	27 95       	ror	r18
    27de:	a7 95       	ror	r26
    27e0:	f0 40       	sbci	r31, 0x00	; 0
    27e2:	53 95       	inc	r21
    27e4:	c9 f7       	brne	.-14     	; 0x27d8 <__addsf3x+0x4e>
    27e6:	7e f4       	brtc	.+30     	; 0x2806 <__addsf3x+0x7c>
    27e8:	1f 16       	cp	r1, r31
    27ea:	ba 0b       	sbc	r27, r26
    27ec:	62 0b       	sbc	r22, r18
    27ee:	73 0b       	sbc	r23, r19
    27f0:	84 0b       	sbc	r24, r20
    27f2:	ba f0       	brmi	.+46     	; 0x2822 <__addsf3x+0x98>
    27f4:	91 50       	subi	r25, 0x01	; 1
    27f6:	a1 f0       	breq	.+40     	; 0x2820 <__addsf3x+0x96>
    27f8:	ff 0f       	add	r31, r31
    27fa:	bb 1f       	adc	r27, r27
    27fc:	66 1f       	adc	r22, r22
    27fe:	77 1f       	adc	r23, r23
    2800:	88 1f       	adc	r24, r24
    2802:	c2 f7       	brpl	.-16     	; 0x27f4 <__addsf3x+0x6a>
    2804:	0e c0       	rjmp	.+28     	; 0x2822 <__addsf3x+0x98>
    2806:	ba 0f       	add	r27, r26
    2808:	62 1f       	adc	r22, r18
    280a:	73 1f       	adc	r23, r19
    280c:	84 1f       	adc	r24, r20
    280e:	48 f4       	brcc	.+18     	; 0x2822 <__addsf3x+0x98>
    2810:	87 95       	ror	r24
    2812:	77 95       	ror	r23
    2814:	67 95       	ror	r22
    2816:	b7 95       	ror	r27
    2818:	f7 95       	ror	r31
    281a:	9e 3f       	cpi	r25, 0xFE	; 254
    281c:	08 f0       	brcs	.+2      	; 0x2820 <__addsf3x+0x96>
    281e:	b3 cf       	rjmp	.-154    	; 0x2786 <__addsf3+0x1e>
    2820:	93 95       	inc	r25
    2822:	88 0f       	add	r24, r24
    2824:	08 f0       	brcs	.+2      	; 0x2828 <__addsf3x+0x9e>
    2826:	99 27       	eor	r25, r25
    2828:	ee 0f       	add	r30, r30
    282a:	97 95       	ror	r25
    282c:	87 95       	ror	r24
    282e:	08 95       	ret

00002830 <__fixsfsi>:
    2830:	04 d0       	rcall	.+8      	; 0x283a <__fixunssfsi>
    2832:	68 94       	set
    2834:	b1 11       	cpse	r27, r1
    2836:	b5 c0       	rjmp	.+362    	; 0x29a2 <__fp_szero>
    2838:	08 95       	ret

0000283a <__fixunssfsi>:
    283a:	98 d0       	rcall	.+304    	; 0x296c <__fp_splitA>
    283c:	88 f0       	brcs	.+34     	; 0x2860 <__fixunssfsi+0x26>
    283e:	9f 57       	subi	r25, 0x7F	; 127
    2840:	90 f0       	brcs	.+36     	; 0x2866 <__fixunssfsi+0x2c>
    2842:	b9 2f       	mov	r27, r25
    2844:	99 27       	eor	r25, r25
    2846:	b7 51       	subi	r27, 0x17	; 23
    2848:	a0 f0       	brcs	.+40     	; 0x2872 <__fixunssfsi+0x38>
    284a:	d1 f0       	breq	.+52     	; 0x2880 <__fixunssfsi+0x46>
    284c:	66 0f       	add	r22, r22
    284e:	77 1f       	adc	r23, r23
    2850:	88 1f       	adc	r24, r24
    2852:	99 1f       	adc	r25, r25
    2854:	1a f0       	brmi	.+6      	; 0x285c <__fixunssfsi+0x22>
    2856:	ba 95       	dec	r27
    2858:	c9 f7       	brne	.-14     	; 0x284c <__fixunssfsi+0x12>
    285a:	12 c0       	rjmp	.+36     	; 0x2880 <__fixunssfsi+0x46>
    285c:	b1 30       	cpi	r27, 0x01	; 1
    285e:	81 f0       	breq	.+32     	; 0x2880 <__fixunssfsi+0x46>
    2860:	9f d0       	rcall	.+318    	; 0x29a0 <__fp_zero>
    2862:	b1 e0       	ldi	r27, 0x01	; 1
    2864:	08 95       	ret
    2866:	9c c0       	rjmp	.+312    	; 0x29a0 <__fp_zero>
    2868:	67 2f       	mov	r22, r23
    286a:	78 2f       	mov	r23, r24
    286c:	88 27       	eor	r24, r24
    286e:	b8 5f       	subi	r27, 0xF8	; 248
    2870:	39 f0       	breq	.+14     	; 0x2880 <__fixunssfsi+0x46>
    2872:	b9 3f       	cpi	r27, 0xF9	; 249
    2874:	cc f3       	brlt	.-14     	; 0x2868 <__fixunssfsi+0x2e>
    2876:	86 95       	lsr	r24
    2878:	77 95       	ror	r23
    287a:	67 95       	ror	r22
    287c:	b3 95       	inc	r27
    287e:	d9 f7       	brne	.-10     	; 0x2876 <__fixunssfsi+0x3c>
    2880:	3e f4       	brtc	.+14     	; 0x2890 <__fixunssfsi+0x56>
    2882:	90 95       	com	r25
    2884:	80 95       	com	r24
    2886:	70 95       	com	r23
    2888:	61 95       	neg	r22
    288a:	7f 4f       	sbci	r23, 0xFF	; 255
    288c:	8f 4f       	sbci	r24, 0xFF	; 255
    288e:	9f 4f       	sbci	r25, 0xFF	; 255
    2890:	08 95       	ret

00002892 <__floatunsisf>:
    2892:	e8 94       	clt
    2894:	09 c0       	rjmp	.+18     	; 0x28a8 <__floatsisf+0x12>

00002896 <__floatsisf>:
    2896:	97 fb       	bst	r25, 7
    2898:	3e f4       	brtc	.+14     	; 0x28a8 <__floatsisf+0x12>
    289a:	90 95       	com	r25
    289c:	80 95       	com	r24
    289e:	70 95       	com	r23
    28a0:	61 95       	neg	r22
    28a2:	7f 4f       	sbci	r23, 0xFF	; 255
    28a4:	8f 4f       	sbci	r24, 0xFF	; 255
    28a6:	9f 4f       	sbci	r25, 0xFF	; 255
    28a8:	99 23       	and	r25, r25
    28aa:	a9 f0       	breq	.+42     	; 0x28d6 <__floatsisf+0x40>
    28ac:	f9 2f       	mov	r31, r25
    28ae:	96 e9       	ldi	r25, 0x96	; 150
    28b0:	bb 27       	eor	r27, r27
    28b2:	93 95       	inc	r25
    28b4:	f6 95       	lsr	r31
    28b6:	87 95       	ror	r24
    28b8:	77 95       	ror	r23
    28ba:	67 95       	ror	r22
    28bc:	b7 95       	ror	r27
    28be:	f1 11       	cpse	r31, r1
    28c0:	f8 cf       	rjmp	.-16     	; 0x28b2 <__floatsisf+0x1c>
    28c2:	fa f4       	brpl	.+62     	; 0x2902 <__floatsisf+0x6c>
    28c4:	bb 0f       	add	r27, r27
    28c6:	11 f4       	brne	.+4      	; 0x28cc <__floatsisf+0x36>
    28c8:	60 ff       	sbrs	r22, 0
    28ca:	1b c0       	rjmp	.+54     	; 0x2902 <__floatsisf+0x6c>
    28cc:	6f 5f       	subi	r22, 0xFF	; 255
    28ce:	7f 4f       	sbci	r23, 0xFF	; 255
    28d0:	8f 4f       	sbci	r24, 0xFF	; 255
    28d2:	9f 4f       	sbci	r25, 0xFF	; 255
    28d4:	16 c0       	rjmp	.+44     	; 0x2902 <__floatsisf+0x6c>
    28d6:	88 23       	and	r24, r24
    28d8:	11 f0       	breq	.+4      	; 0x28de <__floatsisf+0x48>
    28da:	96 e9       	ldi	r25, 0x96	; 150
    28dc:	11 c0       	rjmp	.+34     	; 0x2900 <__floatsisf+0x6a>
    28de:	77 23       	and	r23, r23
    28e0:	21 f0       	breq	.+8      	; 0x28ea <__floatsisf+0x54>
    28e2:	9e e8       	ldi	r25, 0x8E	; 142
    28e4:	87 2f       	mov	r24, r23
    28e6:	76 2f       	mov	r23, r22
    28e8:	05 c0       	rjmp	.+10     	; 0x28f4 <__floatsisf+0x5e>
    28ea:	66 23       	and	r22, r22
    28ec:	71 f0       	breq	.+28     	; 0x290a <__floatsisf+0x74>
    28ee:	96 e8       	ldi	r25, 0x86	; 134
    28f0:	86 2f       	mov	r24, r22
    28f2:	70 e0       	ldi	r23, 0x00	; 0
    28f4:	60 e0       	ldi	r22, 0x00	; 0
    28f6:	2a f0       	brmi	.+10     	; 0x2902 <__floatsisf+0x6c>
    28f8:	9a 95       	dec	r25
    28fa:	66 0f       	add	r22, r22
    28fc:	77 1f       	adc	r23, r23
    28fe:	88 1f       	adc	r24, r24
    2900:	da f7       	brpl	.-10     	; 0x28f8 <__floatsisf+0x62>
    2902:	88 0f       	add	r24, r24
    2904:	96 95       	lsr	r25
    2906:	87 95       	ror	r24
    2908:	97 f9       	bld	r25, 7
    290a:	08 95       	ret

0000290c <__fp_inf>:
    290c:	97 f9       	bld	r25, 7
    290e:	9f 67       	ori	r25, 0x7F	; 127
    2910:	80 e8       	ldi	r24, 0x80	; 128
    2912:	70 e0       	ldi	r23, 0x00	; 0
    2914:	60 e0       	ldi	r22, 0x00	; 0
    2916:	08 95       	ret

00002918 <__fp_nan>:
    2918:	9f ef       	ldi	r25, 0xFF	; 255
    291a:	80 ec       	ldi	r24, 0xC0	; 192
    291c:	08 95       	ret

0000291e <__fp_pscA>:
    291e:	00 24       	eor	r0, r0
    2920:	0a 94       	dec	r0
    2922:	16 16       	cp	r1, r22
    2924:	17 06       	cpc	r1, r23
    2926:	18 06       	cpc	r1, r24
    2928:	09 06       	cpc	r0, r25
    292a:	08 95       	ret

0000292c <__fp_pscB>:
    292c:	00 24       	eor	r0, r0
    292e:	0a 94       	dec	r0
    2930:	12 16       	cp	r1, r18
    2932:	13 06       	cpc	r1, r19
    2934:	14 06       	cpc	r1, r20
    2936:	05 06       	cpc	r0, r21
    2938:	08 95       	ret

0000293a <__fp_round>:
    293a:	09 2e       	mov	r0, r25
    293c:	03 94       	inc	r0
    293e:	00 0c       	add	r0, r0
    2940:	11 f4       	brne	.+4      	; 0x2946 <__fp_round+0xc>
    2942:	88 23       	and	r24, r24
    2944:	52 f0       	brmi	.+20     	; 0x295a <__fp_round+0x20>
    2946:	bb 0f       	add	r27, r27
    2948:	40 f4       	brcc	.+16     	; 0x295a <__fp_round+0x20>
    294a:	bf 2b       	or	r27, r31
    294c:	11 f4       	brne	.+4      	; 0x2952 <__fp_round+0x18>
    294e:	60 ff       	sbrs	r22, 0
    2950:	04 c0       	rjmp	.+8      	; 0x295a <__fp_round+0x20>
    2952:	6f 5f       	subi	r22, 0xFF	; 255
    2954:	7f 4f       	sbci	r23, 0xFF	; 255
    2956:	8f 4f       	sbci	r24, 0xFF	; 255
    2958:	9f 4f       	sbci	r25, 0xFF	; 255
    295a:	08 95       	ret

0000295c <__fp_split3>:
    295c:	57 fd       	sbrc	r21, 7
    295e:	90 58       	subi	r25, 0x80	; 128
    2960:	44 0f       	add	r20, r20
    2962:	55 1f       	adc	r21, r21
    2964:	59 f0       	breq	.+22     	; 0x297c <__fp_splitA+0x10>
    2966:	5f 3f       	cpi	r21, 0xFF	; 255
    2968:	71 f0       	breq	.+28     	; 0x2986 <__fp_splitA+0x1a>
    296a:	47 95       	ror	r20

0000296c <__fp_splitA>:
    296c:	88 0f       	add	r24, r24
    296e:	97 fb       	bst	r25, 7
    2970:	99 1f       	adc	r25, r25
    2972:	61 f0       	breq	.+24     	; 0x298c <__fp_splitA+0x20>
    2974:	9f 3f       	cpi	r25, 0xFF	; 255
    2976:	79 f0       	breq	.+30     	; 0x2996 <__fp_splitA+0x2a>
    2978:	87 95       	ror	r24
    297a:	08 95       	ret
    297c:	12 16       	cp	r1, r18
    297e:	13 06       	cpc	r1, r19
    2980:	14 06       	cpc	r1, r20
    2982:	55 1f       	adc	r21, r21
    2984:	f2 cf       	rjmp	.-28     	; 0x296a <__fp_split3+0xe>
    2986:	46 95       	lsr	r20
    2988:	f1 df       	rcall	.-30     	; 0x296c <__fp_splitA>
    298a:	08 c0       	rjmp	.+16     	; 0x299c <__fp_splitA+0x30>
    298c:	16 16       	cp	r1, r22
    298e:	17 06       	cpc	r1, r23
    2990:	18 06       	cpc	r1, r24
    2992:	99 1f       	adc	r25, r25
    2994:	f1 cf       	rjmp	.-30     	; 0x2978 <__fp_splitA+0xc>
    2996:	86 95       	lsr	r24
    2998:	71 05       	cpc	r23, r1
    299a:	61 05       	cpc	r22, r1
    299c:	08 94       	sec
    299e:	08 95       	ret

000029a0 <__fp_zero>:
    29a0:	e8 94       	clt

000029a2 <__fp_szero>:
    29a2:	bb 27       	eor	r27, r27
    29a4:	66 27       	eor	r22, r22
    29a6:	77 27       	eor	r23, r23
    29a8:	cb 01       	movw	r24, r22
    29aa:	97 f9       	bld	r25, 7
    29ac:	08 95       	ret

000029ae <__mulsf3>:
    29ae:	0b d0       	rcall	.+22     	; 0x29c6 <__mulsf3x>
    29b0:	c4 cf       	rjmp	.-120    	; 0x293a <__fp_round>
    29b2:	b5 df       	rcall	.-150    	; 0x291e <__fp_pscA>
    29b4:	28 f0       	brcs	.+10     	; 0x29c0 <__mulsf3+0x12>
    29b6:	ba df       	rcall	.-140    	; 0x292c <__fp_pscB>
    29b8:	18 f0       	brcs	.+6      	; 0x29c0 <__mulsf3+0x12>
    29ba:	95 23       	and	r25, r21
    29bc:	09 f0       	breq	.+2      	; 0x29c0 <__mulsf3+0x12>
    29be:	a6 cf       	rjmp	.-180    	; 0x290c <__fp_inf>
    29c0:	ab cf       	rjmp	.-170    	; 0x2918 <__fp_nan>
    29c2:	11 24       	eor	r1, r1
    29c4:	ee cf       	rjmp	.-36     	; 0x29a2 <__fp_szero>

000029c6 <__mulsf3x>:
    29c6:	ca df       	rcall	.-108    	; 0x295c <__fp_split3>
    29c8:	a0 f3       	brcs	.-24     	; 0x29b2 <__mulsf3+0x4>

000029ca <__mulsf3_pse>:
    29ca:	95 9f       	mul	r25, r21
    29cc:	d1 f3       	breq	.-12     	; 0x29c2 <__mulsf3+0x14>
    29ce:	95 0f       	add	r25, r21
    29d0:	50 e0       	ldi	r21, 0x00	; 0
    29d2:	55 1f       	adc	r21, r21
    29d4:	62 9f       	mul	r22, r18
    29d6:	f0 01       	movw	r30, r0
    29d8:	72 9f       	mul	r23, r18
    29da:	bb 27       	eor	r27, r27
    29dc:	f0 0d       	add	r31, r0
    29de:	b1 1d       	adc	r27, r1
    29e0:	63 9f       	mul	r22, r19
    29e2:	aa 27       	eor	r26, r26
    29e4:	f0 0d       	add	r31, r0
    29e6:	b1 1d       	adc	r27, r1
    29e8:	aa 1f       	adc	r26, r26
    29ea:	64 9f       	mul	r22, r20
    29ec:	66 27       	eor	r22, r22
    29ee:	b0 0d       	add	r27, r0
    29f0:	a1 1d       	adc	r26, r1
    29f2:	66 1f       	adc	r22, r22
    29f4:	82 9f       	mul	r24, r18
    29f6:	22 27       	eor	r18, r18
    29f8:	b0 0d       	add	r27, r0
    29fa:	a1 1d       	adc	r26, r1
    29fc:	62 1f       	adc	r22, r18
    29fe:	73 9f       	mul	r23, r19
    2a00:	b0 0d       	add	r27, r0
    2a02:	a1 1d       	adc	r26, r1
    2a04:	62 1f       	adc	r22, r18
    2a06:	83 9f       	mul	r24, r19
    2a08:	a0 0d       	add	r26, r0
    2a0a:	61 1d       	adc	r22, r1
    2a0c:	22 1f       	adc	r18, r18
    2a0e:	74 9f       	mul	r23, r20
    2a10:	33 27       	eor	r19, r19
    2a12:	a0 0d       	add	r26, r0
    2a14:	61 1d       	adc	r22, r1
    2a16:	23 1f       	adc	r18, r19
    2a18:	84 9f       	mul	r24, r20
    2a1a:	60 0d       	add	r22, r0
    2a1c:	21 1d       	adc	r18, r1
    2a1e:	82 2f       	mov	r24, r18
    2a20:	76 2f       	mov	r23, r22
    2a22:	6a 2f       	mov	r22, r26
    2a24:	11 24       	eor	r1, r1
    2a26:	9f 57       	subi	r25, 0x7F	; 127
    2a28:	50 40       	sbci	r21, 0x00	; 0
    2a2a:	8a f0       	brmi	.+34     	; 0x2a4e <__mulsf3_pse+0x84>
    2a2c:	e1 f0       	breq	.+56     	; 0x2a66 <__mulsf3_pse+0x9c>
    2a2e:	88 23       	and	r24, r24
    2a30:	4a f0       	brmi	.+18     	; 0x2a44 <__mulsf3_pse+0x7a>
    2a32:	ee 0f       	add	r30, r30
    2a34:	ff 1f       	adc	r31, r31
    2a36:	bb 1f       	adc	r27, r27
    2a38:	66 1f       	adc	r22, r22
    2a3a:	77 1f       	adc	r23, r23
    2a3c:	88 1f       	adc	r24, r24
    2a3e:	91 50       	subi	r25, 0x01	; 1
    2a40:	50 40       	sbci	r21, 0x00	; 0
    2a42:	a9 f7       	brne	.-22     	; 0x2a2e <__mulsf3_pse+0x64>
    2a44:	9e 3f       	cpi	r25, 0xFE	; 254
    2a46:	51 05       	cpc	r21, r1
    2a48:	70 f0       	brcs	.+28     	; 0x2a66 <__mulsf3_pse+0x9c>
    2a4a:	60 cf       	rjmp	.-320    	; 0x290c <__fp_inf>
    2a4c:	aa cf       	rjmp	.-172    	; 0x29a2 <__fp_szero>
    2a4e:	5f 3f       	cpi	r21, 0xFF	; 255
    2a50:	ec f3       	brlt	.-6      	; 0x2a4c <__mulsf3_pse+0x82>
    2a52:	98 3e       	cpi	r25, 0xE8	; 232
    2a54:	dc f3       	brlt	.-10     	; 0x2a4c <__mulsf3_pse+0x82>
    2a56:	86 95       	lsr	r24
    2a58:	77 95       	ror	r23
    2a5a:	67 95       	ror	r22
    2a5c:	b7 95       	ror	r27
    2a5e:	f7 95       	ror	r31
    2a60:	e7 95       	ror	r30
    2a62:	9f 5f       	subi	r25, 0xFF	; 255
    2a64:	c1 f7       	brne	.-16     	; 0x2a56 <__mulsf3_pse+0x8c>
    2a66:	fe 2b       	or	r31, r30
    2a68:	88 0f       	add	r24, r24
    2a6a:	91 1d       	adc	r25, r1
    2a6c:	96 95       	lsr	r25
    2a6e:	87 95       	ror	r24
    2a70:	97 f9       	bld	r25, 7
    2a72:	08 95       	ret

00002a74 <pow>:
    2a74:	fa 01       	movw	r30, r20
    2a76:	ee 0f       	add	r30, r30
    2a78:	ff 1f       	adc	r31, r31
    2a7a:	30 96       	adiw	r30, 0x00	; 0
    2a7c:	21 05       	cpc	r18, r1
    2a7e:	31 05       	cpc	r19, r1
    2a80:	99 f1       	breq	.+102    	; 0x2ae8 <pow+0x74>
    2a82:	61 15       	cp	r22, r1
    2a84:	71 05       	cpc	r23, r1
    2a86:	61 f4       	brne	.+24     	; 0x2aa0 <pow+0x2c>
    2a88:	80 38       	cpi	r24, 0x80	; 128
    2a8a:	bf e3       	ldi	r27, 0x3F	; 63
    2a8c:	9b 07       	cpc	r25, r27
    2a8e:	49 f1       	breq	.+82     	; 0x2ae2 <pow+0x6e>
    2a90:	68 94       	set
    2a92:	90 38       	cpi	r25, 0x80	; 128
    2a94:	81 05       	cpc	r24, r1
    2a96:	61 f0       	breq	.+24     	; 0x2ab0 <pow+0x3c>
    2a98:	80 38       	cpi	r24, 0x80	; 128
    2a9a:	bf ef       	ldi	r27, 0xFF	; 255
    2a9c:	9b 07       	cpc	r25, r27
    2a9e:	41 f0       	breq	.+16     	; 0x2ab0 <pow+0x3c>
    2aa0:	99 23       	and	r25, r25
    2aa2:	42 f5       	brpl	.+80     	; 0x2af4 <pow+0x80>
    2aa4:	ff 3f       	cpi	r31, 0xFF	; 255
    2aa6:	e1 05       	cpc	r30, r1
    2aa8:	31 05       	cpc	r19, r1
    2aaa:	21 05       	cpc	r18, r1
    2aac:	11 f1       	breq	.+68     	; 0x2af2 <pow+0x7e>
    2aae:	e8 94       	clt
    2ab0:	08 94       	sec
    2ab2:	e7 95       	ror	r30
    2ab4:	d9 01       	movw	r26, r18
    2ab6:	aa 23       	and	r26, r26
    2ab8:	29 f4       	brne	.+10     	; 0x2ac4 <pow+0x50>
    2aba:	ab 2f       	mov	r26, r27
    2abc:	be 2f       	mov	r27, r30
    2abe:	f8 5f       	subi	r31, 0xF8	; 248
    2ac0:	d0 f3       	brcs	.-12     	; 0x2ab6 <pow+0x42>
    2ac2:	10 c0       	rjmp	.+32     	; 0x2ae4 <pow+0x70>
    2ac4:	ff 5f       	subi	r31, 0xFF	; 255
    2ac6:	70 f4       	brcc	.+28     	; 0x2ae4 <pow+0x70>
    2ac8:	a6 95       	lsr	r26
    2aca:	e0 f7       	brcc	.-8      	; 0x2ac4 <pow+0x50>
    2acc:	f7 39       	cpi	r31, 0x97	; 151
    2ace:	50 f0       	brcs	.+20     	; 0x2ae4 <pow+0x70>
    2ad0:	19 f0       	breq	.+6      	; 0x2ad8 <pow+0x64>
    2ad2:	ff 3a       	cpi	r31, 0xAF	; 175
    2ad4:	38 f4       	brcc	.+14     	; 0x2ae4 <pow+0x70>
    2ad6:	9f 77       	andi	r25, 0x7F	; 127
    2ad8:	9f 93       	push	r25
    2ada:	0c d0       	rcall	.+24     	; 0x2af4 <pow+0x80>
    2adc:	0f 90       	pop	r0
    2ade:	07 fc       	sbrc	r0, 7
    2ae0:	90 58       	subi	r25, 0x80	; 128
    2ae2:	08 95       	ret
    2ae4:	3e f0       	brts	.+14     	; 0x2af4 <pow+0x80>
    2ae6:	18 cf       	rjmp	.-464    	; 0x2918 <__fp_nan>
    2ae8:	60 e0       	ldi	r22, 0x00	; 0
    2aea:	70 e0       	ldi	r23, 0x00	; 0
    2aec:	80 e8       	ldi	r24, 0x80	; 128
    2aee:	9f e3       	ldi	r25, 0x3F	; 63
    2af0:	08 95       	ret
    2af2:	4f e7       	ldi	r20, 0x7F	; 127
    2af4:	9f 77       	andi	r25, 0x7F	; 127
    2af6:	5f 93       	push	r21
    2af8:	4f 93       	push	r20
    2afa:	3f 93       	push	r19
    2afc:	2f 93       	push	r18
    2afe:	9e d0       	rcall	.+316    	; 0x2c3c <log>
    2b00:	2f 91       	pop	r18
    2b02:	3f 91       	pop	r19
    2b04:	4f 91       	pop	r20
    2b06:	5f 91       	pop	r21
    2b08:	52 df       	rcall	.-348    	; 0x29ae <__mulsf3>
    2b0a:	05 c0       	rjmp	.+10     	; 0x2b16 <exp>
    2b0c:	19 f4       	brne	.+6      	; 0x2b14 <pow+0xa0>
    2b0e:	0e f0       	brts	.+2      	; 0x2b12 <pow+0x9e>
    2b10:	fd ce       	rjmp	.-518    	; 0x290c <__fp_inf>
    2b12:	46 cf       	rjmp	.-372    	; 0x29a0 <__fp_zero>
    2b14:	01 cf       	rjmp	.-510    	; 0x2918 <__fp_nan>

00002b16 <exp>:
    2b16:	2a df       	rcall	.-428    	; 0x296c <__fp_splitA>
    2b18:	c8 f3       	brcs	.-14     	; 0x2b0c <pow+0x98>
    2b1a:	96 38       	cpi	r25, 0x86	; 134
    2b1c:	c0 f7       	brcc	.-16     	; 0x2b0e <pow+0x9a>
    2b1e:	07 f8       	bld	r0, 7
    2b20:	0f 92       	push	r0
    2b22:	e8 94       	clt
    2b24:	2b e3       	ldi	r18, 0x3B	; 59
    2b26:	3a ea       	ldi	r19, 0xAA	; 170
    2b28:	48 eb       	ldi	r20, 0xB8	; 184
    2b2a:	5f e7       	ldi	r21, 0x7F	; 127
    2b2c:	4e df       	rcall	.-356    	; 0x29ca <__mulsf3_pse>
    2b2e:	0f 92       	push	r0
    2b30:	0f 92       	push	r0
    2b32:	0f 92       	push	r0
    2b34:	4d b7       	in	r20, 0x3d	; 61
    2b36:	5e b7       	in	r21, 0x3e	; 62
    2b38:	0f 92       	push	r0
    2b3a:	c0 d0       	rcall	.+384    	; 0x2cbc <modf>
    2b3c:	e4 ee       	ldi	r30, 0xE4	; 228
    2b3e:	f0 e0       	ldi	r31, 0x00	; 0
    2b40:	16 d0       	rcall	.+44     	; 0x2b6e <__fp_powser>
    2b42:	4f 91       	pop	r20
    2b44:	5f 91       	pop	r21
    2b46:	ef 91       	pop	r30
    2b48:	ff 91       	pop	r31
    2b4a:	e5 95       	asr	r30
    2b4c:	ee 1f       	adc	r30, r30
    2b4e:	ff 1f       	adc	r31, r31
    2b50:	49 f0       	breq	.+18     	; 0x2b64 <exp+0x4e>
    2b52:	fe 57       	subi	r31, 0x7E	; 126
    2b54:	e0 68       	ori	r30, 0x80	; 128
    2b56:	44 27       	eor	r20, r20
    2b58:	ee 0f       	add	r30, r30
    2b5a:	44 1f       	adc	r20, r20
    2b5c:	fa 95       	dec	r31
    2b5e:	e1 f7       	brne	.-8      	; 0x2b58 <exp+0x42>
    2b60:	41 95       	neg	r20
    2b62:	55 0b       	sbc	r21, r21
    2b64:	32 d0       	rcall	.+100    	; 0x2bca <ldexp>
    2b66:	0f 90       	pop	r0
    2b68:	07 fe       	sbrs	r0, 7
    2b6a:	26 c0       	rjmp	.+76     	; 0x2bb8 <inverse>
    2b6c:	08 95       	ret

00002b6e <__fp_powser>:
    2b6e:	df 93       	push	r29
    2b70:	cf 93       	push	r28
    2b72:	1f 93       	push	r17
    2b74:	0f 93       	push	r16
    2b76:	ff 92       	push	r15
    2b78:	ef 92       	push	r14
    2b7a:	df 92       	push	r13
    2b7c:	7b 01       	movw	r14, r22
    2b7e:	8c 01       	movw	r16, r24
    2b80:	68 94       	set
    2b82:	05 c0       	rjmp	.+10     	; 0x2b8e <__fp_powser+0x20>
    2b84:	da 2e       	mov	r13, r26
    2b86:	ef 01       	movw	r28, r30
    2b88:	1e df       	rcall	.-452    	; 0x29c6 <__mulsf3x>
    2b8a:	fe 01       	movw	r30, r28
    2b8c:	e8 94       	clt
    2b8e:	a5 91       	lpm	r26, Z+
    2b90:	25 91       	lpm	r18, Z+
    2b92:	35 91       	lpm	r19, Z+
    2b94:	45 91       	lpm	r20, Z+
    2b96:	55 91       	lpm	r21, Z+
    2b98:	ae f3       	brts	.-22     	; 0x2b84 <__fp_powser+0x16>
    2b9a:	ef 01       	movw	r28, r30
    2b9c:	f6 dd       	rcall	.-1044   	; 0x278a <__addsf3x>
    2b9e:	fe 01       	movw	r30, r28
    2ba0:	97 01       	movw	r18, r14
    2ba2:	a8 01       	movw	r20, r16
    2ba4:	da 94       	dec	r13
    2ba6:	79 f7       	brne	.-34     	; 0x2b86 <__fp_powser+0x18>
    2ba8:	df 90       	pop	r13
    2baa:	ef 90       	pop	r14
    2bac:	ff 90       	pop	r15
    2bae:	0f 91       	pop	r16
    2bb0:	1f 91       	pop	r17
    2bb2:	cf 91       	pop	r28
    2bb4:	df 91       	pop	r29
    2bb6:	08 95       	ret

00002bb8 <inverse>:
    2bb8:	9b 01       	movw	r18, r22
    2bba:	ac 01       	movw	r20, r24
    2bbc:	60 e0       	ldi	r22, 0x00	; 0
    2bbe:	70 e0       	ldi	r23, 0x00	; 0
    2bc0:	80 e8       	ldi	r24, 0x80	; 128
    2bc2:	9f e3       	ldi	r25, 0x3F	; 63
    2bc4:	ae c0       	rjmp	.+348    	; 0x2d22 <__divsf3>
    2bc6:	a2 ce       	rjmp	.-700    	; 0x290c <__fp_inf>
    2bc8:	14 c1       	rjmp	.+552    	; 0x2df2 <__fp_mpack>

00002bca <ldexp>:
    2bca:	d0 de       	rcall	.-608    	; 0x296c <__fp_splitA>
    2bcc:	e8 f3       	brcs	.-6      	; 0x2bc8 <inverse+0x10>
    2bce:	99 23       	and	r25, r25
    2bd0:	d9 f3       	breq	.-10     	; 0x2bc8 <inverse+0x10>
    2bd2:	94 0f       	add	r25, r20
    2bd4:	51 1d       	adc	r21, r1
    2bd6:	bb f3       	brvs	.-18     	; 0x2bc6 <inverse+0xe>
    2bd8:	91 50       	subi	r25, 0x01	; 1
    2bda:	50 40       	sbci	r21, 0x00	; 0
    2bdc:	94 f0       	brlt	.+36     	; 0x2c02 <ldexp+0x38>
    2bde:	59 f0       	breq	.+22     	; 0x2bf6 <ldexp+0x2c>
    2be0:	88 23       	and	r24, r24
    2be2:	32 f0       	brmi	.+12     	; 0x2bf0 <ldexp+0x26>
    2be4:	66 0f       	add	r22, r22
    2be6:	77 1f       	adc	r23, r23
    2be8:	88 1f       	adc	r24, r24
    2bea:	91 50       	subi	r25, 0x01	; 1
    2bec:	50 40       	sbci	r21, 0x00	; 0
    2bee:	c1 f7       	brne	.-16     	; 0x2be0 <ldexp+0x16>
    2bf0:	9e 3f       	cpi	r25, 0xFE	; 254
    2bf2:	51 05       	cpc	r21, r1
    2bf4:	44 f7       	brge	.-48     	; 0x2bc6 <inverse+0xe>
    2bf6:	88 0f       	add	r24, r24
    2bf8:	91 1d       	adc	r25, r1
    2bfa:	96 95       	lsr	r25
    2bfc:	87 95       	ror	r24
    2bfe:	97 f9       	bld	r25, 7
    2c00:	08 95       	ret
    2c02:	5f 3f       	cpi	r21, 0xFF	; 255
    2c04:	ac f0       	brlt	.+42     	; 0x2c30 <ldexp+0x66>
    2c06:	98 3e       	cpi	r25, 0xE8	; 232
    2c08:	9c f0       	brlt	.+38     	; 0x2c30 <ldexp+0x66>
    2c0a:	bb 27       	eor	r27, r27
    2c0c:	86 95       	lsr	r24
    2c0e:	77 95       	ror	r23
    2c10:	67 95       	ror	r22
    2c12:	b7 95       	ror	r27
    2c14:	08 f4       	brcc	.+2      	; 0x2c18 <ldexp+0x4e>
    2c16:	b1 60       	ori	r27, 0x01	; 1
    2c18:	93 95       	inc	r25
    2c1a:	c1 f7       	brne	.-16     	; 0x2c0c <ldexp+0x42>
    2c1c:	bb 0f       	add	r27, r27
    2c1e:	58 f7       	brcc	.-42     	; 0x2bf6 <ldexp+0x2c>
    2c20:	11 f4       	brne	.+4      	; 0x2c26 <ldexp+0x5c>
    2c22:	60 ff       	sbrs	r22, 0
    2c24:	e8 cf       	rjmp	.-48     	; 0x2bf6 <ldexp+0x2c>
    2c26:	6f 5f       	subi	r22, 0xFF	; 255
    2c28:	7f 4f       	sbci	r23, 0xFF	; 255
    2c2a:	8f 4f       	sbci	r24, 0xFF	; 255
    2c2c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c2e:	e3 cf       	rjmp	.-58     	; 0x2bf6 <ldexp+0x2c>
    2c30:	b8 ce       	rjmp	.-656    	; 0x29a2 <__fp_szero>
    2c32:	0e f0       	brts	.+2      	; 0x2c36 <ldexp+0x6c>
    2c34:	de c0       	rjmp	.+444    	; 0x2df2 <__fp_mpack>
    2c36:	70 ce       	rjmp	.-800    	; 0x2918 <__fp_nan>
    2c38:	68 94       	set
    2c3a:	68 ce       	rjmp	.-816    	; 0x290c <__fp_inf>

00002c3c <log>:
    2c3c:	97 de       	rcall	.-722    	; 0x296c <__fp_splitA>
    2c3e:	c8 f3       	brcs	.-14     	; 0x2c32 <ldexp+0x68>
    2c40:	99 23       	and	r25, r25
    2c42:	d1 f3       	breq	.-12     	; 0x2c38 <ldexp+0x6e>
    2c44:	c6 f3       	brts	.-16     	; 0x2c36 <ldexp+0x6c>
    2c46:	df 93       	push	r29
    2c48:	cf 93       	push	r28
    2c4a:	1f 93       	push	r17
    2c4c:	0f 93       	push	r16
    2c4e:	ff 92       	push	r15
    2c50:	c9 2f       	mov	r28, r25
    2c52:	dd 27       	eor	r29, r29
    2c54:	88 23       	and	r24, r24
    2c56:	2a f0       	brmi	.+10     	; 0x2c62 <log+0x26>
    2c58:	21 97       	sbiw	r28, 0x01	; 1
    2c5a:	66 0f       	add	r22, r22
    2c5c:	77 1f       	adc	r23, r23
    2c5e:	88 1f       	adc	r24, r24
    2c60:	da f7       	brpl	.-10     	; 0x2c58 <log+0x1c>
    2c62:	20 e0       	ldi	r18, 0x00	; 0
    2c64:	30 e0       	ldi	r19, 0x00	; 0
    2c66:	40 e8       	ldi	r20, 0x80	; 128
    2c68:	5f eb       	ldi	r21, 0xBF	; 191
    2c6a:	9f e3       	ldi	r25, 0x3F	; 63
    2c6c:	88 39       	cpi	r24, 0x98	; 152
    2c6e:	20 f0       	brcs	.+8      	; 0x2c78 <log+0x3c>
    2c70:	80 3e       	cpi	r24, 0xE0	; 224
    2c72:	30 f0       	brcs	.+12     	; 0x2c80 <log+0x44>
    2c74:	21 96       	adiw	r28, 0x01	; 1
    2c76:	8f 77       	andi	r24, 0x7F	; 127
    2c78:	77 dd       	rcall	.-1298   	; 0x2768 <__addsf3>
    2c7a:	ec e0       	ldi	r30, 0x0C	; 12
    2c7c:	f1 e0       	ldi	r31, 0x01	; 1
    2c7e:	03 c0       	rjmp	.+6      	; 0x2c86 <log+0x4a>
    2c80:	73 dd       	rcall	.-1306   	; 0x2768 <__addsf3>
    2c82:	e9 e3       	ldi	r30, 0x39	; 57
    2c84:	f1 e0       	ldi	r31, 0x01	; 1
    2c86:	73 df       	rcall	.-282    	; 0x2b6e <__fp_powser>
    2c88:	8b 01       	movw	r16, r22
    2c8a:	be 01       	movw	r22, r28
    2c8c:	ec 01       	movw	r28, r24
    2c8e:	fb 2e       	mov	r15, r27
    2c90:	6f 57       	subi	r22, 0x7F	; 127
    2c92:	71 09       	sbc	r23, r1
    2c94:	75 95       	asr	r23
    2c96:	77 1f       	adc	r23, r23
    2c98:	88 0b       	sbc	r24, r24
    2c9a:	99 0b       	sbc	r25, r25
    2c9c:	fc dd       	rcall	.-1032   	; 0x2896 <__floatsisf>
    2c9e:	28 e1       	ldi	r18, 0x18	; 24
    2ca0:	32 e7       	ldi	r19, 0x72	; 114
    2ca2:	41 e3       	ldi	r20, 0x31	; 49
    2ca4:	5f e3       	ldi	r21, 0x3F	; 63
    2ca6:	8f de       	rcall	.-738    	; 0x29c6 <__mulsf3x>
    2ca8:	af 2d       	mov	r26, r15
    2caa:	98 01       	movw	r18, r16
    2cac:	ae 01       	movw	r20, r28
    2cae:	ff 90       	pop	r15
    2cb0:	0f 91       	pop	r16
    2cb2:	1f 91       	pop	r17
    2cb4:	cf 91       	pop	r28
    2cb6:	df 91       	pop	r29
    2cb8:	68 dd       	rcall	.-1328   	; 0x278a <__addsf3x>
    2cba:	3f ce       	rjmp	.-898    	; 0x293a <__fp_round>

00002cbc <modf>:
    2cbc:	fa 01       	movw	r30, r20
    2cbe:	dc 01       	movw	r26, r24
    2cc0:	aa 0f       	add	r26, r26
    2cc2:	bb 1f       	adc	r27, r27
    2cc4:	9b 01       	movw	r18, r22
    2cc6:	ac 01       	movw	r20, r24
    2cc8:	bf 57       	subi	r27, 0x7F	; 127
    2cca:	28 f4       	brcc	.+10     	; 0x2cd6 <modf+0x1a>
    2ccc:	22 27       	eor	r18, r18
    2cce:	33 27       	eor	r19, r19
    2cd0:	44 27       	eor	r20, r20
    2cd2:	50 78       	andi	r21, 0x80	; 128
    2cd4:	1f c0       	rjmp	.+62     	; 0x2d14 <modf+0x58>
    2cd6:	b7 51       	subi	r27, 0x17	; 23
    2cd8:	88 f4       	brcc	.+34     	; 0x2cfc <modf+0x40>
    2cda:	ab 2f       	mov	r26, r27
    2cdc:	00 24       	eor	r0, r0
    2cde:	46 95       	lsr	r20
    2ce0:	37 95       	ror	r19
    2ce2:	27 95       	ror	r18
    2ce4:	01 1c       	adc	r0, r1
    2ce6:	a3 95       	inc	r26
    2ce8:	d2 f3       	brmi	.-12     	; 0x2cde <modf+0x22>
    2cea:	00 20       	and	r0, r0
    2cec:	69 f0       	breq	.+26     	; 0x2d08 <modf+0x4c>
    2cee:	22 0f       	add	r18, r18
    2cf0:	33 1f       	adc	r19, r19
    2cf2:	44 1f       	adc	r20, r20
    2cf4:	b3 95       	inc	r27
    2cf6:	da f3       	brmi	.-10     	; 0x2cee <modf+0x32>
    2cf8:	0d d0       	rcall	.+26     	; 0x2d14 <modf+0x58>
    2cfa:	35 cd       	rjmp	.-1430   	; 0x2766 <__subsf3>
    2cfc:	61 30       	cpi	r22, 0x01	; 1
    2cfe:	71 05       	cpc	r23, r1
    2d00:	a0 e8       	ldi	r26, 0x80	; 128
    2d02:	8a 07       	cpc	r24, r26
    2d04:	b9 46       	sbci	r27, 0x69	; 105
    2d06:	30 f4       	brcc	.+12     	; 0x2d14 <modf+0x58>
    2d08:	9b 01       	movw	r18, r22
    2d0a:	ac 01       	movw	r20, r24
    2d0c:	66 27       	eor	r22, r22
    2d0e:	77 27       	eor	r23, r23
    2d10:	88 27       	eor	r24, r24
    2d12:	90 78       	andi	r25, 0x80	; 128
    2d14:	30 96       	adiw	r30, 0x00	; 0
    2d16:	21 f0       	breq	.+8      	; 0x2d20 <modf+0x64>
    2d18:	20 83       	st	Z, r18
    2d1a:	31 83       	std	Z+1, r19	; 0x01
    2d1c:	42 83       	std	Z+2, r20	; 0x02
    2d1e:	53 83       	std	Z+3, r21	; 0x03
    2d20:	08 95       	ret

00002d22 <__divsf3>:
    2d22:	0c d0       	rcall	.+24     	; 0x2d3c <__divsf3x>
    2d24:	0a ce       	rjmp	.-1004   	; 0x293a <__fp_round>
    2d26:	02 de       	rcall	.-1020   	; 0x292c <__fp_pscB>
    2d28:	40 f0       	brcs	.+16     	; 0x2d3a <__divsf3+0x18>
    2d2a:	f9 dd       	rcall	.-1038   	; 0x291e <__fp_pscA>
    2d2c:	30 f0       	brcs	.+12     	; 0x2d3a <__divsf3+0x18>
    2d2e:	21 f4       	brne	.+8      	; 0x2d38 <__divsf3+0x16>
    2d30:	5f 3f       	cpi	r21, 0xFF	; 255
    2d32:	19 f0       	breq	.+6      	; 0x2d3a <__divsf3+0x18>
    2d34:	eb cd       	rjmp	.-1066   	; 0x290c <__fp_inf>
    2d36:	51 11       	cpse	r21, r1
    2d38:	34 ce       	rjmp	.-920    	; 0x29a2 <__fp_szero>
    2d3a:	ee cd       	rjmp	.-1060   	; 0x2918 <__fp_nan>

00002d3c <__divsf3x>:
    2d3c:	0f de       	rcall	.-994    	; 0x295c <__fp_split3>
    2d3e:	98 f3       	brcs	.-26     	; 0x2d26 <__divsf3+0x4>

00002d40 <__divsf3_pse>:
    2d40:	99 23       	and	r25, r25
    2d42:	c9 f3       	breq	.-14     	; 0x2d36 <__divsf3+0x14>
    2d44:	55 23       	and	r21, r21
    2d46:	b1 f3       	breq	.-20     	; 0x2d34 <__divsf3+0x12>
    2d48:	95 1b       	sub	r25, r21
    2d4a:	55 0b       	sbc	r21, r21
    2d4c:	bb 27       	eor	r27, r27
    2d4e:	aa 27       	eor	r26, r26
    2d50:	62 17       	cp	r22, r18
    2d52:	73 07       	cpc	r23, r19
    2d54:	84 07       	cpc	r24, r20
    2d56:	38 f0       	brcs	.+14     	; 0x2d66 <__divsf3_pse+0x26>
    2d58:	9f 5f       	subi	r25, 0xFF	; 255
    2d5a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d5c:	22 0f       	add	r18, r18
    2d5e:	33 1f       	adc	r19, r19
    2d60:	44 1f       	adc	r20, r20
    2d62:	aa 1f       	adc	r26, r26
    2d64:	a9 f3       	breq	.-22     	; 0x2d50 <__divsf3_pse+0x10>
    2d66:	33 d0       	rcall	.+102    	; 0x2dce <__divsf3_pse+0x8e>
    2d68:	0e 2e       	mov	r0, r30
    2d6a:	3a f0       	brmi	.+14     	; 0x2d7a <__divsf3_pse+0x3a>
    2d6c:	e0 e8       	ldi	r30, 0x80	; 128
    2d6e:	30 d0       	rcall	.+96     	; 0x2dd0 <__divsf3_pse+0x90>
    2d70:	91 50       	subi	r25, 0x01	; 1
    2d72:	50 40       	sbci	r21, 0x00	; 0
    2d74:	e6 95       	lsr	r30
    2d76:	00 1c       	adc	r0, r0
    2d78:	ca f7       	brpl	.-14     	; 0x2d6c <__divsf3_pse+0x2c>
    2d7a:	29 d0       	rcall	.+82     	; 0x2dce <__divsf3_pse+0x8e>
    2d7c:	fe 2f       	mov	r31, r30
    2d7e:	27 d0       	rcall	.+78     	; 0x2dce <__divsf3_pse+0x8e>
    2d80:	66 0f       	add	r22, r22
    2d82:	77 1f       	adc	r23, r23
    2d84:	88 1f       	adc	r24, r24
    2d86:	bb 1f       	adc	r27, r27
    2d88:	26 17       	cp	r18, r22
    2d8a:	37 07       	cpc	r19, r23
    2d8c:	48 07       	cpc	r20, r24
    2d8e:	ab 07       	cpc	r26, r27
    2d90:	b0 e8       	ldi	r27, 0x80	; 128
    2d92:	09 f0       	breq	.+2      	; 0x2d96 <__divsf3_pse+0x56>
    2d94:	bb 0b       	sbc	r27, r27
    2d96:	80 2d       	mov	r24, r0
    2d98:	bf 01       	movw	r22, r30
    2d9a:	ff 27       	eor	r31, r31
    2d9c:	93 58       	subi	r25, 0x83	; 131
    2d9e:	5f 4f       	sbci	r21, 0xFF	; 255
    2da0:	2a f0       	brmi	.+10     	; 0x2dac <__divsf3_pse+0x6c>
    2da2:	9e 3f       	cpi	r25, 0xFE	; 254
    2da4:	51 05       	cpc	r21, r1
    2da6:	68 f0       	brcs	.+26     	; 0x2dc2 <__divsf3_pse+0x82>
    2da8:	b1 cd       	rjmp	.-1182   	; 0x290c <__fp_inf>
    2daa:	fb cd       	rjmp	.-1034   	; 0x29a2 <__fp_szero>
    2dac:	5f 3f       	cpi	r21, 0xFF	; 255
    2dae:	ec f3       	brlt	.-6      	; 0x2daa <__divsf3_pse+0x6a>
    2db0:	98 3e       	cpi	r25, 0xE8	; 232
    2db2:	dc f3       	brlt	.-10     	; 0x2daa <__divsf3_pse+0x6a>
    2db4:	86 95       	lsr	r24
    2db6:	77 95       	ror	r23
    2db8:	67 95       	ror	r22
    2dba:	b7 95       	ror	r27
    2dbc:	f7 95       	ror	r31
    2dbe:	9f 5f       	subi	r25, 0xFF	; 255
    2dc0:	c9 f7       	brne	.-14     	; 0x2db4 <__divsf3_pse+0x74>
    2dc2:	88 0f       	add	r24, r24
    2dc4:	91 1d       	adc	r25, r1
    2dc6:	96 95       	lsr	r25
    2dc8:	87 95       	ror	r24
    2dca:	97 f9       	bld	r25, 7
    2dcc:	08 95       	ret
    2dce:	e1 e0       	ldi	r30, 0x01	; 1
    2dd0:	66 0f       	add	r22, r22
    2dd2:	77 1f       	adc	r23, r23
    2dd4:	88 1f       	adc	r24, r24
    2dd6:	bb 1f       	adc	r27, r27
    2dd8:	62 17       	cp	r22, r18
    2dda:	73 07       	cpc	r23, r19
    2ddc:	84 07       	cpc	r24, r20
    2dde:	ba 07       	cpc	r27, r26
    2de0:	20 f0       	brcs	.+8      	; 0x2dea <__divsf3_pse+0xaa>
    2de2:	62 1b       	sub	r22, r18
    2de4:	73 0b       	sbc	r23, r19
    2de6:	84 0b       	sbc	r24, r20
    2de8:	ba 0b       	sbc	r27, r26
    2dea:	ee 1f       	adc	r30, r30
    2dec:	88 f7       	brcc	.-30     	; 0x2dd0 <__divsf3_pse+0x90>
    2dee:	e0 95       	com	r30
    2df0:	08 95       	ret

00002df2 <__fp_mpack>:
    2df2:	9f 3f       	cpi	r25, 0xFF	; 255
    2df4:	31 f0       	breq	.+12     	; 0x2e02 <__fp_mpack_finite+0xc>

00002df6 <__fp_mpack_finite>:
    2df6:	91 50       	subi	r25, 0x01	; 1
    2df8:	20 f4       	brcc	.+8      	; 0x2e02 <__fp_mpack_finite+0xc>
    2dfa:	87 95       	ror	r24
    2dfc:	77 95       	ror	r23
    2dfe:	67 95       	ror	r22
    2e00:	b7 95       	ror	r27
    2e02:	88 0f       	add	r24, r24
    2e04:	91 1d       	adc	r25, r1
    2e06:	96 95       	lsr	r25
    2e08:	87 95       	ror	r24
    2e0a:	97 f9       	bld	r25, 7
    2e0c:	08 95       	ret

00002e0e <__divmodhi4>:
    2e0e:	97 fb       	bst	r25, 7
    2e10:	07 2e       	mov	r0, r23
    2e12:	16 f4       	brtc	.+4      	; 0x2e18 <__divmodhi4+0xa>
    2e14:	00 94       	com	r0
    2e16:	06 d0       	rcall	.+12     	; 0x2e24 <__divmodhi4_neg1>
    2e18:	77 fd       	sbrc	r23, 7
    2e1a:	08 d0       	rcall	.+16     	; 0x2e2c <__divmodhi4_neg2>
    2e1c:	0b d0       	rcall	.+22     	; 0x2e34 <__udivmodhi4>
    2e1e:	07 fc       	sbrc	r0, 7
    2e20:	05 d0       	rcall	.+10     	; 0x2e2c <__divmodhi4_neg2>
    2e22:	3e f4       	brtc	.+14     	; 0x2e32 <__divmodhi4_exit>

00002e24 <__divmodhi4_neg1>:
    2e24:	90 95       	com	r25
    2e26:	81 95       	neg	r24
    2e28:	9f 4f       	sbci	r25, 0xFF	; 255
    2e2a:	08 95       	ret

00002e2c <__divmodhi4_neg2>:
    2e2c:	70 95       	com	r23
    2e2e:	61 95       	neg	r22
    2e30:	7f 4f       	sbci	r23, 0xFF	; 255

00002e32 <__divmodhi4_exit>:
    2e32:	08 95       	ret

00002e34 <__udivmodhi4>:
    2e34:	aa 1b       	sub	r26, r26
    2e36:	bb 1b       	sub	r27, r27
    2e38:	51 e1       	ldi	r21, 0x11	; 17
    2e3a:	07 c0       	rjmp	.+14     	; 0x2e4a <__udivmodhi4_ep>

00002e3c <__udivmodhi4_loop>:
    2e3c:	aa 1f       	adc	r26, r26
    2e3e:	bb 1f       	adc	r27, r27
    2e40:	a6 17       	cp	r26, r22
    2e42:	b7 07       	cpc	r27, r23
    2e44:	10 f0       	brcs	.+4      	; 0x2e4a <__udivmodhi4_ep>
    2e46:	a6 1b       	sub	r26, r22
    2e48:	b7 0b       	sbc	r27, r23

00002e4a <__udivmodhi4_ep>:
    2e4a:	88 1f       	adc	r24, r24
    2e4c:	99 1f       	adc	r25, r25
    2e4e:	5a 95       	dec	r21
    2e50:	a9 f7       	brne	.-22     	; 0x2e3c <__udivmodhi4_loop>
    2e52:	80 95       	com	r24
    2e54:	90 95       	com	r25
    2e56:	bc 01       	movw	r22, r24
    2e58:	cd 01       	movw	r24, r26
    2e5a:	08 95       	ret

00002e5c <memcpy>:
    2e5c:	fb 01       	movw	r30, r22
    2e5e:	dc 01       	movw	r26, r24
    2e60:	02 c0       	rjmp	.+4      	; 0x2e66 <memcpy+0xa>
    2e62:	01 90       	ld	r0, Z+
    2e64:	0d 92       	st	X+, r0
    2e66:	41 50       	subi	r20, 0x01	; 1
    2e68:	50 40       	sbci	r21, 0x00	; 0
    2e6a:	d8 f7       	brcc	.-10     	; 0x2e62 <memcpy+0x6>
    2e6c:	08 95       	ret

00002e6e <__itoa_ncheck>:
    2e6e:	bb 27       	eor	r27, r27
    2e70:	4a 30       	cpi	r20, 0x0A	; 10
    2e72:	31 f4       	brne	.+12     	; 0x2e80 <__itoa_ncheck+0x12>
    2e74:	99 23       	and	r25, r25
    2e76:	22 f4       	brpl	.+8      	; 0x2e80 <__itoa_ncheck+0x12>
    2e78:	bd e2       	ldi	r27, 0x2D	; 45
    2e7a:	90 95       	com	r25
    2e7c:	81 95       	neg	r24
    2e7e:	9f 4f       	sbci	r25, 0xFF	; 255
    2e80:	01 c0       	rjmp	.+2      	; 0x2e84 <__utoa_common>

00002e82 <__utoa_ncheck>:
    2e82:	bb 27       	eor	r27, r27

00002e84 <__utoa_common>:
    2e84:	fb 01       	movw	r30, r22
    2e86:	55 27       	eor	r21, r21
    2e88:	aa 27       	eor	r26, r26
    2e8a:	88 0f       	add	r24, r24
    2e8c:	99 1f       	adc	r25, r25
    2e8e:	aa 1f       	adc	r26, r26
    2e90:	a4 17       	cp	r26, r20
    2e92:	10 f0       	brcs	.+4      	; 0x2e98 <__utoa_common+0x14>
    2e94:	a4 1b       	sub	r26, r20
    2e96:	83 95       	inc	r24
    2e98:	50 51       	subi	r21, 0x10	; 16
    2e9a:	b9 f7       	brne	.-18     	; 0x2e8a <__utoa_common+0x6>
    2e9c:	a0 5d       	subi	r26, 0xD0	; 208
    2e9e:	aa 33       	cpi	r26, 0x3A	; 58
    2ea0:	08 f0       	brcs	.+2      	; 0x2ea4 <__utoa_common+0x20>
    2ea2:	a9 5d       	subi	r26, 0xD9	; 217
    2ea4:	a1 93       	st	Z+, r26
    2ea6:	00 97       	sbiw	r24, 0x00	; 0
    2ea8:	79 f7       	brne	.-34     	; 0x2e88 <__utoa_common+0x4>
    2eaa:	b1 11       	cpse	r27, r1
    2eac:	b1 93       	st	Z+, r27
    2eae:	11 92       	st	Z+, r1
    2eb0:	cb 01       	movw	r24, r22
    2eb2:	00 c0       	rjmp	.+0      	; 0x2eb4 <strrev>

00002eb4 <strrev>:
    2eb4:	dc 01       	movw	r26, r24
    2eb6:	fc 01       	movw	r30, r24
    2eb8:	67 2f       	mov	r22, r23
    2eba:	71 91       	ld	r23, Z+
    2ebc:	77 23       	and	r23, r23
    2ebe:	e1 f7       	brne	.-8      	; 0x2eb8 <strrev+0x4>
    2ec0:	32 97       	sbiw	r30, 0x02	; 2
    2ec2:	04 c0       	rjmp	.+8      	; 0x2ecc <strrev+0x18>
    2ec4:	7c 91       	ld	r23, X
    2ec6:	6d 93       	st	X+, r22
    2ec8:	70 83       	st	Z, r23
    2eca:	62 91       	ld	r22, -Z
    2ecc:	ae 17       	cp	r26, r30
    2ece:	bf 07       	cpc	r27, r31
    2ed0:	c8 f3       	brcs	.-14     	; 0x2ec4 <strrev+0x10>
    2ed2:	08 95       	ret

00002ed4 <_exit>:
    2ed4:	f8 94       	cli

00002ed6 <__stop_program>:
    2ed6:	ff cf       	rjmp	.-2      	; 0x2ed6 <__stop_program>
