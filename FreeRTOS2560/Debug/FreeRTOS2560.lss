
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002ce2  00002d76  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ce2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000709  0080023e  0080023e  00002db4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002db4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000540  00000000  00000000  00002de4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005c58  00000000  00000000  00003324  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001679  00000000  00000000  00008f7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003707  00000000  00000000  0000a5f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000eb8  00000000  00000000  0000dcfc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001697  00000000  00000000  0000ebb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003f58  00000000  00000000  0001024b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004d0  00000000  00000000  000141a3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	49 c3       	rjmp	.+1682   	; 0x6b8 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 c0 09 	jmp	0x1380	; 0x1380 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	78 c6       	rjmp	.+3312   	; 0xd56 <__vector_25>
      66:	00 00       	nop
      68:	e4 c6       	rjmp	.+3528   	; 0xe32 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	d0 c3       	rjmp	.+1952   	; 0x816 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2a c6       	rjmp	.+3156   	; 0xce6 <__vector_36>
      92:	00 00       	nop
      94:	98 c6       	rjmp	.+3376   	; 0xdc6 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myADC_analogRead+0x6>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e2 ee       	ldi	r30, 0xE2	; 226
     17e:	fc e2       	ldi	r31, 0x2C	; 44
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 34       	cpi	r26, 0x47	; 71
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c5 d0       	rcall	.+394    	; 0x32c <main>
     1a2:	0c 94 6f 16 	jmp	0x2cde	; 0x2cde <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	59 d7       	rcall	.+3762   	; 0x105c <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	45 d7       	rcall	.+3722   	; 0x1038 <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	07 d7       	rcall	.+3598   	; 0xfc2 <myUSART_receiveUSART1>
     1b4:	36 d7       	rcall	.+3692   	; 0x1022 <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	4a d7       	rcall	.+3732   	; 0x1050 <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	11 f0       	breq	.+4      	; 0x1c4 <RPI_receiveTask+0x1c>
     1c0:	00 d7       	rcall	.+3584   	; 0xfc2 <myUSART_receiveUSART1>
     1c2:	f2 cf       	rjmp	.-28     	; 0x1a8 <RPI_receiveTask>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	3e d7       	rcall	.+3708   	; 0x1044 <myUSART_receiveHandShakeStart>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <RPI_receiveTask+0x28>
     1cc:	1b d7       	rcall	.+3638   	; 0x1004 <myUSART_waitForHandshake>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	f8 d6       	rcall	.+3568   	; 0xfc2 <myUSART_receiveUSART1>
     1d2:	ea cf       	rjmp	.-44     	; 0x1a8 <RPI_receiveTask>

000001d4 <RPI_sendTask>:
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <RPI_sendTask+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <RPI_sendTask+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	4f ef       	ldi	r20, 0xFF	; 255
     1e4:	5f ef       	ldi	r21, 0xFF	; 255
     1e6:	be 01       	movw	r22, r28
     1e8:	6a 5f       	subi	r22, 0xFA	; 250
     1ea:	7f 4f       	sbci	r23, 0xFF	; 255
     1ec:	80 91 8f 08 	lds	r24, 0x088F
     1f0:	90 91 90 08 	lds	r25, 0x0890
     1f4:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xQueueGenericReceive>
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	80 5d       	subi	r24, 0xD0	; 208
     1fc:	af d6       	rcall	.+3422   	; 0xf5c <myUSART_transmitUSART1_c>
     1fe:	8a e0       	ldi	r24, 0x0A	; 10
     200:	ad d6       	rcall	.+3418   	; 0xf5c <myUSART_transmitUSART1_c>
     202:	8e 81       	ldd	r24, Y+6	; 0x06
     204:	9f ef       	ldi	r25, 0xFF	; 255
     206:	98 0f       	add	r25, r24
     208:	9e 83       	std	Y+6, r25	; 0x06
     20a:	88 23       	and	r24, r24
     20c:	21 f1       	breq	.+72     	; 0x256 <RPI_sendTask+0x82>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	4f ef       	ldi	r20, 0xFF	; 255
     212:	5f ef       	ldi	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 91 08 	lds	r24, 0x0891
     21e:	90 91 92 08 	lds	r25, 0x0892
     222:	0e 94 e2 0b 	call	0x17c4	; 0x17c4 <xQueueGenericReceive>
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	82 d6       	rcall	.+3332   	; 0xf2e <myUSART_transmitUSART0_c>
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	97 d6       	rcall	.+3374   	; 0xf5c <myUSART_transmitUSART1_c>
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	92 e0       	ldi	r25, 0x02	; 2
     232:	b9 d6       	rcall	.+3442   	; 0xfa6 <myUSART_transmitUSART0>
     234:	ce 01       	movw	r24, r28
     236:	02 96       	adiw	r24, 0x02	; 2
     238:	b6 d6       	rcall	.+3436   	; 0xfa6 <myUSART_transmitUSART0>
     23a:	ce 01       	movw	r24, r28
     23c:	02 96       	adiw	r24, 0x02	; 2
     23e:	a5 d6       	rcall	.+3402   	; 0xf8a <myUSART_transmitUSART1>
     240:	8a e0       	ldi	r24, 0x0A	; 10
     242:	8c d6       	rcall	.+3352   	; 0xf5c <myUSART_transmitUSART1_c>
     244:	89 e0       	ldi	r24, 0x09	; 9
     246:	92 e0       	ldi	r25, 0x02	; 2
     248:	ae d6       	rcall	.+3420   	; 0xfa6 <myUSART_transmitUSART0>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f ef       	ldi	r25, 0xFF	; 255
     24e:	98 0f       	add	r25, r24
     250:	9e 83       	std	Y+6, r25	; 0x06
     252:	81 11       	cpse	r24, r1
     254:	dc cf       	rjmp	.-72     	; 0x20e <RPI_sendTask+0x3a>
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	6a d6       	rcall	.+3284   	; 0xf2e <myUSART_transmitUSART0_c>
     25a:	c2 cf       	rjmp	.-124    	; 0x1e0 <RPI_sendTask+0xc>

0000025c <myTimerTask>:
     25c:	95 d4       	rcall	.+2346   	; 0xb88 <myTimer_Init>
     25e:	d4 d4       	rcall	.+2472   	; 0xc08 <myTimer_DelayChecker>
     260:	fe cf       	rjmp	.-4      	; 0x25e <myTimerTask+0x2>

00000262 <task1>:
     262:	26 9a       	sbi	0x04, 6	; 4
     264:	2e 9a       	sbi	0x05, 6	; 5
     266:	88 ee       	ldi	r24, 0xE8	; 232
     268:	93 e0       	ldi	r25, 0x03	; 3
     26a:	0e 94 4f 10 	call	0x209e	; 0x209e <vTaskDelay>
     26e:	85 b1       	in	r24, 0x05	; 5
     270:	15 b8       	out	0x05, r1	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 4f 10 	call	0x209e	; 0x209e <vTaskDelay>
     27a:	f4 cf       	rjmp	.-24     	; 0x264 <task1+0x2>

0000027c <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     27c:	8f ef       	ldi	r24, 0xFF	; 255
     27e:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     282:	ef e7       	ldi	r30, 0x7F	; 127
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	90 81       	ld	r25, Z
     288:	93 60       	ori	r25, 0x03	; 3
     28a:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     28c:	80 93 7d 00 	sts	0x007D, r24
     290:	08 95       	ret

00000292 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     292:	8c ec       	ldi	r24, 0xCC	; 204
     294:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     298:	8e e3       	ldi	r24, 0x3E	; 62
     29a:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     29e:	ee cf       	rjmp	.-36     	; 0x27c <setDigitalInputPowerReduction>
     2a0:	08 95       	ret

000002a2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2a2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2a6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2aa:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ae:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2b2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2b6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ba:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2be:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2c2:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2c6:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2ca:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2ce:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2d2:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2d6:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2da:	10 92 73 00 	sts	0x0073, r1
     2de:	08 95       	ret

000002e0 <init>:
}

void init()
{
     2e0:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2e2:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2e4:	f8 94       	cli
	{
		clearTimer();
     2e6:	dd df       	rcall	.-70     	; 0x2a2 <clearTimer>
		setPowerReduction();
     2e8:	d4 df       	rcall	.-88     	; 0x292 <setPowerReduction>
		myUSART_USART0_Init();
     2ea:	d9 d5       	rcall	.+2994   	; 0xe9e <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2ec:	f8 d5       	rcall	.+3056   	; 0xede <myUSART_USART1_Init>
		myADC_Init();
     2ee:	cb d2       	rcall	.+1430   	; 0x886 <myADC_Init>
		MaxSonar_Init();
     2f0:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     2f2:	6c d2       	rcall	.+1240   	; 0x7cc <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2f4:	40 e0       	ldi	r20, 0x00	; 0
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	85 e0       	ldi	r24, 0x05	; 5
     2fa:	0e 94 bd 0a 	call	0x157a	; 0x157a <xQueueGenericCreate>
     2fe:	90 93 90 08 	sts	0x0890, r25
     302:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     306:	40 e0       	ldi	r20, 0x00	; 0
     308:	65 e0       	ldi	r22, 0x05	; 5
     30a:	84 e1       	ldi	r24, 0x14	; 20
     30c:	0e 94 bd 0a 	call	0x157a	; 0x157a <xQueueGenericCreate>
     310:	90 93 92 08 	sts	0x0892, r25
     314:	80 93 91 08 	sts	0x0891, r24
		
		MOTOR_LEFT_INIT();
     318:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     31a:	e1 e0       	ldi	r30, 0x01	; 1
     31c:	f1 e0       	ldi	r31, 0x01	; 1
     31e:	80 81       	ld	r24, Z
     320:	80 61       	ori	r24, 0x10	; 16
     322:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     324:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     326:	78 94       	sei
}
     328:	cf 91       	pop	r28
     32a:	08 95       	ret

0000032c <main>:
	
	// do nth
}

int main(void)
{
     32c:	cf 93       	push	r28
     32e:	df 93       	push	r29
     330:	cd b7       	in	r28, 0x3d	; 61
     332:	de b7       	in	r29, 0x3e	; 62
     334:	2a 97       	sbiw	r28, 0x0a	; 10
     336:	0f b6       	in	r0, 0x3f	; 63
     338:	f8 94       	cli
     33a:	de bf       	out	0x3e, r29	; 62
     33c:	0f be       	out	0x3f, r0	; 63
     33e:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     340:	cf df       	rcall	.-98     	; 0x2e0 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     342:	a1 2c       	mov	r10, r1
     344:	b1 2c       	mov	r11, r1
     346:	c1 2c       	mov	r12, r1
     348:	d1 2c       	mov	r13, r1
     34a:	ce 01       	movw	r24, r28
     34c:	01 96       	adiw	r24, 0x01	; 1
     34e:	7c 01       	movw	r14, r24
     350:	01 e0       	ldi	r16, 0x01	; 1
     352:	20 e0       	ldi	r18, 0x00	; 0
     354:	30 e0       	ldi	r19, 0x00	; 0
     356:	45 e5       	ldi	r20, 0x55	; 85
     358:	50 e0       	ldi	r21, 0x00	; 0
     35a:	6c e0       	ldi	r22, 0x0C	; 12
     35c:	72 e0       	ldi	r23, 0x02	; 2
     35e:	81 e3       	ldi	r24, 0x31	; 49
     360:	91 e0       	ldi	r25, 0x01	; 1
     362:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     366:	ce 01       	movw	r24, r28
     368:	03 96       	adiw	r24, 0x03	; 3
     36a:	7c 01       	movw	r14, r24
     36c:	04 e0       	ldi	r16, 0x04	; 4
     36e:	9c 01       	movw	r18, r24
     370:	49 e6       	ldi	r20, 0x69	; 105
     372:	50 e0       	ldi	r21, 0x00	; 0
     374:	63 e1       	ldi	r22, 0x13	; 19
     376:	72 e0       	ldi	r23, 0x02	; 2
     378:	8e e2       	ldi	r24, 0x2E	; 46
     37a:	91 e0       	ldi	r25, 0x01	; 1
     37c:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     380:	ce 01       	movw	r24, r28
     382:	09 96       	adiw	r24, 0x09	; 9
     384:	7c 01       	movw	r14, r24
     386:	02 e0       	ldi	r16, 0x02	; 2
     388:	20 e0       	ldi	r18, 0x00	; 0
     38a:	30 e0       	ldi	r19, 0x00	; 0
     38c:	4f e4       	ldi	r20, 0x4F	; 79
     38e:	51 e0       	ldi	r21, 0x01	; 1
     390:	6b e1       	ldi	r22, 0x1B	; 27
     392:	72 e0       	ldi	r23, 0x02	; 2
     394:	82 e5       	ldi	r24, 0x52	; 82
     396:	92 e0       	ldi	r25, 0x02	; 2
     398:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     39c:	ce 01       	movw	r24, r28
     39e:	07 96       	adiw	r24, 0x07	; 7
     3a0:	7c 01       	movw	r14, r24
     3a2:	03 e0       	ldi	r16, 0x03	; 3
     3a4:	20 e0       	ldi	r18, 0x00	; 0
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	47 e8       	ldi	r20, 0x87	; 135
     3aa:	50 e0       	ldi	r21, 0x00	; 0
     3ac:	64 e2       	ldi	r22, 0x24	; 36
     3ae:	72 e0       	ldi	r23, 0x02	; 2
     3b0:	84 ed       	ldi	r24, 0xD4	; 212
     3b2:	90 e0       	ldi	r25, 0x00	; 0
     3b4:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	7c 01       	movw	r14, r24
     3be:	01 e0       	ldi	r16, 0x01	; 1
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	30 e0       	ldi	r19, 0x00	; 0
     3c4:	47 e8       	ldi	r20, 0x87	; 135
     3c6:	50 e0       	ldi	r21, 0x00	; 0
     3c8:	60 e3       	ldi	r22, 0x30	; 48
     3ca:	72 e0       	ldi	r23, 0x02	; 2
     3cc:	8a ee       	ldi	r24, 0xEA	; 234
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3d4:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <vTaskStartScheduler>
     3d8:	b3 cf       	rjmp	.-154    	; 0x340 <main+0x14>

000003da <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceToSend, int reading)
{
     3da:	1f 93       	push	r17
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	00 d0       	rcall	.+0      	; 0x3e2 <obstacleSend+0x8>
     3e2:	1f 92       	push	r1
     3e4:	1f 92       	push	r1
     3e6:	cd b7       	in	r28, 0x3d	; 61
     3e8:	de b7       	in	r29, 0x3e	; 62
     3ea:	18 2f       	mov	r17, r24
     3ec:	cb 01       	movw	r24, r22
	obstacleData queueData;
	
	
	
	if(deviceToSend)
     3ee:	11 23       	and	r17, r17
     3f0:	99 f0       	breq	.+38     	; 0x418 <obstacleSend+0x3e>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     3f2:	4a e0       	ldi	r20, 0x0A	; 10
     3f4:	be 01       	movw	r22, r28
     3f6:	6e 5f       	subi	r22, 0xFE	; 254
     3f8:	7f 4f       	sbci	r23, 0xFF	; 255
     3fa:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__itoa_ncheck>
	{
		itoa(reading, queueData.data, 10); // convert to ascii
		
		queueData.deviceID = deviceToSend;
     3fe:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &queueData, portMAX_DELAY); // send data to queueData
     400:	20 e0       	ldi	r18, 0x00	; 0
     402:	4f ef       	ldi	r20, 0xFF	; 255
     404:	5f ef       	ldi	r21, 0xFF	; 255
     406:	be 01       	movw	r22, r28
     408:	6f 5f       	subi	r22, 0xFF	; 255
     40a:	7f 4f       	sbci	r23, 0xFF	; 255
     40c:	80 91 91 08 	lds	r24, 0x0891
     410:	90 91 92 08 	lds	r25, 0x0892
     414:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <xQueueGenericSend>
	}
}
     418:	0f 90       	pop	r0
     41a:	0f 90       	pop	r0
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	df 91       	pop	r29
     424:	cf 91       	pop	r28
     426:	1f 91       	pop	r17
     428:	08 95       	ret

0000042a <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceToSend, int frontSonar, int leftSonar, int rightSonar, int btmIR)
{
     42a:	8f 92       	push	r8
     42c:	9f 92       	push	r9
     42e:	af 92       	push	r10
     430:	bf 92       	push	r11
     432:	cf 92       	push	r12
     434:	df 92       	push	r13
     436:	ef 92       	push	r14
     438:	ff 92       	push	r15
     43a:	0f 93       	push	r16
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	1f 92       	push	r1
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	89 83       	std	Y+1, r24	; 0x01
     44a:	6b 01       	movw	r12, r22
     44c:	4a 01       	movw	r8, r20
     44e:	59 01       	movw	r10, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     450:	20 e0       	ldi	r18, 0x00	; 0
     452:	4f ef       	ldi	r20, 0xFF	; 255
     454:	5f ef       	ldi	r21, 0xFF	; 255
     456:	be 01       	movw	r22, r28
     458:	6f 5f       	subi	r22, 0xFF	; 255
     45a:	7f 4f       	sbci	r23, 0xFF	; 255
     45c:	80 91 8f 08 	lds	r24, 0x088F
     460:	90 91 90 08 	lds	r25, 0x0890
     464:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <xQueueGenericSend>
		
		obstacleSend(deviceToSend[FRONT_DEVICE], frontSonar);
     468:	b4 01       	movw	r22, r8
     46a:	f6 01       	movw	r30, r12
     46c:	80 81       	ld	r24, Z
     46e:	b5 df       	rcall	.-150    	; 0x3da <obstacleSend>

		obstacleSend(deviceToSend[LEFT_DEVICE], leftSonar);
     470:	b5 01       	movw	r22, r10
     472:	f6 01       	movw	r30, r12
     474:	81 81       	ldd	r24, Z+1	; 0x01
     476:	b1 df       	rcall	.-158    	; 0x3da <obstacleSend>

		obstacleSend(deviceToSend[RIGHT_DEVICE], rightSonar);
     478:	b8 01       	movw	r22, r16
     47a:	f6 01       	movw	r30, r12
     47c:	82 81       	ldd	r24, Z+2	; 0x02
     47e:	ad df       	rcall	.-166    	; 0x3da <obstacleSend>

		obstacleSend(deviceToSend[BTM_DEVICE], btmIR);
     480:	b7 01       	movw	r22, r14
     482:	f6 01       	movw	r30, r12
     484:	83 81       	ldd	r24, Z+3	; 0x03
     486:	a9 df       	rcall	.-174    	; 0x3da <obstacleSend>
		
	}
}
     488:	0f 90       	pop	r0
     48a:	df 91       	pop	r29
     48c:	cf 91       	pop	r28
     48e:	1f 91       	pop	r17
     490:	0f 91       	pop	r16
     492:	ff 90       	pop	r15
     494:	ef 90       	pop	r14
     496:	df 90       	pop	r13
     498:	cf 90       	pop	r12
     49a:	bf 90       	pop	r11
     49c:	af 90       	pop	r10
     49e:	9f 90       	pop	r9
     4a0:	8f 90       	pop	r8
     4a2:	08 95       	ret

000004a4 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	cd b7       	in	r28, 0x3d	; 61
     4aa:	de b7       	in	r29, 0x3e	; 62
     4ac:	28 97       	sbiw	r28, 0x08	; 8
     4ae:	0f b6       	in	r0, 0x3f	; 63
     4b0:	f8 94       	cli
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	0f be       	out	0x3f, r0	; 63
     4b6:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
	int frontSonar, leftSonar, rightSonar, btmIR;
	char deviceToSend[4] = {0}; // flag to indicate if we should send the reading to RPI
     4b8:	1b 82       	std	Y+3, r1	; 0x03
     4ba:	1c 82       	std	Y+4, r1	; 0x04
     4bc:	1d 82       	std	Y+5, r1	; 0x05
     4be:	1e 82       	std	Y+6, r1	; 0x06
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     4c0:	84 e2       	ldi	r24, 0x24	; 36
     4c2:	c5 d2       	rcall	.+1418   	; 0xa4e <mySharpIR_Read>
     4c4:	98 87       	std	Y+8, r25	; 0x08
     4c6:	8f 83       	std	Y+7, r24	; 0x07
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     4c8:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <xTaskGetTickCount>
     4cc:	9a 83       	std	Y+2, r25	; 0x02
     4ce:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{	
		myMaxSonar_Start();
     4d0:	92 d1       	rcall	.+804    	; 0x7f6 <myMaxSonar_Start>
		frontSonar	= myMaxSonar_Read(AN15);
     4d2:	87 e2       	ldi	r24, 0x27	; 39
     4d4:	96 d1       	rcall	.+812    	; 0x802 <myMaxSonar_Read>
     4d6:	6c 01       	movw	r12, r24
		leftSonar	= myMaxSonar_Read(AN14);
     4d8:	86 e2       	ldi	r24, 0x26	; 38
     4da:	93 d1       	rcall	.+806    	; 0x802 <myMaxSonar_Read>
     4dc:	5c 01       	movw	r10, r24
		rightSonar	= myMaxSonar_Read(AN13); 
     4de:	85 e2       	ldi	r24, 0x25	; 37
     4e0:	90 d1       	rcall	.+800    	; 0x802 <myMaxSonar_Read>
     4e2:	4c 01       	movw	r8, r24
		btmIR		= mySharpIR_Read(AN12);	
     4e4:	84 e2       	ldi	r24, 0x24	; 36
     4e6:	b3 d2       	rcall	.+1382   	; 0xa4e <mySharpIR_Read>
     4e8:	7c 01       	movw	r14, r24
	
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     4ea:	bc 01       	movw	r22, r24
     4ec:	ce 01       	movw	r24, r28
     4ee:	07 96       	adiw	r24, 0x07	; 7
     4f0:	e7 d2       	rcall	.+1486   	; 0xac0 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceToSend, leftSonar, rightSonar);
     4f2:	84 01       	movw	r16, r8
     4f4:	95 01       	movw	r18, r10
     4f6:	ae 01       	movw	r20, r28
     4f8:	4d 5f       	subi	r20, 0xFD	; 253
     4fa:	5f 4f       	sbci	r21, 0xFF	; 255
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	c6 01       	movw	r24, r12
     500:	9a d2       	rcall	.+1332   	; 0xa36 <obstacleDetection>
     502:	78 2e       	mov	r7, r24
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, calibratedBtmIR);
     504:	0f 81       	ldd	r16, Y+7	; 0x07
     506:	18 85       	ldd	r17, Y+8	; 0x08
     508:	97 01       	movw	r18, r14
     50a:	a4 01       	movw	r20, r8
     50c:	b5 01       	movw	r22, r10
     50e:	c6 01       	movw	r24, r12
     510:	3b d2       	rcall	.+1142   	; 0x988 <obstacleAvoidance>
		sendObstacleDetected(obstacleDetected, deviceToSend, frontSonar, leftSonar, rightSonar, btmIR);
     512:	84 01       	movw	r16, r8
     514:	95 01       	movw	r18, r10
     516:	a6 01       	movw	r20, r12
     518:	be 01       	movw	r22, r28
     51a:	6d 5f       	subi	r22, 0xFD	; 253
     51c:	7f 4f       	sbci	r23, 0xFF	; 255
     51e:	87 2d       	mov	r24, r7
     520:	84 df       	rcall	.-248    	; 0x42a <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
		deviceToSend[0] = deviceToSend[1] = deviceToSend[2] = deviceToSend[3] = 0;
     522:	1e 82       	std	Y+6, r1	; 0x06
     524:	1d 82       	std	Y+5, r1	; 0x05
     526:	1c 82       	std	Y+4, r1	; 0x04
     528:	1b 82       	std	Y+3, r1	; 0x03
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     52a:	66 e9       	ldi	r22, 0x96	; 150
     52c:	70 e0       	ldi	r23, 0x00	; 0
     52e:	ce 01       	movw	r24, r28
     530:	01 96       	adiw	r24, 0x01	; 1
     532:	0e 94 11 10 	call	0x2022	; 0x2022 <vTaskDelayUntil>
     536:	cc cf       	rjmp	.-104    	; 0x4d0 <Sonar_Task+0x2c>

00000538 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     53e:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     542:	80 91 3e 02 	lds	r24, 0x023E
     546:	90 91 3f 02 	lds	r25, 0x023F
     54a:	89 2b       	or	r24, r25
     54c:	31 f4       	brne	.+12     	; 0x55a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     54e:	83 e4       	ldi	r24, 0x43	; 67
     550:	92 e0       	ldi	r25, 0x02	; 2
     552:	90 93 3f 02 	sts	0x023F, r25
     556:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     55a:	40 91 40 02 	lds	r20, 0x0240
     55e:	50 91 41 02 	lds	r21, 0x0241
     562:	9e 01       	movw	r18, r28
     564:	24 0f       	add	r18, r20
     566:	35 1f       	adc	r19, r21
     568:	2b 3d       	cpi	r18, 0xDB	; 219
     56a:	85 e0       	ldi	r24, 0x05	; 5
     56c:	38 07       	cpc	r19, r24
     56e:	70 f4       	brcc	.+28     	; 0x58c <pvPortMalloc+0x54>
     570:	42 17       	cp	r20, r18
     572:	53 07       	cpc	r21, r19
     574:	70 f4       	brcc	.+28     	; 0x592 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     576:	c0 91 3e 02 	lds	r28, 0x023E
     57a:	d0 91 3f 02 	lds	r29, 0x023F
     57e:	c4 0f       	add	r28, r20
     580:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     582:	30 93 41 02 	sts	0x0241, r19
     586:	20 93 40 02 	sts	0x0240, r18
     58a:	05 c0       	rjmp	.+10     	; 0x596 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     58c:	c0 e0       	ldi	r28, 0x00	; 0
     58e:	d0 e0       	ldi	r29, 0x00	; 0
     590:	02 c0       	rjmp	.+4      	; 0x596 <pvPortMalloc+0x5e>
     592:	c0 e0       	ldi	r28, 0x00	; 0
     594:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     596:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     59a:	ce 01       	movw	r24, r28
     59c:	df 91       	pop	r29
     59e:	cf 91       	pop	r28
     5a0:	08 95       	ret

000005a2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5a2:	08 95       	ret

000005a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5a4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5a6:	03 96       	adiw	r24, 0x03	; 3
     5a8:	92 83       	std	Z+2, r25	; 0x02
     5aa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5ac:	2f ef       	ldi	r18, 0xFF	; 255
     5ae:	3f ef       	ldi	r19, 0xFF	; 255
     5b0:	34 83       	std	Z+4, r19	; 0x04
     5b2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b4:	96 83       	std	Z+6, r25	; 0x06
     5b6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b8:	90 87       	std	Z+8, r25	; 0x08
     5ba:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5bc:	10 82       	st	Z, r1
     5be:	08 95       	ret

000005c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5c0:	fc 01       	movw	r30, r24
     5c2:	11 86       	std	Z+9, r1	; 0x09
     5c4:	10 86       	std	Z+8, r1	; 0x08
     5c6:	08 95       	ret

000005c8 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5c8:	cf 93       	push	r28
     5ca:	df 93       	push	r29
     5cc:	9c 01       	movw	r18, r24
     5ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     5d0:	dc 01       	movw	r26, r24
     5d2:	11 96       	adiw	r26, 0x01	; 1
     5d4:	cd 91       	ld	r28, X+
     5d6:	dc 91       	ld	r29, X
     5d8:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5da:	d3 83       	std	Z+3, r29	; 0x03
     5dc:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5de:	8c 81       	ldd	r24, Y+4	; 0x04
     5e0:	9d 81       	ldd	r25, Y+5	; 0x05
     5e2:	95 83       	std	Z+5, r25	; 0x05
     5e4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5e6:	8c 81       	ldd	r24, Y+4	; 0x04
     5e8:	9d 81       	ldd	r25, Y+5	; 0x05
     5ea:	dc 01       	movw	r26, r24
     5ec:	13 96       	adiw	r26, 0x03	; 3
     5ee:	7c 93       	st	X, r23
     5f0:	6e 93       	st	-X, r22
     5f2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     5f4:	7d 83       	std	Y+5, r23	; 0x05
     5f6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5f8:	31 87       	std	Z+9, r19	; 0x09
     5fa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     5fc:	f9 01       	movw	r30, r18
     5fe:	80 81       	ld	r24, Z
     600:	8f 5f       	subi	r24, 0xFF	; 255
     602:	80 83       	st	Z, r24
}
     604:	df 91       	pop	r29
     606:	cf 91       	pop	r28
     608:	08 95       	ret

0000060a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     610:	48 81       	ld	r20, Y
     612:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     614:	4f 3f       	cpi	r20, 0xFF	; 255
     616:	2f ef       	ldi	r18, 0xFF	; 255
     618:	52 07       	cpc	r21, r18
     61a:	21 f4       	brne	.+8      	; 0x624 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     61c:	fc 01       	movw	r30, r24
     61e:	a7 81       	ldd	r26, Z+7	; 0x07
     620:	b0 85       	ldd	r27, Z+8	; 0x08
     622:	0d c0       	rjmp	.+26     	; 0x63e <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     624:	dc 01       	movw	r26, r24
     626:	13 96       	adiw	r26, 0x03	; 3
     628:	12 96       	adiw	r26, 0x02	; 2
     62a:	ed 91       	ld	r30, X+
     62c:	fc 91       	ld	r31, X
     62e:	13 97       	sbiw	r26, 0x03	; 3
     630:	20 81       	ld	r18, Z
     632:	31 81       	ldd	r19, Z+1	; 0x01
     634:	42 17       	cp	r20, r18
     636:	53 07       	cpc	r21, r19
     638:	10 f0       	brcs	.+4      	; 0x63e <vListInsert+0x34>
     63a:	df 01       	movw	r26, r30
     63c:	f5 cf       	rjmp	.-22     	; 0x628 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     63e:	12 96       	adiw	r26, 0x02	; 2
     640:	ed 91       	ld	r30, X+
     642:	fc 91       	ld	r31, X
     644:	13 97       	sbiw	r26, 0x03	; 3
     646:	fb 83       	std	Y+3, r31	; 0x03
     648:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     64a:	d5 83       	std	Z+5, r29	; 0x05
     64c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     64e:	bd 83       	std	Y+5, r27	; 0x05
     650:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     652:	13 96       	adiw	r26, 0x03	; 3
     654:	dc 93       	st	X, r29
     656:	ce 93       	st	-X, r28
     658:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     65a:	99 87       	std	Y+9, r25	; 0x09
     65c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     65e:	fc 01       	movw	r30, r24
     660:	20 81       	ld	r18, Z
     662:	2f 5f       	subi	r18, 0xFF	; 255
     664:	20 83       	st	Z, r18
}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	08 95       	ret

0000066c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     672:	a0 85       	ldd	r26, Z+8	; 0x08
     674:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     676:	c2 81       	ldd	r28, Z+2	; 0x02
     678:	d3 81       	ldd	r29, Z+3	; 0x03
     67a:	84 81       	ldd	r24, Z+4	; 0x04
     67c:	95 81       	ldd	r25, Z+5	; 0x05
     67e:	9d 83       	std	Y+5, r25	; 0x05
     680:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     682:	c4 81       	ldd	r28, Z+4	; 0x04
     684:	d5 81       	ldd	r29, Z+5	; 0x05
     686:	82 81       	ldd	r24, Z+2	; 0x02
     688:	93 81       	ldd	r25, Z+3	; 0x03
     68a:	9b 83       	std	Y+3, r25	; 0x03
     68c:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     68e:	11 96       	adiw	r26, 0x01	; 1
     690:	cd 91       	ld	r28, X+
     692:	dc 91       	ld	r29, X
     694:	12 97       	sbiw	r26, 0x02	; 2
     696:	ce 17       	cp	r28, r30
     698:	df 07       	cpc	r29, r31
     69a:	31 f4       	brne	.+12     	; 0x6a8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     69c:	8c 81       	ldd	r24, Y+4	; 0x04
     69e:	9d 81       	ldd	r25, Y+5	; 0x05
     6a0:	12 96       	adiw	r26, 0x02	; 2
     6a2:	9c 93       	st	X, r25
     6a4:	8e 93       	st	-X, r24
     6a6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6a8:	11 86       	std	Z+9, r1	; 0x09
     6aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6ac:	8c 91       	ld	r24, X
     6ae:	81 50       	subi	r24, 0x01	; 1
     6b0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6b2:	df 91       	pop	r29
     6b4:	cf 91       	pop	r28
     6b6:	08 95       	ret

000006b8 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     6b8:	1f 92       	push	r1
     6ba:	0f 92       	push	r0
     6bc:	0f b6       	in	r0, 0x3f	; 63
     6be:	0f 92       	push	r0
     6c0:	11 24       	eor	r1, r1
     6c2:	0b b6       	in	r0, 0x3b	; 59
     6c4:	0f 92       	push	r0
     6c6:	2f 93       	push	r18
     6c8:	3f 93       	push	r19
     6ca:	4f 93       	push	r20
     6cc:	5f 93       	push	r21
     6ce:	6f 93       	push	r22
     6d0:	7f 93       	push	r23
     6d2:	8f 93       	push	r24
     6d4:	9f 93       	push	r25
     6d6:	af 93       	push	r26
     6d8:	bf 93       	push	r27
     6da:	ef 93       	push	r30
     6dc:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     6de:	1b 9b       	sbis	0x03, 3	; 3
     6e0:	0d c0       	rjmp	.+26     	; 0x6fc <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     6e2:	6c d2       	rcall	.+1240   	; 0xbbc <myTimer_Read>
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	90 93 98 08 	sts	0x0898, r25
     6ea:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     6ee:	0e 94 cd 0e 	call	0x1d9a	; 0x1d9a <xTaskGetTickCountFromISR>
     6f2:	90 93 94 08 	sts	0x0894, r25
     6f6:	80 93 93 08 	sts	0x0893, r24
     6fa:	55 c0       	rjmp	.+170    	; 0x7a6 <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     6fc:	1b 99       	sbic	0x03, 3	; 3
     6fe:	53 c0       	rjmp	.+166    	; 0x7a6 <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     700:	0e 94 cd 0e 	call	0x1d9a	; 0x1d9a <xTaskGetTickCountFromISR>
     704:	90 93 9e 08 	sts	0x089E, r25
     708:	80 93 9d 08 	sts	0x089D, r24
     70c:	20 91 93 08 	lds	r18, 0x0893
     710:	30 91 94 08 	lds	r19, 0x0894
     714:	82 17       	cp	r24, r18
     716:	93 07       	cpc	r25, r19
     718:	4c f4       	brge	.+18     	; 0x72c <__vector_9+0x74>
			ms_tickEnd += 65535;
     71a:	80 91 9d 08 	lds	r24, 0x089D
     71e:	90 91 9e 08 	lds	r25, 0x089E
     722:	01 97       	sbiw	r24, 0x01	; 1
     724:	90 93 9e 08 	sts	0x089E, r25
     728:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     72c:	47 d2       	rcall	.+1166   	; 0xbbc <myTimer_Read>
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	90 93 a0 08 	sts	0x08A0, r25
     734:	80 93 9f 08 	sts	0x089F, r24
     738:	20 91 97 08 	lds	r18, 0x0897
     73c:	30 91 98 08 	lds	r19, 0x0898
     740:	82 17       	cp	r24, r18
     742:	93 07       	cpc	r25, r19
     744:	54 f4       	brge	.+20     	; 0x75a <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     746:	80 91 9f 08 	lds	r24, 0x089F
     74a:	90 91 a0 08 	lds	r25, 0x08A0
     74e:	86 50       	subi	r24, 0x06	; 6
     750:	9f 4f       	sbci	r25, 0xFF	; 255
     752:	90 93 a0 08 	sts	0x08A0, r25
     756:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     75a:	80 91 9f 08 	lds	r24, 0x089F
     75e:	90 91 a0 08 	lds	r25, 0x08A0
     762:	20 91 97 08 	lds	r18, 0x0897
     766:	30 91 98 08 	lds	r19, 0x0898
     76a:	82 1b       	sub	r24, r18
     76c:	93 0b       	sbc	r25, r19
     76e:	90 93 9a 08 	sts	0x089A, r25
     772:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     776:	80 91 9d 08 	lds	r24, 0x089D
     77a:	90 91 9e 08 	lds	r25, 0x089E
     77e:	20 91 93 08 	lds	r18, 0x0893
     782:	30 91 94 08 	lds	r19, 0x0894
     786:	82 1b       	sub	r24, r18
     788:	93 0b       	sbc	r25, r19
     78a:	90 93 96 08 	sts	0x0896, r25
     78e:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     792:	20 e0       	ldi	r18, 0x00	; 0
     794:	40 e0       	ldi	r20, 0x00	; 0
     796:	50 e0       	ldi	r21, 0x00	; 0
     798:	60 e0       	ldi	r22, 0x00	; 0
     79a:	70 e0       	ldi	r23, 0x00	; 0
     79c:	80 91 9b 08 	lds	r24, 0x089B
     7a0:	90 91 9c 08 	lds	r25, 0x089C
     7a4:	d5 d7       	rcall	.+4010   	; 0x1750 <xQueueGenericSendFromISR>
	}	
}
     7a6:	ff 91       	pop	r31
     7a8:	ef 91       	pop	r30
     7aa:	bf 91       	pop	r27
     7ac:	af 91       	pop	r26
     7ae:	9f 91       	pop	r25
     7b0:	8f 91       	pop	r24
     7b2:	7f 91       	pop	r23
     7b4:	6f 91       	pop	r22
     7b6:	5f 91       	pop	r21
     7b8:	4f 91       	pop	r20
     7ba:	3f 91       	pop	r19
     7bc:	2f 91       	pop	r18
     7be:	0f 90       	pop	r0
     7c0:	0b be       	out	0x3b, r0	; 59
     7c2:	0f 90       	pop	r0
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	0f 90       	pop	r0
     7c8:	1f 90       	pop	r1
     7ca:	18 95       	reti

000007cc <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     7cc:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     7ce:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     7d0:	e8 e6       	ldi	r30, 0x68	; 104
     7d2:	f0 e0       	ldi	r31, 0x00	; 0
     7d4:	80 81       	ld	r24, Z
     7d6:	81 60       	ori	r24, 0x01	; 1
     7d8:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     7da:	eb e6       	ldi	r30, 0x6B	; 107
     7dc:	f0 e0       	ldi	r31, 0x00	; 0
     7de:	80 81       	ld	r24, Z
     7e0:	88 60       	ori	r24, 0x08	; 8
     7e2:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     7e4:	43 e0       	ldi	r20, 0x03	; 3
     7e6:	60 e0       	ldi	r22, 0x00	; 0
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	c7 d6       	rcall	.+3470   	; 0x157a <xQueueGenericCreate>
     7ec:	90 93 9c 08 	sts	0x089C, r25
     7f0:	80 93 9b 08 	sts	0x089B, r24
     7f4:	08 95       	ret

000007f6 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     7f6:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     7f8:	89 e1       	ldi	r24, 0x19	; 25
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	e1 d1       	rcall	.+962    	; 0xbc0 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     7fe:	a1 98       	cbi	0x14, 1	; 20
     800:	08 95       	ret

00000802 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     802:	ab d0       	rcall	.+342    	; 0x95a <myADC_analogRead>
     804:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     806:	63 e0       	ldi	r22, 0x03	; 3
     808:	70 e0       	ldi	r23, 0x00	; 0
     80a:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     80e:	cb 01       	movw	r24, r22
     810:	82 0f       	add	r24, r18
     812:	93 1f       	adc	r25, r19
     814:	08 95       	ret

00000816 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     816:	1f 92       	push	r1
     818:	0f 92       	push	r0
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	0f 92       	push	r0
     81e:	11 24       	eor	r1, r1
     820:	0b b6       	in	r0, 0x3b	; 59
     822:	0f 92       	push	r0
     824:	2f 93       	push	r18
     826:	3f 93       	push	r19
     828:	4f 93       	push	r20
     82a:	5f 93       	push	r21
     82c:	6f 93       	push	r22
     82e:	7f 93       	push	r23
     830:	8f 93       	push	r24
     832:	9f 93       	push	r25
     834:	af 93       	push	r26
     836:	bf 93       	push	r27
     838:	ef 93       	push	r30
     83a:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     83c:	80 91 78 00 	lds	r24, 0x0078
     840:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     844:	80 91 79 00 	lds	r24, 0x0079
     848:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	40 e0       	ldi	r20, 0x00	; 0
     850:	50 e0       	ldi	r21, 0x00	; 0
     852:	60 e0       	ldi	r22, 0x00	; 0
     854:	70 e0       	ldi	r23, 0x00	; 0
     856:	80 91 a5 08 	lds	r24, 0x08A5
     85a:	90 91 a6 08 	lds	r25, 0x08A6
     85e:	78 d7       	rcall	.+3824   	; 0x1750 <xQueueGenericSendFromISR>
}
     860:	ff 91       	pop	r31
     862:	ef 91       	pop	r30
     864:	bf 91       	pop	r27
     866:	af 91       	pop	r26
     868:	9f 91       	pop	r25
     86a:	8f 91       	pop	r24
     86c:	7f 91       	pop	r23
     86e:	6f 91       	pop	r22
     870:	5f 91       	pop	r21
     872:	4f 91       	pop	r20
     874:	3f 91       	pop	r19
     876:	2f 91       	pop	r18
     878:	0f 90       	pop	r0
     87a:	0b be       	out	0x3b, r0	; 59
     87c:	0f 90       	pop	r0
     87e:	0f be       	out	0x3f, r0	; 63
     880:	0f 90       	pop	r0
     882:	1f 90       	pop	r1
     884:	18 95       	reti

00000886 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     886:	8f e8       	ldi	r24, 0x8F	; 143
     888:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     88c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     890:	80 e4       	ldi	r24, 0x40	; 64
     892:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     896:	43 e0       	ldi	r20, 0x03	; 3
     898:	60 e0       	ldi	r22, 0x00	; 0
     89a:	81 e0       	ldi	r24, 0x01	; 1
     89c:	6e d6       	rcall	.+3292   	; 0x157a <xQueueGenericCreate>
     89e:	90 93 a6 08 	sts	0x08A6, r25
     8a2:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	28 d7       	rcall	.+3664   	; 0x16fa <xQueueCreateMutex>
     8aa:	90 93 a4 08 	sts	0x08A4, r25
     8ae:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	40 e0       	ldi	r20, 0x00	; 0
     8b6:	50 e0       	ldi	r21, 0x00	; 0
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	70 e0       	ldi	r23, 0x00	; 0
     8bc:	8b c6       	rjmp	.+3350   	; 0x15d4 <xQueueGenericSend>
     8be:	08 95       	ret

000008c0 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     8c0:	cf 93       	push	r28
     8c2:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     8c4:	20 e0       	ldi	r18, 0x00	; 0
     8c6:	4f ef       	ldi	r20, 0xFF	; 255
     8c8:	5f ef       	ldi	r21, 0xFF	; 255
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	80 91 a3 08 	lds	r24, 0x08A3
     8d2:	90 91 a4 08 	lds	r25, 0x08A4
     8d6:	76 d7       	rcall	.+3820   	; 0x17c4 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     8d8:	ec e7       	ldi	r30, 0x7C	; 124
     8da:	f0 e0       	ldi	r31, 0x00	; 0
     8dc:	80 81       	ld	r24, Z
     8de:	9c 2f       	mov	r25, r28
     8e0:	9f 71       	andi	r25, 0x1F	; 31
     8e2:	80 76       	andi	r24, 0x60	; 96
     8e4:	89 2b       	or	r24, r25
     8e6:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     8e8:	eb e7       	ldi	r30, 0x7B	; 123
     8ea:	f0 e0       	ldi	r31, 0x00	; 0
     8ec:	20 81       	ld	r18, Z
     8ee:	c0 72       	andi	r28, 0x20	; 32
     8f0:	8c 2f       	mov	r24, r28
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	95 95       	asr	r25
     8f6:	87 95       	ror	r24
     8f8:	95 95       	asr	r25
     8fa:	87 95       	ror	r24
     8fc:	92 2f       	mov	r25, r18
     8fe:	90 76       	andi	r25, 0x60	; 96
     900:	89 2b       	or	r24, r25
     902:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     904:	ea e7       	ldi	r30, 0x7A	; 122
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	80 81       	ld	r24, Z
     90a:	80 64       	ori	r24, 0x40	; 64
     90c:	80 83       	st	Z, r24
}
     90e:	cf 91       	pop	r28
     910:	08 95       	ret

00000912 <myADC_readADC>:

int myADC_readADC(char channel)
{
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     916:	20 e0       	ldi	r18, 0x00	; 0
     918:	4f ef       	ldi	r20, 0xFF	; 255
     91a:	5f ef       	ldi	r21, 0xFF	; 255
     91c:	60 e0       	ldi	r22, 0x00	; 0
     91e:	70 e0       	ldi	r23, 0x00	; 0
     920:	80 91 a5 08 	lds	r24, 0x08A5
     924:	90 91 a6 08 	lds	r25, 0x08A6
     928:	4d d7       	rcall	.+3738   	; 0x17c4 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     92a:	c0 91 a2 08 	lds	r28, 0x08A2
     92e:	c3 70       	andi	r28, 0x03	; 3
     930:	d0 e0       	ldi	r29, 0x00	; 0
     932:	dc 2f       	mov	r29, r28
     934:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     936:	80 91 a1 08 	lds	r24, 0x08A1
     93a:	c8 0f       	add	r28, r24
     93c:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	40 e0       	ldi	r20, 0x00	; 0
     942:	50 e0       	ldi	r21, 0x00	; 0
     944:	60 e0       	ldi	r22, 0x00	; 0
     946:	70 e0       	ldi	r23, 0x00	; 0
     948:	80 91 a3 08 	lds	r24, 0x08A3
     94c:	90 91 a4 08 	lds	r25, 0x08A4
     950:	41 d6       	rcall	.+3202   	; 0x15d4 <xQueueGenericSend>
	
	return adcReading;
     952:	ce 01       	movw	r24, r28
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	08 95       	ret

0000095a <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     95a:	cf 93       	push	r28
     95c:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     95e:	b0 df       	rcall	.-160    	; 0x8c0 <myADC_startADC>
	return myADC_readADC(channel);
     960:	8c 2f       	mov	r24, r28
     962:	d7 df       	rcall	.-82     	; 0x912 <myADC_readADC>
}
     964:	cf 91       	pop	r28
     966:	08 95       	ret

00000968 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + 15 || btmIR < calibratedBtmIR - 15)
     968:	9c 01       	movw	r18, r24
     96a:	21 5f       	subi	r18, 0xF1	; 241
     96c:	3f 4f       	sbci	r19, 0xFF	; 255
     96e:	26 17       	cp	r18, r22
     970:	37 07       	cpc	r19, r23
     972:	44 f0       	brlt	.+16     	; 0x984 <detectStairs+0x1c>
     974:	2e 51       	subi	r18, 0x1E	; 30
     976:	31 09       	sbc	r19, r1
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	62 17       	cp	r22, r18
     97c:	73 07       	cpc	r23, r19
     97e:	1c f0       	brlt	.+6      	; 0x986 <detectStairs+0x1e>
     980:	80 e0       	ldi	r24, 0x00	; 0
     982:	08 95       	ret
	{
		return 1; // stairs found
     984:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     986:	08 95       	ret

00000988 <obstacleAvoidance>:

void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, int calibratedBtmIR)
{
     988:	0f 93       	push	r16
     98a:	1f 93       	push	r17
	if(frontSonar < 70)
     98c:	86 34       	cpi	r24, 0x46	; 70
     98e:	91 05       	cpc	r25, r1
     990:	1c f5       	brge	.+70     	; 0x9d8 <obstacleAvoidance+0x50>
	{
		if(leftSonar < 45 && rightSonar < 45)
     992:	6d 32       	cpi	r22, 0x2D	; 45
     994:	71 05       	cpc	r23, r1
     996:	54 f4       	brge	.+20     	; 0x9ac <obstacleAvoidance+0x24>
     998:	4d 32       	cpi	r20, 0x2D	; 45
     99a:	51 05       	cpc	r21, r1
     99c:	3c f4       	brge	.+14     	; 0x9ac <obstacleAvoidance+0x24>
		{
			MOTOR_LEFT_START();
     99e:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     9a0:	e2 e0       	ldi	r30, 0x02	; 2
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	80 81       	ld	r24, Z
     9a6:	80 61       	ori	r24, 0x10	; 16
     9a8:	80 83       	st	Z, r24
     9aa:	42 c0       	rjmp	.+132    	; 0xa30 <obstacleAvoidance+0xa8>
		}
		else if( (leftSonar+10) > rightSonar)
     9ac:	66 5f       	subi	r22, 0xF6	; 246
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	46 17       	cp	r20, r22
     9b2:	57 07       	cpc	r21, r23
     9b4:	3c f4       	brge	.+14     	; 0x9c4 <obstacleAvoidance+0x3c>
		{
			MOTOR_RIGHT_STOP();
     9b6:	e2 e0       	ldi	r30, 0x02	; 2
     9b8:	f1 e0       	ldi	r31, 0x01	; 1
     9ba:	80 81       	ld	r24, Z
     9bc:	8f 7e       	andi	r24, 0xEF	; 239
     9be:	80 83       	st	Z, r24
			MOTOR_LEFT_START();
     9c0:	74 9a       	sbi	0x0e, 4	; 14
     9c2:	36 c0       	rjmp	.+108    	; 0xa30 <obstacleAvoidance+0xa8>
		}
		else if (rightSonar > (leftSonar+10))
     9c4:	64 17       	cp	r22, r20
     9c6:	75 07       	cpc	r23, r21
     9c8:	9c f5       	brge	.+102    	; 0xa30 <obstacleAvoidance+0xa8>
		{
			MOTOR_LEFT_STOP();
     9ca:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     9cc:	e2 e0       	ldi	r30, 0x02	; 2
     9ce:	f1 e0       	ldi	r31, 0x01	; 1
     9d0:	80 81       	ld	r24, Z
     9d2:	80 61       	ori	r24, 0x10	; 16
     9d4:	80 83       	st	Z, r24
     9d6:	2c c0       	rjmp	.+88     	; 0xa30 <obstacleAvoidance+0xa8>
		}
		
	}
	else if (rightSonar < 30 && leftSonar > 30)
     9d8:	4e 31       	cpi	r20, 0x1E	; 30
     9da:	51 05       	cpc	r21, r1
     9dc:	54 f4       	brge	.+20     	; 0x9f2 <obstacleAvoidance+0x6a>
     9de:	6f 31       	cpi	r22, 0x1F	; 31
     9e0:	71 05       	cpc	r23, r1
     9e2:	3c f0       	brlt	.+14     	; 0x9f2 <obstacleAvoidance+0x6a>
	{
		// narrow path
		// too close to right
		MOTOR_RIGHT_STOP();
     9e4:	e2 e0       	ldi	r30, 0x02	; 2
     9e6:	f1 e0       	ldi	r31, 0x01	; 1
     9e8:	80 81       	ld	r24, Z
     9ea:	8f 7e       	andi	r24, 0xEF	; 239
     9ec:	80 83       	st	Z, r24
		MOTOR_LEFT_START();
     9ee:	74 9a       	sbi	0x0e, 4	; 14
     9f0:	1f c0       	rjmp	.+62     	; 0xa30 <obstacleAvoidance+0xa8>
	}
	else if (leftSonar < 30 && rightSonar > 30)
     9f2:	6e 31       	cpi	r22, 0x1E	; 30
     9f4:	71 05       	cpc	r23, r1
     9f6:	54 f4       	brge	.+20     	; 0xa0c <obstacleAvoidance+0x84>
     9f8:	4f 31       	cpi	r20, 0x1F	; 31
     9fa:	51 05       	cpc	r21, r1
     9fc:	3c f0       	brlt	.+14     	; 0xa0c <obstacleAvoidance+0x84>
	{
		// narrow path
		// too close to left
		MOTOR_RIGHT_START();
     9fe:	e2 e0       	ldi	r30, 0x02	; 2
     a00:	f1 e0       	ldi	r31, 0x01	; 1
     a02:	80 81       	ld	r24, Z
     a04:	80 61       	ori	r24, 0x10	; 16
     a06:	80 83       	st	Z, r24
		MOTOR_LEFT_STOP();
     a08:	74 98       	cbi	0x0e, 4	; 14
     a0a:	12 c0       	rjmp	.+36     	; 0xa30 <obstacleAvoidance+0xa8>
	}
	else if (detectStairs(calibratedBtmIR, btmIR))
     a0c:	b9 01       	movw	r22, r18
     a0e:	c8 01       	movw	r24, r16
     a10:	ab df       	rcall	.-170    	; 0x968 <detectStairs>
     a12:	88 23       	and	r24, r24
     a14:	39 f0       	breq	.+14     	; 0xa24 <obstacleAvoidance+0x9c>
	{
		// stairs detection
		MOTOR_LEFT_START();
     a16:	74 9a       	sbi	0x0e, 4	; 14
		MOTOR_RIGHT_START();
     a18:	e2 e0       	ldi	r30, 0x02	; 2
     a1a:	f1 e0       	ldi	r31, 0x01	; 1
     a1c:	80 81       	ld	r24, Z
     a1e:	80 61       	ori	r24, 0x10	; 16
     a20:	80 83       	st	Z, r24
     a22:	06 c0       	rjmp	.+12     	; 0xa30 <obstacleAvoidance+0xa8>
	}
	else
	{
		// narrow path or no obstacle infront.
		MOTOR_RIGHT_STOP();
     a24:	e2 e0       	ldi	r30, 0x02	; 2
     a26:	f1 e0       	ldi	r31, 0x01	; 1
     a28:	80 81       	ld	r24, Z
     a2a:	8f 7e       	andi	r24, 0xEF	; 239
     a2c:	80 83       	st	Z, r24
		MOTOR_LEFT_STOP();
     a2e:	74 98       	cbi	0x0e, 4	; 14
	}
}
     a30:	1f 91       	pop	r17
     a32:	0f 91       	pop	r16
     a34:	08 95       	ret

00000a36 <obstacleDetection>:

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceToSend, int leftSonar, int rightSonar)
{
     a36:	fa 01       	movw	r30, r20
	// Commented out when debuggin.

	//	if(frontSonar < OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceToSend[FRONT_DEVICE] = FRONT_SONAR_ID;
     a38:	86 e4       	ldi	r24, 0x46	; 70
     a3a:	80 83       	st	Z, r24
	}
	//	if (leftSonar < OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceToSend[LEFT_DEVICE] = LEFT_SONAR_ID;
     a3c:	8c e4       	ldi	r24, 0x4C	; 76
     a3e:	81 83       	std	Z+1, r24	; 0x01
	}
	//	if (rightSonar < OBSTACLE_DISTANCE)
	{
		obstacleDetected++;
		deviceToSend[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     a40:	82 e5       	ldi	r24, 0x52	; 82
     a42:	82 83       	std	Z+2, r24	; 0x02
	}
	//	if (btmSonar < OBSTACLE_DISTANCE)
	{
		obstacleDetected++;
		deviceToSend[BTM_DEVICE] = BTM_SONAR_ID;
     a44:	82 e4       	ldi	r24, 0x42	; 66
     a46:	83 83       	std	Z+3, r24	; 0x03
	}
	
	return obstacleDetected;
}
     a48:	84 e0       	ldi	r24, 0x04	; 4
     a4a:	86 0f       	add	r24, r22
     a4c:	08 95       	ret

00000a4e <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     a4e:	85 df       	rcall	.-246    	; 0x95a <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     a50:	bc 01       	movw	r22, r24
     a52:	88 27       	eor	r24, r24
     a54:	77 fd       	sbrc	r23, 7
     a56:	80 95       	com	r24
     a58:	98 2f       	mov	r25, r24
     a5a:	0e 94 50 13 	call	0x26a0	; 0x26a0 <__floatsisf>
     a5e:	29 e2       	ldi	r18, 0x29	; 41
     a60:	3c e5       	ldi	r19, 0x5C	; 92
     a62:	4f e6       	ldi	r20, 0x6F	; 111
     a64:	5f eb       	ldi	r21, 0xBF	; 191
     a66:	0e 94 3f 14 	call	0x287e	; 0x287e <pow>
     a6a:	22 e5       	ldi	r18, 0x52	; 82
     a6c:	38 e6       	ldi	r19, 0x68	; 104
     a6e:	46 e2       	ldi	r20, 0x26	; 38
     a70:	56 e4       	ldi	r21, 0x46	; 70
     a72:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <__mulsf3>
     a76:	20 e0       	ldi	r18, 0x00	; 0
     a78:	30 e0       	ldi	r19, 0x00	; 0
     a7a:	40 e2       	ldi	r20, 0x20	; 32
     a7c:	51 e4       	ldi	r21, 0x41	; 65
     a7e:	0e 94 b8 12 	call	0x2570	; 0x2570 <__subsf3>
     a82:	0e 94 1d 13 	call	0x263a	; 0x263a <__fixsfsi>
     a86:	cb 01       	movw	r24, r22
     a88:	68 3e       	cpi	r22, 0xE8	; 232
     a8a:	23 e0       	ldi	r18, 0x03	; 3
     a8c:	72 07       	cpc	r23, r18
     a8e:	14 f0       	brlt	.+4      	; 0xa94 <mySharpIR_Read+0x46>
     a90:	87 ee       	ldi	r24, 0xE7	; 231
     a92:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
}
     a94:	08 95       	ret

00000a96 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     a96:	fb 01       	movw	r30, r22
     a98:	20 81       	ld	r18, Z
     a9a:	31 81       	ldd	r19, Z+1	; 0x01
     a9c:	50 e0       	ldi	r21, 0x00	; 0
     a9e:	b9 01       	movw	r22, r18
     aa0:	64 0f       	add	r22, r20
     aa2:	75 1f       	adc	r23, r21
     aa4:	68 17       	cp	r22, r24
     aa6:	79 07       	cpc	r23, r25
     aa8:	4c f0       	brlt	.+18     	; 0xabc <checkWithinRange+0x26>
     aaa:	24 1b       	sub	r18, r20
     aac:	35 0b       	sbc	r19, r21
     aae:	41 e0       	ldi	r20, 0x01	; 1
     ab0:	82 17       	cp	r24, r18
     ab2:	93 07       	cpc	r25, r19
     ab4:	0c f0       	brlt	.+2      	; 0xab8 <checkWithinRange+0x22>
     ab6:	40 e0       	ldi	r20, 0x00	; 0
     ab8:	84 2f       	mov	r24, r20
     aba:	08 95       	ret
     abc:	81 e0       	ldi	r24, 0x01	; 1
}
     abe:	08 95       	ret

00000ac0 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     ac0:	0f 93       	push	r16
     ac2:	1f 93       	push	r17
     ac4:	cf 93       	push	r28
     ac6:	df 93       	push	r29
     ac8:	8c 01       	movw	r16, r24
     aca:	eb 01       	movw	r28, r22
	static const char range = 5; // put at header file later...
	static const char CALIBRATE_COUNT = 20; // put at header file later...
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, range) && i == 0)
     acc:	45 e0       	ldi	r20, 0x05	; 5
     ace:	bc 01       	movw	r22, r24
     ad0:	ce 01       	movw	r24, r28
     ad2:	e1 df       	rcall	.-62     	; 0xa96 <checkWithinRange>
     ad4:	88 23       	and	r24, r24
     ad6:	41 f0       	breq	.+16     	; 0xae8 <mySharpIR_ReCalibrate+0x28>
     ad8:	20 91 22 08 	lds	r18, 0x0822
     adc:	30 91 23 08 	lds	r19, 0x0823
     ae0:	21 15       	cp	r18, r1
     ae2:	31 05       	cpc	r19, r1
     ae4:	69 f4       	brne	.+26     	; 0xb00 <mySharpIR_ReCalibrate+0x40>
     ae6:	4b c0       	rjmp	.+150    	; 0xb7e <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     ae8:	20 91 22 08 	lds	r18, 0x0822
     aec:	30 91 23 08 	lds	r19, 0x0823
     af0:	21 15       	cp	r18, r1
     af2:	31 05       	cpc	r19, r1
     af4:	29 f4       	brne	.+10     	; 0xb00 <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     af6:	d0 93 1f 08 	sts	0x081F, r29
     afa:	c0 93 1e 08 	sts	0x081E, r28
     afe:	32 c0       	rjmp	.+100    	; 0xb64 <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     b00:	2a 30       	cpi	r18, 0x0A	; 10
     b02:	31 05       	cpc	r19, r1
     b04:	a9 f4       	brne	.+42     	; 0xb30 <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, range))
     b06:	45 e0       	ldi	r20, 0x05	; 5
     b08:	6e e1       	ldi	r22, 0x1E	; 30
     b0a:	78 e0       	ldi	r23, 0x08	; 8
     b0c:	ce 01       	movw	r24, r28
     b0e:	c3 df       	rcall	.-122    	; 0xa96 <checkWithinRange>
     b10:	88 23       	and	r24, r24
     b12:	49 f0       	breq	.+18     	; 0xb26 <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     b14:	d0 93 1f 08 	sts	0x081F, r29
     b18:	c0 93 1e 08 	sts	0x081E, r28
			i = 0; // reset to count...
     b1c:	10 92 23 08 	sts	0x0823, r1
     b20:	10 92 22 08 	sts	0x0822, r1
     b24:	1f c0       	rjmp	.+62     	; 0xb64 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     b26:	d0 93 21 08 	sts	0x0821, r29
     b2a:	c0 93 20 08 	sts	0x0820, r28
     b2e:	1a c0       	rjmp	.+52     	; 0xb64 <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     b30:	24 31       	cpi	r18, 0x14	; 20
     b32:	31 05       	cpc	r19, r1
     b34:	b9 f4       	brne	.+46     	; 0xb64 <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     b36:	10 92 23 08 	sts	0x0823, r1
     b3a:	10 92 22 08 	sts	0x0822, r1

		if(checkWithinRange(reading, checkReading, range))
     b3e:	45 e0       	ldi	r20, 0x05	; 5
     b40:	6e e1       	ldi	r22, 0x1E	; 30
     b42:	78 e0       	ldi	r23, 0x08	; 8
     b44:	ce 01       	movw	r24, r28
     b46:	a7 df       	rcall	.-178    	; 0xa96 <checkWithinRange>
     b48:	88 23       	and	r24, r24
     b4a:	29 f0       	breq	.+10     	; 0xb56 <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     b4c:	d0 93 1f 08 	sts	0x081F, r29
     b50:	c0 93 1e 08 	sts	0x081E, r28
     b54:	07 c0       	rjmp	.+14     	; 0xb64 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     b56:	80 91 1e 08 	lds	r24, 0x081E
     b5a:	90 91 1f 08 	lds	r25, 0x081F
     b5e:	f8 01       	movw	r30, r16
     b60:	91 83       	std	Z+1, r25	; 0x01
     b62:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     b64:	80 91 22 08 	lds	r24, 0x0822
     b68:	90 91 23 08 	lds	r25, 0x0823
     b6c:	01 96       	adiw	r24, 0x01	; 1
     b6e:	64 e1       	ldi	r22, 0x14	; 20
     b70:	70 e0       	ldi	r23, 0x00	; 0
     b72:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__divmodhi4>
     b76:	90 93 23 08 	sts	0x0823, r25
     b7a:	80 93 22 08 	sts	0x0822, r24
}
     b7e:	df 91       	pop	r29
     b80:	cf 91       	pop	r28
     b82:	1f 91       	pop	r17
     b84:	0f 91       	pop	r16
     b86:	08 95       	ret

00000b88 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     b88:	90 93 ac 08 	sts	0x08AC, r25
     b8c:	80 93 ab 08 	sts	0x08AB, r24
     b90:	fc 01       	movw	r30, r24
     b92:	80 81       	ld	r24, Z
     b94:	91 81       	ldd	r25, Z+1	; 0x01
     b96:	0e 94 02 11 	call	0x2204	; 0x2204 <vTaskSuspend>
     b9a:	43 e0       	ldi	r20, 0x03	; 3
     b9c:	60 e0       	ldi	r22, 0x00	; 0
     b9e:	81 e0       	ldi	r24, 0x01	; 1
     ba0:	ec d4       	rcall	.+2520   	; 0x157a <xQueueGenericCreate>
     ba2:	90 93 a8 08 	sts	0x08A8, r25
     ba6:	80 93 a7 08 	sts	0x08A7, r24
     baa:	43 e0       	ldi	r20, 0x03	; 3
     bac:	60 e0       	ldi	r22, 0x00	; 0
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	e4 d4       	rcall	.+2504   	; 0x157a <xQueueGenericCreate>
     bb2:	90 93 aa 08 	sts	0x08AA, r25
     bb6:	80 93 a9 08 	sts	0x08A9, r24
     bba:	08 95       	ret

00000bbc <myTimer_Read>:
     bbc:	86 b5       	in	r24, 0x26	; 38
     bbe:	08 95       	ret

00000bc0 <myTimer_DelayMicro>:
     bc0:	46 b5       	in	r20, 0x26	; 38
     bc2:	50 e0       	ldi	r21, 0x00	; 0
     bc4:	9c 01       	movw	r18, r24
     bc6:	99 23       	and	r25, r25
     bc8:	14 f4       	brge	.+4      	; 0xbce <myTimer_DelayMicro+0xe>
     bca:	2d 5f       	subi	r18, 0xFD	; 253
     bcc:	3f 4f       	sbci	r19, 0xFF	; 255
     bce:	35 95       	asr	r19
     bd0:	27 95       	ror	r18
     bd2:	35 95       	asr	r19
     bd4:	27 95       	ror	r18
     bd6:	24 0f       	add	r18, r20
     bd8:	35 1f       	adc	r19, r21
     bda:	30 93 03 02 	sts	0x0203, r19
     bde:	20 93 02 02 	sts	0x0202, r18
     be2:	e0 91 ab 08 	lds	r30, 0x08AB
     be6:	f0 91 ac 08 	lds	r31, 0x08AC
     bea:	80 81       	ld	r24, Z
     bec:	91 81       	ldd	r25, Z+1	; 0x01
     bee:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <vTaskResume>
     bf2:	20 e0       	ldi	r18, 0x00	; 0
     bf4:	42 e0       	ldi	r20, 0x02	; 2
     bf6:	50 e0       	ldi	r21, 0x00	; 0
     bf8:	60 e0       	ldi	r22, 0x00	; 0
     bfa:	70 e0       	ldi	r23, 0x00	; 0
     bfc:	80 91 a7 08 	lds	r24, 0x08A7
     c00:	90 91 a8 08 	lds	r25, 0x08A8
     c04:	df c5       	rjmp	.+3006   	; 0x17c4 <xQueueGenericReceive>
     c06:	08 95       	ret

00000c08 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     c08:	cf 93       	push	r28
     c0a:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     c0c:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     c0e:	c1 11       	cpse	r28, r1
     c10:	22 c0       	rjmp	.+68     	; 0xc56 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     c12:	80 91 02 02 	lds	r24, 0x0202
     c16:	90 91 03 02 	lds	r25, 0x0203
     c1a:	88 38       	cpi	r24, 0x88	; 136
     c1c:	93 41       	sbci	r25, 0x13	; 19
     c1e:	51 f0       	breq	.+20     	; 0xc34 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     c20:	80 91 02 02 	lds	r24, 0x0202
     c24:	90 91 03 02 	lds	r25, 0x0203
     c28:	8a 5f       	subi	r24, 0xFA	; 250
     c2a:	91 09       	sbc	r25, r1
     c2c:	90 93 03 02 	sts	0x0203, r25
     c30:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     c34:	80 91 00 02 	lds	r24, 0x0200
     c38:	90 91 01 02 	lds	r25, 0x0201
     c3c:	88 38       	cpi	r24, 0x88	; 136
     c3e:	93 41       	sbci	r25, 0x13	; 19
     c40:	51 f0       	breq	.+20     	; 0xc56 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     c42:	80 91 00 02 	lds	r24, 0x0200
     c46:	90 91 01 02 	lds	r25, 0x0201
     c4a:	8a 5f       	subi	r24, 0xFA	; 250
     c4c:	91 09       	sbc	r25, r1
     c4e:	90 93 01 02 	sts	0x0201, r25
     c52:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     c56:	d0 e0       	ldi	r29, 0x00	; 0
     c58:	80 91 02 02 	lds	r24, 0x0202
     c5c:	90 91 03 02 	lds	r25, 0x0203
     c60:	8c 17       	cp	r24, r28
     c62:	9d 07       	cpc	r25, r29
     c64:	84 f4       	brge	.+32     	; 0xc86 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     c66:	88 e8       	ldi	r24, 0x88	; 136
     c68:	93 e1       	ldi	r25, 0x13	; 19
     c6a:	90 93 03 02 	sts	0x0203, r25
     c6e:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     c72:	20 e0       	ldi	r18, 0x00	; 0
     c74:	40 e0       	ldi	r20, 0x00	; 0
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	60 e0       	ldi	r22, 0x00	; 0
     c7a:	70 e0       	ldi	r23, 0x00	; 0
     c7c:	80 91 a7 08 	lds	r24, 0x08A7
     c80:	90 91 a8 08 	lds	r25, 0x08A8
     c84:	a7 d4       	rcall	.+2382   	; 0x15d4 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     c86:	80 91 00 02 	lds	r24, 0x0200
     c8a:	90 91 01 02 	lds	r25, 0x0201
     c8e:	8c 17       	cp	r24, r28
     c90:	9d 07       	cpc	r25, r29
     c92:	84 f4       	brge	.+32     	; 0xcb4 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     c94:	88 e8       	ldi	r24, 0x88	; 136
     c96:	93 e1       	ldi	r25, 0x13	; 19
     c98:	90 93 01 02 	sts	0x0201, r25
     c9c:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	40 e0       	ldi	r20, 0x00	; 0
     ca4:	50 e0       	ldi	r21, 0x00	; 0
     ca6:	60 e0       	ldi	r22, 0x00	; 0
     ca8:	70 e0       	ldi	r23, 0x00	; 0
     caa:	80 91 a9 08 	lds	r24, 0x08A9
     cae:	90 91 aa 08 	lds	r25, 0x08AA
     cb2:	90 d4       	rcall	.+2336   	; 0x15d4 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     cb4:	80 91 02 02 	lds	r24, 0x0202
     cb8:	90 91 03 02 	lds	r25, 0x0203
     cbc:	88 38       	cpi	r24, 0x88	; 136
     cbe:	93 41       	sbci	r25, 0x13	; 19
     cc0:	79 f4       	brne	.+30     	; 0xce0 <myTimer_DelayChecker+0xd8>
     cc2:	80 91 00 02 	lds	r24, 0x0200
     cc6:	90 91 01 02 	lds	r25, 0x0201
     cca:	88 38       	cpi	r24, 0x88	; 136
     ccc:	93 41       	sbci	r25, 0x13	; 19
     cce:	41 f4       	brne	.+16     	; 0xce0 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     cd0:	e0 91 ab 08 	lds	r30, 0x08AB
     cd4:	f0 91 ac 08 	lds	r31, 0x08AC
     cd8:	80 81       	ld	r24, Z
     cda:	91 81       	ldd	r25, Z+1	; 0x01
     cdc:	0e 94 02 11 	call	0x2204	; 0x2204 <vTaskSuspend>
	}
     ce0:	df 91       	pop	r29
     ce2:	cf 91       	pop	r28
     ce4:	08 95       	ret

00000ce6 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     ce6:	1f 92       	push	r1
     ce8:	0f 92       	push	r0
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	0f 92       	push	r0
     cee:	11 24       	eor	r1, r1
     cf0:	0b b6       	in	r0, 0x3b	; 59
     cf2:	0f 92       	push	r0
     cf4:	2f 93       	push	r18
     cf6:	3f 93       	push	r19
     cf8:	4f 93       	push	r20
     cfa:	5f 93       	push	r21
     cfc:	6f 93       	push	r22
     cfe:	7f 93       	push	r23
     d00:	8f 93       	push	r24
     d02:	9f 93       	push	r25
     d04:	af 93       	push	r26
     d06:	bf 93       	push	r27
     d08:	ef 93       	push	r30
     d0a:	ff 93       	push	r31
     d0c:	60 91 ce 00 	lds	r22, 0x00CE
     d10:	82 e4       	ldi	r24, 0x42	; 66
     d12:	99 e0       	ldi	r25, 0x09	; 9
     d14:	2d d6       	rcall	.+3162   	; 0x1970 <ringBufferPush>
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	40 e0       	ldi	r20, 0x00	; 0
     d1a:	50 e0       	ldi	r21, 0x00	; 0
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	70 e0       	ldi	r23, 0x00	; 0
     d20:	80 91 36 09 	lds	r24, 0x0936
     d24:	90 91 37 09 	lds	r25, 0x0937
     d28:	13 d5       	rcall	.+2598   	; 0x1750 <xQueueGenericSendFromISR>
     d2a:	82 e4       	ldi	r24, 0x42	; 66
     d2c:	99 e0       	ldi	r25, 0x09	; 9
     d2e:	37 d6       	rcall	.+3182   	; 0x199e <ringBufferFull>
     d30:	ff 91       	pop	r31
     d32:	ef 91       	pop	r30
     d34:	bf 91       	pop	r27
     d36:	af 91       	pop	r26
     d38:	9f 91       	pop	r25
     d3a:	8f 91       	pop	r24
     d3c:	7f 91       	pop	r23
     d3e:	6f 91       	pop	r22
     d40:	5f 91       	pop	r21
     d42:	4f 91       	pop	r20
     d44:	3f 91       	pop	r19
     d46:	2f 91       	pop	r18
     d48:	0f 90       	pop	r0
     d4a:	0b be       	out	0x3b, r0	; 59
     d4c:	0f 90       	pop	r0
     d4e:	0f be       	out	0x3f, r0	; 63
     d50:	0f 90       	pop	r0
     d52:	1f 90       	pop	r1
     d54:	18 95       	reti

00000d56 <__vector_25>:
     d56:	1f 92       	push	r1
     d58:	0f 92       	push	r0
     d5a:	0f b6       	in	r0, 0x3f	; 63
     d5c:	0f 92       	push	r0
     d5e:	11 24       	eor	r1, r1
     d60:	0b b6       	in	r0, 0x3b	; 59
     d62:	0f 92       	push	r0
     d64:	2f 93       	push	r18
     d66:	3f 93       	push	r19
     d68:	4f 93       	push	r20
     d6a:	5f 93       	push	r21
     d6c:	6f 93       	push	r22
     d6e:	7f 93       	push	r23
     d70:	8f 93       	push	r24
     d72:	9f 93       	push	r25
     d74:	af 93       	push	r26
     d76:	bf 93       	push	r27
     d78:	ef 93       	push	r30
     d7a:	ff 93       	push	r31
     d7c:	60 91 c6 00 	lds	r22, 0x00C6
     d80:	8d ec       	ldi	r24, 0xCD	; 205
     d82:	98 e0       	ldi	r25, 0x08	; 8
     d84:	f5 d5       	rcall	.+3050   	; 0x1970 <ringBufferPush>
     d86:	20 e0       	ldi	r18, 0x00	; 0
     d88:	40 e0       	ldi	r20, 0x00	; 0
     d8a:	50 e0       	ldi	r21, 0x00	; 0
     d8c:	60 e0       	ldi	r22, 0x00	; 0
     d8e:	70 e0       	ldi	r23, 0x00	; 0
     d90:	80 91 36 09 	lds	r24, 0x0936
     d94:	90 91 37 09 	lds	r25, 0x0937
     d98:	db d4       	rcall	.+2486   	; 0x1750 <xQueueGenericSendFromISR>
     d9a:	8d ec       	ldi	r24, 0xCD	; 205
     d9c:	98 e0       	ldi	r25, 0x08	; 8
     d9e:	ff d5       	rcall	.+3070   	; 0x199e <ringBufferFull>
     da0:	ff 91       	pop	r31
     da2:	ef 91       	pop	r30
     da4:	bf 91       	pop	r27
     da6:	af 91       	pop	r26
     da8:	9f 91       	pop	r25
     daa:	8f 91       	pop	r24
     dac:	7f 91       	pop	r23
     dae:	6f 91       	pop	r22
     db0:	5f 91       	pop	r21
     db2:	4f 91       	pop	r20
     db4:	3f 91       	pop	r19
     db6:	2f 91       	pop	r18
     db8:	0f 90       	pop	r0
     dba:	0b be       	out	0x3b, r0	; 59
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0
     dc2:	1f 90       	pop	r1
     dc4:	18 95       	reti

00000dc6 <__vector_37>:
     dc6:	1f 92       	push	r1
     dc8:	0f 92       	push	r0
     dca:	0f b6       	in	r0, 0x3f	; 63
     dcc:	0f 92       	push	r0
     dce:	11 24       	eor	r1, r1
     dd0:	0b b6       	in	r0, 0x3b	; 59
     dd2:	0f 92       	push	r0
     dd4:	2f 93       	push	r18
     dd6:	3f 93       	push	r19
     dd8:	4f 93       	push	r20
     dda:	5f 93       	push	r21
     ddc:	6f 93       	push	r22
     dde:	7f 93       	push	r23
     de0:	8f 93       	push	r24
     de2:	9f 93       	push	r25
     de4:	af 93       	push	r26
     de6:	bf 93       	push	r27
     de8:	ef 93       	push	r30
     dea:	ff 93       	push	r31
     dec:	88 e3       	ldi	r24, 0x38	; 56
     dee:	99 e0       	ldi	r25, 0x09	; 9
     df0:	dd d5       	rcall	.+3002   	; 0x19ac <ringBufferNotEmpty>
     df2:	88 23       	and	r24, r24
     df4:	31 f0       	breq	.+12     	; 0xe02 <__vector_37+0x3c>
     df6:	88 e3       	ldi	r24, 0x38	; 56
     df8:	99 e0       	ldi	r25, 0x09	; 9
     dfa:	a8 d5       	rcall	.+2896   	; 0x194c <ringBufferPop>
     dfc:	80 93 ce 00 	sts	0x00CE, r24
     e00:	05 c0       	rjmp	.+10     	; 0xe0c <__vector_37+0x46>
     e02:	e9 ec       	ldi	r30, 0xC9	; 201
     e04:	f0 e0       	ldi	r31, 0x00	; 0
     e06:	80 81       	ld	r24, Z
     e08:	8f 7d       	andi	r24, 0xDF	; 223
     e0a:	80 83       	st	Z, r24
     e0c:	ff 91       	pop	r31
     e0e:	ef 91       	pop	r30
     e10:	bf 91       	pop	r27
     e12:	af 91       	pop	r26
     e14:	9f 91       	pop	r25
     e16:	8f 91       	pop	r24
     e18:	7f 91       	pop	r23
     e1a:	6f 91       	pop	r22
     e1c:	5f 91       	pop	r21
     e1e:	4f 91       	pop	r20
     e20:	3f 91       	pop	r19
     e22:	2f 91       	pop	r18
     e24:	0f 90       	pop	r0
     e26:	0b be       	out	0x3b, r0	; 59
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <__vector_26>:
     e32:	1f 92       	push	r1
     e34:	0f 92       	push	r0
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	0f 92       	push	r0
     e3a:	11 24       	eor	r1, r1
     e3c:	0b b6       	in	r0, 0x3b	; 59
     e3e:	0f 92       	push	r0
     e40:	2f 93       	push	r18
     e42:	3f 93       	push	r19
     e44:	4f 93       	push	r20
     e46:	5f 93       	push	r21
     e48:	6f 93       	push	r22
     e4a:	7f 93       	push	r23
     e4c:	8f 93       	push	r24
     e4e:	9f 93       	push	r25
     e50:	af 93       	push	r26
     e52:	bf 93       	push	r27
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31
     e58:	8d e3       	ldi	r24, 0x3D	; 61
     e5a:	99 e0       	ldi	r25, 0x09	; 9
     e5c:	a7 d5       	rcall	.+2894   	; 0x19ac <ringBufferNotEmpty>
     e5e:	88 23       	and	r24, r24
     e60:	31 f0       	breq	.+12     	; 0xe6e <__vector_26+0x3c>
     e62:	8d e3       	ldi	r24, 0x3D	; 61
     e64:	99 e0       	ldi	r25, 0x09	; 9
     e66:	72 d5       	rcall	.+2788   	; 0x194c <ringBufferPop>
     e68:	80 93 c6 00 	sts	0x00C6, r24
     e6c:	05 c0       	rjmp	.+10     	; 0xe78 <__vector_26+0x46>
     e6e:	e1 ec       	ldi	r30, 0xC1	; 193
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	80 81       	ld	r24, Z
     e74:	8f 7d       	andi	r24, 0xDF	; 223
     e76:	80 83       	st	Z, r24
     e78:	ff 91       	pop	r31
     e7a:	ef 91       	pop	r30
     e7c:	bf 91       	pop	r27
     e7e:	af 91       	pop	r26
     e80:	9f 91       	pop	r25
     e82:	8f 91       	pop	r24
     e84:	7f 91       	pop	r23
     e86:	6f 91       	pop	r22
     e88:	5f 91       	pop	r21
     e8a:	4f 91       	pop	r20
     e8c:	3f 91       	pop	r19
     e8e:	2f 91       	pop	r18
     e90:	0f 90       	pop	r0
     e92:	0b be       	out	0x3b, r0	; 59
     e94:	0f 90       	pop	r0
     e96:	0f be       	out	0x3f, r0	; 63
     e98:	0f 90       	pop	r0
     e9a:	1f 90       	pop	r1
     e9c:	18 95       	reti

00000e9e <myUSART_USART0_Init>:
     e9e:	10 92 c5 00 	sts	0x00C5, r1
     ea2:	87 e6       	ldi	r24, 0x67	; 103
     ea4:	80 93 c4 00 	sts	0x00C4, r24
     ea8:	88 eb       	ldi	r24, 0xB8	; 184
     eaa:	80 93 c1 00 	sts	0x00C1, r24
     eae:	86 e0       	ldi	r24, 0x06	; 6
     eb0:	80 93 c2 00 	sts	0x00C2, r24
     eb4:	40 e2       	ldi	r20, 0x20	; 32
     eb6:	64 ef       	ldi	r22, 0xF4	; 244
     eb8:	78 e0       	ldi	r23, 0x08	; 8
     eba:	8d ec       	ldi	r24, 0xCD	; 205
     ebc:	98 e0       	ldi	r25, 0x08	; 8
     ebe:	35 d5       	rcall	.+2666   	; 0x192a <ringBufferInit>
     ec0:	40 e2       	ldi	r20, 0x20	; 32
     ec2:	62 ed       	ldi	r22, 0xD2	; 210
     ec4:	78 e0       	ldi	r23, 0x08	; 8
     ec6:	8d e3       	ldi	r24, 0x3D	; 61
     ec8:	99 e0       	ldi	r25, 0x09	; 9
     eca:	2f d5       	rcall	.+2654   	; 0x192a <ringBufferInit>
     ecc:	43 e0       	ldi	r20, 0x03	; 3
     ece:	60 e0       	ldi	r22, 0x00	; 0
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	53 d3       	rcall	.+1702   	; 0x157a <xQueueGenericCreate>
     ed4:	90 93 35 09 	sts	0x0935, r25
     ed8:	80 93 34 09 	sts	0x0934, r24
     edc:	08 95       	ret

00000ede <myUSART_USART1_Init>:
     ede:	10 92 cd 00 	sts	0x00CD, r1
     ee2:	87 e6       	ldi	r24, 0x67	; 103
     ee4:	80 93 cc 00 	sts	0x00CC, r24
     ee8:	88 eb       	ldi	r24, 0xB8	; 184
     eea:	80 93 c9 00 	sts	0x00C9, r24
     eee:	86 e0       	ldi	r24, 0x06	; 6
     ef0:	80 93 ca 00 	sts	0x00CA, r24
     ef4:	40 e2       	ldi	r20, 0x20	; 32
     ef6:	6d ea       	ldi	r22, 0xAD	; 173
     ef8:	78 e0       	ldi	r23, 0x08	; 8
     efa:	82 e4       	ldi	r24, 0x42	; 66
     efc:	99 e0       	ldi	r25, 0x09	; 9
     efe:	15 d5       	rcall	.+2602   	; 0x192a <ringBufferInit>
     f00:	40 e2       	ldi	r20, 0x20	; 32
     f02:	64 e1       	ldi	r22, 0x14	; 20
     f04:	79 e0       	ldi	r23, 0x09	; 9
     f06:	88 e3       	ldi	r24, 0x38	; 56
     f08:	99 e0       	ldi	r25, 0x09	; 9
     f0a:	0f d5       	rcall	.+2590   	; 0x192a <ringBufferInit>
     f0c:	43 e0       	ldi	r20, 0x03	; 3
     f0e:	60 e0       	ldi	r22, 0x00	; 0
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	33 d3       	rcall	.+1638   	; 0x157a <xQueueGenericCreate>
     f14:	90 93 37 09 	sts	0x0937, r25
     f18:	80 93 36 09 	sts	0x0936, r24
     f1c:	43 e0       	ldi	r20, 0x03	; 3
     f1e:	60 e0       	ldi	r22, 0x00	; 0
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	2b d3       	rcall	.+1622   	; 0x157a <xQueueGenericCreate>
     f24:	90 93 f3 08 	sts	0x08F3, r25
     f28:	80 93 f2 08 	sts	0x08F2, r24
     f2c:	08 95       	ret

00000f2e <myUSART_transmitUSART0_c>:
     f2e:	cf 93       	push	r28
     f30:	c8 2f       	mov	r28, r24
     f32:	8d e3       	ldi	r24, 0x3D	; 61
     f34:	99 e0       	ldi	r25, 0x09	; 9
     f36:	33 d5       	rcall	.+2662   	; 0x199e <ringBufferFull>
     f38:	81 11       	cpse	r24, r1
     f3a:	fb cf       	rjmp	.-10     	; 0xf32 <myUSART_transmitUSART0_c+0x4>
     f3c:	6c 2f       	mov	r22, r28
     f3e:	8d e3       	ldi	r24, 0x3D	; 61
     f40:	99 e0       	ldi	r25, 0x09	; 9
     f42:	16 d5       	rcall	.+2604   	; 0x1970 <ringBufferPush>
     f44:	e1 ec       	ldi	r30, 0xC1	; 193
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	80 81       	ld	r24, Z
     f4a:	80 62       	ori	r24, 0x20	; 32
     f4c:	80 83       	st	Z, r24
     f4e:	e0 ec       	ldi	r30, 0xC0	; 192
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	80 81       	ld	r24, Z
     f54:	80 64       	ori	r24, 0x40	; 64
     f56:	80 83       	st	Z, r24
     f58:	cf 91       	pop	r28
     f5a:	08 95       	ret

00000f5c <myUSART_transmitUSART1_c>:
     f5c:	cf 93       	push	r28
     f5e:	c8 2f       	mov	r28, r24
     f60:	88 e3       	ldi	r24, 0x38	; 56
     f62:	99 e0       	ldi	r25, 0x09	; 9
     f64:	1c d5       	rcall	.+2616   	; 0x199e <ringBufferFull>
     f66:	81 11       	cpse	r24, r1
     f68:	fb cf       	rjmp	.-10     	; 0xf60 <myUSART_transmitUSART1_c+0x4>
     f6a:	6c 2f       	mov	r22, r28
     f6c:	88 e3       	ldi	r24, 0x38	; 56
     f6e:	99 e0       	ldi	r25, 0x09	; 9
     f70:	ff d4       	rcall	.+2558   	; 0x1970 <ringBufferPush>
     f72:	e9 ec       	ldi	r30, 0xC9	; 201
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	80 81       	ld	r24, Z
     f78:	80 62       	ori	r24, 0x20	; 32
     f7a:	80 83       	st	Z, r24
     f7c:	e8 ec       	ldi	r30, 0xC8	; 200
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	80 81       	ld	r24, Z
     f82:	80 64       	ori	r24, 0x40	; 64
     f84:	80 83       	st	Z, r24
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <myUSART_transmitUSART1>:
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	ec 01       	movw	r28, r24
     f90:	88 81       	ld	r24, Y
     f92:	88 23       	and	r24, r24
     f94:	29 f0       	breq	.+10     	; 0xfa0 <myUSART_transmitUSART1+0x16>
     f96:	21 96       	adiw	r28, 0x01	; 1
     f98:	e1 df       	rcall	.-62     	; 0xf5c <myUSART_transmitUSART1_c>
     f9a:	89 91       	ld	r24, Y+
     f9c:	81 11       	cpse	r24, r1
     f9e:	fc cf       	rjmp	.-8      	; 0xf98 <myUSART_transmitUSART1+0xe>
     fa0:	df 91       	pop	r29
     fa2:	cf 91       	pop	r28
     fa4:	08 95       	ret

00000fa6 <myUSART_transmitUSART0>:
     fa6:	cf 93       	push	r28
     fa8:	df 93       	push	r29
     faa:	ec 01       	movw	r28, r24
     fac:	88 81       	ld	r24, Y
     fae:	88 23       	and	r24, r24
     fb0:	29 f0       	breq	.+10     	; 0xfbc <myUSART_transmitUSART0+0x16>
     fb2:	21 96       	adiw	r28, 0x01	; 1
     fb4:	bc df       	rcall	.-136    	; 0xf2e <myUSART_transmitUSART0_c>
     fb6:	89 91       	ld	r24, Y+
     fb8:	81 11       	cpse	r24, r1
     fba:	fc cf       	rjmp	.-8      	; 0xfb4 <myUSART_transmitUSART0+0xe>
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	08 95       	ret

00000fc2 <myUSART_receiveUSART1>:
     fc2:	cf 93       	push	r28
     fc4:	20 e0       	ldi	r18, 0x00	; 0
     fc6:	4f ef       	ldi	r20, 0xFF	; 255
     fc8:	5f ef       	ldi	r21, 0xFF	; 255
     fca:	60 e0       	ldi	r22, 0x00	; 0
     fcc:	70 e0       	ldi	r23, 0x00	; 0
     fce:	80 91 36 09 	lds	r24, 0x0936
     fd2:	90 91 37 09 	lds	r25, 0x0937
     fd6:	f6 d3       	rcall	.+2028   	; 0x17c4 <xQueueGenericReceive>
     fd8:	82 e4       	ldi	r24, 0x42	; 66
     fda:	99 e0       	ldi	r25, 0x09	; 9
     fdc:	b7 d4       	rcall	.+2414   	; 0x194c <ringBufferPop>
     fde:	c8 2f       	mov	r28, r24
     fe0:	82 e4       	ldi	r24, 0x42	; 66
     fe2:	99 e0       	ldi	r25, 0x09	; 9
     fe4:	e3 d4       	rcall	.+2502   	; 0x19ac <ringBufferNotEmpty>
     fe6:	88 23       	and	r24, r24
     fe8:	51 f0       	breq	.+20     	; 0xffe <myUSART_receiveUSART1+0x3c>
     fea:	20 e0       	ldi	r18, 0x00	; 0
     fec:	40 e0       	ldi	r20, 0x00	; 0
     fee:	50 e0       	ldi	r21, 0x00	; 0
     ff0:	60 e0       	ldi	r22, 0x00	; 0
     ff2:	70 e0       	ldi	r23, 0x00	; 0
     ff4:	80 91 36 09 	lds	r24, 0x0936
     ff8:	90 91 37 09 	lds	r25, 0x0937
     ffc:	eb d2       	rcall	.+1494   	; 0x15d4 <xQueueGenericSend>
     ffe:	8c 2f       	mov	r24, r28
    1000:	cf 91       	pop	r28
    1002:	08 95       	ret

00001004 <myUSART_waitForHandshake>:
    1004:	de df       	rcall	.-68     	; 0xfc2 <myUSART_receiveUSART1>
    1006:	86 31       	cpi	r24, 0x16	; 22
    1008:	51 f4       	brne	.+20     	; 0x101e <myUSART_waitForHandshake+0x1a>
    100a:	85 e0       	ldi	r24, 0x05	; 5
    100c:	a7 df       	rcall	.-178    	; 0xf5c <myUSART_transmitUSART1_c>
    100e:	d9 df       	rcall	.-78     	; 0xfc2 <myUSART_receiveUSART1>
    1010:	91 e0       	ldi	r25, 0x01	; 1
    1012:	86 31       	cpi	r24, 0x16	; 22
    1014:	09 f4       	brne	.+2      	; 0x1018 <myUSART_waitForHandshake+0x14>
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	89 2f       	mov	r24, r25
    101a:	81 95       	neg	r24
    101c:	08 95       	ret
    101e:	8f ef       	ldi	r24, 0xFF	; 255
    1020:	08 95       	ret

00001022 <myUSART_completeHandShake>:
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	40 e0       	ldi	r20, 0x00	; 0
    1026:	50 e0       	ldi	r21, 0x00	; 0
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	70 e0       	ldi	r23, 0x00	; 0
    102c:	80 91 f2 08 	lds	r24, 0x08F2
    1030:	90 91 f3 08 	lds	r25, 0x08F3
    1034:	cf c2       	rjmp	.+1438   	; 0x15d4 <xQueueGenericSend>
    1036:	08 95       	ret

00001038 <myUSART_receiveHandShakeAck>:
    1038:	91 e0       	ldi	r25, 0x01	; 1
    103a:	85 30       	cpi	r24, 0x05	; 5
    103c:	09 f0       	breq	.+2      	; 0x1040 <myUSART_receiveHandShakeAck+0x8>
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	89 2f       	mov	r24, r25
    1042:	08 95       	ret

00001044 <myUSART_receiveHandShakeStart>:
    1044:	91 e0       	ldi	r25, 0x01	; 1
    1046:	86 31       	cpi	r24, 0x16	; 22
    1048:	09 f0       	breq	.+2      	; 0x104c <myUSART_receiveHandShakeStart+0x8>
    104a:	90 e0       	ldi	r25, 0x00	; 0
    104c:	89 2f       	mov	r24, r25
    104e:	08 95       	ret

00001050 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1050:	91 e0       	ldi	r25, 0x01	; 1
    1052:	86 30       	cpi	r24, 0x06	; 6
    1054:	09 f0       	breq	.+2      	; 0x1058 <myUSART_receiveMessageACK+0x8>
    1056:	90 e0       	ldi	r25, 0x00	; 0
}
    1058:	89 2f       	mov	r24, r25
    105a:	08 95       	ret

0000105c <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    105c:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    105e:	20 e0       	ldi	r18, 0x00	; 0
    1060:	4f ef       	ldi	r20, 0xFF	; 255
    1062:	5f ef       	ldi	r21, 0xFF	; 255
    1064:	60 e0       	ldi	r22, 0x00	; 0
    1066:	70 e0       	ldi	r23, 0x00	; 0
    1068:	80 91 36 09 	lds	r24, 0x0936
    106c:	90 91 37 09 	lds	r25, 0x0937
    1070:	a9 d3       	rcall	.+1874   	; 0x17c4 <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    1072:	82 e4       	ldi	r24, 0x42	; 66
    1074:	99 e0       	ldi	r25, 0x09	; 9
    1076:	60 d4       	rcall	.+2240   	; 0x1938 <ringBufferPeek>
    1078:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    107a:	82 e4       	ldi	r24, 0x42	; 66
    107c:	99 e0       	ldi	r25, 0x09	; 9
    107e:	96 d4       	rcall	.+2348   	; 0x19ac <ringBufferNotEmpty>
    1080:	88 23       	and	r24, r24
    1082:	51 f0       	breq	.+20     	; 0x1098 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    1084:	20 e0       	ldi	r18, 0x00	; 0
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	60 e0       	ldi	r22, 0x00	; 0
    108c:	70 e0       	ldi	r23, 0x00	; 0
    108e:	80 91 36 09 	lds	r24, 0x0936
    1092:	90 91 37 09 	lds	r25, 0x0937
    1096:	9e d2       	rcall	.+1340   	; 0x15d4 <xQueueGenericSend>
	}
	
	return data;
    1098:	8c 2f       	mov	r24, r28
    109a:	cf 91       	pop	r28
    109c:	08 95       	ret

0000109e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    109e:	31 e1       	ldi	r19, 0x11	; 17
    10a0:	fc 01       	movw	r30, r24
    10a2:	30 83       	st	Z, r19
    10a4:	31 97       	sbiw	r30, 0x01	; 1
    10a6:	22 e2       	ldi	r18, 0x22	; 34
    10a8:	20 83       	st	Z, r18
    10aa:	31 97       	sbiw	r30, 0x01	; 1
    10ac:	a3 e3       	ldi	r26, 0x33	; 51
    10ae:	a0 83       	st	Z, r26
    10b0:	31 97       	sbiw	r30, 0x01	; 1
    10b2:	60 83       	st	Z, r22
    10b4:	31 97       	sbiw	r30, 0x01	; 1
    10b6:	70 83       	st	Z, r23
    10b8:	31 97       	sbiw	r30, 0x01	; 1
    10ba:	10 82       	st	Z, r1
    10bc:	31 97       	sbiw	r30, 0x01	; 1
    10be:	10 82       	st	Z, r1
    10c0:	31 97       	sbiw	r30, 0x01	; 1
    10c2:	60 e8       	ldi	r22, 0x80	; 128
    10c4:	60 83       	st	Z, r22
    10c6:	31 97       	sbiw	r30, 0x01	; 1
    10c8:	10 82       	st	Z, r1
    10ca:	31 97       	sbiw	r30, 0x01	; 1
    10cc:	10 82       	st	Z, r1
    10ce:	31 97       	sbiw	r30, 0x01	; 1
    10d0:	10 82       	st	Z, r1
    10d2:	31 97       	sbiw	r30, 0x01	; 1
    10d4:	62 e0       	ldi	r22, 0x02	; 2
    10d6:	60 83       	st	Z, r22
    10d8:	31 97       	sbiw	r30, 0x01	; 1
    10da:	63 e0       	ldi	r22, 0x03	; 3
    10dc:	60 83       	st	Z, r22
    10de:	31 97       	sbiw	r30, 0x01	; 1
    10e0:	64 e0       	ldi	r22, 0x04	; 4
    10e2:	60 83       	st	Z, r22
    10e4:	31 97       	sbiw	r30, 0x01	; 1
    10e6:	65 e0       	ldi	r22, 0x05	; 5
    10e8:	60 83       	st	Z, r22
    10ea:	31 97       	sbiw	r30, 0x01	; 1
    10ec:	66 e0       	ldi	r22, 0x06	; 6
    10ee:	60 83       	st	Z, r22
    10f0:	31 97       	sbiw	r30, 0x01	; 1
    10f2:	67 e0       	ldi	r22, 0x07	; 7
    10f4:	60 83       	st	Z, r22
    10f6:	31 97       	sbiw	r30, 0x01	; 1
    10f8:	68 e0       	ldi	r22, 0x08	; 8
    10fa:	60 83       	st	Z, r22
    10fc:	31 97       	sbiw	r30, 0x01	; 1
    10fe:	69 e0       	ldi	r22, 0x09	; 9
    1100:	60 83       	st	Z, r22
    1102:	31 97       	sbiw	r30, 0x01	; 1
    1104:	60 e1       	ldi	r22, 0x10	; 16
    1106:	60 83       	st	Z, r22
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	30 83       	st	Z, r19
    110c:	31 97       	sbiw	r30, 0x01	; 1
    110e:	32 e1       	ldi	r19, 0x12	; 18
    1110:	30 83       	st	Z, r19
    1112:	31 97       	sbiw	r30, 0x01	; 1
    1114:	33 e1       	ldi	r19, 0x13	; 19
    1116:	30 83       	st	Z, r19
    1118:	31 97       	sbiw	r30, 0x01	; 1
    111a:	34 e1       	ldi	r19, 0x14	; 20
    111c:	30 83       	st	Z, r19
    111e:	31 97       	sbiw	r30, 0x01	; 1
    1120:	35 e1       	ldi	r19, 0x15	; 21
    1122:	30 83       	st	Z, r19
    1124:	31 97       	sbiw	r30, 0x01	; 1
    1126:	36 e1       	ldi	r19, 0x16	; 22
    1128:	30 83       	st	Z, r19
    112a:	31 97       	sbiw	r30, 0x01	; 1
    112c:	37 e1       	ldi	r19, 0x17	; 23
    112e:	30 83       	st	Z, r19
    1130:	31 97       	sbiw	r30, 0x01	; 1
    1132:	38 e1       	ldi	r19, 0x18	; 24
    1134:	30 83       	st	Z, r19
    1136:	31 97       	sbiw	r30, 0x01	; 1
    1138:	39 e1       	ldi	r19, 0x19	; 25
    113a:	30 83       	st	Z, r19
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	30 e2       	ldi	r19, 0x20	; 32
    1140:	30 83       	st	Z, r19
    1142:	31 97       	sbiw	r30, 0x01	; 1
    1144:	31 e2       	ldi	r19, 0x21	; 33
    1146:	30 83       	st	Z, r19
    1148:	31 97       	sbiw	r30, 0x01	; 1
    114a:	20 83       	st	Z, r18
    114c:	31 97       	sbiw	r30, 0x01	; 1
    114e:	23 e2       	ldi	r18, 0x23	; 35
    1150:	20 83       	st	Z, r18
    1152:	31 97       	sbiw	r30, 0x01	; 1
    1154:	40 83       	st	Z, r20
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	50 83       	st	Z, r21
    115a:	31 97       	sbiw	r30, 0x01	; 1
    115c:	26 e2       	ldi	r18, 0x26	; 38
    115e:	20 83       	st	Z, r18
    1160:	31 97       	sbiw	r30, 0x01	; 1
    1162:	27 e2       	ldi	r18, 0x27	; 39
    1164:	20 83       	st	Z, r18
    1166:	31 97       	sbiw	r30, 0x01	; 1
    1168:	28 e2       	ldi	r18, 0x28	; 40
    116a:	20 83       	st	Z, r18
    116c:	31 97       	sbiw	r30, 0x01	; 1
    116e:	29 e2       	ldi	r18, 0x29	; 41
    1170:	20 83       	st	Z, r18
    1172:	31 97       	sbiw	r30, 0x01	; 1
    1174:	20 e3       	ldi	r18, 0x30	; 48
    1176:	20 83       	st	Z, r18
    1178:	31 97       	sbiw	r30, 0x01	; 1
    117a:	21 e3       	ldi	r18, 0x31	; 49
    117c:	20 83       	st	Z, r18
    117e:	89 97       	sbiw	r24, 0x29	; 41
    1180:	08 95       	ret

00001182 <xPortStartScheduler>:
    1182:	82 e0       	ldi	r24, 0x02	; 2
    1184:	84 bd       	out	0x24, r24	; 36
    1186:	16 bc       	out	0x26, r1	; 38
    1188:	80 e3       	ldi	r24, 0x30	; 48
    118a:	87 bd       	out	0x27, r24	; 39
    118c:	ee e6       	ldi	r30, 0x6E	; 110
    118e:	f0 e0       	ldi	r31, 0x00	; 0
    1190:	80 81       	ld	r24, Z
    1192:	82 60       	ori	r24, 0x02	; 2
    1194:	80 83       	st	Z, r24
    1196:	83 e0       	ldi	r24, 0x03	; 3
    1198:	85 bd       	out	0x25, r24	; 37
    119a:	a0 91 8d 08 	lds	r26, 0x088D
    119e:	b0 91 8e 08 	lds	r27, 0x088E
    11a2:	cd 91       	ld	r28, X+
    11a4:	cd bf       	out	0x3d, r28	; 61
    11a6:	dd 91       	ld	r29, X+
    11a8:	de bf       	out	0x3e, r29	; 62
    11aa:	ff 91       	pop	r31
    11ac:	ef 91       	pop	r30
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	bf 91       	pop	r27
    11b4:	af 91       	pop	r26
    11b6:	9f 91       	pop	r25
    11b8:	8f 91       	pop	r24
    11ba:	7f 91       	pop	r23
    11bc:	6f 91       	pop	r22
    11be:	5f 91       	pop	r21
    11c0:	4f 91       	pop	r20
    11c2:	3f 91       	pop	r19
    11c4:	2f 91       	pop	r18
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	ef 90       	pop	r14
    11ce:	df 90       	pop	r13
    11d0:	cf 90       	pop	r12
    11d2:	bf 90       	pop	r11
    11d4:	af 90       	pop	r10
    11d6:	9f 90       	pop	r9
    11d8:	8f 90       	pop	r8
    11da:	7f 90       	pop	r7
    11dc:	6f 90       	pop	r6
    11de:	5f 90       	pop	r5
    11e0:	4f 90       	pop	r4
    11e2:	3f 90       	pop	r3
    11e4:	2f 90       	pop	r2
    11e6:	1f 90       	pop	r1
    11e8:	0f 90       	pop	r0
    11ea:	0c be       	out	0x3c, r0	; 60
    11ec:	0f 90       	pop	r0
    11ee:	0b be       	out	0x3b, r0	; 59
    11f0:	0f 90       	pop	r0
    11f2:	0f be       	out	0x3f, r0	; 63
    11f4:	0f 90       	pop	r0
    11f6:	08 95       	ret
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	08 95       	ret

000011fc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    11fc:	0f 92       	push	r0
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	0f 92       	push	r0
    1204:	0b b6       	in	r0, 0x3b	; 59
    1206:	0f 92       	push	r0
    1208:	0c b6       	in	r0, 0x3c	; 60
    120a:	0f 92       	push	r0
    120c:	1f 92       	push	r1
    120e:	11 24       	eor	r1, r1
    1210:	2f 92       	push	r2
    1212:	3f 92       	push	r3
    1214:	4f 92       	push	r4
    1216:	5f 92       	push	r5
    1218:	6f 92       	push	r6
    121a:	7f 92       	push	r7
    121c:	8f 92       	push	r8
    121e:	9f 92       	push	r9
    1220:	af 92       	push	r10
    1222:	bf 92       	push	r11
    1224:	cf 92       	push	r12
    1226:	df 92       	push	r13
    1228:	ef 92       	push	r14
    122a:	ff 92       	push	r15
    122c:	0f 93       	push	r16
    122e:	1f 93       	push	r17
    1230:	2f 93       	push	r18
    1232:	3f 93       	push	r19
    1234:	4f 93       	push	r20
    1236:	5f 93       	push	r21
    1238:	6f 93       	push	r22
    123a:	7f 93       	push	r23
    123c:	8f 93       	push	r24
    123e:	9f 93       	push	r25
    1240:	af 93       	push	r26
    1242:	bf 93       	push	r27
    1244:	cf 93       	push	r28
    1246:	df 93       	push	r29
    1248:	ef 93       	push	r30
    124a:	ff 93       	push	r31
    124c:	a0 91 8d 08 	lds	r26, 0x088D
    1250:	b0 91 8e 08 	lds	r27, 0x088E
    1254:	0d b6       	in	r0, 0x3d	; 61
    1256:	0d 92       	st	X+, r0
    1258:	0e b6       	in	r0, 0x3e	; 62
    125a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    125c:	75 d7       	rcall	.+3818   	; 0x2148 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    125e:	a0 91 8d 08 	lds	r26, 0x088D
    1262:	b0 91 8e 08 	lds	r27, 0x088E
    1266:	cd 91       	ld	r28, X+
    1268:	cd bf       	out	0x3d, r28	; 61
    126a:	dd 91       	ld	r29, X+
    126c:	de bf       	out	0x3e, r29	; 62
    126e:	ff 91       	pop	r31
    1270:	ef 91       	pop	r30
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	bf 91       	pop	r27
    1278:	af 91       	pop	r26
    127a:	9f 91       	pop	r25
    127c:	8f 91       	pop	r24
    127e:	7f 91       	pop	r23
    1280:	6f 91       	pop	r22
    1282:	5f 91       	pop	r21
    1284:	4f 91       	pop	r20
    1286:	3f 91       	pop	r19
    1288:	2f 91       	pop	r18
    128a:	1f 91       	pop	r17
    128c:	0f 91       	pop	r16
    128e:	ff 90       	pop	r15
    1290:	ef 90       	pop	r14
    1292:	df 90       	pop	r13
    1294:	cf 90       	pop	r12
    1296:	bf 90       	pop	r11
    1298:	af 90       	pop	r10
    129a:	9f 90       	pop	r9
    129c:	8f 90       	pop	r8
    129e:	7f 90       	pop	r7
    12a0:	6f 90       	pop	r6
    12a2:	5f 90       	pop	r5
    12a4:	4f 90       	pop	r4
    12a6:	3f 90       	pop	r3
    12a8:	2f 90       	pop	r2
    12aa:	1f 90       	pop	r1
    12ac:	0f 90       	pop	r0
    12ae:	0c be       	out	0x3c, r0	; 60
    12b0:	0f 90       	pop	r0
    12b2:	0b be       	out	0x3b, r0	; 59
    12b4:	0f 90       	pop	r0
    12b6:	0f be       	out	0x3f, r0	; 63
    12b8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12ba:	08 95       	ret

000012bc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12bc:	0f 92       	push	r0
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	f8 94       	cli
    12c2:	0f 92       	push	r0
    12c4:	0b b6       	in	r0, 0x3b	; 59
    12c6:	0f 92       	push	r0
    12c8:	0c b6       	in	r0, 0x3c	; 60
    12ca:	0f 92       	push	r0
    12cc:	1f 92       	push	r1
    12ce:	11 24       	eor	r1, r1
    12d0:	2f 92       	push	r2
    12d2:	3f 92       	push	r3
    12d4:	4f 92       	push	r4
    12d6:	5f 92       	push	r5
    12d8:	6f 92       	push	r6
    12da:	7f 92       	push	r7
    12dc:	8f 92       	push	r8
    12de:	9f 92       	push	r9
    12e0:	af 92       	push	r10
    12e2:	bf 92       	push	r11
    12e4:	cf 92       	push	r12
    12e6:	df 92       	push	r13
    12e8:	ef 92       	push	r14
    12ea:	ff 92       	push	r15
    12ec:	0f 93       	push	r16
    12ee:	1f 93       	push	r17
    12f0:	2f 93       	push	r18
    12f2:	3f 93       	push	r19
    12f4:	4f 93       	push	r20
    12f6:	5f 93       	push	r21
    12f8:	6f 93       	push	r22
    12fa:	7f 93       	push	r23
    12fc:	8f 93       	push	r24
    12fe:	9f 93       	push	r25
    1300:	af 93       	push	r26
    1302:	bf 93       	push	r27
    1304:	cf 93       	push	r28
    1306:	df 93       	push	r29
    1308:	ef 93       	push	r30
    130a:	ff 93       	push	r31
    130c:	a0 91 8d 08 	lds	r26, 0x088D
    1310:	b0 91 8e 08 	lds	r27, 0x088E
    1314:	0d b6       	in	r0, 0x3d	; 61
    1316:	0d 92       	st	X+, r0
    1318:	0e b6       	in	r0, 0x3e	; 62
    131a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    131c:	43 d5       	rcall	.+2694   	; 0x1da4 <xTaskIncrementTick>
    131e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1320:	13 d7       	rcall	.+3622   	; 0x2148 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1322:	a0 91 8d 08 	lds	r26, 0x088D
    1326:	b0 91 8e 08 	lds	r27, 0x088E
    132a:	cd 91       	ld	r28, X+
    132c:	cd bf       	out	0x3d, r28	; 61
    132e:	dd 91       	ld	r29, X+
    1330:	de bf       	out	0x3e, r29	; 62
    1332:	ff 91       	pop	r31
    1334:	ef 91       	pop	r30
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	bf 91       	pop	r27
    133c:	af 91       	pop	r26
    133e:	9f 91       	pop	r25
    1340:	8f 91       	pop	r24
    1342:	7f 91       	pop	r23
    1344:	6f 91       	pop	r22
    1346:	5f 91       	pop	r21
    1348:	4f 91       	pop	r20
    134a:	3f 91       	pop	r19
    134c:	2f 91       	pop	r18
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	ff 90       	pop	r15
    1354:	ef 90       	pop	r14
    1356:	df 90       	pop	r13
    1358:	cf 90       	pop	r12
    135a:	bf 90       	pop	r11
    135c:	af 90       	pop	r10
    135e:	9f 90       	pop	r9
    1360:	8f 90       	pop	r8
    1362:	7f 90       	pop	r7
    1364:	6f 90       	pop	r6
    1366:	5f 90       	pop	r5
    1368:	4f 90       	pop	r4
    136a:	3f 90       	pop	r3
    136c:	2f 90       	pop	r2
    136e:	1f 90       	pop	r1
    1370:	0f 90       	pop	r0
    1372:	0c be       	out	0x3c, r0	; 60
    1374:	0f 90       	pop	r0
    1376:	0b be       	out	0x3b, r0	; 59
    1378:	0f 90       	pop	r0
    137a:	0f be       	out	0x3f, r0	; 63
    137c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    137e:	08 95       	ret

00001380 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1380:	9d df       	rcall	.-198    	; 0x12bc <vPortYieldFromTick>
		 asm volatile ("reti");
    1382:	18 95       	reti

00001384 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1384:	1f 93       	push	r17
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	ec 01       	movw	r28, r24
    138c:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    138e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1390:	81 11       	cpse	r24, r1
    1392:	0c c0       	rjmp	.+24     	; 0x13ac <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1394:	88 81       	ld	r24, Y
    1396:	99 81       	ldd	r25, Y+1	; 0x01
    1398:	89 2b       	or	r24, r25
    139a:	09 f0       	breq	.+2      	; 0x139e <prvCopyDataToQueue+0x1a>
    139c:	47 c0       	rjmp	.+142    	; 0x142c <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    139e:	8a 81       	ldd	r24, Y+2	; 0x02
    13a0:	9b 81       	ldd	r25, Y+3	; 0x03
    13a2:	0e 94 67 12 	call	0x24ce	; 0x24ce <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    13a6:	1b 82       	std	Y+3, r1	; 0x03
    13a8:	1a 82       	std	Y+2, r1	; 0x02
    13aa:	47 c0       	rjmp	.+142    	; 0x143a <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    13ac:	41 11       	cpse	r20, r1
    13ae:	18 c0       	rjmp	.+48     	; 0x13e0 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    13b0:	48 2f       	mov	r20, r24
    13b2:	50 e0       	ldi	r21, 0x00	; 0
    13b4:	8c 81       	ldd	r24, Y+4	; 0x04
    13b6:	9d 81       	ldd	r25, Y+5	; 0x05
    13b8:	0e 94 33 16 	call	0x2c66	; 0x2c66 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    13bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13be:	8c 81       	ldd	r24, Y+4	; 0x04
    13c0:	9d 81       	ldd	r25, Y+5	; 0x05
    13c2:	82 0f       	add	r24, r18
    13c4:	91 1d       	adc	r25, r1
    13c6:	9d 83       	std	Y+5, r25	; 0x05
    13c8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    13ca:	2a 81       	ldd	r18, Y+2	; 0x02
    13cc:	3b 81       	ldd	r19, Y+3	; 0x03
    13ce:	82 17       	cp	r24, r18
    13d0:	93 07       	cpc	r25, r19
    13d2:	70 f1       	brcs	.+92     	; 0x1430 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    13d4:	88 81       	ld	r24, Y
    13d6:	99 81       	ldd	r25, Y+1	; 0x01
    13d8:	9d 83       	std	Y+5, r25	; 0x05
    13da:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	2d c0       	rjmp	.+90     	; 0x143a <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13e0:	48 2f       	mov	r20, r24
    13e2:	50 e0       	ldi	r21, 0x00	; 0
    13e4:	8e 81       	ldd	r24, Y+6	; 0x06
    13e6:	9f 81       	ldd	r25, Y+7	; 0x07
    13e8:	0e 94 33 16 	call	0x2c66	; 0x2c66 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    13ec:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    13f0:	31 95       	neg	r19
    13f2:	21 95       	neg	r18
    13f4:	31 09       	sbc	r19, r1
    13f6:	8e 81       	ldd	r24, Y+6	; 0x06
    13f8:	9f 81       	ldd	r25, Y+7	; 0x07
    13fa:	82 0f       	add	r24, r18
    13fc:	93 1f       	adc	r25, r19
    13fe:	9f 83       	std	Y+7, r25	; 0x07
    1400:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1402:	68 81       	ld	r22, Y
    1404:	79 81       	ldd	r23, Y+1	; 0x01
    1406:	86 17       	cp	r24, r22
    1408:	97 07       	cpc	r25, r23
    140a:	30 f4       	brcc	.+12     	; 0x1418 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    140c:	8a 81       	ldd	r24, Y+2	; 0x02
    140e:	9b 81       	ldd	r25, Y+3	; 0x03
    1410:	28 0f       	add	r18, r24
    1412:	39 1f       	adc	r19, r25
    1414:	3f 83       	std	Y+7, r19	; 0x07
    1416:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1418:	12 30       	cpi	r17, 0x02	; 2
    141a:	61 f4       	brne	.+24     	; 0x1434 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    141c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    141e:	88 23       	and	r24, r24
    1420:	59 f0       	breq	.+22     	; 0x1438 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1422:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1424:	81 50       	subi	r24, 0x01	; 1
    1426:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1428:	80 e0       	ldi	r24, 0x00	; 0
    142a:	07 c0       	rjmp	.+14     	; 0x143a <prvCopyDataToQueue+0xb6>
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	05 c0       	rjmp	.+10     	; 0x143a <prvCopyDataToQueue+0xb6>
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	03 c0       	rjmp	.+6      	; 0x143a <prvCopyDataToQueue+0xb6>
    1434:	80 e0       	ldi	r24, 0x00	; 0
    1436:	01 c0       	rjmp	.+2      	; 0x143a <prvCopyDataToQueue+0xb6>
    1438:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    143a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    143c:	9f 5f       	subi	r25, 0xFF	; 255
    143e:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1440:	df 91       	pop	r29
    1442:	cf 91       	pop	r28
    1444:	1f 91       	pop	r17
    1446:	08 95       	ret

00001448 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1448:	fc 01       	movw	r30, r24
    144a:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    144c:	44 8d       	ldd	r20, Z+28	; 0x1c
    144e:	44 23       	and	r20, r20
    1450:	a1 f0       	breq	.+40     	; 0x147a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1452:	50 e0       	ldi	r21, 0x00	; 0
    1454:	26 81       	ldd	r18, Z+6	; 0x06
    1456:	37 81       	ldd	r19, Z+7	; 0x07
    1458:	24 0f       	add	r18, r20
    145a:	35 1f       	adc	r19, r21
    145c:	37 83       	std	Z+7, r19	; 0x07
    145e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1460:	62 81       	ldd	r22, Z+2	; 0x02
    1462:	73 81       	ldd	r23, Z+3	; 0x03
    1464:	26 17       	cp	r18, r22
    1466:	37 07       	cpc	r19, r23
    1468:	20 f0       	brcs	.+8      	; 0x1472 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    146a:	20 81       	ld	r18, Z
    146c:	31 81       	ldd	r19, Z+1	; 0x01
    146e:	37 83       	std	Z+7, r19	; 0x07
    1470:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1472:	66 81       	ldd	r22, Z+6	; 0x06
    1474:	77 81       	ldd	r23, Z+7	; 0x07
    1476:	0c 94 33 16 	jmp	0x2c66	; 0x2c66 <memcpy>
    147a:	08 95       	ret

0000147c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	cf 93       	push	r28
    1482:	df 93       	push	r29
    1484:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    148c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    148e:	18 16       	cp	r1, r24
    1490:	a4 f4       	brge	.+40     	; 0x14ba <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1492:	89 89       	ldd	r24, Y+17	; 0x11
    1494:	88 23       	and	r24, r24
    1496:	89 f0       	breq	.+34     	; 0x14ba <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1498:	8e 01       	movw	r16, r28
    149a:	0f 5e       	subi	r16, 0xEF	; 239
    149c:	1f 4f       	sbci	r17, 0xFF	; 255
    149e:	03 c0       	rjmp	.+6      	; 0x14a6 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14a0:	89 89       	ldd	r24, Y+17	; 0x11
    14a2:	88 23       	and	r24, r24
    14a4:	51 f0       	breq	.+20     	; 0x14ba <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14a6:	c8 01       	movw	r24, r16
    14a8:	25 d7       	rcall	.+3658   	; 0x22f4 <xTaskRemoveFromEventList>
    14aa:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    14ac:	ae d7       	rcall	.+3932   	; 0x240a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    14ae:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14b0:	81 50       	subi	r24, 0x01	; 1
    14b2:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    14b4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14b6:	18 16       	cp	r1, r24
    14b8:	9c f3       	brlt	.-26     	; 0x14a0 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    14ba:	8f ef       	ldi	r24, 0xFF	; 255
    14bc:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14c8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14ca:	18 16       	cp	r1, r24
    14cc:	a4 f4       	brge	.+40     	; 0x14f6 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14ce:	88 85       	ldd	r24, Y+8	; 0x08
    14d0:	88 23       	and	r24, r24
    14d2:	89 f0       	breq	.+34     	; 0x14f6 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14d4:	8e 01       	movw	r16, r28
    14d6:	08 5f       	subi	r16, 0xF8	; 248
    14d8:	1f 4f       	sbci	r17, 0xFF	; 255
    14da:	03 c0       	rjmp	.+6      	; 0x14e2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14dc:	88 85       	ldd	r24, Y+8	; 0x08
    14de:	88 23       	and	r24, r24
    14e0:	51 f0       	breq	.+20     	; 0x14f6 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14e2:	c8 01       	movw	r24, r16
    14e4:	07 d7       	rcall	.+3598   	; 0x22f4 <xTaskRemoveFromEventList>
    14e6:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    14e8:	90 d7       	rcall	.+3872   	; 0x240a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    14ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14ec:	81 50       	subi	r24, 0x01	; 1
    14ee:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    14f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14f2:	18 16       	cp	r1, r24
    14f4:	9c f3       	brlt	.-26     	; 0x14dc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    14f6:	8f ef       	ldi	r24, 0xFF	; 255
    14f8:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63
}
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	08 95       	ret

00001508 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1514:	88 81       	ld	r24, Y
    1516:	99 81       	ldd	r25, Y+1	; 0x01
    1518:	2c 8d       	ldd	r18, Y+28	; 0x1c
    151a:	30 e0       	ldi	r19, 0x00	; 0
    151c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    151e:	72 9f       	mul	r23, r18
    1520:	a0 01       	movw	r20, r0
    1522:	73 9f       	mul	r23, r19
    1524:	50 0d       	add	r21, r0
    1526:	11 24       	eor	r1, r1
    1528:	fc 01       	movw	r30, r24
    152a:	e4 0f       	add	r30, r20
    152c:	f5 1f       	adc	r31, r21
    152e:	fb 83       	std	Y+3, r31	; 0x03
    1530:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1532:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1534:	9d 83       	std	Y+5, r25	; 0x05
    1536:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1538:	42 1b       	sub	r20, r18
    153a:	53 0b       	sbc	r21, r19
    153c:	84 0f       	add	r24, r20
    153e:	95 1f       	adc	r25, r21
    1540:	9f 83       	std	Y+7, r25	; 0x07
    1542:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1544:	8f ef       	ldi	r24, 0xFF	; 255
    1546:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1548:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    154a:	61 11       	cpse	r22, r1
    154c:	0a c0       	rjmp	.+20     	; 0x1562 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    154e:	88 85       	ldd	r24, Y+8	; 0x08
    1550:	88 23       	and	r24, r24
    1552:	69 f0       	breq	.+26     	; 0x156e <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1554:	ce 01       	movw	r24, r28
    1556:	08 96       	adiw	r24, 0x08	; 8
    1558:	cd d6       	rcall	.+3482   	; 0x22f4 <xTaskRemoveFromEventList>
    155a:	81 30       	cpi	r24, 0x01	; 1
    155c:	41 f4       	brne	.+16     	; 0x156e <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    155e:	4e de       	rcall	.-868    	; 0x11fc <vPortYield>
    1560:	06 c0       	rjmp	.+12     	; 0x156e <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1562:	ce 01       	movw	r24, r28
    1564:	08 96       	adiw	r24, 0x08	; 8
    1566:	1e d8       	rcall	.-4036   	; 0x5a4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1568:	ce 01       	movw	r24, r28
    156a:	41 96       	adiw	r24, 0x11	; 17
    156c:	1b d8       	rcall	.-4042   	; 0x5a4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    156e:	0f 90       	pop	r0
    1570:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1572:	81 e0       	ldi	r24, 0x01	; 1
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	08 95       	ret

0000157a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	18 2f       	mov	r17, r24
    1584:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1586:	88 23       	and	r24, r24
    1588:	e9 f0       	breq	.+58     	; 0x15c4 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    158a:	8f e1       	ldi	r24, 0x1F	; 31
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 9c 02 	call	0x538	; 0x538 <pvPortMalloc>
    1592:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1594:	00 97       	sbiw	r24, 0x00	; 0
    1596:	c1 f0       	breq	.+48     	; 0x15c8 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1598:	10 9f       	mul	r17, r16
    159a:	c0 01       	movw	r24, r0
    159c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    159e:	01 96       	adiw	r24, 0x01	; 1
    15a0:	0e 94 9c 02 	call	0x538	; 0x538 <pvPortMalloc>
    15a4:	99 83       	std	Y+1, r25	; 0x01
    15a6:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    15a8:	89 2b       	or	r24, r25
    15aa:	31 f0       	breq	.+12     	; 0x15b8 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    15ac:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    15ae:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    15b0:	61 e0       	ldi	r22, 0x01	; 1
    15b2:	ce 01       	movw	r24, r28
    15b4:	a9 df       	rcall	.-174    	; 0x1508 <xQueueGenericReset>
    15b6:	08 c0       	rjmp	.+16     	; 0x15c8 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    15b8:	ce 01       	movw	r24, r28
    15ba:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    15be:	c0 e0       	ldi	r28, 0x00	; 0
    15c0:	d0 e0       	ldi	r29, 0x00	; 0
    15c2:	02 c0       	rjmp	.+4      	; 0x15c8 <xQueueGenericCreate+0x4e>
    15c4:	c0 e0       	ldi	r28, 0x00	; 0
    15c6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    15c8:	ce 01       	movw	r24, r28
    15ca:	df 91       	pop	r29
    15cc:	cf 91       	pop	r28
    15ce:	1f 91       	pop	r17
    15d0:	0f 91       	pop	r16
    15d2:	08 95       	ret

000015d4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    15d4:	9f 92       	push	r9
    15d6:	af 92       	push	r10
    15d8:	bf 92       	push	r11
    15da:	cf 92       	push	r12
    15dc:	df 92       	push	r13
    15de:	ef 92       	push	r14
    15e0:	ff 92       	push	r15
    15e2:	0f 93       	push	r16
    15e4:	1f 93       	push	r17
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	00 d0       	rcall	.+0      	; 0x15ec <xQueueGenericSend+0x18>
    15ec:	1f 92       	push	r1
    15ee:	1f 92       	push	r1
    15f0:	cd b7       	in	r28, 0x3d	; 61
    15f2:	de b7       	in	r29, 0x3e	; 62
    15f4:	8c 01       	movw	r16, r24
    15f6:	6b 01       	movw	r12, r22
    15f8:	5d 83       	std	Y+5, r21	; 0x05
    15fa:	4c 83       	std	Y+4, r20	; 0x04
    15fc:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    15fe:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1600:	99 24       	eor	r9, r9
    1602:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1604:	7c 01       	movw	r14, r24
    1606:	88 e0       	ldi	r24, 0x08	; 8
    1608:	e8 0e       	add	r14, r24
    160a:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    160c:	0f b6       	in	r0, 0x3f	; 63
    160e:	f8 94       	cli
    1610:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1612:	f8 01       	movw	r30, r16
    1614:	92 8d       	ldd	r25, Z+26	; 0x1a
    1616:	83 8d       	ldd	r24, Z+27	; 0x1b
    1618:	98 17       	cp	r25, r24
    161a:	18 f0       	brcs	.+6      	; 0x1622 <xQueueGenericSend+0x4e>
    161c:	f2 e0       	ldi	r31, 0x02	; 2
    161e:	af 12       	cpse	r10, r31
    1620:	15 c0       	rjmp	.+42     	; 0x164c <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1622:	4a 2d       	mov	r20, r10
    1624:	b6 01       	movw	r22, r12
    1626:	c8 01       	movw	r24, r16
    1628:	ad de       	rcall	.-678    	; 0x1384 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    162a:	f8 01       	movw	r30, r16
    162c:	91 89       	ldd	r25, Z+17	; 0x11
    162e:	99 23       	and	r25, r25
    1630:	39 f0       	breq	.+14     	; 0x1640 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1632:	c8 01       	movw	r24, r16
    1634:	41 96       	adiw	r24, 0x11	; 17
    1636:	5e d6       	rcall	.+3260   	; 0x22f4 <xTaskRemoveFromEventList>
    1638:	81 30       	cpi	r24, 0x01	; 1
    163a:	21 f4       	brne	.+8      	; 0x1644 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    163c:	df dd       	rcall	.-1090   	; 0x11fc <vPortYield>
    163e:	02 c0       	rjmp	.+4      	; 0x1644 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1640:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1642:	dc dd       	rcall	.-1096   	; 0x11fc <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1644:	0f 90       	pop	r0
    1646:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	46 c0       	rjmp	.+140    	; 0x16d8 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    164c:	ec 81       	ldd	r30, Y+4	; 0x04
    164e:	fd 81       	ldd	r31, Y+5	; 0x05
    1650:	ef 2b       	or	r30, r31
    1652:	21 f4       	brne	.+8      	; 0x165c <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1654:	0f 90       	pop	r0
    1656:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1658:	80 e0       	ldi	r24, 0x00	; 0
    165a:	3e c0       	rjmp	.+124    	; 0x16d8 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    165c:	b1 10       	cpse	r11, r1
    165e:	04 c0       	rjmp	.+8      	; 0x1668 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1660:	ce 01       	movw	r24, r28
    1662:	01 96       	adiw	r24, 0x01	; 1
    1664:	8f d6       	rcall	.+3358   	; 0x2384 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1666:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1668:	0f 90       	pop	r0
    166a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    166c:	86 d3       	rcall	.+1804   	; 0x1d7a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    166e:	0f b6       	in	r0, 0x3f	; 63
    1670:	f8 94       	cli
    1672:	0f 92       	push	r0
    1674:	f8 01       	movw	r30, r16
    1676:	85 8d       	ldd	r24, Z+29	; 0x1d
    1678:	8f 3f       	cpi	r24, 0xFF	; 255
    167a:	09 f4       	brne	.+2      	; 0x167e <xQueueGenericSend+0xaa>
    167c:	15 8e       	std	Z+29, r1	; 0x1d
    167e:	f8 01       	movw	r30, r16
    1680:	86 8d       	ldd	r24, Z+30	; 0x1e
    1682:	8f 3f       	cpi	r24, 0xFF	; 255
    1684:	09 f4       	brne	.+2      	; 0x1688 <xQueueGenericSend+0xb4>
    1686:	16 8e       	std	Z+30, r1	; 0x1e
    1688:	0f 90       	pop	r0
    168a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    168c:	be 01       	movw	r22, r28
    168e:	6c 5f       	subi	r22, 0xFC	; 252
    1690:	7f 4f       	sbci	r23, 0xFF	; 255
    1692:	ce 01       	movw	r24, r28
    1694:	01 96       	adiw	r24, 0x01	; 1
    1696:	81 d6       	rcall	.+3330   	; 0x239a <xTaskCheckForTimeOut>
    1698:	81 11       	cpse	r24, r1
    169a:	1a c0       	rjmp	.+52     	; 0x16d0 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    16a2:	f8 01       	movw	r30, r16
    16a4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16aa:	f8 01       	movw	r30, r16
    16ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    16ae:	98 13       	cpse	r25, r24
    16b0:	0b c0       	rjmp	.+22     	; 0x16c8 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16b2:	6c 81       	ldd	r22, Y+4	; 0x04
    16b4:	7d 81       	ldd	r23, Y+5	; 0x05
    16b6:	c7 01       	movw	r24, r14
    16b8:	f2 d5       	rcall	.+3044   	; 0x229e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16ba:	c8 01       	movw	r24, r16
    16bc:	df de       	rcall	.-578    	; 0x147c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    16be:	30 d4       	rcall	.+2144   	; 0x1f20 <xTaskResumeAll>
    16c0:	81 11       	cpse	r24, r1
    16c2:	a4 cf       	rjmp	.-184    	; 0x160c <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    16c4:	9b dd       	rcall	.-1226   	; 0x11fc <vPortYield>
    16c6:	a2 cf       	rjmp	.-188    	; 0x160c <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16c8:	c8 01       	movw	r24, r16
    16ca:	d8 de       	rcall	.-592    	; 0x147c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16cc:	29 d4       	rcall	.+2130   	; 0x1f20 <xTaskResumeAll>
    16ce:	9e cf       	rjmp	.-196    	; 0x160c <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    16d0:	c8 01       	movw	r24, r16
    16d2:	d4 de       	rcall	.-600    	; 0x147c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16d4:	25 d4       	rcall	.+2122   	; 0x1f20 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    16d6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    16d8:	0f 90       	pop	r0
    16da:	0f 90       	pop	r0
    16dc:	0f 90       	pop	r0
    16de:	0f 90       	pop	r0
    16e0:	0f 90       	pop	r0
    16e2:	df 91       	pop	r29
    16e4:	cf 91       	pop	r28
    16e6:	1f 91       	pop	r17
    16e8:	0f 91       	pop	r16
    16ea:	ff 90       	pop	r15
    16ec:	ef 90       	pop	r14
    16ee:	df 90       	pop	r13
    16f0:	cf 90       	pop	r12
    16f2:	bf 90       	pop	r11
    16f4:	af 90       	pop	r10
    16f6:	9f 90       	pop	r9
    16f8:	08 95       	ret

000016fa <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    16fa:	cf 93       	push	r28
    16fc:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    16fe:	8f e1       	ldi	r24, 0x1F	; 31
    1700:	90 e0       	ldi	r25, 0x00	; 0
    1702:	0e 94 9c 02 	call	0x538	; 0x538 <pvPortMalloc>
    1706:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1708:	00 97       	sbiw	r24, 0x00	; 0
    170a:	f1 f0       	breq	.+60     	; 0x1748 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    170c:	1b 82       	std	Y+3, r1	; 0x03
    170e:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1710:	19 82       	std	Y+1, r1	; 0x01
    1712:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1714:	1d 82       	std	Y+5, r1	; 0x05
    1716:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1718:	1f 82       	std	Y+7, r1	; 0x07
    171a:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    171c:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1722:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1724:	8f ef       	ldi	r24, 0xFF	; 255
    1726:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1728:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    172a:	ce 01       	movw	r24, r28
    172c:	08 96       	adiw	r24, 0x08	; 8
    172e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1732:	ce 01       	movw	r24, r28
    1734:	41 96       	adiw	r24, 0x11	; 17
    1736:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    173a:	20 e0       	ldi	r18, 0x00	; 0
    173c:	40 e0       	ldi	r20, 0x00	; 0
    173e:	50 e0       	ldi	r21, 0x00	; 0
    1740:	60 e0       	ldi	r22, 0x00	; 0
    1742:	70 e0       	ldi	r23, 0x00	; 0
    1744:	ce 01       	movw	r24, r28
    1746:	46 df       	rcall	.-372    	; 0x15d4 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1748:	ce 01       	movw	r24, r28
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	08 95       	ret

00001750 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1750:	0f 93       	push	r16
    1752:	1f 93       	push	r17
    1754:	cf 93       	push	r28
    1756:	df 93       	push	r29
    1758:	ec 01       	movw	r28, r24
    175a:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    175c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    175e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1760:	98 17       	cp	r25, r24
    1762:	10 f0       	brcs	.+4      	; 0x1768 <xQueueGenericSendFromISR+0x18>
    1764:	22 30       	cpi	r18, 0x02	; 2
    1766:	11 f5       	brne	.+68     	; 0x17ac <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1768:	42 2f       	mov	r20, r18
    176a:	ce 01       	movw	r24, r28
    176c:	0b de       	rcall	.-1002   	; 0x1384 <prvCopyDataToQueue>
    176e:	88 23       	and	r24, r24
    1770:	31 f0       	breq	.+12     	; 0x177e <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1772:	01 15       	cp	r16, r1
    1774:	11 05       	cpc	r17, r1
    1776:	19 f0       	breq	.+6      	; 0x177e <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	f8 01       	movw	r30, r16
    177c:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    177e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1780:	8f 3f       	cpi	r24, 0xFF	; 255
    1782:	79 f4       	brne	.+30     	; 0x17a2 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1784:	89 89       	ldd	r24, Y+17	; 0x11
    1786:	88 23       	and	r24, r24
    1788:	99 f0       	breq	.+38     	; 0x17b0 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    178a:	ce 01       	movw	r24, r28
    178c:	41 96       	adiw	r24, 0x11	; 17
    178e:	b2 d5       	rcall	.+2916   	; 0x22f4 <xTaskRemoveFromEventList>
    1790:	88 23       	and	r24, r24
    1792:	81 f0       	breq	.+32     	; 0x17b4 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1794:	01 15       	cp	r16, r1
    1796:	11 05       	cpc	r17, r1
    1798:	79 f0       	breq	.+30     	; 0x17b8 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    179a:	81 e0       	ldi	r24, 0x01	; 1
    179c:	f8 01       	movw	r30, r16
    179e:	80 83       	st	Z, r24
    17a0:	0c c0       	rjmp	.+24     	; 0x17ba <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17a4:	8f 5f       	subi	r24, 0xFF	; 255
    17a6:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    17a8:	81 e0       	ldi	r24, 0x01	; 1
    17aa:	07 c0       	rjmp	.+14     	; 0x17ba <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	05 c0       	rjmp	.+10     	; 0x17ba <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	03 c0       	rjmp	.+6      	; 0x17ba <xQueueGenericSendFromISR+0x6a>
    17b4:	81 e0       	ldi	r24, 0x01	; 1
    17b6:	01 c0       	rjmp	.+2      	; 0x17ba <xQueueGenericSendFromISR+0x6a>
    17b8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17ba:	df 91       	pop	r29
    17bc:	cf 91       	pop	r28
    17be:	1f 91       	pop	r17
    17c0:	0f 91       	pop	r16
    17c2:	08 95       	ret

000017c4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    17c4:	9f 92       	push	r9
    17c6:	af 92       	push	r10
    17c8:	bf 92       	push	r11
    17ca:	cf 92       	push	r12
    17cc:	df 92       	push	r13
    17ce:	ef 92       	push	r14
    17d0:	ff 92       	push	r15
    17d2:	0f 93       	push	r16
    17d4:	1f 93       	push	r17
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    17da:	00 d0       	rcall	.+0      	; 0x17dc <xQueueGenericReceive+0x18>
    17dc:	1f 92       	push	r1
    17de:	1f 92       	push	r1
    17e0:	cd b7       	in	r28, 0x3d	; 61
    17e2:	de b7       	in	r29, 0x3e	; 62
    17e4:	8c 01       	movw	r16, r24
    17e6:	6b 01       	movw	r12, r22
    17e8:	5d 83       	std	Y+5, r21	; 0x05
    17ea:	4c 83       	std	Y+4, r20	; 0x04
    17ec:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    17ee:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17f0:	99 24       	eor	r9, r9
    17f2:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17f4:	7c 01       	movw	r14, r24
    17f6:	81 e1       	ldi	r24, 0x11	; 17
    17f8:	e8 0e       	add	r14, r24
    17fa:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1802:	f8 01       	movw	r30, r16
    1804:	82 8d       	ldd	r24, Z+26	; 0x1a
    1806:	88 23       	and	r24, r24
    1808:	69 f1       	breq	.+90     	; 0x1864 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    180a:	e6 80       	ldd	r14, Z+6	; 0x06
    180c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    180e:	b6 01       	movw	r22, r12
    1810:	c8 01       	movw	r24, r16
    1812:	1a de       	rcall	.-972    	; 0x1448 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1814:	b1 10       	cpse	r11, r1
    1816:	17 c0       	rjmp	.+46     	; 0x1846 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1818:	f8 01       	movw	r30, r16
    181a:	82 8d       	ldd	r24, Z+26	; 0x1a
    181c:	81 50       	subi	r24, 0x01	; 1
    181e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1820:	80 81       	ld	r24, Z
    1822:	91 81       	ldd	r25, Z+1	; 0x01
    1824:	89 2b       	or	r24, r25
    1826:	21 f4       	brne	.+8      	; 0x1830 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1828:	91 d6       	rcall	.+3362   	; 0x254c <pvTaskIncrementMutexHeldCount>
    182a:	f8 01       	movw	r30, r16
    182c:	93 83       	std	Z+3, r25	; 0x03
    182e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1830:	f8 01       	movw	r30, r16
    1832:	80 85       	ldd	r24, Z+8	; 0x08
    1834:	88 23       	and	r24, r24
    1836:	91 f0       	breq	.+36     	; 0x185c <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1838:	c8 01       	movw	r24, r16
    183a:	08 96       	adiw	r24, 0x08	; 8
    183c:	5b d5       	rcall	.+2742   	; 0x22f4 <xTaskRemoveFromEventList>
    183e:	81 30       	cpi	r24, 0x01	; 1
    1840:	69 f4       	brne	.+26     	; 0x185c <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1842:	dc dc       	rcall	.-1608   	; 0x11fc <vPortYield>
    1844:	0b c0       	rjmp	.+22     	; 0x185c <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1846:	f8 01       	movw	r30, r16
    1848:	f7 82       	std	Z+7, r15	; 0x07
    184a:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    184c:	81 89       	ldd	r24, Z+17	; 0x11
    184e:	88 23       	and	r24, r24
    1850:	29 f0       	breq	.+10     	; 0x185c <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1852:	c8 01       	movw	r24, r16
    1854:	41 96       	adiw	r24, 0x11	; 17
    1856:	4e d5       	rcall	.+2716   	; 0x22f4 <xTaskRemoveFromEventList>
    1858:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    185a:	d0 dc       	rcall	.-1632   	; 0x11fc <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    185c:	0f 90       	pop	r0
    185e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	52 c0       	rjmp	.+164    	; 0x1908 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1864:	4c 81       	ldd	r20, Y+4	; 0x04
    1866:	5d 81       	ldd	r21, Y+5	; 0x05
    1868:	45 2b       	or	r20, r21
    186a:	21 f4       	brne	.+8      	; 0x1874 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    186c:	0f 90       	pop	r0
    186e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1870:	80 e0       	ldi	r24, 0x00	; 0
    1872:	4a c0       	rjmp	.+148    	; 0x1908 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1874:	a1 10       	cpse	r10, r1
    1876:	04 c0       	rjmp	.+8      	; 0x1880 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1878:	ce 01       	movw	r24, r28
    187a:	01 96       	adiw	r24, 0x01	; 1
    187c:	83 d5       	rcall	.+2822   	; 0x2384 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    187e:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1884:	7a d2       	rcall	.+1268   	; 0x1d7a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1886:	0f b6       	in	r0, 0x3f	; 63
    1888:	f8 94       	cli
    188a:	0f 92       	push	r0
    188c:	f8 01       	movw	r30, r16
    188e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1890:	8f 3f       	cpi	r24, 0xFF	; 255
    1892:	09 f4       	brne	.+2      	; 0x1896 <xQueueGenericReceive+0xd2>
    1894:	15 8e       	std	Z+29, r1	; 0x1d
    1896:	f8 01       	movw	r30, r16
    1898:	86 8d       	ldd	r24, Z+30	; 0x1e
    189a:	8f 3f       	cpi	r24, 0xFF	; 255
    189c:	09 f4       	brne	.+2      	; 0x18a0 <xQueueGenericReceive+0xdc>
    189e:	16 8e       	std	Z+30, r1	; 0x1e
    18a0:	0f 90       	pop	r0
    18a2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18a4:	be 01       	movw	r22, r28
    18a6:	6c 5f       	subi	r22, 0xFC	; 252
    18a8:	7f 4f       	sbci	r23, 0xFF	; 255
    18aa:	ce 01       	movw	r24, r28
    18ac:	01 96       	adiw	r24, 0x01	; 1
    18ae:	75 d5       	rcall	.+2794   	; 0x239a <xTaskCheckForTimeOut>
    18b0:	81 11       	cpse	r24, r1
    18b2:	26 c0       	rjmp	.+76     	; 0x1900 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18b4:	0f b6       	in	r0, 0x3f	; 63
    18b6:	f8 94       	cli
    18b8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    18ba:	f8 01       	movw	r30, r16
    18bc:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18be:	0f 90       	pop	r0
    18c0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18c2:	81 11       	cpse	r24, r1
    18c4:	19 c0       	rjmp	.+50     	; 0x18f8 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18c6:	f8 01       	movw	r30, r16
    18c8:	80 81       	ld	r24, Z
    18ca:	91 81       	ldd	r25, Z+1	; 0x01
    18cc:	89 2b       	or	r24, r25
    18ce:	49 f4       	brne	.+18     	; 0x18e2 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    18d0:	0f b6       	in	r0, 0x3f	; 63
    18d2:	f8 94       	cli
    18d4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    18d6:	f8 01       	movw	r30, r16
    18d8:	82 81       	ldd	r24, Z+2	; 0x02
    18da:	93 81       	ldd	r25, Z+3	; 0x03
    18dc:	9a d5       	rcall	.+2868   	; 0x2412 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18e2:	6c 81       	ldd	r22, Y+4	; 0x04
    18e4:	7d 81       	ldd	r23, Y+5	; 0x05
    18e6:	c7 01       	movw	r24, r14
    18e8:	da d4       	rcall	.+2484   	; 0x229e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18ea:	c8 01       	movw	r24, r16
    18ec:	c7 dd       	rcall	.-1138   	; 0x147c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18ee:	18 d3       	rcall	.+1584   	; 0x1f20 <xTaskResumeAll>
    18f0:	81 11       	cpse	r24, r1
    18f2:	84 cf       	rjmp	.-248    	; 0x17fc <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    18f4:	83 dc       	rcall	.-1786   	; 0x11fc <vPortYield>
    18f6:	82 cf       	rjmp	.-252    	; 0x17fc <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18f8:	c8 01       	movw	r24, r16
    18fa:	c0 dd       	rcall	.-1152   	; 0x147c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18fc:	11 d3       	rcall	.+1570   	; 0x1f20 <xTaskResumeAll>
    18fe:	7e cf       	rjmp	.-260    	; 0x17fc <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1900:	c8 01       	movw	r24, r16
    1902:	bc dd       	rcall	.-1160   	; 0x147c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1904:	0d d3       	rcall	.+1562   	; 0x1f20 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1906:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1908:	0f 90       	pop	r0
    190a:	0f 90       	pop	r0
    190c:	0f 90       	pop	r0
    190e:	0f 90       	pop	r0
    1910:	0f 90       	pop	r0
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	1f 91       	pop	r17
    1918:	0f 91       	pop	r16
    191a:	ff 90       	pop	r15
    191c:	ef 90       	pop	r14
    191e:	df 90       	pop	r13
    1920:	cf 90       	pop	r12
    1922:	bf 90       	pop	r11
    1924:	af 90       	pop	r10
    1926:	9f 90       	pop	r9
    1928:	08 95       	ret

0000192a <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    192a:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    192c:	71 83       	std	Z+1, r23	; 0x01
    192e:	60 83       	st	Z, r22
	ring->rSize = size;
    1930:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1932:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1934:	13 82       	std	Z+3, r1	; 0x03
    1936:	08 95       	ret

00001938 <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1938:	dc 01       	movw	r26, r24
    193a:	14 96       	adiw	r26, 0x04	; 4
    193c:	2c 91       	ld	r18, X
    193e:	14 97       	sbiw	r26, 0x04	; 4
    1940:	ed 91       	ld	r30, X+
    1942:	fc 91       	ld	r31, X
    1944:	e2 0f       	add	r30, r18
    1946:	f1 1d       	adc	r31, r1
}
    1948:	80 81       	ld	r24, Z
    194a:	08 95       	ret

0000194c <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    194c:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    194e:	94 81       	ldd	r25, Z+4	; 0x04
    1950:	a0 81       	ld	r26, Z
    1952:	b1 81       	ldd	r27, Z+1	; 0x01
    1954:	a9 0f       	add	r26, r25
    1956:	b1 1d       	adc	r27, r1
    1958:	8c 91       	ld	r24, X
            ring->rIndex ++;
    195a:	9f 5f       	subi	r25, 0xFF	; 255
    195c:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    195e:	22 81       	ldd	r18, Z+2	; 0x02
    1960:	92 17       	cp	r25, r18
    1962:	10 f0       	brcs	.+4      	; 0x1968 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1964:	92 1b       	sub	r25, r18
    1966:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1968:	93 81       	ldd	r25, Z+3	; 0x03
    196a:	91 50       	subi	r25, 0x01	; 1
    196c:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    196e:	08 95       	ret

00001970 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1970:	fc 01       	movw	r30, r24
    1972:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1974:	83 81       	ldd	r24, Z+3	; 0x03
    1976:	22 81       	ldd	r18, Z+2	; 0x02
    1978:	82 17       	cp	r24, r18
    197a:	80 f4       	brcc	.+32     	; 0x199c <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    197c:	34 81       	ldd	r19, Z+4	; 0x04
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	83 0f       	add	r24, r19
    1982:	91 1d       	adc	r25, r1
    1984:	62 2f       	mov	r22, r18
    1986:	70 e0       	ldi	r23, 0x00	; 0
    1988:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__divmodhi4>
    198c:	a0 81       	ld	r26, Z
    198e:	b1 81       	ldd	r27, Z+1	; 0x01
    1990:	a8 0f       	add	r26, r24
    1992:	b9 1f       	adc	r27, r25
    1994:	4c 93       	st	X, r20
            ring->rLength++;
    1996:	83 81       	ldd	r24, Z+3	; 0x03
    1998:	8f 5f       	subi	r24, 0xFF	; 255
    199a:	83 83       	std	Z+3, r24	; 0x03
    199c:	08 95       	ret

0000199e <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    199e:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    19a0:	81 e0       	ldi	r24, 0x01	; 1
    19a2:	22 81       	ldd	r18, Z+2	; 0x02
    19a4:	93 81       	ldd	r25, Z+3	; 0x03
    19a6:	29 13       	cpse	r18, r25
    19a8:	80 e0       	ldi	r24, 0x00	; 0
}
    19aa:	08 95       	ret

000019ac <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    19ac:	21 e0       	ldi	r18, 0x01	; 1
    19ae:	fc 01       	movw	r30, r24
    19b0:	83 81       	ldd	r24, Z+3	; 0x03
    19b2:	81 11       	cpse	r24, r1
    19b4:	01 c0       	rjmp	.+2      	; 0x19b8 <ringBufferNotEmpty+0xc>
    19b6:	20 e0       	ldi	r18, 0x00	; 0
}
    19b8:	82 2f       	mov	r24, r18
    19ba:	08 95       	ret

000019bc <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    19bc:	e0 91 4c 08 	lds	r30, 0x084C
    19c0:	f0 91 4d 08 	lds	r31, 0x084D
    19c4:	80 81       	ld	r24, Z
    19c6:	81 11       	cpse	r24, r1
    19c8:	07 c0       	rjmp	.+14     	; 0x19d8 <prvResetNextTaskUnblockTime+0x1c>
    19ca:	8f ef       	ldi	r24, 0xFF	; 255
    19cc:	9f ef       	ldi	r25, 0xFF	; 255
    19ce:	90 93 05 02 	sts	0x0205, r25
    19d2:	80 93 04 02 	sts	0x0204, r24
    19d6:	08 95       	ret
    19d8:	e0 91 4c 08 	lds	r30, 0x084C
    19dc:	f0 91 4d 08 	lds	r31, 0x084D
    19e0:	05 80       	ldd	r0, Z+5	; 0x05
    19e2:	f6 81       	ldd	r31, Z+6	; 0x06
    19e4:	e0 2d       	mov	r30, r0
    19e6:	06 80       	ldd	r0, Z+6	; 0x06
    19e8:	f7 81       	ldd	r31, Z+7	; 0x07
    19ea:	e0 2d       	mov	r30, r0
    19ec:	82 81       	ldd	r24, Z+2	; 0x02
    19ee:	93 81       	ldd	r25, Z+3	; 0x03
    19f0:	90 93 05 02 	sts	0x0205, r25
    19f4:	80 93 04 02 	sts	0x0204, r24
    19f8:	08 95       	ret

000019fa <prvAddCurrentTaskToDelayedList>:
    19fa:	cf 93       	push	r28
    19fc:	df 93       	push	r29
    19fe:	ec 01       	movw	r28, r24
    1a00:	e0 91 8d 08 	lds	r30, 0x088D
    1a04:	f0 91 8e 08 	lds	r31, 0x088E
    1a08:	93 83       	std	Z+3, r25	; 0x03
    1a0a:	82 83       	std	Z+2, r24	; 0x02
    1a0c:	80 91 2b 08 	lds	r24, 0x082B
    1a10:	90 91 2c 08 	lds	r25, 0x082C
    1a14:	c8 17       	cp	r28, r24
    1a16:	d9 07       	cpc	r29, r25
    1a18:	68 f4       	brcc	.+26     	; 0x1a34 <prvAddCurrentTaskToDelayedList+0x3a>
    1a1a:	60 91 8d 08 	lds	r22, 0x088D
    1a1e:	70 91 8e 08 	lds	r23, 0x088E
    1a22:	80 91 4a 08 	lds	r24, 0x084A
    1a26:	90 91 4b 08 	lds	r25, 0x084B
    1a2a:	6e 5f       	subi	r22, 0xFE	; 254
    1a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a2e:	0e 94 05 03 	call	0x60a	; 0x60a <vListInsert>
    1a32:	17 c0       	rjmp	.+46     	; 0x1a62 <prvAddCurrentTaskToDelayedList+0x68>
    1a34:	60 91 8d 08 	lds	r22, 0x088D
    1a38:	70 91 8e 08 	lds	r23, 0x088E
    1a3c:	80 91 4c 08 	lds	r24, 0x084C
    1a40:	90 91 4d 08 	lds	r25, 0x084D
    1a44:	6e 5f       	subi	r22, 0xFE	; 254
    1a46:	7f 4f       	sbci	r23, 0xFF	; 255
    1a48:	0e 94 05 03 	call	0x60a	; 0x60a <vListInsert>
    1a4c:	80 91 04 02 	lds	r24, 0x0204
    1a50:	90 91 05 02 	lds	r25, 0x0205
    1a54:	c8 17       	cp	r28, r24
    1a56:	d9 07       	cpc	r29, r25
    1a58:	20 f4       	brcc	.+8      	; 0x1a62 <prvAddCurrentTaskToDelayedList+0x68>
    1a5a:	d0 93 05 02 	sts	0x0205, r29
    1a5e:	c0 93 04 02 	sts	0x0204, r28
    1a62:	df 91       	pop	r29
    1a64:	cf 91       	pop	r28
    1a66:	08 95       	ret

00001a68 <xTaskGenericCreate>:
    1a68:	4f 92       	push	r4
    1a6a:	5f 92       	push	r5
    1a6c:	6f 92       	push	r6
    1a6e:	7f 92       	push	r7
    1a70:	8f 92       	push	r8
    1a72:	9f 92       	push	r9
    1a74:	af 92       	push	r10
    1a76:	bf 92       	push	r11
    1a78:	cf 92       	push	r12
    1a7a:	df 92       	push	r13
    1a7c:	ef 92       	push	r14
    1a7e:	ff 92       	push	r15
    1a80:	0f 93       	push	r16
    1a82:	1f 93       	push	r17
    1a84:	cf 93       	push	r28
    1a86:	df 93       	push	r29
    1a88:	4c 01       	movw	r8, r24
    1a8a:	5b 01       	movw	r10, r22
    1a8c:	2a 01       	movw	r4, r20
    1a8e:	39 01       	movw	r6, r18
    1a90:	83 e2       	ldi	r24, 0x23	; 35
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	0e 94 9c 02 	call	0x538	; 0x538 <pvPortMalloc>
    1a98:	ec 01       	movw	r28, r24
    1a9a:	00 97       	sbiw	r24, 0x00	; 0
    1a9c:	09 f4       	brne	.+2      	; 0x1aa0 <xTaskGenericCreate+0x38>
    1a9e:	e7 c0       	rjmp	.+462    	; 0x1c6e <xTaskGenericCreate+0x206>
    1aa0:	c1 14       	cp	r12, r1
    1aa2:	d1 04       	cpc	r13, r1
    1aa4:	09 f0       	breq	.+2      	; 0x1aa8 <xTaskGenericCreate+0x40>
    1aa6:	cc c0       	rjmp	.+408    	; 0x1c40 <xTaskGenericCreate+0x1d8>
    1aa8:	c2 01       	movw	r24, r4
    1aaa:	0e 94 9c 02 	call	0x538	; 0x538 <pvPortMalloc>
    1aae:	98 8f       	std	Y+24, r25	; 0x18
    1ab0:	8f 8b       	std	Y+23, r24	; 0x17
    1ab2:	89 2b       	or	r24, r25
    1ab4:	09 f0       	breq	.+2      	; 0x1ab8 <xTaskGenericCreate+0x50>
    1ab6:	c6 c0       	rjmp	.+396    	; 0x1c44 <xTaskGenericCreate+0x1dc>
    1ab8:	ce 01       	movw	r24, r28
    1aba:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortFree>
    1abe:	d7 c0       	rjmp	.+430    	; 0x1c6e <xTaskGenericCreate+0x206>
    1ac0:	cf 01       	movw	r24, r30
    1ac2:	31 91       	ld	r19, Z+
    1ac4:	da 01       	movw	r26, r20
    1ac6:	3d 93       	st	X+, r19
    1ac8:	ad 01       	movw	r20, r26
    1aca:	dc 01       	movw	r26, r24
    1acc:	8c 91       	ld	r24, X
    1ace:	88 23       	and	r24, r24
    1ad0:	11 f0       	breq	.+4      	; 0x1ad6 <xTaskGenericCreate+0x6e>
    1ad2:	21 50       	subi	r18, 0x01	; 1
    1ad4:	a9 f7       	brne	.-22     	; 0x1ac0 <xTaskGenericCreate+0x58>
    1ad6:	18 a2       	std	Y+32, r1	; 0x20
    1ad8:	10 2f       	mov	r17, r16
    1ada:	05 30       	cpi	r16, 0x05	; 5
    1adc:	08 f0       	brcs	.+2      	; 0x1ae0 <xTaskGenericCreate+0x78>
    1ade:	14 e0       	ldi	r17, 0x04	; 4
    1ae0:	1e 8b       	std	Y+22, r17	; 0x16
    1ae2:	19 a3       	std	Y+33, r17	; 0x21
    1ae4:	1a a2       	std	Y+34, r1	; 0x22
    1ae6:	5e 01       	movw	r10, r28
    1ae8:	b2 e0       	ldi	r27, 0x02	; 2
    1aea:	ab 0e       	add	r10, r27
    1aec:	b1 1c       	adc	r11, r1
    1aee:	c5 01       	movw	r24, r10
    1af0:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <vListInitialiseItem>
    1af4:	ce 01       	movw	r24, r28
    1af6:	0c 96       	adiw	r24, 0x0c	; 12
    1af8:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <vListInitialiseItem>
    1afc:	d9 87       	std	Y+9, r29	; 0x09
    1afe:	c8 87       	std	Y+8, r28	; 0x08
    1b00:	85 e0       	ldi	r24, 0x05	; 5
    1b02:	90 e0       	ldi	r25, 0x00	; 0
    1b04:	81 1b       	sub	r24, r17
    1b06:	91 09       	sbc	r25, r1
    1b08:	9d 87       	std	Y+13, r25	; 0x0d
    1b0a:	8c 87       	std	Y+12, r24	; 0x0c
    1b0c:	db 8b       	std	Y+19, r29	; 0x13
    1b0e:	ca 8b       	std	Y+18, r28	; 0x12
    1b10:	a3 01       	movw	r20, r6
    1b12:	b4 01       	movw	r22, r8
    1b14:	c6 01       	movw	r24, r12
    1b16:	c3 da       	rcall	.-2682   	; 0x109e <pxPortInitialiseStack>
    1b18:	99 83       	std	Y+1, r25	; 0x01
    1b1a:	88 83       	st	Y, r24
    1b1c:	e1 14       	cp	r14, r1
    1b1e:	f1 04       	cpc	r15, r1
    1b20:	19 f0       	breq	.+6      	; 0x1b28 <xTaskGenericCreate+0xc0>
    1b22:	f7 01       	movw	r30, r14
    1b24:	d1 83       	std	Z+1, r29	; 0x01
    1b26:	c0 83       	st	Z, r28
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	f8 94       	cli
    1b2c:	0f 92       	push	r0
    1b2e:	80 91 2d 08 	lds	r24, 0x082D
    1b32:	8f 5f       	subi	r24, 0xFF	; 255
    1b34:	80 93 2d 08 	sts	0x082D, r24
    1b38:	80 91 8d 08 	lds	r24, 0x088D
    1b3c:	90 91 8e 08 	lds	r25, 0x088E
    1b40:	89 2b       	or	r24, r25
    1b42:	09 f0       	breq	.+2      	; 0x1b46 <xTaskGenericCreate+0xde>
    1b44:	3f c0       	rjmp	.+126    	; 0x1bc4 <xTaskGenericCreate+0x15c>
    1b46:	d0 93 8e 08 	sts	0x088E, r29
    1b4a:	c0 93 8d 08 	sts	0x088D, r28
    1b4e:	80 91 2d 08 	lds	r24, 0x082D
    1b52:	81 30       	cpi	r24, 0x01	; 1
    1b54:	09 f0       	breq	.+2      	; 0x1b58 <xTaskGenericCreate+0xf0>
    1b56:	45 c0       	rjmp	.+138    	; 0x1be2 <xTaskGenericCreate+0x17a>
    1b58:	0f 2e       	mov	r0, r31
    1b5a:	f0 e6       	ldi	r31, 0x60	; 96
    1b5c:	ef 2e       	mov	r14, r31
    1b5e:	f8 e0       	ldi	r31, 0x08	; 8
    1b60:	ff 2e       	mov	r15, r31
    1b62:	f0 2d       	mov	r31, r0
    1b64:	0f 2e       	mov	r0, r31
    1b66:	fd e8       	ldi	r31, 0x8D	; 141
    1b68:	cf 2e       	mov	r12, r31
    1b6a:	f8 e0       	ldi	r31, 0x08	; 8
    1b6c:	df 2e       	mov	r13, r31
    1b6e:	f0 2d       	mov	r31, r0
    1b70:	c7 01       	movw	r24, r14
    1b72:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1b76:	f9 e0       	ldi	r31, 0x09	; 9
    1b78:	ef 0e       	add	r14, r31
    1b7a:	f1 1c       	adc	r15, r1
    1b7c:	ec 14       	cp	r14, r12
    1b7e:	fd 04       	cpc	r15, r13
    1b80:	b9 f7       	brne	.-18     	; 0x1b70 <xTaskGenericCreate+0x108>
    1b82:	87 e5       	ldi	r24, 0x57	; 87
    1b84:	98 e0       	ldi	r25, 0x08	; 8
    1b86:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1b8a:	8e e4       	ldi	r24, 0x4E	; 78
    1b8c:	98 e0       	ldi	r25, 0x08	; 8
    1b8e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1b92:	81 e4       	ldi	r24, 0x41	; 65
    1b94:	98 e0       	ldi	r25, 0x08	; 8
    1b96:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1b9a:	88 e3       	ldi	r24, 0x38	; 56
    1b9c:	98 e0       	ldi	r25, 0x08	; 8
    1b9e:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1ba2:	8e e2       	ldi	r24, 0x2E	; 46
    1ba4:	98 e0       	ldi	r25, 0x08	; 8
    1ba6:	0e 94 d2 02 	call	0x5a4	; 0x5a4 <vListInitialise>
    1baa:	87 e5       	ldi	r24, 0x57	; 87
    1bac:	98 e0       	ldi	r25, 0x08	; 8
    1bae:	90 93 4d 08 	sts	0x084D, r25
    1bb2:	80 93 4c 08 	sts	0x084C, r24
    1bb6:	8e e4       	ldi	r24, 0x4E	; 78
    1bb8:	98 e0       	ldi	r25, 0x08	; 8
    1bba:	90 93 4b 08 	sts	0x084B, r25
    1bbe:	80 93 4a 08 	sts	0x084A, r24
    1bc2:	0f c0       	rjmp	.+30     	; 0x1be2 <xTaskGenericCreate+0x17a>
    1bc4:	80 91 29 08 	lds	r24, 0x0829
    1bc8:	81 11       	cpse	r24, r1
    1bca:	0b c0       	rjmp	.+22     	; 0x1be2 <xTaskGenericCreate+0x17a>
    1bcc:	e0 91 8d 08 	lds	r30, 0x088D
    1bd0:	f0 91 8e 08 	lds	r31, 0x088E
    1bd4:	86 89       	ldd	r24, Z+22	; 0x16
    1bd6:	08 17       	cp	r16, r24
    1bd8:	20 f0       	brcs	.+8      	; 0x1be2 <xTaskGenericCreate+0x17a>
    1bda:	d0 93 8e 08 	sts	0x088E, r29
    1bde:	c0 93 8d 08 	sts	0x088D, r28
    1be2:	80 91 25 08 	lds	r24, 0x0825
    1be6:	8f 5f       	subi	r24, 0xFF	; 255
    1be8:	80 93 25 08 	sts	0x0825, r24
    1bec:	8e 89       	ldd	r24, Y+22	; 0x16
    1bee:	90 91 2a 08 	lds	r25, 0x082A
    1bf2:	98 17       	cp	r25, r24
    1bf4:	10 f4       	brcc	.+4      	; 0x1bfa <xTaskGenericCreate+0x192>
    1bf6:	80 93 2a 08 	sts	0x082A, r24
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	9c 01       	movw	r18, r24
    1bfe:	22 0f       	add	r18, r18
    1c00:	33 1f       	adc	r19, r19
    1c02:	22 0f       	add	r18, r18
    1c04:	33 1f       	adc	r19, r19
    1c06:	22 0f       	add	r18, r18
    1c08:	33 1f       	adc	r19, r19
    1c0a:	82 0f       	add	r24, r18
    1c0c:	93 1f       	adc	r25, r19
    1c0e:	b5 01       	movw	r22, r10
    1c10:	80 5a       	subi	r24, 0xA0	; 160
    1c12:	97 4f       	sbci	r25, 0xF7	; 247
    1c14:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    1c18:	0f 90       	pop	r0
    1c1a:	0f be       	out	0x3f, r0	; 63
    1c1c:	80 91 29 08 	lds	r24, 0x0829
    1c20:	88 23       	and	r24, r24
    1c22:	51 f0       	breq	.+20     	; 0x1c38 <xTaskGenericCreate+0x1d0>
    1c24:	e0 91 8d 08 	lds	r30, 0x088D
    1c28:	f0 91 8e 08 	lds	r31, 0x088E
    1c2c:	86 89       	ldd	r24, Z+22	; 0x16
    1c2e:	80 17       	cp	r24, r16
    1c30:	28 f4       	brcc	.+10     	; 0x1c3c <xTaskGenericCreate+0x1d4>
    1c32:	e4 da       	rcall	.-2616   	; 0x11fc <vPortYield>
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	1c c0       	rjmp	.+56     	; 0x1c70 <xTaskGenericCreate+0x208>
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	1a c0       	rjmp	.+52     	; 0x1c70 <xTaskGenericCreate+0x208>
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	18 c0       	rjmp	.+48     	; 0x1c70 <xTaskGenericCreate+0x208>
    1c40:	d8 8e       	std	Y+24, r13	; 0x18
    1c42:	cf 8a       	std	Y+23, r12	; 0x17
    1c44:	81 e0       	ldi	r24, 0x01	; 1
    1c46:	48 1a       	sub	r4, r24
    1c48:	51 08       	sbc	r5, r1
    1c4a:	cf 88       	ldd	r12, Y+23	; 0x17
    1c4c:	d8 8c       	ldd	r13, Y+24	; 0x18
    1c4e:	c4 0c       	add	r12, r4
    1c50:	d5 1c       	adc	r13, r5
    1c52:	d5 01       	movw	r26, r10
    1c54:	8c 91       	ld	r24, X
    1c56:	89 8f       	std	Y+25, r24	; 0x19
    1c58:	8c 91       	ld	r24, X
    1c5a:	88 23       	and	r24, r24
    1c5c:	09 f4       	brne	.+2      	; 0x1c60 <xTaskGenericCreate+0x1f8>
    1c5e:	3b cf       	rjmp	.-394    	; 0x1ad6 <xTaskGenericCreate+0x6e>
    1c60:	ae 01       	movw	r20, r28
    1c62:	46 5e       	subi	r20, 0xE6	; 230
    1c64:	5f 4f       	sbci	r21, 0xFF	; 255
    1c66:	f5 01       	movw	r30, r10
    1c68:	31 96       	adiw	r30, 0x01	; 1
    1c6a:	27 e0       	ldi	r18, 0x07	; 7
    1c6c:	29 cf       	rjmp	.-430    	; 0x1ac0 <xTaskGenericCreate+0x58>
    1c6e:	8f ef       	ldi	r24, 0xFF	; 255
    1c70:	df 91       	pop	r29
    1c72:	cf 91       	pop	r28
    1c74:	1f 91       	pop	r17
    1c76:	0f 91       	pop	r16
    1c78:	ff 90       	pop	r15
    1c7a:	ef 90       	pop	r14
    1c7c:	df 90       	pop	r13
    1c7e:	cf 90       	pop	r12
    1c80:	bf 90       	pop	r11
    1c82:	af 90       	pop	r10
    1c84:	9f 90       	pop	r9
    1c86:	8f 90       	pop	r8
    1c88:	7f 90       	pop	r7
    1c8a:	6f 90       	pop	r6
    1c8c:	5f 90       	pop	r5
    1c8e:	4f 90       	pop	r4
    1c90:	08 95       	ret

00001c92 <vTaskResume>:
    1c92:	0f 93       	push	r16
    1c94:	1f 93       	push	r17
    1c96:	cf 93       	push	r28
    1c98:	df 93       	push	r29
    1c9a:	ec 01       	movw	r28, r24
    1c9c:	00 97       	sbiw	r24, 0x00	; 0
    1c9e:	09 f4       	brne	.+2      	; 0x1ca2 <vTaskResume+0x10>
    1ca0:	3e c0       	rjmp	.+124    	; 0x1d1e <vTaskResume+0x8c>
    1ca2:	80 91 8d 08 	lds	r24, 0x088D
    1ca6:	90 91 8e 08 	lds	r25, 0x088E
    1caa:	c8 17       	cp	r28, r24
    1cac:	d9 07       	cpc	r29, r25
    1cae:	b9 f1       	breq	.+110    	; 0x1d1e <vTaskResume+0x8c>
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	f8 94       	cli
    1cb4:	0f 92       	push	r0
    1cb6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cb8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cba:	8e 52       	subi	r24, 0x2E	; 46
    1cbc:	98 40       	sbci	r25, 0x08	; 8
    1cbe:	69 f5       	brne	.+90     	; 0x1d1a <vTaskResume+0x88>
    1cc0:	8c 89       	ldd	r24, Y+20	; 0x14
    1cc2:	9d 89       	ldd	r25, Y+21	; 0x15
    1cc4:	28 e0       	ldi	r18, 0x08	; 8
    1cc6:	81 34       	cpi	r24, 0x41	; 65
    1cc8:	92 07       	cpc	r25, r18
    1cca:	39 f1       	breq	.+78     	; 0x1d1a <vTaskResume+0x88>
    1ccc:	89 2b       	or	r24, r25
    1cce:	29 f5       	brne	.+74     	; 0x1d1a <vTaskResume+0x88>
    1cd0:	8e 01       	movw	r16, r28
    1cd2:	0e 5f       	subi	r16, 0xFE	; 254
    1cd4:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd6:	c8 01       	movw	r24, r16
    1cd8:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    1cdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cde:	90 91 2a 08 	lds	r25, 0x082A
    1ce2:	98 17       	cp	r25, r24
    1ce4:	10 f4       	brcc	.+4      	; 0x1cea <vTaskResume+0x58>
    1ce6:	80 93 2a 08 	sts	0x082A, r24
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	9c 01       	movw	r18, r24
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	22 0f       	add	r18, r18
    1cf4:	33 1f       	adc	r19, r19
    1cf6:	22 0f       	add	r18, r18
    1cf8:	33 1f       	adc	r19, r19
    1cfa:	82 0f       	add	r24, r18
    1cfc:	93 1f       	adc	r25, r19
    1cfe:	b8 01       	movw	r22, r16
    1d00:	80 5a       	subi	r24, 0xA0	; 160
    1d02:	97 4f       	sbci	r25, 0xF7	; 247
    1d04:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    1d08:	e0 91 8d 08 	lds	r30, 0x088D
    1d0c:	f0 91 8e 08 	lds	r31, 0x088E
    1d10:	9e 89       	ldd	r25, Y+22	; 0x16
    1d12:	86 89       	ldd	r24, Z+22	; 0x16
    1d14:	98 17       	cp	r25, r24
    1d16:	08 f0       	brcs	.+2      	; 0x1d1a <vTaskResume+0x88>
    1d18:	71 da       	rcall	.-2846   	; 0x11fc <vPortYield>
    1d1a:	0f 90       	pop	r0
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	1f 91       	pop	r17
    1d24:	0f 91       	pop	r16
    1d26:	08 95       	ret

00001d28 <vTaskStartScheduler>:
    1d28:	af 92       	push	r10
    1d2a:	bf 92       	push	r11
    1d2c:	cf 92       	push	r12
    1d2e:	df 92       	push	r13
    1d30:	ef 92       	push	r14
    1d32:	ff 92       	push	r15
    1d34:	0f 93       	push	r16
    1d36:	a1 2c       	mov	r10, r1
    1d38:	b1 2c       	mov	r11, r1
    1d3a:	c1 2c       	mov	r12, r1
    1d3c:	d1 2c       	mov	r13, r1
    1d3e:	e1 2c       	mov	r14, r1
    1d40:	f1 2c       	mov	r15, r1
    1d42:	00 e0       	ldi	r16, 0x00	; 0
    1d44:	20 e0       	ldi	r18, 0x00	; 0
    1d46:	30 e0       	ldi	r19, 0x00	; 0
    1d48:	45 e5       	ldi	r20, 0x55	; 85
    1d4a:	50 e0       	ldi	r21, 0x00	; 0
    1d4c:	69 e3       	ldi	r22, 0x39	; 57
    1d4e:	72 e0       	ldi	r23, 0x02	; 2
    1d50:	8b e6       	ldi	r24, 0x6B	; 107
    1d52:	90 e1       	ldi	r25, 0x10	; 16
    1d54:	89 de       	rcall	.-750    	; 0x1a68 <xTaskGenericCreate>
    1d56:	81 30       	cpi	r24, 0x01	; 1
    1d58:	41 f4       	brne	.+16     	; 0x1d6a <vTaskStartScheduler+0x42>
    1d5a:	f8 94       	cli
    1d5c:	80 93 29 08 	sts	0x0829, r24
    1d60:	10 92 2c 08 	sts	0x082C, r1
    1d64:	10 92 2b 08 	sts	0x082B, r1
    1d68:	0c da       	rcall	.-3048   	; 0x1182 <xPortStartScheduler>
    1d6a:	0f 91       	pop	r16
    1d6c:	ff 90       	pop	r15
    1d6e:	ef 90       	pop	r14
    1d70:	df 90       	pop	r13
    1d72:	cf 90       	pop	r12
    1d74:	bf 90       	pop	r11
    1d76:	af 90       	pop	r10
    1d78:	08 95       	ret

00001d7a <vTaskSuspendAll>:
    1d7a:	80 91 24 08 	lds	r24, 0x0824
    1d7e:	8f 5f       	subi	r24, 0xFF	; 255
    1d80:	80 93 24 08 	sts	0x0824, r24
    1d84:	08 95       	ret

00001d86 <xTaskGetTickCount>:
    1d86:	0f b6       	in	r0, 0x3f	; 63
    1d88:	f8 94       	cli
    1d8a:	0f 92       	push	r0
    1d8c:	80 91 2b 08 	lds	r24, 0x082B
    1d90:	90 91 2c 08 	lds	r25, 0x082C
    1d94:	0f 90       	pop	r0
    1d96:	0f be       	out	0x3f, r0	; 63
    1d98:	08 95       	ret

00001d9a <xTaskGetTickCountFromISR>:
    1d9a:	80 91 2b 08 	lds	r24, 0x082B
    1d9e:	90 91 2c 08 	lds	r25, 0x082C
    1da2:	08 95       	ret

00001da4 <xTaskIncrementTick>:
    1da4:	cf 92       	push	r12
    1da6:	df 92       	push	r13
    1da8:	ef 92       	push	r14
    1daa:	ff 92       	push	r15
    1dac:	0f 93       	push	r16
    1dae:	1f 93       	push	r17
    1db0:	cf 93       	push	r28
    1db2:	df 93       	push	r29
    1db4:	80 91 24 08 	lds	r24, 0x0824
    1db8:	81 11       	cpse	r24, r1
    1dba:	99 c0       	rjmp	.+306    	; 0x1eee <xTaskIncrementTick+0x14a>
    1dbc:	80 91 2b 08 	lds	r24, 0x082B
    1dc0:	90 91 2c 08 	lds	r25, 0x082C
    1dc4:	01 96       	adiw	r24, 0x01	; 1
    1dc6:	90 93 2c 08 	sts	0x082C, r25
    1dca:	80 93 2b 08 	sts	0x082B, r24
    1dce:	e0 90 2b 08 	lds	r14, 0x082B
    1dd2:	f0 90 2c 08 	lds	r15, 0x082C
    1dd6:	e1 14       	cp	r14, r1
    1dd8:	f1 04       	cpc	r15, r1
    1dda:	b1 f4       	brne	.+44     	; 0x1e08 <xTaskIncrementTick+0x64>
    1ddc:	80 91 4c 08 	lds	r24, 0x084C
    1de0:	90 91 4d 08 	lds	r25, 0x084D
    1de4:	20 91 4a 08 	lds	r18, 0x084A
    1de8:	30 91 4b 08 	lds	r19, 0x084B
    1dec:	30 93 4d 08 	sts	0x084D, r19
    1df0:	20 93 4c 08 	sts	0x084C, r18
    1df4:	90 93 4b 08 	sts	0x084B, r25
    1df8:	80 93 4a 08 	sts	0x084A, r24
    1dfc:	80 91 26 08 	lds	r24, 0x0826
    1e00:	8f 5f       	subi	r24, 0xFF	; 255
    1e02:	80 93 26 08 	sts	0x0826, r24
    1e06:	da dd       	rcall	.-1100   	; 0x19bc <prvResetNextTaskUnblockTime>
    1e08:	80 91 04 02 	lds	r24, 0x0204
    1e0c:	90 91 05 02 	lds	r25, 0x0205
    1e10:	e8 16       	cp	r14, r24
    1e12:	f9 06       	cpc	r15, r25
    1e14:	08 f4       	brcc	.+2      	; 0x1e18 <xTaskIncrementTick+0x74>
    1e16:	54 c0       	rjmp	.+168    	; 0x1ec0 <xTaskIncrementTick+0x11c>
    1e18:	d1 2c       	mov	r13, r1
    1e1a:	cc 24       	eor	r12, r12
    1e1c:	c3 94       	inc	r12
    1e1e:	01 c0       	rjmp	.+2      	; 0x1e22 <xTaskIncrementTick+0x7e>
    1e20:	dc 2c       	mov	r13, r12
    1e22:	e0 91 4c 08 	lds	r30, 0x084C
    1e26:	f0 91 4d 08 	lds	r31, 0x084D
    1e2a:	80 81       	ld	r24, Z
    1e2c:	81 11       	cpse	r24, r1
    1e2e:	07 c0       	rjmp	.+14     	; 0x1e3e <xTaskIncrementTick+0x9a>
    1e30:	8f ef       	ldi	r24, 0xFF	; 255
    1e32:	9f ef       	ldi	r25, 0xFF	; 255
    1e34:	90 93 05 02 	sts	0x0205, r25
    1e38:	80 93 04 02 	sts	0x0204, r24
    1e3c:	42 c0       	rjmp	.+132    	; 0x1ec2 <xTaskIncrementTick+0x11e>
    1e3e:	e0 91 4c 08 	lds	r30, 0x084C
    1e42:	f0 91 4d 08 	lds	r31, 0x084D
    1e46:	05 80       	ldd	r0, Z+5	; 0x05
    1e48:	f6 81       	ldd	r31, Z+6	; 0x06
    1e4a:	e0 2d       	mov	r30, r0
    1e4c:	c6 81       	ldd	r28, Z+6	; 0x06
    1e4e:	d7 81       	ldd	r29, Z+7	; 0x07
    1e50:	2a 81       	ldd	r18, Y+2	; 0x02
    1e52:	3b 81       	ldd	r19, Y+3	; 0x03
    1e54:	e2 16       	cp	r14, r18
    1e56:	f3 06       	cpc	r15, r19
    1e58:	28 f4       	brcc	.+10     	; 0x1e64 <xTaskIncrementTick+0xc0>
    1e5a:	30 93 05 02 	sts	0x0205, r19
    1e5e:	20 93 04 02 	sts	0x0204, r18
    1e62:	2f c0       	rjmp	.+94     	; 0x1ec2 <xTaskIncrementTick+0x11e>
    1e64:	8e 01       	movw	r16, r28
    1e66:	0e 5f       	subi	r16, 0xFE	; 254
    1e68:	1f 4f       	sbci	r17, 0xFF	; 255
    1e6a:	c8 01       	movw	r24, r16
    1e6c:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    1e70:	8c 89       	ldd	r24, Y+20	; 0x14
    1e72:	9d 89       	ldd	r25, Y+21	; 0x15
    1e74:	89 2b       	or	r24, r25
    1e76:	21 f0       	breq	.+8      	; 0x1e80 <xTaskIncrementTick+0xdc>
    1e78:	ce 01       	movw	r24, r28
    1e7a:	0c 96       	adiw	r24, 0x0c	; 12
    1e7c:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    1e80:	2e 89       	ldd	r18, Y+22	; 0x16
    1e82:	80 91 2a 08 	lds	r24, 0x082A
    1e86:	82 17       	cp	r24, r18
    1e88:	10 f4       	brcc	.+4      	; 0x1e8e <xTaskIncrementTick+0xea>
    1e8a:	20 93 2a 08 	sts	0x082A, r18
    1e8e:	30 e0       	ldi	r19, 0x00	; 0
    1e90:	c9 01       	movw	r24, r18
    1e92:	88 0f       	add	r24, r24
    1e94:	99 1f       	adc	r25, r25
    1e96:	88 0f       	add	r24, r24
    1e98:	99 1f       	adc	r25, r25
    1e9a:	88 0f       	add	r24, r24
    1e9c:	99 1f       	adc	r25, r25
    1e9e:	82 0f       	add	r24, r18
    1ea0:	93 1f       	adc	r25, r19
    1ea2:	b8 01       	movw	r22, r16
    1ea4:	80 5a       	subi	r24, 0xA0	; 160
    1ea6:	97 4f       	sbci	r25, 0xF7	; 247
    1ea8:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    1eac:	e0 91 8d 08 	lds	r30, 0x088D
    1eb0:	f0 91 8e 08 	lds	r31, 0x088E
    1eb4:	9e 89       	ldd	r25, Y+22	; 0x16
    1eb6:	86 89       	ldd	r24, Z+22	; 0x16
    1eb8:	98 17       	cp	r25, r24
    1eba:	08 f0       	brcs	.+2      	; 0x1ebe <xTaskIncrementTick+0x11a>
    1ebc:	b1 cf       	rjmp	.-158    	; 0x1e20 <xTaskIncrementTick+0x7c>
    1ebe:	b1 cf       	rjmp	.-158    	; 0x1e22 <xTaskIncrementTick+0x7e>
    1ec0:	d1 2c       	mov	r13, r1
    1ec2:	e0 91 8d 08 	lds	r30, 0x088D
    1ec6:	f0 91 8e 08 	lds	r31, 0x088E
    1eca:	86 89       	ldd	r24, Z+22	; 0x16
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	fc 01       	movw	r30, r24
    1ed0:	ee 0f       	add	r30, r30
    1ed2:	ff 1f       	adc	r31, r31
    1ed4:	ee 0f       	add	r30, r30
    1ed6:	ff 1f       	adc	r31, r31
    1ed8:	ee 0f       	add	r30, r30
    1eda:	ff 1f       	adc	r31, r31
    1edc:	8e 0f       	add	r24, r30
    1ede:	9f 1f       	adc	r25, r31
    1ee0:	fc 01       	movw	r30, r24
    1ee2:	e0 5a       	subi	r30, 0xA0	; 160
    1ee4:	f7 4f       	sbci	r31, 0xF7	; 247
    1ee6:	80 81       	ld	r24, Z
    1ee8:	82 30       	cpi	r24, 0x02	; 2
    1eea:	40 f4       	brcc	.+16     	; 0x1efc <xTaskIncrementTick+0x158>
    1eec:	09 c0       	rjmp	.+18     	; 0x1f00 <xTaskIncrementTick+0x15c>
    1eee:	80 91 28 08 	lds	r24, 0x0828
    1ef2:	8f 5f       	subi	r24, 0xFF	; 255
    1ef4:	80 93 28 08 	sts	0x0828, r24
    1ef8:	d1 2c       	mov	r13, r1
    1efa:	02 c0       	rjmp	.+4      	; 0x1f00 <xTaskIncrementTick+0x15c>
    1efc:	dd 24       	eor	r13, r13
    1efe:	d3 94       	inc	r13
    1f00:	80 91 27 08 	lds	r24, 0x0827
    1f04:	88 23       	and	r24, r24
    1f06:	11 f0       	breq	.+4      	; 0x1f0c <xTaskIncrementTick+0x168>
    1f08:	dd 24       	eor	r13, r13
    1f0a:	d3 94       	inc	r13
    1f0c:	8d 2d       	mov	r24, r13
    1f0e:	df 91       	pop	r29
    1f10:	cf 91       	pop	r28
    1f12:	1f 91       	pop	r17
    1f14:	0f 91       	pop	r16
    1f16:	ff 90       	pop	r15
    1f18:	ef 90       	pop	r14
    1f1a:	df 90       	pop	r13
    1f1c:	cf 90       	pop	r12
    1f1e:	08 95       	ret

00001f20 <xTaskResumeAll>:
    1f20:	df 92       	push	r13
    1f22:	ef 92       	push	r14
    1f24:	ff 92       	push	r15
    1f26:	0f 93       	push	r16
    1f28:	1f 93       	push	r17
    1f2a:	cf 93       	push	r28
    1f2c:	df 93       	push	r29
    1f2e:	0f b6       	in	r0, 0x3f	; 63
    1f30:	f8 94       	cli
    1f32:	0f 92       	push	r0
    1f34:	80 91 24 08 	lds	r24, 0x0824
    1f38:	81 50       	subi	r24, 0x01	; 1
    1f3a:	80 93 24 08 	sts	0x0824, r24
    1f3e:	80 91 24 08 	lds	r24, 0x0824
    1f42:	81 11       	cpse	r24, r1
    1f44:	5f c0       	rjmp	.+190    	; 0x2004 <xTaskResumeAll+0xe4>
    1f46:	80 91 2d 08 	lds	r24, 0x082D
    1f4a:	88 23       	and	r24, r24
    1f4c:	09 f4       	brne	.+2      	; 0x1f50 <xTaskResumeAll+0x30>
    1f4e:	5c c0       	rjmp	.+184    	; 0x2008 <xTaskResumeAll+0xe8>
    1f50:	0f 2e       	mov	r0, r31
    1f52:	f1 e4       	ldi	r31, 0x41	; 65
    1f54:	ef 2e       	mov	r14, r31
    1f56:	f8 e0       	ldi	r31, 0x08	; 8
    1f58:	ff 2e       	mov	r15, r31
    1f5a:	f0 2d       	mov	r31, r0
    1f5c:	dd 24       	eor	r13, r13
    1f5e:	d3 94       	inc	r13
    1f60:	30 c0       	rjmp	.+96     	; 0x1fc2 <xTaskResumeAll+0xa2>
    1f62:	e0 91 46 08 	lds	r30, 0x0846
    1f66:	f0 91 47 08 	lds	r31, 0x0847
    1f6a:	c6 81       	ldd	r28, Z+6	; 0x06
    1f6c:	d7 81       	ldd	r29, Z+7	; 0x07
    1f6e:	ce 01       	movw	r24, r28
    1f70:	0c 96       	adiw	r24, 0x0c	; 12
    1f72:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    1f76:	8e 01       	movw	r16, r28
    1f78:	0e 5f       	subi	r16, 0xFE	; 254
    1f7a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f7c:	c8 01       	movw	r24, r16
    1f7e:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    1f82:	8e 89       	ldd	r24, Y+22	; 0x16
    1f84:	90 91 2a 08 	lds	r25, 0x082A
    1f88:	98 17       	cp	r25, r24
    1f8a:	10 f4       	brcc	.+4      	; 0x1f90 <xTaskResumeAll+0x70>
    1f8c:	80 93 2a 08 	sts	0x082A, r24
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	9c 01       	movw	r18, r24
    1f94:	22 0f       	add	r18, r18
    1f96:	33 1f       	adc	r19, r19
    1f98:	22 0f       	add	r18, r18
    1f9a:	33 1f       	adc	r19, r19
    1f9c:	22 0f       	add	r18, r18
    1f9e:	33 1f       	adc	r19, r19
    1fa0:	82 0f       	add	r24, r18
    1fa2:	93 1f       	adc	r25, r19
    1fa4:	b8 01       	movw	r22, r16
    1fa6:	80 5a       	subi	r24, 0xA0	; 160
    1fa8:	97 4f       	sbci	r25, 0xF7	; 247
    1faa:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    1fae:	e0 91 8d 08 	lds	r30, 0x088D
    1fb2:	f0 91 8e 08 	lds	r31, 0x088E
    1fb6:	9e 89       	ldd	r25, Y+22	; 0x16
    1fb8:	86 89       	ldd	r24, Z+22	; 0x16
    1fba:	98 17       	cp	r25, r24
    1fbc:	10 f0       	brcs	.+4      	; 0x1fc2 <xTaskResumeAll+0xa2>
    1fbe:	d0 92 27 08 	sts	0x0827, r13
    1fc2:	f7 01       	movw	r30, r14
    1fc4:	80 81       	ld	r24, Z
    1fc6:	81 11       	cpse	r24, r1
    1fc8:	cc cf       	rjmp	.-104    	; 0x1f62 <xTaskResumeAll+0x42>
    1fca:	80 91 28 08 	lds	r24, 0x0828
    1fce:	88 23       	and	r24, r24
    1fd0:	91 f0       	breq	.+36     	; 0x1ff6 <xTaskResumeAll+0xd6>
    1fd2:	80 91 28 08 	lds	r24, 0x0828
    1fd6:	88 23       	and	r24, r24
    1fd8:	71 f0       	breq	.+28     	; 0x1ff6 <xTaskResumeAll+0xd6>
    1fda:	c1 e0       	ldi	r28, 0x01	; 1
    1fdc:	e3 de       	rcall	.-570    	; 0x1da4 <xTaskIncrementTick>
    1fde:	81 11       	cpse	r24, r1
    1fe0:	c0 93 27 08 	sts	0x0827, r28
    1fe4:	80 91 28 08 	lds	r24, 0x0828
    1fe8:	81 50       	subi	r24, 0x01	; 1
    1fea:	80 93 28 08 	sts	0x0828, r24
    1fee:	80 91 28 08 	lds	r24, 0x0828
    1ff2:	81 11       	cpse	r24, r1
    1ff4:	f3 cf       	rjmp	.-26     	; 0x1fdc <xTaskResumeAll+0xbc>
    1ff6:	80 91 27 08 	lds	r24, 0x0827
    1ffa:	81 30       	cpi	r24, 0x01	; 1
    1ffc:	39 f4       	brne	.+14     	; 0x200c <xTaskResumeAll+0xec>
    1ffe:	fe d8       	rcall	.-3588   	; 0x11fc <vPortYield>
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	05 c0       	rjmp	.+10     	; 0x200e <xTaskResumeAll+0xee>
    2004:	80 e0       	ldi	r24, 0x00	; 0
    2006:	03 c0       	rjmp	.+6      	; 0x200e <xTaskResumeAll+0xee>
    2008:	80 e0       	ldi	r24, 0x00	; 0
    200a:	01 c0       	rjmp	.+2      	; 0x200e <xTaskResumeAll+0xee>
    200c:	80 e0       	ldi	r24, 0x00	; 0
    200e:	0f 90       	pop	r0
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	1f 91       	pop	r17
    2018:	0f 91       	pop	r16
    201a:	ff 90       	pop	r15
    201c:	ef 90       	pop	r14
    201e:	df 90       	pop	r13
    2020:	08 95       	ret

00002022 <vTaskDelayUntil>:
    2022:	0f 93       	push	r16
    2024:	1f 93       	push	r17
    2026:	cf 93       	push	r28
    2028:	df 93       	push	r29
    202a:	8c 01       	movw	r16, r24
    202c:	eb 01       	movw	r28, r22
    202e:	a5 de       	rcall	.-694    	; 0x1d7a <vTaskSuspendAll>
    2030:	80 91 2b 08 	lds	r24, 0x082B
    2034:	90 91 2c 08 	lds	r25, 0x082C
    2038:	f8 01       	movw	r30, r16
    203a:	20 81       	ld	r18, Z
    203c:	31 81       	ldd	r19, Z+1	; 0x01
    203e:	c2 0f       	add	r28, r18
    2040:	d3 1f       	adc	r29, r19
    2042:	82 17       	cp	r24, r18
    2044:	93 07       	cpc	r25, r19
    2046:	48 f4       	brcc	.+18     	; 0x205a <vTaskDelayUntil+0x38>
    2048:	c2 17       	cp	r28, r18
    204a:	d3 07       	cpc	r29, r19
    204c:	f8 f4       	brcc	.+62     	; 0x208c <vTaskDelayUntil+0x6a>
    204e:	d1 83       	std	Z+1, r29	; 0x01
    2050:	c0 83       	st	Z, r28
    2052:	8c 17       	cp	r24, r28
    2054:	9d 07       	cpc	r25, r29
    2056:	88 f4       	brcc	.+34     	; 0x207a <vTaskDelayUntil+0x58>
    2058:	07 c0       	rjmp	.+14     	; 0x2068 <vTaskDelayUntil+0x46>
    205a:	c2 17       	cp	r28, r18
    205c:	d3 07       	cpc	r29, r19
    205e:	90 f0       	brcs	.+36     	; 0x2084 <vTaskDelayUntil+0x62>
    2060:	8c 17       	cp	r24, r28
    2062:	9d 07       	cpc	r25, r29
    2064:	78 f0       	brcs	.+30     	; 0x2084 <vTaskDelayUntil+0x62>
    2066:	12 c0       	rjmp	.+36     	; 0x208c <vTaskDelayUntil+0x6a>
    2068:	80 91 8d 08 	lds	r24, 0x088D
    206c:	90 91 8e 08 	lds	r25, 0x088E
    2070:	02 96       	adiw	r24, 0x02	; 2
    2072:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    2076:	ce 01       	movw	r24, r28
    2078:	c0 dc       	rcall	.-1664   	; 0x19fa <prvAddCurrentTaskToDelayedList>
    207a:	52 df       	rcall	.-348    	; 0x1f20 <xTaskResumeAll>
    207c:	81 11       	cpse	r24, r1
    207e:	0a c0       	rjmp	.+20     	; 0x2094 <vTaskDelayUntil+0x72>
    2080:	bd d8       	rcall	.-3718   	; 0x11fc <vPortYield>
    2082:	08 c0       	rjmp	.+16     	; 0x2094 <vTaskDelayUntil+0x72>
    2084:	f8 01       	movw	r30, r16
    2086:	d1 83       	std	Z+1, r29	; 0x01
    2088:	c0 83       	st	Z, r28
    208a:	ee cf       	rjmp	.-36     	; 0x2068 <vTaskDelayUntil+0x46>
    208c:	f8 01       	movw	r30, r16
    208e:	d1 83       	std	Z+1, r29	; 0x01
    2090:	c0 83       	st	Z, r28
    2092:	f3 cf       	rjmp	.-26     	; 0x207a <vTaskDelayUntil+0x58>
    2094:	df 91       	pop	r29
    2096:	cf 91       	pop	r28
    2098:	1f 91       	pop	r17
    209a:	0f 91       	pop	r16
    209c:	08 95       	ret

0000209e <vTaskDelay>:
    209e:	cf 93       	push	r28
    20a0:	df 93       	push	r29
    20a2:	ec 01       	movw	r28, r24
    20a4:	00 97       	sbiw	r24, 0x00	; 0
    20a6:	99 f0       	breq	.+38     	; 0x20ce <vTaskDelay+0x30>
    20a8:	68 de       	rcall	.-816    	; 0x1d7a <vTaskSuspendAll>
    20aa:	80 91 2b 08 	lds	r24, 0x082B
    20ae:	90 91 2c 08 	lds	r25, 0x082C
    20b2:	c8 0f       	add	r28, r24
    20b4:	d9 1f       	adc	r29, r25
    20b6:	80 91 8d 08 	lds	r24, 0x088D
    20ba:	90 91 8e 08 	lds	r25, 0x088E
    20be:	02 96       	adiw	r24, 0x02	; 2
    20c0:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    20c4:	ce 01       	movw	r24, r28
    20c6:	99 dc       	rcall	.-1742   	; 0x19fa <prvAddCurrentTaskToDelayedList>
    20c8:	2b df       	rcall	.-426    	; 0x1f20 <xTaskResumeAll>
    20ca:	81 11       	cpse	r24, r1
    20cc:	01 c0       	rjmp	.+2      	; 0x20d0 <vTaskDelay+0x32>
    20ce:	96 d8       	rcall	.-3796   	; 0x11fc <vPortYield>
    20d0:	df 91       	pop	r29
    20d2:	cf 91       	pop	r28
    20d4:	08 95       	ret

000020d6 <prvIdleTask>:
    20d6:	0f 2e       	mov	r0, r31
    20d8:	f0 e6       	ldi	r31, 0x60	; 96
    20da:	ef 2e       	mov	r14, r31
    20dc:	f8 e0       	ldi	r31, 0x08	; 8
    20de:	ff 2e       	mov	r15, r31
    20e0:	f0 2d       	mov	r31, r0
    20e2:	c8 e3       	ldi	r28, 0x38	; 56
    20e4:	d8 e0       	ldi	r29, 0x08	; 8
    20e6:	26 c0       	rjmp	.+76     	; 0x2134 <prvIdleTask+0x5e>
    20e8:	48 de       	rcall	.-880    	; 0x1d7a <vTaskSuspendAll>
    20ea:	18 81       	ld	r17, Y
    20ec:	19 df       	rcall	.-462    	; 0x1f20 <xTaskResumeAll>
    20ee:	11 23       	and	r17, r17
    20f0:	09 f1       	breq	.+66     	; 0x2134 <prvIdleTask+0x5e>
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	0f 92       	push	r0
    20f8:	e0 91 3d 08 	lds	r30, 0x083D
    20fc:	f0 91 3e 08 	lds	r31, 0x083E
    2100:	06 81       	ldd	r16, Z+6	; 0x06
    2102:	17 81       	ldd	r17, Z+7	; 0x07
    2104:	c8 01       	movw	r24, r16
    2106:	02 96       	adiw	r24, 0x02	; 2
    2108:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    210c:	80 91 2d 08 	lds	r24, 0x082D
    2110:	81 50       	subi	r24, 0x01	; 1
    2112:	80 93 2d 08 	sts	0x082D, r24
    2116:	80 91 37 08 	lds	r24, 0x0837
    211a:	81 50       	subi	r24, 0x01	; 1
    211c:	80 93 37 08 	sts	0x0837, r24
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63
    2124:	f8 01       	movw	r30, r16
    2126:	87 89       	ldd	r24, Z+23	; 0x17
    2128:	90 8d       	ldd	r25, Z+24	; 0x18
    212a:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortFree>
    212e:	c8 01       	movw	r24, r16
    2130:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <vPortFree>
    2134:	80 91 37 08 	lds	r24, 0x0837
    2138:	81 11       	cpse	r24, r1
    213a:	d6 cf       	rjmp	.-84     	; 0x20e8 <prvIdleTask+0x12>
    213c:	f7 01       	movw	r30, r14
    213e:	80 81       	ld	r24, Z
    2140:	82 30       	cpi	r24, 0x02	; 2
    2142:	c0 f3       	brcs	.-16     	; 0x2134 <prvIdleTask+0x5e>
    2144:	5b d8       	rcall	.-3914   	; 0x11fc <vPortYield>
    2146:	f6 cf       	rjmp	.-20     	; 0x2134 <prvIdleTask+0x5e>

00002148 <vTaskSwitchContext>:
    2148:	80 91 24 08 	lds	r24, 0x0824
    214c:	88 23       	and	r24, r24
    214e:	21 f0       	breq	.+8      	; 0x2158 <vTaskSwitchContext+0x10>
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	80 93 27 08 	sts	0x0827, r24
    2156:	08 95       	ret
    2158:	10 92 27 08 	sts	0x0827, r1
    215c:	80 91 2a 08 	lds	r24, 0x082A
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	fc 01       	movw	r30, r24
    2164:	ee 0f       	add	r30, r30
    2166:	ff 1f       	adc	r31, r31
    2168:	ee 0f       	add	r30, r30
    216a:	ff 1f       	adc	r31, r31
    216c:	ee 0f       	add	r30, r30
    216e:	ff 1f       	adc	r31, r31
    2170:	8e 0f       	add	r24, r30
    2172:	9f 1f       	adc	r25, r31
    2174:	fc 01       	movw	r30, r24
    2176:	e0 5a       	subi	r30, 0xA0	; 160
    2178:	f7 4f       	sbci	r31, 0xF7	; 247
    217a:	80 81       	ld	r24, Z
    217c:	81 11       	cpse	r24, r1
    217e:	17 c0       	rjmp	.+46     	; 0x21ae <vTaskSwitchContext+0x66>
    2180:	80 91 2a 08 	lds	r24, 0x082A
    2184:	81 50       	subi	r24, 0x01	; 1
    2186:	80 93 2a 08 	sts	0x082A, r24
    218a:	80 91 2a 08 	lds	r24, 0x082A
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	fc 01       	movw	r30, r24
    2192:	ee 0f       	add	r30, r30
    2194:	ff 1f       	adc	r31, r31
    2196:	ee 0f       	add	r30, r30
    2198:	ff 1f       	adc	r31, r31
    219a:	ee 0f       	add	r30, r30
    219c:	ff 1f       	adc	r31, r31
    219e:	8e 0f       	add	r24, r30
    21a0:	9f 1f       	adc	r25, r31
    21a2:	fc 01       	movw	r30, r24
    21a4:	e0 5a       	subi	r30, 0xA0	; 160
    21a6:	f7 4f       	sbci	r31, 0xF7	; 247
    21a8:	80 81       	ld	r24, Z
    21aa:	88 23       	and	r24, r24
    21ac:	49 f3       	breq	.-46     	; 0x2180 <vTaskSwitchContext+0x38>
    21ae:	e0 91 2a 08 	lds	r30, 0x082A
    21b2:	f0 e0       	ldi	r31, 0x00	; 0
    21b4:	cf 01       	movw	r24, r30
    21b6:	88 0f       	add	r24, r24
    21b8:	99 1f       	adc	r25, r25
    21ba:	88 0f       	add	r24, r24
    21bc:	99 1f       	adc	r25, r25
    21be:	88 0f       	add	r24, r24
    21c0:	99 1f       	adc	r25, r25
    21c2:	e8 0f       	add	r30, r24
    21c4:	f9 1f       	adc	r31, r25
    21c6:	e0 5a       	subi	r30, 0xA0	; 160
    21c8:	f7 4f       	sbci	r31, 0xF7	; 247
    21ca:	a1 81       	ldd	r26, Z+1	; 0x01
    21cc:	b2 81       	ldd	r27, Z+2	; 0x02
    21ce:	12 96       	adiw	r26, 0x02	; 2
    21d0:	0d 90       	ld	r0, X+
    21d2:	bc 91       	ld	r27, X
    21d4:	a0 2d       	mov	r26, r0
    21d6:	b2 83       	std	Z+2, r27	; 0x02
    21d8:	a1 83       	std	Z+1, r26	; 0x01
    21da:	cf 01       	movw	r24, r30
    21dc:	03 96       	adiw	r24, 0x03	; 3
    21de:	a8 17       	cp	r26, r24
    21e0:	b9 07       	cpc	r27, r25
    21e2:	31 f4       	brne	.+12     	; 0x21f0 <vTaskSwitchContext+0xa8>
    21e4:	12 96       	adiw	r26, 0x02	; 2
    21e6:	8d 91       	ld	r24, X+
    21e8:	9c 91       	ld	r25, X
    21ea:	13 97       	sbiw	r26, 0x03	; 3
    21ec:	92 83       	std	Z+2, r25	; 0x02
    21ee:	81 83       	std	Z+1, r24	; 0x01
    21f0:	01 80       	ldd	r0, Z+1	; 0x01
    21f2:	f2 81       	ldd	r31, Z+2	; 0x02
    21f4:	e0 2d       	mov	r30, r0
    21f6:	86 81       	ldd	r24, Z+6	; 0x06
    21f8:	97 81       	ldd	r25, Z+7	; 0x07
    21fa:	90 93 8e 08 	sts	0x088E, r25
    21fe:	80 93 8d 08 	sts	0x088D, r24
    2202:	08 95       	ret

00002204 <vTaskSuspend>:
    2204:	0f 93       	push	r16
    2206:	1f 93       	push	r17
    2208:	cf 93       	push	r28
    220a:	df 93       	push	r29
    220c:	ec 01       	movw	r28, r24
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	0f 92       	push	r0
    2214:	00 97       	sbiw	r24, 0x00	; 0
    2216:	21 f4       	brne	.+8      	; 0x2220 <vTaskSuspend+0x1c>
    2218:	c0 91 8d 08 	lds	r28, 0x088D
    221c:	d0 91 8e 08 	lds	r29, 0x088E
    2220:	8e 01       	movw	r16, r28
    2222:	0e 5f       	subi	r16, 0xFE	; 254
    2224:	1f 4f       	sbci	r17, 0xFF	; 255
    2226:	c8 01       	movw	r24, r16
    2228:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    222c:	8c 89       	ldd	r24, Y+20	; 0x14
    222e:	9d 89       	ldd	r25, Y+21	; 0x15
    2230:	89 2b       	or	r24, r25
    2232:	21 f0       	breq	.+8      	; 0x223c <vTaskSuspend+0x38>
    2234:	ce 01       	movw	r24, r28
    2236:	0c 96       	adiw	r24, 0x0c	; 12
    2238:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    223c:	b8 01       	movw	r22, r16
    223e:	8e e2       	ldi	r24, 0x2E	; 46
    2240:	98 e0       	ldi	r25, 0x08	; 8
    2242:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    2246:	0f 90       	pop	r0
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	80 91 8d 08 	lds	r24, 0x088D
    224e:	90 91 8e 08 	lds	r25, 0x088E
    2252:	c8 17       	cp	r28, r24
    2254:	d9 07       	cpc	r29, r25
    2256:	a1 f4       	brne	.+40     	; 0x2280 <vTaskSuspend+0x7c>
    2258:	80 91 29 08 	lds	r24, 0x0829
    225c:	88 23       	and	r24, r24
    225e:	19 f0       	breq	.+6      	; 0x2266 <vTaskSuspend+0x62>
    2260:	0e 94 fe 08 	call	0x11fc	; 0x11fc <vPortYield>
    2264:	17 c0       	rjmp	.+46     	; 0x2294 <vTaskSuspend+0x90>
    2266:	80 91 2d 08 	lds	r24, 0x082D
    226a:	90 91 2e 08 	lds	r25, 0x082E
    226e:	98 13       	cpse	r25, r24
    2270:	05 c0       	rjmp	.+10     	; 0x227c <vTaskSuspend+0x78>
    2272:	10 92 8e 08 	sts	0x088E, r1
    2276:	10 92 8d 08 	sts	0x088D, r1
    227a:	0c c0       	rjmp	.+24     	; 0x2294 <vTaskSuspend+0x90>
    227c:	65 df       	rcall	.-310    	; 0x2148 <vTaskSwitchContext>
    227e:	0a c0       	rjmp	.+20     	; 0x2294 <vTaskSuspend+0x90>
    2280:	80 91 29 08 	lds	r24, 0x0829
    2284:	88 23       	and	r24, r24
    2286:	31 f0       	breq	.+12     	; 0x2294 <vTaskSuspend+0x90>
    2288:	0f b6       	in	r0, 0x3f	; 63
    228a:	f8 94       	cli
    228c:	0f 92       	push	r0
    228e:	96 db       	rcall	.-2260   	; 0x19bc <prvResetNextTaskUnblockTime>
    2290:	0f 90       	pop	r0
    2292:	0f be       	out	0x3f, r0	; 63
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	1f 91       	pop	r17
    229a:	0f 91       	pop	r16
    229c:	08 95       	ret

0000229e <vTaskPlaceOnEventList>:
    229e:	cf 93       	push	r28
    22a0:	df 93       	push	r29
    22a2:	eb 01       	movw	r28, r22
    22a4:	60 91 8d 08 	lds	r22, 0x088D
    22a8:	70 91 8e 08 	lds	r23, 0x088E
    22ac:	64 5f       	subi	r22, 0xF4	; 244
    22ae:	7f 4f       	sbci	r23, 0xFF	; 255
    22b0:	0e 94 05 03 	call	0x60a	; 0x60a <vListInsert>
    22b4:	80 91 8d 08 	lds	r24, 0x088D
    22b8:	90 91 8e 08 	lds	r25, 0x088E
    22bc:	02 96       	adiw	r24, 0x02	; 2
    22be:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    22c2:	cf 3f       	cpi	r28, 0xFF	; 255
    22c4:	8f ef       	ldi	r24, 0xFF	; 255
    22c6:	d8 07       	cpc	r29, r24
    22c8:	59 f4       	brne	.+22     	; 0x22e0 <vTaskPlaceOnEventList+0x42>
    22ca:	60 91 8d 08 	lds	r22, 0x088D
    22ce:	70 91 8e 08 	lds	r23, 0x088E
    22d2:	6e 5f       	subi	r22, 0xFE	; 254
    22d4:	7f 4f       	sbci	r23, 0xFF	; 255
    22d6:	8e e2       	ldi	r24, 0x2E	; 46
    22d8:	98 e0       	ldi	r25, 0x08	; 8
    22da:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    22de:	07 c0       	rjmp	.+14     	; 0x22ee <vTaskPlaceOnEventList+0x50>
    22e0:	80 91 2b 08 	lds	r24, 0x082B
    22e4:	90 91 2c 08 	lds	r25, 0x082C
    22e8:	8c 0f       	add	r24, r28
    22ea:	9d 1f       	adc	r25, r29
    22ec:	86 db       	rcall	.-2292   	; 0x19fa <prvAddCurrentTaskToDelayedList>
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	08 95       	ret

000022f4 <xTaskRemoveFromEventList>:
    22f4:	0f 93       	push	r16
    22f6:	1f 93       	push	r17
    22f8:	cf 93       	push	r28
    22fa:	df 93       	push	r29
    22fc:	dc 01       	movw	r26, r24
    22fe:	15 96       	adiw	r26, 0x05	; 5
    2300:	ed 91       	ld	r30, X+
    2302:	fc 91       	ld	r31, X
    2304:	16 97       	sbiw	r26, 0x06	; 6
    2306:	c6 81       	ldd	r28, Z+6	; 0x06
    2308:	d7 81       	ldd	r29, Z+7	; 0x07
    230a:	8e 01       	movw	r16, r28
    230c:	04 5f       	subi	r16, 0xF4	; 244
    230e:	1f 4f       	sbci	r17, 0xFF	; 255
    2310:	c8 01       	movw	r24, r16
    2312:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    2316:	80 91 24 08 	lds	r24, 0x0824
    231a:	81 11       	cpse	r24, r1
    231c:	1c c0       	rjmp	.+56     	; 0x2356 <xTaskRemoveFromEventList+0x62>
    231e:	0a 50       	subi	r16, 0x0A	; 10
    2320:	11 09       	sbc	r17, r1
    2322:	c8 01       	movw	r24, r16
    2324:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    2328:	8e 89       	ldd	r24, Y+22	; 0x16
    232a:	90 91 2a 08 	lds	r25, 0x082A
    232e:	98 17       	cp	r25, r24
    2330:	10 f4       	brcc	.+4      	; 0x2336 <xTaskRemoveFromEventList+0x42>
    2332:	80 93 2a 08 	sts	0x082A, r24
    2336:	90 e0       	ldi	r25, 0x00	; 0
    2338:	9c 01       	movw	r18, r24
    233a:	22 0f       	add	r18, r18
    233c:	33 1f       	adc	r19, r19
    233e:	22 0f       	add	r18, r18
    2340:	33 1f       	adc	r19, r19
    2342:	22 0f       	add	r18, r18
    2344:	33 1f       	adc	r19, r19
    2346:	82 0f       	add	r24, r18
    2348:	93 1f       	adc	r25, r19
    234a:	b8 01       	movw	r22, r16
    234c:	80 5a       	subi	r24, 0xA0	; 160
    234e:	97 4f       	sbci	r25, 0xF7	; 247
    2350:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    2354:	05 c0       	rjmp	.+10     	; 0x2360 <xTaskRemoveFromEventList+0x6c>
    2356:	b8 01       	movw	r22, r16
    2358:	81 e4       	ldi	r24, 0x41	; 65
    235a:	98 e0       	ldi	r25, 0x08	; 8
    235c:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    2360:	e0 91 8d 08 	lds	r30, 0x088D
    2364:	f0 91 8e 08 	lds	r31, 0x088E
    2368:	9e 89       	ldd	r25, Y+22	; 0x16
    236a:	86 89       	ldd	r24, Z+22	; 0x16
    236c:	89 17       	cp	r24, r25
    236e:	20 f4       	brcc	.+8      	; 0x2378 <xTaskRemoveFromEventList+0x84>
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	80 93 27 08 	sts	0x0827, r24
    2376:	01 c0       	rjmp	.+2      	; 0x237a <xTaskRemoveFromEventList+0x86>
    2378:	80 e0       	ldi	r24, 0x00	; 0
    237a:	df 91       	pop	r29
    237c:	cf 91       	pop	r28
    237e:	1f 91       	pop	r17
    2380:	0f 91       	pop	r16
    2382:	08 95       	ret

00002384 <vTaskSetTimeOutState>:
    2384:	20 91 26 08 	lds	r18, 0x0826
    2388:	fc 01       	movw	r30, r24
    238a:	20 83       	st	Z, r18
    238c:	20 91 2b 08 	lds	r18, 0x082B
    2390:	30 91 2c 08 	lds	r19, 0x082C
    2394:	32 83       	std	Z+2, r19	; 0x02
    2396:	21 83       	std	Z+1, r18	; 0x01
    2398:	08 95       	ret

0000239a <xTaskCheckForTimeOut>:
    239a:	0f b6       	in	r0, 0x3f	; 63
    239c:	f8 94       	cli
    239e:	0f 92       	push	r0
    23a0:	40 91 2b 08 	lds	r20, 0x082B
    23a4:	50 91 2c 08 	lds	r21, 0x082C
    23a8:	db 01       	movw	r26, r22
    23aa:	2d 91       	ld	r18, X+
    23ac:	3c 91       	ld	r19, X
    23ae:	2f 3f       	cpi	r18, 0xFF	; 255
    23b0:	bf ef       	ldi	r27, 0xFF	; 255
    23b2:	3b 07       	cpc	r19, r27
    23b4:	11 f1       	breq	.+68     	; 0x23fa <xTaskCheckForTimeOut+0x60>
    23b6:	e0 91 26 08 	lds	r30, 0x0826
    23ba:	dc 01       	movw	r26, r24
    23bc:	fc 91       	ld	r31, X
    23be:	fe 17       	cp	r31, r30
    23c0:	39 f0       	breq	.+14     	; 0x23d0 <xTaskCheckForTimeOut+0x36>
    23c2:	11 96       	adiw	r26, 0x01	; 1
    23c4:	ed 91       	ld	r30, X+
    23c6:	fc 91       	ld	r31, X
    23c8:	12 97       	sbiw	r26, 0x02	; 2
    23ca:	4e 17       	cp	r20, r30
    23cc:	5f 07       	cpc	r21, r31
    23ce:	b8 f4       	brcc	.+46     	; 0x23fe <xTaskCheckForTimeOut+0x64>
    23d0:	dc 01       	movw	r26, r24
    23d2:	11 96       	adiw	r26, 0x01	; 1
    23d4:	ed 91       	ld	r30, X+
    23d6:	fc 91       	ld	r31, X
    23d8:	12 97       	sbiw	r26, 0x02	; 2
    23da:	da 01       	movw	r26, r20
    23dc:	ae 1b       	sub	r26, r30
    23de:	bf 0b       	sbc	r27, r31
    23e0:	a2 17       	cp	r26, r18
    23e2:	b3 07       	cpc	r27, r19
    23e4:	70 f4       	brcc	.+28     	; 0x2402 <xTaskCheckForTimeOut+0x68>
    23e6:	e4 1b       	sub	r30, r20
    23e8:	f5 0b       	sbc	r31, r21
    23ea:	2e 0f       	add	r18, r30
    23ec:	3f 1f       	adc	r19, r31
    23ee:	fb 01       	movw	r30, r22
    23f0:	31 83       	std	Z+1, r19	; 0x01
    23f2:	20 83       	st	Z, r18
    23f4:	c7 df       	rcall	.-114    	; 0x2384 <vTaskSetTimeOutState>
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	05 c0       	rjmp	.+10     	; 0x2404 <xTaskCheckForTimeOut+0x6a>
    23fa:	80 e0       	ldi	r24, 0x00	; 0
    23fc:	03 c0       	rjmp	.+6      	; 0x2404 <xTaskCheckForTimeOut+0x6a>
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	01 c0       	rjmp	.+2      	; 0x2404 <xTaskCheckForTimeOut+0x6a>
    2402:	81 e0       	ldi	r24, 0x01	; 1
    2404:	0f 90       	pop	r0
    2406:	0f be       	out	0x3f, r0	; 63
    2408:	08 95       	ret

0000240a <vTaskMissedYield>:
    240a:	81 e0       	ldi	r24, 0x01	; 1
    240c:	80 93 27 08 	sts	0x0827, r24
    2410:	08 95       	ret

00002412 <vTaskPriorityInherit>:
    2412:	0f 93       	push	r16
    2414:	1f 93       	push	r17
    2416:	cf 93       	push	r28
    2418:	df 93       	push	r29
    241a:	ec 01       	movw	r28, r24
    241c:	00 97       	sbiw	r24, 0x00	; 0
    241e:	09 f4       	brne	.+2      	; 0x2422 <vTaskPriorityInherit+0x10>
    2420:	51 c0       	rjmp	.+162    	; 0x24c4 <vTaskPriorityInherit+0xb2>
    2422:	8e 89       	ldd	r24, Y+22	; 0x16
    2424:	e0 91 8d 08 	lds	r30, 0x088D
    2428:	f0 91 8e 08 	lds	r31, 0x088E
    242c:	96 89       	ldd	r25, Z+22	; 0x16
    242e:	89 17       	cp	r24, r25
    2430:	08 f0       	brcs	.+2      	; 0x2434 <vTaskPriorityInherit+0x22>
    2432:	48 c0       	rjmp	.+144    	; 0x24c4 <vTaskPriorityInherit+0xb2>
    2434:	2c 85       	ldd	r18, Y+12	; 0x0c
    2436:	3d 85       	ldd	r19, Y+13	; 0x0d
    2438:	33 23       	and	r19, r19
    243a:	5c f0       	brlt	.+22     	; 0x2452 <vTaskPriorityInherit+0x40>
    243c:	e0 91 8d 08 	lds	r30, 0x088D
    2440:	f0 91 8e 08 	lds	r31, 0x088E
    2444:	96 89       	ldd	r25, Z+22	; 0x16
    2446:	25 e0       	ldi	r18, 0x05	; 5
    2448:	30 e0       	ldi	r19, 0x00	; 0
    244a:	29 1b       	sub	r18, r25
    244c:	31 09       	sbc	r19, r1
    244e:	3d 87       	std	Y+13, r19	; 0x0d
    2450:	2c 87       	std	Y+12, r18	; 0x0c
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	9c 01       	movw	r18, r24
    2456:	22 0f       	add	r18, r18
    2458:	33 1f       	adc	r19, r19
    245a:	22 0f       	add	r18, r18
    245c:	33 1f       	adc	r19, r19
    245e:	22 0f       	add	r18, r18
    2460:	33 1f       	adc	r19, r19
    2462:	82 0f       	add	r24, r18
    2464:	93 1f       	adc	r25, r19
    2466:	80 5a       	subi	r24, 0xA0	; 160
    2468:	97 4f       	sbci	r25, 0xF7	; 247
    246a:	2a 85       	ldd	r18, Y+10	; 0x0a
    246c:	3b 85       	ldd	r19, Y+11	; 0x0b
    246e:	28 17       	cp	r18, r24
    2470:	39 07       	cpc	r19, r25
    2472:	11 f5       	brne	.+68     	; 0x24b8 <vTaskPriorityInherit+0xa6>
    2474:	8e 01       	movw	r16, r28
    2476:	0e 5f       	subi	r16, 0xFE	; 254
    2478:	1f 4f       	sbci	r17, 0xFF	; 255
    247a:	c8 01       	movw	r24, r16
    247c:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    2480:	e0 91 8d 08 	lds	r30, 0x088D
    2484:	f0 91 8e 08 	lds	r31, 0x088E
    2488:	86 89       	ldd	r24, Z+22	; 0x16
    248a:	8e 8b       	std	Y+22, r24	; 0x16
    248c:	90 91 2a 08 	lds	r25, 0x082A
    2490:	98 17       	cp	r25, r24
    2492:	10 f4       	brcc	.+4      	; 0x2498 <vTaskPriorityInherit+0x86>
    2494:	80 93 2a 08 	sts	0x082A, r24
    2498:	90 e0       	ldi	r25, 0x00	; 0
    249a:	9c 01       	movw	r18, r24
    249c:	22 0f       	add	r18, r18
    249e:	33 1f       	adc	r19, r19
    24a0:	22 0f       	add	r18, r18
    24a2:	33 1f       	adc	r19, r19
    24a4:	22 0f       	add	r18, r18
    24a6:	33 1f       	adc	r19, r19
    24a8:	82 0f       	add	r24, r18
    24aa:	93 1f       	adc	r25, r19
    24ac:	b8 01       	movw	r22, r16
    24ae:	80 5a       	subi	r24, 0xA0	; 160
    24b0:	97 4f       	sbci	r25, 0xF7	; 247
    24b2:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    24b6:	06 c0       	rjmp	.+12     	; 0x24c4 <vTaskPriorityInherit+0xb2>
    24b8:	e0 91 8d 08 	lds	r30, 0x088D
    24bc:	f0 91 8e 08 	lds	r31, 0x088E
    24c0:	86 89       	ldd	r24, Z+22	; 0x16
    24c2:	8e 8b       	std	Y+22, r24	; 0x16
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	1f 91       	pop	r17
    24ca:	0f 91       	pop	r16
    24cc:	08 95       	ret

000024ce <xTaskPriorityDisinherit>:
    24ce:	0f 93       	push	r16
    24d0:	1f 93       	push	r17
    24d2:	cf 93       	push	r28
    24d4:	df 93       	push	r29
    24d6:	ec 01       	movw	r28, r24
    24d8:	00 97       	sbiw	r24, 0x00	; 0
    24da:	71 f1       	breq	.+92     	; 0x2538 <xTaskPriorityDisinherit+0x6a>
    24dc:	8a a1       	ldd	r24, Y+34	; 0x22
    24de:	81 50       	subi	r24, 0x01	; 1
    24e0:	8a a3       	std	Y+34, r24	; 0x22
    24e2:	2e 89       	ldd	r18, Y+22	; 0x16
    24e4:	99 a1       	ldd	r25, Y+33	; 0x21
    24e6:	29 17       	cp	r18, r25
    24e8:	49 f1       	breq	.+82     	; 0x253c <xTaskPriorityDisinherit+0x6e>
    24ea:	81 11       	cpse	r24, r1
    24ec:	29 c0       	rjmp	.+82     	; 0x2540 <xTaskPriorityDisinherit+0x72>
    24ee:	8e 01       	movw	r16, r28
    24f0:	0e 5f       	subi	r16, 0xFE	; 254
    24f2:	1f 4f       	sbci	r17, 0xFF	; 255
    24f4:	c8 01       	movw	r24, r16
    24f6:	0e 94 36 03 	call	0x66c	; 0x66c <uxListRemove>
    24fa:	89 a1       	ldd	r24, Y+33	; 0x21
    24fc:	8e 8b       	std	Y+22, r24	; 0x16
    24fe:	25 e0       	ldi	r18, 0x05	; 5
    2500:	30 e0       	ldi	r19, 0x00	; 0
    2502:	28 1b       	sub	r18, r24
    2504:	31 09       	sbc	r19, r1
    2506:	3d 87       	std	Y+13, r19	; 0x0d
    2508:	2c 87       	std	Y+12, r18	; 0x0c
    250a:	90 91 2a 08 	lds	r25, 0x082A
    250e:	98 17       	cp	r25, r24
    2510:	10 f4       	brcc	.+4      	; 0x2516 <xTaskPriorityDisinherit+0x48>
    2512:	80 93 2a 08 	sts	0x082A, r24
    2516:	90 e0       	ldi	r25, 0x00	; 0
    2518:	9c 01       	movw	r18, r24
    251a:	22 0f       	add	r18, r18
    251c:	33 1f       	adc	r19, r19
    251e:	22 0f       	add	r18, r18
    2520:	33 1f       	adc	r19, r19
    2522:	22 0f       	add	r18, r18
    2524:	33 1f       	adc	r19, r19
    2526:	82 0f       	add	r24, r18
    2528:	93 1f       	adc	r25, r19
    252a:	b8 01       	movw	r22, r16
    252c:	80 5a       	subi	r24, 0xA0	; 160
    252e:	97 4f       	sbci	r25, 0xF7	; 247
    2530:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsertEnd>
    2534:	81 e0       	ldi	r24, 0x01	; 1
    2536:	05 c0       	rjmp	.+10     	; 0x2542 <xTaskPriorityDisinherit+0x74>
    2538:	80 e0       	ldi	r24, 0x00	; 0
    253a:	03 c0       	rjmp	.+6      	; 0x2542 <xTaskPriorityDisinherit+0x74>
    253c:	80 e0       	ldi	r24, 0x00	; 0
    253e:	01 c0       	rjmp	.+2      	; 0x2542 <xTaskPriorityDisinherit+0x74>
    2540:	80 e0       	ldi	r24, 0x00	; 0
    2542:	df 91       	pop	r29
    2544:	cf 91       	pop	r28
    2546:	1f 91       	pop	r17
    2548:	0f 91       	pop	r16
    254a:	08 95       	ret

0000254c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    254c:	80 91 8d 08 	lds	r24, 0x088D
    2550:	90 91 8e 08 	lds	r25, 0x088E
    2554:	89 2b       	or	r24, r25
    2556:	39 f0       	breq	.+14     	; 0x2566 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2558:	e0 91 8d 08 	lds	r30, 0x088D
    255c:	f0 91 8e 08 	lds	r31, 0x088E
    2560:	82 a1       	ldd	r24, Z+34	; 0x22
    2562:	8f 5f       	subi	r24, 0xFF	; 255
    2564:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2566:	80 91 8d 08 	lds	r24, 0x088D
    256a:	90 91 8e 08 	lds	r25, 0x088E
	}
    256e:	08 95       	ret

00002570 <__subsf3>:
    2570:	50 58       	subi	r21, 0x80	; 128

00002572 <__addsf3>:
    2572:	bb 27       	eor	r27, r27
    2574:	aa 27       	eor	r26, r26
    2576:	0e d0       	rcall	.+28     	; 0x2594 <__addsf3x>
    2578:	e5 c0       	rjmp	.+458    	; 0x2744 <__fp_round>
    257a:	d6 d0       	rcall	.+428    	; 0x2728 <__fp_pscA>
    257c:	30 f0       	brcs	.+12     	; 0x258a <__addsf3+0x18>
    257e:	db d0       	rcall	.+438    	; 0x2736 <__fp_pscB>
    2580:	20 f0       	brcs	.+8      	; 0x258a <__addsf3+0x18>
    2582:	31 f4       	brne	.+12     	; 0x2590 <__addsf3+0x1e>
    2584:	9f 3f       	cpi	r25, 0xFF	; 255
    2586:	11 f4       	brne	.+4      	; 0x258c <__addsf3+0x1a>
    2588:	1e f4       	brtc	.+6      	; 0x2590 <__addsf3+0x1e>
    258a:	cb c0       	rjmp	.+406    	; 0x2722 <__fp_nan>
    258c:	0e f4       	brtc	.+2      	; 0x2590 <__addsf3+0x1e>
    258e:	e0 95       	com	r30
    2590:	e7 fb       	bst	r30, 7
    2592:	c1 c0       	rjmp	.+386    	; 0x2716 <__fp_inf>

00002594 <__addsf3x>:
    2594:	e9 2f       	mov	r30, r25
    2596:	e7 d0       	rcall	.+462    	; 0x2766 <__fp_split3>
    2598:	80 f3       	brcs	.-32     	; 0x257a <__addsf3+0x8>
    259a:	ba 17       	cp	r27, r26
    259c:	62 07       	cpc	r22, r18
    259e:	73 07       	cpc	r23, r19
    25a0:	84 07       	cpc	r24, r20
    25a2:	95 07       	cpc	r25, r21
    25a4:	18 f0       	brcs	.+6      	; 0x25ac <__addsf3x+0x18>
    25a6:	71 f4       	brne	.+28     	; 0x25c4 <__addsf3x+0x30>
    25a8:	9e f5       	brtc	.+102    	; 0x2610 <__addsf3x+0x7c>
    25aa:	ff c0       	rjmp	.+510    	; 0x27aa <__fp_zero>
    25ac:	0e f4       	brtc	.+2      	; 0x25b0 <__addsf3x+0x1c>
    25ae:	e0 95       	com	r30
    25b0:	0b 2e       	mov	r0, r27
    25b2:	ba 2f       	mov	r27, r26
    25b4:	a0 2d       	mov	r26, r0
    25b6:	0b 01       	movw	r0, r22
    25b8:	b9 01       	movw	r22, r18
    25ba:	90 01       	movw	r18, r0
    25bc:	0c 01       	movw	r0, r24
    25be:	ca 01       	movw	r24, r20
    25c0:	a0 01       	movw	r20, r0
    25c2:	11 24       	eor	r1, r1
    25c4:	ff 27       	eor	r31, r31
    25c6:	59 1b       	sub	r21, r25
    25c8:	99 f0       	breq	.+38     	; 0x25f0 <__addsf3x+0x5c>
    25ca:	59 3f       	cpi	r21, 0xF9	; 249
    25cc:	50 f4       	brcc	.+20     	; 0x25e2 <__addsf3x+0x4e>
    25ce:	50 3e       	cpi	r21, 0xE0	; 224
    25d0:	68 f1       	brcs	.+90     	; 0x262c <__addsf3x+0x98>
    25d2:	1a 16       	cp	r1, r26
    25d4:	f0 40       	sbci	r31, 0x00	; 0
    25d6:	a2 2f       	mov	r26, r18
    25d8:	23 2f       	mov	r18, r19
    25da:	34 2f       	mov	r19, r20
    25dc:	44 27       	eor	r20, r20
    25de:	58 5f       	subi	r21, 0xF8	; 248
    25e0:	f3 cf       	rjmp	.-26     	; 0x25c8 <__addsf3x+0x34>
    25e2:	46 95       	lsr	r20
    25e4:	37 95       	ror	r19
    25e6:	27 95       	ror	r18
    25e8:	a7 95       	ror	r26
    25ea:	f0 40       	sbci	r31, 0x00	; 0
    25ec:	53 95       	inc	r21
    25ee:	c9 f7       	brne	.-14     	; 0x25e2 <__addsf3x+0x4e>
    25f0:	7e f4       	brtc	.+30     	; 0x2610 <__addsf3x+0x7c>
    25f2:	1f 16       	cp	r1, r31
    25f4:	ba 0b       	sbc	r27, r26
    25f6:	62 0b       	sbc	r22, r18
    25f8:	73 0b       	sbc	r23, r19
    25fa:	84 0b       	sbc	r24, r20
    25fc:	ba f0       	brmi	.+46     	; 0x262c <__addsf3x+0x98>
    25fe:	91 50       	subi	r25, 0x01	; 1
    2600:	a1 f0       	breq	.+40     	; 0x262a <__addsf3x+0x96>
    2602:	ff 0f       	add	r31, r31
    2604:	bb 1f       	adc	r27, r27
    2606:	66 1f       	adc	r22, r22
    2608:	77 1f       	adc	r23, r23
    260a:	88 1f       	adc	r24, r24
    260c:	c2 f7       	brpl	.-16     	; 0x25fe <__addsf3x+0x6a>
    260e:	0e c0       	rjmp	.+28     	; 0x262c <__addsf3x+0x98>
    2610:	ba 0f       	add	r27, r26
    2612:	62 1f       	adc	r22, r18
    2614:	73 1f       	adc	r23, r19
    2616:	84 1f       	adc	r24, r20
    2618:	48 f4       	brcc	.+18     	; 0x262c <__addsf3x+0x98>
    261a:	87 95       	ror	r24
    261c:	77 95       	ror	r23
    261e:	67 95       	ror	r22
    2620:	b7 95       	ror	r27
    2622:	f7 95       	ror	r31
    2624:	9e 3f       	cpi	r25, 0xFE	; 254
    2626:	08 f0       	brcs	.+2      	; 0x262a <__addsf3x+0x96>
    2628:	b3 cf       	rjmp	.-154    	; 0x2590 <__addsf3+0x1e>
    262a:	93 95       	inc	r25
    262c:	88 0f       	add	r24, r24
    262e:	08 f0       	brcs	.+2      	; 0x2632 <__addsf3x+0x9e>
    2630:	99 27       	eor	r25, r25
    2632:	ee 0f       	add	r30, r30
    2634:	97 95       	ror	r25
    2636:	87 95       	ror	r24
    2638:	08 95       	ret

0000263a <__fixsfsi>:
    263a:	04 d0       	rcall	.+8      	; 0x2644 <__fixunssfsi>
    263c:	68 94       	set
    263e:	b1 11       	cpse	r27, r1
    2640:	b5 c0       	rjmp	.+362    	; 0x27ac <__fp_szero>
    2642:	08 95       	ret

00002644 <__fixunssfsi>:
    2644:	98 d0       	rcall	.+304    	; 0x2776 <__fp_splitA>
    2646:	88 f0       	brcs	.+34     	; 0x266a <__fixunssfsi+0x26>
    2648:	9f 57       	subi	r25, 0x7F	; 127
    264a:	90 f0       	brcs	.+36     	; 0x2670 <__fixunssfsi+0x2c>
    264c:	b9 2f       	mov	r27, r25
    264e:	99 27       	eor	r25, r25
    2650:	b7 51       	subi	r27, 0x17	; 23
    2652:	a0 f0       	brcs	.+40     	; 0x267c <__fixunssfsi+0x38>
    2654:	d1 f0       	breq	.+52     	; 0x268a <__fixunssfsi+0x46>
    2656:	66 0f       	add	r22, r22
    2658:	77 1f       	adc	r23, r23
    265a:	88 1f       	adc	r24, r24
    265c:	99 1f       	adc	r25, r25
    265e:	1a f0       	brmi	.+6      	; 0x2666 <__fixunssfsi+0x22>
    2660:	ba 95       	dec	r27
    2662:	c9 f7       	brne	.-14     	; 0x2656 <__fixunssfsi+0x12>
    2664:	12 c0       	rjmp	.+36     	; 0x268a <__fixunssfsi+0x46>
    2666:	b1 30       	cpi	r27, 0x01	; 1
    2668:	81 f0       	breq	.+32     	; 0x268a <__fixunssfsi+0x46>
    266a:	9f d0       	rcall	.+318    	; 0x27aa <__fp_zero>
    266c:	b1 e0       	ldi	r27, 0x01	; 1
    266e:	08 95       	ret
    2670:	9c c0       	rjmp	.+312    	; 0x27aa <__fp_zero>
    2672:	67 2f       	mov	r22, r23
    2674:	78 2f       	mov	r23, r24
    2676:	88 27       	eor	r24, r24
    2678:	b8 5f       	subi	r27, 0xF8	; 248
    267a:	39 f0       	breq	.+14     	; 0x268a <__fixunssfsi+0x46>
    267c:	b9 3f       	cpi	r27, 0xF9	; 249
    267e:	cc f3       	brlt	.-14     	; 0x2672 <__fixunssfsi+0x2e>
    2680:	86 95       	lsr	r24
    2682:	77 95       	ror	r23
    2684:	67 95       	ror	r22
    2686:	b3 95       	inc	r27
    2688:	d9 f7       	brne	.-10     	; 0x2680 <__fixunssfsi+0x3c>
    268a:	3e f4       	brtc	.+14     	; 0x269a <__fixunssfsi+0x56>
    268c:	90 95       	com	r25
    268e:	80 95       	com	r24
    2690:	70 95       	com	r23
    2692:	61 95       	neg	r22
    2694:	7f 4f       	sbci	r23, 0xFF	; 255
    2696:	8f 4f       	sbci	r24, 0xFF	; 255
    2698:	9f 4f       	sbci	r25, 0xFF	; 255
    269a:	08 95       	ret

0000269c <__floatunsisf>:
    269c:	e8 94       	clt
    269e:	09 c0       	rjmp	.+18     	; 0x26b2 <__floatsisf+0x12>

000026a0 <__floatsisf>:
    26a0:	97 fb       	bst	r25, 7
    26a2:	3e f4       	brtc	.+14     	; 0x26b2 <__floatsisf+0x12>
    26a4:	90 95       	com	r25
    26a6:	80 95       	com	r24
    26a8:	70 95       	com	r23
    26aa:	61 95       	neg	r22
    26ac:	7f 4f       	sbci	r23, 0xFF	; 255
    26ae:	8f 4f       	sbci	r24, 0xFF	; 255
    26b0:	9f 4f       	sbci	r25, 0xFF	; 255
    26b2:	99 23       	and	r25, r25
    26b4:	a9 f0       	breq	.+42     	; 0x26e0 <__floatsisf+0x40>
    26b6:	f9 2f       	mov	r31, r25
    26b8:	96 e9       	ldi	r25, 0x96	; 150
    26ba:	bb 27       	eor	r27, r27
    26bc:	93 95       	inc	r25
    26be:	f6 95       	lsr	r31
    26c0:	87 95       	ror	r24
    26c2:	77 95       	ror	r23
    26c4:	67 95       	ror	r22
    26c6:	b7 95       	ror	r27
    26c8:	f1 11       	cpse	r31, r1
    26ca:	f8 cf       	rjmp	.-16     	; 0x26bc <__floatsisf+0x1c>
    26cc:	fa f4       	brpl	.+62     	; 0x270c <__floatsisf+0x6c>
    26ce:	bb 0f       	add	r27, r27
    26d0:	11 f4       	brne	.+4      	; 0x26d6 <__floatsisf+0x36>
    26d2:	60 ff       	sbrs	r22, 0
    26d4:	1b c0       	rjmp	.+54     	; 0x270c <__floatsisf+0x6c>
    26d6:	6f 5f       	subi	r22, 0xFF	; 255
    26d8:	7f 4f       	sbci	r23, 0xFF	; 255
    26da:	8f 4f       	sbci	r24, 0xFF	; 255
    26dc:	9f 4f       	sbci	r25, 0xFF	; 255
    26de:	16 c0       	rjmp	.+44     	; 0x270c <__floatsisf+0x6c>
    26e0:	88 23       	and	r24, r24
    26e2:	11 f0       	breq	.+4      	; 0x26e8 <__floatsisf+0x48>
    26e4:	96 e9       	ldi	r25, 0x96	; 150
    26e6:	11 c0       	rjmp	.+34     	; 0x270a <__floatsisf+0x6a>
    26e8:	77 23       	and	r23, r23
    26ea:	21 f0       	breq	.+8      	; 0x26f4 <__floatsisf+0x54>
    26ec:	9e e8       	ldi	r25, 0x8E	; 142
    26ee:	87 2f       	mov	r24, r23
    26f0:	76 2f       	mov	r23, r22
    26f2:	05 c0       	rjmp	.+10     	; 0x26fe <__floatsisf+0x5e>
    26f4:	66 23       	and	r22, r22
    26f6:	71 f0       	breq	.+28     	; 0x2714 <__floatsisf+0x74>
    26f8:	96 e8       	ldi	r25, 0x86	; 134
    26fa:	86 2f       	mov	r24, r22
    26fc:	70 e0       	ldi	r23, 0x00	; 0
    26fe:	60 e0       	ldi	r22, 0x00	; 0
    2700:	2a f0       	brmi	.+10     	; 0x270c <__floatsisf+0x6c>
    2702:	9a 95       	dec	r25
    2704:	66 0f       	add	r22, r22
    2706:	77 1f       	adc	r23, r23
    2708:	88 1f       	adc	r24, r24
    270a:	da f7       	brpl	.-10     	; 0x2702 <__floatsisf+0x62>
    270c:	88 0f       	add	r24, r24
    270e:	96 95       	lsr	r25
    2710:	87 95       	ror	r24
    2712:	97 f9       	bld	r25, 7
    2714:	08 95       	ret

00002716 <__fp_inf>:
    2716:	97 f9       	bld	r25, 7
    2718:	9f 67       	ori	r25, 0x7F	; 127
    271a:	80 e8       	ldi	r24, 0x80	; 128
    271c:	70 e0       	ldi	r23, 0x00	; 0
    271e:	60 e0       	ldi	r22, 0x00	; 0
    2720:	08 95       	ret

00002722 <__fp_nan>:
    2722:	9f ef       	ldi	r25, 0xFF	; 255
    2724:	80 ec       	ldi	r24, 0xC0	; 192
    2726:	08 95       	ret

00002728 <__fp_pscA>:
    2728:	00 24       	eor	r0, r0
    272a:	0a 94       	dec	r0
    272c:	16 16       	cp	r1, r22
    272e:	17 06       	cpc	r1, r23
    2730:	18 06       	cpc	r1, r24
    2732:	09 06       	cpc	r0, r25
    2734:	08 95       	ret

00002736 <__fp_pscB>:
    2736:	00 24       	eor	r0, r0
    2738:	0a 94       	dec	r0
    273a:	12 16       	cp	r1, r18
    273c:	13 06       	cpc	r1, r19
    273e:	14 06       	cpc	r1, r20
    2740:	05 06       	cpc	r0, r21
    2742:	08 95       	ret

00002744 <__fp_round>:
    2744:	09 2e       	mov	r0, r25
    2746:	03 94       	inc	r0
    2748:	00 0c       	add	r0, r0
    274a:	11 f4       	brne	.+4      	; 0x2750 <__fp_round+0xc>
    274c:	88 23       	and	r24, r24
    274e:	52 f0       	brmi	.+20     	; 0x2764 <__fp_round+0x20>
    2750:	bb 0f       	add	r27, r27
    2752:	40 f4       	brcc	.+16     	; 0x2764 <__fp_round+0x20>
    2754:	bf 2b       	or	r27, r31
    2756:	11 f4       	brne	.+4      	; 0x275c <__fp_round+0x18>
    2758:	60 ff       	sbrs	r22, 0
    275a:	04 c0       	rjmp	.+8      	; 0x2764 <__fp_round+0x20>
    275c:	6f 5f       	subi	r22, 0xFF	; 255
    275e:	7f 4f       	sbci	r23, 0xFF	; 255
    2760:	8f 4f       	sbci	r24, 0xFF	; 255
    2762:	9f 4f       	sbci	r25, 0xFF	; 255
    2764:	08 95       	ret

00002766 <__fp_split3>:
    2766:	57 fd       	sbrc	r21, 7
    2768:	90 58       	subi	r25, 0x80	; 128
    276a:	44 0f       	add	r20, r20
    276c:	55 1f       	adc	r21, r21
    276e:	59 f0       	breq	.+22     	; 0x2786 <__fp_splitA+0x10>
    2770:	5f 3f       	cpi	r21, 0xFF	; 255
    2772:	71 f0       	breq	.+28     	; 0x2790 <__fp_splitA+0x1a>
    2774:	47 95       	ror	r20

00002776 <__fp_splitA>:
    2776:	88 0f       	add	r24, r24
    2778:	97 fb       	bst	r25, 7
    277a:	99 1f       	adc	r25, r25
    277c:	61 f0       	breq	.+24     	; 0x2796 <__fp_splitA+0x20>
    277e:	9f 3f       	cpi	r25, 0xFF	; 255
    2780:	79 f0       	breq	.+30     	; 0x27a0 <__fp_splitA+0x2a>
    2782:	87 95       	ror	r24
    2784:	08 95       	ret
    2786:	12 16       	cp	r1, r18
    2788:	13 06       	cpc	r1, r19
    278a:	14 06       	cpc	r1, r20
    278c:	55 1f       	adc	r21, r21
    278e:	f2 cf       	rjmp	.-28     	; 0x2774 <__fp_split3+0xe>
    2790:	46 95       	lsr	r20
    2792:	f1 df       	rcall	.-30     	; 0x2776 <__fp_splitA>
    2794:	08 c0       	rjmp	.+16     	; 0x27a6 <__fp_splitA+0x30>
    2796:	16 16       	cp	r1, r22
    2798:	17 06       	cpc	r1, r23
    279a:	18 06       	cpc	r1, r24
    279c:	99 1f       	adc	r25, r25
    279e:	f1 cf       	rjmp	.-30     	; 0x2782 <__fp_splitA+0xc>
    27a0:	86 95       	lsr	r24
    27a2:	71 05       	cpc	r23, r1
    27a4:	61 05       	cpc	r22, r1
    27a6:	08 94       	sec
    27a8:	08 95       	ret

000027aa <__fp_zero>:
    27aa:	e8 94       	clt

000027ac <__fp_szero>:
    27ac:	bb 27       	eor	r27, r27
    27ae:	66 27       	eor	r22, r22
    27b0:	77 27       	eor	r23, r23
    27b2:	cb 01       	movw	r24, r22
    27b4:	97 f9       	bld	r25, 7
    27b6:	08 95       	ret

000027b8 <__mulsf3>:
    27b8:	0b d0       	rcall	.+22     	; 0x27d0 <__mulsf3x>
    27ba:	c4 cf       	rjmp	.-120    	; 0x2744 <__fp_round>
    27bc:	b5 df       	rcall	.-150    	; 0x2728 <__fp_pscA>
    27be:	28 f0       	brcs	.+10     	; 0x27ca <__mulsf3+0x12>
    27c0:	ba df       	rcall	.-140    	; 0x2736 <__fp_pscB>
    27c2:	18 f0       	brcs	.+6      	; 0x27ca <__mulsf3+0x12>
    27c4:	95 23       	and	r25, r21
    27c6:	09 f0       	breq	.+2      	; 0x27ca <__mulsf3+0x12>
    27c8:	a6 cf       	rjmp	.-180    	; 0x2716 <__fp_inf>
    27ca:	ab cf       	rjmp	.-170    	; 0x2722 <__fp_nan>
    27cc:	11 24       	eor	r1, r1
    27ce:	ee cf       	rjmp	.-36     	; 0x27ac <__fp_szero>

000027d0 <__mulsf3x>:
    27d0:	ca df       	rcall	.-108    	; 0x2766 <__fp_split3>
    27d2:	a0 f3       	brcs	.-24     	; 0x27bc <__mulsf3+0x4>

000027d4 <__mulsf3_pse>:
    27d4:	95 9f       	mul	r25, r21
    27d6:	d1 f3       	breq	.-12     	; 0x27cc <__mulsf3+0x14>
    27d8:	95 0f       	add	r25, r21
    27da:	50 e0       	ldi	r21, 0x00	; 0
    27dc:	55 1f       	adc	r21, r21
    27de:	62 9f       	mul	r22, r18
    27e0:	f0 01       	movw	r30, r0
    27e2:	72 9f       	mul	r23, r18
    27e4:	bb 27       	eor	r27, r27
    27e6:	f0 0d       	add	r31, r0
    27e8:	b1 1d       	adc	r27, r1
    27ea:	63 9f       	mul	r22, r19
    27ec:	aa 27       	eor	r26, r26
    27ee:	f0 0d       	add	r31, r0
    27f0:	b1 1d       	adc	r27, r1
    27f2:	aa 1f       	adc	r26, r26
    27f4:	64 9f       	mul	r22, r20
    27f6:	66 27       	eor	r22, r22
    27f8:	b0 0d       	add	r27, r0
    27fa:	a1 1d       	adc	r26, r1
    27fc:	66 1f       	adc	r22, r22
    27fe:	82 9f       	mul	r24, r18
    2800:	22 27       	eor	r18, r18
    2802:	b0 0d       	add	r27, r0
    2804:	a1 1d       	adc	r26, r1
    2806:	62 1f       	adc	r22, r18
    2808:	73 9f       	mul	r23, r19
    280a:	b0 0d       	add	r27, r0
    280c:	a1 1d       	adc	r26, r1
    280e:	62 1f       	adc	r22, r18
    2810:	83 9f       	mul	r24, r19
    2812:	a0 0d       	add	r26, r0
    2814:	61 1d       	adc	r22, r1
    2816:	22 1f       	adc	r18, r18
    2818:	74 9f       	mul	r23, r20
    281a:	33 27       	eor	r19, r19
    281c:	a0 0d       	add	r26, r0
    281e:	61 1d       	adc	r22, r1
    2820:	23 1f       	adc	r18, r19
    2822:	84 9f       	mul	r24, r20
    2824:	60 0d       	add	r22, r0
    2826:	21 1d       	adc	r18, r1
    2828:	82 2f       	mov	r24, r18
    282a:	76 2f       	mov	r23, r22
    282c:	6a 2f       	mov	r22, r26
    282e:	11 24       	eor	r1, r1
    2830:	9f 57       	subi	r25, 0x7F	; 127
    2832:	50 40       	sbci	r21, 0x00	; 0
    2834:	8a f0       	brmi	.+34     	; 0x2858 <__mulsf3_pse+0x84>
    2836:	e1 f0       	breq	.+56     	; 0x2870 <__mulsf3_pse+0x9c>
    2838:	88 23       	and	r24, r24
    283a:	4a f0       	brmi	.+18     	; 0x284e <__mulsf3_pse+0x7a>
    283c:	ee 0f       	add	r30, r30
    283e:	ff 1f       	adc	r31, r31
    2840:	bb 1f       	adc	r27, r27
    2842:	66 1f       	adc	r22, r22
    2844:	77 1f       	adc	r23, r23
    2846:	88 1f       	adc	r24, r24
    2848:	91 50       	subi	r25, 0x01	; 1
    284a:	50 40       	sbci	r21, 0x00	; 0
    284c:	a9 f7       	brne	.-22     	; 0x2838 <__mulsf3_pse+0x64>
    284e:	9e 3f       	cpi	r25, 0xFE	; 254
    2850:	51 05       	cpc	r21, r1
    2852:	70 f0       	brcs	.+28     	; 0x2870 <__mulsf3_pse+0x9c>
    2854:	60 cf       	rjmp	.-320    	; 0x2716 <__fp_inf>
    2856:	aa cf       	rjmp	.-172    	; 0x27ac <__fp_szero>
    2858:	5f 3f       	cpi	r21, 0xFF	; 255
    285a:	ec f3       	brlt	.-6      	; 0x2856 <__mulsf3_pse+0x82>
    285c:	98 3e       	cpi	r25, 0xE8	; 232
    285e:	dc f3       	brlt	.-10     	; 0x2856 <__mulsf3_pse+0x82>
    2860:	86 95       	lsr	r24
    2862:	77 95       	ror	r23
    2864:	67 95       	ror	r22
    2866:	b7 95       	ror	r27
    2868:	f7 95       	ror	r31
    286a:	e7 95       	ror	r30
    286c:	9f 5f       	subi	r25, 0xFF	; 255
    286e:	c1 f7       	brne	.-16     	; 0x2860 <__mulsf3_pse+0x8c>
    2870:	fe 2b       	or	r31, r30
    2872:	88 0f       	add	r24, r24
    2874:	91 1d       	adc	r25, r1
    2876:	96 95       	lsr	r25
    2878:	87 95       	ror	r24
    287a:	97 f9       	bld	r25, 7
    287c:	08 95       	ret

0000287e <pow>:
    287e:	fa 01       	movw	r30, r20
    2880:	ee 0f       	add	r30, r30
    2882:	ff 1f       	adc	r31, r31
    2884:	30 96       	adiw	r30, 0x00	; 0
    2886:	21 05       	cpc	r18, r1
    2888:	31 05       	cpc	r19, r1
    288a:	99 f1       	breq	.+102    	; 0x28f2 <pow+0x74>
    288c:	61 15       	cp	r22, r1
    288e:	71 05       	cpc	r23, r1
    2890:	61 f4       	brne	.+24     	; 0x28aa <pow+0x2c>
    2892:	80 38       	cpi	r24, 0x80	; 128
    2894:	bf e3       	ldi	r27, 0x3F	; 63
    2896:	9b 07       	cpc	r25, r27
    2898:	49 f1       	breq	.+82     	; 0x28ec <pow+0x6e>
    289a:	68 94       	set
    289c:	90 38       	cpi	r25, 0x80	; 128
    289e:	81 05       	cpc	r24, r1
    28a0:	61 f0       	breq	.+24     	; 0x28ba <pow+0x3c>
    28a2:	80 38       	cpi	r24, 0x80	; 128
    28a4:	bf ef       	ldi	r27, 0xFF	; 255
    28a6:	9b 07       	cpc	r25, r27
    28a8:	41 f0       	breq	.+16     	; 0x28ba <pow+0x3c>
    28aa:	99 23       	and	r25, r25
    28ac:	42 f5       	brpl	.+80     	; 0x28fe <pow+0x80>
    28ae:	ff 3f       	cpi	r31, 0xFF	; 255
    28b0:	e1 05       	cpc	r30, r1
    28b2:	31 05       	cpc	r19, r1
    28b4:	21 05       	cpc	r18, r1
    28b6:	11 f1       	breq	.+68     	; 0x28fc <pow+0x7e>
    28b8:	e8 94       	clt
    28ba:	08 94       	sec
    28bc:	e7 95       	ror	r30
    28be:	d9 01       	movw	r26, r18
    28c0:	aa 23       	and	r26, r26
    28c2:	29 f4       	brne	.+10     	; 0x28ce <pow+0x50>
    28c4:	ab 2f       	mov	r26, r27
    28c6:	be 2f       	mov	r27, r30
    28c8:	f8 5f       	subi	r31, 0xF8	; 248
    28ca:	d0 f3       	brcs	.-12     	; 0x28c0 <pow+0x42>
    28cc:	10 c0       	rjmp	.+32     	; 0x28ee <pow+0x70>
    28ce:	ff 5f       	subi	r31, 0xFF	; 255
    28d0:	70 f4       	brcc	.+28     	; 0x28ee <pow+0x70>
    28d2:	a6 95       	lsr	r26
    28d4:	e0 f7       	brcc	.-8      	; 0x28ce <pow+0x50>
    28d6:	f7 39       	cpi	r31, 0x97	; 151
    28d8:	50 f0       	brcs	.+20     	; 0x28ee <pow+0x70>
    28da:	19 f0       	breq	.+6      	; 0x28e2 <pow+0x64>
    28dc:	ff 3a       	cpi	r31, 0xAF	; 175
    28de:	38 f4       	brcc	.+14     	; 0x28ee <pow+0x70>
    28e0:	9f 77       	andi	r25, 0x7F	; 127
    28e2:	9f 93       	push	r25
    28e4:	0c d0       	rcall	.+24     	; 0x28fe <pow+0x80>
    28e6:	0f 90       	pop	r0
    28e8:	07 fc       	sbrc	r0, 7
    28ea:	90 58       	subi	r25, 0x80	; 128
    28ec:	08 95       	ret
    28ee:	3e f0       	brts	.+14     	; 0x28fe <pow+0x80>
    28f0:	18 cf       	rjmp	.-464    	; 0x2722 <__fp_nan>
    28f2:	60 e0       	ldi	r22, 0x00	; 0
    28f4:	70 e0       	ldi	r23, 0x00	; 0
    28f6:	80 e8       	ldi	r24, 0x80	; 128
    28f8:	9f e3       	ldi	r25, 0x3F	; 63
    28fa:	08 95       	ret
    28fc:	4f e7       	ldi	r20, 0x7F	; 127
    28fe:	9f 77       	andi	r25, 0x7F	; 127
    2900:	5f 93       	push	r21
    2902:	4f 93       	push	r20
    2904:	3f 93       	push	r19
    2906:	2f 93       	push	r18
    2908:	9e d0       	rcall	.+316    	; 0x2a46 <log>
    290a:	2f 91       	pop	r18
    290c:	3f 91       	pop	r19
    290e:	4f 91       	pop	r20
    2910:	5f 91       	pop	r21
    2912:	52 df       	rcall	.-348    	; 0x27b8 <__mulsf3>
    2914:	05 c0       	rjmp	.+10     	; 0x2920 <exp>
    2916:	19 f4       	brne	.+6      	; 0x291e <pow+0xa0>
    2918:	0e f0       	brts	.+2      	; 0x291c <pow+0x9e>
    291a:	fd ce       	rjmp	.-518    	; 0x2716 <__fp_inf>
    291c:	46 cf       	rjmp	.-372    	; 0x27aa <__fp_zero>
    291e:	01 cf       	rjmp	.-510    	; 0x2722 <__fp_nan>

00002920 <exp>:
    2920:	2a df       	rcall	.-428    	; 0x2776 <__fp_splitA>
    2922:	c8 f3       	brcs	.-14     	; 0x2916 <pow+0x98>
    2924:	96 38       	cpi	r25, 0x86	; 134
    2926:	c0 f7       	brcc	.-16     	; 0x2918 <pow+0x9a>
    2928:	07 f8       	bld	r0, 7
    292a:	0f 92       	push	r0
    292c:	e8 94       	clt
    292e:	2b e3       	ldi	r18, 0x3B	; 59
    2930:	3a ea       	ldi	r19, 0xAA	; 170
    2932:	48 eb       	ldi	r20, 0xB8	; 184
    2934:	5f e7       	ldi	r21, 0x7F	; 127
    2936:	4e df       	rcall	.-356    	; 0x27d4 <__mulsf3_pse>
    2938:	0f 92       	push	r0
    293a:	0f 92       	push	r0
    293c:	0f 92       	push	r0
    293e:	4d b7       	in	r20, 0x3d	; 61
    2940:	5e b7       	in	r21, 0x3e	; 62
    2942:	0f 92       	push	r0
    2944:	c0 d0       	rcall	.+384    	; 0x2ac6 <modf>
    2946:	e4 ee       	ldi	r30, 0xE4	; 228
    2948:	f0 e0       	ldi	r31, 0x00	; 0
    294a:	16 d0       	rcall	.+44     	; 0x2978 <__fp_powser>
    294c:	4f 91       	pop	r20
    294e:	5f 91       	pop	r21
    2950:	ef 91       	pop	r30
    2952:	ff 91       	pop	r31
    2954:	e5 95       	asr	r30
    2956:	ee 1f       	adc	r30, r30
    2958:	ff 1f       	adc	r31, r31
    295a:	49 f0       	breq	.+18     	; 0x296e <exp+0x4e>
    295c:	fe 57       	subi	r31, 0x7E	; 126
    295e:	e0 68       	ori	r30, 0x80	; 128
    2960:	44 27       	eor	r20, r20
    2962:	ee 0f       	add	r30, r30
    2964:	44 1f       	adc	r20, r20
    2966:	fa 95       	dec	r31
    2968:	e1 f7       	brne	.-8      	; 0x2962 <exp+0x42>
    296a:	41 95       	neg	r20
    296c:	55 0b       	sbc	r21, r21
    296e:	32 d0       	rcall	.+100    	; 0x29d4 <ldexp>
    2970:	0f 90       	pop	r0
    2972:	07 fe       	sbrs	r0, 7
    2974:	26 c0       	rjmp	.+76     	; 0x29c2 <inverse>
    2976:	08 95       	ret

00002978 <__fp_powser>:
    2978:	df 93       	push	r29
    297a:	cf 93       	push	r28
    297c:	1f 93       	push	r17
    297e:	0f 93       	push	r16
    2980:	ff 92       	push	r15
    2982:	ef 92       	push	r14
    2984:	df 92       	push	r13
    2986:	7b 01       	movw	r14, r22
    2988:	8c 01       	movw	r16, r24
    298a:	68 94       	set
    298c:	05 c0       	rjmp	.+10     	; 0x2998 <__fp_powser+0x20>
    298e:	da 2e       	mov	r13, r26
    2990:	ef 01       	movw	r28, r30
    2992:	1e df       	rcall	.-452    	; 0x27d0 <__mulsf3x>
    2994:	fe 01       	movw	r30, r28
    2996:	e8 94       	clt
    2998:	a5 91       	lpm	r26, Z+
    299a:	25 91       	lpm	r18, Z+
    299c:	35 91       	lpm	r19, Z+
    299e:	45 91       	lpm	r20, Z+
    29a0:	55 91       	lpm	r21, Z+
    29a2:	ae f3       	brts	.-22     	; 0x298e <__fp_powser+0x16>
    29a4:	ef 01       	movw	r28, r30
    29a6:	f6 dd       	rcall	.-1044   	; 0x2594 <__addsf3x>
    29a8:	fe 01       	movw	r30, r28
    29aa:	97 01       	movw	r18, r14
    29ac:	a8 01       	movw	r20, r16
    29ae:	da 94       	dec	r13
    29b0:	79 f7       	brne	.-34     	; 0x2990 <__fp_powser+0x18>
    29b2:	df 90       	pop	r13
    29b4:	ef 90       	pop	r14
    29b6:	ff 90       	pop	r15
    29b8:	0f 91       	pop	r16
    29ba:	1f 91       	pop	r17
    29bc:	cf 91       	pop	r28
    29be:	df 91       	pop	r29
    29c0:	08 95       	ret

000029c2 <inverse>:
    29c2:	9b 01       	movw	r18, r22
    29c4:	ac 01       	movw	r20, r24
    29c6:	60 e0       	ldi	r22, 0x00	; 0
    29c8:	70 e0       	ldi	r23, 0x00	; 0
    29ca:	80 e8       	ldi	r24, 0x80	; 128
    29cc:	9f e3       	ldi	r25, 0x3F	; 63
    29ce:	ae c0       	rjmp	.+348    	; 0x2b2c <__divsf3>
    29d0:	a2 ce       	rjmp	.-700    	; 0x2716 <__fp_inf>
    29d2:	14 c1       	rjmp	.+552    	; 0x2bfc <__fp_mpack>

000029d4 <ldexp>:
    29d4:	d0 de       	rcall	.-608    	; 0x2776 <__fp_splitA>
    29d6:	e8 f3       	brcs	.-6      	; 0x29d2 <inverse+0x10>
    29d8:	99 23       	and	r25, r25
    29da:	d9 f3       	breq	.-10     	; 0x29d2 <inverse+0x10>
    29dc:	94 0f       	add	r25, r20
    29de:	51 1d       	adc	r21, r1
    29e0:	bb f3       	brvs	.-18     	; 0x29d0 <inverse+0xe>
    29e2:	91 50       	subi	r25, 0x01	; 1
    29e4:	50 40       	sbci	r21, 0x00	; 0
    29e6:	94 f0       	brlt	.+36     	; 0x2a0c <ldexp+0x38>
    29e8:	59 f0       	breq	.+22     	; 0x2a00 <ldexp+0x2c>
    29ea:	88 23       	and	r24, r24
    29ec:	32 f0       	brmi	.+12     	; 0x29fa <ldexp+0x26>
    29ee:	66 0f       	add	r22, r22
    29f0:	77 1f       	adc	r23, r23
    29f2:	88 1f       	adc	r24, r24
    29f4:	91 50       	subi	r25, 0x01	; 1
    29f6:	50 40       	sbci	r21, 0x00	; 0
    29f8:	c1 f7       	brne	.-16     	; 0x29ea <ldexp+0x16>
    29fa:	9e 3f       	cpi	r25, 0xFE	; 254
    29fc:	51 05       	cpc	r21, r1
    29fe:	44 f7       	brge	.-48     	; 0x29d0 <inverse+0xe>
    2a00:	88 0f       	add	r24, r24
    2a02:	91 1d       	adc	r25, r1
    2a04:	96 95       	lsr	r25
    2a06:	87 95       	ror	r24
    2a08:	97 f9       	bld	r25, 7
    2a0a:	08 95       	ret
    2a0c:	5f 3f       	cpi	r21, 0xFF	; 255
    2a0e:	ac f0       	brlt	.+42     	; 0x2a3a <ldexp+0x66>
    2a10:	98 3e       	cpi	r25, 0xE8	; 232
    2a12:	9c f0       	brlt	.+38     	; 0x2a3a <ldexp+0x66>
    2a14:	bb 27       	eor	r27, r27
    2a16:	86 95       	lsr	r24
    2a18:	77 95       	ror	r23
    2a1a:	67 95       	ror	r22
    2a1c:	b7 95       	ror	r27
    2a1e:	08 f4       	brcc	.+2      	; 0x2a22 <ldexp+0x4e>
    2a20:	b1 60       	ori	r27, 0x01	; 1
    2a22:	93 95       	inc	r25
    2a24:	c1 f7       	brne	.-16     	; 0x2a16 <ldexp+0x42>
    2a26:	bb 0f       	add	r27, r27
    2a28:	58 f7       	brcc	.-42     	; 0x2a00 <ldexp+0x2c>
    2a2a:	11 f4       	brne	.+4      	; 0x2a30 <ldexp+0x5c>
    2a2c:	60 ff       	sbrs	r22, 0
    2a2e:	e8 cf       	rjmp	.-48     	; 0x2a00 <ldexp+0x2c>
    2a30:	6f 5f       	subi	r22, 0xFF	; 255
    2a32:	7f 4f       	sbci	r23, 0xFF	; 255
    2a34:	8f 4f       	sbci	r24, 0xFF	; 255
    2a36:	9f 4f       	sbci	r25, 0xFF	; 255
    2a38:	e3 cf       	rjmp	.-58     	; 0x2a00 <ldexp+0x2c>
    2a3a:	b8 ce       	rjmp	.-656    	; 0x27ac <__fp_szero>
    2a3c:	0e f0       	brts	.+2      	; 0x2a40 <ldexp+0x6c>
    2a3e:	de c0       	rjmp	.+444    	; 0x2bfc <__fp_mpack>
    2a40:	70 ce       	rjmp	.-800    	; 0x2722 <__fp_nan>
    2a42:	68 94       	set
    2a44:	68 ce       	rjmp	.-816    	; 0x2716 <__fp_inf>

00002a46 <log>:
    2a46:	97 de       	rcall	.-722    	; 0x2776 <__fp_splitA>
    2a48:	c8 f3       	brcs	.-14     	; 0x2a3c <ldexp+0x68>
    2a4a:	99 23       	and	r25, r25
    2a4c:	d1 f3       	breq	.-12     	; 0x2a42 <ldexp+0x6e>
    2a4e:	c6 f3       	brts	.-16     	; 0x2a40 <ldexp+0x6c>
    2a50:	df 93       	push	r29
    2a52:	cf 93       	push	r28
    2a54:	1f 93       	push	r17
    2a56:	0f 93       	push	r16
    2a58:	ff 92       	push	r15
    2a5a:	c9 2f       	mov	r28, r25
    2a5c:	dd 27       	eor	r29, r29
    2a5e:	88 23       	and	r24, r24
    2a60:	2a f0       	brmi	.+10     	; 0x2a6c <log+0x26>
    2a62:	21 97       	sbiw	r28, 0x01	; 1
    2a64:	66 0f       	add	r22, r22
    2a66:	77 1f       	adc	r23, r23
    2a68:	88 1f       	adc	r24, r24
    2a6a:	da f7       	brpl	.-10     	; 0x2a62 <log+0x1c>
    2a6c:	20 e0       	ldi	r18, 0x00	; 0
    2a6e:	30 e0       	ldi	r19, 0x00	; 0
    2a70:	40 e8       	ldi	r20, 0x80	; 128
    2a72:	5f eb       	ldi	r21, 0xBF	; 191
    2a74:	9f e3       	ldi	r25, 0x3F	; 63
    2a76:	88 39       	cpi	r24, 0x98	; 152
    2a78:	20 f0       	brcs	.+8      	; 0x2a82 <log+0x3c>
    2a7a:	80 3e       	cpi	r24, 0xE0	; 224
    2a7c:	30 f0       	brcs	.+12     	; 0x2a8a <log+0x44>
    2a7e:	21 96       	adiw	r28, 0x01	; 1
    2a80:	8f 77       	andi	r24, 0x7F	; 127
    2a82:	77 dd       	rcall	.-1298   	; 0x2572 <__addsf3>
    2a84:	ec e0       	ldi	r30, 0x0C	; 12
    2a86:	f1 e0       	ldi	r31, 0x01	; 1
    2a88:	03 c0       	rjmp	.+6      	; 0x2a90 <log+0x4a>
    2a8a:	73 dd       	rcall	.-1306   	; 0x2572 <__addsf3>
    2a8c:	e9 e3       	ldi	r30, 0x39	; 57
    2a8e:	f1 e0       	ldi	r31, 0x01	; 1
    2a90:	73 df       	rcall	.-282    	; 0x2978 <__fp_powser>
    2a92:	8b 01       	movw	r16, r22
    2a94:	be 01       	movw	r22, r28
    2a96:	ec 01       	movw	r28, r24
    2a98:	fb 2e       	mov	r15, r27
    2a9a:	6f 57       	subi	r22, 0x7F	; 127
    2a9c:	71 09       	sbc	r23, r1
    2a9e:	75 95       	asr	r23
    2aa0:	77 1f       	adc	r23, r23
    2aa2:	88 0b       	sbc	r24, r24
    2aa4:	99 0b       	sbc	r25, r25
    2aa6:	fc dd       	rcall	.-1032   	; 0x26a0 <__floatsisf>
    2aa8:	28 e1       	ldi	r18, 0x18	; 24
    2aaa:	32 e7       	ldi	r19, 0x72	; 114
    2aac:	41 e3       	ldi	r20, 0x31	; 49
    2aae:	5f e3       	ldi	r21, 0x3F	; 63
    2ab0:	8f de       	rcall	.-738    	; 0x27d0 <__mulsf3x>
    2ab2:	af 2d       	mov	r26, r15
    2ab4:	98 01       	movw	r18, r16
    2ab6:	ae 01       	movw	r20, r28
    2ab8:	ff 90       	pop	r15
    2aba:	0f 91       	pop	r16
    2abc:	1f 91       	pop	r17
    2abe:	cf 91       	pop	r28
    2ac0:	df 91       	pop	r29
    2ac2:	68 dd       	rcall	.-1328   	; 0x2594 <__addsf3x>
    2ac4:	3f ce       	rjmp	.-898    	; 0x2744 <__fp_round>

00002ac6 <modf>:
    2ac6:	fa 01       	movw	r30, r20
    2ac8:	dc 01       	movw	r26, r24
    2aca:	aa 0f       	add	r26, r26
    2acc:	bb 1f       	adc	r27, r27
    2ace:	9b 01       	movw	r18, r22
    2ad0:	ac 01       	movw	r20, r24
    2ad2:	bf 57       	subi	r27, 0x7F	; 127
    2ad4:	28 f4       	brcc	.+10     	; 0x2ae0 <modf+0x1a>
    2ad6:	22 27       	eor	r18, r18
    2ad8:	33 27       	eor	r19, r19
    2ada:	44 27       	eor	r20, r20
    2adc:	50 78       	andi	r21, 0x80	; 128
    2ade:	1f c0       	rjmp	.+62     	; 0x2b1e <modf+0x58>
    2ae0:	b7 51       	subi	r27, 0x17	; 23
    2ae2:	88 f4       	brcc	.+34     	; 0x2b06 <modf+0x40>
    2ae4:	ab 2f       	mov	r26, r27
    2ae6:	00 24       	eor	r0, r0
    2ae8:	46 95       	lsr	r20
    2aea:	37 95       	ror	r19
    2aec:	27 95       	ror	r18
    2aee:	01 1c       	adc	r0, r1
    2af0:	a3 95       	inc	r26
    2af2:	d2 f3       	brmi	.-12     	; 0x2ae8 <modf+0x22>
    2af4:	00 20       	and	r0, r0
    2af6:	69 f0       	breq	.+26     	; 0x2b12 <modf+0x4c>
    2af8:	22 0f       	add	r18, r18
    2afa:	33 1f       	adc	r19, r19
    2afc:	44 1f       	adc	r20, r20
    2afe:	b3 95       	inc	r27
    2b00:	da f3       	brmi	.-10     	; 0x2af8 <modf+0x32>
    2b02:	0d d0       	rcall	.+26     	; 0x2b1e <modf+0x58>
    2b04:	35 cd       	rjmp	.-1430   	; 0x2570 <__subsf3>
    2b06:	61 30       	cpi	r22, 0x01	; 1
    2b08:	71 05       	cpc	r23, r1
    2b0a:	a0 e8       	ldi	r26, 0x80	; 128
    2b0c:	8a 07       	cpc	r24, r26
    2b0e:	b9 46       	sbci	r27, 0x69	; 105
    2b10:	30 f4       	brcc	.+12     	; 0x2b1e <modf+0x58>
    2b12:	9b 01       	movw	r18, r22
    2b14:	ac 01       	movw	r20, r24
    2b16:	66 27       	eor	r22, r22
    2b18:	77 27       	eor	r23, r23
    2b1a:	88 27       	eor	r24, r24
    2b1c:	90 78       	andi	r25, 0x80	; 128
    2b1e:	30 96       	adiw	r30, 0x00	; 0
    2b20:	21 f0       	breq	.+8      	; 0x2b2a <modf+0x64>
    2b22:	20 83       	st	Z, r18
    2b24:	31 83       	std	Z+1, r19	; 0x01
    2b26:	42 83       	std	Z+2, r20	; 0x02
    2b28:	53 83       	std	Z+3, r21	; 0x03
    2b2a:	08 95       	ret

00002b2c <__divsf3>:
    2b2c:	0c d0       	rcall	.+24     	; 0x2b46 <__divsf3x>
    2b2e:	0a ce       	rjmp	.-1004   	; 0x2744 <__fp_round>
    2b30:	02 de       	rcall	.-1020   	; 0x2736 <__fp_pscB>
    2b32:	40 f0       	brcs	.+16     	; 0x2b44 <__divsf3+0x18>
    2b34:	f9 dd       	rcall	.-1038   	; 0x2728 <__fp_pscA>
    2b36:	30 f0       	brcs	.+12     	; 0x2b44 <__divsf3+0x18>
    2b38:	21 f4       	brne	.+8      	; 0x2b42 <__divsf3+0x16>
    2b3a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b3c:	19 f0       	breq	.+6      	; 0x2b44 <__divsf3+0x18>
    2b3e:	eb cd       	rjmp	.-1066   	; 0x2716 <__fp_inf>
    2b40:	51 11       	cpse	r21, r1
    2b42:	34 ce       	rjmp	.-920    	; 0x27ac <__fp_szero>
    2b44:	ee cd       	rjmp	.-1060   	; 0x2722 <__fp_nan>

00002b46 <__divsf3x>:
    2b46:	0f de       	rcall	.-994    	; 0x2766 <__fp_split3>
    2b48:	98 f3       	brcs	.-26     	; 0x2b30 <__divsf3+0x4>

00002b4a <__divsf3_pse>:
    2b4a:	99 23       	and	r25, r25
    2b4c:	c9 f3       	breq	.-14     	; 0x2b40 <__divsf3+0x14>
    2b4e:	55 23       	and	r21, r21
    2b50:	b1 f3       	breq	.-20     	; 0x2b3e <__divsf3+0x12>
    2b52:	95 1b       	sub	r25, r21
    2b54:	55 0b       	sbc	r21, r21
    2b56:	bb 27       	eor	r27, r27
    2b58:	aa 27       	eor	r26, r26
    2b5a:	62 17       	cp	r22, r18
    2b5c:	73 07       	cpc	r23, r19
    2b5e:	84 07       	cpc	r24, r20
    2b60:	38 f0       	brcs	.+14     	; 0x2b70 <__divsf3_pse+0x26>
    2b62:	9f 5f       	subi	r25, 0xFF	; 255
    2b64:	5f 4f       	sbci	r21, 0xFF	; 255
    2b66:	22 0f       	add	r18, r18
    2b68:	33 1f       	adc	r19, r19
    2b6a:	44 1f       	adc	r20, r20
    2b6c:	aa 1f       	adc	r26, r26
    2b6e:	a9 f3       	breq	.-22     	; 0x2b5a <__divsf3_pse+0x10>
    2b70:	33 d0       	rcall	.+102    	; 0x2bd8 <__divsf3_pse+0x8e>
    2b72:	0e 2e       	mov	r0, r30
    2b74:	3a f0       	brmi	.+14     	; 0x2b84 <__divsf3_pse+0x3a>
    2b76:	e0 e8       	ldi	r30, 0x80	; 128
    2b78:	30 d0       	rcall	.+96     	; 0x2bda <__divsf3_pse+0x90>
    2b7a:	91 50       	subi	r25, 0x01	; 1
    2b7c:	50 40       	sbci	r21, 0x00	; 0
    2b7e:	e6 95       	lsr	r30
    2b80:	00 1c       	adc	r0, r0
    2b82:	ca f7       	brpl	.-14     	; 0x2b76 <__divsf3_pse+0x2c>
    2b84:	29 d0       	rcall	.+82     	; 0x2bd8 <__divsf3_pse+0x8e>
    2b86:	fe 2f       	mov	r31, r30
    2b88:	27 d0       	rcall	.+78     	; 0x2bd8 <__divsf3_pse+0x8e>
    2b8a:	66 0f       	add	r22, r22
    2b8c:	77 1f       	adc	r23, r23
    2b8e:	88 1f       	adc	r24, r24
    2b90:	bb 1f       	adc	r27, r27
    2b92:	26 17       	cp	r18, r22
    2b94:	37 07       	cpc	r19, r23
    2b96:	48 07       	cpc	r20, r24
    2b98:	ab 07       	cpc	r26, r27
    2b9a:	b0 e8       	ldi	r27, 0x80	; 128
    2b9c:	09 f0       	breq	.+2      	; 0x2ba0 <__divsf3_pse+0x56>
    2b9e:	bb 0b       	sbc	r27, r27
    2ba0:	80 2d       	mov	r24, r0
    2ba2:	bf 01       	movw	r22, r30
    2ba4:	ff 27       	eor	r31, r31
    2ba6:	93 58       	subi	r25, 0x83	; 131
    2ba8:	5f 4f       	sbci	r21, 0xFF	; 255
    2baa:	2a f0       	brmi	.+10     	; 0x2bb6 <__divsf3_pse+0x6c>
    2bac:	9e 3f       	cpi	r25, 0xFE	; 254
    2bae:	51 05       	cpc	r21, r1
    2bb0:	68 f0       	brcs	.+26     	; 0x2bcc <__divsf3_pse+0x82>
    2bb2:	b1 cd       	rjmp	.-1182   	; 0x2716 <__fp_inf>
    2bb4:	fb cd       	rjmp	.-1034   	; 0x27ac <__fp_szero>
    2bb6:	5f 3f       	cpi	r21, 0xFF	; 255
    2bb8:	ec f3       	brlt	.-6      	; 0x2bb4 <__divsf3_pse+0x6a>
    2bba:	98 3e       	cpi	r25, 0xE8	; 232
    2bbc:	dc f3       	brlt	.-10     	; 0x2bb4 <__divsf3_pse+0x6a>
    2bbe:	86 95       	lsr	r24
    2bc0:	77 95       	ror	r23
    2bc2:	67 95       	ror	r22
    2bc4:	b7 95       	ror	r27
    2bc6:	f7 95       	ror	r31
    2bc8:	9f 5f       	subi	r25, 0xFF	; 255
    2bca:	c9 f7       	brne	.-14     	; 0x2bbe <__divsf3_pse+0x74>
    2bcc:	88 0f       	add	r24, r24
    2bce:	91 1d       	adc	r25, r1
    2bd0:	96 95       	lsr	r25
    2bd2:	87 95       	ror	r24
    2bd4:	97 f9       	bld	r25, 7
    2bd6:	08 95       	ret
    2bd8:	e1 e0       	ldi	r30, 0x01	; 1
    2bda:	66 0f       	add	r22, r22
    2bdc:	77 1f       	adc	r23, r23
    2bde:	88 1f       	adc	r24, r24
    2be0:	bb 1f       	adc	r27, r27
    2be2:	62 17       	cp	r22, r18
    2be4:	73 07       	cpc	r23, r19
    2be6:	84 07       	cpc	r24, r20
    2be8:	ba 07       	cpc	r27, r26
    2bea:	20 f0       	brcs	.+8      	; 0x2bf4 <__divsf3_pse+0xaa>
    2bec:	62 1b       	sub	r22, r18
    2bee:	73 0b       	sbc	r23, r19
    2bf0:	84 0b       	sbc	r24, r20
    2bf2:	ba 0b       	sbc	r27, r26
    2bf4:	ee 1f       	adc	r30, r30
    2bf6:	88 f7       	brcc	.-30     	; 0x2bda <__divsf3_pse+0x90>
    2bf8:	e0 95       	com	r30
    2bfa:	08 95       	ret

00002bfc <__fp_mpack>:
    2bfc:	9f 3f       	cpi	r25, 0xFF	; 255
    2bfe:	31 f0       	breq	.+12     	; 0x2c0c <__fp_mpack_finite+0xc>

00002c00 <__fp_mpack_finite>:
    2c00:	91 50       	subi	r25, 0x01	; 1
    2c02:	20 f4       	brcc	.+8      	; 0x2c0c <__fp_mpack_finite+0xc>
    2c04:	87 95       	ror	r24
    2c06:	77 95       	ror	r23
    2c08:	67 95       	ror	r22
    2c0a:	b7 95       	ror	r27
    2c0c:	88 0f       	add	r24, r24
    2c0e:	91 1d       	adc	r25, r1
    2c10:	96 95       	lsr	r25
    2c12:	87 95       	ror	r24
    2c14:	97 f9       	bld	r25, 7
    2c16:	08 95       	ret

00002c18 <__divmodhi4>:
    2c18:	97 fb       	bst	r25, 7
    2c1a:	07 2e       	mov	r0, r23
    2c1c:	16 f4       	brtc	.+4      	; 0x2c22 <__divmodhi4+0xa>
    2c1e:	00 94       	com	r0
    2c20:	06 d0       	rcall	.+12     	; 0x2c2e <__divmodhi4_neg1>
    2c22:	77 fd       	sbrc	r23, 7
    2c24:	08 d0       	rcall	.+16     	; 0x2c36 <__divmodhi4_neg2>
    2c26:	0b d0       	rcall	.+22     	; 0x2c3e <__udivmodhi4>
    2c28:	07 fc       	sbrc	r0, 7
    2c2a:	05 d0       	rcall	.+10     	; 0x2c36 <__divmodhi4_neg2>
    2c2c:	3e f4       	brtc	.+14     	; 0x2c3c <__divmodhi4_exit>

00002c2e <__divmodhi4_neg1>:
    2c2e:	90 95       	com	r25
    2c30:	81 95       	neg	r24
    2c32:	9f 4f       	sbci	r25, 0xFF	; 255
    2c34:	08 95       	ret

00002c36 <__divmodhi4_neg2>:
    2c36:	70 95       	com	r23
    2c38:	61 95       	neg	r22
    2c3a:	7f 4f       	sbci	r23, 0xFF	; 255

00002c3c <__divmodhi4_exit>:
    2c3c:	08 95       	ret

00002c3e <__udivmodhi4>:
    2c3e:	aa 1b       	sub	r26, r26
    2c40:	bb 1b       	sub	r27, r27
    2c42:	51 e1       	ldi	r21, 0x11	; 17
    2c44:	07 c0       	rjmp	.+14     	; 0x2c54 <__udivmodhi4_ep>

00002c46 <__udivmodhi4_loop>:
    2c46:	aa 1f       	adc	r26, r26
    2c48:	bb 1f       	adc	r27, r27
    2c4a:	a6 17       	cp	r26, r22
    2c4c:	b7 07       	cpc	r27, r23
    2c4e:	10 f0       	brcs	.+4      	; 0x2c54 <__udivmodhi4_ep>
    2c50:	a6 1b       	sub	r26, r22
    2c52:	b7 0b       	sbc	r27, r23

00002c54 <__udivmodhi4_ep>:
    2c54:	88 1f       	adc	r24, r24
    2c56:	99 1f       	adc	r25, r25
    2c58:	5a 95       	dec	r21
    2c5a:	a9 f7       	brne	.-22     	; 0x2c46 <__udivmodhi4_loop>
    2c5c:	80 95       	com	r24
    2c5e:	90 95       	com	r25
    2c60:	bc 01       	movw	r22, r24
    2c62:	cd 01       	movw	r24, r26
    2c64:	08 95       	ret

00002c66 <memcpy>:
    2c66:	fb 01       	movw	r30, r22
    2c68:	dc 01       	movw	r26, r24
    2c6a:	02 c0       	rjmp	.+4      	; 0x2c70 <memcpy+0xa>
    2c6c:	01 90       	ld	r0, Z+
    2c6e:	0d 92       	st	X+, r0
    2c70:	41 50       	subi	r20, 0x01	; 1
    2c72:	50 40       	sbci	r21, 0x00	; 0
    2c74:	d8 f7       	brcc	.-10     	; 0x2c6c <memcpy+0x6>
    2c76:	08 95       	ret

00002c78 <__itoa_ncheck>:
    2c78:	bb 27       	eor	r27, r27
    2c7a:	4a 30       	cpi	r20, 0x0A	; 10
    2c7c:	31 f4       	brne	.+12     	; 0x2c8a <__itoa_ncheck+0x12>
    2c7e:	99 23       	and	r25, r25
    2c80:	22 f4       	brpl	.+8      	; 0x2c8a <__itoa_ncheck+0x12>
    2c82:	bd e2       	ldi	r27, 0x2D	; 45
    2c84:	90 95       	com	r25
    2c86:	81 95       	neg	r24
    2c88:	9f 4f       	sbci	r25, 0xFF	; 255
    2c8a:	01 c0       	rjmp	.+2      	; 0x2c8e <__utoa_common>

00002c8c <__utoa_ncheck>:
    2c8c:	bb 27       	eor	r27, r27

00002c8e <__utoa_common>:
    2c8e:	fb 01       	movw	r30, r22
    2c90:	55 27       	eor	r21, r21
    2c92:	aa 27       	eor	r26, r26
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
    2c98:	aa 1f       	adc	r26, r26
    2c9a:	a4 17       	cp	r26, r20
    2c9c:	10 f0       	brcs	.+4      	; 0x2ca2 <__utoa_common+0x14>
    2c9e:	a4 1b       	sub	r26, r20
    2ca0:	83 95       	inc	r24
    2ca2:	50 51       	subi	r21, 0x10	; 16
    2ca4:	b9 f7       	brne	.-18     	; 0x2c94 <__utoa_common+0x6>
    2ca6:	a0 5d       	subi	r26, 0xD0	; 208
    2ca8:	aa 33       	cpi	r26, 0x3A	; 58
    2caa:	08 f0       	brcs	.+2      	; 0x2cae <__utoa_common+0x20>
    2cac:	a9 5d       	subi	r26, 0xD9	; 217
    2cae:	a1 93       	st	Z+, r26
    2cb0:	00 97       	sbiw	r24, 0x00	; 0
    2cb2:	79 f7       	brne	.-34     	; 0x2c92 <__utoa_common+0x4>
    2cb4:	b1 11       	cpse	r27, r1
    2cb6:	b1 93       	st	Z+, r27
    2cb8:	11 92       	st	Z+, r1
    2cba:	cb 01       	movw	r24, r22
    2cbc:	00 c0       	rjmp	.+0      	; 0x2cbe <strrev>

00002cbe <strrev>:
    2cbe:	dc 01       	movw	r26, r24
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	67 2f       	mov	r22, r23
    2cc4:	71 91       	ld	r23, Z+
    2cc6:	77 23       	and	r23, r23
    2cc8:	e1 f7       	brne	.-8      	; 0x2cc2 <strrev+0x4>
    2cca:	32 97       	sbiw	r30, 0x02	; 2
    2ccc:	04 c0       	rjmp	.+8      	; 0x2cd6 <strrev+0x18>
    2cce:	7c 91       	ld	r23, X
    2cd0:	6d 93       	st	X+, r22
    2cd2:	70 83       	st	Z, r23
    2cd4:	62 91       	ld	r22, -Z
    2cd6:	ae 17       	cp	r26, r30
    2cd8:	bf 07       	cpc	r27, r31
    2cda:	c8 f3       	brcs	.-14     	; 0x2cce <strrev+0x10>
    2cdc:	08 95       	ret

00002cde <_exit>:
    2cde:	f8 94       	cli

00002ce0 <__stop_program>:
    2ce0:	ff cf       	rjmp	.-2      	; 0x2ce0 <__stop_program>
