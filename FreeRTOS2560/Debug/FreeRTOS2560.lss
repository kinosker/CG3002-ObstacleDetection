
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007a  00800200  00001ce6  00001d7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001ce6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006df  0080027a  0080027a  00001df4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001df4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000438  00000000  00000000  00001e24  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004a2f  00000000  00000000  0000225c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000010da  00000000  00000000  00006c8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002d89  00000000  00000000  00007d65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c24  00000000  00000000  0000aaf0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000128d  00000000  00000000  0000b714  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003484  00000000  00000000  0000c9a1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000408  00000000  00000000  0000fe25  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	f2 c5       	rjmp	.+3044   	; 0xc3a <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	1e c3       	rjmp	.+1596   	; 0x6a2 <__vector_25>
      66:	00 00       	nop
      68:	8a c3       	rjmp	.+1812   	; 0x77e <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	46 c2       	rjmp	.+1164   	; 0x502 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	d0 c2       	rjmp	.+1440   	; 0x632 <__vector_36>
      92:	00 00       	nop
      94:	3e c3       	rjmp	.+1660   	; 0x712 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 ee       	ldi	r30, 0xE6	; 230
      fc:	fc e1       	ldi	r31, 0x1C	; 28
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	aa 37       	cpi	r26, 0x7A	; 122
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	aa e7       	ldi	r26, 0x7A	; 122
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a9 35       	cpi	r26, 0x59	; 89
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	cc d0       	rcall	.+408    	; 0x2b8 <main>
     120:	0c 94 71 0e 	jmp	0x1ce2	; 0x1ce2 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	f1 d3       	rcall	.+2018   	; 0x93a <waitForHandshake>
     158:	82 e0       	ldi	r24, 0x02	; 2
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	b4 c3       	rjmp	.+1896   	; 0x8c6 <transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	e1 d3       	rcall	.+1986   	; 0x924 <startHandShake>
     162:	85 e1       	ldi	r24, 0x15	; 21
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	af c3       	rjmp	.+1886   	; 0x8c6 <transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a6 97       	sbiw	r28, 0x26	; 38
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e7 e2       	ldi	r30, 0x27	; 39
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	15 96       	adiw	r26, 0x05	; 5
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	ef e2       	ldi	r30, 0x2F	; 47
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1d 96       	adiw	r26, 0x0d	; 13
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e6 e3       	ldi	r30, 0x36	; 54
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	54 96       	adiw	r26, 0x14	; 20
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	ee e3       	ldi	r30, 0x3E	; 62
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5c 96       	adiw	r26, 0x1c	; 28
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	e4 e4       	ldi	r30, 0x44	; 68
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	92 96       	adiw	r26, 0x22	; 34
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	82 d1       	rcall	.+772    	; 0x4de <MaxSonar_Start>
     1da:	87 e2       	ldi	r24, 0x27	; 39
     1dc:	88 d1       	rcall	.+784    	; 0x4ee <MaxSonar_Read>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6f 5f       	subi	r22, 0xFF	; 255
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__itoa_ncheck>
     1ea:	ce 01       	movw	r24, r28
     1ec:	05 96       	adiw	r24, 0x05	; 5
     1ee:	6b d3       	rcall	.+1750   	; 0x8c6 <transmitUSART0>
     1f0:	ce 01       	movw	r24, r28
     1f2:	01 96       	adiw	r24, 0x01	; 1
     1f4:	68 d3       	rcall	.+1744   	; 0x8c6 <transmitUSART0>
     1f6:	ce 01       	movw	r24, r28
     1f8:	4c 96       	adiw	r24, 0x1c	; 28
     1fa:	65 d3       	rcall	.+1738   	; 0x8c6 <transmitUSART0>
     1fc:	86 e2       	ldi	r24, 0x26	; 38
     1fe:	77 d1       	rcall	.+750    	; 0x4ee <MaxSonar_Read>
     200:	4a e0       	ldi	r20, 0x0A	; 10
     202:	be 01       	movw	r22, r28
     204:	6f 5f       	subi	r22, 0xFF	; 255
     206:	7f 4f       	sbci	r23, 0xFF	; 255
     208:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__itoa_ncheck>
     20c:	ce 01       	movw	r24, r28
     20e:	0d 96       	adiw	r24, 0x0d	; 13
     210:	5a d3       	rcall	.+1716   	; 0x8c6 <transmitUSART0>
     212:	ce 01       	movw	r24, r28
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	57 d3       	rcall	.+1710   	; 0x8c6 <transmitUSART0>
     218:	ce 01       	movw	r24, r28
     21a:	4c 96       	adiw	r24, 0x1c	; 28
     21c:	54 d3       	rcall	.+1704   	; 0x8c6 <transmitUSART0>
     21e:	85 e2       	ldi	r24, 0x25	; 37
     220:	66 d1       	rcall	.+716    	; 0x4ee <MaxSonar_Read>
     222:	4a e0       	ldi	r20, 0x0A	; 10
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	0a 97       	sbiw	r24, 0x0a	; 10
     22c:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__itoa_ncheck>
     230:	ce 01       	movw	r24, r28
     232:	44 96       	adiw	r24, 0x14	; 20
     234:	48 d3       	rcall	.+1680   	; 0x8c6 <transmitUSART0>
     236:	ce 01       	movw	r24, r28
     238:	01 96       	adiw	r24, 0x01	; 1
     23a:	45 d3       	rcall	.+1674   	; 0x8c6 <transmitUSART0>
     23c:	ce 01       	movw	r24, r28
     23e:	82 96       	adiw	r24, 0x22	; 34
     240:	42 d3       	rcall	.+1668   	; 0x8c6 <transmitUSART0>
     242:	86 e9       	ldi	r24, 0x96	; 150
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
     24a:	c6 cf       	rjmp	.-116    	; 0x1d8 <maxSonarTask+0x6e>

0000024c <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     24c:	8c ec       	ldi	r24, 0xCC	; 204
     24e:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     252:	8e e3       	ldi	r24, 0x3E	; 62
     254:	80 93 65 00 	sts	0x0065, r24
     258:	08 95       	ret

0000025a <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     25a:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     25e:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     262:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     266:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     26a:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     26e:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     272:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     276:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     27a:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     27e:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     282:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     286:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     28a:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     28e:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     292:	10 92 73 00 	sts	0x0073, r1
     296:	08 95       	ret

00000298 <init>:
}

void init()
{
     298:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     29a:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     29c:	f8 94       	cli
	{
		clearTimer();
     29e:	dd df       	rcall	.-70     	; 0x25a <clearTimer>
		setPowerReduction();
     2a0:	d5 df       	rcall	.-86     	; 0x24c <setPowerReduction>
		USART0_Init();
     2a2:	a3 d2       	rcall	.+1350   	; 0x7ea <USART0_Init>
		USART1_Init();
     2a4:	c2 d2       	rcall	.+1412   	; 0x82a <USART1_Init>
		ADC_Init();
     2a6:	61 d1       	rcall	.+706    	; 0x56a <ADC_Init>
		MaxSonar_Init();
     2a8:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2aa:	84 b1       	in	r24, 0x04	; 4
     2ac:	80 6c       	ori	r24, 0xC0	; 192
     2ae:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2b0:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2b2:	78 94       	sei
}
     2b4:	cf 91       	pop	r28
     2b6:	08 95       	ret

000002b8 <main>:
	
	// do nth
}

int main(void)
{
     2b8:	cf 93       	push	r28
     2ba:	df 93       	push	r29
     2bc:	cd b7       	in	r28, 0x3d	; 61
     2be:	de b7       	in	r29, 0x3e	; 62
     2c0:	2a 97       	sbiw	r28, 0x0a	; 10
     2c2:	0f b6       	in	r0, 0x3f	; 63
     2c4:	f8 94       	cli
     2c6:	de bf       	out	0x3e, r29	; 62
     2c8:	0f be       	out	0x3f, r0	; 63
     2ca:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		init();
     2cc:	e5 df       	rcall	.-54     	; 0x298 <init>
		TaskHandle_t t1,t2,t3,t4,t5;
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t3);
     2ce:	a1 2c       	mov	r10, r1
     2d0:	b1 2c       	mov	r11, r1
     2d2:	c1 2c       	mov	r12, r1
     2d4:	d1 2c       	mov	r13, r1
     2d6:	ce 01       	movw	r24, r28
     2d8:	05 96       	adiw	r24, 0x05	; 5
     2da:	7c 01       	movw	r14, r24
     2dc:	02 e0       	ldi	r16, 0x02	; 2
     2de:	20 e0       	ldi	r18, 0x00	; 0
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	4d e1       	ldi	r20, 0x1D	; 29
     2e4:	51 e0       	ldi	r21, 0x01	; 1
     2e6:	69 e4       	ldi	r22, 0x49	; 73
     2e8:	72 e0       	ldi	r23, 0x02	; 2
     2ea:	85 eb       	ldi	r24, 0xB5	; 181
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     2f2:	ce 01       	movw	r24, r28
     2f4:	09 96       	adiw	r24, 0x09	; 9
     2f6:	7c 01       	movw	r14, r24
     2f8:	01 e0       	ldi	r16, 0x01	; 1
     2fa:	20 e0       	ldi	r18, 0x00	; 0
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	49 e6       	ldi	r20, 0x69	; 105
     300:	50 e0       	ldi	r21, 0x00	; 0
     302:	62 e5       	ldi	r22, 0x52	; 82
     304:	72 e0       	ldi	r23, 0x02	; 2
     306:	83 e9       	ldi	r24, 0x93	; 147
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	f4 d7       	rcall	.+4072   	; 0x12f4 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     30c:	ce 01       	movw	r24, r28
     30e:	07 96       	adiw	r24, 0x07	; 7
     310:	7c 01       	movw	r14, r24
     312:	20 e0       	ldi	r18, 0x00	; 0
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	49 e6       	ldi	r20, 0x69	; 105
     318:	50 e0       	ldi	r21, 0x00	; 0
     31a:	69 e5       	ldi	r22, 0x59	; 89
     31c:	72 e0       	ldi	r23, 0x02	; 2
     31e:	8f e9       	ldi	r24, 0x9F	; 159
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	e8 d7       	rcall	.+4048   	; 0x12f4 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t4);
     324:	ce 01       	movw	r24, r28
     326:	03 96       	adiw	r24, 0x03	; 3
     328:	7c 01       	movw	r14, r24
     32a:	03 e0       	ldi	r16, 0x03	; 3
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	47 e8       	ldi	r20, 0x87	; 135
     332:	50 e0       	ldi	r21, 0x00	; 0
     334:	60 e6       	ldi	r22, 0x60	; 96
     336:	72 e0       	ldi	r23, 0x02	; 2
     338:	8b ea       	ldi	r24, 0xAB	; 171
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	db d7       	rcall	.+4022   	; 0x12f4 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t5);
     33e:	ce 01       	movw	r24, r28
     340:	01 96       	adiw	r24, 0x01	; 1
     342:	7c 01       	movw	r14, r24
     344:	02 e0       	ldi	r16, 0x02	; 2
     346:	20 e0       	ldi	r18, 0x00	; 0
     348:	30 e0       	ldi	r19, 0x00	; 0
     34a:	47 e8       	ldi	r20, 0x87	; 135
     34c:	50 e0       	ldi	r21, 0x00	; 0
     34e:	6c e6       	ldi	r22, 0x6C	; 108
     350:	72 e0       	ldi	r23, 0x02	; 2
     352:	80 eb       	ldi	r24, 0xB0	; 176
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	ce d7       	rcall	.+3996   	; 0x12f4 <xTaskGenericCreate>
		

		vTaskStartScheduler();
     358:	0e 94 84 0a 	call	0x1508	; 0x1508 <vTaskStartScheduler>
     35c:	b7 cf       	rjmp	.-146    	; 0x2cc <main+0x14>

0000035e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     364:	0e 94 ad 0a 	call	0x155a	; 0x155a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     368:	80 91 7a 02 	lds	r24, 0x027A
     36c:	90 91 7b 02 	lds	r25, 0x027B
     370:	89 2b       	or	r24, r25
     372:	31 f4       	brne	.+12     	; 0x380 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     374:	8f e7       	ldi	r24, 0x7F	; 127
     376:	92 e0       	ldi	r25, 0x02	; 2
     378:	90 93 7b 02 	sts	0x027B, r25
     37c:	80 93 7a 02 	sts	0x027A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     380:	40 91 7c 02 	lds	r20, 0x027C
     384:	50 91 7d 02 	lds	r21, 0x027D
     388:	9e 01       	movw	r18, r28
     38a:	24 0f       	add	r18, r20
     38c:	35 1f       	adc	r19, r21
     38e:	2b 3d       	cpi	r18, 0xDB	; 219
     390:	85 e0       	ldi	r24, 0x05	; 5
     392:	38 07       	cpc	r19, r24
     394:	70 f4       	brcc	.+28     	; 0x3b2 <pvPortMalloc+0x54>
     396:	42 17       	cp	r20, r18
     398:	53 07       	cpc	r21, r19
     39a:	70 f4       	brcc	.+28     	; 0x3b8 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     39c:	c0 91 7a 02 	lds	r28, 0x027A
     3a0:	d0 91 7b 02 	lds	r29, 0x027B
     3a4:	c4 0f       	add	r28, r20
     3a6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3a8:	30 93 7d 02 	sts	0x027D, r19
     3ac:	20 93 7c 02 	sts	0x027C, r18
     3b0:	05 c0       	rjmp	.+10     	; 0x3bc <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3b2:	c0 e0       	ldi	r28, 0x00	; 0
     3b4:	d0 e0       	ldi	r29, 0x00	; 0
     3b6:	02 c0       	rjmp	.+4      	; 0x3bc <pvPortMalloc+0x5e>
     3b8:	c0 e0       	ldi	r28, 0x00	; 0
     3ba:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3bc:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3c0:	ce 01       	movw	r24, r28
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3c8:	08 95       	ret

000003ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3ca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3cc:	03 96       	adiw	r24, 0x03	; 3
     3ce:	92 83       	std	Z+2, r25	; 0x02
     3d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3d2:	2f ef       	ldi	r18, 0xFF	; 255
     3d4:	3f ef       	ldi	r19, 0xFF	; 255
     3d6:	34 83       	std	Z+4, r19	; 0x04
     3d8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3da:	96 83       	std	Z+6, r25	; 0x06
     3dc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3de:	90 87       	std	Z+8, r25	; 0x08
     3e0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     3e2:	10 82       	st	Z, r1
     3e4:	08 95       	ret

000003e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3e6:	fc 01       	movw	r30, r24
     3e8:	11 86       	std	Z+9, r1	; 0x09
     3ea:	10 86       	std	Z+8, r1	; 0x08
     3ec:	08 95       	ret

000003ee <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	9c 01       	movw	r18, r24
     3f4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3f6:	dc 01       	movw	r26, r24
     3f8:	11 96       	adiw	r26, 0x01	; 1
     3fa:	cd 91       	ld	r28, X+
     3fc:	dc 91       	ld	r29, X
     3fe:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     400:	d3 83       	std	Z+3, r29	; 0x03
     402:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     404:	8c 81       	ldd	r24, Y+4	; 0x04
     406:	9d 81       	ldd	r25, Y+5	; 0x05
     408:	95 83       	std	Z+5, r25	; 0x05
     40a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     40c:	8c 81       	ldd	r24, Y+4	; 0x04
     40e:	9d 81       	ldd	r25, Y+5	; 0x05
     410:	dc 01       	movw	r26, r24
     412:	13 96       	adiw	r26, 0x03	; 3
     414:	7c 93       	st	X, r23
     416:	6e 93       	st	-X, r22
     418:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     41a:	7d 83       	std	Y+5, r23	; 0x05
     41c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     41e:	31 87       	std	Z+9, r19	; 0x09
     420:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     422:	f9 01       	movw	r30, r18
     424:	80 81       	ld	r24, Z
     426:	8f 5f       	subi	r24, 0xFF	; 255
     428:	80 83       	st	Z, r24
}
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	08 95       	ret

00000430 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     430:	cf 93       	push	r28
     432:	df 93       	push	r29
     434:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     436:	48 81       	ld	r20, Y
     438:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     43a:	4f 3f       	cpi	r20, 0xFF	; 255
     43c:	2f ef       	ldi	r18, 0xFF	; 255
     43e:	52 07       	cpc	r21, r18
     440:	21 f4       	brne	.+8      	; 0x44a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     442:	fc 01       	movw	r30, r24
     444:	a7 81       	ldd	r26, Z+7	; 0x07
     446:	b0 85       	ldd	r27, Z+8	; 0x08
     448:	0d c0       	rjmp	.+26     	; 0x464 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     44a:	dc 01       	movw	r26, r24
     44c:	13 96       	adiw	r26, 0x03	; 3
     44e:	12 96       	adiw	r26, 0x02	; 2
     450:	ed 91       	ld	r30, X+
     452:	fc 91       	ld	r31, X
     454:	13 97       	sbiw	r26, 0x03	; 3
     456:	20 81       	ld	r18, Z
     458:	31 81       	ldd	r19, Z+1	; 0x01
     45a:	42 17       	cp	r20, r18
     45c:	53 07       	cpc	r21, r19
     45e:	10 f0       	brcs	.+4      	; 0x464 <vListInsert+0x34>
     460:	df 01       	movw	r26, r30
     462:	f5 cf       	rjmp	.-22     	; 0x44e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     464:	12 96       	adiw	r26, 0x02	; 2
     466:	ed 91       	ld	r30, X+
     468:	fc 91       	ld	r31, X
     46a:	13 97       	sbiw	r26, 0x03	; 3
     46c:	fb 83       	std	Y+3, r31	; 0x03
     46e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     470:	d5 83       	std	Z+5, r29	; 0x05
     472:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     474:	bd 83       	std	Y+5, r27	; 0x05
     476:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     478:	13 96       	adiw	r26, 0x03	; 3
     47a:	dc 93       	st	X, r29
     47c:	ce 93       	st	-X, r28
     47e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     480:	99 87       	std	Y+9, r25	; 0x09
     482:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     484:	fc 01       	movw	r30, r24
     486:	20 81       	ld	r18, Z
     488:	2f 5f       	subi	r18, 0xFF	; 255
     48a:	20 83       	st	Z, r18
}
     48c:	df 91       	pop	r29
     48e:	cf 91       	pop	r28
     490:	08 95       	ret

00000492 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
     496:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     498:	a0 85       	ldd	r26, Z+8	; 0x08
     49a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     49c:	c2 81       	ldd	r28, Z+2	; 0x02
     49e:	d3 81       	ldd	r29, Z+3	; 0x03
     4a0:	84 81       	ldd	r24, Z+4	; 0x04
     4a2:	95 81       	ldd	r25, Z+5	; 0x05
     4a4:	9d 83       	std	Y+5, r25	; 0x05
     4a6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4a8:	c4 81       	ldd	r28, Z+4	; 0x04
     4aa:	d5 81       	ldd	r29, Z+5	; 0x05
     4ac:	82 81       	ldd	r24, Z+2	; 0x02
     4ae:	93 81       	ldd	r25, Z+3	; 0x03
     4b0:	9b 83       	std	Y+3, r25	; 0x03
     4b2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4b4:	11 96       	adiw	r26, 0x01	; 1
     4b6:	cd 91       	ld	r28, X+
     4b8:	dc 91       	ld	r29, X
     4ba:	12 97       	sbiw	r26, 0x02	; 2
     4bc:	ce 17       	cp	r28, r30
     4be:	df 07       	cpc	r29, r31
     4c0:	31 f4       	brne	.+12     	; 0x4ce <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4c2:	8c 81       	ldd	r24, Y+4	; 0x04
     4c4:	9d 81       	ldd	r25, Y+5	; 0x05
     4c6:	12 96       	adiw	r26, 0x02	; 2
     4c8:	9c 93       	st	X, r25
     4ca:	8e 93       	st	-X, r24
     4cc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     4ce:	11 86       	std	Z+9, r1	; 0x09
     4d0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4d2:	8c 91       	ld	r24, X
     4d4:	81 50       	subi	r24, 0x01	; 1
     4d6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     4d8:	df 91       	pop	r29
     4da:	cf 91       	pop	r28
     4dc:	08 95       	ret

000004de <MaxSonar_Start>:
#include <maxSonar.h>
#include <myADC.h>

void MaxSonar_Start()
{
	MaxSonar_TriggerStart();
     4de:	a1 9a       	sbi	0x14, 1	; 20
	
	vTaskDelay(1);	
     4e0:	81 e0       	ldi	r24, 0x01	; 1
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <vTaskDelay>
	
	MaxSonar_TriggerStop();
     4e8:	84 b3       	in	r24, 0x14	; 20
     4ea:	14 ba       	out	0x14, r1	; 20
     4ec:	08 95       	ret

000004ee <MaxSonar_Read>:
}

// Return distance in cm
int MaxSonar_Read(char analogChannel)
{
	return analogRead(analogChannel) * 5;
     4ee:	9a d0       	rcall	.+308    	; 0x624 <analogRead>
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	9c 01       	movw	r18, r24
     4f4:	22 0f       	add	r18, r18
     4f6:	33 1f       	adc	r19, r19
     4f8:	22 0f       	add	r18, r18
     4fa:	33 1f       	adc	r19, r19
}
     4fc:	82 0f       	add	r24, r18
     4fe:	93 1f       	adc	r25, r19
     500:	08 95       	ret

00000502 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     502:	1f 92       	push	r1
     504:	0f 92       	push	r0
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	0f 92       	push	r0
     50a:	11 24       	eor	r1, r1
     50c:	0b b6       	in	r0, 0x3b	; 59
     50e:	0f 92       	push	r0
     510:	2f 93       	push	r18
     512:	3f 93       	push	r19
     514:	4f 93       	push	r20
     516:	5f 93       	push	r21
     518:	6f 93       	push	r22
     51a:	7f 93       	push	r23
     51c:	8f 93       	push	r24
     51e:	9f 93       	push	r25
     520:	af 93       	push	r26
     522:	bf 93       	push	r27
     524:	ef 93       	push	r30
     526:	ff 93       	push	r31
	adcReading = ADCH; // read value
     528:	80 91 79 00 	lds	r24, 0x0079
     52c:	80 93 bc 08 	sts	0x08BC, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	40 e0       	ldi	r20, 0x00	; 0
     534:	50 e0       	ldi	r21, 0x00	; 0
     536:	60 e0       	ldi	r22, 0x00	; 0
     538:	70 e0       	ldi	r23, 0x00	; 0
     53a:	80 91 bf 08 	lds	r24, 0x08BF
     53e:	90 91 c0 08 	lds	r25, 0x08C0
     542:	59 d5       	rcall	.+2738   	; 0xff6 <xQueueGenericSendFromISR>
}
     544:	ff 91       	pop	r31
     546:	ef 91       	pop	r30
     548:	bf 91       	pop	r27
     54a:	af 91       	pop	r26
     54c:	9f 91       	pop	r25
     54e:	8f 91       	pop	r24
     550:	7f 91       	pop	r23
     552:	6f 91       	pop	r22
     554:	5f 91       	pop	r21
     556:	4f 91       	pop	r20
     558:	3f 91       	pop	r19
     55a:	2f 91       	pop	r18
     55c:	0f 90       	pop	r0
     55e:	0b be       	out	0x3b, r0	; 59
     560:	0f 90       	pop	r0
     562:	0f be       	out	0x3f, r0	; 63
     564:	0f 90       	pop	r0
     566:	1f 90       	pop	r1
     568:	18 95       	reti

0000056a <ADC_Init>:

void ADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     56a:	8f e8       	ldi	r24, 0x8F	; 143
     56c:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     570:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     574:	80 e6       	ldi	r24, 0x60	; 96
     576:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     57a:	43 e0       	ldi	r20, 0x03	; 3
     57c:	60 e0       	ldi	r22, 0x00	; 0
     57e:	81 e0       	ldi	r24, 0x01	; 1
     580:	55 d4       	rcall	.+2218   	; 0xe2c <xQueueGenericCreate>
     582:	90 93 c0 08 	sts	0x08C0, r25
     586:	80 93 bf 08 	sts	0x08BF, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     58a:	81 e0       	ldi	r24, 0x01	; 1
     58c:	0c d5       	rcall	.+2584   	; 0xfa6 <xQueueCreateMutex>
     58e:	90 93 be 08 	sts	0x08BE, r25
     592:	80 93 bd 08 	sts	0x08BD, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     596:	20 e0       	ldi	r18, 0x00	; 0
     598:	40 e0       	ldi	r20, 0x00	; 0
     59a:	50 e0       	ldi	r21, 0x00	; 0
     59c:	60 e0       	ldi	r22, 0x00	; 0
     59e:	70 e0       	ldi	r23, 0x00	; 0
     5a0:	6f c4       	rjmp	.+2270   	; 0xe80 <xQueueGenericSend>
     5a2:	08 95       	ret

000005a4 <startADC>:
	return readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void startADC(char channel)
{
     5a4:	cf 93       	push	r28
     5a6:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     5a8:	20 e0       	ldi	r18, 0x00	; 0
     5aa:	4f ef       	ldi	r20, 0xFF	; 255
     5ac:	5f ef       	ldi	r21, 0xFF	; 255
     5ae:	60 e0       	ldi	r22, 0x00	; 0
     5b0:	70 e0       	ldi	r23, 0x00	; 0
     5b2:	80 91 bd 08 	lds	r24, 0x08BD
     5b6:	90 91 be 08 	lds	r25, 0x08BE
     5ba:	57 d5       	rcall	.+2734   	; 0x106a <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     5bc:	ec e7       	ldi	r30, 0x7C	; 124
     5be:	f0 e0       	ldi	r31, 0x00	; 0
     5c0:	80 81       	ld	r24, Z
     5c2:	9c 2f       	mov	r25, r28
     5c4:	9f 71       	andi	r25, 0x1F	; 31
     5c6:	80 76       	andi	r24, 0x60	; 96
     5c8:	89 2b       	or	r24, r25
     5ca:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     5cc:	eb e7       	ldi	r30, 0x7B	; 123
     5ce:	f0 e0       	ldi	r31, 0x00	; 0
     5d0:	20 81       	ld	r18, Z
     5d2:	c0 72       	andi	r28, 0x20	; 32
     5d4:	8c 2f       	mov	r24, r28
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	95 95       	asr	r25
     5da:	87 95       	ror	r24
     5dc:	95 95       	asr	r25
     5de:	87 95       	ror	r24
     5e0:	92 2f       	mov	r25, r18
     5e2:	90 76       	andi	r25, 0x60	; 96
     5e4:	89 2b       	or	r24, r25
     5e6:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     5e8:	ea e7       	ldi	r30, 0x7A	; 122
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	80 81       	ld	r24, Z
     5ee:	80 64       	ori	r24, 0x40	; 64
     5f0:	80 83       	st	Z, r24
}
     5f2:	cf 91       	pop	r28
     5f4:	08 95       	ret

000005f6 <readADC>:

unsigned char readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     5f6:	20 e0       	ldi	r18, 0x00	; 0
     5f8:	4f ef       	ldi	r20, 0xFF	; 255
     5fa:	5f ef       	ldi	r21, 0xFF	; 255
     5fc:	60 e0       	ldi	r22, 0x00	; 0
     5fe:	70 e0       	ldi	r23, 0x00	; 0
     600:	80 91 bf 08 	lds	r24, 0x08BF
     604:	90 91 c0 08 	lds	r25, 0x08C0
     608:	30 d5       	rcall	.+2656   	; 0x106a <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     60a:	20 e0       	ldi	r18, 0x00	; 0
     60c:	40 e0       	ldi	r20, 0x00	; 0
     60e:	50 e0       	ldi	r21, 0x00	; 0
     610:	60 e0       	ldi	r22, 0x00	; 0
     612:	70 e0       	ldi	r23, 0x00	; 0
     614:	80 91 bd 08 	lds	r24, 0x08BD
     618:	90 91 be 08 	lds	r25, 0x08BE
     61c:	31 d4       	rcall	.+2146   	; 0xe80 <xQueueGenericSend>
	return adcReading;
     61e:	80 91 bc 08 	lds	r24, 0x08BC
     622:	08 95       	ret

00000624 <analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char analogRead(char channel)
{
     624:	cf 93       	push	r28
     626:	c8 2f       	mov	r28, r24
	startADC(channel);
     628:	bd df       	rcall	.-134    	; 0x5a4 <startADC>
	return readADC(channel);
     62a:	8c 2f       	mov	r24, r28
     62c:	e4 df       	rcall	.-56     	; 0x5f6 <readADC>
}
     62e:	cf 91       	pop	r28
     630:	08 95       	ret

00000632 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     632:	1f 92       	push	r1
     634:	0f 92       	push	r0
     636:	0f b6       	in	r0, 0x3f	; 63
     638:	0f 92       	push	r0
     63a:	11 24       	eor	r1, r1
     63c:	0b b6       	in	r0, 0x3b	; 59
     63e:	0f 92       	push	r0
     640:	2f 93       	push	r18
     642:	3f 93       	push	r19
     644:	4f 93       	push	r20
     646:	5f 93       	push	r21
     648:	6f 93       	push	r22
     64a:	7f 93       	push	r23
     64c:	8f 93       	push	r24
     64e:	9f 93       	push	r25
     650:	af 93       	push	r26
     652:	bf 93       	push	r27
     654:	ef 93       	push	r30
     656:	ff 93       	push	r31
     658:	60 91 ce 00 	lds	r22, 0x00CE
     65c:	84 e5       	ldi	r24, 0x54	; 84
     65e:	99 e0       	ldi	r25, 0x09	; 9
     660:	d0 d5       	rcall	.+2976   	; 0x1202 <ringBufferPush>
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	40 e0       	ldi	r20, 0x00	; 0
     666:	50 e0       	ldi	r21, 0x00	; 0
     668:	60 e0       	ldi	r22, 0x00	; 0
     66a:	70 e0       	ldi	r23, 0x00	; 0
     66c:	80 91 48 09 	lds	r24, 0x0948
     670:	90 91 49 09 	lds	r25, 0x0949
     674:	c0 d4       	rcall	.+2432   	; 0xff6 <xQueueGenericSendFromISR>
     676:	84 e5       	ldi	r24, 0x54	; 84
     678:	99 e0       	ldi	r25, 0x09	; 9
     67a:	d9 d5       	rcall	.+2994   	; 0x122e <ringBufferFull>
     67c:	ff 91       	pop	r31
     67e:	ef 91       	pop	r30
     680:	bf 91       	pop	r27
     682:	af 91       	pop	r26
     684:	9f 91       	pop	r25
     686:	8f 91       	pop	r24
     688:	7f 91       	pop	r23
     68a:	6f 91       	pop	r22
     68c:	5f 91       	pop	r21
     68e:	4f 91       	pop	r20
     690:	3f 91       	pop	r19
     692:	2f 91       	pop	r18
     694:	0f 90       	pop	r0
     696:	0b be       	out	0x3b, r0	; 59
     698:	0f 90       	pop	r0
     69a:	0f be       	out	0x3f, r0	; 63
     69c:	0f 90       	pop	r0
     69e:	1f 90       	pop	r1
     6a0:	18 95       	reti

000006a2 <__vector_25>:
     6a2:	1f 92       	push	r1
     6a4:	0f 92       	push	r0
     6a6:	0f b6       	in	r0, 0x3f	; 63
     6a8:	0f 92       	push	r0
     6aa:	11 24       	eor	r1, r1
     6ac:	0b b6       	in	r0, 0x3b	; 59
     6ae:	0f 92       	push	r0
     6b0:	2f 93       	push	r18
     6b2:	3f 93       	push	r19
     6b4:	4f 93       	push	r20
     6b6:	5f 93       	push	r21
     6b8:	6f 93       	push	r22
     6ba:	7f 93       	push	r23
     6bc:	8f 93       	push	r24
     6be:	9f 93       	push	r25
     6c0:	af 93       	push	r26
     6c2:	bf 93       	push	r27
     6c4:	ef 93       	push	r30
     6c6:	ff 93       	push	r31
     6c8:	60 91 c6 00 	lds	r22, 0x00C6
     6cc:	81 ee       	ldi	r24, 0xE1	; 225
     6ce:	98 e0       	ldi	r25, 0x08	; 8
     6d0:	98 d5       	rcall	.+2864   	; 0x1202 <ringBufferPush>
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	40 e0       	ldi	r20, 0x00	; 0
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	70 e0       	ldi	r23, 0x00	; 0
     6dc:	80 91 48 09 	lds	r24, 0x0948
     6e0:	90 91 49 09 	lds	r25, 0x0949
     6e4:	88 d4       	rcall	.+2320   	; 0xff6 <xQueueGenericSendFromISR>
     6e6:	81 ee       	ldi	r24, 0xE1	; 225
     6e8:	98 e0       	ldi	r25, 0x08	; 8
     6ea:	a1 d5       	rcall	.+2882   	; 0x122e <ringBufferFull>
     6ec:	ff 91       	pop	r31
     6ee:	ef 91       	pop	r30
     6f0:	bf 91       	pop	r27
     6f2:	af 91       	pop	r26
     6f4:	9f 91       	pop	r25
     6f6:	8f 91       	pop	r24
     6f8:	7f 91       	pop	r23
     6fa:	6f 91       	pop	r22
     6fc:	5f 91       	pop	r21
     6fe:	4f 91       	pop	r20
     700:	3f 91       	pop	r19
     702:	2f 91       	pop	r18
     704:	0f 90       	pop	r0
     706:	0b be       	out	0x3b, r0	; 59
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	0f 90       	pop	r0
     70e:	1f 90       	pop	r1
     710:	18 95       	reti

00000712 <__vector_37>:
     712:	1f 92       	push	r1
     714:	0f 92       	push	r0
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	0f 92       	push	r0
     71a:	11 24       	eor	r1, r1
     71c:	0b b6       	in	r0, 0x3b	; 59
     71e:	0f 92       	push	r0
     720:	2f 93       	push	r18
     722:	3f 93       	push	r19
     724:	4f 93       	push	r20
     726:	5f 93       	push	r21
     728:	6f 93       	push	r22
     72a:	7f 93       	push	r23
     72c:	8f 93       	push	r24
     72e:	9f 93       	push	r25
     730:	af 93       	push	r26
     732:	bf 93       	push	r27
     734:	ef 93       	push	r30
     736:	ff 93       	push	r31
     738:	8a e4       	ldi	r24, 0x4A	; 74
     73a:	99 e0       	ldi	r25, 0x09	; 9
     73c:	7f d5       	rcall	.+2814   	; 0x123c <ringBufferNotEmpty>
     73e:	88 23       	and	r24, r24
     740:	31 f0       	breq	.+12     	; 0x74e <__vector_37+0x3c>
     742:	8a e4       	ldi	r24, 0x4A	; 74
     744:	99 e0       	ldi	r25, 0x09	; 9
     746:	4b d5       	rcall	.+2710   	; 0x11de <ringBufferPop>
     748:	80 93 ce 00 	sts	0x00CE, r24
     74c:	05 c0       	rjmp	.+10     	; 0x758 <__vector_37+0x46>
     74e:	e9 ec       	ldi	r30, 0xC9	; 201
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	80 81       	ld	r24, Z
     754:	8f 7d       	andi	r24, 0xDF	; 223
     756:	80 83       	st	Z, r24
     758:	ff 91       	pop	r31
     75a:	ef 91       	pop	r30
     75c:	bf 91       	pop	r27
     75e:	af 91       	pop	r26
     760:	9f 91       	pop	r25
     762:	8f 91       	pop	r24
     764:	7f 91       	pop	r23
     766:	6f 91       	pop	r22
     768:	5f 91       	pop	r21
     76a:	4f 91       	pop	r20
     76c:	3f 91       	pop	r19
     76e:	2f 91       	pop	r18
     770:	0f 90       	pop	r0
     772:	0b be       	out	0x3b, r0	; 59
     774:	0f 90       	pop	r0
     776:	0f be       	out	0x3f, r0	; 63
     778:	0f 90       	pop	r0
     77a:	1f 90       	pop	r1
     77c:	18 95       	reti

0000077e <__vector_26>:
     77e:	1f 92       	push	r1
     780:	0f 92       	push	r0
     782:	0f b6       	in	r0, 0x3f	; 63
     784:	0f 92       	push	r0
     786:	11 24       	eor	r1, r1
     788:	0b b6       	in	r0, 0x3b	; 59
     78a:	0f 92       	push	r0
     78c:	2f 93       	push	r18
     78e:	3f 93       	push	r19
     790:	4f 93       	push	r20
     792:	5f 93       	push	r21
     794:	6f 93       	push	r22
     796:	7f 93       	push	r23
     798:	8f 93       	push	r24
     79a:	9f 93       	push	r25
     79c:	af 93       	push	r26
     79e:	bf 93       	push	r27
     7a0:	ef 93       	push	r30
     7a2:	ff 93       	push	r31
     7a4:	8f e4       	ldi	r24, 0x4F	; 79
     7a6:	99 e0       	ldi	r25, 0x09	; 9
     7a8:	49 d5       	rcall	.+2706   	; 0x123c <ringBufferNotEmpty>
     7aa:	88 23       	and	r24, r24
     7ac:	31 f0       	breq	.+12     	; 0x7ba <__vector_26+0x3c>
     7ae:	8f e4       	ldi	r24, 0x4F	; 79
     7b0:	99 e0       	ldi	r25, 0x09	; 9
     7b2:	15 d5       	rcall	.+2602   	; 0x11de <ringBufferPop>
     7b4:	80 93 c6 00 	sts	0x00C6, r24
     7b8:	05 c0       	rjmp	.+10     	; 0x7c4 <__vector_26+0x46>
     7ba:	e1 ec       	ldi	r30, 0xC1	; 193
     7bc:	f0 e0       	ldi	r31, 0x00	; 0
     7be:	80 81       	ld	r24, Z
     7c0:	8f 7d       	andi	r24, 0xDF	; 223
     7c2:	80 83       	st	Z, r24
     7c4:	ff 91       	pop	r31
     7c6:	ef 91       	pop	r30
     7c8:	bf 91       	pop	r27
     7ca:	af 91       	pop	r26
     7cc:	9f 91       	pop	r25
     7ce:	8f 91       	pop	r24
     7d0:	7f 91       	pop	r23
     7d2:	6f 91       	pop	r22
     7d4:	5f 91       	pop	r21
     7d6:	4f 91       	pop	r20
     7d8:	3f 91       	pop	r19
     7da:	2f 91       	pop	r18
     7dc:	0f 90       	pop	r0
     7de:	0b be       	out	0x3b, r0	; 59
     7e0:	0f 90       	pop	r0
     7e2:	0f be       	out	0x3f, r0	; 63
     7e4:	0f 90       	pop	r0
     7e6:	1f 90       	pop	r1
     7e8:	18 95       	reti

000007ea <USART0_Init>:
     7ea:	10 92 c5 00 	sts	0x00C5, r1
     7ee:	87 e6       	ldi	r24, 0x67	; 103
     7f0:	80 93 c4 00 	sts	0x00C4, r24
     7f4:	88 eb       	ldi	r24, 0xB8	; 184
     7f6:	80 93 c1 00 	sts	0x00C1, r24
     7fa:	86 e0       	ldi	r24, 0x06	; 6
     7fc:	80 93 c2 00 	sts	0x00C2, r24
     800:	40 e2       	ldi	r20, 0x20	; 32
     802:	66 e0       	ldi	r22, 0x06	; 6
     804:	79 e0       	ldi	r23, 0x09	; 9
     806:	81 ee       	ldi	r24, 0xE1	; 225
     808:	98 e0       	ldi	r25, 0x08	; 8
     80a:	e2 d4       	rcall	.+2500   	; 0x11d0 <ringBufferInit>
     80c:	40 e2       	ldi	r20, 0x20	; 32
     80e:	66 ee       	ldi	r22, 0xE6	; 230
     810:	78 e0       	ldi	r23, 0x08	; 8
     812:	8f e4       	ldi	r24, 0x4F	; 79
     814:	99 e0       	ldi	r25, 0x09	; 9
     816:	dc d4       	rcall	.+2488   	; 0x11d0 <ringBufferInit>
     818:	43 e0       	ldi	r20, 0x03	; 3
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	06 d3       	rcall	.+1548   	; 0xe2c <xQueueGenericCreate>
     820:	90 93 47 09 	sts	0x0947, r25
     824:	80 93 46 09 	sts	0x0946, r24
     828:	08 95       	ret

0000082a <USART1_Init>:
     82a:	10 92 cd 00 	sts	0x00CD, r1
     82e:	87 e6       	ldi	r24, 0x67	; 103
     830:	80 93 cc 00 	sts	0x00CC, r24
     834:	88 eb       	ldi	r24, 0xB8	; 184
     836:	80 93 c9 00 	sts	0x00C9, r24
     83a:	86 e0       	ldi	r24, 0x06	; 6
     83c:	80 93 ca 00 	sts	0x00CA, r24
     840:	40 e2       	ldi	r20, 0x20	; 32
     842:	61 ec       	ldi	r22, 0xC1	; 193
     844:	78 e0       	ldi	r23, 0x08	; 8
     846:	84 e5       	ldi	r24, 0x54	; 84
     848:	99 e0       	ldi	r25, 0x09	; 9
     84a:	c2 d4       	rcall	.+2436   	; 0x11d0 <ringBufferInit>
     84c:	40 e2       	ldi	r20, 0x20	; 32
     84e:	66 e2       	ldi	r22, 0x26	; 38
     850:	79 e0       	ldi	r23, 0x09	; 9
     852:	8a e4       	ldi	r24, 0x4A	; 74
     854:	99 e0       	ldi	r25, 0x09	; 9
     856:	bc d4       	rcall	.+2424   	; 0x11d0 <ringBufferInit>
     858:	43 e0       	ldi	r20, 0x03	; 3
     85a:	60 e0       	ldi	r22, 0x00	; 0
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	e6 d2       	rcall	.+1484   	; 0xe2c <xQueueGenericCreate>
     860:	90 93 49 09 	sts	0x0949, r25
     864:	80 93 48 09 	sts	0x0948, r24
     868:	08 95       	ret

0000086a <transmitUSART0_c>:
     86a:	cf 93       	push	r28
     86c:	c8 2f       	mov	r28, r24
     86e:	8f e4       	ldi	r24, 0x4F	; 79
     870:	99 e0       	ldi	r25, 0x09	; 9
     872:	dd d4       	rcall	.+2490   	; 0x122e <ringBufferFull>
     874:	81 11       	cpse	r24, r1
     876:	fb cf       	rjmp	.-10     	; 0x86e <transmitUSART0_c+0x4>
     878:	6c 2f       	mov	r22, r28
     87a:	8f e4       	ldi	r24, 0x4F	; 79
     87c:	99 e0       	ldi	r25, 0x09	; 9
     87e:	c1 d4       	rcall	.+2434   	; 0x1202 <ringBufferPush>
     880:	e1 ec       	ldi	r30, 0xC1	; 193
     882:	f0 e0       	ldi	r31, 0x00	; 0
     884:	80 81       	ld	r24, Z
     886:	80 62       	ori	r24, 0x20	; 32
     888:	80 83       	st	Z, r24
     88a:	e0 ec       	ldi	r30, 0xC0	; 192
     88c:	f0 e0       	ldi	r31, 0x00	; 0
     88e:	80 81       	ld	r24, Z
     890:	80 64       	ori	r24, 0x40	; 64
     892:	80 83       	st	Z, r24
     894:	cf 91       	pop	r28
     896:	08 95       	ret

00000898 <transmitUSART1_c>:
     898:	cf 93       	push	r28
     89a:	c8 2f       	mov	r28, r24
     89c:	8a e4       	ldi	r24, 0x4A	; 74
     89e:	99 e0       	ldi	r25, 0x09	; 9
     8a0:	c6 d4       	rcall	.+2444   	; 0x122e <ringBufferFull>
     8a2:	81 11       	cpse	r24, r1
     8a4:	fb cf       	rjmp	.-10     	; 0x89c <transmitUSART1_c+0x4>
     8a6:	6c 2f       	mov	r22, r28
     8a8:	8a e4       	ldi	r24, 0x4A	; 74
     8aa:	99 e0       	ldi	r25, 0x09	; 9
     8ac:	aa d4       	rcall	.+2388   	; 0x1202 <ringBufferPush>
     8ae:	e9 ec       	ldi	r30, 0xC9	; 201
     8b0:	f0 e0       	ldi	r31, 0x00	; 0
     8b2:	80 81       	ld	r24, Z
     8b4:	80 62       	ori	r24, 0x20	; 32
     8b6:	80 83       	st	Z, r24
     8b8:	e8 ec       	ldi	r30, 0xC8	; 200
     8ba:	f0 e0       	ldi	r31, 0x00	; 0
     8bc:	80 81       	ld	r24, Z
     8be:	80 64       	ori	r24, 0x40	; 64
     8c0:	80 83       	st	Z, r24
     8c2:	cf 91       	pop	r28
     8c4:	08 95       	ret

000008c6 <transmitUSART0>:
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     8ca:	ec 01       	movw	r28, r24
     8cc:	88 81       	ld	r24, Y
     8ce:	88 23       	and	r24, r24
     8d0:	29 f0       	breq	.+10     	; 0x8dc <transmitUSART0+0x16>
     8d2:	21 96       	adiw	r28, 0x01	; 1
     8d4:	ca df       	rcall	.-108    	; 0x86a <transmitUSART0_c>
     8d6:	89 91       	ld	r24, Y+
     8d8:	81 11       	cpse	r24, r1
     8da:	fc cf       	rjmp	.-8      	; 0x8d4 <transmitUSART0+0xe>
     8dc:	df 91       	pop	r29
     8de:	cf 91       	pop	r28
     8e0:	08 95       	ret

000008e2 <receiveUSART1>:
     8e2:	cf 93       	push	r28
     8e4:	20 e0       	ldi	r18, 0x00	; 0
     8e6:	4f ef       	ldi	r20, 0xFF	; 255
     8e8:	5f ef       	ldi	r21, 0xFF	; 255
     8ea:	60 e0       	ldi	r22, 0x00	; 0
     8ec:	70 e0       	ldi	r23, 0x00	; 0
     8ee:	80 91 46 09 	lds	r24, 0x0946
     8f2:	90 91 47 09 	lds	r25, 0x0947
     8f6:	b9 d3       	rcall	.+1906   	; 0x106a <xQueueGenericReceive>
     8f8:	84 e5       	ldi	r24, 0x54	; 84
     8fa:	99 e0       	ldi	r25, 0x09	; 9
     8fc:	70 d4       	rcall	.+2272   	; 0x11de <ringBufferPop>
     8fe:	c8 2f       	mov	r28, r24
     900:	84 e5       	ldi	r24, 0x54	; 84
     902:	99 e0       	ldi	r25, 0x09	; 9
     904:	9b d4       	rcall	.+2358   	; 0x123c <ringBufferNotEmpty>
     906:	88 23       	and	r24, r24
     908:	51 f0       	breq	.+20     	; 0x91e <receiveUSART1+0x3c>
     90a:	20 e0       	ldi	r18, 0x00	; 0
     90c:	40 e0       	ldi	r20, 0x00	; 0
     90e:	50 e0       	ldi	r21, 0x00	; 0
     910:	60 e0       	ldi	r22, 0x00	; 0
     912:	70 e0       	ldi	r23, 0x00	; 0
     914:	80 91 46 09 	lds	r24, 0x0946
     918:	90 91 47 09 	lds	r25, 0x0947
     91c:	b1 d2       	rcall	.+1378   	; 0xe80 <xQueueGenericSend>
     91e:	8c 2f       	mov	r24, r28
     920:	cf 91       	pop	r28
     922:	08 95       	ret

00000924 <startHandShake>:

// -1 if fail, 0 success
char startHandShake()
{
	transmitUSART1_c(HANDSHAKE_START);
     924:	80 e0       	ldi	r24, 0x00	; 0
     926:	b8 df       	rcall	.-144    	; 0x898 <transmitUSART1_c>
	
	if (! receiveHandShakeAck(receiveUSART1()))
     928:	dc df       	rcall	.-72     	; 0x8e2 <receiveUSART1>
     92a:	85 35       	cpi	r24, 0x55	; 85
     92c:	21 f4       	brne	.+8      	; 0x936 <startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
     92e:	8f ef       	ldi	r24, 0xFF	; 255
     930:	b3 df       	rcall	.-154    	; 0x898 <transmitUSART1_c>
	
	return 0;
     932:	80 e0       	ldi	r24, 0x00	; 0
     934:	08 95       	ret
{
	transmitUSART1_c(HANDSHAKE_START);
	
	if (! receiveHandShakeAck(receiveUSART1()))
	{
		return -1; //error handling
     936:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     938:	08 95       	ret

0000093a <waitForHandshake>:


// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
     93a:	d3 df       	rcall	.-90     	; 0x8e2 <receiveUSART1>
     93c:	81 11       	cpse	r24, r1
     93e:	0a c0       	rjmp	.+20     	; 0x954 <waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	transmitUSART1_c(HANDSHAKE_ACK);
     940:	85 e5       	ldi	r24, 0x55	; 85
     942:	aa df       	rcall	.-172    	; 0x898 <transmitUSART1_c>
	
	if (! receiveHandShakeStart(receiveUSART1()))
     944:	ce df       	rcall	.-100    	; 0x8e2 <receiveUSART1>
     946:	91 e0       	ldi	r25, 0x01	; 1
     948:	81 11       	cpse	r24, r1
     94a:	01 c0       	rjmp	.+2      	; 0x94e <waitForHandshake+0x14>
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	89 2f       	mov	r24, r25
     950:	81 95       	neg	r24
     952:	08 95       	ret
// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
	{
		return -1; // error handling
     954:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     956:	08 95       	ret

00000958 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     958:	31 e1       	ldi	r19, 0x11	; 17
     95a:	fc 01       	movw	r30, r24
     95c:	30 83       	st	Z, r19
     95e:	31 97       	sbiw	r30, 0x01	; 1
     960:	22 e2       	ldi	r18, 0x22	; 34
     962:	20 83       	st	Z, r18
     964:	31 97       	sbiw	r30, 0x01	; 1
     966:	a3 e3       	ldi	r26, 0x33	; 51
     968:	a0 83       	st	Z, r26
     96a:	31 97       	sbiw	r30, 0x01	; 1
     96c:	60 83       	st	Z, r22
     96e:	31 97       	sbiw	r30, 0x01	; 1
     970:	70 83       	st	Z, r23
     972:	31 97       	sbiw	r30, 0x01	; 1
     974:	10 82       	st	Z, r1
     976:	31 97       	sbiw	r30, 0x01	; 1
     978:	10 82       	st	Z, r1
     97a:	31 97       	sbiw	r30, 0x01	; 1
     97c:	60 e8       	ldi	r22, 0x80	; 128
     97e:	60 83       	st	Z, r22
     980:	31 97       	sbiw	r30, 0x01	; 1
     982:	10 82       	st	Z, r1
     984:	31 97       	sbiw	r30, 0x01	; 1
     986:	10 82       	st	Z, r1
     988:	31 97       	sbiw	r30, 0x01	; 1
     98a:	10 82       	st	Z, r1
     98c:	31 97       	sbiw	r30, 0x01	; 1
     98e:	62 e0       	ldi	r22, 0x02	; 2
     990:	60 83       	st	Z, r22
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	63 e0       	ldi	r22, 0x03	; 3
     996:	60 83       	st	Z, r22
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	64 e0       	ldi	r22, 0x04	; 4
     99c:	60 83       	st	Z, r22
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	65 e0       	ldi	r22, 0x05	; 5
     9a2:	60 83       	st	Z, r22
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	66 e0       	ldi	r22, 0x06	; 6
     9a8:	60 83       	st	Z, r22
     9aa:	31 97       	sbiw	r30, 0x01	; 1
     9ac:	67 e0       	ldi	r22, 0x07	; 7
     9ae:	60 83       	st	Z, r22
     9b0:	31 97       	sbiw	r30, 0x01	; 1
     9b2:	68 e0       	ldi	r22, 0x08	; 8
     9b4:	60 83       	st	Z, r22
     9b6:	31 97       	sbiw	r30, 0x01	; 1
     9b8:	69 e0       	ldi	r22, 0x09	; 9
     9ba:	60 83       	st	Z, r22
     9bc:	31 97       	sbiw	r30, 0x01	; 1
     9be:	60 e1       	ldi	r22, 0x10	; 16
     9c0:	60 83       	st	Z, r22
     9c2:	31 97       	sbiw	r30, 0x01	; 1
     9c4:	30 83       	st	Z, r19
     9c6:	31 97       	sbiw	r30, 0x01	; 1
     9c8:	32 e1       	ldi	r19, 0x12	; 18
     9ca:	30 83       	st	Z, r19
     9cc:	31 97       	sbiw	r30, 0x01	; 1
     9ce:	33 e1       	ldi	r19, 0x13	; 19
     9d0:	30 83       	st	Z, r19
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	34 e1       	ldi	r19, 0x14	; 20
     9d6:	30 83       	st	Z, r19
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	35 e1       	ldi	r19, 0x15	; 21
     9dc:	30 83       	st	Z, r19
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	36 e1       	ldi	r19, 0x16	; 22
     9e2:	30 83       	st	Z, r19
     9e4:	31 97       	sbiw	r30, 0x01	; 1
     9e6:	37 e1       	ldi	r19, 0x17	; 23
     9e8:	30 83       	st	Z, r19
     9ea:	31 97       	sbiw	r30, 0x01	; 1
     9ec:	38 e1       	ldi	r19, 0x18	; 24
     9ee:	30 83       	st	Z, r19
     9f0:	31 97       	sbiw	r30, 0x01	; 1
     9f2:	39 e1       	ldi	r19, 0x19	; 25
     9f4:	30 83       	st	Z, r19
     9f6:	31 97       	sbiw	r30, 0x01	; 1
     9f8:	30 e2       	ldi	r19, 0x20	; 32
     9fa:	30 83       	st	Z, r19
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	31 e2       	ldi	r19, 0x21	; 33
     a00:	30 83       	st	Z, r19
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	20 83       	st	Z, r18
     a06:	31 97       	sbiw	r30, 0x01	; 1
     a08:	23 e2       	ldi	r18, 0x23	; 35
     a0a:	20 83       	st	Z, r18
     a0c:	31 97       	sbiw	r30, 0x01	; 1
     a0e:	40 83       	st	Z, r20
     a10:	31 97       	sbiw	r30, 0x01	; 1
     a12:	50 83       	st	Z, r21
     a14:	31 97       	sbiw	r30, 0x01	; 1
     a16:	26 e2       	ldi	r18, 0x26	; 38
     a18:	20 83       	st	Z, r18
     a1a:	31 97       	sbiw	r30, 0x01	; 1
     a1c:	27 e2       	ldi	r18, 0x27	; 39
     a1e:	20 83       	st	Z, r18
     a20:	31 97       	sbiw	r30, 0x01	; 1
     a22:	28 e2       	ldi	r18, 0x28	; 40
     a24:	20 83       	st	Z, r18
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	29 e2       	ldi	r18, 0x29	; 41
     a2a:	20 83       	st	Z, r18
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	20 e3       	ldi	r18, 0x30	; 48
     a30:	20 83       	st	Z, r18
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	21 e3       	ldi	r18, 0x31	; 49
     a36:	20 83       	st	Z, r18
     a38:	89 97       	sbiw	r24, 0x29	; 41
     a3a:	08 95       	ret

00000a3c <xPortStartScheduler>:
     a3c:	82 e0       	ldi	r24, 0x02	; 2
     a3e:	84 bd       	out	0x24, r24	; 36
     a40:	16 bc       	out	0x26, r1	; 38
     a42:	80 e3       	ldi	r24, 0x30	; 48
     a44:	87 bd       	out	0x27, r24	; 39
     a46:	ee e6       	ldi	r30, 0x6E	; 110
     a48:	f0 e0       	ldi	r31, 0x00	; 0
     a4a:	80 81       	ld	r24, Z
     a4c:	82 60       	ori	r24, 0x02	; 2
     a4e:	80 83       	st	Z, r24
     a50:	83 e0       	ldi	r24, 0x03	; 3
     a52:	85 bd       	out	0x25, r24	; 37
     a54:	a0 91 ba 08 	lds	r26, 0x08BA
     a58:	b0 91 bb 08 	lds	r27, 0x08BB
     a5c:	cd 91       	ld	r28, X+
     a5e:	cd bf       	out	0x3d, r28	; 61
     a60:	dd 91       	ld	r29, X+
     a62:	de bf       	out	0x3e, r29	; 62
     a64:	ff 91       	pop	r31
     a66:	ef 91       	pop	r30
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	bf 91       	pop	r27
     a6e:	af 91       	pop	r26
     a70:	9f 91       	pop	r25
     a72:	8f 91       	pop	r24
     a74:	7f 91       	pop	r23
     a76:	6f 91       	pop	r22
     a78:	5f 91       	pop	r21
     a7a:	4f 91       	pop	r20
     a7c:	3f 91       	pop	r19
     a7e:	2f 91       	pop	r18
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	ff 90       	pop	r15
     a86:	ef 90       	pop	r14
     a88:	df 90       	pop	r13
     a8a:	cf 90       	pop	r12
     a8c:	bf 90       	pop	r11
     a8e:	af 90       	pop	r10
     a90:	9f 90       	pop	r9
     a92:	8f 90       	pop	r8
     a94:	7f 90       	pop	r7
     a96:	6f 90       	pop	r6
     a98:	5f 90       	pop	r5
     a9a:	4f 90       	pop	r4
     a9c:	3f 90       	pop	r3
     a9e:	2f 90       	pop	r2
     aa0:	1f 90       	pop	r1
     aa2:	0f 90       	pop	r0
     aa4:	0c be       	out	0x3c, r0	; 60
     aa6:	0f 90       	pop	r0
     aa8:	0b be       	out	0x3b, r0	; 59
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63
     aae:	0f 90       	pop	r0
     ab0:	08 95       	ret
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	08 95       	ret

00000ab6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ab6:	0f 92       	push	r0
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	0f 92       	push	r0
     abe:	0b b6       	in	r0, 0x3b	; 59
     ac0:	0f 92       	push	r0
     ac2:	0c b6       	in	r0, 0x3c	; 60
     ac4:	0f 92       	push	r0
     ac6:	1f 92       	push	r1
     ac8:	11 24       	eor	r1, r1
     aca:	2f 92       	push	r2
     acc:	3f 92       	push	r3
     ace:	4f 92       	push	r4
     ad0:	5f 92       	push	r5
     ad2:	6f 92       	push	r6
     ad4:	7f 92       	push	r7
     ad6:	8f 92       	push	r8
     ad8:	9f 92       	push	r9
     ada:	af 92       	push	r10
     adc:	bf 92       	push	r11
     ade:	cf 92       	push	r12
     ae0:	df 92       	push	r13
     ae2:	ef 92       	push	r14
     ae4:	ff 92       	push	r15
     ae6:	0f 93       	push	r16
     ae8:	1f 93       	push	r17
     aea:	2f 93       	push	r18
     aec:	3f 93       	push	r19
     aee:	4f 93       	push	r20
     af0:	5f 93       	push	r21
     af2:	6f 93       	push	r22
     af4:	7f 93       	push	r23
     af6:	8f 93       	push	r24
     af8:	9f 93       	push	r25
     afa:	af 93       	push	r26
     afc:	bf 93       	push	r27
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	ef 93       	push	r30
     b04:	ff 93       	push	r31
     b06:	a0 91 ba 08 	lds	r26, 0x08BA
     b0a:	b0 91 bb 08 	lds	r27, 0x08BB
     b0e:	0d b6       	in	r0, 0x3d	; 61
     b10:	0d 92       	st	X+, r0
     b12:	0e b6       	in	r0, 0x3e	; 62
     b14:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b16:	bb d6       	rcall	.+3446   	; 0x188e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b18:	a0 91 ba 08 	lds	r26, 0x08BA
     b1c:	b0 91 bb 08 	lds	r27, 0x08BB
     b20:	cd 91       	ld	r28, X+
     b22:	cd bf       	out	0x3d, r28	; 61
     b24:	dd 91       	ld	r29, X+
     b26:	de bf       	out	0x3e, r29	; 62
     b28:	ff 91       	pop	r31
     b2a:	ef 91       	pop	r30
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	bf 91       	pop	r27
     b32:	af 91       	pop	r26
     b34:	9f 91       	pop	r25
     b36:	8f 91       	pop	r24
     b38:	7f 91       	pop	r23
     b3a:	6f 91       	pop	r22
     b3c:	5f 91       	pop	r21
     b3e:	4f 91       	pop	r20
     b40:	3f 91       	pop	r19
     b42:	2f 91       	pop	r18
     b44:	1f 91       	pop	r17
     b46:	0f 91       	pop	r16
     b48:	ff 90       	pop	r15
     b4a:	ef 90       	pop	r14
     b4c:	df 90       	pop	r13
     b4e:	cf 90       	pop	r12
     b50:	bf 90       	pop	r11
     b52:	af 90       	pop	r10
     b54:	9f 90       	pop	r9
     b56:	8f 90       	pop	r8
     b58:	7f 90       	pop	r7
     b5a:	6f 90       	pop	r6
     b5c:	5f 90       	pop	r5
     b5e:	4f 90       	pop	r4
     b60:	3f 90       	pop	r3
     b62:	2f 90       	pop	r2
     b64:	1f 90       	pop	r1
     b66:	0f 90       	pop	r0
     b68:	0c be       	out	0x3c, r0	; 60
     b6a:	0f 90       	pop	r0
     b6c:	0b be       	out	0x3b, r0	; 59
     b6e:	0f 90       	pop	r0
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b74:	08 95       	ret

00000b76 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b76:	0f 92       	push	r0
     b78:	0f b6       	in	r0, 0x3f	; 63
     b7a:	f8 94       	cli
     b7c:	0f 92       	push	r0
     b7e:	0b b6       	in	r0, 0x3b	; 59
     b80:	0f 92       	push	r0
     b82:	0c b6       	in	r0, 0x3c	; 60
     b84:	0f 92       	push	r0
     b86:	1f 92       	push	r1
     b88:	11 24       	eor	r1, r1
     b8a:	2f 92       	push	r2
     b8c:	3f 92       	push	r3
     b8e:	4f 92       	push	r4
     b90:	5f 92       	push	r5
     b92:	6f 92       	push	r6
     b94:	7f 92       	push	r7
     b96:	8f 92       	push	r8
     b98:	9f 92       	push	r9
     b9a:	af 92       	push	r10
     b9c:	bf 92       	push	r11
     b9e:	cf 92       	push	r12
     ba0:	df 92       	push	r13
     ba2:	ef 92       	push	r14
     ba4:	ff 92       	push	r15
     ba6:	0f 93       	push	r16
     ba8:	1f 93       	push	r17
     baa:	2f 93       	push	r18
     bac:	3f 93       	push	r19
     bae:	4f 93       	push	r20
     bb0:	5f 93       	push	r21
     bb2:	6f 93       	push	r22
     bb4:	7f 93       	push	r23
     bb6:	8f 93       	push	r24
     bb8:	9f 93       	push	r25
     bba:	af 93       	push	r26
     bbc:	bf 93       	push	r27
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	ef 93       	push	r30
     bc4:	ff 93       	push	r31
     bc6:	a0 91 ba 08 	lds	r26, 0x08BA
     bca:	b0 91 bb 08 	lds	r27, 0x08BB
     bce:	0d b6       	in	r0, 0x3d	; 61
     bd0:	0d 92       	st	X+, r0
     bd2:	0e b6       	in	r0, 0x3e	; 62
     bd4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     bd6:	c7 d4       	rcall	.+2446   	; 0x1566 <xTaskIncrementTick>
     bd8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     bda:	59 d6       	rcall	.+3250   	; 0x188e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     bdc:	a0 91 ba 08 	lds	r26, 0x08BA
     be0:	b0 91 bb 08 	lds	r27, 0x08BB
     be4:	cd 91       	ld	r28, X+
     be6:	cd bf       	out	0x3d, r28	; 61
     be8:	dd 91       	ld	r29, X+
     bea:	de bf       	out	0x3e, r29	; 62
     bec:	ff 91       	pop	r31
     bee:	ef 91       	pop	r30
     bf0:	df 91       	pop	r29
     bf2:	cf 91       	pop	r28
     bf4:	bf 91       	pop	r27
     bf6:	af 91       	pop	r26
     bf8:	9f 91       	pop	r25
     bfa:	8f 91       	pop	r24
     bfc:	7f 91       	pop	r23
     bfe:	6f 91       	pop	r22
     c00:	5f 91       	pop	r21
     c02:	4f 91       	pop	r20
     c04:	3f 91       	pop	r19
     c06:	2f 91       	pop	r18
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	ef 90       	pop	r14
     c10:	df 90       	pop	r13
     c12:	cf 90       	pop	r12
     c14:	bf 90       	pop	r11
     c16:	af 90       	pop	r10
     c18:	9f 90       	pop	r9
     c1a:	8f 90       	pop	r8
     c1c:	7f 90       	pop	r7
     c1e:	6f 90       	pop	r6
     c20:	5f 90       	pop	r5
     c22:	4f 90       	pop	r4
     c24:	3f 90       	pop	r3
     c26:	2f 90       	pop	r2
     c28:	1f 90       	pop	r1
     c2a:	0f 90       	pop	r0
     c2c:	0c be       	out	0x3c, r0	; 60
     c2e:	0f 90       	pop	r0
     c30:	0b be       	out	0x3b, r0	; 59
     c32:	0f 90       	pop	r0
     c34:	0f be       	out	0x3f, r0	; 63
     c36:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c38:	08 95       	ret

00000c3a <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     c3a:	9d df       	rcall	.-198    	; 0xb76 <vPortYieldFromTick>
		 asm volatile ("reti");
     c3c:	18 95       	reti

00000c3e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     c3e:	1f 93       	push	r17
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	ec 01       	movw	r28, r24
     c46:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     c48:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c4a:	81 11       	cpse	r24, r1
     c4c:	0b c0       	rjmp	.+22     	; 0xc64 <prvCopyDataToQueue+0x26>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c4e:	88 81       	ld	r24, Y
     c50:	99 81       	ldd	r25, Y+1	; 0x01
     c52:	89 2b       	or	r24, r25
     c54:	09 f0       	breq	.+2      	; 0xc58 <prvCopyDataToQueue+0x1a>
     c56:	44 c0       	rjmp	.+136    	; 0xce0 <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     c58:	8a 81       	ldd	r24, Y+2	; 0x02
     c5a:	9b 81       	ldd	r25, Y+3	; 0x03
     c5c:	8e d7       	rcall	.+3868   	; 0x1b7a <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     c5e:	1b 82       	std	Y+3, r1	; 0x03
     c60:	1a 82       	std	Y+2, r1	; 0x02
     c62:	45 c0       	rjmp	.+138    	; 0xcee <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     c64:	41 11       	cpse	r20, r1
     c66:	17 c0       	rjmp	.+46     	; 0xc96 <prvCopyDataToQueue+0x58>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     c68:	48 2f       	mov	r20, r24
     c6a:	50 e0       	ldi	r21, 0x00	; 0
     c6c:	8c 81       	ldd	r24, Y+4	; 0x04
     c6e:	9d 81       	ldd	r25, Y+5	; 0x05
     c70:	fc d7       	rcall	.+4088   	; 0x1c6a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     c72:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c74:	8c 81       	ldd	r24, Y+4	; 0x04
     c76:	9d 81       	ldd	r25, Y+5	; 0x05
     c78:	82 0f       	add	r24, r18
     c7a:	91 1d       	adc	r25, r1
     c7c:	9d 83       	std	Y+5, r25	; 0x05
     c7e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     c80:	2a 81       	ldd	r18, Y+2	; 0x02
     c82:	3b 81       	ldd	r19, Y+3	; 0x03
     c84:	82 17       	cp	r24, r18
     c86:	93 07       	cpc	r25, r19
     c88:	68 f1       	brcs	.+90     	; 0xce4 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     c8a:	88 81       	ld	r24, Y
     c8c:	99 81       	ldd	r25, Y+1	; 0x01
     c8e:	9d 83       	std	Y+5, r25	; 0x05
     c90:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     c92:	80 e0       	ldi	r24, 0x00	; 0
     c94:	2c c0       	rjmp	.+88     	; 0xcee <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     c96:	48 2f       	mov	r20, r24
     c98:	50 e0       	ldi	r21, 0x00	; 0
     c9a:	8e 81       	ldd	r24, Y+6	; 0x06
     c9c:	9f 81       	ldd	r25, Y+7	; 0x07
     c9e:	e5 d7       	rcall	.+4042   	; 0x1c6a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ca0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	31 95       	neg	r19
     ca6:	21 95       	neg	r18
     ca8:	31 09       	sbc	r19, r1
     caa:	8e 81       	ldd	r24, Y+6	; 0x06
     cac:	9f 81       	ldd	r25, Y+7	; 0x07
     cae:	82 0f       	add	r24, r18
     cb0:	93 1f       	adc	r25, r19
     cb2:	9f 83       	std	Y+7, r25	; 0x07
     cb4:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cb6:	68 81       	ld	r22, Y
     cb8:	79 81       	ldd	r23, Y+1	; 0x01
     cba:	86 17       	cp	r24, r22
     cbc:	97 07       	cpc	r25, r23
     cbe:	30 f4       	brcc	.+12     	; 0xccc <prvCopyDataToQueue+0x8e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     cc0:	8a 81       	ldd	r24, Y+2	; 0x02
     cc2:	9b 81       	ldd	r25, Y+3	; 0x03
     cc4:	28 0f       	add	r18, r24
     cc6:	39 1f       	adc	r19, r25
     cc8:	3f 83       	std	Y+7, r19	; 0x07
     cca:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     ccc:	12 30       	cpi	r17, 0x02	; 2
     cce:	61 f4       	brne	.+24     	; 0xce8 <prvCopyDataToQueue+0xaa>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     cd0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cd2:	88 23       	and	r24, r24
     cd4:	59 f0       	breq	.+22     	; 0xcec <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     cd6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     cd8:	81 50       	subi	r24, 0x01	; 1
     cda:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	07 c0       	rjmp	.+14     	; 0xcee <prvCopyDataToQueue+0xb0>
     ce0:	80 e0       	ldi	r24, 0x00	; 0
     ce2:	05 c0       	rjmp	.+10     	; 0xcee <prvCopyDataToQueue+0xb0>
     ce4:	80 e0       	ldi	r24, 0x00	; 0
     ce6:	03 c0       	rjmp	.+6      	; 0xcee <prvCopyDataToQueue+0xb0>
     ce8:	80 e0       	ldi	r24, 0x00	; 0
     cea:	01 c0       	rjmp	.+2      	; 0xcee <prvCopyDataToQueue+0xb0>
     cec:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     cee:	9a 8d       	ldd	r25, Y+26	; 0x1a
     cf0:	9f 5f       	subi	r25, 0xFF	; 255
     cf2:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	1f 91       	pop	r17
     cfa:	08 95       	ret

00000cfc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     cfc:	fc 01       	movw	r30, r24
     cfe:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     d00:	44 8d       	ldd	r20, Z+28	; 0x1c
     d02:	44 23       	and	r20, r20
     d04:	99 f0       	breq	.+38     	; 0xd2c <prvCopyDataFromQueue+0x30>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d06:	50 e0       	ldi	r21, 0x00	; 0
     d08:	26 81       	ldd	r18, Z+6	; 0x06
     d0a:	37 81       	ldd	r19, Z+7	; 0x07
     d0c:	24 0f       	add	r18, r20
     d0e:	35 1f       	adc	r19, r21
     d10:	37 83       	std	Z+7, r19	; 0x07
     d12:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     d14:	62 81       	ldd	r22, Z+2	; 0x02
     d16:	73 81       	ldd	r23, Z+3	; 0x03
     d18:	26 17       	cp	r18, r22
     d1a:	37 07       	cpc	r19, r23
     d1c:	20 f0       	brcs	.+8      	; 0xd26 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d1e:	20 81       	ld	r18, Z
     d20:	31 81       	ldd	r19, Z+1	; 0x01
     d22:	37 83       	std	Z+7, r19	; 0x07
     d24:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     d26:	66 81       	ldd	r22, Z+6	; 0x06
     d28:	77 81       	ldd	r23, Z+7	; 0x07
     d2a:	9f c7       	rjmp	.+3902   	; 0x1c6a <memcpy>
     d2c:	08 95       	ret

00000d2e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     d2e:	0f 93       	push	r16
     d30:	1f 93       	push	r17
     d32:	cf 93       	push	r28
     d34:	df 93       	push	r29
     d36:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     d38:	0f b6       	in	r0, 0x3f	; 63
     d3a:	f8 94       	cli
     d3c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     d3e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d40:	18 16       	cp	r1, r24
     d42:	a4 f4       	brge	.+40     	; 0xd6c <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d44:	89 89       	ldd	r24, Y+17	; 0x11
     d46:	88 23       	and	r24, r24
     d48:	89 f0       	breq	.+34     	; 0xd6c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d4a:	8e 01       	movw	r16, r28
     d4c:	0f 5e       	subi	r16, 0xEF	; 239
     d4e:	1f 4f       	sbci	r17, 0xFF	; 255
     d50:	03 c0       	rjmp	.+6      	; 0xd58 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d52:	89 89       	ldd	r24, Y+17	; 0x11
     d54:	88 23       	and	r24, r24
     d56:	51 f0       	breq	.+20     	; 0xd6c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d58:	c8 01       	movw	r24, r16
     d5a:	22 d6       	rcall	.+3140   	; 0x19a0 <xTaskRemoveFromEventList>
     d5c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     d5e:	ab d6       	rcall	.+3414   	; 0x1ab6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     d60:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d62:	81 50       	subi	r24, 0x01	; 1
     d64:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     d66:	8e 8d       	ldd	r24, Y+30	; 0x1e
     d68:	18 16       	cp	r1, r24
     d6a:	9c f3       	brlt	.-26     	; 0xd52 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     d6c:	8f ef       	ldi	r24, 0xFF	; 255
     d6e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     d70:	0f 90       	pop	r0
     d72:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     d74:	0f b6       	in	r0, 0x3f	; 63
     d76:	f8 94       	cli
     d78:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     d7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d7c:	18 16       	cp	r1, r24
     d7e:	a4 f4       	brge	.+40     	; 0xda8 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d80:	88 85       	ldd	r24, Y+8	; 0x08
     d82:	88 23       	and	r24, r24
     d84:	89 f0       	breq	.+34     	; 0xda8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d86:	8e 01       	movw	r16, r28
     d88:	08 5f       	subi	r16, 0xF8	; 248
     d8a:	1f 4f       	sbci	r17, 0xFF	; 255
     d8c:	03 c0       	rjmp	.+6      	; 0xd94 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d8e:	88 85       	ldd	r24, Y+8	; 0x08
     d90:	88 23       	and	r24, r24
     d92:	51 f0       	breq	.+20     	; 0xda8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d94:	c8 01       	movw	r24, r16
     d96:	04 d6       	rcall	.+3080   	; 0x19a0 <xTaskRemoveFromEventList>
     d98:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     d9a:	8d d6       	rcall	.+3354   	; 0x1ab6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     d9c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d9e:	81 50       	subi	r24, 0x01	; 1
     da0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     da2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     da4:	18 16       	cp	r1, r24
     da6:	9c f3       	brlt	.-26     	; 0xd8e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     da8:	8f ef       	ldi	r24, 0xFF	; 255
     daa:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     dac:	0f 90       	pop	r0
     dae:	0f be       	out	0x3f, r0	; 63
}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	08 95       	ret

00000dba <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     dba:	cf 93       	push	r28
     dbc:	df 93       	push	r29
     dbe:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     dc6:	88 81       	ld	r24, Y
     dc8:	99 81       	ldd	r25, Y+1	; 0x01
     dca:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dcc:	30 e0       	ldi	r19, 0x00	; 0
     dce:	7b 8d       	ldd	r23, Y+27	; 0x1b
     dd0:	72 9f       	mul	r23, r18
     dd2:	a0 01       	movw	r20, r0
     dd4:	73 9f       	mul	r23, r19
     dd6:	50 0d       	add	r21, r0
     dd8:	11 24       	eor	r1, r1
     dda:	fc 01       	movw	r30, r24
     ddc:	e4 0f       	add	r30, r20
     dde:	f5 1f       	adc	r31, r21
     de0:	fb 83       	std	Y+3, r31	; 0x03
     de2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     de4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     de6:	9d 83       	std	Y+5, r25	; 0x05
     de8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     dea:	42 1b       	sub	r20, r18
     dec:	53 0b       	sbc	r21, r19
     dee:	84 0f       	add	r24, r20
     df0:	95 1f       	adc	r25, r21
     df2:	9f 83       	std	Y+7, r25	; 0x07
     df4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     df6:	8f ef       	ldi	r24, 0xFF	; 255
     df8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     dfa:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     dfc:	61 11       	cpse	r22, r1
     dfe:	0a c0       	rjmp	.+20     	; 0xe14 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e00:	88 85       	ldd	r24, Y+8	; 0x08
     e02:	88 23       	and	r24, r24
     e04:	69 f0       	breq	.+26     	; 0xe20 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     e06:	ce 01       	movw	r24, r28
     e08:	08 96       	adiw	r24, 0x08	; 8
     e0a:	ca d5       	rcall	.+2964   	; 0x19a0 <xTaskRemoveFromEventList>
     e0c:	81 30       	cpi	r24, 0x01	; 1
     e0e:	41 f4       	brne	.+16     	; 0xe20 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
     e10:	52 de       	rcall	.-860    	; 0xab6 <vPortYield>
     e12:	06 c0       	rjmp	.+12     	; 0xe20 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     e14:	ce 01       	movw	r24, r28
     e16:	08 96       	adiw	r24, 0x08	; 8
     e18:	d8 da       	rcall	.-2640   	; 0x3ca <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     e1a:	ce 01       	movw	r24, r28
     e1c:	41 96       	adiw	r24, 0x11	; 17
     e1e:	d5 da       	rcall	.-2646   	; 0x3ca <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	df 91       	pop	r29
     e28:	cf 91       	pop	r28
     e2a:	08 95       	ret

00000e2c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     e2c:	0f 93       	push	r16
     e2e:	1f 93       	push	r17
     e30:	cf 93       	push	r28
     e32:	df 93       	push	r29
     e34:	18 2f       	mov	r17, r24
     e36:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
     e38:	88 23       	and	r24, r24
     e3a:	d1 f0       	breq	.+52     	; 0xe70 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
     e3c:	8f e1       	ldi	r24, 0x1F	; 31
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	8e da       	rcall	.-2788   	; 0x35e <pvPortMalloc>
     e42:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     e44:	00 97       	sbiw	r24, 0x00	; 0
     e46:	b1 f0       	breq	.+44     	; 0xe74 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e48:	10 9f       	mul	r17, r16
     e4a:	c0 01       	movw	r24, r0
     e4c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
     e4e:	01 96       	adiw	r24, 0x01	; 1
     e50:	86 da       	rcall	.-2804   	; 0x35e <pvPortMalloc>
     e52:	99 83       	std	Y+1, r25	; 0x01
     e54:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     e56:	89 2b       	or	r24, r25
     e58:	31 f0       	breq	.+12     	; 0xe66 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     e5a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     e5c:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     e5e:	61 e0       	ldi	r22, 0x01	; 1
     e60:	ce 01       	movw	r24, r28
     e62:	ab df       	rcall	.-170    	; 0xdba <xQueueGenericReset>
     e64:	07 c0       	rjmp	.+14     	; 0xe74 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     e66:	ce 01       	movw	r24, r28
     e68:	af da       	rcall	.-2722   	; 0x3c8 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
     e6a:	c0 e0       	ldi	r28, 0x00	; 0
     e6c:	d0 e0       	ldi	r29, 0x00	; 0
     e6e:	02 c0       	rjmp	.+4      	; 0xe74 <xQueueGenericCreate+0x48>
     e70:	c0 e0       	ldi	r28, 0x00	; 0
     e72:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     e74:	ce 01       	movw	r24, r28
     e76:	df 91       	pop	r29
     e78:	cf 91       	pop	r28
     e7a:	1f 91       	pop	r17
     e7c:	0f 91       	pop	r16
     e7e:	08 95       	ret

00000e80 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     e80:	9f 92       	push	r9
     e82:	af 92       	push	r10
     e84:	bf 92       	push	r11
     e86:	cf 92       	push	r12
     e88:	df 92       	push	r13
     e8a:	ef 92       	push	r14
     e8c:	ff 92       	push	r15
     e8e:	0f 93       	push	r16
     e90:	1f 93       	push	r17
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	00 d0       	rcall	.+0      	; 0xe98 <xQueueGenericSend+0x18>
     e98:	1f 92       	push	r1
     e9a:	1f 92       	push	r1
     e9c:	cd b7       	in	r28, 0x3d	; 61
     e9e:	de b7       	in	r29, 0x3e	; 62
     ea0:	8c 01       	movw	r16, r24
     ea2:	6b 01       	movw	r12, r22
     ea4:	5d 83       	std	Y+5, r21	; 0x05
     ea6:	4c 83       	std	Y+4, r20	; 0x04
     ea8:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     eaa:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     eac:	99 24       	eor	r9, r9
     eae:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     eb0:	7c 01       	movw	r14, r24
     eb2:	88 e0       	ldi	r24, 0x08	; 8
     eb4:	e8 0e       	add	r14, r24
     eb6:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     eb8:	0f b6       	in	r0, 0x3f	; 63
     eba:	f8 94       	cli
     ebc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ebe:	f8 01       	movw	r30, r16
     ec0:	92 8d       	ldd	r25, Z+26	; 0x1a
     ec2:	83 8d       	ldd	r24, Z+27	; 0x1b
     ec4:	98 17       	cp	r25, r24
     ec6:	18 f0       	brcs	.+6      	; 0xece <xQueueGenericSend+0x4e>
     ec8:	f2 e0       	ldi	r31, 0x02	; 2
     eca:	af 12       	cpse	r10, r31
     ecc:	15 c0       	rjmp	.+42     	; 0xef8 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ece:	4a 2d       	mov	r20, r10
     ed0:	b6 01       	movw	r22, r12
     ed2:	c8 01       	movw	r24, r16
     ed4:	b4 de       	rcall	.-664    	; 0xc3e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ed6:	f8 01       	movw	r30, r16
     ed8:	91 89       	ldd	r25, Z+17	; 0x11
     eda:	99 23       	and	r25, r25
     edc:	39 f0       	breq	.+14     	; 0xeec <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ede:	c8 01       	movw	r24, r16
     ee0:	41 96       	adiw	r24, 0x11	; 17
     ee2:	5e d5       	rcall	.+2748   	; 0x19a0 <xTaskRemoveFromEventList>
     ee4:	81 30       	cpi	r24, 0x01	; 1
     ee6:	21 f4       	brne	.+8      	; 0xef0 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     ee8:	e6 dd       	rcall	.-1076   	; 0xab6 <vPortYield>
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     eec:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     eee:	e3 dd       	rcall	.-1082   	; 0xab6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     ef4:	81 e0       	ldi	r24, 0x01	; 1
     ef6:	46 c0       	rjmp	.+140    	; 0xf84 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     ef8:	ec 81       	ldd	r30, Y+4	; 0x04
     efa:	fd 81       	ldd	r31, Y+5	; 0x05
     efc:	ef 2b       	or	r30, r31
     efe:	21 f4       	brne	.+8      	; 0xf08 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     f00:	0f 90       	pop	r0
     f02:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     f04:	80 e0       	ldi	r24, 0x00	; 0
     f06:	3e c0       	rjmp	.+124    	; 0xf84 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
     f08:	b1 10       	cpse	r11, r1
     f0a:	04 c0       	rjmp	.+8      	; 0xf14 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     f0c:	ce 01       	movw	r24, r28
     f0e:	01 96       	adiw	r24, 0x01	; 1
     f10:	8f d5       	rcall	.+2846   	; 0x1a30 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     f12:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     f18:	20 d3       	rcall	.+1600   	; 0x155a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     f1a:	0f b6       	in	r0, 0x3f	; 63
     f1c:	f8 94       	cli
     f1e:	0f 92       	push	r0
     f20:	f8 01       	movw	r30, r16
     f22:	85 8d       	ldd	r24, Z+29	; 0x1d
     f24:	8f 3f       	cpi	r24, 0xFF	; 255
     f26:	09 f4       	brne	.+2      	; 0xf2a <xQueueGenericSend+0xaa>
     f28:	15 8e       	std	Z+29, r1	; 0x1d
     f2a:	f8 01       	movw	r30, r16
     f2c:	86 8d       	ldd	r24, Z+30	; 0x1e
     f2e:	8f 3f       	cpi	r24, 0xFF	; 255
     f30:	09 f4       	brne	.+2      	; 0xf34 <xQueueGenericSend+0xb4>
     f32:	16 8e       	std	Z+30, r1	; 0x1e
     f34:	0f 90       	pop	r0
     f36:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     f38:	be 01       	movw	r22, r28
     f3a:	6c 5f       	subi	r22, 0xFC	; 252
     f3c:	7f 4f       	sbci	r23, 0xFF	; 255
     f3e:	ce 01       	movw	r24, r28
     f40:	01 96       	adiw	r24, 0x01	; 1
     f42:	81 d5       	rcall	.+2818   	; 0x1a46 <xTaskCheckForTimeOut>
     f44:	81 11       	cpse	r24, r1
     f46:	1a c0       	rjmp	.+52     	; 0xf7c <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	f8 94       	cli
     f4c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     f4e:	f8 01       	movw	r30, r16
     f50:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     f56:	f8 01       	movw	r30, r16
     f58:	83 8d       	ldd	r24, Z+27	; 0x1b
     f5a:	98 13       	cpse	r25, r24
     f5c:	0b c0       	rjmp	.+22     	; 0xf74 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f5e:	6c 81       	ldd	r22, Y+4	; 0x04
     f60:	7d 81       	ldd	r23, Y+5	; 0x05
     f62:	c7 01       	movw	r24, r14
     f64:	f2 d4       	rcall	.+2532   	; 0x194a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     f66:	c8 01       	movw	r24, r16
     f68:	e2 de       	rcall	.-572    	; 0xd2e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     f6a:	bb d3       	rcall	.+1910   	; 0x16e2 <xTaskResumeAll>
     f6c:	81 11       	cpse	r24, r1
     f6e:	a4 cf       	rjmp	.-184    	; 0xeb8 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     f70:	a2 dd       	rcall	.-1212   	; 0xab6 <vPortYield>
     f72:	a2 cf       	rjmp	.-188    	; 0xeb8 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     f74:	c8 01       	movw	r24, r16
     f76:	db de       	rcall	.-586    	; 0xd2e <prvUnlockQueue>
				( void ) xTaskResumeAll();
     f78:	b4 d3       	rcall	.+1896   	; 0x16e2 <xTaskResumeAll>
     f7a:	9e cf       	rjmp	.-196    	; 0xeb8 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     f7c:	c8 01       	movw	r24, r16
     f7e:	d7 de       	rcall	.-594    	; 0xd2e <prvUnlockQueue>
			( void ) xTaskResumeAll();
     f80:	b0 d3       	rcall	.+1888   	; 0x16e2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     f82:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     f84:	0f 90       	pop	r0
     f86:	0f 90       	pop	r0
     f88:	0f 90       	pop	r0
     f8a:	0f 90       	pop	r0
     f8c:	0f 90       	pop	r0
     f8e:	df 91       	pop	r29
     f90:	cf 91       	pop	r28
     f92:	1f 91       	pop	r17
     f94:	0f 91       	pop	r16
     f96:	ff 90       	pop	r15
     f98:	ef 90       	pop	r14
     f9a:	df 90       	pop	r13
     f9c:	cf 90       	pop	r12
     f9e:	bf 90       	pop	r11
     fa0:	af 90       	pop	r10
     fa2:	9f 90       	pop	r9
     fa4:	08 95       	ret

00000fa6 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
     fa6:	cf 93       	push	r28
     fa8:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
     faa:	8f e1       	ldi	r24, 0x1F	; 31
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	d7 d9       	rcall	.-3154   	; 0x35e <pvPortMalloc>
     fb0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     fb2:	00 97       	sbiw	r24, 0x00	; 0
     fb4:	e1 f0       	breq	.+56     	; 0xfee <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     fb6:	1b 82       	std	Y+3, r1	; 0x03
     fb8:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     fba:	19 82       	std	Y+1, r1	; 0x01
     fbc:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
     fbe:	1d 82       	std	Y+5, r1	; 0x05
     fc0:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
     fc2:	1f 82       	std	Y+7, r1	; 0x07
     fc4:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     fc6:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
     fc8:	81 e0       	ldi	r24, 0x01	; 1
     fca:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
     fcc:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
     fce:	8f ef       	ldi	r24, 0xFF	; 255
     fd0:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
     fd2:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
     fd4:	ce 01       	movw	r24, r28
     fd6:	08 96       	adiw	r24, 0x08	; 8
     fd8:	f8 d9       	rcall	.-3088   	; 0x3ca <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
     fda:	ce 01       	movw	r24, r28
     fdc:	41 96       	adiw	r24, 0x11	; 17
     fde:	f5 d9       	rcall	.-3094   	; 0x3ca <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
     fe0:	20 e0       	ldi	r18, 0x00	; 0
     fe2:	40 e0       	ldi	r20, 0x00	; 0
     fe4:	50 e0       	ldi	r21, 0x00	; 0
     fe6:	60 e0       	ldi	r22, 0x00	; 0
     fe8:	70 e0       	ldi	r23, 0x00	; 0
     fea:	ce 01       	movw	r24, r28
     fec:	49 df       	rcall	.-366    	; 0xe80 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
     fee:	ce 01       	movw	r24, r28
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	08 95       	ret

00000ff6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     ff6:	0f 93       	push	r16
     ff8:	1f 93       	push	r17
     ffa:	cf 93       	push	r28
     ffc:	df 93       	push	r29
     ffe:	ec 01       	movw	r28, r24
    1000:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1002:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1004:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1006:	98 17       	cp	r25, r24
    1008:	10 f0       	brcs	.+4      	; 0x100e <xQueueGenericSendFromISR+0x18>
    100a:	22 30       	cpi	r18, 0x02	; 2
    100c:	11 f5       	brne	.+68     	; 0x1052 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    100e:	42 2f       	mov	r20, r18
    1010:	ce 01       	movw	r24, r28
    1012:	15 de       	rcall	.-982    	; 0xc3e <prvCopyDataToQueue>
    1014:	88 23       	and	r24, r24
    1016:	31 f0       	breq	.+12     	; 0x1024 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1018:	01 15       	cp	r16, r1
    101a:	11 05       	cpc	r17, r1
    101c:	19 f0       	breq	.+6      	; 0x1024 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	f8 01       	movw	r30, r16
    1022:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1024:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1026:	8f 3f       	cpi	r24, 0xFF	; 255
    1028:	79 f4       	brne	.+30     	; 0x1048 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    102a:	89 89       	ldd	r24, Y+17	; 0x11
    102c:	88 23       	and	r24, r24
    102e:	99 f0       	breq	.+38     	; 0x1056 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1030:	ce 01       	movw	r24, r28
    1032:	41 96       	adiw	r24, 0x11	; 17
    1034:	b5 d4       	rcall	.+2410   	; 0x19a0 <xTaskRemoveFromEventList>
    1036:	88 23       	and	r24, r24
    1038:	81 f0       	breq	.+32     	; 0x105a <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    103a:	01 15       	cp	r16, r1
    103c:	11 05       	cpc	r17, r1
    103e:	79 f0       	breq	.+30     	; 0x105e <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	f8 01       	movw	r30, r16
    1044:	80 83       	st	Z, r24
    1046:	0c c0       	rjmp	.+24     	; 0x1060 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1048:	8e 8d       	ldd	r24, Y+30	; 0x1e
    104a:	8f 5f       	subi	r24, 0xFF	; 255
    104c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	07 c0       	rjmp	.+14     	; 0x1060 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1052:	80 e0       	ldi	r24, 0x00	; 0
    1054:	05 c0       	rjmp	.+10     	; 0x1060 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1056:	81 e0       	ldi	r24, 0x01	; 1
    1058:	03 c0       	rjmp	.+6      	; 0x1060 <xQueueGenericSendFromISR+0x6a>
    105a:	81 e0       	ldi	r24, 0x01	; 1
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <xQueueGenericSendFromISR+0x6a>
    105e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1060:	df 91       	pop	r29
    1062:	cf 91       	pop	r28
    1064:	1f 91       	pop	r17
    1066:	0f 91       	pop	r16
    1068:	08 95       	ret

0000106a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    106a:	9f 92       	push	r9
    106c:	af 92       	push	r10
    106e:	bf 92       	push	r11
    1070:	cf 92       	push	r12
    1072:	df 92       	push	r13
    1074:	ef 92       	push	r14
    1076:	ff 92       	push	r15
    1078:	0f 93       	push	r16
    107a:	1f 93       	push	r17
    107c:	cf 93       	push	r28
    107e:	df 93       	push	r29
    1080:	00 d0       	rcall	.+0      	; 0x1082 <xQueueGenericReceive+0x18>
    1082:	1f 92       	push	r1
    1084:	1f 92       	push	r1
    1086:	cd b7       	in	r28, 0x3d	; 61
    1088:	de b7       	in	r29, 0x3e	; 62
    108a:	8c 01       	movw	r16, r24
    108c:	6b 01       	movw	r12, r22
    108e:	5d 83       	std	Y+5, r21	; 0x05
    1090:	4c 83       	std	Y+4, r20	; 0x04
    1092:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1094:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1096:	99 24       	eor	r9, r9
    1098:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    109a:	7c 01       	movw	r14, r24
    109c:	81 e1       	ldi	r24, 0x11	; 17
    109e:	e8 0e       	add	r14, r24
    10a0:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    10a2:	0f b6       	in	r0, 0x3f	; 63
    10a4:	f8 94       	cli
    10a6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    10a8:	f8 01       	movw	r30, r16
    10aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    10ac:	88 23       	and	r24, r24
    10ae:	69 f1       	breq	.+90     	; 0x110a <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    10b0:	e6 80       	ldd	r14, Z+6	; 0x06
    10b2:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    10b4:	b6 01       	movw	r22, r12
    10b6:	c8 01       	movw	r24, r16
    10b8:	21 de       	rcall	.-958    	; 0xcfc <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    10ba:	b1 10       	cpse	r11, r1
    10bc:	17 c0       	rjmp	.+46     	; 0x10ec <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    10be:	f8 01       	movw	r30, r16
    10c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    10c2:	81 50       	subi	r24, 0x01	; 1
    10c4:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    10c6:	80 81       	ld	r24, Z
    10c8:	91 81       	ldd	r25, Z+1	; 0x01
    10ca:	89 2b       	or	r24, r25
    10cc:	21 f4       	brne	.+8      	; 0x10d6 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    10ce:	94 d5       	rcall	.+2856   	; 0x1bf8 <pvTaskIncrementMutexHeldCount>
    10d0:	f8 01       	movw	r30, r16
    10d2:	93 83       	std	Z+3, r25	; 0x03
    10d4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10d6:	f8 01       	movw	r30, r16
    10d8:	80 85       	ldd	r24, Z+8	; 0x08
    10da:	88 23       	and	r24, r24
    10dc:	91 f0       	breq	.+36     	; 0x1102 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    10de:	c8 01       	movw	r24, r16
    10e0:	08 96       	adiw	r24, 0x08	; 8
    10e2:	5e d4       	rcall	.+2236   	; 0x19a0 <xTaskRemoveFromEventList>
    10e4:	81 30       	cpi	r24, 0x01	; 1
    10e6:	69 f4       	brne	.+26     	; 0x1102 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    10e8:	e6 dc       	rcall	.-1588   	; 0xab6 <vPortYield>
    10ea:	0b c0       	rjmp	.+22     	; 0x1102 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    10ec:	f8 01       	movw	r30, r16
    10ee:	f7 82       	std	Z+7, r15	; 0x07
    10f0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10f2:	81 89       	ldd	r24, Z+17	; 0x11
    10f4:	88 23       	and	r24, r24
    10f6:	29 f0       	breq	.+10     	; 0x1102 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10f8:	c8 01       	movw	r24, r16
    10fa:	41 96       	adiw	r24, 0x11	; 17
    10fc:	51 d4       	rcall	.+2210   	; 0x19a0 <xTaskRemoveFromEventList>
    10fe:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1100:	da dc       	rcall	.-1612   	; 0xab6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	52 c0       	rjmp	.+164    	; 0x11ae <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    110a:	4c 81       	ldd	r20, Y+4	; 0x04
    110c:	5d 81       	ldd	r21, Y+5	; 0x05
    110e:	45 2b       	or	r20, r21
    1110:	21 f4       	brne	.+8      	; 0x111a <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1112:	0f 90       	pop	r0
    1114:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1116:	80 e0       	ldi	r24, 0x00	; 0
    1118:	4a c0       	rjmp	.+148    	; 0x11ae <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    111a:	a1 10       	cpse	r10, r1
    111c:	04 c0       	rjmp	.+8      	; 0x1126 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    111e:	ce 01       	movw	r24, r28
    1120:	01 96       	adiw	r24, 0x01	; 1
    1122:	86 d4       	rcall	.+2316   	; 0x1a30 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1124:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1126:	0f 90       	pop	r0
    1128:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    112a:	17 d2       	rcall	.+1070   	; 0x155a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	0f 92       	push	r0
    1132:	f8 01       	movw	r30, r16
    1134:	85 8d       	ldd	r24, Z+29	; 0x1d
    1136:	8f 3f       	cpi	r24, 0xFF	; 255
    1138:	09 f4       	brne	.+2      	; 0x113c <xQueueGenericReceive+0xd2>
    113a:	15 8e       	std	Z+29, r1	; 0x1d
    113c:	f8 01       	movw	r30, r16
    113e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1140:	8f 3f       	cpi	r24, 0xFF	; 255
    1142:	09 f4       	brne	.+2      	; 0x1146 <xQueueGenericReceive+0xdc>
    1144:	16 8e       	std	Z+30, r1	; 0x1e
    1146:	0f 90       	pop	r0
    1148:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    114a:	be 01       	movw	r22, r28
    114c:	6c 5f       	subi	r22, 0xFC	; 252
    114e:	7f 4f       	sbci	r23, 0xFF	; 255
    1150:	ce 01       	movw	r24, r28
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	78 d4       	rcall	.+2288   	; 0x1a46 <xTaskCheckForTimeOut>
    1156:	81 11       	cpse	r24, r1
    1158:	26 c0       	rjmp	.+76     	; 0x11a6 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    115a:	0f b6       	in	r0, 0x3f	; 63
    115c:	f8 94       	cli
    115e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1160:	f8 01       	movw	r30, r16
    1162:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1164:	0f 90       	pop	r0
    1166:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1168:	81 11       	cpse	r24, r1
    116a:	19 c0       	rjmp	.+50     	; 0x119e <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    116c:	f8 01       	movw	r30, r16
    116e:	80 81       	ld	r24, Z
    1170:	91 81       	ldd	r25, Z+1	; 0x01
    1172:	89 2b       	or	r24, r25
    1174:	49 f4       	brne	.+18     	; 0x1188 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    117c:	f8 01       	movw	r30, r16
    117e:	82 81       	ldd	r24, Z+2	; 0x02
    1180:	93 81       	ldd	r25, Z+3	; 0x03
    1182:	9d d4       	rcall	.+2362   	; 0x1abe <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1184:	0f 90       	pop	r0
    1186:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1188:	6c 81       	ldd	r22, Y+4	; 0x04
    118a:	7d 81       	ldd	r23, Y+5	; 0x05
    118c:	c7 01       	movw	r24, r14
    118e:	dd d3       	rcall	.+1978   	; 0x194a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1190:	c8 01       	movw	r24, r16
    1192:	cd dd       	rcall	.-1126   	; 0xd2e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1194:	a6 d2       	rcall	.+1356   	; 0x16e2 <xTaskResumeAll>
    1196:	81 11       	cpse	r24, r1
    1198:	84 cf       	rjmp	.-248    	; 0x10a2 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    119a:	8d dc       	rcall	.-1766   	; 0xab6 <vPortYield>
    119c:	82 cf       	rjmp	.-252    	; 0x10a2 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    119e:	c8 01       	movw	r24, r16
    11a0:	c6 dd       	rcall	.-1140   	; 0xd2e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11a2:	9f d2       	rcall	.+1342   	; 0x16e2 <xTaskResumeAll>
    11a4:	7e cf       	rjmp	.-260    	; 0x10a2 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    11a6:	c8 01       	movw	r24, r16
    11a8:	c2 dd       	rcall	.-1148   	; 0xd2e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11aa:	9b d2       	rcall	.+1334   	; 0x16e2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    11ac:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	0f 90       	pop	r0
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	9f 90       	pop	r9
    11ce:	08 95       	ret

000011d0 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    11d0:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    11d2:	71 83       	std	Z+1, r23	; 0x01
    11d4:	60 83       	st	Z, r22
	ring->rSize = size;
    11d6:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    11d8:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    11da:	13 82       	std	Z+3, r1	; 0x03
    11dc:	08 95       	ret

000011de <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    11de:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    11e0:	94 81       	ldd	r25, Z+4	; 0x04
    11e2:	a0 81       	ld	r26, Z
    11e4:	b1 81       	ldd	r27, Z+1	; 0x01
    11e6:	a9 0f       	add	r26, r25
    11e8:	b1 1d       	adc	r27, r1
    11ea:	8c 91       	ld	r24, X
            ring->rIndex ++;
    11ec:	9f 5f       	subi	r25, 0xFF	; 255
    11ee:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    11f0:	22 81       	ldd	r18, Z+2	; 0x02
    11f2:	92 17       	cp	r25, r18
    11f4:	10 f0       	brcs	.+4      	; 0x11fa <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    11f6:	92 1b       	sub	r25, r18
    11f8:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    11fa:	93 81       	ldd	r25, Z+3	; 0x03
    11fc:	91 50       	subi	r25, 0x01	; 1
    11fe:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1200:	08 95       	ret

00001202 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1202:	fc 01       	movw	r30, r24
    1204:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1206:	83 81       	ldd	r24, Z+3	; 0x03
    1208:	22 81       	ldd	r18, Z+2	; 0x02
    120a:	82 17       	cp	r24, r18
    120c:	78 f4       	brcc	.+30     	; 0x122c <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    120e:	34 81       	ldd	r19, Z+4	; 0x04
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	83 0f       	add	r24, r19
    1214:	91 1d       	adc	r25, r1
    1216:	62 2f       	mov	r22, r18
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	00 d5       	rcall	.+2560   	; 0x1c1c <__divmodhi4>
    121c:	a0 81       	ld	r26, Z
    121e:	b1 81       	ldd	r27, Z+1	; 0x01
    1220:	a8 0f       	add	r26, r24
    1222:	b9 1f       	adc	r27, r25
    1224:	4c 93       	st	X, r20
            ring->rLength++;
    1226:	83 81       	ldd	r24, Z+3	; 0x03
    1228:	8f 5f       	subi	r24, 0xFF	; 255
    122a:	83 83       	std	Z+3, r24	; 0x03
    122c:	08 95       	ret

0000122e <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    122e:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	22 81       	ldd	r18, Z+2	; 0x02
    1234:	93 81       	ldd	r25, Z+3	; 0x03
    1236:	29 13       	cpse	r18, r25
    1238:	80 e0       	ldi	r24, 0x00	; 0
}
    123a:	08 95       	ret

0000123c <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    123c:	21 e0       	ldi	r18, 0x01	; 1
    123e:	fc 01       	movw	r30, r24
    1240:	83 81       	ldd	r24, Z+3	; 0x03
    1242:	81 11       	cpse	r24, r1
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <ringBufferNotEmpty+0xc>
    1246:	20 e0       	ldi	r18, 0x00	; 0
}
    1248:	82 2f       	mov	r24, r18
    124a:	08 95       	ret

0000124c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    124c:	e0 91 82 08 	lds	r30, 0x0882
    1250:	f0 91 83 08 	lds	r31, 0x0883
    1254:	80 81       	ld	r24, Z
    1256:	81 11       	cpse	r24, r1
    1258:	07 c0       	rjmp	.+14     	; 0x1268 <prvResetNextTaskUnblockTime+0x1c>
    125a:	8f ef       	ldi	r24, 0xFF	; 255
    125c:	9f ef       	ldi	r25, 0xFF	; 255
    125e:	90 93 01 02 	sts	0x0201, r25
    1262:	80 93 00 02 	sts	0x0200, r24
    1266:	08 95       	ret
    1268:	e0 91 82 08 	lds	r30, 0x0882
    126c:	f0 91 83 08 	lds	r31, 0x0883
    1270:	05 80       	ldd	r0, Z+5	; 0x05
    1272:	f6 81       	ldd	r31, Z+6	; 0x06
    1274:	e0 2d       	mov	r30, r0
    1276:	06 80       	ldd	r0, Z+6	; 0x06
    1278:	f7 81       	ldd	r31, Z+7	; 0x07
    127a:	e0 2d       	mov	r30, r0
    127c:	82 81       	ldd	r24, Z+2	; 0x02
    127e:	93 81       	ldd	r25, Z+3	; 0x03
    1280:	90 93 01 02 	sts	0x0201, r25
    1284:	80 93 00 02 	sts	0x0200, r24
    1288:	08 95       	ret

0000128a <prvAddCurrentTaskToDelayedList>:
    128a:	cf 93       	push	r28
    128c:	df 93       	push	r29
    128e:	ec 01       	movw	r28, r24
    1290:	e0 91 ba 08 	lds	r30, 0x08BA
    1294:	f0 91 bb 08 	lds	r31, 0x08BB
    1298:	93 83       	std	Z+3, r25	; 0x03
    129a:	82 83       	std	Z+2, r24	; 0x02
    129c:	80 91 61 08 	lds	r24, 0x0861
    12a0:	90 91 62 08 	lds	r25, 0x0862
    12a4:	c8 17       	cp	r28, r24
    12a6:	d9 07       	cpc	r29, r25
    12a8:	60 f4       	brcc	.+24     	; 0x12c2 <prvAddCurrentTaskToDelayedList+0x38>
    12aa:	60 91 ba 08 	lds	r22, 0x08BA
    12ae:	70 91 bb 08 	lds	r23, 0x08BB
    12b2:	80 91 80 08 	lds	r24, 0x0880
    12b6:	90 91 81 08 	lds	r25, 0x0881
    12ba:	6e 5f       	subi	r22, 0xFE	; 254
    12bc:	7f 4f       	sbci	r23, 0xFF	; 255
    12be:	b8 d8       	rcall	.-3728   	; 0x430 <vListInsert>
    12c0:	16 c0       	rjmp	.+44     	; 0x12ee <prvAddCurrentTaskToDelayedList+0x64>
    12c2:	60 91 ba 08 	lds	r22, 0x08BA
    12c6:	70 91 bb 08 	lds	r23, 0x08BB
    12ca:	80 91 82 08 	lds	r24, 0x0882
    12ce:	90 91 83 08 	lds	r25, 0x0883
    12d2:	6e 5f       	subi	r22, 0xFE	; 254
    12d4:	7f 4f       	sbci	r23, 0xFF	; 255
    12d6:	ac d8       	rcall	.-3752   	; 0x430 <vListInsert>
    12d8:	80 91 00 02 	lds	r24, 0x0200
    12dc:	90 91 01 02 	lds	r25, 0x0201
    12e0:	c8 17       	cp	r28, r24
    12e2:	d9 07       	cpc	r29, r25
    12e4:	20 f4       	brcc	.+8      	; 0x12ee <prvAddCurrentTaskToDelayedList+0x64>
    12e6:	d0 93 01 02 	sts	0x0201, r29
    12ea:	c0 93 00 02 	sts	0x0200, r28
    12ee:	df 91       	pop	r29
    12f0:	cf 91       	pop	r28
    12f2:	08 95       	ret

000012f4 <xTaskGenericCreate>:
    12f4:	4f 92       	push	r4
    12f6:	5f 92       	push	r5
    12f8:	6f 92       	push	r6
    12fa:	7f 92       	push	r7
    12fc:	8f 92       	push	r8
    12fe:	9f 92       	push	r9
    1300:	af 92       	push	r10
    1302:	bf 92       	push	r11
    1304:	cf 92       	push	r12
    1306:	df 92       	push	r13
    1308:	ef 92       	push	r14
    130a:	ff 92       	push	r15
    130c:	0f 93       	push	r16
    130e:	1f 93       	push	r17
    1310:	cf 93       	push	r28
    1312:	df 93       	push	r29
    1314:	4c 01       	movw	r8, r24
    1316:	5b 01       	movw	r10, r22
    1318:	2a 01       	movw	r4, r20
    131a:	39 01       	movw	r6, r18
    131c:	83 e2       	ldi	r24, 0x23	; 35
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	1e d8       	rcall	.-4036   	; 0x35e <pvPortMalloc>
    1322:	ec 01       	movw	r28, r24
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	09 f4       	brne	.+2      	; 0x132a <xTaskGenericCreate+0x36>
    1328:	dd c0       	rjmp	.+442    	; 0x14e4 <xTaskGenericCreate+0x1f0>
    132a:	c1 14       	cp	r12, r1
    132c:	d1 04       	cpc	r13, r1
    132e:	09 f0       	breq	.+2      	; 0x1332 <xTaskGenericCreate+0x3e>
    1330:	c2 c0       	rjmp	.+388    	; 0x14b6 <xTaskGenericCreate+0x1c2>
    1332:	c2 01       	movw	r24, r4
    1334:	14 d8       	rcall	.-4056   	; 0x35e <pvPortMalloc>
    1336:	98 8f       	std	Y+24, r25	; 0x18
    1338:	8f 8b       	std	Y+23, r24	; 0x17
    133a:	89 2b       	or	r24, r25
    133c:	09 f0       	breq	.+2      	; 0x1340 <xTaskGenericCreate+0x4c>
    133e:	bd c0       	rjmp	.+378    	; 0x14ba <xTaskGenericCreate+0x1c6>
    1340:	ce 01       	movw	r24, r28
    1342:	42 d8       	rcall	.-3964   	; 0x3c8 <vPortFree>
    1344:	cf c0       	rjmp	.+414    	; 0x14e4 <xTaskGenericCreate+0x1f0>
    1346:	cf 01       	movw	r24, r30
    1348:	31 91       	ld	r19, Z+
    134a:	da 01       	movw	r26, r20
    134c:	3d 93       	st	X+, r19
    134e:	ad 01       	movw	r20, r26
    1350:	dc 01       	movw	r26, r24
    1352:	8c 91       	ld	r24, X
    1354:	88 23       	and	r24, r24
    1356:	11 f0       	breq	.+4      	; 0x135c <xTaskGenericCreate+0x68>
    1358:	21 50       	subi	r18, 0x01	; 1
    135a:	a9 f7       	brne	.-22     	; 0x1346 <xTaskGenericCreate+0x52>
    135c:	18 a2       	std	Y+32, r1	; 0x20
    135e:	10 2f       	mov	r17, r16
    1360:	04 30       	cpi	r16, 0x04	; 4
    1362:	08 f0       	brcs	.+2      	; 0x1366 <xTaskGenericCreate+0x72>
    1364:	13 e0       	ldi	r17, 0x03	; 3
    1366:	1e 8b       	std	Y+22, r17	; 0x16
    1368:	19 a3       	std	Y+33, r17	; 0x21
    136a:	1a a2       	std	Y+34, r1	; 0x22
    136c:	5e 01       	movw	r10, r28
    136e:	b2 e0       	ldi	r27, 0x02	; 2
    1370:	ab 0e       	add	r10, r27
    1372:	b1 1c       	adc	r11, r1
    1374:	c5 01       	movw	r24, r10
    1376:	37 d8       	rcall	.-3986   	; 0x3e6 <vListInitialiseItem>
    1378:	ce 01       	movw	r24, r28
    137a:	0c 96       	adiw	r24, 0x0c	; 12
    137c:	34 d8       	rcall	.-3992   	; 0x3e6 <vListInitialiseItem>
    137e:	d9 87       	std	Y+9, r29	; 0x09
    1380:	c8 87       	std	Y+8, r28	; 0x08
    1382:	84 e0       	ldi	r24, 0x04	; 4
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	81 1b       	sub	r24, r17
    1388:	91 09       	sbc	r25, r1
    138a:	9d 87       	std	Y+13, r25	; 0x0d
    138c:	8c 87       	std	Y+12, r24	; 0x0c
    138e:	db 8b       	std	Y+19, r29	; 0x13
    1390:	ca 8b       	std	Y+18, r28	; 0x12
    1392:	a3 01       	movw	r20, r6
    1394:	b4 01       	movw	r22, r8
    1396:	c6 01       	movw	r24, r12
    1398:	df da       	rcall	.-2626   	; 0x958 <pxPortInitialiseStack>
    139a:	99 83       	std	Y+1, r25	; 0x01
    139c:	88 83       	st	Y, r24
    139e:	e1 14       	cp	r14, r1
    13a0:	f1 04       	cpc	r15, r1
    13a2:	19 f0       	breq	.+6      	; 0x13aa <xTaskGenericCreate+0xb6>
    13a4:	f7 01       	movw	r30, r14
    13a6:	d1 83       	std	Z+1, r29	; 0x01
    13a8:	c0 83       	st	Z, r28
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	0f 92       	push	r0
    13b0:	80 91 63 08 	lds	r24, 0x0863
    13b4:	8f 5f       	subi	r24, 0xFF	; 255
    13b6:	80 93 63 08 	sts	0x0863, r24
    13ba:	80 91 ba 08 	lds	r24, 0x08BA
    13be:	90 91 bb 08 	lds	r25, 0x08BB
    13c2:	89 2b       	or	r24, r25
    13c4:	d1 f5       	brne	.+116    	; 0x143a <xTaskGenericCreate+0x146>
    13c6:	d0 93 bb 08 	sts	0x08BB, r29
    13ca:	c0 93 ba 08 	sts	0x08BA, r28
    13ce:	80 91 63 08 	lds	r24, 0x0863
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	09 f0       	breq	.+2      	; 0x13d8 <xTaskGenericCreate+0xe4>
    13d6:	40 c0       	rjmp	.+128    	; 0x1458 <xTaskGenericCreate+0x164>
    13d8:	86 e9       	ldi	r24, 0x96	; 150
    13da:	98 e0       	ldi	r25, 0x08	; 8
    13dc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    13e0:	8f e9       	ldi	r24, 0x9F	; 159
    13e2:	98 e0       	ldi	r25, 0x08	; 8
    13e4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    13e8:	88 ea       	ldi	r24, 0xA8	; 168
    13ea:	98 e0       	ldi	r25, 0x08	; 8
    13ec:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    13f0:	81 eb       	ldi	r24, 0xB1	; 177
    13f2:	98 e0       	ldi	r25, 0x08	; 8
    13f4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    13f8:	8d e8       	ldi	r24, 0x8D	; 141
    13fa:	98 e0       	ldi	r25, 0x08	; 8
    13fc:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    1400:	84 e8       	ldi	r24, 0x84	; 132
    1402:	98 e0       	ldi	r25, 0x08	; 8
    1404:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    1408:	87 e7       	ldi	r24, 0x77	; 119
    140a:	98 e0       	ldi	r25, 0x08	; 8
    140c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    1410:	8e e6       	ldi	r24, 0x6E	; 110
    1412:	98 e0       	ldi	r25, 0x08	; 8
    1414:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    1418:	84 e6       	ldi	r24, 0x64	; 100
    141a:	98 e0       	ldi	r25, 0x08	; 8
    141c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <vListInitialise>
    1420:	8d e8       	ldi	r24, 0x8D	; 141
    1422:	98 e0       	ldi	r25, 0x08	; 8
    1424:	90 93 83 08 	sts	0x0883, r25
    1428:	80 93 82 08 	sts	0x0882, r24
    142c:	84 e8       	ldi	r24, 0x84	; 132
    142e:	98 e0       	ldi	r25, 0x08	; 8
    1430:	90 93 81 08 	sts	0x0881, r25
    1434:	80 93 80 08 	sts	0x0880, r24
    1438:	0f c0       	rjmp	.+30     	; 0x1458 <xTaskGenericCreate+0x164>
    143a:	80 91 5f 08 	lds	r24, 0x085F
    143e:	81 11       	cpse	r24, r1
    1440:	0b c0       	rjmp	.+22     	; 0x1458 <xTaskGenericCreate+0x164>
    1442:	e0 91 ba 08 	lds	r30, 0x08BA
    1446:	f0 91 bb 08 	lds	r31, 0x08BB
    144a:	86 89       	ldd	r24, Z+22	; 0x16
    144c:	08 17       	cp	r16, r24
    144e:	20 f0       	brcs	.+8      	; 0x1458 <xTaskGenericCreate+0x164>
    1450:	d0 93 bb 08 	sts	0x08BB, r29
    1454:	c0 93 ba 08 	sts	0x08BA, r28
    1458:	80 91 5b 08 	lds	r24, 0x085B
    145c:	8f 5f       	subi	r24, 0xFF	; 255
    145e:	80 93 5b 08 	sts	0x085B, r24
    1462:	8e 89       	ldd	r24, Y+22	; 0x16
    1464:	90 91 60 08 	lds	r25, 0x0860
    1468:	98 17       	cp	r25, r24
    146a:	10 f4       	brcc	.+4      	; 0x1470 <xTaskGenericCreate+0x17c>
    146c:	80 93 60 08 	sts	0x0860, r24
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	9c 01       	movw	r18, r24
    1474:	22 0f       	add	r18, r18
    1476:	33 1f       	adc	r19, r19
    1478:	22 0f       	add	r18, r18
    147a:	33 1f       	adc	r19, r19
    147c:	22 0f       	add	r18, r18
    147e:	33 1f       	adc	r19, r19
    1480:	82 0f       	add	r24, r18
    1482:	93 1f       	adc	r25, r19
    1484:	b5 01       	movw	r22, r10
    1486:	8a 56       	subi	r24, 0x6A	; 106
    1488:	97 4f       	sbci	r25, 0xF7	; 247
    148a:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    148e:	0f 90       	pop	r0
    1490:	0f be       	out	0x3f, r0	; 63
    1492:	80 91 5f 08 	lds	r24, 0x085F
    1496:	88 23       	and	r24, r24
    1498:	51 f0       	breq	.+20     	; 0x14ae <xTaskGenericCreate+0x1ba>
    149a:	e0 91 ba 08 	lds	r30, 0x08BA
    149e:	f0 91 bb 08 	lds	r31, 0x08BB
    14a2:	86 89       	ldd	r24, Z+22	; 0x16
    14a4:	80 17       	cp	r24, r16
    14a6:	28 f4       	brcc	.+10     	; 0x14b2 <xTaskGenericCreate+0x1be>
    14a8:	06 db       	rcall	.-2548   	; 0xab6 <vPortYield>
    14aa:	81 e0       	ldi	r24, 0x01	; 1
    14ac:	1c c0       	rjmp	.+56     	; 0x14e6 <xTaskGenericCreate+0x1f2>
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	1a c0       	rjmp	.+52     	; 0x14e6 <xTaskGenericCreate+0x1f2>
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	18 c0       	rjmp	.+48     	; 0x14e6 <xTaskGenericCreate+0x1f2>
    14b6:	d8 8e       	std	Y+24, r13	; 0x18
    14b8:	cf 8a       	std	Y+23, r12	; 0x17
    14ba:	f1 e0       	ldi	r31, 0x01	; 1
    14bc:	4f 1a       	sub	r4, r31
    14be:	51 08       	sbc	r5, r1
    14c0:	cf 88       	ldd	r12, Y+23	; 0x17
    14c2:	d8 8c       	ldd	r13, Y+24	; 0x18
    14c4:	c4 0c       	add	r12, r4
    14c6:	d5 1c       	adc	r13, r5
    14c8:	d5 01       	movw	r26, r10
    14ca:	8c 91       	ld	r24, X
    14cc:	89 8f       	std	Y+25, r24	; 0x19
    14ce:	8c 91       	ld	r24, X
    14d0:	88 23       	and	r24, r24
    14d2:	09 f4       	brne	.+2      	; 0x14d6 <xTaskGenericCreate+0x1e2>
    14d4:	43 cf       	rjmp	.-378    	; 0x135c <xTaskGenericCreate+0x68>
    14d6:	ae 01       	movw	r20, r28
    14d8:	46 5e       	subi	r20, 0xE6	; 230
    14da:	5f 4f       	sbci	r21, 0xFF	; 255
    14dc:	f5 01       	movw	r30, r10
    14de:	31 96       	adiw	r30, 0x01	; 1
    14e0:	27 e0       	ldi	r18, 0x07	; 7
    14e2:	31 cf       	rjmp	.-414    	; 0x1346 <xTaskGenericCreate+0x52>
    14e4:	8f ef       	ldi	r24, 0xFF	; 255
    14e6:	df 91       	pop	r29
    14e8:	cf 91       	pop	r28
    14ea:	1f 91       	pop	r17
    14ec:	0f 91       	pop	r16
    14ee:	ff 90       	pop	r15
    14f0:	ef 90       	pop	r14
    14f2:	df 90       	pop	r13
    14f4:	cf 90       	pop	r12
    14f6:	bf 90       	pop	r11
    14f8:	af 90       	pop	r10
    14fa:	9f 90       	pop	r9
    14fc:	8f 90       	pop	r8
    14fe:	7f 90       	pop	r7
    1500:	6f 90       	pop	r6
    1502:	5f 90       	pop	r5
    1504:	4f 90       	pop	r4
    1506:	08 95       	ret

00001508 <vTaskStartScheduler>:
    1508:	af 92       	push	r10
    150a:	bf 92       	push	r11
    150c:	cf 92       	push	r12
    150e:	df 92       	push	r13
    1510:	ef 92       	push	r14
    1512:	ff 92       	push	r15
    1514:	0f 93       	push	r16
    1516:	a1 2c       	mov	r10, r1
    1518:	b1 2c       	mov	r11, r1
    151a:	c1 2c       	mov	r12, r1
    151c:	d1 2c       	mov	r13, r1
    151e:	e1 2c       	mov	r14, r1
    1520:	f1 2c       	mov	r15, r1
    1522:	00 e0       	ldi	r16, 0x00	; 0
    1524:	20 e0       	ldi	r18, 0x00	; 0
    1526:	30 e0       	ldi	r19, 0x00	; 0
    1528:	45 e5       	ldi	r20, 0x55	; 85
    152a:	50 e0       	ldi	r21, 0x00	; 0
    152c:	65 e7       	ldi	r22, 0x75	; 117
    152e:	72 e0       	ldi	r23, 0x02	; 2
    1530:	8e e0       	ldi	r24, 0x0E	; 14
    1532:	9c e0       	ldi	r25, 0x0C	; 12
    1534:	df de       	rcall	.-578    	; 0x12f4 <xTaskGenericCreate>
    1536:	81 30       	cpi	r24, 0x01	; 1
    1538:	41 f4       	brne	.+16     	; 0x154a <vTaskStartScheduler+0x42>
    153a:	f8 94       	cli
    153c:	80 93 5f 08 	sts	0x085F, r24
    1540:	10 92 62 08 	sts	0x0862, r1
    1544:	10 92 61 08 	sts	0x0861, r1
    1548:	79 da       	rcall	.-2830   	; 0xa3c <xPortStartScheduler>
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	08 95       	ret

0000155a <vTaskSuspendAll>:
    155a:	80 91 5a 08 	lds	r24, 0x085A
    155e:	8f 5f       	subi	r24, 0xFF	; 255
    1560:	80 93 5a 08 	sts	0x085A, r24
    1564:	08 95       	ret

00001566 <xTaskIncrementTick>:
    1566:	cf 92       	push	r12
    1568:	df 92       	push	r13
    156a:	ef 92       	push	r14
    156c:	ff 92       	push	r15
    156e:	0f 93       	push	r16
    1570:	1f 93       	push	r17
    1572:	cf 93       	push	r28
    1574:	df 93       	push	r29
    1576:	80 91 5a 08 	lds	r24, 0x085A
    157a:	81 11       	cpse	r24, r1
    157c:	99 c0       	rjmp	.+306    	; 0x16b0 <xTaskIncrementTick+0x14a>
    157e:	80 91 61 08 	lds	r24, 0x0861
    1582:	90 91 62 08 	lds	r25, 0x0862
    1586:	01 96       	adiw	r24, 0x01	; 1
    1588:	90 93 62 08 	sts	0x0862, r25
    158c:	80 93 61 08 	sts	0x0861, r24
    1590:	e0 90 61 08 	lds	r14, 0x0861
    1594:	f0 90 62 08 	lds	r15, 0x0862
    1598:	e1 14       	cp	r14, r1
    159a:	f1 04       	cpc	r15, r1
    159c:	b1 f4       	brne	.+44     	; 0x15ca <xTaskIncrementTick+0x64>
    159e:	80 91 82 08 	lds	r24, 0x0882
    15a2:	90 91 83 08 	lds	r25, 0x0883
    15a6:	20 91 80 08 	lds	r18, 0x0880
    15aa:	30 91 81 08 	lds	r19, 0x0881
    15ae:	30 93 83 08 	sts	0x0883, r19
    15b2:	20 93 82 08 	sts	0x0882, r18
    15b6:	90 93 81 08 	sts	0x0881, r25
    15ba:	80 93 80 08 	sts	0x0880, r24
    15be:	80 91 5c 08 	lds	r24, 0x085C
    15c2:	8f 5f       	subi	r24, 0xFF	; 255
    15c4:	80 93 5c 08 	sts	0x085C, r24
    15c8:	41 de       	rcall	.-894    	; 0x124c <prvResetNextTaskUnblockTime>
    15ca:	80 91 00 02 	lds	r24, 0x0200
    15ce:	90 91 01 02 	lds	r25, 0x0201
    15d2:	e8 16       	cp	r14, r24
    15d4:	f9 06       	cpc	r15, r25
    15d6:	08 f4       	brcc	.+2      	; 0x15da <xTaskIncrementTick+0x74>
    15d8:	54 c0       	rjmp	.+168    	; 0x1682 <xTaskIncrementTick+0x11c>
    15da:	d1 2c       	mov	r13, r1
    15dc:	cc 24       	eor	r12, r12
    15de:	c3 94       	inc	r12
    15e0:	01 c0       	rjmp	.+2      	; 0x15e4 <xTaskIncrementTick+0x7e>
    15e2:	dc 2c       	mov	r13, r12
    15e4:	e0 91 82 08 	lds	r30, 0x0882
    15e8:	f0 91 83 08 	lds	r31, 0x0883
    15ec:	80 81       	ld	r24, Z
    15ee:	81 11       	cpse	r24, r1
    15f0:	07 c0       	rjmp	.+14     	; 0x1600 <xTaskIncrementTick+0x9a>
    15f2:	8f ef       	ldi	r24, 0xFF	; 255
    15f4:	9f ef       	ldi	r25, 0xFF	; 255
    15f6:	90 93 01 02 	sts	0x0201, r25
    15fa:	80 93 00 02 	sts	0x0200, r24
    15fe:	42 c0       	rjmp	.+132    	; 0x1684 <xTaskIncrementTick+0x11e>
    1600:	e0 91 82 08 	lds	r30, 0x0882
    1604:	f0 91 83 08 	lds	r31, 0x0883
    1608:	05 80       	ldd	r0, Z+5	; 0x05
    160a:	f6 81       	ldd	r31, Z+6	; 0x06
    160c:	e0 2d       	mov	r30, r0
    160e:	c6 81       	ldd	r28, Z+6	; 0x06
    1610:	d7 81       	ldd	r29, Z+7	; 0x07
    1612:	2a 81       	ldd	r18, Y+2	; 0x02
    1614:	3b 81       	ldd	r19, Y+3	; 0x03
    1616:	e2 16       	cp	r14, r18
    1618:	f3 06       	cpc	r15, r19
    161a:	28 f4       	brcc	.+10     	; 0x1626 <xTaskIncrementTick+0xc0>
    161c:	30 93 01 02 	sts	0x0201, r19
    1620:	20 93 00 02 	sts	0x0200, r18
    1624:	2f c0       	rjmp	.+94     	; 0x1684 <xTaskIncrementTick+0x11e>
    1626:	8e 01       	movw	r16, r28
    1628:	0e 5f       	subi	r16, 0xFE	; 254
    162a:	1f 4f       	sbci	r17, 0xFF	; 255
    162c:	c8 01       	movw	r24, r16
    162e:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1632:	8c 89       	ldd	r24, Y+20	; 0x14
    1634:	9d 89       	ldd	r25, Y+21	; 0x15
    1636:	89 2b       	or	r24, r25
    1638:	21 f0       	breq	.+8      	; 0x1642 <xTaskIncrementTick+0xdc>
    163a:	ce 01       	movw	r24, r28
    163c:	0c 96       	adiw	r24, 0x0c	; 12
    163e:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1642:	2e 89       	ldd	r18, Y+22	; 0x16
    1644:	80 91 60 08 	lds	r24, 0x0860
    1648:	82 17       	cp	r24, r18
    164a:	10 f4       	brcc	.+4      	; 0x1650 <xTaskIncrementTick+0xea>
    164c:	20 93 60 08 	sts	0x0860, r18
    1650:	30 e0       	ldi	r19, 0x00	; 0
    1652:	c9 01       	movw	r24, r18
    1654:	88 0f       	add	r24, r24
    1656:	99 1f       	adc	r25, r25
    1658:	88 0f       	add	r24, r24
    165a:	99 1f       	adc	r25, r25
    165c:	88 0f       	add	r24, r24
    165e:	99 1f       	adc	r25, r25
    1660:	82 0f       	add	r24, r18
    1662:	93 1f       	adc	r25, r19
    1664:	b8 01       	movw	r22, r16
    1666:	8a 56       	subi	r24, 0x6A	; 106
    1668:	97 4f       	sbci	r25, 0xF7	; 247
    166a:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    166e:	e0 91 ba 08 	lds	r30, 0x08BA
    1672:	f0 91 bb 08 	lds	r31, 0x08BB
    1676:	9e 89       	ldd	r25, Y+22	; 0x16
    1678:	86 89       	ldd	r24, Z+22	; 0x16
    167a:	98 17       	cp	r25, r24
    167c:	08 f0       	brcs	.+2      	; 0x1680 <xTaskIncrementTick+0x11a>
    167e:	b1 cf       	rjmp	.-158    	; 0x15e2 <xTaskIncrementTick+0x7c>
    1680:	b1 cf       	rjmp	.-158    	; 0x15e4 <xTaskIncrementTick+0x7e>
    1682:	d1 2c       	mov	r13, r1
    1684:	e0 91 ba 08 	lds	r30, 0x08BA
    1688:	f0 91 bb 08 	lds	r31, 0x08BB
    168c:	86 89       	ldd	r24, Z+22	; 0x16
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	fc 01       	movw	r30, r24
    1692:	ee 0f       	add	r30, r30
    1694:	ff 1f       	adc	r31, r31
    1696:	ee 0f       	add	r30, r30
    1698:	ff 1f       	adc	r31, r31
    169a:	ee 0f       	add	r30, r30
    169c:	ff 1f       	adc	r31, r31
    169e:	8e 0f       	add	r24, r30
    16a0:	9f 1f       	adc	r25, r31
    16a2:	fc 01       	movw	r30, r24
    16a4:	ea 56       	subi	r30, 0x6A	; 106
    16a6:	f7 4f       	sbci	r31, 0xF7	; 247
    16a8:	80 81       	ld	r24, Z
    16aa:	82 30       	cpi	r24, 0x02	; 2
    16ac:	40 f4       	brcc	.+16     	; 0x16be <xTaskIncrementTick+0x158>
    16ae:	09 c0       	rjmp	.+18     	; 0x16c2 <xTaskIncrementTick+0x15c>
    16b0:	80 91 5e 08 	lds	r24, 0x085E
    16b4:	8f 5f       	subi	r24, 0xFF	; 255
    16b6:	80 93 5e 08 	sts	0x085E, r24
    16ba:	d1 2c       	mov	r13, r1
    16bc:	02 c0       	rjmp	.+4      	; 0x16c2 <xTaskIncrementTick+0x15c>
    16be:	dd 24       	eor	r13, r13
    16c0:	d3 94       	inc	r13
    16c2:	80 91 5d 08 	lds	r24, 0x085D
    16c6:	88 23       	and	r24, r24
    16c8:	11 f0       	breq	.+4      	; 0x16ce <xTaskIncrementTick+0x168>
    16ca:	dd 24       	eor	r13, r13
    16cc:	d3 94       	inc	r13
    16ce:	8d 2d       	mov	r24, r13
    16d0:	df 91       	pop	r29
    16d2:	cf 91       	pop	r28
    16d4:	1f 91       	pop	r17
    16d6:	0f 91       	pop	r16
    16d8:	ff 90       	pop	r15
    16da:	ef 90       	pop	r14
    16dc:	df 90       	pop	r13
    16de:	cf 90       	pop	r12
    16e0:	08 95       	ret

000016e2 <xTaskResumeAll>:
    16e2:	df 92       	push	r13
    16e4:	ef 92       	push	r14
    16e6:	ff 92       	push	r15
    16e8:	0f 93       	push	r16
    16ea:	1f 93       	push	r17
    16ec:	cf 93       	push	r28
    16ee:	df 93       	push	r29
    16f0:	0f b6       	in	r0, 0x3f	; 63
    16f2:	f8 94       	cli
    16f4:	0f 92       	push	r0
    16f6:	80 91 5a 08 	lds	r24, 0x085A
    16fa:	81 50       	subi	r24, 0x01	; 1
    16fc:	80 93 5a 08 	sts	0x085A, r24
    1700:	80 91 5a 08 	lds	r24, 0x085A
    1704:	81 11       	cpse	r24, r1
    1706:	5f c0       	rjmp	.+190    	; 0x17c6 <xTaskResumeAll+0xe4>
    1708:	80 91 63 08 	lds	r24, 0x0863
    170c:	88 23       	and	r24, r24
    170e:	09 f4       	brne	.+2      	; 0x1712 <xTaskResumeAll+0x30>
    1710:	5c c0       	rjmp	.+184    	; 0x17ca <xTaskResumeAll+0xe8>
    1712:	0f 2e       	mov	r0, r31
    1714:	f7 e7       	ldi	r31, 0x77	; 119
    1716:	ef 2e       	mov	r14, r31
    1718:	f8 e0       	ldi	r31, 0x08	; 8
    171a:	ff 2e       	mov	r15, r31
    171c:	f0 2d       	mov	r31, r0
    171e:	dd 24       	eor	r13, r13
    1720:	d3 94       	inc	r13
    1722:	30 c0       	rjmp	.+96     	; 0x1784 <xTaskResumeAll+0xa2>
    1724:	e0 91 7c 08 	lds	r30, 0x087C
    1728:	f0 91 7d 08 	lds	r31, 0x087D
    172c:	c6 81       	ldd	r28, Z+6	; 0x06
    172e:	d7 81       	ldd	r29, Z+7	; 0x07
    1730:	ce 01       	movw	r24, r28
    1732:	0c 96       	adiw	r24, 0x0c	; 12
    1734:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1738:	8e 01       	movw	r16, r28
    173a:	0e 5f       	subi	r16, 0xFE	; 254
    173c:	1f 4f       	sbci	r17, 0xFF	; 255
    173e:	c8 01       	movw	r24, r16
    1740:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1744:	8e 89       	ldd	r24, Y+22	; 0x16
    1746:	90 91 60 08 	lds	r25, 0x0860
    174a:	98 17       	cp	r25, r24
    174c:	10 f4       	brcc	.+4      	; 0x1752 <xTaskResumeAll+0x70>
    174e:	80 93 60 08 	sts	0x0860, r24
    1752:	90 e0       	ldi	r25, 0x00	; 0
    1754:	9c 01       	movw	r18, r24
    1756:	22 0f       	add	r18, r18
    1758:	33 1f       	adc	r19, r19
    175a:	22 0f       	add	r18, r18
    175c:	33 1f       	adc	r19, r19
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	82 0f       	add	r24, r18
    1764:	93 1f       	adc	r25, r19
    1766:	b8 01       	movw	r22, r16
    1768:	8a 56       	subi	r24, 0x6A	; 106
    176a:	97 4f       	sbci	r25, 0xF7	; 247
    176c:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    1770:	e0 91 ba 08 	lds	r30, 0x08BA
    1774:	f0 91 bb 08 	lds	r31, 0x08BB
    1778:	9e 89       	ldd	r25, Y+22	; 0x16
    177a:	86 89       	ldd	r24, Z+22	; 0x16
    177c:	98 17       	cp	r25, r24
    177e:	10 f0       	brcs	.+4      	; 0x1784 <xTaskResumeAll+0xa2>
    1780:	d0 92 5d 08 	sts	0x085D, r13
    1784:	f7 01       	movw	r30, r14
    1786:	80 81       	ld	r24, Z
    1788:	81 11       	cpse	r24, r1
    178a:	cc cf       	rjmp	.-104    	; 0x1724 <xTaskResumeAll+0x42>
    178c:	80 91 5e 08 	lds	r24, 0x085E
    1790:	88 23       	and	r24, r24
    1792:	91 f0       	breq	.+36     	; 0x17b8 <xTaskResumeAll+0xd6>
    1794:	80 91 5e 08 	lds	r24, 0x085E
    1798:	88 23       	and	r24, r24
    179a:	71 f0       	breq	.+28     	; 0x17b8 <xTaskResumeAll+0xd6>
    179c:	c1 e0       	ldi	r28, 0x01	; 1
    179e:	e3 de       	rcall	.-570    	; 0x1566 <xTaskIncrementTick>
    17a0:	81 11       	cpse	r24, r1
    17a2:	c0 93 5d 08 	sts	0x085D, r28
    17a6:	80 91 5e 08 	lds	r24, 0x085E
    17aa:	81 50       	subi	r24, 0x01	; 1
    17ac:	80 93 5e 08 	sts	0x085E, r24
    17b0:	80 91 5e 08 	lds	r24, 0x085E
    17b4:	81 11       	cpse	r24, r1
    17b6:	f3 cf       	rjmp	.-26     	; 0x179e <xTaskResumeAll+0xbc>
    17b8:	80 91 5d 08 	lds	r24, 0x085D
    17bc:	81 30       	cpi	r24, 0x01	; 1
    17be:	39 f4       	brne	.+14     	; 0x17ce <xTaskResumeAll+0xec>
    17c0:	7a d9       	rcall	.-3340   	; 0xab6 <vPortYield>
    17c2:	81 e0       	ldi	r24, 0x01	; 1
    17c4:	05 c0       	rjmp	.+10     	; 0x17d0 <xTaskResumeAll+0xee>
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	03 c0       	rjmp	.+6      	; 0x17d0 <xTaskResumeAll+0xee>
    17ca:	80 e0       	ldi	r24, 0x00	; 0
    17cc:	01 c0       	rjmp	.+2      	; 0x17d0 <xTaskResumeAll+0xee>
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	08 95       	ret

000017e4 <vTaskDelay>:
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
    17e8:	ec 01       	movw	r28, r24
    17ea:	00 97       	sbiw	r24, 0x00	; 0
    17ec:	99 f0       	breq	.+38     	; 0x1814 <vTaskDelay+0x30>
    17ee:	b5 de       	rcall	.-662    	; 0x155a <vTaskSuspendAll>
    17f0:	80 91 61 08 	lds	r24, 0x0861
    17f4:	90 91 62 08 	lds	r25, 0x0862
    17f8:	c8 0f       	add	r28, r24
    17fa:	d9 1f       	adc	r29, r25
    17fc:	80 91 ba 08 	lds	r24, 0x08BA
    1800:	90 91 bb 08 	lds	r25, 0x08BB
    1804:	02 96       	adiw	r24, 0x02	; 2
    1806:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    180a:	ce 01       	movw	r24, r28
    180c:	3e dd       	rcall	.-1412   	; 0x128a <prvAddCurrentTaskToDelayedList>
    180e:	69 df       	rcall	.-302    	; 0x16e2 <xTaskResumeAll>
    1810:	81 11       	cpse	r24, r1
    1812:	01 c0       	rjmp	.+2      	; 0x1816 <vTaskDelay+0x32>
    1814:	50 d9       	rcall	.-3424   	; 0xab6 <vPortYield>
    1816:	df 91       	pop	r29
    1818:	cf 91       	pop	r28
    181a:	08 95       	ret

0000181c <prvIdleTask>:
    181c:	0f 2e       	mov	r0, r31
    181e:	f6 e9       	ldi	r31, 0x96	; 150
    1820:	ef 2e       	mov	r14, r31
    1822:	f8 e0       	ldi	r31, 0x08	; 8
    1824:	ff 2e       	mov	r15, r31
    1826:	f0 2d       	mov	r31, r0
    1828:	ce e6       	ldi	r28, 0x6E	; 110
    182a:	d8 e0       	ldi	r29, 0x08	; 8
    182c:	26 c0       	rjmp	.+76     	; 0x187a <prvIdleTask+0x5e>
    182e:	95 de       	rcall	.-726    	; 0x155a <vTaskSuspendAll>
    1830:	18 81       	ld	r17, Y
    1832:	57 df       	rcall	.-338    	; 0x16e2 <xTaskResumeAll>
    1834:	11 23       	and	r17, r17
    1836:	09 f1       	breq	.+66     	; 0x187a <prvIdleTask+0x5e>
    1838:	0f b6       	in	r0, 0x3f	; 63
    183a:	f8 94       	cli
    183c:	0f 92       	push	r0
    183e:	e0 91 73 08 	lds	r30, 0x0873
    1842:	f0 91 74 08 	lds	r31, 0x0874
    1846:	06 81       	ldd	r16, Z+6	; 0x06
    1848:	17 81       	ldd	r17, Z+7	; 0x07
    184a:	c8 01       	movw	r24, r16
    184c:	02 96       	adiw	r24, 0x02	; 2
    184e:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1852:	80 91 63 08 	lds	r24, 0x0863
    1856:	81 50       	subi	r24, 0x01	; 1
    1858:	80 93 63 08 	sts	0x0863, r24
    185c:	80 91 6d 08 	lds	r24, 0x086D
    1860:	81 50       	subi	r24, 0x01	; 1
    1862:	80 93 6d 08 	sts	0x086D, r24
    1866:	0f 90       	pop	r0
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	f8 01       	movw	r30, r16
    186c:	87 89       	ldd	r24, Z+23	; 0x17
    186e:	90 8d       	ldd	r25, Z+24	; 0x18
    1870:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <vPortFree>
    1874:	c8 01       	movw	r24, r16
    1876:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <vPortFree>
    187a:	80 91 6d 08 	lds	r24, 0x086D
    187e:	81 11       	cpse	r24, r1
    1880:	d6 cf       	rjmp	.-84     	; 0x182e <prvIdleTask+0x12>
    1882:	f7 01       	movw	r30, r14
    1884:	80 81       	ld	r24, Z
    1886:	82 30       	cpi	r24, 0x02	; 2
    1888:	c0 f3       	brcs	.-16     	; 0x187a <prvIdleTask+0x5e>
    188a:	15 d9       	rcall	.-3542   	; 0xab6 <vPortYield>
    188c:	f6 cf       	rjmp	.-20     	; 0x187a <prvIdleTask+0x5e>

0000188e <vTaskSwitchContext>:
    188e:	80 91 5a 08 	lds	r24, 0x085A
    1892:	88 23       	and	r24, r24
    1894:	21 f0       	breq	.+8      	; 0x189e <vTaskSwitchContext+0x10>
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	80 93 5d 08 	sts	0x085D, r24
    189c:	08 95       	ret
    189e:	10 92 5d 08 	sts	0x085D, r1
    18a2:	80 91 60 08 	lds	r24, 0x0860
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	fc 01       	movw	r30, r24
    18aa:	ee 0f       	add	r30, r30
    18ac:	ff 1f       	adc	r31, r31
    18ae:	ee 0f       	add	r30, r30
    18b0:	ff 1f       	adc	r31, r31
    18b2:	ee 0f       	add	r30, r30
    18b4:	ff 1f       	adc	r31, r31
    18b6:	8e 0f       	add	r24, r30
    18b8:	9f 1f       	adc	r25, r31
    18ba:	fc 01       	movw	r30, r24
    18bc:	ea 56       	subi	r30, 0x6A	; 106
    18be:	f7 4f       	sbci	r31, 0xF7	; 247
    18c0:	80 81       	ld	r24, Z
    18c2:	81 11       	cpse	r24, r1
    18c4:	17 c0       	rjmp	.+46     	; 0x18f4 <vTaskSwitchContext+0x66>
    18c6:	80 91 60 08 	lds	r24, 0x0860
    18ca:	81 50       	subi	r24, 0x01	; 1
    18cc:	80 93 60 08 	sts	0x0860, r24
    18d0:	80 91 60 08 	lds	r24, 0x0860
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	fc 01       	movw	r30, r24
    18d8:	ee 0f       	add	r30, r30
    18da:	ff 1f       	adc	r31, r31
    18dc:	ee 0f       	add	r30, r30
    18de:	ff 1f       	adc	r31, r31
    18e0:	ee 0f       	add	r30, r30
    18e2:	ff 1f       	adc	r31, r31
    18e4:	8e 0f       	add	r24, r30
    18e6:	9f 1f       	adc	r25, r31
    18e8:	fc 01       	movw	r30, r24
    18ea:	ea 56       	subi	r30, 0x6A	; 106
    18ec:	f7 4f       	sbci	r31, 0xF7	; 247
    18ee:	80 81       	ld	r24, Z
    18f0:	88 23       	and	r24, r24
    18f2:	49 f3       	breq	.-46     	; 0x18c6 <vTaskSwitchContext+0x38>
    18f4:	e0 91 60 08 	lds	r30, 0x0860
    18f8:	f0 e0       	ldi	r31, 0x00	; 0
    18fa:	cf 01       	movw	r24, r30
    18fc:	88 0f       	add	r24, r24
    18fe:	99 1f       	adc	r25, r25
    1900:	88 0f       	add	r24, r24
    1902:	99 1f       	adc	r25, r25
    1904:	88 0f       	add	r24, r24
    1906:	99 1f       	adc	r25, r25
    1908:	e8 0f       	add	r30, r24
    190a:	f9 1f       	adc	r31, r25
    190c:	ea 56       	subi	r30, 0x6A	; 106
    190e:	f7 4f       	sbci	r31, 0xF7	; 247
    1910:	a1 81       	ldd	r26, Z+1	; 0x01
    1912:	b2 81       	ldd	r27, Z+2	; 0x02
    1914:	12 96       	adiw	r26, 0x02	; 2
    1916:	0d 90       	ld	r0, X+
    1918:	bc 91       	ld	r27, X
    191a:	a0 2d       	mov	r26, r0
    191c:	b2 83       	std	Z+2, r27	; 0x02
    191e:	a1 83       	std	Z+1, r26	; 0x01
    1920:	cf 01       	movw	r24, r30
    1922:	03 96       	adiw	r24, 0x03	; 3
    1924:	a8 17       	cp	r26, r24
    1926:	b9 07       	cpc	r27, r25
    1928:	31 f4       	brne	.+12     	; 0x1936 <vTaskSwitchContext+0xa8>
    192a:	12 96       	adiw	r26, 0x02	; 2
    192c:	8d 91       	ld	r24, X+
    192e:	9c 91       	ld	r25, X
    1930:	13 97       	sbiw	r26, 0x03	; 3
    1932:	92 83       	std	Z+2, r25	; 0x02
    1934:	81 83       	std	Z+1, r24	; 0x01
    1936:	01 80       	ldd	r0, Z+1	; 0x01
    1938:	f2 81       	ldd	r31, Z+2	; 0x02
    193a:	e0 2d       	mov	r30, r0
    193c:	86 81       	ldd	r24, Z+6	; 0x06
    193e:	97 81       	ldd	r25, Z+7	; 0x07
    1940:	90 93 bb 08 	sts	0x08BB, r25
    1944:	80 93 ba 08 	sts	0x08BA, r24
    1948:	08 95       	ret

0000194a <vTaskPlaceOnEventList>:
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	eb 01       	movw	r28, r22
    1950:	60 91 ba 08 	lds	r22, 0x08BA
    1954:	70 91 bb 08 	lds	r23, 0x08BB
    1958:	64 5f       	subi	r22, 0xF4	; 244
    195a:	7f 4f       	sbci	r23, 0xFF	; 255
    195c:	0e 94 18 02 	call	0x430	; 0x430 <vListInsert>
    1960:	80 91 ba 08 	lds	r24, 0x08BA
    1964:	90 91 bb 08 	lds	r25, 0x08BB
    1968:	02 96       	adiw	r24, 0x02	; 2
    196a:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    196e:	cf 3f       	cpi	r28, 0xFF	; 255
    1970:	8f ef       	ldi	r24, 0xFF	; 255
    1972:	d8 07       	cpc	r29, r24
    1974:	59 f4       	brne	.+22     	; 0x198c <vTaskPlaceOnEventList+0x42>
    1976:	60 91 ba 08 	lds	r22, 0x08BA
    197a:	70 91 bb 08 	lds	r23, 0x08BB
    197e:	6e 5f       	subi	r22, 0xFE	; 254
    1980:	7f 4f       	sbci	r23, 0xFF	; 255
    1982:	84 e6       	ldi	r24, 0x64	; 100
    1984:	98 e0       	ldi	r25, 0x08	; 8
    1986:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    198a:	07 c0       	rjmp	.+14     	; 0x199a <vTaskPlaceOnEventList+0x50>
    198c:	80 91 61 08 	lds	r24, 0x0861
    1990:	90 91 62 08 	lds	r25, 0x0862
    1994:	8c 0f       	add	r24, r28
    1996:	9d 1f       	adc	r25, r29
    1998:	78 dc       	rcall	.-1808   	; 0x128a <prvAddCurrentTaskToDelayedList>
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	08 95       	ret

000019a0 <xTaskRemoveFromEventList>:
    19a0:	0f 93       	push	r16
    19a2:	1f 93       	push	r17
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	dc 01       	movw	r26, r24
    19aa:	15 96       	adiw	r26, 0x05	; 5
    19ac:	ed 91       	ld	r30, X+
    19ae:	fc 91       	ld	r31, X
    19b0:	16 97       	sbiw	r26, 0x06	; 6
    19b2:	c6 81       	ldd	r28, Z+6	; 0x06
    19b4:	d7 81       	ldd	r29, Z+7	; 0x07
    19b6:	8e 01       	movw	r16, r28
    19b8:	04 5f       	subi	r16, 0xF4	; 244
    19ba:	1f 4f       	sbci	r17, 0xFF	; 255
    19bc:	c8 01       	movw	r24, r16
    19be:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    19c2:	80 91 5a 08 	lds	r24, 0x085A
    19c6:	81 11       	cpse	r24, r1
    19c8:	1c c0       	rjmp	.+56     	; 0x1a02 <xTaskRemoveFromEventList+0x62>
    19ca:	0a 50       	subi	r16, 0x0A	; 10
    19cc:	11 09       	sbc	r17, r1
    19ce:	c8 01       	movw	r24, r16
    19d0:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    19d4:	8e 89       	ldd	r24, Y+22	; 0x16
    19d6:	90 91 60 08 	lds	r25, 0x0860
    19da:	98 17       	cp	r25, r24
    19dc:	10 f4       	brcc	.+4      	; 0x19e2 <xTaskRemoveFromEventList+0x42>
    19de:	80 93 60 08 	sts	0x0860, r24
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	9c 01       	movw	r18, r24
    19e6:	22 0f       	add	r18, r18
    19e8:	33 1f       	adc	r19, r19
    19ea:	22 0f       	add	r18, r18
    19ec:	33 1f       	adc	r19, r19
    19ee:	22 0f       	add	r18, r18
    19f0:	33 1f       	adc	r19, r19
    19f2:	82 0f       	add	r24, r18
    19f4:	93 1f       	adc	r25, r19
    19f6:	b8 01       	movw	r22, r16
    19f8:	8a 56       	subi	r24, 0x6A	; 106
    19fa:	97 4f       	sbci	r25, 0xF7	; 247
    19fc:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    1a00:	05 c0       	rjmp	.+10     	; 0x1a0c <xTaskRemoveFromEventList+0x6c>
    1a02:	b8 01       	movw	r22, r16
    1a04:	87 e7       	ldi	r24, 0x77	; 119
    1a06:	98 e0       	ldi	r25, 0x08	; 8
    1a08:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    1a0c:	e0 91 ba 08 	lds	r30, 0x08BA
    1a10:	f0 91 bb 08 	lds	r31, 0x08BB
    1a14:	9e 89       	ldd	r25, Y+22	; 0x16
    1a16:	86 89       	ldd	r24, Z+22	; 0x16
    1a18:	89 17       	cp	r24, r25
    1a1a:	20 f4       	brcc	.+8      	; 0x1a24 <xTaskRemoveFromEventList+0x84>
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	80 93 5d 08 	sts	0x085D, r24
    1a22:	01 c0       	rjmp	.+2      	; 0x1a26 <xTaskRemoveFromEventList+0x86>
    1a24:	80 e0       	ldi	r24, 0x00	; 0
    1a26:	df 91       	pop	r29
    1a28:	cf 91       	pop	r28
    1a2a:	1f 91       	pop	r17
    1a2c:	0f 91       	pop	r16
    1a2e:	08 95       	ret

00001a30 <vTaskSetTimeOutState>:
    1a30:	20 91 5c 08 	lds	r18, 0x085C
    1a34:	fc 01       	movw	r30, r24
    1a36:	20 83       	st	Z, r18
    1a38:	20 91 61 08 	lds	r18, 0x0861
    1a3c:	30 91 62 08 	lds	r19, 0x0862
    1a40:	32 83       	std	Z+2, r19	; 0x02
    1a42:	21 83       	std	Z+1, r18	; 0x01
    1a44:	08 95       	ret

00001a46 <xTaskCheckForTimeOut>:
    1a46:	0f b6       	in	r0, 0x3f	; 63
    1a48:	f8 94       	cli
    1a4a:	0f 92       	push	r0
    1a4c:	40 91 61 08 	lds	r20, 0x0861
    1a50:	50 91 62 08 	lds	r21, 0x0862
    1a54:	db 01       	movw	r26, r22
    1a56:	2d 91       	ld	r18, X+
    1a58:	3c 91       	ld	r19, X
    1a5a:	2f 3f       	cpi	r18, 0xFF	; 255
    1a5c:	bf ef       	ldi	r27, 0xFF	; 255
    1a5e:	3b 07       	cpc	r19, r27
    1a60:	11 f1       	breq	.+68     	; 0x1aa6 <xTaskCheckForTimeOut+0x60>
    1a62:	e0 91 5c 08 	lds	r30, 0x085C
    1a66:	dc 01       	movw	r26, r24
    1a68:	fc 91       	ld	r31, X
    1a6a:	fe 17       	cp	r31, r30
    1a6c:	39 f0       	breq	.+14     	; 0x1a7c <xTaskCheckForTimeOut+0x36>
    1a6e:	11 96       	adiw	r26, 0x01	; 1
    1a70:	ed 91       	ld	r30, X+
    1a72:	fc 91       	ld	r31, X
    1a74:	12 97       	sbiw	r26, 0x02	; 2
    1a76:	4e 17       	cp	r20, r30
    1a78:	5f 07       	cpc	r21, r31
    1a7a:	b8 f4       	brcc	.+46     	; 0x1aaa <xTaskCheckForTimeOut+0x64>
    1a7c:	dc 01       	movw	r26, r24
    1a7e:	11 96       	adiw	r26, 0x01	; 1
    1a80:	ed 91       	ld	r30, X+
    1a82:	fc 91       	ld	r31, X
    1a84:	12 97       	sbiw	r26, 0x02	; 2
    1a86:	da 01       	movw	r26, r20
    1a88:	ae 1b       	sub	r26, r30
    1a8a:	bf 0b       	sbc	r27, r31
    1a8c:	a2 17       	cp	r26, r18
    1a8e:	b3 07       	cpc	r27, r19
    1a90:	70 f4       	brcc	.+28     	; 0x1aae <xTaskCheckForTimeOut+0x68>
    1a92:	e4 1b       	sub	r30, r20
    1a94:	f5 0b       	sbc	r31, r21
    1a96:	2e 0f       	add	r18, r30
    1a98:	3f 1f       	adc	r19, r31
    1a9a:	fb 01       	movw	r30, r22
    1a9c:	31 83       	std	Z+1, r19	; 0x01
    1a9e:	20 83       	st	Z, r18
    1aa0:	c7 df       	rcall	.-114    	; 0x1a30 <vTaskSetTimeOutState>
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
    1aa4:	05 c0       	rjmp	.+10     	; 0x1ab0 <xTaskCheckForTimeOut+0x6a>
    1aa6:	80 e0       	ldi	r24, 0x00	; 0
    1aa8:	03 c0       	rjmp	.+6      	; 0x1ab0 <xTaskCheckForTimeOut+0x6a>
    1aaa:	81 e0       	ldi	r24, 0x01	; 1
    1aac:	01 c0       	rjmp	.+2      	; 0x1ab0 <xTaskCheckForTimeOut+0x6a>
    1aae:	81 e0       	ldi	r24, 0x01	; 1
    1ab0:	0f 90       	pop	r0
    1ab2:	0f be       	out	0x3f, r0	; 63
    1ab4:	08 95       	ret

00001ab6 <vTaskMissedYield>:
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
    1ab8:	80 93 5d 08 	sts	0x085D, r24
    1abc:	08 95       	ret

00001abe <vTaskPriorityInherit>:
    1abe:	0f 93       	push	r16
    1ac0:	1f 93       	push	r17
    1ac2:	cf 93       	push	r28
    1ac4:	df 93       	push	r29
    1ac6:	ec 01       	movw	r28, r24
    1ac8:	00 97       	sbiw	r24, 0x00	; 0
    1aca:	09 f4       	brne	.+2      	; 0x1ace <vTaskPriorityInherit+0x10>
    1acc:	51 c0       	rjmp	.+162    	; 0x1b70 <vTaskPriorityInherit+0xb2>
    1ace:	8e 89       	ldd	r24, Y+22	; 0x16
    1ad0:	e0 91 ba 08 	lds	r30, 0x08BA
    1ad4:	f0 91 bb 08 	lds	r31, 0x08BB
    1ad8:	96 89       	ldd	r25, Z+22	; 0x16
    1ada:	89 17       	cp	r24, r25
    1adc:	08 f0       	brcs	.+2      	; 0x1ae0 <vTaskPriorityInherit+0x22>
    1ade:	48 c0       	rjmp	.+144    	; 0x1b70 <vTaskPriorityInherit+0xb2>
    1ae0:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ae2:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ae4:	33 23       	and	r19, r19
    1ae6:	5c f0       	brlt	.+22     	; 0x1afe <vTaskPriorityInherit+0x40>
    1ae8:	e0 91 ba 08 	lds	r30, 0x08BA
    1aec:	f0 91 bb 08 	lds	r31, 0x08BB
    1af0:	96 89       	ldd	r25, Z+22	; 0x16
    1af2:	24 e0       	ldi	r18, 0x04	; 4
    1af4:	30 e0       	ldi	r19, 0x00	; 0
    1af6:	29 1b       	sub	r18, r25
    1af8:	31 09       	sbc	r19, r1
    1afa:	3d 87       	std	Y+13, r19	; 0x0d
    1afc:	2c 87       	std	Y+12, r18	; 0x0c
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	9c 01       	movw	r18, r24
    1b02:	22 0f       	add	r18, r18
    1b04:	33 1f       	adc	r19, r19
    1b06:	22 0f       	add	r18, r18
    1b08:	33 1f       	adc	r19, r19
    1b0a:	22 0f       	add	r18, r18
    1b0c:	33 1f       	adc	r19, r19
    1b0e:	82 0f       	add	r24, r18
    1b10:	93 1f       	adc	r25, r19
    1b12:	8a 56       	subi	r24, 0x6A	; 106
    1b14:	97 4f       	sbci	r25, 0xF7	; 247
    1b16:	2a 85       	ldd	r18, Y+10	; 0x0a
    1b18:	3b 85       	ldd	r19, Y+11	; 0x0b
    1b1a:	28 17       	cp	r18, r24
    1b1c:	39 07       	cpc	r19, r25
    1b1e:	11 f5       	brne	.+68     	; 0x1b64 <vTaskPriorityInherit+0xa6>
    1b20:	8e 01       	movw	r16, r28
    1b22:	0e 5f       	subi	r16, 0xFE	; 254
    1b24:	1f 4f       	sbci	r17, 0xFF	; 255
    1b26:	c8 01       	movw	r24, r16
    1b28:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1b2c:	e0 91 ba 08 	lds	r30, 0x08BA
    1b30:	f0 91 bb 08 	lds	r31, 0x08BB
    1b34:	86 89       	ldd	r24, Z+22	; 0x16
    1b36:	8e 8b       	std	Y+22, r24	; 0x16
    1b38:	90 91 60 08 	lds	r25, 0x0860
    1b3c:	98 17       	cp	r25, r24
    1b3e:	10 f4       	brcc	.+4      	; 0x1b44 <vTaskPriorityInherit+0x86>
    1b40:	80 93 60 08 	sts	0x0860, r24
    1b44:	90 e0       	ldi	r25, 0x00	; 0
    1b46:	9c 01       	movw	r18, r24
    1b48:	22 0f       	add	r18, r18
    1b4a:	33 1f       	adc	r19, r19
    1b4c:	22 0f       	add	r18, r18
    1b4e:	33 1f       	adc	r19, r19
    1b50:	22 0f       	add	r18, r18
    1b52:	33 1f       	adc	r19, r19
    1b54:	82 0f       	add	r24, r18
    1b56:	93 1f       	adc	r25, r19
    1b58:	b8 01       	movw	r22, r16
    1b5a:	8a 56       	subi	r24, 0x6A	; 106
    1b5c:	97 4f       	sbci	r25, 0xF7	; 247
    1b5e:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    1b62:	06 c0       	rjmp	.+12     	; 0x1b70 <vTaskPriorityInherit+0xb2>
    1b64:	e0 91 ba 08 	lds	r30, 0x08BA
    1b68:	f0 91 bb 08 	lds	r31, 0x08BB
    1b6c:	86 89       	ldd	r24, Z+22	; 0x16
    1b6e:	8e 8b       	std	Y+22, r24	; 0x16
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	1f 91       	pop	r17
    1b76:	0f 91       	pop	r16
    1b78:	08 95       	ret

00001b7a <xTaskPriorityDisinherit>:
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	cf 93       	push	r28
    1b80:	df 93       	push	r29
    1b82:	ec 01       	movw	r28, r24
    1b84:	00 97       	sbiw	r24, 0x00	; 0
    1b86:	71 f1       	breq	.+92     	; 0x1be4 <xTaskPriorityDisinherit+0x6a>
    1b88:	8a a1       	ldd	r24, Y+34	; 0x22
    1b8a:	81 50       	subi	r24, 0x01	; 1
    1b8c:	8a a3       	std	Y+34, r24	; 0x22
    1b8e:	2e 89       	ldd	r18, Y+22	; 0x16
    1b90:	99 a1       	ldd	r25, Y+33	; 0x21
    1b92:	29 17       	cp	r18, r25
    1b94:	49 f1       	breq	.+82     	; 0x1be8 <xTaskPriorityDisinherit+0x6e>
    1b96:	81 11       	cpse	r24, r1
    1b98:	29 c0       	rjmp	.+82     	; 0x1bec <xTaskPriorityDisinherit+0x72>
    1b9a:	8e 01       	movw	r16, r28
    1b9c:	0e 5f       	subi	r16, 0xFE	; 254
    1b9e:	1f 4f       	sbci	r17, 0xFF	; 255
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	0e 94 49 02 	call	0x492	; 0x492 <uxListRemove>
    1ba6:	89 a1       	ldd	r24, Y+33	; 0x21
    1ba8:	8e 8b       	std	Y+22, r24	; 0x16
    1baa:	24 e0       	ldi	r18, 0x04	; 4
    1bac:	30 e0       	ldi	r19, 0x00	; 0
    1bae:	28 1b       	sub	r18, r24
    1bb0:	31 09       	sbc	r19, r1
    1bb2:	3d 87       	std	Y+13, r19	; 0x0d
    1bb4:	2c 87       	std	Y+12, r18	; 0x0c
    1bb6:	90 91 60 08 	lds	r25, 0x0860
    1bba:	98 17       	cp	r25, r24
    1bbc:	10 f4       	brcc	.+4      	; 0x1bc2 <xTaskPriorityDisinherit+0x48>
    1bbe:	80 93 60 08 	sts	0x0860, r24
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	9c 01       	movw	r18, r24
    1bc6:	22 0f       	add	r18, r18
    1bc8:	33 1f       	adc	r19, r19
    1bca:	22 0f       	add	r18, r18
    1bcc:	33 1f       	adc	r19, r19
    1bce:	22 0f       	add	r18, r18
    1bd0:	33 1f       	adc	r19, r19
    1bd2:	82 0f       	add	r24, r18
    1bd4:	93 1f       	adc	r25, r19
    1bd6:	b8 01       	movw	r22, r16
    1bd8:	8a 56       	subi	r24, 0x6A	; 106
    1bda:	97 4f       	sbci	r25, 0xF7	; 247
    1bdc:	0e 94 f7 01 	call	0x3ee	; 0x3ee <vListInsertEnd>
    1be0:	81 e0       	ldi	r24, 0x01	; 1
    1be2:	05 c0       	rjmp	.+10     	; 0x1bee <xTaskPriorityDisinherit+0x74>
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	03 c0       	rjmp	.+6      	; 0x1bee <xTaskPriorityDisinherit+0x74>
    1be8:	80 e0       	ldi	r24, 0x00	; 0
    1bea:	01 c0       	rjmp	.+2      	; 0x1bee <xTaskPriorityDisinherit+0x74>
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	df 91       	pop	r29
    1bf0:	cf 91       	pop	r28
    1bf2:	1f 91       	pop	r17
    1bf4:	0f 91       	pop	r16
    1bf6:	08 95       	ret

00001bf8 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1bf8:	80 91 ba 08 	lds	r24, 0x08BA
    1bfc:	90 91 bb 08 	lds	r25, 0x08BB
    1c00:	89 2b       	or	r24, r25
    1c02:	39 f0       	breq	.+14     	; 0x1c12 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1c04:	e0 91 ba 08 	lds	r30, 0x08BA
    1c08:	f0 91 bb 08 	lds	r31, 0x08BB
    1c0c:	82 a1       	ldd	r24, Z+34	; 0x22
    1c0e:	8f 5f       	subi	r24, 0xFF	; 255
    1c10:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1c12:	80 91 ba 08 	lds	r24, 0x08BA
    1c16:	90 91 bb 08 	lds	r25, 0x08BB
	}
    1c1a:	08 95       	ret

00001c1c <__divmodhi4>:
    1c1c:	97 fb       	bst	r25, 7
    1c1e:	07 2e       	mov	r0, r23
    1c20:	16 f4       	brtc	.+4      	; 0x1c26 <__divmodhi4+0xa>
    1c22:	00 94       	com	r0
    1c24:	06 d0       	rcall	.+12     	; 0x1c32 <__divmodhi4_neg1>
    1c26:	77 fd       	sbrc	r23, 7
    1c28:	08 d0       	rcall	.+16     	; 0x1c3a <__divmodhi4_neg2>
    1c2a:	0b d0       	rcall	.+22     	; 0x1c42 <__udivmodhi4>
    1c2c:	07 fc       	sbrc	r0, 7
    1c2e:	05 d0       	rcall	.+10     	; 0x1c3a <__divmodhi4_neg2>
    1c30:	3e f4       	brtc	.+14     	; 0x1c40 <__divmodhi4_exit>

00001c32 <__divmodhi4_neg1>:
    1c32:	90 95       	com	r25
    1c34:	81 95       	neg	r24
    1c36:	9f 4f       	sbci	r25, 0xFF	; 255
    1c38:	08 95       	ret

00001c3a <__divmodhi4_neg2>:
    1c3a:	70 95       	com	r23
    1c3c:	61 95       	neg	r22
    1c3e:	7f 4f       	sbci	r23, 0xFF	; 255

00001c40 <__divmodhi4_exit>:
    1c40:	08 95       	ret

00001c42 <__udivmodhi4>:
    1c42:	aa 1b       	sub	r26, r26
    1c44:	bb 1b       	sub	r27, r27
    1c46:	51 e1       	ldi	r21, 0x11	; 17
    1c48:	07 c0       	rjmp	.+14     	; 0x1c58 <__udivmodhi4_ep>

00001c4a <__udivmodhi4_loop>:
    1c4a:	aa 1f       	adc	r26, r26
    1c4c:	bb 1f       	adc	r27, r27
    1c4e:	a6 17       	cp	r26, r22
    1c50:	b7 07       	cpc	r27, r23
    1c52:	10 f0       	brcs	.+4      	; 0x1c58 <__udivmodhi4_ep>
    1c54:	a6 1b       	sub	r26, r22
    1c56:	b7 0b       	sbc	r27, r23

00001c58 <__udivmodhi4_ep>:
    1c58:	88 1f       	adc	r24, r24
    1c5a:	99 1f       	adc	r25, r25
    1c5c:	5a 95       	dec	r21
    1c5e:	a9 f7       	brne	.-22     	; 0x1c4a <__udivmodhi4_loop>
    1c60:	80 95       	com	r24
    1c62:	90 95       	com	r25
    1c64:	bc 01       	movw	r22, r24
    1c66:	cd 01       	movw	r24, r26
    1c68:	08 95       	ret

00001c6a <memcpy>:
    1c6a:	fb 01       	movw	r30, r22
    1c6c:	dc 01       	movw	r26, r24
    1c6e:	02 c0       	rjmp	.+4      	; 0x1c74 <memcpy+0xa>
    1c70:	01 90       	ld	r0, Z+
    1c72:	0d 92       	st	X+, r0
    1c74:	41 50       	subi	r20, 0x01	; 1
    1c76:	50 40       	sbci	r21, 0x00	; 0
    1c78:	d8 f7       	brcc	.-10     	; 0x1c70 <memcpy+0x6>
    1c7a:	08 95       	ret

00001c7c <__itoa_ncheck>:
    1c7c:	bb 27       	eor	r27, r27
    1c7e:	4a 30       	cpi	r20, 0x0A	; 10
    1c80:	31 f4       	brne	.+12     	; 0x1c8e <__itoa_ncheck+0x12>
    1c82:	99 23       	and	r25, r25
    1c84:	22 f4       	brpl	.+8      	; 0x1c8e <__itoa_ncheck+0x12>
    1c86:	bd e2       	ldi	r27, 0x2D	; 45
    1c88:	90 95       	com	r25
    1c8a:	81 95       	neg	r24
    1c8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1c8e:	01 c0       	rjmp	.+2      	; 0x1c92 <__utoa_common>

00001c90 <__utoa_ncheck>:
    1c90:	bb 27       	eor	r27, r27

00001c92 <__utoa_common>:
    1c92:	fb 01       	movw	r30, r22
    1c94:	55 27       	eor	r21, r21
    1c96:	aa 27       	eor	r26, r26
    1c98:	88 0f       	add	r24, r24
    1c9a:	99 1f       	adc	r25, r25
    1c9c:	aa 1f       	adc	r26, r26
    1c9e:	a4 17       	cp	r26, r20
    1ca0:	10 f0       	brcs	.+4      	; 0x1ca6 <__utoa_common+0x14>
    1ca2:	a4 1b       	sub	r26, r20
    1ca4:	83 95       	inc	r24
    1ca6:	50 51       	subi	r21, 0x10	; 16
    1ca8:	b9 f7       	brne	.-18     	; 0x1c98 <__utoa_common+0x6>
    1caa:	a0 5d       	subi	r26, 0xD0	; 208
    1cac:	aa 33       	cpi	r26, 0x3A	; 58
    1cae:	08 f0       	brcs	.+2      	; 0x1cb2 <__utoa_common+0x20>
    1cb0:	a9 5d       	subi	r26, 0xD9	; 217
    1cb2:	a1 93       	st	Z+, r26
    1cb4:	00 97       	sbiw	r24, 0x00	; 0
    1cb6:	79 f7       	brne	.-34     	; 0x1c96 <__utoa_common+0x4>
    1cb8:	b1 11       	cpse	r27, r1
    1cba:	b1 93       	st	Z+, r27
    1cbc:	11 92       	st	Z+, r1
    1cbe:	cb 01       	movw	r24, r22
    1cc0:	00 c0       	rjmp	.+0      	; 0x1cc2 <strrev>

00001cc2 <strrev>:
    1cc2:	dc 01       	movw	r26, r24
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	67 2f       	mov	r22, r23
    1cc8:	71 91       	ld	r23, Z+
    1cca:	77 23       	and	r23, r23
    1ccc:	e1 f7       	brne	.-8      	; 0x1cc6 <strrev+0x4>
    1cce:	32 97       	sbiw	r30, 0x02	; 2
    1cd0:	04 c0       	rjmp	.+8      	; 0x1cda <strrev+0x18>
    1cd2:	7c 91       	ld	r23, X
    1cd4:	6d 93       	st	X+, r22
    1cd6:	70 83       	st	Z, r23
    1cd8:	62 91       	ld	r22, -Z
    1cda:	ae 17       	cp	r26, r30
    1cdc:	bf 07       	cpc	r27, r31
    1cde:	c8 f3       	brcs	.-14     	; 0x1cd2 <strrev+0x10>
    1ce0:	08 95       	ret

00001ce2 <_exit>:
    1ce2:	f8 94       	cli

00001ce4 <__stop_program>:
    1ce4:	ff cf       	rjmp	.-2      	; 0x1ce4 <__stop_program>
