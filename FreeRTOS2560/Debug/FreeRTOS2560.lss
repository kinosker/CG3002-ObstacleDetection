
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002f18  00002fac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070d  00800238  00800238  00002fe4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002fe4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00003014  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f6f  00000000  00000000  00003584  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000166f  00000000  00000000  000094f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000392b  00000000  00000000  0000ab62  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f94  00000000  00000000  0000e490  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017a6  00000000  00000000  0000f424  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000441c  00000000  00000000  00010bca  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014fe6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c3 c3       	rjmp	.+1926   	; 0x7ac <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	cc c7       	rjmp	.+3992   	; 0xffe <__vector_25>
      66:	00 00       	nop
      68:	0c 94 77 08 	jmp	0x10ee	; 0x10ee <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	9e c4       	rjmp	.+2364   	; 0x9b2 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	7e c7       	rjmp	.+3836   	; 0xf8e <__vector_36>
      92:	00 00       	nop
      94:	ec c7       	rjmp	.+4056   	; 0x106e <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x2c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e8 e1       	ldi	r30, 0x18	; 24
     17e:	ff e2       	ldi	r31, 0x2F	; 47
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a5 34       	cpi	r26, 0x45	; 69
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	df d0       	rcall	.+446    	; 0x360 <main>
     1a2:	0c 94 8a 17 	jmp	0x2f14	; 0x2f14 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 69 09 	call	0x12d2	; 0x12d2 <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 a9 09 	call	0x1352	; 0x1352 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 9e 09 	call	0x133c	; 0x133c <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 bb 09 	call	0x1376	; 0x1376 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 38 02 	lds	r24, 0x0238
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 af 09 	call	0x135e	; 0x135e <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 2c 09 	call	0x1258	; 0x1258 <myUSART_transmitUSART1_c>
     1e2:	d0 93 38 02 	sts	0x0238, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 b5 09 	call	0x136a	; 0x136a <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 38 02 	sts	0x0238, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 38 02 	sts	0x0238, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 38 02 	sts	0x0238, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 8a 09 	call	0x1314	; 0x1314 <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 93 08 	lds	r24, 0x0893
     232:	90 91 94 08 	lds	r25, 0x0894
     236:	0e 94 56 0d 	call	0x1aac	; 0x1aac <xQueueGenericReceive>
     23a:	11 23       	and	r17, r17
     23c:	61 f1       	breq	.+88     	; 0x296 <RPI_sendTask+0x86>
     23e:	8e 81       	ldd	r24, Y+6	; 0x06
     240:	80 5d       	subi	r24, 0xD0	; 208
     242:	0e 94 2c 09 	call	0x1258	; 0x1258 <myUSART_transmitUSART1_c>
     246:	8a e0       	ldi	r24, 0x0A	; 10
     248:	0e 94 2c 09 	call	0x1258	; 0x1258 <myUSART_transmitUSART1_c>
     24c:	24 c0       	rjmp	.+72     	; 0x296 <RPI_sendTask+0x86>
     24e:	20 e0       	ldi	r18, 0x00	; 0
     250:	4f ef       	ldi	r20, 0xFF	; 255
     252:	5f ef       	ldi	r21, 0xFF	; 255
     254:	be 01       	movw	r22, r28
     256:	6f 5f       	subi	r22, 0xFF	; 255
     258:	7f 4f       	sbci	r23, 0xFF	; 255
     25a:	80 91 95 08 	lds	r24, 0x0895
     25e:	90 91 96 08 	lds	r25, 0x0896
     262:	0e 94 56 0d 	call	0x1aac	; 0x1aac <xQueueGenericReceive>
     266:	89 81       	ldd	r24, Y+1	; 0x01
     268:	d6 d7       	rcall	.+4012   	; 0x1216 <myUSART_transmitUSART0_c>
     26a:	87 e0       	ldi	r24, 0x07	; 7
     26c:	92 e0       	ldi	r25, 0x02	; 2
     26e:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <myUSART_transmitUSART0>
     272:	ce 01       	movw	r24, r28
     274:	02 96       	adiw	r24, 0x02	; 2
     276:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <myUSART_transmitUSART0>
     27a:	8a e0       	ldi	r24, 0x0A	; 10
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <myUSART_transmitUSART0>
     282:	11 23       	and	r17, r17
     284:	41 f0       	breq	.+16     	; 0x296 <RPI_sendTask+0x86>
     286:	89 81       	ldd	r24, Y+1	; 0x01
     288:	e7 d7       	rcall	.+4046   	; 0x1258 <myUSART_transmitUSART1_c>
     28a:	ce 01       	movw	r24, r28
     28c:	02 96       	adiw	r24, 0x02	; 2
     28e:	0e 94 4d 09 	call	0x129a	; 0x129a <myUSART_transmitUSART1>
     292:	8a e0       	ldi	r24, 0x0A	; 10
     294:	e1 d7       	rcall	.+4034   	; 0x1258 <myUSART_transmitUSART1_c>
     296:	9e 81       	ldd	r25, Y+6	; 0x06
     298:	2f ef       	ldi	r18, 0xFF	; 255
     29a:	29 0f       	add	r18, r25
     29c:	2e 83       	std	Y+6, r18	; 0x06
     29e:	91 11       	cpse	r25, r1
     2a0:	d6 cf       	rjmp	.-84     	; 0x24e <RPI_sendTask+0x3e>
     2a2:	8a e0       	ldi	r24, 0x0A	; 10
     2a4:	b8 d7       	rcall	.+3952   	; 0x1216 <myUSART_transmitUSART0_c>
     2a6:	ba cf       	rjmp	.-140    	; 0x21c <RPI_sendTask+0xc>

000002a8 <myTimerTask>:
     2a8:	9f d5       	rcall	.+2878   	; 0xde8 <myTimer_Init>
     2aa:	02 d6       	rcall	.+3076   	; 0xeb0 <myTimer_DelayChecker>
     2ac:	fe cf       	rjmp	.-4      	; 0x2aa <myTimerTask+0x2>

000002ae <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2ae:	8f ef       	ldi	r24, 0xFF	; 255
     2b0:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2b4:	ef e7       	ldi	r30, 0x7F	; 127
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	90 81       	ld	r25, Z
     2ba:	93 60       	ori	r25, 0x03	; 3
     2bc:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2be:	80 93 7d 00 	sts	0x007D, r24
     2c2:	08 95       	ret

000002c4 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2c4:	8c ec       	ldi	r24, 0xCC	; 204
     2c6:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2ca:	8e e3       	ldi	r24, 0x3E	; 62
     2cc:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2d0:	ee cf       	rjmp	.-36     	; 0x2ae <setDigitalInputPowerReduction>
     2d2:	08 95       	ret

000002d4 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2d4:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2d8:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2dc:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2e0:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2e4:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2e8:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ec:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2f0:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2f4:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2f8:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2fc:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     300:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     304:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     308:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     30c:	10 92 73 00 	sts	0x0073, r1
     310:	08 95       	ret

00000312 <init>:
}

void init()
{
     312:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     314:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     316:	f8 94       	cli
	{
		clearTimer();
     318:	dd df       	rcall	.-70     	; 0x2d4 <clearTimer>
		setPowerReduction();
     31a:	d4 df       	rcall	.-88     	; 0x2c4 <setPowerReduction>
		myUSART_USART0_Init();
     31c:	28 d7       	rcall	.+3664   	; 0x116e <myUSART_USART0_Init>
		myUSART_USART1_Init();
     31e:	4d d7       	rcall	.+3738   	; 0x11ba <myUSART_USART1_Init>
		myADC_Init();
     320:	81 d3       	rcall	.+1794   	; 0xa24 <myADC_Init>
		
		MaxSonar_Init();
     322:	83 b3       	in	r24, 0x13	; 19
     324:	83 60       	ori	r24, 0x03	; 3
     326:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     328:	40 e0       	ldi	r20, 0x00	; 0
     32a:	61 e0       	ldi	r22, 0x01	; 1
     32c:	85 e0       	ldi	r24, 0x05	; 5
     32e:	0e 94 31 0c 	call	0x1862	; 0x1862 <xQueueGenericCreate>
     332:	90 93 94 08 	sts	0x0894, r25
     336:	80 93 93 08 	sts	0x0893, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     33a:	40 e0       	ldi	r20, 0x00	; 0
     33c:	65 e0       	ldi	r22, 0x05	; 5
     33e:	84 e1       	ldi	r24, 0x14	; 20
     340:	0e 94 31 0c 	call	0x1862	; 0x1862 <xQueueGenericCreate>
     344:	90 93 96 08 	sts	0x0896, r25
     348:	80 93 95 08 	sts	0x0895, r24
		
		MOTOR_LEFT_INIT();
     34c:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     34e:	e1 e0       	ldi	r30, 0x01	; 1
     350:	f1 e0       	ldi	r31, 0x01	; 1
     352:	80 81       	ld	r24, Z
     354:	80 61       	ori	r24, 0x10	; 16
     356:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     358:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     35a:	78 94       	sei
}
     35c:	cf 91       	pop	r28
     35e:	08 95       	ret

00000360 <main>:
	
	// do nth
}

int main(void)
{
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	28 97       	sbiw	r28, 0x08	; 8
     36a:	0f b6       	in	r0, 0x3f	; 63
     36c:	f8 94       	cli
     36e:	de bf       	out	0x3e, r29	; 62
     370:	0f be       	out	0x3f, r0	; 63
     372:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     374:	ce df       	rcall	.-100    	; 0x312 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     376:	a1 2c       	mov	r10, r1
     378:	b1 2c       	mov	r11, r1
     37a:	c1 2c       	mov	r12, r1
     37c:	d1 2c       	mov	r13, r1
     37e:	ce 01       	movw	r24, r28
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	7c 01       	movw	r14, r24
     384:	04 e0       	ldi	r16, 0x04	; 4
     386:	9c 01       	movw	r18, r24
     388:	49 e6       	ldi	r20, 0x69	; 105
     38a:	50 e0       	ldi	r21, 0x00	; 0
     38c:	6d e0       	ldi	r22, 0x0D	; 13
     38e:	72 e0       	ldi	r23, 0x02	; 2
     390:	84 e5       	ldi	r24, 0x54	; 84
     392:	91 e0       	ldi	r25, 0x01	; 1
     394:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     398:	ce 01       	movw	r24, r28
     39a:	07 96       	adiw	r24, 0x07	; 7
     39c:	7c 01       	movw	r14, r24
     39e:	02 e0       	ldi	r16, 0x02	; 2
     3a0:	20 e0       	ldi	r18, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	4d e6       	ldi	r20, 0x6D	; 109
     3a6:	51 e0       	ldi	r21, 0x01	; 1
     3a8:	65 e1       	ldi	r22, 0x15	; 21
     3aa:	72 e0       	ldi	r23, 0x02	; 2
     3ac:	89 e8       	ldi	r24, 0x89	; 137
     3ae:	92 e0       	ldi	r25, 0x02	; 2
     3b0:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3b4:	ce 01       	movw	r24, r28
     3b6:	05 96       	adiw	r24, 0x05	; 5
     3b8:	7c 01       	movw	r14, r24
     3ba:	03 e0       	ldi	r16, 0x03	; 3
     3bc:	20 e0       	ldi	r18, 0x00	; 0
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	47 e8       	ldi	r20, 0x87	; 135
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	6e e1       	ldi	r22, 0x1E	; 30
     3c6:	72 e0       	ldi	r23, 0x02	; 2
     3c8:	84 ed       	ldi	r24, 0xD4	; 212
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3d0:	ce 01       	movw	r24, r28
     3d2:	03 96       	adiw	r24, 0x03	; 3
     3d4:	7c 01       	movw	r14, r24
     3d6:	01 e0       	ldi	r16, 0x01	; 1
     3d8:	20 e0       	ldi	r18, 0x00	; 0
     3da:	30 e0       	ldi	r19, 0x00	; 0
     3dc:	47 e8       	ldi	r20, 0x87	; 135
     3de:	50 e0       	ldi	r21, 0x00	; 0
     3e0:	6a e2       	ldi	r22, 0x2A	; 42
     3e2:	72 e0       	ldi	r23, 0x02	; 2
     3e4:	88 e0       	ldi	r24, 0x08	; 8
     3e6:	91 e0       	ldi	r25, 0x01	; 1
     3e8:	0e 94 9e 0e 	call	0x1d3c	; 0x1d3c <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ec:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <vTaskStartScheduler>
     3f0:	c1 cf       	rjmp	.-126    	; 0x374 <main+0x14>

000003f2 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3f2:	9c 01       	movw	r18, r24
     3f4:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3f6:	64 e6       	ldi	r22, 0x64	; 100
     3f8:	70 e0       	ldi	r23, 0x00	; 0
     3fa:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__divmodhi4>
	
	if(input)
     3fe:	61 15       	cp	r22, r1
     400:	71 05       	cpc	r23, r1
     402:	21 f0       	breq	.+8      	; 0x40c <myItoa+0x1a>
		*buffer++ = input + '0';
     404:	80 e3       	ldi	r24, 0x30	; 48
     406:	86 0f       	add	r24, r22
     408:	80 83       	st	Z, r24
     40a:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     40c:	4c e9       	ldi	r20, 0x9C	; 156
     40e:	46 03       	mulsu	r20, r22
     410:	c0 01       	movw	r24, r0
     412:	47 9f       	mul	r20, r23
     414:	90 0d       	add	r25, r0
     416:	11 24       	eor	r1, r1
     418:	28 0f       	add	r18, r24
     41a:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     41c:	c9 01       	movw	r24, r18
     41e:	6a e0       	ldi	r22, 0x0A	; 10
     420:	70 e0       	ldi	r23, 0x00	; 0
     422:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__divmodhi4>
	*buffer++ = input + '0';
     426:	80 e3       	ldi	r24, 0x30	; 48
     428:	86 0f       	add	r24, r22
     42a:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     42c:	8a e0       	ldi	r24, 0x0A	; 10
     42e:	68 9f       	mul	r22, r24
     430:	20 19       	sub	r18, r0
     432:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     434:	20 5d       	subi	r18, 0xD0	; 208
     436:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     438:	12 82       	std	Z+2, r1	; 0x02
     43a:	08 95       	ret

0000043c <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	00 d0       	rcall	.+0      	; 0x444 <obstacleSend+0x8>
     444:	1f 92       	push	r1
     446:	1f 92       	push	r1
     448:	cd b7       	in	r28, 0x3d	; 61
     44a:	de b7       	in	r29, 0x3e	; 62
     44c:	18 2f       	mov	r17, r24
     44e:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     450:	11 23       	and	r17, r17
     452:	89 f0       	breq	.+34     	; 0x476 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     454:	be 01       	movw	r22, r28
     456:	6e 5f       	subi	r22, 0xFE	; 254
     458:	7f 4f       	sbci	r23, 0xFF	; 255
     45a:	cb df       	rcall	.-106    	; 0x3f2 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     45c:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     45e:	20 e0       	ldi	r18, 0x00	; 0
     460:	4f ef       	ldi	r20, 0xFF	; 255
     462:	5f ef       	ldi	r21, 0xFF	; 255
     464:	be 01       	movw	r22, r28
     466:	6f 5f       	subi	r22, 0xFF	; 255
     468:	7f 4f       	sbci	r23, 0xFF	; 255
     46a:	80 91 95 08 	lds	r24, 0x0895
     46e:	90 91 96 08 	lds	r25, 0x0896
     472:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <xQueueGenericSend>
	}
}
     476:	0f 90       	pop	r0
     478:	0f 90       	pop	r0
     47a:	0f 90       	pop	r0
     47c:	0f 90       	pop	r0
     47e:	0f 90       	pop	r0
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	1f 91       	pop	r17
     486:	08 95       	ret

00000488 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     488:	6f 92       	push	r6
     48a:	7f 92       	push	r7
     48c:	8f 92       	push	r8
     48e:	9f 92       	push	r9
     490:	af 92       	push	r10
     492:	bf 92       	push	r11
     494:	cf 92       	push	r12
     496:	df 92       	push	r13
     498:	ef 92       	push	r14
     49a:	ff 92       	push	r15
     49c:	0f 93       	push	r16
     49e:	1f 93       	push	r17
     4a0:	cf 93       	push	r28
     4a2:	df 93       	push	r29
     4a4:	1f 92       	push	r1
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	89 83       	std	Y+1, r24	; 0x01
     4ac:	5b 01       	movw	r10, r22
     4ae:	3a 01       	movw	r6, r20
     4b0:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4b2:	20 e0       	ldi	r18, 0x00	; 0
     4b4:	4f ef       	ldi	r20, 0xFF	; 255
     4b6:	5f ef       	ldi	r21, 0xFF	; 255
     4b8:	be 01       	movw	r22, r28
     4ba:	6f 5f       	subi	r22, 0xFF	; 255
     4bc:	7f 4f       	sbci	r23, 0xFF	; 255
     4be:	80 91 93 08 	lds	r24, 0x0893
     4c2:	90 91 94 08 	lds	r25, 0x0894
     4c6:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4ca:	b3 01       	movw	r22, r6
     4cc:	f5 01       	movw	r30, r10
     4ce:	80 81       	ld	r24, Z
     4d0:	b5 df       	rcall	.-150    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4d2:	b4 01       	movw	r22, r8
     4d4:	f5 01       	movw	r30, r10
     4d6:	81 81       	ldd	r24, Z+1	; 0x01
     4d8:	b1 df       	rcall	.-158    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4da:	b8 01       	movw	r22, r16
     4dc:	f5 01       	movw	r30, r10
     4de:	82 81       	ldd	r24, Z+2	; 0x02
     4e0:	ad df       	rcall	.-166    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4e2:	b7 01       	movw	r22, r14
     4e4:	f5 01       	movw	r30, r10
     4e6:	83 81       	ldd	r24, Z+3	; 0x03
     4e8:	a9 df       	rcall	.-174    	; 0x43c <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4ea:	b6 01       	movw	r22, r12
     4ec:	f5 01       	movw	r30, r10
     4ee:	84 81       	ldd	r24, Z+4	; 0x04
     4f0:	a5 df       	rcall	.-182    	; 0x43c <obstacleSend>
		
	}
}
     4f2:	0f 90       	pop	r0
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	ff 90       	pop	r15
     4fe:	ef 90       	pop	r14
     500:	df 90       	pop	r13
     502:	cf 90       	pop	r12
     504:	bf 90       	pop	r11
     506:	af 90       	pop	r10
     508:	9f 90       	pop	r9
     50a:	8f 90       	pop	r8
     50c:	7f 90       	pop	r7
     50e:	6f 90       	pop	r6
     510:	08 95       	ret

00000512 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     512:	cf 93       	push	r28
     514:	df 93       	push	r29
     516:	cd b7       	in	r28, 0x3d	; 61
     518:	de b7       	in	r29, 0x3e	; 62
     51a:	a4 97       	sbiw	r28, 0x24	; 36
     51c:	0f b6       	in	r0, 0x3f	; 63
     51e:	f8 94       	cli
     520:	de bf       	out	0x3e, r29	; 62
     522:	0f be       	out	0x3f, r0	; 63
     524:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     526:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     528:	86 e0       	ldi	r24, 0x06	; 6
     52a:	fe 01       	movw	r30, r28
     52c:	34 96       	adiw	r30, 0x04	; 4
     52e:	df 01       	movw	r26, r30
     530:	98 2f       	mov	r25, r24
     532:	1d 92       	st	X+, r1
     534:	9a 95       	dec	r25
     536:	e9 f7       	brne	.-6      	; 0x532 <Sonar_Task+0x20>
     538:	36 96       	adiw	r30, 0x06	; 6
     53a:	df 01       	movw	r26, r30
     53c:	98 2f       	mov	r25, r24
     53e:	1d 92       	st	X+, r1
     540:	9a 95       	dec	r25
     542:	e9 f7       	brne	.-6      	; 0x53e <Sonar_Task+0x2c>
     544:	36 96       	adiw	r30, 0x06	; 6
     546:	df 01       	movw	r26, r30
     548:	98 2f       	mov	r25, r24
     54a:	1d 92       	st	X+, r1
     54c:	9a 95       	dec	r25
     54e:	e9 f7       	brne	.-6      	; 0x54a <Sonar_Task+0x38>
     550:	36 96       	adiw	r30, 0x06	; 6
     552:	df 01       	movw	r26, r30
     554:	1d 92       	st	X+, r1
     556:	8a 95       	dec	r24
     558:	e9 f7       	brne	.-6      	; 0x554 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     55a:	36 96       	adiw	r30, 0x06	; 6
     55c:	85 e0       	ldi	r24, 0x05	; 5
     55e:	df 01       	movw	r26, r30
     560:	1d 92       	st	X+, r1
     562:	8a 95       	dec	r24
     564:	e9 f7       	brne	.-6      	; 0x560 <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     566:	84 e2       	ldi	r24, 0x24	; 36
     568:	b6 d3       	rcall	.+1900   	; 0xcd6 <mySharpIR_Read>
     56a:	9a a3       	std	Y+34, r25	; 0x22
     56c:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     56e:	0e 94 2d 10 	call	0x205a	; 0x205a <xTaskGetTickCount>
     572:	9a 83       	std	Y+2, r25	; 0x02
     574:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     576:	a5 d1       	rcall	.+842    	; 0x8c2 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     578:	87 e2       	ldi	r24, 0x27	; 39
     57a:	09 d2       	rcall	.+1042   	; 0x98e <myMaxSonar_Read>
     57c:	be 01       	movw	r22, r28
     57e:	66 5f       	subi	r22, 0xF6	; 246
     580:	7f 4f       	sbci	r23, 0xFF	; 255
     582:	fc d1       	rcall	.+1016   	; 0x97c <myMaxSonar_getFilteredReading>
     584:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     586:	86 e2       	ldi	r24, 0x26	; 38
     588:	02 d2       	rcall	.+1028   	; 0x98e <myMaxSonar_Read>
     58a:	be 01       	movw	r22, r28
     58c:	60 5f       	subi	r22, 0xF0	; 240
     58e:	7f 4f       	sbci	r23, 0xFF	; 255
     590:	f5 d1       	rcall	.+1002   	; 0x97c <myMaxSonar_getFilteredReading>
     592:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     594:	85 e2       	ldi	r24, 0x25	; 37
     596:	fb d1       	rcall	.+1014   	; 0x98e <myMaxSonar_Read>
     598:	be 01       	movw	r22, r28
     59a:	6a 5e       	subi	r22, 0xEA	; 234
     59c:	7f 4f       	sbci	r23, 0xFF	; 255
     59e:	ee d1       	rcall	.+988    	; 0x97c <myMaxSonar_getFilteredReading>
     5a0:	2c 01       	movw	r4, r24
		
		myMaxSonar_TopStart();
     5a2:	95 d1       	rcall	.+810    	; 0x8ce <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5a4:	83 e2       	ldi	r24, 0x23	; 35
     5a6:	f3 d1       	rcall	.+998    	; 0x98e <myMaxSonar_Read>
     5a8:	be 01       	movw	r22, r28
     5aa:	6c 5f       	subi	r22, 0xFC	; 252
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	e6 d1       	rcall	.+972    	; 0x97c <myMaxSonar_getFilteredReading>
     5b0:	9c a3       	std	Y+36, r25	; 0x24
     5b2:	8b a3       	std	Y+35, r24	; 0x23
			
			
		btmIR		= mySharpIR_Read(AN12);
     5b4:	84 e2       	ldi	r24, 0x24	; 36
     5b6:	8f d3       	rcall	.+1822   	; 0xcd6 <mySharpIR_Read>
     5b8:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5ba:	bc 01       	movw	r22, r24
     5bc:	ce 01       	movw	r24, r28
     5be:	81 96       	adiw	r24, 0x21	; 33
     5c0:	c3 d3       	rcall	.+1926   	; 0xd48 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5c2:	c9 a0       	ldd	r12, Y+33	; 0x21
     5c4:	da a0       	ldd	r13, Y+34	; 0x22
     5c6:	54 01       	movw	r10, r8
     5c8:	eb a0       	ldd	r14, Y+35	; 0x23
     5ca:	fc a0       	ldd	r15, Y+36	; 0x24
     5cc:	82 01       	movw	r16, r4
     5ce:	91 01       	movw	r18, r2
     5d0:	ae 01       	movw	r20, r28
     5d2:	44 5e       	subi	r20, 0xE4	; 228
     5d4:	5f 4f       	sbci	r21, 0xFF	; 255
     5d6:	6b 81       	ldd	r22, Y+3	; 0x03
     5d8:	c3 01       	movw	r24, r6
     5da:	43 d3       	rcall	.+1670   	; 0xc62 <obstacleDetection>
     5dc:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5de:	ce 01       	movw	r24, r28
     5e0:	4c 96       	adiw	r24, 0x1c	; 28
     5e2:	7c 01       	movw	r14, r24
     5e4:	84 01       	movw	r16, r8
     5e6:	92 01       	movw	r18, r4
     5e8:	a1 01       	movw	r20, r2
     5ea:	6b a1       	ldd	r22, Y+35	; 0x23
     5ec:	7c a1       	ldd	r23, Y+36	; 0x24
     5ee:	c3 01       	movw	r24, r6
     5f0:	b6 d2       	rcall	.+1388   	; 0xb5e <obstacleAvoidance>
		
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5f2:	be 01       	movw	r22, r28
     5f4:	6d 5f       	subi	r22, 0xFD	; 253
     5f6:	7f 4f       	sbci	r23, 0xFF	; 255
     5f8:	c7 01       	movw	r24, r14
     5fa:	96 d2       	rcall	.+1324   	; 0xb28 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5fc:	cb a0       	ldd	r12, Y+35	; 0x23
     5fe:	dc a0       	ldd	r13, Y+36	; 0x24
     600:	74 01       	movw	r14, r8
     602:	82 01       	movw	r16, r4
     604:	91 01       	movw	r18, r2
     606:	a3 01       	movw	r20, r6
     608:	be 01       	movw	r22, r28
     60a:	64 5e       	subi	r22, 0xE4	; 228
     60c:	7f 4f       	sbci	r23, 0xFF	; 255
     60e:	8b 81       	ldd	r24, Y+3	; 0x03
     610:	3b df       	rcall	.-394    	; 0x488 <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     612:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     614:	18 a2       	std	Y+32, r1	; 0x20
     616:	1f 8e       	std	Y+31, r1	; 0x1f
     618:	1e 8e       	std	Y+30, r1	; 0x1e
     61a:	1d 8e       	std	Y+29, r1	; 0x1d
     61c:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     61e:	66 e9       	ldi	r22, 0x96	; 150
     620:	70 e0       	ldi	r23, 0x00	; 0
     622:	ce 01       	movw	r24, r28
     624:	01 96       	adiw	r24, 0x01	; 1
     626:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <vTaskDelayUntil>
     62a:	a5 cf       	rjmp	.-182    	; 0x576 <Sonar_Task+0x64>

0000062c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     632:	0e 94 27 10 	call	0x204e	; 0x204e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     636:	80 91 39 02 	lds	r24, 0x0239
     63a:	90 91 3a 02 	lds	r25, 0x023A
     63e:	89 2b       	or	r24, r25
     640:	31 f4       	brne	.+12     	; 0x64e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     642:	8e e3       	ldi	r24, 0x3E	; 62
     644:	92 e0       	ldi	r25, 0x02	; 2
     646:	90 93 3a 02 	sts	0x023A, r25
     64a:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     64e:	40 91 3b 02 	lds	r20, 0x023B
     652:	50 91 3c 02 	lds	r21, 0x023C
     656:	9e 01       	movw	r18, r28
     658:	24 0f       	add	r18, r20
     65a:	35 1f       	adc	r19, r21
     65c:	2b 3d       	cpi	r18, 0xDB	; 219
     65e:	85 e0       	ldi	r24, 0x05	; 5
     660:	38 07       	cpc	r19, r24
     662:	70 f4       	brcc	.+28     	; 0x680 <pvPortMalloc+0x54>
     664:	42 17       	cp	r20, r18
     666:	53 07       	cpc	r21, r19
     668:	70 f4       	brcc	.+28     	; 0x686 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     66a:	c0 91 39 02 	lds	r28, 0x0239
     66e:	d0 91 3a 02 	lds	r29, 0x023A
     672:	c4 0f       	add	r28, r20
     674:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     676:	30 93 3c 02 	sts	0x023C, r19
     67a:	20 93 3b 02 	sts	0x023B, r18
     67e:	05 c0       	rjmp	.+10     	; 0x68a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     680:	c0 e0       	ldi	r28, 0x00	; 0
     682:	d0 e0       	ldi	r29, 0x00	; 0
     684:	02 c0       	rjmp	.+4      	; 0x68a <pvPortMalloc+0x5e>
     686:	c0 e0       	ldi	r28, 0x00	; 0
     688:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     68a:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     68e:	ce 01       	movw	r24, r28
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	08 95       	ret

00000696 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     696:	08 95       	ret

00000698 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     698:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     69a:	03 96       	adiw	r24, 0x03	; 3
     69c:	92 83       	std	Z+2, r25	; 0x02
     69e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6a0:	2f ef       	ldi	r18, 0xFF	; 255
     6a2:	3f ef       	ldi	r19, 0xFF	; 255
     6a4:	34 83       	std	Z+4, r19	; 0x04
     6a6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a8:	96 83       	std	Z+6, r25	; 0x06
     6aa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ac:	90 87       	std	Z+8, r25	; 0x08
     6ae:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6b0:	10 82       	st	Z, r1
     6b2:	08 95       	ret

000006b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6b4:	fc 01       	movw	r30, r24
     6b6:	11 86       	std	Z+9, r1	; 0x09
     6b8:	10 86       	std	Z+8, r1	; 0x08
     6ba:	08 95       	ret

000006bc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	9c 01       	movw	r18, r24
     6c2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6c4:	dc 01       	movw	r26, r24
     6c6:	11 96       	adiw	r26, 0x01	; 1
     6c8:	cd 91       	ld	r28, X+
     6ca:	dc 91       	ld	r29, X
     6cc:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6ce:	d3 83       	std	Z+3, r29	; 0x03
     6d0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6d2:	8c 81       	ldd	r24, Y+4	; 0x04
     6d4:	9d 81       	ldd	r25, Y+5	; 0x05
     6d6:	95 83       	std	Z+5, r25	; 0x05
     6d8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6da:	8c 81       	ldd	r24, Y+4	; 0x04
     6dc:	9d 81       	ldd	r25, Y+5	; 0x05
     6de:	dc 01       	movw	r26, r24
     6e0:	13 96       	adiw	r26, 0x03	; 3
     6e2:	7c 93       	st	X, r23
     6e4:	6e 93       	st	-X, r22
     6e6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6e8:	7d 83       	std	Y+5, r23	; 0x05
     6ea:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ec:	31 87       	std	Z+9, r19	; 0x09
     6ee:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6f0:	f9 01       	movw	r30, r18
     6f2:	80 81       	ld	r24, Z
     6f4:	8f 5f       	subi	r24, 0xFF	; 255
     6f6:	80 83       	st	Z, r24
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6fe:	cf 93       	push	r28
     700:	df 93       	push	r29
     702:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     704:	48 81       	ld	r20, Y
     706:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     708:	4f 3f       	cpi	r20, 0xFF	; 255
     70a:	2f ef       	ldi	r18, 0xFF	; 255
     70c:	52 07       	cpc	r21, r18
     70e:	21 f4       	brne	.+8      	; 0x718 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     710:	fc 01       	movw	r30, r24
     712:	a7 81       	ldd	r26, Z+7	; 0x07
     714:	b0 85       	ldd	r27, Z+8	; 0x08
     716:	0d c0       	rjmp	.+26     	; 0x732 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     718:	dc 01       	movw	r26, r24
     71a:	13 96       	adiw	r26, 0x03	; 3
     71c:	12 96       	adiw	r26, 0x02	; 2
     71e:	ed 91       	ld	r30, X+
     720:	fc 91       	ld	r31, X
     722:	13 97       	sbiw	r26, 0x03	; 3
     724:	20 81       	ld	r18, Z
     726:	31 81       	ldd	r19, Z+1	; 0x01
     728:	42 17       	cp	r20, r18
     72a:	53 07       	cpc	r21, r19
     72c:	10 f0       	brcs	.+4      	; 0x732 <vListInsert+0x34>
     72e:	df 01       	movw	r26, r30
     730:	f5 cf       	rjmp	.-22     	; 0x71c <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     732:	12 96       	adiw	r26, 0x02	; 2
     734:	ed 91       	ld	r30, X+
     736:	fc 91       	ld	r31, X
     738:	13 97       	sbiw	r26, 0x03	; 3
     73a:	fb 83       	std	Y+3, r31	; 0x03
     73c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     73e:	d5 83       	std	Z+5, r29	; 0x05
     740:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     742:	bd 83       	std	Y+5, r27	; 0x05
     744:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     746:	13 96       	adiw	r26, 0x03	; 3
     748:	dc 93       	st	X, r29
     74a:	ce 93       	st	-X, r28
     74c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     74e:	99 87       	std	Y+9, r25	; 0x09
     750:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     752:	fc 01       	movw	r30, r24
     754:	20 81       	ld	r18, Z
     756:	2f 5f       	subi	r18, 0xFF	; 255
     758:	20 83       	st	Z, r18
}
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     766:	a0 85       	ldd	r26, Z+8	; 0x08
     768:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     76a:	c2 81       	ldd	r28, Z+2	; 0x02
     76c:	d3 81       	ldd	r29, Z+3	; 0x03
     76e:	84 81       	ldd	r24, Z+4	; 0x04
     770:	95 81       	ldd	r25, Z+5	; 0x05
     772:	9d 83       	std	Y+5, r25	; 0x05
     774:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     776:	c4 81       	ldd	r28, Z+4	; 0x04
     778:	d5 81       	ldd	r29, Z+5	; 0x05
     77a:	82 81       	ldd	r24, Z+2	; 0x02
     77c:	93 81       	ldd	r25, Z+3	; 0x03
     77e:	9b 83       	std	Y+3, r25	; 0x03
     780:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     782:	11 96       	adiw	r26, 0x01	; 1
     784:	cd 91       	ld	r28, X+
     786:	dc 91       	ld	r29, X
     788:	12 97       	sbiw	r26, 0x02	; 2
     78a:	ce 17       	cp	r28, r30
     78c:	df 07       	cpc	r29, r31
     78e:	31 f4       	brne	.+12     	; 0x79c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     790:	8c 81       	ldd	r24, Y+4	; 0x04
     792:	9d 81       	ldd	r25, Y+5	; 0x05
     794:	12 96       	adiw	r26, 0x02	; 2
     796:	9c 93       	st	X, r25
     798:	8e 93       	st	-X, r24
     79a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     79c:	11 86       	std	Z+9, r1	; 0x09
     79e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7a0:	8c 91       	ld	r24, X
     7a2:	81 50       	subi	r24, 0x01	; 1
     7a4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7a6:	df 91       	pop	r29
     7a8:	cf 91       	pop	r28
     7aa:	08 95       	ret

000007ac <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7ac:	1f 92       	push	r1
     7ae:	0f 92       	push	r0
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	0f 92       	push	r0
     7b4:	11 24       	eor	r1, r1
     7b6:	0b b6       	in	r0, 0x3b	; 59
     7b8:	0f 92       	push	r0
     7ba:	2f 93       	push	r18
     7bc:	3f 93       	push	r19
     7be:	4f 93       	push	r20
     7c0:	5f 93       	push	r21
     7c2:	6f 93       	push	r22
     7c4:	7f 93       	push	r23
     7c6:	8f 93       	push	r24
     7c8:	9f 93       	push	r25
     7ca:	af 93       	push	r26
     7cc:	bf 93       	push	r27
     7ce:	ef 93       	push	r30
     7d0:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7d2:	1b 9b       	sbis	0x03, 3	; 3
     7d4:	0d c0       	rjmp	.+26     	; 0x7f0 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7d6:	22 d3       	rcall	.+1604   	; 0xe1c <myTimer_Read>
     7d8:	90 e0       	ldi	r25, 0x00	; 0
     7da:	90 93 9c 08 	sts	0x089C, r25
     7de:	80 93 9b 08 	sts	0x089B, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7e2:	0e 94 37 10 	call	0x206e	; 0x206e <xTaskGetTickCountFromISR>
     7e6:	90 93 98 08 	sts	0x0898, r25
     7ea:	80 93 97 08 	sts	0x0897, r24
     7ee:	56 c0       	rjmp	.+172    	; 0x89c <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7f0:	1b 99       	sbic	0x03, 3	; 3
     7f2:	54 c0       	rjmp	.+168    	; 0x89c <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7f4:	0e 94 37 10 	call	0x206e	; 0x206e <xTaskGetTickCountFromISR>
     7f8:	90 93 a2 08 	sts	0x08A2, r25
     7fc:	80 93 a1 08 	sts	0x08A1, r24
     800:	20 91 97 08 	lds	r18, 0x0897
     804:	30 91 98 08 	lds	r19, 0x0898
     808:	82 17       	cp	r24, r18
     80a:	93 07       	cpc	r25, r19
     80c:	4c f4       	brge	.+18     	; 0x820 <__vector_9+0x74>
			ms_tickEnd += 65535;
     80e:	80 91 a1 08 	lds	r24, 0x08A1
     812:	90 91 a2 08 	lds	r25, 0x08A2
     816:	01 97       	sbiw	r24, 0x01	; 1
     818:	90 93 a2 08 	sts	0x08A2, r25
     81c:	80 93 a1 08 	sts	0x08A1, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     820:	fd d2       	rcall	.+1530   	; 0xe1c <myTimer_Read>
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	90 93 a4 08 	sts	0x08A4, r25
     828:	80 93 a3 08 	sts	0x08A3, r24
     82c:	20 91 9b 08 	lds	r18, 0x089B
     830:	30 91 9c 08 	lds	r19, 0x089C
     834:	82 17       	cp	r24, r18
     836:	93 07       	cpc	r25, r19
     838:	54 f4       	brge	.+20     	; 0x84e <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     83a:	80 91 a3 08 	lds	r24, 0x08A3
     83e:	90 91 a4 08 	lds	r25, 0x08A4
     842:	86 50       	subi	r24, 0x06	; 6
     844:	9f 4f       	sbci	r25, 0xFF	; 255
     846:	90 93 a4 08 	sts	0x08A4, r25
     84a:	80 93 a3 08 	sts	0x08A3, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     84e:	80 91 a3 08 	lds	r24, 0x08A3
     852:	90 91 a4 08 	lds	r25, 0x08A4
     856:	20 91 9b 08 	lds	r18, 0x089B
     85a:	30 91 9c 08 	lds	r19, 0x089C
     85e:	82 1b       	sub	r24, r18
     860:	93 0b       	sbc	r25, r19
     862:	90 93 9e 08 	sts	0x089E, r25
     866:	80 93 9d 08 	sts	0x089D, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     86a:	80 91 a1 08 	lds	r24, 0x08A1
     86e:	90 91 a2 08 	lds	r25, 0x08A2
     872:	20 91 97 08 	lds	r18, 0x0897
     876:	30 91 98 08 	lds	r19, 0x0898
     87a:	82 1b       	sub	r24, r18
     87c:	93 0b       	sbc	r25, r19
     87e:	90 93 9a 08 	sts	0x089A, r25
     882:	80 93 99 08 	sts	0x0899, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     886:	20 e0       	ldi	r18, 0x00	; 0
     888:	40 e0       	ldi	r20, 0x00	; 0
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	60 e0       	ldi	r22, 0x00	; 0
     88e:	70 e0       	ldi	r23, 0x00	; 0
     890:	80 91 9f 08 	lds	r24, 0x089F
     894:	90 91 a0 08 	lds	r25, 0x08A0
     898:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <xQueueGenericSendFromISR>
	}	
}
     89c:	ff 91       	pop	r31
     89e:	ef 91       	pop	r30
     8a0:	bf 91       	pop	r27
     8a2:	af 91       	pop	r26
     8a4:	9f 91       	pop	r25
     8a6:	8f 91       	pop	r24
     8a8:	7f 91       	pop	r23
     8aa:	6f 91       	pop	r22
     8ac:	5f 91       	pop	r21
     8ae:	4f 91       	pop	r20
     8b0:	3f 91       	pop	r19
     8b2:	2f 91       	pop	r18
     8b4:	0f 90       	pop	r0
     8b6:	0b be       	out	0x3b, r0	; 59
     8b8:	0f 90       	pop	r0
     8ba:	0f be       	out	0x3f, r0	; 63
     8bc:	0f 90       	pop	r0
     8be:	1f 90       	pop	r1
     8c0:	18 95       	reti

000008c2 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8c2:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8c4:	89 e1       	ldi	r24, 0x19	; 25
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	ab d2       	rcall	.+1366   	; 0xe20 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8ca:	a1 98       	cbi	0x14, 1	; 20
     8cc:	08 95       	ret

000008ce <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8ce:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro2(25); // delay 25 micro seconds...
     8d0:	89 e1       	ldi	r24, 0x19	; 25
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	c9 d2       	rcall	.+1426   	; 0xe68 <myTimer_DelayMicro2>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8d6:	a0 98       	cbi	0x14, 0	; 20
     8d8:	08 95       	ret

000008da <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8da:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8dc:	80 81       	ld	r24, Z
     8de:	91 81       	ldd	r25, Z+1	; 0x01
     8e0:	22 81       	ldd	r18, Z+2	; 0x02
     8e2:	33 81       	ldd	r19, Z+3	; 0x03
     8e4:	28 17       	cp	r18, r24
     8e6:	39 07       	cpc	r19, r25
     8e8:	54 f4       	brge	.+20     	; 0x8fe <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8ea:	44 81       	ldd	r20, Z+4	; 0x04
     8ec:	55 81       	ldd	r21, Z+5	; 0x05
     8ee:	42 17       	cp	r20, r18
     8f0:	53 07       	cpc	r21, r19
     8f2:	84 f0       	brlt	.+32     	; 0x914 <myMaxSonar_extractMedian+0x3a>
     8f4:	48 17       	cp	r20, r24
     8f6:	59 07       	cpc	r21, r25
     8f8:	74 f4       	brge	.+28     	; 0x916 <myMaxSonar_extractMedian+0x3c>
     8fa:	ca 01       	movw	r24, r20
     8fc:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8fe:	44 81       	ldd	r20, Z+4	; 0x04
     900:	55 81       	ldd	r21, Z+5	; 0x05
     902:	48 17       	cp	r20, r24
     904:	59 07       	cpc	r21, r25
     906:	3c f0       	brlt	.+14     	; 0x916 <myMaxSonar_extractMedian+0x3c>
     908:	ca 01       	movw	r24, r20
     90a:	24 17       	cp	r18, r20
     90c:	35 07       	cpc	r19, r21
     90e:	1c f4       	brge	.+6      	; 0x916 <myMaxSonar_extractMedian+0x3c>
     910:	c9 01       	movw	r24, r18
     912:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     914:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     916:	08 95       	ret

00000918 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     918:	9b 01       	movw	r18, r22
     91a:	28 5f       	subi	r18, 0xF8	; 248
     91c:	3f 4f       	sbci	r19, 0xFF	; 255
     91e:	28 17       	cp	r18, r24
     920:	39 07       	cpc	r19, r25
     922:	3c f0       	brlt	.+14     	; 0x932 <myMaxSonar_Stabilizer+0x1a>
     924:	20 51       	subi	r18, 0x10	; 16
     926:	31 09       	sbc	r19, r1
     928:	82 17       	cp	r24, r18
     92a:	93 07       	cpc	r25, r19
     92c:	14 f0       	brlt	.+4      	; 0x932 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     92e:	86 2f       	mov	r24, r22
     930:	97 2f       	mov	r25, r23
}
     932:	08 95       	ret

00000934 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     934:	0f 93       	push	r16
     936:	1f 93       	push	r17
     938:	cf 93       	push	r28
     93a:	df 93       	push	r29
     93c:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     93e:	00 91 00 02 	lds	r16, 0x0200
     942:	10 e0       	ldi	r17, 0x00	; 0
     944:	f8 01       	movw	r30, r16
     946:	ee 0f       	add	r30, r30
     948:	ff 1f       	adc	r31, r31
     94a:	e6 0f       	add	r30, r22
     94c:	f7 1f       	adc	r31, r23
     94e:	60 81       	ld	r22, Z
     950:	71 81       	ldd	r23, Z+1	; 0x01
     952:	e2 df       	rcall	.-60     	; 0x918 <myMaxSonar_Stabilizer>
     954:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     956:	c8 01       	movw	r24, r16
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	63 e0       	ldi	r22, 0x03	; 3
     95c:	70 e0       	ldi	r23, 0x00	; 0
     95e:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__divmodhi4>
     962:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	c8 0f       	add	r28, r24
     96c:	d9 1f       	adc	r29, r25
     96e:	39 83       	std	Y+1, r19	; 0x01
     970:	28 83       	st	Y, r18
}
     972:	df 91       	pop	r29
     974:	cf 91       	pop	r28
     976:	1f 91       	pop	r17
     978:	0f 91       	pop	r16
     97a:	08 95       	ret

0000097c <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     982:	d8 df       	rcall	.-80     	; 0x934 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     984:	ce 01       	movw	r24, r28
     986:	a9 df       	rcall	.-174    	; 0x8da <myMaxSonar_extractMedian>

}
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     98e:	b5 d0       	rcall	.+362    	; 0xafa <myADC_analogRead>
     990:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     992:	63 e0       	ldi	r22, 0x03	; 3
     994:	70 e0       	ldi	r23, 0x00	; 0
     996:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     99a:	26 0f       	add	r18, r22
     99c:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     99e:	29 3e       	cpi	r18, 0xE9	; 233
     9a0:	83 e0       	ldi	r24, 0x03	; 3
     9a2:	38 07       	cpc	r19, r24
     9a4:	1c f0       	brlt	.+6      	; 0x9ac <myMaxSonar_Read+0x1e>
		return 999;
     9a6:	87 ee       	ldi	r24, 0xE7	; 231
     9a8:	93 e0       	ldi	r25, 0x03	; 3
     9aa:	08 95       	ret
	
	return reading;
     9ac:	82 2f       	mov	r24, r18
     9ae:	93 2f       	mov	r25, r19
}
     9b0:	08 95       	ret

000009b2 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9b2:	1f 92       	push	r1
     9b4:	0f 92       	push	r0
     9b6:	0f b6       	in	r0, 0x3f	; 63
     9b8:	0f 92       	push	r0
     9ba:	11 24       	eor	r1, r1
     9bc:	0b b6       	in	r0, 0x3b	; 59
     9be:	0f 92       	push	r0
     9c0:	2f 93       	push	r18
     9c2:	3f 93       	push	r19
     9c4:	4f 93       	push	r20
     9c6:	5f 93       	push	r21
     9c8:	6f 93       	push	r22
     9ca:	7f 93       	push	r23
     9cc:	8f 93       	push	r24
     9ce:	9f 93       	push	r25
     9d0:	af 93       	push	r26
     9d2:	bf 93       	push	r27
     9d4:	ef 93       	push	r30
     9d6:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9d8:	80 91 78 00 	lds	r24, 0x0078
     9dc:	80 93 a5 08 	sts	0x08A5, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9e0:	80 91 79 00 	lds	r24, 0x0079
     9e4:	80 93 a6 08 	sts	0x08A6, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9e8:	20 e0       	ldi	r18, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	60 e0       	ldi	r22, 0x00	; 0
     9f0:	70 e0       	ldi	r23, 0x00	; 0
     9f2:	80 91 a9 08 	lds	r24, 0x08A9
     9f6:	90 91 aa 08 	lds	r25, 0x08AA
     9fa:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <xQueueGenericSendFromISR>
}
     9fe:	ff 91       	pop	r31
     a00:	ef 91       	pop	r30
     a02:	bf 91       	pop	r27
     a04:	af 91       	pop	r26
     a06:	9f 91       	pop	r25
     a08:	8f 91       	pop	r24
     a0a:	7f 91       	pop	r23
     a0c:	6f 91       	pop	r22
     a0e:	5f 91       	pop	r21
     a10:	4f 91       	pop	r20
     a12:	3f 91       	pop	r19
     a14:	2f 91       	pop	r18
     a16:	0f 90       	pop	r0
     a18:	0b be       	out	0x3b, r0	; 59
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0
     a20:	1f 90       	pop	r1
     a22:	18 95       	reti

00000a24 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a24:	8f e8       	ldi	r24, 0x8F	; 143
     a26:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a2a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a34:	43 e0       	ldi	r20, 0x03	; 3
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	13 d7       	rcall	.+3622   	; 0x1862 <xQueueGenericCreate>
     a3c:	90 93 aa 08 	sts	0x08AA, r25
     a40:	80 93 a9 08 	sts	0x08A9, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a44:	81 e0       	ldi	r24, 0x01	; 1
     a46:	cd d7       	rcall	.+3994   	; 0x19e2 <xQueueCreateMutex>
     a48:	90 93 a8 08 	sts	0x08A8, r25
     a4c:	80 93 a7 08 	sts	0x08A7, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	40 e0       	ldi	r20, 0x00	; 0
     a54:	50 e0       	ldi	r21, 0x00	; 0
     a56:	60 e0       	ldi	r22, 0x00	; 0
     a58:	70 e0       	ldi	r23, 0x00	; 0
     a5a:	30 c7       	rjmp	.+3680   	; 0x18bc <xQueueGenericSend>
     a5c:	08 95       	ret

00000a5e <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a5e:	cf 93       	push	r28
     a60:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a62:	20 e0       	ldi	r18, 0x00	; 0
     a64:	4f ef       	ldi	r20, 0xFF	; 255
     a66:	5f ef       	ldi	r21, 0xFF	; 255
     a68:	60 e0       	ldi	r22, 0x00	; 0
     a6a:	70 e0       	ldi	r23, 0x00	; 0
     a6c:	80 91 a7 08 	lds	r24, 0x08A7
     a70:	90 91 a8 08 	lds	r25, 0x08A8
     a74:	0e 94 56 0d 	call	0x1aac	; 0x1aac <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a78:	ec e7       	ldi	r30, 0x7C	; 124
     a7a:	f0 e0       	ldi	r31, 0x00	; 0
     a7c:	80 81       	ld	r24, Z
     a7e:	9c 2f       	mov	r25, r28
     a80:	9f 71       	andi	r25, 0x1F	; 31
     a82:	80 76       	andi	r24, 0x60	; 96
     a84:	89 2b       	or	r24, r25
     a86:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a88:	eb e7       	ldi	r30, 0x7B	; 123
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	20 81       	ld	r18, Z
     a8e:	c0 72       	andi	r28, 0x20	; 32
     a90:	8c 2f       	mov	r24, r28
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	95 95       	asr	r25
     a96:	87 95       	ror	r24
     a98:	95 95       	asr	r25
     a9a:	87 95       	ror	r24
     a9c:	92 2f       	mov	r25, r18
     a9e:	90 76       	andi	r25, 0x60	; 96
     aa0:	89 2b       	or	r24, r25
     aa2:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     aa4:	ea e7       	ldi	r30, 0x7A	; 122
     aa6:	f0 e0       	ldi	r31, 0x00	; 0
     aa8:	80 81       	ld	r24, Z
     aaa:	80 64       	ori	r24, 0x40	; 64
     aac:	80 83       	st	Z, r24
}
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ab6:	20 e0       	ldi	r18, 0x00	; 0
     ab8:	4f ef       	ldi	r20, 0xFF	; 255
     aba:	5f ef       	ldi	r21, 0xFF	; 255
     abc:	60 e0       	ldi	r22, 0x00	; 0
     abe:	70 e0       	ldi	r23, 0x00	; 0
     ac0:	80 91 a9 08 	lds	r24, 0x08A9
     ac4:	90 91 aa 08 	lds	r25, 0x08AA
     ac8:	f1 d7       	rcall	.+4066   	; 0x1aac <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     aca:	c0 91 a6 08 	lds	r28, 0x08A6
     ace:	c3 70       	andi	r28, 0x03	; 3
     ad0:	d0 e0       	ldi	r29, 0x00	; 0
     ad2:	dc 2f       	mov	r29, r28
     ad4:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ad6:	80 91 a5 08 	lds	r24, 0x08A5
     ada:	c8 0f       	add	r28, r24
     adc:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     ade:	20 e0       	ldi	r18, 0x00	; 0
     ae0:	40 e0       	ldi	r20, 0x00	; 0
     ae2:	50 e0       	ldi	r21, 0x00	; 0
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	70 e0       	ldi	r23, 0x00	; 0
     ae8:	80 91 a7 08 	lds	r24, 0x08A7
     aec:	90 91 a8 08 	lds	r25, 0x08A8
     af0:	e5 d6       	rcall	.+3530   	; 0x18bc <xQueueGenericSend>
	
	return adcReading;
     af2:	ce 01       	movw	r24, r28
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     afa:	cf 93       	push	r28
     afc:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     afe:	af df       	rcall	.-162    	; 0xa5e <myADC_startADC>
	return myADC_readADC(channel);
     b00:	8c 2f       	mov	r24, r28
     b02:	d7 df       	rcall	.-82     	; 0xab2 <myADC_readADC>
}
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b08:	9c 01       	movw	r18, r24
     b0a:	29 5f       	subi	r18, 0xF9	; 249
     b0c:	3f 4f       	sbci	r19, 0xFF	; 255
     b0e:	26 17       	cp	r18, r22
     b10:	37 07       	cpc	r19, r23
     b12:	44 f0       	brlt	.+16     	; 0xb24 <detectStairs+0x1c>
     b14:	2e 50       	subi	r18, 0x0E	; 14
     b16:	31 09       	sbc	r19, r1
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	62 17       	cp	r22, r18
     b1c:	73 07       	cpc	r23, r19
     b1e:	1c f0       	brlt	.+6      	; 0xb26 <detectStairs+0x1e>
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	08 95       	ret
	{
		return 1; // stairs found
     b24:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b26:	08 95       	ret

00000b28 <cheatPrintAll>:
	}
}


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     b28:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     b2a:	85 e0       	ldi	r24, 0x05	; 5
     b2c:	db 01       	movw	r26, r22
     b2e:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     b30:	86 e4       	ldi	r24, 0x46	; 70
     b32:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     b34:	8c e4       	ldi	r24, 0x4C	; 76
     b36:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     b38:	82 e5       	ldi	r24, 0x52	; 82
     b3a:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     b3c:	82 e4       	ldi	r24, 0x42	; 66
     b3e:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     b40:	84 e5       	ldi	r24, 0x54	; 84
     b42:	84 83       	std	Z+4, r24	; 0x04
     b44:	08 95       	ret

00000b46 <possibleStairs>:
}

// detect possibleStairs infront 
char possibleStairs(int frontSonar, int topSonar)
{
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
     b46:	c2 97       	sbiw	r24, 0x32	; 50
     b48:	44 f4       	brge	.+16     	; 0xb5a <possibleStairs+0x14>
     b4a:	61 55       	subi	r22, 0x51	; 81
     b4c:	71 09       	sbc	r23, r1
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	6d 31       	cpi	r22, 0x1D	; 29
     b52:	71 05       	cpc	r23, r1
     b54:	18 f0       	brcs	.+6      	; 0xb5c <possibleStairs+0x16>
     b56:	80 e0       	ldi	r24, 0x00	; 0
     b58:	08 95       	ret
		return 1;
	else 
		return 0;
     b5a:	80 e0       	ldi	r24, 0x00	; 0
	
}
     b5c:	08 95       	ret

00000b5e <obstacleAvoidance>:
}


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int topSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b5e:	cf 92       	push	r12
     b60:	df 92       	push	r13
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	0f 93       	push	r16
     b68:	1f 93       	push	r17
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	8a 01       	movw	r16, r20
     b70:	69 01       	movw	r12, r18
     b72:	e7 01       	movw	r28, r14
	
	if(deviceBlocked[BTM_DEVICE])
     b74:	2b 81       	ldd	r18, Y+3	; 0x03
     b76:	22 23       	and	r18, r18
     b78:	39 f0       	breq	.+14     	; 0xb88 <obstacleAvoidance+0x2a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b7a:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b7c:	e2 e0       	ldi	r30, 0x02	; 2
     b7e:	f1 e0       	ldi	r31, 0x01	; 1
     b80:	80 81       	ld	r24, Z
     b82:	80 61       	ori	r24, 0x10	; 16
     b84:	80 83       	st	Z, r24
     b86:	64 c0       	rjmp	.+200    	; 0xc50 <obstacleAvoidance+0xf2>
	}
	else if( (deviceBlocked[FRONT_DEVICE] && (!possibleStairs(frontSonar, topSonar))) || deviceBlocked[TOP_DEVICE])
     b88:	28 81       	ld	r18, Y
     b8a:	22 23       	and	r18, r18
     b8c:	19 f0       	breq	.+6      	; 0xb94 <obstacleAvoidance+0x36>
     b8e:	db df       	rcall	.-74     	; 0xb46 <possibleStairs>
     b90:	88 23       	and	r24, r24
     b92:	19 f0       	breq	.+6      	; 0xb9a <obstacleAvoidance+0x3c>
     b94:	8c 81       	ldd	r24, Y+4	; 0x04
     b96:	88 23       	and	r24, r24
     b98:	e1 f1       	breq	.+120    	; 0xc12 <obstacleAvoidance+0xb4>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	81 11       	cpse	r24, r1
     b9e:	1d c0       	rjmp	.+58     	; 0xbda <obstacleAvoidance+0x7c>
     ba0:	8a 81       	ldd	r24, Y+2	; 0x02
     ba2:	81 11       	cpse	r24, r1
     ba4:	2a c0       	rjmp	.+84     	; 0xbfa <obstacleAvoidance+0x9c>
		{
			
			leftSonar -= LEFT_POSITIONAL_OFFSET;  // left sonar reading is now on approx ...
     ba6:	04 51       	subi	r16, 0x14	; 20
     ba8:	11 09       	sbc	r17, r1
			
			// both not blocked... so select side that have more range... (if both close... left safer to turn - see product)
				if(rightSonar > leftSonar && (rightSonar - leftSonar > INDISTINGUISHABLE_RANGE)) // if right sonar greater than....
     baa:	0c 15       	cp	r16, r12
     bac:	1d 05       	cpc	r17, r13
     bae:	64 f4       	brge	.+24     	; 0xbc8 <obstacleAvoidance+0x6a>
     bb0:	c6 01       	movw	r24, r12
     bb2:	80 1b       	sub	r24, r16
     bb4:	91 0b       	sbc	r25, r17
     bb6:	07 97       	sbiw	r24, 0x07	; 7
     bb8:	3c f0       	brlt	.+14     	; 0xbc8 <obstacleAvoidance+0x6a>
				{
					MOTOR_LEFT_STOP();
     bba:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     bbc:	e2 e0       	ldi	r30, 0x02	; 2
     bbe:	f1 e0       	ldi	r31, 0x01	; 1
     bc0:	80 81       	ld	r24, Z
     bc2:	80 61       	ori	r24, 0x10	; 16
     bc4:	80 83       	st	Z, r24
     bc6:	06 c0       	rjmp	.+12     	; 0xbd4 <obstacleAvoidance+0x76>
				}
				else 
				{
					MOTOR_LEFT_START();
     bc8:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     bca:	e2 e0       	ldi	r30, 0x02	; 2
     bcc:	f1 e0       	ldi	r31, 0x01	; 1
     bce:	80 81       	ld	r24, Z
     bd0:	8f 7e       	andi	r24, 0xEF	; 239
     bd2:	80 83       	st	Z, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     bd4:	89 81       	ldd	r24, Y+1	; 0x01
     bd6:	88 23       	and	r24, r24
     bd8:	c1 f1       	breq	.+112    	; 0xc4a <obstacleAvoidance+0xec>
     bda:	8a 81       	ldd	r24, Y+2	; 0x02
     bdc:	81 11       	cpse	r24, r1
     bde:	38 c0       	rjmp	.+112    	; 0xc50 <obstacleAvoidance+0xf2>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     be0:	c0 1a       	sub	r12, r16
     be2:	d1 0a       	sbc	r13, r17
     be4:	87 e0       	ldi	r24, 0x07	; 7
     be6:	c8 16       	cp	r12, r24
     be8:	d1 04       	cpc	r13, r1
     bea:	94 f1       	brlt	.+100    	; 0xc50 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_STOP();
     bec:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     bee:	e2 e0       	ldi	r30, 0x02	; 2
     bf0:	f1 e0       	ldi	r31, 0x01	; 1
     bf2:	80 81       	ld	r24, Z
     bf4:	80 61       	ori	r24, 0x10	; 16
     bf6:	80 83       	st	Z, r24
     bf8:	2b c0       	rjmp	.+86     	; 0xc50 <obstacleAvoidance+0xf2>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     bfa:	0c 19       	sub	r16, r12
     bfc:	1d 09       	sbc	r17, r13
     bfe:	07 30       	cpi	r16, 0x07	; 7
     c00:	11 05       	cpc	r17, r1
     c02:	34 f1       	brlt	.+76     	; 0xc50 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_START();
     c04:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     c06:	e2 e0       	ldi	r30, 0x02	; 2
     c08:	f1 e0       	ldi	r31, 0x01	; 1
     c0a:	80 81       	ld	r24, Z
     c0c:	8f 7e       	andi	r24, 0xEF	; 239
     c0e:	80 83       	st	Z, r24
     c10:	1f c0       	rjmp	.+62     	; 0xc50 <obstacleAvoidance+0xf2>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     c12:	03 32       	cpi	r16, 0x23	; 35
     c14:	11 05       	cpc	r17, r1
     c16:	3c f4       	brge	.+14     	; 0xc26 <obstacleAvoidance+0xc8>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     c18:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     c1a:	e2 e0       	ldi	r30, 0x02	; 2
     c1c:	f1 e0       	ldi	r31, 0x01	; 1
     c1e:	80 81       	ld	r24, Z
     c20:	80 61       	ori	r24, 0x10	; 16
     c22:	80 83       	st	Z, r24
     c24:	15 c0       	rjmp	.+42     	; 0xc50 <obstacleAvoidance+0xf2>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     c26:	84 e1       	ldi	r24, 0x14	; 20
     c28:	c8 16       	cp	r12, r24
     c2a:	d1 04       	cpc	r13, r1
     c2c:	3c f4       	brge	.+14     	; 0xc3c <obstacleAvoidance+0xde>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     c2e:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c30:	e2 e0       	ldi	r30, 0x02	; 2
     c32:	f1 e0       	ldi	r31, 0x01	; 1
     c34:	80 81       	ld	r24, Z
     c36:	8f 7e       	andi	r24, 0xEF	; 239
     c38:	80 83       	st	Z, r24
     c3a:	0a c0       	rjmp	.+20     	; 0xc50 <obstacleAvoidance+0xf2>
	}
	else
	{
			MOTOR_LEFT_STOP();
     c3c:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c3e:	e2 e0       	ldi	r30, 0x02	; 2
     c40:	f1 e0       	ldi	r31, 0x01	; 1
     c42:	80 81       	ld	r24, Z
     c44:	8f 7e       	andi	r24, 0xEF	; 239
     c46:	80 83       	st	Z, r24
     c48:	03 c0       	rjmp	.+6      	; 0xc50 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     c4a:	8a 81       	ldd	r24, Y+2	; 0x02
     c4c:	81 11       	cpse	r24, r1
     c4e:	d5 cf       	rjmp	.-86     	; 0xbfa <obstacleAvoidance+0x9c>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	1f 91       	pop	r17
     c56:	0f 91       	pop	r16
     c58:	ff 90       	pop	r15
     c5a:	ef 90       	pop	r14
     c5c:	df 90       	pop	r13
     c5e:	cf 90       	pop	r12
     c60:	08 95       	ret

00000c62 <obstacleDetection>:
}

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c62:	9f 92       	push	r9
     c64:	af 92       	push	r10
     c66:	bf 92       	push	r11
     c68:	cf 92       	push	r12
     c6a:	df 92       	push	r13
     c6c:	ef 92       	push	r14
     c6e:	ff 92       	push	r15
     c70:	0f 93       	push	r16
     c72:	1f 93       	push	r17
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
     c78:	96 2e       	mov	r9, r22
     c7a:	ea 01       	movw	r28, r20
     c7c:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c7e:	c2 97       	sbiw	r24, 0x32	; 50
     c80:	1c f4       	brge	.+6      	; 0xc88 <obstacleDetection+0x26>
	{
		obstacleDetected ++;
     c82:	93 94       	inc	r9
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c84:	86 e4       	ldi	r24, 0x46	; 70
     c86:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c88:	23 32       	cpi	r18, 0x23	; 35
     c8a:	31 05       	cpc	r19, r1
     c8c:	1c f4       	brge	.+6      	; 0xc94 <obstacleDetection+0x32>
	{
		obstacleDetected ++;
     c8e:	93 94       	inc	r9
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c90:	8c e4       	ldi	r24, 0x4C	; 76
     c92:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c94:	0e 31       	cpi	r16, 0x1E	; 30
     c96:	11 05       	cpc	r17, r1
     c98:	1c f4       	brge	.+6      	; 0xca0 <obstacleDetection+0x3e>
	{
		obstacleDetected++;
     c9a:	93 94       	inc	r9
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c9c:	82 e5       	ldi	r24, 0x52	; 82
     c9e:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     ca0:	c6 01       	movw	r24, r12
     ca2:	32 df       	rcall	.-412    	; 0xb08 <detectStairs>
     ca4:	88 23       	and	r24, r24
     ca6:	19 f0       	breq	.+6      	; 0xcae <obstacleDetection+0x4c>
	{
		obstacleDetected++;
     ca8:	93 94       	inc	r9
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     caa:	82 e4       	ldi	r24, 0x42	; 66
     cac:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     cae:	87 e3       	ldi	r24, 0x37	; 55
     cb0:	e8 16       	cp	r14, r24
     cb2:	f1 04       	cpc	r15, r1
     cb4:	1c f4       	brge	.+6      	; 0xcbc <obstacleDetection+0x5a>
	{
		obstacleDetected++;
     cb6:	93 94       	inc	r9
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     cb8:	84 e5       	ldi	r24, 0x54	; 84
     cba:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     cbc:	89 2d       	mov	r24, r9
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	08 95       	ret

00000cd6 <mySharpIR_Read>:
#include <stdint.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     cd6:	11 df       	rcall	.-478    	; 0xafa <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cd8:	bc 01       	movw	r22, r24
     cda:	88 27       	eor	r24, r24
     cdc:	77 fd       	sbrc	r23, 7
     cde:	80 95       	com	r24
     ce0:	98 2f       	mov	r25, r24
     ce2:	0e 94 9e 14 	call	0x293c	; 0x293c <__floatsisf>
     ce6:	29 e2       	ldi	r18, 0x29	; 41
     ce8:	3c e5       	ldi	r19, 0x5C	; 92
     cea:	4f e6       	ldi	r20, 0x6F	; 111
     cec:	5f eb       	ldi	r21, 0xBF	; 191
     cee:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <pow>
     cf2:	22 e5       	ldi	r18, 0x52	; 82
     cf4:	38 e6       	ldi	r19, 0x68	; 104
     cf6:	46 e2       	ldi	r20, 0x26	; 38
     cf8:	56 e4       	ldi	r21, 0x46	; 70
     cfa:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <__mulsf3>
     cfe:	20 e0       	ldi	r18, 0x00	; 0
     d00:	30 e0       	ldi	r19, 0x00	; 0
     d02:	40 e2       	ldi	r20, 0x20	; 32
     d04:	51 e4       	ldi	r21, 0x41	; 65
     d06:	0e 94 06 14 	call	0x280c	; 0x280c <__subsf3>
     d0a:	0e 94 6b 14 	call	0x28d6	; 0x28d6 <__fixsfsi>
     d0e:	cb 01       	movw	r24, r22
     d10:	68 3e       	cpi	r22, 0xE8	; 232
     d12:	23 e0       	ldi	r18, 0x03	; 3
     d14:	72 07       	cpc	r23, r18
     d16:	14 f0       	brlt	.+4      	; 0xd1c <mySharpIR_Read+0x46>
     d18:	87 ee       	ldi	r24, 0xE7	; 231
     d1a:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     d1c:	08 95       	ret

00000d1e <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d1e:	fb 01       	movw	r30, r22
     d20:	20 81       	ld	r18, Z
     d22:	31 81       	ldd	r19, Z+1	; 0x01
     d24:	50 e0       	ldi	r21, 0x00	; 0
     d26:	b9 01       	movw	r22, r18
     d28:	64 0f       	add	r22, r20
     d2a:	75 1f       	adc	r23, r21
     d2c:	68 17       	cp	r22, r24
     d2e:	79 07       	cpc	r23, r25
     d30:	4c f0       	brlt	.+18     	; 0xd44 <checkWithinRange+0x26>
     d32:	24 1b       	sub	r18, r20
     d34:	35 0b       	sbc	r19, r21
     d36:	41 e0       	ldi	r20, 0x01	; 1
     d38:	82 17       	cp	r24, r18
     d3a:	93 07       	cpc	r25, r19
     d3c:	0c f0       	brlt	.+2      	; 0xd40 <checkWithinRange+0x22>
     d3e:	40 e0       	ldi	r20, 0x00	; 0
     d40:	84 2f       	mov	r24, r20
     d42:	08 95       	ret
     d44:	81 e0       	ldi	r24, 0x01	; 1
}
     d46:	08 95       	ret

00000d48 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	8c 01       	movw	r16, r24
     d52:	eb 01       	movw	r28, r22
	static uint8_t i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     d54:	45 e0       	ldi	r20, 0x05	; 5
     d56:	bc 01       	movw	r22, r24
     d58:	ce 01       	movw	r24, r28
     d5a:	e1 df       	rcall	.-62     	; 0xd1e <checkWithinRange>
     d5c:	88 23       	and	r24, r24
     d5e:	29 f0       	breq	.+10     	; 0xd6a <mySharpIR_ReCalibrate+0x22>
     d60:	80 91 1d 08 	lds	r24, 0x081D
     d64:	81 11       	cpse	r24, r1
     d66:	0a c0       	rjmp	.+20     	; 0xd7c <mySharpIR_ReCalibrate+0x34>
     d68:	3a c0       	rjmp	.+116    	; 0xdde <mySharpIR_ReCalibrate+0x96>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     d6a:	80 91 1d 08 	lds	r24, 0x081D
     d6e:	81 11       	cpse	r24, r1
     d70:	05 c0       	rjmp	.+10     	; 0xd7c <mySharpIR_ReCalibrate+0x34>
	{
		checkReading[0] = reading;
     d72:	d0 93 1a 08 	sts	0x081A, r29
     d76:	c0 93 19 08 	sts	0x0819, r28
     d7a:	2c c0       	rjmp	.+88     	; 0xdd4 <mySharpIR_ReCalibrate+0x8c>
	}
	else if (i == CALIBRATE_COUNT/2)
     d7c:	84 36       	cpi	r24, 0x64	; 100
     d7e:	99 f4       	brne	.+38     	; 0xda6 <mySharpIR_ReCalibrate+0x5e>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d80:	45 e0       	ldi	r20, 0x05	; 5
     d82:	69 e1       	ldi	r22, 0x19	; 25
     d84:	78 e0       	ldi	r23, 0x08	; 8
     d86:	ce 01       	movw	r24, r28
     d88:	ca df       	rcall	.-108    	; 0xd1e <checkWithinRange>
     d8a:	88 23       	and	r24, r24
     d8c:	39 f0       	breq	.+14     	; 0xd9c <mySharpIR_ReCalibrate+0x54>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d8e:	d0 93 1a 08 	sts	0x081A, r29
     d92:	c0 93 19 08 	sts	0x0819, r28
			i = 0; // reset to count...
     d96:	10 92 1d 08 	sts	0x081D, r1
     d9a:	1c c0       	rjmp	.+56     	; 0xdd4 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d9c:	d0 93 1c 08 	sts	0x081C, r29
     da0:	c0 93 1b 08 	sts	0x081B, r28
     da4:	17 c0       	rjmp	.+46     	; 0xdd4 <mySharpIR_ReCalibrate+0x8c>
		}
	}
	else if (i == CALIBRATE_COUNT)
     da6:	88 3c       	cpi	r24, 0xC8	; 200
     da8:	a9 f4       	brne	.+42     	; 0xdd4 <mySharpIR_ReCalibrate+0x8c>
	{
		i = 0; // reset to count..
     daa:	10 92 1d 08 	sts	0x081D, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     dae:	45 e0       	ldi	r20, 0x05	; 5
     db0:	69 e1       	ldi	r22, 0x19	; 25
     db2:	78 e0       	ldi	r23, 0x08	; 8
     db4:	ce 01       	movw	r24, r28
     db6:	b3 df       	rcall	.-154    	; 0xd1e <checkWithinRange>
     db8:	88 23       	and	r24, r24
     dba:	29 f0       	breq	.+10     	; 0xdc6 <mySharpIR_ReCalibrate+0x7e>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     dbc:	d0 93 1a 08 	sts	0x081A, r29
     dc0:	c0 93 19 08 	sts	0x0819, r28
     dc4:	07 c0       	rjmp	.+14     	; 0xdd4 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     dc6:	80 91 19 08 	lds	r24, 0x0819
     dca:	90 91 1a 08 	lds	r25, 0x081A
     dce:	f8 01       	movw	r30, r16
     dd0:	91 83       	std	Z+1, r25	; 0x01
     dd2:	80 83       	st	Z, r24
		}
	}
	
	i++;
     dd4:	80 91 1d 08 	lds	r24, 0x081D
     dd8:	8f 5f       	subi	r24, 0xFF	; 255
     dda:	80 93 1d 08 	sts	0x081D, r24
}
     dde:	df 91       	pop	r29
     de0:	cf 91       	pop	r28
     de2:	1f 91       	pop	r17
     de4:	0f 91       	pop	r16
     de6:	08 95       	ret

00000de8 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     de8:	90 93 b0 08 	sts	0x08B0, r25
     dec:	80 93 af 08 	sts	0x08AF, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     df0:	fc 01       	movw	r30, r24
     df2:	80 81       	ld	r24, Z
     df4:	91 81       	ldd	r25, Z+1	; 0x01
     df6:	0e 94 50 12 	call	0x24a0	; 0x24a0 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     dfa:	43 e0       	ldi	r20, 0x03	; 3
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	30 d5       	rcall	.+2656   	; 0x1862 <xQueueGenericCreate>
     e02:	90 93 ac 08 	sts	0x08AC, r25
     e06:	80 93 ab 08 	sts	0x08AB, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     e0a:	43 e0       	ldi	r20, 0x03	; 3
     e0c:	60 e0       	ldi	r22, 0x00	; 0
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	28 d5       	rcall	.+2640   	; 0x1862 <xQueueGenericCreate>
     e12:	90 93 ae 08 	sts	0x08AE, r25
     e16:	80 93 ad 08 	sts	0x08AD, r24
     e1a:	08 95       	ret

00000e1c <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e1c:	86 b5       	in	r24, 0x26	; 38
}
     e1e:	08 95       	ret

00000e20 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e20:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     e22:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e24:	9c 01       	movw	r18, r24
     e26:	99 23       	and	r25, r25
     e28:	14 f4       	brge	.+4      	; 0xe2e <myTimer_DelayMicro+0xe>
     e2a:	2d 5f       	subi	r18, 0xFD	; 253
     e2c:	3f 4f       	sbci	r19, 0xFF	; 255
     e2e:	35 95       	asr	r19
     e30:	27 95       	ror	r18
     e32:	35 95       	asr	r19
     e34:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     e36:	24 0f       	add	r18, r20
     e38:	35 1f       	adc	r19, r21
     e3a:	30 93 04 02 	sts	0x0204, r19
     e3e:	20 93 03 02 	sts	0x0203, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e42:	e0 91 af 08 	lds	r30, 0x08AF
     e46:	f0 91 b0 08 	lds	r31, 0x08B0
     e4a:	80 81       	ld	r24, Z
     e4c:	91 81       	ldd	r25, Z+1	; 0x01
     e4e:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e52:	20 e0       	ldi	r18, 0x00	; 0
     e54:	42 e0       	ldi	r20, 0x02	; 2
     e56:	50 e0       	ldi	r21, 0x00	; 0
     e58:	60 e0       	ldi	r22, 0x00	; 0
     e5a:	70 e0       	ldi	r23, 0x00	; 0
     e5c:	80 91 ab 08 	lds	r24, 0x08AB
     e60:	90 91 ac 08 	lds	r25, 0x08AC
     e64:	23 c6       	rjmp	.+3142   	; 0x1aac <xQueueGenericReceive>
     e66:	08 95       	ret

00000e68 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e68:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     e6a:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e6c:	9c 01       	movw	r18, r24
     e6e:	99 23       	and	r25, r25
     e70:	14 f4       	brge	.+4      	; 0xe76 <myTimer_DelayMicro2+0xe>
     e72:	2d 5f       	subi	r18, 0xFD	; 253
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	35 95       	asr	r19
     e78:	27 95       	ror	r18
     e7a:	35 95       	asr	r19
     e7c:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     e7e:	24 0f       	add	r18, r20
     e80:	35 1f       	adc	r19, r21
     e82:	30 93 02 02 	sts	0x0202, r19
     e86:	20 93 01 02 	sts	0x0201, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e8a:	e0 91 af 08 	lds	r30, 0x08AF
     e8e:	f0 91 b0 08 	lds	r31, 0x08B0
     e92:	80 81       	ld	r24, Z
     e94:	91 81       	ldd	r25, Z+1	; 0x01
     e96:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e9a:	20 e0       	ldi	r18, 0x00	; 0
     e9c:	42 e0       	ldi	r20, 0x02	; 2
     e9e:	50 e0       	ldi	r21, 0x00	; 0
     ea0:	60 e0       	ldi	r22, 0x00	; 0
     ea2:	70 e0       	ldi	r23, 0x00	; 0
     ea4:	80 91 ad 08 	lds	r24, 0x08AD
     ea8:	90 91 ae 08 	lds	r25, 0x08AE
     eac:	ff c5       	rjmp	.+3070   	; 0x1aac <xQueueGenericReceive>
     eae:	08 95       	ret

00000eb0 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     eb0:	cf 93       	push	r28
     eb2:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     eb4:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     eb6:	c1 11       	cpse	r28, r1
     eb8:	22 c0       	rjmp	.+68     	; 0xefe <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     eba:	80 91 03 02 	lds	r24, 0x0203
     ebe:	90 91 04 02 	lds	r25, 0x0204
     ec2:	88 38       	cpi	r24, 0x88	; 136
     ec4:	93 41       	sbci	r25, 0x13	; 19
     ec6:	51 f0       	breq	.+20     	; 0xedc <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     ec8:	80 91 03 02 	lds	r24, 0x0203
     ecc:	90 91 04 02 	lds	r25, 0x0204
     ed0:	8a 5f       	subi	r24, 0xFA	; 250
     ed2:	91 09       	sbc	r25, r1
     ed4:	90 93 04 02 	sts	0x0204, r25
     ed8:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     edc:	80 91 01 02 	lds	r24, 0x0201
     ee0:	90 91 02 02 	lds	r25, 0x0202
     ee4:	88 38       	cpi	r24, 0x88	; 136
     ee6:	93 41       	sbci	r25, 0x13	; 19
     ee8:	51 f0       	breq	.+20     	; 0xefe <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     eea:	80 91 01 02 	lds	r24, 0x0201
     eee:	90 91 02 02 	lds	r25, 0x0202
     ef2:	8a 5f       	subi	r24, 0xFA	; 250
     ef4:	91 09       	sbc	r25, r1
     ef6:	90 93 02 02 	sts	0x0202, r25
     efa:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     efe:	d0 e0       	ldi	r29, 0x00	; 0
     f00:	80 91 03 02 	lds	r24, 0x0203
     f04:	90 91 04 02 	lds	r25, 0x0204
     f08:	8c 17       	cp	r24, r28
     f0a:	9d 07       	cpc	r25, r29
     f0c:	84 f4       	brge	.+32     	; 0xf2e <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     f0e:	88 e8       	ldi	r24, 0x88	; 136
     f10:	93 e1       	ldi	r25, 0x13	; 19
     f12:	90 93 04 02 	sts	0x0204, r25
     f16:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     f1a:	20 e0       	ldi	r18, 0x00	; 0
     f1c:	40 e0       	ldi	r20, 0x00	; 0
     f1e:	50 e0       	ldi	r21, 0x00	; 0
     f20:	60 e0       	ldi	r22, 0x00	; 0
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	80 91 ab 08 	lds	r24, 0x08AB
     f28:	90 91 ac 08 	lds	r25, 0x08AC
     f2c:	c7 d4       	rcall	.+2446   	; 0x18bc <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     f2e:	80 91 01 02 	lds	r24, 0x0201
     f32:	90 91 02 02 	lds	r25, 0x0202
     f36:	8c 17       	cp	r24, r28
     f38:	9d 07       	cpc	r25, r29
     f3a:	84 f4       	brge	.+32     	; 0xf5c <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     f3c:	88 e8       	ldi	r24, 0x88	; 136
     f3e:	93 e1       	ldi	r25, 0x13	; 19
     f40:	90 93 02 02 	sts	0x0202, r25
     f44:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     f48:	20 e0       	ldi	r18, 0x00	; 0
     f4a:	40 e0       	ldi	r20, 0x00	; 0
     f4c:	50 e0       	ldi	r21, 0x00	; 0
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	70 e0       	ldi	r23, 0x00	; 0
     f52:	80 91 ad 08 	lds	r24, 0x08AD
     f56:	90 91 ae 08 	lds	r25, 0x08AE
     f5a:	b0 d4       	rcall	.+2400   	; 0x18bc <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     f5c:	80 91 03 02 	lds	r24, 0x0203
     f60:	90 91 04 02 	lds	r25, 0x0204
     f64:	88 38       	cpi	r24, 0x88	; 136
     f66:	93 41       	sbci	r25, 0x13	; 19
     f68:	79 f4       	brne	.+30     	; 0xf88 <myTimer_DelayChecker+0xd8>
     f6a:	80 91 01 02 	lds	r24, 0x0201
     f6e:	90 91 02 02 	lds	r25, 0x0202
     f72:	88 38       	cpi	r24, 0x88	; 136
     f74:	93 41       	sbci	r25, 0x13	; 19
     f76:	41 f4       	brne	.+16     	; 0xf88 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f78:	e0 91 af 08 	lds	r30, 0x08AF
     f7c:	f0 91 b0 08 	lds	r31, 0x08B0
     f80:	80 81       	ld	r24, Z
     f82:	91 81       	ldd	r25, Z+1	; 0x01
     f84:	0e 94 50 12 	call	0x24a0	; 0x24a0 <vTaskSuspend>
	}
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	08 95       	ret

00000f8e <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     f8e:	1f 92       	push	r1
     f90:	0f 92       	push	r0
     f92:	0f b6       	in	r0, 0x3f	; 63
     f94:	0f 92       	push	r0
     f96:	11 24       	eor	r1, r1
     f98:	0b b6       	in	r0, 0x3b	; 59
     f9a:	0f 92       	push	r0
     f9c:	2f 93       	push	r18
     f9e:	3f 93       	push	r19
     fa0:	4f 93       	push	r20
     fa2:	5f 93       	push	r21
     fa4:	6f 93       	push	r22
     fa6:	7f 93       	push	r23
     fa8:	8f 93       	push	r24
     faa:	9f 93       	push	r25
     fac:	af 93       	push	r26
     fae:	bf 93       	push	r27
     fb0:	ef 93       	push	r30
     fb2:	ff 93       	push	r31
     fb4:	60 91 ce 00 	lds	r22, 0x00CE
     fb8:	80 e4       	ldi	r24, 0x40	; 64
     fba:	99 e0       	ldi	r25, 0x09	; 9
     fbc:	43 d6       	rcall	.+3206   	; 0x1c44 <ringBufferPush>
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	40 e0       	ldi	r20, 0x00	; 0
     fc2:	50 e0       	ldi	r21, 0x00	; 0
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	70 e0       	ldi	r23, 0x00	; 0
     fc8:	80 91 26 08 	lds	r24, 0x0826
     fcc:	90 91 27 08 	lds	r25, 0x0827
     fd0:	33 d5       	rcall	.+2662   	; 0x1a38 <xQueueGenericSendFromISR>
     fd2:	80 e4       	ldi	r24, 0x40	; 64
     fd4:	99 e0       	ldi	r25, 0x09	; 9
     fd6:	4d d6       	rcall	.+3226   	; 0x1c72 <ringBufferFull>
     fd8:	ff 91       	pop	r31
     fda:	ef 91       	pop	r30
     fdc:	bf 91       	pop	r27
     fde:	af 91       	pop	r26
     fe0:	9f 91       	pop	r25
     fe2:	8f 91       	pop	r24
     fe4:	7f 91       	pop	r23
     fe6:	6f 91       	pop	r22
     fe8:	5f 91       	pop	r21
     fea:	4f 91       	pop	r20
     fec:	3f 91       	pop	r19
     fee:	2f 91       	pop	r18
     ff0:	0f 90       	pop	r0
     ff2:	0b be       	out	0x3b, r0	; 59
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	0f 90       	pop	r0
     ffa:	1f 90       	pop	r1
     ffc:	18 95       	reti

00000ffe <__vector_25>:
     ffe:	1f 92       	push	r1
    1000:	0f 92       	push	r0
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	0b b6       	in	r0, 0x3b	; 59
    100a:	0f 92       	push	r0
    100c:	2f 93       	push	r18
    100e:	3f 93       	push	r19
    1010:	4f 93       	push	r20
    1012:	5f 93       	push	r21
    1014:	6f 93       	push	r22
    1016:	7f 93       	push	r23
    1018:	8f 93       	push	r24
    101a:	9f 93       	push	r25
    101c:	af 93       	push	r26
    101e:	bf 93       	push	r27
    1020:	ef 93       	push	r30
    1022:	ff 93       	push	r31
    1024:	60 91 c6 00 	lds	r22, 0x00C6
    1028:	81 ed       	ldi	r24, 0xD1	; 209
    102a:	98 e0       	ldi	r25, 0x08	; 8
    102c:	0b d6       	rcall	.+3094   	; 0x1c44 <ringBufferPush>
    102e:	20 e0       	ldi	r18, 0x00	; 0
    1030:	40 e0       	ldi	r20, 0x00	; 0
    1032:	50 e0       	ldi	r21, 0x00	; 0
    1034:	60 e0       	ldi	r22, 0x00	; 0
    1036:	70 e0       	ldi	r23, 0x00	; 0
    1038:	80 91 26 08 	lds	r24, 0x0826
    103c:	90 91 27 08 	lds	r25, 0x0827
    1040:	fb d4       	rcall	.+2550   	; 0x1a38 <xQueueGenericSendFromISR>
    1042:	81 ed       	ldi	r24, 0xD1	; 209
    1044:	98 e0       	ldi	r25, 0x08	; 8
    1046:	15 d6       	rcall	.+3114   	; 0x1c72 <ringBufferFull>
    1048:	ff 91       	pop	r31
    104a:	ef 91       	pop	r30
    104c:	bf 91       	pop	r27
    104e:	af 91       	pop	r26
    1050:	9f 91       	pop	r25
    1052:	8f 91       	pop	r24
    1054:	7f 91       	pop	r23
    1056:	6f 91       	pop	r22
    1058:	5f 91       	pop	r21
    105a:	4f 91       	pop	r20
    105c:	3f 91       	pop	r19
    105e:	2f 91       	pop	r18
    1060:	0f 90       	pop	r0
    1062:	0b be       	out	0x3b, r0	; 59
    1064:	0f 90       	pop	r0
    1066:	0f be       	out	0x3f, r0	; 63
    1068:	0f 90       	pop	r0
    106a:	1f 90       	pop	r1
    106c:	18 95       	reti

0000106e <__vector_37>:
    106e:	1f 92       	push	r1
    1070:	0f 92       	push	r0
    1072:	0f b6       	in	r0, 0x3f	; 63
    1074:	0f 92       	push	r0
    1076:	11 24       	eor	r1, r1
    1078:	0b b6       	in	r0, 0x3b	; 59
    107a:	0f 92       	push	r0
    107c:	2f 93       	push	r18
    107e:	3f 93       	push	r19
    1080:	4f 93       	push	r20
    1082:	5f 93       	push	r21
    1084:	6f 93       	push	r22
    1086:	7f 93       	push	r23
    1088:	8f 93       	push	r24
    108a:	9f 93       	push	r25
    108c:	af 93       	push	r26
    108e:	bf 93       	push	r27
    1090:	ef 93       	push	r30
    1092:	ff 93       	push	r31
    1094:	86 e3       	ldi	r24, 0x36	; 54
    1096:	99 e0       	ldi	r25, 0x09	; 9
    1098:	f3 d5       	rcall	.+3046   	; 0x1c80 <ringBufferNotEmpty>
    109a:	88 23       	and	r24, r24
    109c:	31 f0       	breq	.+12     	; 0x10aa <__vector_37+0x3c>
    109e:	86 e3       	ldi	r24, 0x36	; 54
    10a0:	99 e0       	ldi	r25, 0x09	; 9
    10a2:	be d5       	rcall	.+2940   	; 0x1c20 <ringBufferPop>
    10a4:	80 93 ce 00 	sts	0x00CE, r24
    10a8:	0f c0       	rjmp	.+30     	; 0x10c8 <__vector_37+0x5a>
    10aa:	e9 ec       	ldi	r30, 0xC9	; 201
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	8f 7d       	andi	r24, 0xDF	; 223
    10b2:	80 83       	st	Z, r24
    10b4:	20 e0       	ldi	r18, 0x00	; 0
    10b6:	40 e0       	ldi	r20, 0x00	; 0
    10b8:	50 e0       	ldi	r21, 0x00	; 0
    10ba:	60 e0       	ldi	r22, 0x00	; 0
    10bc:	70 e0       	ldi	r23, 0x00	; 0
    10be:	80 91 1e 08 	lds	r24, 0x081E
    10c2:	90 91 1f 08 	lds	r25, 0x081F
    10c6:	b8 d4       	rcall	.+2416   	; 0x1a38 <xQueueGenericSendFromISR>
    10c8:	ff 91       	pop	r31
    10ca:	ef 91       	pop	r30
    10cc:	bf 91       	pop	r27
    10ce:	af 91       	pop	r26
    10d0:	9f 91       	pop	r25
    10d2:	8f 91       	pop	r24
    10d4:	7f 91       	pop	r23
    10d6:	6f 91       	pop	r22
    10d8:	5f 91       	pop	r21
    10da:	4f 91       	pop	r20
    10dc:	3f 91       	pop	r19
    10de:	2f 91       	pop	r18
    10e0:	0f 90       	pop	r0
    10e2:	0b be       	out	0x3b, r0	; 59
    10e4:	0f 90       	pop	r0
    10e6:	0f be       	out	0x3f, r0	; 63
    10e8:	0f 90       	pop	r0
    10ea:	1f 90       	pop	r1
    10ec:	18 95       	reti

000010ee <__vector_26>:
    10ee:	1f 92       	push	r1
    10f0:	0f 92       	push	r0
    10f2:	0f b6       	in	r0, 0x3f	; 63
    10f4:	0f 92       	push	r0
    10f6:	11 24       	eor	r1, r1
    10f8:	0b b6       	in	r0, 0x3b	; 59
    10fa:	0f 92       	push	r0
    10fc:	2f 93       	push	r18
    10fe:	3f 93       	push	r19
    1100:	4f 93       	push	r20
    1102:	5f 93       	push	r21
    1104:	6f 93       	push	r22
    1106:	7f 93       	push	r23
    1108:	8f 93       	push	r24
    110a:	9f 93       	push	r25
    110c:	af 93       	push	r26
    110e:	bf 93       	push	r27
    1110:	ef 93       	push	r30
    1112:	ff 93       	push	r31
    1114:	8b e3       	ldi	r24, 0x3B	; 59
    1116:	99 e0       	ldi	r25, 0x09	; 9
    1118:	b3 d5       	rcall	.+2918   	; 0x1c80 <ringBufferNotEmpty>
    111a:	88 23       	and	r24, r24
    111c:	31 f0       	breq	.+12     	; 0x112a <__vector_26+0x3c>
    111e:	8b e3       	ldi	r24, 0x3B	; 59
    1120:	99 e0       	ldi	r25, 0x09	; 9
    1122:	7e d5       	rcall	.+2812   	; 0x1c20 <ringBufferPop>
    1124:	80 93 c6 00 	sts	0x00C6, r24
    1128:	0f c0       	rjmp	.+30     	; 0x1148 <__vector_26+0x5a>
    112a:	e1 ec       	ldi	r30, 0xC1	; 193
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	8f 7d       	andi	r24, 0xDF	; 223
    1132:	80 83       	st	Z, r24
    1134:	20 e0       	ldi	r18, 0x00	; 0
    1136:	40 e0       	ldi	r20, 0x00	; 0
    1138:	50 e0       	ldi	r21, 0x00	; 0
    113a:	60 e0       	ldi	r22, 0x00	; 0
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	80 91 20 08 	lds	r24, 0x0820
    1142:	90 91 21 08 	lds	r25, 0x0821
    1146:	78 d4       	rcall	.+2288   	; 0x1a38 <xQueueGenericSendFromISR>
    1148:	ff 91       	pop	r31
    114a:	ef 91       	pop	r30
    114c:	bf 91       	pop	r27
    114e:	af 91       	pop	r26
    1150:	9f 91       	pop	r25
    1152:	8f 91       	pop	r24
    1154:	7f 91       	pop	r23
    1156:	6f 91       	pop	r22
    1158:	5f 91       	pop	r21
    115a:	4f 91       	pop	r20
    115c:	3f 91       	pop	r19
    115e:	2f 91       	pop	r18
    1160:	0f 90       	pop	r0
    1162:	0b be       	out	0x3b, r0	; 59
    1164:	0f 90       	pop	r0
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	0f 90       	pop	r0
    116a:	1f 90       	pop	r1
    116c:	18 95       	reti

0000116e <myUSART_USART0_Init>:
    116e:	10 92 c5 00 	sts	0x00C5, r1
    1172:	87 e6       	ldi	r24, 0x67	; 103
    1174:	80 93 c4 00 	sts	0x00C4, r24
    1178:	88 eb       	ldi	r24, 0xB8	; 184
    117a:	80 93 c1 00 	sts	0x00C1, r24
    117e:	86 e0       	ldi	r24, 0x06	; 6
    1180:	80 93 c2 00 	sts	0x00C2, r24
    1184:	40 e2       	ldi	r20, 0x20	; 32
    1186:	66 ef       	ldi	r22, 0xF6	; 246
    1188:	78 e0       	ldi	r23, 0x08	; 8
    118a:	81 ed       	ldi	r24, 0xD1	; 209
    118c:	98 e0       	ldi	r25, 0x08	; 8
    118e:	41 d5       	rcall	.+2690   	; 0x1c12 <ringBufferInit>
    1190:	40 e2       	ldi	r20, 0x20	; 32
    1192:	66 ed       	ldi	r22, 0xD6	; 214
    1194:	78 e0       	ldi	r23, 0x08	; 8
    1196:	8b e3       	ldi	r24, 0x3B	; 59
    1198:	99 e0       	ldi	r25, 0x09	; 9
    119a:	3b d5       	rcall	.+2678   	; 0x1c12 <ringBufferInit>
    119c:	43 e0       	ldi	r20, 0x03	; 3
    119e:	60 e0       	ldi	r22, 0x00	; 0
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	5f d3       	rcall	.+1726   	; 0x1862 <xQueueGenericCreate>
    11a4:	90 93 25 08 	sts	0x0825, r25
    11a8:	80 93 24 08 	sts	0x0824, r24
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	19 d4       	rcall	.+2098   	; 0x19e2 <xQueueCreateMutex>
    11b0:	90 93 21 08 	sts	0x0821, r25
    11b4:	80 93 20 08 	sts	0x0820, r24
    11b8:	08 95       	ret

000011ba <myUSART_USART1_Init>:
    11ba:	10 92 cd 00 	sts	0x00CD, r1
    11be:	87 e6       	ldi	r24, 0x67	; 103
    11c0:	80 93 cc 00 	sts	0x00CC, r24
    11c4:	88 eb       	ldi	r24, 0xB8	; 184
    11c6:	80 93 c9 00 	sts	0x00C9, r24
    11ca:	86 e0       	ldi	r24, 0x06	; 6
    11cc:	80 93 ca 00 	sts	0x00CA, r24
    11d0:	40 e2       	ldi	r20, 0x20	; 32
    11d2:	61 eb       	ldi	r22, 0xB1	; 177
    11d4:	78 e0       	ldi	r23, 0x08	; 8
    11d6:	80 e4       	ldi	r24, 0x40	; 64
    11d8:	99 e0       	ldi	r25, 0x09	; 9
    11da:	1b d5       	rcall	.+2614   	; 0x1c12 <ringBufferInit>
    11dc:	40 e2       	ldi	r20, 0x20	; 32
    11de:	66 e1       	ldi	r22, 0x16	; 22
    11e0:	79 e0       	ldi	r23, 0x09	; 9
    11e2:	86 e3       	ldi	r24, 0x36	; 54
    11e4:	99 e0       	ldi	r25, 0x09	; 9
    11e6:	15 d5       	rcall	.+2602   	; 0x1c12 <ringBufferInit>
    11e8:	43 e0       	ldi	r20, 0x03	; 3
    11ea:	60 e0       	ldi	r22, 0x00	; 0
    11ec:	81 e0       	ldi	r24, 0x01	; 1
    11ee:	39 d3       	rcall	.+1650   	; 0x1862 <xQueueGenericCreate>
    11f0:	90 93 27 08 	sts	0x0827, r25
    11f4:	80 93 26 08 	sts	0x0826, r24
    11f8:	43 e0       	ldi	r20, 0x03	; 3
    11fa:	60 e0       	ldi	r22, 0x00	; 0
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	31 d3       	rcall	.+1634   	; 0x1862 <xQueueGenericCreate>
    1200:	90 93 23 08 	sts	0x0823, r25
    1204:	80 93 22 08 	sts	0x0822, r24
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	eb d3       	rcall	.+2006   	; 0x19e2 <xQueueCreateMutex>
    120c:	90 93 1f 08 	sts	0x081F, r25
    1210:	80 93 1e 08 	sts	0x081E, r24
    1214:	08 95       	ret

00001216 <myUSART_transmitUSART0_c>:
    1216:	cf 93       	push	r28
    1218:	c8 2f       	mov	r28, r24
    121a:	20 e0       	ldi	r18, 0x00	; 0
    121c:	4f ef       	ldi	r20, 0xFF	; 255
    121e:	5f ef       	ldi	r21, 0xFF	; 255
    1220:	60 e0       	ldi	r22, 0x00	; 0
    1222:	70 e0       	ldi	r23, 0x00	; 0
    1224:	80 91 20 08 	lds	r24, 0x0820
    1228:	90 91 21 08 	lds	r25, 0x0821
    122c:	3f d4       	rcall	.+2174   	; 0x1aac <xQueueGenericReceive>
    122e:	8b e3       	ldi	r24, 0x3B	; 59
    1230:	99 e0       	ldi	r25, 0x09	; 9
    1232:	1f d5       	rcall	.+2622   	; 0x1c72 <ringBufferFull>
    1234:	81 11       	cpse	r24, r1
    1236:	fb cf       	rjmp	.-10     	; 0x122e <myUSART_transmitUSART0_c+0x18>
    1238:	6c 2f       	mov	r22, r28
    123a:	8b e3       	ldi	r24, 0x3B	; 59
    123c:	99 e0       	ldi	r25, 0x09	; 9
    123e:	02 d5       	rcall	.+2564   	; 0x1c44 <ringBufferPush>
    1240:	e1 ec       	ldi	r30, 0xC1	; 193
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	80 62       	ori	r24, 0x20	; 32
    1248:	80 83       	st	Z, r24
    124a:	e0 ec       	ldi	r30, 0xC0	; 192
    124c:	f0 e0       	ldi	r31, 0x00	; 0
    124e:	80 81       	ld	r24, Z
    1250:	80 64       	ori	r24, 0x40	; 64
    1252:	80 83       	st	Z, r24
    1254:	cf 91       	pop	r28
    1256:	08 95       	ret

00001258 <myUSART_transmitUSART1_c>:
    1258:	cf 93       	push	r28
    125a:	c8 2f       	mov	r28, r24
    125c:	20 e0       	ldi	r18, 0x00	; 0
    125e:	4f ef       	ldi	r20, 0xFF	; 255
    1260:	5f ef       	ldi	r21, 0xFF	; 255
    1262:	60 e0       	ldi	r22, 0x00	; 0
    1264:	70 e0       	ldi	r23, 0x00	; 0
    1266:	80 91 1e 08 	lds	r24, 0x081E
    126a:	90 91 1f 08 	lds	r25, 0x081F
    126e:	1e d4       	rcall	.+2108   	; 0x1aac <xQueueGenericReceive>
    1270:	86 e3       	ldi	r24, 0x36	; 54
    1272:	99 e0       	ldi	r25, 0x09	; 9
    1274:	fe d4       	rcall	.+2556   	; 0x1c72 <ringBufferFull>
    1276:	81 11       	cpse	r24, r1
    1278:	fb cf       	rjmp	.-10     	; 0x1270 <myUSART_transmitUSART1_c+0x18>
    127a:	6c 2f       	mov	r22, r28
    127c:	86 e3       	ldi	r24, 0x36	; 54
    127e:	99 e0       	ldi	r25, 0x09	; 9
    1280:	e1 d4       	rcall	.+2498   	; 0x1c44 <ringBufferPush>
    1282:	e9 ec       	ldi	r30, 0xC9	; 201
    1284:	f0 e0       	ldi	r31, 0x00	; 0
    1286:	80 81       	ld	r24, Z
    1288:	80 62       	ori	r24, 0x20	; 32
    128a:	80 83       	st	Z, r24
    128c:	e8 ec       	ldi	r30, 0xC8	; 200
    128e:	f0 e0       	ldi	r31, 0x00	; 0
    1290:	80 81       	ld	r24, Z
    1292:	80 64       	ori	r24, 0x40	; 64
    1294:	80 83       	st	Z, r24
    1296:	cf 91       	pop	r28
    1298:	08 95       	ret

0000129a <myUSART_transmitUSART1>:
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
    129e:	ec 01       	movw	r28, r24
    12a0:	88 81       	ld	r24, Y
    12a2:	88 23       	and	r24, r24
    12a4:	29 f0       	breq	.+10     	; 0x12b0 <myUSART_transmitUSART1+0x16>
    12a6:	21 96       	adiw	r28, 0x01	; 1
    12a8:	d7 df       	rcall	.-82     	; 0x1258 <myUSART_transmitUSART1_c>
    12aa:	89 91       	ld	r24, Y+
    12ac:	81 11       	cpse	r24, r1
    12ae:	fc cf       	rjmp	.-8      	; 0x12a8 <myUSART_transmitUSART1+0xe>
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	08 95       	ret

000012b6 <myUSART_transmitUSART0>:
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	ec 01       	movw	r28, r24
    12bc:	88 81       	ld	r24, Y
    12be:	88 23       	and	r24, r24
    12c0:	29 f0       	breq	.+10     	; 0x12cc <myUSART_transmitUSART0+0x16>
    12c2:	21 96       	adiw	r28, 0x01	; 1
    12c4:	a8 df       	rcall	.-176    	; 0x1216 <myUSART_transmitUSART0_c>
    12c6:	89 91       	ld	r24, Y+
    12c8:	81 11       	cpse	r24, r1
    12ca:	fc cf       	rjmp	.-8      	; 0x12c4 <myUSART_transmitUSART0+0xe>
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	08 95       	ret

000012d2 <myUSART_receiveUSART1>:
    12d2:	cf 93       	push	r28
    12d4:	20 e0       	ldi	r18, 0x00	; 0
    12d6:	4f ef       	ldi	r20, 0xFF	; 255
    12d8:	5f ef       	ldi	r21, 0xFF	; 255
    12da:	60 e0       	ldi	r22, 0x00	; 0
    12dc:	70 e0       	ldi	r23, 0x00	; 0
    12de:	80 91 26 08 	lds	r24, 0x0826
    12e2:	90 91 27 08 	lds	r25, 0x0827
    12e6:	e2 d3       	rcall	.+1988   	; 0x1aac <xQueueGenericReceive>
    12e8:	80 e4       	ldi	r24, 0x40	; 64
    12ea:	99 e0       	ldi	r25, 0x09	; 9
    12ec:	99 d4       	rcall	.+2354   	; 0x1c20 <ringBufferPop>
    12ee:	c8 2f       	mov	r28, r24
    12f0:	80 e4       	ldi	r24, 0x40	; 64
    12f2:	99 e0       	ldi	r25, 0x09	; 9
    12f4:	c5 d4       	rcall	.+2442   	; 0x1c80 <ringBufferNotEmpty>
    12f6:	88 23       	and	r24, r24
    12f8:	51 f0       	breq	.+20     	; 0x130e <myUSART_receiveUSART1+0x3c>
    12fa:	20 e0       	ldi	r18, 0x00	; 0
    12fc:	40 e0       	ldi	r20, 0x00	; 0
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	60 e0       	ldi	r22, 0x00	; 0
    1302:	70 e0       	ldi	r23, 0x00	; 0
    1304:	80 91 26 08 	lds	r24, 0x0826
    1308:	90 91 27 08 	lds	r25, 0x0827
    130c:	d7 d2       	rcall	.+1454   	; 0x18bc <xQueueGenericSend>
    130e:	8c 2f       	mov	r24, r28
    1310:	cf 91       	pop	r28
    1312:	08 95       	ret

00001314 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    1314:	86 e1       	ldi	r24, 0x16	; 22
    1316:	a0 df       	rcall	.-192    	; 0x1258 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    1318:	20 e0       	ldi	r18, 0x00	; 0
    131a:	4a ef       	ldi	r20, 0xFA	; 250
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	60 e0       	ldi	r22, 0x00	; 0
    1320:	70 e0       	ldi	r23, 0x00	; 0
    1322:	80 91 22 08 	lds	r24, 0x0822
    1326:	90 91 23 08 	lds	r25, 0x0823
    132a:	c0 d3       	rcall	.+1920   	; 0x1aac <xQueueGenericReceive>
    132c:	81 30       	cpi	r24, 0x01	; 1
    132e:	21 f4       	brne	.+8      	; 0x1338 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    1330:	82 e0       	ldi	r24, 0x02	; 2
    1332:	92 df       	rcall	.-220    	; 0x1258 <myUSART_transmitUSART1_c>
		return 1;
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	08 95       	ret
	}
	else
	{
		return 0;
    1338:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    133a:	08 95       	ret

0000133c <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    133c:	20 e0       	ldi	r18, 0x00	; 0
    133e:	40 e0       	ldi	r20, 0x00	; 0
    1340:	50 e0       	ldi	r21, 0x00	; 0
    1342:	60 e0       	ldi	r22, 0x00	; 0
    1344:	70 e0       	ldi	r23, 0x00	; 0
    1346:	80 91 22 08 	lds	r24, 0x0822
    134a:	90 91 23 08 	lds	r25, 0x0823
    134e:	b6 c2       	rjmp	.+1388   	; 0x18bc <xQueueGenericSend>
    1350:	08 95       	ret

00001352 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    1352:	91 e0       	ldi	r25, 0x01	; 1
    1354:	85 30       	cpi	r24, 0x05	; 5
    1356:	09 f0       	breq	.+2      	; 0x135a <myUSART_receiveHandShakeAck+0x8>
    1358:	90 e0       	ldi	r25, 0x00	; 0
}
    135a:	89 2f       	mov	r24, r25
    135c:	08 95       	ret

0000135e <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    135e:	91 e0       	ldi	r25, 0x01	; 1
    1360:	86 31       	cpi	r24, 0x16	; 22
    1362:	09 f0       	breq	.+2      	; 0x1366 <myUSART_receiveHandShakeStart+0x8>
    1364:	90 e0       	ldi	r25, 0x00	; 0
}
    1366:	89 2f       	mov	r24, r25
    1368:	08 95       	ret

0000136a <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    136a:	91 e0       	ldi	r25, 0x01	; 1
    136c:	82 30       	cpi	r24, 0x02	; 2
    136e:	09 f0       	breq	.+2      	; 0x1372 <myUSART_receiveHandShakeFin+0x8>
    1370:	90 e0       	ldi	r25, 0x00	; 0
}
    1372:	89 2f       	mov	r24, r25
    1374:	08 95       	ret

00001376 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1376:	91 e0       	ldi	r25, 0x01	; 1
    1378:	86 30       	cpi	r24, 0x06	; 6
    137a:	09 f0       	breq	.+2      	; 0x137e <myUSART_receiveMessageACK+0x8>
    137c:	90 e0       	ldi	r25, 0x00	; 0
}
    137e:	89 2f       	mov	r24, r25
    1380:	08 95       	ret

00001382 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1382:	31 e1       	ldi	r19, 0x11	; 17
    1384:	fc 01       	movw	r30, r24
    1386:	30 83       	st	Z, r19
    1388:	31 97       	sbiw	r30, 0x01	; 1
    138a:	22 e2       	ldi	r18, 0x22	; 34
    138c:	20 83       	st	Z, r18
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	a3 e3       	ldi	r26, 0x33	; 51
    1392:	a0 83       	st	Z, r26
    1394:	31 97       	sbiw	r30, 0x01	; 1
    1396:	60 83       	st	Z, r22
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	70 83       	st	Z, r23
    139c:	31 97       	sbiw	r30, 0x01	; 1
    139e:	10 82       	st	Z, r1
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	10 82       	st	Z, r1
    13a4:	31 97       	sbiw	r30, 0x01	; 1
    13a6:	60 e8       	ldi	r22, 0x80	; 128
    13a8:	60 83       	st	Z, r22
    13aa:	31 97       	sbiw	r30, 0x01	; 1
    13ac:	10 82       	st	Z, r1
    13ae:	31 97       	sbiw	r30, 0x01	; 1
    13b0:	10 82       	st	Z, r1
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	10 82       	st	Z, r1
    13b6:	31 97       	sbiw	r30, 0x01	; 1
    13b8:	62 e0       	ldi	r22, 0x02	; 2
    13ba:	60 83       	st	Z, r22
    13bc:	31 97       	sbiw	r30, 0x01	; 1
    13be:	63 e0       	ldi	r22, 0x03	; 3
    13c0:	60 83       	st	Z, r22
    13c2:	31 97       	sbiw	r30, 0x01	; 1
    13c4:	64 e0       	ldi	r22, 0x04	; 4
    13c6:	60 83       	st	Z, r22
    13c8:	31 97       	sbiw	r30, 0x01	; 1
    13ca:	65 e0       	ldi	r22, 0x05	; 5
    13cc:	60 83       	st	Z, r22
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	66 e0       	ldi	r22, 0x06	; 6
    13d2:	60 83       	st	Z, r22
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	67 e0       	ldi	r22, 0x07	; 7
    13d8:	60 83       	st	Z, r22
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	68 e0       	ldi	r22, 0x08	; 8
    13de:	60 83       	st	Z, r22
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	69 e0       	ldi	r22, 0x09	; 9
    13e4:	60 83       	st	Z, r22
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	60 e1       	ldi	r22, 0x10	; 16
    13ea:	60 83       	st	Z, r22
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	30 83       	st	Z, r19
    13f0:	31 97       	sbiw	r30, 0x01	; 1
    13f2:	32 e1       	ldi	r19, 0x12	; 18
    13f4:	30 83       	st	Z, r19
    13f6:	31 97       	sbiw	r30, 0x01	; 1
    13f8:	33 e1       	ldi	r19, 0x13	; 19
    13fa:	30 83       	st	Z, r19
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	34 e1       	ldi	r19, 0x14	; 20
    1400:	30 83       	st	Z, r19
    1402:	31 97       	sbiw	r30, 0x01	; 1
    1404:	35 e1       	ldi	r19, 0x15	; 21
    1406:	30 83       	st	Z, r19
    1408:	31 97       	sbiw	r30, 0x01	; 1
    140a:	36 e1       	ldi	r19, 0x16	; 22
    140c:	30 83       	st	Z, r19
    140e:	31 97       	sbiw	r30, 0x01	; 1
    1410:	37 e1       	ldi	r19, 0x17	; 23
    1412:	30 83       	st	Z, r19
    1414:	31 97       	sbiw	r30, 0x01	; 1
    1416:	38 e1       	ldi	r19, 0x18	; 24
    1418:	30 83       	st	Z, r19
    141a:	31 97       	sbiw	r30, 0x01	; 1
    141c:	39 e1       	ldi	r19, 0x19	; 25
    141e:	30 83       	st	Z, r19
    1420:	31 97       	sbiw	r30, 0x01	; 1
    1422:	30 e2       	ldi	r19, 0x20	; 32
    1424:	30 83       	st	Z, r19
    1426:	31 97       	sbiw	r30, 0x01	; 1
    1428:	31 e2       	ldi	r19, 0x21	; 33
    142a:	30 83       	st	Z, r19
    142c:	31 97       	sbiw	r30, 0x01	; 1
    142e:	20 83       	st	Z, r18
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	23 e2       	ldi	r18, 0x23	; 35
    1434:	20 83       	st	Z, r18
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	40 83       	st	Z, r20
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	50 83       	st	Z, r21
    143e:	31 97       	sbiw	r30, 0x01	; 1
    1440:	26 e2       	ldi	r18, 0x26	; 38
    1442:	20 83       	st	Z, r18
    1444:	31 97       	sbiw	r30, 0x01	; 1
    1446:	27 e2       	ldi	r18, 0x27	; 39
    1448:	20 83       	st	Z, r18
    144a:	31 97       	sbiw	r30, 0x01	; 1
    144c:	28 e2       	ldi	r18, 0x28	; 40
    144e:	20 83       	st	Z, r18
    1450:	31 97       	sbiw	r30, 0x01	; 1
    1452:	29 e2       	ldi	r18, 0x29	; 41
    1454:	20 83       	st	Z, r18
    1456:	31 97       	sbiw	r30, 0x01	; 1
    1458:	20 e3       	ldi	r18, 0x30	; 48
    145a:	20 83       	st	Z, r18
    145c:	31 97       	sbiw	r30, 0x01	; 1
    145e:	21 e3       	ldi	r18, 0x31	; 49
    1460:	20 83       	st	Z, r18
    1462:	89 97       	sbiw	r24, 0x29	; 41
    1464:	08 95       	ret

00001466 <xPortStartScheduler>:
    1466:	82 e0       	ldi	r24, 0x02	; 2
    1468:	84 bd       	out	0x24, r24	; 36
    146a:	16 bc       	out	0x26, r1	; 38
    146c:	80 e3       	ldi	r24, 0x30	; 48
    146e:	87 bd       	out	0x27, r24	; 39
    1470:	ee e6       	ldi	r30, 0x6E	; 110
    1472:	f0 e0       	ldi	r31, 0x00	; 0
    1474:	80 81       	ld	r24, Z
    1476:	82 60       	ori	r24, 0x02	; 2
    1478:	80 83       	st	Z, r24
    147a:	83 e0       	ldi	r24, 0x03	; 3
    147c:	85 bd       	out	0x25, r24	; 37
    147e:	a0 91 91 08 	lds	r26, 0x0891
    1482:	b0 91 92 08 	lds	r27, 0x0892
    1486:	cd 91       	ld	r28, X+
    1488:	cd bf       	out	0x3d, r28	; 61
    148a:	dd 91       	ld	r29, X+
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	ff 91       	pop	r31
    1490:	ef 91       	pop	r30
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	bf 91       	pop	r27
    1498:	af 91       	pop	r26
    149a:	9f 91       	pop	r25
    149c:	8f 91       	pop	r24
    149e:	7f 91       	pop	r23
    14a0:	6f 91       	pop	r22
    14a2:	5f 91       	pop	r21
    14a4:	4f 91       	pop	r20
    14a6:	3f 91       	pop	r19
    14a8:	2f 91       	pop	r18
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	ff 90       	pop	r15
    14b0:	ef 90       	pop	r14
    14b2:	df 90       	pop	r13
    14b4:	cf 90       	pop	r12
    14b6:	bf 90       	pop	r11
    14b8:	af 90       	pop	r10
    14ba:	9f 90       	pop	r9
    14bc:	8f 90       	pop	r8
    14be:	7f 90       	pop	r7
    14c0:	6f 90       	pop	r6
    14c2:	5f 90       	pop	r5
    14c4:	4f 90       	pop	r4
    14c6:	3f 90       	pop	r3
    14c8:	2f 90       	pop	r2
    14ca:	1f 90       	pop	r1
    14cc:	0f 90       	pop	r0
    14ce:	0c be       	out	0x3c, r0	; 60
    14d0:	0f 90       	pop	r0
    14d2:	0b be       	out	0x3b, r0	; 59
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	0f 90       	pop	r0
    14da:	08 95       	ret
    14dc:	81 e0       	ldi	r24, 0x01	; 1
    14de:	08 95       	ret

000014e0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14e0:	0f 92       	push	r0
    14e2:	0f b6       	in	r0, 0x3f	; 63
    14e4:	f8 94       	cli
    14e6:	0f 92       	push	r0
    14e8:	0b b6       	in	r0, 0x3b	; 59
    14ea:	0f 92       	push	r0
    14ec:	0c b6       	in	r0, 0x3c	; 60
    14ee:	0f 92       	push	r0
    14f0:	1f 92       	push	r1
    14f2:	11 24       	eor	r1, r1
    14f4:	2f 92       	push	r2
    14f6:	3f 92       	push	r3
    14f8:	4f 92       	push	r4
    14fa:	5f 92       	push	r5
    14fc:	6f 92       	push	r6
    14fe:	7f 92       	push	r7
    1500:	8f 92       	push	r8
    1502:	9f 92       	push	r9
    1504:	af 92       	push	r10
    1506:	bf 92       	push	r11
    1508:	cf 92       	push	r12
    150a:	df 92       	push	r13
    150c:	ef 92       	push	r14
    150e:	ff 92       	push	r15
    1510:	0f 93       	push	r16
    1512:	1f 93       	push	r17
    1514:	2f 93       	push	r18
    1516:	3f 93       	push	r19
    1518:	4f 93       	push	r20
    151a:	5f 93       	push	r21
    151c:	6f 93       	push	r22
    151e:	7f 93       	push	r23
    1520:	8f 93       	push	r24
    1522:	9f 93       	push	r25
    1524:	af 93       	push	r26
    1526:	bf 93       	push	r27
    1528:	cf 93       	push	r28
    152a:	df 93       	push	r29
    152c:	ef 93       	push	r30
    152e:	ff 93       	push	r31
    1530:	a0 91 91 08 	lds	r26, 0x0891
    1534:	b0 91 92 08 	lds	r27, 0x0892
    1538:	0d b6       	in	r0, 0x3d	; 61
    153a:	0d 92       	st	X+, r0
    153c:	0e b6       	in	r0, 0x3e	; 62
    153e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1540:	51 d7       	rcall	.+3746   	; 0x23e4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1542:	a0 91 91 08 	lds	r26, 0x0891
    1546:	b0 91 92 08 	lds	r27, 0x0892
    154a:	cd 91       	ld	r28, X+
    154c:	cd bf       	out	0x3d, r28	; 61
    154e:	dd 91       	ld	r29, X+
    1550:	de bf       	out	0x3e, r29	; 62
    1552:	ff 91       	pop	r31
    1554:	ef 91       	pop	r30
    1556:	df 91       	pop	r29
    1558:	cf 91       	pop	r28
    155a:	bf 91       	pop	r27
    155c:	af 91       	pop	r26
    155e:	9f 91       	pop	r25
    1560:	8f 91       	pop	r24
    1562:	7f 91       	pop	r23
    1564:	6f 91       	pop	r22
    1566:	5f 91       	pop	r21
    1568:	4f 91       	pop	r20
    156a:	3f 91       	pop	r19
    156c:	2f 91       	pop	r18
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	ff 90       	pop	r15
    1574:	ef 90       	pop	r14
    1576:	df 90       	pop	r13
    1578:	cf 90       	pop	r12
    157a:	bf 90       	pop	r11
    157c:	af 90       	pop	r10
    157e:	9f 90       	pop	r9
    1580:	8f 90       	pop	r8
    1582:	7f 90       	pop	r7
    1584:	6f 90       	pop	r6
    1586:	5f 90       	pop	r5
    1588:	4f 90       	pop	r4
    158a:	3f 90       	pop	r3
    158c:	2f 90       	pop	r2
    158e:	1f 90       	pop	r1
    1590:	0f 90       	pop	r0
    1592:	0c be       	out	0x3c, r0	; 60
    1594:	0f 90       	pop	r0
    1596:	0b be       	out	0x3b, r0	; 59
    1598:	0f 90       	pop	r0
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    159e:	08 95       	ret

000015a0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15a0:	0f 92       	push	r0
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	0f 92       	push	r0
    15a8:	0b b6       	in	r0, 0x3b	; 59
    15aa:	0f 92       	push	r0
    15ac:	0c b6       	in	r0, 0x3c	; 60
    15ae:	0f 92       	push	r0
    15b0:	1f 92       	push	r1
    15b2:	11 24       	eor	r1, r1
    15b4:	2f 92       	push	r2
    15b6:	3f 92       	push	r3
    15b8:	4f 92       	push	r4
    15ba:	5f 92       	push	r5
    15bc:	6f 92       	push	r6
    15be:	7f 92       	push	r7
    15c0:	8f 92       	push	r8
    15c2:	9f 92       	push	r9
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	cf 92       	push	r12
    15ca:	df 92       	push	r13
    15cc:	ef 92       	push	r14
    15ce:	ff 92       	push	r15
    15d0:	0f 93       	push	r16
    15d2:	1f 93       	push	r17
    15d4:	2f 93       	push	r18
    15d6:	3f 93       	push	r19
    15d8:	4f 93       	push	r20
    15da:	5f 93       	push	r21
    15dc:	6f 93       	push	r22
    15de:	7f 93       	push	r23
    15e0:	8f 93       	push	r24
    15e2:	9f 93       	push	r25
    15e4:	af 93       	push	r26
    15e6:	bf 93       	push	r27
    15e8:	cf 93       	push	r28
    15ea:	df 93       	push	r29
    15ec:	ef 93       	push	r30
    15ee:	ff 93       	push	r31
    15f0:	a0 91 91 08 	lds	r26, 0x0891
    15f4:	b0 91 92 08 	lds	r27, 0x0892
    15f8:	0d b6       	in	r0, 0x3d	; 61
    15fa:	0d 92       	st	X+, r0
    15fc:	0e b6       	in	r0, 0x3e	; 62
    15fe:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1600:	3b d5       	rcall	.+2678   	; 0x2078 <xTaskIncrementTick>
    1602:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1604:	ef d6       	rcall	.+3550   	; 0x23e4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1606:	a0 91 91 08 	lds	r26, 0x0891
    160a:	b0 91 92 08 	lds	r27, 0x0892
    160e:	cd 91       	ld	r28, X+
    1610:	cd bf       	out	0x3d, r28	; 61
    1612:	dd 91       	ld	r29, X+
    1614:	de bf       	out	0x3e, r29	; 62
    1616:	ff 91       	pop	r31
    1618:	ef 91       	pop	r30
    161a:	df 91       	pop	r29
    161c:	cf 91       	pop	r28
    161e:	bf 91       	pop	r27
    1620:	af 91       	pop	r26
    1622:	9f 91       	pop	r25
    1624:	8f 91       	pop	r24
    1626:	7f 91       	pop	r23
    1628:	6f 91       	pop	r22
    162a:	5f 91       	pop	r21
    162c:	4f 91       	pop	r20
    162e:	3f 91       	pop	r19
    1630:	2f 91       	pop	r18
    1632:	1f 91       	pop	r17
    1634:	0f 91       	pop	r16
    1636:	ff 90       	pop	r15
    1638:	ef 90       	pop	r14
    163a:	df 90       	pop	r13
    163c:	cf 90       	pop	r12
    163e:	bf 90       	pop	r11
    1640:	af 90       	pop	r10
    1642:	9f 90       	pop	r9
    1644:	8f 90       	pop	r8
    1646:	7f 90       	pop	r7
    1648:	6f 90       	pop	r6
    164a:	5f 90       	pop	r5
    164c:	4f 90       	pop	r4
    164e:	3f 90       	pop	r3
    1650:	2f 90       	pop	r2
    1652:	1f 90       	pop	r1
    1654:	0f 90       	pop	r0
    1656:	0c be       	out	0x3c, r0	; 60
    1658:	0f 90       	pop	r0
    165a:	0b be       	out	0x3b, r0	; 59
    165c:	0f 90       	pop	r0
    165e:	0f be       	out	0x3f, r0	; 63
    1660:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1662:	08 95       	ret

00001664 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1664:	9d df       	rcall	.-198    	; 0x15a0 <vPortYieldFromTick>
		 asm volatile ("reti");
    1666:	18 95       	reti

00001668 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1668:	1f 93       	push	r17
    166a:	cf 93       	push	r28
    166c:	df 93       	push	r29
    166e:	ec 01       	movw	r28, r24
    1670:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1672:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1674:	81 11       	cpse	r24, r1
    1676:	0c c0       	rjmp	.+24     	; 0x1690 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1678:	88 81       	ld	r24, Y
    167a:	99 81       	ldd	r25, Y+1	; 0x01
    167c:	89 2b       	or	r24, r25
    167e:	09 f0       	breq	.+2      	; 0x1682 <prvCopyDataToQueue+0x1a>
    1680:	47 c0       	rjmp	.+142    	; 0x1710 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1682:	8a 81       	ldd	r24, Y+2	; 0x02
    1684:	9b 81       	ldd	r25, Y+3	; 0x03
    1686:	0e 94 b5 13 	call	0x276a	; 0x276a <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    168a:	1b 82       	std	Y+3, r1	; 0x03
    168c:	1a 82       	std	Y+2, r1	; 0x02
    168e:	47 c0       	rjmp	.+142    	; 0x171e <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1690:	41 11       	cpse	r20, r1
    1692:	18 c0       	rjmp	.+48     	; 0x16c4 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1694:	48 2f       	mov	r20, r24
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	8c 81       	ldd	r24, Y+4	; 0x04
    169a:	9d 81       	ldd	r25, Y+5	; 0x05
    169c:	0e 94 81 17 	call	0x2f02	; 0x2f02 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16a0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16a2:	8c 81       	ldd	r24, Y+4	; 0x04
    16a4:	9d 81       	ldd	r25, Y+5	; 0x05
    16a6:	82 0f       	add	r24, r18
    16a8:	91 1d       	adc	r25, r1
    16aa:	9d 83       	std	Y+5, r25	; 0x05
    16ac:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16ae:	2a 81       	ldd	r18, Y+2	; 0x02
    16b0:	3b 81       	ldd	r19, Y+3	; 0x03
    16b2:	82 17       	cp	r24, r18
    16b4:	93 07       	cpc	r25, r19
    16b6:	70 f1       	brcs	.+92     	; 0x1714 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    16b8:	88 81       	ld	r24, Y
    16ba:	99 81       	ldd	r25, Y+1	; 0x01
    16bc:	9d 83       	std	Y+5, r25	; 0x05
    16be:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	2d c0       	rjmp	.+90     	; 0x171e <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16c4:	48 2f       	mov	r20, r24
    16c6:	50 e0       	ldi	r21, 0x00	; 0
    16c8:	8e 81       	ldd	r24, Y+6	; 0x06
    16ca:	9f 81       	ldd	r25, Y+7	; 0x07
    16cc:	0e 94 81 17 	call	0x2f02	; 0x2f02 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    16d0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	31 95       	neg	r19
    16d6:	21 95       	neg	r18
    16d8:	31 09       	sbc	r19, r1
    16da:	8e 81       	ldd	r24, Y+6	; 0x06
    16dc:	9f 81       	ldd	r25, Y+7	; 0x07
    16de:	82 0f       	add	r24, r18
    16e0:	93 1f       	adc	r25, r19
    16e2:	9f 83       	std	Y+7, r25	; 0x07
    16e4:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16e6:	68 81       	ld	r22, Y
    16e8:	79 81       	ldd	r23, Y+1	; 0x01
    16ea:	86 17       	cp	r24, r22
    16ec:	97 07       	cpc	r25, r23
    16ee:	30 f4       	brcc	.+12     	; 0x16fc <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16f0:	8a 81       	ldd	r24, Y+2	; 0x02
    16f2:	9b 81       	ldd	r25, Y+3	; 0x03
    16f4:	28 0f       	add	r18, r24
    16f6:	39 1f       	adc	r19, r25
    16f8:	3f 83       	std	Y+7, r19	; 0x07
    16fa:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    16fc:	12 30       	cpi	r17, 0x02	; 2
    16fe:	61 f4       	brne	.+24     	; 0x1718 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1700:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1702:	88 23       	and	r24, r24
    1704:	59 f0       	breq	.+22     	; 0x171c <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1706:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1708:	81 50       	subi	r24, 0x01	; 1
    170a:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	07 c0       	rjmp	.+14     	; 0x171e <prvCopyDataToQueue+0xb6>
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	05 c0       	rjmp	.+10     	; 0x171e <prvCopyDataToQueue+0xb6>
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	03 c0       	rjmp	.+6      	; 0x171e <prvCopyDataToQueue+0xb6>
    1718:	80 e0       	ldi	r24, 0x00	; 0
    171a:	01 c0       	rjmp	.+2      	; 0x171e <prvCopyDataToQueue+0xb6>
    171c:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    171e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1720:	9f 5f       	subi	r25, 0xFF	; 255
    1722:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1724:	df 91       	pop	r29
    1726:	cf 91       	pop	r28
    1728:	1f 91       	pop	r17
    172a:	08 95       	ret

0000172c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    172c:	fc 01       	movw	r30, r24
    172e:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1730:	44 8d       	ldd	r20, Z+28	; 0x1c
    1732:	44 23       	and	r20, r20
    1734:	a1 f0       	breq	.+40     	; 0x175e <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1736:	50 e0       	ldi	r21, 0x00	; 0
    1738:	26 81       	ldd	r18, Z+6	; 0x06
    173a:	37 81       	ldd	r19, Z+7	; 0x07
    173c:	24 0f       	add	r18, r20
    173e:	35 1f       	adc	r19, r21
    1740:	37 83       	std	Z+7, r19	; 0x07
    1742:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1744:	62 81       	ldd	r22, Z+2	; 0x02
    1746:	73 81       	ldd	r23, Z+3	; 0x03
    1748:	26 17       	cp	r18, r22
    174a:	37 07       	cpc	r19, r23
    174c:	20 f0       	brcs	.+8      	; 0x1756 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    174e:	20 81       	ld	r18, Z
    1750:	31 81       	ldd	r19, Z+1	; 0x01
    1752:	37 83       	std	Z+7, r19	; 0x07
    1754:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1756:	66 81       	ldd	r22, Z+6	; 0x06
    1758:	77 81       	ldd	r23, Z+7	; 0x07
    175a:	0c 94 81 17 	jmp	0x2f02	; 0x2f02 <memcpy>
    175e:	08 95       	ret

00001760 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1760:	0f 93       	push	r16
    1762:	1f 93       	push	r17
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    176a:	0f b6       	in	r0, 0x3f	; 63
    176c:	f8 94       	cli
    176e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1770:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1772:	18 16       	cp	r1, r24
    1774:	a4 f4       	brge	.+40     	; 0x179e <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1776:	89 89       	ldd	r24, Y+17	; 0x11
    1778:	88 23       	and	r24, r24
    177a:	89 f0       	breq	.+34     	; 0x179e <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    177c:	8e 01       	movw	r16, r28
    177e:	0f 5e       	subi	r16, 0xEF	; 239
    1780:	1f 4f       	sbci	r17, 0xFF	; 255
    1782:	03 c0       	rjmp	.+6      	; 0x178a <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1784:	89 89       	ldd	r24, Y+17	; 0x11
    1786:	88 23       	and	r24, r24
    1788:	51 f0       	breq	.+20     	; 0x179e <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    178a:	c8 01       	movw	r24, r16
    178c:	01 d7       	rcall	.+3586   	; 0x2590 <xTaskRemoveFromEventList>
    178e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1790:	8a d7       	rcall	.+3860   	; 0x26a6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1792:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1794:	81 50       	subi	r24, 0x01	; 1
    1796:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1798:	8e 8d       	ldd	r24, Y+30	; 0x1e
    179a:	18 16       	cp	r1, r24
    179c:	9c f3       	brlt	.-26     	; 0x1784 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    179e:	8f ef       	ldi	r24, 0xFF	; 255
    17a0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17a2:	0f 90       	pop	r0
    17a4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17a6:	0f b6       	in	r0, 0x3f	; 63
    17a8:	f8 94       	cli
    17aa:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17ac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17ae:	18 16       	cp	r1, r24
    17b0:	a4 f4       	brge	.+40     	; 0x17da <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b2:	88 85       	ldd	r24, Y+8	; 0x08
    17b4:	88 23       	and	r24, r24
    17b6:	89 f0       	breq	.+34     	; 0x17da <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17b8:	8e 01       	movw	r16, r28
    17ba:	08 5f       	subi	r16, 0xF8	; 248
    17bc:	1f 4f       	sbci	r17, 0xFF	; 255
    17be:	03 c0       	rjmp	.+6      	; 0x17c6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17c0:	88 85       	ldd	r24, Y+8	; 0x08
    17c2:	88 23       	and	r24, r24
    17c4:	51 f0       	breq	.+20     	; 0x17da <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17c6:	c8 01       	movw	r24, r16
    17c8:	e3 d6       	rcall	.+3526   	; 0x2590 <xTaskRemoveFromEventList>
    17ca:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    17cc:	6c d7       	rcall	.+3800   	; 0x26a6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    17ce:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17d0:	81 50       	subi	r24, 0x01	; 1
    17d2:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17d6:	18 16       	cp	r1, r24
    17d8:	9c f3       	brlt	.-26     	; 0x17c0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    17da:	8f ef       	ldi	r24, 0xFF	; 255
    17dc:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17de:	0f 90       	pop	r0
    17e0:	0f be       	out	0x3f, r0	; 63
}
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	08 95       	ret

000017ec <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    17f8:	88 81       	ld	r24, Y
    17fa:	99 81       	ldd	r25, Y+1	; 0x01
    17fc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1802:	72 9f       	mul	r23, r18
    1804:	a0 01       	movw	r20, r0
    1806:	73 9f       	mul	r23, r19
    1808:	50 0d       	add	r21, r0
    180a:	11 24       	eor	r1, r1
    180c:	fc 01       	movw	r30, r24
    180e:	e4 0f       	add	r30, r20
    1810:	f5 1f       	adc	r31, r21
    1812:	fb 83       	std	Y+3, r31	; 0x03
    1814:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1816:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1818:	9d 83       	std	Y+5, r25	; 0x05
    181a:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    181c:	42 1b       	sub	r20, r18
    181e:	53 0b       	sbc	r21, r19
    1820:	84 0f       	add	r24, r20
    1822:	95 1f       	adc	r25, r21
    1824:	9f 83       	std	Y+7, r25	; 0x07
    1826:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1828:	8f ef       	ldi	r24, 0xFF	; 255
    182a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    182c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    182e:	61 11       	cpse	r22, r1
    1830:	0a c0       	rjmp	.+20     	; 0x1846 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1832:	88 85       	ldd	r24, Y+8	; 0x08
    1834:	88 23       	and	r24, r24
    1836:	79 f0       	breq	.+30     	; 0x1856 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1838:	ce 01       	movw	r24, r28
    183a:	08 96       	adiw	r24, 0x08	; 8
    183c:	a9 d6       	rcall	.+3410   	; 0x2590 <xTaskRemoveFromEventList>
    183e:	81 30       	cpi	r24, 0x01	; 1
    1840:	51 f4       	brne	.+20     	; 0x1856 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1842:	4e de       	rcall	.-868    	; 0x14e0 <vPortYield>
    1844:	08 c0       	rjmp	.+16     	; 0x1856 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1846:	ce 01       	movw	r24, r28
    1848:	08 96       	adiw	r24, 0x08	; 8
    184a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    184e:	ce 01       	movw	r24, r28
    1850:	41 96       	adiw	r24, 0x11	; 17
    1852:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	08 95       	ret

00001862 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1862:	0f 93       	push	r16
    1864:	1f 93       	push	r17
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	18 2f       	mov	r17, r24
    186c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    186e:	88 23       	and	r24, r24
    1870:	e9 f0       	breq	.+58     	; 0x18ac <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1872:	8f e1       	ldi	r24, 0x1F	; 31
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    187a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    187c:	00 97       	sbiw	r24, 0x00	; 0
    187e:	c1 f0       	breq	.+48     	; 0x18b0 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1880:	10 9f       	mul	r17, r16
    1882:	c0 01       	movw	r24, r0
    1884:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1886:	01 96       	adiw	r24, 0x01	; 1
    1888:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    188c:	99 83       	std	Y+1, r25	; 0x01
    188e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1890:	89 2b       	or	r24, r25
    1892:	31 f0       	breq	.+12     	; 0x18a0 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1894:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1896:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1898:	61 e0       	ldi	r22, 0x01	; 1
    189a:	ce 01       	movw	r24, r28
    189c:	a7 df       	rcall	.-178    	; 0x17ec <xQueueGenericReset>
    189e:	08 c0       	rjmp	.+16     	; 0x18b0 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    18a0:	ce 01       	movw	r24, r28
    18a2:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    18a6:	c0 e0       	ldi	r28, 0x00	; 0
    18a8:	d0 e0       	ldi	r29, 0x00	; 0
    18aa:	02 c0       	rjmp	.+4      	; 0x18b0 <xQueueGenericCreate+0x4e>
    18ac:	c0 e0       	ldi	r28, 0x00	; 0
    18ae:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    18b0:	ce 01       	movw	r24, r28
    18b2:	df 91       	pop	r29
    18b4:	cf 91       	pop	r28
    18b6:	1f 91       	pop	r17
    18b8:	0f 91       	pop	r16
    18ba:	08 95       	ret

000018bc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    18bc:	9f 92       	push	r9
    18be:	af 92       	push	r10
    18c0:	bf 92       	push	r11
    18c2:	cf 92       	push	r12
    18c4:	df 92       	push	r13
    18c6:	ef 92       	push	r14
    18c8:	ff 92       	push	r15
    18ca:	0f 93       	push	r16
    18cc:	1f 93       	push	r17
    18ce:	cf 93       	push	r28
    18d0:	df 93       	push	r29
    18d2:	00 d0       	rcall	.+0      	; 0x18d4 <xQueueGenericSend+0x18>
    18d4:	1f 92       	push	r1
    18d6:	1f 92       	push	r1
    18d8:	cd b7       	in	r28, 0x3d	; 61
    18da:	de b7       	in	r29, 0x3e	; 62
    18dc:	8c 01       	movw	r16, r24
    18de:	6b 01       	movw	r12, r22
    18e0:	5d 83       	std	Y+5, r21	; 0x05
    18e2:	4c 83       	std	Y+4, r20	; 0x04
    18e4:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    18e6:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    18e8:	99 24       	eor	r9, r9
    18ea:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18ec:	7c 01       	movw	r14, r24
    18ee:	88 e0       	ldi	r24, 0x08	; 8
    18f0:	e8 0e       	add	r14, r24
    18f2:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18fa:	f8 01       	movw	r30, r16
    18fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    18fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1900:	98 17       	cp	r25, r24
    1902:	18 f0       	brcs	.+6      	; 0x190a <xQueueGenericSend+0x4e>
    1904:	f2 e0       	ldi	r31, 0x02	; 2
    1906:	af 12       	cpse	r10, r31
    1908:	15 c0       	rjmp	.+42     	; 0x1934 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    190a:	4a 2d       	mov	r20, r10
    190c:	b6 01       	movw	r22, r12
    190e:	c8 01       	movw	r24, r16
    1910:	ab de       	rcall	.-682    	; 0x1668 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1912:	f8 01       	movw	r30, r16
    1914:	91 89       	ldd	r25, Z+17	; 0x11
    1916:	99 23       	and	r25, r25
    1918:	39 f0       	breq	.+14     	; 0x1928 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    191a:	c8 01       	movw	r24, r16
    191c:	41 96       	adiw	r24, 0x11	; 17
    191e:	38 d6       	rcall	.+3184   	; 0x2590 <xTaskRemoveFromEventList>
    1920:	81 30       	cpi	r24, 0x01	; 1
    1922:	21 f4       	brne	.+8      	; 0x192c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1924:	dd dd       	rcall	.-1094   	; 0x14e0 <vPortYield>
    1926:	02 c0       	rjmp	.+4      	; 0x192c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1928:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    192a:	da dd       	rcall	.-1100   	; 0x14e0 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	46 c0       	rjmp	.+140    	; 0x19c0 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1934:	ec 81       	ldd	r30, Y+4	; 0x04
    1936:	fd 81       	ldd	r31, Y+5	; 0x05
    1938:	ef 2b       	or	r30, r31
    193a:	21 f4       	brne	.+8      	; 0x1944 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	3e c0       	rjmp	.+124    	; 0x19c0 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1944:	b1 10       	cpse	r11, r1
    1946:	04 c0       	rjmp	.+8      	; 0x1950 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1948:	ce 01       	movw	r24, r28
    194a:	01 96       	adiw	r24, 0x01	; 1
    194c:	69 d6       	rcall	.+3282   	; 0x2620 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    194e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1954:	7c d3       	rcall	.+1784   	; 0x204e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1956:	0f b6       	in	r0, 0x3f	; 63
    1958:	f8 94       	cli
    195a:	0f 92       	push	r0
    195c:	f8 01       	movw	r30, r16
    195e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1960:	8f 3f       	cpi	r24, 0xFF	; 255
    1962:	09 f4       	brne	.+2      	; 0x1966 <xQueueGenericSend+0xaa>
    1964:	15 8e       	std	Z+29, r1	; 0x1d
    1966:	f8 01       	movw	r30, r16
    1968:	86 8d       	ldd	r24, Z+30	; 0x1e
    196a:	8f 3f       	cpi	r24, 0xFF	; 255
    196c:	09 f4       	brne	.+2      	; 0x1970 <xQueueGenericSend+0xb4>
    196e:	16 8e       	std	Z+30, r1	; 0x1e
    1970:	0f 90       	pop	r0
    1972:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1974:	be 01       	movw	r22, r28
    1976:	6c 5f       	subi	r22, 0xFC	; 252
    1978:	7f 4f       	sbci	r23, 0xFF	; 255
    197a:	ce 01       	movw	r24, r28
    197c:	01 96       	adiw	r24, 0x01	; 1
    197e:	5b d6       	rcall	.+3254   	; 0x2636 <xTaskCheckForTimeOut>
    1980:	81 11       	cpse	r24, r1
    1982:	1a c0       	rjmp	.+52     	; 0x19b8 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    198a:	f8 01       	movw	r30, r16
    198c:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    198e:	0f 90       	pop	r0
    1990:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1992:	f8 01       	movw	r30, r16
    1994:	83 8d       	ldd	r24, Z+27	; 0x1b
    1996:	98 13       	cpse	r25, r24
    1998:	0b c0       	rjmp	.+22     	; 0x19b0 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    199a:	6c 81       	ldd	r22, Y+4	; 0x04
    199c:	7d 81       	ldd	r23, Y+5	; 0x05
    199e:	c7 01       	movw	r24, r14
    19a0:	cc d5       	rcall	.+2968   	; 0x253a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    19a2:	c8 01       	movw	r24, r16
    19a4:	dd de       	rcall	.-582    	; 0x1760 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    19a6:	26 d4       	rcall	.+2124   	; 0x21f4 <xTaskResumeAll>
    19a8:	81 11       	cpse	r24, r1
    19aa:	a4 cf       	rjmp	.-184    	; 0x18f4 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    19ac:	99 dd       	rcall	.-1230   	; 0x14e0 <vPortYield>
    19ae:	a2 cf       	rjmp	.-188    	; 0x18f4 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19b0:	c8 01       	movw	r24, r16
    19b2:	d6 de       	rcall	.-596    	; 0x1760 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19b4:	1f d4       	rcall	.+2110   	; 0x21f4 <xTaskResumeAll>
    19b6:	9e cf       	rjmp	.-196    	; 0x18f4 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19b8:	c8 01       	movw	r24, r16
    19ba:	d2 de       	rcall	.-604    	; 0x1760 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19bc:	1b d4       	rcall	.+2102   	; 0x21f4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19be:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19c0:	0f 90       	pop	r0
    19c2:	0f 90       	pop	r0
    19c4:	0f 90       	pop	r0
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	1f 91       	pop	r17
    19d0:	0f 91       	pop	r16
    19d2:	ff 90       	pop	r15
    19d4:	ef 90       	pop	r14
    19d6:	df 90       	pop	r13
    19d8:	cf 90       	pop	r12
    19da:	bf 90       	pop	r11
    19dc:	af 90       	pop	r10
    19de:	9f 90       	pop	r9
    19e0:	08 95       	ret

000019e2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    19e6:	8f e1       	ldi	r24, 0x1F	; 31
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    19ee:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    19f0:	00 97       	sbiw	r24, 0x00	; 0
    19f2:	f1 f0       	breq	.+60     	; 0x1a30 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    19f4:	1b 82       	std	Y+3, r1	; 0x03
    19f6:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    19f8:	19 82       	std	Y+1, r1	; 0x01
    19fa:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    19fc:	1d 82       	std	Y+5, r1	; 0x05
    19fe:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1a00:	1f 82       	std	Y+7, r1	; 0x07
    1a02:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1a04:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1a0a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1a0c:	8f ef       	ldi	r24, 0xFF	; 255
    1a0e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1a10:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1a12:	ce 01       	movw	r24, r28
    1a14:	08 96       	adiw	r24, 0x08	; 8
    1a16:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1a1a:	ce 01       	movw	r24, r28
    1a1c:	41 96       	adiw	r24, 0x11	; 17
    1a1e:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1a22:	20 e0       	ldi	r18, 0x00	; 0
    1a24:	40 e0       	ldi	r20, 0x00	; 0
    1a26:	50 e0       	ldi	r21, 0x00	; 0
    1a28:	60 e0       	ldi	r22, 0x00	; 0
    1a2a:	70 e0       	ldi	r23, 0x00	; 0
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	46 df       	rcall	.-372    	; 0x18bc <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1a30:	ce 01       	movw	r24, r28
    1a32:	df 91       	pop	r29
    1a34:	cf 91       	pop	r28
    1a36:	08 95       	ret

00001a38 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a38:	0f 93       	push	r16
    1a3a:	1f 93       	push	r17
    1a3c:	cf 93       	push	r28
    1a3e:	df 93       	push	r29
    1a40:	ec 01       	movw	r28, r24
    1a42:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a44:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a46:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a48:	98 17       	cp	r25, r24
    1a4a:	10 f0       	brcs	.+4      	; 0x1a50 <xQueueGenericSendFromISR+0x18>
    1a4c:	22 30       	cpi	r18, 0x02	; 2
    1a4e:	11 f5       	brne	.+68     	; 0x1a94 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a50:	42 2f       	mov	r20, r18
    1a52:	ce 01       	movw	r24, r28
    1a54:	09 de       	rcall	.-1006   	; 0x1668 <prvCopyDataToQueue>
    1a56:	88 23       	and	r24, r24
    1a58:	31 f0       	breq	.+12     	; 0x1a66 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1a5a:	01 15       	cp	r16, r1
    1a5c:	11 05       	cpc	r17, r1
    1a5e:	19 f0       	breq	.+6      	; 0x1a66 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	f8 01       	movw	r30, r16
    1a64:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a66:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a68:	8f 3f       	cpi	r24, 0xFF	; 255
    1a6a:	79 f4       	brne	.+30     	; 0x1a8a <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a6c:	89 89       	ldd	r24, Y+17	; 0x11
    1a6e:	88 23       	and	r24, r24
    1a70:	99 f0       	breq	.+38     	; 0x1a98 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a72:	ce 01       	movw	r24, r28
    1a74:	41 96       	adiw	r24, 0x11	; 17
    1a76:	8c d5       	rcall	.+2840   	; 0x2590 <xTaskRemoveFromEventList>
    1a78:	88 23       	and	r24, r24
    1a7a:	81 f0       	breq	.+32     	; 0x1a9c <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a7c:	01 15       	cp	r16, r1
    1a7e:	11 05       	cpc	r17, r1
    1a80:	79 f0       	breq	.+30     	; 0x1aa0 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	f8 01       	movw	r30, r16
    1a86:	80 83       	st	Z, r24
    1a88:	0c c0       	rjmp	.+24     	; 0x1aa2 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a8a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a8c:	8f 5f       	subi	r24, 0xFF	; 255
    1a8e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	07 c0       	rjmp	.+14     	; 0x1aa2 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a94:	80 e0       	ldi	r24, 0x00	; 0
    1a96:	05 c0       	rjmp	.+10     	; 0x1aa2 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a98:	81 e0       	ldi	r24, 0x01	; 1
    1a9a:	03 c0       	rjmp	.+6      	; 0x1aa2 <xQueueGenericSendFromISR+0x6a>
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	01 c0       	rjmp	.+2      	; 0x1aa2 <xQueueGenericSendFromISR+0x6a>
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1aa2:	df 91       	pop	r29
    1aa4:	cf 91       	pop	r28
    1aa6:	1f 91       	pop	r17
    1aa8:	0f 91       	pop	r16
    1aaa:	08 95       	ret

00001aac <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1aac:	9f 92       	push	r9
    1aae:	af 92       	push	r10
    1ab0:	bf 92       	push	r11
    1ab2:	cf 92       	push	r12
    1ab4:	df 92       	push	r13
    1ab6:	ef 92       	push	r14
    1ab8:	ff 92       	push	r15
    1aba:	0f 93       	push	r16
    1abc:	1f 93       	push	r17
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	00 d0       	rcall	.+0      	; 0x1ac4 <xQueueGenericReceive+0x18>
    1ac4:	1f 92       	push	r1
    1ac6:	1f 92       	push	r1
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	8c 01       	movw	r16, r24
    1ace:	6b 01       	movw	r12, r22
    1ad0:	5d 83       	std	Y+5, r21	; 0x05
    1ad2:	4c 83       	std	Y+4, r20	; 0x04
    1ad4:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1ad6:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ad8:	99 24       	eor	r9, r9
    1ada:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1adc:	7c 01       	movw	r14, r24
    1ade:	81 e1       	ldi	r24, 0x11	; 17
    1ae0:	e8 0e       	add	r14, r24
    1ae2:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ae4:	0f b6       	in	r0, 0x3f	; 63
    1ae6:	f8 94       	cli
    1ae8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aea:	f8 01       	movw	r30, r16
    1aec:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aee:	88 23       	and	r24, r24
    1af0:	69 f1       	breq	.+90     	; 0x1b4c <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1af2:	e6 80       	ldd	r14, Z+6	; 0x06
    1af4:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1af6:	b6 01       	movw	r22, r12
    1af8:	c8 01       	movw	r24, r16
    1afa:	18 de       	rcall	.-976    	; 0x172c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1afc:	b1 10       	cpse	r11, r1
    1afe:	17 c0       	rjmp	.+46     	; 0x1b2e <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b00:	f8 01       	movw	r30, r16
    1b02:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b04:	81 50       	subi	r24, 0x01	; 1
    1b06:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b08:	80 81       	ld	r24, Z
    1b0a:	91 81       	ldd	r25, Z+1	; 0x01
    1b0c:	89 2b       	or	r24, r25
    1b0e:	21 f4       	brne	.+8      	; 0x1b18 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1b10:	6b d6       	rcall	.+3286   	; 0x27e8 <pvTaskIncrementMutexHeldCount>
    1b12:	f8 01       	movw	r30, r16
    1b14:	93 83       	std	Z+3, r25	; 0x03
    1b16:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b18:	f8 01       	movw	r30, r16
    1b1a:	80 85       	ldd	r24, Z+8	; 0x08
    1b1c:	88 23       	and	r24, r24
    1b1e:	91 f0       	breq	.+36     	; 0x1b44 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b20:	c8 01       	movw	r24, r16
    1b22:	08 96       	adiw	r24, 0x08	; 8
    1b24:	35 d5       	rcall	.+2666   	; 0x2590 <xTaskRemoveFromEventList>
    1b26:	81 30       	cpi	r24, 0x01	; 1
    1b28:	69 f4       	brne	.+26     	; 0x1b44 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b2a:	da dc       	rcall	.-1612   	; 0x14e0 <vPortYield>
    1b2c:	0b c0       	rjmp	.+22     	; 0x1b44 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b2e:	f8 01       	movw	r30, r16
    1b30:	f7 82       	std	Z+7, r15	; 0x07
    1b32:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b34:	81 89       	ldd	r24, Z+17	; 0x11
    1b36:	88 23       	and	r24, r24
    1b38:	29 f0       	breq	.+10     	; 0x1b44 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b3a:	c8 01       	movw	r24, r16
    1b3c:	41 96       	adiw	r24, 0x11	; 17
    1b3e:	28 d5       	rcall	.+2640   	; 0x2590 <xTaskRemoveFromEventList>
    1b40:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b42:	ce dc       	rcall	.-1636   	; 0x14e0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b44:	0f 90       	pop	r0
    1b46:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	52 c0       	rjmp	.+164    	; 0x1bf0 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b4c:	4c 81       	ldd	r20, Y+4	; 0x04
    1b4e:	5d 81       	ldd	r21, Y+5	; 0x05
    1b50:	45 2b       	or	r20, r21
    1b52:	21 f4       	brne	.+8      	; 0x1b5c <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b54:	0f 90       	pop	r0
    1b56:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	4a c0       	rjmp	.+148    	; 0x1bf0 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b5c:	a1 10       	cpse	r10, r1
    1b5e:	04 c0       	rjmp	.+8      	; 0x1b68 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b60:	ce 01       	movw	r24, r28
    1b62:	01 96       	adiw	r24, 0x01	; 1
    1b64:	5d d5       	rcall	.+2746   	; 0x2620 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b66:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b6c:	70 d2       	rcall	.+1248   	; 0x204e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b6e:	0f b6       	in	r0, 0x3f	; 63
    1b70:	f8 94       	cli
    1b72:	0f 92       	push	r0
    1b74:	f8 01       	movw	r30, r16
    1b76:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b78:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <xQueueGenericReceive+0xd2>
    1b7c:	15 8e       	std	Z+29, r1	; 0x1d
    1b7e:	f8 01       	movw	r30, r16
    1b80:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b82:	8f 3f       	cpi	r24, 0xFF	; 255
    1b84:	09 f4       	brne	.+2      	; 0x1b88 <xQueueGenericReceive+0xdc>
    1b86:	16 8e       	std	Z+30, r1	; 0x1e
    1b88:	0f 90       	pop	r0
    1b8a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b8c:	be 01       	movw	r22, r28
    1b8e:	6c 5f       	subi	r22, 0xFC	; 252
    1b90:	7f 4f       	sbci	r23, 0xFF	; 255
    1b92:	ce 01       	movw	r24, r28
    1b94:	01 96       	adiw	r24, 0x01	; 1
    1b96:	4f d5       	rcall	.+2718   	; 0x2636 <xTaskCheckForTimeOut>
    1b98:	81 11       	cpse	r24, r1
    1b9a:	26 c0       	rjmp	.+76     	; 0x1be8 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b9c:	0f b6       	in	r0, 0x3f	; 63
    1b9e:	f8 94       	cli
    1ba0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ba2:	f8 01       	movw	r30, r16
    1ba4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1baa:	81 11       	cpse	r24, r1
    1bac:	19 c0       	rjmp	.+50     	; 0x1be0 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1bae:	f8 01       	movw	r30, r16
    1bb0:	80 81       	ld	r24, Z
    1bb2:	91 81       	ldd	r25, Z+1	; 0x01
    1bb4:	89 2b       	or	r24, r25
    1bb6:	49 f4       	brne	.+18     	; 0x1bca <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1bb8:	0f b6       	in	r0, 0x3f	; 63
    1bba:	f8 94       	cli
    1bbc:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	82 81       	ldd	r24, Z+2	; 0x02
    1bc2:	93 81       	ldd	r25, Z+3	; 0x03
    1bc4:	74 d5       	rcall	.+2792   	; 0x26ae <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1bc6:	0f 90       	pop	r0
    1bc8:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bca:	6c 81       	ldd	r22, Y+4	; 0x04
    1bcc:	7d 81       	ldd	r23, Y+5	; 0x05
    1bce:	c7 01       	movw	r24, r14
    1bd0:	b4 d4       	rcall	.+2408   	; 0x253a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bd2:	c8 01       	movw	r24, r16
    1bd4:	c5 dd       	rcall	.-1142   	; 0x1760 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1bd6:	0e d3       	rcall	.+1564   	; 0x21f4 <xTaskResumeAll>
    1bd8:	81 11       	cpse	r24, r1
    1bda:	84 cf       	rjmp	.-248    	; 0x1ae4 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1bdc:	81 dc       	rcall	.-1790   	; 0x14e0 <vPortYield>
    1bde:	82 cf       	rjmp	.-252    	; 0x1ae4 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1be0:	c8 01       	movw	r24, r16
    1be2:	be dd       	rcall	.-1156   	; 0x1760 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1be4:	07 d3       	rcall	.+1550   	; 0x21f4 <xTaskResumeAll>
    1be6:	7e cf       	rjmp	.-260    	; 0x1ae4 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1be8:	c8 01       	movw	r24, r16
    1bea:	ba dd       	rcall	.-1164   	; 0x1760 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bec:	03 d3       	rcall	.+1542   	; 0x21f4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1bee:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1bf0:	0f 90       	pop	r0
    1bf2:	0f 90       	pop	r0
    1bf4:	0f 90       	pop	r0
    1bf6:	0f 90       	pop	r0
    1bf8:	0f 90       	pop	r0
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	1f 91       	pop	r17
    1c00:	0f 91       	pop	r16
    1c02:	ff 90       	pop	r15
    1c04:	ef 90       	pop	r14
    1c06:	df 90       	pop	r13
    1c08:	cf 90       	pop	r12
    1c0a:	bf 90       	pop	r11
    1c0c:	af 90       	pop	r10
    1c0e:	9f 90       	pop	r9
    1c10:	08 95       	ret

00001c12 <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1c12:	fc 01       	movw	r30, r24
    1c14:	71 83       	std	Z+1, r23	; 0x01
    1c16:	60 83       	st	Z, r22
    1c18:	42 83       	std	Z+2, r20	; 0x02
    1c1a:	14 82       	std	Z+4, r1	; 0x04
    1c1c:	13 82       	std	Z+3, r1	; 0x03
    1c1e:	08 95       	ret

00001c20 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1c20:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1c22:	94 81       	ldd	r25, Z+4	; 0x04
    1c24:	a0 81       	ld	r26, Z
    1c26:	b1 81       	ldd	r27, Z+1	; 0x01
    1c28:	a9 0f       	add	r26, r25
    1c2a:	b1 1d       	adc	r27, r1
    1c2c:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1c2e:	9f 5f       	subi	r25, 0xFF	; 255
    1c30:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1c32:	22 81       	ldd	r18, Z+2	; 0x02
    1c34:	92 17       	cp	r25, r18
    1c36:	10 f0       	brcs	.+4      	; 0x1c3c <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1c38:	92 1b       	sub	r25, r18
    1c3a:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c3c:	93 81       	ldd	r25, Z+3	; 0x03
    1c3e:	91 50       	subi	r25, 0x01	; 1
    1c40:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c42:	08 95       	ret

00001c44 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c44:	fc 01       	movw	r30, r24
    1c46:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c48:	83 81       	ldd	r24, Z+3	; 0x03
    1c4a:	22 81       	ldd	r18, Z+2	; 0x02
    1c4c:	82 17       	cp	r24, r18
    1c4e:	80 f4       	brcc	.+32     	; 0x1c70 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c50:	34 81       	ldd	r19, Z+4	; 0x04
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	83 0f       	add	r24, r19
    1c56:	91 1d       	adc	r25, r1
    1c58:	62 2f       	mov	r22, r18
    1c5a:	70 e0       	ldi	r23, 0x00	; 0
    1c5c:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <__divmodhi4>
    1c60:	a0 81       	ld	r26, Z
    1c62:	b1 81       	ldd	r27, Z+1	; 0x01
    1c64:	a8 0f       	add	r26, r24
    1c66:	b9 1f       	adc	r27, r25
    1c68:	4c 93       	st	X, r20
            ring->rLength++;
    1c6a:	83 81       	ldd	r24, Z+3	; 0x03
    1c6c:	8f 5f       	subi	r24, 0xFF	; 255
    1c6e:	83 83       	std	Z+3, r24	; 0x03
    1c70:	08 95       	ret

00001c72 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c72:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c74:	81 e0       	ldi	r24, 0x01	; 1
    1c76:	22 81       	ldd	r18, Z+2	; 0x02
    1c78:	93 81       	ldd	r25, Z+3	; 0x03
    1c7a:	29 13       	cpse	r18, r25
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
}
    1c7e:	08 95       	ret

00001c80 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c80:	21 e0       	ldi	r18, 0x01	; 1
    1c82:	fc 01       	movw	r30, r24
    1c84:	83 81       	ldd	r24, Z+3	; 0x03
    1c86:	81 11       	cpse	r24, r1
    1c88:	01 c0       	rjmp	.+2      	; 0x1c8c <ringBufferNotEmpty+0xc>
    1c8a:	20 e0       	ldi	r18, 0x00	; 0
}
    1c8c:	82 2f       	mov	r24, r18
    1c8e:	08 95       	ret

00001c90 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c90:	e0 91 50 08 	lds	r30, 0x0850
    1c94:	f0 91 51 08 	lds	r31, 0x0851
    1c98:	80 81       	ld	r24, Z
    1c9a:	81 11       	cpse	r24, r1
    1c9c:	07 c0       	rjmp	.+14     	; 0x1cac <prvResetNextTaskUnblockTime+0x1c>
    1c9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ca0:	9f ef       	ldi	r25, 0xFF	; 255
    1ca2:	90 93 06 02 	sts	0x0206, r25
    1ca6:	80 93 05 02 	sts	0x0205, r24
    1caa:	08 95       	ret
    1cac:	e0 91 50 08 	lds	r30, 0x0850
    1cb0:	f0 91 51 08 	lds	r31, 0x0851
    1cb4:	05 80       	ldd	r0, Z+5	; 0x05
    1cb6:	f6 81       	ldd	r31, Z+6	; 0x06
    1cb8:	e0 2d       	mov	r30, r0
    1cba:	06 80       	ldd	r0, Z+6	; 0x06
    1cbc:	f7 81       	ldd	r31, Z+7	; 0x07
    1cbe:	e0 2d       	mov	r30, r0
    1cc0:	82 81       	ldd	r24, Z+2	; 0x02
    1cc2:	93 81       	ldd	r25, Z+3	; 0x03
    1cc4:	90 93 06 02 	sts	0x0206, r25
    1cc8:	80 93 05 02 	sts	0x0205, r24
    1ccc:	08 95       	ret

00001cce <prvAddCurrentTaskToDelayedList>:
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
    1cd2:	ec 01       	movw	r28, r24
    1cd4:	e0 91 91 08 	lds	r30, 0x0891
    1cd8:	f0 91 92 08 	lds	r31, 0x0892
    1cdc:	93 83       	std	Z+3, r25	; 0x03
    1cde:	82 83       	std	Z+2, r24	; 0x02
    1ce0:	80 91 2f 08 	lds	r24, 0x082F
    1ce4:	90 91 30 08 	lds	r25, 0x0830
    1ce8:	c8 17       	cp	r28, r24
    1cea:	d9 07       	cpc	r29, r25
    1cec:	68 f4       	brcc	.+26     	; 0x1d08 <prvAddCurrentTaskToDelayedList+0x3a>
    1cee:	60 91 91 08 	lds	r22, 0x0891
    1cf2:	70 91 92 08 	lds	r23, 0x0892
    1cf6:	80 91 4e 08 	lds	r24, 0x084E
    1cfa:	90 91 4f 08 	lds	r25, 0x084F
    1cfe:	6e 5f       	subi	r22, 0xFE	; 254
    1d00:	7f 4f       	sbci	r23, 0xFF	; 255
    1d02:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    1d06:	17 c0       	rjmp	.+46     	; 0x1d36 <prvAddCurrentTaskToDelayedList+0x68>
    1d08:	60 91 91 08 	lds	r22, 0x0891
    1d0c:	70 91 92 08 	lds	r23, 0x0892
    1d10:	80 91 50 08 	lds	r24, 0x0850
    1d14:	90 91 51 08 	lds	r25, 0x0851
    1d18:	6e 5f       	subi	r22, 0xFE	; 254
    1d1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d1c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    1d20:	80 91 05 02 	lds	r24, 0x0205
    1d24:	90 91 06 02 	lds	r25, 0x0206
    1d28:	c8 17       	cp	r28, r24
    1d2a:	d9 07       	cpc	r29, r25
    1d2c:	20 f4       	brcc	.+8      	; 0x1d36 <prvAddCurrentTaskToDelayedList+0x68>
    1d2e:	d0 93 06 02 	sts	0x0206, r29
    1d32:	c0 93 05 02 	sts	0x0205, r28
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	08 95       	ret

00001d3c <xTaskGenericCreate>:
    1d3c:	4f 92       	push	r4
    1d3e:	5f 92       	push	r5
    1d40:	6f 92       	push	r6
    1d42:	7f 92       	push	r7
    1d44:	8f 92       	push	r8
    1d46:	9f 92       	push	r9
    1d48:	af 92       	push	r10
    1d4a:	bf 92       	push	r11
    1d4c:	cf 92       	push	r12
    1d4e:	df 92       	push	r13
    1d50:	ef 92       	push	r14
    1d52:	ff 92       	push	r15
    1d54:	0f 93       	push	r16
    1d56:	1f 93       	push	r17
    1d58:	cf 93       	push	r28
    1d5a:	df 93       	push	r29
    1d5c:	4c 01       	movw	r8, r24
    1d5e:	5b 01       	movw	r10, r22
    1d60:	2a 01       	movw	r4, r20
    1d62:	39 01       	movw	r6, r18
    1d64:	83 e2       	ldi	r24, 0x23	; 35
    1d66:	90 e0       	ldi	r25, 0x00	; 0
    1d68:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1d6c:	ec 01       	movw	r28, r24
    1d6e:	00 97       	sbiw	r24, 0x00	; 0
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <xTaskGenericCreate+0x38>
    1d72:	e7 c0       	rjmp	.+462    	; 0x1f42 <xTaskGenericCreate+0x206>
    1d74:	c1 14       	cp	r12, r1
    1d76:	d1 04       	cpc	r13, r1
    1d78:	09 f0       	breq	.+2      	; 0x1d7c <xTaskGenericCreate+0x40>
    1d7a:	cc c0       	rjmp	.+408    	; 0x1f14 <xTaskGenericCreate+0x1d8>
    1d7c:	c2 01       	movw	r24, r4
    1d7e:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1d82:	98 8f       	std	Y+24, r25	; 0x18
    1d84:	8f 8b       	std	Y+23, r24	; 0x17
    1d86:	89 2b       	or	r24, r25
    1d88:	09 f0       	breq	.+2      	; 0x1d8c <xTaskGenericCreate+0x50>
    1d8a:	c6 c0       	rjmp	.+396    	; 0x1f18 <xTaskGenericCreate+0x1dc>
    1d8c:	ce 01       	movw	r24, r28
    1d8e:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    1d92:	d7 c0       	rjmp	.+430    	; 0x1f42 <xTaskGenericCreate+0x206>
    1d94:	cf 01       	movw	r24, r30
    1d96:	31 91       	ld	r19, Z+
    1d98:	da 01       	movw	r26, r20
    1d9a:	3d 93       	st	X+, r19
    1d9c:	ad 01       	movw	r20, r26
    1d9e:	dc 01       	movw	r26, r24
    1da0:	8c 91       	ld	r24, X
    1da2:	88 23       	and	r24, r24
    1da4:	11 f0       	breq	.+4      	; 0x1daa <xTaskGenericCreate+0x6e>
    1da6:	21 50       	subi	r18, 0x01	; 1
    1da8:	a9 f7       	brne	.-22     	; 0x1d94 <xTaskGenericCreate+0x58>
    1daa:	18 a2       	std	Y+32, r1	; 0x20
    1dac:	10 2f       	mov	r17, r16
    1dae:	05 30       	cpi	r16, 0x05	; 5
    1db0:	08 f0       	brcs	.+2      	; 0x1db4 <xTaskGenericCreate+0x78>
    1db2:	14 e0       	ldi	r17, 0x04	; 4
    1db4:	1e 8b       	std	Y+22, r17	; 0x16
    1db6:	19 a3       	std	Y+33, r17	; 0x21
    1db8:	1a a2       	std	Y+34, r1	; 0x22
    1dba:	5e 01       	movw	r10, r28
    1dbc:	b2 e0       	ldi	r27, 0x02	; 2
    1dbe:	ab 0e       	add	r10, r27
    1dc0:	b1 1c       	adc	r11, r1
    1dc2:	c5 01       	movw	r24, r10
    1dc4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
    1dc8:	ce 01       	movw	r24, r28
    1dca:	0c 96       	adiw	r24, 0x0c	; 12
    1dcc:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
    1dd0:	d9 87       	std	Y+9, r29	; 0x09
    1dd2:	c8 87       	std	Y+8, r28	; 0x08
    1dd4:	85 e0       	ldi	r24, 0x05	; 5
    1dd6:	90 e0       	ldi	r25, 0x00	; 0
    1dd8:	81 1b       	sub	r24, r17
    1dda:	91 09       	sbc	r25, r1
    1ddc:	9d 87       	std	Y+13, r25	; 0x0d
    1dde:	8c 87       	std	Y+12, r24	; 0x0c
    1de0:	db 8b       	std	Y+19, r29	; 0x13
    1de2:	ca 8b       	std	Y+18, r28	; 0x12
    1de4:	a3 01       	movw	r20, r6
    1de6:	b4 01       	movw	r22, r8
    1de8:	c6 01       	movw	r24, r12
    1dea:	cb da       	rcall	.-2666   	; 0x1382 <pxPortInitialiseStack>
    1dec:	99 83       	std	Y+1, r25	; 0x01
    1dee:	88 83       	st	Y, r24
    1df0:	e1 14       	cp	r14, r1
    1df2:	f1 04       	cpc	r15, r1
    1df4:	19 f0       	breq	.+6      	; 0x1dfc <xTaskGenericCreate+0xc0>
    1df6:	f7 01       	movw	r30, r14
    1df8:	d1 83       	std	Z+1, r29	; 0x01
    1dfa:	c0 83       	st	Z, r28
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	f8 94       	cli
    1e00:	0f 92       	push	r0
    1e02:	80 91 31 08 	lds	r24, 0x0831
    1e06:	8f 5f       	subi	r24, 0xFF	; 255
    1e08:	80 93 31 08 	sts	0x0831, r24
    1e0c:	80 91 91 08 	lds	r24, 0x0891
    1e10:	90 91 92 08 	lds	r25, 0x0892
    1e14:	89 2b       	or	r24, r25
    1e16:	09 f0       	breq	.+2      	; 0x1e1a <xTaskGenericCreate+0xde>
    1e18:	3f c0       	rjmp	.+126    	; 0x1e98 <xTaskGenericCreate+0x15c>
    1e1a:	d0 93 92 08 	sts	0x0892, r29
    1e1e:	c0 93 91 08 	sts	0x0891, r28
    1e22:	80 91 31 08 	lds	r24, 0x0831
    1e26:	81 30       	cpi	r24, 0x01	; 1
    1e28:	09 f0       	breq	.+2      	; 0x1e2c <xTaskGenericCreate+0xf0>
    1e2a:	45 c0       	rjmp	.+138    	; 0x1eb6 <xTaskGenericCreate+0x17a>
    1e2c:	0f 2e       	mov	r0, r31
    1e2e:	f4 e6       	ldi	r31, 0x64	; 100
    1e30:	ef 2e       	mov	r14, r31
    1e32:	f8 e0       	ldi	r31, 0x08	; 8
    1e34:	ff 2e       	mov	r15, r31
    1e36:	f0 2d       	mov	r31, r0
    1e38:	0f 2e       	mov	r0, r31
    1e3a:	f1 e9       	ldi	r31, 0x91	; 145
    1e3c:	cf 2e       	mov	r12, r31
    1e3e:	f8 e0       	ldi	r31, 0x08	; 8
    1e40:	df 2e       	mov	r13, r31
    1e42:	f0 2d       	mov	r31, r0
    1e44:	c7 01       	movw	r24, r14
    1e46:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e4a:	f9 e0       	ldi	r31, 0x09	; 9
    1e4c:	ef 0e       	add	r14, r31
    1e4e:	f1 1c       	adc	r15, r1
    1e50:	ec 14       	cp	r14, r12
    1e52:	fd 04       	cpc	r15, r13
    1e54:	b9 f7       	brne	.-18     	; 0x1e44 <xTaskGenericCreate+0x108>
    1e56:	8b e5       	ldi	r24, 0x5B	; 91
    1e58:	98 e0       	ldi	r25, 0x08	; 8
    1e5a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e5e:	82 e5       	ldi	r24, 0x52	; 82
    1e60:	98 e0       	ldi	r25, 0x08	; 8
    1e62:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e66:	85 e4       	ldi	r24, 0x45	; 69
    1e68:	98 e0       	ldi	r25, 0x08	; 8
    1e6a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e6e:	8c e3       	ldi	r24, 0x3C	; 60
    1e70:	98 e0       	ldi	r25, 0x08	; 8
    1e72:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e76:	82 e3       	ldi	r24, 0x32	; 50
    1e78:	98 e0       	ldi	r25, 0x08	; 8
    1e7a:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e7e:	8b e5       	ldi	r24, 0x5B	; 91
    1e80:	98 e0       	ldi	r25, 0x08	; 8
    1e82:	90 93 51 08 	sts	0x0851, r25
    1e86:	80 93 50 08 	sts	0x0850, r24
    1e8a:	82 e5       	ldi	r24, 0x52	; 82
    1e8c:	98 e0       	ldi	r25, 0x08	; 8
    1e8e:	90 93 4f 08 	sts	0x084F, r25
    1e92:	80 93 4e 08 	sts	0x084E, r24
    1e96:	0f c0       	rjmp	.+30     	; 0x1eb6 <xTaskGenericCreate+0x17a>
    1e98:	80 91 2d 08 	lds	r24, 0x082D
    1e9c:	81 11       	cpse	r24, r1
    1e9e:	0b c0       	rjmp	.+22     	; 0x1eb6 <xTaskGenericCreate+0x17a>
    1ea0:	e0 91 91 08 	lds	r30, 0x0891
    1ea4:	f0 91 92 08 	lds	r31, 0x0892
    1ea8:	86 89       	ldd	r24, Z+22	; 0x16
    1eaa:	08 17       	cp	r16, r24
    1eac:	20 f0       	brcs	.+8      	; 0x1eb6 <xTaskGenericCreate+0x17a>
    1eae:	d0 93 92 08 	sts	0x0892, r29
    1eb2:	c0 93 91 08 	sts	0x0891, r28
    1eb6:	80 91 29 08 	lds	r24, 0x0829
    1eba:	8f 5f       	subi	r24, 0xFF	; 255
    1ebc:	80 93 29 08 	sts	0x0829, r24
    1ec0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ec2:	90 91 2e 08 	lds	r25, 0x082E
    1ec6:	98 17       	cp	r25, r24
    1ec8:	10 f4       	brcc	.+4      	; 0x1ece <xTaskGenericCreate+0x192>
    1eca:	80 93 2e 08 	sts	0x082E, r24
    1ece:	90 e0       	ldi	r25, 0x00	; 0
    1ed0:	9c 01       	movw	r18, r24
    1ed2:	22 0f       	add	r18, r18
    1ed4:	33 1f       	adc	r19, r19
    1ed6:	22 0f       	add	r18, r18
    1ed8:	33 1f       	adc	r19, r19
    1eda:	22 0f       	add	r18, r18
    1edc:	33 1f       	adc	r19, r19
    1ede:	82 0f       	add	r24, r18
    1ee0:	93 1f       	adc	r25, r19
    1ee2:	b5 01       	movw	r22, r10
    1ee4:	8c 59       	subi	r24, 0x9C	; 156
    1ee6:	97 4f       	sbci	r25, 0xF7	; 247
    1ee8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63
    1ef0:	80 91 2d 08 	lds	r24, 0x082D
    1ef4:	88 23       	and	r24, r24
    1ef6:	51 f0       	breq	.+20     	; 0x1f0c <xTaskGenericCreate+0x1d0>
    1ef8:	e0 91 91 08 	lds	r30, 0x0891
    1efc:	f0 91 92 08 	lds	r31, 0x0892
    1f00:	86 89       	ldd	r24, Z+22	; 0x16
    1f02:	80 17       	cp	r24, r16
    1f04:	28 f4       	brcc	.+10     	; 0x1f10 <xTaskGenericCreate+0x1d4>
    1f06:	ec da       	rcall	.-2600   	; 0x14e0 <vPortYield>
    1f08:	81 e0       	ldi	r24, 0x01	; 1
    1f0a:	1c c0       	rjmp	.+56     	; 0x1f44 <xTaskGenericCreate+0x208>
    1f0c:	81 e0       	ldi	r24, 0x01	; 1
    1f0e:	1a c0       	rjmp	.+52     	; 0x1f44 <xTaskGenericCreate+0x208>
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	18 c0       	rjmp	.+48     	; 0x1f44 <xTaskGenericCreate+0x208>
    1f14:	d8 8e       	std	Y+24, r13	; 0x18
    1f16:	cf 8a       	std	Y+23, r12	; 0x17
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	48 1a       	sub	r4, r24
    1f1c:	51 08       	sbc	r5, r1
    1f1e:	cf 88       	ldd	r12, Y+23	; 0x17
    1f20:	d8 8c       	ldd	r13, Y+24	; 0x18
    1f22:	c4 0c       	add	r12, r4
    1f24:	d5 1c       	adc	r13, r5
    1f26:	d5 01       	movw	r26, r10
    1f28:	8c 91       	ld	r24, X
    1f2a:	89 8f       	std	Y+25, r24	; 0x19
    1f2c:	8c 91       	ld	r24, X
    1f2e:	88 23       	and	r24, r24
    1f30:	09 f4       	brne	.+2      	; 0x1f34 <xTaskGenericCreate+0x1f8>
    1f32:	3b cf       	rjmp	.-394    	; 0x1daa <xTaskGenericCreate+0x6e>
    1f34:	ae 01       	movw	r20, r28
    1f36:	46 5e       	subi	r20, 0xE6	; 230
    1f38:	5f 4f       	sbci	r21, 0xFF	; 255
    1f3a:	f5 01       	movw	r30, r10
    1f3c:	31 96       	adiw	r30, 0x01	; 1
    1f3e:	27 e0       	ldi	r18, 0x07	; 7
    1f40:	29 cf       	rjmp	.-430    	; 0x1d94 <xTaskGenericCreate+0x58>
    1f42:	8f ef       	ldi	r24, 0xFF	; 255
    1f44:	df 91       	pop	r29
    1f46:	cf 91       	pop	r28
    1f48:	1f 91       	pop	r17
    1f4a:	0f 91       	pop	r16
    1f4c:	ff 90       	pop	r15
    1f4e:	ef 90       	pop	r14
    1f50:	df 90       	pop	r13
    1f52:	cf 90       	pop	r12
    1f54:	bf 90       	pop	r11
    1f56:	af 90       	pop	r10
    1f58:	9f 90       	pop	r9
    1f5a:	8f 90       	pop	r8
    1f5c:	7f 90       	pop	r7
    1f5e:	6f 90       	pop	r6
    1f60:	5f 90       	pop	r5
    1f62:	4f 90       	pop	r4
    1f64:	08 95       	ret

00001f66 <vTaskResume>:
    1f66:	0f 93       	push	r16
    1f68:	1f 93       	push	r17
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
    1f6e:	ec 01       	movw	r28, r24
    1f70:	00 97       	sbiw	r24, 0x00	; 0
    1f72:	09 f4       	brne	.+2      	; 0x1f76 <vTaskResume+0x10>
    1f74:	3e c0       	rjmp	.+124    	; 0x1ff2 <vTaskResume+0x8c>
    1f76:	80 91 91 08 	lds	r24, 0x0891
    1f7a:	90 91 92 08 	lds	r25, 0x0892
    1f7e:	c8 17       	cp	r28, r24
    1f80:	d9 07       	cpc	r29, r25
    1f82:	b9 f1       	breq	.+110    	; 0x1ff2 <vTaskResume+0x8c>
    1f84:	0f b6       	in	r0, 0x3f	; 63
    1f86:	f8 94       	cli
    1f88:	0f 92       	push	r0
    1f8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f8c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f8e:	82 53       	subi	r24, 0x32	; 50
    1f90:	98 40       	sbci	r25, 0x08	; 8
    1f92:	69 f5       	brne	.+90     	; 0x1fee <vTaskResume+0x88>
    1f94:	8c 89       	ldd	r24, Y+20	; 0x14
    1f96:	9d 89       	ldd	r25, Y+21	; 0x15
    1f98:	28 e0       	ldi	r18, 0x08	; 8
    1f9a:	85 34       	cpi	r24, 0x45	; 69
    1f9c:	92 07       	cpc	r25, r18
    1f9e:	39 f1       	breq	.+78     	; 0x1fee <vTaskResume+0x88>
    1fa0:	89 2b       	or	r24, r25
    1fa2:	29 f5       	brne	.+74     	; 0x1fee <vTaskResume+0x88>
    1fa4:	8e 01       	movw	r16, r28
    1fa6:	0e 5f       	subi	r16, 0xFE	; 254
    1fa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1faa:	c8 01       	movw	r24, r16
    1fac:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    1fb0:	8e 89       	ldd	r24, Y+22	; 0x16
    1fb2:	90 91 2e 08 	lds	r25, 0x082E
    1fb6:	98 17       	cp	r25, r24
    1fb8:	10 f4       	brcc	.+4      	; 0x1fbe <vTaskResume+0x58>
    1fba:	80 93 2e 08 	sts	0x082E, r24
    1fbe:	90 e0       	ldi	r25, 0x00	; 0
    1fc0:	9c 01       	movw	r18, r24
    1fc2:	22 0f       	add	r18, r18
    1fc4:	33 1f       	adc	r19, r19
    1fc6:	22 0f       	add	r18, r18
    1fc8:	33 1f       	adc	r19, r19
    1fca:	22 0f       	add	r18, r18
    1fcc:	33 1f       	adc	r19, r19
    1fce:	82 0f       	add	r24, r18
    1fd0:	93 1f       	adc	r25, r19
    1fd2:	b8 01       	movw	r22, r16
    1fd4:	8c 59       	subi	r24, 0x9C	; 156
    1fd6:	97 4f       	sbci	r25, 0xF7	; 247
    1fd8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1fdc:	e0 91 91 08 	lds	r30, 0x0891
    1fe0:	f0 91 92 08 	lds	r31, 0x0892
    1fe4:	9e 89       	ldd	r25, Y+22	; 0x16
    1fe6:	86 89       	ldd	r24, Z+22	; 0x16
    1fe8:	98 17       	cp	r25, r24
    1fea:	08 f0       	brcs	.+2      	; 0x1fee <vTaskResume+0x88>
    1fec:	79 da       	rcall	.-2830   	; 0x14e0 <vPortYield>
    1fee:	0f 90       	pop	r0
    1ff0:	0f be       	out	0x3f, r0	; 63
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	08 95       	ret

00001ffc <vTaskStartScheduler>:
    1ffc:	af 92       	push	r10
    1ffe:	bf 92       	push	r11
    2000:	cf 92       	push	r12
    2002:	df 92       	push	r13
    2004:	ef 92       	push	r14
    2006:	ff 92       	push	r15
    2008:	0f 93       	push	r16
    200a:	a1 2c       	mov	r10, r1
    200c:	b1 2c       	mov	r11, r1
    200e:	c1 2c       	mov	r12, r1
    2010:	d1 2c       	mov	r13, r1
    2012:	e1 2c       	mov	r14, r1
    2014:	f1 2c       	mov	r15, r1
    2016:	00 e0       	ldi	r16, 0x00	; 0
    2018:	20 e0       	ldi	r18, 0x00	; 0
    201a:	30 e0       	ldi	r19, 0x00	; 0
    201c:	45 e5       	ldi	r20, 0x55	; 85
    201e:	50 e0       	ldi	r21, 0x00	; 0
    2020:	63 e3       	ldi	r22, 0x33	; 51
    2022:	72 e0       	ldi	r23, 0x02	; 2
    2024:	89 eb       	ldi	r24, 0xB9	; 185
    2026:	91 e1       	ldi	r25, 0x11	; 17
    2028:	89 de       	rcall	.-750    	; 0x1d3c <xTaskGenericCreate>
    202a:	81 30       	cpi	r24, 0x01	; 1
    202c:	41 f4       	brne	.+16     	; 0x203e <vTaskStartScheduler+0x42>
    202e:	f8 94       	cli
    2030:	80 93 2d 08 	sts	0x082D, r24
    2034:	10 92 30 08 	sts	0x0830, r1
    2038:	10 92 2f 08 	sts	0x082F, r1
    203c:	14 da       	rcall	.-3032   	; 0x1466 <xPortStartScheduler>
    203e:	0f 91       	pop	r16
    2040:	ff 90       	pop	r15
    2042:	ef 90       	pop	r14
    2044:	df 90       	pop	r13
    2046:	cf 90       	pop	r12
    2048:	bf 90       	pop	r11
    204a:	af 90       	pop	r10
    204c:	08 95       	ret

0000204e <vTaskSuspendAll>:
    204e:	80 91 28 08 	lds	r24, 0x0828
    2052:	8f 5f       	subi	r24, 0xFF	; 255
    2054:	80 93 28 08 	sts	0x0828, r24
    2058:	08 95       	ret

0000205a <xTaskGetTickCount>:
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	0f 92       	push	r0
    2060:	80 91 2f 08 	lds	r24, 0x082F
    2064:	90 91 30 08 	lds	r25, 0x0830
    2068:	0f 90       	pop	r0
    206a:	0f be       	out	0x3f, r0	; 63
    206c:	08 95       	ret

0000206e <xTaskGetTickCountFromISR>:
    206e:	80 91 2f 08 	lds	r24, 0x082F
    2072:	90 91 30 08 	lds	r25, 0x0830
    2076:	08 95       	ret

00002078 <xTaskIncrementTick>:
    2078:	cf 92       	push	r12
    207a:	df 92       	push	r13
    207c:	ef 92       	push	r14
    207e:	ff 92       	push	r15
    2080:	0f 93       	push	r16
    2082:	1f 93       	push	r17
    2084:	cf 93       	push	r28
    2086:	df 93       	push	r29
    2088:	80 91 28 08 	lds	r24, 0x0828
    208c:	81 11       	cpse	r24, r1
    208e:	99 c0       	rjmp	.+306    	; 0x21c2 <xTaskIncrementTick+0x14a>
    2090:	80 91 2f 08 	lds	r24, 0x082F
    2094:	90 91 30 08 	lds	r25, 0x0830
    2098:	01 96       	adiw	r24, 0x01	; 1
    209a:	90 93 30 08 	sts	0x0830, r25
    209e:	80 93 2f 08 	sts	0x082F, r24
    20a2:	e0 90 2f 08 	lds	r14, 0x082F
    20a6:	f0 90 30 08 	lds	r15, 0x0830
    20aa:	e1 14       	cp	r14, r1
    20ac:	f1 04       	cpc	r15, r1
    20ae:	b1 f4       	brne	.+44     	; 0x20dc <xTaskIncrementTick+0x64>
    20b0:	80 91 50 08 	lds	r24, 0x0850
    20b4:	90 91 51 08 	lds	r25, 0x0851
    20b8:	20 91 4e 08 	lds	r18, 0x084E
    20bc:	30 91 4f 08 	lds	r19, 0x084F
    20c0:	30 93 51 08 	sts	0x0851, r19
    20c4:	20 93 50 08 	sts	0x0850, r18
    20c8:	90 93 4f 08 	sts	0x084F, r25
    20cc:	80 93 4e 08 	sts	0x084E, r24
    20d0:	80 91 2a 08 	lds	r24, 0x082A
    20d4:	8f 5f       	subi	r24, 0xFF	; 255
    20d6:	80 93 2a 08 	sts	0x082A, r24
    20da:	da dd       	rcall	.-1100   	; 0x1c90 <prvResetNextTaskUnblockTime>
    20dc:	80 91 05 02 	lds	r24, 0x0205
    20e0:	90 91 06 02 	lds	r25, 0x0206
    20e4:	e8 16       	cp	r14, r24
    20e6:	f9 06       	cpc	r15, r25
    20e8:	08 f4       	brcc	.+2      	; 0x20ec <xTaskIncrementTick+0x74>
    20ea:	54 c0       	rjmp	.+168    	; 0x2194 <xTaskIncrementTick+0x11c>
    20ec:	d1 2c       	mov	r13, r1
    20ee:	cc 24       	eor	r12, r12
    20f0:	c3 94       	inc	r12
    20f2:	01 c0       	rjmp	.+2      	; 0x20f6 <xTaskIncrementTick+0x7e>
    20f4:	dc 2c       	mov	r13, r12
    20f6:	e0 91 50 08 	lds	r30, 0x0850
    20fa:	f0 91 51 08 	lds	r31, 0x0851
    20fe:	80 81       	ld	r24, Z
    2100:	81 11       	cpse	r24, r1
    2102:	07 c0       	rjmp	.+14     	; 0x2112 <xTaskIncrementTick+0x9a>
    2104:	8f ef       	ldi	r24, 0xFF	; 255
    2106:	9f ef       	ldi	r25, 0xFF	; 255
    2108:	90 93 06 02 	sts	0x0206, r25
    210c:	80 93 05 02 	sts	0x0205, r24
    2110:	42 c0       	rjmp	.+132    	; 0x2196 <xTaskIncrementTick+0x11e>
    2112:	e0 91 50 08 	lds	r30, 0x0850
    2116:	f0 91 51 08 	lds	r31, 0x0851
    211a:	05 80       	ldd	r0, Z+5	; 0x05
    211c:	f6 81       	ldd	r31, Z+6	; 0x06
    211e:	e0 2d       	mov	r30, r0
    2120:	c6 81       	ldd	r28, Z+6	; 0x06
    2122:	d7 81       	ldd	r29, Z+7	; 0x07
    2124:	2a 81       	ldd	r18, Y+2	; 0x02
    2126:	3b 81       	ldd	r19, Y+3	; 0x03
    2128:	e2 16       	cp	r14, r18
    212a:	f3 06       	cpc	r15, r19
    212c:	28 f4       	brcc	.+10     	; 0x2138 <xTaskIncrementTick+0xc0>
    212e:	30 93 06 02 	sts	0x0206, r19
    2132:	20 93 05 02 	sts	0x0205, r18
    2136:	2f c0       	rjmp	.+94     	; 0x2196 <xTaskIncrementTick+0x11e>
    2138:	8e 01       	movw	r16, r28
    213a:	0e 5f       	subi	r16, 0xFE	; 254
    213c:	1f 4f       	sbci	r17, 0xFF	; 255
    213e:	c8 01       	movw	r24, r16
    2140:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2144:	8c 89       	ldd	r24, Y+20	; 0x14
    2146:	9d 89       	ldd	r25, Y+21	; 0x15
    2148:	89 2b       	or	r24, r25
    214a:	21 f0       	breq	.+8      	; 0x2154 <xTaskIncrementTick+0xdc>
    214c:	ce 01       	movw	r24, r28
    214e:	0c 96       	adiw	r24, 0x0c	; 12
    2150:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2154:	2e 89       	ldd	r18, Y+22	; 0x16
    2156:	80 91 2e 08 	lds	r24, 0x082E
    215a:	82 17       	cp	r24, r18
    215c:	10 f4       	brcc	.+4      	; 0x2162 <xTaskIncrementTick+0xea>
    215e:	20 93 2e 08 	sts	0x082E, r18
    2162:	30 e0       	ldi	r19, 0x00	; 0
    2164:	c9 01       	movw	r24, r18
    2166:	88 0f       	add	r24, r24
    2168:	99 1f       	adc	r25, r25
    216a:	88 0f       	add	r24, r24
    216c:	99 1f       	adc	r25, r25
    216e:	88 0f       	add	r24, r24
    2170:	99 1f       	adc	r25, r25
    2172:	82 0f       	add	r24, r18
    2174:	93 1f       	adc	r25, r19
    2176:	b8 01       	movw	r22, r16
    2178:	8c 59       	subi	r24, 0x9C	; 156
    217a:	97 4f       	sbci	r25, 0xF7	; 247
    217c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2180:	e0 91 91 08 	lds	r30, 0x0891
    2184:	f0 91 92 08 	lds	r31, 0x0892
    2188:	9e 89       	ldd	r25, Y+22	; 0x16
    218a:	86 89       	ldd	r24, Z+22	; 0x16
    218c:	98 17       	cp	r25, r24
    218e:	08 f0       	brcs	.+2      	; 0x2192 <xTaskIncrementTick+0x11a>
    2190:	b1 cf       	rjmp	.-158    	; 0x20f4 <xTaskIncrementTick+0x7c>
    2192:	b1 cf       	rjmp	.-158    	; 0x20f6 <xTaskIncrementTick+0x7e>
    2194:	d1 2c       	mov	r13, r1
    2196:	e0 91 91 08 	lds	r30, 0x0891
    219a:	f0 91 92 08 	lds	r31, 0x0892
    219e:	86 89       	ldd	r24, Z+22	; 0x16
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	fc 01       	movw	r30, r24
    21a4:	ee 0f       	add	r30, r30
    21a6:	ff 1f       	adc	r31, r31
    21a8:	ee 0f       	add	r30, r30
    21aa:	ff 1f       	adc	r31, r31
    21ac:	ee 0f       	add	r30, r30
    21ae:	ff 1f       	adc	r31, r31
    21b0:	8e 0f       	add	r24, r30
    21b2:	9f 1f       	adc	r25, r31
    21b4:	fc 01       	movw	r30, r24
    21b6:	ec 59       	subi	r30, 0x9C	; 156
    21b8:	f7 4f       	sbci	r31, 0xF7	; 247
    21ba:	80 81       	ld	r24, Z
    21bc:	82 30       	cpi	r24, 0x02	; 2
    21be:	40 f4       	brcc	.+16     	; 0x21d0 <xTaskIncrementTick+0x158>
    21c0:	09 c0       	rjmp	.+18     	; 0x21d4 <xTaskIncrementTick+0x15c>
    21c2:	80 91 2c 08 	lds	r24, 0x082C
    21c6:	8f 5f       	subi	r24, 0xFF	; 255
    21c8:	80 93 2c 08 	sts	0x082C, r24
    21cc:	d1 2c       	mov	r13, r1
    21ce:	02 c0       	rjmp	.+4      	; 0x21d4 <xTaskIncrementTick+0x15c>
    21d0:	dd 24       	eor	r13, r13
    21d2:	d3 94       	inc	r13
    21d4:	80 91 2b 08 	lds	r24, 0x082B
    21d8:	88 23       	and	r24, r24
    21da:	11 f0       	breq	.+4      	; 0x21e0 <xTaskIncrementTick+0x168>
    21dc:	dd 24       	eor	r13, r13
    21de:	d3 94       	inc	r13
    21e0:	8d 2d       	mov	r24, r13
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	1f 91       	pop	r17
    21e8:	0f 91       	pop	r16
    21ea:	ff 90       	pop	r15
    21ec:	ef 90       	pop	r14
    21ee:	df 90       	pop	r13
    21f0:	cf 90       	pop	r12
    21f2:	08 95       	ret

000021f4 <xTaskResumeAll>:
    21f4:	df 92       	push	r13
    21f6:	ef 92       	push	r14
    21f8:	ff 92       	push	r15
    21fa:	0f 93       	push	r16
    21fc:	1f 93       	push	r17
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	f8 94       	cli
    2206:	0f 92       	push	r0
    2208:	80 91 28 08 	lds	r24, 0x0828
    220c:	81 50       	subi	r24, 0x01	; 1
    220e:	80 93 28 08 	sts	0x0828, r24
    2212:	80 91 28 08 	lds	r24, 0x0828
    2216:	81 11       	cpse	r24, r1
    2218:	5f c0       	rjmp	.+190    	; 0x22d8 <__stack+0xd9>
    221a:	80 91 31 08 	lds	r24, 0x0831
    221e:	88 23       	and	r24, r24
    2220:	09 f4       	brne	.+2      	; 0x2224 <__stack+0x25>
    2222:	5c c0       	rjmp	.+184    	; 0x22dc <__stack+0xdd>
    2224:	0f 2e       	mov	r0, r31
    2226:	f5 e4       	ldi	r31, 0x45	; 69
    2228:	ef 2e       	mov	r14, r31
    222a:	f8 e0       	ldi	r31, 0x08	; 8
    222c:	ff 2e       	mov	r15, r31
    222e:	f0 2d       	mov	r31, r0
    2230:	dd 24       	eor	r13, r13
    2232:	d3 94       	inc	r13
    2234:	30 c0       	rjmp	.+96     	; 0x2296 <__stack+0x97>
    2236:	e0 91 4a 08 	lds	r30, 0x084A
    223a:	f0 91 4b 08 	lds	r31, 0x084B
    223e:	c6 81       	ldd	r28, Z+6	; 0x06
    2240:	d7 81       	ldd	r29, Z+7	; 0x07
    2242:	ce 01       	movw	r24, r28
    2244:	0c 96       	adiw	r24, 0x0c	; 12
    2246:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    224a:	8e 01       	movw	r16, r28
    224c:	0e 5f       	subi	r16, 0xFE	; 254
    224e:	1f 4f       	sbci	r17, 0xFF	; 255
    2250:	c8 01       	movw	r24, r16
    2252:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2256:	8e 89       	ldd	r24, Y+22	; 0x16
    2258:	90 91 2e 08 	lds	r25, 0x082E
    225c:	98 17       	cp	r25, r24
    225e:	10 f4       	brcc	.+4      	; 0x2264 <__stack+0x65>
    2260:	80 93 2e 08 	sts	0x082E, r24
    2264:	90 e0       	ldi	r25, 0x00	; 0
    2266:	9c 01       	movw	r18, r24
    2268:	22 0f       	add	r18, r18
    226a:	33 1f       	adc	r19, r19
    226c:	22 0f       	add	r18, r18
    226e:	33 1f       	adc	r19, r19
    2270:	22 0f       	add	r18, r18
    2272:	33 1f       	adc	r19, r19
    2274:	82 0f       	add	r24, r18
    2276:	93 1f       	adc	r25, r19
    2278:	b8 01       	movw	r22, r16
    227a:	8c 59       	subi	r24, 0x9C	; 156
    227c:	97 4f       	sbci	r25, 0xF7	; 247
    227e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2282:	e0 91 91 08 	lds	r30, 0x0891
    2286:	f0 91 92 08 	lds	r31, 0x0892
    228a:	9e 89       	ldd	r25, Y+22	; 0x16
    228c:	86 89       	ldd	r24, Z+22	; 0x16
    228e:	98 17       	cp	r25, r24
    2290:	10 f0       	brcs	.+4      	; 0x2296 <__stack+0x97>
    2292:	d0 92 2b 08 	sts	0x082B, r13
    2296:	f7 01       	movw	r30, r14
    2298:	80 81       	ld	r24, Z
    229a:	81 11       	cpse	r24, r1
    229c:	cc cf       	rjmp	.-104    	; 0x2236 <__stack+0x37>
    229e:	80 91 2c 08 	lds	r24, 0x082C
    22a2:	88 23       	and	r24, r24
    22a4:	91 f0       	breq	.+36     	; 0x22ca <__stack+0xcb>
    22a6:	80 91 2c 08 	lds	r24, 0x082C
    22aa:	88 23       	and	r24, r24
    22ac:	71 f0       	breq	.+28     	; 0x22ca <__stack+0xcb>
    22ae:	c1 e0       	ldi	r28, 0x01	; 1
    22b0:	e3 de       	rcall	.-570    	; 0x2078 <xTaskIncrementTick>
    22b2:	81 11       	cpse	r24, r1
    22b4:	c0 93 2b 08 	sts	0x082B, r28
    22b8:	80 91 2c 08 	lds	r24, 0x082C
    22bc:	81 50       	subi	r24, 0x01	; 1
    22be:	80 93 2c 08 	sts	0x082C, r24
    22c2:	80 91 2c 08 	lds	r24, 0x082C
    22c6:	81 11       	cpse	r24, r1
    22c8:	f3 cf       	rjmp	.-26     	; 0x22b0 <__stack+0xb1>
    22ca:	80 91 2b 08 	lds	r24, 0x082B
    22ce:	81 30       	cpi	r24, 0x01	; 1
    22d0:	39 f4       	brne	.+14     	; 0x22e0 <__stack+0xe1>
    22d2:	06 d9       	rcall	.-3572   	; 0x14e0 <vPortYield>
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	05 c0       	rjmp	.+10     	; 0x22e2 <__stack+0xe3>
    22d8:	80 e0       	ldi	r24, 0x00	; 0
    22da:	03 c0       	rjmp	.+6      	; 0x22e2 <__stack+0xe3>
    22dc:	80 e0       	ldi	r24, 0x00	; 0
    22de:	01 c0       	rjmp	.+2      	; 0x22e2 <__stack+0xe3>
    22e0:	80 e0       	ldi	r24, 0x00	; 0
    22e2:	0f 90       	pop	r0
    22e4:	0f be       	out	0x3f, r0	; 63
    22e6:	df 91       	pop	r29
    22e8:	cf 91       	pop	r28
    22ea:	1f 91       	pop	r17
    22ec:	0f 91       	pop	r16
    22ee:	ff 90       	pop	r15
    22f0:	ef 90       	pop	r14
    22f2:	df 90       	pop	r13
    22f4:	08 95       	ret

000022f6 <vTaskDelayUntil>:
    22f6:	0f 93       	push	r16
    22f8:	1f 93       	push	r17
    22fa:	cf 93       	push	r28
    22fc:	df 93       	push	r29
    22fe:	8c 01       	movw	r16, r24
    2300:	eb 01       	movw	r28, r22
    2302:	a5 de       	rcall	.-694    	; 0x204e <vTaskSuspendAll>
    2304:	80 91 2f 08 	lds	r24, 0x082F
    2308:	90 91 30 08 	lds	r25, 0x0830
    230c:	f8 01       	movw	r30, r16
    230e:	20 81       	ld	r18, Z
    2310:	31 81       	ldd	r19, Z+1	; 0x01
    2312:	c2 0f       	add	r28, r18
    2314:	d3 1f       	adc	r29, r19
    2316:	82 17       	cp	r24, r18
    2318:	93 07       	cpc	r25, r19
    231a:	48 f4       	brcc	.+18     	; 0x232e <vTaskDelayUntil+0x38>
    231c:	c2 17       	cp	r28, r18
    231e:	d3 07       	cpc	r29, r19
    2320:	f8 f4       	brcc	.+62     	; 0x2360 <vTaskDelayUntil+0x6a>
    2322:	d1 83       	std	Z+1, r29	; 0x01
    2324:	c0 83       	st	Z, r28
    2326:	8c 17       	cp	r24, r28
    2328:	9d 07       	cpc	r25, r29
    232a:	88 f4       	brcc	.+34     	; 0x234e <vTaskDelayUntil+0x58>
    232c:	07 c0       	rjmp	.+14     	; 0x233c <vTaskDelayUntil+0x46>
    232e:	c2 17       	cp	r28, r18
    2330:	d3 07       	cpc	r29, r19
    2332:	90 f0       	brcs	.+36     	; 0x2358 <vTaskDelayUntil+0x62>
    2334:	8c 17       	cp	r24, r28
    2336:	9d 07       	cpc	r25, r29
    2338:	78 f0       	brcs	.+30     	; 0x2358 <vTaskDelayUntil+0x62>
    233a:	12 c0       	rjmp	.+36     	; 0x2360 <vTaskDelayUntil+0x6a>
    233c:	80 91 91 08 	lds	r24, 0x0891
    2340:	90 91 92 08 	lds	r25, 0x0892
    2344:	02 96       	adiw	r24, 0x02	; 2
    2346:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    234a:	ce 01       	movw	r24, r28
    234c:	c0 dc       	rcall	.-1664   	; 0x1cce <prvAddCurrentTaskToDelayedList>
    234e:	52 df       	rcall	.-348    	; 0x21f4 <xTaskResumeAll>
    2350:	81 11       	cpse	r24, r1
    2352:	0a c0       	rjmp	.+20     	; 0x2368 <vTaskDelayUntil+0x72>
    2354:	c5 d8       	rcall	.-3702   	; 0x14e0 <vPortYield>
    2356:	08 c0       	rjmp	.+16     	; 0x2368 <vTaskDelayUntil+0x72>
    2358:	f8 01       	movw	r30, r16
    235a:	d1 83       	std	Z+1, r29	; 0x01
    235c:	c0 83       	st	Z, r28
    235e:	ee cf       	rjmp	.-36     	; 0x233c <vTaskDelayUntil+0x46>
    2360:	f8 01       	movw	r30, r16
    2362:	d1 83       	std	Z+1, r29	; 0x01
    2364:	c0 83       	st	Z, r28
    2366:	f3 cf       	rjmp	.-26     	; 0x234e <vTaskDelayUntil+0x58>
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	1f 91       	pop	r17
    236e:	0f 91       	pop	r16
    2370:	08 95       	ret

00002372 <prvIdleTask>:
    2372:	0f 2e       	mov	r0, r31
    2374:	f4 e6       	ldi	r31, 0x64	; 100
    2376:	ef 2e       	mov	r14, r31
    2378:	f8 e0       	ldi	r31, 0x08	; 8
    237a:	ff 2e       	mov	r15, r31
    237c:	f0 2d       	mov	r31, r0
    237e:	cc e3       	ldi	r28, 0x3C	; 60
    2380:	d8 e0       	ldi	r29, 0x08	; 8
    2382:	26 c0       	rjmp	.+76     	; 0x23d0 <prvIdleTask+0x5e>
    2384:	64 de       	rcall	.-824    	; 0x204e <vTaskSuspendAll>
    2386:	18 81       	ld	r17, Y
    2388:	35 df       	rcall	.-406    	; 0x21f4 <xTaskResumeAll>
    238a:	11 23       	and	r17, r17
    238c:	09 f1       	breq	.+66     	; 0x23d0 <prvIdleTask+0x5e>
    238e:	0f b6       	in	r0, 0x3f	; 63
    2390:	f8 94       	cli
    2392:	0f 92       	push	r0
    2394:	e0 91 41 08 	lds	r30, 0x0841
    2398:	f0 91 42 08 	lds	r31, 0x0842
    239c:	06 81       	ldd	r16, Z+6	; 0x06
    239e:	17 81       	ldd	r17, Z+7	; 0x07
    23a0:	c8 01       	movw	r24, r16
    23a2:	02 96       	adiw	r24, 0x02	; 2
    23a4:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    23a8:	80 91 31 08 	lds	r24, 0x0831
    23ac:	81 50       	subi	r24, 0x01	; 1
    23ae:	80 93 31 08 	sts	0x0831, r24
    23b2:	80 91 3b 08 	lds	r24, 0x083B
    23b6:	81 50       	subi	r24, 0x01	; 1
    23b8:	80 93 3b 08 	sts	0x083B, r24
    23bc:	0f 90       	pop	r0
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	f8 01       	movw	r30, r16
    23c2:	87 89       	ldd	r24, Z+23	; 0x17
    23c4:	90 8d       	ldd	r25, Z+24	; 0x18
    23c6:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    23ca:	c8 01       	movw	r24, r16
    23cc:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    23d0:	80 91 3b 08 	lds	r24, 0x083B
    23d4:	81 11       	cpse	r24, r1
    23d6:	d6 cf       	rjmp	.-84     	; 0x2384 <prvIdleTask+0x12>
    23d8:	f7 01       	movw	r30, r14
    23da:	80 81       	ld	r24, Z
    23dc:	82 30       	cpi	r24, 0x02	; 2
    23de:	c0 f3       	brcs	.-16     	; 0x23d0 <prvIdleTask+0x5e>
    23e0:	7f d8       	rcall	.-3842   	; 0x14e0 <vPortYield>
    23e2:	f6 cf       	rjmp	.-20     	; 0x23d0 <prvIdleTask+0x5e>

000023e4 <vTaskSwitchContext>:
    23e4:	80 91 28 08 	lds	r24, 0x0828
    23e8:	88 23       	and	r24, r24
    23ea:	21 f0       	breq	.+8      	; 0x23f4 <vTaskSwitchContext+0x10>
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	80 93 2b 08 	sts	0x082B, r24
    23f2:	08 95       	ret
    23f4:	10 92 2b 08 	sts	0x082B, r1
    23f8:	80 91 2e 08 	lds	r24, 0x082E
    23fc:	90 e0       	ldi	r25, 0x00	; 0
    23fe:	fc 01       	movw	r30, r24
    2400:	ee 0f       	add	r30, r30
    2402:	ff 1f       	adc	r31, r31
    2404:	ee 0f       	add	r30, r30
    2406:	ff 1f       	adc	r31, r31
    2408:	ee 0f       	add	r30, r30
    240a:	ff 1f       	adc	r31, r31
    240c:	8e 0f       	add	r24, r30
    240e:	9f 1f       	adc	r25, r31
    2410:	fc 01       	movw	r30, r24
    2412:	ec 59       	subi	r30, 0x9C	; 156
    2414:	f7 4f       	sbci	r31, 0xF7	; 247
    2416:	80 81       	ld	r24, Z
    2418:	81 11       	cpse	r24, r1
    241a:	17 c0       	rjmp	.+46     	; 0x244a <vTaskSwitchContext+0x66>
    241c:	80 91 2e 08 	lds	r24, 0x082E
    2420:	81 50       	subi	r24, 0x01	; 1
    2422:	80 93 2e 08 	sts	0x082E, r24
    2426:	80 91 2e 08 	lds	r24, 0x082E
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	fc 01       	movw	r30, r24
    242e:	ee 0f       	add	r30, r30
    2430:	ff 1f       	adc	r31, r31
    2432:	ee 0f       	add	r30, r30
    2434:	ff 1f       	adc	r31, r31
    2436:	ee 0f       	add	r30, r30
    2438:	ff 1f       	adc	r31, r31
    243a:	8e 0f       	add	r24, r30
    243c:	9f 1f       	adc	r25, r31
    243e:	fc 01       	movw	r30, r24
    2440:	ec 59       	subi	r30, 0x9C	; 156
    2442:	f7 4f       	sbci	r31, 0xF7	; 247
    2444:	80 81       	ld	r24, Z
    2446:	88 23       	and	r24, r24
    2448:	49 f3       	breq	.-46     	; 0x241c <vTaskSwitchContext+0x38>
    244a:	e0 91 2e 08 	lds	r30, 0x082E
    244e:	f0 e0       	ldi	r31, 0x00	; 0
    2450:	cf 01       	movw	r24, r30
    2452:	88 0f       	add	r24, r24
    2454:	99 1f       	adc	r25, r25
    2456:	88 0f       	add	r24, r24
    2458:	99 1f       	adc	r25, r25
    245a:	88 0f       	add	r24, r24
    245c:	99 1f       	adc	r25, r25
    245e:	e8 0f       	add	r30, r24
    2460:	f9 1f       	adc	r31, r25
    2462:	ec 59       	subi	r30, 0x9C	; 156
    2464:	f7 4f       	sbci	r31, 0xF7	; 247
    2466:	a1 81       	ldd	r26, Z+1	; 0x01
    2468:	b2 81       	ldd	r27, Z+2	; 0x02
    246a:	12 96       	adiw	r26, 0x02	; 2
    246c:	0d 90       	ld	r0, X+
    246e:	bc 91       	ld	r27, X
    2470:	a0 2d       	mov	r26, r0
    2472:	b2 83       	std	Z+2, r27	; 0x02
    2474:	a1 83       	std	Z+1, r26	; 0x01
    2476:	cf 01       	movw	r24, r30
    2478:	03 96       	adiw	r24, 0x03	; 3
    247a:	a8 17       	cp	r26, r24
    247c:	b9 07       	cpc	r27, r25
    247e:	31 f4       	brne	.+12     	; 0x248c <vTaskSwitchContext+0xa8>
    2480:	12 96       	adiw	r26, 0x02	; 2
    2482:	8d 91       	ld	r24, X+
    2484:	9c 91       	ld	r25, X
    2486:	13 97       	sbiw	r26, 0x03	; 3
    2488:	92 83       	std	Z+2, r25	; 0x02
    248a:	81 83       	std	Z+1, r24	; 0x01
    248c:	01 80       	ldd	r0, Z+1	; 0x01
    248e:	f2 81       	ldd	r31, Z+2	; 0x02
    2490:	e0 2d       	mov	r30, r0
    2492:	86 81       	ldd	r24, Z+6	; 0x06
    2494:	97 81       	ldd	r25, Z+7	; 0x07
    2496:	90 93 92 08 	sts	0x0892, r25
    249a:	80 93 91 08 	sts	0x0891, r24
    249e:	08 95       	ret

000024a0 <vTaskSuspend>:
    24a0:	0f 93       	push	r16
    24a2:	1f 93       	push	r17
    24a4:	cf 93       	push	r28
    24a6:	df 93       	push	r29
    24a8:	ec 01       	movw	r28, r24
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	0f 92       	push	r0
    24b0:	00 97       	sbiw	r24, 0x00	; 0
    24b2:	21 f4       	brne	.+8      	; 0x24bc <vTaskSuspend+0x1c>
    24b4:	c0 91 91 08 	lds	r28, 0x0891
    24b8:	d0 91 92 08 	lds	r29, 0x0892
    24bc:	8e 01       	movw	r16, r28
    24be:	0e 5f       	subi	r16, 0xFE	; 254
    24c0:	1f 4f       	sbci	r17, 0xFF	; 255
    24c2:	c8 01       	movw	r24, r16
    24c4:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    24c8:	8c 89       	ldd	r24, Y+20	; 0x14
    24ca:	9d 89       	ldd	r25, Y+21	; 0x15
    24cc:	89 2b       	or	r24, r25
    24ce:	21 f0       	breq	.+8      	; 0x24d8 <vTaskSuspend+0x38>
    24d0:	ce 01       	movw	r24, r28
    24d2:	0c 96       	adiw	r24, 0x0c	; 12
    24d4:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    24d8:	b8 01       	movw	r22, r16
    24da:	82 e3       	ldi	r24, 0x32	; 50
    24dc:	98 e0       	ldi	r25, 0x08	; 8
    24de:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    24e2:	0f 90       	pop	r0
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	80 91 91 08 	lds	r24, 0x0891
    24ea:	90 91 92 08 	lds	r25, 0x0892
    24ee:	c8 17       	cp	r28, r24
    24f0:	d9 07       	cpc	r29, r25
    24f2:	a1 f4       	brne	.+40     	; 0x251c <vTaskSuspend+0x7c>
    24f4:	80 91 2d 08 	lds	r24, 0x082D
    24f8:	88 23       	and	r24, r24
    24fa:	19 f0       	breq	.+6      	; 0x2502 <vTaskSuspend+0x62>
    24fc:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vPortYield>
    2500:	17 c0       	rjmp	.+46     	; 0x2530 <vTaskSuspend+0x90>
    2502:	80 91 31 08 	lds	r24, 0x0831
    2506:	90 91 32 08 	lds	r25, 0x0832
    250a:	98 13       	cpse	r25, r24
    250c:	05 c0       	rjmp	.+10     	; 0x2518 <vTaskSuspend+0x78>
    250e:	10 92 92 08 	sts	0x0892, r1
    2512:	10 92 91 08 	sts	0x0891, r1
    2516:	0c c0       	rjmp	.+24     	; 0x2530 <vTaskSuspend+0x90>
    2518:	65 df       	rcall	.-310    	; 0x23e4 <vTaskSwitchContext>
    251a:	0a c0       	rjmp	.+20     	; 0x2530 <vTaskSuspend+0x90>
    251c:	80 91 2d 08 	lds	r24, 0x082D
    2520:	88 23       	and	r24, r24
    2522:	31 f0       	breq	.+12     	; 0x2530 <vTaskSuspend+0x90>
    2524:	0f b6       	in	r0, 0x3f	; 63
    2526:	f8 94       	cli
    2528:	0f 92       	push	r0
    252a:	b2 db       	rcall	.-2204   	; 0x1c90 <prvResetNextTaskUnblockTime>
    252c:	0f 90       	pop	r0
    252e:	0f be       	out	0x3f, r0	; 63
    2530:	df 91       	pop	r29
    2532:	cf 91       	pop	r28
    2534:	1f 91       	pop	r17
    2536:	0f 91       	pop	r16
    2538:	08 95       	ret

0000253a <vTaskPlaceOnEventList>:
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	eb 01       	movw	r28, r22
    2540:	60 91 91 08 	lds	r22, 0x0891
    2544:	70 91 92 08 	lds	r23, 0x0892
    2548:	64 5f       	subi	r22, 0xF4	; 244
    254a:	7f 4f       	sbci	r23, 0xFF	; 255
    254c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    2550:	80 91 91 08 	lds	r24, 0x0891
    2554:	90 91 92 08 	lds	r25, 0x0892
    2558:	02 96       	adiw	r24, 0x02	; 2
    255a:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    255e:	cf 3f       	cpi	r28, 0xFF	; 255
    2560:	8f ef       	ldi	r24, 0xFF	; 255
    2562:	d8 07       	cpc	r29, r24
    2564:	59 f4       	brne	.+22     	; 0x257c <vTaskPlaceOnEventList+0x42>
    2566:	60 91 91 08 	lds	r22, 0x0891
    256a:	70 91 92 08 	lds	r23, 0x0892
    256e:	6e 5f       	subi	r22, 0xFE	; 254
    2570:	7f 4f       	sbci	r23, 0xFF	; 255
    2572:	82 e3       	ldi	r24, 0x32	; 50
    2574:	98 e0       	ldi	r25, 0x08	; 8
    2576:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    257a:	07 c0       	rjmp	.+14     	; 0x258a <vTaskPlaceOnEventList+0x50>
    257c:	80 91 2f 08 	lds	r24, 0x082F
    2580:	90 91 30 08 	lds	r25, 0x0830
    2584:	8c 0f       	add	r24, r28
    2586:	9d 1f       	adc	r25, r29
    2588:	a2 db       	rcall	.-2236   	; 0x1cce <prvAddCurrentTaskToDelayedList>
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	08 95       	ret

00002590 <xTaskRemoveFromEventList>:
    2590:	0f 93       	push	r16
    2592:	1f 93       	push	r17
    2594:	cf 93       	push	r28
    2596:	df 93       	push	r29
    2598:	dc 01       	movw	r26, r24
    259a:	15 96       	adiw	r26, 0x05	; 5
    259c:	ed 91       	ld	r30, X+
    259e:	fc 91       	ld	r31, X
    25a0:	16 97       	sbiw	r26, 0x06	; 6
    25a2:	c6 81       	ldd	r28, Z+6	; 0x06
    25a4:	d7 81       	ldd	r29, Z+7	; 0x07
    25a6:	8e 01       	movw	r16, r28
    25a8:	04 5f       	subi	r16, 0xF4	; 244
    25aa:	1f 4f       	sbci	r17, 0xFF	; 255
    25ac:	c8 01       	movw	r24, r16
    25ae:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    25b2:	80 91 28 08 	lds	r24, 0x0828
    25b6:	81 11       	cpse	r24, r1
    25b8:	1c c0       	rjmp	.+56     	; 0x25f2 <xTaskRemoveFromEventList+0x62>
    25ba:	0a 50       	subi	r16, 0x0A	; 10
    25bc:	11 09       	sbc	r17, r1
    25be:	c8 01       	movw	r24, r16
    25c0:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    25c4:	8e 89       	ldd	r24, Y+22	; 0x16
    25c6:	90 91 2e 08 	lds	r25, 0x082E
    25ca:	98 17       	cp	r25, r24
    25cc:	10 f4       	brcc	.+4      	; 0x25d2 <xTaskRemoveFromEventList+0x42>
    25ce:	80 93 2e 08 	sts	0x082E, r24
    25d2:	90 e0       	ldi	r25, 0x00	; 0
    25d4:	9c 01       	movw	r18, r24
    25d6:	22 0f       	add	r18, r18
    25d8:	33 1f       	adc	r19, r19
    25da:	22 0f       	add	r18, r18
    25dc:	33 1f       	adc	r19, r19
    25de:	22 0f       	add	r18, r18
    25e0:	33 1f       	adc	r19, r19
    25e2:	82 0f       	add	r24, r18
    25e4:	93 1f       	adc	r25, r19
    25e6:	b8 01       	movw	r22, r16
    25e8:	8c 59       	subi	r24, 0x9C	; 156
    25ea:	97 4f       	sbci	r25, 0xF7	; 247
    25ec:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    25f0:	05 c0       	rjmp	.+10     	; 0x25fc <xTaskRemoveFromEventList+0x6c>
    25f2:	b8 01       	movw	r22, r16
    25f4:	85 e4       	ldi	r24, 0x45	; 69
    25f6:	98 e0       	ldi	r25, 0x08	; 8
    25f8:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    25fc:	e0 91 91 08 	lds	r30, 0x0891
    2600:	f0 91 92 08 	lds	r31, 0x0892
    2604:	9e 89       	ldd	r25, Y+22	; 0x16
    2606:	86 89       	ldd	r24, Z+22	; 0x16
    2608:	89 17       	cp	r24, r25
    260a:	20 f4       	brcc	.+8      	; 0x2614 <xTaskRemoveFromEventList+0x84>
    260c:	81 e0       	ldi	r24, 0x01	; 1
    260e:	80 93 2b 08 	sts	0x082B, r24
    2612:	01 c0       	rjmp	.+2      	; 0x2616 <xTaskRemoveFromEventList+0x86>
    2614:	80 e0       	ldi	r24, 0x00	; 0
    2616:	df 91       	pop	r29
    2618:	cf 91       	pop	r28
    261a:	1f 91       	pop	r17
    261c:	0f 91       	pop	r16
    261e:	08 95       	ret

00002620 <vTaskSetTimeOutState>:
    2620:	20 91 2a 08 	lds	r18, 0x082A
    2624:	fc 01       	movw	r30, r24
    2626:	20 83       	st	Z, r18
    2628:	20 91 2f 08 	lds	r18, 0x082F
    262c:	30 91 30 08 	lds	r19, 0x0830
    2630:	32 83       	std	Z+2, r19	; 0x02
    2632:	21 83       	std	Z+1, r18	; 0x01
    2634:	08 95       	ret

00002636 <xTaskCheckForTimeOut>:
    2636:	0f b6       	in	r0, 0x3f	; 63
    2638:	f8 94       	cli
    263a:	0f 92       	push	r0
    263c:	40 91 2f 08 	lds	r20, 0x082F
    2640:	50 91 30 08 	lds	r21, 0x0830
    2644:	db 01       	movw	r26, r22
    2646:	2d 91       	ld	r18, X+
    2648:	3c 91       	ld	r19, X
    264a:	2f 3f       	cpi	r18, 0xFF	; 255
    264c:	bf ef       	ldi	r27, 0xFF	; 255
    264e:	3b 07       	cpc	r19, r27
    2650:	11 f1       	breq	.+68     	; 0x2696 <xTaskCheckForTimeOut+0x60>
    2652:	e0 91 2a 08 	lds	r30, 0x082A
    2656:	dc 01       	movw	r26, r24
    2658:	fc 91       	ld	r31, X
    265a:	fe 17       	cp	r31, r30
    265c:	39 f0       	breq	.+14     	; 0x266c <xTaskCheckForTimeOut+0x36>
    265e:	11 96       	adiw	r26, 0x01	; 1
    2660:	ed 91       	ld	r30, X+
    2662:	fc 91       	ld	r31, X
    2664:	12 97       	sbiw	r26, 0x02	; 2
    2666:	4e 17       	cp	r20, r30
    2668:	5f 07       	cpc	r21, r31
    266a:	b8 f4       	brcc	.+46     	; 0x269a <xTaskCheckForTimeOut+0x64>
    266c:	dc 01       	movw	r26, r24
    266e:	11 96       	adiw	r26, 0x01	; 1
    2670:	ed 91       	ld	r30, X+
    2672:	fc 91       	ld	r31, X
    2674:	12 97       	sbiw	r26, 0x02	; 2
    2676:	da 01       	movw	r26, r20
    2678:	ae 1b       	sub	r26, r30
    267a:	bf 0b       	sbc	r27, r31
    267c:	a2 17       	cp	r26, r18
    267e:	b3 07       	cpc	r27, r19
    2680:	70 f4       	brcc	.+28     	; 0x269e <xTaskCheckForTimeOut+0x68>
    2682:	e4 1b       	sub	r30, r20
    2684:	f5 0b       	sbc	r31, r21
    2686:	2e 0f       	add	r18, r30
    2688:	3f 1f       	adc	r19, r31
    268a:	fb 01       	movw	r30, r22
    268c:	31 83       	std	Z+1, r19	; 0x01
    268e:	20 83       	st	Z, r18
    2690:	c7 df       	rcall	.-114    	; 0x2620 <vTaskSetTimeOutState>
    2692:	80 e0       	ldi	r24, 0x00	; 0
    2694:	05 c0       	rjmp	.+10     	; 0x26a0 <xTaskCheckForTimeOut+0x6a>
    2696:	80 e0       	ldi	r24, 0x00	; 0
    2698:	03 c0       	rjmp	.+6      	; 0x26a0 <xTaskCheckForTimeOut+0x6a>
    269a:	81 e0       	ldi	r24, 0x01	; 1
    269c:	01 c0       	rjmp	.+2      	; 0x26a0 <xTaskCheckForTimeOut+0x6a>
    269e:	81 e0       	ldi	r24, 0x01	; 1
    26a0:	0f 90       	pop	r0
    26a2:	0f be       	out	0x3f, r0	; 63
    26a4:	08 95       	ret

000026a6 <vTaskMissedYield>:
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	80 93 2b 08 	sts	0x082B, r24
    26ac:	08 95       	ret

000026ae <vTaskPriorityInherit>:
    26ae:	0f 93       	push	r16
    26b0:	1f 93       	push	r17
    26b2:	cf 93       	push	r28
    26b4:	df 93       	push	r29
    26b6:	ec 01       	movw	r28, r24
    26b8:	00 97       	sbiw	r24, 0x00	; 0
    26ba:	09 f4       	brne	.+2      	; 0x26be <vTaskPriorityInherit+0x10>
    26bc:	51 c0       	rjmp	.+162    	; 0x2760 <vTaskPriorityInherit+0xb2>
    26be:	8e 89       	ldd	r24, Y+22	; 0x16
    26c0:	e0 91 91 08 	lds	r30, 0x0891
    26c4:	f0 91 92 08 	lds	r31, 0x0892
    26c8:	96 89       	ldd	r25, Z+22	; 0x16
    26ca:	89 17       	cp	r24, r25
    26cc:	08 f0       	brcs	.+2      	; 0x26d0 <vTaskPriorityInherit+0x22>
    26ce:	48 c0       	rjmp	.+144    	; 0x2760 <vTaskPriorityInherit+0xb2>
    26d0:	2c 85       	ldd	r18, Y+12	; 0x0c
    26d2:	3d 85       	ldd	r19, Y+13	; 0x0d
    26d4:	33 23       	and	r19, r19
    26d6:	5c f0       	brlt	.+22     	; 0x26ee <vTaskPriorityInherit+0x40>
    26d8:	e0 91 91 08 	lds	r30, 0x0891
    26dc:	f0 91 92 08 	lds	r31, 0x0892
    26e0:	96 89       	ldd	r25, Z+22	; 0x16
    26e2:	25 e0       	ldi	r18, 0x05	; 5
    26e4:	30 e0       	ldi	r19, 0x00	; 0
    26e6:	29 1b       	sub	r18, r25
    26e8:	31 09       	sbc	r19, r1
    26ea:	3d 87       	std	Y+13, r19	; 0x0d
    26ec:	2c 87       	std	Y+12, r18	; 0x0c
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	9c 01       	movw	r18, r24
    26f2:	22 0f       	add	r18, r18
    26f4:	33 1f       	adc	r19, r19
    26f6:	22 0f       	add	r18, r18
    26f8:	33 1f       	adc	r19, r19
    26fa:	22 0f       	add	r18, r18
    26fc:	33 1f       	adc	r19, r19
    26fe:	82 0f       	add	r24, r18
    2700:	93 1f       	adc	r25, r19
    2702:	8c 59       	subi	r24, 0x9C	; 156
    2704:	97 4f       	sbci	r25, 0xF7	; 247
    2706:	2a 85       	ldd	r18, Y+10	; 0x0a
    2708:	3b 85       	ldd	r19, Y+11	; 0x0b
    270a:	28 17       	cp	r18, r24
    270c:	39 07       	cpc	r19, r25
    270e:	11 f5       	brne	.+68     	; 0x2754 <vTaskPriorityInherit+0xa6>
    2710:	8e 01       	movw	r16, r28
    2712:	0e 5f       	subi	r16, 0xFE	; 254
    2714:	1f 4f       	sbci	r17, 0xFF	; 255
    2716:	c8 01       	movw	r24, r16
    2718:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    271c:	e0 91 91 08 	lds	r30, 0x0891
    2720:	f0 91 92 08 	lds	r31, 0x0892
    2724:	86 89       	ldd	r24, Z+22	; 0x16
    2726:	8e 8b       	std	Y+22, r24	; 0x16
    2728:	90 91 2e 08 	lds	r25, 0x082E
    272c:	98 17       	cp	r25, r24
    272e:	10 f4       	brcc	.+4      	; 0x2734 <vTaskPriorityInherit+0x86>
    2730:	80 93 2e 08 	sts	0x082E, r24
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	9c 01       	movw	r18, r24
    2738:	22 0f       	add	r18, r18
    273a:	33 1f       	adc	r19, r19
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	22 0f       	add	r18, r18
    2742:	33 1f       	adc	r19, r19
    2744:	82 0f       	add	r24, r18
    2746:	93 1f       	adc	r25, r19
    2748:	b8 01       	movw	r22, r16
    274a:	8c 59       	subi	r24, 0x9C	; 156
    274c:	97 4f       	sbci	r25, 0xF7	; 247
    274e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2752:	06 c0       	rjmp	.+12     	; 0x2760 <vTaskPriorityInherit+0xb2>
    2754:	e0 91 91 08 	lds	r30, 0x0891
    2758:	f0 91 92 08 	lds	r31, 0x0892
    275c:	86 89       	ldd	r24, Z+22	; 0x16
    275e:	8e 8b       	std	Y+22, r24	; 0x16
    2760:	df 91       	pop	r29
    2762:	cf 91       	pop	r28
    2764:	1f 91       	pop	r17
    2766:	0f 91       	pop	r16
    2768:	08 95       	ret

0000276a <xTaskPriorityDisinherit>:
    276a:	0f 93       	push	r16
    276c:	1f 93       	push	r17
    276e:	cf 93       	push	r28
    2770:	df 93       	push	r29
    2772:	ec 01       	movw	r28, r24
    2774:	00 97       	sbiw	r24, 0x00	; 0
    2776:	71 f1       	breq	.+92     	; 0x27d4 <xTaskPriorityDisinherit+0x6a>
    2778:	8a a1       	ldd	r24, Y+34	; 0x22
    277a:	81 50       	subi	r24, 0x01	; 1
    277c:	8a a3       	std	Y+34, r24	; 0x22
    277e:	2e 89       	ldd	r18, Y+22	; 0x16
    2780:	99 a1       	ldd	r25, Y+33	; 0x21
    2782:	29 17       	cp	r18, r25
    2784:	49 f1       	breq	.+82     	; 0x27d8 <xTaskPriorityDisinherit+0x6e>
    2786:	81 11       	cpse	r24, r1
    2788:	29 c0       	rjmp	.+82     	; 0x27dc <xTaskPriorityDisinherit+0x72>
    278a:	8e 01       	movw	r16, r28
    278c:	0e 5f       	subi	r16, 0xFE	; 254
    278e:	1f 4f       	sbci	r17, 0xFF	; 255
    2790:	c8 01       	movw	r24, r16
    2792:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2796:	89 a1       	ldd	r24, Y+33	; 0x21
    2798:	8e 8b       	std	Y+22, r24	; 0x16
    279a:	25 e0       	ldi	r18, 0x05	; 5
    279c:	30 e0       	ldi	r19, 0x00	; 0
    279e:	28 1b       	sub	r18, r24
    27a0:	31 09       	sbc	r19, r1
    27a2:	3d 87       	std	Y+13, r19	; 0x0d
    27a4:	2c 87       	std	Y+12, r18	; 0x0c
    27a6:	90 91 2e 08 	lds	r25, 0x082E
    27aa:	98 17       	cp	r25, r24
    27ac:	10 f4       	brcc	.+4      	; 0x27b2 <xTaskPriorityDisinherit+0x48>
    27ae:	80 93 2e 08 	sts	0x082E, r24
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	9c 01       	movw	r18, r24
    27b6:	22 0f       	add	r18, r18
    27b8:	33 1f       	adc	r19, r19
    27ba:	22 0f       	add	r18, r18
    27bc:	33 1f       	adc	r19, r19
    27be:	22 0f       	add	r18, r18
    27c0:	33 1f       	adc	r19, r19
    27c2:	82 0f       	add	r24, r18
    27c4:	93 1f       	adc	r25, r19
    27c6:	b8 01       	movw	r22, r16
    27c8:	8c 59       	subi	r24, 0x9C	; 156
    27ca:	97 4f       	sbci	r25, 0xF7	; 247
    27cc:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	05 c0       	rjmp	.+10     	; 0x27de <xTaskPriorityDisinherit+0x74>
    27d4:	80 e0       	ldi	r24, 0x00	; 0
    27d6:	03 c0       	rjmp	.+6      	; 0x27de <xTaskPriorityDisinherit+0x74>
    27d8:	80 e0       	ldi	r24, 0x00	; 0
    27da:	01 c0       	rjmp	.+2      	; 0x27de <xTaskPriorityDisinherit+0x74>
    27dc:	80 e0       	ldi	r24, 0x00	; 0
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	1f 91       	pop	r17
    27e4:	0f 91       	pop	r16
    27e6:	08 95       	ret

000027e8 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    27e8:	80 91 91 08 	lds	r24, 0x0891
    27ec:	90 91 92 08 	lds	r25, 0x0892
    27f0:	89 2b       	or	r24, r25
    27f2:	39 f0       	breq	.+14     	; 0x2802 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    27f4:	e0 91 91 08 	lds	r30, 0x0891
    27f8:	f0 91 92 08 	lds	r31, 0x0892
    27fc:	82 a1       	ldd	r24, Z+34	; 0x22
    27fe:	8f 5f       	subi	r24, 0xFF	; 255
    2800:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2802:	80 91 91 08 	lds	r24, 0x0891
    2806:	90 91 92 08 	lds	r25, 0x0892
	}
    280a:	08 95       	ret

0000280c <__subsf3>:
    280c:	50 58       	subi	r21, 0x80	; 128

0000280e <__addsf3>:
    280e:	bb 27       	eor	r27, r27
    2810:	aa 27       	eor	r26, r26
    2812:	0e d0       	rcall	.+28     	; 0x2830 <__addsf3x>
    2814:	e5 c0       	rjmp	.+458    	; 0x29e0 <__fp_round>
    2816:	d6 d0       	rcall	.+428    	; 0x29c4 <__fp_pscA>
    2818:	30 f0       	brcs	.+12     	; 0x2826 <__addsf3+0x18>
    281a:	db d0       	rcall	.+438    	; 0x29d2 <__fp_pscB>
    281c:	20 f0       	brcs	.+8      	; 0x2826 <__addsf3+0x18>
    281e:	31 f4       	brne	.+12     	; 0x282c <__addsf3+0x1e>
    2820:	9f 3f       	cpi	r25, 0xFF	; 255
    2822:	11 f4       	brne	.+4      	; 0x2828 <__addsf3+0x1a>
    2824:	1e f4       	brtc	.+6      	; 0x282c <__addsf3+0x1e>
    2826:	cb c0       	rjmp	.+406    	; 0x29be <__fp_nan>
    2828:	0e f4       	brtc	.+2      	; 0x282c <__addsf3+0x1e>
    282a:	e0 95       	com	r30
    282c:	e7 fb       	bst	r30, 7
    282e:	c1 c0       	rjmp	.+386    	; 0x29b2 <__fp_inf>

00002830 <__addsf3x>:
    2830:	e9 2f       	mov	r30, r25
    2832:	e7 d0       	rcall	.+462    	; 0x2a02 <__fp_split3>
    2834:	80 f3       	brcs	.-32     	; 0x2816 <__addsf3+0x8>
    2836:	ba 17       	cp	r27, r26
    2838:	62 07       	cpc	r22, r18
    283a:	73 07       	cpc	r23, r19
    283c:	84 07       	cpc	r24, r20
    283e:	95 07       	cpc	r25, r21
    2840:	18 f0       	brcs	.+6      	; 0x2848 <__addsf3x+0x18>
    2842:	71 f4       	brne	.+28     	; 0x2860 <__addsf3x+0x30>
    2844:	9e f5       	brtc	.+102    	; 0x28ac <__addsf3x+0x7c>
    2846:	ff c0       	rjmp	.+510    	; 0x2a46 <__fp_zero>
    2848:	0e f4       	brtc	.+2      	; 0x284c <__addsf3x+0x1c>
    284a:	e0 95       	com	r30
    284c:	0b 2e       	mov	r0, r27
    284e:	ba 2f       	mov	r27, r26
    2850:	a0 2d       	mov	r26, r0
    2852:	0b 01       	movw	r0, r22
    2854:	b9 01       	movw	r22, r18
    2856:	90 01       	movw	r18, r0
    2858:	0c 01       	movw	r0, r24
    285a:	ca 01       	movw	r24, r20
    285c:	a0 01       	movw	r20, r0
    285e:	11 24       	eor	r1, r1
    2860:	ff 27       	eor	r31, r31
    2862:	59 1b       	sub	r21, r25
    2864:	99 f0       	breq	.+38     	; 0x288c <__addsf3x+0x5c>
    2866:	59 3f       	cpi	r21, 0xF9	; 249
    2868:	50 f4       	brcc	.+20     	; 0x287e <__addsf3x+0x4e>
    286a:	50 3e       	cpi	r21, 0xE0	; 224
    286c:	68 f1       	brcs	.+90     	; 0x28c8 <__addsf3x+0x98>
    286e:	1a 16       	cp	r1, r26
    2870:	f0 40       	sbci	r31, 0x00	; 0
    2872:	a2 2f       	mov	r26, r18
    2874:	23 2f       	mov	r18, r19
    2876:	34 2f       	mov	r19, r20
    2878:	44 27       	eor	r20, r20
    287a:	58 5f       	subi	r21, 0xF8	; 248
    287c:	f3 cf       	rjmp	.-26     	; 0x2864 <__addsf3x+0x34>
    287e:	46 95       	lsr	r20
    2880:	37 95       	ror	r19
    2882:	27 95       	ror	r18
    2884:	a7 95       	ror	r26
    2886:	f0 40       	sbci	r31, 0x00	; 0
    2888:	53 95       	inc	r21
    288a:	c9 f7       	brne	.-14     	; 0x287e <__addsf3x+0x4e>
    288c:	7e f4       	brtc	.+30     	; 0x28ac <__addsf3x+0x7c>
    288e:	1f 16       	cp	r1, r31
    2890:	ba 0b       	sbc	r27, r26
    2892:	62 0b       	sbc	r22, r18
    2894:	73 0b       	sbc	r23, r19
    2896:	84 0b       	sbc	r24, r20
    2898:	ba f0       	brmi	.+46     	; 0x28c8 <__addsf3x+0x98>
    289a:	91 50       	subi	r25, 0x01	; 1
    289c:	a1 f0       	breq	.+40     	; 0x28c6 <__addsf3x+0x96>
    289e:	ff 0f       	add	r31, r31
    28a0:	bb 1f       	adc	r27, r27
    28a2:	66 1f       	adc	r22, r22
    28a4:	77 1f       	adc	r23, r23
    28a6:	88 1f       	adc	r24, r24
    28a8:	c2 f7       	brpl	.-16     	; 0x289a <__addsf3x+0x6a>
    28aa:	0e c0       	rjmp	.+28     	; 0x28c8 <__addsf3x+0x98>
    28ac:	ba 0f       	add	r27, r26
    28ae:	62 1f       	adc	r22, r18
    28b0:	73 1f       	adc	r23, r19
    28b2:	84 1f       	adc	r24, r20
    28b4:	48 f4       	brcc	.+18     	; 0x28c8 <__addsf3x+0x98>
    28b6:	87 95       	ror	r24
    28b8:	77 95       	ror	r23
    28ba:	67 95       	ror	r22
    28bc:	b7 95       	ror	r27
    28be:	f7 95       	ror	r31
    28c0:	9e 3f       	cpi	r25, 0xFE	; 254
    28c2:	08 f0       	brcs	.+2      	; 0x28c6 <__addsf3x+0x96>
    28c4:	b3 cf       	rjmp	.-154    	; 0x282c <__addsf3+0x1e>
    28c6:	93 95       	inc	r25
    28c8:	88 0f       	add	r24, r24
    28ca:	08 f0       	brcs	.+2      	; 0x28ce <__addsf3x+0x9e>
    28cc:	99 27       	eor	r25, r25
    28ce:	ee 0f       	add	r30, r30
    28d0:	97 95       	ror	r25
    28d2:	87 95       	ror	r24
    28d4:	08 95       	ret

000028d6 <__fixsfsi>:
    28d6:	04 d0       	rcall	.+8      	; 0x28e0 <__fixunssfsi>
    28d8:	68 94       	set
    28da:	b1 11       	cpse	r27, r1
    28dc:	b5 c0       	rjmp	.+362    	; 0x2a48 <__fp_szero>
    28de:	08 95       	ret

000028e0 <__fixunssfsi>:
    28e0:	98 d0       	rcall	.+304    	; 0x2a12 <__fp_splitA>
    28e2:	88 f0       	brcs	.+34     	; 0x2906 <__fixunssfsi+0x26>
    28e4:	9f 57       	subi	r25, 0x7F	; 127
    28e6:	90 f0       	brcs	.+36     	; 0x290c <__fixunssfsi+0x2c>
    28e8:	b9 2f       	mov	r27, r25
    28ea:	99 27       	eor	r25, r25
    28ec:	b7 51       	subi	r27, 0x17	; 23
    28ee:	a0 f0       	brcs	.+40     	; 0x2918 <__fixunssfsi+0x38>
    28f0:	d1 f0       	breq	.+52     	; 0x2926 <__fixunssfsi+0x46>
    28f2:	66 0f       	add	r22, r22
    28f4:	77 1f       	adc	r23, r23
    28f6:	88 1f       	adc	r24, r24
    28f8:	99 1f       	adc	r25, r25
    28fa:	1a f0       	brmi	.+6      	; 0x2902 <__fixunssfsi+0x22>
    28fc:	ba 95       	dec	r27
    28fe:	c9 f7       	brne	.-14     	; 0x28f2 <__fixunssfsi+0x12>
    2900:	12 c0       	rjmp	.+36     	; 0x2926 <__fixunssfsi+0x46>
    2902:	b1 30       	cpi	r27, 0x01	; 1
    2904:	81 f0       	breq	.+32     	; 0x2926 <__fixunssfsi+0x46>
    2906:	9f d0       	rcall	.+318    	; 0x2a46 <__fp_zero>
    2908:	b1 e0       	ldi	r27, 0x01	; 1
    290a:	08 95       	ret
    290c:	9c c0       	rjmp	.+312    	; 0x2a46 <__fp_zero>
    290e:	67 2f       	mov	r22, r23
    2910:	78 2f       	mov	r23, r24
    2912:	88 27       	eor	r24, r24
    2914:	b8 5f       	subi	r27, 0xF8	; 248
    2916:	39 f0       	breq	.+14     	; 0x2926 <__fixunssfsi+0x46>
    2918:	b9 3f       	cpi	r27, 0xF9	; 249
    291a:	cc f3       	brlt	.-14     	; 0x290e <__fixunssfsi+0x2e>
    291c:	86 95       	lsr	r24
    291e:	77 95       	ror	r23
    2920:	67 95       	ror	r22
    2922:	b3 95       	inc	r27
    2924:	d9 f7       	brne	.-10     	; 0x291c <__fixunssfsi+0x3c>
    2926:	3e f4       	brtc	.+14     	; 0x2936 <__fixunssfsi+0x56>
    2928:	90 95       	com	r25
    292a:	80 95       	com	r24
    292c:	70 95       	com	r23
    292e:	61 95       	neg	r22
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	8f 4f       	sbci	r24, 0xFF	; 255
    2934:	9f 4f       	sbci	r25, 0xFF	; 255
    2936:	08 95       	ret

00002938 <__floatunsisf>:
    2938:	e8 94       	clt
    293a:	09 c0       	rjmp	.+18     	; 0x294e <__floatsisf+0x12>

0000293c <__floatsisf>:
    293c:	97 fb       	bst	r25, 7
    293e:	3e f4       	brtc	.+14     	; 0x294e <__floatsisf+0x12>
    2940:	90 95       	com	r25
    2942:	80 95       	com	r24
    2944:	70 95       	com	r23
    2946:	61 95       	neg	r22
    2948:	7f 4f       	sbci	r23, 0xFF	; 255
    294a:	8f 4f       	sbci	r24, 0xFF	; 255
    294c:	9f 4f       	sbci	r25, 0xFF	; 255
    294e:	99 23       	and	r25, r25
    2950:	a9 f0       	breq	.+42     	; 0x297c <__floatsisf+0x40>
    2952:	f9 2f       	mov	r31, r25
    2954:	96 e9       	ldi	r25, 0x96	; 150
    2956:	bb 27       	eor	r27, r27
    2958:	93 95       	inc	r25
    295a:	f6 95       	lsr	r31
    295c:	87 95       	ror	r24
    295e:	77 95       	ror	r23
    2960:	67 95       	ror	r22
    2962:	b7 95       	ror	r27
    2964:	f1 11       	cpse	r31, r1
    2966:	f8 cf       	rjmp	.-16     	; 0x2958 <__floatsisf+0x1c>
    2968:	fa f4       	brpl	.+62     	; 0x29a8 <__floatsisf+0x6c>
    296a:	bb 0f       	add	r27, r27
    296c:	11 f4       	brne	.+4      	; 0x2972 <__floatsisf+0x36>
    296e:	60 ff       	sbrs	r22, 0
    2970:	1b c0       	rjmp	.+54     	; 0x29a8 <__floatsisf+0x6c>
    2972:	6f 5f       	subi	r22, 0xFF	; 255
    2974:	7f 4f       	sbci	r23, 0xFF	; 255
    2976:	8f 4f       	sbci	r24, 0xFF	; 255
    2978:	9f 4f       	sbci	r25, 0xFF	; 255
    297a:	16 c0       	rjmp	.+44     	; 0x29a8 <__floatsisf+0x6c>
    297c:	88 23       	and	r24, r24
    297e:	11 f0       	breq	.+4      	; 0x2984 <__floatsisf+0x48>
    2980:	96 e9       	ldi	r25, 0x96	; 150
    2982:	11 c0       	rjmp	.+34     	; 0x29a6 <__floatsisf+0x6a>
    2984:	77 23       	and	r23, r23
    2986:	21 f0       	breq	.+8      	; 0x2990 <__floatsisf+0x54>
    2988:	9e e8       	ldi	r25, 0x8E	; 142
    298a:	87 2f       	mov	r24, r23
    298c:	76 2f       	mov	r23, r22
    298e:	05 c0       	rjmp	.+10     	; 0x299a <__floatsisf+0x5e>
    2990:	66 23       	and	r22, r22
    2992:	71 f0       	breq	.+28     	; 0x29b0 <__floatsisf+0x74>
    2994:	96 e8       	ldi	r25, 0x86	; 134
    2996:	86 2f       	mov	r24, r22
    2998:	70 e0       	ldi	r23, 0x00	; 0
    299a:	60 e0       	ldi	r22, 0x00	; 0
    299c:	2a f0       	brmi	.+10     	; 0x29a8 <__floatsisf+0x6c>
    299e:	9a 95       	dec	r25
    29a0:	66 0f       	add	r22, r22
    29a2:	77 1f       	adc	r23, r23
    29a4:	88 1f       	adc	r24, r24
    29a6:	da f7       	brpl	.-10     	; 0x299e <__floatsisf+0x62>
    29a8:	88 0f       	add	r24, r24
    29aa:	96 95       	lsr	r25
    29ac:	87 95       	ror	r24
    29ae:	97 f9       	bld	r25, 7
    29b0:	08 95       	ret

000029b2 <__fp_inf>:
    29b2:	97 f9       	bld	r25, 7
    29b4:	9f 67       	ori	r25, 0x7F	; 127
    29b6:	80 e8       	ldi	r24, 0x80	; 128
    29b8:	70 e0       	ldi	r23, 0x00	; 0
    29ba:	60 e0       	ldi	r22, 0x00	; 0
    29bc:	08 95       	ret

000029be <__fp_nan>:
    29be:	9f ef       	ldi	r25, 0xFF	; 255
    29c0:	80 ec       	ldi	r24, 0xC0	; 192
    29c2:	08 95       	ret

000029c4 <__fp_pscA>:
    29c4:	00 24       	eor	r0, r0
    29c6:	0a 94       	dec	r0
    29c8:	16 16       	cp	r1, r22
    29ca:	17 06       	cpc	r1, r23
    29cc:	18 06       	cpc	r1, r24
    29ce:	09 06       	cpc	r0, r25
    29d0:	08 95       	ret

000029d2 <__fp_pscB>:
    29d2:	00 24       	eor	r0, r0
    29d4:	0a 94       	dec	r0
    29d6:	12 16       	cp	r1, r18
    29d8:	13 06       	cpc	r1, r19
    29da:	14 06       	cpc	r1, r20
    29dc:	05 06       	cpc	r0, r21
    29de:	08 95       	ret

000029e0 <__fp_round>:
    29e0:	09 2e       	mov	r0, r25
    29e2:	03 94       	inc	r0
    29e4:	00 0c       	add	r0, r0
    29e6:	11 f4       	brne	.+4      	; 0x29ec <__fp_round+0xc>
    29e8:	88 23       	and	r24, r24
    29ea:	52 f0       	brmi	.+20     	; 0x2a00 <__fp_round+0x20>
    29ec:	bb 0f       	add	r27, r27
    29ee:	40 f4       	brcc	.+16     	; 0x2a00 <__fp_round+0x20>
    29f0:	bf 2b       	or	r27, r31
    29f2:	11 f4       	brne	.+4      	; 0x29f8 <__fp_round+0x18>
    29f4:	60 ff       	sbrs	r22, 0
    29f6:	04 c0       	rjmp	.+8      	; 0x2a00 <__fp_round+0x20>
    29f8:	6f 5f       	subi	r22, 0xFF	; 255
    29fa:	7f 4f       	sbci	r23, 0xFF	; 255
    29fc:	8f 4f       	sbci	r24, 0xFF	; 255
    29fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2a00:	08 95       	ret

00002a02 <__fp_split3>:
    2a02:	57 fd       	sbrc	r21, 7
    2a04:	90 58       	subi	r25, 0x80	; 128
    2a06:	44 0f       	add	r20, r20
    2a08:	55 1f       	adc	r21, r21
    2a0a:	59 f0       	breq	.+22     	; 0x2a22 <__fp_splitA+0x10>
    2a0c:	5f 3f       	cpi	r21, 0xFF	; 255
    2a0e:	71 f0       	breq	.+28     	; 0x2a2c <__fp_splitA+0x1a>
    2a10:	47 95       	ror	r20

00002a12 <__fp_splitA>:
    2a12:	88 0f       	add	r24, r24
    2a14:	97 fb       	bst	r25, 7
    2a16:	99 1f       	adc	r25, r25
    2a18:	61 f0       	breq	.+24     	; 0x2a32 <__fp_splitA+0x20>
    2a1a:	9f 3f       	cpi	r25, 0xFF	; 255
    2a1c:	79 f0       	breq	.+30     	; 0x2a3c <__fp_splitA+0x2a>
    2a1e:	87 95       	ror	r24
    2a20:	08 95       	ret
    2a22:	12 16       	cp	r1, r18
    2a24:	13 06       	cpc	r1, r19
    2a26:	14 06       	cpc	r1, r20
    2a28:	55 1f       	adc	r21, r21
    2a2a:	f2 cf       	rjmp	.-28     	; 0x2a10 <__fp_split3+0xe>
    2a2c:	46 95       	lsr	r20
    2a2e:	f1 df       	rcall	.-30     	; 0x2a12 <__fp_splitA>
    2a30:	08 c0       	rjmp	.+16     	; 0x2a42 <__fp_splitA+0x30>
    2a32:	16 16       	cp	r1, r22
    2a34:	17 06       	cpc	r1, r23
    2a36:	18 06       	cpc	r1, r24
    2a38:	99 1f       	adc	r25, r25
    2a3a:	f1 cf       	rjmp	.-30     	; 0x2a1e <__fp_splitA+0xc>
    2a3c:	86 95       	lsr	r24
    2a3e:	71 05       	cpc	r23, r1
    2a40:	61 05       	cpc	r22, r1
    2a42:	08 94       	sec
    2a44:	08 95       	ret

00002a46 <__fp_zero>:
    2a46:	e8 94       	clt

00002a48 <__fp_szero>:
    2a48:	bb 27       	eor	r27, r27
    2a4a:	66 27       	eor	r22, r22
    2a4c:	77 27       	eor	r23, r23
    2a4e:	cb 01       	movw	r24, r22
    2a50:	97 f9       	bld	r25, 7
    2a52:	08 95       	ret

00002a54 <__mulsf3>:
    2a54:	0b d0       	rcall	.+22     	; 0x2a6c <__mulsf3x>
    2a56:	c4 cf       	rjmp	.-120    	; 0x29e0 <__fp_round>
    2a58:	b5 df       	rcall	.-150    	; 0x29c4 <__fp_pscA>
    2a5a:	28 f0       	brcs	.+10     	; 0x2a66 <__mulsf3+0x12>
    2a5c:	ba df       	rcall	.-140    	; 0x29d2 <__fp_pscB>
    2a5e:	18 f0       	brcs	.+6      	; 0x2a66 <__mulsf3+0x12>
    2a60:	95 23       	and	r25, r21
    2a62:	09 f0       	breq	.+2      	; 0x2a66 <__mulsf3+0x12>
    2a64:	a6 cf       	rjmp	.-180    	; 0x29b2 <__fp_inf>
    2a66:	ab cf       	rjmp	.-170    	; 0x29be <__fp_nan>
    2a68:	11 24       	eor	r1, r1
    2a6a:	ee cf       	rjmp	.-36     	; 0x2a48 <__fp_szero>

00002a6c <__mulsf3x>:
    2a6c:	ca df       	rcall	.-108    	; 0x2a02 <__fp_split3>
    2a6e:	a0 f3       	brcs	.-24     	; 0x2a58 <__mulsf3+0x4>

00002a70 <__mulsf3_pse>:
    2a70:	95 9f       	mul	r25, r21
    2a72:	d1 f3       	breq	.-12     	; 0x2a68 <__mulsf3+0x14>
    2a74:	95 0f       	add	r25, r21
    2a76:	50 e0       	ldi	r21, 0x00	; 0
    2a78:	55 1f       	adc	r21, r21
    2a7a:	62 9f       	mul	r22, r18
    2a7c:	f0 01       	movw	r30, r0
    2a7e:	72 9f       	mul	r23, r18
    2a80:	bb 27       	eor	r27, r27
    2a82:	f0 0d       	add	r31, r0
    2a84:	b1 1d       	adc	r27, r1
    2a86:	63 9f       	mul	r22, r19
    2a88:	aa 27       	eor	r26, r26
    2a8a:	f0 0d       	add	r31, r0
    2a8c:	b1 1d       	adc	r27, r1
    2a8e:	aa 1f       	adc	r26, r26
    2a90:	64 9f       	mul	r22, r20
    2a92:	66 27       	eor	r22, r22
    2a94:	b0 0d       	add	r27, r0
    2a96:	a1 1d       	adc	r26, r1
    2a98:	66 1f       	adc	r22, r22
    2a9a:	82 9f       	mul	r24, r18
    2a9c:	22 27       	eor	r18, r18
    2a9e:	b0 0d       	add	r27, r0
    2aa0:	a1 1d       	adc	r26, r1
    2aa2:	62 1f       	adc	r22, r18
    2aa4:	73 9f       	mul	r23, r19
    2aa6:	b0 0d       	add	r27, r0
    2aa8:	a1 1d       	adc	r26, r1
    2aaa:	62 1f       	adc	r22, r18
    2aac:	83 9f       	mul	r24, r19
    2aae:	a0 0d       	add	r26, r0
    2ab0:	61 1d       	adc	r22, r1
    2ab2:	22 1f       	adc	r18, r18
    2ab4:	74 9f       	mul	r23, r20
    2ab6:	33 27       	eor	r19, r19
    2ab8:	a0 0d       	add	r26, r0
    2aba:	61 1d       	adc	r22, r1
    2abc:	23 1f       	adc	r18, r19
    2abe:	84 9f       	mul	r24, r20
    2ac0:	60 0d       	add	r22, r0
    2ac2:	21 1d       	adc	r18, r1
    2ac4:	82 2f       	mov	r24, r18
    2ac6:	76 2f       	mov	r23, r22
    2ac8:	6a 2f       	mov	r22, r26
    2aca:	11 24       	eor	r1, r1
    2acc:	9f 57       	subi	r25, 0x7F	; 127
    2ace:	50 40       	sbci	r21, 0x00	; 0
    2ad0:	8a f0       	brmi	.+34     	; 0x2af4 <__mulsf3_pse+0x84>
    2ad2:	e1 f0       	breq	.+56     	; 0x2b0c <__mulsf3_pse+0x9c>
    2ad4:	88 23       	and	r24, r24
    2ad6:	4a f0       	brmi	.+18     	; 0x2aea <__mulsf3_pse+0x7a>
    2ad8:	ee 0f       	add	r30, r30
    2ada:	ff 1f       	adc	r31, r31
    2adc:	bb 1f       	adc	r27, r27
    2ade:	66 1f       	adc	r22, r22
    2ae0:	77 1f       	adc	r23, r23
    2ae2:	88 1f       	adc	r24, r24
    2ae4:	91 50       	subi	r25, 0x01	; 1
    2ae6:	50 40       	sbci	r21, 0x00	; 0
    2ae8:	a9 f7       	brne	.-22     	; 0x2ad4 <__mulsf3_pse+0x64>
    2aea:	9e 3f       	cpi	r25, 0xFE	; 254
    2aec:	51 05       	cpc	r21, r1
    2aee:	70 f0       	brcs	.+28     	; 0x2b0c <__mulsf3_pse+0x9c>
    2af0:	60 cf       	rjmp	.-320    	; 0x29b2 <__fp_inf>
    2af2:	aa cf       	rjmp	.-172    	; 0x2a48 <__fp_szero>
    2af4:	5f 3f       	cpi	r21, 0xFF	; 255
    2af6:	ec f3       	brlt	.-6      	; 0x2af2 <__mulsf3_pse+0x82>
    2af8:	98 3e       	cpi	r25, 0xE8	; 232
    2afa:	dc f3       	brlt	.-10     	; 0x2af2 <__mulsf3_pse+0x82>
    2afc:	86 95       	lsr	r24
    2afe:	77 95       	ror	r23
    2b00:	67 95       	ror	r22
    2b02:	b7 95       	ror	r27
    2b04:	f7 95       	ror	r31
    2b06:	e7 95       	ror	r30
    2b08:	9f 5f       	subi	r25, 0xFF	; 255
    2b0a:	c1 f7       	brne	.-16     	; 0x2afc <__mulsf3_pse+0x8c>
    2b0c:	fe 2b       	or	r31, r30
    2b0e:	88 0f       	add	r24, r24
    2b10:	91 1d       	adc	r25, r1
    2b12:	96 95       	lsr	r25
    2b14:	87 95       	ror	r24
    2b16:	97 f9       	bld	r25, 7
    2b18:	08 95       	ret

00002b1a <pow>:
    2b1a:	fa 01       	movw	r30, r20
    2b1c:	ee 0f       	add	r30, r30
    2b1e:	ff 1f       	adc	r31, r31
    2b20:	30 96       	adiw	r30, 0x00	; 0
    2b22:	21 05       	cpc	r18, r1
    2b24:	31 05       	cpc	r19, r1
    2b26:	99 f1       	breq	.+102    	; 0x2b8e <pow+0x74>
    2b28:	61 15       	cp	r22, r1
    2b2a:	71 05       	cpc	r23, r1
    2b2c:	61 f4       	brne	.+24     	; 0x2b46 <pow+0x2c>
    2b2e:	80 38       	cpi	r24, 0x80	; 128
    2b30:	bf e3       	ldi	r27, 0x3F	; 63
    2b32:	9b 07       	cpc	r25, r27
    2b34:	49 f1       	breq	.+82     	; 0x2b88 <pow+0x6e>
    2b36:	68 94       	set
    2b38:	90 38       	cpi	r25, 0x80	; 128
    2b3a:	81 05       	cpc	r24, r1
    2b3c:	61 f0       	breq	.+24     	; 0x2b56 <pow+0x3c>
    2b3e:	80 38       	cpi	r24, 0x80	; 128
    2b40:	bf ef       	ldi	r27, 0xFF	; 255
    2b42:	9b 07       	cpc	r25, r27
    2b44:	41 f0       	breq	.+16     	; 0x2b56 <pow+0x3c>
    2b46:	99 23       	and	r25, r25
    2b48:	42 f5       	brpl	.+80     	; 0x2b9a <pow+0x80>
    2b4a:	ff 3f       	cpi	r31, 0xFF	; 255
    2b4c:	e1 05       	cpc	r30, r1
    2b4e:	31 05       	cpc	r19, r1
    2b50:	21 05       	cpc	r18, r1
    2b52:	11 f1       	breq	.+68     	; 0x2b98 <pow+0x7e>
    2b54:	e8 94       	clt
    2b56:	08 94       	sec
    2b58:	e7 95       	ror	r30
    2b5a:	d9 01       	movw	r26, r18
    2b5c:	aa 23       	and	r26, r26
    2b5e:	29 f4       	brne	.+10     	; 0x2b6a <pow+0x50>
    2b60:	ab 2f       	mov	r26, r27
    2b62:	be 2f       	mov	r27, r30
    2b64:	f8 5f       	subi	r31, 0xF8	; 248
    2b66:	d0 f3       	brcs	.-12     	; 0x2b5c <pow+0x42>
    2b68:	10 c0       	rjmp	.+32     	; 0x2b8a <pow+0x70>
    2b6a:	ff 5f       	subi	r31, 0xFF	; 255
    2b6c:	70 f4       	brcc	.+28     	; 0x2b8a <pow+0x70>
    2b6e:	a6 95       	lsr	r26
    2b70:	e0 f7       	brcc	.-8      	; 0x2b6a <pow+0x50>
    2b72:	f7 39       	cpi	r31, 0x97	; 151
    2b74:	50 f0       	brcs	.+20     	; 0x2b8a <pow+0x70>
    2b76:	19 f0       	breq	.+6      	; 0x2b7e <pow+0x64>
    2b78:	ff 3a       	cpi	r31, 0xAF	; 175
    2b7a:	38 f4       	brcc	.+14     	; 0x2b8a <pow+0x70>
    2b7c:	9f 77       	andi	r25, 0x7F	; 127
    2b7e:	9f 93       	push	r25
    2b80:	0c d0       	rcall	.+24     	; 0x2b9a <pow+0x80>
    2b82:	0f 90       	pop	r0
    2b84:	07 fc       	sbrc	r0, 7
    2b86:	90 58       	subi	r25, 0x80	; 128
    2b88:	08 95       	ret
    2b8a:	3e f0       	brts	.+14     	; 0x2b9a <pow+0x80>
    2b8c:	18 cf       	rjmp	.-464    	; 0x29be <__fp_nan>
    2b8e:	60 e0       	ldi	r22, 0x00	; 0
    2b90:	70 e0       	ldi	r23, 0x00	; 0
    2b92:	80 e8       	ldi	r24, 0x80	; 128
    2b94:	9f e3       	ldi	r25, 0x3F	; 63
    2b96:	08 95       	ret
    2b98:	4f e7       	ldi	r20, 0x7F	; 127
    2b9a:	9f 77       	andi	r25, 0x7F	; 127
    2b9c:	5f 93       	push	r21
    2b9e:	4f 93       	push	r20
    2ba0:	3f 93       	push	r19
    2ba2:	2f 93       	push	r18
    2ba4:	9e d0       	rcall	.+316    	; 0x2ce2 <log>
    2ba6:	2f 91       	pop	r18
    2ba8:	3f 91       	pop	r19
    2baa:	4f 91       	pop	r20
    2bac:	5f 91       	pop	r21
    2bae:	52 df       	rcall	.-348    	; 0x2a54 <__mulsf3>
    2bb0:	05 c0       	rjmp	.+10     	; 0x2bbc <exp>
    2bb2:	19 f4       	brne	.+6      	; 0x2bba <pow+0xa0>
    2bb4:	0e f0       	brts	.+2      	; 0x2bb8 <pow+0x9e>
    2bb6:	fd ce       	rjmp	.-518    	; 0x29b2 <__fp_inf>
    2bb8:	46 cf       	rjmp	.-372    	; 0x2a46 <__fp_zero>
    2bba:	01 cf       	rjmp	.-510    	; 0x29be <__fp_nan>

00002bbc <exp>:
    2bbc:	2a df       	rcall	.-428    	; 0x2a12 <__fp_splitA>
    2bbe:	c8 f3       	brcs	.-14     	; 0x2bb2 <pow+0x98>
    2bc0:	96 38       	cpi	r25, 0x86	; 134
    2bc2:	c0 f7       	brcc	.-16     	; 0x2bb4 <pow+0x9a>
    2bc4:	07 f8       	bld	r0, 7
    2bc6:	0f 92       	push	r0
    2bc8:	e8 94       	clt
    2bca:	2b e3       	ldi	r18, 0x3B	; 59
    2bcc:	3a ea       	ldi	r19, 0xAA	; 170
    2bce:	48 eb       	ldi	r20, 0xB8	; 184
    2bd0:	5f e7       	ldi	r21, 0x7F	; 127
    2bd2:	4e df       	rcall	.-356    	; 0x2a70 <__mulsf3_pse>
    2bd4:	0f 92       	push	r0
    2bd6:	0f 92       	push	r0
    2bd8:	0f 92       	push	r0
    2bda:	4d b7       	in	r20, 0x3d	; 61
    2bdc:	5e b7       	in	r21, 0x3e	; 62
    2bde:	0f 92       	push	r0
    2be0:	c0 d0       	rcall	.+384    	; 0x2d62 <modf>
    2be2:	e4 ee       	ldi	r30, 0xE4	; 228
    2be4:	f0 e0       	ldi	r31, 0x00	; 0
    2be6:	16 d0       	rcall	.+44     	; 0x2c14 <__fp_powser>
    2be8:	4f 91       	pop	r20
    2bea:	5f 91       	pop	r21
    2bec:	ef 91       	pop	r30
    2bee:	ff 91       	pop	r31
    2bf0:	e5 95       	asr	r30
    2bf2:	ee 1f       	adc	r30, r30
    2bf4:	ff 1f       	adc	r31, r31
    2bf6:	49 f0       	breq	.+18     	; 0x2c0a <exp+0x4e>
    2bf8:	fe 57       	subi	r31, 0x7E	; 126
    2bfa:	e0 68       	ori	r30, 0x80	; 128
    2bfc:	44 27       	eor	r20, r20
    2bfe:	ee 0f       	add	r30, r30
    2c00:	44 1f       	adc	r20, r20
    2c02:	fa 95       	dec	r31
    2c04:	e1 f7       	brne	.-8      	; 0x2bfe <exp+0x42>
    2c06:	41 95       	neg	r20
    2c08:	55 0b       	sbc	r21, r21
    2c0a:	32 d0       	rcall	.+100    	; 0x2c70 <ldexp>
    2c0c:	0f 90       	pop	r0
    2c0e:	07 fe       	sbrs	r0, 7
    2c10:	26 c0       	rjmp	.+76     	; 0x2c5e <inverse>
    2c12:	08 95       	ret

00002c14 <__fp_powser>:
    2c14:	df 93       	push	r29
    2c16:	cf 93       	push	r28
    2c18:	1f 93       	push	r17
    2c1a:	0f 93       	push	r16
    2c1c:	ff 92       	push	r15
    2c1e:	ef 92       	push	r14
    2c20:	df 92       	push	r13
    2c22:	7b 01       	movw	r14, r22
    2c24:	8c 01       	movw	r16, r24
    2c26:	68 94       	set
    2c28:	05 c0       	rjmp	.+10     	; 0x2c34 <__fp_powser+0x20>
    2c2a:	da 2e       	mov	r13, r26
    2c2c:	ef 01       	movw	r28, r30
    2c2e:	1e df       	rcall	.-452    	; 0x2a6c <__mulsf3x>
    2c30:	fe 01       	movw	r30, r28
    2c32:	e8 94       	clt
    2c34:	a5 91       	lpm	r26, Z+
    2c36:	25 91       	lpm	r18, Z+
    2c38:	35 91       	lpm	r19, Z+
    2c3a:	45 91       	lpm	r20, Z+
    2c3c:	55 91       	lpm	r21, Z+
    2c3e:	ae f3       	brts	.-22     	; 0x2c2a <__fp_powser+0x16>
    2c40:	ef 01       	movw	r28, r30
    2c42:	f6 dd       	rcall	.-1044   	; 0x2830 <__addsf3x>
    2c44:	fe 01       	movw	r30, r28
    2c46:	97 01       	movw	r18, r14
    2c48:	a8 01       	movw	r20, r16
    2c4a:	da 94       	dec	r13
    2c4c:	79 f7       	brne	.-34     	; 0x2c2c <__fp_powser+0x18>
    2c4e:	df 90       	pop	r13
    2c50:	ef 90       	pop	r14
    2c52:	ff 90       	pop	r15
    2c54:	0f 91       	pop	r16
    2c56:	1f 91       	pop	r17
    2c58:	cf 91       	pop	r28
    2c5a:	df 91       	pop	r29
    2c5c:	08 95       	ret

00002c5e <inverse>:
    2c5e:	9b 01       	movw	r18, r22
    2c60:	ac 01       	movw	r20, r24
    2c62:	60 e0       	ldi	r22, 0x00	; 0
    2c64:	70 e0       	ldi	r23, 0x00	; 0
    2c66:	80 e8       	ldi	r24, 0x80	; 128
    2c68:	9f e3       	ldi	r25, 0x3F	; 63
    2c6a:	ae c0       	rjmp	.+348    	; 0x2dc8 <__divsf3>
    2c6c:	a2 ce       	rjmp	.-700    	; 0x29b2 <__fp_inf>
    2c6e:	14 c1       	rjmp	.+552    	; 0x2e98 <__fp_mpack>

00002c70 <ldexp>:
    2c70:	d0 de       	rcall	.-608    	; 0x2a12 <__fp_splitA>
    2c72:	e8 f3       	brcs	.-6      	; 0x2c6e <inverse+0x10>
    2c74:	99 23       	and	r25, r25
    2c76:	d9 f3       	breq	.-10     	; 0x2c6e <inverse+0x10>
    2c78:	94 0f       	add	r25, r20
    2c7a:	51 1d       	adc	r21, r1
    2c7c:	bb f3       	brvs	.-18     	; 0x2c6c <inverse+0xe>
    2c7e:	91 50       	subi	r25, 0x01	; 1
    2c80:	50 40       	sbci	r21, 0x00	; 0
    2c82:	94 f0       	brlt	.+36     	; 0x2ca8 <ldexp+0x38>
    2c84:	59 f0       	breq	.+22     	; 0x2c9c <ldexp+0x2c>
    2c86:	88 23       	and	r24, r24
    2c88:	32 f0       	brmi	.+12     	; 0x2c96 <ldexp+0x26>
    2c8a:	66 0f       	add	r22, r22
    2c8c:	77 1f       	adc	r23, r23
    2c8e:	88 1f       	adc	r24, r24
    2c90:	91 50       	subi	r25, 0x01	; 1
    2c92:	50 40       	sbci	r21, 0x00	; 0
    2c94:	c1 f7       	brne	.-16     	; 0x2c86 <ldexp+0x16>
    2c96:	9e 3f       	cpi	r25, 0xFE	; 254
    2c98:	51 05       	cpc	r21, r1
    2c9a:	44 f7       	brge	.-48     	; 0x2c6c <inverse+0xe>
    2c9c:	88 0f       	add	r24, r24
    2c9e:	91 1d       	adc	r25, r1
    2ca0:	96 95       	lsr	r25
    2ca2:	87 95       	ror	r24
    2ca4:	97 f9       	bld	r25, 7
    2ca6:	08 95       	ret
    2ca8:	5f 3f       	cpi	r21, 0xFF	; 255
    2caa:	ac f0       	brlt	.+42     	; 0x2cd6 <ldexp+0x66>
    2cac:	98 3e       	cpi	r25, 0xE8	; 232
    2cae:	9c f0       	brlt	.+38     	; 0x2cd6 <ldexp+0x66>
    2cb0:	bb 27       	eor	r27, r27
    2cb2:	86 95       	lsr	r24
    2cb4:	77 95       	ror	r23
    2cb6:	67 95       	ror	r22
    2cb8:	b7 95       	ror	r27
    2cba:	08 f4       	brcc	.+2      	; 0x2cbe <ldexp+0x4e>
    2cbc:	b1 60       	ori	r27, 0x01	; 1
    2cbe:	93 95       	inc	r25
    2cc0:	c1 f7       	brne	.-16     	; 0x2cb2 <ldexp+0x42>
    2cc2:	bb 0f       	add	r27, r27
    2cc4:	58 f7       	brcc	.-42     	; 0x2c9c <ldexp+0x2c>
    2cc6:	11 f4       	brne	.+4      	; 0x2ccc <ldexp+0x5c>
    2cc8:	60 ff       	sbrs	r22, 0
    2cca:	e8 cf       	rjmp	.-48     	; 0x2c9c <ldexp+0x2c>
    2ccc:	6f 5f       	subi	r22, 0xFF	; 255
    2cce:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd0:	8f 4f       	sbci	r24, 0xFF	; 255
    2cd2:	9f 4f       	sbci	r25, 0xFF	; 255
    2cd4:	e3 cf       	rjmp	.-58     	; 0x2c9c <ldexp+0x2c>
    2cd6:	b8 ce       	rjmp	.-656    	; 0x2a48 <__fp_szero>
    2cd8:	0e f0       	brts	.+2      	; 0x2cdc <ldexp+0x6c>
    2cda:	de c0       	rjmp	.+444    	; 0x2e98 <__fp_mpack>
    2cdc:	70 ce       	rjmp	.-800    	; 0x29be <__fp_nan>
    2cde:	68 94       	set
    2ce0:	68 ce       	rjmp	.-816    	; 0x29b2 <__fp_inf>

00002ce2 <log>:
    2ce2:	97 de       	rcall	.-722    	; 0x2a12 <__fp_splitA>
    2ce4:	c8 f3       	brcs	.-14     	; 0x2cd8 <ldexp+0x68>
    2ce6:	99 23       	and	r25, r25
    2ce8:	d1 f3       	breq	.-12     	; 0x2cde <ldexp+0x6e>
    2cea:	c6 f3       	brts	.-16     	; 0x2cdc <ldexp+0x6c>
    2cec:	df 93       	push	r29
    2cee:	cf 93       	push	r28
    2cf0:	1f 93       	push	r17
    2cf2:	0f 93       	push	r16
    2cf4:	ff 92       	push	r15
    2cf6:	c9 2f       	mov	r28, r25
    2cf8:	dd 27       	eor	r29, r29
    2cfa:	88 23       	and	r24, r24
    2cfc:	2a f0       	brmi	.+10     	; 0x2d08 <log+0x26>
    2cfe:	21 97       	sbiw	r28, 0x01	; 1
    2d00:	66 0f       	add	r22, r22
    2d02:	77 1f       	adc	r23, r23
    2d04:	88 1f       	adc	r24, r24
    2d06:	da f7       	brpl	.-10     	; 0x2cfe <log+0x1c>
    2d08:	20 e0       	ldi	r18, 0x00	; 0
    2d0a:	30 e0       	ldi	r19, 0x00	; 0
    2d0c:	40 e8       	ldi	r20, 0x80	; 128
    2d0e:	5f eb       	ldi	r21, 0xBF	; 191
    2d10:	9f e3       	ldi	r25, 0x3F	; 63
    2d12:	88 39       	cpi	r24, 0x98	; 152
    2d14:	20 f0       	brcs	.+8      	; 0x2d1e <log+0x3c>
    2d16:	80 3e       	cpi	r24, 0xE0	; 224
    2d18:	30 f0       	brcs	.+12     	; 0x2d26 <log+0x44>
    2d1a:	21 96       	adiw	r28, 0x01	; 1
    2d1c:	8f 77       	andi	r24, 0x7F	; 127
    2d1e:	77 dd       	rcall	.-1298   	; 0x280e <__addsf3>
    2d20:	ec e0       	ldi	r30, 0x0C	; 12
    2d22:	f1 e0       	ldi	r31, 0x01	; 1
    2d24:	03 c0       	rjmp	.+6      	; 0x2d2c <log+0x4a>
    2d26:	73 dd       	rcall	.-1306   	; 0x280e <__addsf3>
    2d28:	e9 e3       	ldi	r30, 0x39	; 57
    2d2a:	f1 e0       	ldi	r31, 0x01	; 1
    2d2c:	73 df       	rcall	.-282    	; 0x2c14 <__fp_powser>
    2d2e:	8b 01       	movw	r16, r22
    2d30:	be 01       	movw	r22, r28
    2d32:	ec 01       	movw	r28, r24
    2d34:	fb 2e       	mov	r15, r27
    2d36:	6f 57       	subi	r22, 0x7F	; 127
    2d38:	71 09       	sbc	r23, r1
    2d3a:	75 95       	asr	r23
    2d3c:	77 1f       	adc	r23, r23
    2d3e:	88 0b       	sbc	r24, r24
    2d40:	99 0b       	sbc	r25, r25
    2d42:	fc dd       	rcall	.-1032   	; 0x293c <__floatsisf>
    2d44:	28 e1       	ldi	r18, 0x18	; 24
    2d46:	32 e7       	ldi	r19, 0x72	; 114
    2d48:	41 e3       	ldi	r20, 0x31	; 49
    2d4a:	5f e3       	ldi	r21, 0x3F	; 63
    2d4c:	8f de       	rcall	.-738    	; 0x2a6c <__mulsf3x>
    2d4e:	af 2d       	mov	r26, r15
    2d50:	98 01       	movw	r18, r16
    2d52:	ae 01       	movw	r20, r28
    2d54:	ff 90       	pop	r15
    2d56:	0f 91       	pop	r16
    2d58:	1f 91       	pop	r17
    2d5a:	cf 91       	pop	r28
    2d5c:	df 91       	pop	r29
    2d5e:	68 dd       	rcall	.-1328   	; 0x2830 <__addsf3x>
    2d60:	3f ce       	rjmp	.-898    	; 0x29e0 <__fp_round>

00002d62 <modf>:
    2d62:	fa 01       	movw	r30, r20
    2d64:	dc 01       	movw	r26, r24
    2d66:	aa 0f       	add	r26, r26
    2d68:	bb 1f       	adc	r27, r27
    2d6a:	9b 01       	movw	r18, r22
    2d6c:	ac 01       	movw	r20, r24
    2d6e:	bf 57       	subi	r27, 0x7F	; 127
    2d70:	28 f4       	brcc	.+10     	; 0x2d7c <modf+0x1a>
    2d72:	22 27       	eor	r18, r18
    2d74:	33 27       	eor	r19, r19
    2d76:	44 27       	eor	r20, r20
    2d78:	50 78       	andi	r21, 0x80	; 128
    2d7a:	1f c0       	rjmp	.+62     	; 0x2dba <modf+0x58>
    2d7c:	b7 51       	subi	r27, 0x17	; 23
    2d7e:	88 f4       	brcc	.+34     	; 0x2da2 <modf+0x40>
    2d80:	ab 2f       	mov	r26, r27
    2d82:	00 24       	eor	r0, r0
    2d84:	46 95       	lsr	r20
    2d86:	37 95       	ror	r19
    2d88:	27 95       	ror	r18
    2d8a:	01 1c       	adc	r0, r1
    2d8c:	a3 95       	inc	r26
    2d8e:	d2 f3       	brmi	.-12     	; 0x2d84 <modf+0x22>
    2d90:	00 20       	and	r0, r0
    2d92:	69 f0       	breq	.+26     	; 0x2dae <modf+0x4c>
    2d94:	22 0f       	add	r18, r18
    2d96:	33 1f       	adc	r19, r19
    2d98:	44 1f       	adc	r20, r20
    2d9a:	b3 95       	inc	r27
    2d9c:	da f3       	brmi	.-10     	; 0x2d94 <modf+0x32>
    2d9e:	0d d0       	rcall	.+26     	; 0x2dba <modf+0x58>
    2da0:	35 cd       	rjmp	.-1430   	; 0x280c <__subsf3>
    2da2:	61 30       	cpi	r22, 0x01	; 1
    2da4:	71 05       	cpc	r23, r1
    2da6:	a0 e8       	ldi	r26, 0x80	; 128
    2da8:	8a 07       	cpc	r24, r26
    2daa:	b9 46       	sbci	r27, 0x69	; 105
    2dac:	30 f4       	brcc	.+12     	; 0x2dba <modf+0x58>
    2dae:	9b 01       	movw	r18, r22
    2db0:	ac 01       	movw	r20, r24
    2db2:	66 27       	eor	r22, r22
    2db4:	77 27       	eor	r23, r23
    2db6:	88 27       	eor	r24, r24
    2db8:	90 78       	andi	r25, 0x80	; 128
    2dba:	30 96       	adiw	r30, 0x00	; 0
    2dbc:	21 f0       	breq	.+8      	; 0x2dc6 <modf+0x64>
    2dbe:	20 83       	st	Z, r18
    2dc0:	31 83       	std	Z+1, r19	; 0x01
    2dc2:	42 83       	std	Z+2, r20	; 0x02
    2dc4:	53 83       	std	Z+3, r21	; 0x03
    2dc6:	08 95       	ret

00002dc8 <__divsf3>:
    2dc8:	0c d0       	rcall	.+24     	; 0x2de2 <__divsf3x>
    2dca:	0a ce       	rjmp	.-1004   	; 0x29e0 <__fp_round>
    2dcc:	02 de       	rcall	.-1020   	; 0x29d2 <__fp_pscB>
    2dce:	40 f0       	brcs	.+16     	; 0x2de0 <__divsf3+0x18>
    2dd0:	f9 dd       	rcall	.-1038   	; 0x29c4 <__fp_pscA>
    2dd2:	30 f0       	brcs	.+12     	; 0x2de0 <__divsf3+0x18>
    2dd4:	21 f4       	brne	.+8      	; 0x2dde <__divsf3+0x16>
    2dd6:	5f 3f       	cpi	r21, 0xFF	; 255
    2dd8:	19 f0       	breq	.+6      	; 0x2de0 <__divsf3+0x18>
    2dda:	eb cd       	rjmp	.-1066   	; 0x29b2 <__fp_inf>
    2ddc:	51 11       	cpse	r21, r1
    2dde:	34 ce       	rjmp	.-920    	; 0x2a48 <__fp_szero>
    2de0:	ee cd       	rjmp	.-1060   	; 0x29be <__fp_nan>

00002de2 <__divsf3x>:
    2de2:	0f de       	rcall	.-994    	; 0x2a02 <__fp_split3>
    2de4:	98 f3       	brcs	.-26     	; 0x2dcc <__divsf3+0x4>

00002de6 <__divsf3_pse>:
    2de6:	99 23       	and	r25, r25
    2de8:	c9 f3       	breq	.-14     	; 0x2ddc <__divsf3+0x14>
    2dea:	55 23       	and	r21, r21
    2dec:	b1 f3       	breq	.-20     	; 0x2dda <__divsf3+0x12>
    2dee:	95 1b       	sub	r25, r21
    2df0:	55 0b       	sbc	r21, r21
    2df2:	bb 27       	eor	r27, r27
    2df4:	aa 27       	eor	r26, r26
    2df6:	62 17       	cp	r22, r18
    2df8:	73 07       	cpc	r23, r19
    2dfa:	84 07       	cpc	r24, r20
    2dfc:	38 f0       	brcs	.+14     	; 0x2e0c <__divsf3_pse+0x26>
    2dfe:	9f 5f       	subi	r25, 0xFF	; 255
    2e00:	5f 4f       	sbci	r21, 0xFF	; 255
    2e02:	22 0f       	add	r18, r18
    2e04:	33 1f       	adc	r19, r19
    2e06:	44 1f       	adc	r20, r20
    2e08:	aa 1f       	adc	r26, r26
    2e0a:	a9 f3       	breq	.-22     	; 0x2df6 <__divsf3_pse+0x10>
    2e0c:	33 d0       	rcall	.+102    	; 0x2e74 <__divsf3_pse+0x8e>
    2e0e:	0e 2e       	mov	r0, r30
    2e10:	3a f0       	brmi	.+14     	; 0x2e20 <__divsf3_pse+0x3a>
    2e12:	e0 e8       	ldi	r30, 0x80	; 128
    2e14:	30 d0       	rcall	.+96     	; 0x2e76 <__divsf3_pse+0x90>
    2e16:	91 50       	subi	r25, 0x01	; 1
    2e18:	50 40       	sbci	r21, 0x00	; 0
    2e1a:	e6 95       	lsr	r30
    2e1c:	00 1c       	adc	r0, r0
    2e1e:	ca f7       	brpl	.-14     	; 0x2e12 <__divsf3_pse+0x2c>
    2e20:	29 d0       	rcall	.+82     	; 0x2e74 <__divsf3_pse+0x8e>
    2e22:	fe 2f       	mov	r31, r30
    2e24:	27 d0       	rcall	.+78     	; 0x2e74 <__divsf3_pse+0x8e>
    2e26:	66 0f       	add	r22, r22
    2e28:	77 1f       	adc	r23, r23
    2e2a:	88 1f       	adc	r24, r24
    2e2c:	bb 1f       	adc	r27, r27
    2e2e:	26 17       	cp	r18, r22
    2e30:	37 07       	cpc	r19, r23
    2e32:	48 07       	cpc	r20, r24
    2e34:	ab 07       	cpc	r26, r27
    2e36:	b0 e8       	ldi	r27, 0x80	; 128
    2e38:	09 f0       	breq	.+2      	; 0x2e3c <__divsf3_pse+0x56>
    2e3a:	bb 0b       	sbc	r27, r27
    2e3c:	80 2d       	mov	r24, r0
    2e3e:	bf 01       	movw	r22, r30
    2e40:	ff 27       	eor	r31, r31
    2e42:	93 58       	subi	r25, 0x83	; 131
    2e44:	5f 4f       	sbci	r21, 0xFF	; 255
    2e46:	2a f0       	brmi	.+10     	; 0x2e52 <__divsf3_pse+0x6c>
    2e48:	9e 3f       	cpi	r25, 0xFE	; 254
    2e4a:	51 05       	cpc	r21, r1
    2e4c:	68 f0       	brcs	.+26     	; 0x2e68 <__divsf3_pse+0x82>
    2e4e:	b1 cd       	rjmp	.-1182   	; 0x29b2 <__fp_inf>
    2e50:	fb cd       	rjmp	.-1034   	; 0x2a48 <__fp_szero>
    2e52:	5f 3f       	cpi	r21, 0xFF	; 255
    2e54:	ec f3       	brlt	.-6      	; 0x2e50 <__divsf3_pse+0x6a>
    2e56:	98 3e       	cpi	r25, 0xE8	; 232
    2e58:	dc f3       	brlt	.-10     	; 0x2e50 <__divsf3_pse+0x6a>
    2e5a:	86 95       	lsr	r24
    2e5c:	77 95       	ror	r23
    2e5e:	67 95       	ror	r22
    2e60:	b7 95       	ror	r27
    2e62:	f7 95       	ror	r31
    2e64:	9f 5f       	subi	r25, 0xFF	; 255
    2e66:	c9 f7       	brne	.-14     	; 0x2e5a <__divsf3_pse+0x74>
    2e68:	88 0f       	add	r24, r24
    2e6a:	91 1d       	adc	r25, r1
    2e6c:	96 95       	lsr	r25
    2e6e:	87 95       	ror	r24
    2e70:	97 f9       	bld	r25, 7
    2e72:	08 95       	ret
    2e74:	e1 e0       	ldi	r30, 0x01	; 1
    2e76:	66 0f       	add	r22, r22
    2e78:	77 1f       	adc	r23, r23
    2e7a:	88 1f       	adc	r24, r24
    2e7c:	bb 1f       	adc	r27, r27
    2e7e:	62 17       	cp	r22, r18
    2e80:	73 07       	cpc	r23, r19
    2e82:	84 07       	cpc	r24, r20
    2e84:	ba 07       	cpc	r27, r26
    2e86:	20 f0       	brcs	.+8      	; 0x2e90 <__divsf3_pse+0xaa>
    2e88:	62 1b       	sub	r22, r18
    2e8a:	73 0b       	sbc	r23, r19
    2e8c:	84 0b       	sbc	r24, r20
    2e8e:	ba 0b       	sbc	r27, r26
    2e90:	ee 1f       	adc	r30, r30
    2e92:	88 f7       	brcc	.-30     	; 0x2e76 <__divsf3_pse+0x90>
    2e94:	e0 95       	com	r30
    2e96:	08 95       	ret

00002e98 <__fp_mpack>:
    2e98:	9f 3f       	cpi	r25, 0xFF	; 255
    2e9a:	31 f0       	breq	.+12     	; 0x2ea8 <__fp_mpack_finite+0xc>

00002e9c <__fp_mpack_finite>:
    2e9c:	91 50       	subi	r25, 0x01	; 1
    2e9e:	20 f4       	brcc	.+8      	; 0x2ea8 <__fp_mpack_finite+0xc>
    2ea0:	87 95       	ror	r24
    2ea2:	77 95       	ror	r23
    2ea4:	67 95       	ror	r22
    2ea6:	b7 95       	ror	r27
    2ea8:	88 0f       	add	r24, r24
    2eaa:	91 1d       	adc	r25, r1
    2eac:	96 95       	lsr	r25
    2eae:	87 95       	ror	r24
    2eb0:	97 f9       	bld	r25, 7
    2eb2:	08 95       	ret

00002eb4 <__divmodhi4>:
    2eb4:	97 fb       	bst	r25, 7
    2eb6:	07 2e       	mov	r0, r23
    2eb8:	16 f4       	brtc	.+4      	; 0x2ebe <__divmodhi4+0xa>
    2eba:	00 94       	com	r0
    2ebc:	06 d0       	rcall	.+12     	; 0x2eca <__divmodhi4_neg1>
    2ebe:	77 fd       	sbrc	r23, 7
    2ec0:	08 d0       	rcall	.+16     	; 0x2ed2 <__divmodhi4_neg2>
    2ec2:	0b d0       	rcall	.+22     	; 0x2eda <__udivmodhi4>
    2ec4:	07 fc       	sbrc	r0, 7
    2ec6:	05 d0       	rcall	.+10     	; 0x2ed2 <__divmodhi4_neg2>
    2ec8:	3e f4       	brtc	.+14     	; 0x2ed8 <__divmodhi4_exit>

00002eca <__divmodhi4_neg1>:
    2eca:	90 95       	com	r25
    2ecc:	81 95       	neg	r24
    2ece:	9f 4f       	sbci	r25, 0xFF	; 255
    2ed0:	08 95       	ret

00002ed2 <__divmodhi4_neg2>:
    2ed2:	70 95       	com	r23
    2ed4:	61 95       	neg	r22
    2ed6:	7f 4f       	sbci	r23, 0xFF	; 255

00002ed8 <__divmodhi4_exit>:
    2ed8:	08 95       	ret

00002eda <__udivmodhi4>:
    2eda:	aa 1b       	sub	r26, r26
    2edc:	bb 1b       	sub	r27, r27
    2ede:	51 e1       	ldi	r21, 0x11	; 17
    2ee0:	07 c0       	rjmp	.+14     	; 0x2ef0 <__udivmodhi4_ep>

00002ee2 <__udivmodhi4_loop>:
    2ee2:	aa 1f       	adc	r26, r26
    2ee4:	bb 1f       	adc	r27, r27
    2ee6:	a6 17       	cp	r26, r22
    2ee8:	b7 07       	cpc	r27, r23
    2eea:	10 f0       	brcs	.+4      	; 0x2ef0 <__udivmodhi4_ep>
    2eec:	a6 1b       	sub	r26, r22
    2eee:	b7 0b       	sbc	r27, r23

00002ef0 <__udivmodhi4_ep>:
    2ef0:	88 1f       	adc	r24, r24
    2ef2:	99 1f       	adc	r25, r25
    2ef4:	5a 95       	dec	r21
    2ef6:	a9 f7       	brne	.-22     	; 0x2ee2 <__udivmodhi4_loop>
    2ef8:	80 95       	com	r24
    2efa:	90 95       	com	r25
    2efc:	bc 01       	movw	r22, r24
    2efe:	cd 01       	movw	r24, r26
    2f00:	08 95       	ret

00002f02 <memcpy>:
    2f02:	fb 01       	movw	r30, r22
    2f04:	dc 01       	movw	r26, r24
    2f06:	02 c0       	rjmp	.+4      	; 0x2f0c <memcpy+0xa>
    2f08:	01 90       	ld	r0, Z+
    2f0a:	0d 92       	st	X+, r0
    2f0c:	41 50       	subi	r20, 0x01	; 1
    2f0e:	50 40       	sbci	r21, 0x00	; 0
    2f10:	d8 f7       	brcc	.-10     	; 0x2f08 <memcpy+0x6>
    2f12:	08 95       	ret

00002f14 <_exit>:
    2f14:	f8 94       	cli

00002f16 <__stop_program>:
    2f16:	ff cf       	rjmp	.-2      	; 0x2f16 <__stop_program>
