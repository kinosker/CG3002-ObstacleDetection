
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800200  000020a0  00002134  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000020a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006ee  0080028e  0080028e  000021c2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021c2  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000480  00000000  00000000  000021f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004f10  00000000  00000000  00002672  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001243  00000000  00000000  00007582  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002fb9  00000000  00000000  000087c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000ca4  00000000  00000000  0000b780  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001368  00000000  00000000  0000c424  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003585  00000000  00000000  0000d78c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000440  00000000  00000000  00010d11  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	de c6       	rjmp	.+3516   	; 0xe12 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	0a c4       	rjmp	.+2068   	; 0x87a <__vector_25>
      66:	00 00       	nop
      68:	76 c4       	rjmp	.+2284   	; 0x956 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	62 c2       	rjmp	.+1220   	; 0x53a <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	bc c3       	rjmp	.+1912   	; 0x80a <__vector_36>
      92:	00 00       	nop
      94:	2a c4       	rjmp	.+2132   	; 0x8ea <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 ea       	ldi	r30, 0xA0	; 160
      fc:	f0 e2       	ldi	r31, 0x20	; 32
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 38       	cpi	r26, 0x8E	; 142
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ae e8       	ldi	r26, 0x8E	; 142
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ac 37       	cpi	r26, 0x7C	; 124
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	d5 d0       	rcall	.+426    	; 0x2ca <main>
     120:	0c 94 4e 10 	jmp	0x209c	; 0x209c <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	dd d4       	rcall	.+2490   	; 0xb12 <waitForHandshake>
     158:	86 e0       	ldi	r24, 0x06	; 6
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	a0 c4       	rjmp	.+2368   	; 0xa9e <transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	cd d4       	rcall	.+2458   	; 0xafc <startHandShake>
     162:	8d e1       	ldi	r24, 0x1D	; 29
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	9b c4       	rjmp	.+2358   	; 0xa9e <transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a8 97       	sbiw	r28, 0x28	; 40
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e3 e3       	ldi	r30, 0x33	; 51
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	17 96       	adiw	r26, 0x07	; 7
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	eb e3       	ldi	r30, 0x3B	; 59
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1f 96       	adiw	r26, 0x0f	; 15
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e2 e4       	ldi	r30, 0x42	; 66
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	56 96       	adiw	r26, 0x16	; 22
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	ea e4       	ldi	r30, 0x4A	; 74
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5e 96       	adiw	r26, 0x1e	; 30
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	e0 e5       	ldi	r30, 0x50	; 80
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	94 96       	adiw	r26, 0x24	; 36
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xTaskGetTickCount>
     1dc:	9a 83       	std	Y+2, r25	; 0x02
     1de:	89 83       	std	Y+1, r24	; 0x01
     1e0:	98 d1       	rcall	.+816    	; 0x512 <MaxSonar_Start>
     1e2:	87 e2       	ldi	r24, 0x27	; 39
     1e4:	a0 d1       	rcall	.+832    	; 0x526 <MaxSonar_Read>
     1e6:	4a e0       	ldi	r20, 0x0A	; 10
     1e8:	be 01       	movw	r22, r28
     1ea:	6d 5f       	subi	r22, 0xFD	; 253
     1ec:	7f 4f       	sbci	r23, 0xFF	; 255
     1ee:	0e 94 1b 10 	call	0x2036	; 0x2036 <__itoa_ncheck>
     1f2:	ce 01       	movw	r24, r28
     1f4:	07 96       	adiw	r24, 0x07	; 7
     1f6:	53 d4       	rcall	.+2214   	; 0xa9e <transmitUSART0>
     1f8:	ce 01       	movw	r24, r28
     1fa:	03 96       	adiw	r24, 0x03	; 3
     1fc:	50 d4       	rcall	.+2208   	; 0xa9e <transmitUSART0>
     1fe:	ce 01       	movw	r24, r28
     200:	4e 96       	adiw	r24, 0x1e	; 30
     202:	4d d4       	rcall	.+2202   	; 0xa9e <transmitUSART0>
     204:	86 e2       	ldi	r24, 0x26	; 38
     206:	8f d1       	rcall	.+798    	; 0x526 <MaxSonar_Read>
     208:	4a e0       	ldi	r20, 0x0A	; 10
     20a:	be 01       	movw	r22, r28
     20c:	6d 5f       	subi	r22, 0xFD	; 253
     20e:	7f 4f       	sbci	r23, 0xFF	; 255
     210:	0e 94 1b 10 	call	0x2036	; 0x2036 <__itoa_ncheck>
     214:	ce 01       	movw	r24, r28
     216:	0f 96       	adiw	r24, 0x0f	; 15
     218:	42 d4       	rcall	.+2180   	; 0xa9e <transmitUSART0>
     21a:	ce 01       	movw	r24, r28
     21c:	03 96       	adiw	r24, 0x03	; 3
     21e:	3f d4       	rcall	.+2174   	; 0xa9e <transmitUSART0>
     220:	ce 01       	movw	r24, r28
     222:	4e 96       	adiw	r24, 0x1e	; 30
     224:	3c d4       	rcall	.+2168   	; 0xa9e <transmitUSART0>
     226:	85 e2       	ldi	r24, 0x25	; 37
     228:	7e d1       	rcall	.+764    	; 0x526 <MaxSonar_Read>
     22a:	4a e0       	ldi	r20, 0x0A	; 10
     22c:	be 01       	movw	r22, r28
     22e:	6d 5f       	subi	r22, 0xFD	; 253
     230:	7f 4f       	sbci	r23, 0xFF	; 255
     232:	0a 97       	sbiw	r24, 0x0a	; 10
     234:	0e 94 1b 10 	call	0x2036	; 0x2036 <__itoa_ncheck>
     238:	ce 01       	movw	r24, r28
     23a:	46 96       	adiw	r24, 0x16	; 22
     23c:	30 d4       	rcall	.+2144   	; 0xa9e <transmitUSART0>
     23e:	ce 01       	movw	r24, r28
     240:	03 96       	adiw	r24, 0x03	; 3
     242:	2d d4       	rcall	.+2138   	; 0xa9e <transmitUSART0>
     244:	ce 01       	movw	r24, r28
     246:	84 96       	adiw	r24, 0x24	; 36
     248:	2a d4       	rcall	.+2132   	; 0xa9e <transmitUSART0>
     24a:	66 e9       	ldi	r22, 0x96	; 150
     24c:	70 e0       	ldi	r23, 0x00	; 0
     24e:	ce 01       	movw	r24, r28
     250:	01 96       	adiw	r24, 0x01	; 1
     252:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vTaskDelayUntil>
     256:	c4 cf       	rjmp	.-120    	; 0x1e0 <maxSonarTask+0x76>

00000258 <myTimerTask>:
     258:	08 d2       	rcall	.+1040   	; 0x66a <MyTimer_Init>
     25a:	68 d2       	rcall	.+1232   	; 0x72c <delayMicroCheck>
     25c:	fe cf       	rjmp	.-4      	; 0x25a <myTimerTask+0x2>

0000025e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     25e:	8c ec       	ldi	r24, 0xCC	; 204
     260:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     264:	8e e3       	ldi	r24, 0x3E	; 62
     266:	80 93 65 00 	sts	0x0065, r24
     26a:	08 95       	ret

0000026c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     26c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     270:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     274:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     278:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     27c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     280:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     284:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     288:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     28c:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     290:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     294:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     298:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     29c:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2a0:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2a4:	10 92 73 00 	sts	0x0073, r1
     2a8:	08 95       	ret

000002aa <init>:
}

void init()
{
     2aa:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2ac:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2ae:	f8 94       	cli
	{
		clearTimer();
     2b0:	dd df       	rcall	.-70     	; 0x26c <clearTimer>
		setPowerReduction();
     2b2:	d5 df       	rcall	.-86     	; 0x25e <setPowerReduction>
		USART0_Init();
     2b4:	86 d3       	rcall	.+1804   	; 0x9c2 <USART0_Init>
		USART1_Init();
     2b6:	a5 d3       	rcall	.+1866   	; 0xa02 <USART1_Init>
		ADC_Init();
     2b8:	74 d1       	rcall	.+744    	; 0x5a2 <ADC_Init>
		MaxSonar_Init();
     2ba:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2bc:	84 b1       	in	r24, 0x04	; 4
     2be:	80 6c       	ori	r24, 0xC0	; 192
     2c0:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2c2:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2c4:	78 94       	sei
}
     2c6:	cf 91       	pop	r28
     2c8:	08 95       	ret

000002ca <main>:
	
	// do nth
}

int main(void)
{
     2ca:	cf 93       	push	r28
     2cc:	df 93       	push	r29
     2ce:	cd b7       	in	r28, 0x3d	; 61
     2d0:	de b7       	in	r29, 0x3e	; 62
     2d2:	2c 97       	sbiw	r28, 0x0c	; 12
     2d4:	0f b6       	in	r0, 0x3f	; 63
     2d6:	f8 94       	cli
     2d8:	de bf       	out	0x3e, r29	; 62
     2da:	0f be       	out	0x3f, r0	; 63
     2dc:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2de:	e5 df       	rcall	.-54     	; 0x2aa <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     2e0:	a1 2c       	mov	r10, r1
     2e2:	b1 2c       	mov	r11, r1
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
     2e8:	ce 01       	movw	r24, r28
     2ea:	01 96       	adiw	r24, 0x01	; 1
     2ec:	7c 01       	movw	r14, r24
     2ee:	04 e0       	ldi	r16, 0x04	; 4
     2f0:	9c 01       	movw	r18, r24
     2f2:	49 e6       	ldi	r20, 0x69	; 105
     2f4:	50 e0       	ldi	r21, 0x00	; 0
     2f6:	65 e5       	ldi	r22, 0x55	; 85
     2f8:	72 e0       	ldi	r23, 0x02	; 2
     2fa:	8c e2       	ldi	r24, 0x2C	; 44
     2fc:	91 e0       	ldi	r25, 0x01	; 1
     2fe:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     302:	ce 01       	movw	r24, r28
     304:	07 96       	adiw	r24, 0x07	; 7
     306:	7c 01       	movw	r14, r24
     308:	02 e0       	ldi	r16, 0x02	; 2
     30a:	20 e0       	ldi	r18, 0x00	; 0
     30c:	30 e0       	ldi	r19, 0x00	; 0
     30e:	4d e1       	ldi	r20, 0x1D	; 29
     310:	51 e0       	ldi	r21, 0x01	; 1
     312:	6d e5       	ldi	r22, 0x5D	; 93
     314:	72 e0       	ldi	r23, 0x02	; 2
     316:	85 eb       	ldi	r24, 0xB5	; 181
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     31e:	ce 01       	movw	r24, r28
     320:	0b 96       	adiw	r24, 0x0b	; 11
     322:	7c 01       	movw	r14, r24
     324:	01 e0       	ldi	r16, 0x01	; 1
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	49 e6       	ldi	r20, 0x69	; 105
     32c:	50 e0       	ldi	r21, 0x00	; 0
     32e:	66 e6       	ldi	r22, 0x66	; 102
     330:	72 e0       	ldi	r23, 0x02	; 2
     332:	83 e9       	ldi	r24, 0x93	; 147
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     33a:	ce 01       	movw	r24, r28
     33c:	09 96       	adiw	r24, 0x09	; 9
     33e:	7c 01       	movw	r14, r24
     340:	20 e0       	ldi	r18, 0x00	; 0
     342:	30 e0       	ldi	r19, 0x00	; 0
     344:	49 e6       	ldi	r20, 0x69	; 105
     346:	50 e0       	ldi	r21, 0x00	; 0
     348:	6d e6       	ldi	r22, 0x6D	; 109
     34a:	72 e0       	ldi	r23, 0x02	; 2
     34c:	8f e9       	ldi	r24, 0x9F	; 159
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     354:	ce 01       	movw	r24, r28
     356:	05 96       	adiw	r24, 0x05	; 5
     358:	7c 01       	movw	r14, r24
     35a:	03 e0       	ldi	r16, 0x03	; 3
     35c:	20 e0       	ldi	r18, 0x00	; 0
     35e:	30 e0       	ldi	r19, 0x00	; 0
     360:	47 e8       	ldi	r20, 0x87	; 135
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	64 e7       	ldi	r22, 0x74	; 116
     366:	72 e0       	ldi	r23, 0x02	; 2
     368:	8b ea       	ldi	r24, 0xAB	; 171
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     370:	ce 01       	movw	r24, r28
     372:	03 96       	adiw	r24, 0x03	; 3
     374:	7c 01       	movw	r14, r24
     376:	02 e0       	ldi	r16, 0x02	; 2
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	47 e8       	ldi	r20, 0x87	; 135
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	60 e8       	ldi	r22, 0x80	; 128
     382:	72 e0       	ldi	r23, 0x02	; 2
     384:	80 eb       	ldi	r24, 0xB0	; 176
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     38c:	0e 94 cc 0b 	call	0x1798	; 0x1798 <vTaskStartScheduler>
     390:	a6 cf       	rjmp	.-180    	; 0x2de <main+0x14>

00000392 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     398:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     39c:	80 91 8e 02 	lds	r24, 0x028E
     3a0:	90 91 8f 02 	lds	r25, 0x028F
     3a4:	89 2b       	or	r24, r25
     3a6:	31 f4       	brne	.+12     	; 0x3b4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3a8:	83 e9       	ldi	r24, 0x93	; 147
     3aa:	92 e0       	ldi	r25, 0x02	; 2
     3ac:	90 93 8f 02 	sts	0x028F, r25
     3b0:	80 93 8e 02 	sts	0x028E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3b4:	40 91 90 02 	lds	r20, 0x0290
     3b8:	50 91 91 02 	lds	r21, 0x0291
     3bc:	9e 01       	movw	r18, r28
     3be:	24 0f       	add	r18, r20
     3c0:	35 1f       	adc	r19, r21
     3c2:	2b 3d       	cpi	r18, 0xDB	; 219
     3c4:	85 e0       	ldi	r24, 0x05	; 5
     3c6:	38 07       	cpc	r19, r24
     3c8:	70 f4       	brcc	.+28     	; 0x3e6 <pvPortMalloc+0x54>
     3ca:	42 17       	cp	r20, r18
     3cc:	53 07       	cpc	r21, r19
     3ce:	70 f4       	brcc	.+28     	; 0x3ec <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3d0:	c0 91 8e 02 	lds	r28, 0x028E
     3d4:	d0 91 8f 02 	lds	r29, 0x028F
     3d8:	c4 0f       	add	r28, r20
     3da:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3dc:	30 93 91 02 	sts	0x0291, r19
     3e0:	20 93 90 02 	sts	0x0290, r18
     3e4:	05 c0       	rjmp	.+10     	; 0x3f0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3e6:	c0 e0       	ldi	r28, 0x00	; 0
     3e8:	d0 e0       	ldi	r29, 0x00	; 0
     3ea:	02 c0       	rjmp	.+4      	; 0x3f0 <pvPortMalloc+0x5e>
     3ec:	c0 e0       	ldi	r28, 0x00	; 0
     3ee:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3f0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3f4:	ce 01       	movw	r24, r28
     3f6:	df 91       	pop	r29
     3f8:	cf 91       	pop	r28
     3fa:	08 95       	ret

000003fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3fc:	08 95       	ret

000003fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3fe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     400:	03 96       	adiw	r24, 0x03	; 3
     402:	92 83       	std	Z+2, r25	; 0x02
     404:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     406:	2f ef       	ldi	r18, 0xFF	; 255
     408:	3f ef       	ldi	r19, 0xFF	; 255
     40a:	34 83       	std	Z+4, r19	; 0x04
     40c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     40e:	96 83       	std	Z+6, r25	; 0x06
     410:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     412:	90 87       	std	Z+8, r25	; 0x08
     414:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     416:	10 82       	st	Z, r1
     418:	08 95       	ret

0000041a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     41a:	fc 01       	movw	r30, r24
     41c:	11 86       	std	Z+9, r1	; 0x09
     41e:	10 86       	std	Z+8, r1	; 0x08
     420:	08 95       	ret

00000422 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	9c 01       	movw	r18, r24
     428:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     42a:	dc 01       	movw	r26, r24
     42c:	11 96       	adiw	r26, 0x01	; 1
     42e:	cd 91       	ld	r28, X+
     430:	dc 91       	ld	r29, X
     432:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     434:	d3 83       	std	Z+3, r29	; 0x03
     436:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     438:	8c 81       	ldd	r24, Y+4	; 0x04
     43a:	9d 81       	ldd	r25, Y+5	; 0x05
     43c:	95 83       	std	Z+5, r25	; 0x05
     43e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     440:	8c 81       	ldd	r24, Y+4	; 0x04
     442:	9d 81       	ldd	r25, Y+5	; 0x05
     444:	dc 01       	movw	r26, r24
     446:	13 96       	adiw	r26, 0x03	; 3
     448:	7c 93       	st	X, r23
     44a:	6e 93       	st	-X, r22
     44c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     44e:	7d 83       	std	Y+5, r23	; 0x05
     450:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     452:	31 87       	std	Z+9, r19	; 0x09
     454:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     456:	f9 01       	movw	r30, r18
     458:	80 81       	ld	r24, Z
     45a:	8f 5f       	subi	r24, 0xFF	; 255
     45c:	80 83       	st	Z, r24
}
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	08 95       	ret

00000464 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     464:	cf 93       	push	r28
     466:	df 93       	push	r29
     468:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     46a:	48 81       	ld	r20, Y
     46c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     46e:	4f 3f       	cpi	r20, 0xFF	; 255
     470:	2f ef       	ldi	r18, 0xFF	; 255
     472:	52 07       	cpc	r21, r18
     474:	21 f4       	brne	.+8      	; 0x47e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     476:	fc 01       	movw	r30, r24
     478:	a7 81       	ldd	r26, Z+7	; 0x07
     47a:	b0 85       	ldd	r27, Z+8	; 0x08
     47c:	0d c0       	rjmp	.+26     	; 0x498 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     47e:	dc 01       	movw	r26, r24
     480:	13 96       	adiw	r26, 0x03	; 3
     482:	12 96       	adiw	r26, 0x02	; 2
     484:	ed 91       	ld	r30, X+
     486:	fc 91       	ld	r31, X
     488:	13 97       	sbiw	r26, 0x03	; 3
     48a:	20 81       	ld	r18, Z
     48c:	31 81       	ldd	r19, Z+1	; 0x01
     48e:	42 17       	cp	r20, r18
     490:	53 07       	cpc	r21, r19
     492:	10 f0       	brcs	.+4      	; 0x498 <vListInsert+0x34>
     494:	df 01       	movw	r26, r30
     496:	f5 cf       	rjmp	.-22     	; 0x482 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     498:	12 96       	adiw	r26, 0x02	; 2
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	13 97       	sbiw	r26, 0x03	; 3
     4a0:	fb 83       	std	Y+3, r31	; 0x03
     4a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4a4:	d5 83       	std	Z+5, r29	; 0x05
     4a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4a8:	bd 83       	std	Y+5, r27	; 0x05
     4aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4ac:	13 96       	adiw	r26, 0x03	; 3
     4ae:	dc 93       	st	X, r29
     4b0:	ce 93       	st	-X, r28
     4b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4b4:	99 87       	std	Y+9, r25	; 0x09
     4b6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4b8:	fc 01       	movw	r30, r24
     4ba:	20 81       	ld	r18, Z
     4bc:	2f 5f       	subi	r18, 0xFF	; 255
     4be:	20 83       	st	Z, r18
}
     4c0:	df 91       	pop	r29
     4c2:	cf 91       	pop	r28
     4c4:	08 95       	ret

000004c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
     4ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4cc:	a0 85       	ldd	r26, Z+8	; 0x08
     4ce:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4d0:	c2 81       	ldd	r28, Z+2	; 0x02
     4d2:	d3 81       	ldd	r29, Z+3	; 0x03
     4d4:	84 81       	ldd	r24, Z+4	; 0x04
     4d6:	95 81       	ldd	r25, Z+5	; 0x05
     4d8:	9d 83       	std	Y+5, r25	; 0x05
     4da:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4dc:	c4 81       	ldd	r28, Z+4	; 0x04
     4de:	d5 81       	ldd	r29, Z+5	; 0x05
     4e0:	82 81       	ldd	r24, Z+2	; 0x02
     4e2:	93 81       	ldd	r25, Z+3	; 0x03
     4e4:	9b 83       	std	Y+3, r25	; 0x03
     4e6:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4e8:	11 96       	adiw	r26, 0x01	; 1
     4ea:	cd 91       	ld	r28, X+
     4ec:	dc 91       	ld	r29, X
     4ee:	12 97       	sbiw	r26, 0x02	; 2
     4f0:	ce 17       	cp	r28, r30
     4f2:	df 07       	cpc	r29, r31
     4f4:	31 f4       	brne	.+12     	; 0x502 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4f6:	8c 81       	ldd	r24, Y+4	; 0x04
     4f8:	9d 81       	ldd	r25, Y+5	; 0x05
     4fa:	12 96       	adiw	r26, 0x02	; 2
     4fc:	9c 93       	st	X, r25
     4fe:	8e 93       	st	-X, r24
     500:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     502:	11 86       	std	Z+9, r1	; 0x09
     504:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     506:	8c 91       	ld	r24, X
     508:	81 50       	subi	r24, 0x01	; 1
     50a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	08 95       	ret

00000512 <MaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void MaxSonar_Start()
{
	MaxSonar_TriggerStart();
     512:	a1 9a       	sbi	0x14, 1	; 20
	
	delayMicro(25); // delay 25 micro seconds...
     514:	89 e1       	ldi	r24, 0x19	; 25
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	c2 d0       	rcall	.+388    	; 0x69e <delayMicro>
	delayMicro2(5); // delay 25 micro seconds...
     51a:	85 e0       	ldi	r24, 0x05	; 5
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	e3 d0       	rcall	.+454    	; 0x6e6 <delayMicro2>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     520:	84 b3       	in	r24, 0x14	; 20
     522:	14 ba       	out	0x14, r1	; 20
     524:	08 95       	ret

00000526 <MaxSonar_Read>:
}

// Return distance in cm
int MaxSonar_Read(char analogChannel)
{
	return analogRead(analogChannel) * valueToCM;
     526:	9a d0       	rcall	.+308    	; 0x65c <analogRead>
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	9c 01       	movw	r18, r24
     52c:	22 0f       	add	r18, r18
     52e:	33 1f       	adc	r19, r19
     530:	22 0f       	add	r18, r18
     532:	33 1f       	adc	r19, r19
}
     534:	82 0f       	add	r24, r18
     536:	93 1f       	adc	r25, r19
     538:	08 95       	ret

0000053a <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     53a:	1f 92       	push	r1
     53c:	0f 92       	push	r0
     53e:	0f b6       	in	r0, 0x3f	; 63
     540:	0f 92       	push	r0
     542:	11 24       	eor	r1, r1
     544:	0b b6       	in	r0, 0x3b	; 59
     546:	0f 92       	push	r0
     548:	2f 93       	push	r18
     54a:	3f 93       	push	r19
     54c:	4f 93       	push	r20
     54e:	5f 93       	push	r21
     550:	6f 93       	push	r22
     552:	7f 93       	push	r23
     554:	8f 93       	push	r24
     556:	9f 93       	push	r25
     558:	af 93       	push	r26
     55a:	bf 93       	push	r27
     55c:	ef 93       	push	r30
     55e:	ff 93       	push	r31
	adcReading = ADCH; // read value
     560:	80 91 79 00 	lds	r24, 0x0079
     564:	80 93 d9 08 	sts	0x08D9, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     568:	20 e0       	ldi	r18, 0x00	; 0
     56a:	40 e0       	ldi	r20, 0x00	; 0
     56c:	50 e0       	ldi	r21, 0x00	; 0
     56e:	60 e0       	ldi	r22, 0x00	; 0
     570:	70 e0       	ldi	r23, 0x00	; 0
     572:	80 91 dc 08 	lds	r24, 0x08DC
     576:	90 91 dd 08 	lds	r25, 0x08DD
     57a:	2d d6       	rcall	.+3162   	; 0x11d6 <xQueueGenericSendFromISR>
}
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	bf 91       	pop	r27
     582:	af 91       	pop	r26
     584:	9f 91       	pop	r25
     586:	8f 91       	pop	r24
     588:	7f 91       	pop	r23
     58a:	6f 91       	pop	r22
     58c:	5f 91       	pop	r21
     58e:	4f 91       	pop	r20
     590:	3f 91       	pop	r19
     592:	2f 91       	pop	r18
     594:	0f 90       	pop	r0
     596:	0b be       	out	0x3b, r0	; 59
     598:	0f 90       	pop	r0
     59a:	0f be       	out	0x3f, r0	; 63
     59c:	0f 90       	pop	r0
     59e:	1f 90       	pop	r1
     5a0:	18 95       	reti

000005a2 <ADC_Init>:

void ADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     5a2:	8f e8       	ldi	r24, 0x8F	; 143
     5a4:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     5a8:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     5ac:	80 e6       	ldi	r24, 0x60	; 96
     5ae:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     5b2:	43 e0       	ldi	r20, 0x03	; 3
     5b4:	60 e0       	ldi	r22, 0x00	; 0
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	29 d5       	rcall	.+2642   	; 0x100c <xQueueGenericCreate>
     5ba:	90 93 dd 08 	sts	0x08DD, r25
     5be:	80 93 dc 08 	sts	0x08DC, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	e0 d5       	rcall	.+3008   	; 0x1186 <xQueueCreateMutex>
     5c6:	90 93 db 08 	sts	0x08DB, r25
     5ca:	80 93 da 08 	sts	0x08DA, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     5ce:	20 e0       	ldi	r18, 0x00	; 0
     5d0:	40 e0       	ldi	r20, 0x00	; 0
     5d2:	50 e0       	ldi	r21, 0x00	; 0
     5d4:	60 e0       	ldi	r22, 0x00	; 0
     5d6:	70 e0       	ldi	r23, 0x00	; 0
     5d8:	43 c5       	rjmp	.+2694   	; 0x1060 <xQueueGenericSend>
     5da:	08 95       	ret

000005dc <startADC>:
	return readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void startADC(char channel)
{
     5dc:	cf 93       	push	r28
     5de:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     5e0:	20 e0       	ldi	r18, 0x00	; 0
     5e2:	4f ef       	ldi	r20, 0xFF	; 255
     5e4:	5f ef       	ldi	r21, 0xFF	; 255
     5e6:	60 e0       	ldi	r22, 0x00	; 0
     5e8:	70 e0       	ldi	r23, 0x00	; 0
     5ea:	80 91 da 08 	lds	r24, 0x08DA
     5ee:	90 91 db 08 	lds	r25, 0x08DB
     5f2:	2b d6       	rcall	.+3158   	; 0x124a <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     5f4:	ec e7       	ldi	r30, 0x7C	; 124
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	80 81       	ld	r24, Z
     5fa:	9c 2f       	mov	r25, r28
     5fc:	9f 71       	andi	r25, 0x1F	; 31
     5fe:	80 76       	andi	r24, 0x60	; 96
     600:	89 2b       	or	r24, r25
     602:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     604:	eb e7       	ldi	r30, 0x7B	; 123
     606:	f0 e0       	ldi	r31, 0x00	; 0
     608:	20 81       	ld	r18, Z
     60a:	c0 72       	andi	r28, 0x20	; 32
     60c:	8c 2f       	mov	r24, r28
     60e:	90 e0       	ldi	r25, 0x00	; 0
     610:	95 95       	asr	r25
     612:	87 95       	ror	r24
     614:	95 95       	asr	r25
     616:	87 95       	ror	r24
     618:	92 2f       	mov	r25, r18
     61a:	90 76       	andi	r25, 0x60	; 96
     61c:	89 2b       	or	r24, r25
     61e:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     620:	ea e7       	ldi	r30, 0x7A	; 122
     622:	f0 e0       	ldi	r31, 0x00	; 0
     624:	80 81       	ld	r24, Z
     626:	80 64       	ori	r24, 0x40	; 64
     628:	80 83       	st	Z, r24
}
     62a:	cf 91       	pop	r28
     62c:	08 95       	ret

0000062e <readADC>:

unsigned char readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     62e:	20 e0       	ldi	r18, 0x00	; 0
     630:	4f ef       	ldi	r20, 0xFF	; 255
     632:	5f ef       	ldi	r21, 0xFF	; 255
     634:	60 e0       	ldi	r22, 0x00	; 0
     636:	70 e0       	ldi	r23, 0x00	; 0
     638:	80 91 dc 08 	lds	r24, 0x08DC
     63c:	90 91 dd 08 	lds	r25, 0x08DD
     640:	04 d6       	rcall	.+3080   	; 0x124a <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     642:	20 e0       	ldi	r18, 0x00	; 0
     644:	40 e0       	ldi	r20, 0x00	; 0
     646:	50 e0       	ldi	r21, 0x00	; 0
     648:	60 e0       	ldi	r22, 0x00	; 0
     64a:	70 e0       	ldi	r23, 0x00	; 0
     64c:	80 91 da 08 	lds	r24, 0x08DA
     650:	90 91 db 08 	lds	r25, 0x08DB
     654:	05 d5       	rcall	.+2570   	; 0x1060 <xQueueGenericSend>
	return adcReading;
     656:	80 91 d9 08 	lds	r24, 0x08D9
     65a:	08 95       	ret

0000065c <analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char analogRead(char channel)
{
     65c:	cf 93       	push	r28
     65e:	c8 2f       	mov	r28, r24
	startADC(channel);
     660:	bd df       	rcall	.-134    	; 0x5dc <startADC>
	return readADC(channel);
     662:	8c 2f       	mov	r24, r28
     664:	e4 df       	rcall	.-56     	; 0x62e <readADC>
}
     666:	cf 91       	pop	r28
     668:	08 95       	ret

0000066a <MyTimer_Init>:

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
}
     66a:	90 93 e3 08 	sts	0x08E3, r25
     66e:	80 93 e2 08 	sts	0x08E2, r24
     672:	fc 01       	movw	r30, r24
     674:	80 81       	ld	r24, Z
     676:	91 81       	ldd	r25, Z+1	; 0x01
     678:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskSuspend>
     67c:	43 e0       	ldi	r20, 0x03	; 3
     67e:	60 e0       	ldi	r22, 0x00	; 0
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	c4 d4       	rcall	.+2440   	; 0x100c <xQueueGenericCreate>
     684:	90 93 df 08 	sts	0x08DF, r25
     688:	80 93 de 08 	sts	0x08DE, r24
     68c:	43 e0       	ldi	r20, 0x03	; 3
     68e:	60 e0       	ldi	r22, 0x00	; 0
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	bc d4       	rcall	.+2424   	; 0x100c <xQueueGenericCreate>
     694:	90 93 e1 08 	sts	0x08E1, r25
     698:	80 93 e0 08 	sts	0x08E0, r24
     69c:	08 95       	ret

0000069e <delayMicro>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     69e:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     6a0:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     6a2:	9c 01       	movw	r18, r24
     6a4:	99 23       	and	r25, r25
     6a6:	14 f4       	brge	.+4      	; 0x6ac <delayMicro+0xe>
     6a8:	2d 5f       	subi	r18, 0xFD	; 253
     6aa:	3f 4f       	sbci	r19, 0xFF	; 255
     6ac:	35 95       	asr	r19
     6ae:	27 95       	ror	r18
     6b0:	35 95       	asr	r19
     6b2:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     6b4:	24 0f       	add	r18, r20
     6b6:	35 1f       	adc	r19, r21
     6b8:	30 93 03 02 	sts	0x0203, r19
     6bc:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     6c0:	e0 91 e2 08 	lds	r30, 0x08E2
     6c4:	f0 91 e3 08 	lds	r31, 0x08E3
     6c8:	80 81       	ld	r24, Z
     6ca:	91 81       	ldd	r25, Z+1	; 0x01
     6cc:	0e 94 81 0b 	call	0x1702	; 0x1702 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	42 e0       	ldi	r20, 0x02	; 2
     6d4:	50 e0       	ldi	r21, 0x00	; 0
     6d6:	60 e0       	ldi	r22, 0x00	; 0
     6d8:	70 e0       	ldi	r23, 0x00	; 0
     6da:	80 91 de 08 	lds	r24, 0x08DE
     6de:	90 91 df 08 	lds	r25, 0x08DF
     6e2:	b3 c5       	rjmp	.+2918   	; 0x124a <xQueueGenericReceive>
     6e4:	08 95       	ret

000006e6 <delayMicro2>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     6e6:	46 b5       	in	r20, 0x26	; 38
void delayMicro2(int delay)
{
	unsigned char currentTick = readTimer();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     6e8:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void delayMicro2(int delay)
{
	unsigned char currentTick = readTimer();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     6ea:	9c 01       	movw	r18, r24
     6ec:	99 23       	and	r25, r25
     6ee:	14 f4       	brge	.+4      	; 0x6f4 <delayMicro2+0xe>
     6f0:	2d 5f       	subi	r18, 0xFD	; 253
     6f2:	3f 4f       	sbci	r19, 0xFF	; 255
     6f4:	35 95       	asr	r19
     6f6:	27 95       	ror	r18
     6f8:	35 95       	asr	r19
     6fa:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     6fc:	24 0f       	add	r18, r20
     6fe:	35 1f       	adc	r19, r21
     700:	30 93 01 02 	sts	0x0201, r19
     704:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     708:	e0 91 e2 08 	lds	r30, 0x08E2
     70c:	f0 91 e3 08 	lds	r31, 0x08E3
     710:	80 81       	ld	r24, Z
     712:	91 81       	ldd	r25, Z+1	; 0x01
     714:	f6 d7       	rcall	.+4076   	; 0x1702 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     716:	20 e0       	ldi	r18, 0x00	; 0
     718:	42 e0       	ldi	r20, 0x02	; 2
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	60 e0       	ldi	r22, 0x00	; 0
     71e:	70 e0       	ldi	r23, 0x00	; 0
     720:	80 91 e0 08 	lds	r24, 0x08E0
     724:	90 91 e1 08 	lds	r25, 0x08E1
     728:	90 c5       	rjmp	.+2848   	; 0x124a <xQueueGenericReceive>
     72a:	08 95       	ret

0000072c <delayMicroCheck>:
}

// Semaphore on sale if u match lucky number ...
void delayMicroCheck()
{
     72c:	cf 93       	push	r28
     72e:	df 93       	push	r29
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     730:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void delayMicroCheck()
{
	unsigned char currentTick = readTimer();
	
	if(currentTick == 0) // overflow happened
     732:	c1 11       	cpse	r28, r1
     734:	22 c0       	rjmp	.+68     	; 0x77a <delayMicroCheck+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     736:	80 91 02 02 	lds	r24, 0x0202
     73a:	90 91 03 02 	lds	r25, 0x0203
     73e:	88 38       	cpi	r24, 0x88	; 136
     740:	93 41       	sbci	r25, 0x13	; 19
     742:	51 f0       	breq	.+20     	; 0x758 <delayMicroCheck+0x2c>
			expectedTick -= MAX_TICKS;
     744:	80 91 02 02 	lds	r24, 0x0202
     748:	90 91 03 02 	lds	r25, 0x0203
     74c:	8a 5f       	subi	r24, 0xFA	; 250
     74e:	91 09       	sbc	r25, r1
     750:	90 93 03 02 	sts	0x0203, r25
     754:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     758:	80 91 00 02 	lds	r24, 0x0200
     75c:	90 91 01 02 	lds	r25, 0x0201
     760:	88 38       	cpi	r24, 0x88	; 136
     762:	93 41       	sbci	r25, 0x13	; 19
     764:	51 f0       	breq	.+20     	; 0x77a <delayMicroCheck+0x4e>
			expectedTick2 -= MAX_TICKS;
     766:	80 91 00 02 	lds	r24, 0x0200
     76a:	90 91 01 02 	lds	r25, 0x0201
     76e:	8a 5f       	subi	r24, 0xFA	; 250
     770:	91 09       	sbc	r25, r1
     772:	90 93 01 02 	sts	0x0201, r25
     776:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     77a:	d0 e0       	ldi	r29, 0x00	; 0
     77c:	80 91 02 02 	lds	r24, 0x0202
     780:	90 91 03 02 	lds	r25, 0x0203
     784:	8c 17       	cp	r24, r28
     786:	9d 07       	cpc	r25, r29
     788:	84 f4       	brge	.+32     	; 0x7aa <delayMicroCheck+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     78a:	88 e8       	ldi	r24, 0x88	; 136
     78c:	93 e1       	ldi	r25, 0x13	; 19
     78e:	90 93 03 02 	sts	0x0203, r25
     792:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	40 e0       	ldi	r20, 0x00	; 0
     79a:	50 e0       	ldi	r21, 0x00	; 0
     79c:	60 e0       	ldi	r22, 0x00	; 0
     79e:	70 e0       	ldi	r23, 0x00	; 0
     7a0:	80 91 de 08 	lds	r24, 0x08DE
     7a4:	90 91 df 08 	lds	r25, 0x08DF
     7a8:	5b d4       	rcall	.+2230   	; 0x1060 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     7aa:	80 91 00 02 	lds	r24, 0x0200
     7ae:	90 91 01 02 	lds	r25, 0x0201
     7b2:	8c 17       	cp	r24, r28
     7b4:	9d 07       	cpc	r25, r29
     7b6:	84 f4       	brge	.+32     	; 0x7d8 <delayMicroCheck+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     7b8:	88 e8       	ldi	r24, 0x88	; 136
     7ba:	93 e1       	ldi	r25, 0x13	; 19
     7bc:	90 93 01 02 	sts	0x0201, r25
     7c0:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     7c4:	20 e0       	ldi	r18, 0x00	; 0
     7c6:	40 e0       	ldi	r20, 0x00	; 0
     7c8:	50 e0       	ldi	r21, 0x00	; 0
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	70 e0       	ldi	r23, 0x00	; 0
     7ce:	80 91 e0 08 	lds	r24, 0x08E0
     7d2:	90 91 e1 08 	lds	r25, 0x08E1
     7d6:	44 d4       	rcall	.+2184   	; 0x1060 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     7d8:	80 91 02 02 	lds	r24, 0x0202
     7dc:	90 91 03 02 	lds	r25, 0x0203
     7e0:	88 38       	cpi	r24, 0x88	; 136
     7e2:	93 41       	sbci	r25, 0x13	; 19
     7e4:	79 f4       	brne	.+30     	; 0x804 <delayMicroCheck+0xd8>
     7e6:	80 91 00 02 	lds	r24, 0x0200
     7ea:	90 91 01 02 	lds	r25, 0x0201
     7ee:	88 38       	cpi	r24, 0x88	; 136
     7f0:	93 41       	sbci	r25, 0x13	; 19
     7f2:	41 f4       	brne	.+16     	; 0x804 <delayMicroCheck+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     7f4:	e0 91 e2 08 	lds	r30, 0x08E2
     7f8:	f0 91 e3 08 	lds	r31, 0x08E3
     7fc:	80 81       	ld	r24, Z
     7fe:	91 81       	ldd	r25, Z+1	; 0x01
     800:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskSuspend>
	}
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	08 95       	ret

0000080a <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     80a:	1f 92       	push	r1
     80c:	0f 92       	push	r0
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	0f 92       	push	r0
     812:	11 24       	eor	r1, r1
     814:	0b b6       	in	r0, 0x3b	; 59
     816:	0f 92       	push	r0
     818:	2f 93       	push	r18
     81a:	3f 93       	push	r19
     81c:	4f 93       	push	r20
     81e:	5f 93       	push	r21
     820:	6f 93       	push	r22
     822:	7f 93       	push	r23
     824:	8f 93       	push	r24
     826:	9f 93       	push	r25
     828:	af 93       	push	r26
     82a:	bf 93       	push	r27
     82c:	ef 93       	push	r30
     82e:	ff 93       	push	r31
     830:	60 91 ce 00 	lds	r22, 0x00CE
     834:	87 e7       	ldi	r24, 0x77	; 119
     836:	99 e0       	ldi	r25, 0x09	; 9
     838:	d4 d5       	rcall	.+2984   	; 0x13e2 <ringBufferPush>
     83a:	20 e0       	ldi	r18, 0x00	; 0
     83c:	40 e0       	ldi	r20, 0x00	; 0
     83e:	50 e0       	ldi	r21, 0x00	; 0
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	80 91 6b 09 	lds	r24, 0x096B
     848:	90 91 6c 09 	lds	r25, 0x096C
     84c:	c4 d4       	rcall	.+2440   	; 0x11d6 <xQueueGenericSendFromISR>
     84e:	87 e7       	ldi	r24, 0x77	; 119
     850:	99 e0       	ldi	r25, 0x09	; 9
     852:	dd d5       	rcall	.+3002   	; 0x140e <ringBufferFull>
     854:	ff 91       	pop	r31
     856:	ef 91       	pop	r30
     858:	bf 91       	pop	r27
     85a:	af 91       	pop	r26
     85c:	9f 91       	pop	r25
     85e:	8f 91       	pop	r24
     860:	7f 91       	pop	r23
     862:	6f 91       	pop	r22
     864:	5f 91       	pop	r21
     866:	4f 91       	pop	r20
     868:	3f 91       	pop	r19
     86a:	2f 91       	pop	r18
     86c:	0f 90       	pop	r0
     86e:	0b be       	out	0x3b, r0	; 59
     870:	0f 90       	pop	r0
     872:	0f be       	out	0x3f, r0	; 63
     874:	0f 90       	pop	r0
     876:	1f 90       	pop	r1
     878:	18 95       	reti

0000087a <__vector_25>:
     87a:	1f 92       	push	r1
     87c:	0f 92       	push	r0
     87e:	0f b6       	in	r0, 0x3f	; 63
     880:	0f 92       	push	r0
     882:	11 24       	eor	r1, r1
     884:	0b b6       	in	r0, 0x3b	; 59
     886:	0f 92       	push	r0
     888:	2f 93       	push	r18
     88a:	3f 93       	push	r19
     88c:	4f 93       	push	r20
     88e:	5f 93       	push	r21
     890:	6f 93       	push	r22
     892:	7f 93       	push	r23
     894:	8f 93       	push	r24
     896:	9f 93       	push	r25
     898:	af 93       	push	r26
     89a:	bf 93       	push	r27
     89c:	ef 93       	push	r30
     89e:	ff 93       	push	r31
     8a0:	60 91 c6 00 	lds	r22, 0x00C6
     8a4:	84 e0       	ldi	r24, 0x04	; 4
     8a6:	99 e0       	ldi	r25, 0x09	; 9
     8a8:	9c d5       	rcall	.+2872   	; 0x13e2 <ringBufferPush>
     8aa:	20 e0       	ldi	r18, 0x00	; 0
     8ac:	40 e0       	ldi	r20, 0x00	; 0
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	60 e0       	ldi	r22, 0x00	; 0
     8b2:	70 e0       	ldi	r23, 0x00	; 0
     8b4:	80 91 6b 09 	lds	r24, 0x096B
     8b8:	90 91 6c 09 	lds	r25, 0x096C
     8bc:	8c d4       	rcall	.+2328   	; 0x11d6 <xQueueGenericSendFromISR>
     8be:	84 e0       	ldi	r24, 0x04	; 4
     8c0:	99 e0       	ldi	r25, 0x09	; 9
     8c2:	a5 d5       	rcall	.+2890   	; 0x140e <ringBufferFull>
     8c4:	ff 91       	pop	r31
     8c6:	ef 91       	pop	r30
     8c8:	bf 91       	pop	r27
     8ca:	af 91       	pop	r26
     8cc:	9f 91       	pop	r25
     8ce:	8f 91       	pop	r24
     8d0:	7f 91       	pop	r23
     8d2:	6f 91       	pop	r22
     8d4:	5f 91       	pop	r21
     8d6:	4f 91       	pop	r20
     8d8:	3f 91       	pop	r19
     8da:	2f 91       	pop	r18
     8dc:	0f 90       	pop	r0
     8de:	0b be       	out	0x3b, r0	; 59
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	0f 90       	pop	r0
     8e6:	1f 90       	pop	r1
     8e8:	18 95       	reti

000008ea <__vector_37>:
     8ea:	1f 92       	push	r1
     8ec:	0f 92       	push	r0
     8ee:	0f b6       	in	r0, 0x3f	; 63
     8f0:	0f 92       	push	r0
     8f2:	11 24       	eor	r1, r1
     8f4:	0b b6       	in	r0, 0x3b	; 59
     8f6:	0f 92       	push	r0
     8f8:	2f 93       	push	r18
     8fa:	3f 93       	push	r19
     8fc:	4f 93       	push	r20
     8fe:	5f 93       	push	r21
     900:	6f 93       	push	r22
     902:	7f 93       	push	r23
     904:	8f 93       	push	r24
     906:	9f 93       	push	r25
     908:	af 93       	push	r26
     90a:	bf 93       	push	r27
     90c:	ef 93       	push	r30
     90e:	ff 93       	push	r31
     910:	8d e6       	ldi	r24, 0x6D	; 109
     912:	99 e0       	ldi	r25, 0x09	; 9
     914:	83 d5       	rcall	.+2822   	; 0x141c <ringBufferNotEmpty>
     916:	88 23       	and	r24, r24
     918:	31 f0       	breq	.+12     	; 0x926 <__vector_37+0x3c>
     91a:	8d e6       	ldi	r24, 0x6D	; 109
     91c:	99 e0       	ldi	r25, 0x09	; 9
     91e:	4f d5       	rcall	.+2718   	; 0x13be <ringBufferPop>
     920:	80 93 ce 00 	sts	0x00CE, r24
     924:	05 c0       	rjmp	.+10     	; 0x930 <__vector_37+0x46>
     926:	e9 ec       	ldi	r30, 0xC9	; 201
     928:	f0 e0       	ldi	r31, 0x00	; 0
     92a:	80 81       	ld	r24, Z
     92c:	8f 7d       	andi	r24, 0xDF	; 223
     92e:	80 83       	st	Z, r24
     930:	ff 91       	pop	r31
     932:	ef 91       	pop	r30
     934:	bf 91       	pop	r27
     936:	af 91       	pop	r26
     938:	9f 91       	pop	r25
     93a:	8f 91       	pop	r24
     93c:	7f 91       	pop	r23
     93e:	6f 91       	pop	r22
     940:	5f 91       	pop	r21
     942:	4f 91       	pop	r20
     944:	3f 91       	pop	r19
     946:	2f 91       	pop	r18
     948:	0f 90       	pop	r0
     94a:	0b be       	out	0x3b, r0	; 59
     94c:	0f 90       	pop	r0
     94e:	0f be       	out	0x3f, r0	; 63
     950:	0f 90       	pop	r0
     952:	1f 90       	pop	r1
     954:	18 95       	reti

00000956 <__vector_26>:
     956:	1f 92       	push	r1
     958:	0f 92       	push	r0
     95a:	0f b6       	in	r0, 0x3f	; 63
     95c:	0f 92       	push	r0
     95e:	11 24       	eor	r1, r1
     960:	0b b6       	in	r0, 0x3b	; 59
     962:	0f 92       	push	r0
     964:	2f 93       	push	r18
     966:	3f 93       	push	r19
     968:	4f 93       	push	r20
     96a:	5f 93       	push	r21
     96c:	6f 93       	push	r22
     96e:	7f 93       	push	r23
     970:	8f 93       	push	r24
     972:	9f 93       	push	r25
     974:	af 93       	push	r26
     976:	bf 93       	push	r27
     978:	ef 93       	push	r30
     97a:	ff 93       	push	r31
     97c:	82 e7       	ldi	r24, 0x72	; 114
     97e:	99 e0       	ldi	r25, 0x09	; 9
     980:	4d d5       	rcall	.+2714   	; 0x141c <ringBufferNotEmpty>
     982:	88 23       	and	r24, r24
     984:	31 f0       	breq	.+12     	; 0x992 <__vector_26+0x3c>
     986:	82 e7       	ldi	r24, 0x72	; 114
     988:	99 e0       	ldi	r25, 0x09	; 9
     98a:	19 d5       	rcall	.+2610   	; 0x13be <ringBufferPop>
     98c:	80 93 c6 00 	sts	0x00C6, r24
     990:	05 c0       	rjmp	.+10     	; 0x99c <__vector_26+0x46>
     992:	e1 ec       	ldi	r30, 0xC1	; 193
     994:	f0 e0       	ldi	r31, 0x00	; 0
     996:	80 81       	ld	r24, Z
     998:	8f 7d       	andi	r24, 0xDF	; 223
     99a:	80 83       	st	Z, r24
     99c:	ff 91       	pop	r31
     99e:	ef 91       	pop	r30
     9a0:	bf 91       	pop	r27
     9a2:	af 91       	pop	r26
     9a4:	9f 91       	pop	r25
     9a6:	8f 91       	pop	r24
     9a8:	7f 91       	pop	r23
     9aa:	6f 91       	pop	r22
     9ac:	5f 91       	pop	r21
     9ae:	4f 91       	pop	r20
     9b0:	3f 91       	pop	r19
     9b2:	2f 91       	pop	r18
     9b4:	0f 90       	pop	r0
     9b6:	0b be       	out	0x3b, r0	; 59
     9b8:	0f 90       	pop	r0
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	0f 90       	pop	r0
     9be:	1f 90       	pop	r1
     9c0:	18 95       	reti

000009c2 <USART0_Init>:
     9c2:	10 92 c5 00 	sts	0x00C5, r1
     9c6:	87 e6       	ldi	r24, 0x67	; 103
     9c8:	80 93 c4 00 	sts	0x00C4, r24
     9cc:	88 eb       	ldi	r24, 0xB8	; 184
     9ce:	80 93 c1 00 	sts	0x00C1, r24
     9d2:	86 e0       	ldi	r24, 0x06	; 6
     9d4:	80 93 c2 00 	sts	0x00C2, r24
     9d8:	40 e2       	ldi	r20, 0x20	; 32
     9da:	69 e2       	ldi	r22, 0x29	; 41
     9dc:	79 e0       	ldi	r23, 0x09	; 9
     9de:	84 e0       	ldi	r24, 0x04	; 4
     9e0:	99 e0       	ldi	r25, 0x09	; 9
     9e2:	e6 d4       	rcall	.+2508   	; 0x13b0 <ringBufferInit>
     9e4:	40 e2       	ldi	r20, 0x20	; 32
     9e6:	69 e0       	ldi	r22, 0x09	; 9
     9e8:	79 e0       	ldi	r23, 0x09	; 9
     9ea:	82 e7       	ldi	r24, 0x72	; 114
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	e0 d4       	rcall	.+2496   	; 0x13b0 <ringBufferInit>
     9f0:	43 e0       	ldi	r20, 0x03	; 3
     9f2:	60 e0       	ldi	r22, 0x00	; 0
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	0a d3       	rcall	.+1556   	; 0x100c <xQueueGenericCreate>
     9f8:	90 93 6a 09 	sts	0x096A, r25
     9fc:	80 93 69 09 	sts	0x0969, r24
     a00:	08 95       	ret

00000a02 <USART1_Init>:
     a02:	10 92 cd 00 	sts	0x00CD, r1
     a06:	87 e6       	ldi	r24, 0x67	; 103
     a08:	80 93 cc 00 	sts	0x00CC, r24
     a0c:	88 eb       	ldi	r24, 0xB8	; 184
     a0e:	80 93 c9 00 	sts	0x00C9, r24
     a12:	86 e0       	ldi	r24, 0x06	; 6
     a14:	80 93 ca 00 	sts	0x00CA, r24
     a18:	40 e2       	ldi	r20, 0x20	; 32
     a1a:	64 ee       	ldi	r22, 0xE4	; 228
     a1c:	78 e0       	ldi	r23, 0x08	; 8
     a1e:	87 e7       	ldi	r24, 0x77	; 119
     a20:	99 e0       	ldi	r25, 0x09	; 9
     a22:	c6 d4       	rcall	.+2444   	; 0x13b0 <ringBufferInit>
     a24:	40 e2       	ldi	r20, 0x20	; 32
     a26:	69 e4       	ldi	r22, 0x49	; 73
     a28:	79 e0       	ldi	r23, 0x09	; 9
     a2a:	8d e6       	ldi	r24, 0x6D	; 109
     a2c:	99 e0       	ldi	r25, 0x09	; 9
     a2e:	c0 d4       	rcall	.+2432   	; 0x13b0 <ringBufferInit>
     a30:	43 e0       	ldi	r20, 0x03	; 3
     a32:	60 e0       	ldi	r22, 0x00	; 0
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	ea d2       	rcall	.+1492   	; 0x100c <xQueueGenericCreate>
     a38:	90 93 6c 09 	sts	0x096C, r25
     a3c:	80 93 6b 09 	sts	0x096B, r24
     a40:	08 95       	ret

00000a42 <transmitUSART0_c>:
     a42:	cf 93       	push	r28
     a44:	c8 2f       	mov	r28, r24
     a46:	82 e7       	ldi	r24, 0x72	; 114
     a48:	99 e0       	ldi	r25, 0x09	; 9
     a4a:	e1 d4       	rcall	.+2498   	; 0x140e <ringBufferFull>
     a4c:	81 11       	cpse	r24, r1
     a4e:	fb cf       	rjmp	.-10     	; 0xa46 <transmitUSART0_c+0x4>
     a50:	6c 2f       	mov	r22, r28
     a52:	82 e7       	ldi	r24, 0x72	; 114
     a54:	99 e0       	ldi	r25, 0x09	; 9
     a56:	c5 d4       	rcall	.+2442   	; 0x13e2 <ringBufferPush>
     a58:	e1 ec       	ldi	r30, 0xC1	; 193
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	80 81       	ld	r24, Z
     a5e:	80 62       	ori	r24, 0x20	; 32
     a60:	80 83       	st	Z, r24
     a62:	e0 ec       	ldi	r30, 0xC0	; 192
     a64:	f0 e0       	ldi	r31, 0x00	; 0
     a66:	80 81       	ld	r24, Z
     a68:	80 64       	ori	r24, 0x40	; 64
     a6a:	80 83       	st	Z, r24
     a6c:	cf 91       	pop	r28
     a6e:	08 95       	ret

00000a70 <transmitUSART1_c>:
     a70:	cf 93       	push	r28
     a72:	c8 2f       	mov	r28, r24
     a74:	8d e6       	ldi	r24, 0x6D	; 109
     a76:	99 e0       	ldi	r25, 0x09	; 9
     a78:	ca d4       	rcall	.+2452   	; 0x140e <ringBufferFull>
     a7a:	81 11       	cpse	r24, r1
     a7c:	fb cf       	rjmp	.-10     	; 0xa74 <transmitUSART1_c+0x4>
     a7e:	6c 2f       	mov	r22, r28
     a80:	8d e6       	ldi	r24, 0x6D	; 109
     a82:	99 e0       	ldi	r25, 0x09	; 9
     a84:	ae d4       	rcall	.+2396   	; 0x13e2 <ringBufferPush>
     a86:	e9 ec       	ldi	r30, 0xC9	; 201
     a88:	f0 e0       	ldi	r31, 0x00	; 0
     a8a:	80 81       	ld	r24, Z
     a8c:	80 62       	ori	r24, 0x20	; 32
     a8e:	80 83       	st	Z, r24
     a90:	e8 ec       	ldi	r30, 0xC8	; 200
     a92:	f0 e0       	ldi	r31, 0x00	; 0
     a94:	80 81       	ld	r24, Z
     a96:	80 64       	ori	r24, 0x40	; 64
     a98:	80 83       	st	Z, r24
     a9a:	cf 91       	pop	r28
     a9c:	08 95       	ret

00000a9e <transmitUSART0>:
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
     aa2:	ec 01       	movw	r28, r24
     aa4:	88 81       	ld	r24, Y
     aa6:	88 23       	and	r24, r24
     aa8:	29 f0       	breq	.+10     	; 0xab4 <transmitUSART0+0x16>
     aaa:	21 96       	adiw	r28, 0x01	; 1
     aac:	ca df       	rcall	.-108    	; 0xa42 <transmitUSART0_c>
     aae:	89 91       	ld	r24, Y+
     ab0:	81 11       	cpse	r24, r1
     ab2:	fc cf       	rjmp	.-8      	; 0xaac <transmitUSART0+0xe>
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	08 95       	ret

00000aba <receiveUSART1>:
     aba:	cf 93       	push	r28
     abc:	20 e0       	ldi	r18, 0x00	; 0
     abe:	4f ef       	ldi	r20, 0xFF	; 255
     ac0:	5f ef       	ldi	r21, 0xFF	; 255
     ac2:	60 e0       	ldi	r22, 0x00	; 0
     ac4:	70 e0       	ldi	r23, 0x00	; 0
     ac6:	80 91 69 09 	lds	r24, 0x0969
     aca:	90 91 6a 09 	lds	r25, 0x096A
     ace:	bd d3       	rcall	.+1914   	; 0x124a <xQueueGenericReceive>
     ad0:	87 e7       	ldi	r24, 0x77	; 119
     ad2:	99 e0       	ldi	r25, 0x09	; 9
     ad4:	74 d4       	rcall	.+2280   	; 0x13be <ringBufferPop>
     ad6:	c8 2f       	mov	r28, r24
     ad8:	87 e7       	ldi	r24, 0x77	; 119
     ada:	99 e0       	ldi	r25, 0x09	; 9
     adc:	9f d4       	rcall	.+2366   	; 0x141c <ringBufferNotEmpty>
     ade:	88 23       	and	r24, r24
     ae0:	51 f0       	breq	.+20     	; 0xaf6 <receiveUSART1+0x3c>
     ae2:	20 e0       	ldi	r18, 0x00	; 0
     ae4:	40 e0       	ldi	r20, 0x00	; 0
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	60 e0       	ldi	r22, 0x00	; 0
     aea:	70 e0       	ldi	r23, 0x00	; 0
     aec:	80 91 69 09 	lds	r24, 0x0969
     af0:	90 91 6a 09 	lds	r25, 0x096A
     af4:	b5 d2       	rcall	.+1386   	; 0x1060 <xQueueGenericSend>
     af6:	8c 2f       	mov	r24, r28
     af8:	cf 91       	pop	r28
     afa:	08 95       	ret

00000afc <startHandShake>:

// -1 if fail, 0 success
char startHandShake()
{
	transmitUSART1_c(HANDSHAKE_START);
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	b8 df       	rcall	.-144    	; 0xa70 <transmitUSART1_c>
	
	if (! receiveHandShakeAck(receiveUSART1()))
     b00:	dc df       	rcall	.-72     	; 0xaba <receiveUSART1>
     b02:	85 35       	cpi	r24, 0x55	; 85
     b04:	21 f4       	brne	.+8      	; 0xb0e <startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
     b06:	8f ef       	ldi	r24, 0xFF	; 255
     b08:	b3 df       	rcall	.-154    	; 0xa70 <transmitUSART1_c>
	
	return 0;
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	08 95       	ret
{
	transmitUSART1_c(HANDSHAKE_START);
	
	if (! receiveHandShakeAck(receiveUSART1()))
	{
		return -1; //error handling
     b0e:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     b10:	08 95       	ret

00000b12 <waitForHandshake>:


// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
     b12:	d3 df       	rcall	.-90     	; 0xaba <receiveUSART1>
     b14:	81 11       	cpse	r24, r1
     b16:	0a c0       	rjmp	.+20     	; 0xb2c <waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	transmitUSART1_c(HANDSHAKE_ACK);
     b18:	85 e5       	ldi	r24, 0x55	; 85
     b1a:	aa df       	rcall	.-172    	; 0xa70 <transmitUSART1_c>
	
	if (! receiveHandShakeStart(receiveUSART1()))
     b1c:	ce df       	rcall	.-100    	; 0xaba <receiveUSART1>
     b1e:	91 e0       	ldi	r25, 0x01	; 1
     b20:	81 11       	cpse	r24, r1
     b22:	01 c0       	rjmp	.+2      	; 0xb26 <waitForHandshake+0x14>
     b24:	90 e0       	ldi	r25, 0x00	; 0
     b26:	89 2f       	mov	r24, r25
     b28:	81 95       	neg	r24
     b2a:	08 95       	ret
// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
	{
		return -1; // error handling
     b2c:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     b2e:	08 95       	ret

00000b30 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     b30:	31 e1       	ldi	r19, 0x11	; 17
     b32:	fc 01       	movw	r30, r24
     b34:	30 83       	st	Z, r19
     b36:	31 97       	sbiw	r30, 0x01	; 1
     b38:	22 e2       	ldi	r18, 0x22	; 34
     b3a:	20 83       	st	Z, r18
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	a3 e3       	ldi	r26, 0x33	; 51
     b40:	a0 83       	st	Z, r26
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	60 83       	st	Z, r22
     b46:	31 97       	sbiw	r30, 0x01	; 1
     b48:	70 83       	st	Z, r23
     b4a:	31 97       	sbiw	r30, 0x01	; 1
     b4c:	10 82       	st	Z, r1
     b4e:	31 97       	sbiw	r30, 0x01	; 1
     b50:	10 82       	st	Z, r1
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	60 e8       	ldi	r22, 0x80	; 128
     b56:	60 83       	st	Z, r22
     b58:	31 97       	sbiw	r30, 0x01	; 1
     b5a:	10 82       	st	Z, r1
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	10 82       	st	Z, r1
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	10 82       	st	Z, r1
     b64:	31 97       	sbiw	r30, 0x01	; 1
     b66:	62 e0       	ldi	r22, 0x02	; 2
     b68:	60 83       	st	Z, r22
     b6a:	31 97       	sbiw	r30, 0x01	; 1
     b6c:	63 e0       	ldi	r22, 0x03	; 3
     b6e:	60 83       	st	Z, r22
     b70:	31 97       	sbiw	r30, 0x01	; 1
     b72:	64 e0       	ldi	r22, 0x04	; 4
     b74:	60 83       	st	Z, r22
     b76:	31 97       	sbiw	r30, 0x01	; 1
     b78:	65 e0       	ldi	r22, 0x05	; 5
     b7a:	60 83       	st	Z, r22
     b7c:	31 97       	sbiw	r30, 0x01	; 1
     b7e:	66 e0       	ldi	r22, 0x06	; 6
     b80:	60 83       	st	Z, r22
     b82:	31 97       	sbiw	r30, 0x01	; 1
     b84:	67 e0       	ldi	r22, 0x07	; 7
     b86:	60 83       	st	Z, r22
     b88:	31 97       	sbiw	r30, 0x01	; 1
     b8a:	68 e0       	ldi	r22, 0x08	; 8
     b8c:	60 83       	st	Z, r22
     b8e:	31 97       	sbiw	r30, 0x01	; 1
     b90:	69 e0       	ldi	r22, 0x09	; 9
     b92:	60 83       	st	Z, r22
     b94:	31 97       	sbiw	r30, 0x01	; 1
     b96:	60 e1       	ldi	r22, 0x10	; 16
     b98:	60 83       	st	Z, r22
     b9a:	31 97       	sbiw	r30, 0x01	; 1
     b9c:	30 83       	st	Z, r19
     b9e:	31 97       	sbiw	r30, 0x01	; 1
     ba0:	32 e1       	ldi	r19, 0x12	; 18
     ba2:	30 83       	st	Z, r19
     ba4:	31 97       	sbiw	r30, 0x01	; 1
     ba6:	33 e1       	ldi	r19, 0x13	; 19
     ba8:	30 83       	st	Z, r19
     baa:	31 97       	sbiw	r30, 0x01	; 1
     bac:	34 e1       	ldi	r19, 0x14	; 20
     bae:	30 83       	st	Z, r19
     bb0:	31 97       	sbiw	r30, 0x01	; 1
     bb2:	35 e1       	ldi	r19, 0x15	; 21
     bb4:	30 83       	st	Z, r19
     bb6:	31 97       	sbiw	r30, 0x01	; 1
     bb8:	36 e1       	ldi	r19, 0x16	; 22
     bba:	30 83       	st	Z, r19
     bbc:	31 97       	sbiw	r30, 0x01	; 1
     bbe:	37 e1       	ldi	r19, 0x17	; 23
     bc0:	30 83       	st	Z, r19
     bc2:	31 97       	sbiw	r30, 0x01	; 1
     bc4:	38 e1       	ldi	r19, 0x18	; 24
     bc6:	30 83       	st	Z, r19
     bc8:	31 97       	sbiw	r30, 0x01	; 1
     bca:	39 e1       	ldi	r19, 0x19	; 25
     bcc:	30 83       	st	Z, r19
     bce:	31 97       	sbiw	r30, 0x01	; 1
     bd0:	30 e2       	ldi	r19, 0x20	; 32
     bd2:	30 83       	st	Z, r19
     bd4:	31 97       	sbiw	r30, 0x01	; 1
     bd6:	31 e2       	ldi	r19, 0x21	; 33
     bd8:	30 83       	st	Z, r19
     bda:	31 97       	sbiw	r30, 0x01	; 1
     bdc:	20 83       	st	Z, r18
     bde:	31 97       	sbiw	r30, 0x01	; 1
     be0:	23 e2       	ldi	r18, 0x23	; 35
     be2:	20 83       	st	Z, r18
     be4:	31 97       	sbiw	r30, 0x01	; 1
     be6:	40 83       	st	Z, r20
     be8:	31 97       	sbiw	r30, 0x01	; 1
     bea:	50 83       	st	Z, r21
     bec:	31 97       	sbiw	r30, 0x01	; 1
     bee:	26 e2       	ldi	r18, 0x26	; 38
     bf0:	20 83       	st	Z, r18
     bf2:	31 97       	sbiw	r30, 0x01	; 1
     bf4:	27 e2       	ldi	r18, 0x27	; 39
     bf6:	20 83       	st	Z, r18
     bf8:	31 97       	sbiw	r30, 0x01	; 1
     bfa:	28 e2       	ldi	r18, 0x28	; 40
     bfc:	20 83       	st	Z, r18
     bfe:	31 97       	sbiw	r30, 0x01	; 1
     c00:	29 e2       	ldi	r18, 0x29	; 41
     c02:	20 83       	st	Z, r18
     c04:	31 97       	sbiw	r30, 0x01	; 1
     c06:	20 e3       	ldi	r18, 0x30	; 48
     c08:	20 83       	st	Z, r18
     c0a:	31 97       	sbiw	r30, 0x01	; 1
     c0c:	21 e3       	ldi	r18, 0x31	; 49
     c0e:	20 83       	st	Z, r18
     c10:	89 97       	sbiw	r24, 0x29	; 41
     c12:	08 95       	ret

00000c14 <xPortStartScheduler>:
     c14:	82 e0       	ldi	r24, 0x02	; 2
     c16:	84 bd       	out	0x24, r24	; 36
     c18:	16 bc       	out	0x26, r1	; 38
     c1a:	80 e3       	ldi	r24, 0x30	; 48
     c1c:	87 bd       	out	0x27, r24	; 39
     c1e:	ee e6       	ldi	r30, 0x6E	; 110
     c20:	f0 e0       	ldi	r31, 0x00	; 0
     c22:	80 81       	ld	r24, Z
     c24:	82 60       	ori	r24, 0x02	; 2
     c26:	80 83       	st	Z, r24
     c28:	83 e0       	ldi	r24, 0x03	; 3
     c2a:	85 bd       	out	0x25, r24	; 37
     c2c:	a0 91 d7 08 	lds	r26, 0x08D7
     c30:	b0 91 d8 08 	lds	r27, 0x08D8
     c34:	cd 91       	ld	r28, X+
     c36:	cd bf       	out	0x3d, r28	; 61
     c38:	dd 91       	ld	r29, X+
     c3a:	de bf       	out	0x3e, r29	; 62
     c3c:	ff 91       	pop	r31
     c3e:	ef 91       	pop	r30
     c40:	df 91       	pop	r29
     c42:	cf 91       	pop	r28
     c44:	bf 91       	pop	r27
     c46:	af 91       	pop	r26
     c48:	9f 91       	pop	r25
     c4a:	8f 91       	pop	r24
     c4c:	7f 91       	pop	r23
     c4e:	6f 91       	pop	r22
     c50:	5f 91       	pop	r21
     c52:	4f 91       	pop	r20
     c54:	3f 91       	pop	r19
     c56:	2f 91       	pop	r18
     c58:	1f 91       	pop	r17
     c5a:	0f 91       	pop	r16
     c5c:	ff 90       	pop	r15
     c5e:	ef 90       	pop	r14
     c60:	df 90       	pop	r13
     c62:	cf 90       	pop	r12
     c64:	bf 90       	pop	r11
     c66:	af 90       	pop	r10
     c68:	9f 90       	pop	r9
     c6a:	8f 90       	pop	r8
     c6c:	7f 90       	pop	r7
     c6e:	6f 90       	pop	r6
     c70:	5f 90       	pop	r5
     c72:	4f 90       	pop	r4
     c74:	3f 90       	pop	r3
     c76:	2f 90       	pop	r2
     c78:	1f 90       	pop	r1
     c7a:	0f 90       	pop	r0
     c7c:	0c be       	out	0x3c, r0	; 60
     c7e:	0f 90       	pop	r0
     c80:	0b be       	out	0x3b, r0	; 59
     c82:	0f 90       	pop	r0
     c84:	0f be       	out	0x3f, r0	; 63
     c86:	0f 90       	pop	r0
     c88:	08 95       	ret
     c8a:	81 e0       	ldi	r24, 0x01	; 1
     c8c:	08 95       	ret

00000c8e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c8e:	0f 92       	push	r0
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	0f 92       	push	r0
     c96:	0b b6       	in	r0, 0x3b	; 59
     c98:	0f 92       	push	r0
     c9a:	0c b6       	in	r0, 0x3c	; 60
     c9c:	0f 92       	push	r0
     c9e:	1f 92       	push	r1
     ca0:	11 24       	eor	r1, r1
     ca2:	2f 92       	push	r2
     ca4:	3f 92       	push	r3
     ca6:	4f 92       	push	r4
     ca8:	5f 92       	push	r5
     caa:	6f 92       	push	r6
     cac:	7f 92       	push	r7
     cae:	8f 92       	push	r8
     cb0:	9f 92       	push	r9
     cb2:	af 92       	push	r10
     cb4:	bf 92       	push	r11
     cb6:	cf 92       	push	r12
     cb8:	df 92       	push	r13
     cba:	ef 92       	push	r14
     cbc:	ff 92       	push	r15
     cbe:	0f 93       	push	r16
     cc0:	1f 93       	push	r17
     cc2:	2f 93       	push	r18
     cc4:	3f 93       	push	r19
     cc6:	4f 93       	push	r20
     cc8:	5f 93       	push	r21
     cca:	6f 93       	push	r22
     ccc:	7f 93       	push	r23
     cce:	8f 93       	push	r24
     cd0:	9f 93       	push	r25
     cd2:	af 93       	push	r26
     cd4:	bf 93       	push	r27
     cd6:	cf 93       	push	r28
     cd8:	df 93       	push	r29
     cda:	ef 93       	push	r30
     cdc:	ff 93       	push	r31
     cde:	a0 91 d7 08 	lds	r26, 0x08D7
     ce2:	b0 91 d8 08 	lds	r27, 0x08D8
     ce6:	0d b6       	in	r0, 0x3d	; 61
     ce8:	0d 92       	st	X+, r0
     cea:	0e b6       	in	r0, 0x3e	; 62
     cec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     cee:	5f d7       	rcall	.+3774   	; 0x1bae <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     cf0:	a0 91 d7 08 	lds	r26, 0x08D7
     cf4:	b0 91 d8 08 	lds	r27, 0x08D8
     cf8:	cd 91       	ld	r28, X+
     cfa:	cd bf       	out	0x3d, r28	; 61
     cfc:	dd 91       	ld	r29, X+
     cfe:	de bf       	out	0x3e, r29	; 62
     d00:	ff 91       	pop	r31
     d02:	ef 91       	pop	r30
     d04:	df 91       	pop	r29
     d06:	cf 91       	pop	r28
     d08:	bf 91       	pop	r27
     d0a:	af 91       	pop	r26
     d0c:	9f 91       	pop	r25
     d0e:	8f 91       	pop	r24
     d10:	7f 91       	pop	r23
     d12:	6f 91       	pop	r22
     d14:	5f 91       	pop	r21
     d16:	4f 91       	pop	r20
     d18:	3f 91       	pop	r19
     d1a:	2f 91       	pop	r18
     d1c:	1f 91       	pop	r17
     d1e:	0f 91       	pop	r16
     d20:	ff 90       	pop	r15
     d22:	ef 90       	pop	r14
     d24:	df 90       	pop	r13
     d26:	cf 90       	pop	r12
     d28:	bf 90       	pop	r11
     d2a:	af 90       	pop	r10
     d2c:	9f 90       	pop	r9
     d2e:	8f 90       	pop	r8
     d30:	7f 90       	pop	r7
     d32:	6f 90       	pop	r6
     d34:	5f 90       	pop	r5
     d36:	4f 90       	pop	r4
     d38:	3f 90       	pop	r3
     d3a:	2f 90       	pop	r2
     d3c:	1f 90       	pop	r1
     d3e:	0f 90       	pop	r0
     d40:	0c be       	out	0x3c, r0	; 60
     d42:	0f 90       	pop	r0
     d44:	0b be       	out	0x3b, r0	; 59
     d46:	0f 90       	pop	r0
     d48:	0f be       	out	0x3f, r0	; 63
     d4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d4c:	08 95       	ret

00000d4e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     d4e:	0f 92       	push	r0
     d50:	0f b6       	in	r0, 0x3f	; 63
     d52:	f8 94       	cli
     d54:	0f 92       	push	r0
     d56:	0b b6       	in	r0, 0x3b	; 59
     d58:	0f 92       	push	r0
     d5a:	0c b6       	in	r0, 0x3c	; 60
     d5c:	0f 92       	push	r0
     d5e:	1f 92       	push	r1
     d60:	11 24       	eor	r1, r1
     d62:	2f 92       	push	r2
     d64:	3f 92       	push	r3
     d66:	4f 92       	push	r4
     d68:	5f 92       	push	r5
     d6a:	6f 92       	push	r6
     d6c:	7f 92       	push	r7
     d6e:	8f 92       	push	r8
     d70:	9f 92       	push	r9
     d72:	af 92       	push	r10
     d74:	bf 92       	push	r11
     d76:	cf 92       	push	r12
     d78:	df 92       	push	r13
     d7a:	ef 92       	push	r14
     d7c:	ff 92       	push	r15
     d7e:	0f 93       	push	r16
     d80:	1f 93       	push	r17
     d82:	2f 93       	push	r18
     d84:	3f 93       	push	r19
     d86:	4f 93       	push	r20
     d88:	5f 93       	push	r21
     d8a:	6f 93       	push	r22
     d8c:	7f 93       	push	r23
     d8e:	8f 93       	push	r24
     d90:	9f 93       	push	r25
     d92:	af 93       	push	r26
     d94:	bf 93       	push	r27
     d96:	cf 93       	push	r28
     d98:	df 93       	push	r29
     d9a:	ef 93       	push	r30
     d9c:	ff 93       	push	r31
     d9e:	a0 91 d7 08 	lds	r26, 0x08D7
     da2:	b0 91 d8 08 	lds	r27, 0x08D8
     da6:	0d b6       	in	r0, 0x3d	; 61
     da8:	0d 92       	st	X+, r0
     daa:	0e b6       	in	r0, 0x3e	; 62
     dac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     dae:	2d d5       	rcall	.+2650   	; 0x180a <xTaskIncrementTick>
     db0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     db2:	fd d6       	rcall	.+3578   	; 0x1bae <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     db4:	a0 91 d7 08 	lds	r26, 0x08D7
     db8:	b0 91 d8 08 	lds	r27, 0x08D8
     dbc:	cd 91       	ld	r28, X+
     dbe:	cd bf       	out	0x3d, r28	; 61
     dc0:	dd 91       	ld	r29, X+
     dc2:	de bf       	out	0x3e, r29	; 62
     dc4:	ff 91       	pop	r31
     dc6:	ef 91       	pop	r30
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	bf 91       	pop	r27
     dce:	af 91       	pop	r26
     dd0:	9f 91       	pop	r25
     dd2:	8f 91       	pop	r24
     dd4:	7f 91       	pop	r23
     dd6:	6f 91       	pop	r22
     dd8:	5f 91       	pop	r21
     dda:	4f 91       	pop	r20
     ddc:	3f 91       	pop	r19
     dde:	2f 91       	pop	r18
     de0:	1f 91       	pop	r17
     de2:	0f 91       	pop	r16
     de4:	ff 90       	pop	r15
     de6:	ef 90       	pop	r14
     de8:	df 90       	pop	r13
     dea:	cf 90       	pop	r12
     dec:	bf 90       	pop	r11
     dee:	af 90       	pop	r10
     df0:	9f 90       	pop	r9
     df2:	8f 90       	pop	r8
     df4:	7f 90       	pop	r7
     df6:	6f 90       	pop	r6
     df8:	5f 90       	pop	r5
     dfa:	4f 90       	pop	r4
     dfc:	3f 90       	pop	r3
     dfe:	2f 90       	pop	r2
     e00:	1f 90       	pop	r1
     e02:	0f 90       	pop	r0
     e04:	0c be       	out	0x3c, r0	; 60
     e06:	0f 90       	pop	r0
     e08:	0b be       	out	0x3b, r0	; 59
     e0a:	0f 90       	pop	r0
     e0c:	0f be       	out	0x3f, r0	; 63
     e0e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e10:	08 95       	ret

00000e12 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     e12:	9d df       	rcall	.-198    	; 0xd4e <vPortYieldFromTick>
		 asm volatile ("reti");
     e14:	18 95       	reti

00000e16 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	ec 01       	movw	r28, r24
     e1e:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     e20:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e22:	81 11       	cpse	r24, r1
     e24:	0c c0       	rjmp	.+24     	; 0xe3e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e26:	88 81       	ld	r24, Y
     e28:	99 81       	ldd	r25, Y+1	; 0x01
     e2a:	89 2b       	or	r24, r25
     e2c:	09 f0       	breq	.+2      	; 0xe30 <prvCopyDataToQueue+0x1a>
     e2e:	47 c0       	rjmp	.+142    	; 0xebe <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     e30:	8a 81       	ldd	r24, Y+2	; 0x02
     e32:	9b 81       	ldd	r25, Y+3	; 0x03
     e34:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     e38:	1b 82       	std	Y+3, r1	; 0x03
     e3a:	1a 82       	std	Y+2, r1	; 0x02
     e3c:	47 c0       	rjmp	.+142    	; 0xecc <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     e3e:	41 11       	cpse	r20, r1
     e40:	18 c0       	rjmp	.+48     	; 0xe72 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     e42:	48 2f       	mov	r20, r24
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	8c 81       	ldd	r24, Y+4	; 0x04
     e48:	9d 81       	ldd	r25, Y+5	; 0x05
     e4a:	0e 94 12 10 	call	0x2024	; 0x2024 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     e4e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e50:	8c 81       	ldd	r24, Y+4	; 0x04
     e52:	9d 81       	ldd	r25, Y+5	; 0x05
     e54:	82 0f       	add	r24, r18
     e56:	91 1d       	adc	r25, r1
     e58:	9d 83       	std	Y+5, r25	; 0x05
     e5a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e5c:	2a 81       	ldd	r18, Y+2	; 0x02
     e5e:	3b 81       	ldd	r19, Y+3	; 0x03
     e60:	82 17       	cp	r24, r18
     e62:	93 07       	cpc	r25, r19
     e64:	70 f1       	brcs	.+92     	; 0xec2 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     e66:	88 81       	ld	r24, Y
     e68:	99 81       	ldd	r25, Y+1	; 0x01
     e6a:	9d 83       	std	Y+5, r25	; 0x05
     e6c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     e6e:	80 e0       	ldi	r24, 0x00	; 0
     e70:	2d c0       	rjmp	.+90     	; 0xecc <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e72:	48 2f       	mov	r20, r24
     e74:	50 e0       	ldi	r21, 0x00	; 0
     e76:	8e 81       	ldd	r24, Y+6	; 0x06
     e78:	9f 81       	ldd	r25, Y+7	; 0x07
     e7a:	0e 94 12 10 	call	0x2024	; 0x2024 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     e7e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e80:	30 e0       	ldi	r19, 0x00	; 0
     e82:	31 95       	neg	r19
     e84:	21 95       	neg	r18
     e86:	31 09       	sbc	r19, r1
     e88:	8e 81       	ldd	r24, Y+6	; 0x06
     e8a:	9f 81       	ldd	r25, Y+7	; 0x07
     e8c:	82 0f       	add	r24, r18
     e8e:	93 1f       	adc	r25, r19
     e90:	9f 83       	std	Y+7, r25	; 0x07
     e92:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e94:	68 81       	ld	r22, Y
     e96:	79 81       	ldd	r23, Y+1	; 0x01
     e98:	86 17       	cp	r24, r22
     e9a:	97 07       	cpc	r25, r23
     e9c:	30 f4       	brcc	.+12     	; 0xeaa <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ea0:	9b 81       	ldd	r25, Y+3	; 0x03
     ea2:	28 0f       	add	r18, r24
     ea4:	39 1f       	adc	r19, r25
     ea6:	3f 83       	std	Y+7, r19	; 0x07
     ea8:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     eaa:	12 30       	cpi	r17, 0x02	; 2
     eac:	61 f4       	brne	.+24     	; 0xec6 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     eae:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eb0:	88 23       	and	r24, r24
     eb2:	59 f0       	breq	.+22     	; 0xeca <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     eb4:	8a 8d       	ldd	r24, Y+26	; 0x1a
     eb6:	81 50       	subi	r24, 0x01	; 1
     eb8:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	07 c0       	rjmp	.+14     	; 0xecc <prvCopyDataToQueue+0xb6>
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	05 c0       	rjmp	.+10     	; 0xecc <prvCopyDataToQueue+0xb6>
     ec2:	80 e0       	ldi	r24, 0x00	; 0
     ec4:	03 c0       	rjmp	.+6      	; 0xecc <prvCopyDataToQueue+0xb6>
     ec6:	80 e0       	ldi	r24, 0x00	; 0
     ec8:	01 c0       	rjmp	.+2      	; 0xecc <prvCopyDataToQueue+0xb6>
     eca:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     ecc:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ece:	9f 5f       	subi	r25, 0xFF	; 255
     ed0:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	1f 91       	pop	r17
     ed8:	08 95       	ret

00000eda <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     eda:	fc 01       	movw	r30, r24
     edc:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     ede:	44 8d       	ldd	r20, Z+28	; 0x1c
     ee0:	44 23       	and	r20, r20
     ee2:	a1 f0       	breq	.+40     	; 0xf0c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     ee4:	50 e0       	ldi	r21, 0x00	; 0
     ee6:	26 81       	ldd	r18, Z+6	; 0x06
     ee8:	37 81       	ldd	r19, Z+7	; 0x07
     eea:	24 0f       	add	r18, r20
     eec:	35 1f       	adc	r19, r21
     eee:	37 83       	std	Z+7, r19	; 0x07
     ef0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     ef2:	62 81       	ldd	r22, Z+2	; 0x02
     ef4:	73 81       	ldd	r23, Z+3	; 0x03
     ef6:	26 17       	cp	r18, r22
     ef8:	37 07       	cpc	r19, r23
     efa:	20 f0       	brcs	.+8      	; 0xf04 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     efc:	20 81       	ld	r18, Z
     efe:	31 81       	ldd	r19, Z+1	; 0x01
     f00:	37 83       	std	Z+7, r19	; 0x07
     f02:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     f04:	66 81       	ldd	r22, Z+6	; 0x06
     f06:	77 81       	ldd	r23, Z+7	; 0x07
     f08:	0c 94 12 10 	jmp	0x2024	; 0x2024 <memcpy>
     f0c:	08 95       	ret

00000f0e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     f0e:	0f 93       	push	r16
     f10:	1f 93       	push	r17
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29
     f16:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     f18:	0f b6       	in	r0, 0x3f	; 63
     f1a:	f8 94       	cli
     f1c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f20:	18 16       	cp	r1, r24
     f22:	a4 f4       	brge	.+40     	; 0xf4c <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f24:	89 89       	ldd	r24, Y+17	; 0x11
     f26:	88 23       	and	r24, r24
     f28:	89 f0       	breq	.+34     	; 0xf4c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f2a:	8e 01       	movw	r16, r28
     f2c:	0f 5e       	subi	r16, 0xEF	; 239
     f2e:	1f 4f       	sbci	r17, 0xFF	; 255
     f30:	03 c0       	rjmp	.+6      	; 0xf38 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f32:	89 89       	ldd	r24, Y+17	; 0x11
     f34:	88 23       	and	r24, r24
     f36:	51 f0       	breq	.+20     	; 0xf4c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f38:	c8 01       	movw	r24, r16
     f3a:	0f d7       	rcall	.+3614   	; 0x1d5a <xTaskRemoveFromEventList>
     f3c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     f3e:	98 d7       	rcall	.+3888   	; 0x1e70 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     f40:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f42:	81 50       	subi	r24, 0x01	; 1
     f44:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f46:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f48:	18 16       	cp	r1, r24
     f4a:	9c f3       	brlt	.-26     	; 0xf32 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     f4c:	8f ef       	ldi	r24, 0xFF	; 255
     f4e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     f50:	0f 90       	pop	r0
     f52:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     f54:	0f b6       	in	r0, 0x3f	; 63
     f56:	f8 94       	cli
     f58:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     f5a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f5c:	18 16       	cp	r1, r24
     f5e:	a4 f4       	brge	.+40     	; 0xf88 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f60:	88 85       	ldd	r24, Y+8	; 0x08
     f62:	88 23       	and	r24, r24
     f64:	89 f0       	breq	.+34     	; 0xf88 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f66:	8e 01       	movw	r16, r28
     f68:	08 5f       	subi	r16, 0xF8	; 248
     f6a:	1f 4f       	sbci	r17, 0xFF	; 255
     f6c:	03 c0       	rjmp	.+6      	; 0xf74 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f6e:	88 85       	ldd	r24, Y+8	; 0x08
     f70:	88 23       	and	r24, r24
     f72:	51 f0       	breq	.+20     	; 0xf88 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     f74:	c8 01       	movw	r24, r16
     f76:	f1 d6       	rcall	.+3554   	; 0x1d5a <xTaskRemoveFromEventList>
     f78:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     f7a:	7a d7       	rcall	.+3828   	; 0x1e70 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     f7c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f7e:	81 50       	subi	r24, 0x01	; 1
     f80:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     f82:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f84:	18 16       	cp	r1, r24
     f86:	9c f3       	brlt	.-26     	; 0xf6e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     f88:	8f ef       	ldi	r24, 0xFF	; 255
     f8a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     f8c:	0f 90       	pop	r0
     f8e:	0f be       	out	0x3f, r0	; 63
}
     f90:	df 91       	pop	r29
     f92:	cf 91       	pop	r28
     f94:	1f 91       	pop	r17
     f96:	0f 91       	pop	r16
     f98:	08 95       	ret

00000f9a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     f9a:	cf 93       	push	r28
     f9c:	df 93       	push	r29
     f9e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     fa0:	0f b6       	in	r0, 0x3f	; 63
     fa2:	f8 94       	cli
     fa4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     fa6:	88 81       	ld	r24, Y
     fa8:	99 81       	ldd	r25, Y+1	; 0x01
     faa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fac:	30 e0       	ldi	r19, 0x00	; 0
     fae:	7b 8d       	ldd	r23, Y+27	; 0x1b
     fb0:	72 9f       	mul	r23, r18
     fb2:	a0 01       	movw	r20, r0
     fb4:	73 9f       	mul	r23, r19
     fb6:	50 0d       	add	r21, r0
     fb8:	11 24       	eor	r1, r1
     fba:	fc 01       	movw	r30, r24
     fbc:	e4 0f       	add	r30, r20
     fbe:	f5 1f       	adc	r31, r21
     fc0:	fb 83       	std	Y+3, r31	; 0x03
     fc2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     fc4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     fc6:	9d 83       	std	Y+5, r25	; 0x05
     fc8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     fca:	42 1b       	sub	r20, r18
     fcc:	53 0b       	sbc	r21, r19
     fce:	84 0f       	add	r24, r20
     fd0:	95 1f       	adc	r25, r21
     fd2:	9f 83       	std	Y+7, r25	; 0x07
     fd4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     fd6:	8f ef       	ldi	r24, 0xFF	; 255
     fd8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     fda:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     fdc:	61 11       	cpse	r22, r1
     fde:	0a c0       	rjmp	.+20     	; 0xff4 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fe0:	88 85       	ldd	r24, Y+8	; 0x08
     fe2:	88 23       	and	r24, r24
     fe4:	69 f0       	breq	.+26     	; 0x1000 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     fe6:	ce 01       	movw	r24, r28
     fe8:	08 96       	adiw	r24, 0x08	; 8
     fea:	b7 d6       	rcall	.+3438   	; 0x1d5a <xTaskRemoveFromEventList>
     fec:	81 30       	cpi	r24, 0x01	; 1
     fee:	41 f4       	brne	.+16     	; 0x1000 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
     ff0:	4e de       	rcall	.-868    	; 0xc8e <vPortYield>
     ff2:	06 c0       	rjmp	.+12     	; 0x1000 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     ff4:	ce 01       	movw	r24, r28
     ff6:	08 96       	adiw	r24, 0x08	; 8
     ff8:	02 da       	rcall	.-3068   	; 0x3fe <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     ffa:	ce 01       	movw	r24, r28
     ffc:	41 96       	adiw	r24, 0x11	; 17
     ffe:	ff d9       	rcall	.-3074   	; 0x3fe <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1000:	0f 90       	pop	r0
    1002:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1004:	81 e0       	ldi	r24, 0x01	; 1
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	08 95       	ret

0000100c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	18 2f       	mov	r17, r24
    1016:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1018:	88 23       	and	r24, r24
    101a:	d1 f0       	breq	.+52     	; 0x1050 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    101c:	8f e1       	ldi	r24, 0x1F	; 31
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	b8 d9       	rcall	.-3216   	; 0x392 <pvPortMalloc>
    1022:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1024:	00 97       	sbiw	r24, 0x00	; 0
    1026:	b1 f0       	breq	.+44     	; 0x1054 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1028:	10 9f       	mul	r17, r16
    102a:	c0 01       	movw	r24, r0
    102c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    102e:	01 96       	adiw	r24, 0x01	; 1
    1030:	b0 d9       	rcall	.-3232   	; 0x392 <pvPortMalloc>
    1032:	99 83       	std	Y+1, r25	; 0x01
    1034:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1036:	89 2b       	or	r24, r25
    1038:	31 f0       	breq	.+12     	; 0x1046 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    103a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    103c:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    103e:	61 e0       	ldi	r22, 0x01	; 1
    1040:	ce 01       	movw	r24, r28
    1042:	ab df       	rcall	.-170    	; 0xf9a <xQueueGenericReset>
    1044:	07 c0       	rjmp	.+14     	; 0x1054 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1046:	ce 01       	movw	r24, r28
    1048:	d9 d9       	rcall	.-3150   	; 0x3fc <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    104a:	c0 e0       	ldi	r28, 0x00	; 0
    104c:	d0 e0       	ldi	r29, 0x00	; 0
    104e:	02 c0       	rjmp	.+4      	; 0x1054 <xQueueGenericCreate+0x48>
    1050:	c0 e0       	ldi	r28, 0x00	; 0
    1052:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1054:	ce 01       	movw	r24, r28
    1056:	df 91       	pop	r29
    1058:	cf 91       	pop	r28
    105a:	1f 91       	pop	r17
    105c:	0f 91       	pop	r16
    105e:	08 95       	ret

00001060 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1060:	9f 92       	push	r9
    1062:	af 92       	push	r10
    1064:	bf 92       	push	r11
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ef 92       	push	r14
    106c:	ff 92       	push	r15
    106e:	0f 93       	push	r16
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	00 d0       	rcall	.+0      	; 0x1078 <xQueueGenericSend+0x18>
    1078:	1f 92       	push	r1
    107a:	1f 92       	push	r1
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	8c 01       	movw	r16, r24
    1082:	6b 01       	movw	r12, r22
    1084:	5d 83       	std	Y+5, r21	; 0x05
    1086:	4c 83       	std	Y+4, r20	; 0x04
    1088:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    108a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    108c:	99 24       	eor	r9, r9
    108e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1090:	7c 01       	movw	r14, r24
    1092:	88 e0       	ldi	r24, 0x08	; 8
    1094:	e8 0e       	add	r14, r24
    1096:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    109e:	f8 01       	movw	r30, r16
    10a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    10a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a4:	98 17       	cp	r25, r24
    10a6:	18 f0       	brcs	.+6      	; 0x10ae <xQueueGenericSend+0x4e>
    10a8:	f2 e0       	ldi	r31, 0x02	; 2
    10aa:	af 12       	cpse	r10, r31
    10ac:	15 c0       	rjmp	.+42     	; 0x10d8 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    10ae:	4a 2d       	mov	r20, r10
    10b0:	b6 01       	movw	r22, r12
    10b2:	c8 01       	movw	r24, r16
    10b4:	b0 de       	rcall	.-672    	; 0xe16 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10b6:	f8 01       	movw	r30, r16
    10b8:	91 89       	ldd	r25, Z+17	; 0x11
    10ba:	99 23       	and	r25, r25
    10bc:	39 f0       	breq	.+14     	; 0x10cc <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    10be:	c8 01       	movw	r24, r16
    10c0:	41 96       	adiw	r24, 0x11	; 17
    10c2:	4b d6       	rcall	.+3222   	; 0x1d5a <xTaskRemoveFromEventList>
    10c4:	81 30       	cpi	r24, 0x01	; 1
    10c6:	21 f4       	brne	.+8      	; 0x10d0 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    10c8:	e2 dd       	rcall	.-1084   	; 0xc8e <vPortYield>
    10ca:	02 c0       	rjmp	.+4      	; 0x10d0 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    10cc:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    10ce:	df dd       	rcall	.-1090   	; 0xc8e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    10d0:	0f 90       	pop	r0
    10d2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	46 c0       	rjmp	.+140    	; 0x1164 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    10d8:	ec 81       	ldd	r30, Y+4	; 0x04
    10da:	fd 81       	ldd	r31, Y+5	; 0x05
    10dc:	ef 2b       	or	r30, r31
    10de:	21 f4       	brne	.+8      	; 0x10e8 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10e0:	0f 90       	pop	r0
    10e2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    10e4:	80 e0       	ldi	r24, 0x00	; 0
    10e6:	3e c0       	rjmp	.+124    	; 0x1164 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    10e8:	b1 10       	cpse	r11, r1
    10ea:	04 c0       	rjmp	.+8      	; 0x10f4 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10ec:	ce 01       	movw	r24, r28
    10ee:	01 96       	adiw	r24, 0x01	; 1
    10f0:	7c d6       	rcall	.+3320   	; 0x1dea <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    10f2:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    10f4:	0f 90       	pop	r0
    10f6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    10f8:	78 d3       	rcall	.+1776   	; 0x17ea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    10fa:	0f b6       	in	r0, 0x3f	; 63
    10fc:	f8 94       	cli
    10fe:	0f 92       	push	r0
    1100:	f8 01       	movw	r30, r16
    1102:	85 8d       	ldd	r24, Z+29	; 0x1d
    1104:	8f 3f       	cpi	r24, 0xFF	; 255
    1106:	09 f4       	brne	.+2      	; 0x110a <xQueueGenericSend+0xaa>
    1108:	15 8e       	std	Z+29, r1	; 0x1d
    110a:	f8 01       	movw	r30, r16
    110c:	86 8d       	ldd	r24, Z+30	; 0x1e
    110e:	8f 3f       	cpi	r24, 0xFF	; 255
    1110:	09 f4       	brne	.+2      	; 0x1114 <xQueueGenericSend+0xb4>
    1112:	16 8e       	std	Z+30, r1	; 0x1e
    1114:	0f 90       	pop	r0
    1116:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1118:	be 01       	movw	r22, r28
    111a:	6c 5f       	subi	r22, 0xFC	; 252
    111c:	7f 4f       	sbci	r23, 0xFF	; 255
    111e:	ce 01       	movw	r24, r28
    1120:	01 96       	adiw	r24, 0x01	; 1
    1122:	6e d6       	rcall	.+3292   	; 0x1e00 <xTaskCheckForTimeOut>
    1124:	81 11       	cpse	r24, r1
    1126:	1a c0       	rjmp	.+52     	; 0x115c <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1128:	0f b6       	in	r0, 0x3f	; 63
    112a:	f8 94       	cli
    112c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    112e:	f8 01       	movw	r30, r16
    1130:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1132:	0f 90       	pop	r0
    1134:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1136:	f8 01       	movw	r30, r16
    1138:	83 8d       	ldd	r24, Z+27	; 0x1b
    113a:	98 13       	cpse	r25, r24
    113c:	0b c0       	rjmp	.+22     	; 0x1154 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    113e:	6c 81       	ldd	r22, Y+4	; 0x04
    1140:	7d 81       	ldd	r23, Y+5	; 0x05
    1142:	c7 01       	movw	r24, r14
    1144:	df d5       	rcall	.+3006   	; 0x1d04 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1146:	c8 01       	movw	r24, r16
    1148:	e2 de       	rcall	.-572    	; 0xf0e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    114a:	1d d4       	rcall	.+2106   	; 0x1986 <xTaskResumeAll>
    114c:	81 11       	cpse	r24, r1
    114e:	a4 cf       	rjmp	.-184    	; 0x1098 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1150:	9e dd       	rcall	.-1220   	; 0xc8e <vPortYield>
    1152:	a2 cf       	rjmp	.-188    	; 0x1098 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1154:	c8 01       	movw	r24, r16
    1156:	db de       	rcall	.-586    	; 0xf0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1158:	16 d4       	rcall	.+2092   	; 0x1986 <xTaskResumeAll>
    115a:	9e cf       	rjmp	.-196    	; 0x1098 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    115c:	c8 01       	movw	r24, r16
    115e:	d7 de       	rcall	.-594    	; 0xf0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1160:	12 d4       	rcall	.+2084   	; 0x1986 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1162:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1164:	0f 90       	pop	r0
    1166:	0f 90       	pop	r0
    1168:	0f 90       	pop	r0
    116a:	0f 90       	pop	r0
    116c:	0f 90       	pop	r0
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	ff 90       	pop	r15
    1178:	ef 90       	pop	r14
    117a:	df 90       	pop	r13
    117c:	cf 90       	pop	r12
    117e:	bf 90       	pop	r11
    1180:	af 90       	pop	r10
    1182:	9f 90       	pop	r9
    1184:	08 95       	ret

00001186 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    118a:	8f e1       	ldi	r24, 0x1F	; 31
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	01 d9       	rcall	.-3582   	; 0x392 <pvPortMalloc>
    1190:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1192:	00 97       	sbiw	r24, 0x00	; 0
    1194:	e1 f0       	breq	.+56     	; 0x11ce <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1196:	1b 82       	std	Y+3, r1	; 0x03
    1198:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    119a:	19 82       	std	Y+1, r1	; 0x01
    119c:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    119e:	1d 82       	std	Y+5, r1	; 0x05
    11a0:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    11a2:	1f 82       	std	Y+7, r1	; 0x07
    11a4:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    11a6:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    11a8:	81 e0       	ldi	r24, 0x01	; 1
    11aa:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    11ac:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    11ae:	8f ef       	ldi	r24, 0xFF	; 255
    11b0:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    11b2:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11b4:	ce 01       	movw	r24, r28
    11b6:	08 96       	adiw	r24, 0x08	; 8
    11b8:	22 d9       	rcall	.-3516   	; 0x3fe <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11ba:	ce 01       	movw	r24, r28
    11bc:	41 96       	adiw	r24, 0x11	; 17
    11be:	1f d9       	rcall	.-3522   	; 0x3fe <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    11c0:	20 e0       	ldi	r18, 0x00	; 0
    11c2:	40 e0       	ldi	r20, 0x00	; 0
    11c4:	50 e0       	ldi	r21, 0x00	; 0
    11c6:	60 e0       	ldi	r22, 0x00	; 0
    11c8:	70 e0       	ldi	r23, 0x00	; 0
    11ca:	ce 01       	movw	r24, r28
    11cc:	49 df       	rcall	.-366    	; 0x1060 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    11ce:	ce 01       	movw	r24, r28
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	ec 01       	movw	r28, r24
    11e0:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11e2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    11e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    11e6:	98 17       	cp	r25, r24
    11e8:	10 f0       	brcs	.+4      	; 0x11ee <xQueueGenericSendFromISR+0x18>
    11ea:	22 30       	cpi	r18, 0x02	; 2
    11ec:	11 f5       	brne	.+68     	; 0x1232 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    11ee:	42 2f       	mov	r20, r18
    11f0:	ce 01       	movw	r24, r28
    11f2:	11 de       	rcall	.-990    	; 0xe16 <prvCopyDataToQueue>
    11f4:	88 23       	and	r24, r24
    11f6:	31 f0       	breq	.+12     	; 0x1204 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    11f8:	01 15       	cp	r16, r1
    11fa:	11 05       	cpc	r17, r1
    11fc:	19 f0       	breq	.+6      	; 0x1204 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	f8 01       	movw	r30, r16
    1202:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1204:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1206:	8f 3f       	cpi	r24, 0xFF	; 255
    1208:	79 f4       	brne	.+30     	; 0x1228 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    120a:	89 89       	ldd	r24, Y+17	; 0x11
    120c:	88 23       	and	r24, r24
    120e:	99 f0       	breq	.+38     	; 0x1236 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1210:	ce 01       	movw	r24, r28
    1212:	41 96       	adiw	r24, 0x11	; 17
    1214:	a2 d5       	rcall	.+2884   	; 0x1d5a <xTaskRemoveFromEventList>
    1216:	88 23       	and	r24, r24
    1218:	81 f0       	breq	.+32     	; 0x123a <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    121a:	01 15       	cp	r16, r1
    121c:	11 05       	cpc	r17, r1
    121e:	79 f0       	breq	.+30     	; 0x123e <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	f8 01       	movw	r30, r16
    1224:	80 83       	st	Z, r24
    1226:	0c c0       	rjmp	.+24     	; 0x1240 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1228:	8e 8d       	ldd	r24, Y+30	; 0x1e
    122a:	8f 5f       	subi	r24, 0xFF	; 255
    122c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	07 c0       	rjmp	.+14     	; 0x1240 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1232:	80 e0       	ldi	r24, 0x00	; 0
    1234:	05 c0       	rjmp	.+10     	; 0x1240 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1236:	81 e0       	ldi	r24, 0x01	; 1
    1238:	03 c0       	rjmp	.+6      	; 0x1240 <xQueueGenericSendFromISR+0x6a>
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	01 c0       	rjmp	.+2      	; 0x1240 <xQueueGenericSendFromISR+0x6a>
    123e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	1f 91       	pop	r17
    1246:	0f 91       	pop	r16
    1248:	08 95       	ret

0000124a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    124a:	9f 92       	push	r9
    124c:	af 92       	push	r10
    124e:	bf 92       	push	r11
    1250:	cf 92       	push	r12
    1252:	df 92       	push	r13
    1254:	ef 92       	push	r14
    1256:	ff 92       	push	r15
    1258:	0f 93       	push	r16
    125a:	1f 93       	push	r17
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	00 d0       	rcall	.+0      	; 0x1262 <xQueueGenericReceive+0x18>
    1262:	1f 92       	push	r1
    1264:	1f 92       	push	r1
    1266:	cd b7       	in	r28, 0x3d	; 61
    1268:	de b7       	in	r29, 0x3e	; 62
    126a:	8c 01       	movw	r16, r24
    126c:	6b 01       	movw	r12, r22
    126e:	5d 83       	std	Y+5, r21	; 0x05
    1270:	4c 83       	std	Y+4, r20	; 0x04
    1272:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1274:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1276:	99 24       	eor	r9, r9
    1278:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    127a:	7c 01       	movw	r14, r24
    127c:	81 e1       	ldi	r24, 0x11	; 17
    127e:	e8 0e       	add	r14, r24
    1280:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1282:	0f b6       	in	r0, 0x3f	; 63
    1284:	f8 94       	cli
    1286:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1288:	f8 01       	movw	r30, r16
    128a:	82 8d       	ldd	r24, Z+26	; 0x1a
    128c:	88 23       	and	r24, r24
    128e:	69 f1       	breq	.+90     	; 0x12ea <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1290:	e6 80       	ldd	r14, Z+6	; 0x06
    1292:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1294:	b6 01       	movw	r22, r12
    1296:	c8 01       	movw	r24, r16
    1298:	20 de       	rcall	.-960    	; 0xeda <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    129a:	b1 10       	cpse	r11, r1
    129c:	17 c0       	rjmp	.+46     	; 0x12cc <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    129e:	f8 01       	movw	r30, r16
    12a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    12a2:	81 50       	subi	r24, 0x01	; 1
    12a4:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12a6:	80 81       	ld	r24, Z
    12a8:	91 81       	ldd	r25, Z+1	; 0x01
    12aa:	89 2b       	or	r24, r25
    12ac:	21 f4       	brne	.+8      	; 0x12b6 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    12ae:	81 d6       	rcall	.+3330   	; 0x1fb2 <pvTaskIncrementMutexHeldCount>
    12b0:	f8 01       	movw	r30, r16
    12b2:	93 83       	std	Z+3, r25	; 0x03
    12b4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12b6:	f8 01       	movw	r30, r16
    12b8:	80 85       	ldd	r24, Z+8	; 0x08
    12ba:	88 23       	and	r24, r24
    12bc:	91 f0       	breq	.+36     	; 0x12e2 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    12be:	c8 01       	movw	r24, r16
    12c0:	08 96       	adiw	r24, 0x08	; 8
    12c2:	4b d5       	rcall	.+2710   	; 0x1d5a <xTaskRemoveFromEventList>
    12c4:	81 30       	cpi	r24, 0x01	; 1
    12c6:	69 f4       	brne	.+26     	; 0x12e2 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    12c8:	e2 dc       	rcall	.-1596   	; 0xc8e <vPortYield>
    12ca:	0b c0       	rjmp	.+22     	; 0x12e2 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    12cc:	f8 01       	movw	r30, r16
    12ce:	f7 82       	std	Z+7, r15	; 0x07
    12d0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12d2:	81 89       	ldd	r24, Z+17	; 0x11
    12d4:	88 23       	and	r24, r24
    12d6:	29 f0       	breq	.+10     	; 0x12e2 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12d8:	c8 01       	movw	r24, r16
    12da:	41 96       	adiw	r24, 0x11	; 17
    12dc:	3e d5       	rcall	.+2684   	; 0x1d5a <xTaskRemoveFromEventList>
    12de:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    12e0:	d6 dc       	rcall	.-1620   	; 0xc8e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    12e2:	0f 90       	pop	r0
    12e4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	52 c0       	rjmp	.+164    	; 0x138e <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    12ea:	4c 81       	ldd	r20, Y+4	; 0x04
    12ec:	5d 81       	ldd	r21, Y+5	; 0x05
    12ee:	45 2b       	or	r20, r21
    12f0:	21 f4       	brne	.+8      	; 0x12fa <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12f2:	0f 90       	pop	r0
    12f4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    12f6:	80 e0       	ldi	r24, 0x00	; 0
    12f8:	4a c0       	rjmp	.+148    	; 0x138e <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    12fa:	a1 10       	cpse	r10, r1
    12fc:	04 c0       	rjmp	.+8      	; 0x1306 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12fe:	ce 01       	movw	r24, r28
    1300:	01 96       	adiw	r24, 0x01	; 1
    1302:	73 d5       	rcall	.+2790   	; 0x1dea <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1304:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1306:	0f 90       	pop	r0
    1308:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    130a:	6f d2       	rcall	.+1246   	; 0x17ea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    130c:	0f b6       	in	r0, 0x3f	; 63
    130e:	f8 94       	cli
    1310:	0f 92       	push	r0
    1312:	f8 01       	movw	r30, r16
    1314:	85 8d       	ldd	r24, Z+29	; 0x1d
    1316:	8f 3f       	cpi	r24, 0xFF	; 255
    1318:	09 f4       	brne	.+2      	; 0x131c <xQueueGenericReceive+0xd2>
    131a:	15 8e       	std	Z+29, r1	; 0x1d
    131c:	f8 01       	movw	r30, r16
    131e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1320:	8f 3f       	cpi	r24, 0xFF	; 255
    1322:	09 f4       	brne	.+2      	; 0x1326 <xQueueGenericReceive+0xdc>
    1324:	16 8e       	std	Z+30, r1	; 0x1e
    1326:	0f 90       	pop	r0
    1328:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    132a:	be 01       	movw	r22, r28
    132c:	6c 5f       	subi	r22, 0xFC	; 252
    132e:	7f 4f       	sbci	r23, 0xFF	; 255
    1330:	ce 01       	movw	r24, r28
    1332:	01 96       	adiw	r24, 0x01	; 1
    1334:	65 d5       	rcall	.+2762   	; 0x1e00 <xTaskCheckForTimeOut>
    1336:	81 11       	cpse	r24, r1
    1338:	26 c0       	rjmp	.+76     	; 0x1386 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    133a:	0f b6       	in	r0, 0x3f	; 63
    133c:	f8 94       	cli
    133e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1340:	f8 01       	movw	r30, r16
    1342:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1344:	0f 90       	pop	r0
    1346:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1348:	81 11       	cpse	r24, r1
    134a:	19 c0       	rjmp	.+50     	; 0x137e <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    134c:	f8 01       	movw	r30, r16
    134e:	80 81       	ld	r24, Z
    1350:	91 81       	ldd	r25, Z+1	; 0x01
    1352:	89 2b       	or	r24, r25
    1354:	49 f4       	brne	.+18     	; 0x1368 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    135c:	f8 01       	movw	r30, r16
    135e:	82 81       	ldd	r24, Z+2	; 0x02
    1360:	93 81       	ldd	r25, Z+3	; 0x03
    1362:	8a d5       	rcall	.+2836   	; 0x1e78 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1368:	6c 81       	ldd	r22, Y+4	; 0x04
    136a:	7d 81       	ldd	r23, Y+5	; 0x05
    136c:	c7 01       	movw	r24, r14
    136e:	ca d4       	rcall	.+2452   	; 0x1d04 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1370:	c8 01       	movw	r24, r16
    1372:	cd dd       	rcall	.-1126   	; 0xf0e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1374:	08 d3       	rcall	.+1552   	; 0x1986 <xTaskResumeAll>
    1376:	81 11       	cpse	r24, r1
    1378:	84 cf       	rjmp	.-248    	; 0x1282 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    137a:	89 dc       	rcall	.-1774   	; 0xc8e <vPortYield>
    137c:	82 cf       	rjmp	.-252    	; 0x1282 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    137e:	c8 01       	movw	r24, r16
    1380:	c6 dd       	rcall	.-1140   	; 0xf0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1382:	01 d3       	rcall	.+1538   	; 0x1986 <xTaskResumeAll>
    1384:	7e cf       	rjmp	.-260    	; 0x1282 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1386:	c8 01       	movw	r24, r16
    1388:	c2 dd       	rcall	.-1148   	; 0xf0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    138a:	fd d2       	rcall	.+1530   	; 0x1986 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    138c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    138e:	0f 90       	pop	r0
    1390:	0f 90       	pop	r0
    1392:	0f 90       	pop	r0
    1394:	0f 90       	pop	r0
    1396:	0f 90       	pop	r0
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	ff 90       	pop	r15
    13a2:	ef 90       	pop	r14
    13a4:	df 90       	pop	r13
    13a6:	cf 90       	pop	r12
    13a8:	bf 90       	pop	r11
    13aa:	af 90       	pop	r10
    13ac:	9f 90       	pop	r9
    13ae:	08 95       	ret

000013b0 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    13b0:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    13b2:	71 83       	std	Z+1, r23	; 0x01
    13b4:	60 83       	st	Z, r22
	ring->rSize = size;
    13b6:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    13b8:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    13ba:	13 82       	std	Z+3, r1	; 0x03
    13bc:	08 95       	ret

000013be <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    13be:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    13c0:	94 81       	ldd	r25, Z+4	; 0x04
    13c2:	a0 81       	ld	r26, Z
    13c4:	b1 81       	ldd	r27, Z+1	; 0x01
    13c6:	a9 0f       	add	r26, r25
    13c8:	b1 1d       	adc	r27, r1
    13ca:	8c 91       	ld	r24, X
            ring->rIndex ++;
    13cc:	9f 5f       	subi	r25, 0xFF	; 255
    13ce:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    13d0:	22 81       	ldd	r18, Z+2	; 0x02
    13d2:	92 17       	cp	r25, r18
    13d4:	10 f0       	brcs	.+4      	; 0x13da <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    13d6:	92 1b       	sub	r25, r18
    13d8:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    13da:	93 81       	ldd	r25, Z+3	; 0x03
    13dc:	91 50       	subi	r25, 0x01	; 1
    13de:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    13e0:	08 95       	ret

000013e2 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    13e2:	fc 01       	movw	r30, r24
    13e4:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    13e6:	83 81       	ldd	r24, Z+3	; 0x03
    13e8:	22 81       	ldd	r18, Z+2	; 0x02
    13ea:	82 17       	cp	r24, r18
    13ec:	78 f4       	brcc	.+30     	; 0x140c <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    13ee:	34 81       	ldd	r19, Z+4	; 0x04
    13f0:	90 e0       	ldi	r25, 0x00	; 0
    13f2:	83 0f       	add	r24, r19
    13f4:	91 1d       	adc	r25, r1
    13f6:	62 2f       	mov	r22, r18
    13f8:	70 e0       	ldi	r23, 0x00	; 0
    13fa:	ed d5       	rcall	.+3034   	; 0x1fd6 <__divmodhi4>
    13fc:	a0 81       	ld	r26, Z
    13fe:	b1 81       	ldd	r27, Z+1	; 0x01
    1400:	a8 0f       	add	r26, r24
    1402:	b9 1f       	adc	r27, r25
    1404:	4c 93       	st	X, r20
            ring->rLength++;
    1406:	83 81       	ldd	r24, Z+3	; 0x03
    1408:	8f 5f       	subi	r24, 0xFF	; 255
    140a:	83 83       	std	Z+3, r24	; 0x03
    140c:	08 95       	ret

0000140e <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    140e:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	22 81       	ldd	r18, Z+2	; 0x02
    1414:	93 81       	ldd	r25, Z+3	; 0x03
    1416:	29 13       	cpse	r18, r25
    1418:	80 e0       	ldi	r24, 0x00	; 0
}
    141a:	08 95       	ret

0000141c <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    141c:	21 e0       	ldi	r18, 0x01	; 1
    141e:	fc 01       	movw	r30, r24
    1420:	83 81       	ldd	r24, Z+3	; 0x03
    1422:	81 11       	cpse	r24, r1
    1424:	01 c0       	rjmp	.+2      	; 0x1428 <ringBufferNotEmpty+0xc>
    1426:	20 e0       	ldi	r18, 0x00	; 0
}
    1428:	82 2f       	mov	r24, r18
    142a:	08 95       	ret

0000142c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    142c:	e0 91 96 08 	lds	r30, 0x0896
    1430:	f0 91 97 08 	lds	r31, 0x0897
    1434:	80 81       	ld	r24, Z
    1436:	81 11       	cpse	r24, r1
    1438:	07 c0       	rjmp	.+14     	; 0x1448 <prvResetNextTaskUnblockTime+0x1c>
    143a:	8f ef       	ldi	r24, 0xFF	; 255
    143c:	9f ef       	ldi	r25, 0xFF	; 255
    143e:	90 93 05 02 	sts	0x0205, r25
    1442:	80 93 04 02 	sts	0x0204, r24
    1446:	08 95       	ret
    1448:	e0 91 96 08 	lds	r30, 0x0896
    144c:	f0 91 97 08 	lds	r31, 0x0897
    1450:	05 80       	ldd	r0, Z+5	; 0x05
    1452:	f6 81       	ldd	r31, Z+6	; 0x06
    1454:	e0 2d       	mov	r30, r0
    1456:	06 80       	ldd	r0, Z+6	; 0x06
    1458:	f7 81       	ldd	r31, Z+7	; 0x07
    145a:	e0 2d       	mov	r30, r0
    145c:	82 81       	ldd	r24, Z+2	; 0x02
    145e:	93 81       	ldd	r25, Z+3	; 0x03
    1460:	90 93 05 02 	sts	0x0205, r25
    1464:	80 93 04 02 	sts	0x0204, r24
    1468:	08 95       	ret

0000146a <prvAddCurrentTaskToDelayedList>:
    146a:	cf 93       	push	r28
    146c:	df 93       	push	r29
    146e:	ec 01       	movw	r28, r24
    1470:	e0 91 d7 08 	lds	r30, 0x08D7
    1474:	f0 91 d8 08 	lds	r31, 0x08D8
    1478:	93 83       	std	Z+3, r25	; 0x03
    147a:	82 83       	std	Z+2, r24	; 0x02
    147c:	80 91 75 08 	lds	r24, 0x0875
    1480:	90 91 76 08 	lds	r25, 0x0876
    1484:	c8 17       	cp	r28, r24
    1486:	d9 07       	cpc	r29, r25
    1488:	68 f4       	brcc	.+26     	; 0x14a4 <prvAddCurrentTaskToDelayedList+0x3a>
    148a:	60 91 d7 08 	lds	r22, 0x08D7
    148e:	70 91 d8 08 	lds	r23, 0x08D8
    1492:	80 91 94 08 	lds	r24, 0x0894
    1496:	90 91 95 08 	lds	r25, 0x0895
    149a:	6e 5f       	subi	r22, 0xFE	; 254
    149c:	7f 4f       	sbci	r23, 0xFF	; 255
    149e:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    14a2:	17 c0       	rjmp	.+46     	; 0x14d2 <prvAddCurrentTaskToDelayedList+0x68>
    14a4:	60 91 d7 08 	lds	r22, 0x08D7
    14a8:	70 91 d8 08 	lds	r23, 0x08D8
    14ac:	80 91 96 08 	lds	r24, 0x0896
    14b0:	90 91 97 08 	lds	r25, 0x0897
    14b4:	6e 5f       	subi	r22, 0xFE	; 254
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    14bc:	80 91 04 02 	lds	r24, 0x0204
    14c0:	90 91 05 02 	lds	r25, 0x0205
    14c4:	c8 17       	cp	r28, r24
    14c6:	d9 07       	cpc	r29, r25
    14c8:	20 f4       	brcc	.+8      	; 0x14d2 <prvAddCurrentTaskToDelayedList+0x68>
    14ca:	d0 93 05 02 	sts	0x0205, r29
    14ce:	c0 93 04 02 	sts	0x0204, r28
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	08 95       	ret

000014d8 <xTaskGenericCreate>:
    14d8:	4f 92       	push	r4
    14da:	5f 92       	push	r5
    14dc:	6f 92       	push	r6
    14de:	7f 92       	push	r7
    14e0:	8f 92       	push	r8
    14e2:	9f 92       	push	r9
    14e4:	af 92       	push	r10
    14e6:	bf 92       	push	r11
    14e8:	cf 92       	push	r12
    14ea:	df 92       	push	r13
    14ec:	ef 92       	push	r14
    14ee:	ff 92       	push	r15
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	4c 01       	movw	r8, r24
    14fa:	5b 01       	movw	r10, r22
    14fc:	2a 01       	movw	r4, r20
    14fe:	39 01       	movw	r6, r18
    1500:	83 e2       	ldi	r24, 0x23	; 35
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	0e 94 c9 01 	call	0x392	; 0x392 <pvPortMalloc>
    1508:	ec 01       	movw	r28, r24
    150a:	00 97       	sbiw	r24, 0x00	; 0
    150c:	09 f4       	brne	.+2      	; 0x1510 <xTaskGenericCreate+0x38>
    150e:	e7 c0       	rjmp	.+462    	; 0x16de <xTaskGenericCreate+0x206>
    1510:	c1 14       	cp	r12, r1
    1512:	d1 04       	cpc	r13, r1
    1514:	09 f0       	breq	.+2      	; 0x1518 <xTaskGenericCreate+0x40>
    1516:	cc c0       	rjmp	.+408    	; 0x16b0 <xTaskGenericCreate+0x1d8>
    1518:	c2 01       	movw	r24, r4
    151a:	0e 94 c9 01 	call	0x392	; 0x392 <pvPortMalloc>
    151e:	98 8f       	std	Y+24, r25	; 0x18
    1520:	8f 8b       	std	Y+23, r24	; 0x17
    1522:	89 2b       	or	r24, r25
    1524:	09 f0       	breq	.+2      	; 0x1528 <xTaskGenericCreate+0x50>
    1526:	c6 c0       	rjmp	.+396    	; 0x16b4 <xTaskGenericCreate+0x1dc>
    1528:	ce 01       	movw	r24, r28
    152a:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    152e:	d7 c0       	rjmp	.+430    	; 0x16de <xTaskGenericCreate+0x206>
    1530:	cf 01       	movw	r24, r30
    1532:	31 91       	ld	r19, Z+
    1534:	da 01       	movw	r26, r20
    1536:	3d 93       	st	X+, r19
    1538:	ad 01       	movw	r20, r26
    153a:	dc 01       	movw	r26, r24
    153c:	8c 91       	ld	r24, X
    153e:	88 23       	and	r24, r24
    1540:	11 f0       	breq	.+4      	; 0x1546 <xTaskGenericCreate+0x6e>
    1542:	21 50       	subi	r18, 0x01	; 1
    1544:	a9 f7       	brne	.-22     	; 0x1530 <xTaskGenericCreate+0x58>
    1546:	18 a2       	std	Y+32, r1	; 0x20
    1548:	10 2f       	mov	r17, r16
    154a:	05 30       	cpi	r16, 0x05	; 5
    154c:	08 f0       	brcs	.+2      	; 0x1550 <xTaskGenericCreate+0x78>
    154e:	14 e0       	ldi	r17, 0x04	; 4
    1550:	1e 8b       	std	Y+22, r17	; 0x16
    1552:	19 a3       	std	Y+33, r17	; 0x21
    1554:	1a a2       	std	Y+34, r1	; 0x22
    1556:	5e 01       	movw	r10, r28
    1558:	b2 e0       	ldi	r27, 0x02	; 2
    155a:	ab 0e       	add	r10, r27
    155c:	b1 1c       	adc	r11, r1
    155e:	c5 01       	movw	r24, r10
    1560:	0e 94 0d 02 	call	0x41a	; 0x41a <vListInitialiseItem>
    1564:	ce 01       	movw	r24, r28
    1566:	0c 96       	adiw	r24, 0x0c	; 12
    1568:	0e 94 0d 02 	call	0x41a	; 0x41a <vListInitialiseItem>
    156c:	d9 87       	std	Y+9, r29	; 0x09
    156e:	c8 87       	std	Y+8, r28	; 0x08
    1570:	85 e0       	ldi	r24, 0x05	; 5
    1572:	90 e0       	ldi	r25, 0x00	; 0
    1574:	81 1b       	sub	r24, r17
    1576:	91 09       	sbc	r25, r1
    1578:	9d 87       	std	Y+13, r25	; 0x0d
    157a:	8c 87       	std	Y+12, r24	; 0x0c
    157c:	db 8b       	std	Y+19, r29	; 0x13
    157e:	ca 8b       	std	Y+18, r28	; 0x12
    1580:	a3 01       	movw	r20, r6
    1582:	b4 01       	movw	r22, r8
    1584:	c6 01       	movw	r24, r12
    1586:	d4 da       	rcall	.-2648   	; 0xb30 <pxPortInitialiseStack>
    1588:	99 83       	std	Y+1, r25	; 0x01
    158a:	88 83       	st	Y, r24
    158c:	e1 14       	cp	r14, r1
    158e:	f1 04       	cpc	r15, r1
    1590:	19 f0       	breq	.+6      	; 0x1598 <xTaskGenericCreate+0xc0>
    1592:	f7 01       	movw	r30, r14
    1594:	d1 83       	std	Z+1, r29	; 0x01
    1596:	c0 83       	st	Z, r28
    1598:	0f b6       	in	r0, 0x3f	; 63
    159a:	f8 94       	cli
    159c:	0f 92       	push	r0
    159e:	80 91 77 08 	lds	r24, 0x0877
    15a2:	8f 5f       	subi	r24, 0xFF	; 255
    15a4:	80 93 77 08 	sts	0x0877, r24
    15a8:	80 91 d7 08 	lds	r24, 0x08D7
    15ac:	90 91 d8 08 	lds	r25, 0x08D8
    15b0:	89 2b       	or	r24, r25
    15b2:	09 f0       	breq	.+2      	; 0x15b6 <xTaskGenericCreate+0xde>
    15b4:	3f c0       	rjmp	.+126    	; 0x1634 <xTaskGenericCreate+0x15c>
    15b6:	d0 93 d8 08 	sts	0x08D8, r29
    15ba:	c0 93 d7 08 	sts	0x08D7, r28
    15be:	80 91 77 08 	lds	r24, 0x0877
    15c2:	81 30       	cpi	r24, 0x01	; 1
    15c4:	09 f0       	breq	.+2      	; 0x15c8 <xTaskGenericCreate+0xf0>
    15c6:	45 c0       	rjmp	.+138    	; 0x1652 <xTaskGenericCreate+0x17a>
    15c8:	0f 2e       	mov	r0, r31
    15ca:	fa ea       	ldi	r31, 0xAA	; 170
    15cc:	ef 2e       	mov	r14, r31
    15ce:	f8 e0       	ldi	r31, 0x08	; 8
    15d0:	ff 2e       	mov	r15, r31
    15d2:	f0 2d       	mov	r31, r0
    15d4:	0f 2e       	mov	r0, r31
    15d6:	f7 ed       	ldi	r31, 0xD7	; 215
    15d8:	cf 2e       	mov	r12, r31
    15da:	f8 e0       	ldi	r31, 0x08	; 8
    15dc:	df 2e       	mov	r13, r31
    15de:	f0 2d       	mov	r31, r0
    15e0:	c7 01       	movw	r24, r14
    15e2:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    15e6:	f9 e0       	ldi	r31, 0x09	; 9
    15e8:	ef 0e       	add	r14, r31
    15ea:	f1 1c       	adc	r15, r1
    15ec:	ec 14       	cp	r14, r12
    15ee:	fd 04       	cpc	r15, r13
    15f0:	b9 f7       	brne	.-18     	; 0x15e0 <xTaskGenericCreate+0x108>
    15f2:	81 ea       	ldi	r24, 0xA1	; 161
    15f4:	98 e0       	ldi	r25, 0x08	; 8
    15f6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    15fa:	88 e9       	ldi	r24, 0x98	; 152
    15fc:	98 e0       	ldi	r25, 0x08	; 8
    15fe:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    1602:	8b e8       	ldi	r24, 0x8B	; 139
    1604:	98 e0       	ldi	r25, 0x08	; 8
    1606:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    160a:	82 e8       	ldi	r24, 0x82	; 130
    160c:	98 e0       	ldi	r25, 0x08	; 8
    160e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    1612:	88 e7       	ldi	r24, 0x78	; 120
    1614:	98 e0       	ldi	r25, 0x08	; 8
    1616:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    161a:	81 ea       	ldi	r24, 0xA1	; 161
    161c:	98 e0       	ldi	r25, 0x08	; 8
    161e:	90 93 97 08 	sts	0x0897, r25
    1622:	80 93 96 08 	sts	0x0896, r24
    1626:	88 e9       	ldi	r24, 0x98	; 152
    1628:	98 e0       	ldi	r25, 0x08	; 8
    162a:	90 93 95 08 	sts	0x0895, r25
    162e:	80 93 94 08 	sts	0x0894, r24
    1632:	0f c0       	rjmp	.+30     	; 0x1652 <xTaskGenericCreate+0x17a>
    1634:	80 91 73 08 	lds	r24, 0x0873
    1638:	81 11       	cpse	r24, r1
    163a:	0b c0       	rjmp	.+22     	; 0x1652 <xTaskGenericCreate+0x17a>
    163c:	e0 91 d7 08 	lds	r30, 0x08D7
    1640:	f0 91 d8 08 	lds	r31, 0x08D8
    1644:	86 89       	ldd	r24, Z+22	; 0x16
    1646:	08 17       	cp	r16, r24
    1648:	20 f0       	brcs	.+8      	; 0x1652 <xTaskGenericCreate+0x17a>
    164a:	d0 93 d8 08 	sts	0x08D8, r29
    164e:	c0 93 d7 08 	sts	0x08D7, r28
    1652:	80 91 6f 08 	lds	r24, 0x086F
    1656:	8f 5f       	subi	r24, 0xFF	; 255
    1658:	80 93 6f 08 	sts	0x086F, r24
    165c:	8e 89       	ldd	r24, Y+22	; 0x16
    165e:	90 91 74 08 	lds	r25, 0x0874
    1662:	98 17       	cp	r25, r24
    1664:	10 f4       	brcc	.+4      	; 0x166a <xTaskGenericCreate+0x192>
    1666:	80 93 74 08 	sts	0x0874, r24
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	9c 01       	movw	r18, r24
    166e:	22 0f       	add	r18, r18
    1670:	33 1f       	adc	r19, r19
    1672:	22 0f       	add	r18, r18
    1674:	33 1f       	adc	r19, r19
    1676:	22 0f       	add	r18, r18
    1678:	33 1f       	adc	r19, r19
    167a:	82 0f       	add	r24, r18
    167c:	93 1f       	adc	r25, r19
    167e:	b5 01       	movw	r22, r10
    1680:	86 55       	subi	r24, 0x56	; 86
    1682:	97 4f       	sbci	r25, 0xF7	; 247
    1684:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1688:	0f 90       	pop	r0
    168a:	0f be       	out	0x3f, r0	; 63
    168c:	80 91 73 08 	lds	r24, 0x0873
    1690:	88 23       	and	r24, r24
    1692:	51 f0       	breq	.+20     	; 0x16a8 <xTaskGenericCreate+0x1d0>
    1694:	e0 91 d7 08 	lds	r30, 0x08D7
    1698:	f0 91 d8 08 	lds	r31, 0x08D8
    169c:	86 89       	ldd	r24, Z+22	; 0x16
    169e:	80 17       	cp	r24, r16
    16a0:	28 f4       	brcc	.+10     	; 0x16ac <xTaskGenericCreate+0x1d4>
    16a2:	f5 da       	rcall	.-2582   	; 0xc8e <vPortYield>
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	1c c0       	rjmp	.+56     	; 0x16e0 <xTaskGenericCreate+0x208>
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	1a c0       	rjmp	.+52     	; 0x16e0 <xTaskGenericCreate+0x208>
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	18 c0       	rjmp	.+48     	; 0x16e0 <xTaskGenericCreate+0x208>
    16b0:	d8 8e       	std	Y+24, r13	; 0x18
    16b2:	cf 8a       	std	Y+23, r12	; 0x17
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	48 1a       	sub	r4, r24
    16b8:	51 08       	sbc	r5, r1
    16ba:	cf 88       	ldd	r12, Y+23	; 0x17
    16bc:	d8 8c       	ldd	r13, Y+24	; 0x18
    16be:	c4 0c       	add	r12, r4
    16c0:	d5 1c       	adc	r13, r5
    16c2:	d5 01       	movw	r26, r10
    16c4:	8c 91       	ld	r24, X
    16c6:	89 8f       	std	Y+25, r24	; 0x19
    16c8:	8c 91       	ld	r24, X
    16ca:	88 23       	and	r24, r24
    16cc:	09 f4       	brne	.+2      	; 0x16d0 <xTaskGenericCreate+0x1f8>
    16ce:	3b cf       	rjmp	.-394    	; 0x1546 <xTaskGenericCreate+0x6e>
    16d0:	ae 01       	movw	r20, r28
    16d2:	46 5e       	subi	r20, 0xE6	; 230
    16d4:	5f 4f       	sbci	r21, 0xFF	; 255
    16d6:	f5 01       	movw	r30, r10
    16d8:	31 96       	adiw	r30, 0x01	; 1
    16da:	27 e0       	ldi	r18, 0x07	; 7
    16dc:	29 cf       	rjmp	.-430    	; 0x1530 <xTaskGenericCreate+0x58>
    16de:	8f ef       	ldi	r24, 0xFF	; 255
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	1f 91       	pop	r17
    16e6:	0f 91       	pop	r16
    16e8:	ff 90       	pop	r15
    16ea:	ef 90       	pop	r14
    16ec:	df 90       	pop	r13
    16ee:	cf 90       	pop	r12
    16f0:	bf 90       	pop	r11
    16f2:	af 90       	pop	r10
    16f4:	9f 90       	pop	r9
    16f6:	8f 90       	pop	r8
    16f8:	7f 90       	pop	r7
    16fa:	6f 90       	pop	r6
    16fc:	5f 90       	pop	r5
    16fe:	4f 90       	pop	r4
    1700:	08 95       	ret

00001702 <vTaskResume>:
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	ec 01       	movw	r28, r24
    170c:	00 97       	sbiw	r24, 0x00	; 0
    170e:	09 f4       	brne	.+2      	; 0x1712 <vTaskResume+0x10>
    1710:	3e c0       	rjmp	.+124    	; 0x178e <vTaskResume+0x8c>
    1712:	80 91 d7 08 	lds	r24, 0x08D7
    1716:	90 91 d8 08 	lds	r25, 0x08D8
    171a:	c8 17       	cp	r28, r24
    171c:	d9 07       	cpc	r29, r25
    171e:	b9 f1       	breq	.+110    	; 0x178e <vTaskResume+0x8c>
    1720:	0f b6       	in	r0, 0x3f	; 63
    1722:	f8 94       	cli
    1724:	0f 92       	push	r0
    1726:	8a 85       	ldd	r24, Y+10	; 0x0a
    1728:	9b 85       	ldd	r25, Y+11	; 0x0b
    172a:	88 57       	subi	r24, 0x78	; 120
    172c:	98 40       	sbci	r25, 0x08	; 8
    172e:	69 f5       	brne	.+90     	; 0x178a <vTaskResume+0x88>
    1730:	8c 89       	ldd	r24, Y+20	; 0x14
    1732:	9d 89       	ldd	r25, Y+21	; 0x15
    1734:	28 e0       	ldi	r18, 0x08	; 8
    1736:	8b 38       	cpi	r24, 0x8B	; 139
    1738:	92 07       	cpc	r25, r18
    173a:	39 f1       	breq	.+78     	; 0x178a <vTaskResume+0x88>
    173c:	89 2b       	or	r24, r25
    173e:	29 f5       	brne	.+74     	; 0x178a <vTaskResume+0x88>
    1740:	8e 01       	movw	r16, r28
    1742:	0e 5f       	subi	r16, 0xFE	; 254
    1744:	1f 4f       	sbci	r17, 0xFF	; 255
    1746:	c8 01       	movw	r24, r16
    1748:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    174c:	8e 89       	ldd	r24, Y+22	; 0x16
    174e:	90 91 74 08 	lds	r25, 0x0874
    1752:	98 17       	cp	r25, r24
    1754:	10 f4       	brcc	.+4      	; 0x175a <vTaskResume+0x58>
    1756:	80 93 74 08 	sts	0x0874, r24
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	9c 01       	movw	r18, r24
    175e:	22 0f       	add	r18, r18
    1760:	33 1f       	adc	r19, r19
    1762:	22 0f       	add	r18, r18
    1764:	33 1f       	adc	r19, r19
    1766:	22 0f       	add	r18, r18
    1768:	33 1f       	adc	r19, r19
    176a:	82 0f       	add	r24, r18
    176c:	93 1f       	adc	r25, r19
    176e:	b8 01       	movw	r22, r16
    1770:	86 55       	subi	r24, 0x56	; 86
    1772:	97 4f       	sbci	r25, 0xF7	; 247
    1774:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1778:	e0 91 d7 08 	lds	r30, 0x08D7
    177c:	f0 91 d8 08 	lds	r31, 0x08D8
    1780:	9e 89       	ldd	r25, Y+22	; 0x16
    1782:	86 89       	ldd	r24, Z+22	; 0x16
    1784:	98 17       	cp	r25, r24
    1786:	08 f0       	brcs	.+2      	; 0x178a <vTaskResume+0x88>
    1788:	82 da       	rcall	.-2812   	; 0xc8e <vPortYield>
    178a:	0f 90       	pop	r0
    178c:	0f be       	out	0x3f, r0	; 63
    178e:	df 91       	pop	r29
    1790:	cf 91       	pop	r28
    1792:	1f 91       	pop	r17
    1794:	0f 91       	pop	r16
    1796:	08 95       	ret

00001798 <vTaskStartScheduler>:
    1798:	af 92       	push	r10
    179a:	bf 92       	push	r11
    179c:	cf 92       	push	r12
    179e:	df 92       	push	r13
    17a0:	ef 92       	push	r14
    17a2:	ff 92       	push	r15
    17a4:	0f 93       	push	r16
    17a6:	a1 2c       	mov	r10, r1
    17a8:	b1 2c       	mov	r11, r1
    17aa:	c1 2c       	mov	r12, r1
    17ac:	d1 2c       	mov	r13, r1
    17ae:	e1 2c       	mov	r14, r1
    17b0:	f1 2c       	mov	r15, r1
    17b2:	00 e0       	ldi	r16, 0x00	; 0
    17b4:	20 e0       	ldi	r18, 0x00	; 0
    17b6:	30 e0       	ldi	r19, 0x00	; 0
    17b8:	45 e5       	ldi	r20, 0x55	; 85
    17ba:	50 e0       	ldi	r21, 0x00	; 0
    17bc:	69 e8       	ldi	r22, 0x89	; 137
    17be:	72 e0       	ldi	r23, 0x02	; 2
    17c0:	8e e9       	ldi	r24, 0x9E	; 158
    17c2:	9d e0       	ldi	r25, 0x0D	; 13
    17c4:	89 de       	rcall	.-750    	; 0x14d8 <xTaskGenericCreate>
    17c6:	81 30       	cpi	r24, 0x01	; 1
    17c8:	41 f4       	brne	.+16     	; 0x17da <vTaskStartScheduler+0x42>
    17ca:	f8 94       	cli
    17cc:	80 93 73 08 	sts	0x0873, r24
    17d0:	10 92 76 08 	sts	0x0876, r1
    17d4:	10 92 75 08 	sts	0x0875, r1
    17d8:	1d da       	rcall	.-3014   	; 0xc14 <xPortStartScheduler>
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	bf 90       	pop	r11
    17e6:	af 90       	pop	r10
    17e8:	08 95       	ret

000017ea <vTaskSuspendAll>:
    17ea:	80 91 6e 08 	lds	r24, 0x086E
    17ee:	8f 5f       	subi	r24, 0xFF	; 255
    17f0:	80 93 6e 08 	sts	0x086E, r24
    17f4:	08 95       	ret

000017f6 <xTaskGetTickCount>:
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
    17fc:	80 91 75 08 	lds	r24, 0x0875
    1800:	90 91 76 08 	lds	r25, 0x0876
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	08 95       	ret

0000180a <xTaskIncrementTick>:
    180a:	cf 92       	push	r12
    180c:	df 92       	push	r13
    180e:	ef 92       	push	r14
    1810:	ff 92       	push	r15
    1812:	0f 93       	push	r16
    1814:	1f 93       	push	r17
    1816:	cf 93       	push	r28
    1818:	df 93       	push	r29
    181a:	80 91 6e 08 	lds	r24, 0x086E
    181e:	81 11       	cpse	r24, r1
    1820:	99 c0       	rjmp	.+306    	; 0x1954 <xTaskIncrementTick+0x14a>
    1822:	80 91 75 08 	lds	r24, 0x0875
    1826:	90 91 76 08 	lds	r25, 0x0876
    182a:	01 96       	adiw	r24, 0x01	; 1
    182c:	90 93 76 08 	sts	0x0876, r25
    1830:	80 93 75 08 	sts	0x0875, r24
    1834:	e0 90 75 08 	lds	r14, 0x0875
    1838:	f0 90 76 08 	lds	r15, 0x0876
    183c:	e1 14       	cp	r14, r1
    183e:	f1 04       	cpc	r15, r1
    1840:	b1 f4       	brne	.+44     	; 0x186e <xTaskIncrementTick+0x64>
    1842:	80 91 96 08 	lds	r24, 0x0896
    1846:	90 91 97 08 	lds	r25, 0x0897
    184a:	20 91 94 08 	lds	r18, 0x0894
    184e:	30 91 95 08 	lds	r19, 0x0895
    1852:	30 93 97 08 	sts	0x0897, r19
    1856:	20 93 96 08 	sts	0x0896, r18
    185a:	90 93 95 08 	sts	0x0895, r25
    185e:	80 93 94 08 	sts	0x0894, r24
    1862:	80 91 70 08 	lds	r24, 0x0870
    1866:	8f 5f       	subi	r24, 0xFF	; 255
    1868:	80 93 70 08 	sts	0x0870, r24
    186c:	df dd       	rcall	.-1090   	; 0x142c <prvResetNextTaskUnblockTime>
    186e:	80 91 04 02 	lds	r24, 0x0204
    1872:	90 91 05 02 	lds	r25, 0x0205
    1876:	e8 16       	cp	r14, r24
    1878:	f9 06       	cpc	r15, r25
    187a:	08 f4       	brcc	.+2      	; 0x187e <xTaskIncrementTick+0x74>
    187c:	54 c0       	rjmp	.+168    	; 0x1926 <xTaskIncrementTick+0x11c>
    187e:	d1 2c       	mov	r13, r1
    1880:	cc 24       	eor	r12, r12
    1882:	c3 94       	inc	r12
    1884:	01 c0       	rjmp	.+2      	; 0x1888 <xTaskIncrementTick+0x7e>
    1886:	dc 2c       	mov	r13, r12
    1888:	e0 91 96 08 	lds	r30, 0x0896
    188c:	f0 91 97 08 	lds	r31, 0x0897
    1890:	80 81       	ld	r24, Z
    1892:	81 11       	cpse	r24, r1
    1894:	07 c0       	rjmp	.+14     	; 0x18a4 <xTaskIncrementTick+0x9a>
    1896:	8f ef       	ldi	r24, 0xFF	; 255
    1898:	9f ef       	ldi	r25, 0xFF	; 255
    189a:	90 93 05 02 	sts	0x0205, r25
    189e:	80 93 04 02 	sts	0x0204, r24
    18a2:	42 c0       	rjmp	.+132    	; 0x1928 <xTaskIncrementTick+0x11e>
    18a4:	e0 91 96 08 	lds	r30, 0x0896
    18a8:	f0 91 97 08 	lds	r31, 0x0897
    18ac:	05 80       	ldd	r0, Z+5	; 0x05
    18ae:	f6 81       	ldd	r31, Z+6	; 0x06
    18b0:	e0 2d       	mov	r30, r0
    18b2:	c6 81       	ldd	r28, Z+6	; 0x06
    18b4:	d7 81       	ldd	r29, Z+7	; 0x07
    18b6:	2a 81       	ldd	r18, Y+2	; 0x02
    18b8:	3b 81       	ldd	r19, Y+3	; 0x03
    18ba:	e2 16       	cp	r14, r18
    18bc:	f3 06       	cpc	r15, r19
    18be:	28 f4       	brcc	.+10     	; 0x18ca <xTaskIncrementTick+0xc0>
    18c0:	30 93 05 02 	sts	0x0205, r19
    18c4:	20 93 04 02 	sts	0x0204, r18
    18c8:	2f c0       	rjmp	.+94     	; 0x1928 <xTaskIncrementTick+0x11e>
    18ca:	8e 01       	movw	r16, r28
    18cc:	0e 5f       	subi	r16, 0xFE	; 254
    18ce:	1f 4f       	sbci	r17, 0xFF	; 255
    18d0:	c8 01       	movw	r24, r16
    18d2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    18d6:	8c 89       	ldd	r24, Y+20	; 0x14
    18d8:	9d 89       	ldd	r25, Y+21	; 0x15
    18da:	89 2b       	or	r24, r25
    18dc:	21 f0       	breq	.+8      	; 0x18e6 <xTaskIncrementTick+0xdc>
    18de:	ce 01       	movw	r24, r28
    18e0:	0c 96       	adiw	r24, 0x0c	; 12
    18e2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    18e6:	2e 89       	ldd	r18, Y+22	; 0x16
    18e8:	80 91 74 08 	lds	r24, 0x0874
    18ec:	82 17       	cp	r24, r18
    18ee:	10 f4       	brcc	.+4      	; 0x18f4 <xTaskIncrementTick+0xea>
    18f0:	20 93 74 08 	sts	0x0874, r18
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	c9 01       	movw	r24, r18
    18f8:	88 0f       	add	r24, r24
    18fa:	99 1f       	adc	r25, r25
    18fc:	88 0f       	add	r24, r24
    18fe:	99 1f       	adc	r25, r25
    1900:	88 0f       	add	r24, r24
    1902:	99 1f       	adc	r25, r25
    1904:	82 0f       	add	r24, r18
    1906:	93 1f       	adc	r25, r19
    1908:	b8 01       	movw	r22, r16
    190a:	86 55       	subi	r24, 0x56	; 86
    190c:	97 4f       	sbci	r25, 0xF7	; 247
    190e:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1912:	e0 91 d7 08 	lds	r30, 0x08D7
    1916:	f0 91 d8 08 	lds	r31, 0x08D8
    191a:	9e 89       	ldd	r25, Y+22	; 0x16
    191c:	86 89       	ldd	r24, Z+22	; 0x16
    191e:	98 17       	cp	r25, r24
    1920:	08 f0       	brcs	.+2      	; 0x1924 <xTaskIncrementTick+0x11a>
    1922:	b1 cf       	rjmp	.-158    	; 0x1886 <xTaskIncrementTick+0x7c>
    1924:	b1 cf       	rjmp	.-158    	; 0x1888 <xTaskIncrementTick+0x7e>
    1926:	d1 2c       	mov	r13, r1
    1928:	e0 91 d7 08 	lds	r30, 0x08D7
    192c:	f0 91 d8 08 	lds	r31, 0x08D8
    1930:	86 89       	ldd	r24, Z+22	; 0x16
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	fc 01       	movw	r30, r24
    1936:	ee 0f       	add	r30, r30
    1938:	ff 1f       	adc	r31, r31
    193a:	ee 0f       	add	r30, r30
    193c:	ff 1f       	adc	r31, r31
    193e:	ee 0f       	add	r30, r30
    1940:	ff 1f       	adc	r31, r31
    1942:	8e 0f       	add	r24, r30
    1944:	9f 1f       	adc	r25, r31
    1946:	fc 01       	movw	r30, r24
    1948:	e6 55       	subi	r30, 0x56	; 86
    194a:	f7 4f       	sbci	r31, 0xF7	; 247
    194c:	80 81       	ld	r24, Z
    194e:	82 30       	cpi	r24, 0x02	; 2
    1950:	40 f4       	brcc	.+16     	; 0x1962 <xTaskIncrementTick+0x158>
    1952:	09 c0       	rjmp	.+18     	; 0x1966 <xTaskIncrementTick+0x15c>
    1954:	80 91 72 08 	lds	r24, 0x0872
    1958:	8f 5f       	subi	r24, 0xFF	; 255
    195a:	80 93 72 08 	sts	0x0872, r24
    195e:	d1 2c       	mov	r13, r1
    1960:	02 c0       	rjmp	.+4      	; 0x1966 <xTaskIncrementTick+0x15c>
    1962:	dd 24       	eor	r13, r13
    1964:	d3 94       	inc	r13
    1966:	80 91 71 08 	lds	r24, 0x0871
    196a:	88 23       	and	r24, r24
    196c:	11 f0       	breq	.+4      	; 0x1972 <xTaskIncrementTick+0x168>
    196e:	dd 24       	eor	r13, r13
    1970:	d3 94       	inc	r13
    1972:	8d 2d       	mov	r24, r13
    1974:	df 91       	pop	r29
    1976:	cf 91       	pop	r28
    1978:	1f 91       	pop	r17
    197a:	0f 91       	pop	r16
    197c:	ff 90       	pop	r15
    197e:	ef 90       	pop	r14
    1980:	df 90       	pop	r13
    1982:	cf 90       	pop	r12
    1984:	08 95       	ret

00001986 <xTaskResumeAll>:
    1986:	df 92       	push	r13
    1988:	ef 92       	push	r14
    198a:	ff 92       	push	r15
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	0f 92       	push	r0
    199a:	80 91 6e 08 	lds	r24, 0x086E
    199e:	81 50       	subi	r24, 0x01	; 1
    19a0:	80 93 6e 08 	sts	0x086E, r24
    19a4:	80 91 6e 08 	lds	r24, 0x086E
    19a8:	81 11       	cpse	r24, r1
    19aa:	5f c0       	rjmp	.+190    	; 0x1a6a <xTaskResumeAll+0xe4>
    19ac:	80 91 77 08 	lds	r24, 0x0877
    19b0:	88 23       	and	r24, r24
    19b2:	09 f4       	brne	.+2      	; 0x19b6 <xTaskResumeAll+0x30>
    19b4:	5c c0       	rjmp	.+184    	; 0x1a6e <xTaskResumeAll+0xe8>
    19b6:	0f 2e       	mov	r0, r31
    19b8:	fb e8       	ldi	r31, 0x8B	; 139
    19ba:	ef 2e       	mov	r14, r31
    19bc:	f8 e0       	ldi	r31, 0x08	; 8
    19be:	ff 2e       	mov	r15, r31
    19c0:	f0 2d       	mov	r31, r0
    19c2:	dd 24       	eor	r13, r13
    19c4:	d3 94       	inc	r13
    19c6:	30 c0       	rjmp	.+96     	; 0x1a28 <xTaskResumeAll+0xa2>
    19c8:	e0 91 90 08 	lds	r30, 0x0890
    19cc:	f0 91 91 08 	lds	r31, 0x0891
    19d0:	c6 81       	ldd	r28, Z+6	; 0x06
    19d2:	d7 81       	ldd	r29, Z+7	; 0x07
    19d4:	ce 01       	movw	r24, r28
    19d6:	0c 96       	adiw	r24, 0x0c	; 12
    19d8:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    19dc:	8e 01       	movw	r16, r28
    19de:	0e 5f       	subi	r16, 0xFE	; 254
    19e0:	1f 4f       	sbci	r17, 0xFF	; 255
    19e2:	c8 01       	movw	r24, r16
    19e4:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    19e8:	8e 89       	ldd	r24, Y+22	; 0x16
    19ea:	90 91 74 08 	lds	r25, 0x0874
    19ee:	98 17       	cp	r25, r24
    19f0:	10 f4       	brcc	.+4      	; 0x19f6 <xTaskResumeAll+0x70>
    19f2:	80 93 74 08 	sts	0x0874, r24
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	9c 01       	movw	r18, r24
    19fa:	22 0f       	add	r18, r18
    19fc:	33 1f       	adc	r19, r19
    19fe:	22 0f       	add	r18, r18
    1a00:	33 1f       	adc	r19, r19
    1a02:	22 0f       	add	r18, r18
    1a04:	33 1f       	adc	r19, r19
    1a06:	82 0f       	add	r24, r18
    1a08:	93 1f       	adc	r25, r19
    1a0a:	b8 01       	movw	r22, r16
    1a0c:	86 55       	subi	r24, 0x56	; 86
    1a0e:	97 4f       	sbci	r25, 0xF7	; 247
    1a10:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1a14:	e0 91 d7 08 	lds	r30, 0x08D7
    1a18:	f0 91 d8 08 	lds	r31, 0x08D8
    1a1c:	9e 89       	ldd	r25, Y+22	; 0x16
    1a1e:	86 89       	ldd	r24, Z+22	; 0x16
    1a20:	98 17       	cp	r25, r24
    1a22:	10 f0       	brcs	.+4      	; 0x1a28 <xTaskResumeAll+0xa2>
    1a24:	d0 92 71 08 	sts	0x0871, r13
    1a28:	f7 01       	movw	r30, r14
    1a2a:	80 81       	ld	r24, Z
    1a2c:	81 11       	cpse	r24, r1
    1a2e:	cc cf       	rjmp	.-104    	; 0x19c8 <xTaskResumeAll+0x42>
    1a30:	80 91 72 08 	lds	r24, 0x0872
    1a34:	88 23       	and	r24, r24
    1a36:	91 f0       	breq	.+36     	; 0x1a5c <xTaskResumeAll+0xd6>
    1a38:	80 91 72 08 	lds	r24, 0x0872
    1a3c:	88 23       	and	r24, r24
    1a3e:	71 f0       	breq	.+28     	; 0x1a5c <xTaskResumeAll+0xd6>
    1a40:	c1 e0       	ldi	r28, 0x01	; 1
    1a42:	e3 de       	rcall	.-570    	; 0x180a <xTaskIncrementTick>
    1a44:	81 11       	cpse	r24, r1
    1a46:	c0 93 71 08 	sts	0x0871, r28
    1a4a:	80 91 72 08 	lds	r24, 0x0872
    1a4e:	81 50       	subi	r24, 0x01	; 1
    1a50:	80 93 72 08 	sts	0x0872, r24
    1a54:	80 91 72 08 	lds	r24, 0x0872
    1a58:	81 11       	cpse	r24, r1
    1a5a:	f3 cf       	rjmp	.-26     	; 0x1a42 <xTaskResumeAll+0xbc>
    1a5c:	80 91 71 08 	lds	r24, 0x0871
    1a60:	81 30       	cpi	r24, 0x01	; 1
    1a62:	39 f4       	brne	.+14     	; 0x1a72 <xTaskResumeAll+0xec>
    1a64:	14 d9       	rcall	.-3544   	; 0xc8e <vPortYield>
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	05 c0       	rjmp	.+10     	; 0x1a74 <xTaskResumeAll+0xee>
    1a6a:	80 e0       	ldi	r24, 0x00	; 0
    1a6c:	03 c0       	rjmp	.+6      	; 0x1a74 <xTaskResumeAll+0xee>
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	01 c0       	rjmp	.+2      	; 0x1a74 <xTaskResumeAll+0xee>
    1a72:	80 e0       	ldi	r24, 0x00	; 0
    1a74:	0f 90       	pop	r0
    1a76:	0f be       	out	0x3f, r0	; 63
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	ff 90       	pop	r15
    1a82:	ef 90       	pop	r14
    1a84:	df 90       	pop	r13
    1a86:	08 95       	ret

00001a88 <vTaskDelayUntil>:
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	cf 93       	push	r28
    1a8e:	df 93       	push	r29
    1a90:	8c 01       	movw	r16, r24
    1a92:	eb 01       	movw	r28, r22
    1a94:	aa de       	rcall	.-684    	; 0x17ea <vTaskSuspendAll>
    1a96:	80 91 75 08 	lds	r24, 0x0875
    1a9a:	90 91 76 08 	lds	r25, 0x0876
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	20 81       	ld	r18, Z
    1aa2:	31 81       	ldd	r19, Z+1	; 0x01
    1aa4:	c2 0f       	add	r28, r18
    1aa6:	d3 1f       	adc	r29, r19
    1aa8:	82 17       	cp	r24, r18
    1aaa:	93 07       	cpc	r25, r19
    1aac:	48 f4       	brcc	.+18     	; 0x1ac0 <vTaskDelayUntil+0x38>
    1aae:	c2 17       	cp	r28, r18
    1ab0:	d3 07       	cpc	r29, r19
    1ab2:	f8 f4       	brcc	.+62     	; 0x1af2 <vTaskDelayUntil+0x6a>
    1ab4:	d1 83       	std	Z+1, r29	; 0x01
    1ab6:	c0 83       	st	Z, r28
    1ab8:	8c 17       	cp	r24, r28
    1aba:	9d 07       	cpc	r25, r29
    1abc:	88 f4       	brcc	.+34     	; 0x1ae0 <vTaskDelayUntil+0x58>
    1abe:	07 c0       	rjmp	.+14     	; 0x1ace <vTaskDelayUntil+0x46>
    1ac0:	c2 17       	cp	r28, r18
    1ac2:	d3 07       	cpc	r29, r19
    1ac4:	90 f0       	brcs	.+36     	; 0x1aea <vTaskDelayUntil+0x62>
    1ac6:	8c 17       	cp	r24, r28
    1ac8:	9d 07       	cpc	r25, r29
    1aca:	78 f0       	brcs	.+30     	; 0x1aea <vTaskDelayUntil+0x62>
    1acc:	12 c0       	rjmp	.+36     	; 0x1af2 <vTaskDelayUntil+0x6a>
    1ace:	80 91 d7 08 	lds	r24, 0x08D7
    1ad2:	90 91 d8 08 	lds	r25, 0x08D8
    1ad6:	02 96       	adiw	r24, 0x02	; 2
    1ad8:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1adc:	ce 01       	movw	r24, r28
    1ade:	c5 dc       	rcall	.-1654   	; 0x146a <prvAddCurrentTaskToDelayedList>
    1ae0:	52 df       	rcall	.-348    	; 0x1986 <xTaskResumeAll>
    1ae2:	81 11       	cpse	r24, r1
    1ae4:	0a c0       	rjmp	.+20     	; 0x1afa <vTaskDelayUntil+0x72>
    1ae6:	d3 d8       	rcall	.-3674   	; 0xc8e <vPortYield>
    1ae8:	08 c0       	rjmp	.+16     	; 0x1afa <vTaskDelayUntil+0x72>
    1aea:	f8 01       	movw	r30, r16
    1aec:	d1 83       	std	Z+1, r29	; 0x01
    1aee:	c0 83       	st	Z, r28
    1af0:	ee cf       	rjmp	.-36     	; 0x1ace <vTaskDelayUntil+0x46>
    1af2:	f8 01       	movw	r30, r16
    1af4:	d1 83       	std	Z+1, r29	; 0x01
    1af6:	c0 83       	st	Z, r28
    1af8:	f3 cf       	rjmp	.-26     	; 0x1ae0 <vTaskDelayUntil+0x58>
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	08 95       	ret

00001b04 <vTaskDelay>:
    1b04:	cf 93       	push	r28
    1b06:	df 93       	push	r29
    1b08:	ec 01       	movw	r28, r24
    1b0a:	00 97       	sbiw	r24, 0x00	; 0
    1b0c:	99 f0       	breq	.+38     	; 0x1b34 <vTaskDelay+0x30>
    1b0e:	6d de       	rcall	.-806    	; 0x17ea <vTaskSuspendAll>
    1b10:	80 91 75 08 	lds	r24, 0x0875
    1b14:	90 91 76 08 	lds	r25, 0x0876
    1b18:	c8 0f       	add	r28, r24
    1b1a:	d9 1f       	adc	r29, r25
    1b1c:	80 91 d7 08 	lds	r24, 0x08D7
    1b20:	90 91 d8 08 	lds	r25, 0x08D8
    1b24:	02 96       	adiw	r24, 0x02	; 2
    1b26:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1b2a:	ce 01       	movw	r24, r28
    1b2c:	9e dc       	rcall	.-1732   	; 0x146a <prvAddCurrentTaskToDelayedList>
    1b2e:	2b df       	rcall	.-426    	; 0x1986 <xTaskResumeAll>
    1b30:	81 11       	cpse	r24, r1
    1b32:	01 c0       	rjmp	.+2      	; 0x1b36 <vTaskDelay+0x32>
    1b34:	ac d8       	rcall	.-3752   	; 0xc8e <vPortYield>
    1b36:	df 91       	pop	r29
    1b38:	cf 91       	pop	r28
    1b3a:	08 95       	ret

00001b3c <prvIdleTask>:
    1b3c:	0f 2e       	mov	r0, r31
    1b3e:	fa ea       	ldi	r31, 0xAA	; 170
    1b40:	ef 2e       	mov	r14, r31
    1b42:	f8 e0       	ldi	r31, 0x08	; 8
    1b44:	ff 2e       	mov	r15, r31
    1b46:	f0 2d       	mov	r31, r0
    1b48:	c2 e8       	ldi	r28, 0x82	; 130
    1b4a:	d8 e0       	ldi	r29, 0x08	; 8
    1b4c:	26 c0       	rjmp	.+76     	; 0x1b9a <prvIdleTask+0x5e>
    1b4e:	4d de       	rcall	.-870    	; 0x17ea <vTaskSuspendAll>
    1b50:	18 81       	ld	r17, Y
    1b52:	19 df       	rcall	.-462    	; 0x1986 <xTaskResumeAll>
    1b54:	11 23       	and	r17, r17
    1b56:	09 f1       	breq	.+66     	; 0x1b9a <prvIdleTask+0x5e>
    1b58:	0f b6       	in	r0, 0x3f	; 63
    1b5a:	f8 94       	cli
    1b5c:	0f 92       	push	r0
    1b5e:	e0 91 87 08 	lds	r30, 0x0887
    1b62:	f0 91 88 08 	lds	r31, 0x0888
    1b66:	06 81       	ldd	r16, Z+6	; 0x06
    1b68:	17 81       	ldd	r17, Z+7	; 0x07
    1b6a:	c8 01       	movw	r24, r16
    1b6c:	02 96       	adiw	r24, 0x02	; 2
    1b6e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1b72:	80 91 77 08 	lds	r24, 0x0877
    1b76:	81 50       	subi	r24, 0x01	; 1
    1b78:	80 93 77 08 	sts	0x0877, r24
    1b7c:	80 91 81 08 	lds	r24, 0x0881
    1b80:	81 50       	subi	r24, 0x01	; 1
    1b82:	80 93 81 08 	sts	0x0881, r24
    1b86:	0f 90       	pop	r0
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	87 89       	ldd	r24, Z+23	; 0x17
    1b8e:	90 8d       	ldd	r25, Z+24	; 0x18
    1b90:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    1b94:	c8 01       	movw	r24, r16
    1b96:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    1b9a:	80 91 81 08 	lds	r24, 0x0881
    1b9e:	81 11       	cpse	r24, r1
    1ba0:	d6 cf       	rjmp	.-84     	; 0x1b4e <prvIdleTask+0x12>
    1ba2:	f7 01       	movw	r30, r14
    1ba4:	80 81       	ld	r24, Z
    1ba6:	82 30       	cpi	r24, 0x02	; 2
    1ba8:	c0 f3       	brcs	.-16     	; 0x1b9a <prvIdleTask+0x5e>
    1baa:	71 d8       	rcall	.-3870   	; 0xc8e <vPortYield>
    1bac:	f6 cf       	rjmp	.-20     	; 0x1b9a <prvIdleTask+0x5e>

00001bae <vTaskSwitchContext>:
    1bae:	80 91 6e 08 	lds	r24, 0x086E
    1bb2:	88 23       	and	r24, r24
    1bb4:	21 f0       	breq	.+8      	; 0x1bbe <vTaskSwitchContext+0x10>
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	80 93 71 08 	sts	0x0871, r24
    1bbc:	08 95       	ret
    1bbe:	10 92 71 08 	sts	0x0871, r1
    1bc2:	80 91 74 08 	lds	r24, 0x0874
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	fc 01       	movw	r30, r24
    1bca:	ee 0f       	add	r30, r30
    1bcc:	ff 1f       	adc	r31, r31
    1bce:	ee 0f       	add	r30, r30
    1bd0:	ff 1f       	adc	r31, r31
    1bd2:	ee 0f       	add	r30, r30
    1bd4:	ff 1f       	adc	r31, r31
    1bd6:	8e 0f       	add	r24, r30
    1bd8:	9f 1f       	adc	r25, r31
    1bda:	fc 01       	movw	r30, r24
    1bdc:	e6 55       	subi	r30, 0x56	; 86
    1bde:	f7 4f       	sbci	r31, 0xF7	; 247
    1be0:	80 81       	ld	r24, Z
    1be2:	81 11       	cpse	r24, r1
    1be4:	17 c0       	rjmp	.+46     	; 0x1c14 <vTaskSwitchContext+0x66>
    1be6:	80 91 74 08 	lds	r24, 0x0874
    1bea:	81 50       	subi	r24, 0x01	; 1
    1bec:	80 93 74 08 	sts	0x0874, r24
    1bf0:	80 91 74 08 	lds	r24, 0x0874
    1bf4:	90 e0       	ldi	r25, 0x00	; 0
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	ee 0f       	add	r30, r30
    1bfa:	ff 1f       	adc	r31, r31
    1bfc:	ee 0f       	add	r30, r30
    1bfe:	ff 1f       	adc	r31, r31
    1c00:	ee 0f       	add	r30, r30
    1c02:	ff 1f       	adc	r31, r31
    1c04:	8e 0f       	add	r24, r30
    1c06:	9f 1f       	adc	r25, r31
    1c08:	fc 01       	movw	r30, r24
    1c0a:	e6 55       	subi	r30, 0x56	; 86
    1c0c:	f7 4f       	sbci	r31, 0xF7	; 247
    1c0e:	80 81       	ld	r24, Z
    1c10:	88 23       	and	r24, r24
    1c12:	49 f3       	breq	.-46     	; 0x1be6 <vTaskSwitchContext+0x38>
    1c14:	e0 91 74 08 	lds	r30, 0x0874
    1c18:	f0 e0       	ldi	r31, 0x00	; 0
    1c1a:	cf 01       	movw	r24, r30
    1c1c:	88 0f       	add	r24, r24
    1c1e:	99 1f       	adc	r25, r25
    1c20:	88 0f       	add	r24, r24
    1c22:	99 1f       	adc	r25, r25
    1c24:	88 0f       	add	r24, r24
    1c26:	99 1f       	adc	r25, r25
    1c28:	e8 0f       	add	r30, r24
    1c2a:	f9 1f       	adc	r31, r25
    1c2c:	e6 55       	subi	r30, 0x56	; 86
    1c2e:	f7 4f       	sbci	r31, 0xF7	; 247
    1c30:	a1 81       	ldd	r26, Z+1	; 0x01
    1c32:	b2 81       	ldd	r27, Z+2	; 0x02
    1c34:	12 96       	adiw	r26, 0x02	; 2
    1c36:	0d 90       	ld	r0, X+
    1c38:	bc 91       	ld	r27, X
    1c3a:	a0 2d       	mov	r26, r0
    1c3c:	b2 83       	std	Z+2, r27	; 0x02
    1c3e:	a1 83       	std	Z+1, r26	; 0x01
    1c40:	cf 01       	movw	r24, r30
    1c42:	03 96       	adiw	r24, 0x03	; 3
    1c44:	a8 17       	cp	r26, r24
    1c46:	b9 07       	cpc	r27, r25
    1c48:	31 f4       	brne	.+12     	; 0x1c56 <vTaskSwitchContext+0xa8>
    1c4a:	12 96       	adiw	r26, 0x02	; 2
    1c4c:	8d 91       	ld	r24, X+
    1c4e:	9c 91       	ld	r25, X
    1c50:	13 97       	sbiw	r26, 0x03	; 3
    1c52:	92 83       	std	Z+2, r25	; 0x02
    1c54:	81 83       	std	Z+1, r24	; 0x01
    1c56:	01 80       	ldd	r0, Z+1	; 0x01
    1c58:	f2 81       	ldd	r31, Z+2	; 0x02
    1c5a:	e0 2d       	mov	r30, r0
    1c5c:	86 81       	ldd	r24, Z+6	; 0x06
    1c5e:	97 81       	ldd	r25, Z+7	; 0x07
    1c60:	90 93 d8 08 	sts	0x08D8, r25
    1c64:	80 93 d7 08 	sts	0x08D7, r24
    1c68:	08 95       	ret

00001c6a <vTaskSuspend>:
    1c6a:	0f 93       	push	r16
    1c6c:	1f 93       	push	r17
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	ec 01       	movw	r28, r24
    1c74:	0f b6       	in	r0, 0x3f	; 63
    1c76:	f8 94       	cli
    1c78:	0f 92       	push	r0
    1c7a:	00 97       	sbiw	r24, 0x00	; 0
    1c7c:	21 f4       	brne	.+8      	; 0x1c86 <vTaskSuspend+0x1c>
    1c7e:	c0 91 d7 08 	lds	r28, 0x08D7
    1c82:	d0 91 d8 08 	lds	r29, 0x08D8
    1c86:	8e 01       	movw	r16, r28
    1c88:	0e 5f       	subi	r16, 0xFE	; 254
    1c8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1c8c:	c8 01       	movw	r24, r16
    1c8e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1c92:	8c 89       	ldd	r24, Y+20	; 0x14
    1c94:	9d 89       	ldd	r25, Y+21	; 0x15
    1c96:	89 2b       	or	r24, r25
    1c98:	21 f0       	breq	.+8      	; 0x1ca2 <vTaskSuspend+0x38>
    1c9a:	ce 01       	movw	r24, r28
    1c9c:	0c 96       	adiw	r24, 0x0c	; 12
    1c9e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1ca2:	b8 01       	movw	r22, r16
    1ca4:	88 e7       	ldi	r24, 0x78	; 120
    1ca6:	98 e0       	ldi	r25, 0x08	; 8
    1ca8:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1cac:	0f 90       	pop	r0
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	80 91 d7 08 	lds	r24, 0x08D7
    1cb4:	90 91 d8 08 	lds	r25, 0x08D8
    1cb8:	c8 17       	cp	r28, r24
    1cba:	d9 07       	cpc	r29, r25
    1cbc:	a1 f4       	brne	.+40     	; 0x1ce6 <vTaskSuspend+0x7c>
    1cbe:	80 91 73 08 	lds	r24, 0x0873
    1cc2:	88 23       	and	r24, r24
    1cc4:	19 f0       	breq	.+6      	; 0x1ccc <vTaskSuspend+0x62>
    1cc6:	0e 94 47 06 	call	0xc8e	; 0xc8e <vPortYield>
    1cca:	17 c0       	rjmp	.+46     	; 0x1cfa <vTaskSuspend+0x90>
    1ccc:	80 91 77 08 	lds	r24, 0x0877
    1cd0:	90 91 78 08 	lds	r25, 0x0878
    1cd4:	98 13       	cpse	r25, r24
    1cd6:	05 c0       	rjmp	.+10     	; 0x1ce2 <vTaskSuspend+0x78>
    1cd8:	10 92 d8 08 	sts	0x08D8, r1
    1cdc:	10 92 d7 08 	sts	0x08D7, r1
    1ce0:	0c c0       	rjmp	.+24     	; 0x1cfa <vTaskSuspend+0x90>
    1ce2:	65 df       	rcall	.-310    	; 0x1bae <vTaskSwitchContext>
    1ce4:	0a c0       	rjmp	.+20     	; 0x1cfa <vTaskSuspend+0x90>
    1ce6:	80 91 73 08 	lds	r24, 0x0873
    1cea:	88 23       	and	r24, r24
    1cec:	31 f0       	breq	.+12     	; 0x1cfa <vTaskSuspend+0x90>
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	0f 92       	push	r0
    1cf4:	9b db       	rcall	.-2250   	; 0x142c <prvResetNextTaskUnblockTime>
    1cf6:	0f 90       	pop	r0
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	df 91       	pop	r29
    1cfc:	cf 91       	pop	r28
    1cfe:	1f 91       	pop	r17
    1d00:	0f 91       	pop	r16
    1d02:	08 95       	ret

00001d04 <vTaskPlaceOnEventList>:
    1d04:	cf 93       	push	r28
    1d06:	df 93       	push	r29
    1d08:	eb 01       	movw	r28, r22
    1d0a:	60 91 d7 08 	lds	r22, 0x08D7
    1d0e:	70 91 d8 08 	lds	r23, 0x08D8
    1d12:	64 5f       	subi	r22, 0xF4	; 244
    1d14:	7f 4f       	sbci	r23, 0xFF	; 255
    1d16:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    1d1a:	80 91 d7 08 	lds	r24, 0x08D7
    1d1e:	90 91 d8 08 	lds	r25, 0x08D8
    1d22:	02 96       	adiw	r24, 0x02	; 2
    1d24:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1d28:	cf 3f       	cpi	r28, 0xFF	; 255
    1d2a:	8f ef       	ldi	r24, 0xFF	; 255
    1d2c:	d8 07       	cpc	r29, r24
    1d2e:	59 f4       	brne	.+22     	; 0x1d46 <vTaskPlaceOnEventList+0x42>
    1d30:	60 91 d7 08 	lds	r22, 0x08D7
    1d34:	70 91 d8 08 	lds	r23, 0x08D8
    1d38:	6e 5f       	subi	r22, 0xFE	; 254
    1d3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d3c:	88 e7       	ldi	r24, 0x78	; 120
    1d3e:	98 e0       	ldi	r25, 0x08	; 8
    1d40:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1d44:	07 c0       	rjmp	.+14     	; 0x1d54 <vTaskPlaceOnEventList+0x50>
    1d46:	80 91 75 08 	lds	r24, 0x0875
    1d4a:	90 91 76 08 	lds	r25, 0x0876
    1d4e:	8c 0f       	add	r24, r28
    1d50:	9d 1f       	adc	r25, r29
    1d52:	8b db       	rcall	.-2282   	; 0x146a <prvAddCurrentTaskToDelayedList>
    1d54:	df 91       	pop	r29
    1d56:	cf 91       	pop	r28
    1d58:	08 95       	ret

00001d5a <xTaskRemoveFromEventList>:
    1d5a:	0f 93       	push	r16
    1d5c:	1f 93       	push	r17
    1d5e:	cf 93       	push	r28
    1d60:	df 93       	push	r29
    1d62:	dc 01       	movw	r26, r24
    1d64:	15 96       	adiw	r26, 0x05	; 5
    1d66:	ed 91       	ld	r30, X+
    1d68:	fc 91       	ld	r31, X
    1d6a:	16 97       	sbiw	r26, 0x06	; 6
    1d6c:	c6 81       	ldd	r28, Z+6	; 0x06
    1d6e:	d7 81       	ldd	r29, Z+7	; 0x07
    1d70:	8e 01       	movw	r16, r28
    1d72:	04 5f       	subi	r16, 0xF4	; 244
    1d74:	1f 4f       	sbci	r17, 0xFF	; 255
    1d76:	c8 01       	movw	r24, r16
    1d78:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1d7c:	80 91 6e 08 	lds	r24, 0x086E
    1d80:	81 11       	cpse	r24, r1
    1d82:	1c c0       	rjmp	.+56     	; 0x1dbc <xTaskRemoveFromEventList+0x62>
    1d84:	0a 50       	subi	r16, 0x0A	; 10
    1d86:	11 09       	sbc	r17, r1
    1d88:	c8 01       	movw	r24, r16
    1d8a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1d8e:	8e 89       	ldd	r24, Y+22	; 0x16
    1d90:	90 91 74 08 	lds	r25, 0x0874
    1d94:	98 17       	cp	r25, r24
    1d96:	10 f4       	brcc	.+4      	; 0x1d9c <xTaskRemoveFromEventList+0x42>
    1d98:	80 93 74 08 	sts	0x0874, r24
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	9c 01       	movw	r18, r24
    1da0:	22 0f       	add	r18, r18
    1da2:	33 1f       	adc	r19, r19
    1da4:	22 0f       	add	r18, r18
    1da6:	33 1f       	adc	r19, r19
    1da8:	22 0f       	add	r18, r18
    1daa:	33 1f       	adc	r19, r19
    1dac:	82 0f       	add	r24, r18
    1dae:	93 1f       	adc	r25, r19
    1db0:	b8 01       	movw	r22, r16
    1db2:	86 55       	subi	r24, 0x56	; 86
    1db4:	97 4f       	sbci	r25, 0xF7	; 247
    1db6:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1dba:	05 c0       	rjmp	.+10     	; 0x1dc6 <xTaskRemoveFromEventList+0x6c>
    1dbc:	b8 01       	movw	r22, r16
    1dbe:	8b e8       	ldi	r24, 0x8B	; 139
    1dc0:	98 e0       	ldi	r25, 0x08	; 8
    1dc2:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1dc6:	e0 91 d7 08 	lds	r30, 0x08D7
    1dca:	f0 91 d8 08 	lds	r31, 0x08D8
    1dce:	9e 89       	ldd	r25, Y+22	; 0x16
    1dd0:	86 89       	ldd	r24, Z+22	; 0x16
    1dd2:	89 17       	cp	r24, r25
    1dd4:	20 f4       	brcc	.+8      	; 0x1dde <xTaskRemoveFromEventList+0x84>
    1dd6:	81 e0       	ldi	r24, 0x01	; 1
    1dd8:	80 93 71 08 	sts	0x0871, r24
    1ddc:	01 c0       	rjmp	.+2      	; 0x1de0 <xTaskRemoveFromEventList+0x86>
    1dde:	80 e0       	ldi	r24, 0x00	; 0
    1de0:	df 91       	pop	r29
    1de2:	cf 91       	pop	r28
    1de4:	1f 91       	pop	r17
    1de6:	0f 91       	pop	r16
    1de8:	08 95       	ret

00001dea <vTaskSetTimeOutState>:
    1dea:	20 91 70 08 	lds	r18, 0x0870
    1dee:	fc 01       	movw	r30, r24
    1df0:	20 83       	st	Z, r18
    1df2:	20 91 75 08 	lds	r18, 0x0875
    1df6:	30 91 76 08 	lds	r19, 0x0876
    1dfa:	32 83       	std	Z+2, r19	; 0x02
    1dfc:	21 83       	std	Z+1, r18	; 0x01
    1dfe:	08 95       	ret

00001e00 <xTaskCheckForTimeOut>:
    1e00:	0f b6       	in	r0, 0x3f	; 63
    1e02:	f8 94       	cli
    1e04:	0f 92       	push	r0
    1e06:	40 91 75 08 	lds	r20, 0x0875
    1e0a:	50 91 76 08 	lds	r21, 0x0876
    1e0e:	db 01       	movw	r26, r22
    1e10:	2d 91       	ld	r18, X+
    1e12:	3c 91       	ld	r19, X
    1e14:	2f 3f       	cpi	r18, 0xFF	; 255
    1e16:	bf ef       	ldi	r27, 0xFF	; 255
    1e18:	3b 07       	cpc	r19, r27
    1e1a:	11 f1       	breq	.+68     	; 0x1e60 <xTaskCheckForTimeOut+0x60>
    1e1c:	e0 91 70 08 	lds	r30, 0x0870
    1e20:	dc 01       	movw	r26, r24
    1e22:	fc 91       	ld	r31, X
    1e24:	fe 17       	cp	r31, r30
    1e26:	39 f0       	breq	.+14     	; 0x1e36 <xTaskCheckForTimeOut+0x36>
    1e28:	11 96       	adiw	r26, 0x01	; 1
    1e2a:	ed 91       	ld	r30, X+
    1e2c:	fc 91       	ld	r31, X
    1e2e:	12 97       	sbiw	r26, 0x02	; 2
    1e30:	4e 17       	cp	r20, r30
    1e32:	5f 07       	cpc	r21, r31
    1e34:	b8 f4       	brcc	.+46     	; 0x1e64 <xTaskCheckForTimeOut+0x64>
    1e36:	dc 01       	movw	r26, r24
    1e38:	11 96       	adiw	r26, 0x01	; 1
    1e3a:	ed 91       	ld	r30, X+
    1e3c:	fc 91       	ld	r31, X
    1e3e:	12 97       	sbiw	r26, 0x02	; 2
    1e40:	da 01       	movw	r26, r20
    1e42:	ae 1b       	sub	r26, r30
    1e44:	bf 0b       	sbc	r27, r31
    1e46:	a2 17       	cp	r26, r18
    1e48:	b3 07       	cpc	r27, r19
    1e4a:	70 f4       	brcc	.+28     	; 0x1e68 <xTaskCheckForTimeOut+0x68>
    1e4c:	e4 1b       	sub	r30, r20
    1e4e:	f5 0b       	sbc	r31, r21
    1e50:	2e 0f       	add	r18, r30
    1e52:	3f 1f       	adc	r19, r31
    1e54:	fb 01       	movw	r30, r22
    1e56:	31 83       	std	Z+1, r19	; 0x01
    1e58:	20 83       	st	Z, r18
    1e5a:	c7 df       	rcall	.-114    	; 0x1dea <vTaskSetTimeOutState>
    1e5c:	80 e0       	ldi	r24, 0x00	; 0
    1e5e:	05 c0       	rjmp	.+10     	; 0x1e6a <xTaskCheckForTimeOut+0x6a>
    1e60:	80 e0       	ldi	r24, 0x00	; 0
    1e62:	03 c0       	rjmp	.+6      	; 0x1e6a <xTaskCheckForTimeOut+0x6a>
    1e64:	81 e0       	ldi	r24, 0x01	; 1
    1e66:	01 c0       	rjmp	.+2      	; 0x1e6a <xTaskCheckForTimeOut+0x6a>
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	08 95       	ret

00001e70 <vTaskMissedYield>:
    1e70:	81 e0       	ldi	r24, 0x01	; 1
    1e72:	80 93 71 08 	sts	0x0871, r24
    1e76:	08 95       	ret

00001e78 <vTaskPriorityInherit>:
    1e78:	0f 93       	push	r16
    1e7a:	1f 93       	push	r17
    1e7c:	cf 93       	push	r28
    1e7e:	df 93       	push	r29
    1e80:	ec 01       	movw	r28, r24
    1e82:	00 97       	sbiw	r24, 0x00	; 0
    1e84:	09 f4       	brne	.+2      	; 0x1e88 <vTaskPriorityInherit+0x10>
    1e86:	51 c0       	rjmp	.+162    	; 0x1f2a <vTaskPriorityInherit+0xb2>
    1e88:	8e 89       	ldd	r24, Y+22	; 0x16
    1e8a:	e0 91 d7 08 	lds	r30, 0x08D7
    1e8e:	f0 91 d8 08 	lds	r31, 0x08D8
    1e92:	96 89       	ldd	r25, Z+22	; 0x16
    1e94:	89 17       	cp	r24, r25
    1e96:	08 f0       	brcs	.+2      	; 0x1e9a <vTaskPriorityInherit+0x22>
    1e98:	48 c0       	rjmp	.+144    	; 0x1f2a <vTaskPriorityInherit+0xb2>
    1e9a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e9c:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e9e:	33 23       	and	r19, r19
    1ea0:	5c f0       	brlt	.+22     	; 0x1eb8 <vTaskPriorityInherit+0x40>
    1ea2:	e0 91 d7 08 	lds	r30, 0x08D7
    1ea6:	f0 91 d8 08 	lds	r31, 0x08D8
    1eaa:	96 89       	ldd	r25, Z+22	; 0x16
    1eac:	25 e0       	ldi	r18, 0x05	; 5
    1eae:	30 e0       	ldi	r19, 0x00	; 0
    1eb0:	29 1b       	sub	r18, r25
    1eb2:	31 09       	sbc	r19, r1
    1eb4:	3d 87       	std	Y+13, r19	; 0x0d
    1eb6:	2c 87       	std	Y+12, r18	; 0x0c
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
    1eba:	9c 01       	movw	r18, r24
    1ebc:	22 0f       	add	r18, r18
    1ebe:	33 1f       	adc	r19, r19
    1ec0:	22 0f       	add	r18, r18
    1ec2:	33 1f       	adc	r19, r19
    1ec4:	22 0f       	add	r18, r18
    1ec6:	33 1f       	adc	r19, r19
    1ec8:	82 0f       	add	r24, r18
    1eca:	93 1f       	adc	r25, r19
    1ecc:	86 55       	subi	r24, 0x56	; 86
    1ece:	97 4f       	sbci	r25, 0xF7	; 247
    1ed0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ed2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ed4:	28 17       	cp	r18, r24
    1ed6:	39 07       	cpc	r19, r25
    1ed8:	11 f5       	brne	.+68     	; 0x1f1e <vTaskPriorityInherit+0xa6>
    1eda:	8e 01       	movw	r16, r28
    1edc:	0e 5f       	subi	r16, 0xFE	; 254
    1ede:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee0:	c8 01       	movw	r24, r16
    1ee2:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1ee6:	e0 91 d7 08 	lds	r30, 0x08D7
    1eea:	f0 91 d8 08 	lds	r31, 0x08D8
    1eee:	86 89       	ldd	r24, Z+22	; 0x16
    1ef0:	8e 8b       	std	Y+22, r24	; 0x16
    1ef2:	90 91 74 08 	lds	r25, 0x0874
    1ef6:	98 17       	cp	r25, r24
    1ef8:	10 f4       	brcc	.+4      	; 0x1efe <vTaskPriorityInherit+0x86>
    1efa:	80 93 74 08 	sts	0x0874, r24
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	9c 01       	movw	r18, r24
    1f02:	22 0f       	add	r18, r18
    1f04:	33 1f       	adc	r19, r19
    1f06:	22 0f       	add	r18, r18
    1f08:	33 1f       	adc	r19, r19
    1f0a:	22 0f       	add	r18, r18
    1f0c:	33 1f       	adc	r19, r19
    1f0e:	82 0f       	add	r24, r18
    1f10:	93 1f       	adc	r25, r19
    1f12:	b8 01       	movw	r22, r16
    1f14:	86 55       	subi	r24, 0x56	; 86
    1f16:	97 4f       	sbci	r25, 0xF7	; 247
    1f18:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1f1c:	06 c0       	rjmp	.+12     	; 0x1f2a <vTaskPriorityInherit+0xb2>
    1f1e:	e0 91 d7 08 	lds	r30, 0x08D7
    1f22:	f0 91 d8 08 	lds	r31, 0x08D8
    1f26:	86 89       	ldd	r24, Z+22	; 0x16
    1f28:	8e 8b       	std	Y+22, r24	; 0x16
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	1f 91       	pop	r17
    1f30:	0f 91       	pop	r16
    1f32:	08 95       	ret

00001f34 <xTaskPriorityDisinherit>:
    1f34:	0f 93       	push	r16
    1f36:	1f 93       	push	r17
    1f38:	cf 93       	push	r28
    1f3a:	df 93       	push	r29
    1f3c:	ec 01       	movw	r28, r24
    1f3e:	00 97       	sbiw	r24, 0x00	; 0
    1f40:	71 f1       	breq	.+92     	; 0x1f9e <xTaskPriorityDisinherit+0x6a>
    1f42:	8a a1       	ldd	r24, Y+34	; 0x22
    1f44:	81 50       	subi	r24, 0x01	; 1
    1f46:	8a a3       	std	Y+34, r24	; 0x22
    1f48:	2e 89       	ldd	r18, Y+22	; 0x16
    1f4a:	99 a1       	ldd	r25, Y+33	; 0x21
    1f4c:	29 17       	cp	r18, r25
    1f4e:	49 f1       	breq	.+82     	; 0x1fa2 <xTaskPriorityDisinherit+0x6e>
    1f50:	81 11       	cpse	r24, r1
    1f52:	29 c0       	rjmp	.+82     	; 0x1fa6 <xTaskPriorityDisinherit+0x72>
    1f54:	8e 01       	movw	r16, r28
    1f56:	0e 5f       	subi	r16, 0xFE	; 254
    1f58:	1f 4f       	sbci	r17, 0xFF	; 255
    1f5a:	c8 01       	movw	r24, r16
    1f5c:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1f60:	89 a1       	ldd	r24, Y+33	; 0x21
    1f62:	8e 8b       	std	Y+22, r24	; 0x16
    1f64:	25 e0       	ldi	r18, 0x05	; 5
    1f66:	30 e0       	ldi	r19, 0x00	; 0
    1f68:	28 1b       	sub	r18, r24
    1f6a:	31 09       	sbc	r19, r1
    1f6c:	3d 87       	std	Y+13, r19	; 0x0d
    1f6e:	2c 87       	std	Y+12, r18	; 0x0c
    1f70:	90 91 74 08 	lds	r25, 0x0874
    1f74:	98 17       	cp	r25, r24
    1f76:	10 f4       	brcc	.+4      	; 0x1f7c <xTaskPriorityDisinherit+0x48>
    1f78:	80 93 74 08 	sts	0x0874, r24
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	9c 01       	movw	r18, r24
    1f80:	22 0f       	add	r18, r18
    1f82:	33 1f       	adc	r19, r19
    1f84:	22 0f       	add	r18, r18
    1f86:	33 1f       	adc	r19, r19
    1f88:	22 0f       	add	r18, r18
    1f8a:	33 1f       	adc	r19, r19
    1f8c:	82 0f       	add	r24, r18
    1f8e:	93 1f       	adc	r25, r19
    1f90:	b8 01       	movw	r22, r16
    1f92:	86 55       	subi	r24, 0x56	; 86
    1f94:	97 4f       	sbci	r25, 0xF7	; 247
    1f96:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1f9a:	81 e0       	ldi	r24, 0x01	; 1
    1f9c:	05 c0       	rjmp	.+10     	; 0x1fa8 <xTaskPriorityDisinherit+0x74>
    1f9e:	80 e0       	ldi	r24, 0x00	; 0
    1fa0:	03 c0       	rjmp	.+6      	; 0x1fa8 <xTaskPriorityDisinherit+0x74>
    1fa2:	80 e0       	ldi	r24, 0x00	; 0
    1fa4:	01 c0       	rjmp	.+2      	; 0x1fa8 <xTaskPriorityDisinherit+0x74>
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	1f 91       	pop	r17
    1fae:	0f 91       	pop	r16
    1fb0:	08 95       	ret

00001fb2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1fb2:	80 91 d7 08 	lds	r24, 0x08D7
    1fb6:	90 91 d8 08 	lds	r25, 0x08D8
    1fba:	89 2b       	or	r24, r25
    1fbc:	39 f0       	breq	.+14     	; 0x1fcc <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1fbe:	e0 91 d7 08 	lds	r30, 0x08D7
    1fc2:	f0 91 d8 08 	lds	r31, 0x08D8
    1fc6:	82 a1       	ldd	r24, Z+34	; 0x22
    1fc8:	8f 5f       	subi	r24, 0xFF	; 255
    1fca:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1fcc:	80 91 d7 08 	lds	r24, 0x08D7
    1fd0:	90 91 d8 08 	lds	r25, 0x08D8
	}
    1fd4:	08 95       	ret

00001fd6 <__divmodhi4>:
    1fd6:	97 fb       	bst	r25, 7
    1fd8:	07 2e       	mov	r0, r23
    1fda:	16 f4       	brtc	.+4      	; 0x1fe0 <__divmodhi4+0xa>
    1fdc:	00 94       	com	r0
    1fde:	06 d0       	rcall	.+12     	; 0x1fec <__divmodhi4_neg1>
    1fe0:	77 fd       	sbrc	r23, 7
    1fe2:	08 d0       	rcall	.+16     	; 0x1ff4 <__divmodhi4_neg2>
    1fe4:	0b d0       	rcall	.+22     	; 0x1ffc <__udivmodhi4>
    1fe6:	07 fc       	sbrc	r0, 7
    1fe8:	05 d0       	rcall	.+10     	; 0x1ff4 <__divmodhi4_neg2>
    1fea:	3e f4       	brtc	.+14     	; 0x1ffa <__divmodhi4_exit>

00001fec <__divmodhi4_neg1>:
    1fec:	90 95       	com	r25
    1fee:	81 95       	neg	r24
    1ff0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ff2:	08 95       	ret

00001ff4 <__divmodhi4_neg2>:
    1ff4:	70 95       	com	r23
    1ff6:	61 95       	neg	r22
    1ff8:	7f 4f       	sbci	r23, 0xFF	; 255

00001ffa <__divmodhi4_exit>:
    1ffa:	08 95       	ret

00001ffc <__udivmodhi4>:
    1ffc:	aa 1b       	sub	r26, r26
    1ffe:	bb 1b       	sub	r27, r27
    2000:	51 e1       	ldi	r21, 0x11	; 17
    2002:	07 c0       	rjmp	.+14     	; 0x2012 <__udivmodhi4_ep>

00002004 <__udivmodhi4_loop>:
    2004:	aa 1f       	adc	r26, r26
    2006:	bb 1f       	adc	r27, r27
    2008:	a6 17       	cp	r26, r22
    200a:	b7 07       	cpc	r27, r23
    200c:	10 f0       	brcs	.+4      	; 0x2012 <__udivmodhi4_ep>
    200e:	a6 1b       	sub	r26, r22
    2010:	b7 0b       	sbc	r27, r23

00002012 <__udivmodhi4_ep>:
    2012:	88 1f       	adc	r24, r24
    2014:	99 1f       	adc	r25, r25
    2016:	5a 95       	dec	r21
    2018:	a9 f7       	brne	.-22     	; 0x2004 <__udivmodhi4_loop>
    201a:	80 95       	com	r24
    201c:	90 95       	com	r25
    201e:	bc 01       	movw	r22, r24
    2020:	cd 01       	movw	r24, r26
    2022:	08 95       	ret

00002024 <memcpy>:
    2024:	fb 01       	movw	r30, r22
    2026:	dc 01       	movw	r26, r24
    2028:	02 c0       	rjmp	.+4      	; 0x202e <memcpy+0xa>
    202a:	01 90       	ld	r0, Z+
    202c:	0d 92       	st	X+, r0
    202e:	41 50       	subi	r20, 0x01	; 1
    2030:	50 40       	sbci	r21, 0x00	; 0
    2032:	d8 f7       	brcc	.-10     	; 0x202a <memcpy+0x6>
    2034:	08 95       	ret

00002036 <__itoa_ncheck>:
    2036:	bb 27       	eor	r27, r27
    2038:	4a 30       	cpi	r20, 0x0A	; 10
    203a:	31 f4       	brne	.+12     	; 0x2048 <__itoa_ncheck+0x12>
    203c:	99 23       	and	r25, r25
    203e:	22 f4       	brpl	.+8      	; 0x2048 <__itoa_ncheck+0x12>
    2040:	bd e2       	ldi	r27, 0x2D	; 45
    2042:	90 95       	com	r25
    2044:	81 95       	neg	r24
    2046:	9f 4f       	sbci	r25, 0xFF	; 255
    2048:	01 c0       	rjmp	.+2      	; 0x204c <__utoa_common>

0000204a <__utoa_ncheck>:
    204a:	bb 27       	eor	r27, r27

0000204c <__utoa_common>:
    204c:	fb 01       	movw	r30, r22
    204e:	55 27       	eor	r21, r21
    2050:	aa 27       	eor	r26, r26
    2052:	88 0f       	add	r24, r24
    2054:	99 1f       	adc	r25, r25
    2056:	aa 1f       	adc	r26, r26
    2058:	a4 17       	cp	r26, r20
    205a:	10 f0       	brcs	.+4      	; 0x2060 <__utoa_common+0x14>
    205c:	a4 1b       	sub	r26, r20
    205e:	83 95       	inc	r24
    2060:	50 51       	subi	r21, 0x10	; 16
    2062:	b9 f7       	brne	.-18     	; 0x2052 <__utoa_common+0x6>
    2064:	a0 5d       	subi	r26, 0xD0	; 208
    2066:	aa 33       	cpi	r26, 0x3A	; 58
    2068:	08 f0       	brcs	.+2      	; 0x206c <__utoa_common+0x20>
    206a:	a9 5d       	subi	r26, 0xD9	; 217
    206c:	a1 93       	st	Z+, r26
    206e:	00 97       	sbiw	r24, 0x00	; 0
    2070:	79 f7       	brne	.-34     	; 0x2050 <__utoa_common+0x4>
    2072:	b1 11       	cpse	r27, r1
    2074:	b1 93       	st	Z+, r27
    2076:	11 92       	st	Z+, r1
    2078:	cb 01       	movw	r24, r22
    207a:	00 c0       	rjmp	.+0      	; 0x207c <strrev>

0000207c <strrev>:
    207c:	dc 01       	movw	r26, r24
    207e:	fc 01       	movw	r30, r24
    2080:	67 2f       	mov	r22, r23
    2082:	71 91       	ld	r23, Z+
    2084:	77 23       	and	r23, r23
    2086:	e1 f7       	brne	.-8      	; 0x2080 <strrev+0x4>
    2088:	32 97       	sbiw	r30, 0x02	; 2
    208a:	04 c0       	rjmp	.+8      	; 0x2094 <strrev+0x18>
    208c:	7c 91       	ld	r23, X
    208e:	6d 93       	st	X+, r22
    2090:	70 83       	st	Z, r23
    2092:	62 91       	ld	r22, -Z
    2094:	ae 17       	cp	r26, r30
    2096:	bf 07       	cpc	r27, r31
    2098:	c8 f3       	brcs	.-14     	; 0x208c <strrev+0x10>
    209a:	08 95       	ret

0000209c <_exit>:
    209c:	f8 94       	cli

0000209e <__stop_program>:
    209e:	ff cf       	rjmp	.-2      	; 0x209e <__stop_program>
