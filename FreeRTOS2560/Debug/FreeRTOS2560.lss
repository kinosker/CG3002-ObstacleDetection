
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002eb2  00002f46  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002eb2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070b  0080023e  0080023e  00002f84  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f84  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00006046  00000000  00000000  00003524  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001743  00000000  00000000  0000956a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003887  00000000  00000000  0000acad  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f64  00000000  00000000  0000e534  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017d2  00000000  00000000  0000f498  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004210  00000000  00000000  00010c6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014e7a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	a8 c3       	rjmp	.+1872   	; 0x776 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 c2 0a 	jmp	0x1584	; 0x1584 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	7a c7       	rjmp	.+3828   	; 0xf5a <__vector_25>
      66:	00 00       	nop
      68:	e6 c7       	rjmp	.+4044   	; 0x1036 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	8f c4       	rjmp	.+2334   	; 0x994 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2c c7       	rjmp	.+3672   	; 0xeea <__vector_36>
      92:	00 00       	nop
      94:	9a c7       	rjmp	.+3892   	; 0xfca <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_getFilteredReading+0x2>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e2 eb       	ldi	r30, 0xB2	; 178
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a9 34       	cpi	r26, 0x49	; 73
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c1 d0       	rcall	.+386    	; 0x324 <main>
     1a2:	0c 94 57 17 	jmp	0x2eae	; 0x2eae <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	0e 94 30 09 	call	0x1260	; 0x1260 <myUSART_peekReceiveUSART1>
     1ac:	c8 2f       	mov	r28, r24
     1ae:	0e 94 1e 09 	call	0x123c	; 0x123c <myUSART_receiveHandShakeAck>
     1b2:	88 23       	and	r24, r24
     1b4:	29 f0       	breq	.+10     	; 0x1c0 <RPI_receiveTask+0x18>
     1b6:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <myUSART_receiveUSART1>
     1ba:	0e 94 13 09 	call	0x1226	; 0x1226 <myUSART_completeHandShake>
     1be:	f4 cf       	rjmp	.-24     	; 0x1a8 <RPI_receiveTask>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 2a 09 	call	0x1254	; 0x1254 <myUSART_receiveMessageACK>
     1c6:	88 23       	and	r24, r24
     1c8:	11 f0       	breq	.+4      	; 0x1ce <RPI_receiveTask+0x26>
     1ca:	fd d7       	rcall	.+4090   	; 0x11c6 <myUSART_receiveUSART1>
     1cc:	ed cf       	rjmp	.-38     	; 0x1a8 <RPI_receiveTask>
     1ce:	8c 2f       	mov	r24, r28
     1d0:	0e 94 24 09 	call	0x1248	; 0x1248 <myUSART_receiveHandShakeStart>
     1d4:	88 23       	and	r24, r24
     1d6:	19 f0       	breq	.+6      	; 0x1de <RPI_receiveTask+0x36>
     1d8:	0e 94 04 09 	call	0x1208	; 0x1208 <myUSART_waitForHandshake>
     1dc:	e5 cf       	rjmp	.-54     	; 0x1a8 <RPI_receiveTask>
     1de:	f3 d7       	rcall	.+4070   	; 0x11c6 <myUSART_receiveUSART1>
     1e0:	e3 cf       	rjmp	.-58     	; 0x1a8 <RPI_receiveTask>

000001e2 <RPI_sendTask>:
     1e2:	cf 93       	push	r28
     1e4:	df 93       	push	r29
     1e6:	00 d0       	rcall	.+0      	; 0x1e8 <RPI_sendTask+0x6>
     1e8:	00 d0       	rcall	.+0      	; 0x1ea <RPI_sendTask+0x8>
     1ea:	cd b7       	in	r28, 0x3d	; 61
     1ec:	de b7       	in	r29, 0x3e	; 62
     1ee:	20 e0       	ldi	r18, 0x00	; 0
     1f0:	4f ef       	ldi	r20, 0xFF	; 255
     1f2:	5f ef       	ldi	r21, 0xFF	; 255
     1f4:	be 01       	movw	r22, r28
     1f6:	6a 5f       	subi	r22, 0xFA	; 250
     1f8:	7f 4f       	sbci	r23, 0xFF	; 255
     1fa:	80 91 91 08 	lds	r24, 0x0891
     1fe:	90 91 92 08 	lds	r25, 0x0892
     202:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xQueueGenericReceive>
     206:	8e 81       	ldd	r24, Y+6	; 0x06
     208:	80 5d       	subi	r24, 0xD0	; 208
     20a:	aa d7       	rcall	.+3924   	; 0x1160 <myUSART_transmitUSART1_c>
     20c:	8a e0       	ldi	r24, 0x0A	; 10
     20e:	a8 d7       	rcall	.+3920   	; 0x1160 <myUSART_transmitUSART1_c>
     210:	8e 81       	ldd	r24, Y+6	; 0x06
     212:	9f ef       	ldi	r25, 0xFF	; 255
     214:	98 0f       	add	r25, r24
     216:	9e 83       	std	Y+6, r25	; 0x06
     218:	88 23       	and	r24, r24
     21a:	21 f1       	breq	.+72     	; 0x264 <RPI_sendTask+0x82>
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	4f ef       	ldi	r20, 0xFF	; 255
     220:	5f ef       	ldi	r21, 0xFF	; 255
     222:	be 01       	movw	r22, r28
     224:	6f 5f       	subi	r22, 0xFF	; 255
     226:	7f 4f       	sbci	r23, 0xFF	; 255
     228:	80 91 93 08 	lds	r24, 0x0893
     22c:	90 91 94 08 	lds	r25, 0x0894
     230:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xQueueGenericReceive>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	7d d7       	rcall	.+3834   	; 0x1132 <myUSART_transmitUSART0_c>
     238:	89 81       	ldd	r24, Y+1	; 0x01
     23a:	92 d7       	rcall	.+3876   	; 0x1160 <myUSART_transmitUSART1_c>
     23c:	8c e0       	ldi	r24, 0x0C	; 12
     23e:	92 e0       	ldi	r25, 0x02	; 2
     240:	b4 d7       	rcall	.+3944   	; 0x11aa <myUSART_transmitUSART0>
     242:	ce 01       	movw	r24, r28
     244:	02 96       	adiw	r24, 0x02	; 2
     246:	b1 d7       	rcall	.+3938   	; 0x11aa <myUSART_transmitUSART0>
     248:	ce 01       	movw	r24, r28
     24a:	02 96       	adiw	r24, 0x02	; 2
     24c:	a0 d7       	rcall	.+3904   	; 0x118e <myUSART_transmitUSART1>
     24e:	8a e0       	ldi	r24, 0x0A	; 10
     250:	87 d7       	rcall	.+3854   	; 0x1160 <myUSART_transmitUSART1_c>
     252:	8f e0       	ldi	r24, 0x0F	; 15
     254:	92 e0       	ldi	r25, 0x02	; 2
     256:	a9 d7       	rcall	.+3922   	; 0x11aa <myUSART_transmitUSART0>
     258:	8e 81       	ldd	r24, Y+6	; 0x06
     25a:	9f ef       	ldi	r25, 0xFF	; 255
     25c:	98 0f       	add	r25, r24
     25e:	9e 83       	std	Y+6, r25	; 0x06
     260:	81 11       	cpse	r24, r1
     262:	dc cf       	rjmp	.-72     	; 0x21c <RPI_sendTask+0x3a>
     264:	8a e0       	ldi	r24, 0x0A	; 10
     266:	65 d7       	rcall	.+3786   	; 0x1132 <myUSART_transmitUSART0_c>
     268:	c2 cf       	rjmp	.-124    	; 0x1ee <RPI_sendTask+0xc>

0000026a <myTimerTask>:
     26a:	90 d5       	rcall	.+2848   	; 0xd8c <myTimer_Init>
     26c:	cf d5       	rcall	.+2974   	; 0xe0c <myTimer_DelayChecker>
     26e:	fe cf       	rjmp	.-4      	; 0x26c <myTimerTask+0x2>

00000270 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     270:	8f ef       	ldi	r24, 0xFF	; 255
     272:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     276:	ef e7       	ldi	r30, 0x7F	; 127
     278:	f0 e0       	ldi	r31, 0x00	; 0
     27a:	90 81       	ld	r25, Z
     27c:	93 60       	ori	r25, 0x03	; 3
     27e:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     280:	80 93 7d 00 	sts	0x007D, r24
     284:	08 95       	ret

00000286 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     286:	8c ec       	ldi	r24, 0xCC	; 204
     288:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     28c:	8e e3       	ldi	r24, 0x3E	; 62
     28e:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     292:	ee cf       	rjmp	.-36     	; 0x270 <setDigitalInputPowerReduction>
     294:	08 95       	ret

00000296 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     296:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     29a:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     29e:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2a2:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2a6:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2aa:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ae:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2b2:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2b6:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2ba:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2be:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2c2:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2c6:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2ca:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2ce:	10 92 73 00 	sts	0x0073, r1
     2d2:	08 95       	ret

000002d4 <init>:
}

void init()
{
     2d4:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2d6:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2d8:	f8 94       	cli
	{
		clearTimer();
     2da:	dd df       	rcall	.-70     	; 0x296 <clearTimer>
		setPowerReduction();
     2dc:	d4 df       	rcall	.-88     	; 0x286 <setPowerReduction>
		myUSART_USART0_Init();
     2de:	e1 d6       	rcall	.+3522   	; 0x10a2 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2e0:	00 d7       	rcall	.+3584   	; 0x10e2 <myUSART_USART1_Init>
		myADC_Init();
     2e2:	90 d3       	rcall	.+1824   	; 0xa04 <myADC_Init>
		
		MaxSonar_Init();
     2e4:	83 b3       	in	r24, 0x13	; 19
     2e6:	83 60       	ori	r24, 0x03	; 3
     2e8:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     2ea:	d0 d2       	rcall	.+1440   	; 0x88c <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2ec:	40 e0       	ldi	r20, 0x00	; 0
     2ee:	61 e0       	ldi	r22, 0x01	; 1
     2f0:	85 e0       	ldi	r24, 0x05	; 5
     2f2:	0e 94 c1 0b 	call	0x1782	; 0x1782 <xQueueGenericCreate>
     2f6:	90 93 92 08 	sts	0x0892, r25
     2fa:	80 93 91 08 	sts	0x0891, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     2fe:	40 e0       	ldi	r20, 0x00	; 0
     300:	65 e0       	ldi	r22, 0x05	; 5
     302:	84 e1       	ldi	r24, 0x14	; 20
     304:	0e 94 c1 0b 	call	0x1782	; 0x1782 <xQueueGenericCreate>
     308:	90 93 94 08 	sts	0x0894, r25
     30c:	80 93 93 08 	sts	0x0893, r24
		
		MOTOR_LEFT_INIT();
     310:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     312:	e1 e0       	ldi	r30, 0x01	; 1
     314:	f1 e0       	ldi	r31, 0x01	; 1
     316:	80 81       	ld	r24, Z
     318:	80 61       	ori	r24, 0x10	; 16
     31a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     31c:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     31e:	78 94       	sei
}
     320:	cf 91       	pop	r28
     322:	08 95       	ret

00000324 <main>:
	
	// do nth
}

int main(void)
{
     324:	cf 93       	push	r28
     326:	df 93       	push	r29
     328:	cd b7       	in	r28, 0x3d	; 61
     32a:	de b7       	in	r29, 0x3e	; 62
     32c:	28 97       	sbiw	r28, 0x08	; 8
     32e:	0f b6       	in	r0, 0x3f	; 63
     330:	f8 94       	cli
     332:	de bf       	out	0x3e, r29	; 62
     334:	0f be       	out	0x3f, r0	; 63
     336:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     338:	cd df       	rcall	.-102    	; 0x2d4 <init>

		//xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     33a:	a1 2c       	mov	r10, r1
     33c:	b1 2c       	mov	r11, r1
     33e:	c1 2c       	mov	r12, r1
     340:	d1 2c       	mov	r13, r1
     342:	ce 01       	movw	r24, r28
     344:	01 96       	adiw	r24, 0x01	; 1
     346:	7c 01       	movw	r14, r24
     348:	04 e0       	ldi	r16, 0x04	; 4
     34a:	9c 01       	movw	r18, r24
     34c:	49 e6       	ldi	r20, 0x69	; 105
     34e:	50 e0       	ldi	r21, 0x00	; 0
     350:	62 e1       	ldi	r22, 0x12	; 18
     352:	72 e0       	ldi	r23, 0x02	; 2
     354:	85 e3       	ldi	r24, 0x35	; 53
     356:	91 e0       	ldi	r25, 0x01	; 1
     358:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     35c:	ce 01       	movw	r24, r28
     35e:	07 96       	adiw	r24, 0x07	; 7
     360:	7c 01       	movw	r14, r24
     362:	02 e0       	ldi	r16, 0x02	; 2
     364:	20 e0       	ldi	r18, 0x00	; 0
     366:	30 e0       	ldi	r19, 0x00	; 0
     368:	4d e6       	ldi	r20, 0x6D	; 109
     36a:	51 e0       	ldi	r21, 0x01	; 1
     36c:	6a e1       	ldi	r22, 0x1A	; 26
     36e:	72 e0       	ldi	r23, 0x02	; 2
     370:	88 e4       	ldi	r24, 0x48	; 72
     372:	92 e0       	ldi	r25, 0x02	; 2
     374:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     378:	ce 01       	movw	r24, r28
     37a:	05 96       	adiw	r24, 0x05	; 5
     37c:	7c 01       	movw	r14, r24
     37e:	03 e0       	ldi	r16, 0x03	; 3
     380:	20 e0       	ldi	r18, 0x00	; 0
     382:	30 e0       	ldi	r19, 0x00	; 0
     384:	47 e8       	ldi	r20, 0x87	; 135
     386:	50 e0       	ldi	r21, 0x00	; 0
     388:	63 e2       	ldi	r22, 0x23	; 35
     38a:	72 e0       	ldi	r23, 0x02	; 2
     38c:	84 ed       	ldi	r24, 0xD4	; 212
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     394:	ce 01       	movw	r24, r28
     396:	03 96       	adiw	r24, 0x03	; 3
     398:	7c 01       	movw	r14, r24
     39a:	01 e0       	ldi	r16, 0x01	; 1
     39c:	20 e0       	ldi	r18, 0x00	; 0
     39e:	30 e0       	ldi	r19, 0x00	; 0
     3a0:	47 e8       	ldi	r20, 0x87	; 135
     3a2:	50 e0       	ldi	r21, 0x00	; 0
     3a4:	6f e2       	ldi	r22, 0x2F	; 47
     3a6:	72 e0       	ldi	r23, 0x02	; 2
     3a8:	81 ef       	ldi	r24, 0xF1	; 241
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3b0:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <vTaskStartScheduler>
     3b4:	c1 cf       	rjmp	.-126    	; 0x338 <main+0x14>

000003b6 <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     3b6:	1f 93       	push	r17
     3b8:	cf 93       	push	r28
     3ba:	df 93       	push	r29
     3bc:	00 d0       	rcall	.+0      	; 0x3be <obstacleSend+0x8>
     3be:	1f 92       	push	r1
     3c0:	1f 92       	push	r1
     3c2:	cd b7       	in	r28, 0x3d	; 61
     3c4:	de b7       	in	r29, 0x3e	; 62
     3c6:	18 2f       	mov	r17, r24
     3c8:	cb 01       	movw	r24, r22
	obstacleData queueData;
	
	
	
	if(deviceBlocked)
     3ca:	11 23       	and	r17, r17
     3cc:	99 f0       	breq	.+38     	; 0x3f4 <obstacleSend+0x3e>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     3ce:	4a e0       	ldi	r20, 0x0A	; 10
     3d0:	be 01       	movw	r22, r28
     3d2:	6e 5f       	subi	r22, 0xFE	; 254
     3d4:	7f 4f       	sbci	r23, 0xFF	; 255
     3d6:	0e 94 24 17 	call	0x2e48	; 0x2e48 <__itoa_ncheck>
	{
		itoa(reading, queueData.data, 10); // convert to ascii
		
		queueData.deviceID = deviceBlocked;
     3da:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &queueData, portMAX_DELAY); // send data to queueData
     3dc:	20 e0       	ldi	r18, 0x00	; 0
     3de:	4f ef       	ldi	r20, 0xFF	; 255
     3e0:	5f ef       	ldi	r21, 0xFF	; 255
     3e2:	be 01       	movw	r22, r28
     3e4:	6f 5f       	subi	r22, 0xFF	; 255
     3e6:	7f 4f       	sbci	r23, 0xFF	; 255
     3e8:	80 91 93 08 	lds	r24, 0x0893
     3ec:	90 91 94 08 	lds	r25, 0x0894
     3f0:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <xQueueGenericSend>
	}
}
     3f4:	0f 90       	pop	r0
     3f6:	0f 90       	pop	r0
     3f8:	0f 90       	pop	r0
     3fa:	0f 90       	pop	r0
     3fc:	0f 90       	pop	r0
     3fe:	df 91       	pop	r29
     400:	cf 91       	pop	r28
     402:	1f 91       	pop	r17
     404:	08 95       	ret

00000406 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     406:	6f 92       	push	r6
     408:	7f 92       	push	r7
     40a:	8f 92       	push	r8
     40c:	9f 92       	push	r9
     40e:	af 92       	push	r10
     410:	bf 92       	push	r11
     412:	cf 92       	push	r12
     414:	df 92       	push	r13
     416:	ef 92       	push	r14
     418:	ff 92       	push	r15
     41a:	0f 93       	push	r16
     41c:	1f 93       	push	r17
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	1f 92       	push	r1
     424:	cd b7       	in	r28, 0x3d	; 61
     426:	de b7       	in	r29, 0x3e	; 62
     428:	89 83       	std	Y+1, r24	; 0x01
     42a:	5b 01       	movw	r10, r22
     42c:	3a 01       	movw	r6, r20
     42e:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     430:	20 e0       	ldi	r18, 0x00	; 0
     432:	4f ef       	ldi	r20, 0xFF	; 255
     434:	5f ef       	ldi	r21, 0xFF	; 255
     436:	be 01       	movw	r22, r28
     438:	6f 5f       	subi	r22, 0xFF	; 255
     43a:	7f 4f       	sbci	r23, 0xFF	; 255
     43c:	80 91 91 08 	lds	r24, 0x0891
     440:	90 91 92 08 	lds	r25, 0x0892
     444:	0e 94 ee 0b 	call	0x17dc	; 0x17dc <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     448:	b3 01       	movw	r22, r6
     44a:	f5 01       	movw	r30, r10
     44c:	80 81       	ld	r24, Z
     44e:	b3 df       	rcall	.-154    	; 0x3b6 <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     450:	b4 01       	movw	r22, r8
     452:	f5 01       	movw	r30, r10
     454:	81 81       	ldd	r24, Z+1	; 0x01
     456:	af df       	rcall	.-162    	; 0x3b6 <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     458:	b8 01       	movw	r22, r16
     45a:	f5 01       	movw	r30, r10
     45c:	82 81       	ldd	r24, Z+2	; 0x02
     45e:	ab df       	rcall	.-170    	; 0x3b6 <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     460:	b7 01       	movw	r22, r14
     462:	f5 01       	movw	r30, r10
     464:	83 81       	ldd	r24, Z+3	; 0x03
     466:	a7 df       	rcall	.-178    	; 0x3b6 <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     468:	b6 01       	movw	r22, r12
     46a:	f5 01       	movw	r30, r10
     46c:	84 81       	ldd	r24, Z+4	; 0x04
     46e:	a3 df       	rcall	.-186    	; 0x3b6 <obstacleSend>
		
	}
}
     470:	0f 90       	pop	r0
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	1f 91       	pop	r17
     478:	0f 91       	pop	r16
     47a:	ff 90       	pop	r15
     47c:	ef 90       	pop	r14
     47e:	df 90       	pop	r13
     480:	cf 90       	pop	r12
     482:	bf 90       	pop	r11
     484:	af 90       	pop	r10
     486:	9f 90       	pop	r9
     488:	8f 90       	pop	r8
     48a:	7f 90       	pop	r7
     48c:	6f 90       	pop	r6
     48e:	08 95       	ret

00000490 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     490:	cf 93       	push	r28
     492:	df 93       	push	r29
     494:	cd b7       	in	r28, 0x3d	; 61
     496:	de b7       	in	r29, 0x3e	; 62
     498:	ac 97       	sbiw	r28, 0x2c	; 44
     49a:	0f b6       	in	r0, 0x3f	; 63
     49c:	f8 94       	cli
     49e:	de bf       	out	0x3e, r29	; 62
     4a0:	0f be       	out	0x3f, r0	; 63
     4a2:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     4a4:	1b 82       	std	Y+3, r1	; 0x03
	int prevTopSonar = 0, prevFrontSonar = 0, prevLeftSonar = 0, prevRightSonar = 0;
     4a6:	1d 82       	std	Y+5, r1	; 0x05
     4a8:	1c 82       	std	Y+4, r1	; 0x04
     4aa:	1f 82       	std	Y+7, r1	; 0x07
     4ac:	1e 82       	std	Y+6, r1	; 0x06
     4ae:	19 86       	std	Y+9, r1	; 0x09
     4b0:	18 86       	std	Y+8, r1	; 0x08
     4b2:	1b 86       	std	Y+11, r1	; 0x0b
     4b4:	1a 86       	std	Y+10, r1	; 0x0a
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[3] = {999,999,999}, frontSonarSample[3] = {999,999,999}, leftSonarSample[3] = {999,999,999}, rightSonarSample[3] = {999,999,999};
     4b6:	86 e0       	ldi	r24, 0x06	; 6
     4b8:	e6 e0       	ldi	r30, 0x06	; 6
     4ba:	f2 e0       	ldi	r31, 0x02	; 2
     4bc:	de 01       	movw	r26, r28
     4be:	1c 96       	adiw	r26, 0x0c	; 12
     4c0:	01 90       	ld	r0, Z+
     4c2:	0d 92       	st	X+, r0
     4c4:	8a 95       	dec	r24
     4c6:	e1 f7       	brne	.-8      	; 0x4c0 <Sonar_Task+0x30>
     4c8:	86 e0       	ldi	r24, 0x06	; 6
     4ca:	e6 e0       	ldi	r30, 0x06	; 6
     4cc:	f2 e0       	ldi	r31, 0x02	; 2
     4ce:	de 01       	movw	r26, r28
     4d0:	52 96       	adiw	r26, 0x12	; 18
     4d2:	01 90       	ld	r0, Z+
     4d4:	0d 92       	st	X+, r0
     4d6:	8a 95       	dec	r24
     4d8:	e1 f7       	brne	.-8      	; 0x4d2 <Sonar_Task+0x42>
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	e6 e0       	ldi	r30, 0x06	; 6
     4de:	f2 e0       	ldi	r31, 0x02	; 2
     4e0:	de 01       	movw	r26, r28
     4e2:	58 96       	adiw	r26, 0x18	; 24
     4e4:	01 90       	ld	r0, Z+
     4e6:	0d 92       	st	X+, r0
     4e8:	8a 95       	dec	r24
     4ea:	e1 f7       	brne	.-8      	; 0x4e4 <Sonar_Task+0x54>
     4ec:	86 e0       	ldi	r24, 0x06	; 6
     4ee:	e6 e0       	ldi	r30, 0x06	; 6
     4f0:	f2 e0       	ldi	r31, 0x02	; 2
     4f2:	de 01       	movw	r26, r28
     4f4:	5e 96       	adiw	r26, 0x1e	; 30
     4f6:	01 90       	ld	r0, Z+
     4f8:	0d 92       	st	X+, r0
     4fa:	8a 95       	dec	r24
     4fc:	e1 f7       	brne	.-8      	; 0x4f6 <Sonar_Task+0x66>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     4fe:	fe 01       	movw	r30, r28
     500:	b4 96       	adiw	r30, 0x24	; 36
     502:	85 e0       	ldi	r24, 0x05	; 5
     504:	df 01       	movw	r26, r30
     506:	1d 92       	st	X+, r1
     508:	8a 95       	dec	r24
     50a:	e9 f7       	brne	.-6      	; 0x506 <Sonar_Task+0x76>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     50c:	84 e2       	ldi	r24, 0x24	; 36
     50e:	a1 d3       	rcall	.+1858   	; 0xc52 <mySharpIR_Read>
     510:	9a a7       	std	Y+42, r25	; 0x2a
     512:	89 a7       	std	Y+41, r24	; 0x29
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     514:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <xTaskGetTickCount>
     518:	9a 83       	std	Y+2, r25	; 0x02
     51a:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     51c:	d2 d1       	rcall	.+932    	; 0x8c2 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), &prevTopSonar, topSonarSample, 3);
     51e:	83 e2       	ldi	r24, 0x23	; 35
     520:	2f d2       	rcall	.+1118   	; 0x980 <myMaxSonar_Read>
     522:	23 e0       	ldi	r18, 0x03	; 3
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	ae 01       	movw	r20, r28
     528:	44 5f       	subi	r20, 0xF4	; 244
     52a:	5f 4f       	sbci	r21, 0xFF	; 255
     52c:	be 01       	movw	r22, r28
     52e:	6c 5f       	subi	r22, 0xFC	; 252
     530:	7f 4f       	sbci	r23, 0xFF	; 255
     532:	15 d2       	rcall	.+1066   	; 0x95e <myMaxSonar_getFilteredReading>
     534:	9c a7       	std	Y+44, r25	; 0x2c
     536:	8b a7       	std	Y+43, r24	; 0x2b
		
		myMaxSonar_BtmStart();
     538:	be d1       	rcall	.+892    	; 0x8b6 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), &prevFrontSonar, frontSonarSample, 3);
     53a:	87 e2       	ldi	r24, 0x27	; 39
     53c:	21 d2       	rcall	.+1090   	; 0x980 <myMaxSonar_Read>
     53e:	23 e0       	ldi	r18, 0x03	; 3
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	ae 01       	movw	r20, r28
     544:	4e 5e       	subi	r20, 0xEE	; 238
     546:	5f 4f       	sbci	r21, 0xFF	; 255
     548:	be 01       	movw	r22, r28
     54a:	6a 5f       	subi	r22, 0xFA	; 250
     54c:	7f 4f       	sbci	r23, 0xFF	; 255
     54e:	07 d2       	rcall	.+1038   	; 0x95e <myMaxSonar_getFilteredReading>
     550:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), &prevLeftSonar, leftSonarSample, 3);
     552:	86 e2       	ldi	r24, 0x26	; 38
     554:	15 d2       	rcall	.+1066   	; 0x980 <myMaxSonar_Read>
     556:	23 e0       	ldi	r18, 0x03	; 3
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	ae 01       	movw	r20, r28
     55c:	48 5e       	subi	r20, 0xE8	; 232
     55e:	5f 4f       	sbci	r21, 0xFF	; 255
     560:	be 01       	movw	r22, r28
     562:	68 5f       	subi	r22, 0xF8	; 248
     564:	7f 4f       	sbci	r23, 0xFF	; 255
     566:	fb d1       	rcall	.+1014   	; 0x95e <myMaxSonar_getFilteredReading>
     568:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), &prevRightSonar, rightSonarSample, 3); 
     56a:	85 e2       	ldi	r24, 0x25	; 37
     56c:	09 d2       	rcall	.+1042   	; 0x980 <myMaxSonar_Read>
     56e:	23 e0       	ldi	r18, 0x03	; 3
     570:	30 e0       	ldi	r19, 0x00	; 0
     572:	ae 01       	movw	r20, r28
     574:	42 5e       	subi	r20, 0xE2	; 226
     576:	5f 4f       	sbci	r21, 0xFF	; 255
     578:	be 01       	movw	r22, r28
     57a:	66 5f       	subi	r22, 0xF6	; 246
     57c:	7f 4f       	sbci	r23, 0xFF	; 255
     57e:	ef d1       	rcall	.+990    	; 0x95e <myMaxSonar_getFilteredReading>
     580:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     582:	84 e2       	ldi	r24, 0x24	; 36
     584:	66 d3       	rcall	.+1740   	; 0xc52 <mySharpIR_Read>
     586:	4c 01       	movw	r8, r24
		//frontSonar = myMaxSonar_Stabilizer(frontSonar, &prevFrontSonar);
		//leftSonar = myMaxSonar_Stabilizer(leftSonar, &prevLeftSonar);
		//rightSonar = myMaxSonar_Stabilizer(rightSonar, &prevRightSonar);
		
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     588:	bc 01       	movw	r22, r24
     58a:	ce 01       	movw	r24, r28
     58c:	89 96       	adiw	r24, 0x29	; 41
     58e:	9a d3       	rcall	.+1844   	; 0xcc4 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     590:	c9 a4       	ldd	r12, Y+41	; 0x29
     592:	da a4       	ldd	r13, Y+42	; 0x2a
     594:	54 01       	movw	r10, r8
     596:	eb a4       	ldd	r14, Y+43	; 0x2b
     598:	fc a4       	ldd	r15, Y+44	; 0x2c
     59a:	82 01       	movw	r16, r4
     59c:	91 01       	movw	r18, r2
     59e:	ae 01       	movw	r20, r28
     5a0:	4c 5d       	subi	r20, 0xDC	; 220
     5a2:	5f 4f       	sbci	r21, 0xFF	; 255
     5a4:	6b 81       	ldd	r22, Y+3	; 0x03
     5a6:	c3 01       	movw	r24, r6
     5a8:	24 d3       	rcall	.+1608   	; 0xbf2 <obstacleDetection>
     5aa:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5ac:	8e 01       	movw	r16, r28
     5ae:	0c 5d       	subi	r16, 0xDC	; 220
     5b0:	1f 4f       	sbci	r17, 0xFF	; 255
     5b2:	94 01       	movw	r18, r8
     5b4:	a2 01       	movw	r20, r4
     5b6:	b1 01       	movw	r22, r2
     5b8:	c3 01       	movw	r24, r6
     5ba:	a5 d2       	rcall	.+1354   	; 0xb06 <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5bc:	be 01       	movw	r22, r28
     5be:	6d 5f       	subi	r22, 0xFD	; 253
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	c8 01       	movw	r24, r16
     5c4:	07 d3       	rcall	.+1550   	; 0xbd4 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5c6:	cb a4       	ldd	r12, Y+43	; 0x2b
     5c8:	dc a4       	ldd	r13, Y+44	; 0x2c
     5ca:	74 01       	movw	r14, r8
     5cc:	82 01       	movw	r16, r4
     5ce:	91 01       	movw	r18, r2
     5d0:	a3 01       	movw	r20, r6
     5d2:	be 01       	movw	r22, r28
     5d4:	6c 5d       	subi	r22, 0xDC	; 220
     5d6:	7f 4f       	sbci	r23, 0xFF	; 255
     5d8:	8b 81       	ldd	r24, Y+3	; 0x03
     5da:	15 df       	rcall	.-470    	; 0x406 <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     5dc:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     5de:	18 a6       	std	Y+40, r1	; 0x28
     5e0:	1f a2       	std	Y+39, r1	; 0x27
     5e2:	1e a2       	std	Y+38, r1	; 0x26
     5e4:	1d a2       	std	Y+37, r1	; 0x25
     5e6:	1c a2       	std	Y+36, r1	; 0x24
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     5e8:	66 e9       	ldi	r22, 0x96	; 150
     5ea:	70 e0       	ldi	r23, 0x00	; 0
     5ec:	ce 01       	movw	r24, r28
     5ee:	01 96       	adiw	r24, 0x01	; 1
     5f0:	0e 94 15 11 	call	0x222a	; 0x222a <vTaskDelayUntil>
     5f4:	93 cf       	rjmp	.-218    	; 0x51c <Sonar_Task+0x8c>

000005f6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5f6:	cf 93       	push	r28
     5f8:	df 93       	push	r29
     5fa:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5fc:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     600:	80 91 3e 02 	lds	r24, 0x023E
     604:	90 91 3f 02 	lds	r25, 0x023F
     608:	89 2b       	or	r24, r25
     60a:	31 f4       	brne	.+12     	; 0x618 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     60c:	83 e4       	ldi	r24, 0x43	; 67
     60e:	92 e0       	ldi	r25, 0x02	; 2
     610:	90 93 3f 02 	sts	0x023F, r25
     614:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     618:	40 91 40 02 	lds	r20, 0x0240
     61c:	50 91 41 02 	lds	r21, 0x0241
     620:	9e 01       	movw	r18, r28
     622:	24 0f       	add	r18, r20
     624:	35 1f       	adc	r19, r21
     626:	2b 3d       	cpi	r18, 0xDB	; 219
     628:	85 e0       	ldi	r24, 0x05	; 5
     62a:	38 07       	cpc	r19, r24
     62c:	70 f4       	brcc	.+28     	; 0x64a <pvPortMalloc+0x54>
     62e:	42 17       	cp	r20, r18
     630:	53 07       	cpc	r21, r19
     632:	70 f4       	brcc	.+28     	; 0x650 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     634:	c0 91 3e 02 	lds	r28, 0x023E
     638:	d0 91 3f 02 	lds	r29, 0x023F
     63c:	c4 0f       	add	r28, r20
     63e:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     640:	30 93 41 02 	sts	0x0241, r19
     644:	20 93 40 02 	sts	0x0240, r18
     648:	05 c0       	rjmp	.+10     	; 0x654 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     64a:	c0 e0       	ldi	r28, 0x00	; 0
     64c:	d0 e0       	ldi	r29, 0x00	; 0
     64e:	02 c0       	rjmp	.+4      	; 0x654 <pvPortMalloc+0x5e>
     650:	c0 e0       	ldi	r28, 0x00	; 0
     652:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     654:	0e 94 94 10 	call	0x2128	; 0x2128 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     658:	ce 01       	movw	r24, r28
     65a:	df 91       	pop	r29
     65c:	cf 91       	pop	r28
     65e:	08 95       	ret

00000660 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     660:	08 95       	ret

00000662 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     662:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     664:	03 96       	adiw	r24, 0x03	; 3
     666:	92 83       	std	Z+2, r25	; 0x02
     668:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     66a:	2f ef       	ldi	r18, 0xFF	; 255
     66c:	3f ef       	ldi	r19, 0xFF	; 255
     66e:	34 83       	std	Z+4, r19	; 0x04
     670:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     672:	96 83       	std	Z+6, r25	; 0x06
     674:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     676:	90 87       	std	Z+8, r25	; 0x08
     678:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     67a:	10 82       	st	Z, r1
     67c:	08 95       	ret

0000067e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     67e:	fc 01       	movw	r30, r24
     680:	11 86       	std	Z+9, r1	; 0x09
     682:	10 86       	std	Z+8, r1	; 0x08
     684:	08 95       	ret

00000686 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	9c 01       	movw	r18, r24
     68c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     68e:	dc 01       	movw	r26, r24
     690:	11 96       	adiw	r26, 0x01	; 1
     692:	cd 91       	ld	r28, X+
     694:	dc 91       	ld	r29, X
     696:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     698:	d3 83       	std	Z+3, r29	; 0x03
     69a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     69c:	8c 81       	ldd	r24, Y+4	; 0x04
     69e:	9d 81       	ldd	r25, Y+5	; 0x05
     6a0:	95 83       	std	Z+5, r25	; 0x05
     6a2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6a4:	8c 81       	ldd	r24, Y+4	; 0x04
     6a6:	9d 81       	ldd	r25, Y+5	; 0x05
     6a8:	dc 01       	movw	r26, r24
     6aa:	13 96       	adiw	r26, 0x03	; 3
     6ac:	7c 93       	st	X, r23
     6ae:	6e 93       	st	-X, r22
     6b0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6b2:	7d 83       	std	Y+5, r23	; 0x05
     6b4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6b6:	31 87       	std	Z+9, r19	; 0x09
     6b8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6ba:	f9 01       	movw	r30, r18
     6bc:	80 81       	ld	r24, Z
     6be:	8f 5f       	subi	r24, 0xFF	; 255
     6c0:	80 83       	st	Z, r24
}
     6c2:	df 91       	pop	r29
     6c4:	cf 91       	pop	r28
     6c6:	08 95       	ret

000006c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6c8:	cf 93       	push	r28
     6ca:	df 93       	push	r29
     6cc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6ce:	48 81       	ld	r20, Y
     6d0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6d2:	4f 3f       	cpi	r20, 0xFF	; 255
     6d4:	2f ef       	ldi	r18, 0xFF	; 255
     6d6:	52 07       	cpc	r21, r18
     6d8:	21 f4       	brne	.+8      	; 0x6e2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6da:	fc 01       	movw	r30, r24
     6dc:	a7 81       	ldd	r26, Z+7	; 0x07
     6de:	b0 85       	ldd	r27, Z+8	; 0x08
     6e0:	0d c0       	rjmp	.+26     	; 0x6fc <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e2:	dc 01       	movw	r26, r24
     6e4:	13 96       	adiw	r26, 0x03	; 3
     6e6:	12 96       	adiw	r26, 0x02	; 2
     6e8:	ed 91       	ld	r30, X+
     6ea:	fc 91       	ld	r31, X
     6ec:	13 97       	sbiw	r26, 0x03	; 3
     6ee:	20 81       	ld	r18, Z
     6f0:	31 81       	ldd	r19, Z+1	; 0x01
     6f2:	42 17       	cp	r20, r18
     6f4:	53 07       	cpc	r21, r19
     6f6:	10 f0       	brcs	.+4      	; 0x6fc <vListInsert+0x34>
     6f8:	df 01       	movw	r26, r30
     6fa:	f5 cf       	rjmp	.-22     	; 0x6e6 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6fc:	12 96       	adiw	r26, 0x02	; 2
     6fe:	ed 91       	ld	r30, X+
     700:	fc 91       	ld	r31, X
     702:	13 97       	sbiw	r26, 0x03	; 3
     704:	fb 83       	std	Y+3, r31	; 0x03
     706:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     708:	d5 83       	std	Z+5, r29	; 0x05
     70a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     70c:	bd 83       	std	Y+5, r27	; 0x05
     70e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     710:	13 96       	adiw	r26, 0x03	; 3
     712:	dc 93       	st	X, r29
     714:	ce 93       	st	-X, r28
     716:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     718:	99 87       	std	Y+9, r25	; 0x09
     71a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     71c:	fc 01       	movw	r30, r24
     71e:	20 81       	ld	r18, Z
     720:	2f 5f       	subi	r18, 0xFF	; 255
     722:	20 83       	st	Z, r18
}
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	08 95       	ret

0000072a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     730:	a0 85       	ldd	r26, Z+8	; 0x08
     732:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     734:	c2 81       	ldd	r28, Z+2	; 0x02
     736:	d3 81       	ldd	r29, Z+3	; 0x03
     738:	84 81       	ldd	r24, Z+4	; 0x04
     73a:	95 81       	ldd	r25, Z+5	; 0x05
     73c:	9d 83       	std	Y+5, r25	; 0x05
     73e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     740:	c4 81       	ldd	r28, Z+4	; 0x04
     742:	d5 81       	ldd	r29, Z+5	; 0x05
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9b 83       	std	Y+3, r25	; 0x03
     74a:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     74c:	11 96       	adiw	r26, 0x01	; 1
     74e:	cd 91       	ld	r28, X+
     750:	dc 91       	ld	r29, X
     752:	12 97       	sbiw	r26, 0x02	; 2
     754:	ce 17       	cp	r28, r30
     756:	df 07       	cpc	r29, r31
     758:	31 f4       	brne	.+12     	; 0x766 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     75a:	8c 81       	ldd	r24, Y+4	; 0x04
     75c:	9d 81       	ldd	r25, Y+5	; 0x05
     75e:	12 96       	adiw	r26, 0x02	; 2
     760:	9c 93       	st	X, r25
     762:	8e 93       	st	-X, r24
     764:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     766:	11 86       	std	Z+9, r1	; 0x09
     768:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     76a:	8c 91       	ld	r24, X
     76c:	81 50       	subi	r24, 0x01	; 1
     76e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	08 95       	ret

00000776 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     776:	1f 92       	push	r1
     778:	0f 92       	push	r0
     77a:	0f b6       	in	r0, 0x3f	; 63
     77c:	0f 92       	push	r0
     77e:	11 24       	eor	r1, r1
     780:	0b b6       	in	r0, 0x3b	; 59
     782:	0f 92       	push	r0
     784:	2f 93       	push	r18
     786:	3f 93       	push	r19
     788:	4f 93       	push	r20
     78a:	5f 93       	push	r21
     78c:	6f 93       	push	r22
     78e:	7f 93       	push	r23
     790:	8f 93       	push	r24
     792:	9f 93       	push	r25
     794:	af 93       	push	r26
     796:	bf 93       	push	r27
     798:	ef 93       	push	r30
     79a:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     79c:	1b 9b       	sbis	0x03, 3	; 3
     79e:	0d c0       	rjmp	.+26     	; 0x7ba <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7a0:	0f d3       	rcall	.+1566   	; 0xdc0 <myTimer_Read>
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	90 93 9a 08 	sts	0x089A, r25
     7a8:	80 93 99 08 	sts	0x0899, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7ac:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <xTaskGetTickCountFromISR>
     7b0:	90 93 96 08 	sts	0x0896, r25
     7b4:	80 93 95 08 	sts	0x0895, r24
     7b8:	56 c0       	rjmp	.+172    	; 0x866 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7ba:	1b 99       	sbic	0x03, 3	; 3
     7bc:	54 c0       	rjmp	.+168    	; 0x866 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7be:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <xTaskGetTickCountFromISR>
     7c2:	90 93 a0 08 	sts	0x08A0, r25
     7c6:	80 93 9f 08 	sts	0x089F, r24
     7ca:	20 91 95 08 	lds	r18, 0x0895
     7ce:	30 91 96 08 	lds	r19, 0x0896
     7d2:	82 17       	cp	r24, r18
     7d4:	93 07       	cpc	r25, r19
     7d6:	4c f4       	brge	.+18     	; 0x7ea <__vector_9+0x74>
			ms_tickEnd += 65535;
     7d8:	80 91 9f 08 	lds	r24, 0x089F
     7dc:	90 91 a0 08 	lds	r25, 0x08A0
     7e0:	01 97       	sbiw	r24, 0x01	; 1
     7e2:	90 93 a0 08 	sts	0x08A0, r25
     7e6:	80 93 9f 08 	sts	0x089F, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     7ea:	ea d2       	rcall	.+1492   	; 0xdc0 <myTimer_Read>
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	90 93 a2 08 	sts	0x08A2, r25
     7f2:	80 93 a1 08 	sts	0x08A1, r24
     7f6:	20 91 99 08 	lds	r18, 0x0899
     7fa:	30 91 9a 08 	lds	r19, 0x089A
     7fe:	82 17       	cp	r24, r18
     800:	93 07       	cpc	r25, r19
     802:	54 f4       	brge	.+20     	; 0x818 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     804:	80 91 a1 08 	lds	r24, 0x08A1
     808:	90 91 a2 08 	lds	r25, 0x08A2
     80c:	86 50       	subi	r24, 0x06	; 6
     80e:	9f 4f       	sbci	r25, 0xFF	; 255
     810:	90 93 a2 08 	sts	0x08A2, r25
     814:	80 93 a1 08 	sts	0x08A1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     818:	80 91 a1 08 	lds	r24, 0x08A1
     81c:	90 91 a2 08 	lds	r25, 0x08A2
     820:	20 91 99 08 	lds	r18, 0x0899
     824:	30 91 9a 08 	lds	r19, 0x089A
     828:	82 1b       	sub	r24, r18
     82a:	93 0b       	sbc	r25, r19
     82c:	90 93 9c 08 	sts	0x089C, r25
     830:	80 93 9b 08 	sts	0x089B, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     834:	80 91 9f 08 	lds	r24, 0x089F
     838:	90 91 a0 08 	lds	r25, 0x08A0
     83c:	20 91 95 08 	lds	r18, 0x0895
     840:	30 91 96 08 	lds	r19, 0x0896
     844:	82 1b       	sub	r24, r18
     846:	93 0b       	sbc	r25, r19
     848:	90 93 98 08 	sts	0x0898, r25
     84c:	80 93 97 08 	sts	0x0897, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     850:	20 e0       	ldi	r18, 0x00	; 0
     852:	40 e0       	ldi	r20, 0x00	; 0
     854:	50 e0       	ldi	r21, 0x00	; 0
     856:	60 e0       	ldi	r22, 0x00	; 0
     858:	70 e0       	ldi	r23, 0x00	; 0
     85a:	80 91 9d 08 	lds	r24, 0x089D
     85e:	90 91 9e 08 	lds	r25, 0x089E
     862:	0e 94 ac 0c 	call	0x1958	; 0x1958 <xQueueGenericSendFromISR>
	}	
}
     866:	ff 91       	pop	r31
     868:	ef 91       	pop	r30
     86a:	bf 91       	pop	r27
     86c:	af 91       	pop	r26
     86e:	9f 91       	pop	r25
     870:	8f 91       	pop	r24
     872:	7f 91       	pop	r23
     874:	6f 91       	pop	r22
     876:	5f 91       	pop	r21
     878:	4f 91       	pop	r20
     87a:	3f 91       	pop	r19
     87c:	2f 91       	pop	r18
     87e:	0f 90       	pop	r0
     880:	0b be       	out	0x3b, r0	; 59
     882:	0f 90       	pop	r0
     884:	0f be       	out	0x3f, r0	; 63
     886:	0f 90       	pop	r0
     888:	1f 90       	pop	r1
     88a:	18 95       	reti

0000088c <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     88c:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     88e:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     890:	e8 e6       	ldi	r30, 0x68	; 104
     892:	f0 e0       	ldi	r31, 0x00	; 0
     894:	80 81       	ld	r24, Z
     896:	81 60       	ori	r24, 0x01	; 1
     898:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     89a:	eb e6       	ldi	r30, 0x6B	; 107
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	80 81       	ld	r24, Z
     8a0:	88 60       	ori	r24, 0x08	; 8
     8a2:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     8a4:	43 e0       	ldi	r20, 0x03	; 3
     8a6:	60 e0       	ldi	r22, 0x00	; 0
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	6b d7       	rcall	.+3798   	; 0x1782 <xQueueGenericCreate>
     8ac:	90 93 9e 08 	sts	0x089E, r25
     8b0:	80 93 9d 08 	sts	0x089D, r24
     8b4:	08 95       	ret

000008b6 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8b6:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8b8:	89 e1       	ldi	r24, 0x19	; 25
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	83 d2       	rcall	.+1286   	; 0xdc4 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8be:	a1 98       	cbi	0x14, 1	; 20
     8c0:	08 95       	ret

000008c2 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8c2:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8c4:	89 e1       	ldi	r24, 0x19	; 25
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	7d d2       	rcall	.+1274   	; 0xdc4 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8ca:	a0 98       	cbi	0x14, 0	; 20
     8cc:	08 95       	ret

000008ce <myMaxSonar_extractMedian>:
}

int myMaxSonar_extractMedian(int * sample)
{
     8ce:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8d0:	80 81       	ld	r24, Z
     8d2:	91 81       	ldd	r25, Z+1	; 0x01
     8d4:	22 81       	ldd	r18, Z+2	; 0x02
     8d6:	33 81       	ldd	r19, Z+3	; 0x03
     8d8:	28 17       	cp	r18, r24
     8da:	39 07       	cpc	r19, r25
     8dc:	54 f4       	brge	.+20     	; 0x8f2 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8de:	44 81       	ldd	r20, Z+4	; 0x04
     8e0:	55 81       	ldd	r21, Z+5	; 0x05
     8e2:	42 17       	cp	r20, r18
     8e4:	53 07       	cpc	r21, r19
     8e6:	84 f0       	brlt	.+32     	; 0x908 <myMaxSonar_extractMedian+0x3a>
     8e8:	48 17       	cp	r20, r24
     8ea:	59 07       	cpc	r21, r25
     8ec:	74 f4       	brge	.+28     	; 0x90a <myMaxSonar_extractMedian+0x3c>
     8ee:	ca 01       	movw	r24, r20
     8f0:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8f2:	44 81       	ldd	r20, Z+4	; 0x04
     8f4:	55 81       	ldd	r21, Z+5	; 0x05
     8f6:	48 17       	cp	r20, r24
     8f8:	59 07       	cpc	r21, r25
     8fa:	3c f0       	brlt	.+14     	; 0x90a <myMaxSonar_extractMedian+0x3c>
     8fc:	ca 01       	movw	r24, r20
     8fe:	24 17       	cp	r18, r20
     900:	35 07       	cpc	r19, r21
     902:	1c f4       	brge	.+6      	; 0x90a <myMaxSonar_extractMedian+0x3c>
     904:	c9 01       	movw	r24, r18
     906:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     908:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     90a:	08 95       	ret

0000090c <myMaxSonar_AddSample>:

void myMaxSonar_AddSample(int currentReading ,int *sample, int sampleSize)
{
	static int i = 0; 
	
	sample[i] = currentReading;
     90c:	20 91 1e 08 	lds	r18, 0x081E
     910:	30 91 1f 08 	lds	r19, 0x081F
     914:	f9 01       	movw	r30, r18
     916:	ee 0f       	add	r30, r30
     918:	ff 1f       	adc	r31, r31
     91a:	e6 0f       	add	r30, r22
     91c:	f7 1f       	adc	r31, r23
     91e:	91 83       	std	Z+1, r25	; 0x01
     920:	80 83       	st	Z, r24
	i = (i+1) % sampleSize;
     922:	c9 01       	movw	r24, r18
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	ba 01       	movw	r22, r20
     928:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <__divmodhi4>
     92c:	90 93 1f 08 	sts	0x081F, r25
     930:	80 93 1e 08 	sts	0x081E, r24
     934:	08 95       	ret

00000936 <myMaxSonar_Stabilizer>:
}

int myMaxSonar_Stabilizer(const int currentReading, int* prevReading)
{
     936:	9c 01       	movw	r18, r24
	if(currentReading > (*prevReading + NOISE_RANGE) || currentReading < (*prevReading - NOISE_RANGE))
     938:	fb 01       	movw	r30, r22
     93a:	80 81       	ld	r24, Z
     93c:	91 81       	ldd	r25, Z+1	; 0x01
     93e:	ac 01       	movw	r20, r24
     940:	48 5f       	subi	r20, 0xF8	; 248
     942:	5f 4f       	sbci	r21, 0xFF	; 255
     944:	42 17       	cp	r20, r18
     946:	53 07       	cpc	r21, r19
     948:	2c f0       	brlt	.+10     	; 0x954 <myMaxSonar_Stabilizer+0x1e>
     94a:	40 51       	subi	r20, 0x10	; 16
     94c:	51 09       	sbc	r21, r1
     94e:	24 17       	cp	r18, r20
     950:	35 07       	cpc	r19, r21
     952:	24 f4       	brge	.+8      	; 0x95c <myMaxSonar_Stabilizer+0x26>
	{
		*prevReading = currentReading;
     954:	fb 01       	movw	r30, r22
     956:	31 83       	std	Z+1, r19	; 0x01
     958:	20 83       	st	Z, r18
		return currentReading; // when current reading exceed noise range.... return current reading
     95a:	c9 01       	movw	r24, r18
	}
	else
		return *prevReading; // return prevReading if in noise range..
}
     95c:	08 95       	ret

0000095e <myMaxSonar_getFilteredReading>:
	}
}


int myMaxSonar_getFilteredReading(int currentReading, int* prevReading, int *sample, int sampleSize)
{
     95e:	0f 93       	push	r16
     960:	1f 93       	push	r17
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	ea 01       	movw	r28, r20
     968:	89 01       	movw	r16, r18
	currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
     96a:	e5 df       	rcall	.-54     	; 0x936 <myMaxSonar_Stabilizer>
	myMaxSonar_AddSample(currentReading, sample, sampleSize);
     96c:	a8 01       	movw	r20, r16
     96e:	be 01       	movw	r22, r28
     970:	cd df       	rcall	.-102    	; 0x90c <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     972:	ce 01       	movw	r24, r28
     974:	ac df       	rcall	.-168    	; 0x8ce <myMaxSonar_extractMedian>

}
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	1f 91       	pop	r17
     97c:	0f 91       	pop	r16
     97e:	08 95       	ret

00000980 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     980:	ab d0       	rcall	.+342    	; 0xad8 <myADC_analogRead>
     982:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     984:	63 e0       	ldi	r22, 0x03	; 3
     986:	70 e0       	ldi	r23, 0x00	; 0
     988:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     98c:	cb 01       	movw	r24, r22
     98e:	82 0f       	add	r24, r18
     990:	93 1f       	adc	r25, r19
     992:	08 95       	ret

00000994 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     994:	1f 92       	push	r1
     996:	0f 92       	push	r0
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	0f 92       	push	r0
     99c:	11 24       	eor	r1, r1
     99e:	0b b6       	in	r0, 0x3b	; 59
     9a0:	0f 92       	push	r0
     9a2:	2f 93       	push	r18
     9a4:	3f 93       	push	r19
     9a6:	4f 93       	push	r20
     9a8:	5f 93       	push	r21
     9aa:	6f 93       	push	r22
     9ac:	7f 93       	push	r23
     9ae:	8f 93       	push	r24
     9b0:	9f 93       	push	r25
     9b2:	af 93       	push	r26
     9b4:	bf 93       	push	r27
     9b6:	ef 93       	push	r30
     9b8:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9ba:	80 91 78 00 	lds	r24, 0x0078
     9be:	80 93 a3 08 	sts	0x08A3, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9c2:	80 91 79 00 	lds	r24, 0x0079
     9c6:	80 93 a4 08 	sts	0x08A4, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9ca:	20 e0       	ldi	r18, 0x00	; 0
     9cc:	40 e0       	ldi	r20, 0x00	; 0
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	80 91 a7 08 	lds	r24, 0x08A7
     9d8:	90 91 a8 08 	lds	r25, 0x08A8
     9dc:	bd d7       	rcall	.+3962   	; 0x1958 <xQueueGenericSendFromISR>
}
     9de:	ff 91       	pop	r31
     9e0:	ef 91       	pop	r30
     9e2:	bf 91       	pop	r27
     9e4:	af 91       	pop	r26
     9e6:	9f 91       	pop	r25
     9e8:	8f 91       	pop	r24
     9ea:	7f 91       	pop	r23
     9ec:	6f 91       	pop	r22
     9ee:	5f 91       	pop	r21
     9f0:	4f 91       	pop	r20
     9f2:	3f 91       	pop	r19
     9f4:	2f 91       	pop	r18
     9f6:	0f 90       	pop	r0
     9f8:	0b be       	out	0x3b, r0	; 59
     9fa:	0f 90       	pop	r0
     9fc:	0f be       	out	0x3f, r0	; 63
     9fe:	0f 90       	pop	r0
     a00:	1f 90       	pop	r1
     a02:	18 95       	reti

00000a04 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a04:	8f e8       	ldi	r24, 0x8F	; 143
     a06:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a0a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a0e:	80 e4       	ldi	r24, 0x40	; 64
     a10:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a14:	43 e0       	ldi	r20, 0x03	; 3
     a16:	60 e0       	ldi	r22, 0x00	; 0
     a18:	81 e0       	ldi	r24, 0x01	; 1
     a1a:	b3 d6       	rcall	.+3430   	; 0x1782 <xQueueGenericCreate>
     a1c:	90 93 a8 08 	sts	0x08A8, r25
     a20:	80 93 a7 08 	sts	0x08A7, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	6d d7       	rcall	.+3802   	; 0x1902 <xQueueCreateMutex>
     a28:	90 93 a6 08 	sts	0x08A6, r25
     a2c:	80 93 a5 08 	sts	0x08A5, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	40 e0       	ldi	r20, 0x00	; 0
     a34:	50 e0       	ldi	r21, 0x00	; 0
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	70 e0       	ldi	r23, 0x00	; 0
     a3a:	d0 c6       	rjmp	.+3488   	; 0x17dc <xQueueGenericSend>
     a3c:	08 95       	ret

00000a3e <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a3e:	cf 93       	push	r28
     a40:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a42:	20 e0       	ldi	r18, 0x00	; 0
     a44:	4f ef       	ldi	r20, 0xFF	; 255
     a46:	5f ef       	ldi	r21, 0xFF	; 255
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	70 e0       	ldi	r23, 0x00	; 0
     a4c:	80 91 a5 08 	lds	r24, 0x08A5
     a50:	90 91 a6 08 	lds	r25, 0x08A6
     a54:	bb d7       	rcall	.+3958   	; 0x19cc <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a56:	ec e7       	ldi	r30, 0x7C	; 124
     a58:	f0 e0       	ldi	r31, 0x00	; 0
     a5a:	80 81       	ld	r24, Z
     a5c:	9c 2f       	mov	r25, r28
     a5e:	9f 71       	andi	r25, 0x1F	; 31
     a60:	80 76       	andi	r24, 0x60	; 96
     a62:	89 2b       	or	r24, r25
     a64:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a66:	eb e7       	ldi	r30, 0x7B	; 123
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	20 81       	ld	r18, Z
     a6c:	c0 72       	andi	r28, 0x20	; 32
     a6e:	8c 2f       	mov	r24, r28
     a70:	90 e0       	ldi	r25, 0x00	; 0
     a72:	95 95       	asr	r25
     a74:	87 95       	ror	r24
     a76:	95 95       	asr	r25
     a78:	87 95       	ror	r24
     a7a:	92 2f       	mov	r25, r18
     a7c:	90 76       	andi	r25, 0x60	; 96
     a7e:	89 2b       	or	r24, r25
     a80:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a82:	ea e7       	ldi	r30, 0x7A	; 122
     a84:	f0 e0       	ldi	r31, 0x00	; 0
     a86:	80 81       	ld	r24, Z
     a88:	80 64       	ori	r24, 0x40	; 64
     a8a:	80 83       	st	Z, r24
}
     a8c:	cf 91       	pop	r28
     a8e:	08 95       	ret

00000a90 <myADC_readADC>:

int myADC_readADC(char channel)
{
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a94:	20 e0       	ldi	r18, 0x00	; 0
     a96:	4f ef       	ldi	r20, 0xFF	; 255
     a98:	5f ef       	ldi	r21, 0xFF	; 255
     a9a:	60 e0       	ldi	r22, 0x00	; 0
     a9c:	70 e0       	ldi	r23, 0x00	; 0
     a9e:	80 91 a7 08 	lds	r24, 0x08A7
     aa2:	90 91 a8 08 	lds	r25, 0x08A8
     aa6:	92 d7       	rcall	.+3876   	; 0x19cc <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     aa8:	c0 91 a4 08 	lds	r28, 0x08A4
     aac:	c3 70       	andi	r28, 0x03	; 3
     aae:	d0 e0       	ldi	r29, 0x00	; 0
     ab0:	dc 2f       	mov	r29, r28
     ab2:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ab4:	80 91 a3 08 	lds	r24, 0x08A3
     ab8:	c8 0f       	add	r28, r24
     aba:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     abc:	20 e0       	ldi	r18, 0x00	; 0
     abe:	40 e0       	ldi	r20, 0x00	; 0
     ac0:	50 e0       	ldi	r21, 0x00	; 0
     ac2:	60 e0       	ldi	r22, 0x00	; 0
     ac4:	70 e0       	ldi	r23, 0x00	; 0
     ac6:	80 91 a5 08 	lds	r24, 0x08A5
     aca:	90 91 a6 08 	lds	r25, 0x08A6
     ace:	86 d6       	rcall	.+3340   	; 0x17dc <xQueueGenericSend>
	
	return adcReading;
     ad0:	ce 01       	movw	r24, r28
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
     ad6:	08 95       	ret

00000ad8 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     ad8:	cf 93       	push	r28
     ada:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     adc:	b0 df       	rcall	.-160    	; 0xa3e <myADC_startADC>
	return myADC_readADC(channel);
     ade:	8c 2f       	mov	r24, r28
     ae0:	d7 df       	rcall	.-82     	; 0xa90 <myADC_readADC>
}
     ae2:	cf 91       	pop	r28
     ae4:	08 95       	ret

00000ae6 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     ae6:	9c 01       	movw	r18, r24
     ae8:	24 5f       	subi	r18, 0xF4	; 244
     aea:	3f 4f       	sbci	r19, 0xFF	; 255
     aec:	26 17       	cp	r18, r22
     aee:	37 07       	cpc	r19, r23
     af0:	44 f0       	brlt	.+16     	; 0xb02 <detectStairs+0x1c>
     af2:	28 51       	subi	r18, 0x18	; 24
     af4:	31 09       	sbc	r19, r1
     af6:	81 e0       	ldi	r24, 0x01	; 1
     af8:	62 17       	cp	r22, r18
     afa:	73 07       	cpc	r23, r19
     afc:	1c f0       	brlt	.+6      	; 0xb04 <detectStairs+0x1e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	08 95       	ret
	{
		return 1; // stairs found
     b02:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b04:	08 95       	ret

00000b06 <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b06:	0f 93       	push	r16
     b08:	1f 93       	push	r17
     b0a:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     b0c:	83 81       	ldd	r24, Z+3	; 0x03
     b0e:	88 23       	and	r24, r24
     b10:	39 f0       	breq	.+14     	; 0xb20 <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b12:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b14:	e2 e0       	ldi	r30, 0x02	; 2
     b16:	f1 e0       	ldi	r31, 0x01	; 1
     b18:	80 81       	ld	r24, Z
     b1a:	80 61       	ori	r24, 0x10	; 16
     b1c:	80 83       	st	Z, r24
     b1e:	57 c0       	rjmp	.+174    	; 0xbce <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b20:	80 81       	ld	r24, Z
     b22:	88 23       	and	r24, r24
     b24:	b1 f1       	breq	.+108    	; 0xb92 <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b26:	81 81       	ldd	r24, Z+1	; 0x01
     b28:	81 11       	cpse	r24, r1
     b2a:	18 c0       	rjmp	.+48     	; 0xb5c <obstacleAvoidance+0x56>
     b2c:	82 81       	ldd	r24, Z+2	; 0x02
     b2e:	81 11       	cpse	r24, r1
     b30:	24 c0       	rjmp	.+72     	; 0xb7a <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar + 14) // if right sonar greater than....
     b32:	cb 01       	movw	r24, r22
     b34:	0e 96       	adiw	r24, 0x0e	; 14
     b36:	84 17       	cp	r24, r20
     b38:	95 07       	cpc	r25, r21
     b3a:	3c f4       	brge	.+14     	; 0xb4a <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b3c:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b3e:	a2 e0       	ldi	r26, 0x02	; 2
     b40:	b1 e0       	ldi	r27, 0x01	; 1
     b42:	8c 91       	ld	r24, X
     b44:	80 61       	ori	r24, 0x10	; 16
     b46:	8c 93       	st	X, r24
     b48:	06 c0       	rjmp	.+12     	; 0xb56 <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b4a:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b4c:	a2 e0       	ldi	r26, 0x02	; 2
     b4e:	b1 e0       	ldi	r27, 0x01	; 1
     b50:	8c 91       	ld	r24, X
     b52:	8f 7e       	andi	r24, 0xEF	; 239
     b54:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b56:	81 81       	ldd	r24, Z+1	; 0x01
     b58:	88 23       	and	r24, r24
     b5a:	b1 f1       	breq	.+108    	; 0xbc8 <obstacleAvoidance+0xc2>
     b5c:	82 81       	ldd	r24, Z+2	; 0x02
     b5e:	81 11       	cpse	r24, r1
     b60:	36 c0       	rjmp	.+108    	; 0xbce <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b62:	46 1b       	sub	r20, r22
     b64:	57 0b       	sbc	r21, r23
     b66:	49 30       	cpi	r20, 0x09	; 9
     b68:	51 05       	cpc	r21, r1
     b6a:	8c f1       	brlt	.+98     	; 0xbce <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     b6c:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     b6e:	e2 e0       	ldi	r30, 0x02	; 2
     b70:	f1 e0       	ldi	r31, 0x01	; 1
     b72:	80 81       	ld	r24, Z
     b74:	80 61       	ori	r24, 0x10	; 16
     b76:	80 83       	st	Z, r24
     b78:	2a c0       	rjmp	.+84     	; 0xbce <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     b7a:	64 1b       	sub	r22, r20
     b7c:	75 0b       	sbc	r23, r21
     b7e:	69 30       	cpi	r22, 0x09	; 9
     b80:	71 05       	cpc	r23, r1
     b82:	2c f1       	brlt	.+74     	; 0xbce <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     b84:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     b86:	e2 e0       	ldi	r30, 0x02	; 2
     b88:	f1 e0       	ldi	r31, 0x01	; 1
     b8a:	80 81       	ld	r24, Z
     b8c:	8f 7e       	andi	r24, 0xEF	; 239
     b8e:	80 83       	st	Z, r24
     b90:	1e c0       	rjmp	.+60     	; 0xbce <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     b92:	66 32       	cpi	r22, 0x26	; 38
     b94:	71 05       	cpc	r23, r1
     b96:	3c f4       	brge	.+14     	; 0xba6 <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     b98:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     b9a:	e2 e0       	ldi	r30, 0x02	; 2
     b9c:	f1 e0       	ldi	r31, 0x01	; 1
     b9e:	80 81       	ld	r24, Z
     ba0:	80 61       	ori	r24, 0x10	; 16
     ba2:	80 83       	st	Z, r24
     ba4:	14 c0       	rjmp	.+40     	; 0xbce <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     ba6:	44 31       	cpi	r20, 0x14	; 20
     ba8:	51 05       	cpc	r21, r1
     baa:	3c f4       	brge	.+14     	; 0xbba <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     bac:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bae:	e2 e0       	ldi	r30, 0x02	; 2
     bb0:	f1 e0       	ldi	r31, 0x01	; 1
     bb2:	80 81       	ld	r24, Z
     bb4:	8f 7e       	andi	r24, 0xEF	; 239
     bb6:	80 83       	st	Z, r24
     bb8:	0a c0       	rjmp	.+20     	; 0xbce <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     bba:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bbc:	e2 e0       	ldi	r30, 0x02	; 2
     bbe:	f1 e0       	ldi	r31, 0x01	; 1
     bc0:	80 81       	ld	r24, Z
     bc2:	8f 7e       	andi	r24, 0xEF	; 239
     bc4:	80 83       	st	Z, r24
     bc6:	03 c0       	rjmp	.+6      	; 0xbce <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     bc8:	82 81       	ldd	r24, Z+2	; 0x02
     bca:	81 11       	cpse	r24, r1
     bcc:	d6 cf       	rjmp	.-84     	; 0xb7a <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     bce:	1f 91       	pop	r17
     bd0:	0f 91       	pop	r16
     bd2:	08 95       	ret

00000bd4 <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     bd4:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     bd6:	85 e0       	ldi	r24, 0x05	; 5
     bd8:	db 01       	movw	r26, r22
     bda:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     bdc:	86 e4       	ldi	r24, 0x46	; 70
     bde:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     be0:	8c e4       	ldi	r24, 0x4C	; 76
     be2:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     be4:	82 e5       	ldi	r24, 0x52	; 82
     be6:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     be8:	82 e4       	ldi	r24, 0x42	; 66
     bea:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     bec:	84 e5       	ldi	r24, 0x54	; 84
     bee:	84 83       	std	Z+4, r24	; 0x04
     bf0:	08 95       	ret

00000bf2 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     bf2:	af 92       	push	r10
     bf4:	bf 92       	push	r11
     bf6:	cf 92       	push	r12
     bf8:	df 92       	push	r13
     bfa:	ff 92       	push	r15
     bfc:	0f 93       	push	r16
     bfe:	1f 93       	push	r17
     c00:	cf 93       	push	r28
     c02:	df 93       	push	r29
     c04:	f6 2e       	mov	r15, r22
     c06:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c08:	86 34       	cpi	r24, 0x46	; 70
     c0a:	91 05       	cpc	r25, r1
     c0c:	1c f4       	brge	.+6      	; 0xc14 <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     c0e:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c10:	86 e4       	ldi	r24, 0x46	; 70
     c12:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c14:	2e 31       	cpi	r18, 0x1E	; 30
     c16:	31 05       	cpc	r19, r1
     c18:	1c f4       	brge	.+6      	; 0xc20 <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     c1a:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c1c:	8c e4       	ldi	r24, 0x4C	; 76
     c1e:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c20:	0e 31       	cpi	r16, 0x1E	; 30
     c22:	11 05       	cpc	r17, r1
     c24:	1c f4       	brge	.+6      	; 0xc2c <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     c26:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c28:	82 e5       	ldi	r24, 0x52	; 82
     c2a:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c2c:	b5 01       	movw	r22, r10
     c2e:	c6 01       	movw	r24, r12
     c30:	5a df       	rcall	.-332    	; 0xae6 <detectStairs>
     c32:	88 23       	and	r24, r24
     c34:	19 f0       	breq	.+6      	; 0xc3c <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c36:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c38:	82 e4       	ldi	r24, 0x42	; 66
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     c3c:	8f 2d       	mov	r24, r15
     c3e:	df 91       	pop	r29
     c40:	cf 91       	pop	r28
     c42:	1f 91       	pop	r17
     c44:	0f 91       	pop	r16
     c46:	ff 90       	pop	r15
     c48:	df 90       	pop	r13
     c4a:	cf 90       	pop	r12
     c4c:	bf 90       	pop	r11
     c4e:	af 90       	pop	r10
     c50:	08 95       	ret

00000c52 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c52:	42 df       	rcall	.-380    	; 0xad8 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c54:	bc 01       	movw	r22, r24
     c56:	88 27       	eor	r24, r24
     c58:	77 fd       	sbrc	r23, 7
     c5a:	80 95       	com	r24
     c5c:	98 2f       	mov	r25, r24
     c5e:	0e 94 38 14 	call	0x2870	; 0x2870 <__floatsisf>
     c62:	29 e2       	ldi	r18, 0x29	; 41
     c64:	3c e5       	ldi	r19, 0x5C	; 92
     c66:	4f e6       	ldi	r20, 0x6F	; 111
     c68:	5f eb       	ldi	r21, 0xBF	; 191
     c6a:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <pow>
     c6e:	22 e5       	ldi	r18, 0x52	; 82
     c70:	38 e6       	ldi	r19, 0x68	; 104
     c72:	46 e2       	ldi	r20, 0x26	; 38
     c74:	56 e4       	ldi	r21, 0x46	; 70
     c76:	0e 94 c4 14 	call	0x2988	; 0x2988 <__mulsf3>
     c7a:	20 e0       	ldi	r18, 0x00	; 0
     c7c:	30 e0       	ldi	r19, 0x00	; 0
     c7e:	40 e2       	ldi	r20, 0x20	; 32
     c80:	51 e4       	ldi	r21, 0x41	; 65
     c82:	0e 94 a0 13 	call	0x2740	; 0x2740 <__subsf3>
     c86:	0e 94 05 14 	call	0x280a	; 0x280a <__fixsfsi>
     c8a:	cb 01       	movw	r24, r22
     c8c:	68 3e       	cpi	r22, 0xE8	; 232
     c8e:	23 e0       	ldi	r18, 0x03	; 3
     c90:	72 07       	cpc	r23, r18
     c92:	14 f0       	brlt	.+4      	; 0xc98 <mySharpIR_Read+0x46>
     c94:	87 ee       	ldi	r24, 0xE7	; 231
     c96:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
}
     c98:	08 95       	ret

00000c9a <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     c9a:	fb 01       	movw	r30, r22
     c9c:	20 81       	ld	r18, Z
     c9e:	31 81       	ldd	r19, Z+1	; 0x01
     ca0:	50 e0       	ldi	r21, 0x00	; 0
     ca2:	b9 01       	movw	r22, r18
     ca4:	64 0f       	add	r22, r20
     ca6:	75 1f       	adc	r23, r21
     ca8:	68 17       	cp	r22, r24
     caa:	79 07       	cpc	r23, r25
     cac:	4c f0       	brlt	.+18     	; 0xcc0 <checkWithinRange+0x26>
     cae:	24 1b       	sub	r18, r20
     cb0:	35 0b       	sbc	r19, r21
     cb2:	41 e0       	ldi	r20, 0x01	; 1
     cb4:	82 17       	cp	r24, r18
     cb6:	93 07       	cpc	r25, r19
     cb8:	0c f0       	brlt	.+2      	; 0xcbc <checkWithinRange+0x22>
     cba:	40 e0       	ldi	r20, 0x00	; 0
     cbc:	84 2f       	mov	r24, r20
     cbe:	08 95       	ret
     cc0:	81 e0       	ldi	r24, 0x01	; 1
}
     cc2:	08 95       	ret

00000cc4 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     cc4:	0f 93       	push	r16
     cc6:	1f 93       	push	r17
     cc8:	cf 93       	push	r28
     cca:	df 93       	push	r29
     ccc:	8c 01       	movw	r16, r24
     cce:	eb 01       	movw	r28, r22
	static const char range = 5; // put at header file later...
	static const char CALIBRATE_COUNT = 20; // put at header file later...
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, range) && i == 0)
     cd0:	45 e0       	ldi	r20, 0x05	; 5
     cd2:	bc 01       	movw	r22, r24
     cd4:	ce 01       	movw	r24, r28
     cd6:	e1 df       	rcall	.-62     	; 0xc9a <checkWithinRange>
     cd8:	88 23       	and	r24, r24
     cda:	41 f0       	breq	.+16     	; 0xcec <mySharpIR_ReCalibrate+0x28>
     cdc:	20 91 24 08 	lds	r18, 0x0824
     ce0:	30 91 25 08 	lds	r19, 0x0825
     ce4:	21 15       	cp	r18, r1
     ce6:	31 05       	cpc	r19, r1
     ce8:	69 f4       	brne	.+26     	; 0xd04 <mySharpIR_ReCalibrate+0x40>
     cea:	4b c0       	rjmp	.+150    	; 0xd82 <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     cec:	20 91 24 08 	lds	r18, 0x0824
     cf0:	30 91 25 08 	lds	r19, 0x0825
     cf4:	21 15       	cp	r18, r1
     cf6:	31 05       	cpc	r19, r1
     cf8:	29 f4       	brne	.+10     	; 0xd04 <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     cfa:	d0 93 21 08 	sts	0x0821, r29
     cfe:	c0 93 20 08 	sts	0x0820, r28
     d02:	32 c0       	rjmp	.+100    	; 0xd68 <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     d04:	2a 30       	cpi	r18, 0x0A	; 10
     d06:	31 05       	cpc	r19, r1
     d08:	a9 f4       	brne	.+42     	; 0xd34 <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, range))
     d0a:	45 e0       	ldi	r20, 0x05	; 5
     d0c:	60 e2       	ldi	r22, 0x20	; 32
     d0e:	78 e0       	ldi	r23, 0x08	; 8
     d10:	ce 01       	movw	r24, r28
     d12:	c3 df       	rcall	.-122    	; 0xc9a <checkWithinRange>
     d14:	88 23       	and	r24, r24
     d16:	49 f0       	breq	.+18     	; 0xd2a <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d18:	d0 93 21 08 	sts	0x0821, r29
     d1c:	c0 93 20 08 	sts	0x0820, r28
			i = 0; // reset to count...
     d20:	10 92 25 08 	sts	0x0825, r1
     d24:	10 92 24 08 	sts	0x0824, r1
     d28:	1f c0       	rjmp	.+62     	; 0xd68 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d2a:	d0 93 23 08 	sts	0x0823, r29
     d2e:	c0 93 22 08 	sts	0x0822, r28
     d32:	1a c0       	rjmp	.+52     	; 0xd68 <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d34:	24 31       	cpi	r18, 0x14	; 20
     d36:	31 05       	cpc	r19, r1
     d38:	b9 f4       	brne	.+46     	; 0xd68 <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     d3a:	10 92 25 08 	sts	0x0825, r1
     d3e:	10 92 24 08 	sts	0x0824, r1

		if(checkWithinRange(reading, checkReading, range))
     d42:	45 e0       	ldi	r20, 0x05	; 5
     d44:	60 e2       	ldi	r22, 0x20	; 32
     d46:	78 e0       	ldi	r23, 0x08	; 8
     d48:	ce 01       	movw	r24, r28
     d4a:	a7 df       	rcall	.-178    	; 0xc9a <checkWithinRange>
     d4c:	88 23       	and	r24, r24
     d4e:	29 f0       	breq	.+10     	; 0xd5a <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d50:	d0 93 21 08 	sts	0x0821, r29
     d54:	c0 93 20 08 	sts	0x0820, r28
     d58:	07 c0       	rjmp	.+14     	; 0xd68 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     d5a:	80 91 20 08 	lds	r24, 0x0820
     d5e:	90 91 21 08 	lds	r25, 0x0821
     d62:	f8 01       	movw	r30, r16
     d64:	91 83       	std	Z+1, r25	; 0x01
     d66:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     d68:	80 91 24 08 	lds	r24, 0x0824
     d6c:	90 91 25 08 	lds	r25, 0x0825
     d70:	01 96       	adiw	r24, 0x01	; 1
     d72:	64 e1       	ldi	r22, 0x14	; 20
     d74:	70 e0       	ldi	r23, 0x00	; 0
     d76:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <__divmodhi4>
     d7a:	90 93 25 08 	sts	0x0825, r25
     d7e:	80 93 24 08 	sts	0x0824, r24
}
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	1f 91       	pop	r17
     d88:	0f 91       	pop	r16
     d8a:	08 95       	ret

00000d8c <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     d8c:	90 93 ae 08 	sts	0x08AE, r25
     d90:	80 93 ad 08 	sts	0x08AD, r24
     d94:	fc 01       	movw	r30, r24
     d96:	80 81       	ld	r24, Z
     d98:	91 81       	ldd	r25, Z+1	; 0x01
     d9a:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspend>
     d9e:	43 e0       	ldi	r20, 0x03	; 3
     da0:	60 e0       	ldi	r22, 0x00	; 0
     da2:	81 e0       	ldi	r24, 0x01	; 1
     da4:	ee d4       	rcall	.+2524   	; 0x1782 <xQueueGenericCreate>
     da6:	90 93 aa 08 	sts	0x08AA, r25
     daa:	80 93 a9 08 	sts	0x08A9, r24
     dae:	43 e0       	ldi	r20, 0x03	; 3
     db0:	60 e0       	ldi	r22, 0x00	; 0
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	e6 d4       	rcall	.+2508   	; 0x1782 <xQueueGenericCreate>
     db6:	90 93 ac 08 	sts	0x08AC, r25
     dba:	80 93 ab 08 	sts	0x08AB, r24
     dbe:	08 95       	ret

00000dc0 <myTimer_Read>:
     dc0:	86 b5       	in	r24, 0x26	; 38
     dc2:	08 95       	ret

00000dc4 <myTimer_DelayMicro>:
     dc4:	46 b5       	in	r20, 0x26	; 38
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	9c 01       	movw	r18, r24
     dca:	99 23       	and	r25, r25
     dcc:	14 f4       	brge	.+4      	; 0xdd2 <myTimer_DelayMicro+0xe>
     dce:	2d 5f       	subi	r18, 0xFD	; 253
     dd0:	3f 4f       	sbci	r19, 0xFF	; 255
     dd2:	35 95       	asr	r19
     dd4:	27 95       	ror	r18
     dd6:	35 95       	asr	r19
     dd8:	27 95       	ror	r18
     dda:	24 0f       	add	r18, r20
     ddc:	35 1f       	adc	r19, r21
     dde:	30 93 03 02 	sts	0x0203, r19
     de2:	20 93 02 02 	sts	0x0202, r18
     de6:	e0 91 ad 08 	lds	r30, 0x08AD
     dea:	f0 91 ae 08 	lds	r31, 0x08AE
     dee:	80 81       	ld	r24, Z
     df0:	91 81       	ldd	r25, Z+1	; 0x01
     df2:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <vTaskResume>
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	42 e0       	ldi	r20, 0x02	; 2
     dfa:	50 e0       	ldi	r21, 0x00	; 0
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	70 e0       	ldi	r23, 0x00	; 0
     e00:	80 91 a9 08 	lds	r24, 0x08A9
     e04:	90 91 aa 08 	lds	r25, 0x08AA
     e08:	e1 c5       	rjmp	.+3010   	; 0x19cc <xQueueGenericReceive>
     e0a:	08 95       	ret

00000e0c <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e10:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e12:	c1 11       	cpse	r28, r1
     e14:	22 c0       	rjmp	.+68     	; 0xe5a <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e16:	80 91 02 02 	lds	r24, 0x0202
     e1a:	90 91 03 02 	lds	r25, 0x0203
     e1e:	88 38       	cpi	r24, 0x88	; 136
     e20:	93 41       	sbci	r25, 0x13	; 19
     e22:	51 f0       	breq	.+20     	; 0xe38 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e24:	80 91 02 02 	lds	r24, 0x0202
     e28:	90 91 03 02 	lds	r25, 0x0203
     e2c:	8a 5f       	subi	r24, 0xFA	; 250
     e2e:	91 09       	sbc	r25, r1
     e30:	90 93 03 02 	sts	0x0203, r25
     e34:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e38:	80 91 00 02 	lds	r24, 0x0200
     e3c:	90 91 01 02 	lds	r25, 0x0201
     e40:	88 38       	cpi	r24, 0x88	; 136
     e42:	93 41       	sbci	r25, 0x13	; 19
     e44:	51 f0       	breq	.+20     	; 0xe5a <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e46:	80 91 00 02 	lds	r24, 0x0200
     e4a:	90 91 01 02 	lds	r25, 0x0201
     e4e:	8a 5f       	subi	r24, 0xFA	; 250
     e50:	91 09       	sbc	r25, r1
     e52:	90 93 01 02 	sts	0x0201, r25
     e56:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e5a:	d0 e0       	ldi	r29, 0x00	; 0
     e5c:	80 91 02 02 	lds	r24, 0x0202
     e60:	90 91 03 02 	lds	r25, 0x0203
     e64:	8c 17       	cp	r24, r28
     e66:	9d 07       	cpc	r25, r29
     e68:	84 f4       	brge	.+32     	; 0xe8a <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     e6a:	88 e8       	ldi	r24, 0x88	; 136
     e6c:	93 e1       	ldi	r25, 0x13	; 19
     e6e:	90 93 03 02 	sts	0x0203, r25
     e72:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     e76:	20 e0       	ldi	r18, 0x00	; 0
     e78:	40 e0       	ldi	r20, 0x00	; 0
     e7a:	50 e0       	ldi	r21, 0x00	; 0
     e7c:	60 e0       	ldi	r22, 0x00	; 0
     e7e:	70 e0       	ldi	r23, 0x00	; 0
     e80:	80 91 a9 08 	lds	r24, 0x08A9
     e84:	90 91 aa 08 	lds	r25, 0x08AA
     e88:	a9 d4       	rcall	.+2386   	; 0x17dc <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     e8a:	80 91 00 02 	lds	r24, 0x0200
     e8e:	90 91 01 02 	lds	r25, 0x0201
     e92:	8c 17       	cp	r24, r28
     e94:	9d 07       	cpc	r25, r29
     e96:	84 f4       	brge	.+32     	; 0xeb8 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     e98:	88 e8       	ldi	r24, 0x88	; 136
     e9a:	93 e1       	ldi	r25, 0x13	; 19
     e9c:	90 93 01 02 	sts	0x0201, r25
     ea0:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	60 e0       	ldi	r22, 0x00	; 0
     eac:	70 e0       	ldi	r23, 0x00	; 0
     eae:	80 91 ab 08 	lds	r24, 0x08AB
     eb2:	90 91 ac 08 	lds	r25, 0x08AC
     eb6:	92 d4       	rcall	.+2340   	; 0x17dc <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     eb8:	80 91 02 02 	lds	r24, 0x0202
     ebc:	90 91 03 02 	lds	r25, 0x0203
     ec0:	88 38       	cpi	r24, 0x88	; 136
     ec2:	93 41       	sbci	r25, 0x13	; 19
     ec4:	79 f4       	brne	.+30     	; 0xee4 <myTimer_DelayChecker+0xd8>
     ec6:	80 91 00 02 	lds	r24, 0x0200
     eca:	90 91 01 02 	lds	r25, 0x0201
     ece:	88 38       	cpi	r24, 0x88	; 136
     ed0:	93 41       	sbci	r25, 0x13	; 19
     ed2:	41 f4       	brne	.+16     	; 0xee4 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     ed4:	e0 91 ad 08 	lds	r30, 0x08AD
     ed8:	f0 91 ae 08 	lds	r31, 0x08AE
     edc:	80 81       	ld	r24, Z
     ede:	91 81       	ldd	r25, Z+1	; 0x01
     ee0:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspend>
	}
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	08 95       	ret

00000eea <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     eea:	1f 92       	push	r1
     eec:	0f 92       	push	r0
     eee:	0f b6       	in	r0, 0x3f	; 63
     ef0:	0f 92       	push	r0
     ef2:	11 24       	eor	r1, r1
     ef4:	0b b6       	in	r0, 0x3b	; 59
     ef6:	0f 92       	push	r0
     ef8:	2f 93       	push	r18
     efa:	3f 93       	push	r19
     efc:	4f 93       	push	r20
     efe:	5f 93       	push	r21
     f00:	6f 93       	push	r22
     f02:	7f 93       	push	r23
     f04:	8f 93       	push	r24
     f06:	9f 93       	push	r25
     f08:	af 93       	push	r26
     f0a:	bf 93       	push	r27
     f0c:	ef 93       	push	r30
     f0e:	ff 93       	push	r31
     f10:	60 91 ce 00 	lds	r22, 0x00CE
     f14:	84 e4       	ldi	r24, 0x44	; 68
     f16:	99 e0       	ldi	r25, 0x09	; 9
     f18:	2f d6       	rcall	.+3166   	; 0x1b78 <ringBufferPush>
     f1a:	20 e0       	ldi	r18, 0x00	; 0
     f1c:	40 e0       	ldi	r20, 0x00	; 0
     f1e:	50 e0       	ldi	r21, 0x00	; 0
     f20:	60 e0       	ldi	r22, 0x00	; 0
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	80 91 38 09 	lds	r24, 0x0938
     f28:	90 91 39 09 	lds	r25, 0x0939
     f2c:	15 d5       	rcall	.+2602   	; 0x1958 <xQueueGenericSendFromISR>
     f2e:	84 e4       	ldi	r24, 0x44	; 68
     f30:	99 e0       	ldi	r25, 0x09	; 9
     f32:	39 d6       	rcall	.+3186   	; 0x1ba6 <ringBufferFull>
     f34:	ff 91       	pop	r31
     f36:	ef 91       	pop	r30
     f38:	bf 91       	pop	r27
     f3a:	af 91       	pop	r26
     f3c:	9f 91       	pop	r25
     f3e:	8f 91       	pop	r24
     f40:	7f 91       	pop	r23
     f42:	6f 91       	pop	r22
     f44:	5f 91       	pop	r21
     f46:	4f 91       	pop	r20
     f48:	3f 91       	pop	r19
     f4a:	2f 91       	pop	r18
     f4c:	0f 90       	pop	r0
     f4e:	0b be       	out	0x3b, r0	; 59
     f50:	0f 90       	pop	r0
     f52:	0f be       	out	0x3f, r0	; 63
     f54:	0f 90       	pop	r0
     f56:	1f 90       	pop	r1
     f58:	18 95       	reti

00000f5a <__vector_25>:
     f5a:	1f 92       	push	r1
     f5c:	0f 92       	push	r0
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	0f 92       	push	r0
     f62:	11 24       	eor	r1, r1
     f64:	0b b6       	in	r0, 0x3b	; 59
     f66:	0f 92       	push	r0
     f68:	2f 93       	push	r18
     f6a:	3f 93       	push	r19
     f6c:	4f 93       	push	r20
     f6e:	5f 93       	push	r21
     f70:	6f 93       	push	r22
     f72:	7f 93       	push	r23
     f74:	8f 93       	push	r24
     f76:	9f 93       	push	r25
     f78:	af 93       	push	r26
     f7a:	bf 93       	push	r27
     f7c:	ef 93       	push	r30
     f7e:	ff 93       	push	r31
     f80:	60 91 c6 00 	lds	r22, 0x00C6
     f84:	8f ec       	ldi	r24, 0xCF	; 207
     f86:	98 e0       	ldi	r25, 0x08	; 8
     f88:	f7 d5       	rcall	.+3054   	; 0x1b78 <ringBufferPush>
     f8a:	20 e0       	ldi	r18, 0x00	; 0
     f8c:	40 e0       	ldi	r20, 0x00	; 0
     f8e:	50 e0       	ldi	r21, 0x00	; 0
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	70 e0       	ldi	r23, 0x00	; 0
     f94:	80 91 38 09 	lds	r24, 0x0938
     f98:	90 91 39 09 	lds	r25, 0x0939
     f9c:	dd d4       	rcall	.+2490   	; 0x1958 <xQueueGenericSendFromISR>
     f9e:	8f ec       	ldi	r24, 0xCF	; 207
     fa0:	98 e0       	ldi	r25, 0x08	; 8
     fa2:	01 d6       	rcall	.+3074   	; 0x1ba6 <ringBufferFull>
     fa4:	ff 91       	pop	r31
     fa6:	ef 91       	pop	r30
     fa8:	bf 91       	pop	r27
     faa:	af 91       	pop	r26
     fac:	9f 91       	pop	r25
     fae:	8f 91       	pop	r24
     fb0:	7f 91       	pop	r23
     fb2:	6f 91       	pop	r22
     fb4:	5f 91       	pop	r21
     fb6:	4f 91       	pop	r20
     fb8:	3f 91       	pop	r19
     fba:	2f 91       	pop	r18
     fbc:	0f 90       	pop	r0
     fbe:	0b be       	out	0x3b, r0	; 59
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
     fc4:	0f 90       	pop	r0
     fc6:	1f 90       	pop	r1
     fc8:	18 95       	reti

00000fca <__vector_37>:
     fca:	1f 92       	push	r1
     fcc:	0f 92       	push	r0
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	0f 92       	push	r0
     fd2:	11 24       	eor	r1, r1
     fd4:	0b b6       	in	r0, 0x3b	; 59
     fd6:	0f 92       	push	r0
     fd8:	2f 93       	push	r18
     fda:	3f 93       	push	r19
     fdc:	4f 93       	push	r20
     fde:	5f 93       	push	r21
     fe0:	6f 93       	push	r22
     fe2:	7f 93       	push	r23
     fe4:	8f 93       	push	r24
     fe6:	9f 93       	push	r25
     fe8:	af 93       	push	r26
     fea:	bf 93       	push	r27
     fec:	ef 93       	push	r30
     fee:	ff 93       	push	r31
     ff0:	8a e3       	ldi	r24, 0x3A	; 58
     ff2:	99 e0       	ldi	r25, 0x09	; 9
     ff4:	df d5       	rcall	.+3006   	; 0x1bb4 <ringBufferNotEmpty>
     ff6:	88 23       	and	r24, r24
     ff8:	31 f0       	breq	.+12     	; 0x1006 <__vector_37+0x3c>
     ffa:	8a e3       	ldi	r24, 0x3A	; 58
     ffc:	99 e0       	ldi	r25, 0x09	; 9
     ffe:	aa d5       	rcall	.+2900   	; 0x1b54 <ringBufferPop>
    1000:	80 93 ce 00 	sts	0x00CE, r24
    1004:	05 c0       	rjmp	.+10     	; 0x1010 <__vector_37+0x46>
    1006:	e9 ec       	ldi	r30, 0xC9	; 201
    1008:	f0 e0       	ldi	r31, 0x00	; 0
    100a:	80 81       	ld	r24, Z
    100c:	8f 7d       	andi	r24, 0xDF	; 223
    100e:	80 83       	st	Z, r24
    1010:	ff 91       	pop	r31
    1012:	ef 91       	pop	r30
    1014:	bf 91       	pop	r27
    1016:	af 91       	pop	r26
    1018:	9f 91       	pop	r25
    101a:	8f 91       	pop	r24
    101c:	7f 91       	pop	r23
    101e:	6f 91       	pop	r22
    1020:	5f 91       	pop	r21
    1022:	4f 91       	pop	r20
    1024:	3f 91       	pop	r19
    1026:	2f 91       	pop	r18
    1028:	0f 90       	pop	r0
    102a:	0b be       	out	0x3b, r0	; 59
    102c:	0f 90       	pop	r0
    102e:	0f be       	out	0x3f, r0	; 63
    1030:	0f 90       	pop	r0
    1032:	1f 90       	pop	r1
    1034:	18 95       	reti

00001036 <__vector_26>:
    1036:	1f 92       	push	r1
    1038:	0f 92       	push	r0
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	0f 92       	push	r0
    103e:	11 24       	eor	r1, r1
    1040:	0b b6       	in	r0, 0x3b	; 59
    1042:	0f 92       	push	r0
    1044:	2f 93       	push	r18
    1046:	3f 93       	push	r19
    1048:	4f 93       	push	r20
    104a:	5f 93       	push	r21
    104c:	6f 93       	push	r22
    104e:	7f 93       	push	r23
    1050:	8f 93       	push	r24
    1052:	9f 93       	push	r25
    1054:	af 93       	push	r26
    1056:	bf 93       	push	r27
    1058:	ef 93       	push	r30
    105a:	ff 93       	push	r31
    105c:	8f e3       	ldi	r24, 0x3F	; 63
    105e:	99 e0       	ldi	r25, 0x09	; 9
    1060:	a9 d5       	rcall	.+2898   	; 0x1bb4 <ringBufferNotEmpty>
    1062:	88 23       	and	r24, r24
    1064:	31 f0       	breq	.+12     	; 0x1072 <__vector_26+0x3c>
    1066:	8f e3       	ldi	r24, 0x3F	; 63
    1068:	99 e0       	ldi	r25, 0x09	; 9
    106a:	74 d5       	rcall	.+2792   	; 0x1b54 <ringBufferPop>
    106c:	80 93 c6 00 	sts	0x00C6, r24
    1070:	05 c0       	rjmp	.+10     	; 0x107c <__vector_26+0x46>
    1072:	e1 ec       	ldi	r30, 0xC1	; 193
    1074:	f0 e0       	ldi	r31, 0x00	; 0
    1076:	80 81       	ld	r24, Z
    1078:	8f 7d       	andi	r24, 0xDF	; 223
    107a:	80 83       	st	Z, r24
    107c:	ff 91       	pop	r31
    107e:	ef 91       	pop	r30
    1080:	bf 91       	pop	r27
    1082:	af 91       	pop	r26
    1084:	9f 91       	pop	r25
    1086:	8f 91       	pop	r24
    1088:	7f 91       	pop	r23
    108a:	6f 91       	pop	r22
    108c:	5f 91       	pop	r21
    108e:	4f 91       	pop	r20
    1090:	3f 91       	pop	r19
    1092:	2f 91       	pop	r18
    1094:	0f 90       	pop	r0
    1096:	0b be       	out	0x3b, r0	; 59
    1098:	0f 90       	pop	r0
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	0f 90       	pop	r0
    109e:	1f 90       	pop	r1
    10a0:	18 95       	reti

000010a2 <myUSART_USART0_Init>:
    10a2:	10 92 c5 00 	sts	0x00C5, r1
    10a6:	87 e6       	ldi	r24, 0x67	; 103
    10a8:	80 93 c4 00 	sts	0x00C4, r24
    10ac:	88 eb       	ldi	r24, 0xB8	; 184
    10ae:	80 93 c1 00 	sts	0x00C1, r24
    10b2:	86 e0       	ldi	r24, 0x06	; 6
    10b4:	80 93 c2 00 	sts	0x00C2, r24
    10b8:	40 e2       	ldi	r20, 0x20	; 32
    10ba:	66 ef       	ldi	r22, 0xF6	; 246
    10bc:	78 e0       	ldi	r23, 0x08	; 8
    10be:	8f ec       	ldi	r24, 0xCF	; 207
    10c0:	98 e0       	ldi	r25, 0x08	; 8
    10c2:	37 d5       	rcall	.+2670   	; 0x1b32 <ringBufferInit>
    10c4:	40 e2       	ldi	r20, 0x20	; 32
    10c6:	64 ed       	ldi	r22, 0xD4	; 212
    10c8:	78 e0       	ldi	r23, 0x08	; 8
    10ca:	8f e3       	ldi	r24, 0x3F	; 63
    10cc:	99 e0       	ldi	r25, 0x09	; 9
    10ce:	31 d5       	rcall	.+2658   	; 0x1b32 <ringBufferInit>
    10d0:	43 e0       	ldi	r20, 0x03	; 3
    10d2:	60 e0       	ldi	r22, 0x00	; 0
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	55 d3       	rcall	.+1706   	; 0x1782 <xQueueGenericCreate>
    10d8:	90 93 37 09 	sts	0x0937, r25
    10dc:	80 93 36 09 	sts	0x0936, r24
    10e0:	08 95       	ret

000010e2 <myUSART_USART1_Init>:
    10e2:	10 92 cd 00 	sts	0x00CD, r1
    10e6:	87 e6       	ldi	r24, 0x67	; 103
    10e8:	80 93 cc 00 	sts	0x00CC, r24
    10ec:	88 eb       	ldi	r24, 0xB8	; 184
    10ee:	80 93 c9 00 	sts	0x00C9, r24
    10f2:	86 e0       	ldi	r24, 0x06	; 6
    10f4:	80 93 ca 00 	sts	0x00CA, r24
    10f8:	40 e2       	ldi	r20, 0x20	; 32
    10fa:	6f ea       	ldi	r22, 0xAF	; 175
    10fc:	78 e0       	ldi	r23, 0x08	; 8
    10fe:	84 e4       	ldi	r24, 0x44	; 68
    1100:	99 e0       	ldi	r25, 0x09	; 9
    1102:	17 d5       	rcall	.+2606   	; 0x1b32 <ringBufferInit>
    1104:	40 e2       	ldi	r20, 0x20	; 32
    1106:	66 e1       	ldi	r22, 0x16	; 22
    1108:	79 e0       	ldi	r23, 0x09	; 9
    110a:	8a e3       	ldi	r24, 0x3A	; 58
    110c:	99 e0       	ldi	r25, 0x09	; 9
    110e:	11 d5       	rcall	.+2594   	; 0x1b32 <ringBufferInit>
    1110:	43 e0       	ldi	r20, 0x03	; 3
    1112:	60 e0       	ldi	r22, 0x00	; 0
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	35 d3       	rcall	.+1642   	; 0x1782 <xQueueGenericCreate>
    1118:	90 93 39 09 	sts	0x0939, r25
    111c:	80 93 38 09 	sts	0x0938, r24
    1120:	43 e0       	ldi	r20, 0x03	; 3
    1122:	60 e0       	ldi	r22, 0x00	; 0
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	2d d3       	rcall	.+1626   	; 0x1782 <xQueueGenericCreate>
    1128:	90 93 f5 08 	sts	0x08F5, r25
    112c:	80 93 f4 08 	sts	0x08F4, r24
    1130:	08 95       	ret

00001132 <myUSART_transmitUSART0_c>:
    1132:	cf 93       	push	r28
    1134:	c8 2f       	mov	r28, r24
    1136:	8f e3       	ldi	r24, 0x3F	; 63
    1138:	99 e0       	ldi	r25, 0x09	; 9
    113a:	35 d5       	rcall	.+2666   	; 0x1ba6 <ringBufferFull>
    113c:	81 11       	cpse	r24, r1
    113e:	fb cf       	rjmp	.-10     	; 0x1136 <myUSART_transmitUSART0_c+0x4>
    1140:	6c 2f       	mov	r22, r28
    1142:	8f e3       	ldi	r24, 0x3F	; 63
    1144:	99 e0       	ldi	r25, 0x09	; 9
    1146:	18 d5       	rcall	.+2608   	; 0x1b78 <ringBufferPush>
    1148:	e1 ec       	ldi	r30, 0xC1	; 193
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	80 81       	ld	r24, Z
    114e:	80 62       	ori	r24, 0x20	; 32
    1150:	80 83       	st	Z, r24
    1152:	e0 ec       	ldi	r30, 0xC0	; 192
    1154:	f0 e0       	ldi	r31, 0x00	; 0
    1156:	80 81       	ld	r24, Z
    1158:	80 64       	ori	r24, 0x40	; 64
    115a:	80 83       	st	Z, r24
    115c:	cf 91       	pop	r28
    115e:	08 95       	ret

00001160 <myUSART_transmitUSART1_c>:
    1160:	cf 93       	push	r28
    1162:	c8 2f       	mov	r28, r24
    1164:	8a e3       	ldi	r24, 0x3A	; 58
    1166:	99 e0       	ldi	r25, 0x09	; 9
    1168:	1e d5       	rcall	.+2620   	; 0x1ba6 <ringBufferFull>
    116a:	81 11       	cpse	r24, r1
    116c:	fb cf       	rjmp	.-10     	; 0x1164 <myUSART_transmitUSART1_c+0x4>
    116e:	6c 2f       	mov	r22, r28
    1170:	8a e3       	ldi	r24, 0x3A	; 58
    1172:	99 e0       	ldi	r25, 0x09	; 9
    1174:	01 d5       	rcall	.+2562   	; 0x1b78 <ringBufferPush>
    1176:	e9 ec       	ldi	r30, 0xC9	; 201
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	80 81       	ld	r24, Z
    117c:	80 62       	ori	r24, 0x20	; 32
    117e:	80 83       	st	Z, r24
    1180:	e8 ec       	ldi	r30, 0xC8	; 200
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	80 81       	ld	r24, Z
    1186:	80 64       	ori	r24, 0x40	; 64
    1188:	80 83       	st	Z, r24
    118a:	cf 91       	pop	r28
    118c:	08 95       	ret

0000118e <myUSART_transmitUSART1>:
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
    1192:	ec 01       	movw	r28, r24
    1194:	88 81       	ld	r24, Y
    1196:	88 23       	and	r24, r24
    1198:	29 f0       	breq	.+10     	; 0x11a4 <myUSART_transmitUSART1+0x16>
    119a:	21 96       	adiw	r28, 0x01	; 1
    119c:	e1 df       	rcall	.-62     	; 0x1160 <myUSART_transmitUSART1_c>
    119e:	89 91       	ld	r24, Y+
    11a0:	81 11       	cpse	r24, r1
    11a2:	fc cf       	rjmp	.-8      	; 0x119c <myUSART_transmitUSART1+0xe>
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	08 95       	ret

000011aa <myUSART_transmitUSART0>:
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	ec 01       	movw	r28, r24
    11b0:	88 81       	ld	r24, Y
    11b2:	88 23       	and	r24, r24
    11b4:	29 f0       	breq	.+10     	; 0x11c0 <myUSART_transmitUSART0+0x16>
    11b6:	21 96       	adiw	r28, 0x01	; 1
    11b8:	bc df       	rcall	.-136    	; 0x1132 <myUSART_transmitUSART0_c>
    11ba:	89 91       	ld	r24, Y+
    11bc:	81 11       	cpse	r24, r1
    11be:	fc cf       	rjmp	.-8      	; 0x11b8 <myUSART_transmitUSART0+0xe>
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	08 95       	ret

000011c6 <myUSART_receiveUSART1>:
    11c6:	cf 93       	push	r28
    11c8:	20 e0       	ldi	r18, 0x00	; 0
    11ca:	4f ef       	ldi	r20, 0xFF	; 255
    11cc:	5f ef       	ldi	r21, 0xFF	; 255
    11ce:	60 e0       	ldi	r22, 0x00	; 0
    11d0:	70 e0       	ldi	r23, 0x00	; 0
    11d2:	80 91 38 09 	lds	r24, 0x0938
    11d6:	90 91 39 09 	lds	r25, 0x0939
    11da:	f8 d3       	rcall	.+2032   	; 0x19cc <xQueueGenericReceive>
    11dc:	84 e4       	ldi	r24, 0x44	; 68
    11de:	99 e0       	ldi	r25, 0x09	; 9
    11e0:	b9 d4       	rcall	.+2418   	; 0x1b54 <ringBufferPop>
    11e2:	c8 2f       	mov	r28, r24
    11e4:	84 e4       	ldi	r24, 0x44	; 68
    11e6:	99 e0       	ldi	r25, 0x09	; 9
    11e8:	e5 d4       	rcall	.+2506   	; 0x1bb4 <ringBufferNotEmpty>
    11ea:	88 23       	and	r24, r24
    11ec:	51 f0       	breq	.+20     	; 0x1202 <myUSART_receiveUSART1+0x3c>
    11ee:	20 e0       	ldi	r18, 0x00	; 0
    11f0:	40 e0       	ldi	r20, 0x00	; 0
    11f2:	50 e0       	ldi	r21, 0x00	; 0
    11f4:	60 e0       	ldi	r22, 0x00	; 0
    11f6:	70 e0       	ldi	r23, 0x00	; 0
    11f8:	80 91 38 09 	lds	r24, 0x0938
    11fc:	90 91 39 09 	lds	r25, 0x0939
    1200:	ed d2       	rcall	.+1498   	; 0x17dc <xQueueGenericSend>
    1202:	8c 2f       	mov	r24, r28
    1204:	cf 91       	pop	r28
    1206:	08 95       	ret

00001208 <myUSART_waitForHandshake>:
    1208:	de df       	rcall	.-68     	; 0x11c6 <myUSART_receiveUSART1>
    120a:	86 31       	cpi	r24, 0x16	; 22
    120c:	51 f4       	brne	.+20     	; 0x1222 <myUSART_waitForHandshake+0x1a>
    120e:	85 e0       	ldi	r24, 0x05	; 5
    1210:	a7 df       	rcall	.-178    	; 0x1160 <myUSART_transmitUSART1_c>
    1212:	d9 df       	rcall	.-78     	; 0x11c6 <myUSART_receiveUSART1>
    1214:	91 e0       	ldi	r25, 0x01	; 1
    1216:	86 31       	cpi	r24, 0x16	; 22
    1218:	09 f4       	brne	.+2      	; 0x121c <myUSART_waitForHandshake+0x14>
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	89 2f       	mov	r24, r25
    121e:	81 95       	neg	r24
    1220:	08 95       	ret
    1222:	8f ef       	ldi	r24, 0xFF	; 255
    1224:	08 95       	ret

00001226 <myUSART_completeHandShake>:
    1226:	20 e0       	ldi	r18, 0x00	; 0
    1228:	40 e0       	ldi	r20, 0x00	; 0
    122a:	50 e0       	ldi	r21, 0x00	; 0
    122c:	60 e0       	ldi	r22, 0x00	; 0
    122e:	70 e0       	ldi	r23, 0x00	; 0
    1230:	80 91 f4 08 	lds	r24, 0x08F4
    1234:	90 91 f5 08 	lds	r25, 0x08F5
    1238:	d1 c2       	rjmp	.+1442   	; 0x17dc <xQueueGenericSend>
    123a:	08 95       	ret

0000123c <myUSART_receiveHandShakeAck>:
    123c:	91 e0       	ldi	r25, 0x01	; 1
    123e:	85 30       	cpi	r24, 0x05	; 5
    1240:	09 f0       	breq	.+2      	; 0x1244 <myUSART_receiveHandShakeAck+0x8>
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	89 2f       	mov	r24, r25
    1246:	08 95       	ret

00001248 <myUSART_receiveHandShakeStart>:
    1248:	91 e0       	ldi	r25, 0x01	; 1
    124a:	86 31       	cpi	r24, 0x16	; 22
    124c:	09 f0       	breq	.+2      	; 0x1250 <myUSART_receiveHandShakeStart+0x8>
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	89 2f       	mov	r24, r25
    1252:	08 95       	ret

00001254 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1254:	91 e0       	ldi	r25, 0x01	; 1
    1256:	86 30       	cpi	r24, 0x06	; 6
    1258:	09 f0       	breq	.+2      	; 0x125c <myUSART_receiveMessageACK+0x8>
    125a:	90 e0       	ldi	r25, 0x00	; 0
}
    125c:	89 2f       	mov	r24, r25
    125e:	08 95       	ret

00001260 <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    1260:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    1262:	20 e0       	ldi	r18, 0x00	; 0
    1264:	4f ef       	ldi	r20, 0xFF	; 255
    1266:	5f ef       	ldi	r21, 0xFF	; 255
    1268:	60 e0       	ldi	r22, 0x00	; 0
    126a:	70 e0       	ldi	r23, 0x00	; 0
    126c:	80 91 38 09 	lds	r24, 0x0938
    1270:	90 91 39 09 	lds	r25, 0x0939
    1274:	ab d3       	rcall	.+1878   	; 0x19cc <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    1276:	84 e4       	ldi	r24, 0x44	; 68
    1278:	99 e0       	ldi	r25, 0x09	; 9
    127a:	62 d4       	rcall	.+2244   	; 0x1b40 <ringBufferPeek>
    127c:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    127e:	84 e4       	ldi	r24, 0x44	; 68
    1280:	99 e0       	ldi	r25, 0x09	; 9
    1282:	98 d4       	rcall	.+2352   	; 0x1bb4 <ringBufferNotEmpty>
    1284:	88 23       	and	r24, r24
    1286:	51 f0       	breq	.+20     	; 0x129c <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	40 e0       	ldi	r20, 0x00	; 0
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	60 e0       	ldi	r22, 0x00	; 0
    1290:	70 e0       	ldi	r23, 0x00	; 0
    1292:	80 91 38 09 	lds	r24, 0x0938
    1296:	90 91 39 09 	lds	r25, 0x0939
    129a:	a0 d2       	rcall	.+1344   	; 0x17dc <xQueueGenericSend>
	}
	
	return data;
    129c:	8c 2f       	mov	r24, r28
    129e:	cf 91       	pop	r28
    12a0:	08 95       	ret

000012a2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12a2:	31 e1       	ldi	r19, 0x11	; 17
    12a4:	fc 01       	movw	r30, r24
    12a6:	30 83       	st	Z, r19
    12a8:	31 97       	sbiw	r30, 0x01	; 1
    12aa:	22 e2       	ldi	r18, 0x22	; 34
    12ac:	20 83       	st	Z, r18
    12ae:	31 97       	sbiw	r30, 0x01	; 1
    12b0:	a3 e3       	ldi	r26, 0x33	; 51
    12b2:	a0 83       	st	Z, r26
    12b4:	31 97       	sbiw	r30, 0x01	; 1
    12b6:	60 83       	st	Z, r22
    12b8:	31 97       	sbiw	r30, 0x01	; 1
    12ba:	70 83       	st	Z, r23
    12bc:	31 97       	sbiw	r30, 0x01	; 1
    12be:	10 82       	st	Z, r1
    12c0:	31 97       	sbiw	r30, 0x01	; 1
    12c2:	10 82       	st	Z, r1
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	60 e8       	ldi	r22, 0x80	; 128
    12c8:	60 83       	st	Z, r22
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	10 82       	st	Z, r1
    12ce:	31 97       	sbiw	r30, 0x01	; 1
    12d0:	10 82       	st	Z, r1
    12d2:	31 97       	sbiw	r30, 0x01	; 1
    12d4:	10 82       	st	Z, r1
    12d6:	31 97       	sbiw	r30, 0x01	; 1
    12d8:	62 e0       	ldi	r22, 0x02	; 2
    12da:	60 83       	st	Z, r22
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	63 e0       	ldi	r22, 0x03	; 3
    12e0:	60 83       	st	Z, r22
    12e2:	31 97       	sbiw	r30, 0x01	; 1
    12e4:	64 e0       	ldi	r22, 0x04	; 4
    12e6:	60 83       	st	Z, r22
    12e8:	31 97       	sbiw	r30, 0x01	; 1
    12ea:	65 e0       	ldi	r22, 0x05	; 5
    12ec:	60 83       	st	Z, r22
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	66 e0       	ldi	r22, 0x06	; 6
    12f2:	60 83       	st	Z, r22
    12f4:	31 97       	sbiw	r30, 0x01	; 1
    12f6:	67 e0       	ldi	r22, 0x07	; 7
    12f8:	60 83       	st	Z, r22
    12fa:	31 97       	sbiw	r30, 0x01	; 1
    12fc:	68 e0       	ldi	r22, 0x08	; 8
    12fe:	60 83       	st	Z, r22
    1300:	31 97       	sbiw	r30, 0x01	; 1
    1302:	69 e0       	ldi	r22, 0x09	; 9
    1304:	60 83       	st	Z, r22
    1306:	31 97       	sbiw	r30, 0x01	; 1
    1308:	60 e1       	ldi	r22, 0x10	; 16
    130a:	60 83       	st	Z, r22
    130c:	31 97       	sbiw	r30, 0x01	; 1
    130e:	30 83       	st	Z, r19
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	32 e1       	ldi	r19, 0x12	; 18
    1314:	30 83       	st	Z, r19
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	33 e1       	ldi	r19, 0x13	; 19
    131a:	30 83       	st	Z, r19
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	34 e1       	ldi	r19, 0x14	; 20
    1320:	30 83       	st	Z, r19
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	35 e1       	ldi	r19, 0x15	; 21
    1326:	30 83       	st	Z, r19
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	36 e1       	ldi	r19, 0x16	; 22
    132c:	30 83       	st	Z, r19
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	37 e1       	ldi	r19, 0x17	; 23
    1332:	30 83       	st	Z, r19
    1334:	31 97       	sbiw	r30, 0x01	; 1
    1336:	38 e1       	ldi	r19, 0x18	; 24
    1338:	30 83       	st	Z, r19
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	39 e1       	ldi	r19, 0x19	; 25
    133e:	30 83       	st	Z, r19
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	30 e2       	ldi	r19, 0x20	; 32
    1344:	30 83       	st	Z, r19
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	31 e2       	ldi	r19, 0x21	; 33
    134a:	30 83       	st	Z, r19
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	20 83       	st	Z, r18
    1350:	31 97       	sbiw	r30, 0x01	; 1
    1352:	23 e2       	ldi	r18, 0x23	; 35
    1354:	20 83       	st	Z, r18
    1356:	31 97       	sbiw	r30, 0x01	; 1
    1358:	40 83       	st	Z, r20
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	50 83       	st	Z, r21
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	26 e2       	ldi	r18, 0x26	; 38
    1362:	20 83       	st	Z, r18
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	27 e2       	ldi	r18, 0x27	; 39
    1368:	20 83       	st	Z, r18
    136a:	31 97       	sbiw	r30, 0x01	; 1
    136c:	28 e2       	ldi	r18, 0x28	; 40
    136e:	20 83       	st	Z, r18
    1370:	31 97       	sbiw	r30, 0x01	; 1
    1372:	29 e2       	ldi	r18, 0x29	; 41
    1374:	20 83       	st	Z, r18
    1376:	31 97       	sbiw	r30, 0x01	; 1
    1378:	20 e3       	ldi	r18, 0x30	; 48
    137a:	20 83       	st	Z, r18
    137c:	31 97       	sbiw	r30, 0x01	; 1
    137e:	21 e3       	ldi	r18, 0x31	; 49
    1380:	20 83       	st	Z, r18
    1382:	89 97       	sbiw	r24, 0x29	; 41
    1384:	08 95       	ret

00001386 <xPortStartScheduler>:
    1386:	82 e0       	ldi	r24, 0x02	; 2
    1388:	84 bd       	out	0x24, r24	; 36
    138a:	16 bc       	out	0x26, r1	; 38
    138c:	80 e3       	ldi	r24, 0x30	; 48
    138e:	87 bd       	out	0x27, r24	; 39
    1390:	ee e6       	ldi	r30, 0x6E	; 110
    1392:	f0 e0       	ldi	r31, 0x00	; 0
    1394:	80 81       	ld	r24, Z
    1396:	82 60       	ori	r24, 0x02	; 2
    1398:	80 83       	st	Z, r24
    139a:	83 e0       	ldi	r24, 0x03	; 3
    139c:	85 bd       	out	0x25, r24	; 37
    139e:	a0 91 8f 08 	lds	r26, 0x088F
    13a2:	b0 91 90 08 	lds	r27, 0x0890
    13a6:	cd 91       	ld	r28, X+
    13a8:	cd bf       	out	0x3d, r28	; 61
    13aa:	dd 91       	ld	r29, X+
    13ac:	de bf       	out	0x3e, r29	; 62
    13ae:	ff 91       	pop	r31
    13b0:	ef 91       	pop	r30
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	bf 91       	pop	r27
    13b8:	af 91       	pop	r26
    13ba:	9f 91       	pop	r25
    13bc:	8f 91       	pop	r24
    13be:	7f 91       	pop	r23
    13c0:	6f 91       	pop	r22
    13c2:	5f 91       	pop	r21
    13c4:	4f 91       	pop	r20
    13c6:	3f 91       	pop	r19
    13c8:	2f 91       	pop	r18
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	ff 90       	pop	r15
    13d0:	ef 90       	pop	r14
    13d2:	df 90       	pop	r13
    13d4:	cf 90       	pop	r12
    13d6:	bf 90       	pop	r11
    13d8:	af 90       	pop	r10
    13da:	9f 90       	pop	r9
    13dc:	8f 90       	pop	r8
    13de:	7f 90       	pop	r7
    13e0:	6f 90       	pop	r6
    13e2:	5f 90       	pop	r5
    13e4:	4f 90       	pop	r4
    13e6:	3f 90       	pop	r3
    13e8:	2f 90       	pop	r2
    13ea:	1f 90       	pop	r1
    13ec:	0f 90       	pop	r0
    13ee:	0c be       	out	0x3c, r0	; 60
    13f0:	0f 90       	pop	r0
    13f2:	0b be       	out	0x3b, r0	; 59
    13f4:	0f 90       	pop	r0
    13f6:	0f be       	out	0x3f, r0	; 63
    13f8:	0f 90       	pop	r0
    13fa:	08 95       	ret
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	08 95       	ret

00001400 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1400:	0f 92       	push	r0
    1402:	0f b6       	in	r0, 0x3f	; 63
    1404:	f8 94       	cli
    1406:	0f 92       	push	r0
    1408:	0b b6       	in	r0, 0x3b	; 59
    140a:	0f 92       	push	r0
    140c:	0c b6       	in	r0, 0x3c	; 60
    140e:	0f 92       	push	r0
    1410:	1f 92       	push	r1
    1412:	11 24       	eor	r1, r1
    1414:	2f 92       	push	r2
    1416:	3f 92       	push	r3
    1418:	4f 92       	push	r4
    141a:	5f 92       	push	r5
    141c:	6f 92       	push	r6
    141e:	7f 92       	push	r7
    1420:	8f 92       	push	r8
    1422:	9f 92       	push	r9
    1424:	af 92       	push	r10
    1426:	bf 92       	push	r11
    1428:	cf 92       	push	r12
    142a:	df 92       	push	r13
    142c:	ef 92       	push	r14
    142e:	ff 92       	push	r15
    1430:	0f 93       	push	r16
    1432:	1f 93       	push	r17
    1434:	2f 93       	push	r18
    1436:	3f 93       	push	r19
    1438:	4f 93       	push	r20
    143a:	5f 93       	push	r21
    143c:	6f 93       	push	r22
    143e:	7f 93       	push	r23
    1440:	8f 93       	push	r24
    1442:	9f 93       	push	r25
    1444:	af 93       	push	r26
    1446:	bf 93       	push	r27
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	ef 93       	push	r30
    144e:	ff 93       	push	r31
    1450:	a0 91 8f 08 	lds	r26, 0x088F
    1454:	b0 91 90 08 	lds	r27, 0x0890
    1458:	0d b6       	in	r0, 0x3d	; 61
    145a:	0d 92       	st	X+, r0
    145c:	0e b6       	in	r0, 0x3e	; 62
    145e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1460:	5b d7       	rcall	.+3766   	; 0x2318 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1462:	a0 91 8f 08 	lds	r26, 0x088F
    1466:	b0 91 90 08 	lds	r27, 0x0890
    146a:	cd 91       	ld	r28, X+
    146c:	cd bf       	out	0x3d, r28	; 61
    146e:	dd 91       	ld	r29, X+
    1470:	de bf       	out	0x3e, r29	; 62
    1472:	ff 91       	pop	r31
    1474:	ef 91       	pop	r30
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	bf 91       	pop	r27
    147c:	af 91       	pop	r26
    147e:	9f 91       	pop	r25
    1480:	8f 91       	pop	r24
    1482:	7f 91       	pop	r23
    1484:	6f 91       	pop	r22
    1486:	5f 91       	pop	r21
    1488:	4f 91       	pop	r20
    148a:	3f 91       	pop	r19
    148c:	2f 91       	pop	r18
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	ff 90       	pop	r15
    1494:	ef 90       	pop	r14
    1496:	df 90       	pop	r13
    1498:	cf 90       	pop	r12
    149a:	bf 90       	pop	r11
    149c:	af 90       	pop	r10
    149e:	9f 90       	pop	r9
    14a0:	8f 90       	pop	r8
    14a2:	7f 90       	pop	r7
    14a4:	6f 90       	pop	r6
    14a6:	5f 90       	pop	r5
    14a8:	4f 90       	pop	r4
    14aa:	3f 90       	pop	r3
    14ac:	2f 90       	pop	r2
    14ae:	1f 90       	pop	r1
    14b0:	0f 90       	pop	r0
    14b2:	0c be       	out	0x3c, r0	; 60
    14b4:	0f 90       	pop	r0
    14b6:	0b be       	out	0x3b, r0	; 59
    14b8:	0f 90       	pop	r0
    14ba:	0f be       	out	0x3f, r0	; 63
    14bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14be:	08 95       	ret

000014c0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14c0:	0f 92       	push	r0
    14c2:	0f b6       	in	r0, 0x3f	; 63
    14c4:	f8 94       	cli
    14c6:	0f 92       	push	r0
    14c8:	0b b6       	in	r0, 0x3b	; 59
    14ca:	0f 92       	push	r0
    14cc:	0c b6       	in	r0, 0x3c	; 60
    14ce:	0f 92       	push	r0
    14d0:	1f 92       	push	r1
    14d2:	11 24       	eor	r1, r1
    14d4:	2f 92       	push	r2
    14d6:	3f 92       	push	r3
    14d8:	4f 92       	push	r4
    14da:	5f 92       	push	r5
    14dc:	6f 92       	push	r6
    14de:	7f 92       	push	r7
    14e0:	8f 92       	push	r8
    14e2:	9f 92       	push	r9
    14e4:	af 92       	push	r10
    14e6:	bf 92       	push	r11
    14e8:	cf 92       	push	r12
    14ea:	df 92       	push	r13
    14ec:	ef 92       	push	r14
    14ee:	ff 92       	push	r15
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	2f 93       	push	r18
    14f6:	3f 93       	push	r19
    14f8:	4f 93       	push	r20
    14fa:	5f 93       	push	r21
    14fc:	6f 93       	push	r22
    14fe:	7f 93       	push	r23
    1500:	8f 93       	push	r24
    1502:	9f 93       	push	r25
    1504:	af 93       	push	r26
    1506:	bf 93       	push	r27
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ef 93       	push	r30
    150e:	ff 93       	push	r31
    1510:	a0 91 8f 08 	lds	r26, 0x088F
    1514:	b0 91 90 08 	lds	r27, 0x0890
    1518:	0d b6       	in	r0, 0x3d	; 61
    151a:	0d 92       	st	X+, r0
    151c:	0e b6       	in	r0, 0x3e	; 62
    151e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1520:	45 d5       	rcall	.+2698   	; 0x1fac <xTaskIncrementTick>
    1522:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1524:	f9 d6       	rcall	.+3570   	; 0x2318 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1526:	a0 91 8f 08 	lds	r26, 0x088F
    152a:	b0 91 90 08 	lds	r27, 0x0890
    152e:	cd 91       	ld	r28, X+
    1530:	cd bf       	out	0x3d, r28	; 61
    1532:	dd 91       	ld	r29, X+
    1534:	de bf       	out	0x3e, r29	; 62
    1536:	ff 91       	pop	r31
    1538:	ef 91       	pop	r30
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	bf 91       	pop	r27
    1540:	af 91       	pop	r26
    1542:	9f 91       	pop	r25
    1544:	8f 91       	pop	r24
    1546:	7f 91       	pop	r23
    1548:	6f 91       	pop	r22
    154a:	5f 91       	pop	r21
    154c:	4f 91       	pop	r20
    154e:	3f 91       	pop	r19
    1550:	2f 91       	pop	r18
    1552:	1f 91       	pop	r17
    1554:	0f 91       	pop	r16
    1556:	ff 90       	pop	r15
    1558:	ef 90       	pop	r14
    155a:	df 90       	pop	r13
    155c:	cf 90       	pop	r12
    155e:	bf 90       	pop	r11
    1560:	af 90       	pop	r10
    1562:	9f 90       	pop	r9
    1564:	8f 90       	pop	r8
    1566:	7f 90       	pop	r7
    1568:	6f 90       	pop	r6
    156a:	5f 90       	pop	r5
    156c:	4f 90       	pop	r4
    156e:	3f 90       	pop	r3
    1570:	2f 90       	pop	r2
    1572:	1f 90       	pop	r1
    1574:	0f 90       	pop	r0
    1576:	0c be       	out	0x3c, r0	; 60
    1578:	0f 90       	pop	r0
    157a:	0b be       	out	0x3b, r0	; 59
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1582:	08 95       	ret

00001584 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1584:	9d df       	rcall	.-198    	; 0x14c0 <vPortYieldFromTick>
		 asm volatile ("reti");
    1586:	18 95       	reti

00001588 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1588:	1f 93       	push	r17
    158a:	cf 93       	push	r28
    158c:	df 93       	push	r29
    158e:	ec 01       	movw	r28, r24
    1590:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1592:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1594:	81 11       	cpse	r24, r1
    1596:	0c c0       	rjmp	.+24     	; 0x15b0 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1598:	88 81       	ld	r24, Y
    159a:	99 81       	ldd	r25, Y+1	; 0x01
    159c:	89 2b       	or	r24, r25
    159e:	09 f0       	breq	.+2      	; 0x15a2 <prvCopyDataToQueue+0x1a>
    15a0:	47 c0       	rjmp	.+142    	; 0x1630 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    15a2:	8a 81       	ldd	r24, Y+2	; 0x02
    15a4:	9b 81       	ldd	r25, Y+3	; 0x03
    15a6:	0e 94 4f 13 	call	0x269e	; 0x269e <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    15aa:	1b 82       	std	Y+3, r1	; 0x03
    15ac:	1a 82       	std	Y+2, r1	; 0x02
    15ae:	47 c0       	rjmp	.+142    	; 0x163e <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    15b0:	41 11       	cpse	r20, r1
    15b2:	18 c0       	rjmp	.+48     	; 0x15e4 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    15b4:	48 2f       	mov	r20, r24
    15b6:	50 e0       	ldi	r21, 0x00	; 0
    15b8:	8c 81       	ldd	r24, Y+4	; 0x04
    15ba:	9d 81       	ldd	r25, Y+5	; 0x05
    15bc:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15c0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15c2:	8c 81       	ldd	r24, Y+4	; 0x04
    15c4:	9d 81       	ldd	r25, Y+5	; 0x05
    15c6:	82 0f       	add	r24, r18
    15c8:	91 1d       	adc	r25, r1
    15ca:	9d 83       	std	Y+5, r25	; 0x05
    15cc:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15ce:	2a 81       	ldd	r18, Y+2	; 0x02
    15d0:	3b 81       	ldd	r19, Y+3	; 0x03
    15d2:	82 17       	cp	r24, r18
    15d4:	93 07       	cpc	r25, r19
    15d6:	70 f1       	brcs	.+92     	; 0x1634 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15d8:	88 81       	ld	r24, Y
    15da:	99 81       	ldd	r25, Y+1	; 0x01
    15dc:	9d 83       	std	Y+5, r25	; 0x05
    15de:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    15e0:	80 e0       	ldi	r24, 0x00	; 0
    15e2:	2d c0       	rjmp	.+90     	; 0x163e <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15e4:	48 2f       	mov	r20, r24
    15e6:	50 e0       	ldi	r21, 0x00	; 0
    15e8:	8e 81       	ldd	r24, Y+6	; 0x06
    15ea:	9f 81       	ldd	r25, Y+7	; 0x07
    15ec:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    15f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	31 95       	neg	r19
    15f6:	21 95       	neg	r18
    15f8:	31 09       	sbc	r19, r1
    15fa:	8e 81       	ldd	r24, Y+6	; 0x06
    15fc:	9f 81       	ldd	r25, Y+7	; 0x07
    15fe:	82 0f       	add	r24, r18
    1600:	93 1f       	adc	r25, r19
    1602:	9f 83       	std	Y+7, r25	; 0x07
    1604:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1606:	68 81       	ld	r22, Y
    1608:	79 81       	ldd	r23, Y+1	; 0x01
    160a:	86 17       	cp	r24, r22
    160c:	97 07       	cpc	r25, r23
    160e:	30 f4       	brcc	.+12     	; 0x161c <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1610:	8a 81       	ldd	r24, Y+2	; 0x02
    1612:	9b 81       	ldd	r25, Y+3	; 0x03
    1614:	28 0f       	add	r18, r24
    1616:	39 1f       	adc	r19, r25
    1618:	3f 83       	std	Y+7, r19	; 0x07
    161a:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    161c:	12 30       	cpi	r17, 0x02	; 2
    161e:	61 f4       	brne	.+24     	; 0x1638 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1620:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1622:	88 23       	and	r24, r24
    1624:	59 f0       	breq	.+22     	; 0x163c <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1626:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1628:	81 50       	subi	r24, 0x01	; 1
    162a:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    162c:	80 e0       	ldi	r24, 0x00	; 0
    162e:	07 c0       	rjmp	.+14     	; 0x163e <prvCopyDataToQueue+0xb6>
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	05 c0       	rjmp	.+10     	; 0x163e <prvCopyDataToQueue+0xb6>
    1634:	80 e0       	ldi	r24, 0x00	; 0
    1636:	03 c0       	rjmp	.+6      	; 0x163e <prvCopyDataToQueue+0xb6>
    1638:	80 e0       	ldi	r24, 0x00	; 0
    163a:	01 c0       	rjmp	.+2      	; 0x163e <prvCopyDataToQueue+0xb6>
    163c:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    163e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1640:	9f 5f       	subi	r25, 0xFF	; 255
    1642:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	08 95       	ret

0000164c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    164c:	fc 01       	movw	r30, r24
    164e:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1650:	44 8d       	ldd	r20, Z+28	; 0x1c
    1652:	44 23       	and	r20, r20
    1654:	a1 f0       	breq	.+40     	; 0x167e <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1656:	50 e0       	ldi	r21, 0x00	; 0
    1658:	26 81       	ldd	r18, Z+6	; 0x06
    165a:	37 81       	ldd	r19, Z+7	; 0x07
    165c:	24 0f       	add	r18, r20
    165e:	35 1f       	adc	r19, r21
    1660:	37 83       	std	Z+7, r19	; 0x07
    1662:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1664:	62 81       	ldd	r22, Z+2	; 0x02
    1666:	73 81       	ldd	r23, Z+3	; 0x03
    1668:	26 17       	cp	r18, r22
    166a:	37 07       	cpc	r19, r23
    166c:	20 f0       	brcs	.+8      	; 0x1676 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    166e:	20 81       	ld	r18, Z
    1670:	31 81       	ldd	r19, Z+1	; 0x01
    1672:	37 83       	std	Z+7, r19	; 0x07
    1674:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1676:	66 81       	ldd	r22, Z+6	; 0x06
    1678:	77 81       	ldd	r23, Z+7	; 0x07
    167a:	0c 94 1b 17 	jmp	0x2e36	; 0x2e36 <memcpy>
    167e:	08 95       	ret

00001680 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1680:	0f 93       	push	r16
    1682:	1f 93       	push	r17
    1684:	cf 93       	push	r28
    1686:	df 93       	push	r29
    1688:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	f8 94       	cli
    168e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1690:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1692:	18 16       	cp	r1, r24
    1694:	a4 f4       	brge	.+40     	; 0x16be <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1696:	89 89       	ldd	r24, Y+17	; 0x11
    1698:	88 23       	and	r24, r24
    169a:	89 f0       	breq	.+34     	; 0x16be <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    169c:	8e 01       	movw	r16, r28
    169e:	0f 5e       	subi	r16, 0xEF	; 239
    16a0:	1f 4f       	sbci	r17, 0xFF	; 255
    16a2:	03 c0       	rjmp	.+6      	; 0x16aa <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16a4:	89 89       	ldd	r24, Y+17	; 0x11
    16a6:	88 23       	and	r24, r24
    16a8:	51 f0       	breq	.+20     	; 0x16be <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16aa:	c8 01       	movw	r24, r16
    16ac:	0b d7       	rcall	.+3606   	; 0x24c4 <xTaskRemoveFromEventList>
    16ae:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    16b0:	94 d7       	rcall	.+3880   	; 0x25da <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    16b2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16b4:	81 50       	subi	r24, 0x01	; 1
    16b6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16ba:	18 16       	cp	r1, r24
    16bc:	9c f3       	brlt	.-26     	; 0x16a4 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    16be:	8f ef       	ldi	r24, 0xFF	; 255
    16c0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	f8 94       	cli
    16ca:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16cc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16ce:	18 16       	cp	r1, r24
    16d0:	a4 f4       	brge	.+40     	; 0x16fa <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16d2:	88 85       	ldd	r24, Y+8	; 0x08
    16d4:	88 23       	and	r24, r24
    16d6:	89 f0       	breq	.+34     	; 0x16fa <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16d8:	8e 01       	movw	r16, r28
    16da:	08 5f       	subi	r16, 0xF8	; 248
    16dc:	1f 4f       	sbci	r17, 0xFF	; 255
    16de:	03 c0       	rjmp	.+6      	; 0x16e6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16e0:	88 85       	ldd	r24, Y+8	; 0x08
    16e2:	88 23       	and	r24, r24
    16e4:	51 f0       	breq	.+20     	; 0x16fa <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16e6:	c8 01       	movw	r24, r16
    16e8:	ed d6       	rcall	.+3546   	; 0x24c4 <xTaskRemoveFromEventList>
    16ea:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    16ec:	76 d7       	rcall	.+3820   	; 0x25da <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    16ee:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16f0:	81 50       	subi	r24, 0x01	; 1
    16f2:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16f4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16f6:	18 16       	cp	r1, r24
    16f8:	9c f3       	brlt	.-26     	; 0x16e0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    16fa:	8f ef       	ldi	r24, 0xFF	; 255
    16fc:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
}
    1702:	df 91       	pop	r29
    1704:	cf 91       	pop	r28
    1706:	1f 91       	pop	r17
    1708:	0f 91       	pop	r16
    170a:	08 95       	ret

0000170c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    170c:	cf 93       	push	r28
    170e:	df 93       	push	r29
    1710:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1712:	0f b6       	in	r0, 0x3f	; 63
    1714:	f8 94       	cli
    1716:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1718:	88 81       	ld	r24, Y
    171a:	99 81       	ldd	r25, Y+1	; 0x01
    171c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    171e:	30 e0       	ldi	r19, 0x00	; 0
    1720:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1722:	72 9f       	mul	r23, r18
    1724:	a0 01       	movw	r20, r0
    1726:	73 9f       	mul	r23, r19
    1728:	50 0d       	add	r21, r0
    172a:	11 24       	eor	r1, r1
    172c:	fc 01       	movw	r30, r24
    172e:	e4 0f       	add	r30, r20
    1730:	f5 1f       	adc	r31, r21
    1732:	fb 83       	std	Y+3, r31	; 0x03
    1734:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1736:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1738:	9d 83       	std	Y+5, r25	; 0x05
    173a:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    173c:	42 1b       	sub	r20, r18
    173e:	53 0b       	sbc	r21, r19
    1740:	84 0f       	add	r24, r20
    1742:	95 1f       	adc	r25, r21
    1744:	9f 83       	std	Y+7, r25	; 0x07
    1746:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1748:	8f ef       	ldi	r24, 0xFF	; 255
    174a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    174c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    174e:	61 11       	cpse	r22, r1
    1750:	0a c0       	rjmp	.+20     	; 0x1766 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1752:	88 85       	ldd	r24, Y+8	; 0x08
    1754:	88 23       	and	r24, r24
    1756:	79 f0       	breq	.+30     	; 0x1776 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1758:	ce 01       	movw	r24, r28
    175a:	08 96       	adiw	r24, 0x08	; 8
    175c:	b3 d6       	rcall	.+3430   	; 0x24c4 <xTaskRemoveFromEventList>
    175e:	81 30       	cpi	r24, 0x01	; 1
    1760:	51 f4       	brne	.+20     	; 0x1776 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1762:	4e de       	rcall	.-868    	; 0x1400 <vPortYield>
    1764:	08 c0       	rjmp	.+16     	; 0x1776 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1766:	ce 01       	movw	r24, r28
    1768:	08 96       	adiw	r24, 0x08	; 8
    176a:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    176e:	ce 01       	movw	r24, r28
    1770:	41 96       	adiw	r24, 0x11	; 17
    1772:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1776:	0f 90       	pop	r0
    1778:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	df 91       	pop	r29
    177e:	cf 91       	pop	r28
    1780:	08 95       	ret

00001782 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1782:	0f 93       	push	r16
    1784:	1f 93       	push	r17
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    178a:	18 2f       	mov	r17, r24
    178c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    178e:	88 23       	and	r24, r24
    1790:	e9 f0       	breq	.+58     	; 0x17cc <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1792:	8f e1       	ldi	r24, 0x1F	; 31
    1794:	90 e0       	ldi	r25, 0x00	; 0
    1796:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pvPortMalloc>
    179a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    179c:	00 97       	sbiw	r24, 0x00	; 0
    179e:	c1 f0       	breq	.+48     	; 0x17d0 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17a0:	10 9f       	mul	r17, r16
    17a2:	c0 01       	movw	r24, r0
    17a4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    17a6:	01 96       	adiw	r24, 0x01	; 1
    17a8:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pvPortMalloc>
    17ac:	99 83       	std	Y+1, r25	; 0x01
    17ae:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    17b0:	89 2b       	or	r24, r25
    17b2:	31 f0       	breq	.+12     	; 0x17c0 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    17b4:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    17b6:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    17b8:	61 e0       	ldi	r22, 0x01	; 1
    17ba:	ce 01       	movw	r24, r28
    17bc:	a7 df       	rcall	.-178    	; 0x170c <xQueueGenericReset>
    17be:	08 c0       	rjmp	.+16     	; 0x17d0 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    17c0:	ce 01       	movw	r24, r28
    17c2:	0e 94 30 03 	call	0x660	; 0x660 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    17c6:	c0 e0       	ldi	r28, 0x00	; 0
    17c8:	d0 e0       	ldi	r29, 0x00	; 0
    17ca:	02 c0       	rjmp	.+4      	; 0x17d0 <xQueueGenericCreate+0x4e>
    17cc:	c0 e0       	ldi	r28, 0x00	; 0
    17ce:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    17d0:	ce 01       	movw	r24, r28
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	1f 91       	pop	r17
    17d8:	0f 91       	pop	r16
    17da:	08 95       	ret

000017dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    17dc:	9f 92       	push	r9
    17de:	af 92       	push	r10
    17e0:	bf 92       	push	r11
    17e2:	cf 92       	push	r12
    17e4:	df 92       	push	r13
    17e6:	ef 92       	push	r14
    17e8:	ff 92       	push	r15
    17ea:	0f 93       	push	r16
    17ec:	1f 93       	push	r17
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
    17f2:	00 d0       	rcall	.+0      	; 0x17f4 <xQueueGenericSend+0x18>
    17f4:	1f 92       	push	r1
    17f6:	1f 92       	push	r1
    17f8:	cd b7       	in	r28, 0x3d	; 61
    17fa:	de b7       	in	r29, 0x3e	; 62
    17fc:	8c 01       	movw	r16, r24
    17fe:	6b 01       	movw	r12, r22
    1800:	5d 83       	std	Y+5, r21	; 0x05
    1802:	4c 83       	std	Y+4, r20	; 0x04
    1804:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1806:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1808:	99 24       	eor	r9, r9
    180a:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    180c:	7c 01       	movw	r14, r24
    180e:	88 e0       	ldi	r24, 0x08	; 8
    1810:	e8 0e       	add	r14, r24
    1812:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1814:	0f b6       	in	r0, 0x3f	; 63
    1816:	f8 94       	cli
    1818:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    181a:	f8 01       	movw	r30, r16
    181c:	92 8d       	ldd	r25, Z+26	; 0x1a
    181e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1820:	98 17       	cp	r25, r24
    1822:	18 f0       	brcs	.+6      	; 0x182a <xQueueGenericSend+0x4e>
    1824:	f2 e0       	ldi	r31, 0x02	; 2
    1826:	af 12       	cpse	r10, r31
    1828:	15 c0       	rjmp	.+42     	; 0x1854 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    182a:	4a 2d       	mov	r20, r10
    182c:	b6 01       	movw	r22, r12
    182e:	c8 01       	movw	r24, r16
    1830:	ab de       	rcall	.-682    	; 0x1588 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1832:	f8 01       	movw	r30, r16
    1834:	91 89       	ldd	r25, Z+17	; 0x11
    1836:	99 23       	and	r25, r25
    1838:	39 f0       	breq	.+14     	; 0x1848 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    183a:	c8 01       	movw	r24, r16
    183c:	41 96       	adiw	r24, 0x11	; 17
    183e:	42 d6       	rcall	.+3204   	; 0x24c4 <xTaskRemoveFromEventList>
    1840:	81 30       	cpi	r24, 0x01	; 1
    1842:	21 f4       	brne	.+8      	; 0x184c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1844:	dd dd       	rcall	.-1094   	; 0x1400 <vPortYield>
    1846:	02 c0       	rjmp	.+4      	; 0x184c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1848:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    184a:	da dd       	rcall	.-1100   	; 0x1400 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    184c:	0f 90       	pop	r0
    184e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	46 c0       	rjmp	.+140    	; 0x18e0 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1854:	ec 81       	ldd	r30, Y+4	; 0x04
    1856:	fd 81       	ldd	r31, Y+5	; 0x05
    1858:	ef 2b       	or	r30, r31
    185a:	21 f4       	brne	.+8      	; 0x1864 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    185c:	0f 90       	pop	r0
    185e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1860:	80 e0       	ldi	r24, 0x00	; 0
    1862:	3e c0       	rjmp	.+124    	; 0x18e0 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1864:	b1 10       	cpse	r11, r1
    1866:	04 c0       	rjmp	.+8      	; 0x1870 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1868:	ce 01       	movw	r24, r28
    186a:	01 96       	adiw	r24, 0x01	; 1
    186c:	73 d6       	rcall	.+3302   	; 0x2554 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    186e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1870:	0f 90       	pop	r0
    1872:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1874:	86 d3       	rcall	.+1804   	; 0x1f82 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
    187c:	f8 01       	movw	r30, r16
    187e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1880:	8f 3f       	cpi	r24, 0xFF	; 255
    1882:	09 f4       	brne	.+2      	; 0x1886 <xQueueGenericSend+0xaa>
    1884:	15 8e       	std	Z+29, r1	; 0x1d
    1886:	f8 01       	movw	r30, r16
    1888:	86 8d       	ldd	r24, Z+30	; 0x1e
    188a:	8f 3f       	cpi	r24, 0xFF	; 255
    188c:	09 f4       	brne	.+2      	; 0x1890 <xQueueGenericSend+0xb4>
    188e:	16 8e       	std	Z+30, r1	; 0x1e
    1890:	0f 90       	pop	r0
    1892:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1894:	be 01       	movw	r22, r28
    1896:	6c 5f       	subi	r22, 0xFC	; 252
    1898:	7f 4f       	sbci	r23, 0xFF	; 255
    189a:	ce 01       	movw	r24, r28
    189c:	01 96       	adiw	r24, 0x01	; 1
    189e:	65 d6       	rcall	.+3274   	; 0x256a <xTaskCheckForTimeOut>
    18a0:	81 11       	cpse	r24, r1
    18a2:	1a c0       	rjmp	.+52     	; 0x18d8 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18a4:	0f b6       	in	r0, 0x3f	; 63
    18a6:	f8 94       	cli
    18a8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    18aa:	f8 01       	movw	r30, r16
    18ac:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18b2:	f8 01       	movw	r30, r16
    18b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    18b6:	98 13       	cpse	r25, r24
    18b8:	0b c0       	rjmp	.+22     	; 0x18d0 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18ba:	6c 81       	ldd	r22, Y+4	; 0x04
    18bc:	7d 81       	ldd	r23, Y+5	; 0x05
    18be:	c7 01       	movw	r24, r14
    18c0:	d6 d5       	rcall	.+2988   	; 0x246e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    18c2:	c8 01       	movw	r24, r16
    18c4:	dd de       	rcall	.-582    	; 0x1680 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    18c6:	30 d4       	rcall	.+2144   	; 0x2128 <xTaskResumeAll>
    18c8:	81 11       	cpse	r24, r1
    18ca:	a4 cf       	rjmp	.-184    	; 0x1814 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    18cc:	99 dd       	rcall	.-1230   	; 0x1400 <vPortYield>
    18ce:	a2 cf       	rjmp	.-188    	; 0x1814 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18d0:	c8 01       	movw	r24, r16
    18d2:	d6 de       	rcall	.-596    	; 0x1680 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18d4:	29 d4       	rcall	.+2130   	; 0x2128 <xTaskResumeAll>
    18d6:	9e cf       	rjmp	.-196    	; 0x1814 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18d8:	c8 01       	movw	r24, r16
    18da:	d2 de       	rcall	.-604    	; 0x1680 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18dc:	25 d4       	rcall	.+2122   	; 0x2128 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    18e0:	0f 90       	pop	r0
    18e2:	0f 90       	pop	r0
    18e4:	0f 90       	pop	r0
    18e6:	0f 90       	pop	r0
    18e8:	0f 90       	pop	r0
    18ea:	df 91       	pop	r29
    18ec:	cf 91       	pop	r28
    18ee:	1f 91       	pop	r17
    18f0:	0f 91       	pop	r16
    18f2:	ff 90       	pop	r15
    18f4:	ef 90       	pop	r14
    18f6:	df 90       	pop	r13
    18f8:	cf 90       	pop	r12
    18fa:	bf 90       	pop	r11
    18fc:	af 90       	pop	r10
    18fe:	9f 90       	pop	r9
    1900:	08 95       	ret

00001902 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1906:	8f e1       	ldi	r24, 0x1F	; 31
    1908:	90 e0       	ldi	r25, 0x00	; 0
    190a:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pvPortMalloc>
    190e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1910:	00 97       	sbiw	r24, 0x00	; 0
    1912:	f1 f0       	breq	.+60     	; 0x1950 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1914:	1b 82       	std	Y+3, r1	; 0x03
    1916:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1918:	19 82       	std	Y+1, r1	; 0x01
    191a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    191c:	1d 82       	std	Y+5, r1	; 0x05
    191e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1920:	1f 82       	std	Y+7, r1	; 0x07
    1922:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1924:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    192a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    192c:	8f ef       	ldi	r24, 0xFF	; 255
    192e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1930:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1932:	ce 01       	movw	r24, r28
    1934:	08 96       	adiw	r24, 0x08	; 8
    1936:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    193a:	ce 01       	movw	r24, r28
    193c:	41 96       	adiw	r24, 0x11	; 17
    193e:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1942:	20 e0       	ldi	r18, 0x00	; 0
    1944:	40 e0       	ldi	r20, 0x00	; 0
    1946:	50 e0       	ldi	r21, 0x00	; 0
    1948:	60 e0       	ldi	r22, 0x00	; 0
    194a:	70 e0       	ldi	r23, 0x00	; 0
    194c:	ce 01       	movw	r24, r28
    194e:	46 df       	rcall	.-372    	; 0x17dc <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1950:	ce 01       	movw	r24, r28
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	08 95       	ret

00001958 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1958:	0f 93       	push	r16
    195a:	1f 93       	push	r17
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
    1960:	ec 01       	movw	r28, r24
    1962:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1964:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1966:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1968:	98 17       	cp	r25, r24
    196a:	10 f0       	brcs	.+4      	; 0x1970 <xQueueGenericSendFromISR+0x18>
    196c:	22 30       	cpi	r18, 0x02	; 2
    196e:	11 f5       	brne	.+68     	; 0x19b4 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1970:	42 2f       	mov	r20, r18
    1972:	ce 01       	movw	r24, r28
    1974:	09 de       	rcall	.-1006   	; 0x1588 <prvCopyDataToQueue>
    1976:	88 23       	and	r24, r24
    1978:	31 f0       	breq	.+12     	; 0x1986 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    197a:	01 15       	cp	r16, r1
    197c:	11 05       	cpc	r17, r1
    197e:	19 f0       	breq	.+6      	; 0x1986 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1980:	81 e0       	ldi	r24, 0x01	; 1
    1982:	f8 01       	movw	r30, r16
    1984:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1986:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1988:	8f 3f       	cpi	r24, 0xFF	; 255
    198a:	79 f4       	brne	.+30     	; 0x19aa <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    198c:	89 89       	ldd	r24, Y+17	; 0x11
    198e:	88 23       	and	r24, r24
    1990:	99 f0       	breq	.+38     	; 0x19b8 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1992:	ce 01       	movw	r24, r28
    1994:	41 96       	adiw	r24, 0x11	; 17
    1996:	96 d5       	rcall	.+2860   	; 0x24c4 <xTaskRemoveFromEventList>
    1998:	88 23       	and	r24, r24
    199a:	81 f0       	breq	.+32     	; 0x19bc <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    199c:	01 15       	cp	r16, r1
    199e:	11 05       	cpc	r17, r1
    19a0:	79 f0       	breq	.+30     	; 0x19c0 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    19a2:	81 e0       	ldi	r24, 0x01	; 1
    19a4:	f8 01       	movw	r30, r16
    19a6:	80 83       	st	Z, r24
    19a8:	0c c0       	rjmp	.+24     	; 0x19c2 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    19aa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19ac:	8f 5f       	subi	r24, 0xFF	; 255
    19ae:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	07 c0       	rjmp	.+14     	; 0x19c2 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	05 c0       	rjmp	.+10     	; 0x19c2 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	03 c0       	rjmp	.+6      	; 0x19c2 <xQueueGenericSendFromISR+0x6a>
    19bc:	81 e0       	ldi	r24, 0x01	; 1
    19be:	01 c0       	rjmp	.+2      	; 0x19c2 <xQueueGenericSendFromISR+0x6a>
    19c0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19c2:	df 91       	pop	r29
    19c4:	cf 91       	pop	r28
    19c6:	1f 91       	pop	r17
    19c8:	0f 91       	pop	r16
    19ca:	08 95       	ret

000019cc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    19cc:	9f 92       	push	r9
    19ce:	af 92       	push	r10
    19d0:	bf 92       	push	r11
    19d2:	cf 92       	push	r12
    19d4:	df 92       	push	r13
    19d6:	ef 92       	push	r14
    19d8:	ff 92       	push	r15
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	00 d0       	rcall	.+0      	; 0x19e4 <xQueueGenericReceive+0x18>
    19e4:	1f 92       	push	r1
    19e6:	1f 92       	push	r1
    19e8:	cd b7       	in	r28, 0x3d	; 61
    19ea:	de b7       	in	r29, 0x3e	; 62
    19ec:	8c 01       	movw	r16, r24
    19ee:	6b 01       	movw	r12, r22
    19f0:	5d 83       	std	Y+5, r21	; 0x05
    19f2:	4c 83       	std	Y+4, r20	; 0x04
    19f4:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    19f6:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    19f8:	99 24       	eor	r9, r9
    19fa:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19fc:	7c 01       	movw	r14, r24
    19fe:	81 e1       	ldi	r24, 0x11	; 17
    1a00:	e8 0e       	add	r14, r24
    1a02:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a04:	0f b6       	in	r0, 0x3f	; 63
    1a06:	f8 94       	cli
    1a08:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a0a:	f8 01       	movw	r30, r16
    1a0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a0e:	88 23       	and	r24, r24
    1a10:	69 f1       	breq	.+90     	; 0x1a6c <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a12:	e6 80       	ldd	r14, Z+6	; 0x06
    1a14:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a16:	b6 01       	movw	r22, r12
    1a18:	c8 01       	movw	r24, r16
    1a1a:	18 de       	rcall	.-976    	; 0x164c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a1c:	b1 10       	cpse	r11, r1
    1a1e:	17 c0       	rjmp	.+46     	; 0x1a4e <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a20:	f8 01       	movw	r30, r16
    1a22:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a24:	81 50       	subi	r24, 0x01	; 1
    1a26:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a28:	80 81       	ld	r24, Z
    1a2a:	91 81       	ldd	r25, Z+1	; 0x01
    1a2c:	89 2b       	or	r24, r25
    1a2e:	21 f4       	brne	.+8      	; 0x1a38 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1a30:	75 d6       	rcall	.+3306   	; 0x271c <pvTaskIncrementMutexHeldCount>
    1a32:	f8 01       	movw	r30, r16
    1a34:	93 83       	std	Z+3, r25	; 0x03
    1a36:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a38:	f8 01       	movw	r30, r16
    1a3a:	80 85       	ldd	r24, Z+8	; 0x08
    1a3c:	88 23       	and	r24, r24
    1a3e:	91 f0       	breq	.+36     	; 0x1a64 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a40:	c8 01       	movw	r24, r16
    1a42:	08 96       	adiw	r24, 0x08	; 8
    1a44:	3f d5       	rcall	.+2686   	; 0x24c4 <xTaskRemoveFromEventList>
    1a46:	81 30       	cpi	r24, 0x01	; 1
    1a48:	69 f4       	brne	.+26     	; 0x1a64 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1a4a:	da dc       	rcall	.-1612   	; 0x1400 <vPortYield>
    1a4c:	0b c0       	rjmp	.+22     	; 0x1a64 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a4e:	f8 01       	movw	r30, r16
    1a50:	f7 82       	std	Z+7, r15	; 0x07
    1a52:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a54:	81 89       	ldd	r24, Z+17	; 0x11
    1a56:	88 23       	and	r24, r24
    1a58:	29 f0       	breq	.+10     	; 0x1a64 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a5a:	c8 01       	movw	r24, r16
    1a5c:	41 96       	adiw	r24, 0x11	; 17
    1a5e:	32 d5       	rcall	.+2660   	; 0x24c4 <xTaskRemoveFromEventList>
    1a60:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1a62:	ce dc       	rcall	.-1636   	; 0x1400 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1a64:	0f 90       	pop	r0
    1a66:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	52 c0       	rjmp	.+164    	; 0x1b10 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a6c:	4c 81       	ldd	r20, Y+4	; 0x04
    1a6e:	5d 81       	ldd	r21, Y+5	; 0x05
    1a70:	45 2b       	or	r20, r21
    1a72:	21 f4       	brne	.+8      	; 0x1a7c <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a74:	0f 90       	pop	r0
    1a76:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a78:	80 e0       	ldi	r24, 0x00	; 0
    1a7a:	4a c0       	rjmp	.+148    	; 0x1b10 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a7c:	a1 10       	cpse	r10, r1
    1a7e:	04 c0       	rjmp	.+8      	; 0x1a88 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a80:	ce 01       	movw	r24, r28
    1a82:	01 96       	adiw	r24, 0x01	; 1
    1a84:	67 d5       	rcall	.+2766   	; 0x2554 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a86:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a88:	0f 90       	pop	r0
    1a8a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a8c:	7a d2       	rcall	.+1268   	; 0x1f82 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a8e:	0f b6       	in	r0, 0x3f	; 63
    1a90:	f8 94       	cli
    1a92:	0f 92       	push	r0
    1a94:	f8 01       	movw	r30, r16
    1a96:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a98:	8f 3f       	cpi	r24, 0xFF	; 255
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <xQueueGenericReceive+0xd2>
    1a9c:	15 8e       	std	Z+29, r1	; 0x1d
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aa2:	8f 3f       	cpi	r24, 0xFF	; 255
    1aa4:	09 f4       	brne	.+2      	; 0x1aa8 <xQueueGenericReceive+0xdc>
    1aa6:	16 8e       	std	Z+30, r1	; 0x1e
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aac:	be 01       	movw	r22, r28
    1aae:	6c 5f       	subi	r22, 0xFC	; 252
    1ab0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ab2:	ce 01       	movw	r24, r28
    1ab4:	01 96       	adiw	r24, 0x01	; 1
    1ab6:	59 d5       	rcall	.+2738   	; 0x256a <xTaskCheckForTimeOut>
    1ab8:	81 11       	cpse	r24, r1
    1aba:	26 c0       	rjmp	.+76     	; 0x1b08 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ac6:	0f 90       	pop	r0
    1ac8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1aca:	81 11       	cpse	r24, r1
    1acc:	19 c0       	rjmp	.+50     	; 0x1b00 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ace:	f8 01       	movw	r30, r16
    1ad0:	80 81       	ld	r24, Z
    1ad2:	91 81       	ldd	r25, Z+1	; 0x01
    1ad4:	89 2b       	or	r24, r25
    1ad6:	49 f4       	brne	.+18     	; 0x1aea <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ade:	f8 01       	movw	r30, r16
    1ae0:	82 81       	ldd	r24, Z+2	; 0x02
    1ae2:	93 81       	ldd	r25, Z+3	; 0x03
    1ae4:	7e d5       	rcall	.+2812   	; 0x25e2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1ae6:	0f 90       	pop	r0
    1ae8:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1aea:	6c 81       	ldd	r22, Y+4	; 0x04
    1aec:	7d 81       	ldd	r23, Y+5	; 0x05
    1aee:	c7 01       	movw	r24, r14
    1af0:	be d4       	rcall	.+2428   	; 0x246e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1af2:	c8 01       	movw	r24, r16
    1af4:	c5 dd       	rcall	.-1142   	; 0x1680 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1af6:	18 d3       	rcall	.+1584   	; 0x2128 <xTaskResumeAll>
    1af8:	81 11       	cpse	r24, r1
    1afa:	84 cf       	rjmp	.-248    	; 0x1a04 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1afc:	81 dc       	rcall	.-1790   	; 0x1400 <vPortYield>
    1afe:	82 cf       	rjmp	.-252    	; 0x1a04 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b00:	c8 01       	movw	r24, r16
    1b02:	be dd       	rcall	.-1156   	; 0x1680 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b04:	11 d3       	rcall	.+1570   	; 0x2128 <xTaskResumeAll>
    1b06:	7e cf       	rjmp	.-260    	; 0x1a04 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b08:	c8 01       	movw	r24, r16
    1b0a:	ba dd       	rcall	.-1164   	; 0x1680 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b0c:	0d d3       	rcall	.+1562   	; 0x2128 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	0f 90       	pop	r0
    1b16:	0f 90       	pop	r0
    1b18:	0f 90       	pop	r0
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	1f 91       	pop	r17
    1b20:	0f 91       	pop	r16
    1b22:	ff 90       	pop	r15
    1b24:	ef 90       	pop	r14
    1b26:	df 90       	pop	r13
    1b28:	cf 90       	pop	r12
    1b2a:	bf 90       	pop	r11
    1b2c:	af 90       	pop	r10
    1b2e:	9f 90       	pop	r9
    1b30:	08 95       	ret

00001b32 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1b32:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1b34:	71 83       	std	Z+1, r23	; 0x01
    1b36:	60 83       	st	Z, r22
	ring->rSize = size;
    1b38:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1b3a:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1b3c:	13 82       	std	Z+3, r1	; 0x03
    1b3e:	08 95       	ret

00001b40 <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1b40:	dc 01       	movw	r26, r24
    1b42:	14 96       	adiw	r26, 0x04	; 4
    1b44:	2c 91       	ld	r18, X
    1b46:	14 97       	sbiw	r26, 0x04	; 4
    1b48:	ed 91       	ld	r30, X+
    1b4a:	fc 91       	ld	r31, X
    1b4c:	e2 0f       	add	r30, r18
    1b4e:	f1 1d       	adc	r31, r1
}
    1b50:	80 81       	ld	r24, Z
    1b52:	08 95       	ret

00001b54 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1b54:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1b56:	94 81       	ldd	r25, Z+4	; 0x04
    1b58:	a0 81       	ld	r26, Z
    1b5a:	b1 81       	ldd	r27, Z+1	; 0x01
    1b5c:	a9 0f       	add	r26, r25
    1b5e:	b1 1d       	adc	r27, r1
    1b60:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1b62:	9f 5f       	subi	r25, 0xFF	; 255
    1b64:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1b66:	22 81       	ldd	r18, Z+2	; 0x02
    1b68:	92 17       	cp	r25, r18
    1b6a:	10 f0       	brcs	.+4      	; 0x1b70 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1b6c:	92 1b       	sub	r25, r18
    1b6e:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1b70:	93 81       	ldd	r25, Z+3	; 0x03
    1b72:	91 50       	subi	r25, 0x01	; 1
    1b74:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1b76:	08 95       	ret

00001b78 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1b78:	fc 01       	movw	r30, r24
    1b7a:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1b7c:	83 81       	ldd	r24, Z+3	; 0x03
    1b7e:	22 81       	ldd	r18, Z+2	; 0x02
    1b80:	82 17       	cp	r24, r18
    1b82:	80 f4       	brcc	.+32     	; 0x1ba4 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1b84:	34 81       	ldd	r19, Z+4	; 0x04
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	83 0f       	add	r24, r19
    1b8a:	91 1d       	adc	r25, r1
    1b8c:	62 2f       	mov	r22, r18
    1b8e:	70 e0       	ldi	r23, 0x00	; 0
    1b90:	0e 94 f4 16 	call	0x2de8	; 0x2de8 <__divmodhi4>
    1b94:	a0 81       	ld	r26, Z
    1b96:	b1 81       	ldd	r27, Z+1	; 0x01
    1b98:	a8 0f       	add	r26, r24
    1b9a:	b9 1f       	adc	r27, r25
    1b9c:	4c 93       	st	X, r20
            ring->rLength++;
    1b9e:	83 81       	ldd	r24, Z+3	; 0x03
    1ba0:	8f 5f       	subi	r24, 0xFF	; 255
    1ba2:	83 83       	std	Z+3, r24	; 0x03
    1ba4:	08 95       	ret

00001ba6 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1ba6:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	22 81       	ldd	r18, Z+2	; 0x02
    1bac:	93 81       	ldd	r25, Z+3	; 0x03
    1bae:	29 13       	cpse	r18, r25
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
}
    1bb2:	08 95       	ret

00001bb4 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1bb4:	21 e0       	ldi	r18, 0x01	; 1
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	83 81       	ldd	r24, Z+3	; 0x03
    1bba:	81 11       	cpse	r24, r1
    1bbc:	01 c0       	rjmp	.+2      	; 0x1bc0 <ringBufferNotEmpty+0xc>
    1bbe:	20 e0       	ldi	r18, 0x00	; 0
}
    1bc0:	82 2f       	mov	r24, r18
    1bc2:	08 95       	ret

00001bc4 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1bc4:	e0 91 4e 08 	lds	r30, 0x084E
    1bc8:	f0 91 4f 08 	lds	r31, 0x084F
    1bcc:	80 81       	ld	r24, Z
    1bce:	81 11       	cpse	r24, r1
    1bd0:	07 c0       	rjmp	.+14     	; 0x1be0 <prvResetNextTaskUnblockTime+0x1c>
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	9f ef       	ldi	r25, 0xFF	; 255
    1bd6:	90 93 05 02 	sts	0x0205, r25
    1bda:	80 93 04 02 	sts	0x0204, r24
    1bde:	08 95       	ret
    1be0:	e0 91 4e 08 	lds	r30, 0x084E
    1be4:	f0 91 4f 08 	lds	r31, 0x084F
    1be8:	05 80       	ldd	r0, Z+5	; 0x05
    1bea:	f6 81       	ldd	r31, Z+6	; 0x06
    1bec:	e0 2d       	mov	r30, r0
    1bee:	06 80       	ldd	r0, Z+6	; 0x06
    1bf0:	f7 81       	ldd	r31, Z+7	; 0x07
    1bf2:	e0 2d       	mov	r30, r0
    1bf4:	82 81       	ldd	r24, Z+2	; 0x02
    1bf6:	93 81       	ldd	r25, Z+3	; 0x03
    1bf8:	90 93 05 02 	sts	0x0205, r25
    1bfc:	80 93 04 02 	sts	0x0204, r24
    1c00:	08 95       	ret

00001c02 <prvAddCurrentTaskToDelayedList>:
    1c02:	cf 93       	push	r28
    1c04:	df 93       	push	r29
    1c06:	ec 01       	movw	r28, r24
    1c08:	e0 91 8f 08 	lds	r30, 0x088F
    1c0c:	f0 91 90 08 	lds	r31, 0x0890
    1c10:	93 83       	std	Z+3, r25	; 0x03
    1c12:	82 83       	std	Z+2, r24	; 0x02
    1c14:	80 91 2d 08 	lds	r24, 0x082D
    1c18:	90 91 2e 08 	lds	r25, 0x082E
    1c1c:	c8 17       	cp	r28, r24
    1c1e:	d9 07       	cpc	r29, r25
    1c20:	68 f4       	brcc	.+26     	; 0x1c3c <prvAddCurrentTaskToDelayedList+0x3a>
    1c22:	60 91 8f 08 	lds	r22, 0x088F
    1c26:	70 91 90 08 	lds	r23, 0x0890
    1c2a:	80 91 4c 08 	lds	r24, 0x084C
    1c2e:	90 91 4d 08 	lds	r25, 0x084D
    1c32:	6e 5f       	subi	r22, 0xFE	; 254
    1c34:	7f 4f       	sbci	r23, 0xFF	; 255
    1c36:	0e 94 64 03 	call	0x6c8	; 0x6c8 <vListInsert>
    1c3a:	17 c0       	rjmp	.+46     	; 0x1c6a <prvAddCurrentTaskToDelayedList+0x68>
    1c3c:	60 91 8f 08 	lds	r22, 0x088F
    1c40:	70 91 90 08 	lds	r23, 0x0890
    1c44:	80 91 4e 08 	lds	r24, 0x084E
    1c48:	90 91 4f 08 	lds	r25, 0x084F
    1c4c:	6e 5f       	subi	r22, 0xFE	; 254
    1c4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c50:	0e 94 64 03 	call	0x6c8	; 0x6c8 <vListInsert>
    1c54:	80 91 04 02 	lds	r24, 0x0204
    1c58:	90 91 05 02 	lds	r25, 0x0205
    1c5c:	c8 17       	cp	r28, r24
    1c5e:	d9 07       	cpc	r29, r25
    1c60:	20 f4       	brcc	.+8      	; 0x1c6a <prvAddCurrentTaskToDelayedList+0x68>
    1c62:	d0 93 05 02 	sts	0x0205, r29
    1c66:	c0 93 04 02 	sts	0x0204, r28
    1c6a:	df 91       	pop	r29
    1c6c:	cf 91       	pop	r28
    1c6e:	08 95       	ret

00001c70 <xTaskGenericCreate>:
    1c70:	4f 92       	push	r4
    1c72:	5f 92       	push	r5
    1c74:	6f 92       	push	r6
    1c76:	7f 92       	push	r7
    1c78:	8f 92       	push	r8
    1c7a:	9f 92       	push	r9
    1c7c:	af 92       	push	r10
    1c7e:	bf 92       	push	r11
    1c80:	cf 92       	push	r12
    1c82:	df 92       	push	r13
    1c84:	ef 92       	push	r14
    1c86:	ff 92       	push	r15
    1c88:	0f 93       	push	r16
    1c8a:	1f 93       	push	r17
    1c8c:	cf 93       	push	r28
    1c8e:	df 93       	push	r29
    1c90:	4c 01       	movw	r8, r24
    1c92:	5b 01       	movw	r10, r22
    1c94:	2a 01       	movw	r4, r20
    1c96:	39 01       	movw	r6, r18
    1c98:	83 e2       	ldi	r24, 0x23	; 35
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pvPortMalloc>
    1ca0:	ec 01       	movw	r28, r24
    1ca2:	00 97       	sbiw	r24, 0x00	; 0
    1ca4:	09 f4       	brne	.+2      	; 0x1ca8 <xTaskGenericCreate+0x38>
    1ca6:	e7 c0       	rjmp	.+462    	; 0x1e76 <xTaskGenericCreate+0x206>
    1ca8:	c1 14       	cp	r12, r1
    1caa:	d1 04       	cpc	r13, r1
    1cac:	09 f0       	breq	.+2      	; 0x1cb0 <xTaskGenericCreate+0x40>
    1cae:	cc c0       	rjmp	.+408    	; 0x1e48 <xTaskGenericCreate+0x1d8>
    1cb0:	c2 01       	movw	r24, r4
    1cb2:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <pvPortMalloc>
    1cb6:	98 8f       	std	Y+24, r25	; 0x18
    1cb8:	8f 8b       	std	Y+23, r24	; 0x17
    1cba:	89 2b       	or	r24, r25
    1cbc:	09 f0       	breq	.+2      	; 0x1cc0 <xTaskGenericCreate+0x50>
    1cbe:	c6 c0       	rjmp	.+396    	; 0x1e4c <xTaskGenericCreate+0x1dc>
    1cc0:	ce 01       	movw	r24, r28
    1cc2:	0e 94 30 03 	call	0x660	; 0x660 <vPortFree>
    1cc6:	d7 c0       	rjmp	.+430    	; 0x1e76 <xTaskGenericCreate+0x206>
    1cc8:	cf 01       	movw	r24, r30
    1cca:	31 91       	ld	r19, Z+
    1ccc:	da 01       	movw	r26, r20
    1cce:	3d 93       	st	X+, r19
    1cd0:	ad 01       	movw	r20, r26
    1cd2:	dc 01       	movw	r26, r24
    1cd4:	8c 91       	ld	r24, X
    1cd6:	88 23       	and	r24, r24
    1cd8:	11 f0       	breq	.+4      	; 0x1cde <xTaskGenericCreate+0x6e>
    1cda:	21 50       	subi	r18, 0x01	; 1
    1cdc:	a9 f7       	brne	.-22     	; 0x1cc8 <xTaskGenericCreate+0x58>
    1cde:	18 a2       	std	Y+32, r1	; 0x20
    1ce0:	10 2f       	mov	r17, r16
    1ce2:	05 30       	cpi	r16, 0x05	; 5
    1ce4:	08 f0       	brcs	.+2      	; 0x1ce8 <xTaskGenericCreate+0x78>
    1ce6:	14 e0       	ldi	r17, 0x04	; 4
    1ce8:	1e 8b       	std	Y+22, r17	; 0x16
    1cea:	19 a3       	std	Y+33, r17	; 0x21
    1cec:	1a a2       	std	Y+34, r1	; 0x22
    1cee:	5e 01       	movw	r10, r28
    1cf0:	b2 e0       	ldi	r27, 0x02	; 2
    1cf2:	ab 0e       	add	r10, r27
    1cf4:	b1 1c       	adc	r11, r1
    1cf6:	c5 01       	movw	r24, r10
    1cf8:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialiseItem>
    1cfc:	ce 01       	movw	r24, r28
    1cfe:	0c 96       	adiw	r24, 0x0c	; 12
    1d00:	0e 94 3f 03 	call	0x67e	; 0x67e <vListInitialiseItem>
    1d04:	d9 87       	std	Y+9, r29	; 0x09
    1d06:	c8 87       	std	Y+8, r28	; 0x08
    1d08:	85 e0       	ldi	r24, 0x05	; 5
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	81 1b       	sub	r24, r17
    1d0e:	91 09       	sbc	r25, r1
    1d10:	9d 87       	std	Y+13, r25	; 0x0d
    1d12:	8c 87       	std	Y+12, r24	; 0x0c
    1d14:	db 8b       	std	Y+19, r29	; 0x13
    1d16:	ca 8b       	std	Y+18, r28	; 0x12
    1d18:	a3 01       	movw	r20, r6
    1d1a:	b4 01       	movw	r22, r8
    1d1c:	c6 01       	movw	r24, r12
    1d1e:	c1 da       	rcall	.-2686   	; 0x12a2 <pxPortInitialiseStack>
    1d20:	99 83       	std	Y+1, r25	; 0x01
    1d22:	88 83       	st	Y, r24
    1d24:	e1 14       	cp	r14, r1
    1d26:	f1 04       	cpc	r15, r1
    1d28:	19 f0       	breq	.+6      	; 0x1d30 <xTaskGenericCreate+0xc0>
    1d2a:	f7 01       	movw	r30, r14
    1d2c:	d1 83       	std	Z+1, r29	; 0x01
    1d2e:	c0 83       	st	Z, r28
    1d30:	0f b6       	in	r0, 0x3f	; 63
    1d32:	f8 94       	cli
    1d34:	0f 92       	push	r0
    1d36:	80 91 2f 08 	lds	r24, 0x082F
    1d3a:	8f 5f       	subi	r24, 0xFF	; 255
    1d3c:	80 93 2f 08 	sts	0x082F, r24
    1d40:	80 91 8f 08 	lds	r24, 0x088F
    1d44:	90 91 90 08 	lds	r25, 0x0890
    1d48:	89 2b       	or	r24, r25
    1d4a:	09 f0       	breq	.+2      	; 0x1d4e <xTaskGenericCreate+0xde>
    1d4c:	3f c0       	rjmp	.+126    	; 0x1dcc <xTaskGenericCreate+0x15c>
    1d4e:	d0 93 90 08 	sts	0x0890, r29
    1d52:	c0 93 8f 08 	sts	0x088F, r28
    1d56:	80 91 2f 08 	lds	r24, 0x082F
    1d5a:	81 30       	cpi	r24, 0x01	; 1
    1d5c:	09 f0       	breq	.+2      	; 0x1d60 <xTaskGenericCreate+0xf0>
    1d5e:	45 c0       	rjmp	.+138    	; 0x1dea <xTaskGenericCreate+0x17a>
    1d60:	0f 2e       	mov	r0, r31
    1d62:	f2 e6       	ldi	r31, 0x62	; 98
    1d64:	ef 2e       	mov	r14, r31
    1d66:	f8 e0       	ldi	r31, 0x08	; 8
    1d68:	ff 2e       	mov	r15, r31
    1d6a:	f0 2d       	mov	r31, r0
    1d6c:	0f 2e       	mov	r0, r31
    1d6e:	ff e8       	ldi	r31, 0x8F	; 143
    1d70:	cf 2e       	mov	r12, r31
    1d72:	f8 e0       	ldi	r31, 0x08	; 8
    1d74:	df 2e       	mov	r13, r31
    1d76:	f0 2d       	mov	r31, r0
    1d78:	c7 01       	movw	r24, r14
    1d7a:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1d7e:	f9 e0       	ldi	r31, 0x09	; 9
    1d80:	ef 0e       	add	r14, r31
    1d82:	f1 1c       	adc	r15, r1
    1d84:	ec 14       	cp	r14, r12
    1d86:	fd 04       	cpc	r15, r13
    1d88:	b9 f7       	brne	.-18     	; 0x1d78 <xTaskGenericCreate+0x108>
    1d8a:	89 e5       	ldi	r24, 0x59	; 89
    1d8c:	98 e0       	ldi	r25, 0x08	; 8
    1d8e:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1d92:	80 e5       	ldi	r24, 0x50	; 80
    1d94:	98 e0       	ldi	r25, 0x08	; 8
    1d96:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1d9a:	83 e4       	ldi	r24, 0x43	; 67
    1d9c:	98 e0       	ldi	r25, 0x08	; 8
    1d9e:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1da2:	8a e3       	ldi	r24, 0x3A	; 58
    1da4:	98 e0       	ldi	r25, 0x08	; 8
    1da6:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1daa:	80 e3       	ldi	r24, 0x30	; 48
    1dac:	98 e0       	ldi	r25, 0x08	; 8
    1dae:	0e 94 31 03 	call	0x662	; 0x662 <vListInitialise>
    1db2:	89 e5       	ldi	r24, 0x59	; 89
    1db4:	98 e0       	ldi	r25, 0x08	; 8
    1db6:	90 93 4f 08 	sts	0x084F, r25
    1dba:	80 93 4e 08 	sts	0x084E, r24
    1dbe:	80 e5       	ldi	r24, 0x50	; 80
    1dc0:	98 e0       	ldi	r25, 0x08	; 8
    1dc2:	90 93 4d 08 	sts	0x084D, r25
    1dc6:	80 93 4c 08 	sts	0x084C, r24
    1dca:	0f c0       	rjmp	.+30     	; 0x1dea <xTaskGenericCreate+0x17a>
    1dcc:	80 91 2b 08 	lds	r24, 0x082B
    1dd0:	81 11       	cpse	r24, r1
    1dd2:	0b c0       	rjmp	.+22     	; 0x1dea <xTaskGenericCreate+0x17a>
    1dd4:	e0 91 8f 08 	lds	r30, 0x088F
    1dd8:	f0 91 90 08 	lds	r31, 0x0890
    1ddc:	86 89       	ldd	r24, Z+22	; 0x16
    1dde:	08 17       	cp	r16, r24
    1de0:	20 f0       	brcs	.+8      	; 0x1dea <xTaskGenericCreate+0x17a>
    1de2:	d0 93 90 08 	sts	0x0890, r29
    1de6:	c0 93 8f 08 	sts	0x088F, r28
    1dea:	80 91 27 08 	lds	r24, 0x0827
    1dee:	8f 5f       	subi	r24, 0xFF	; 255
    1df0:	80 93 27 08 	sts	0x0827, r24
    1df4:	8e 89       	ldd	r24, Y+22	; 0x16
    1df6:	90 91 2c 08 	lds	r25, 0x082C
    1dfa:	98 17       	cp	r25, r24
    1dfc:	10 f4       	brcc	.+4      	; 0x1e02 <xTaskGenericCreate+0x192>
    1dfe:	80 93 2c 08 	sts	0x082C, r24
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	9c 01       	movw	r18, r24
    1e06:	22 0f       	add	r18, r18
    1e08:	33 1f       	adc	r19, r19
    1e0a:	22 0f       	add	r18, r18
    1e0c:	33 1f       	adc	r19, r19
    1e0e:	22 0f       	add	r18, r18
    1e10:	33 1f       	adc	r19, r19
    1e12:	82 0f       	add	r24, r18
    1e14:	93 1f       	adc	r25, r19
    1e16:	b5 01       	movw	r22, r10
    1e18:	8e 59       	subi	r24, 0x9E	; 158
    1e1a:	97 4f       	sbci	r25, 0xF7	; 247
    1e1c:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    1e20:	0f 90       	pop	r0
    1e22:	0f be       	out	0x3f, r0	; 63
    1e24:	80 91 2b 08 	lds	r24, 0x082B
    1e28:	88 23       	and	r24, r24
    1e2a:	51 f0       	breq	.+20     	; 0x1e40 <xTaskGenericCreate+0x1d0>
    1e2c:	e0 91 8f 08 	lds	r30, 0x088F
    1e30:	f0 91 90 08 	lds	r31, 0x0890
    1e34:	86 89       	ldd	r24, Z+22	; 0x16
    1e36:	80 17       	cp	r24, r16
    1e38:	28 f4       	brcc	.+10     	; 0x1e44 <xTaskGenericCreate+0x1d4>
    1e3a:	e2 da       	rcall	.-2620   	; 0x1400 <vPortYield>
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	1c c0       	rjmp	.+56     	; 0x1e78 <xTaskGenericCreate+0x208>
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	1a c0       	rjmp	.+52     	; 0x1e78 <xTaskGenericCreate+0x208>
    1e44:	81 e0       	ldi	r24, 0x01	; 1
    1e46:	18 c0       	rjmp	.+48     	; 0x1e78 <xTaskGenericCreate+0x208>
    1e48:	d8 8e       	std	Y+24, r13	; 0x18
    1e4a:	cf 8a       	std	Y+23, r12	; 0x17
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	48 1a       	sub	r4, r24
    1e50:	51 08       	sbc	r5, r1
    1e52:	cf 88       	ldd	r12, Y+23	; 0x17
    1e54:	d8 8c       	ldd	r13, Y+24	; 0x18
    1e56:	c4 0c       	add	r12, r4
    1e58:	d5 1c       	adc	r13, r5
    1e5a:	d5 01       	movw	r26, r10
    1e5c:	8c 91       	ld	r24, X
    1e5e:	89 8f       	std	Y+25, r24	; 0x19
    1e60:	8c 91       	ld	r24, X
    1e62:	88 23       	and	r24, r24
    1e64:	09 f4       	brne	.+2      	; 0x1e68 <xTaskGenericCreate+0x1f8>
    1e66:	3b cf       	rjmp	.-394    	; 0x1cde <xTaskGenericCreate+0x6e>
    1e68:	ae 01       	movw	r20, r28
    1e6a:	46 5e       	subi	r20, 0xE6	; 230
    1e6c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e6e:	f5 01       	movw	r30, r10
    1e70:	31 96       	adiw	r30, 0x01	; 1
    1e72:	27 e0       	ldi	r18, 0x07	; 7
    1e74:	29 cf       	rjmp	.-430    	; 0x1cc8 <xTaskGenericCreate+0x58>
    1e76:	8f ef       	ldi	r24, 0xFF	; 255
    1e78:	df 91       	pop	r29
    1e7a:	cf 91       	pop	r28
    1e7c:	1f 91       	pop	r17
    1e7e:	0f 91       	pop	r16
    1e80:	ff 90       	pop	r15
    1e82:	ef 90       	pop	r14
    1e84:	df 90       	pop	r13
    1e86:	cf 90       	pop	r12
    1e88:	bf 90       	pop	r11
    1e8a:	af 90       	pop	r10
    1e8c:	9f 90       	pop	r9
    1e8e:	8f 90       	pop	r8
    1e90:	7f 90       	pop	r7
    1e92:	6f 90       	pop	r6
    1e94:	5f 90       	pop	r5
    1e96:	4f 90       	pop	r4
    1e98:	08 95       	ret

00001e9a <vTaskResume>:
    1e9a:	0f 93       	push	r16
    1e9c:	1f 93       	push	r17
    1e9e:	cf 93       	push	r28
    1ea0:	df 93       	push	r29
    1ea2:	ec 01       	movw	r28, r24
    1ea4:	00 97       	sbiw	r24, 0x00	; 0
    1ea6:	09 f4       	brne	.+2      	; 0x1eaa <vTaskResume+0x10>
    1ea8:	3e c0       	rjmp	.+124    	; 0x1f26 <vTaskResume+0x8c>
    1eaa:	80 91 8f 08 	lds	r24, 0x088F
    1eae:	90 91 90 08 	lds	r25, 0x0890
    1eb2:	c8 17       	cp	r28, r24
    1eb4:	d9 07       	cpc	r29, r25
    1eb6:	b9 f1       	breq	.+110    	; 0x1f26 <vTaskResume+0x8c>
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	0f 92       	push	r0
    1ebe:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ec0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ec2:	80 53       	subi	r24, 0x30	; 48
    1ec4:	98 40       	sbci	r25, 0x08	; 8
    1ec6:	69 f5       	brne	.+90     	; 0x1f22 <vTaskResume+0x88>
    1ec8:	8c 89       	ldd	r24, Y+20	; 0x14
    1eca:	9d 89       	ldd	r25, Y+21	; 0x15
    1ecc:	28 e0       	ldi	r18, 0x08	; 8
    1ece:	83 34       	cpi	r24, 0x43	; 67
    1ed0:	92 07       	cpc	r25, r18
    1ed2:	39 f1       	breq	.+78     	; 0x1f22 <vTaskResume+0x88>
    1ed4:	89 2b       	or	r24, r25
    1ed6:	29 f5       	brne	.+74     	; 0x1f22 <vTaskResume+0x88>
    1ed8:	8e 01       	movw	r16, r28
    1eda:	0e 5f       	subi	r16, 0xFE	; 254
    1edc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ede:	c8 01       	movw	r24, r16
    1ee0:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    1ee4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ee6:	90 91 2c 08 	lds	r25, 0x082C
    1eea:	98 17       	cp	r25, r24
    1eec:	10 f4       	brcc	.+4      	; 0x1ef2 <vTaskResume+0x58>
    1eee:	80 93 2c 08 	sts	0x082C, r24
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	9c 01       	movw	r18, r24
    1ef6:	22 0f       	add	r18, r18
    1ef8:	33 1f       	adc	r19, r19
    1efa:	22 0f       	add	r18, r18
    1efc:	33 1f       	adc	r19, r19
    1efe:	22 0f       	add	r18, r18
    1f00:	33 1f       	adc	r19, r19
    1f02:	82 0f       	add	r24, r18
    1f04:	93 1f       	adc	r25, r19
    1f06:	b8 01       	movw	r22, r16
    1f08:	8e 59       	subi	r24, 0x9E	; 158
    1f0a:	97 4f       	sbci	r25, 0xF7	; 247
    1f0c:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    1f10:	e0 91 8f 08 	lds	r30, 0x088F
    1f14:	f0 91 90 08 	lds	r31, 0x0890
    1f18:	9e 89       	ldd	r25, Y+22	; 0x16
    1f1a:	86 89       	ldd	r24, Z+22	; 0x16
    1f1c:	98 17       	cp	r25, r24
    1f1e:	08 f0       	brcs	.+2      	; 0x1f22 <vTaskResume+0x88>
    1f20:	6f da       	rcall	.-2850   	; 0x1400 <vPortYield>
    1f22:	0f 90       	pop	r0
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	1f 91       	pop	r17
    1f2c:	0f 91       	pop	r16
    1f2e:	08 95       	ret

00001f30 <vTaskStartScheduler>:
    1f30:	af 92       	push	r10
    1f32:	bf 92       	push	r11
    1f34:	cf 92       	push	r12
    1f36:	df 92       	push	r13
    1f38:	ef 92       	push	r14
    1f3a:	ff 92       	push	r15
    1f3c:	0f 93       	push	r16
    1f3e:	a1 2c       	mov	r10, r1
    1f40:	b1 2c       	mov	r11, r1
    1f42:	c1 2c       	mov	r12, r1
    1f44:	d1 2c       	mov	r13, r1
    1f46:	e1 2c       	mov	r14, r1
    1f48:	f1 2c       	mov	r15, r1
    1f4a:	00 e0       	ldi	r16, 0x00	; 0
    1f4c:	20 e0       	ldi	r18, 0x00	; 0
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	45 e5       	ldi	r20, 0x55	; 85
    1f52:	50 e0       	ldi	r21, 0x00	; 0
    1f54:	68 e3       	ldi	r22, 0x38	; 56
    1f56:	72 e0       	ldi	r23, 0x02	; 2
    1f58:	83 e5       	ldi	r24, 0x53	; 83
    1f5a:	91 e1       	ldi	r25, 0x11	; 17
    1f5c:	89 de       	rcall	.-750    	; 0x1c70 <xTaskGenericCreate>
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	41 f4       	brne	.+16     	; 0x1f72 <vTaskStartScheduler+0x42>
    1f62:	f8 94       	cli
    1f64:	80 93 2b 08 	sts	0x082B, r24
    1f68:	10 92 2e 08 	sts	0x082E, r1
    1f6c:	10 92 2d 08 	sts	0x082D, r1
    1f70:	0a da       	rcall	.-3052   	; 0x1386 <xPortStartScheduler>
    1f72:	0f 91       	pop	r16
    1f74:	ff 90       	pop	r15
    1f76:	ef 90       	pop	r14
    1f78:	df 90       	pop	r13
    1f7a:	cf 90       	pop	r12
    1f7c:	bf 90       	pop	r11
    1f7e:	af 90       	pop	r10
    1f80:	08 95       	ret

00001f82 <vTaskSuspendAll>:
    1f82:	80 91 26 08 	lds	r24, 0x0826
    1f86:	8f 5f       	subi	r24, 0xFF	; 255
    1f88:	80 93 26 08 	sts	0x0826, r24
    1f8c:	08 95       	ret

00001f8e <xTaskGetTickCount>:
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	0f 92       	push	r0
    1f94:	80 91 2d 08 	lds	r24, 0x082D
    1f98:	90 91 2e 08 	lds	r25, 0x082E
    1f9c:	0f 90       	pop	r0
    1f9e:	0f be       	out	0x3f, r0	; 63
    1fa0:	08 95       	ret

00001fa2 <xTaskGetTickCountFromISR>:
    1fa2:	80 91 2d 08 	lds	r24, 0x082D
    1fa6:	90 91 2e 08 	lds	r25, 0x082E
    1faa:	08 95       	ret

00001fac <xTaskIncrementTick>:
    1fac:	cf 92       	push	r12
    1fae:	df 92       	push	r13
    1fb0:	ef 92       	push	r14
    1fb2:	ff 92       	push	r15
    1fb4:	0f 93       	push	r16
    1fb6:	1f 93       	push	r17
    1fb8:	cf 93       	push	r28
    1fba:	df 93       	push	r29
    1fbc:	80 91 26 08 	lds	r24, 0x0826
    1fc0:	81 11       	cpse	r24, r1
    1fc2:	99 c0       	rjmp	.+306    	; 0x20f6 <xTaskIncrementTick+0x14a>
    1fc4:	80 91 2d 08 	lds	r24, 0x082D
    1fc8:	90 91 2e 08 	lds	r25, 0x082E
    1fcc:	01 96       	adiw	r24, 0x01	; 1
    1fce:	90 93 2e 08 	sts	0x082E, r25
    1fd2:	80 93 2d 08 	sts	0x082D, r24
    1fd6:	e0 90 2d 08 	lds	r14, 0x082D
    1fda:	f0 90 2e 08 	lds	r15, 0x082E
    1fde:	e1 14       	cp	r14, r1
    1fe0:	f1 04       	cpc	r15, r1
    1fe2:	b1 f4       	brne	.+44     	; 0x2010 <xTaskIncrementTick+0x64>
    1fe4:	80 91 4e 08 	lds	r24, 0x084E
    1fe8:	90 91 4f 08 	lds	r25, 0x084F
    1fec:	20 91 4c 08 	lds	r18, 0x084C
    1ff0:	30 91 4d 08 	lds	r19, 0x084D
    1ff4:	30 93 4f 08 	sts	0x084F, r19
    1ff8:	20 93 4e 08 	sts	0x084E, r18
    1ffc:	90 93 4d 08 	sts	0x084D, r25
    2000:	80 93 4c 08 	sts	0x084C, r24
    2004:	80 91 28 08 	lds	r24, 0x0828
    2008:	8f 5f       	subi	r24, 0xFF	; 255
    200a:	80 93 28 08 	sts	0x0828, r24
    200e:	da dd       	rcall	.-1100   	; 0x1bc4 <prvResetNextTaskUnblockTime>
    2010:	80 91 04 02 	lds	r24, 0x0204
    2014:	90 91 05 02 	lds	r25, 0x0205
    2018:	e8 16       	cp	r14, r24
    201a:	f9 06       	cpc	r15, r25
    201c:	08 f4       	brcc	.+2      	; 0x2020 <xTaskIncrementTick+0x74>
    201e:	54 c0       	rjmp	.+168    	; 0x20c8 <xTaskIncrementTick+0x11c>
    2020:	d1 2c       	mov	r13, r1
    2022:	cc 24       	eor	r12, r12
    2024:	c3 94       	inc	r12
    2026:	01 c0       	rjmp	.+2      	; 0x202a <xTaskIncrementTick+0x7e>
    2028:	dc 2c       	mov	r13, r12
    202a:	e0 91 4e 08 	lds	r30, 0x084E
    202e:	f0 91 4f 08 	lds	r31, 0x084F
    2032:	80 81       	ld	r24, Z
    2034:	81 11       	cpse	r24, r1
    2036:	07 c0       	rjmp	.+14     	; 0x2046 <xTaskIncrementTick+0x9a>
    2038:	8f ef       	ldi	r24, 0xFF	; 255
    203a:	9f ef       	ldi	r25, 0xFF	; 255
    203c:	90 93 05 02 	sts	0x0205, r25
    2040:	80 93 04 02 	sts	0x0204, r24
    2044:	42 c0       	rjmp	.+132    	; 0x20ca <xTaskIncrementTick+0x11e>
    2046:	e0 91 4e 08 	lds	r30, 0x084E
    204a:	f0 91 4f 08 	lds	r31, 0x084F
    204e:	05 80       	ldd	r0, Z+5	; 0x05
    2050:	f6 81       	ldd	r31, Z+6	; 0x06
    2052:	e0 2d       	mov	r30, r0
    2054:	c6 81       	ldd	r28, Z+6	; 0x06
    2056:	d7 81       	ldd	r29, Z+7	; 0x07
    2058:	2a 81       	ldd	r18, Y+2	; 0x02
    205a:	3b 81       	ldd	r19, Y+3	; 0x03
    205c:	e2 16       	cp	r14, r18
    205e:	f3 06       	cpc	r15, r19
    2060:	28 f4       	brcc	.+10     	; 0x206c <xTaskIncrementTick+0xc0>
    2062:	30 93 05 02 	sts	0x0205, r19
    2066:	20 93 04 02 	sts	0x0204, r18
    206a:	2f c0       	rjmp	.+94     	; 0x20ca <xTaskIncrementTick+0x11e>
    206c:	8e 01       	movw	r16, r28
    206e:	0e 5f       	subi	r16, 0xFE	; 254
    2070:	1f 4f       	sbci	r17, 0xFF	; 255
    2072:	c8 01       	movw	r24, r16
    2074:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    2078:	8c 89       	ldd	r24, Y+20	; 0x14
    207a:	9d 89       	ldd	r25, Y+21	; 0x15
    207c:	89 2b       	or	r24, r25
    207e:	21 f0       	breq	.+8      	; 0x2088 <xTaskIncrementTick+0xdc>
    2080:	ce 01       	movw	r24, r28
    2082:	0c 96       	adiw	r24, 0x0c	; 12
    2084:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    2088:	2e 89       	ldd	r18, Y+22	; 0x16
    208a:	80 91 2c 08 	lds	r24, 0x082C
    208e:	82 17       	cp	r24, r18
    2090:	10 f4       	brcc	.+4      	; 0x2096 <xTaskIncrementTick+0xea>
    2092:	20 93 2c 08 	sts	0x082C, r18
    2096:	30 e0       	ldi	r19, 0x00	; 0
    2098:	c9 01       	movw	r24, r18
    209a:	88 0f       	add	r24, r24
    209c:	99 1f       	adc	r25, r25
    209e:	88 0f       	add	r24, r24
    20a0:	99 1f       	adc	r25, r25
    20a2:	88 0f       	add	r24, r24
    20a4:	99 1f       	adc	r25, r25
    20a6:	82 0f       	add	r24, r18
    20a8:	93 1f       	adc	r25, r19
    20aa:	b8 01       	movw	r22, r16
    20ac:	8e 59       	subi	r24, 0x9E	; 158
    20ae:	97 4f       	sbci	r25, 0xF7	; 247
    20b0:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    20b4:	e0 91 8f 08 	lds	r30, 0x088F
    20b8:	f0 91 90 08 	lds	r31, 0x0890
    20bc:	9e 89       	ldd	r25, Y+22	; 0x16
    20be:	86 89       	ldd	r24, Z+22	; 0x16
    20c0:	98 17       	cp	r25, r24
    20c2:	08 f0       	brcs	.+2      	; 0x20c6 <xTaskIncrementTick+0x11a>
    20c4:	b1 cf       	rjmp	.-158    	; 0x2028 <xTaskIncrementTick+0x7c>
    20c6:	b1 cf       	rjmp	.-158    	; 0x202a <xTaskIncrementTick+0x7e>
    20c8:	d1 2c       	mov	r13, r1
    20ca:	e0 91 8f 08 	lds	r30, 0x088F
    20ce:	f0 91 90 08 	lds	r31, 0x0890
    20d2:	86 89       	ldd	r24, Z+22	; 0x16
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	fc 01       	movw	r30, r24
    20d8:	ee 0f       	add	r30, r30
    20da:	ff 1f       	adc	r31, r31
    20dc:	ee 0f       	add	r30, r30
    20de:	ff 1f       	adc	r31, r31
    20e0:	ee 0f       	add	r30, r30
    20e2:	ff 1f       	adc	r31, r31
    20e4:	8e 0f       	add	r24, r30
    20e6:	9f 1f       	adc	r25, r31
    20e8:	fc 01       	movw	r30, r24
    20ea:	ee 59       	subi	r30, 0x9E	; 158
    20ec:	f7 4f       	sbci	r31, 0xF7	; 247
    20ee:	80 81       	ld	r24, Z
    20f0:	82 30       	cpi	r24, 0x02	; 2
    20f2:	40 f4       	brcc	.+16     	; 0x2104 <xTaskIncrementTick+0x158>
    20f4:	09 c0       	rjmp	.+18     	; 0x2108 <xTaskIncrementTick+0x15c>
    20f6:	80 91 2a 08 	lds	r24, 0x082A
    20fa:	8f 5f       	subi	r24, 0xFF	; 255
    20fc:	80 93 2a 08 	sts	0x082A, r24
    2100:	d1 2c       	mov	r13, r1
    2102:	02 c0       	rjmp	.+4      	; 0x2108 <xTaskIncrementTick+0x15c>
    2104:	dd 24       	eor	r13, r13
    2106:	d3 94       	inc	r13
    2108:	80 91 29 08 	lds	r24, 0x0829
    210c:	88 23       	and	r24, r24
    210e:	11 f0       	breq	.+4      	; 0x2114 <xTaskIncrementTick+0x168>
    2110:	dd 24       	eor	r13, r13
    2112:	d3 94       	inc	r13
    2114:	8d 2d       	mov	r24, r13
    2116:	df 91       	pop	r29
    2118:	cf 91       	pop	r28
    211a:	1f 91       	pop	r17
    211c:	0f 91       	pop	r16
    211e:	ff 90       	pop	r15
    2120:	ef 90       	pop	r14
    2122:	df 90       	pop	r13
    2124:	cf 90       	pop	r12
    2126:	08 95       	ret

00002128 <xTaskResumeAll>:
    2128:	df 92       	push	r13
    212a:	ef 92       	push	r14
    212c:	ff 92       	push	r15
    212e:	0f 93       	push	r16
    2130:	1f 93       	push	r17
    2132:	cf 93       	push	r28
    2134:	df 93       	push	r29
    2136:	0f b6       	in	r0, 0x3f	; 63
    2138:	f8 94       	cli
    213a:	0f 92       	push	r0
    213c:	80 91 26 08 	lds	r24, 0x0826
    2140:	81 50       	subi	r24, 0x01	; 1
    2142:	80 93 26 08 	sts	0x0826, r24
    2146:	80 91 26 08 	lds	r24, 0x0826
    214a:	81 11       	cpse	r24, r1
    214c:	5f c0       	rjmp	.+190    	; 0x220c <__stack+0xd>
    214e:	80 91 2f 08 	lds	r24, 0x082F
    2152:	88 23       	and	r24, r24
    2154:	09 f4       	brne	.+2      	; 0x2158 <xTaskResumeAll+0x30>
    2156:	5c c0       	rjmp	.+184    	; 0x2210 <__stack+0x11>
    2158:	0f 2e       	mov	r0, r31
    215a:	f3 e4       	ldi	r31, 0x43	; 67
    215c:	ef 2e       	mov	r14, r31
    215e:	f8 e0       	ldi	r31, 0x08	; 8
    2160:	ff 2e       	mov	r15, r31
    2162:	f0 2d       	mov	r31, r0
    2164:	dd 24       	eor	r13, r13
    2166:	d3 94       	inc	r13
    2168:	30 c0       	rjmp	.+96     	; 0x21ca <xTaskResumeAll+0xa2>
    216a:	e0 91 48 08 	lds	r30, 0x0848
    216e:	f0 91 49 08 	lds	r31, 0x0849
    2172:	c6 81       	ldd	r28, Z+6	; 0x06
    2174:	d7 81       	ldd	r29, Z+7	; 0x07
    2176:	ce 01       	movw	r24, r28
    2178:	0c 96       	adiw	r24, 0x0c	; 12
    217a:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    217e:	8e 01       	movw	r16, r28
    2180:	0e 5f       	subi	r16, 0xFE	; 254
    2182:	1f 4f       	sbci	r17, 0xFF	; 255
    2184:	c8 01       	movw	r24, r16
    2186:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    218a:	8e 89       	ldd	r24, Y+22	; 0x16
    218c:	90 91 2c 08 	lds	r25, 0x082C
    2190:	98 17       	cp	r25, r24
    2192:	10 f4       	brcc	.+4      	; 0x2198 <xTaskResumeAll+0x70>
    2194:	80 93 2c 08 	sts	0x082C, r24
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	9c 01       	movw	r18, r24
    219c:	22 0f       	add	r18, r18
    219e:	33 1f       	adc	r19, r19
    21a0:	22 0f       	add	r18, r18
    21a2:	33 1f       	adc	r19, r19
    21a4:	22 0f       	add	r18, r18
    21a6:	33 1f       	adc	r19, r19
    21a8:	82 0f       	add	r24, r18
    21aa:	93 1f       	adc	r25, r19
    21ac:	b8 01       	movw	r22, r16
    21ae:	8e 59       	subi	r24, 0x9E	; 158
    21b0:	97 4f       	sbci	r25, 0xF7	; 247
    21b2:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    21b6:	e0 91 8f 08 	lds	r30, 0x088F
    21ba:	f0 91 90 08 	lds	r31, 0x0890
    21be:	9e 89       	ldd	r25, Y+22	; 0x16
    21c0:	86 89       	ldd	r24, Z+22	; 0x16
    21c2:	98 17       	cp	r25, r24
    21c4:	10 f0       	brcs	.+4      	; 0x21ca <xTaskResumeAll+0xa2>
    21c6:	d0 92 29 08 	sts	0x0829, r13
    21ca:	f7 01       	movw	r30, r14
    21cc:	80 81       	ld	r24, Z
    21ce:	81 11       	cpse	r24, r1
    21d0:	cc cf       	rjmp	.-104    	; 0x216a <xTaskResumeAll+0x42>
    21d2:	80 91 2a 08 	lds	r24, 0x082A
    21d6:	88 23       	and	r24, r24
    21d8:	91 f0       	breq	.+36     	; 0x21fe <xTaskResumeAll+0xd6>
    21da:	80 91 2a 08 	lds	r24, 0x082A
    21de:	88 23       	and	r24, r24
    21e0:	71 f0       	breq	.+28     	; 0x21fe <xTaskResumeAll+0xd6>
    21e2:	c1 e0       	ldi	r28, 0x01	; 1
    21e4:	e3 de       	rcall	.-570    	; 0x1fac <xTaskIncrementTick>
    21e6:	81 11       	cpse	r24, r1
    21e8:	c0 93 29 08 	sts	0x0829, r28
    21ec:	80 91 2a 08 	lds	r24, 0x082A
    21f0:	81 50       	subi	r24, 0x01	; 1
    21f2:	80 93 2a 08 	sts	0x082A, r24
    21f6:	80 91 2a 08 	lds	r24, 0x082A
    21fa:	81 11       	cpse	r24, r1
    21fc:	f3 cf       	rjmp	.-26     	; 0x21e4 <xTaskResumeAll+0xbc>
    21fe:	80 91 29 08 	lds	r24, 0x0829
    2202:	81 30       	cpi	r24, 0x01	; 1
    2204:	39 f4       	brne	.+14     	; 0x2214 <__stack+0x15>
    2206:	fc d8       	rcall	.-3592   	; 0x1400 <vPortYield>
    2208:	81 e0       	ldi	r24, 0x01	; 1
    220a:	05 c0       	rjmp	.+10     	; 0x2216 <__stack+0x17>
    220c:	80 e0       	ldi	r24, 0x00	; 0
    220e:	03 c0       	rjmp	.+6      	; 0x2216 <__stack+0x17>
    2210:	80 e0       	ldi	r24, 0x00	; 0
    2212:	01 c0       	rjmp	.+2      	; 0x2216 <__stack+0x17>
    2214:	80 e0       	ldi	r24, 0x00	; 0
    2216:	0f 90       	pop	r0
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	df 91       	pop	r29
    221c:	cf 91       	pop	r28
    221e:	1f 91       	pop	r17
    2220:	0f 91       	pop	r16
    2222:	ff 90       	pop	r15
    2224:	ef 90       	pop	r14
    2226:	df 90       	pop	r13
    2228:	08 95       	ret

0000222a <vTaskDelayUntil>:
    222a:	0f 93       	push	r16
    222c:	1f 93       	push	r17
    222e:	cf 93       	push	r28
    2230:	df 93       	push	r29
    2232:	8c 01       	movw	r16, r24
    2234:	eb 01       	movw	r28, r22
    2236:	a5 de       	rcall	.-694    	; 0x1f82 <vTaskSuspendAll>
    2238:	80 91 2d 08 	lds	r24, 0x082D
    223c:	90 91 2e 08 	lds	r25, 0x082E
    2240:	f8 01       	movw	r30, r16
    2242:	20 81       	ld	r18, Z
    2244:	31 81       	ldd	r19, Z+1	; 0x01
    2246:	c2 0f       	add	r28, r18
    2248:	d3 1f       	adc	r29, r19
    224a:	82 17       	cp	r24, r18
    224c:	93 07       	cpc	r25, r19
    224e:	48 f4       	brcc	.+18     	; 0x2262 <vTaskDelayUntil+0x38>
    2250:	c2 17       	cp	r28, r18
    2252:	d3 07       	cpc	r29, r19
    2254:	f8 f4       	brcc	.+62     	; 0x2294 <vTaskDelayUntil+0x6a>
    2256:	d1 83       	std	Z+1, r29	; 0x01
    2258:	c0 83       	st	Z, r28
    225a:	8c 17       	cp	r24, r28
    225c:	9d 07       	cpc	r25, r29
    225e:	88 f4       	brcc	.+34     	; 0x2282 <vTaskDelayUntil+0x58>
    2260:	07 c0       	rjmp	.+14     	; 0x2270 <vTaskDelayUntil+0x46>
    2262:	c2 17       	cp	r28, r18
    2264:	d3 07       	cpc	r29, r19
    2266:	90 f0       	brcs	.+36     	; 0x228c <vTaskDelayUntil+0x62>
    2268:	8c 17       	cp	r24, r28
    226a:	9d 07       	cpc	r25, r29
    226c:	78 f0       	brcs	.+30     	; 0x228c <vTaskDelayUntil+0x62>
    226e:	12 c0       	rjmp	.+36     	; 0x2294 <vTaskDelayUntil+0x6a>
    2270:	80 91 8f 08 	lds	r24, 0x088F
    2274:	90 91 90 08 	lds	r25, 0x0890
    2278:	02 96       	adiw	r24, 0x02	; 2
    227a:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    227e:	ce 01       	movw	r24, r28
    2280:	c0 dc       	rcall	.-1664   	; 0x1c02 <prvAddCurrentTaskToDelayedList>
    2282:	52 df       	rcall	.-348    	; 0x2128 <xTaskResumeAll>
    2284:	81 11       	cpse	r24, r1
    2286:	0a c0       	rjmp	.+20     	; 0x229c <vTaskDelayUntil+0x72>
    2288:	bb d8       	rcall	.-3722   	; 0x1400 <vPortYield>
    228a:	08 c0       	rjmp	.+16     	; 0x229c <vTaskDelayUntil+0x72>
    228c:	f8 01       	movw	r30, r16
    228e:	d1 83       	std	Z+1, r29	; 0x01
    2290:	c0 83       	st	Z, r28
    2292:	ee cf       	rjmp	.-36     	; 0x2270 <vTaskDelayUntil+0x46>
    2294:	f8 01       	movw	r30, r16
    2296:	d1 83       	std	Z+1, r29	; 0x01
    2298:	c0 83       	st	Z, r28
    229a:	f3 cf       	rjmp	.-26     	; 0x2282 <vTaskDelayUntil+0x58>
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	08 95       	ret

000022a6 <prvIdleTask>:
    22a6:	0f 2e       	mov	r0, r31
    22a8:	f2 e6       	ldi	r31, 0x62	; 98
    22aa:	ef 2e       	mov	r14, r31
    22ac:	f8 e0       	ldi	r31, 0x08	; 8
    22ae:	ff 2e       	mov	r15, r31
    22b0:	f0 2d       	mov	r31, r0
    22b2:	ca e3       	ldi	r28, 0x3A	; 58
    22b4:	d8 e0       	ldi	r29, 0x08	; 8
    22b6:	26 c0       	rjmp	.+76     	; 0x2304 <prvIdleTask+0x5e>
    22b8:	64 de       	rcall	.-824    	; 0x1f82 <vTaskSuspendAll>
    22ba:	18 81       	ld	r17, Y
    22bc:	35 df       	rcall	.-406    	; 0x2128 <xTaskResumeAll>
    22be:	11 23       	and	r17, r17
    22c0:	09 f1       	breq	.+66     	; 0x2304 <prvIdleTask+0x5e>
    22c2:	0f b6       	in	r0, 0x3f	; 63
    22c4:	f8 94       	cli
    22c6:	0f 92       	push	r0
    22c8:	e0 91 3f 08 	lds	r30, 0x083F
    22cc:	f0 91 40 08 	lds	r31, 0x0840
    22d0:	06 81       	ldd	r16, Z+6	; 0x06
    22d2:	17 81       	ldd	r17, Z+7	; 0x07
    22d4:	c8 01       	movw	r24, r16
    22d6:	02 96       	adiw	r24, 0x02	; 2
    22d8:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    22dc:	80 91 2f 08 	lds	r24, 0x082F
    22e0:	81 50       	subi	r24, 0x01	; 1
    22e2:	80 93 2f 08 	sts	0x082F, r24
    22e6:	80 91 39 08 	lds	r24, 0x0839
    22ea:	81 50       	subi	r24, 0x01	; 1
    22ec:	80 93 39 08 	sts	0x0839, r24
    22f0:	0f 90       	pop	r0
    22f2:	0f be       	out	0x3f, r0	; 63
    22f4:	f8 01       	movw	r30, r16
    22f6:	87 89       	ldd	r24, Z+23	; 0x17
    22f8:	90 8d       	ldd	r25, Z+24	; 0x18
    22fa:	0e 94 30 03 	call	0x660	; 0x660 <vPortFree>
    22fe:	c8 01       	movw	r24, r16
    2300:	0e 94 30 03 	call	0x660	; 0x660 <vPortFree>
    2304:	80 91 39 08 	lds	r24, 0x0839
    2308:	81 11       	cpse	r24, r1
    230a:	d6 cf       	rjmp	.-84     	; 0x22b8 <prvIdleTask+0x12>
    230c:	f7 01       	movw	r30, r14
    230e:	80 81       	ld	r24, Z
    2310:	82 30       	cpi	r24, 0x02	; 2
    2312:	c0 f3       	brcs	.-16     	; 0x2304 <prvIdleTask+0x5e>
    2314:	75 d8       	rcall	.-3862   	; 0x1400 <vPortYield>
    2316:	f6 cf       	rjmp	.-20     	; 0x2304 <prvIdleTask+0x5e>

00002318 <vTaskSwitchContext>:
    2318:	80 91 26 08 	lds	r24, 0x0826
    231c:	88 23       	and	r24, r24
    231e:	21 f0       	breq	.+8      	; 0x2328 <vTaskSwitchContext+0x10>
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	80 93 29 08 	sts	0x0829, r24
    2326:	08 95       	ret
    2328:	10 92 29 08 	sts	0x0829, r1
    232c:	80 91 2c 08 	lds	r24, 0x082C
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	fc 01       	movw	r30, r24
    2334:	ee 0f       	add	r30, r30
    2336:	ff 1f       	adc	r31, r31
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	ee 0f       	add	r30, r30
    233e:	ff 1f       	adc	r31, r31
    2340:	8e 0f       	add	r24, r30
    2342:	9f 1f       	adc	r25, r31
    2344:	fc 01       	movw	r30, r24
    2346:	ee 59       	subi	r30, 0x9E	; 158
    2348:	f7 4f       	sbci	r31, 0xF7	; 247
    234a:	80 81       	ld	r24, Z
    234c:	81 11       	cpse	r24, r1
    234e:	17 c0       	rjmp	.+46     	; 0x237e <vTaskSwitchContext+0x66>
    2350:	80 91 2c 08 	lds	r24, 0x082C
    2354:	81 50       	subi	r24, 0x01	; 1
    2356:	80 93 2c 08 	sts	0x082C, r24
    235a:	80 91 2c 08 	lds	r24, 0x082C
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	fc 01       	movw	r30, r24
    2362:	ee 0f       	add	r30, r30
    2364:	ff 1f       	adc	r31, r31
    2366:	ee 0f       	add	r30, r30
    2368:	ff 1f       	adc	r31, r31
    236a:	ee 0f       	add	r30, r30
    236c:	ff 1f       	adc	r31, r31
    236e:	8e 0f       	add	r24, r30
    2370:	9f 1f       	adc	r25, r31
    2372:	fc 01       	movw	r30, r24
    2374:	ee 59       	subi	r30, 0x9E	; 158
    2376:	f7 4f       	sbci	r31, 0xF7	; 247
    2378:	80 81       	ld	r24, Z
    237a:	88 23       	and	r24, r24
    237c:	49 f3       	breq	.-46     	; 0x2350 <vTaskSwitchContext+0x38>
    237e:	e0 91 2c 08 	lds	r30, 0x082C
    2382:	f0 e0       	ldi	r31, 0x00	; 0
    2384:	cf 01       	movw	r24, r30
    2386:	88 0f       	add	r24, r24
    2388:	99 1f       	adc	r25, r25
    238a:	88 0f       	add	r24, r24
    238c:	99 1f       	adc	r25, r25
    238e:	88 0f       	add	r24, r24
    2390:	99 1f       	adc	r25, r25
    2392:	e8 0f       	add	r30, r24
    2394:	f9 1f       	adc	r31, r25
    2396:	ee 59       	subi	r30, 0x9E	; 158
    2398:	f7 4f       	sbci	r31, 0xF7	; 247
    239a:	a1 81       	ldd	r26, Z+1	; 0x01
    239c:	b2 81       	ldd	r27, Z+2	; 0x02
    239e:	12 96       	adiw	r26, 0x02	; 2
    23a0:	0d 90       	ld	r0, X+
    23a2:	bc 91       	ld	r27, X
    23a4:	a0 2d       	mov	r26, r0
    23a6:	b2 83       	std	Z+2, r27	; 0x02
    23a8:	a1 83       	std	Z+1, r26	; 0x01
    23aa:	cf 01       	movw	r24, r30
    23ac:	03 96       	adiw	r24, 0x03	; 3
    23ae:	a8 17       	cp	r26, r24
    23b0:	b9 07       	cpc	r27, r25
    23b2:	31 f4       	brne	.+12     	; 0x23c0 <vTaskSwitchContext+0xa8>
    23b4:	12 96       	adiw	r26, 0x02	; 2
    23b6:	8d 91       	ld	r24, X+
    23b8:	9c 91       	ld	r25, X
    23ba:	13 97       	sbiw	r26, 0x03	; 3
    23bc:	92 83       	std	Z+2, r25	; 0x02
    23be:	81 83       	std	Z+1, r24	; 0x01
    23c0:	01 80       	ldd	r0, Z+1	; 0x01
    23c2:	f2 81       	ldd	r31, Z+2	; 0x02
    23c4:	e0 2d       	mov	r30, r0
    23c6:	86 81       	ldd	r24, Z+6	; 0x06
    23c8:	97 81       	ldd	r25, Z+7	; 0x07
    23ca:	90 93 90 08 	sts	0x0890, r25
    23ce:	80 93 8f 08 	sts	0x088F, r24
    23d2:	08 95       	ret

000023d4 <vTaskSuspend>:
    23d4:	0f 93       	push	r16
    23d6:	1f 93       	push	r17
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
    23dc:	ec 01       	movw	r28, r24
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	0f 92       	push	r0
    23e4:	00 97       	sbiw	r24, 0x00	; 0
    23e6:	21 f4       	brne	.+8      	; 0x23f0 <vTaskSuspend+0x1c>
    23e8:	c0 91 8f 08 	lds	r28, 0x088F
    23ec:	d0 91 90 08 	lds	r29, 0x0890
    23f0:	8e 01       	movw	r16, r28
    23f2:	0e 5f       	subi	r16, 0xFE	; 254
    23f4:	1f 4f       	sbci	r17, 0xFF	; 255
    23f6:	c8 01       	movw	r24, r16
    23f8:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    23fc:	8c 89       	ldd	r24, Y+20	; 0x14
    23fe:	9d 89       	ldd	r25, Y+21	; 0x15
    2400:	89 2b       	or	r24, r25
    2402:	21 f0       	breq	.+8      	; 0x240c <vTaskSuspend+0x38>
    2404:	ce 01       	movw	r24, r28
    2406:	0c 96       	adiw	r24, 0x0c	; 12
    2408:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    240c:	b8 01       	movw	r22, r16
    240e:	80 e3       	ldi	r24, 0x30	; 48
    2410:	98 e0       	ldi	r25, 0x08	; 8
    2412:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    2416:	0f 90       	pop	r0
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	80 91 8f 08 	lds	r24, 0x088F
    241e:	90 91 90 08 	lds	r25, 0x0890
    2422:	c8 17       	cp	r28, r24
    2424:	d9 07       	cpc	r29, r25
    2426:	a1 f4       	brne	.+40     	; 0x2450 <vTaskSuspend+0x7c>
    2428:	80 91 2b 08 	lds	r24, 0x082B
    242c:	88 23       	and	r24, r24
    242e:	19 f0       	breq	.+6      	; 0x2436 <vTaskSuspend+0x62>
    2430:	0e 94 00 0a 	call	0x1400	; 0x1400 <vPortYield>
    2434:	17 c0       	rjmp	.+46     	; 0x2464 <vTaskSuspend+0x90>
    2436:	80 91 2f 08 	lds	r24, 0x082F
    243a:	90 91 30 08 	lds	r25, 0x0830
    243e:	98 13       	cpse	r25, r24
    2440:	05 c0       	rjmp	.+10     	; 0x244c <vTaskSuspend+0x78>
    2442:	10 92 90 08 	sts	0x0890, r1
    2446:	10 92 8f 08 	sts	0x088F, r1
    244a:	0c c0       	rjmp	.+24     	; 0x2464 <vTaskSuspend+0x90>
    244c:	65 df       	rcall	.-310    	; 0x2318 <vTaskSwitchContext>
    244e:	0a c0       	rjmp	.+20     	; 0x2464 <vTaskSuspend+0x90>
    2450:	80 91 2b 08 	lds	r24, 0x082B
    2454:	88 23       	and	r24, r24
    2456:	31 f0       	breq	.+12     	; 0x2464 <vTaskSuspend+0x90>
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	f8 94       	cli
    245c:	0f 92       	push	r0
    245e:	b2 db       	rcall	.-2204   	; 0x1bc4 <prvResetNextTaskUnblockTime>
    2460:	0f 90       	pop	r0
    2462:	0f be       	out	0x3f, r0	; 63
    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	08 95       	ret

0000246e <vTaskPlaceOnEventList>:
    246e:	cf 93       	push	r28
    2470:	df 93       	push	r29
    2472:	eb 01       	movw	r28, r22
    2474:	60 91 8f 08 	lds	r22, 0x088F
    2478:	70 91 90 08 	lds	r23, 0x0890
    247c:	64 5f       	subi	r22, 0xF4	; 244
    247e:	7f 4f       	sbci	r23, 0xFF	; 255
    2480:	0e 94 64 03 	call	0x6c8	; 0x6c8 <vListInsert>
    2484:	80 91 8f 08 	lds	r24, 0x088F
    2488:	90 91 90 08 	lds	r25, 0x0890
    248c:	02 96       	adiw	r24, 0x02	; 2
    248e:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    2492:	cf 3f       	cpi	r28, 0xFF	; 255
    2494:	8f ef       	ldi	r24, 0xFF	; 255
    2496:	d8 07       	cpc	r29, r24
    2498:	59 f4       	brne	.+22     	; 0x24b0 <vTaskPlaceOnEventList+0x42>
    249a:	60 91 8f 08 	lds	r22, 0x088F
    249e:	70 91 90 08 	lds	r23, 0x0890
    24a2:	6e 5f       	subi	r22, 0xFE	; 254
    24a4:	7f 4f       	sbci	r23, 0xFF	; 255
    24a6:	80 e3       	ldi	r24, 0x30	; 48
    24a8:	98 e0       	ldi	r25, 0x08	; 8
    24aa:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    24ae:	07 c0       	rjmp	.+14     	; 0x24be <vTaskPlaceOnEventList+0x50>
    24b0:	80 91 2d 08 	lds	r24, 0x082D
    24b4:	90 91 2e 08 	lds	r25, 0x082E
    24b8:	8c 0f       	add	r24, r28
    24ba:	9d 1f       	adc	r25, r29
    24bc:	a2 db       	rcall	.-2236   	; 0x1c02 <prvAddCurrentTaskToDelayedList>
    24be:	df 91       	pop	r29
    24c0:	cf 91       	pop	r28
    24c2:	08 95       	ret

000024c4 <xTaskRemoveFromEventList>:
    24c4:	0f 93       	push	r16
    24c6:	1f 93       	push	r17
    24c8:	cf 93       	push	r28
    24ca:	df 93       	push	r29
    24cc:	dc 01       	movw	r26, r24
    24ce:	15 96       	adiw	r26, 0x05	; 5
    24d0:	ed 91       	ld	r30, X+
    24d2:	fc 91       	ld	r31, X
    24d4:	16 97       	sbiw	r26, 0x06	; 6
    24d6:	c6 81       	ldd	r28, Z+6	; 0x06
    24d8:	d7 81       	ldd	r29, Z+7	; 0x07
    24da:	8e 01       	movw	r16, r28
    24dc:	04 5f       	subi	r16, 0xF4	; 244
    24de:	1f 4f       	sbci	r17, 0xFF	; 255
    24e0:	c8 01       	movw	r24, r16
    24e2:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    24e6:	80 91 26 08 	lds	r24, 0x0826
    24ea:	81 11       	cpse	r24, r1
    24ec:	1c c0       	rjmp	.+56     	; 0x2526 <xTaskRemoveFromEventList+0x62>
    24ee:	0a 50       	subi	r16, 0x0A	; 10
    24f0:	11 09       	sbc	r17, r1
    24f2:	c8 01       	movw	r24, r16
    24f4:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    24f8:	8e 89       	ldd	r24, Y+22	; 0x16
    24fa:	90 91 2c 08 	lds	r25, 0x082C
    24fe:	98 17       	cp	r25, r24
    2500:	10 f4       	brcc	.+4      	; 0x2506 <xTaskRemoveFromEventList+0x42>
    2502:	80 93 2c 08 	sts	0x082C, r24
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	9c 01       	movw	r18, r24
    250a:	22 0f       	add	r18, r18
    250c:	33 1f       	adc	r19, r19
    250e:	22 0f       	add	r18, r18
    2510:	33 1f       	adc	r19, r19
    2512:	22 0f       	add	r18, r18
    2514:	33 1f       	adc	r19, r19
    2516:	82 0f       	add	r24, r18
    2518:	93 1f       	adc	r25, r19
    251a:	b8 01       	movw	r22, r16
    251c:	8e 59       	subi	r24, 0x9E	; 158
    251e:	97 4f       	sbci	r25, 0xF7	; 247
    2520:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    2524:	05 c0       	rjmp	.+10     	; 0x2530 <xTaskRemoveFromEventList+0x6c>
    2526:	b8 01       	movw	r22, r16
    2528:	83 e4       	ldi	r24, 0x43	; 67
    252a:	98 e0       	ldi	r25, 0x08	; 8
    252c:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    2530:	e0 91 8f 08 	lds	r30, 0x088F
    2534:	f0 91 90 08 	lds	r31, 0x0890
    2538:	9e 89       	ldd	r25, Y+22	; 0x16
    253a:	86 89       	ldd	r24, Z+22	; 0x16
    253c:	89 17       	cp	r24, r25
    253e:	20 f4       	brcc	.+8      	; 0x2548 <xTaskRemoveFromEventList+0x84>
    2540:	81 e0       	ldi	r24, 0x01	; 1
    2542:	80 93 29 08 	sts	0x0829, r24
    2546:	01 c0       	rjmp	.+2      	; 0x254a <xTaskRemoveFromEventList+0x86>
    2548:	80 e0       	ldi	r24, 0x00	; 0
    254a:	df 91       	pop	r29
    254c:	cf 91       	pop	r28
    254e:	1f 91       	pop	r17
    2550:	0f 91       	pop	r16
    2552:	08 95       	ret

00002554 <vTaskSetTimeOutState>:
    2554:	20 91 28 08 	lds	r18, 0x0828
    2558:	fc 01       	movw	r30, r24
    255a:	20 83       	st	Z, r18
    255c:	20 91 2d 08 	lds	r18, 0x082D
    2560:	30 91 2e 08 	lds	r19, 0x082E
    2564:	32 83       	std	Z+2, r19	; 0x02
    2566:	21 83       	std	Z+1, r18	; 0x01
    2568:	08 95       	ret

0000256a <xTaskCheckForTimeOut>:
    256a:	0f b6       	in	r0, 0x3f	; 63
    256c:	f8 94       	cli
    256e:	0f 92       	push	r0
    2570:	40 91 2d 08 	lds	r20, 0x082D
    2574:	50 91 2e 08 	lds	r21, 0x082E
    2578:	db 01       	movw	r26, r22
    257a:	2d 91       	ld	r18, X+
    257c:	3c 91       	ld	r19, X
    257e:	2f 3f       	cpi	r18, 0xFF	; 255
    2580:	bf ef       	ldi	r27, 0xFF	; 255
    2582:	3b 07       	cpc	r19, r27
    2584:	11 f1       	breq	.+68     	; 0x25ca <xTaskCheckForTimeOut+0x60>
    2586:	e0 91 28 08 	lds	r30, 0x0828
    258a:	dc 01       	movw	r26, r24
    258c:	fc 91       	ld	r31, X
    258e:	fe 17       	cp	r31, r30
    2590:	39 f0       	breq	.+14     	; 0x25a0 <xTaskCheckForTimeOut+0x36>
    2592:	11 96       	adiw	r26, 0x01	; 1
    2594:	ed 91       	ld	r30, X+
    2596:	fc 91       	ld	r31, X
    2598:	12 97       	sbiw	r26, 0x02	; 2
    259a:	4e 17       	cp	r20, r30
    259c:	5f 07       	cpc	r21, r31
    259e:	b8 f4       	brcc	.+46     	; 0x25ce <xTaskCheckForTimeOut+0x64>
    25a0:	dc 01       	movw	r26, r24
    25a2:	11 96       	adiw	r26, 0x01	; 1
    25a4:	ed 91       	ld	r30, X+
    25a6:	fc 91       	ld	r31, X
    25a8:	12 97       	sbiw	r26, 0x02	; 2
    25aa:	da 01       	movw	r26, r20
    25ac:	ae 1b       	sub	r26, r30
    25ae:	bf 0b       	sbc	r27, r31
    25b0:	a2 17       	cp	r26, r18
    25b2:	b3 07       	cpc	r27, r19
    25b4:	70 f4       	brcc	.+28     	; 0x25d2 <xTaskCheckForTimeOut+0x68>
    25b6:	e4 1b       	sub	r30, r20
    25b8:	f5 0b       	sbc	r31, r21
    25ba:	2e 0f       	add	r18, r30
    25bc:	3f 1f       	adc	r19, r31
    25be:	fb 01       	movw	r30, r22
    25c0:	31 83       	std	Z+1, r19	; 0x01
    25c2:	20 83       	st	Z, r18
    25c4:	c7 df       	rcall	.-114    	; 0x2554 <vTaskSetTimeOutState>
    25c6:	80 e0       	ldi	r24, 0x00	; 0
    25c8:	05 c0       	rjmp	.+10     	; 0x25d4 <xTaskCheckForTimeOut+0x6a>
    25ca:	80 e0       	ldi	r24, 0x00	; 0
    25cc:	03 c0       	rjmp	.+6      	; 0x25d4 <xTaskCheckForTimeOut+0x6a>
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	01 c0       	rjmp	.+2      	; 0x25d4 <xTaskCheckForTimeOut+0x6a>
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	0f 90       	pop	r0
    25d6:	0f be       	out	0x3f, r0	; 63
    25d8:	08 95       	ret

000025da <vTaskMissedYield>:
    25da:	81 e0       	ldi	r24, 0x01	; 1
    25dc:	80 93 29 08 	sts	0x0829, r24
    25e0:	08 95       	ret

000025e2 <vTaskPriorityInherit>:
    25e2:	0f 93       	push	r16
    25e4:	1f 93       	push	r17
    25e6:	cf 93       	push	r28
    25e8:	df 93       	push	r29
    25ea:	ec 01       	movw	r28, r24
    25ec:	00 97       	sbiw	r24, 0x00	; 0
    25ee:	09 f4       	brne	.+2      	; 0x25f2 <vTaskPriorityInherit+0x10>
    25f0:	51 c0       	rjmp	.+162    	; 0x2694 <vTaskPriorityInherit+0xb2>
    25f2:	8e 89       	ldd	r24, Y+22	; 0x16
    25f4:	e0 91 8f 08 	lds	r30, 0x088F
    25f8:	f0 91 90 08 	lds	r31, 0x0890
    25fc:	96 89       	ldd	r25, Z+22	; 0x16
    25fe:	89 17       	cp	r24, r25
    2600:	08 f0       	brcs	.+2      	; 0x2604 <vTaskPriorityInherit+0x22>
    2602:	48 c0       	rjmp	.+144    	; 0x2694 <vTaskPriorityInherit+0xb2>
    2604:	2c 85       	ldd	r18, Y+12	; 0x0c
    2606:	3d 85       	ldd	r19, Y+13	; 0x0d
    2608:	33 23       	and	r19, r19
    260a:	5c f0       	brlt	.+22     	; 0x2622 <vTaskPriorityInherit+0x40>
    260c:	e0 91 8f 08 	lds	r30, 0x088F
    2610:	f0 91 90 08 	lds	r31, 0x0890
    2614:	96 89       	ldd	r25, Z+22	; 0x16
    2616:	25 e0       	ldi	r18, 0x05	; 5
    2618:	30 e0       	ldi	r19, 0x00	; 0
    261a:	29 1b       	sub	r18, r25
    261c:	31 09       	sbc	r19, r1
    261e:	3d 87       	std	Y+13, r19	; 0x0d
    2620:	2c 87       	std	Y+12, r18	; 0x0c
    2622:	90 e0       	ldi	r25, 0x00	; 0
    2624:	9c 01       	movw	r18, r24
    2626:	22 0f       	add	r18, r18
    2628:	33 1f       	adc	r19, r19
    262a:	22 0f       	add	r18, r18
    262c:	33 1f       	adc	r19, r19
    262e:	22 0f       	add	r18, r18
    2630:	33 1f       	adc	r19, r19
    2632:	82 0f       	add	r24, r18
    2634:	93 1f       	adc	r25, r19
    2636:	8e 59       	subi	r24, 0x9E	; 158
    2638:	97 4f       	sbci	r25, 0xF7	; 247
    263a:	2a 85       	ldd	r18, Y+10	; 0x0a
    263c:	3b 85       	ldd	r19, Y+11	; 0x0b
    263e:	28 17       	cp	r18, r24
    2640:	39 07       	cpc	r19, r25
    2642:	11 f5       	brne	.+68     	; 0x2688 <vTaskPriorityInherit+0xa6>
    2644:	8e 01       	movw	r16, r28
    2646:	0e 5f       	subi	r16, 0xFE	; 254
    2648:	1f 4f       	sbci	r17, 0xFF	; 255
    264a:	c8 01       	movw	r24, r16
    264c:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    2650:	e0 91 8f 08 	lds	r30, 0x088F
    2654:	f0 91 90 08 	lds	r31, 0x0890
    2658:	86 89       	ldd	r24, Z+22	; 0x16
    265a:	8e 8b       	std	Y+22, r24	; 0x16
    265c:	90 91 2c 08 	lds	r25, 0x082C
    2660:	98 17       	cp	r25, r24
    2662:	10 f4       	brcc	.+4      	; 0x2668 <vTaskPriorityInherit+0x86>
    2664:	80 93 2c 08 	sts	0x082C, r24
    2668:	90 e0       	ldi	r25, 0x00	; 0
    266a:	9c 01       	movw	r18, r24
    266c:	22 0f       	add	r18, r18
    266e:	33 1f       	adc	r19, r19
    2670:	22 0f       	add	r18, r18
    2672:	33 1f       	adc	r19, r19
    2674:	22 0f       	add	r18, r18
    2676:	33 1f       	adc	r19, r19
    2678:	82 0f       	add	r24, r18
    267a:	93 1f       	adc	r25, r19
    267c:	b8 01       	movw	r22, r16
    267e:	8e 59       	subi	r24, 0x9E	; 158
    2680:	97 4f       	sbci	r25, 0xF7	; 247
    2682:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    2686:	06 c0       	rjmp	.+12     	; 0x2694 <vTaskPriorityInherit+0xb2>
    2688:	e0 91 8f 08 	lds	r30, 0x088F
    268c:	f0 91 90 08 	lds	r31, 0x0890
    2690:	86 89       	ldd	r24, Z+22	; 0x16
    2692:	8e 8b       	std	Y+22, r24	; 0x16
    2694:	df 91       	pop	r29
    2696:	cf 91       	pop	r28
    2698:	1f 91       	pop	r17
    269a:	0f 91       	pop	r16
    269c:	08 95       	ret

0000269e <xTaskPriorityDisinherit>:
    269e:	0f 93       	push	r16
    26a0:	1f 93       	push	r17
    26a2:	cf 93       	push	r28
    26a4:	df 93       	push	r29
    26a6:	ec 01       	movw	r28, r24
    26a8:	00 97       	sbiw	r24, 0x00	; 0
    26aa:	71 f1       	breq	.+92     	; 0x2708 <xTaskPriorityDisinherit+0x6a>
    26ac:	8a a1       	ldd	r24, Y+34	; 0x22
    26ae:	81 50       	subi	r24, 0x01	; 1
    26b0:	8a a3       	std	Y+34, r24	; 0x22
    26b2:	2e 89       	ldd	r18, Y+22	; 0x16
    26b4:	99 a1       	ldd	r25, Y+33	; 0x21
    26b6:	29 17       	cp	r18, r25
    26b8:	49 f1       	breq	.+82     	; 0x270c <xTaskPriorityDisinherit+0x6e>
    26ba:	81 11       	cpse	r24, r1
    26bc:	29 c0       	rjmp	.+82     	; 0x2710 <xTaskPriorityDisinherit+0x72>
    26be:	8e 01       	movw	r16, r28
    26c0:	0e 5f       	subi	r16, 0xFE	; 254
    26c2:	1f 4f       	sbci	r17, 0xFF	; 255
    26c4:	c8 01       	movw	r24, r16
    26c6:	0e 94 95 03 	call	0x72a	; 0x72a <uxListRemove>
    26ca:	89 a1       	ldd	r24, Y+33	; 0x21
    26cc:	8e 8b       	std	Y+22, r24	; 0x16
    26ce:	25 e0       	ldi	r18, 0x05	; 5
    26d0:	30 e0       	ldi	r19, 0x00	; 0
    26d2:	28 1b       	sub	r18, r24
    26d4:	31 09       	sbc	r19, r1
    26d6:	3d 87       	std	Y+13, r19	; 0x0d
    26d8:	2c 87       	std	Y+12, r18	; 0x0c
    26da:	90 91 2c 08 	lds	r25, 0x082C
    26de:	98 17       	cp	r25, r24
    26e0:	10 f4       	brcc	.+4      	; 0x26e6 <xTaskPriorityDisinherit+0x48>
    26e2:	80 93 2c 08 	sts	0x082C, r24
    26e6:	90 e0       	ldi	r25, 0x00	; 0
    26e8:	9c 01       	movw	r18, r24
    26ea:	22 0f       	add	r18, r18
    26ec:	33 1f       	adc	r19, r19
    26ee:	22 0f       	add	r18, r18
    26f0:	33 1f       	adc	r19, r19
    26f2:	22 0f       	add	r18, r18
    26f4:	33 1f       	adc	r19, r19
    26f6:	82 0f       	add	r24, r18
    26f8:	93 1f       	adc	r25, r19
    26fa:	b8 01       	movw	r22, r16
    26fc:	8e 59       	subi	r24, 0x9E	; 158
    26fe:	97 4f       	sbci	r25, 0xF7	; 247
    2700:	0e 94 43 03 	call	0x686	; 0x686 <vListInsertEnd>
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	05 c0       	rjmp	.+10     	; 0x2712 <xTaskPriorityDisinherit+0x74>
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	03 c0       	rjmp	.+6      	; 0x2712 <xTaskPriorityDisinherit+0x74>
    270c:	80 e0       	ldi	r24, 0x00	; 0
    270e:	01 c0       	rjmp	.+2      	; 0x2712 <xTaskPriorityDisinherit+0x74>
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	1f 91       	pop	r17
    2718:	0f 91       	pop	r16
    271a:	08 95       	ret

0000271c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    271c:	80 91 8f 08 	lds	r24, 0x088F
    2720:	90 91 90 08 	lds	r25, 0x0890
    2724:	89 2b       	or	r24, r25
    2726:	39 f0       	breq	.+14     	; 0x2736 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2728:	e0 91 8f 08 	lds	r30, 0x088F
    272c:	f0 91 90 08 	lds	r31, 0x0890
    2730:	82 a1       	ldd	r24, Z+34	; 0x22
    2732:	8f 5f       	subi	r24, 0xFF	; 255
    2734:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2736:	80 91 8f 08 	lds	r24, 0x088F
    273a:	90 91 90 08 	lds	r25, 0x0890
	}
    273e:	08 95       	ret

00002740 <__subsf3>:
    2740:	50 58       	subi	r21, 0x80	; 128

00002742 <__addsf3>:
    2742:	bb 27       	eor	r27, r27
    2744:	aa 27       	eor	r26, r26
    2746:	0e d0       	rcall	.+28     	; 0x2764 <__addsf3x>
    2748:	e5 c0       	rjmp	.+458    	; 0x2914 <__fp_round>
    274a:	d6 d0       	rcall	.+428    	; 0x28f8 <__fp_pscA>
    274c:	30 f0       	brcs	.+12     	; 0x275a <__addsf3+0x18>
    274e:	db d0       	rcall	.+438    	; 0x2906 <__fp_pscB>
    2750:	20 f0       	brcs	.+8      	; 0x275a <__addsf3+0x18>
    2752:	31 f4       	brne	.+12     	; 0x2760 <__addsf3+0x1e>
    2754:	9f 3f       	cpi	r25, 0xFF	; 255
    2756:	11 f4       	brne	.+4      	; 0x275c <__addsf3+0x1a>
    2758:	1e f4       	brtc	.+6      	; 0x2760 <__addsf3+0x1e>
    275a:	cb c0       	rjmp	.+406    	; 0x28f2 <__fp_nan>
    275c:	0e f4       	brtc	.+2      	; 0x2760 <__addsf3+0x1e>
    275e:	e0 95       	com	r30
    2760:	e7 fb       	bst	r30, 7
    2762:	c1 c0       	rjmp	.+386    	; 0x28e6 <__fp_inf>

00002764 <__addsf3x>:
    2764:	e9 2f       	mov	r30, r25
    2766:	e7 d0       	rcall	.+462    	; 0x2936 <__fp_split3>
    2768:	80 f3       	brcs	.-32     	; 0x274a <__addsf3+0x8>
    276a:	ba 17       	cp	r27, r26
    276c:	62 07       	cpc	r22, r18
    276e:	73 07       	cpc	r23, r19
    2770:	84 07       	cpc	r24, r20
    2772:	95 07       	cpc	r25, r21
    2774:	18 f0       	brcs	.+6      	; 0x277c <__addsf3x+0x18>
    2776:	71 f4       	brne	.+28     	; 0x2794 <__addsf3x+0x30>
    2778:	9e f5       	brtc	.+102    	; 0x27e0 <__addsf3x+0x7c>
    277a:	ff c0       	rjmp	.+510    	; 0x297a <__fp_zero>
    277c:	0e f4       	brtc	.+2      	; 0x2780 <__addsf3x+0x1c>
    277e:	e0 95       	com	r30
    2780:	0b 2e       	mov	r0, r27
    2782:	ba 2f       	mov	r27, r26
    2784:	a0 2d       	mov	r26, r0
    2786:	0b 01       	movw	r0, r22
    2788:	b9 01       	movw	r22, r18
    278a:	90 01       	movw	r18, r0
    278c:	0c 01       	movw	r0, r24
    278e:	ca 01       	movw	r24, r20
    2790:	a0 01       	movw	r20, r0
    2792:	11 24       	eor	r1, r1
    2794:	ff 27       	eor	r31, r31
    2796:	59 1b       	sub	r21, r25
    2798:	99 f0       	breq	.+38     	; 0x27c0 <__addsf3x+0x5c>
    279a:	59 3f       	cpi	r21, 0xF9	; 249
    279c:	50 f4       	brcc	.+20     	; 0x27b2 <__addsf3x+0x4e>
    279e:	50 3e       	cpi	r21, 0xE0	; 224
    27a0:	68 f1       	brcs	.+90     	; 0x27fc <__addsf3x+0x98>
    27a2:	1a 16       	cp	r1, r26
    27a4:	f0 40       	sbci	r31, 0x00	; 0
    27a6:	a2 2f       	mov	r26, r18
    27a8:	23 2f       	mov	r18, r19
    27aa:	34 2f       	mov	r19, r20
    27ac:	44 27       	eor	r20, r20
    27ae:	58 5f       	subi	r21, 0xF8	; 248
    27b0:	f3 cf       	rjmp	.-26     	; 0x2798 <__addsf3x+0x34>
    27b2:	46 95       	lsr	r20
    27b4:	37 95       	ror	r19
    27b6:	27 95       	ror	r18
    27b8:	a7 95       	ror	r26
    27ba:	f0 40       	sbci	r31, 0x00	; 0
    27bc:	53 95       	inc	r21
    27be:	c9 f7       	brne	.-14     	; 0x27b2 <__addsf3x+0x4e>
    27c0:	7e f4       	brtc	.+30     	; 0x27e0 <__addsf3x+0x7c>
    27c2:	1f 16       	cp	r1, r31
    27c4:	ba 0b       	sbc	r27, r26
    27c6:	62 0b       	sbc	r22, r18
    27c8:	73 0b       	sbc	r23, r19
    27ca:	84 0b       	sbc	r24, r20
    27cc:	ba f0       	brmi	.+46     	; 0x27fc <__addsf3x+0x98>
    27ce:	91 50       	subi	r25, 0x01	; 1
    27d0:	a1 f0       	breq	.+40     	; 0x27fa <__addsf3x+0x96>
    27d2:	ff 0f       	add	r31, r31
    27d4:	bb 1f       	adc	r27, r27
    27d6:	66 1f       	adc	r22, r22
    27d8:	77 1f       	adc	r23, r23
    27da:	88 1f       	adc	r24, r24
    27dc:	c2 f7       	brpl	.-16     	; 0x27ce <__addsf3x+0x6a>
    27de:	0e c0       	rjmp	.+28     	; 0x27fc <__addsf3x+0x98>
    27e0:	ba 0f       	add	r27, r26
    27e2:	62 1f       	adc	r22, r18
    27e4:	73 1f       	adc	r23, r19
    27e6:	84 1f       	adc	r24, r20
    27e8:	48 f4       	brcc	.+18     	; 0x27fc <__addsf3x+0x98>
    27ea:	87 95       	ror	r24
    27ec:	77 95       	ror	r23
    27ee:	67 95       	ror	r22
    27f0:	b7 95       	ror	r27
    27f2:	f7 95       	ror	r31
    27f4:	9e 3f       	cpi	r25, 0xFE	; 254
    27f6:	08 f0       	brcs	.+2      	; 0x27fa <__addsf3x+0x96>
    27f8:	b3 cf       	rjmp	.-154    	; 0x2760 <__addsf3+0x1e>
    27fa:	93 95       	inc	r25
    27fc:	88 0f       	add	r24, r24
    27fe:	08 f0       	brcs	.+2      	; 0x2802 <__addsf3x+0x9e>
    2800:	99 27       	eor	r25, r25
    2802:	ee 0f       	add	r30, r30
    2804:	97 95       	ror	r25
    2806:	87 95       	ror	r24
    2808:	08 95       	ret

0000280a <__fixsfsi>:
    280a:	04 d0       	rcall	.+8      	; 0x2814 <__fixunssfsi>
    280c:	68 94       	set
    280e:	b1 11       	cpse	r27, r1
    2810:	b5 c0       	rjmp	.+362    	; 0x297c <__fp_szero>
    2812:	08 95       	ret

00002814 <__fixunssfsi>:
    2814:	98 d0       	rcall	.+304    	; 0x2946 <__fp_splitA>
    2816:	88 f0       	brcs	.+34     	; 0x283a <__fixunssfsi+0x26>
    2818:	9f 57       	subi	r25, 0x7F	; 127
    281a:	90 f0       	brcs	.+36     	; 0x2840 <__fixunssfsi+0x2c>
    281c:	b9 2f       	mov	r27, r25
    281e:	99 27       	eor	r25, r25
    2820:	b7 51       	subi	r27, 0x17	; 23
    2822:	a0 f0       	brcs	.+40     	; 0x284c <__fixunssfsi+0x38>
    2824:	d1 f0       	breq	.+52     	; 0x285a <__fixunssfsi+0x46>
    2826:	66 0f       	add	r22, r22
    2828:	77 1f       	adc	r23, r23
    282a:	88 1f       	adc	r24, r24
    282c:	99 1f       	adc	r25, r25
    282e:	1a f0       	brmi	.+6      	; 0x2836 <__fixunssfsi+0x22>
    2830:	ba 95       	dec	r27
    2832:	c9 f7       	brne	.-14     	; 0x2826 <__fixunssfsi+0x12>
    2834:	12 c0       	rjmp	.+36     	; 0x285a <__fixunssfsi+0x46>
    2836:	b1 30       	cpi	r27, 0x01	; 1
    2838:	81 f0       	breq	.+32     	; 0x285a <__fixunssfsi+0x46>
    283a:	9f d0       	rcall	.+318    	; 0x297a <__fp_zero>
    283c:	b1 e0       	ldi	r27, 0x01	; 1
    283e:	08 95       	ret
    2840:	9c c0       	rjmp	.+312    	; 0x297a <__fp_zero>
    2842:	67 2f       	mov	r22, r23
    2844:	78 2f       	mov	r23, r24
    2846:	88 27       	eor	r24, r24
    2848:	b8 5f       	subi	r27, 0xF8	; 248
    284a:	39 f0       	breq	.+14     	; 0x285a <__fixunssfsi+0x46>
    284c:	b9 3f       	cpi	r27, 0xF9	; 249
    284e:	cc f3       	brlt	.-14     	; 0x2842 <__fixunssfsi+0x2e>
    2850:	86 95       	lsr	r24
    2852:	77 95       	ror	r23
    2854:	67 95       	ror	r22
    2856:	b3 95       	inc	r27
    2858:	d9 f7       	brne	.-10     	; 0x2850 <__fixunssfsi+0x3c>
    285a:	3e f4       	brtc	.+14     	; 0x286a <__fixunssfsi+0x56>
    285c:	90 95       	com	r25
    285e:	80 95       	com	r24
    2860:	70 95       	com	r23
    2862:	61 95       	neg	r22
    2864:	7f 4f       	sbci	r23, 0xFF	; 255
    2866:	8f 4f       	sbci	r24, 0xFF	; 255
    2868:	9f 4f       	sbci	r25, 0xFF	; 255
    286a:	08 95       	ret

0000286c <__floatunsisf>:
    286c:	e8 94       	clt
    286e:	09 c0       	rjmp	.+18     	; 0x2882 <__floatsisf+0x12>

00002870 <__floatsisf>:
    2870:	97 fb       	bst	r25, 7
    2872:	3e f4       	brtc	.+14     	; 0x2882 <__floatsisf+0x12>
    2874:	90 95       	com	r25
    2876:	80 95       	com	r24
    2878:	70 95       	com	r23
    287a:	61 95       	neg	r22
    287c:	7f 4f       	sbci	r23, 0xFF	; 255
    287e:	8f 4f       	sbci	r24, 0xFF	; 255
    2880:	9f 4f       	sbci	r25, 0xFF	; 255
    2882:	99 23       	and	r25, r25
    2884:	a9 f0       	breq	.+42     	; 0x28b0 <__floatsisf+0x40>
    2886:	f9 2f       	mov	r31, r25
    2888:	96 e9       	ldi	r25, 0x96	; 150
    288a:	bb 27       	eor	r27, r27
    288c:	93 95       	inc	r25
    288e:	f6 95       	lsr	r31
    2890:	87 95       	ror	r24
    2892:	77 95       	ror	r23
    2894:	67 95       	ror	r22
    2896:	b7 95       	ror	r27
    2898:	f1 11       	cpse	r31, r1
    289a:	f8 cf       	rjmp	.-16     	; 0x288c <__floatsisf+0x1c>
    289c:	fa f4       	brpl	.+62     	; 0x28dc <__floatsisf+0x6c>
    289e:	bb 0f       	add	r27, r27
    28a0:	11 f4       	brne	.+4      	; 0x28a6 <__floatsisf+0x36>
    28a2:	60 ff       	sbrs	r22, 0
    28a4:	1b c0       	rjmp	.+54     	; 0x28dc <__floatsisf+0x6c>
    28a6:	6f 5f       	subi	r22, 0xFF	; 255
    28a8:	7f 4f       	sbci	r23, 0xFF	; 255
    28aa:	8f 4f       	sbci	r24, 0xFF	; 255
    28ac:	9f 4f       	sbci	r25, 0xFF	; 255
    28ae:	16 c0       	rjmp	.+44     	; 0x28dc <__floatsisf+0x6c>
    28b0:	88 23       	and	r24, r24
    28b2:	11 f0       	breq	.+4      	; 0x28b8 <__floatsisf+0x48>
    28b4:	96 e9       	ldi	r25, 0x96	; 150
    28b6:	11 c0       	rjmp	.+34     	; 0x28da <__floatsisf+0x6a>
    28b8:	77 23       	and	r23, r23
    28ba:	21 f0       	breq	.+8      	; 0x28c4 <__floatsisf+0x54>
    28bc:	9e e8       	ldi	r25, 0x8E	; 142
    28be:	87 2f       	mov	r24, r23
    28c0:	76 2f       	mov	r23, r22
    28c2:	05 c0       	rjmp	.+10     	; 0x28ce <__floatsisf+0x5e>
    28c4:	66 23       	and	r22, r22
    28c6:	71 f0       	breq	.+28     	; 0x28e4 <__floatsisf+0x74>
    28c8:	96 e8       	ldi	r25, 0x86	; 134
    28ca:	86 2f       	mov	r24, r22
    28cc:	70 e0       	ldi	r23, 0x00	; 0
    28ce:	60 e0       	ldi	r22, 0x00	; 0
    28d0:	2a f0       	brmi	.+10     	; 0x28dc <__floatsisf+0x6c>
    28d2:	9a 95       	dec	r25
    28d4:	66 0f       	add	r22, r22
    28d6:	77 1f       	adc	r23, r23
    28d8:	88 1f       	adc	r24, r24
    28da:	da f7       	brpl	.-10     	; 0x28d2 <__floatsisf+0x62>
    28dc:	88 0f       	add	r24, r24
    28de:	96 95       	lsr	r25
    28e0:	87 95       	ror	r24
    28e2:	97 f9       	bld	r25, 7
    28e4:	08 95       	ret

000028e6 <__fp_inf>:
    28e6:	97 f9       	bld	r25, 7
    28e8:	9f 67       	ori	r25, 0x7F	; 127
    28ea:	80 e8       	ldi	r24, 0x80	; 128
    28ec:	70 e0       	ldi	r23, 0x00	; 0
    28ee:	60 e0       	ldi	r22, 0x00	; 0
    28f0:	08 95       	ret

000028f2 <__fp_nan>:
    28f2:	9f ef       	ldi	r25, 0xFF	; 255
    28f4:	80 ec       	ldi	r24, 0xC0	; 192
    28f6:	08 95       	ret

000028f8 <__fp_pscA>:
    28f8:	00 24       	eor	r0, r0
    28fa:	0a 94       	dec	r0
    28fc:	16 16       	cp	r1, r22
    28fe:	17 06       	cpc	r1, r23
    2900:	18 06       	cpc	r1, r24
    2902:	09 06       	cpc	r0, r25
    2904:	08 95       	ret

00002906 <__fp_pscB>:
    2906:	00 24       	eor	r0, r0
    2908:	0a 94       	dec	r0
    290a:	12 16       	cp	r1, r18
    290c:	13 06       	cpc	r1, r19
    290e:	14 06       	cpc	r1, r20
    2910:	05 06       	cpc	r0, r21
    2912:	08 95       	ret

00002914 <__fp_round>:
    2914:	09 2e       	mov	r0, r25
    2916:	03 94       	inc	r0
    2918:	00 0c       	add	r0, r0
    291a:	11 f4       	brne	.+4      	; 0x2920 <__fp_round+0xc>
    291c:	88 23       	and	r24, r24
    291e:	52 f0       	brmi	.+20     	; 0x2934 <__fp_round+0x20>
    2920:	bb 0f       	add	r27, r27
    2922:	40 f4       	brcc	.+16     	; 0x2934 <__fp_round+0x20>
    2924:	bf 2b       	or	r27, r31
    2926:	11 f4       	brne	.+4      	; 0x292c <__fp_round+0x18>
    2928:	60 ff       	sbrs	r22, 0
    292a:	04 c0       	rjmp	.+8      	; 0x2934 <__fp_round+0x20>
    292c:	6f 5f       	subi	r22, 0xFF	; 255
    292e:	7f 4f       	sbci	r23, 0xFF	; 255
    2930:	8f 4f       	sbci	r24, 0xFF	; 255
    2932:	9f 4f       	sbci	r25, 0xFF	; 255
    2934:	08 95       	ret

00002936 <__fp_split3>:
    2936:	57 fd       	sbrc	r21, 7
    2938:	90 58       	subi	r25, 0x80	; 128
    293a:	44 0f       	add	r20, r20
    293c:	55 1f       	adc	r21, r21
    293e:	59 f0       	breq	.+22     	; 0x2956 <__fp_splitA+0x10>
    2940:	5f 3f       	cpi	r21, 0xFF	; 255
    2942:	71 f0       	breq	.+28     	; 0x2960 <__fp_splitA+0x1a>
    2944:	47 95       	ror	r20

00002946 <__fp_splitA>:
    2946:	88 0f       	add	r24, r24
    2948:	97 fb       	bst	r25, 7
    294a:	99 1f       	adc	r25, r25
    294c:	61 f0       	breq	.+24     	; 0x2966 <__fp_splitA+0x20>
    294e:	9f 3f       	cpi	r25, 0xFF	; 255
    2950:	79 f0       	breq	.+30     	; 0x2970 <__fp_splitA+0x2a>
    2952:	87 95       	ror	r24
    2954:	08 95       	ret
    2956:	12 16       	cp	r1, r18
    2958:	13 06       	cpc	r1, r19
    295a:	14 06       	cpc	r1, r20
    295c:	55 1f       	adc	r21, r21
    295e:	f2 cf       	rjmp	.-28     	; 0x2944 <__fp_split3+0xe>
    2960:	46 95       	lsr	r20
    2962:	f1 df       	rcall	.-30     	; 0x2946 <__fp_splitA>
    2964:	08 c0       	rjmp	.+16     	; 0x2976 <__fp_splitA+0x30>
    2966:	16 16       	cp	r1, r22
    2968:	17 06       	cpc	r1, r23
    296a:	18 06       	cpc	r1, r24
    296c:	99 1f       	adc	r25, r25
    296e:	f1 cf       	rjmp	.-30     	; 0x2952 <__fp_splitA+0xc>
    2970:	86 95       	lsr	r24
    2972:	71 05       	cpc	r23, r1
    2974:	61 05       	cpc	r22, r1
    2976:	08 94       	sec
    2978:	08 95       	ret

0000297a <__fp_zero>:
    297a:	e8 94       	clt

0000297c <__fp_szero>:
    297c:	bb 27       	eor	r27, r27
    297e:	66 27       	eor	r22, r22
    2980:	77 27       	eor	r23, r23
    2982:	cb 01       	movw	r24, r22
    2984:	97 f9       	bld	r25, 7
    2986:	08 95       	ret

00002988 <__mulsf3>:
    2988:	0b d0       	rcall	.+22     	; 0x29a0 <__mulsf3x>
    298a:	c4 cf       	rjmp	.-120    	; 0x2914 <__fp_round>
    298c:	b5 df       	rcall	.-150    	; 0x28f8 <__fp_pscA>
    298e:	28 f0       	brcs	.+10     	; 0x299a <__mulsf3+0x12>
    2990:	ba df       	rcall	.-140    	; 0x2906 <__fp_pscB>
    2992:	18 f0       	brcs	.+6      	; 0x299a <__mulsf3+0x12>
    2994:	95 23       	and	r25, r21
    2996:	09 f0       	breq	.+2      	; 0x299a <__mulsf3+0x12>
    2998:	a6 cf       	rjmp	.-180    	; 0x28e6 <__fp_inf>
    299a:	ab cf       	rjmp	.-170    	; 0x28f2 <__fp_nan>
    299c:	11 24       	eor	r1, r1
    299e:	ee cf       	rjmp	.-36     	; 0x297c <__fp_szero>

000029a0 <__mulsf3x>:
    29a0:	ca df       	rcall	.-108    	; 0x2936 <__fp_split3>
    29a2:	a0 f3       	brcs	.-24     	; 0x298c <__mulsf3+0x4>

000029a4 <__mulsf3_pse>:
    29a4:	95 9f       	mul	r25, r21
    29a6:	d1 f3       	breq	.-12     	; 0x299c <__mulsf3+0x14>
    29a8:	95 0f       	add	r25, r21
    29aa:	50 e0       	ldi	r21, 0x00	; 0
    29ac:	55 1f       	adc	r21, r21
    29ae:	62 9f       	mul	r22, r18
    29b0:	f0 01       	movw	r30, r0
    29b2:	72 9f       	mul	r23, r18
    29b4:	bb 27       	eor	r27, r27
    29b6:	f0 0d       	add	r31, r0
    29b8:	b1 1d       	adc	r27, r1
    29ba:	63 9f       	mul	r22, r19
    29bc:	aa 27       	eor	r26, r26
    29be:	f0 0d       	add	r31, r0
    29c0:	b1 1d       	adc	r27, r1
    29c2:	aa 1f       	adc	r26, r26
    29c4:	64 9f       	mul	r22, r20
    29c6:	66 27       	eor	r22, r22
    29c8:	b0 0d       	add	r27, r0
    29ca:	a1 1d       	adc	r26, r1
    29cc:	66 1f       	adc	r22, r22
    29ce:	82 9f       	mul	r24, r18
    29d0:	22 27       	eor	r18, r18
    29d2:	b0 0d       	add	r27, r0
    29d4:	a1 1d       	adc	r26, r1
    29d6:	62 1f       	adc	r22, r18
    29d8:	73 9f       	mul	r23, r19
    29da:	b0 0d       	add	r27, r0
    29dc:	a1 1d       	adc	r26, r1
    29de:	62 1f       	adc	r22, r18
    29e0:	83 9f       	mul	r24, r19
    29e2:	a0 0d       	add	r26, r0
    29e4:	61 1d       	adc	r22, r1
    29e6:	22 1f       	adc	r18, r18
    29e8:	74 9f       	mul	r23, r20
    29ea:	33 27       	eor	r19, r19
    29ec:	a0 0d       	add	r26, r0
    29ee:	61 1d       	adc	r22, r1
    29f0:	23 1f       	adc	r18, r19
    29f2:	84 9f       	mul	r24, r20
    29f4:	60 0d       	add	r22, r0
    29f6:	21 1d       	adc	r18, r1
    29f8:	82 2f       	mov	r24, r18
    29fa:	76 2f       	mov	r23, r22
    29fc:	6a 2f       	mov	r22, r26
    29fe:	11 24       	eor	r1, r1
    2a00:	9f 57       	subi	r25, 0x7F	; 127
    2a02:	50 40       	sbci	r21, 0x00	; 0
    2a04:	8a f0       	brmi	.+34     	; 0x2a28 <__mulsf3_pse+0x84>
    2a06:	e1 f0       	breq	.+56     	; 0x2a40 <__mulsf3_pse+0x9c>
    2a08:	88 23       	and	r24, r24
    2a0a:	4a f0       	brmi	.+18     	; 0x2a1e <__mulsf3_pse+0x7a>
    2a0c:	ee 0f       	add	r30, r30
    2a0e:	ff 1f       	adc	r31, r31
    2a10:	bb 1f       	adc	r27, r27
    2a12:	66 1f       	adc	r22, r22
    2a14:	77 1f       	adc	r23, r23
    2a16:	88 1f       	adc	r24, r24
    2a18:	91 50       	subi	r25, 0x01	; 1
    2a1a:	50 40       	sbci	r21, 0x00	; 0
    2a1c:	a9 f7       	brne	.-22     	; 0x2a08 <__mulsf3_pse+0x64>
    2a1e:	9e 3f       	cpi	r25, 0xFE	; 254
    2a20:	51 05       	cpc	r21, r1
    2a22:	70 f0       	brcs	.+28     	; 0x2a40 <__mulsf3_pse+0x9c>
    2a24:	60 cf       	rjmp	.-320    	; 0x28e6 <__fp_inf>
    2a26:	aa cf       	rjmp	.-172    	; 0x297c <__fp_szero>
    2a28:	5f 3f       	cpi	r21, 0xFF	; 255
    2a2a:	ec f3       	brlt	.-6      	; 0x2a26 <__mulsf3_pse+0x82>
    2a2c:	98 3e       	cpi	r25, 0xE8	; 232
    2a2e:	dc f3       	brlt	.-10     	; 0x2a26 <__mulsf3_pse+0x82>
    2a30:	86 95       	lsr	r24
    2a32:	77 95       	ror	r23
    2a34:	67 95       	ror	r22
    2a36:	b7 95       	ror	r27
    2a38:	f7 95       	ror	r31
    2a3a:	e7 95       	ror	r30
    2a3c:	9f 5f       	subi	r25, 0xFF	; 255
    2a3e:	c1 f7       	brne	.-16     	; 0x2a30 <__mulsf3_pse+0x8c>
    2a40:	fe 2b       	or	r31, r30
    2a42:	88 0f       	add	r24, r24
    2a44:	91 1d       	adc	r25, r1
    2a46:	96 95       	lsr	r25
    2a48:	87 95       	ror	r24
    2a4a:	97 f9       	bld	r25, 7
    2a4c:	08 95       	ret

00002a4e <pow>:
    2a4e:	fa 01       	movw	r30, r20
    2a50:	ee 0f       	add	r30, r30
    2a52:	ff 1f       	adc	r31, r31
    2a54:	30 96       	adiw	r30, 0x00	; 0
    2a56:	21 05       	cpc	r18, r1
    2a58:	31 05       	cpc	r19, r1
    2a5a:	99 f1       	breq	.+102    	; 0x2ac2 <pow+0x74>
    2a5c:	61 15       	cp	r22, r1
    2a5e:	71 05       	cpc	r23, r1
    2a60:	61 f4       	brne	.+24     	; 0x2a7a <pow+0x2c>
    2a62:	80 38       	cpi	r24, 0x80	; 128
    2a64:	bf e3       	ldi	r27, 0x3F	; 63
    2a66:	9b 07       	cpc	r25, r27
    2a68:	49 f1       	breq	.+82     	; 0x2abc <pow+0x6e>
    2a6a:	68 94       	set
    2a6c:	90 38       	cpi	r25, 0x80	; 128
    2a6e:	81 05       	cpc	r24, r1
    2a70:	61 f0       	breq	.+24     	; 0x2a8a <pow+0x3c>
    2a72:	80 38       	cpi	r24, 0x80	; 128
    2a74:	bf ef       	ldi	r27, 0xFF	; 255
    2a76:	9b 07       	cpc	r25, r27
    2a78:	41 f0       	breq	.+16     	; 0x2a8a <pow+0x3c>
    2a7a:	99 23       	and	r25, r25
    2a7c:	42 f5       	brpl	.+80     	; 0x2ace <pow+0x80>
    2a7e:	ff 3f       	cpi	r31, 0xFF	; 255
    2a80:	e1 05       	cpc	r30, r1
    2a82:	31 05       	cpc	r19, r1
    2a84:	21 05       	cpc	r18, r1
    2a86:	11 f1       	breq	.+68     	; 0x2acc <pow+0x7e>
    2a88:	e8 94       	clt
    2a8a:	08 94       	sec
    2a8c:	e7 95       	ror	r30
    2a8e:	d9 01       	movw	r26, r18
    2a90:	aa 23       	and	r26, r26
    2a92:	29 f4       	brne	.+10     	; 0x2a9e <pow+0x50>
    2a94:	ab 2f       	mov	r26, r27
    2a96:	be 2f       	mov	r27, r30
    2a98:	f8 5f       	subi	r31, 0xF8	; 248
    2a9a:	d0 f3       	brcs	.-12     	; 0x2a90 <pow+0x42>
    2a9c:	10 c0       	rjmp	.+32     	; 0x2abe <pow+0x70>
    2a9e:	ff 5f       	subi	r31, 0xFF	; 255
    2aa0:	70 f4       	brcc	.+28     	; 0x2abe <pow+0x70>
    2aa2:	a6 95       	lsr	r26
    2aa4:	e0 f7       	brcc	.-8      	; 0x2a9e <pow+0x50>
    2aa6:	f7 39       	cpi	r31, 0x97	; 151
    2aa8:	50 f0       	brcs	.+20     	; 0x2abe <pow+0x70>
    2aaa:	19 f0       	breq	.+6      	; 0x2ab2 <pow+0x64>
    2aac:	ff 3a       	cpi	r31, 0xAF	; 175
    2aae:	38 f4       	brcc	.+14     	; 0x2abe <pow+0x70>
    2ab0:	9f 77       	andi	r25, 0x7F	; 127
    2ab2:	9f 93       	push	r25
    2ab4:	0c d0       	rcall	.+24     	; 0x2ace <pow+0x80>
    2ab6:	0f 90       	pop	r0
    2ab8:	07 fc       	sbrc	r0, 7
    2aba:	90 58       	subi	r25, 0x80	; 128
    2abc:	08 95       	ret
    2abe:	3e f0       	brts	.+14     	; 0x2ace <pow+0x80>
    2ac0:	18 cf       	rjmp	.-464    	; 0x28f2 <__fp_nan>
    2ac2:	60 e0       	ldi	r22, 0x00	; 0
    2ac4:	70 e0       	ldi	r23, 0x00	; 0
    2ac6:	80 e8       	ldi	r24, 0x80	; 128
    2ac8:	9f e3       	ldi	r25, 0x3F	; 63
    2aca:	08 95       	ret
    2acc:	4f e7       	ldi	r20, 0x7F	; 127
    2ace:	9f 77       	andi	r25, 0x7F	; 127
    2ad0:	5f 93       	push	r21
    2ad2:	4f 93       	push	r20
    2ad4:	3f 93       	push	r19
    2ad6:	2f 93       	push	r18
    2ad8:	9e d0       	rcall	.+316    	; 0x2c16 <log>
    2ada:	2f 91       	pop	r18
    2adc:	3f 91       	pop	r19
    2ade:	4f 91       	pop	r20
    2ae0:	5f 91       	pop	r21
    2ae2:	52 df       	rcall	.-348    	; 0x2988 <__mulsf3>
    2ae4:	05 c0       	rjmp	.+10     	; 0x2af0 <exp>
    2ae6:	19 f4       	brne	.+6      	; 0x2aee <pow+0xa0>
    2ae8:	0e f0       	brts	.+2      	; 0x2aec <pow+0x9e>
    2aea:	fd ce       	rjmp	.-518    	; 0x28e6 <__fp_inf>
    2aec:	46 cf       	rjmp	.-372    	; 0x297a <__fp_zero>
    2aee:	01 cf       	rjmp	.-510    	; 0x28f2 <__fp_nan>

00002af0 <exp>:
    2af0:	2a df       	rcall	.-428    	; 0x2946 <__fp_splitA>
    2af2:	c8 f3       	brcs	.-14     	; 0x2ae6 <pow+0x98>
    2af4:	96 38       	cpi	r25, 0x86	; 134
    2af6:	c0 f7       	brcc	.-16     	; 0x2ae8 <pow+0x9a>
    2af8:	07 f8       	bld	r0, 7
    2afa:	0f 92       	push	r0
    2afc:	e8 94       	clt
    2afe:	2b e3       	ldi	r18, 0x3B	; 59
    2b00:	3a ea       	ldi	r19, 0xAA	; 170
    2b02:	48 eb       	ldi	r20, 0xB8	; 184
    2b04:	5f e7       	ldi	r21, 0x7F	; 127
    2b06:	4e df       	rcall	.-356    	; 0x29a4 <__mulsf3_pse>
    2b08:	0f 92       	push	r0
    2b0a:	0f 92       	push	r0
    2b0c:	0f 92       	push	r0
    2b0e:	4d b7       	in	r20, 0x3d	; 61
    2b10:	5e b7       	in	r21, 0x3e	; 62
    2b12:	0f 92       	push	r0
    2b14:	c0 d0       	rcall	.+384    	; 0x2c96 <modf>
    2b16:	e4 ee       	ldi	r30, 0xE4	; 228
    2b18:	f0 e0       	ldi	r31, 0x00	; 0
    2b1a:	16 d0       	rcall	.+44     	; 0x2b48 <__fp_powser>
    2b1c:	4f 91       	pop	r20
    2b1e:	5f 91       	pop	r21
    2b20:	ef 91       	pop	r30
    2b22:	ff 91       	pop	r31
    2b24:	e5 95       	asr	r30
    2b26:	ee 1f       	adc	r30, r30
    2b28:	ff 1f       	adc	r31, r31
    2b2a:	49 f0       	breq	.+18     	; 0x2b3e <exp+0x4e>
    2b2c:	fe 57       	subi	r31, 0x7E	; 126
    2b2e:	e0 68       	ori	r30, 0x80	; 128
    2b30:	44 27       	eor	r20, r20
    2b32:	ee 0f       	add	r30, r30
    2b34:	44 1f       	adc	r20, r20
    2b36:	fa 95       	dec	r31
    2b38:	e1 f7       	brne	.-8      	; 0x2b32 <exp+0x42>
    2b3a:	41 95       	neg	r20
    2b3c:	55 0b       	sbc	r21, r21
    2b3e:	32 d0       	rcall	.+100    	; 0x2ba4 <ldexp>
    2b40:	0f 90       	pop	r0
    2b42:	07 fe       	sbrs	r0, 7
    2b44:	26 c0       	rjmp	.+76     	; 0x2b92 <inverse>
    2b46:	08 95       	ret

00002b48 <__fp_powser>:
    2b48:	df 93       	push	r29
    2b4a:	cf 93       	push	r28
    2b4c:	1f 93       	push	r17
    2b4e:	0f 93       	push	r16
    2b50:	ff 92       	push	r15
    2b52:	ef 92       	push	r14
    2b54:	df 92       	push	r13
    2b56:	7b 01       	movw	r14, r22
    2b58:	8c 01       	movw	r16, r24
    2b5a:	68 94       	set
    2b5c:	05 c0       	rjmp	.+10     	; 0x2b68 <__fp_powser+0x20>
    2b5e:	da 2e       	mov	r13, r26
    2b60:	ef 01       	movw	r28, r30
    2b62:	1e df       	rcall	.-452    	; 0x29a0 <__mulsf3x>
    2b64:	fe 01       	movw	r30, r28
    2b66:	e8 94       	clt
    2b68:	a5 91       	lpm	r26, Z+
    2b6a:	25 91       	lpm	r18, Z+
    2b6c:	35 91       	lpm	r19, Z+
    2b6e:	45 91       	lpm	r20, Z+
    2b70:	55 91       	lpm	r21, Z+
    2b72:	ae f3       	brts	.-22     	; 0x2b5e <__fp_powser+0x16>
    2b74:	ef 01       	movw	r28, r30
    2b76:	f6 dd       	rcall	.-1044   	; 0x2764 <__addsf3x>
    2b78:	fe 01       	movw	r30, r28
    2b7a:	97 01       	movw	r18, r14
    2b7c:	a8 01       	movw	r20, r16
    2b7e:	da 94       	dec	r13
    2b80:	79 f7       	brne	.-34     	; 0x2b60 <__fp_powser+0x18>
    2b82:	df 90       	pop	r13
    2b84:	ef 90       	pop	r14
    2b86:	ff 90       	pop	r15
    2b88:	0f 91       	pop	r16
    2b8a:	1f 91       	pop	r17
    2b8c:	cf 91       	pop	r28
    2b8e:	df 91       	pop	r29
    2b90:	08 95       	ret

00002b92 <inverse>:
    2b92:	9b 01       	movw	r18, r22
    2b94:	ac 01       	movw	r20, r24
    2b96:	60 e0       	ldi	r22, 0x00	; 0
    2b98:	70 e0       	ldi	r23, 0x00	; 0
    2b9a:	80 e8       	ldi	r24, 0x80	; 128
    2b9c:	9f e3       	ldi	r25, 0x3F	; 63
    2b9e:	ae c0       	rjmp	.+348    	; 0x2cfc <__divsf3>
    2ba0:	a2 ce       	rjmp	.-700    	; 0x28e6 <__fp_inf>
    2ba2:	14 c1       	rjmp	.+552    	; 0x2dcc <__fp_mpack>

00002ba4 <ldexp>:
    2ba4:	d0 de       	rcall	.-608    	; 0x2946 <__fp_splitA>
    2ba6:	e8 f3       	brcs	.-6      	; 0x2ba2 <inverse+0x10>
    2ba8:	99 23       	and	r25, r25
    2baa:	d9 f3       	breq	.-10     	; 0x2ba2 <inverse+0x10>
    2bac:	94 0f       	add	r25, r20
    2bae:	51 1d       	adc	r21, r1
    2bb0:	bb f3       	brvs	.-18     	; 0x2ba0 <inverse+0xe>
    2bb2:	91 50       	subi	r25, 0x01	; 1
    2bb4:	50 40       	sbci	r21, 0x00	; 0
    2bb6:	94 f0       	brlt	.+36     	; 0x2bdc <ldexp+0x38>
    2bb8:	59 f0       	breq	.+22     	; 0x2bd0 <ldexp+0x2c>
    2bba:	88 23       	and	r24, r24
    2bbc:	32 f0       	brmi	.+12     	; 0x2bca <ldexp+0x26>
    2bbe:	66 0f       	add	r22, r22
    2bc0:	77 1f       	adc	r23, r23
    2bc2:	88 1f       	adc	r24, r24
    2bc4:	91 50       	subi	r25, 0x01	; 1
    2bc6:	50 40       	sbci	r21, 0x00	; 0
    2bc8:	c1 f7       	brne	.-16     	; 0x2bba <ldexp+0x16>
    2bca:	9e 3f       	cpi	r25, 0xFE	; 254
    2bcc:	51 05       	cpc	r21, r1
    2bce:	44 f7       	brge	.-48     	; 0x2ba0 <inverse+0xe>
    2bd0:	88 0f       	add	r24, r24
    2bd2:	91 1d       	adc	r25, r1
    2bd4:	96 95       	lsr	r25
    2bd6:	87 95       	ror	r24
    2bd8:	97 f9       	bld	r25, 7
    2bda:	08 95       	ret
    2bdc:	5f 3f       	cpi	r21, 0xFF	; 255
    2bde:	ac f0       	brlt	.+42     	; 0x2c0a <ldexp+0x66>
    2be0:	98 3e       	cpi	r25, 0xE8	; 232
    2be2:	9c f0       	brlt	.+38     	; 0x2c0a <ldexp+0x66>
    2be4:	bb 27       	eor	r27, r27
    2be6:	86 95       	lsr	r24
    2be8:	77 95       	ror	r23
    2bea:	67 95       	ror	r22
    2bec:	b7 95       	ror	r27
    2bee:	08 f4       	brcc	.+2      	; 0x2bf2 <ldexp+0x4e>
    2bf0:	b1 60       	ori	r27, 0x01	; 1
    2bf2:	93 95       	inc	r25
    2bf4:	c1 f7       	brne	.-16     	; 0x2be6 <ldexp+0x42>
    2bf6:	bb 0f       	add	r27, r27
    2bf8:	58 f7       	brcc	.-42     	; 0x2bd0 <ldexp+0x2c>
    2bfa:	11 f4       	brne	.+4      	; 0x2c00 <ldexp+0x5c>
    2bfc:	60 ff       	sbrs	r22, 0
    2bfe:	e8 cf       	rjmp	.-48     	; 0x2bd0 <ldexp+0x2c>
    2c00:	6f 5f       	subi	r22, 0xFF	; 255
    2c02:	7f 4f       	sbci	r23, 0xFF	; 255
    2c04:	8f 4f       	sbci	r24, 0xFF	; 255
    2c06:	9f 4f       	sbci	r25, 0xFF	; 255
    2c08:	e3 cf       	rjmp	.-58     	; 0x2bd0 <ldexp+0x2c>
    2c0a:	b8 ce       	rjmp	.-656    	; 0x297c <__fp_szero>
    2c0c:	0e f0       	brts	.+2      	; 0x2c10 <ldexp+0x6c>
    2c0e:	de c0       	rjmp	.+444    	; 0x2dcc <__fp_mpack>
    2c10:	70 ce       	rjmp	.-800    	; 0x28f2 <__fp_nan>
    2c12:	68 94       	set
    2c14:	68 ce       	rjmp	.-816    	; 0x28e6 <__fp_inf>

00002c16 <log>:
    2c16:	97 de       	rcall	.-722    	; 0x2946 <__fp_splitA>
    2c18:	c8 f3       	brcs	.-14     	; 0x2c0c <ldexp+0x68>
    2c1a:	99 23       	and	r25, r25
    2c1c:	d1 f3       	breq	.-12     	; 0x2c12 <ldexp+0x6e>
    2c1e:	c6 f3       	brts	.-16     	; 0x2c10 <ldexp+0x6c>
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	1f 93       	push	r17
    2c26:	0f 93       	push	r16
    2c28:	ff 92       	push	r15
    2c2a:	c9 2f       	mov	r28, r25
    2c2c:	dd 27       	eor	r29, r29
    2c2e:	88 23       	and	r24, r24
    2c30:	2a f0       	brmi	.+10     	; 0x2c3c <log+0x26>
    2c32:	21 97       	sbiw	r28, 0x01	; 1
    2c34:	66 0f       	add	r22, r22
    2c36:	77 1f       	adc	r23, r23
    2c38:	88 1f       	adc	r24, r24
    2c3a:	da f7       	brpl	.-10     	; 0x2c32 <log+0x1c>
    2c3c:	20 e0       	ldi	r18, 0x00	; 0
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	40 e8       	ldi	r20, 0x80	; 128
    2c42:	5f eb       	ldi	r21, 0xBF	; 191
    2c44:	9f e3       	ldi	r25, 0x3F	; 63
    2c46:	88 39       	cpi	r24, 0x98	; 152
    2c48:	20 f0       	brcs	.+8      	; 0x2c52 <log+0x3c>
    2c4a:	80 3e       	cpi	r24, 0xE0	; 224
    2c4c:	30 f0       	brcs	.+12     	; 0x2c5a <log+0x44>
    2c4e:	21 96       	adiw	r28, 0x01	; 1
    2c50:	8f 77       	andi	r24, 0x7F	; 127
    2c52:	77 dd       	rcall	.-1298   	; 0x2742 <__addsf3>
    2c54:	ec e0       	ldi	r30, 0x0C	; 12
    2c56:	f1 e0       	ldi	r31, 0x01	; 1
    2c58:	03 c0       	rjmp	.+6      	; 0x2c60 <log+0x4a>
    2c5a:	73 dd       	rcall	.-1306   	; 0x2742 <__addsf3>
    2c5c:	e9 e3       	ldi	r30, 0x39	; 57
    2c5e:	f1 e0       	ldi	r31, 0x01	; 1
    2c60:	73 df       	rcall	.-282    	; 0x2b48 <__fp_powser>
    2c62:	8b 01       	movw	r16, r22
    2c64:	be 01       	movw	r22, r28
    2c66:	ec 01       	movw	r28, r24
    2c68:	fb 2e       	mov	r15, r27
    2c6a:	6f 57       	subi	r22, 0x7F	; 127
    2c6c:	71 09       	sbc	r23, r1
    2c6e:	75 95       	asr	r23
    2c70:	77 1f       	adc	r23, r23
    2c72:	88 0b       	sbc	r24, r24
    2c74:	99 0b       	sbc	r25, r25
    2c76:	fc dd       	rcall	.-1032   	; 0x2870 <__floatsisf>
    2c78:	28 e1       	ldi	r18, 0x18	; 24
    2c7a:	32 e7       	ldi	r19, 0x72	; 114
    2c7c:	41 e3       	ldi	r20, 0x31	; 49
    2c7e:	5f e3       	ldi	r21, 0x3F	; 63
    2c80:	8f de       	rcall	.-738    	; 0x29a0 <__mulsf3x>
    2c82:	af 2d       	mov	r26, r15
    2c84:	98 01       	movw	r18, r16
    2c86:	ae 01       	movw	r20, r28
    2c88:	ff 90       	pop	r15
    2c8a:	0f 91       	pop	r16
    2c8c:	1f 91       	pop	r17
    2c8e:	cf 91       	pop	r28
    2c90:	df 91       	pop	r29
    2c92:	68 dd       	rcall	.-1328   	; 0x2764 <__addsf3x>
    2c94:	3f ce       	rjmp	.-898    	; 0x2914 <__fp_round>

00002c96 <modf>:
    2c96:	fa 01       	movw	r30, r20
    2c98:	dc 01       	movw	r26, r24
    2c9a:	aa 0f       	add	r26, r26
    2c9c:	bb 1f       	adc	r27, r27
    2c9e:	9b 01       	movw	r18, r22
    2ca0:	ac 01       	movw	r20, r24
    2ca2:	bf 57       	subi	r27, 0x7F	; 127
    2ca4:	28 f4       	brcc	.+10     	; 0x2cb0 <modf+0x1a>
    2ca6:	22 27       	eor	r18, r18
    2ca8:	33 27       	eor	r19, r19
    2caa:	44 27       	eor	r20, r20
    2cac:	50 78       	andi	r21, 0x80	; 128
    2cae:	1f c0       	rjmp	.+62     	; 0x2cee <modf+0x58>
    2cb0:	b7 51       	subi	r27, 0x17	; 23
    2cb2:	88 f4       	brcc	.+34     	; 0x2cd6 <modf+0x40>
    2cb4:	ab 2f       	mov	r26, r27
    2cb6:	00 24       	eor	r0, r0
    2cb8:	46 95       	lsr	r20
    2cba:	37 95       	ror	r19
    2cbc:	27 95       	ror	r18
    2cbe:	01 1c       	adc	r0, r1
    2cc0:	a3 95       	inc	r26
    2cc2:	d2 f3       	brmi	.-12     	; 0x2cb8 <modf+0x22>
    2cc4:	00 20       	and	r0, r0
    2cc6:	69 f0       	breq	.+26     	; 0x2ce2 <modf+0x4c>
    2cc8:	22 0f       	add	r18, r18
    2cca:	33 1f       	adc	r19, r19
    2ccc:	44 1f       	adc	r20, r20
    2cce:	b3 95       	inc	r27
    2cd0:	da f3       	brmi	.-10     	; 0x2cc8 <modf+0x32>
    2cd2:	0d d0       	rcall	.+26     	; 0x2cee <modf+0x58>
    2cd4:	35 cd       	rjmp	.-1430   	; 0x2740 <__subsf3>
    2cd6:	61 30       	cpi	r22, 0x01	; 1
    2cd8:	71 05       	cpc	r23, r1
    2cda:	a0 e8       	ldi	r26, 0x80	; 128
    2cdc:	8a 07       	cpc	r24, r26
    2cde:	b9 46       	sbci	r27, 0x69	; 105
    2ce0:	30 f4       	brcc	.+12     	; 0x2cee <modf+0x58>
    2ce2:	9b 01       	movw	r18, r22
    2ce4:	ac 01       	movw	r20, r24
    2ce6:	66 27       	eor	r22, r22
    2ce8:	77 27       	eor	r23, r23
    2cea:	88 27       	eor	r24, r24
    2cec:	90 78       	andi	r25, 0x80	; 128
    2cee:	30 96       	adiw	r30, 0x00	; 0
    2cf0:	21 f0       	breq	.+8      	; 0x2cfa <modf+0x64>
    2cf2:	20 83       	st	Z, r18
    2cf4:	31 83       	std	Z+1, r19	; 0x01
    2cf6:	42 83       	std	Z+2, r20	; 0x02
    2cf8:	53 83       	std	Z+3, r21	; 0x03
    2cfa:	08 95       	ret

00002cfc <__divsf3>:
    2cfc:	0c d0       	rcall	.+24     	; 0x2d16 <__divsf3x>
    2cfe:	0a ce       	rjmp	.-1004   	; 0x2914 <__fp_round>
    2d00:	02 de       	rcall	.-1020   	; 0x2906 <__fp_pscB>
    2d02:	40 f0       	brcs	.+16     	; 0x2d14 <__divsf3+0x18>
    2d04:	f9 dd       	rcall	.-1038   	; 0x28f8 <__fp_pscA>
    2d06:	30 f0       	brcs	.+12     	; 0x2d14 <__divsf3+0x18>
    2d08:	21 f4       	brne	.+8      	; 0x2d12 <__divsf3+0x16>
    2d0a:	5f 3f       	cpi	r21, 0xFF	; 255
    2d0c:	19 f0       	breq	.+6      	; 0x2d14 <__divsf3+0x18>
    2d0e:	eb cd       	rjmp	.-1066   	; 0x28e6 <__fp_inf>
    2d10:	51 11       	cpse	r21, r1
    2d12:	34 ce       	rjmp	.-920    	; 0x297c <__fp_szero>
    2d14:	ee cd       	rjmp	.-1060   	; 0x28f2 <__fp_nan>

00002d16 <__divsf3x>:
    2d16:	0f de       	rcall	.-994    	; 0x2936 <__fp_split3>
    2d18:	98 f3       	brcs	.-26     	; 0x2d00 <__divsf3+0x4>

00002d1a <__divsf3_pse>:
    2d1a:	99 23       	and	r25, r25
    2d1c:	c9 f3       	breq	.-14     	; 0x2d10 <__divsf3+0x14>
    2d1e:	55 23       	and	r21, r21
    2d20:	b1 f3       	breq	.-20     	; 0x2d0e <__divsf3+0x12>
    2d22:	95 1b       	sub	r25, r21
    2d24:	55 0b       	sbc	r21, r21
    2d26:	bb 27       	eor	r27, r27
    2d28:	aa 27       	eor	r26, r26
    2d2a:	62 17       	cp	r22, r18
    2d2c:	73 07       	cpc	r23, r19
    2d2e:	84 07       	cpc	r24, r20
    2d30:	38 f0       	brcs	.+14     	; 0x2d40 <__divsf3_pse+0x26>
    2d32:	9f 5f       	subi	r25, 0xFF	; 255
    2d34:	5f 4f       	sbci	r21, 0xFF	; 255
    2d36:	22 0f       	add	r18, r18
    2d38:	33 1f       	adc	r19, r19
    2d3a:	44 1f       	adc	r20, r20
    2d3c:	aa 1f       	adc	r26, r26
    2d3e:	a9 f3       	breq	.-22     	; 0x2d2a <__divsf3_pse+0x10>
    2d40:	33 d0       	rcall	.+102    	; 0x2da8 <__divsf3_pse+0x8e>
    2d42:	0e 2e       	mov	r0, r30
    2d44:	3a f0       	brmi	.+14     	; 0x2d54 <__divsf3_pse+0x3a>
    2d46:	e0 e8       	ldi	r30, 0x80	; 128
    2d48:	30 d0       	rcall	.+96     	; 0x2daa <__divsf3_pse+0x90>
    2d4a:	91 50       	subi	r25, 0x01	; 1
    2d4c:	50 40       	sbci	r21, 0x00	; 0
    2d4e:	e6 95       	lsr	r30
    2d50:	00 1c       	adc	r0, r0
    2d52:	ca f7       	brpl	.-14     	; 0x2d46 <__divsf3_pse+0x2c>
    2d54:	29 d0       	rcall	.+82     	; 0x2da8 <__divsf3_pse+0x8e>
    2d56:	fe 2f       	mov	r31, r30
    2d58:	27 d0       	rcall	.+78     	; 0x2da8 <__divsf3_pse+0x8e>
    2d5a:	66 0f       	add	r22, r22
    2d5c:	77 1f       	adc	r23, r23
    2d5e:	88 1f       	adc	r24, r24
    2d60:	bb 1f       	adc	r27, r27
    2d62:	26 17       	cp	r18, r22
    2d64:	37 07       	cpc	r19, r23
    2d66:	48 07       	cpc	r20, r24
    2d68:	ab 07       	cpc	r26, r27
    2d6a:	b0 e8       	ldi	r27, 0x80	; 128
    2d6c:	09 f0       	breq	.+2      	; 0x2d70 <__divsf3_pse+0x56>
    2d6e:	bb 0b       	sbc	r27, r27
    2d70:	80 2d       	mov	r24, r0
    2d72:	bf 01       	movw	r22, r30
    2d74:	ff 27       	eor	r31, r31
    2d76:	93 58       	subi	r25, 0x83	; 131
    2d78:	5f 4f       	sbci	r21, 0xFF	; 255
    2d7a:	2a f0       	brmi	.+10     	; 0x2d86 <__divsf3_pse+0x6c>
    2d7c:	9e 3f       	cpi	r25, 0xFE	; 254
    2d7e:	51 05       	cpc	r21, r1
    2d80:	68 f0       	brcs	.+26     	; 0x2d9c <__divsf3_pse+0x82>
    2d82:	b1 cd       	rjmp	.-1182   	; 0x28e6 <__fp_inf>
    2d84:	fb cd       	rjmp	.-1034   	; 0x297c <__fp_szero>
    2d86:	5f 3f       	cpi	r21, 0xFF	; 255
    2d88:	ec f3       	brlt	.-6      	; 0x2d84 <__divsf3_pse+0x6a>
    2d8a:	98 3e       	cpi	r25, 0xE8	; 232
    2d8c:	dc f3       	brlt	.-10     	; 0x2d84 <__divsf3_pse+0x6a>
    2d8e:	86 95       	lsr	r24
    2d90:	77 95       	ror	r23
    2d92:	67 95       	ror	r22
    2d94:	b7 95       	ror	r27
    2d96:	f7 95       	ror	r31
    2d98:	9f 5f       	subi	r25, 0xFF	; 255
    2d9a:	c9 f7       	brne	.-14     	; 0x2d8e <__divsf3_pse+0x74>
    2d9c:	88 0f       	add	r24, r24
    2d9e:	91 1d       	adc	r25, r1
    2da0:	96 95       	lsr	r25
    2da2:	87 95       	ror	r24
    2da4:	97 f9       	bld	r25, 7
    2da6:	08 95       	ret
    2da8:	e1 e0       	ldi	r30, 0x01	; 1
    2daa:	66 0f       	add	r22, r22
    2dac:	77 1f       	adc	r23, r23
    2dae:	88 1f       	adc	r24, r24
    2db0:	bb 1f       	adc	r27, r27
    2db2:	62 17       	cp	r22, r18
    2db4:	73 07       	cpc	r23, r19
    2db6:	84 07       	cpc	r24, r20
    2db8:	ba 07       	cpc	r27, r26
    2dba:	20 f0       	brcs	.+8      	; 0x2dc4 <__divsf3_pse+0xaa>
    2dbc:	62 1b       	sub	r22, r18
    2dbe:	73 0b       	sbc	r23, r19
    2dc0:	84 0b       	sbc	r24, r20
    2dc2:	ba 0b       	sbc	r27, r26
    2dc4:	ee 1f       	adc	r30, r30
    2dc6:	88 f7       	brcc	.-30     	; 0x2daa <__divsf3_pse+0x90>
    2dc8:	e0 95       	com	r30
    2dca:	08 95       	ret

00002dcc <__fp_mpack>:
    2dcc:	9f 3f       	cpi	r25, 0xFF	; 255
    2dce:	31 f0       	breq	.+12     	; 0x2ddc <__fp_mpack_finite+0xc>

00002dd0 <__fp_mpack_finite>:
    2dd0:	91 50       	subi	r25, 0x01	; 1
    2dd2:	20 f4       	brcc	.+8      	; 0x2ddc <__fp_mpack_finite+0xc>
    2dd4:	87 95       	ror	r24
    2dd6:	77 95       	ror	r23
    2dd8:	67 95       	ror	r22
    2dda:	b7 95       	ror	r27
    2ddc:	88 0f       	add	r24, r24
    2dde:	91 1d       	adc	r25, r1
    2de0:	96 95       	lsr	r25
    2de2:	87 95       	ror	r24
    2de4:	97 f9       	bld	r25, 7
    2de6:	08 95       	ret

00002de8 <__divmodhi4>:
    2de8:	97 fb       	bst	r25, 7
    2dea:	07 2e       	mov	r0, r23
    2dec:	16 f4       	brtc	.+4      	; 0x2df2 <__divmodhi4+0xa>
    2dee:	00 94       	com	r0
    2df0:	06 d0       	rcall	.+12     	; 0x2dfe <__divmodhi4_neg1>
    2df2:	77 fd       	sbrc	r23, 7
    2df4:	08 d0       	rcall	.+16     	; 0x2e06 <__divmodhi4_neg2>
    2df6:	0b d0       	rcall	.+22     	; 0x2e0e <__udivmodhi4>
    2df8:	07 fc       	sbrc	r0, 7
    2dfa:	05 d0       	rcall	.+10     	; 0x2e06 <__divmodhi4_neg2>
    2dfc:	3e f4       	brtc	.+14     	; 0x2e0c <__divmodhi4_exit>

00002dfe <__divmodhi4_neg1>:
    2dfe:	90 95       	com	r25
    2e00:	81 95       	neg	r24
    2e02:	9f 4f       	sbci	r25, 0xFF	; 255
    2e04:	08 95       	ret

00002e06 <__divmodhi4_neg2>:
    2e06:	70 95       	com	r23
    2e08:	61 95       	neg	r22
    2e0a:	7f 4f       	sbci	r23, 0xFF	; 255

00002e0c <__divmodhi4_exit>:
    2e0c:	08 95       	ret

00002e0e <__udivmodhi4>:
    2e0e:	aa 1b       	sub	r26, r26
    2e10:	bb 1b       	sub	r27, r27
    2e12:	51 e1       	ldi	r21, 0x11	; 17
    2e14:	07 c0       	rjmp	.+14     	; 0x2e24 <__udivmodhi4_ep>

00002e16 <__udivmodhi4_loop>:
    2e16:	aa 1f       	adc	r26, r26
    2e18:	bb 1f       	adc	r27, r27
    2e1a:	a6 17       	cp	r26, r22
    2e1c:	b7 07       	cpc	r27, r23
    2e1e:	10 f0       	brcs	.+4      	; 0x2e24 <__udivmodhi4_ep>
    2e20:	a6 1b       	sub	r26, r22
    2e22:	b7 0b       	sbc	r27, r23

00002e24 <__udivmodhi4_ep>:
    2e24:	88 1f       	adc	r24, r24
    2e26:	99 1f       	adc	r25, r25
    2e28:	5a 95       	dec	r21
    2e2a:	a9 f7       	brne	.-22     	; 0x2e16 <__udivmodhi4_loop>
    2e2c:	80 95       	com	r24
    2e2e:	90 95       	com	r25
    2e30:	bc 01       	movw	r22, r24
    2e32:	cd 01       	movw	r24, r26
    2e34:	08 95       	ret

00002e36 <memcpy>:
    2e36:	fb 01       	movw	r30, r22
    2e38:	dc 01       	movw	r26, r24
    2e3a:	02 c0       	rjmp	.+4      	; 0x2e40 <memcpy+0xa>
    2e3c:	01 90       	ld	r0, Z+
    2e3e:	0d 92       	st	X+, r0
    2e40:	41 50       	subi	r20, 0x01	; 1
    2e42:	50 40       	sbci	r21, 0x00	; 0
    2e44:	d8 f7       	brcc	.-10     	; 0x2e3c <memcpy+0x6>
    2e46:	08 95       	ret

00002e48 <__itoa_ncheck>:
    2e48:	bb 27       	eor	r27, r27
    2e4a:	4a 30       	cpi	r20, 0x0A	; 10
    2e4c:	31 f4       	brne	.+12     	; 0x2e5a <__itoa_ncheck+0x12>
    2e4e:	99 23       	and	r25, r25
    2e50:	22 f4       	brpl	.+8      	; 0x2e5a <__itoa_ncheck+0x12>
    2e52:	bd e2       	ldi	r27, 0x2D	; 45
    2e54:	90 95       	com	r25
    2e56:	81 95       	neg	r24
    2e58:	9f 4f       	sbci	r25, 0xFF	; 255
    2e5a:	01 c0       	rjmp	.+2      	; 0x2e5e <__utoa_common>

00002e5c <__utoa_ncheck>:
    2e5c:	bb 27       	eor	r27, r27

00002e5e <__utoa_common>:
    2e5e:	fb 01       	movw	r30, r22
    2e60:	55 27       	eor	r21, r21
    2e62:	aa 27       	eor	r26, r26
    2e64:	88 0f       	add	r24, r24
    2e66:	99 1f       	adc	r25, r25
    2e68:	aa 1f       	adc	r26, r26
    2e6a:	a4 17       	cp	r26, r20
    2e6c:	10 f0       	brcs	.+4      	; 0x2e72 <__utoa_common+0x14>
    2e6e:	a4 1b       	sub	r26, r20
    2e70:	83 95       	inc	r24
    2e72:	50 51       	subi	r21, 0x10	; 16
    2e74:	b9 f7       	brne	.-18     	; 0x2e64 <__utoa_common+0x6>
    2e76:	a0 5d       	subi	r26, 0xD0	; 208
    2e78:	aa 33       	cpi	r26, 0x3A	; 58
    2e7a:	08 f0       	brcs	.+2      	; 0x2e7e <__utoa_common+0x20>
    2e7c:	a9 5d       	subi	r26, 0xD9	; 217
    2e7e:	a1 93       	st	Z+, r26
    2e80:	00 97       	sbiw	r24, 0x00	; 0
    2e82:	79 f7       	brne	.-34     	; 0x2e62 <__utoa_common+0x4>
    2e84:	b1 11       	cpse	r27, r1
    2e86:	b1 93       	st	Z+, r27
    2e88:	11 92       	st	Z+, r1
    2e8a:	cb 01       	movw	r24, r22
    2e8c:	00 c0       	rjmp	.+0      	; 0x2e8e <strrev>

00002e8e <strrev>:
    2e8e:	dc 01       	movw	r26, r24
    2e90:	fc 01       	movw	r30, r24
    2e92:	67 2f       	mov	r22, r23
    2e94:	71 91       	ld	r23, Z+
    2e96:	77 23       	and	r23, r23
    2e98:	e1 f7       	brne	.-8      	; 0x2e92 <strrev+0x4>
    2e9a:	32 97       	sbiw	r30, 0x02	; 2
    2e9c:	04 c0       	rjmp	.+8      	; 0x2ea6 <strrev+0x18>
    2e9e:	7c 91       	ld	r23, X
    2ea0:	6d 93       	st	X+, r22
    2ea2:	70 83       	st	Z, r23
    2ea4:	62 91       	ld	r22, -Z
    2ea6:	ae 17       	cp	r26, r30
    2ea8:	bf 07       	cpc	r27, r31
    2eaa:	c8 f3       	brcs	.-14     	; 0x2e9e <strrev+0x10>
    2eac:	08 95       	ret

00002eae <_exit>:
    2eae:	f8 94       	cli

00002eb0 <__stop_program>:
    2eb0:	ff cf       	rjmp	.-2      	; 0x2eb0 <__stop_program>
