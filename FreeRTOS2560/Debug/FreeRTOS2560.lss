
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800200  00002122  000021b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002122  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fa  0080028e  0080028e  00002244  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002244  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  00002274  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000520d  00000000  00000000  0000272c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001389  00000000  00000000  00007939  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003238  00000000  00000000  00008cc2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d40  00000000  00000000  0000befc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000014ad  00000000  00000000  0000cc3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003677  00000000  00000000  0000e0e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011760  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	76 c2       	rjmp	.+1260   	; 0x512 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	1a c7       	rjmp	.+3636   	; 0xe8a <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	46 c4       	rjmp	.+2188   	; 0x8f2 <__vector_25>
      66:	00 00       	nop
      68:	b2 c4       	rjmp	.+2404   	; 0x9ce <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	c0 c2       	rjmp	.+1408   	; 0x5f6 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f8 c3       	rjmp	.+2032   	; 0x882 <__vector_36>
      92:	00 00       	nop
      94:	66 c4       	rjmp	.+2252   	; 0x962 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 e2       	ldi	r30, 0x22	; 34
      fc:	f1 e2       	ldi	r31, 0x21	; 33
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 38       	cpi	r26, 0x8E	; 142
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ae e8       	ldi	r26, 0x8E	; 142
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a8 38       	cpi	r26, 0x88	; 136
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	d5 d0       	rcall	.+426    	; 0x2ca <main>
     120:	0c 94 8f 10 	jmp	0x211e	; 0x211e <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	19 d5       	rcall	.+2610   	; 0xb8a <myUSART_waitForHandshake>
     158:	86 e0       	ldi	r24, 0x06	; 6
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	dc c4       	rjmp	.+2488   	; 0xb16 <myUSART_transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	09 d5       	rcall	.+2578   	; 0xb74 <myUSART_startHandShake>
     162:	8d e1       	ldi	r24, 0x1D	; 29
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	d7 c4       	rjmp	.+2478   	; 0xb16 <myUSART_transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a8 97       	sbiw	r28, 0x28	; 40
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e3 e3       	ldi	r30, 0x33	; 51
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	17 96       	adiw	r26, 0x07	; 7
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	eb e3       	ldi	r30, 0x3B	; 59
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1f 96       	adiw	r26, 0x0f	; 15
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e2 e4       	ldi	r30, 0x42	; 66
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	56 96       	adiw	r26, 0x16	; 22
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	ea e4       	ldi	r30, 0x4A	; 74
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5e 96       	adiw	r26, 0x1e	; 30
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	e0 e5       	ldi	r30, 0x50	; 80
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	94 96       	adiw	r26, 0x24	; 36
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	0e 94 37 0c 	call	0x186e	; 0x186e <xTaskGetTickCount>
     1dc:	9a 83       	std	Y+2, r25	; 0x02
     1de:	89 83       	std	Y+1, r24	; 0x01
     1e0:	f9 d1       	rcall	.+1010   	; 0x5d4 <myMaxSonar_Start>
     1e2:	87 e2       	ldi	r24, 0x27	; 39
     1e4:	fe d1       	rcall	.+1020   	; 0x5e2 <myMaxSonar_Read>
     1e6:	4a e0       	ldi	r20, 0x0A	; 10
     1e8:	be 01       	movw	r22, r28
     1ea:	6d 5f       	subi	r22, 0xFD	; 253
     1ec:	7f 4f       	sbci	r23, 0xFF	; 255
     1ee:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <__itoa_ncheck>
     1f2:	ce 01       	movw	r24, r28
     1f4:	07 96       	adiw	r24, 0x07	; 7
     1f6:	8f d4       	rcall	.+2334   	; 0xb16 <myUSART_transmitUSART0>
     1f8:	ce 01       	movw	r24, r28
     1fa:	03 96       	adiw	r24, 0x03	; 3
     1fc:	8c d4       	rcall	.+2328   	; 0xb16 <myUSART_transmitUSART0>
     1fe:	ce 01       	movw	r24, r28
     200:	4e 96       	adiw	r24, 0x1e	; 30
     202:	89 d4       	rcall	.+2322   	; 0xb16 <myUSART_transmitUSART0>
     204:	86 e2       	ldi	r24, 0x26	; 38
     206:	ed d1       	rcall	.+986    	; 0x5e2 <myMaxSonar_Read>
     208:	4a e0       	ldi	r20, 0x0A	; 10
     20a:	be 01       	movw	r22, r28
     20c:	6d 5f       	subi	r22, 0xFD	; 253
     20e:	7f 4f       	sbci	r23, 0xFF	; 255
     210:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <__itoa_ncheck>
     214:	ce 01       	movw	r24, r28
     216:	0f 96       	adiw	r24, 0x0f	; 15
     218:	7e d4       	rcall	.+2300   	; 0xb16 <myUSART_transmitUSART0>
     21a:	ce 01       	movw	r24, r28
     21c:	03 96       	adiw	r24, 0x03	; 3
     21e:	7b d4       	rcall	.+2294   	; 0xb16 <myUSART_transmitUSART0>
     220:	ce 01       	movw	r24, r28
     222:	4e 96       	adiw	r24, 0x1e	; 30
     224:	78 d4       	rcall	.+2288   	; 0xb16 <myUSART_transmitUSART0>
     226:	85 e2       	ldi	r24, 0x25	; 37
     228:	dc d1       	rcall	.+952    	; 0x5e2 <myMaxSonar_Read>
     22a:	4a e0       	ldi	r20, 0x0A	; 10
     22c:	be 01       	movw	r22, r28
     22e:	6d 5f       	subi	r22, 0xFD	; 253
     230:	7f 4f       	sbci	r23, 0xFF	; 255
     232:	0a 97       	sbiw	r24, 0x0a	; 10
     234:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <__itoa_ncheck>
     238:	ce 01       	movw	r24, r28
     23a:	46 96       	adiw	r24, 0x16	; 22
     23c:	6c d4       	rcall	.+2264   	; 0xb16 <myUSART_transmitUSART0>
     23e:	ce 01       	movw	r24, r28
     240:	03 96       	adiw	r24, 0x03	; 3
     242:	69 d4       	rcall	.+2258   	; 0xb16 <myUSART_transmitUSART0>
     244:	ce 01       	movw	r24, r28
     246:	84 96       	adiw	r24, 0x24	; 36
     248:	66 d4       	rcall	.+2252   	; 0xb16 <myUSART_transmitUSART0>
     24a:	66 e9       	ldi	r22, 0x96	; 150
     24c:	70 e0       	ldi	r23, 0x00	; 0
     24e:	ce 01       	movw	r24, r28
     250:	01 96       	adiw	r24, 0x01	; 1
     252:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <vTaskDelayUntil>
     256:	c4 cf       	rjmp	.-120    	; 0x1e0 <maxSonarTask+0x76>

00000258 <myTimerTask>:
     258:	66 d2       	rcall	.+1228   	; 0x726 <myTimer_Init>
     25a:	a4 d2       	rcall	.+1352   	; 0x7a4 <myTimer_DelayChecker>
     25c:	fe cf       	rjmp	.-4      	; 0x25a <myTimerTask+0x2>

0000025e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     25e:	8c ec       	ldi	r24, 0xCC	; 204
     260:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     264:	8e e3       	ldi	r24, 0x3E	; 62
     266:	80 93 65 00 	sts	0x0065, r24
     26a:	08 95       	ret

0000026c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     26c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     270:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     274:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     278:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     27c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     280:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     284:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     288:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     28c:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     290:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     294:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     298:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     29c:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2a0:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2a4:	10 92 73 00 	sts	0x0073, r1
     2a8:	08 95       	ret

000002aa <init>:
}

void init()
{
     2aa:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2ac:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2ae:	f8 94       	cli
	{
		clearTimer();
     2b0:	dd df       	rcall	.-70     	; 0x26c <clearTimer>
		setPowerReduction();
     2b2:	d5 df       	rcall	.-86     	; 0x25e <setPowerReduction>
		myUSART_USART0_Init();
     2b4:	c2 d3       	rcall	.+1924   	; 0xa3a <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2b6:	e1 d3       	rcall	.+1986   	; 0xa7a <myUSART_USART1_Init>
		myADC_Init();
     2b8:	d2 d1       	rcall	.+932    	; 0x65e <myADC_Init>
		MaxSonar_Init();
     2ba:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2bc:	84 b1       	in	r24, 0x04	; 4
     2be:	80 6c       	ori	r24, 0xC0	; 192
     2c0:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2c2:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2c4:	78 94       	sei
}
     2c6:	cf 91       	pop	r28
     2c8:	08 95       	ret

000002ca <main>:
	
	// do nth
}

int main(void)
{
     2ca:	cf 93       	push	r28
     2cc:	df 93       	push	r29
     2ce:	cd b7       	in	r28, 0x3d	; 61
     2d0:	de b7       	in	r29, 0x3e	; 62
     2d2:	2c 97       	sbiw	r28, 0x0c	; 12
     2d4:	0f b6       	in	r0, 0x3f	; 63
     2d6:	f8 94       	cli
     2d8:	de bf       	out	0x3e, r29	; 62
     2da:	0f be       	out	0x3f, r0	; 63
     2dc:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2de:	e5 df       	rcall	.-54     	; 0x2aa <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     2e0:	a1 2c       	mov	r10, r1
     2e2:	b1 2c       	mov	r11, r1
     2e4:	c1 2c       	mov	r12, r1
     2e6:	d1 2c       	mov	r13, r1
     2e8:	ce 01       	movw	r24, r28
     2ea:	01 96       	adiw	r24, 0x01	; 1
     2ec:	7c 01       	movw	r14, r24
     2ee:	04 e0       	ldi	r16, 0x04	; 4
     2f0:	9c 01       	movw	r18, r24
     2f2:	49 e6       	ldi	r20, 0x69	; 105
     2f4:	50 e0       	ldi	r21, 0x00	; 0
     2f6:	65 e5       	ldi	r22, 0x55	; 85
     2f8:	72 e0       	ldi	r23, 0x02	; 2
     2fa:	8c e2       	ldi	r24, 0x2C	; 44
     2fc:	91 e0       	ldi	r25, 0x01	; 1
     2fe:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     302:	ce 01       	movw	r24, r28
     304:	07 96       	adiw	r24, 0x07	; 7
     306:	7c 01       	movw	r14, r24
     308:	02 e0       	ldi	r16, 0x02	; 2
     30a:	20 e0       	ldi	r18, 0x00	; 0
     30c:	30 e0       	ldi	r19, 0x00	; 0
     30e:	4d e1       	ldi	r20, 0x1D	; 29
     310:	51 e0       	ldi	r21, 0x01	; 1
     312:	6d e5       	ldi	r22, 0x5D	; 93
     314:	72 e0       	ldi	r23, 0x02	; 2
     316:	85 eb       	ldi	r24, 0xB5	; 181
     318:	90 e0       	ldi	r25, 0x00	; 0
     31a:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     31e:	ce 01       	movw	r24, r28
     320:	0b 96       	adiw	r24, 0x0b	; 11
     322:	7c 01       	movw	r14, r24
     324:	01 e0       	ldi	r16, 0x01	; 1
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	49 e6       	ldi	r20, 0x69	; 105
     32c:	50 e0       	ldi	r21, 0x00	; 0
     32e:	66 e6       	ldi	r22, 0x66	; 102
     330:	72 e0       	ldi	r23, 0x02	; 2
     332:	83 e9       	ldi	r24, 0x93	; 147
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     33a:	ce 01       	movw	r24, r28
     33c:	09 96       	adiw	r24, 0x09	; 9
     33e:	7c 01       	movw	r14, r24
     340:	20 e0       	ldi	r18, 0x00	; 0
     342:	30 e0       	ldi	r19, 0x00	; 0
     344:	49 e6       	ldi	r20, 0x69	; 105
     346:	50 e0       	ldi	r21, 0x00	; 0
     348:	6d e6       	ldi	r22, 0x6D	; 109
     34a:	72 e0       	ldi	r23, 0x02	; 2
     34c:	8f e9       	ldi	r24, 0x9F	; 159
     34e:	90 e0       	ldi	r25, 0x00	; 0
     350:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     354:	ce 01       	movw	r24, r28
     356:	05 96       	adiw	r24, 0x05	; 5
     358:	7c 01       	movw	r14, r24
     35a:	03 e0       	ldi	r16, 0x03	; 3
     35c:	20 e0       	ldi	r18, 0x00	; 0
     35e:	30 e0       	ldi	r19, 0x00	; 0
     360:	47 e8       	ldi	r20, 0x87	; 135
     362:	50 e0       	ldi	r21, 0x00	; 0
     364:	64 e7       	ldi	r22, 0x74	; 116
     366:	72 e0       	ldi	r23, 0x02	; 2
     368:	8b ea       	ldi	r24, 0xAB	; 171
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     370:	ce 01       	movw	r24, r28
     372:	03 96       	adiw	r24, 0x03	; 3
     374:	7c 01       	movw	r14, r24
     376:	02 e0       	ldi	r16, 0x02	; 2
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	47 e8       	ldi	r20, 0x87	; 135
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	60 e8       	ldi	r22, 0x80	; 128
     382:	72 e0       	ldi	r23, 0x02	; 2
     384:	80 eb       	ldi	r24, 0xB0	; 176
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     38c:	0e 94 08 0c 	call	0x1810	; 0x1810 <vTaskStartScheduler>
     390:	a6 cf       	rjmp	.-180    	; 0x2de <main+0x14>

00000392 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     398:	0e 94 31 0c 	call	0x1862	; 0x1862 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     39c:	80 91 8e 02 	lds	r24, 0x028E
     3a0:	90 91 8f 02 	lds	r25, 0x028F
     3a4:	89 2b       	or	r24, r25
     3a6:	31 f4       	brne	.+12     	; 0x3b4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3a8:	83 e9       	ldi	r24, 0x93	; 147
     3aa:	92 e0       	ldi	r25, 0x02	; 2
     3ac:	90 93 8f 02 	sts	0x028F, r25
     3b0:	80 93 8e 02 	sts	0x028E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3b4:	40 91 90 02 	lds	r20, 0x0290
     3b8:	50 91 91 02 	lds	r21, 0x0291
     3bc:	9e 01       	movw	r18, r28
     3be:	24 0f       	add	r18, r20
     3c0:	35 1f       	adc	r19, r21
     3c2:	2b 3d       	cpi	r18, 0xDB	; 219
     3c4:	85 e0       	ldi	r24, 0x05	; 5
     3c6:	38 07       	cpc	r19, r24
     3c8:	70 f4       	brcc	.+28     	; 0x3e6 <pvPortMalloc+0x54>
     3ca:	42 17       	cp	r20, r18
     3cc:	53 07       	cpc	r21, r19
     3ce:	70 f4       	brcc	.+28     	; 0x3ec <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3d0:	c0 91 8e 02 	lds	r28, 0x028E
     3d4:	d0 91 8f 02 	lds	r29, 0x028F
     3d8:	c4 0f       	add	r28, r20
     3da:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3dc:	30 93 91 02 	sts	0x0291, r19
     3e0:	20 93 90 02 	sts	0x0290, r18
     3e4:	05 c0       	rjmp	.+10     	; 0x3f0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3e6:	c0 e0       	ldi	r28, 0x00	; 0
     3e8:	d0 e0       	ldi	r29, 0x00	; 0
     3ea:	02 c0       	rjmp	.+4      	; 0x3f0 <pvPortMalloc+0x5e>
     3ec:	c0 e0       	ldi	r28, 0x00	; 0
     3ee:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3f0:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3f4:	ce 01       	movw	r24, r28
     3f6:	df 91       	pop	r29
     3f8:	cf 91       	pop	r28
     3fa:	08 95       	ret

000003fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3fc:	08 95       	ret

000003fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3fe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     400:	03 96       	adiw	r24, 0x03	; 3
     402:	92 83       	std	Z+2, r25	; 0x02
     404:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     406:	2f ef       	ldi	r18, 0xFF	; 255
     408:	3f ef       	ldi	r19, 0xFF	; 255
     40a:	34 83       	std	Z+4, r19	; 0x04
     40c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     40e:	96 83       	std	Z+6, r25	; 0x06
     410:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     412:	90 87       	std	Z+8, r25	; 0x08
     414:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     416:	10 82       	st	Z, r1
     418:	08 95       	ret

0000041a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     41a:	fc 01       	movw	r30, r24
     41c:	11 86       	std	Z+9, r1	; 0x09
     41e:	10 86       	std	Z+8, r1	; 0x08
     420:	08 95       	ret

00000422 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	9c 01       	movw	r18, r24
     428:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     42a:	dc 01       	movw	r26, r24
     42c:	11 96       	adiw	r26, 0x01	; 1
     42e:	cd 91       	ld	r28, X+
     430:	dc 91       	ld	r29, X
     432:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     434:	d3 83       	std	Z+3, r29	; 0x03
     436:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     438:	8c 81       	ldd	r24, Y+4	; 0x04
     43a:	9d 81       	ldd	r25, Y+5	; 0x05
     43c:	95 83       	std	Z+5, r25	; 0x05
     43e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     440:	8c 81       	ldd	r24, Y+4	; 0x04
     442:	9d 81       	ldd	r25, Y+5	; 0x05
     444:	dc 01       	movw	r26, r24
     446:	13 96       	adiw	r26, 0x03	; 3
     448:	7c 93       	st	X, r23
     44a:	6e 93       	st	-X, r22
     44c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     44e:	7d 83       	std	Y+5, r23	; 0x05
     450:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     452:	31 87       	std	Z+9, r19	; 0x09
     454:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     456:	f9 01       	movw	r30, r18
     458:	80 81       	ld	r24, Z
     45a:	8f 5f       	subi	r24, 0xFF	; 255
     45c:	80 83       	st	Z, r24
}
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	08 95       	ret

00000464 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     464:	cf 93       	push	r28
     466:	df 93       	push	r29
     468:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     46a:	48 81       	ld	r20, Y
     46c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     46e:	4f 3f       	cpi	r20, 0xFF	; 255
     470:	2f ef       	ldi	r18, 0xFF	; 255
     472:	52 07       	cpc	r21, r18
     474:	21 f4       	brne	.+8      	; 0x47e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     476:	fc 01       	movw	r30, r24
     478:	a7 81       	ldd	r26, Z+7	; 0x07
     47a:	b0 85       	ldd	r27, Z+8	; 0x08
     47c:	0d c0       	rjmp	.+26     	; 0x498 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     47e:	dc 01       	movw	r26, r24
     480:	13 96       	adiw	r26, 0x03	; 3
     482:	12 96       	adiw	r26, 0x02	; 2
     484:	ed 91       	ld	r30, X+
     486:	fc 91       	ld	r31, X
     488:	13 97       	sbiw	r26, 0x03	; 3
     48a:	20 81       	ld	r18, Z
     48c:	31 81       	ldd	r19, Z+1	; 0x01
     48e:	42 17       	cp	r20, r18
     490:	53 07       	cpc	r21, r19
     492:	10 f0       	brcs	.+4      	; 0x498 <vListInsert+0x34>
     494:	df 01       	movw	r26, r30
     496:	f5 cf       	rjmp	.-22     	; 0x482 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     498:	12 96       	adiw	r26, 0x02	; 2
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	13 97       	sbiw	r26, 0x03	; 3
     4a0:	fb 83       	std	Y+3, r31	; 0x03
     4a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4a4:	d5 83       	std	Z+5, r29	; 0x05
     4a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4a8:	bd 83       	std	Y+5, r27	; 0x05
     4aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4ac:	13 96       	adiw	r26, 0x03	; 3
     4ae:	dc 93       	st	X, r29
     4b0:	ce 93       	st	-X, r28
     4b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4b4:	99 87       	std	Y+9, r25	; 0x09
     4b6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4b8:	fc 01       	movw	r30, r24
     4ba:	20 81       	ld	r18, Z
     4bc:	2f 5f       	subi	r18, 0xFF	; 255
     4be:	20 83       	st	Z, r18
}
     4c0:	df 91       	pop	r29
     4c2:	cf 91       	pop	r28
     4c4:	08 95       	ret

000004c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4c6:	cf 93       	push	r28
     4c8:	df 93       	push	r29
     4ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4cc:	a0 85       	ldd	r26, Z+8	; 0x08
     4ce:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4d0:	c2 81       	ldd	r28, Z+2	; 0x02
     4d2:	d3 81       	ldd	r29, Z+3	; 0x03
     4d4:	84 81       	ldd	r24, Z+4	; 0x04
     4d6:	95 81       	ldd	r25, Z+5	; 0x05
     4d8:	9d 83       	std	Y+5, r25	; 0x05
     4da:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4dc:	c4 81       	ldd	r28, Z+4	; 0x04
     4de:	d5 81       	ldd	r29, Z+5	; 0x05
     4e0:	82 81       	ldd	r24, Z+2	; 0x02
     4e2:	93 81       	ldd	r25, Z+3	; 0x03
     4e4:	9b 83       	std	Y+3, r25	; 0x03
     4e6:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4e8:	11 96       	adiw	r26, 0x01	; 1
     4ea:	cd 91       	ld	r28, X+
     4ec:	dc 91       	ld	r29, X
     4ee:	12 97       	sbiw	r26, 0x02	; 2
     4f0:	ce 17       	cp	r28, r30
     4f2:	df 07       	cpc	r29, r31
     4f4:	31 f4       	brne	.+12     	; 0x502 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4f6:	8c 81       	ldd	r24, Y+4	; 0x04
     4f8:	9d 81       	ldd	r25, Y+5	; 0x05
     4fa:	12 96       	adiw	r26, 0x02	; 2
     4fc:	9c 93       	st	X, r25
     4fe:	8e 93       	st	-X, r24
     500:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     502:	11 86       	std	Z+9, r1	; 0x09
     504:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     506:	8c 91       	ld	r24, X
     508:	81 50       	subi	r24, 0x01	; 1
     50a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	08 95       	ret

00000512 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     512:	1f 92       	push	r1
     514:	0f 92       	push	r0
     516:	0f b6       	in	r0, 0x3f	; 63
     518:	0f 92       	push	r0
     51a:	11 24       	eor	r1, r1
     51c:	0b b6       	in	r0, 0x3b	; 59
     51e:	0f 92       	push	r0
     520:	2f 93       	push	r18
     522:	3f 93       	push	r19
     524:	4f 93       	push	r20
     526:	5f 93       	push	r21
     528:	6f 93       	push	r22
     52a:	7f 93       	push	r23
     52c:	8f 93       	push	r24
     52e:	9f 93       	push	r25
     530:	af 93       	push	r26
     532:	bf 93       	push	r27
     534:	ef 93       	push	r30
     536:	ff 93       	push	r31
	if(HC_Echo_Read == 1)
     538:	83 b1       	in	r24, 0x03	; 3
     53a:	13 b8       	out	0x03, r1	; 3
		us_tickStart = myTimer_Read();
		ms_tickStart = xTaskGetTickCountFromISR();
	}	
	else
	{
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     53c:	0e d1       	rcall	.+540    	; 0x75a <myTimer_Read>
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	90 93 e4 08 	sts	0x08E4, r25
     544:	80 93 e3 08 	sts	0x08E3, r24
     548:	20 91 dd 08 	lds	r18, 0x08DD
     54c:	30 91 de 08 	lds	r19, 0x08DE
     550:	82 17       	cp	r24, r18
     552:	93 07       	cpc	r25, r19
     554:	54 f4       	brge	.+20     	; 0x56a <__vector_9+0x58>
			us_tickEnd += MAX_TICKS;
     556:	80 91 e3 08 	lds	r24, 0x08E3
     55a:	90 91 e4 08 	lds	r25, 0x08E4
     55e:	86 50       	subi	r24, 0x06	; 6
     560:	9f 4f       	sbci	r25, 0xFF	; 255
     562:	90 93 e4 08 	sts	0x08E4, r25
     566:	80 93 e3 08 	sts	0x08E3, r24
			
		us_tickLapsed = myTimer_Read() - us_tickStart;
     56a:	f7 d0       	rcall	.+494    	; 0x75a <myTimer_Read>
     56c:	20 91 dd 08 	lds	r18, 0x08DD
     570:	30 91 de 08 	lds	r19, 0x08DE
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	82 1b       	sub	r24, r18
     578:	93 0b       	sbc	r25, r19
     57a:	90 93 e0 08 	sts	0x08E0, r25
     57e:	80 93 df 08 	sts	0x08DF, r24
		ms_tickLapsed = xTaskGetTickCountFromISR() - ms_tickStart;
     582:	0e 94 41 0c 	call	0x1882	; 0x1882 <xTaskGetTickCountFromISR>
     586:	20 91 d9 08 	lds	r18, 0x08D9
     58a:	30 91 da 08 	lds	r19, 0x08DA
     58e:	82 1b       	sub	r24, r18
     590:	93 0b       	sbc	r25, r19
     592:	90 93 dc 08 	sts	0x08DC, r25
     596:	80 93 db 08 	sts	0x08DB, r24
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	40 e0       	ldi	r20, 0x00	; 0
     59e:	50 e0       	ldi	r21, 0x00	; 0
     5a0:	60 e0       	ldi	r22, 0x00	; 0
     5a2:	70 e0       	ldi	r23, 0x00	; 0
     5a4:	80 91 e1 08 	lds	r24, 0x08E1
     5a8:	90 91 e2 08 	lds	r25, 0x08E2
     5ac:	50 d6       	rcall	.+3232   	; 0x124e <xQueueGenericSendFromISR>
	}	
}
     5ae:	ff 91       	pop	r31
     5b0:	ef 91       	pop	r30
     5b2:	bf 91       	pop	r27
     5b4:	af 91       	pop	r26
     5b6:	9f 91       	pop	r25
     5b8:	8f 91       	pop	r24
     5ba:	7f 91       	pop	r23
     5bc:	6f 91       	pop	r22
     5be:	5f 91       	pop	r21
     5c0:	4f 91       	pop	r20
     5c2:	3f 91       	pop	r19
     5c4:	2f 91       	pop	r18
     5c6:	0f 90       	pop	r0
     5c8:	0b be       	out	0x3b, r0	; 59
     5ca:	0f 90       	pop	r0
     5cc:	0f be       	out	0x3f, r0	; 63
     5ce:	0f 90       	pop	r0
     5d0:	1f 90       	pop	r1
     5d2:	18 95       	reti

000005d4 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     5d4:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     5d6:	89 e1       	ldi	r24, 0x19	; 25
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	c1 d0       	rcall	.+386    	; 0x75e <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     5dc:	84 b3       	in	r24, 0x14	; 20
     5de:	14 ba       	out	0x14, r1	; 20
     5e0:	08 95       	ret

000005e2 <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     5e2:	9a d0       	rcall	.+308    	; 0x718 <myADC_analogRead>
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	9c 01       	movw	r18, r24
     5e8:	22 0f       	add	r18, r18
     5ea:	33 1f       	adc	r19, r19
     5ec:	22 0f       	add	r18, r18
     5ee:	33 1f       	adc	r19, r19
}
     5f0:	82 0f       	add	r24, r18
     5f2:	93 1f       	adc	r25, r19
     5f4:	08 95       	ret

000005f6 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     5f6:	1f 92       	push	r1
     5f8:	0f 92       	push	r0
     5fa:	0f b6       	in	r0, 0x3f	; 63
     5fc:	0f 92       	push	r0
     5fe:	11 24       	eor	r1, r1
     600:	0b b6       	in	r0, 0x3b	; 59
     602:	0f 92       	push	r0
     604:	2f 93       	push	r18
     606:	3f 93       	push	r19
     608:	4f 93       	push	r20
     60a:	5f 93       	push	r21
     60c:	6f 93       	push	r22
     60e:	7f 93       	push	r23
     610:	8f 93       	push	r24
     612:	9f 93       	push	r25
     614:	af 93       	push	r26
     616:	bf 93       	push	r27
     618:	ef 93       	push	r30
     61a:	ff 93       	push	r31
	adcReading = ADCH; // read value
     61c:	80 91 79 00 	lds	r24, 0x0079
     620:	80 93 e5 08 	sts	0x08E5, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     624:	20 e0       	ldi	r18, 0x00	; 0
     626:	40 e0       	ldi	r20, 0x00	; 0
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	60 e0       	ldi	r22, 0x00	; 0
     62c:	70 e0       	ldi	r23, 0x00	; 0
     62e:	80 91 e8 08 	lds	r24, 0x08E8
     632:	90 91 e9 08 	lds	r25, 0x08E9
     636:	0b d6       	rcall	.+3094   	; 0x124e <xQueueGenericSendFromISR>
}
     638:	ff 91       	pop	r31
     63a:	ef 91       	pop	r30
     63c:	bf 91       	pop	r27
     63e:	af 91       	pop	r26
     640:	9f 91       	pop	r25
     642:	8f 91       	pop	r24
     644:	7f 91       	pop	r23
     646:	6f 91       	pop	r22
     648:	5f 91       	pop	r21
     64a:	4f 91       	pop	r20
     64c:	3f 91       	pop	r19
     64e:	2f 91       	pop	r18
     650:	0f 90       	pop	r0
     652:	0b be       	out	0x3b, r0	; 59
     654:	0f 90       	pop	r0
     656:	0f be       	out	0x3f, r0	; 63
     658:	0f 90       	pop	r0
     65a:	1f 90       	pop	r1
     65c:	18 95       	reti

0000065e <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     65e:	8f e8       	ldi	r24, 0x8F	; 143
     660:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     664:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     668:	80 e6       	ldi	r24, 0x60	; 96
     66a:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     66e:	43 e0       	ldi	r20, 0x03	; 3
     670:	60 e0       	ldi	r22, 0x00	; 0
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	07 d5       	rcall	.+2574   	; 0x1084 <xQueueGenericCreate>
     676:	90 93 e9 08 	sts	0x08E9, r25
     67a:	80 93 e8 08 	sts	0x08E8, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	be d5       	rcall	.+2940   	; 0x11fe <xQueueCreateMutex>
     682:	90 93 e7 08 	sts	0x08E7, r25
     686:	80 93 e6 08 	sts	0x08E6, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	40 e0       	ldi	r20, 0x00	; 0
     68e:	50 e0       	ldi	r21, 0x00	; 0
     690:	60 e0       	ldi	r22, 0x00	; 0
     692:	70 e0       	ldi	r23, 0x00	; 0
     694:	21 c5       	rjmp	.+2626   	; 0x10d8 <xQueueGenericSend>
     696:	08 95       	ret

00000698 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     698:	cf 93       	push	r28
     69a:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     69c:	20 e0       	ldi	r18, 0x00	; 0
     69e:	4f ef       	ldi	r20, 0xFF	; 255
     6a0:	5f ef       	ldi	r21, 0xFF	; 255
     6a2:	60 e0       	ldi	r22, 0x00	; 0
     6a4:	70 e0       	ldi	r23, 0x00	; 0
     6a6:	80 91 e6 08 	lds	r24, 0x08E6
     6aa:	90 91 e7 08 	lds	r25, 0x08E7
     6ae:	09 d6       	rcall	.+3090   	; 0x12c2 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     6b0:	ec e7       	ldi	r30, 0x7C	; 124
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	80 81       	ld	r24, Z
     6b6:	9c 2f       	mov	r25, r28
     6b8:	9f 71       	andi	r25, 0x1F	; 31
     6ba:	80 76       	andi	r24, 0x60	; 96
     6bc:	89 2b       	or	r24, r25
     6be:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     6c0:	eb e7       	ldi	r30, 0x7B	; 123
     6c2:	f0 e0       	ldi	r31, 0x00	; 0
     6c4:	20 81       	ld	r18, Z
     6c6:	c0 72       	andi	r28, 0x20	; 32
     6c8:	8c 2f       	mov	r24, r28
     6ca:	90 e0       	ldi	r25, 0x00	; 0
     6cc:	95 95       	asr	r25
     6ce:	87 95       	ror	r24
     6d0:	95 95       	asr	r25
     6d2:	87 95       	ror	r24
     6d4:	92 2f       	mov	r25, r18
     6d6:	90 76       	andi	r25, 0x60	; 96
     6d8:	89 2b       	or	r24, r25
     6da:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     6dc:	ea e7       	ldi	r30, 0x7A	; 122
     6de:	f0 e0       	ldi	r31, 0x00	; 0
     6e0:	80 81       	ld	r24, Z
     6e2:	80 64       	ori	r24, 0x40	; 64
     6e4:	80 83       	st	Z, r24
}
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     6ea:	20 e0       	ldi	r18, 0x00	; 0
     6ec:	4f ef       	ldi	r20, 0xFF	; 255
     6ee:	5f ef       	ldi	r21, 0xFF	; 255
     6f0:	60 e0       	ldi	r22, 0x00	; 0
     6f2:	70 e0       	ldi	r23, 0x00	; 0
     6f4:	80 91 e8 08 	lds	r24, 0x08E8
     6f8:	90 91 e9 08 	lds	r25, 0x08E9
     6fc:	e2 d5       	rcall	.+3012   	; 0x12c2 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     6fe:	20 e0       	ldi	r18, 0x00	; 0
     700:	40 e0       	ldi	r20, 0x00	; 0
     702:	50 e0       	ldi	r21, 0x00	; 0
     704:	60 e0       	ldi	r22, 0x00	; 0
     706:	70 e0       	ldi	r23, 0x00	; 0
     708:	80 91 e6 08 	lds	r24, 0x08E6
     70c:	90 91 e7 08 	lds	r25, 0x08E7
     710:	e3 d4       	rcall	.+2502   	; 0x10d8 <xQueueGenericSend>
	return adcReading;
     712:	80 91 e5 08 	lds	r24, 0x08E5
     716:	08 95       	ret

00000718 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     718:	cf 93       	push	r28
     71a:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     71c:	bd df       	rcall	.-134    	; 0x698 <myADC_startADC>
	return myADC_readADC(channel);
     71e:	8c 2f       	mov	r24, r28
     720:	e4 df       	rcall	.-56     	; 0x6ea <myADC_readADC>
}
     722:	cf 91       	pop	r28
     724:	08 95       	ret

00000726 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     726:	90 93 ef 08 	sts	0x08EF, r25
     72a:	80 93 ee 08 	sts	0x08EE, r24
     72e:	fc 01       	movw	r30, r24
     730:	80 81       	ld	r24, Z
     732:	91 81       	ldd	r25, Z+1	; 0x01
     734:	0e 94 76 0e 	call	0x1cec	; 0x1cec <vTaskSuspend>
     738:	43 e0       	ldi	r20, 0x03	; 3
     73a:	60 e0       	ldi	r22, 0x00	; 0
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	a2 d4       	rcall	.+2372   	; 0x1084 <xQueueGenericCreate>
     740:	90 93 eb 08 	sts	0x08EB, r25
     744:	80 93 ea 08 	sts	0x08EA, r24
     748:	43 e0       	ldi	r20, 0x03	; 3
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	9a d4       	rcall	.+2356   	; 0x1084 <xQueueGenericCreate>
     750:	90 93 ed 08 	sts	0x08ED, r25
     754:	80 93 ec 08 	sts	0x08EC, r24
     758:	08 95       	ret

0000075a <myTimer_Read>:
     75a:	86 b5       	in	r24, 0x26	; 38
     75c:	08 95       	ret

0000075e <myTimer_DelayMicro>:
     75e:	46 b5       	in	r20, 0x26	; 38
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	9c 01       	movw	r18, r24
     764:	99 23       	and	r25, r25
     766:	14 f4       	brge	.+4      	; 0x76c <myTimer_DelayMicro+0xe>
     768:	2d 5f       	subi	r18, 0xFD	; 253
     76a:	3f 4f       	sbci	r19, 0xFF	; 255
     76c:	35 95       	asr	r19
     76e:	27 95       	ror	r18
     770:	35 95       	asr	r19
     772:	27 95       	ror	r18
     774:	24 0f       	add	r18, r20
     776:	35 1f       	adc	r19, r21
     778:	30 93 03 02 	sts	0x0203, r19
     77c:	20 93 02 02 	sts	0x0202, r18
     780:	e0 91 ee 08 	lds	r30, 0x08EE
     784:	f0 91 ef 08 	lds	r31, 0x08EF
     788:	80 81       	ld	r24, Z
     78a:	91 81       	ldd	r25, Z+1	; 0x01
     78c:	f6 d7       	rcall	.+4076   	; 0x177a <vTaskResume>
     78e:	20 e0       	ldi	r18, 0x00	; 0
     790:	42 e0       	ldi	r20, 0x02	; 2
     792:	50 e0       	ldi	r21, 0x00	; 0
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	70 e0       	ldi	r23, 0x00	; 0
     798:	80 91 ea 08 	lds	r24, 0x08EA
     79c:	90 91 eb 08 	lds	r25, 0x08EB
     7a0:	90 c5       	rjmp	.+2848   	; 0x12c2 <xQueueGenericReceive>
     7a2:	08 95       	ret

000007a4 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7a8:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     7aa:	c1 11       	cpse	r28, r1
     7ac:	22 c0       	rjmp	.+68     	; 0x7f2 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     7ae:	80 91 02 02 	lds	r24, 0x0202
     7b2:	90 91 03 02 	lds	r25, 0x0203
     7b6:	88 38       	cpi	r24, 0x88	; 136
     7b8:	93 41       	sbci	r25, 0x13	; 19
     7ba:	51 f0       	breq	.+20     	; 0x7d0 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     7bc:	80 91 02 02 	lds	r24, 0x0202
     7c0:	90 91 03 02 	lds	r25, 0x0203
     7c4:	8a 5f       	subi	r24, 0xFA	; 250
     7c6:	91 09       	sbc	r25, r1
     7c8:	90 93 03 02 	sts	0x0203, r25
     7cc:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     7d0:	80 91 00 02 	lds	r24, 0x0200
     7d4:	90 91 01 02 	lds	r25, 0x0201
     7d8:	88 38       	cpi	r24, 0x88	; 136
     7da:	93 41       	sbci	r25, 0x13	; 19
     7dc:	51 f0       	breq	.+20     	; 0x7f2 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     7de:	80 91 00 02 	lds	r24, 0x0200
     7e2:	90 91 01 02 	lds	r25, 0x0201
     7e6:	8a 5f       	subi	r24, 0xFA	; 250
     7e8:	91 09       	sbc	r25, r1
     7ea:	90 93 01 02 	sts	0x0201, r25
     7ee:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     7f2:	d0 e0       	ldi	r29, 0x00	; 0
     7f4:	80 91 02 02 	lds	r24, 0x0202
     7f8:	90 91 03 02 	lds	r25, 0x0203
     7fc:	8c 17       	cp	r24, r28
     7fe:	9d 07       	cpc	r25, r29
     800:	84 f4       	brge	.+32     	; 0x822 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     802:	88 e8       	ldi	r24, 0x88	; 136
     804:	93 e1       	ldi	r25, 0x13	; 19
     806:	90 93 03 02 	sts	0x0203, r25
     80a:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	40 e0       	ldi	r20, 0x00	; 0
     812:	50 e0       	ldi	r21, 0x00	; 0
     814:	60 e0       	ldi	r22, 0x00	; 0
     816:	70 e0       	ldi	r23, 0x00	; 0
     818:	80 91 ea 08 	lds	r24, 0x08EA
     81c:	90 91 eb 08 	lds	r25, 0x08EB
     820:	5b d4       	rcall	.+2230   	; 0x10d8 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     822:	80 91 00 02 	lds	r24, 0x0200
     826:	90 91 01 02 	lds	r25, 0x0201
     82a:	8c 17       	cp	r24, r28
     82c:	9d 07       	cpc	r25, r29
     82e:	84 f4       	brge	.+32     	; 0x850 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     830:	88 e8       	ldi	r24, 0x88	; 136
     832:	93 e1       	ldi	r25, 0x13	; 19
     834:	90 93 01 02 	sts	0x0201, r25
     838:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     83c:	20 e0       	ldi	r18, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	60 e0       	ldi	r22, 0x00	; 0
     844:	70 e0       	ldi	r23, 0x00	; 0
     846:	80 91 ec 08 	lds	r24, 0x08EC
     84a:	90 91 ed 08 	lds	r25, 0x08ED
     84e:	44 d4       	rcall	.+2184   	; 0x10d8 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     850:	80 91 02 02 	lds	r24, 0x0202
     854:	90 91 03 02 	lds	r25, 0x0203
     858:	88 38       	cpi	r24, 0x88	; 136
     85a:	93 41       	sbci	r25, 0x13	; 19
     85c:	79 f4       	brne	.+30     	; 0x87c <myTimer_DelayChecker+0xd8>
     85e:	80 91 00 02 	lds	r24, 0x0200
     862:	90 91 01 02 	lds	r25, 0x0201
     866:	88 38       	cpi	r24, 0x88	; 136
     868:	93 41       	sbci	r25, 0x13	; 19
     86a:	41 f4       	brne	.+16     	; 0x87c <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     86c:	e0 91 ee 08 	lds	r30, 0x08EE
     870:	f0 91 ef 08 	lds	r31, 0x08EF
     874:	80 81       	ld	r24, Z
     876:	91 81       	ldd	r25, Z+1	; 0x01
     878:	0e 94 76 0e 	call	0x1cec	; 0x1cec <vTaskSuspend>
	}
     87c:	df 91       	pop	r29
     87e:	cf 91       	pop	r28
     880:	08 95       	ret

00000882 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     882:	1f 92       	push	r1
     884:	0f 92       	push	r0
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	0f 92       	push	r0
     88a:	11 24       	eor	r1, r1
     88c:	0b b6       	in	r0, 0x3b	; 59
     88e:	0f 92       	push	r0
     890:	2f 93       	push	r18
     892:	3f 93       	push	r19
     894:	4f 93       	push	r20
     896:	5f 93       	push	r21
     898:	6f 93       	push	r22
     89a:	7f 93       	push	r23
     89c:	8f 93       	push	r24
     89e:	9f 93       	push	r25
     8a0:	af 93       	push	r26
     8a2:	bf 93       	push	r27
     8a4:	ef 93       	push	r30
     8a6:	ff 93       	push	r31
     8a8:	60 91 ce 00 	lds	r22, 0x00CE
     8ac:	83 e8       	ldi	r24, 0x83	; 131
     8ae:	99 e0       	ldi	r25, 0x09	; 9
     8b0:	d4 d5       	rcall	.+2984   	; 0x145a <ringBufferPush>
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	40 e0       	ldi	r20, 0x00	; 0
     8b6:	50 e0       	ldi	r21, 0x00	; 0
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	70 e0       	ldi	r23, 0x00	; 0
     8bc:	80 91 77 09 	lds	r24, 0x0977
     8c0:	90 91 78 09 	lds	r25, 0x0978
     8c4:	c4 d4       	rcall	.+2440   	; 0x124e <xQueueGenericSendFromISR>
     8c6:	83 e8       	ldi	r24, 0x83	; 131
     8c8:	99 e0       	ldi	r25, 0x09	; 9
     8ca:	dd d5       	rcall	.+3002   	; 0x1486 <ringBufferFull>
     8cc:	ff 91       	pop	r31
     8ce:	ef 91       	pop	r30
     8d0:	bf 91       	pop	r27
     8d2:	af 91       	pop	r26
     8d4:	9f 91       	pop	r25
     8d6:	8f 91       	pop	r24
     8d8:	7f 91       	pop	r23
     8da:	6f 91       	pop	r22
     8dc:	5f 91       	pop	r21
     8de:	4f 91       	pop	r20
     8e0:	3f 91       	pop	r19
     8e2:	2f 91       	pop	r18
     8e4:	0f 90       	pop	r0
     8e6:	0b be       	out	0x3b, r0	; 59
     8e8:	0f 90       	pop	r0
     8ea:	0f be       	out	0x3f, r0	; 63
     8ec:	0f 90       	pop	r0
     8ee:	1f 90       	pop	r1
     8f0:	18 95       	reti

000008f2 <__vector_25>:
     8f2:	1f 92       	push	r1
     8f4:	0f 92       	push	r0
     8f6:	0f b6       	in	r0, 0x3f	; 63
     8f8:	0f 92       	push	r0
     8fa:	11 24       	eor	r1, r1
     8fc:	0b b6       	in	r0, 0x3b	; 59
     8fe:	0f 92       	push	r0
     900:	2f 93       	push	r18
     902:	3f 93       	push	r19
     904:	4f 93       	push	r20
     906:	5f 93       	push	r21
     908:	6f 93       	push	r22
     90a:	7f 93       	push	r23
     90c:	8f 93       	push	r24
     90e:	9f 93       	push	r25
     910:	af 93       	push	r26
     912:	bf 93       	push	r27
     914:	ef 93       	push	r30
     916:	ff 93       	push	r31
     918:	60 91 c6 00 	lds	r22, 0x00C6
     91c:	80 e1       	ldi	r24, 0x10	; 16
     91e:	99 e0       	ldi	r25, 0x09	; 9
     920:	9c d5       	rcall	.+2872   	; 0x145a <ringBufferPush>
     922:	20 e0       	ldi	r18, 0x00	; 0
     924:	40 e0       	ldi	r20, 0x00	; 0
     926:	50 e0       	ldi	r21, 0x00	; 0
     928:	60 e0       	ldi	r22, 0x00	; 0
     92a:	70 e0       	ldi	r23, 0x00	; 0
     92c:	80 91 77 09 	lds	r24, 0x0977
     930:	90 91 78 09 	lds	r25, 0x0978
     934:	8c d4       	rcall	.+2328   	; 0x124e <xQueueGenericSendFromISR>
     936:	80 e1       	ldi	r24, 0x10	; 16
     938:	99 e0       	ldi	r25, 0x09	; 9
     93a:	a5 d5       	rcall	.+2890   	; 0x1486 <ringBufferFull>
     93c:	ff 91       	pop	r31
     93e:	ef 91       	pop	r30
     940:	bf 91       	pop	r27
     942:	af 91       	pop	r26
     944:	9f 91       	pop	r25
     946:	8f 91       	pop	r24
     948:	7f 91       	pop	r23
     94a:	6f 91       	pop	r22
     94c:	5f 91       	pop	r21
     94e:	4f 91       	pop	r20
     950:	3f 91       	pop	r19
     952:	2f 91       	pop	r18
     954:	0f 90       	pop	r0
     956:	0b be       	out	0x3b, r0	; 59
     958:	0f 90       	pop	r0
     95a:	0f be       	out	0x3f, r0	; 63
     95c:	0f 90       	pop	r0
     95e:	1f 90       	pop	r1
     960:	18 95       	reti

00000962 <__vector_37>:
     962:	1f 92       	push	r1
     964:	0f 92       	push	r0
     966:	0f b6       	in	r0, 0x3f	; 63
     968:	0f 92       	push	r0
     96a:	11 24       	eor	r1, r1
     96c:	0b b6       	in	r0, 0x3b	; 59
     96e:	0f 92       	push	r0
     970:	2f 93       	push	r18
     972:	3f 93       	push	r19
     974:	4f 93       	push	r20
     976:	5f 93       	push	r21
     978:	6f 93       	push	r22
     97a:	7f 93       	push	r23
     97c:	8f 93       	push	r24
     97e:	9f 93       	push	r25
     980:	af 93       	push	r26
     982:	bf 93       	push	r27
     984:	ef 93       	push	r30
     986:	ff 93       	push	r31
     988:	89 e7       	ldi	r24, 0x79	; 121
     98a:	99 e0       	ldi	r25, 0x09	; 9
     98c:	83 d5       	rcall	.+2822   	; 0x1494 <ringBufferNotEmpty>
     98e:	88 23       	and	r24, r24
     990:	31 f0       	breq	.+12     	; 0x99e <__vector_37+0x3c>
     992:	89 e7       	ldi	r24, 0x79	; 121
     994:	99 e0       	ldi	r25, 0x09	; 9
     996:	4f d5       	rcall	.+2718   	; 0x1436 <ringBufferPop>
     998:	80 93 ce 00 	sts	0x00CE, r24
     99c:	05 c0       	rjmp	.+10     	; 0x9a8 <__vector_37+0x46>
     99e:	e9 ec       	ldi	r30, 0xC9	; 201
     9a0:	f0 e0       	ldi	r31, 0x00	; 0
     9a2:	80 81       	ld	r24, Z
     9a4:	8f 7d       	andi	r24, 0xDF	; 223
     9a6:	80 83       	st	Z, r24
     9a8:	ff 91       	pop	r31
     9aa:	ef 91       	pop	r30
     9ac:	bf 91       	pop	r27
     9ae:	af 91       	pop	r26
     9b0:	9f 91       	pop	r25
     9b2:	8f 91       	pop	r24
     9b4:	7f 91       	pop	r23
     9b6:	6f 91       	pop	r22
     9b8:	5f 91       	pop	r21
     9ba:	4f 91       	pop	r20
     9bc:	3f 91       	pop	r19
     9be:	2f 91       	pop	r18
     9c0:	0f 90       	pop	r0
     9c2:	0b be       	out	0x3b, r0	; 59
     9c4:	0f 90       	pop	r0
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	0f 90       	pop	r0
     9ca:	1f 90       	pop	r1
     9cc:	18 95       	reti

000009ce <__vector_26>:
     9ce:	1f 92       	push	r1
     9d0:	0f 92       	push	r0
     9d2:	0f b6       	in	r0, 0x3f	; 63
     9d4:	0f 92       	push	r0
     9d6:	11 24       	eor	r1, r1
     9d8:	0b b6       	in	r0, 0x3b	; 59
     9da:	0f 92       	push	r0
     9dc:	2f 93       	push	r18
     9de:	3f 93       	push	r19
     9e0:	4f 93       	push	r20
     9e2:	5f 93       	push	r21
     9e4:	6f 93       	push	r22
     9e6:	7f 93       	push	r23
     9e8:	8f 93       	push	r24
     9ea:	9f 93       	push	r25
     9ec:	af 93       	push	r26
     9ee:	bf 93       	push	r27
     9f0:	ef 93       	push	r30
     9f2:	ff 93       	push	r31
     9f4:	8e e7       	ldi	r24, 0x7E	; 126
     9f6:	99 e0       	ldi	r25, 0x09	; 9
     9f8:	4d d5       	rcall	.+2714   	; 0x1494 <ringBufferNotEmpty>
     9fa:	88 23       	and	r24, r24
     9fc:	31 f0       	breq	.+12     	; 0xa0a <__vector_26+0x3c>
     9fe:	8e e7       	ldi	r24, 0x7E	; 126
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	19 d5       	rcall	.+2610   	; 0x1436 <ringBufferPop>
     a04:	80 93 c6 00 	sts	0x00C6, r24
     a08:	05 c0       	rjmp	.+10     	; 0xa14 <__vector_26+0x46>
     a0a:	e1 ec       	ldi	r30, 0xC1	; 193
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	80 81       	ld	r24, Z
     a10:	8f 7d       	andi	r24, 0xDF	; 223
     a12:	80 83       	st	Z, r24
     a14:	ff 91       	pop	r31
     a16:	ef 91       	pop	r30
     a18:	bf 91       	pop	r27
     a1a:	af 91       	pop	r26
     a1c:	9f 91       	pop	r25
     a1e:	8f 91       	pop	r24
     a20:	7f 91       	pop	r23
     a22:	6f 91       	pop	r22
     a24:	5f 91       	pop	r21
     a26:	4f 91       	pop	r20
     a28:	3f 91       	pop	r19
     a2a:	2f 91       	pop	r18
     a2c:	0f 90       	pop	r0
     a2e:	0b be       	out	0x3b, r0	; 59
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	0f 90       	pop	r0
     a36:	1f 90       	pop	r1
     a38:	18 95       	reti

00000a3a <myUSART_USART0_Init>:
     a3a:	10 92 c5 00 	sts	0x00C5, r1
     a3e:	87 e6       	ldi	r24, 0x67	; 103
     a40:	80 93 c4 00 	sts	0x00C4, r24
     a44:	88 eb       	ldi	r24, 0xB8	; 184
     a46:	80 93 c1 00 	sts	0x00C1, r24
     a4a:	86 e0       	ldi	r24, 0x06	; 6
     a4c:	80 93 c2 00 	sts	0x00C2, r24
     a50:	40 e2       	ldi	r20, 0x20	; 32
     a52:	65 e3       	ldi	r22, 0x35	; 53
     a54:	79 e0       	ldi	r23, 0x09	; 9
     a56:	80 e1       	ldi	r24, 0x10	; 16
     a58:	99 e0       	ldi	r25, 0x09	; 9
     a5a:	e6 d4       	rcall	.+2508   	; 0x1428 <ringBufferInit>
     a5c:	40 e2       	ldi	r20, 0x20	; 32
     a5e:	65 e1       	ldi	r22, 0x15	; 21
     a60:	79 e0       	ldi	r23, 0x09	; 9
     a62:	8e e7       	ldi	r24, 0x7E	; 126
     a64:	99 e0       	ldi	r25, 0x09	; 9
     a66:	e0 d4       	rcall	.+2496   	; 0x1428 <ringBufferInit>
     a68:	43 e0       	ldi	r20, 0x03	; 3
     a6a:	60 e0       	ldi	r22, 0x00	; 0
     a6c:	81 e0       	ldi	r24, 0x01	; 1
     a6e:	0a d3       	rcall	.+1556   	; 0x1084 <xQueueGenericCreate>
     a70:	90 93 76 09 	sts	0x0976, r25
     a74:	80 93 75 09 	sts	0x0975, r24
     a78:	08 95       	ret

00000a7a <myUSART_USART1_Init>:
     a7a:	10 92 cd 00 	sts	0x00CD, r1
     a7e:	87 e6       	ldi	r24, 0x67	; 103
     a80:	80 93 cc 00 	sts	0x00CC, r24
     a84:	88 eb       	ldi	r24, 0xB8	; 184
     a86:	80 93 c9 00 	sts	0x00C9, r24
     a8a:	86 e0       	ldi	r24, 0x06	; 6
     a8c:	80 93 ca 00 	sts	0x00CA, r24
     a90:	40 e2       	ldi	r20, 0x20	; 32
     a92:	60 ef       	ldi	r22, 0xF0	; 240
     a94:	78 e0       	ldi	r23, 0x08	; 8
     a96:	83 e8       	ldi	r24, 0x83	; 131
     a98:	99 e0       	ldi	r25, 0x09	; 9
     a9a:	c6 d4       	rcall	.+2444   	; 0x1428 <ringBufferInit>
     a9c:	40 e2       	ldi	r20, 0x20	; 32
     a9e:	65 e5       	ldi	r22, 0x55	; 85
     aa0:	79 e0       	ldi	r23, 0x09	; 9
     aa2:	89 e7       	ldi	r24, 0x79	; 121
     aa4:	99 e0       	ldi	r25, 0x09	; 9
     aa6:	c0 d4       	rcall	.+2432   	; 0x1428 <ringBufferInit>
     aa8:	43 e0       	ldi	r20, 0x03	; 3
     aaa:	60 e0       	ldi	r22, 0x00	; 0
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	ea d2       	rcall	.+1492   	; 0x1084 <xQueueGenericCreate>
     ab0:	90 93 78 09 	sts	0x0978, r25
     ab4:	80 93 77 09 	sts	0x0977, r24
     ab8:	08 95       	ret

00000aba <myUSART_transmitUSART0_c>:
     aba:	cf 93       	push	r28
     abc:	c8 2f       	mov	r28, r24
     abe:	8e e7       	ldi	r24, 0x7E	; 126
     ac0:	99 e0       	ldi	r25, 0x09	; 9
     ac2:	e1 d4       	rcall	.+2498   	; 0x1486 <ringBufferFull>
     ac4:	81 11       	cpse	r24, r1
     ac6:	fb cf       	rjmp	.-10     	; 0xabe <myUSART_transmitUSART0_c+0x4>
     ac8:	6c 2f       	mov	r22, r28
     aca:	8e e7       	ldi	r24, 0x7E	; 126
     acc:	99 e0       	ldi	r25, 0x09	; 9
     ace:	c5 d4       	rcall	.+2442   	; 0x145a <ringBufferPush>
     ad0:	e1 ec       	ldi	r30, 0xC1	; 193
     ad2:	f0 e0       	ldi	r31, 0x00	; 0
     ad4:	80 81       	ld	r24, Z
     ad6:	80 62       	ori	r24, 0x20	; 32
     ad8:	80 83       	st	Z, r24
     ada:	e0 ec       	ldi	r30, 0xC0	; 192
     adc:	f0 e0       	ldi	r31, 0x00	; 0
     ade:	80 81       	ld	r24, Z
     ae0:	80 64       	ori	r24, 0x40	; 64
     ae2:	80 83       	st	Z, r24
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <myUSART_transmitUSART1_c>:
     ae8:	cf 93       	push	r28
     aea:	c8 2f       	mov	r28, r24
     aec:	89 e7       	ldi	r24, 0x79	; 121
     aee:	99 e0       	ldi	r25, 0x09	; 9
     af0:	ca d4       	rcall	.+2452   	; 0x1486 <ringBufferFull>
     af2:	81 11       	cpse	r24, r1
     af4:	fb cf       	rjmp	.-10     	; 0xaec <myUSART_transmitUSART1_c+0x4>
     af6:	6c 2f       	mov	r22, r28
     af8:	89 e7       	ldi	r24, 0x79	; 121
     afa:	99 e0       	ldi	r25, 0x09	; 9
     afc:	ae d4       	rcall	.+2396   	; 0x145a <ringBufferPush>
     afe:	e9 ec       	ldi	r30, 0xC9	; 201
     b00:	f0 e0       	ldi	r31, 0x00	; 0
     b02:	80 81       	ld	r24, Z
     b04:	80 62       	ori	r24, 0x20	; 32
     b06:	80 83       	st	Z, r24
     b08:	e8 ec       	ldi	r30, 0xC8	; 200
     b0a:	f0 e0       	ldi	r31, 0x00	; 0
     b0c:	80 81       	ld	r24, Z
     b0e:	80 64       	ori	r24, 0x40	; 64
     b10:	80 83       	st	Z, r24
     b12:	cf 91       	pop	r28
     b14:	08 95       	ret

00000b16 <myUSART_transmitUSART0>:
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	ec 01       	movw	r28, r24
     b1c:	88 81       	ld	r24, Y
     b1e:	88 23       	and	r24, r24
     b20:	29 f0       	breq	.+10     	; 0xb2c <myUSART_transmitUSART0+0x16>
     b22:	21 96       	adiw	r28, 0x01	; 1
     b24:	ca df       	rcall	.-108    	; 0xaba <myUSART_transmitUSART0_c>
     b26:	89 91       	ld	r24, Y+
     b28:	81 11       	cpse	r24, r1
     b2a:	fc cf       	rjmp	.-8      	; 0xb24 <myUSART_transmitUSART0+0xe>
     b2c:	df 91       	pop	r29
     b2e:	cf 91       	pop	r28
     b30:	08 95       	ret

00000b32 <myUSART_receiveUSART1>:
     b32:	cf 93       	push	r28
     b34:	20 e0       	ldi	r18, 0x00	; 0
     b36:	4f ef       	ldi	r20, 0xFF	; 255
     b38:	5f ef       	ldi	r21, 0xFF	; 255
     b3a:	60 e0       	ldi	r22, 0x00	; 0
     b3c:	70 e0       	ldi	r23, 0x00	; 0
     b3e:	80 91 75 09 	lds	r24, 0x0975
     b42:	90 91 76 09 	lds	r25, 0x0976
     b46:	bd d3       	rcall	.+1914   	; 0x12c2 <xQueueGenericReceive>
     b48:	83 e8       	ldi	r24, 0x83	; 131
     b4a:	99 e0       	ldi	r25, 0x09	; 9
     b4c:	74 d4       	rcall	.+2280   	; 0x1436 <ringBufferPop>
     b4e:	c8 2f       	mov	r28, r24
     b50:	83 e8       	ldi	r24, 0x83	; 131
     b52:	99 e0       	ldi	r25, 0x09	; 9
     b54:	9f d4       	rcall	.+2366   	; 0x1494 <ringBufferNotEmpty>
     b56:	88 23       	and	r24, r24
     b58:	51 f0       	breq	.+20     	; 0xb6e <myUSART_receiveUSART1+0x3c>
     b5a:	20 e0       	ldi	r18, 0x00	; 0
     b5c:	40 e0       	ldi	r20, 0x00	; 0
     b5e:	50 e0       	ldi	r21, 0x00	; 0
     b60:	60 e0       	ldi	r22, 0x00	; 0
     b62:	70 e0       	ldi	r23, 0x00	; 0
     b64:	80 91 75 09 	lds	r24, 0x0975
     b68:	90 91 76 09 	lds	r25, 0x0976
     b6c:	b5 d2       	rcall	.+1386   	; 0x10d8 <xQueueGenericSend>
     b6e:	8c 2f       	mov	r24, r28
     b70:	cf 91       	pop	r28
     b72:	08 95       	ret

00000b74 <myUSART_startHandShake>:

// -1 if fail, 0 success
char myUSART_startHandShake()
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
     b74:	80 e0       	ldi	r24, 0x00	; 0
     b76:	b8 df       	rcall	.-144    	; 0xae8 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
     b78:	dc df       	rcall	.-72     	; 0xb32 <myUSART_receiveUSART1>
     b7a:	85 35       	cpi	r24, 0x55	; 85
     b7c:	21 f4       	brne	.+8      	; 0xb86 <myUSART_startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	b3 df       	rcall	.-154    	; 0xae8 <myUSART_transmitUSART1_c>
	
	return 0;
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	08 95       	ret
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
	{
		return -1; //error handling
     b86:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     b88:	08 95       	ret

00000b8a <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     b8a:	d3 df       	rcall	.-90     	; 0xb32 <myUSART_receiveUSART1>
     b8c:	81 11       	cpse	r24, r1
     b8e:	0a c0       	rjmp	.+20     	; 0xba4 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     b90:	85 e5       	ldi	r24, 0x55	; 85
     b92:	aa df       	rcall	.-172    	; 0xae8 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     b94:	ce df       	rcall	.-100    	; 0xb32 <myUSART_receiveUSART1>
     b96:	91 e0       	ldi	r25, 0x01	; 1
     b98:	81 11       	cpse	r24, r1
     b9a:	01 c0       	rjmp	.+2      	; 0xb9e <myUSART_waitForHandshake+0x14>
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	89 2f       	mov	r24, r25
     ba0:	81 95       	neg	r24
     ba2:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     ba4:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     ba6:	08 95       	ret

00000ba8 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ba8:	31 e1       	ldi	r19, 0x11	; 17
     baa:	fc 01       	movw	r30, r24
     bac:	30 83       	st	Z, r19
     bae:	31 97       	sbiw	r30, 0x01	; 1
     bb0:	22 e2       	ldi	r18, 0x22	; 34
     bb2:	20 83       	st	Z, r18
     bb4:	31 97       	sbiw	r30, 0x01	; 1
     bb6:	a3 e3       	ldi	r26, 0x33	; 51
     bb8:	a0 83       	st	Z, r26
     bba:	31 97       	sbiw	r30, 0x01	; 1
     bbc:	60 83       	st	Z, r22
     bbe:	31 97       	sbiw	r30, 0x01	; 1
     bc0:	70 83       	st	Z, r23
     bc2:	31 97       	sbiw	r30, 0x01	; 1
     bc4:	10 82       	st	Z, r1
     bc6:	31 97       	sbiw	r30, 0x01	; 1
     bc8:	10 82       	st	Z, r1
     bca:	31 97       	sbiw	r30, 0x01	; 1
     bcc:	60 e8       	ldi	r22, 0x80	; 128
     bce:	60 83       	st	Z, r22
     bd0:	31 97       	sbiw	r30, 0x01	; 1
     bd2:	10 82       	st	Z, r1
     bd4:	31 97       	sbiw	r30, 0x01	; 1
     bd6:	10 82       	st	Z, r1
     bd8:	31 97       	sbiw	r30, 0x01	; 1
     bda:	10 82       	st	Z, r1
     bdc:	31 97       	sbiw	r30, 0x01	; 1
     bde:	62 e0       	ldi	r22, 0x02	; 2
     be0:	60 83       	st	Z, r22
     be2:	31 97       	sbiw	r30, 0x01	; 1
     be4:	63 e0       	ldi	r22, 0x03	; 3
     be6:	60 83       	st	Z, r22
     be8:	31 97       	sbiw	r30, 0x01	; 1
     bea:	64 e0       	ldi	r22, 0x04	; 4
     bec:	60 83       	st	Z, r22
     bee:	31 97       	sbiw	r30, 0x01	; 1
     bf0:	65 e0       	ldi	r22, 0x05	; 5
     bf2:	60 83       	st	Z, r22
     bf4:	31 97       	sbiw	r30, 0x01	; 1
     bf6:	66 e0       	ldi	r22, 0x06	; 6
     bf8:	60 83       	st	Z, r22
     bfa:	31 97       	sbiw	r30, 0x01	; 1
     bfc:	67 e0       	ldi	r22, 0x07	; 7
     bfe:	60 83       	st	Z, r22
     c00:	31 97       	sbiw	r30, 0x01	; 1
     c02:	68 e0       	ldi	r22, 0x08	; 8
     c04:	60 83       	st	Z, r22
     c06:	31 97       	sbiw	r30, 0x01	; 1
     c08:	69 e0       	ldi	r22, 0x09	; 9
     c0a:	60 83       	st	Z, r22
     c0c:	31 97       	sbiw	r30, 0x01	; 1
     c0e:	60 e1       	ldi	r22, 0x10	; 16
     c10:	60 83       	st	Z, r22
     c12:	31 97       	sbiw	r30, 0x01	; 1
     c14:	30 83       	st	Z, r19
     c16:	31 97       	sbiw	r30, 0x01	; 1
     c18:	32 e1       	ldi	r19, 0x12	; 18
     c1a:	30 83       	st	Z, r19
     c1c:	31 97       	sbiw	r30, 0x01	; 1
     c1e:	33 e1       	ldi	r19, 0x13	; 19
     c20:	30 83       	st	Z, r19
     c22:	31 97       	sbiw	r30, 0x01	; 1
     c24:	34 e1       	ldi	r19, 0x14	; 20
     c26:	30 83       	st	Z, r19
     c28:	31 97       	sbiw	r30, 0x01	; 1
     c2a:	35 e1       	ldi	r19, 0x15	; 21
     c2c:	30 83       	st	Z, r19
     c2e:	31 97       	sbiw	r30, 0x01	; 1
     c30:	36 e1       	ldi	r19, 0x16	; 22
     c32:	30 83       	st	Z, r19
     c34:	31 97       	sbiw	r30, 0x01	; 1
     c36:	37 e1       	ldi	r19, 0x17	; 23
     c38:	30 83       	st	Z, r19
     c3a:	31 97       	sbiw	r30, 0x01	; 1
     c3c:	38 e1       	ldi	r19, 0x18	; 24
     c3e:	30 83       	st	Z, r19
     c40:	31 97       	sbiw	r30, 0x01	; 1
     c42:	39 e1       	ldi	r19, 0x19	; 25
     c44:	30 83       	st	Z, r19
     c46:	31 97       	sbiw	r30, 0x01	; 1
     c48:	30 e2       	ldi	r19, 0x20	; 32
     c4a:	30 83       	st	Z, r19
     c4c:	31 97       	sbiw	r30, 0x01	; 1
     c4e:	31 e2       	ldi	r19, 0x21	; 33
     c50:	30 83       	st	Z, r19
     c52:	31 97       	sbiw	r30, 0x01	; 1
     c54:	20 83       	st	Z, r18
     c56:	31 97       	sbiw	r30, 0x01	; 1
     c58:	23 e2       	ldi	r18, 0x23	; 35
     c5a:	20 83       	st	Z, r18
     c5c:	31 97       	sbiw	r30, 0x01	; 1
     c5e:	40 83       	st	Z, r20
     c60:	31 97       	sbiw	r30, 0x01	; 1
     c62:	50 83       	st	Z, r21
     c64:	31 97       	sbiw	r30, 0x01	; 1
     c66:	26 e2       	ldi	r18, 0x26	; 38
     c68:	20 83       	st	Z, r18
     c6a:	31 97       	sbiw	r30, 0x01	; 1
     c6c:	27 e2       	ldi	r18, 0x27	; 39
     c6e:	20 83       	st	Z, r18
     c70:	31 97       	sbiw	r30, 0x01	; 1
     c72:	28 e2       	ldi	r18, 0x28	; 40
     c74:	20 83       	st	Z, r18
     c76:	31 97       	sbiw	r30, 0x01	; 1
     c78:	29 e2       	ldi	r18, 0x29	; 41
     c7a:	20 83       	st	Z, r18
     c7c:	31 97       	sbiw	r30, 0x01	; 1
     c7e:	20 e3       	ldi	r18, 0x30	; 48
     c80:	20 83       	st	Z, r18
     c82:	31 97       	sbiw	r30, 0x01	; 1
     c84:	21 e3       	ldi	r18, 0x31	; 49
     c86:	20 83       	st	Z, r18
     c88:	89 97       	sbiw	r24, 0x29	; 41
     c8a:	08 95       	ret

00000c8c <xPortStartScheduler>:
     c8c:	82 e0       	ldi	r24, 0x02	; 2
     c8e:	84 bd       	out	0x24, r24	; 36
     c90:	16 bc       	out	0x26, r1	; 38
     c92:	80 e3       	ldi	r24, 0x30	; 48
     c94:	87 bd       	out	0x27, r24	; 39
     c96:	ee e6       	ldi	r30, 0x6E	; 110
     c98:	f0 e0       	ldi	r31, 0x00	; 0
     c9a:	80 81       	ld	r24, Z
     c9c:	82 60       	ori	r24, 0x02	; 2
     c9e:	80 83       	st	Z, r24
     ca0:	83 e0       	ldi	r24, 0x03	; 3
     ca2:	85 bd       	out	0x25, r24	; 37
     ca4:	a0 91 d7 08 	lds	r26, 0x08D7
     ca8:	b0 91 d8 08 	lds	r27, 0x08D8
     cac:	cd 91       	ld	r28, X+
     cae:	cd bf       	out	0x3d, r28	; 61
     cb0:	dd 91       	ld	r29, X+
     cb2:	de bf       	out	0x3e, r29	; 62
     cb4:	ff 91       	pop	r31
     cb6:	ef 91       	pop	r30
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	bf 91       	pop	r27
     cbe:	af 91       	pop	r26
     cc0:	9f 91       	pop	r25
     cc2:	8f 91       	pop	r24
     cc4:	7f 91       	pop	r23
     cc6:	6f 91       	pop	r22
     cc8:	5f 91       	pop	r21
     cca:	4f 91       	pop	r20
     ccc:	3f 91       	pop	r19
     cce:	2f 91       	pop	r18
     cd0:	1f 91       	pop	r17
     cd2:	0f 91       	pop	r16
     cd4:	ff 90       	pop	r15
     cd6:	ef 90       	pop	r14
     cd8:	df 90       	pop	r13
     cda:	cf 90       	pop	r12
     cdc:	bf 90       	pop	r11
     cde:	af 90       	pop	r10
     ce0:	9f 90       	pop	r9
     ce2:	8f 90       	pop	r8
     ce4:	7f 90       	pop	r7
     ce6:	6f 90       	pop	r6
     ce8:	5f 90       	pop	r5
     cea:	4f 90       	pop	r4
     cec:	3f 90       	pop	r3
     cee:	2f 90       	pop	r2
     cf0:	1f 90       	pop	r1
     cf2:	0f 90       	pop	r0
     cf4:	0c be       	out	0x3c, r0	; 60
     cf6:	0f 90       	pop	r0
     cf8:	0b be       	out	0x3b, r0	; 59
     cfa:	0f 90       	pop	r0
     cfc:	0f be       	out	0x3f, r0	; 63
     cfe:	0f 90       	pop	r0
     d00:	08 95       	ret
     d02:	81 e0       	ldi	r24, 0x01	; 1
     d04:	08 95       	ret

00000d06 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d06:	0f 92       	push	r0
     d08:	0f b6       	in	r0, 0x3f	; 63
     d0a:	f8 94       	cli
     d0c:	0f 92       	push	r0
     d0e:	0b b6       	in	r0, 0x3b	; 59
     d10:	0f 92       	push	r0
     d12:	0c b6       	in	r0, 0x3c	; 60
     d14:	0f 92       	push	r0
     d16:	1f 92       	push	r1
     d18:	11 24       	eor	r1, r1
     d1a:	2f 92       	push	r2
     d1c:	3f 92       	push	r3
     d1e:	4f 92       	push	r4
     d20:	5f 92       	push	r5
     d22:	6f 92       	push	r6
     d24:	7f 92       	push	r7
     d26:	8f 92       	push	r8
     d28:	9f 92       	push	r9
     d2a:	af 92       	push	r10
     d2c:	bf 92       	push	r11
     d2e:	cf 92       	push	r12
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	2f 93       	push	r18
     d3c:	3f 93       	push	r19
     d3e:	4f 93       	push	r20
     d40:	5f 93       	push	r21
     d42:	6f 93       	push	r22
     d44:	7f 93       	push	r23
     d46:	8f 93       	push	r24
     d48:	9f 93       	push	r25
     d4a:	af 93       	push	r26
     d4c:	bf 93       	push	r27
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	ef 93       	push	r30
     d54:	ff 93       	push	r31
     d56:	a0 91 d7 08 	lds	r26, 0x08D7
     d5a:	b0 91 d8 08 	lds	r27, 0x08D8
     d5e:	0d b6       	in	r0, 0x3d	; 61
     d60:	0d 92       	st	X+, r0
     d62:	0e b6       	in	r0, 0x3e	; 62
     d64:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d66:	64 d7       	rcall	.+3784   	; 0x1c30 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d68:	a0 91 d7 08 	lds	r26, 0x08D7
     d6c:	b0 91 d8 08 	lds	r27, 0x08D8
     d70:	cd 91       	ld	r28, X+
     d72:	cd bf       	out	0x3d, r28	; 61
     d74:	dd 91       	ld	r29, X+
     d76:	de bf       	out	0x3e, r29	; 62
     d78:	ff 91       	pop	r31
     d7a:	ef 91       	pop	r30
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	bf 91       	pop	r27
     d82:	af 91       	pop	r26
     d84:	9f 91       	pop	r25
     d86:	8f 91       	pop	r24
     d88:	7f 91       	pop	r23
     d8a:	6f 91       	pop	r22
     d8c:	5f 91       	pop	r21
     d8e:	4f 91       	pop	r20
     d90:	3f 91       	pop	r19
     d92:	2f 91       	pop	r18
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	ff 90       	pop	r15
     d9a:	ef 90       	pop	r14
     d9c:	df 90       	pop	r13
     d9e:	cf 90       	pop	r12
     da0:	bf 90       	pop	r11
     da2:	af 90       	pop	r10
     da4:	9f 90       	pop	r9
     da6:	8f 90       	pop	r8
     da8:	7f 90       	pop	r7
     daa:	6f 90       	pop	r6
     dac:	5f 90       	pop	r5
     dae:	4f 90       	pop	r4
     db0:	3f 90       	pop	r3
     db2:	2f 90       	pop	r2
     db4:	1f 90       	pop	r1
     db6:	0f 90       	pop	r0
     db8:	0c be       	out	0x3c, r0	; 60
     dba:	0f 90       	pop	r0
     dbc:	0b be       	out	0x3b, r0	; 59
     dbe:	0f 90       	pop	r0
     dc0:	0f be       	out	0x3f, r0	; 63
     dc2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dc4:	08 95       	ret

00000dc6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     dc6:	0f 92       	push	r0
     dc8:	0f b6       	in	r0, 0x3f	; 63
     dca:	f8 94       	cli
     dcc:	0f 92       	push	r0
     dce:	0b b6       	in	r0, 0x3b	; 59
     dd0:	0f 92       	push	r0
     dd2:	0c b6       	in	r0, 0x3c	; 60
     dd4:	0f 92       	push	r0
     dd6:	1f 92       	push	r1
     dd8:	11 24       	eor	r1, r1
     dda:	2f 92       	push	r2
     ddc:	3f 92       	push	r3
     dde:	4f 92       	push	r4
     de0:	5f 92       	push	r5
     de2:	6f 92       	push	r6
     de4:	7f 92       	push	r7
     de6:	8f 92       	push	r8
     de8:	9f 92       	push	r9
     dea:	af 92       	push	r10
     dec:	bf 92       	push	r11
     dee:	cf 92       	push	r12
     df0:	df 92       	push	r13
     df2:	ef 92       	push	r14
     df4:	ff 92       	push	r15
     df6:	0f 93       	push	r16
     df8:	1f 93       	push	r17
     dfa:	2f 93       	push	r18
     dfc:	3f 93       	push	r19
     dfe:	4f 93       	push	r20
     e00:	5f 93       	push	r21
     e02:	6f 93       	push	r22
     e04:	7f 93       	push	r23
     e06:	8f 93       	push	r24
     e08:	9f 93       	push	r25
     e0a:	af 93       	push	r26
     e0c:	bf 93       	push	r27
     e0e:	cf 93       	push	r28
     e10:	df 93       	push	r29
     e12:	ef 93       	push	r30
     e14:	ff 93       	push	r31
     e16:	a0 91 d7 08 	lds	r26, 0x08D7
     e1a:	b0 91 d8 08 	lds	r27, 0x08D8
     e1e:	0d b6       	in	r0, 0x3d	; 61
     e20:	0d 92       	st	X+, r0
     e22:	0e b6       	in	r0, 0x3e	; 62
     e24:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     e26:	32 d5       	rcall	.+2660   	; 0x188c <xTaskIncrementTick>
     e28:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     e2a:	02 d7       	rcall	.+3588   	; 0x1c30 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     e2c:	a0 91 d7 08 	lds	r26, 0x08D7
     e30:	b0 91 d8 08 	lds	r27, 0x08D8
     e34:	cd 91       	ld	r28, X+
     e36:	cd bf       	out	0x3d, r28	; 61
     e38:	dd 91       	ld	r29, X+
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	ff 91       	pop	r31
     e3e:	ef 91       	pop	r30
     e40:	df 91       	pop	r29
     e42:	cf 91       	pop	r28
     e44:	bf 91       	pop	r27
     e46:	af 91       	pop	r26
     e48:	9f 91       	pop	r25
     e4a:	8f 91       	pop	r24
     e4c:	7f 91       	pop	r23
     e4e:	6f 91       	pop	r22
     e50:	5f 91       	pop	r21
     e52:	4f 91       	pop	r20
     e54:	3f 91       	pop	r19
     e56:	2f 91       	pop	r18
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	df 90       	pop	r13
     e62:	cf 90       	pop	r12
     e64:	bf 90       	pop	r11
     e66:	af 90       	pop	r10
     e68:	9f 90       	pop	r9
     e6a:	8f 90       	pop	r8
     e6c:	7f 90       	pop	r7
     e6e:	6f 90       	pop	r6
     e70:	5f 90       	pop	r5
     e72:	4f 90       	pop	r4
     e74:	3f 90       	pop	r3
     e76:	2f 90       	pop	r2
     e78:	1f 90       	pop	r1
     e7a:	0f 90       	pop	r0
     e7c:	0c be       	out	0x3c, r0	; 60
     e7e:	0f 90       	pop	r0
     e80:	0b be       	out	0x3b, r0	; 59
     e82:	0f 90       	pop	r0
     e84:	0f be       	out	0x3f, r0	; 63
     e86:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e88:	08 95       	ret

00000e8a <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     e8a:	9d df       	rcall	.-198    	; 0xdc6 <vPortYieldFromTick>
		 asm volatile ("reti");
     e8c:	18 95       	reti

00000e8e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     e8e:	1f 93       	push	r17
     e90:	cf 93       	push	r28
     e92:	df 93       	push	r29
     e94:	ec 01       	movw	r28, r24
     e96:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     e98:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e9a:	81 11       	cpse	r24, r1
     e9c:	0c c0       	rjmp	.+24     	; 0xeb6 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     e9e:	88 81       	ld	r24, Y
     ea0:	99 81       	ldd	r25, Y+1	; 0x01
     ea2:	89 2b       	or	r24, r25
     ea4:	09 f0       	breq	.+2      	; 0xea8 <prvCopyDataToQueue+0x1a>
     ea6:	47 c0       	rjmp	.+142    	; 0xf36 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     ea8:	8a 81       	ldd	r24, Y+2	; 0x02
     eaa:	9b 81       	ldd	r25, Y+3	; 0x03
     eac:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     eb0:	1b 82       	std	Y+3, r1	; 0x03
     eb2:	1a 82       	std	Y+2, r1	; 0x02
     eb4:	47 c0       	rjmp	.+142    	; 0xf44 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     eb6:	41 11       	cpse	r20, r1
     eb8:	18 c0       	rjmp	.+48     	; 0xeea <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     eba:	48 2f       	mov	r20, r24
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	8c 81       	ldd	r24, Y+4	; 0x04
     ec0:	9d 81       	ldd	r25, Y+5	; 0x05
     ec2:	0e 94 53 10 	call	0x20a6	; 0x20a6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ec6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ec8:	8c 81       	ldd	r24, Y+4	; 0x04
     eca:	9d 81       	ldd	r25, Y+5	; 0x05
     ecc:	82 0f       	add	r24, r18
     ece:	91 1d       	adc	r25, r1
     ed0:	9d 83       	std	Y+5, r25	; 0x05
     ed2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ed4:	2a 81       	ldd	r18, Y+2	; 0x02
     ed6:	3b 81       	ldd	r19, Y+3	; 0x03
     ed8:	82 17       	cp	r24, r18
     eda:	93 07       	cpc	r25, r19
     edc:	70 f1       	brcs	.+92     	; 0xf3a <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ede:	88 81       	ld	r24, Y
     ee0:	99 81       	ldd	r25, Y+1	; 0x01
     ee2:	9d 83       	std	Y+5, r25	; 0x05
     ee4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     ee6:	80 e0       	ldi	r24, 0x00	; 0
     ee8:	2d c0       	rjmp	.+90     	; 0xf44 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     eea:	48 2f       	mov	r20, r24
     eec:	50 e0       	ldi	r21, 0x00	; 0
     eee:	8e 81       	ldd	r24, Y+6	; 0x06
     ef0:	9f 81       	ldd	r25, Y+7	; 0x07
     ef2:	0e 94 53 10 	call	0x20a6	; 0x20a6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ef6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ef8:	30 e0       	ldi	r19, 0x00	; 0
     efa:	31 95       	neg	r19
     efc:	21 95       	neg	r18
     efe:	31 09       	sbc	r19, r1
     f00:	8e 81       	ldd	r24, Y+6	; 0x06
     f02:	9f 81       	ldd	r25, Y+7	; 0x07
     f04:	82 0f       	add	r24, r18
     f06:	93 1f       	adc	r25, r19
     f08:	9f 83       	std	Y+7, r25	; 0x07
     f0a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f0c:	68 81       	ld	r22, Y
     f0e:	79 81       	ldd	r23, Y+1	; 0x01
     f10:	86 17       	cp	r24, r22
     f12:	97 07       	cpc	r25, r23
     f14:	30 f4       	brcc	.+12     	; 0xf22 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f16:	8a 81       	ldd	r24, Y+2	; 0x02
     f18:	9b 81       	ldd	r25, Y+3	; 0x03
     f1a:	28 0f       	add	r18, r24
     f1c:	39 1f       	adc	r19, r25
     f1e:	3f 83       	std	Y+7, r19	; 0x07
     f20:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     f22:	12 30       	cpi	r17, 0x02	; 2
     f24:	61 f4       	brne	.+24     	; 0xf3e <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     f26:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f28:	88 23       	and	r24, r24
     f2a:	59 f0       	breq	.+22     	; 0xf42 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     f2c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f2e:	81 50       	subi	r24, 0x01	; 1
     f30:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	07 c0       	rjmp	.+14     	; 0xf44 <prvCopyDataToQueue+0xb6>
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	05 c0       	rjmp	.+10     	; 0xf44 <prvCopyDataToQueue+0xb6>
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	03 c0       	rjmp	.+6      	; 0xf44 <prvCopyDataToQueue+0xb6>
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	01 c0       	rjmp	.+2      	; 0xf44 <prvCopyDataToQueue+0xb6>
     f42:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     f44:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f46:	9f 5f       	subi	r25, 0xFF	; 255
     f48:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     f4a:	df 91       	pop	r29
     f4c:	cf 91       	pop	r28
     f4e:	1f 91       	pop	r17
     f50:	08 95       	ret

00000f52 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     f52:	fc 01       	movw	r30, r24
     f54:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     f56:	44 8d       	ldd	r20, Z+28	; 0x1c
     f58:	44 23       	and	r20, r20
     f5a:	a1 f0       	breq	.+40     	; 0xf84 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     f5c:	50 e0       	ldi	r21, 0x00	; 0
     f5e:	26 81       	ldd	r18, Z+6	; 0x06
     f60:	37 81       	ldd	r19, Z+7	; 0x07
     f62:	24 0f       	add	r18, r20
     f64:	35 1f       	adc	r19, r21
     f66:	37 83       	std	Z+7, r19	; 0x07
     f68:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     f6a:	62 81       	ldd	r22, Z+2	; 0x02
     f6c:	73 81       	ldd	r23, Z+3	; 0x03
     f6e:	26 17       	cp	r18, r22
     f70:	37 07       	cpc	r19, r23
     f72:	20 f0       	brcs	.+8      	; 0xf7c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     f74:	20 81       	ld	r18, Z
     f76:	31 81       	ldd	r19, Z+1	; 0x01
     f78:	37 83       	std	Z+7, r19	; 0x07
     f7a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     f7c:	66 81       	ldd	r22, Z+6	; 0x06
     f7e:	77 81       	ldd	r23, Z+7	; 0x07
     f80:	0c 94 53 10 	jmp	0x20a6	; 0x20a6 <memcpy>
     f84:	08 95       	ret

00000f86 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     f86:	0f 93       	push	r16
     f88:	1f 93       	push	r17
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	f8 94       	cli
     f94:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f96:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f98:	18 16       	cp	r1, r24
     f9a:	a4 f4       	brge	.+40     	; 0xfc4 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f9c:	89 89       	ldd	r24, Y+17	; 0x11
     f9e:	88 23       	and	r24, r24
     fa0:	89 f0       	breq	.+34     	; 0xfc4 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fa2:	8e 01       	movw	r16, r28
     fa4:	0f 5e       	subi	r16, 0xEF	; 239
     fa6:	1f 4f       	sbci	r17, 0xFF	; 255
     fa8:	03 c0       	rjmp	.+6      	; 0xfb0 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     faa:	89 89       	ldd	r24, Y+17	; 0x11
     fac:	88 23       	and	r24, r24
     fae:	51 f0       	breq	.+20     	; 0xfc4 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fb0:	c8 01       	movw	r24, r16
     fb2:	14 d7       	rcall	.+3624   	; 0x1ddc <xTaskRemoveFromEventList>
     fb4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     fb6:	9d d7       	rcall	.+3898   	; 0x1ef2 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     fb8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fba:	81 50       	subi	r24, 0x01	; 1
     fbc:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     fbe:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fc0:	18 16       	cp	r1, r24
     fc2:	9c f3       	brlt	.-26     	; 0xfaa <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     fc8:	0f 90       	pop	r0
     fca:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     fcc:	0f b6       	in	r0, 0x3f	; 63
     fce:	f8 94       	cli
     fd0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     fd2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fd4:	18 16       	cp	r1, r24
     fd6:	a4 f4       	brge	.+40     	; 0x1000 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fd8:	88 85       	ldd	r24, Y+8	; 0x08
     fda:	88 23       	and	r24, r24
     fdc:	89 f0       	breq	.+34     	; 0x1000 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fde:	8e 01       	movw	r16, r28
     fe0:	08 5f       	subi	r16, 0xF8	; 248
     fe2:	1f 4f       	sbci	r17, 0xFF	; 255
     fe4:	03 c0       	rjmp	.+6      	; 0xfec <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fe6:	88 85       	ldd	r24, Y+8	; 0x08
     fe8:	88 23       	and	r24, r24
     fea:	51 f0       	breq	.+20     	; 0x1000 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fec:	c8 01       	movw	r24, r16
     fee:	f6 d6       	rcall	.+3564   	; 0x1ddc <xTaskRemoveFromEventList>
     ff0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     ff2:	7f d7       	rcall	.+3838   	; 0x1ef2 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     ff4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ff6:	81 50       	subi	r24, 0x01	; 1
     ff8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ffa:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ffc:	18 16       	cp	r1, r24
     ffe:	9c f3       	brlt	.-26     	; 0xfe6 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1000:	8f ef       	ldi	r24, 0xFF	; 255
    1002:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
}
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	08 95       	ret

00001012 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1018:	0f b6       	in	r0, 0x3f	; 63
    101a:	f8 94       	cli
    101c:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    101e:	88 81       	ld	r24, Y
    1020:	99 81       	ldd	r25, Y+1	; 0x01
    1022:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1028:	72 9f       	mul	r23, r18
    102a:	a0 01       	movw	r20, r0
    102c:	73 9f       	mul	r23, r19
    102e:	50 0d       	add	r21, r0
    1030:	11 24       	eor	r1, r1
    1032:	fc 01       	movw	r30, r24
    1034:	e4 0f       	add	r30, r20
    1036:	f5 1f       	adc	r31, r21
    1038:	fb 83       	std	Y+3, r31	; 0x03
    103a:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    103c:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    103e:	9d 83       	std	Y+5, r25	; 0x05
    1040:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1042:	42 1b       	sub	r20, r18
    1044:	53 0b       	sbc	r21, r19
    1046:	84 0f       	add	r24, r20
    1048:	95 1f       	adc	r25, r21
    104a:	9f 83       	std	Y+7, r25	; 0x07
    104c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    104e:	8f ef       	ldi	r24, 0xFF	; 255
    1050:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1052:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1054:	61 11       	cpse	r22, r1
    1056:	0a c0       	rjmp	.+20     	; 0x106c <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1058:	88 85       	ldd	r24, Y+8	; 0x08
    105a:	88 23       	and	r24, r24
    105c:	69 f0       	breq	.+26     	; 0x1078 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    105e:	ce 01       	movw	r24, r28
    1060:	08 96       	adiw	r24, 0x08	; 8
    1062:	bc d6       	rcall	.+3448   	; 0x1ddc <xTaskRemoveFromEventList>
    1064:	81 30       	cpi	r24, 0x01	; 1
    1066:	41 f4       	brne	.+16     	; 0x1078 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1068:	4e de       	rcall	.-868    	; 0xd06 <vPortYield>
    106a:	06 c0       	rjmp	.+12     	; 0x1078 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    106c:	ce 01       	movw	r24, r28
    106e:	08 96       	adiw	r24, 0x08	; 8
    1070:	c6 d9       	rcall	.-3188   	; 0x3fe <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1072:	ce 01       	movw	r24, r28
    1074:	41 96       	adiw	r24, 0x11	; 17
    1076:	c3 d9       	rcall	.-3194   	; 0x3fe <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    107c:	81 e0       	ldi	r24, 0x01	; 1
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	08 95       	ret

00001084 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	cf 93       	push	r28
    108a:	df 93       	push	r29
    108c:	18 2f       	mov	r17, r24
    108e:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1090:	88 23       	and	r24, r24
    1092:	d1 f0       	breq	.+52     	; 0x10c8 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1094:	8f e1       	ldi	r24, 0x1F	; 31
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	7c d9       	rcall	.-3336   	; 0x392 <pvPortMalloc>
    109a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    109c:	00 97       	sbiw	r24, 0x00	; 0
    109e:	b1 f0       	breq	.+44     	; 0x10cc <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10a0:	10 9f       	mul	r17, r16
    10a2:	c0 01       	movw	r24, r0
    10a4:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    10a6:	01 96       	adiw	r24, 0x01	; 1
    10a8:	74 d9       	rcall	.-3352   	; 0x392 <pvPortMalloc>
    10aa:	99 83       	std	Y+1, r25	; 0x01
    10ac:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    10ae:	89 2b       	or	r24, r25
    10b0:	31 f0       	breq	.+12     	; 0x10be <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    10b2:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    10b4:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    10b6:	61 e0       	ldi	r22, 0x01	; 1
    10b8:	ce 01       	movw	r24, r28
    10ba:	ab df       	rcall	.-170    	; 0x1012 <xQueueGenericReset>
    10bc:	07 c0       	rjmp	.+14     	; 0x10cc <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    10be:	ce 01       	movw	r24, r28
    10c0:	9d d9       	rcall	.-3270   	; 0x3fc <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    10c2:	c0 e0       	ldi	r28, 0x00	; 0
    10c4:	d0 e0       	ldi	r29, 0x00	; 0
    10c6:	02 c0       	rjmp	.+4      	; 0x10cc <xQueueGenericCreate+0x48>
    10c8:	c0 e0       	ldi	r28, 0x00	; 0
    10ca:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    10cc:	ce 01       	movw	r24, r28
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	08 95       	ret

000010d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    10d8:	9f 92       	push	r9
    10da:	af 92       	push	r10
    10dc:	bf 92       	push	r11
    10de:	cf 92       	push	r12
    10e0:	df 92       	push	r13
    10e2:	ef 92       	push	r14
    10e4:	ff 92       	push	r15
    10e6:	0f 93       	push	r16
    10e8:	1f 93       	push	r17
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	00 d0       	rcall	.+0      	; 0x10f0 <xQueueGenericSend+0x18>
    10f0:	1f 92       	push	r1
    10f2:	1f 92       	push	r1
    10f4:	cd b7       	in	r28, 0x3d	; 61
    10f6:	de b7       	in	r29, 0x3e	; 62
    10f8:	8c 01       	movw	r16, r24
    10fa:	6b 01       	movw	r12, r22
    10fc:	5d 83       	std	Y+5, r21	; 0x05
    10fe:	4c 83       	std	Y+4, r20	; 0x04
    1100:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1102:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1104:	99 24       	eor	r9, r9
    1106:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1108:	7c 01       	movw	r14, r24
    110a:	88 e0       	ldi	r24, 0x08	; 8
    110c:	e8 0e       	add	r14, r24
    110e:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1110:	0f b6       	in	r0, 0x3f	; 63
    1112:	f8 94       	cli
    1114:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1116:	f8 01       	movw	r30, r16
    1118:	92 8d       	ldd	r25, Z+26	; 0x1a
    111a:	83 8d       	ldd	r24, Z+27	; 0x1b
    111c:	98 17       	cp	r25, r24
    111e:	18 f0       	brcs	.+6      	; 0x1126 <xQueueGenericSend+0x4e>
    1120:	f2 e0       	ldi	r31, 0x02	; 2
    1122:	af 12       	cpse	r10, r31
    1124:	15 c0       	rjmp	.+42     	; 0x1150 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1126:	4a 2d       	mov	r20, r10
    1128:	b6 01       	movw	r22, r12
    112a:	c8 01       	movw	r24, r16
    112c:	b0 de       	rcall	.-672    	; 0xe8e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    112e:	f8 01       	movw	r30, r16
    1130:	91 89       	ldd	r25, Z+17	; 0x11
    1132:	99 23       	and	r25, r25
    1134:	39 f0       	breq	.+14     	; 0x1144 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1136:	c8 01       	movw	r24, r16
    1138:	41 96       	adiw	r24, 0x11	; 17
    113a:	50 d6       	rcall	.+3232   	; 0x1ddc <xTaskRemoveFromEventList>
    113c:	81 30       	cpi	r24, 0x01	; 1
    113e:	21 f4       	brne	.+8      	; 0x1148 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1140:	e2 dd       	rcall	.-1084   	; 0xd06 <vPortYield>
    1142:	02 c0       	rjmp	.+4      	; 0x1148 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1144:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1146:	df dd       	rcall	.-1090   	; 0xd06 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1148:	0f 90       	pop	r0
    114a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	46 c0       	rjmp	.+140    	; 0x11dc <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1150:	ec 81       	ldd	r30, Y+4	; 0x04
    1152:	fd 81       	ldd	r31, Y+5	; 0x05
    1154:	ef 2b       	or	r30, r31
    1156:	21 f4       	brne	.+8      	; 0x1160 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1158:	0f 90       	pop	r0
    115a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    115c:	80 e0       	ldi	r24, 0x00	; 0
    115e:	3e c0       	rjmp	.+124    	; 0x11dc <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1160:	b1 10       	cpse	r11, r1
    1162:	04 c0       	rjmp	.+8      	; 0x116c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1164:	ce 01       	movw	r24, r28
    1166:	01 96       	adiw	r24, 0x01	; 1
    1168:	81 d6       	rcall	.+3330   	; 0x1e6c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    116a:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1170:	78 d3       	rcall	.+1776   	; 0x1862 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	f8 94       	cli
    1176:	0f 92       	push	r0
    1178:	f8 01       	movw	r30, r16
    117a:	85 8d       	ldd	r24, Z+29	; 0x1d
    117c:	8f 3f       	cpi	r24, 0xFF	; 255
    117e:	09 f4       	brne	.+2      	; 0x1182 <xQueueGenericSend+0xaa>
    1180:	15 8e       	std	Z+29, r1	; 0x1d
    1182:	f8 01       	movw	r30, r16
    1184:	86 8d       	ldd	r24, Z+30	; 0x1e
    1186:	8f 3f       	cpi	r24, 0xFF	; 255
    1188:	09 f4       	brne	.+2      	; 0x118c <xQueueGenericSend+0xb4>
    118a:	16 8e       	std	Z+30, r1	; 0x1e
    118c:	0f 90       	pop	r0
    118e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1190:	be 01       	movw	r22, r28
    1192:	6c 5f       	subi	r22, 0xFC	; 252
    1194:	7f 4f       	sbci	r23, 0xFF	; 255
    1196:	ce 01       	movw	r24, r28
    1198:	01 96       	adiw	r24, 0x01	; 1
    119a:	73 d6       	rcall	.+3302   	; 0x1e82 <xTaskCheckForTimeOut>
    119c:	81 11       	cpse	r24, r1
    119e:	1a c0       	rjmp	.+52     	; 0x11d4 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	f8 94       	cli
    11a4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    11a6:	f8 01       	movw	r30, r16
    11a8:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    11aa:	0f 90       	pop	r0
    11ac:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    11ae:	f8 01       	movw	r30, r16
    11b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    11b2:	98 13       	cpse	r25, r24
    11b4:	0b c0       	rjmp	.+22     	; 0x11cc <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11b6:	6c 81       	ldd	r22, Y+4	; 0x04
    11b8:	7d 81       	ldd	r23, Y+5	; 0x05
    11ba:	c7 01       	movw	r24, r14
    11bc:	e4 d5       	rcall	.+3016   	; 0x1d86 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    11be:	c8 01       	movw	r24, r16
    11c0:	e2 de       	rcall	.-572    	; 0xf86 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    11c2:	22 d4       	rcall	.+2116   	; 0x1a08 <xTaskResumeAll>
    11c4:	81 11       	cpse	r24, r1
    11c6:	a4 cf       	rjmp	.-184    	; 0x1110 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    11c8:	9e dd       	rcall	.-1220   	; 0xd06 <vPortYield>
    11ca:	a2 cf       	rjmp	.-188    	; 0x1110 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11cc:	c8 01       	movw	r24, r16
    11ce:	db de       	rcall	.-586    	; 0xf86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11d0:	1b d4       	rcall	.+2102   	; 0x1a08 <xTaskResumeAll>
    11d2:	9e cf       	rjmp	.-196    	; 0x1110 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    11d4:	c8 01       	movw	r24, r16
    11d6:	d7 de       	rcall	.-594    	; 0xf86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11d8:	17 d4       	rcall	.+2094   	; 0x1a08 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    11da:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11dc:	0f 90       	pop	r0
    11de:	0f 90       	pop	r0
    11e0:	0f 90       	pop	r0
    11e2:	0f 90       	pop	r0
    11e4:	0f 90       	pop	r0
    11e6:	df 91       	pop	r29
    11e8:	cf 91       	pop	r28
    11ea:	1f 91       	pop	r17
    11ec:	0f 91       	pop	r16
    11ee:	ff 90       	pop	r15
    11f0:	ef 90       	pop	r14
    11f2:	df 90       	pop	r13
    11f4:	cf 90       	pop	r12
    11f6:	bf 90       	pop	r11
    11f8:	af 90       	pop	r10
    11fa:	9f 90       	pop	r9
    11fc:	08 95       	ret

000011fe <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    11fe:	cf 93       	push	r28
    1200:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1202:	8f e1       	ldi	r24, 0x1F	; 31
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	c5 d8       	rcall	.-3702   	; 0x392 <pvPortMalloc>
    1208:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    120a:	00 97       	sbiw	r24, 0x00	; 0
    120c:	e1 f0       	breq	.+56     	; 0x1246 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    120e:	1b 82       	std	Y+3, r1	; 0x03
    1210:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1212:	19 82       	std	Y+1, r1	; 0x01
    1214:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1216:	1d 82       	std	Y+5, r1	; 0x05
    1218:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    121a:	1f 82       	std	Y+7, r1	; 0x07
    121c:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    121e:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1224:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1226:	8f ef       	ldi	r24, 0xFF	; 255
    1228:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    122a:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    122c:	ce 01       	movw	r24, r28
    122e:	08 96       	adiw	r24, 0x08	; 8
    1230:	e6 d8       	rcall	.-3636   	; 0x3fe <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1232:	ce 01       	movw	r24, r28
    1234:	41 96       	adiw	r24, 0x11	; 17
    1236:	e3 d8       	rcall	.-3642   	; 0x3fe <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1238:	20 e0       	ldi	r18, 0x00	; 0
    123a:	40 e0       	ldi	r20, 0x00	; 0
    123c:	50 e0       	ldi	r21, 0x00	; 0
    123e:	60 e0       	ldi	r22, 0x00	; 0
    1240:	70 e0       	ldi	r23, 0x00	; 0
    1242:	ce 01       	movw	r24, r28
    1244:	49 df       	rcall	.-366    	; 0x10d8 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1246:	ce 01       	movw	r24, r28
    1248:	df 91       	pop	r29
    124a:	cf 91       	pop	r28
    124c:	08 95       	ret

0000124e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    124e:	0f 93       	push	r16
    1250:	1f 93       	push	r17
    1252:	cf 93       	push	r28
    1254:	df 93       	push	r29
    1256:	ec 01       	movw	r28, r24
    1258:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    125a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    125c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    125e:	98 17       	cp	r25, r24
    1260:	10 f0       	brcs	.+4      	; 0x1266 <xQueueGenericSendFromISR+0x18>
    1262:	22 30       	cpi	r18, 0x02	; 2
    1264:	11 f5       	brne	.+68     	; 0x12aa <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1266:	42 2f       	mov	r20, r18
    1268:	ce 01       	movw	r24, r28
    126a:	11 de       	rcall	.-990    	; 0xe8e <prvCopyDataToQueue>
    126c:	88 23       	and	r24, r24
    126e:	31 f0       	breq	.+12     	; 0x127c <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1270:	01 15       	cp	r16, r1
    1272:	11 05       	cpc	r17, r1
    1274:	19 f0       	breq	.+6      	; 0x127c <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	f8 01       	movw	r30, r16
    127a:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    127c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    127e:	8f 3f       	cpi	r24, 0xFF	; 255
    1280:	79 f4       	brne	.+30     	; 0x12a0 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1282:	89 89       	ldd	r24, Y+17	; 0x11
    1284:	88 23       	and	r24, r24
    1286:	99 f0       	breq	.+38     	; 0x12ae <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1288:	ce 01       	movw	r24, r28
    128a:	41 96       	adiw	r24, 0x11	; 17
    128c:	a7 d5       	rcall	.+2894   	; 0x1ddc <xTaskRemoveFromEventList>
    128e:	88 23       	and	r24, r24
    1290:	81 f0       	breq	.+32     	; 0x12b2 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1292:	01 15       	cp	r16, r1
    1294:	11 05       	cpc	r17, r1
    1296:	79 f0       	breq	.+30     	; 0x12b6 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	f8 01       	movw	r30, r16
    129c:	80 83       	st	Z, r24
    129e:	0c c0       	rjmp	.+24     	; 0x12b8 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    12a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12a2:	8f 5f       	subi	r24, 0xFF	; 255
    12a4:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	07 c0       	rjmp	.+14     	; 0x12b8 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	05 c0       	rjmp	.+10     	; 0x12b8 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	03 c0       	rjmp	.+6      	; 0x12b8 <xQueueGenericSendFromISR+0x6a>
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	01 c0       	rjmp	.+2      	; 0x12b8 <xQueueGenericSendFromISR+0x6a>
    12b6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	08 95       	ret

000012c2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    12c2:	9f 92       	push	r9
    12c4:	af 92       	push	r10
    12c6:	bf 92       	push	r11
    12c8:	cf 92       	push	r12
    12ca:	df 92       	push	r13
    12cc:	ef 92       	push	r14
    12ce:	ff 92       	push	r15
    12d0:	0f 93       	push	r16
    12d2:	1f 93       	push	r17
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
    12d8:	00 d0       	rcall	.+0      	; 0x12da <xQueueGenericReceive+0x18>
    12da:	1f 92       	push	r1
    12dc:	1f 92       	push	r1
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    12e2:	8c 01       	movw	r16, r24
    12e4:	6b 01       	movw	r12, r22
    12e6:	5d 83       	std	Y+5, r21	; 0x05
    12e8:	4c 83       	std	Y+4, r20	; 0x04
    12ea:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    12ec:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    12ee:	99 24       	eor	r9, r9
    12f0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12f2:	7c 01       	movw	r14, r24
    12f4:	81 e1       	ldi	r24, 0x11	; 17
    12f6:	e8 0e       	add	r14, r24
    12f8:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1300:	f8 01       	movw	r30, r16
    1302:	82 8d       	ldd	r24, Z+26	; 0x1a
    1304:	88 23       	and	r24, r24
    1306:	69 f1       	breq	.+90     	; 0x1362 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1308:	e6 80       	ldd	r14, Z+6	; 0x06
    130a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    130c:	b6 01       	movw	r22, r12
    130e:	c8 01       	movw	r24, r16
    1310:	20 de       	rcall	.-960    	; 0xf52 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1312:	b1 10       	cpse	r11, r1
    1314:	17 c0       	rjmp	.+46     	; 0x1344 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1316:	f8 01       	movw	r30, r16
    1318:	82 8d       	ldd	r24, Z+26	; 0x1a
    131a:	81 50       	subi	r24, 0x01	; 1
    131c:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    131e:	80 81       	ld	r24, Z
    1320:	91 81       	ldd	r25, Z+1	; 0x01
    1322:	89 2b       	or	r24, r25
    1324:	21 f4       	brne	.+8      	; 0x132e <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1326:	86 d6       	rcall	.+3340   	; 0x2034 <pvTaskIncrementMutexHeldCount>
    1328:	f8 01       	movw	r30, r16
    132a:	93 83       	std	Z+3, r25	; 0x03
    132c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    132e:	f8 01       	movw	r30, r16
    1330:	80 85       	ldd	r24, Z+8	; 0x08
    1332:	88 23       	and	r24, r24
    1334:	91 f0       	breq	.+36     	; 0x135a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1336:	c8 01       	movw	r24, r16
    1338:	08 96       	adiw	r24, 0x08	; 8
    133a:	50 d5       	rcall	.+2720   	; 0x1ddc <xTaskRemoveFromEventList>
    133c:	81 30       	cpi	r24, 0x01	; 1
    133e:	69 f4       	brne	.+26     	; 0x135a <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1340:	e2 dc       	rcall	.-1596   	; 0xd06 <vPortYield>
    1342:	0b c0       	rjmp	.+22     	; 0x135a <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1344:	f8 01       	movw	r30, r16
    1346:	f7 82       	std	Z+7, r15	; 0x07
    1348:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    134a:	81 89       	ldd	r24, Z+17	; 0x11
    134c:	88 23       	and	r24, r24
    134e:	29 f0       	breq	.+10     	; 0x135a <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1350:	c8 01       	movw	r24, r16
    1352:	41 96       	adiw	r24, 0x11	; 17
    1354:	43 d5       	rcall	.+2694   	; 0x1ddc <xTaskRemoveFromEventList>
    1356:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1358:	d6 dc       	rcall	.-1620   	; 0xd06 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    135a:	0f 90       	pop	r0
    135c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	52 c0       	rjmp	.+164    	; 0x1406 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1362:	4c 81       	ldd	r20, Y+4	; 0x04
    1364:	5d 81       	ldd	r21, Y+5	; 0x05
    1366:	45 2b       	or	r20, r21
    1368:	21 f4       	brne	.+8      	; 0x1372 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    136a:	0f 90       	pop	r0
    136c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    136e:	80 e0       	ldi	r24, 0x00	; 0
    1370:	4a c0       	rjmp	.+148    	; 0x1406 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1372:	a1 10       	cpse	r10, r1
    1374:	04 c0       	rjmp	.+8      	; 0x137e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1376:	ce 01       	movw	r24, r28
    1378:	01 96       	adiw	r24, 0x01	; 1
    137a:	78 d5       	rcall	.+2800   	; 0x1e6c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    137c:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    137e:	0f 90       	pop	r0
    1380:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1382:	6f d2       	rcall	.+1246   	; 0x1862 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	f8 94       	cli
    1388:	0f 92       	push	r0
    138a:	f8 01       	movw	r30, r16
    138c:	85 8d       	ldd	r24, Z+29	; 0x1d
    138e:	8f 3f       	cpi	r24, 0xFF	; 255
    1390:	09 f4       	brne	.+2      	; 0x1394 <xQueueGenericReceive+0xd2>
    1392:	15 8e       	std	Z+29, r1	; 0x1d
    1394:	f8 01       	movw	r30, r16
    1396:	86 8d       	ldd	r24, Z+30	; 0x1e
    1398:	8f 3f       	cpi	r24, 0xFF	; 255
    139a:	09 f4       	brne	.+2      	; 0x139e <xQueueGenericReceive+0xdc>
    139c:	16 8e       	std	Z+30, r1	; 0x1e
    139e:	0f 90       	pop	r0
    13a0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13a2:	be 01       	movw	r22, r28
    13a4:	6c 5f       	subi	r22, 0xFC	; 252
    13a6:	7f 4f       	sbci	r23, 0xFF	; 255
    13a8:	ce 01       	movw	r24, r28
    13aa:	01 96       	adiw	r24, 0x01	; 1
    13ac:	6a d5       	rcall	.+2772   	; 0x1e82 <xTaskCheckForTimeOut>
    13ae:	81 11       	cpse	r24, r1
    13b0:	26 c0       	rjmp	.+76     	; 0x13fe <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    13b2:	0f b6       	in	r0, 0x3f	; 63
    13b4:	f8 94       	cli
    13b6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    13b8:	f8 01       	movw	r30, r16
    13ba:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    13bc:	0f 90       	pop	r0
    13be:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13c0:	81 11       	cpse	r24, r1
    13c2:	19 c0       	rjmp	.+50     	; 0x13f6 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13c4:	f8 01       	movw	r30, r16
    13c6:	80 81       	ld	r24, Z
    13c8:	91 81       	ldd	r25, Z+1	; 0x01
    13ca:	89 2b       	or	r24, r25
    13cc:	49 f4       	brne	.+18     	; 0x13e0 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    13ce:	0f b6       	in	r0, 0x3f	; 63
    13d0:	f8 94       	cli
    13d2:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    13d4:	f8 01       	movw	r30, r16
    13d6:	82 81       	ldd	r24, Z+2	; 0x02
    13d8:	93 81       	ldd	r25, Z+3	; 0x03
    13da:	8f d5       	rcall	.+2846   	; 0x1efa <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    13dc:	0f 90       	pop	r0
    13de:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13e0:	6c 81       	ldd	r22, Y+4	; 0x04
    13e2:	7d 81       	ldd	r23, Y+5	; 0x05
    13e4:	c7 01       	movw	r24, r14
    13e6:	cf d4       	rcall	.+2462   	; 0x1d86 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    13e8:	c8 01       	movw	r24, r16
    13ea:	cd dd       	rcall	.-1126   	; 0xf86 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    13ec:	0d d3       	rcall	.+1562   	; 0x1a08 <xTaskResumeAll>
    13ee:	81 11       	cpse	r24, r1
    13f0:	84 cf       	rjmp	.-248    	; 0x12fa <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    13f2:	89 dc       	rcall	.-1774   	; 0xd06 <vPortYield>
    13f4:	82 cf       	rjmp	.-252    	; 0x12fa <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13f6:	c8 01       	movw	r24, r16
    13f8:	c6 dd       	rcall	.-1140   	; 0xf86 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13fa:	06 d3       	rcall	.+1548   	; 0x1a08 <xTaskResumeAll>
    13fc:	7e cf       	rjmp	.-260    	; 0x12fa <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    13fe:	c8 01       	movw	r24, r16
    1400:	c2 dd       	rcall	.-1148   	; 0xf86 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1402:	02 d3       	rcall	.+1540   	; 0x1a08 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1404:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1406:	0f 90       	pop	r0
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	0f 90       	pop	r0
    140e:	0f 90       	pop	r0
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	1f 91       	pop	r17
    1416:	0f 91       	pop	r16
    1418:	ff 90       	pop	r15
    141a:	ef 90       	pop	r14
    141c:	df 90       	pop	r13
    141e:	cf 90       	pop	r12
    1420:	bf 90       	pop	r11
    1422:	af 90       	pop	r10
    1424:	9f 90       	pop	r9
    1426:	08 95       	ret

00001428 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1428:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    142a:	71 83       	std	Z+1, r23	; 0x01
    142c:	60 83       	st	Z, r22
	ring->rSize = size;
    142e:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1430:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1432:	13 82       	std	Z+3, r1	; 0x03
    1434:	08 95       	ret

00001436 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1436:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1438:	94 81       	ldd	r25, Z+4	; 0x04
    143a:	a0 81       	ld	r26, Z
    143c:	b1 81       	ldd	r27, Z+1	; 0x01
    143e:	a9 0f       	add	r26, r25
    1440:	b1 1d       	adc	r27, r1
    1442:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1444:	9f 5f       	subi	r25, 0xFF	; 255
    1446:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1448:	22 81       	ldd	r18, Z+2	; 0x02
    144a:	92 17       	cp	r25, r18
    144c:	10 f0       	brcs	.+4      	; 0x1452 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    144e:	92 1b       	sub	r25, r18
    1450:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1452:	93 81       	ldd	r25, Z+3	; 0x03
    1454:	91 50       	subi	r25, 0x01	; 1
    1456:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1458:	08 95       	ret

0000145a <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    145a:	fc 01       	movw	r30, r24
    145c:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    145e:	83 81       	ldd	r24, Z+3	; 0x03
    1460:	22 81       	ldd	r18, Z+2	; 0x02
    1462:	82 17       	cp	r24, r18
    1464:	78 f4       	brcc	.+30     	; 0x1484 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1466:	34 81       	ldd	r19, Z+4	; 0x04
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	83 0f       	add	r24, r19
    146c:	91 1d       	adc	r25, r1
    146e:	62 2f       	mov	r22, r18
    1470:	70 e0       	ldi	r23, 0x00	; 0
    1472:	f2 d5       	rcall	.+3044   	; 0x2058 <__divmodhi4>
    1474:	a0 81       	ld	r26, Z
    1476:	b1 81       	ldd	r27, Z+1	; 0x01
    1478:	a8 0f       	add	r26, r24
    147a:	b9 1f       	adc	r27, r25
    147c:	4c 93       	st	X, r20
            ring->rLength++;
    147e:	83 81       	ldd	r24, Z+3	; 0x03
    1480:	8f 5f       	subi	r24, 0xFF	; 255
    1482:	83 83       	std	Z+3, r24	; 0x03
    1484:	08 95       	ret

00001486 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1486:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	22 81       	ldd	r18, Z+2	; 0x02
    148c:	93 81       	ldd	r25, Z+3	; 0x03
    148e:	29 13       	cpse	r18, r25
    1490:	80 e0       	ldi	r24, 0x00	; 0
}
    1492:	08 95       	ret

00001494 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1494:	21 e0       	ldi	r18, 0x01	; 1
    1496:	fc 01       	movw	r30, r24
    1498:	83 81       	ldd	r24, Z+3	; 0x03
    149a:	81 11       	cpse	r24, r1
    149c:	01 c0       	rjmp	.+2      	; 0x14a0 <ringBufferNotEmpty+0xc>
    149e:	20 e0       	ldi	r18, 0x00	; 0
}
    14a0:	82 2f       	mov	r24, r18
    14a2:	08 95       	ret

000014a4 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    14a4:	e0 91 96 08 	lds	r30, 0x0896
    14a8:	f0 91 97 08 	lds	r31, 0x0897
    14ac:	80 81       	ld	r24, Z
    14ae:	81 11       	cpse	r24, r1
    14b0:	07 c0       	rjmp	.+14     	; 0x14c0 <prvResetNextTaskUnblockTime+0x1c>
    14b2:	8f ef       	ldi	r24, 0xFF	; 255
    14b4:	9f ef       	ldi	r25, 0xFF	; 255
    14b6:	90 93 05 02 	sts	0x0205, r25
    14ba:	80 93 04 02 	sts	0x0204, r24
    14be:	08 95       	ret
    14c0:	e0 91 96 08 	lds	r30, 0x0896
    14c4:	f0 91 97 08 	lds	r31, 0x0897
    14c8:	05 80       	ldd	r0, Z+5	; 0x05
    14ca:	f6 81       	ldd	r31, Z+6	; 0x06
    14cc:	e0 2d       	mov	r30, r0
    14ce:	06 80       	ldd	r0, Z+6	; 0x06
    14d0:	f7 81       	ldd	r31, Z+7	; 0x07
    14d2:	e0 2d       	mov	r30, r0
    14d4:	82 81       	ldd	r24, Z+2	; 0x02
    14d6:	93 81       	ldd	r25, Z+3	; 0x03
    14d8:	90 93 05 02 	sts	0x0205, r25
    14dc:	80 93 04 02 	sts	0x0204, r24
    14e0:	08 95       	ret

000014e2 <prvAddCurrentTaskToDelayedList>:
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	ec 01       	movw	r28, r24
    14e8:	e0 91 d7 08 	lds	r30, 0x08D7
    14ec:	f0 91 d8 08 	lds	r31, 0x08D8
    14f0:	93 83       	std	Z+3, r25	; 0x03
    14f2:	82 83       	std	Z+2, r24	; 0x02
    14f4:	80 91 75 08 	lds	r24, 0x0875
    14f8:	90 91 76 08 	lds	r25, 0x0876
    14fc:	c8 17       	cp	r28, r24
    14fe:	d9 07       	cpc	r29, r25
    1500:	68 f4       	brcc	.+26     	; 0x151c <prvAddCurrentTaskToDelayedList+0x3a>
    1502:	60 91 d7 08 	lds	r22, 0x08D7
    1506:	70 91 d8 08 	lds	r23, 0x08D8
    150a:	80 91 94 08 	lds	r24, 0x0894
    150e:	90 91 95 08 	lds	r25, 0x0895
    1512:	6e 5f       	subi	r22, 0xFE	; 254
    1514:	7f 4f       	sbci	r23, 0xFF	; 255
    1516:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    151a:	17 c0       	rjmp	.+46     	; 0x154a <prvAddCurrentTaskToDelayedList+0x68>
    151c:	60 91 d7 08 	lds	r22, 0x08D7
    1520:	70 91 d8 08 	lds	r23, 0x08D8
    1524:	80 91 96 08 	lds	r24, 0x0896
    1528:	90 91 97 08 	lds	r25, 0x0897
    152c:	6e 5f       	subi	r22, 0xFE	; 254
    152e:	7f 4f       	sbci	r23, 0xFF	; 255
    1530:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    1534:	80 91 04 02 	lds	r24, 0x0204
    1538:	90 91 05 02 	lds	r25, 0x0205
    153c:	c8 17       	cp	r28, r24
    153e:	d9 07       	cpc	r29, r25
    1540:	20 f4       	brcc	.+8      	; 0x154a <prvAddCurrentTaskToDelayedList+0x68>
    1542:	d0 93 05 02 	sts	0x0205, r29
    1546:	c0 93 04 02 	sts	0x0204, r28
    154a:	df 91       	pop	r29
    154c:	cf 91       	pop	r28
    154e:	08 95       	ret

00001550 <xTaskGenericCreate>:
    1550:	4f 92       	push	r4
    1552:	5f 92       	push	r5
    1554:	6f 92       	push	r6
    1556:	7f 92       	push	r7
    1558:	8f 92       	push	r8
    155a:	9f 92       	push	r9
    155c:	af 92       	push	r10
    155e:	bf 92       	push	r11
    1560:	cf 92       	push	r12
    1562:	df 92       	push	r13
    1564:	ef 92       	push	r14
    1566:	ff 92       	push	r15
    1568:	0f 93       	push	r16
    156a:	1f 93       	push	r17
    156c:	cf 93       	push	r28
    156e:	df 93       	push	r29
    1570:	4c 01       	movw	r8, r24
    1572:	5b 01       	movw	r10, r22
    1574:	2a 01       	movw	r4, r20
    1576:	39 01       	movw	r6, r18
    1578:	83 e2       	ldi	r24, 0x23	; 35
    157a:	90 e0       	ldi	r25, 0x00	; 0
    157c:	0e 94 c9 01 	call	0x392	; 0x392 <pvPortMalloc>
    1580:	ec 01       	movw	r28, r24
    1582:	00 97       	sbiw	r24, 0x00	; 0
    1584:	09 f4       	brne	.+2      	; 0x1588 <xTaskGenericCreate+0x38>
    1586:	e7 c0       	rjmp	.+462    	; 0x1756 <xTaskGenericCreate+0x206>
    1588:	c1 14       	cp	r12, r1
    158a:	d1 04       	cpc	r13, r1
    158c:	09 f0       	breq	.+2      	; 0x1590 <xTaskGenericCreate+0x40>
    158e:	cc c0       	rjmp	.+408    	; 0x1728 <xTaskGenericCreate+0x1d8>
    1590:	c2 01       	movw	r24, r4
    1592:	0e 94 c9 01 	call	0x392	; 0x392 <pvPortMalloc>
    1596:	98 8f       	std	Y+24, r25	; 0x18
    1598:	8f 8b       	std	Y+23, r24	; 0x17
    159a:	89 2b       	or	r24, r25
    159c:	09 f0       	breq	.+2      	; 0x15a0 <xTaskGenericCreate+0x50>
    159e:	c6 c0       	rjmp	.+396    	; 0x172c <xTaskGenericCreate+0x1dc>
    15a0:	ce 01       	movw	r24, r28
    15a2:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    15a6:	d7 c0       	rjmp	.+430    	; 0x1756 <xTaskGenericCreate+0x206>
    15a8:	cf 01       	movw	r24, r30
    15aa:	31 91       	ld	r19, Z+
    15ac:	da 01       	movw	r26, r20
    15ae:	3d 93       	st	X+, r19
    15b0:	ad 01       	movw	r20, r26
    15b2:	dc 01       	movw	r26, r24
    15b4:	8c 91       	ld	r24, X
    15b6:	88 23       	and	r24, r24
    15b8:	11 f0       	breq	.+4      	; 0x15be <xTaskGenericCreate+0x6e>
    15ba:	21 50       	subi	r18, 0x01	; 1
    15bc:	a9 f7       	brne	.-22     	; 0x15a8 <xTaskGenericCreate+0x58>
    15be:	18 a2       	std	Y+32, r1	; 0x20
    15c0:	10 2f       	mov	r17, r16
    15c2:	05 30       	cpi	r16, 0x05	; 5
    15c4:	08 f0       	brcs	.+2      	; 0x15c8 <xTaskGenericCreate+0x78>
    15c6:	14 e0       	ldi	r17, 0x04	; 4
    15c8:	1e 8b       	std	Y+22, r17	; 0x16
    15ca:	19 a3       	std	Y+33, r17	; 0x21
    15cc:	1a a2       	std	Y+34, r1	; 0x22
    15ce:	5e 01       	movw	r10, r28
    15d0:	b2 e0       	ldi	r27, 0x02	; 2
    15d2:	ab 0e       	add	r10, r27
    15d4:	b1 1c       	adc	r11, r1
    15d6:	c5 01       	movw	r24, r10
    15d8:	0e 94 0d 02 	call	0x41a	; 0x41a <vListInitialiseItem>
    15dc:	ce 01       	movw	r24, r28
    15de:	0c 96       	adiw	r24, 0x0c	; 12
    15e0:	0e 94 0d 02 	call	0x41a	; 0x41a <vListInitialiseItem>
    15e4:	d9 87       	std	Y+9, r29	; 0x09
    15e6:	c8 87       	std	Y+8, r28	; 0x08
    15e8:	85 e0       	ldi	r24, 0x05	; 5
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	81 1b       	sub	r24, r17
    15ee:	91 09       	sbc	r25, r1
    15f0:	9d 87       	std	Y+13, r25	; 0x0d
    15f2:	8c 87       	std	Y+12, r24	; 0x0c
    15f4:	db 8b       	std	Y+19, r29	; 0x13
    15f6:	ca 8b       	std	Y+18, r28	; 0x12
    15f8:	a3 01       	movw	r20, r6
    15fa:	b4 01       	movw	r22, r8
    15fc:	c6 01       	movw	r24, r12
    15fe:	d4 da       	rcall	.-2648   	; 0xba8 <pxPortInitialiseStack>
    1600:	99 83       	std	Y+1, r25	; 0x01
    1602:	88 83       	st	Y, r24
    1604:	e1 14       	cp	r14, r1
    1606:	f1 04       	cpc	r15, r1
    1608:	19 f0       	breq	.+6      	; 0x1610 <xTaskGenericCreate+0xc0>
    160a:	f7 01       	movw	r30, r14
    160c:	d1 83       	std	Z+1, r29	; 0x01
    160e:	c0 83       	st	Z, r28
    1610:	0f b6       	in	r0, 0x3f	; 63
    1612:	f8 94       	cli
    1614:	0f 92       	push	r0
    1616:	80 91 77 08 	lds	r24, 0x0877
    161a:	8f 5f       	subi	r24, 0xFF	; 255
    161c:	80 93 77 08 	sts	0x0877, r24
    1620:	80 91 d7 08 	lds	r24, 0x08D7
    1624:	90 91 d8 08 	lds	r25, 0x08D8
    1628:	89 2b       	or	r24, r25
    162a:	09 f0       	breq	.+2      	; 0x162e <xTaskGenericCreate+0xde>
    162c:	3f c0       	rjmp	.+126    	; 0x16ac <xTaskGenericCreate+0x15c>
    162e:	d0 93 d8 08 	sts	0x08D8, r29
    1632:	c0 93 d7 08 	sts	0x08D7, r28
    1636:	80 91 77 08 	lds	r24, 0x0877
    163a:	81 30       	cpi	r24, 0x01	; 1
    163c:	09 f0       	breq	.+2      	; 0x1640 <xTaskGenericCreate+0xf0>
    163e:	45 c0       	rjmp	.+138    	; 0x16ca <xTaskGenericCreate+0x17a>
    1640:	0f 2e       	mov	r0, r31
    1642:	fa ea       	ldi	r31, 0xAA	; 170
    1644:	ef 2e       	mov	r14, r31
    1646:	f8 e0       	ldi	r31, 0x08	; 8
    1648:	ff 2e       	mov	r15, r31
    164a:	f0 2d       	mov	r31, r0
    164c:	0f 2e       	mov	r0, r31
    164e:	f7 ed       	ldi	r31, 0xD7	; 215
    1650:	cf 2e       	mov	r12, r31
    1652:	f8 e0       	ldi	r31, 0x08	; 8
    1654:	df 2e       	mov	r13, r31
    1656:	f0 2d       	mov	r31, r0
    1658:	c7 01       	movw	r24, r14
    165a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    165e:	f9 e0       	ldi	r31, 0x09	; 9
    1660:	ef 0e       	add	r14, r31
    1662:	f1 1c       	adc	r15, r1
    1664:	ec 14       	cp	r14, r12
    1666:	fd 04       	cpc	r15, r13
    1668:	b9 f7       	brne	.-18     	; 0x1658 <xTaskGenericCreate+0x108>
    166a:	81 ea       	ldi	r24, 0xA1	; 161
    166c:	98 e0       	ldi	r25, 0x08	; 8
    166e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    1672:	88 e9       	ldi	r24, 0x98	; 152
    1674:	98 e0       	ldi	r25, 0x08	; 8
    1676:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    167a:	8b e8       	ldi	r24, 0x8B	; 139
    167c:	98 e0       	ldi	r25, 0x08	; 8
    167e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    1682:	82 e8       	ldi	r24, 0x82	; 130
    1684:	98 e0       	ldi	r25, 0x08	; 8
    1686:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    168a:	88 e7       	ldi	r24, 0x78	; 120
    168c:	98 e0       	ldi	r25, 0x08	; 8
    168e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <vListInitialise>
    1692:	81 ea       	ldi	r24, 0xA1	; 161
    1694:	98 e0       	ldi	r25, 0x08	; 8
    1696:	90 93 97 08 	sts	0x0897, r25
    169a:	80 93 96 08 	sts	0x0896, r24
    169e:	88 e9       	ldi	r24, 0x98	; 152
    16a0:	98 e0       	ldi	r25, 0x08	; 8
    16a2:	90 93 95 08 	sts	0x0895, r25
    16a6:	80 93 94 08 	sts	0x0894, r24
    16aa:	0f c0       	rjmp	.+30     	; 0x16ca <xTaskGenericCreate+0x17a>
    16ac:	80 91 73 08 	lds	r24, 0x0873
    16b0:	81 11       	cpse	r24, r1
    16b2:	0b c0       	rjmp	.+22     	; 0x16ca <xTaskGenericCreate+0x17a>
    16b4:	e0 91 d7 08 	lds	r30, 0x08D7
    16b8:	f0 91 d8 08 	lds	r31, 0x08D8
    16bc:	86 89       	ldd	r24, Z+22	; 0x16
    16be:	08 17       	cp	r16, r24
    16c0:	20 f0       	brcs	.+8      	; 0x16ca <xTaskGenericCreate+0x17a>
    16c2:	d0 93 d8 08 	sts	0x08D8, r29
    16c6:	c0 93 d7 08 	sts	0x08D7, r28
    16ca:	80 91 6f 08 	lds	r24, 0x086F
    16ce:	8f 5f       	subi	r24, 0xFF	; 255
    16d0:	80 93 6f 08 	sts	0x086F, r24
    16d4:	8e 89       	ldd	r24, Y+22	; 0x16
    16d6:	90 91 74 08 	lds	r25, 0x0874
    16da:	98 17       	cp	r25, r24
    16dc:	10 f4       	brcc	.+4      	; 0x16e2 <xTaskGenericCreate+0x192>
    16de:	80 93 74 08 	sts	0x0874, r24
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	9c 01       	movw	r18, r24
    16e6:	22 0f       	add	r18, r18
    16e8:	33 1f       	adc	r19, r19
    16ea:	22 0f       	add	r18, r18
    16ec:	33 1f       	adc	r19, r19
    16ee:	22 0f       	add	r18, r18
    16f0:	33 1f       	adc	r19, r19
    16f2:	82 0f       	add	r24, r18
    16f4:	93 1f       	adc	r25, r19
    16f6:	b5 01       	movw	r22, r10
    16f8:	86 55       	subi	r24, 0x56	; 86
    16fa:	97 4f       	sbci	r25, 0xF7	; 247
    16fc:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
    1704:	80 91 73 08 	lds	r24, 0x0873
    1708:	88 23       	and	r24, r24
    170a:	51 f0       	breq	.+20     	; 0x1720 <xTaskGenericCreate+0x1d0>
    170c:	e0 91 d7 08 	lds	r30, 0x08D7
    1710:	f0 91 d8 08 	lds	r31, 0x08D8
    1714:	86 89       	ldd	r24, Z+22	; 0x16
    1716:	80 17       	cp	r24, r16
    1718:	28 f4       	brcc	.+10     	; 0x1724 <xTaskGenericCreate+0x1d4>
    171a:	f5 da       	rcall	.-2582   	; 0xd06 <vPortYield>
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	1c c0       	rjmp	.+56     	; 0x1758 <xTaskGenericCreate+0x208>
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	1a c0       	rjmp	.+52     	; 0x1758 <xTaskGenericCreate+0x208>
    1724:	81 e0       	ldi	r24, 0x01	; 1
    1726:	18 c0       	rjmp	.+48     	; 0x1758 <xTaskGenericCreate+0x208>
    1728:	d8 8e       	std	Y+24, r13	; 0x18
    172a:	cf 8a       	std	Y+23, r12	; 0x17
    172c:	81 e0       	ldi	r24, 0x01	; 1
    172e:	48 1a       	sub	r4, r24
    1730:	51 08       	sbc	r5, r1
    1732:	cf 88       	ldd	r12, Y+23	; 0x17
    1734:	d8 8c       	ldd	r13, Y+24	; 0x18
    1736:	c4 0c       	add	r12, r4
    1738:	d5 1c       	adc	r13, r5
    173a:	d5 01       	movw	r26, r10
    173c:	8c 91       	ld	r24, X
    173e:	89 8f       	std	Y+25, r24	; 0x19
    1740:	8c 91       	ld	r24, X
    1742:	88 23       	and	r24, r24
    1744:	09 f4       	brne	.+2      	; 0x1748 <xTaskGenericCreate+0x1f8>
    1746:	3b cf       	rjmp	.-394    	; 0x15be <xTaskGenericCreate+0x6e>
    1748:	ae 01       	movw	r20, r28
    174a:	46 5e       	subi	r20, 0xE6	; 230
    174c:	5f 4f       	sbci	r21, 0xFF	; 255
    174e:	f5 01       	movw	r30, r10
    1750:	31 96       	adiw	r30, 0x01	; 1
    1752:	27 e0       	ldi	r18, 0x07	; 7
    1754:	29 cf       	rjmp	.-430    	; 0x15a8 <xTaskGenericCreate+0x58>
    1756:	8f ef       	ldi	r24, 0xFF	; 255
    1758:	df 91       	pop	r29
    175a:	cf 91       	pop	r28
    175c:	1f 91       	pop	r17
    175e:	0f 91       	pop	r16
    1760:	ff 90       	pop	r15
    1762:	ef 90       	pop	r14
    1764:	df 90       	pop	r13
    1766:	cf 90       	pop	r12
    1768:	bf 90       	pop	r11
    176a:	af 90       	pop	r10
    176c:	9f 90       	pop	r9
    176e:	8f 90       	pop	r8
    1770:	7f 90       	pop	r7
    1772:	6f 90       	pop	r6
    1774:	5f 90       	pop	r5
    1776:	4f 90       	pop	r4
    1778:	08 95       	ret

0000177a <vTaskResume>:
    177a:	0f 93       	push	r16
    177c:	1f 93       	push	r17
    177e:	cf 93       	push	r28
    1780:	df 93       	push	r29
    1782:	ec 01       	movw	r28, r24
    1784:	00 97       	sbiw	r24, 0x00	; 0
    1786:	09 f4       	brne	.+2      	; 0x178a <vTaskResume+0x10>
    1788:	3e c0       	rjmp	.+124    	; 0x1806 <vTaskResume+0x8c>
    178a:	80 91 d7 08 	lds	r24, 0x08D7
    178e:	90 91 d8 08 	lds	r25, 0x08D8
    1792:	c8 17       	cp	r28, r24
    1794:	d9 07       	cpc	r29, r25
    1796:	b9 f1       	breq	.+110    	; 0x1806 <vTaskResume+0x8c>
    1798:	0f b6       	in	r0, 0x3f	; 63
    179a:	f8 94       	cli
    179c:	0f 92       	push	r0
    179e:	8a 85       	ldd	r24, Y+10	; 0x0a
    17a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    17a2:	88 57       	subi	r24, 0x78	; 120
    17a4:	98 40       	sbci	r25, 0x08	; 8
    17a6:	69 f5       	brne	.+90     	; 0x1802 <vTaskResume+0x88>
    17a8:	8c 89       	ldd	r24, Y+20	; 0x14
    17aa:	9d 89       	ldd	r25, Y+21	; 0x15
    17ac:	28 e0       	ldi	r18, 0x08	; 8
    17ae:	8b 38       	cpi	r24, 0x8B	; 139
    17b0:	92 07       	cpc	r25, r18
    17b2:	39 f1       	breq	.+78     	; 0x1802 <vTaskResume+0x88>
    17b4:	89 2b       	or	r24, r25
    17b6:	29 f5       	brne	.+74     	; 0x1802 <vTaskResume+0x88>
    17b8:	8e 01       	movw	r16, r28
    17ba:	0e 5f       	subi	r16, 0xFE	; 254
    17bc:	1f 4f       	sbci	r17, 0xFF	; 255
    17be:	c8 01       	movw	r24, r16
    17c0:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    17c4:	8e 89       	ldd	r24, Y+22	; 0x16
    17c6:	90 91 74 08 	lds	r25, 0x0874
    17ca:	98 17       	cp	r25, r24
    17cc:	10 f4       	brcc	.+4      	; 0x17d2 <vTaskResume+0x58>
    17ce:	80 93 74 08 	sts	0x0874, r24
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	9c 01       	movw	r18, r24
    17d6:	22 0f       	add	r18, r18
    17d8:	33 1f       	adc	r19, r19
    17da:	22 0f       	add	r18, r18
    17dc:	33 1f       	adc	r19, r19
    17de:	22 0f       	add	r18, r18
    17e0:	33 1f       	adc	r19, r19
    17e2:	82 0f       	add	r24, r18
    17e4:	93 1f       	adc	r25, r19
    17e6:	b8 01       	movw	r22, r16
    17e8:	86 55       	subi	r24, 0x56	; 86
    17ea:	97 4f       	sbci	r25, 0xF7	; 247
    17ec:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    17f0:	e0 91 d7 08 	lds	r30, 0x08D7
    17f4:	f0 91 d8 08 	lds	r31, 0x08D8
    17f8:	9e 89       	ldd	r25, Y+22	; 0x16
    17fa:	86 89       	ldd	r24, Z+22	; 0x16
    17fc:	98 17       	cp	r25, r24
    17fe:	08 f0       	brcs	.+2      	; 0x1802 <vTaskResume+0x88>
    1800:	82 da       	rcall	.-2812   	; 0xd06 <vPortYield>
    1802:	0f 90       	pop	r0
    1804:	0f be       	out	0x3f, r0	; 63
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	08 95       	ret

00001810 <vTaskStartScheduler>:
    1810:	af 92       	push	r10
    1812:	bf 92       	push	r11
    1814:	cf 92       	push	r12
    1816:	df 92       	push	r13
    1818:	ef 92       	push	r14
    181a:	ff 92       	push	r15
    181c:	0f 93       	push	r16
    181e:	a1 2c       	mov	r10, r1
    1820:	b1 2c       	mov	r11, r1
    1822:	c1 2c       	mov	r12, r1
    1824:	d1 2c       	mov	r13, r1
    1826:	e1 2c       	mov	r14, r1
    1828:	f1 2c       	mov	r15, r1
    182a:	00 e0       	ldi	r16, 0x00	; 0
    182c:	20 e0       	ldi	r18, 0x00	; 0
    182e:	30 e0       	ldi	r19, 0x00	; 0
    1830:	45 e5       	ldi	r20, 0x55	; 85
    1832:	50 e0       	ldi	r21, 0x00	; 0
    1834:	69 e8       	ldi	r22, 0x89	; 137
    1836:	72 e0       	ldi	r23, 0x02	; 2
    1838:	8f ed       	ldi	r24, 0xDF	; 223
    183a:	9d e0       	ldi	r25, 0x0D	; 13
    183c:	89 de       	rcall	.-750    	; 0x1550 <xTaskGenericCreate>
    183e:	81 30       	cpi	r24, 0x01	; 1
    1840:	41 f4       	brne	.+16     	; 0x1852 <vTaskStartScheduler+0x42>
    1842:	f8 94       	cli
    1844:	80 93 73 08 	sts	0x0873, r24
    1848:	10 92 76 08 	sts	0x0876, r1
    184c:	10 92 75 08 	sts	0x0875, r1
    1850:	1d da       	rcall	.-3014   	; 0xc8c <xPortStartScheduler>
    1852:	0f 91       	pop	r16
    1854:	ff 90       	pop	r15
    1856:	ef 90       	pop	r14
    1858:	df 90       	pop	r13
    185a:	cf 90       	pop	r12
    185c:	bf 90       	pop	r11
    185e:	af 90       	pop	r10
    1860:	08 95       	ret

00001862 <vTaskSuspendAll>:
    1862:	80 91 6e 08 	lds	r24, 0x086E
    1866:	8f 5f       	subi	r24, 0xFF	; 255
    1868:	80 93 6e 08 	sts	0x086E, r24
    186c:	08 95       	ret

0000186e <xTaskGetTickCount>:
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	0f 92       	push	r0
    1874:	80 91 75 08 	lds	r24, 0x0875
    1878:	90 91 76 08 	lds	r25, 0x0876
    187c:	0f 90       	pop	r0
    187e:	0f be       	out	0x3f, r0	; 63
    1880:	08 95       	ret

00001882 <xTaskGetTickCountFromISR>:
    1882:	80 91 75 08 	lds	r24, 0x0875
    1886:	90 91 76 08 	lds	r25, 0x0876
    188a:	08 95       	ret

0000188c <xTaskIncrementTick>:
    188c:	cf 92       	push	r12
    188e:	df 92       	push	r13
    1890:	ef 92       	push	r14
    1892:	ff 92       	push	r15
    1894:	0f 93       	push	r16
    1896:	1f 93       	push	r17
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
    189c:	80 91 6e 08 	lds	r24, 0x086E
    18a0:	81 11       	cpse	r24, r1
    18a2:	99 c0       	rjmp	.+306    	; 0x19d6 <xTaskIncrementTick+0x14a>
    18a4:	80 91 75 08 	lds	r24, 0x0875
    18a8:	90 91 76 08 	lds	r25, 0x0876
    18ac:	01 96       	adiw	r24, 0x01	; 1
    18ae:	90 93 76 08 	sts	0x0876, r25
    18b2:	80 93 75 08 	sts	0x0875, r24
    18b6:	e0 90 75 08 	lds	r14, 0x0875
    18ba:	f0 90 76 08 	lds	r15, 0x0876
    18be:	e1 14       	cp	r14, r1
    18c0:	f1 04       	cpc	r15, r1
    18c2:	b1 f4       	brne	.+44     	; 0x18f0 <xTaskIncrementTick+0x64>
    18c4:	80 91 96 08 	lds	r24, 0x0896
    18c8:	90 91 97 08 	lds	r25, 0x0897
    18cc:	20 91 94 08 	lds	r18, 0x0894
    18d0:	30 91 95 08 	lds	r19, 0x0895
    18d4:	30 93 97 08 	sts	0x0897, r19
    18d8:	20 93 96 08 	sts	0x0896, r18
    18dc:	90 93 95 08 	sts	0x0895, r25
    18e0:	80 93 94 08 	sts	0x0894, r24
    18e4:	80 91 70 08 	lds	r24, 0x0870
    18e8:	8f 5f       	subi	r24, 0xFF	; 255
    18ea:	80 93 70 08 	sts	0x0870, r24
    18ee:	da dd       	rcall	.-1100   	; 0x14a4 <prvResetNextTaskUnblockTime>
    18f0:	80 91 04 02 	lds	r24, 0x0204
    18f4:	90 91 05 02 	lds	r25, 0x0205
    18f8:	e8 16       	cp	r14, r24
    18fa:	f9 06       	cpc	r15, r25
    18fc:	08 f4       	brcc	.+2      	; 0x1900 <xTaskIncrementTick+0x74>
    18fe:	54 c0       	rjmp	.+168    	; 0x19a8 <xTaskIncrementTick+0x11c>
    1900:	d1 2c       	mov	r13, r1
    1902:	cc 24       	eor	r12, r12
    1904:	c3 94       	inc	r12
    1906:	01 c0       	rjmp	.+2      	; 0x190a <xTaskIncrementTick+0x7e>
    1908:	dc 2c       	mov	r13, r12
    190a:	e0 91 96 08 	lds	r30, 0x0896
    190e:	f0 91 97 08 	lds	r31, 0x0897
    1912:	80 81       	ld	r24, Z
    1914:	81 11       	cpse	r24, r1
    1916:	07 c0       	rjmp	.+14     	; 0x1926 <xTaskIncrementTick+0x9a>
    1918:	8f ef       	ldi	r24, 0xFF	; 255
    191a:	9f ef       	ldi	r25, 0xFF	; 255
    191c:	90 93 05 02 	sts	0x0205, r25
    1920:	80 93 04 02 	sts	0x0204, r24
    1924:	42 c0       	rjmp	.+132    	; 0x19aa <xTaskIncrementTick+0x11e>
    1926:	e0 91 96 08 	lds	r30, 0x0896
    192a:	f0 91 97 08 	lds	r31, 0x0897
    192e:	05 80       	ldd	r0, Z+5	; 0x05
    1930:	f6 81       	ldd	r31, Z+6	; 0x06
    1932:	e0 2d       	mov	r30, r0
    1934:	c6 81       	ldd	r28, Z+6	; 0x06
    1936:	d7 81       	ldd	r29, Z+7	; 0x07
    1938:	2a 81       	ldd	r18, Y+2	; 0x02
    193a:	3b 81       	ldd	r19, Y+3	; 0x03
    193c:	e2 16       	cp	r14, r18
    193e:	f3 06       	cpc	r15, r19
    1940:	28 f4       	brcc	.+10     	; 0x194c <xTaskIncrementTick+0xc0>
    1942:	30 93 05 02 	sts	0x0205, r19
    1946:	20 93 04 02 	sts	0x0204, r18
    194a:	2f c0       	rjmp	.+94     	; 0x19aa <xTaskIncrementTick+0x11e>
    194c:	8e 01       	movw	r16, r28
    194e:	0e 5f       	subi	r16, 0xFE	; 254
    1950:	1f 4f       	sbci	r17, 0xFF	; 255
    1952:	c8 01       	movw	r24, r16
    1954:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1958:	8c 89       	ldd	r24, Y+20	; 0x14
    195a:	9d 89       	ldd	r25, Y+21	; 0x15
    195c:	89 2b       	or	r24, r25
    195e:	21 f0       	breq	.+8      	; 0x1968 <xTaskIncrementTick+0xdc>
    1960:	ce 01       	movw	r24, r28
    1962:	0c 96       	adiw	r24, 0x0c	; 12
    1964:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1968:	2e 89       	ldd	r18, Y+22	; 0x16
    196a:	80 91 74 08 	lds	r24, 0x0874
    196e:	82 17       	cp	r24, r18
    1970:	10 f4       	brcc	.+4      	; 0x1976 <xTaskIncrementTick+0xea>
    1972:	20 93 74 08 	sts	0x0874, r18
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	c9 01       	movw	r24, r18
    197a:	88 0f       	add	r24, r24
    197c:	99 1f       	adc	r25, r25
    197e:	88 0f       	add	r24, r24
    1980:	99 1f       	adc	r25, r25
    1982:	88 0f       	add	r24, r24
    1984:	99 1f       	adc	r25, r25
    1986:	82 0f       	add	r24, r18
    1988:	93 1f       	adc	r25, r19
    198a:	b8 01       	movw	r22, r16
    198c:	86 55       	subi	r24, 0x56	; 86
    198e:	97 4f       	sbci	r25, 0xF7	; 247
    1990:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1994:	e0 91 d7 08 	lds	r30, 0x08D7
    1998:	f0 91 d8 08 	lds	r31, 0x08D8
    199c:	9e 89       	ldd	r25, Y+22	; 0x16
    199e:	86 89       	ldd	r24, Z+22	; 0x16
    19a0:	98 17       	cp	r25, r24
    19a2:	08 f0       	brcs	.+2      	; 0x19a6 <xTaskIncrementTick+0x11a>
    19a4:	b1 cf       	rjmp	.-158    	; 0x1908 <xTaskIncrementTick+0x7c>
    19a6:	b1 cf       	rjmp	.-158    	; 0x190a <xTaskIncrementTick+0x7e>
    19a8:	d1 2c       	mov	r13, r1
    19aa:	e0 91 d7 08 	lds	r30, 0x08D7
    19ae:	f0 91 d8 08 	lds	r31, 0x08D8
    19b2:	86 89       	ldd	r24, Z+22	; 0x16
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	fc 01       	movw	r30, r24
    19b8:	ee 0f       	add	r30, r30
    19ba:	ff 1f       	adc	r31, r31
    19bc:	ee 0f       	add	r30, r30
    19be:	ff 1f       	adc	r31, r31
    19c0:	ee 0f       	add	r30, r30
    19c2:	ff 1f       	adc	r31, r31
    19c4:	8e 0f       	add	r24, r30
    19c6:	9f 1f       	adc	r25, r31
    19c8:	fc 01       	movw	r30, r24
    19ca:	e6 55       	subi	r30, 0x56	; 86
    19cc:	f7 4f       	sbci	r31, 0xF7	; 247
    19ce:	80 81       	ld	r24, Z
    19d0:	82 30       	cpi	r24, 0x02	; 2
    19d2:	40 f4       	brcc	.+16     	; 0x19e4 <xTaskIncrementTick+0x158>
    19d4:	09 c0       	rjmp	.+18     	; 0x19e8 <xTaskIncrementTick+0x15c>
    19d6:	80 91 72 08 	lds	r24, 0x0872
    19da:	8f 5f       	subi	r24, 0xFF	; 255
    19dc:	80 93 72 08 	sts	0x0872, r24
    19e0:	d1 2c       	mov	r13, r1
    19e2:	02 c0       	rjmp	.+4      	; 0x19e8 <xTaskIncrementTick+0x15c>
    19e4:	dd 24       	eor	r13, r13
    19e6:	d3 94       	inc	r13
    19e8:	80 91 71 08 	lds	r24, 0x0871
    19ec:	88 23       	and	r24, r24
    19ee:	11 f0       	breq	.+4      	; 0x19f4 <xTaskIncrementTick+0x168>
    19f0:	dd 24       	eor	r13, r13
    19f2:	d3 94       	inc	r13
    19f4:	8d 2d       	mov	r24, r13
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	ff 90       	pop	r15
    1a00:	ef 90       	pop	r14
    1a02:	df 90       	pop	r13
    1a04:	cf 90       	pop	r12
    1a06:	08 95       	ret

00001a08 <xTaskResumeAll>:
    1a08:	df 92       	push	r13
    1a0a:	ef 92       	push	r14
    1a0c:	ff 92       	push	r15
    1a0e:	0f 93       	push	r16
    1a10:	1f 93       	push	r17
    1a12:	cf 93       	push	r28
    1a14:	df 93       	push	r29
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	0f 92       	push	r0
    1a1c:	80 91 6e 08 	lds	r24, 0x086E
    1a20:	81 50       	subi	r24, 0x01	; 1
    1a22:	80 93 6e 08 	sts	0x086E, r24
    1a26:	80 91 6e 08 	lds	r24, 0x086E
    1a2a:	81 11       	cpse	r24, r1
    1a2c:	5f c0       	rjmp	.+190    	; 0x1aec <xTaskResumeAll+0xe4>
    1a2e:	80 91 77 08 	lds	r24, 0x0877
    1a32:	88 23       	and	r24, r24
    1a34:	09 f4       	brne	.+2      	; 0x1a38 <xTaskResumeAll+0x30>
    1a36:	5c c0       	rjmp	.+184    	; 0x1af0 <xTaskResumeAll+0xe8>
    1a38:	0f 2e       	mov	r0, r31
    1a3a:	fb e8       	ldi	r31, 0x8B	; 139
    1a3c:	ef 2e       	mov	r14, r31
    1a3e:	f8 e0       	ldi	r31, 0x08	; 8
    1a40:	ff 2e       	mov	r15, r31
    1a42:	f0 2d       	mov	r31, r0
    1a44:	dd 24       	eor	r13, r13
    1a46:	d3 94       	inc	r13
    1a48:	30 c0       	rjmp	.+96     	; 0x1aaa <xTaskResumeAll+0xa2>
    1a4a:	e0 91 90 08 	lds	r30, 0x0890
    1a4e:	f0 91 91 08 	lds	r31, 0x0891
    1a52:	c6 81       	ldd	r28, Z+6	; 0x06
    1a54:	d7 81       	ldd	r29, Z+7	; 0x07
    1a56:	ce 01       	movw	r24, r28
    1a58:	0c 96       	adiw	r24, 0x0c	; 12
    1a5a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1a5e:	8e 01       	movw	r16, r28
    1a60:	0e 5f       	subi	r16, 0xFE	; 254
    1a62:	1f 4f       	sbci	r17, 0xFF	; 255
    1a64:	c8 01       	movw	r24, r16
    1a66:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1a6a:	8e 89       	ldd	r24, Y+22	; 0x16
    1a6c:	90 91 74 08 	lds	r25, 0x0874
    1a70:	98 17       	cp	r25, r24
    1a72:	10 f4       	brcc	.+4      	; 0x1a78 <xTaskResumeAll+0x70>
    1a74:	80 93 74 08 	sts	0x0874, r24
    1a78:	90 e0       	ldi	r25, 0x00	; 0
    1a7a:	9c 01       	movw	r18, r24
    1a7c:	22 0f       	add	r18, r18
    1a7e:	33 1f       	adc	r19, r19
    1a80:	22 0f       	add	r18, r18
    1a82:	33 1f       	adc	r19, r19
    1a84:	22 0f       	add	r18, r18
    1a86:	33 1f       	adc	r19, r19
    1a88:	82 0f       	add	r24, r18
    1a8a:	93 1f       	adc	r25, r19
    1a8c:	b8 01       	movw	r22, r16
    1a8e:	86 55       	subi	r24, 0x56	; 86
    1a90:	97 4f       	sbci	r25, 0xF7	; 247
    1a92:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1a96:	e0 91 d7 08 	lds	r30, 0x08D7
    1a9a:	f0 91 d8 08 	lds	r31, 0x08D8
    1a9e:	9e 89       	ldd	r25, Y+22	; 0x16
    1aa0:	86 89       	ldd	r24, Z+22	; 0x16
    1aa2:	98 17       	cp	r25, r24
    1aa4:	10 f0       	brcs	.+4      	; 0x1aaa <xTaskResumeAll+0xa2>
    1aa6:	d0 92 71 08 	sts	0x0871, r13
    1aaa:	f7 01       	movw	r30, r14
    1aac:	80 81       	ld	r24, Z
    1aae:	81 11       	cpse	r24, r1
    1ab0:	cc cf       	rjmp	.-104    	; 0x1a4a <xTaskResumeAll+0x42>
    1ab2:	80 91 72 08 	lds	r24, 0x0872
    1ab6:	88 23       	and	r24, r24
    1ab8:	91 f0       	breq	.+36     	; 0x1ade <xTaskResumeAll+0xd6>
    1aba:	80 91 72 08 	lds	r24, 0x0872
    1abe:	88 23       	and	r24, r24
    1ac0:	71 f0       	breq	.+28     	; 0x1ade <xTaskResumeAll+0xd6>
    1ac2:	c1 e0       	ldi	r28, 0x01	; 1
    1ac4:	e3 de       	rcall	.-570    	; 0x188c <xTaskIncrementTick>
    1ac6:	81 11       	cpse	r24, r1
    1ac8:	c0 93 71 08 	sts	0x0871, r28
    1acc:	80 91 72 08 	lds	r24, 0x0872
    1ad0:	81 50       	subi	r24, 0x01	; 1
    1ad2:	80 93 72 08 	sts	0x0872, r24
    1ad6:	80 91 72 08 	lds	r24, 0x0872
    1ada:	81 11       	cpse	r24, r1
    1adc:	f3 cf       	rjmp	.-26     	; 0x1ac4 <xTaskResumeAll+0xbc>
    1ade:	80 91 71 08 	lds	r24, 0x0871
    1ae2:	81 30       	cpi	r24, 0x01	; 1
    1ae4:	39 f4       	brne	.+14     	; 0x1af4 <xTaskResumeAll+0xec>
    1ae6:	0f d9       	rcall	.-3554   	; 0xd06 <vPortYield>
    1ae8:	81 e0       	ldi	r24, 0x01	; 1
    1aea:	05 c0       	rjmp	.+10     	; 0x1af6 <xTaskResumeAll+0xee>
    1aec:	80 e0       	ldi	r24, 0x00	; 0
    1aee:	03 c0       	rjmp	.+6      	; 0x1af6 <xTaskResumeAll+0xee>
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <xTaskResumeAll+0xee>
    1af4:	80 e0       	ldi	r24, 0x00	; 0
    1af6:	0f 90       	pop	r0
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	ff 90       	pop	r15
    1b04:	ef 90       	pop	r14
    1b06:	df 90       	pop	r13
    1b08:	08 95       	ret

00001b0a <vTaskDelayUntil>:
    1b0a:	0f 93       	push	r16
    1b0c:	1f 93       	push	r17
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	8c 01       	movw	r16, r24
    1b14:	eb 01       	movw	r28, r22
    1b16:	a5 de       	rcall	.-694    	; 0x1862 <vTaskSuspendAll>
    1b18:	80 91 75 08 	lds	r24, 0x0875
    1b1c:	90 91 76 08 	lds	r25, 0x0876
    1b20:	f8 01       	movw	r30, r16
    1b22:	20 81       	ld	r18, Z
    1b24:	31 81       	ldd	r19, Z+1	; 0x01
    1b26:	c2 0f       	add	r28, r18
    1b28:	d3 1f       	adc	r29, r19
    1b2a:	82 17       	cp	r24, r18
    1b2c:	93 07       	cpc	r25, r19
    1b2e:	48 f4       	brcc	.+18     	; 0x1b42 <vTaskDelayUntil+0x38>
    1b30:	c2 17       	cp	r28, r18
    1b32:	d3 07       	cpc	r29, r19
    1b34:	f8 f4       	brcc	.+62     	; 0x1b74 <vTaskDelayUntil+0x6a>
    1b36:	d1 83       	std	Z+1, r29	; 0x01
    1b38:	c0 83       	st	Z, r28
    1b3a:	8c 17       	cp	r24, r28
    1b3c:	9d 07       	cpc	r25, r29
    1b3e:	88 f4       	brcc	.+34     	; 0x1b62 <vTaskDelayUntil+0x58>
    1b40:	07 c0       	rjmp	.+14     	; 0x1b50 <vTaskDelayUntil+0x46>
    1b42:	c2 17       	cp	r28, r18
    1b44:	d3 07       	cpc	r29, r19
    1b46:	90 f0       	brcs	.+36     	; 0x1b6c <vTaskDelayUntil+0x62>
    1b48:	8c 17       	cp	r24, r28
    1b4a:	9d 07       	cpc	r25, r29
    1b4c:	78 f0       	brcs	.+30     	; 0x1b6c <vTaskDelayUntil+0x62>
    1b4e:	12 c0       	rjmp	.+36     	; 0x1b74 <vTaskDelayUntil+0x6a>
    1b50:	80 91 d7 08 	lds	r24, 0x08D7
    1b54:	90 91 d8 08 	lds	r25, 0x08D8
    1b58:	02 96       	adiw	r24, 0x02	; 2
    1b5a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1b5e:	ce 01       	movw	r24, r28
    1b60:	c0 dc       	rcall	.-1664   	; 0x14e2 <prvAddCurrentTaskToDelayedList>
    1b62:	52 df       	rcall	.-348    	; 0x1a08 <xTaskResumeAll>
    1b64:	81 11       	cpse	r24, r1
    1b66:	0a c0       	rjmp	.+20     	; 0x1b7c <vTaskDelayUntil+0x72>
    1b68:	ce d8       	rcall	.-3684   	; 0xd06 <vPortYield>
    1b6a:	08 c0       	rjmp	.+16     	; 0x1b7c <vTaskDelayUntil+0x72>
    1b6c:	f8 01       	movw	r30, r16
    1b6e:	d1 83       	std	Z+1, r29	; 0x01
    1b70:	c0 83       	st	Z, r28
    1b72:	ee cf       	rjmp	.-36     	; 0x1b50 <vTaskDelayUntil+0x46>
    1b74:	f8 01       	movw	r30, r16
    1b76:	d1 83       	std	Z+1, r29	; 0x01
    1b78:	c0 83       	st	Z, r28
    1b7a:	f3 cf       	rjmp	.-26     	; 0x1b62 <vTaskDelayUntil+0x58>
    1b7c:	df 91       	pop	r29
    1b7e:	cf 91       	pop	r28
    1b80:	1f 91       	pop	r17
    1b82:	0f 91       	pop	r16
    1b84:	08 95       	ret

00001b86 <vTaskDelay>:
    1b86:	cf 93       	push	r28
    1b88:	df 93       	push	r29
    1b8a:	ec 01       	movw	r28, r24
    1b8c:	00 97       	sbiw	r24, 0x00	; 0
    1b8e:	99 f0       	breq	.+38     	; 0x1bb6 <vTaskDelay+0x30>
    1b90:	68 de       	rcall	.-816    	; 0x1862 <vTaskSuspendAll>
    1b92:	80 91 75 08 	lds	r24, 0x0875
    1b96:	90 91 76 08 	lds	r25, 0x0876
    1b9a:	c8 0f       	add	r28, r24
    1b9c:	d9 1f       	adc	r29, r25
    1b9e:	80 91 d7 08 	lds	r24, 0x08D7
    1ba2:	90 91 d8 08 	lds	r25, 0x08D8
    1ba6:	02 96       	adiw	r24, 0x02	; 2
    1ba8:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1bac:	ce 01       	movw	r24, r28
    1bae:	99 dc       	rcall	.-1742   	; 0x14e2 <prvAddCurrentTaskToDelayedList>
    1bb0:	2b df       	rcall	.-426    	; 0x1a08 <xTaskResumeAll>
    1bb2:	81 11       	cpse	r24, r1
    1bb4:	01 c0       	rjmp	.+2      	; 0x1bb8 <vTaskDelay+0x32>
    1bb6:	a7 d8       	rcall	.-3762   	; 0xd06 <vPortYield>
    1bb8:	df 91       	pop	r29
    1bba:	cf 91       	pop	r28
    1bbc:	08 95       	ret

00001bbe <prvIdleTask>:
    1bbe:	0f 2e       	mov	r0, r31
    1bc0:	fa ea       	ldi	r31, 0xAA	; 170
    1bc2:	ef 2e       	mov	r14, r31
    1bc4:	f8 e0       	ldi	r31, 0x08	; 8
    1bc6:	ff 2e       	mov	r15, r31
    1bc8:	f0 2d       	mov	r31, r0
    1bca:	c2 e8       	ldi	r28, 0x82	; 130
    1bcc:	d8 e0       	ldi	r29, 0x08	; 8
    1bce:	26 c0       	rjmp	.+76     	; 0x1c1c <prvIdleTask+0x5e>
    1bd0:	48 de       	rcall	.-880    	; 0x1862 <vTaskSuspendAll>
    1bd2:	18 81       	ld	r17, Y
    1bd4:	19 df       	rcall	.-462    	; 0x1a08 <xTaskResumeAll>
    1bd6:	11 23       	and	r17, r17
    1bd8:	09 f1       	breq	.+66     	; 0x1c1c <prvIdleTask+0x5e>
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
    1be0:	e0 91 87 08 	lds	r30, 0x0887
    1be4:	f0 91 88 08 	lds	r31, 0x0888
    1be8:	06 81       	ldd	r16, Z+6	; 0x06
    1bea:	17 81       	ldd	r17, Z+7	; 0x07
    1bec:	c8 01       	movw	r24, r16
    1bee:	02 96       	adiw	r24, 0x02	; 2
    1bf0:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1bf4:	80 91 77 08 	lds	r24, 0x0877
    1bf8:	81 50       	subi	r24, 0x01	; 1
    1bfa:	80 93 77 08 	sts	0x0877, r24
    1bfe:	80 91 81 08 	lds	r24, 0x0881
    1c02:	81 50       	subi	r24, 0x01	; 1
    1c04:	80 93 81 08 	sts	0x0881, r24
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	f8 01       	movw	r30, r16
    1c0e:	87 89       	ldd	r24, Z+23	; 0x17
    1c10:	90 8d       	ldd	r25, Z+24	; 0x18
    1c12:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    1c16:	c8 01       	movw	r24, r16
    1c18:	0e 94 fe 01 	call	0x3fc	; 0x3fc <vPortFree>
    1c1c:	80 91 81 08 	lds	r24, 0x0881
    1c20:	81 11       	cpse	r24, r1
    1c22:	d6 cf       	rjmp	.-84     	; 0x1bd0 <prvIdleTask+0x12>
    1c24:	f7 01       	movw	r30, r14
    1c26:	80 81       	ld	r24, Z
    1c28:	82 30       	cpi	r24, 0x02	; 2
    1c2a:	c0 f3       	brcs	.-16     	; 0x1c1c <prvIdleTask+0x5e>
    1c2c:	6c d8       	rcall	.-3880   	; 0xd06 <vPortYield>
    1c2e:	f6 cf       	rjmp	.-20     	; 0x1c1c <prvIdleTask+0x5e>

00001c30 <vTaskSwitchContext>:
    1c30:	80 91 6e 08 	lds	r24, 0x086E
    1c34:	88 23       	and	r24, r24
    1c36:	21 f0       	breq	.+8      	; 0x1c40 <vTaskSwitchContext+0x10>
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	80 93 71 08 	sts	0x0871, r24
    1c3e:	08 95       	ret
    1c40:	10 92 71 08 	sts	0x0871, r1
    1c44:	80 91 74 08 	lds	r24, 0x0874
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	fc 01       	movw	r30, r24
    1c4c:	ee 0f       	add	r30, r30
    1c4e:	ff 1f       	adc	r31, r31
    1c50:	ee 0f       	add	r30, r30
    1c52:	ff 1f       	adc	r31, r31
    1c54:	ee 0f       	add	r30, r30
    1c56:	ff 1f       	adc	r31, r31
    1c58:	8e 0f       	add	r24, r30
    1c5a:	9f 1f       	adc	r25, r31
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	e6 55       	subi	r30, 0x56	; 86
    1c60:	f7 4f       	sbci	r31, 0xF7	; 247
    1c62:	80 81       	ld	r24, Z
    1c64:	81 11       	cpse	r24, r1
    1c66:	17 c0       	rjmp	.+46     	; 0x1c96 <vTaskSwitchContext+0x66>
    1c68:	80 91 74 08 	lds	r24, 0x0874
    1c6c:	81 50       	subi	r24, 0x01	; 1
    1c6e:	80 93 74 08 	sts	0x0874, r24
    1c72:	80 91 74 08 	lds	r24, 0x0874
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	fc 01       	movw	r30, r24
    1c7a:	ee 0f       	add	r30, r30
    1c7c:	ff 1f       	adc	r31, r31
    1c7e:	ee 0f       	add	r30, r30
    1c80:	ff 1f       	adc	r31, r31
    1c82:	ee 0f       	add	r30, r30
    1c84:	ff 1f       	adc	r31, r31
    1c86:	8e 0f       	add	r24, r30
    1c88:	9f 1f       	adc	r25, r31
    1c8a:	fc 01       	movw	r30, r24
    1c8c:	e6 55       	subi	r30, 0x56	; 86
    1c8e:	f7 4f       	sbci	r31, 0xF7	; 247
    1c90:	80 81       	ld	r24, Z
    1c92:	88 23       	and	r24, r24
    1c94:	49 f3       	breq	.-46     	; 0x1c68 <vTaskSwitchContext+0x38>
    1c96:	e0 91 74 08 	lds	r30, 0x0874
    1c9a:	f0 e0       	ldi	r31, 0x00	; 0
    1c9c:	cf 01       	movw	r24, r30
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	88 0f       	add	r24, r24
    1ca4:	99 1f       	adc	r25, r25
    1ca6:	88 0f       	add	r24, r24
    1ca8:	99 1f       	adc	r25, r25
    1caa:	e8 0f       	add	r30, r24
    1cac:	f9 1f       	adc	r31, r25
    1cae:	e6 55       	subi	r30, 0x56	; 86
    1cb0:	f7 4f       	sbci	r31, 0xF7	; 247
    1cb2:	a1 81       	ldd	r26, Z+1	; 0x01
    1cb4:	b2 81       	ldd	r27, Z+2	; 0x02
    1cb6:	12 96       	adiw	r26, 0x02	; 2
    1cb8:	0d 90       	ld	r0, X+
    1cba:	bc 91       	ld	r27, X
    1cbc:	a0 2d       	mov	r26, r0
    1cbe:	b2 83       	std	Z+2, r27	; 0x02
    1cc0:	a1 83       	std	Z+1, r26	; 0x01
    1cc2:	cf 01       	movw	r24, r30
    1cc4:	03 96       	adiw	r24, 0x03	; 3
    1cc6:	a8 17       	cp	r26, r24
    1cc8:	b9 07       	cpc	r27, r25
    1cca:	31 f4       	brne	.+12     	; 0x1cd8 <vTaskSwitchContext+0xa8>
    1ccc:	12 96       	adiw	r26, 0x02	; 2
    1cce:	8d 91       	ld	r24, X+
    1cd0:	9c 91       	ld	r25, X
    1cd2:	13 97       	sbiw	r26, 0x03	; 3
    1cd4:	92 83       	std	Z+2, r25	; 0x02
    1cd6:	81 83       	std	Z+1, r24	; 0x01
    1cd8:	01 80       	ldd	r0, Z+1	; 0x01
    1cda:	f2 81       	ldd	r31, Z+2	; 0x02
    1cdc:	e0 2d       	mov	r30, r0
    1cde:	86 81       	ldd	r24, Z+6	; 0x06
    1ce0:	97 81       	ldd	r25, Z+7	; 0x07
    1ce2:	90 93 d8 08 	sts	0x08D8, r25
    1ce6:	80 93 d7 08 	sts	0x08D7, r24
    1cea:	08 95       	ret

00001cec <vTaskSuspend>:
    1cec:	0f 93       	push	r16
    1cee:	1f 93       	push	r17
    1cf0:	cf 93       	push	r28
    1cf2:	df 93       	push	r29
    1cf4:	ec 01       	movw	r28, r24
    1cf6:	0f b6       	in	r0, 0x3f	; 63
    1cf8:	f8 94       	cli
    1cfa:	0f 92       	push	r0
    1cfc:	00 97       	sbiw	r24, 0x00	; 0
    1cfe:	21 f4       	brne	.+8      	; 0x1d08 <vTaskSuspend+0x1c>
    1d00:	c0 91 d7 08 	lds	r28, 0x08D7
    1d04:	d0 91 d8 08 	lds	r29, 0x08D8
    1d08:	8e 01       	movw	r16, r28
    1d0a:	0e 5f       	subi	r16, 0xFE	; 254
    1d0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0e:	c8 01       	movw	r24, r16
    1d10:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1d14:	8c 89       	ldd	r24, Y+20	; 0x14
    1d16:	9d 89       	ldd	r25, Y+21	; 0x15
    1d18:	89 2b       	or	r24, r25
    1d1a:	21 f0       	breq	.+8      	; 0x1d24 <vTaskSuspend+0x38>
    1d1c:	ce 01       	movw	r24, r28
    1d1e:	0c 96       	adiw	r24, 0x0c	; 12
    1d20:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1d24:	b8 01       	movw	r22, r16
    1d26:	88 e7       	ldi	r24, 0x78	; 120
    1d28:	98 e0       	ldi	r25, 0x08	; 8
    1d2a:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1d2e:	0f 90       	pop	r0
    1d30:	0f be       	out	0x3f, r0	; 63
    1d32:	80 91 d7 08 	lds	r24, 0x08D7
    1d36:	90 91 d8 08 	lds	r25, 0x08D8
    1d3a:	c8 17       	cp	r28, r24
    1d3c:	d9 07       	cpc	r29, r25
    1d3e:	a1 f4       	brne	.+40     	; 0x1d68 <vTaskSuspend+0x7c>
    1d40:	80 91 73 08 	lds	r24, 0x0873
    1d44:	88 23       	and	r24, r24
    1d46:	19 f0       	breq	.+6      	; 0x1d4e <vTaskSuspend+0x62>
    1d48:	0e 94 83 06 	call	0xd06	; 0xd06 <vPortYield>
    1d4c:	17 c0       	rjmp	.+46     	; 0x1d7c <vTaskSuspend+0x90>
    1d4e:	80 91 77 08 	lds	r24, 0x0877
    1d52:	90 91 78 08 	lds	r25, 0x0878
    1d56:	98 13       	cpse	r25, r24
    1d58:	05 c0       	rjmp	.+10     	; 0x1d64 <vTaskSuspend+0x78>
    1d5a:	10 92 d8 08 	sts	0x08D8, r1
    1d5e:	10 92 d7 08 	sts	0x08D7, r1
    1d62:	0c c0       	rjmp	.+24     	; 0x1d7c <vTaskSuspend+0x90>
    1d64:	65 df       	rcall	.-310    	; 0x1c30 <vTaskSwitchContext>
    1d66:	0a c0       	rjmp	.+20     	; 0x1d7c <vTaskSuspend+0x90>
    1d68:	80 91 73 08 	lds	r24, 0x0873
    1d6c:	88 23       	and	r24, r24
    1d6e:	31 f0       	breq	.+12     	; 0x1d7c <vTaskSuspend+0x90>
    1d70:	0f b6       	in	r0, 0x3f	; 63
    1d72:	f8 94       	cli
    1d74:	0f 92       	push	r0
    1d76:	96 db       	rcall	.-2260   	; 0x14a4 <prvResetNextTaskUnblockTime>
    1d78:	0f 90       	pop	r0
    1d7a:	0f be       	out	0x3f, r0	; 63
    1d7c:	df 91       	pop	r29
    1d7e:	cf 91       	pop	r28
    1d80:	1f 91       	pop	r17
    1d82:	0f 91       	pop	r16
    1d84:	08 95       	ret

00001d86 <vTaskPlaceOnEventList>:
    1d86:	cf 93       	push	r28
    1d88:	df 93       	push	r29
    1d8a:	eb 01       	movw	r28, r22
    1d8c:	60 91 d7 08 	lds	r22, 0x08D7
    1d90:	70 91 d8 08 	lds	r23, 0x08D8
    1d94:	64 5f       	subi	r22, 0xF4	; 244
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	0e 94 32 02 	call	0x464	; 0x464 <vListInsert>
    1d9c:	80 91 d7 08 	lds	r24, 0x08D7
    1da0:	90 91 d8 08 	lds	r25, 0x08D8
    1da4:	02 96       	adiw	r24, 0x02	; 2
    1da6:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1daa:	cf 3f       	cpi	r28, 0xFF	; 255
    1dac:	8f ef       	ldi	r24, 0xFF	; 255
    1dae:	d8 07       	cpc	r29, r24
    1db0:	59 f4       	brne	.+22     	; 0x1dc8 <vTaskPlaceOnEventList+0x42>
    1db2:	60 91 d7 08 	lds	r22, 0x08D7
    1db6:	70 91 d8 08 	lds	r23, 0x08D8
    1dba:	6e 5f       	subi	r22, 0xFE	; 254
    1dbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1dbe:	88 e7       	ldi	r24, 0x78	; 120
    1dc0:	98 e0       	ldi	r25, 0x08	; 8
    1dc2:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1dc6:	07 c0       	rjmp	.+14     	; 0x1dd6 <vTaskPlaceOnEventList+0x50>
    1dc8:	80 91 75 08 	lds	r24, 0x0875
    1dcc:	90 91 76 08 	lds	r25, 0x0876
    1dd0:	8c 0f       	add	r24, r28
    1dd2:	9d 1f       	adc	r25, r29
    1dd4:	86 db       	rcall	.-2292   	; 0x14e2 <prvAddCurrentTaskToDelayedList>
    1dd6:	df 91       	pop	r29
    1dd8:	cf 91       	pop	r28
    1dda:	08 95       	ret

00001ddc <xTaskRemoveFromEventList>:
    1ddc:	0f 93       	push	r16
    1dde:	1f 93       	push	r17
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	dc 01       	movw	r26, r24
    1de6:	15 96       	adiw	r26, 0x05	; 5
    1de8:	ed 91       	ld	r30, X+
    1dea:	fc 91       	ld	r31, X
    1dec:	16 97       	sbiw	r26, 0x06	; 6
    1dee:	c6 81       	ldd	r28, Z+6	; 0x06
    1df0:	d7 81       	ldd	r29, Z+7	; 0x07
    1df2:	8e 01       	movw	r16, r28
    1df4:	04 5f       	subi	r16, 0xF4	; 244
    1df6:	1f 4f       	sbci	r17, 0xFF	; 255
    1df8:	c8 01       	movw	r24, r16
    1dfa:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1dfe:	80 91 6e 08 	lds	r24, 0x086E
    1e02:	81 11       	cpse	r24, r1
    1e04:	1c c0       	rjmp	.+56     	; 0x1e3e <xTaskRemoveFromEventList+0x62>
    1e06:	0a 50       	subi	r16, 0x0A	; 10
    1e08:	11 09       	sbc	r17, r1
    1e0a:	c8 01       	movw	r24, r16
    1e0c:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1e10:	8e 89       	ldd	r24, Y+22	; 0x16
    1e12:	90 91 74 08 	lds	r25, 0x0874
    1e16:	98 17       	cp	r25, r24
    1e18:	10 f4       	brcc	.+4      	; 0x1e1e <xTaskRemoveFromEventList+0x42>
    1e1a:	80 93 74 08 	sts	0x0874, r24
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	9c 01       	movw	r18, r24
    1e22:	22 0f       	add	r18, r18
    1e24:	33 1f       	adc	r19, r19
    1e26:	22 0f       	add	r18, r18
    1e28:	33 1f       	adc	r19, r19
    1e2a:	22 0f       	add	r18, r18
    1e2c:	33 1f       	adc	r19, r19
    1e2e:	82 0f       	add	r24, r18
    1e30:	93 1f       	adc	r25, r19
    1e32:	b8 01       	movw	r22, r16
    1e34:	86 55       	subi	r24, 0x56	; 86
    1e36:	97 4f       	sbci	r25, 0xF7	; 247
    1e38:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1e3c:	05 c0       	rjmp	.+10     	; 0x1e48 <xTaskRemoveFromEventList+0x6c>
    1e3e:	b8 01       	movw	r22, r16
    1e40:	8b e8       	ldi	r24, 0x8B	; 139
    1e42:	98 e0       	ldi	r25, 0x08	; 8
    1e44:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1e48:	e0 91 d7 08 	lds	r30, 0x08D7
    1e4c:	f0 91 d8 08 	lds	r31, 0x08D8
    1e50:	9e 89       	ldd	r25, Y+22	; 0x16
    1e52:	86 89       	ldd	r24, Z+22	; 0x16
    1e54:	89 17       	cp	r24, r25
    1e56:	20 f4       	brcc	.+8      	; 0x1e60 <xTaskRemoveFromEventList+0x84>
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	80 93 71 08 	sts	0x0871, r24
    1e5e:	01 c0       	rjmp	.+2      	; 0x1e62 <xTaskRemoveFromEventList+0x86>
    1e60:	80 e0       	ldi	r24, 0x00	; 0
    1e62:	df 91       	pop	r29
    1e64:	cf 91       	pop	r28
    1e66:	1f 91       	pop	r17
    1e68:	0f 91       	pop	r16
    1e6a:	08 95       	ret

00001e6c <vTaskSetTimeOutState>:
    1e6c:	20 91 70 08 	lds	r18, 0x0870
    1e70:	fc 01       	movw	r30, r24
    1e72:	20 83       	st	Z, r18
    1e74:	20 91 75 08 	lds	r18, 0x0875
    1e78:	30 91 76 08 	lds	r19, 0x0876
    1e7c:	32 83       	std	Z+2, r19	; 0x02
    1e7e:	21 83       	std	Z+1, r18	; 0x01
    1e80:	08 95       	ret

00001e82 <xTaskCheckForTimeOut>:
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	0f 92       	push	r0
    1e88:	40 91 75 08 	lds	r20, 0x0875
    1e8c:	50 91 76 08 	lds	r21, 0x0876
    1e90:	db 01       	movw	r26, r22
    1e92:	2d 91       	ld	r18, X+
    1e94:	3c 91       	ld	r19, X
    1e96:	2f 3f       	cpi	r18, 0xFF	; 255
    1e98:	bf ef       	ldi	r27, 0xFF	; 255
    1e9a:	3b 07       	cpc	r19, r27
    1e9c:	11 f1       	breq	.+68     	; 0x1ee2 <xTaskCheckForTimeOut+0x60>
    1e9e:	e0 91 70 08 	lds	r30, 0x0870
    1ea2:	dc 01       	movw	r26, r24
    1ea4:	fc 91       	ld	r31, X
    1ea6:	fe 17       	cp	r31, r30
    1ea8:	39 f0       	breq	.+14     	; 0x1eb8 <xTaskCheckForTimeOut+0x36>
    1eaa:	11 96       	adiw	r26, 0x01	; 1
    1eac:	ed 91       	ld	r30, X+
    1eae:	fc 91       	ld	r31, X
    1eb0:	12 97       	sbiw	r26, 0x02	; 2
    1eb2:	4e 17       	cp	r20, r30
    1eb4:	5f 07       	cpc	r21, r31
    1eb6:	b8 f4       	brcc	.+46     	; 0x1ee6 <xTaskCheckForTimeOut+0x64>
    1eb8:	dc 01       	movw	r26, r24
    1eba:	11 96       	adiw	r26, 0x01	; 1
    1ebc:	ed 91       	ld	r30, X+
    1ebe:	fc 91       	ld	r31, X
    1ec0:	12 97       	sbiw	r26, 0x02	; 2
    1ec2:	da 01       	movw	r26, r20
    1ec4:	ae 1b       	sub	r26, r30
    1ec6:	bf 0b       	sbc	r27, r31
    1ec8:	a2 17       	cp	r26, r18
    1eca:	b3 07       	cpc	r27, r19
    1ecc:	70 f4       	brcc	.+28     	; 0x1eea <xTaskCheckForTimeOut+0x68>
    1ece:	e4 1b       	sub	r30, r20
    1ed0:	f5 0b       	sbc	r31, r21
    1ed2:	2e 0f       	add	r18, r30
    1ed4:	3f 1f       	adc	r19, r31
    1ed6:	fb 01       	movw	r30, r22
    1ed8:	31 83       	std	Z+1, r19	; 0x01
    1eda:	20 83       	st	Z, r18
    1edc:	c7 df       	rcall	.-114    	; 0x1e6c <vTaskSetTimeOutState>
    1ede:	80 e0       	ldi	r24, 0x00	; 0
    1ee0:	05 c0       	rjmp	.+10     	; 0x1eec <xTaskCheckForTimeOut+0x6a>
    1ee2:	80 e0       	ldi	r24, 0x00	; 0
    1ee4:	03 c0       	rjmp	.+6      	; 0x1eec <xTaskCheckForTimeOut+0x6a>
    1ee6:	81 e0       	ldi	r24, 0x01	; 1
    1ee8:	01 c0       	rjmp	.+2      	; 0x1eec <xTaskCheckForTimeOut+0x6a>
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63
    1ef0:	08 95       	ret

00001ef2 <vTaskMissedYield>:
    1ef2:	81 e0       	ldi	r24, 0x01	; 1
    1ef4:	80 93 71 08 	sts	0x0871, r24
    1ef8:	08 95       	ret

00001efa <vTaskPriorityInherit>:
    1efa:	0f 93       	push	r16
    1efc:	1f 93       	push	r17
    1efe:	cf 93       	push	r28
    1f00:	df 93       	push	r29
    1f02:	ec 01       	movw	r28, r24
    1f04:	00 97       	sbiw	r24, 0x00	; 0
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <vTaskPriorityInherit+0x10>
    1f08:	51 c0       	rjmp	.+162    	; 0x1fac <vTaskPriorityInherit+0xb2>
    1f0a:	8e 89       	ldd	r24, Y+22	; 0x16
    1f0c:	e0 91 d7 08 	lds	r30, 0x08D7
    1f10:	f0 91 d8 08 	lds	r31, 0x08D8
    1f14:	96 89       	ldd	r25, Z+22	; 0x16
    1f16:	89 17       	cp	r24, r25
    1f18:	08 f0       	brcs	.+2      	; 0x1f1c <vTaskPriorityInherit+0x22>
    1f1a:	48 c0       	rjmp	.+144    	; 0x1fac <vTaskPriorityInherit+0xb2>
    1f1c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f1e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f20:	33 23       	and	r19, r19
    1f22:	5c f0       	brlt	.+22     	; 0x1f3a <vTaskPriorityInherit+0x40>
    1f24:	e0 91 d7 08 	lds	r30, 0x08D7
    1f28:	f0 91 d8 08 	lds	r31, 0x08D8
    1f2c:	96 89       	ldd	r25, Z+22	; 0x16
    1f2e:	25 e0       	ldi	r18, 0x05	; 5
    1f30:	30 e0       	ldi	r19, 0x00	; 0
    1f32:	29 1b       	sub	r18, r25
    1f34:	31 09       	sbc	r19, r1
    1f36:	3d 87       	std	Y+13, r19	; 0x0d
    1f38:	2c 87       	std	Y+12, r18	; 0x0c
    1f3a:	90 e0       	ldi	r25, 0x00	; 0
    1f3c:	9c 01       	movw	r18, r24
    1f3e:	22 0f       	add	r18, r18
    1f40:	33 1f       	adc	r19, r19
    1f42:	22 0f       	add	r18, r18
    1f44:	33 1f       	adc	r19, r19
    1f46:	22 0f       	add	r18, r18
    1f48:	33 1f       	adc	r19, r19
    1f4a:	82 0f       	add	r24, r18
    1f4c:	93 1f       	adc	r25, r19
    1f4e:	86 55       	subi	r24, 0x56	; 86
    1f50:	97 4f       	sbci	r25, 0xF7	; 247
    1f52:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f54:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f56:	28 17       	cp	r18, r24
    1f58:	39 07       	cpc	r19, r25
    1f5a:	11 f5       	brne	.+68     	; 0x1fa0 <vTaskPriorityInherit+0xa6>
    1f5c:	8e 01       	movw	r16, r28
    1f5e:	0e 5f       	subi	r16, 0xFE	; 254
    1f60:	1f 4f       	sbci	r17, 0xFF	; 255
    1f62:	c8 01       	movw	r24, r16
    1f64:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1f68:	e0 91 d7 08 	lds	r30, 0x08D7
    1f6c:	f0 91 d8 08 	lds	r31, 0x08D8
    1f70:	86 89       	ldd	r24, Z+22	; 0x16
    1f72:	8e 8b       	std	Y+22, r24	; 0x16
    1f74:	90 91 74 08 	lds	r25, 0x0874
    1f78:	98 17       	cp	r25, r24
    1f7a:	10 f4       	brcc	.+4      	; 0x1f80 <vTaskPriorityInherit+0x86>
    1f7c:	80 93 74 08 	sts	0x0874, r24
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	9c 01       	movw	r18, r24
    1f84:	22 0f       	add	r18, r18
    1f86:	33 1f       	adc	r19, r19
    1f88:	22 0f       	add	r18, r18
    1f8a:	33 1f       	adc	r19, r19
    1f8c:	22 0f       	add	r18, r18
    1f8e:	33 1f       	adc	r19, r19
    1f90:	82 0f       	add	r24, r18
    1f92:	93 1f       	adc	r25, r19
    1f94:	b8 01       	movw	r22, r16
    1f96:	86 55       	subi	r24, 0x56	; 86
    1f98:	97 4f       	sbci	r25, 0xF7	; 247
    1f9a:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    1f9e:	06 c0       	rjmp	.+12     	; 0x1fac <vTaskPriorityInherit+0xb2>
    1fa0:	e0 91 d7 08 	lds	r30, 0x08D7
    1fa4:	f0 91 d8 08 	lds	r31, 0x08D8
    1fa8:	86 89       	ldd	r24, Z+22	; 0x16
    1faa:	8e 8b       	std	Y+22, r24	; 0x16
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	1f 91       	pop	r17
    1fb2:	0f 91       	pop	r16
    1fb4:	08 95       	ret

00001fb6 <xTaskPriorityDisinherit>:
    1fb6:	0f 93       	push	r16
    1fb8:	1f 93       	push	r17
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
    1fbe:	ec 01       	movw	r28, r24
    1fc0:	00 97       	sbiw	r24, 0x00	; 0
    1fc2:	71 f1       	breq	.+92     	; 0x2020 <xTaskPriorityDisinherit+0x6a>
    1fc4:	8a a1       	ldd	r24, Y+34	; 0x22
    1fc6:	81 50       	subi	r24, 0x01	; 1
    1fc8:	8a a3       	std	Y+34, r24	; 0x22
    1fca:	2e 89       	ldd	r18, Y+22	; 0x16
    1fcc:	99 a1       	ldd	r25, Y+33	; 0x21
    1fce:	29 17       	cp	r18, r25
    1fd0:	49 f1       	breq	.+82     	; 0x2024 <xTaskPriorityDisinherit+0x6e>
    1fd2:	81 11       	cpse	r24, r1
    1fd4:	29 c0       	rjmp	.+82     	; 0x2028 <xTaskPriorityDisinherit+0x72>
    1fd6:	8e 01       	movw	r16, r28
    1fd8:	0e 5f       	subi	r16, 0xFE	; 254
    1fda:	1f 4f       	sbci	r17, 0xFF	; 255
    1fdc:	c8 01       	movw	r24, r16
    1fde:	0e 94 63 02 	call	0x4c6	; 0x4c6 <uxListRemove>
    1fe2:	89 a1       	ldd	r24, Y+33	; 0x21
    1fe4:	8e 8b       	std	Y+22, r24	; 0x16
    1fe6:	25 e0       	ldi	r18, 0x05	; 5
    1fe8:	30 e0       	ldi	r19, 0x00	; 0
    1fea:	28 1b       	sub	r18, r24
    1fec:	31 09       	sbc	r19, r1
    1fee:	3d 87       	std	Y+13, r19	; 0x0d
    1ff0:	2c 87       	std	Y+12, r18	; 0x0c
    1ff2:	90 91 74 08 	lds	r25, 0x0874
    1ff6:	98 17       	cp	r25, r24
    1ff8:	10 f4       	brcc	.+4      	; 0x1ffe <xTaskPriorityDisinherit+0x48>
    1ffa:	80 93 74 08 	sts	0x0874, r24
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	9c 01       	movw	r18, r24
    2002:	22 0f       	add	r18, r18
    2004:	33 1f       	adc	r19, r19
    2006:	22 0f       	add	r18, r18
    2008:	33 1f       	adc	r19, r19
    200a:	22 0f       	add	r18, r18
    200c:	33 1f       	adc	r19, r19
    200e:	82 0f       	add	r24, r18
    2010:	93 1f       	adc	r25, r19
    2012:	b8 01       	movw	r22, r16
    2014:	86 55       	subi	r24, 0x56	; 86
    2016:	97 4f       	sbci	r25, 0xF7	; 247
    2018:	0e 94 11 02 	call	0x422	; 0x422 <vListInsertEnd>
    201c:	81 e0       	ldi	r24, 0x01	; 1
    201e:	05 c0       	rjmp	.+10     	; 0x202a <xTaskPriorityDisinherit+0x74>
    2020:	80 e0       	ldi	r24, 0x00	; 0
    2022:	03 c0       	rjmp	.+6      	; 0x202a <xTaskPriorityDisinherit+0x74>
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	01 c0       	rjmp	.+2      	; 0x202a <xTaskPriorityDisinherit+0x74>
    2028:	80 e0       	ldi	r24, 0x00	; 0
    202a:	df 91       	pop	r29
    202c:	cf 91       	pop	r28
    202e:	1f 91       	pop	r17
    2030:	0f 91       	pop	r16
    2032:	08 95       	ret

00002034 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2034:	80 91 d7 08 	lds	r24, 0x08D7
    2038:	90 91 d8 08 	lds	r25, 0x08D8
    203c:	89 2b       	or	r24, r25
    203e:	39 f0       	breq	.+14     	; 0x204e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2040:	e0 91 d7 08 	lds	r30, 0x08D7
    2044:	f0 91 d8 08 	lds	r31, 0x08D8
    2048:	82 a1       	ldd	r24, Z+34	; 0x22
    204a:	8f 5f       	subi	r24, 0xFF	; 255
    204c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    204e:	80 91 d7 08 	lds	r24, 0x08D7
    2052:	90 91 d8 08 	lds	r25, 0x08D8
	}
    2056:	08 95       	ret

00002058 <__divmodhi4>:
    2058:	97 fb       	bst	r25, 7
    205a:	07 2e       	mov	r0, r23
    205c:	16 f4       	brtc	.+4      	; 0x2062 <__divmodhi4+0xa>
    205e:	00 94       	com	r0
    2060:	06 d0       	rcall	.+12     	; 0x206e <__divmodhi4_neg1>
    2062:	77 fd       	sbrc	r23, 7
    2064:	08 d0       	rcall	.+16     	; 0x2076 <__divmodhi4_neg2>
    2066:	0b d0       	rcall	.+22     	; 0x207e <__udivmodhi4>
    2068:	07 fc       	sbrc	r0, 7
    206a:	05 d0       	rcall	.+10     	; 0x2076 <__divmodhi4_neg2>
    206c:	3e f4       	brtc	.+14     	; 0x207c <__divmodhi4_exit>

0000206e <__divmodhi4_neg1>:
    206e:	90 95       	com	r25
    2070:	81 95       	neg	r24
    2072:	9f 4f       	sbci	r25, 0xFF	; 255
    2074:	08 95       	ret

00002076 <__divmodhi4_neg2>:
    2076:	70 95       	com	r23
    2078:	61 95       	neg	r22
    207a:	7f 4f       	sbci	r23, 0xFF	; 255

0000207c <__divmodhi4_exit>:
    207c:	08 95       	ret

0000207e <__udivmodhi4>:
    207e:	aa 1b       	sub	r26, r26
    2080:	bb 1b       	sub	r27, r27
    2082:	51 e1       	ldi	r21, 0x11	; 17
    2084:	07 c0       	rjmp	.+14     	; 0x2094 <__udivmodhi4_ep>

00002086 <__udivmodhi4_loop>:
    2086:	aa 1f       	adc	r26, r26
    2088:	bb 1f       	adc	r27, r27
    208a:	a6 17       	cp	r26, r22
    208c:	b7 07       	cpc	r27, r23
    208e:	10 f0       	brcs	.+4      	; 0x2094 <__udivmodhi4_ep>
    2090:	a6 1b       	sub	r26, r22
    2092:	b7 0b       	sbc	r27, r23

00002094 <__udivmodhi4_ep>:
    2094:	88 1f       	adc	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	5a 95       	dec	r21
    209a:	a9 f7       	brne	.-22     	; 0x2086 <__udivmodhi4_loop>
    209c:	80 95       	com	r24
    209e:	90 95       	com	r25
    20a0:	bc 01       	movw	r22, r24
    20a2:	cd 01       	movw	r24, r26
    20a4:	08 95       	ret

000020a6 <memcpy>:
    20a6:	fb 01       	movw	r30, r22
    20a8:	dc 01       	movw	r26, r24
    20aa:	02 c0       	rjmp	.+4      	; 0x20b0 <memcpy+0xa>
    20ac:	01 90       	ld	r0, Z+
    20ae:	0d 92       	st	X+, r0
    20b0:	41 50       	subi	r20, 0x01	; 1
    20b2:	50 40       	sbci	r21, 0x00	; 0
    20b4:	d8 f7       	brcc	.-10     	; 0x20ac <memcpy+0x6>
    20b6:	08 95       	ret

000020b8 <__itoa_ncheck>:
    20b8:	bb 27       	eor	r27, r27
    20ba:	4a 30       	cpi	r20, 0x0A	; 10
    20bc:	31 f4       	brne	.+12     	; 0x20ca <__itoa_ncheck+0x12>
    20be:	99 23       	and	r25, r25
    20c0:	22 f4       	brpl	.+8      	; 0x20ca <__itoa_ncheck+0x12>
    20c2:	bd e2       	ldi	r27, 0x2D	; 45
    20c4:	90 95       	com	r25
    20c6:	81 95       	neg	r24
    20c8:	9f 4f       	sbci	r25, 0xFF	; 255
    20ca:	01 c0       	rjmp	.+2      	; 0x20ce <__utoa_common>

000020cc <__utoa_ncheck>:
    20cc:	bb 27       	eor	r27, r27

000020ce <__utoa_common>:
    20ce:	fb 01       	movw	r30, r22
    20d0:	55 27       	eor	r21, r21
    20d2:	aa 27       	eor	r26, r26
    20d4:	88 0f       	add	r24, r24
    20d6:	99 1f       	adc	r25, r25
    20d8:	aa 1f       	adc	r26, r26
    20da:	a4 17       	cp	r26, r20
    20dc:	10 f0       	brcs	.+4      	; 0x20e2 <__utoa_common+0x14>
    20de:	a4 1b       	sub	r26, r20
    20e0:	83 95       	inc	r24
    20e2:	50 51       	subi	r21, 0x10	; 16
    20e4:	b9 f7       	brne	.-18     	; 0x20d4 <__utoa_common+0x6>
    20e6:	a0 5d       	subi	r26, 0xD0	; 208
    20e8:	aa 33       	cpi	r26, 0x3A	; 58
    20ea:	08 f0       	brcs	.+2      	; 0x20ee <__utoa_common+0x20>
    20ec:	a9 5d       	subi	r26, 0xD9	; 217
    20ee:	a1 93       	st	Z+, r26
    20f0:	00 97       	sbiw	r24, 0x00	; 0
    20f2:	79 f7       	brne	.-34     	; 0x20d2 <__utoa_common+0x4>
    20f4:	b1 11       	cpse	r27, r1
    20f6:	b1 93       	st	Z+, r27
    20f8:	11 92       	st	Z+, r1
    20fa:	cb 01       	movw	r24, r22
    20fc:	00 c0       	rjmp	.+0      	; 0x20fe <strrev>

000020fe <strrev>:
    20fe:	dc 01       	movw	r26, r24
    2100:	fc 01       	movw	r30, r24
    2102:	67 2f       	mov	r22, r23
    2104:	71 91       	ld	r23, Z+
    2106:	77 23       	and	r23, r23
    2108:	e1 f7       	brne	.-8      	; 0x2102 <strrev+0x4>
    210a:	32 97       	sbiw	r30, 0x02	; 2
    210c:	04 c0       	rjmp	.+8      	; 0x2116 <strrev+0x18>
    210e:	7c 91       	ld	r23, X
    2110:	6d 93       	st	X+, r22
    2112:	70 83       	st	Z, r23
    2114:	62 91       	ld	r22, -Z
    2116:	ae 17       	cp	r26, r30
    2118:	bf 07       	cpc	r27, r31
    211a:	c8 f3       	brcs	.-14     	; 0x210e <strrev+0x10>
    211c:	08 95       	ret

0000211e <_exit>:
    211e:	f8 94       	cli

00002120 <__stop_program>:
    2120:	ff cf       	rjmp	.-2      	; 0x2120 <__stop_program>
