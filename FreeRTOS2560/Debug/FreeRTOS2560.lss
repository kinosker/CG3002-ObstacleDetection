
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004e  00800200  000022a4  00002338  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000700  0080024e  0080024e  00002386  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002386  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b0  00000000  00000000  000023b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005235  00000000  00000000  00002866  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000013ee  00000000  00000000  00007a9b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000326a  00000000  00000000  00008e89  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d58  00000000  00000000  0000c0f4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001514  00000000  00000000  0000ce4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000037fa  00000000  00000000  0000e360  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000460  00000000  00000000  00011b5a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	ba c2       	rjmp	.+1396   	; 0x59a <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	db c7       	rjmp	.+4022   	; 0x100c <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	12 c5       	rjmp	.+2596   	; 0xa8a <__vector_25>
      66:	00 00       	nop
      68:	7e c5       	rjmp	.+2812   	; 0xb66 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	68 c3       	rjmp	.+1744   	; 0x746 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	c4 c4       	rjmp	.+2440   	; 0xa1a <__vector_36>
      92:	00 00       	nop
      94:	32 c5       	rjmp	.+2660   	; 0xafa <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e4 ea       	ldi	r30, 0xA4	; 164
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 34       	cpi	r26, 0x4E	; 78
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ae e4       	ldi	r26, 0x4E	; 78
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ae 34       	cpi	r26, 0x4E	; 78
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	34 d1       	rcall	.+616    	; 0x388 <main>
     120:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	f2 d5       	rcall	.+3044   	; 0xd0c <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	c0 d5       	rcall	.+2944   	; 0xcae <myUSART_transmitUSART0>
     12e:	fb cf       	rjmp	.-10     	; 0x126 <RPI_receiveTask>

00000130 <RPI_sendTask>:
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	00 d0       	rcall	.+0      	; 0x136 <RPI_sendTask+0x6>
     136:	00 d0       	rcall	.+0      	; 0x138 <RPI_sendTask+0x8>
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	4f ef       	ldi	r20, 0xFF	; 255
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	be 01       	movw	r22, r28
     144:	6a 5f       	subi	r22, 0xFA	; 250
     146:	7f 4f       	sbci	r23, 0xFF	; 255
     148:	80 91 99 08 	lds	r24, 0x0899
     14c:	90 91 9a 08 	lds	r25, 0x089A
     150:	0e 94 22 0a 	call	0x1444	; 0x1444 <xQueueGenericReceive>
     154:	8e 81       	ldd	r24, Y+6	; 0x06
     156:	9f ef       	ldi	r25, 0xFF	; 255
     158:	98 0f       	add	r25, r24
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	88 23       	and	r24, r24
     15e:	e9 f0       	breq	.+58     	; 0x19a <RPI_sendTask+0x6a>
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	be 01       	movw	r22, r28
     168:	6f 5f       	subi	r22, 0xFF	; 255
     16a:	7f 4f       	sbci	r23, 0xFF	; 255
     16c:	80 91 9b 08 	lds	r24, 0x089B
     170:	90 91 9c 08 	lds	r25, 0x089C
     174:	0e 94 22 0a 	call	0x1444	; 0x1444 <xQueueGenericReceive>
     178:	89 81       	ldd	r24, Y+1	; 0x01
     17a:	6b d5       	rcall	.+2774   	; 0xc52 <myUSART_transmitUSART0_c>
     17c:	8d e1       	ldi	r24, 0x1D	; 29
     17e:	92 e0       	ldi	r25, 0x02	; 2
     180:	96 d5       	rcall	.+2860   	; 0xcae <myUSART_transmitUSART0>
     182:	ce 01       	movw	r24, r28
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	93 d5       	rcall	.+2854   	; 0xcae <myUSART_transmitUSART0>
     188:	80 e2       	ldi	r24, 0x20	; 32
     18a:	92 e0       	ldi	r25, 0x02	; 2
     18c:	90 d5       	rcall	.+2848   	; 0xcae <myUSART_transmitUSART0>
     18e:	8e 81       	ldd	r24, Y+6	; 0x06
     190:	9f ef       	ldi	r25, 0xFF	; 255
     192:	98 0f       	add	r25, r24
     194:	9e 83       	std	Y+6, r25	; 0x06
     196:	81 11       	cpse	r24, r1
     198:	e3 cf       	rjmp	.-58     	; 0x160 <RPI_sendTask+0x30>
     19a:	8a e0       	ldi	r24, 0x0A	; 10
     19c:	5a d5       	rcall	.+2740   	; 0xc52 <myUSART_transmitUSART0_c>
     19e:	84 ef       	ldi	r24, 0xF4	; 244
     1a0:	91 e0       	ldi	r25, 0x01	; 1
     1a2:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vTaskDelay>
     1a6:	ca cf       	rjmp	.-108    	; 0x13c <RPI_sendTask+0xc>

000001a8 <myTimerTask>:
     1a8:	66 d3       	rcall	.+1740   	; 0x876 <myTimer_Init>
     1aa:	c8 d3       	rcall	.+1936   	; 0x93c <myTimer_DelayChecker>
     1ac:	fe cf       	rjmp	.-4      	; 0x1aa <myTimerTask+0x2>

000001ae <obstacleSend>:
     1ae:	1f 93       	push	r17
     1b0:	cf 93       	push	r28
     1b2:	df 93       	push	r29
     1b4:	00 d0       	rcall	.+0      	; 0x1b6 <obstacleSend+0x8>
     1b6:	1f 92       	push	r1
     1b8:	1f 92       	push	r1
     1ba:	cd b7       	in	r28, 0x3d	; 61
     1bc:	de b7       	in	r29, 0x3e	; 62
     1be:	18 2f       	mov	r17, r24
     1c0:	cb 01       	movw	r24, r22
     1c2:	11 23       	and	r17, r17
     1c4:	99 f0       	breq	.+38     	; 0x1ec <obstacleSend+0x3e>
     1c6:	4a e0       	ldi	r20, 0x0A	; 10
     1c8:	be 01       	movw	r22, r28
     1ca:	6e 5f       	subi	r22, 0xFE	; 254
     1cc:	7f 4f       	sbci	r23, 0xFF	; 255
     1ce:	0e 94 1d 11 	call	0x223a	; 0x223a <__itoa_ncheck>
     1d2:	19 83       	std	Y+1, r17	; 0x01
     1d4:	20 e0       	ldi	r18, 0x00	; 0
     1d6:	4f ef       	ldi	r20, 0xFF	; 255
     1d8:	5f ef       	ldi	r21, 0xFF	; 255
     1da:	be 01       	movw	r22, r28
     1dc:	6f 5f       	subi	r22, 0xFF	; 255
     1de:	7f 4f       	sbci	r23, 0xFF	; 255
     1e0:	80 91 9b 08 	lds	r24, 0x089B
     1e4:	90 91 9c 08 	lds	r25, 0x089C
     1e8:	0e 94 2d 09 	call	0x125a	; 0x125a <xQueueGenericSend>
     1ec:	0f 90       	pop	r0
     1ee:	0f 90       	pop	r0
     1f0:	0f 90       	pop	r0
     1f2:	0f 90       	pop	r0
     1f4:	0f 90       	pop	r0
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	1f 91       	pop	r17
     1fc:	08 95       	ret

000001fe <Sonar_Task>:
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	00 d0       	rcall	.+0      	; 0x204 <Sonar_Task+0x6>
     204:	cd b7       	in	r28, 0x3d	; 61
     206:	de b7       	in	r29, 0x3e	; 62
     208:	1b 82       	std	Y+3, r1	; 0x03
     20a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <xTaskGetTickCount>
     20e:	9a 83       	std	Y+2, r25	; 0x02
     210:	89 83       	std	Y+1, r24	; 0x01
     212:	0f 2e       	mov	r0, r31
     214:	f8 e7       	ldi	r31, 0x78	; 120
     216:	6f 2e       	mov	r6, r31
     218:	f0 2d       	mov	r31, r0
     21a:	0f 2e       	mov	r0, r31
     21c:	f3 e0       	ldi	r31, 0x03	; 3
     21e:	7f 2e       	mov	r7, r31
     220:	f0 2d       	mov	r31, r0
     222:	68 94       	set
     224:	88 24       	eor	r8, r8
     226:	81 f8       	bld	r8, 1
     228:	99 24       	eor	r9, r9
     22a:	93 94       	inc	r9
     22c:	7c d2       	rcall	.+1272   	; 0x726 <myMaxSonar_Start>
     22e:	87 e2       	ldi	r24, 0x27	; 39
     230:	80 d2       	rcall	.+1280   	; 0x732 <myMaxSonar_Read>
     232:	7c 01       	movw	r14, r24
     234:	86 e2       	ldi	r24, 0x26	; 38
     236:	7d d2       	rcall	.+1274   	; 0x732 <myMaxSonar_Read>
     238:	6c 01       	movw	r12, r24
     23a:	85 e2       	ldi	r24, 0x25	; 37
     23c:	7a d2       	rcall	.+1268   	; 0x732 <myMaxSonar_Read>
     23e:	0a 97       	sbiw	r24, 0x0a	; 10
     240:	5c 01       	movw	r10, r24
     242:	82 e3       	ldi	r24, 0x32	; 50
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <vTaskDelay>
     24a:	4c d2       	rcall	.+1176   	; 0x6e4 <myHcSonar_Read>
     24c:	8c 01       	movw	r16, r24
     24e:	08 3e       	cpi	r16, 0xE8	; 232
     250:	83 e0       	ldi	r24, 0x03	; 3
     252:	18 07       	cpc	r17, r24
     254:	14 f0       	brlt	.+4      	; 0x25a <Sonar_Task+0x5c>
     256:	06 2d       	mov	r16, r6
     258:	17 2d       	mov	r17, r7
     25a:	e6 e4       	ldi	r30, 0x46	; 70
     25c:	ee 16       	cp	r14, r30
     25e:	f1 04       	cpc	r15, r1
     260:	14 f5       	brge	.+68     	; 0x2a6 <Sonar_Task+0xa8>
     262:	fd e2       	ldi	r31, 0x2D	; 45
     264:	cf 16       	cp	r12, r31
     266:	d1 04       	cpc	r13, r1
     268:	54 f4       	brge	.+20     	; 0x27e <Sonar_Task+0x80>
     26a:	8d e2       	ldi	r24, 0x2D	; 45
     26c:	a8 16       	cp	r10, r24
     26e:	b1 04       	cpc	r11, r1
     270:	34 f4       	brge	.+12     	; 0x27e <Sonar_Task+0x80>
     272:	74 9a       	sbi	0x0e, 4	; 14
     274:	f4 01       	movw	r30, r8
     276:	80 81       	ld	r24, Z
     278:	80 61       	ori	r24, 0x10	; 16
     27a:	80 83       	st	Z, r24
     27c:	19 c0       	rjmp	.+50     	; 0x2b0 <Sonar_Task+0xb2>
     27e:	c6 01       	movw	r24, r12
     280:	0a 97       	sbiw	r24, 0x0a	; 10
     282:	a8 16       	cp	r10, r24
     284:	b9 06       	cpc	r11, r25
     286:	34 f4       	brge	.+12     	; 0x294 <Sonar_Task+0x96>
     288:	f4 01       	movw	r30, r8
     28a:	80 81       	ld	r24, Z
     28c:	8f 7e       	andi	r24, 0xEF	; 239
     28e:	80 83       	st	Z, r24
     290:	74 9a       	sbi	0x0e, 4	; 14
     292:	0e c0       	rjmp	.+28     	; 0x2b0 <Sonar_Task+0xb2>
     294:	8a 15       	cp	r24, r10
     296:	9b 05       	cpc	r25, r11
     298:	5c f4       	brge	.+22     	; 0x2b0 <Sonar_Task+0xb2>
     29a:	74 98       	cbi	0x0e, 4	; 14
     29c:	f4 01       	movw	r30, r8
     29e:	80 81       	ld	r24, Z
     2a0:	80 61       	ori	r24, 0x10	; 16
     2a2:	80 83       	st	Z, r24
     2a4:	05 c0       	rjmp	.+10     	; 0x2b0 <Sonar_Task+0xb2>
     2a6:	f4 01       	movw	r30, r8
     2a8:	80 81       	ld	r24, Z
     2aa:	8f 7e       	andi	r24, 0xEF	; 239
     2ac:	80 83       	st	Z, r24
     2ae:	74 98       	cbi	0x0e, 4	; 14
     2b0:	8b 81       	ldd	r24, Y+3	; 0x03
     2b2:	8c 5f       	subi	r24, 0xFC	; 252
     2b4:	8b 83       	std	Y+3, r24	; 0x03
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4f ef       	ldi	r20, 0xFF	; 255
     2ba:	5f ef       	ldi	r21, 0xFF	; 255
     2bc:	be 01       	movw	r22, r28
     2be:	6d 5f       	subi	r22, 0xFD	; 253
     2c0:	7f 4f       	sbci	r23, 0xFF	; 255
     2c2:	80 91 99 08 	lds	r24, 0x0899
     2c6:	90 91 9a 08 	lds	r25, 0x089A
     2ca:	c7 d7       	rcall	.+3982   	; 0x125a <xQueueGenericSend>
     2cc:	b7 01       	movw	r22, r14
     2ce:	86 e4       	ldi	r24, 0x46	; 70
     2d0:	6e df       	rcall	.-292    	; 0x1ae <obstacleSend>
     2d2:	b6 01       	movw	r22, r12
     2d4:	8c e4       	ldi	r24, 0x4C	; 76
     2d6:	6b df       	rcall	.-298    	; 0x1ae <obstacleSend>
     2d8:	b5 01       	movw	r22, r10
     2da:	82 e5       	ldi	r24, 0x52	; 82
     2dc:	68 df       	rcall	.-304    	; 0x1ae <obstacleSend>
     2de:	b8 01       	movw	r22, r16
     2e0:	82 e4       	ldi	r24, 0x42	; 66
     2e2:	65 df       	rcall	.-310    	; 0x1ae <obstacleSend>
     2e4:	1b 82       	std	Y+3, r1	; 0x03
     2e6:	68 ec       	ldi	r22, 0xC8	; 200
     2e8:	70 e0       	ldi	r23, 0x00	; 0
     2ea:	ce 01       	movw	r24, r28
     2ec:	01 96       	adiw	r24, 0x01	; 1
     2ee:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <vTaskDelayUntil>
     2f2:	9c cf       	rjmp	.-200    	; 0x22c <Sonar_Task+0x2e>

000002f4 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2f4:	8c ec       	ldi	r24, 0xCC	; 204
     2f6:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2fa:	8e e3       	ldi	r24, 0x3E	; 62
     2fc:	80 93 65 00 	sts	0x0065, r24
     300:	08 95       	ret

00000302 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     302:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     306:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     30a:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     30e:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     312:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     316:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     31a:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     31e:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     322:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     326:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     32a:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     32e:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     332:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     336:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     33a:	10 92 73 00 	sts	0x0073, r1
     33e:	08 95       	ret

00000340 <init>:
}

void init()
{
     340:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     342:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     344:	f8 94       	cli
	{
		clearTimer();
     346:	dd df       	rcall	.-70     	; 0x302 <clearTimer>
		setPowerReduction();
     348:	d5 df       	rcall	.-86     	; 0x2f4 <setPowerReduction>
		myUSART_USART0_Init();
     34a:	43 d4       	rcall	.+2182   	; 0xbd2 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     34c:	62 d4       	rcall	.+2244   	; 0xc12 <myUSART_USART1_Init>
		myADC_Init();
     34e:	2f d2       	rcall	.+1118   	; 0x7ae <myADC_Init>
		MaxSonar_Init();
     350:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     352:	ad d1       	rcall	.+858    	; 0x6ae <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     354:	40 e0       	ldi	r20, 0x00	; 0
     356:	61 e0       	ldi	r22, 0x01	; 1
     358:	85 e0       	ldi	r24, 0x05	; 5
     35a:	55 d7       	rcall	.+3754   	; 0x1206 <xQueueGenericCreate>
     35c:	90 93 9a 08 	sts	0x089A, r25
     360:	80 93 99 08 	sts	0x0899, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     364:	40 e0       	ldi	r20, 0x00	; 0
     366:	65 e0       	ldi	r22, 0x05	; 5
     368:	84 e1       	ldi	r24, 0x14	; 20
     36a:	4d d7       	rcall	.+3738   	; 0x1206 <xQueueGenericCreate>
     36c:	90 93 9c 08 	sts	0x089C, r25
     370:	80 93 9b 08 	sts	0x089B, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     374:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     376:	e1 e0       	ldi	r30, 0x01	; 1
     378:	f1 e0       	ldi	r31, 0x01	; 1
     37a:	80 81       	ld	r24, Z
     37c:	80 61       	ori	r24, 0x10	; 16
     37e:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     380:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     382:	78 94       	sei
}
     384:	cf 91       	pop	r28
     386:	08 95       	ret

00000388 <main>:
	
	// do nth
}

int main(void)
{
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	cd b7       	in	r28, 0x3d	; 61
     38e:	de b7       	in	r29, 0x3e	; 62
     390:	28 97       	sbiw	r28, 0x08	; 8
     392:	0f b6       	in	r0, 0x3f	; 63
     394:	f8 94       	cli
     396:	de bf       	out	0x3e, r29	; 62
     398:	0f be       	out	0x3f, r0	; 63
     39a:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
		
		init();
     39c:	d1 df       	rcall	.-94     	; 0x340 <init>

		//xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     39e:	a1 2c       	mov	r10, r1
     3a0:	b1 2c       	mov	r11, r1
     3a2:	c1 2c       	mov	r12, r1
     3a4:	d1 2c       	mov	r13, r1
     3a6:	ce 01       	movw	r24, r28
     3a8:	01 96       	adiw	r24, 0x01	; 1
     3aa:	7c 01       	movw	r14, r24
     3ac:	04 e0       	ldi	r16, 0x04	; 4
     3ae:	9c 01       	movw	r18, r24
     3b0:	49 e6       	ldi	r20, 0x69	; 105
     3b2:	50 e0       	ldi	r21, 0x00	; 0
     3b4:	63 e2       	ldi	r22, 0x23	; 35
     3b6:	72 e0       	ldi	r23, 0x02	; 2
     3b8:	84 ed       	ldi	r24, 0xD4	; 212
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     3c0:	ce 01       	movw	r24, r28
     3c2:	07 96       	adiw	r24, 0x07	; 7
     3c4:	7c 01       	movw	r14, r24
     3c6:	02 e0       	ldi	r16, 0x02	; 2
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	4f e4       	ldi	r20, 0x4F	; 79
     3ce:	51 e0       	ldi	r21, 0x01	; 1
     3d0:	6b e2       	ldi	r22, 0x2B	; 43
     3d2:	72 e0       	ldi	r23, 0x02	; 2
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3dc:	ce 01       	movw	r24, r28
     3de:	05 96       	adiw	r24, 0x05	; 5
     3e0:	7c 01       	movw	r14, r24
     3e2:	03 e0       	ldi	r16, 0x03	; 3
     3e4:	20 e0       	ldi	r18, 0x00	; 0
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	47 e8       	ldi	r20, 0x87	; 135
     3ea:	50 e0       	ldi	r21, 0x00	; 0
     3ec:	64 e3       	ldi	r22, 0x34	; 52
     3ee:	72 e0       	ldi	r23, 0x02	; 2
     3f0:	83 e9       	ldi	r24, 0x93	; 147
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3f8:	ce 01       	movw	r24, r28
     3fa:	03 96       	adiw	r24, 0x03	; 3
     3fc:	7c 01       	movw	r14, r24
     3fe:	01 e0       	ldi	r16, 0x01	; 1
     400:	20 e0       	ldi	r18, 0x00	; 0
     402:	30 e0       	ldi	r19, 0x00	; 0
     404:	47 e8       	ldi	r20, 0x87	; 135
     406:	50 e0       	ldi	r21, 0x00	; 0
     408:	60 e4       	ldi	r22, 0x40	; 64
     40a:	72 e0       	ldi	r23, 0x02	; 2
     40c:	88 e9       	ldi	r24, 0x98	; 152
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     414:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vTaskStartScheduler>
     418:	c1 cf       	rjmp	.-126    	; 0x39c <main+0x14>

0000041a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     41a:	cf 93       	push	r28
     41c:	df 93       	push	r29
     41e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     420:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     424:	80 91 4e 02 	lds	r24, 0x024E
     428:	90 91 4f 02 	lds	r25, 0x024F
     42c:	89 2b       	or	r24, r25
     42e:	31 f4       	brne	.+12     	; 0x43c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     430:	83 e5       	ldi	r24, 0x53	; 83
     432:	92 e0       	ldi	r25, 0x02	; 2
     434:	90 93 4f 02 	sts	0x024F, r25
     438:	80 93 4e 02 	sts	0x024E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     43c:	40 91 50 02 	lds	r20, 0x0250
     440:	50 91 51 02 	lds	r21, 0x0251
     444:	9e 01       	movw	r18, r28
     446:	24 0f       	add	r18, r20
     448:	35 1f       	adc	r19, r21
     44a:	2b 3d       	cpi	r18, 0xDB	; 219
     44c:	85 e0       	ldi	r24, 0x05	; 5
     44e:	38 07       	cpc	r19, r24
     450:	70 f4       	brcc	.+28     	; 0x46e <pvPortMalloc+0x54>
     452:	42 17       	cp	r20, r18
     454:	53 07       	cpc	r21, r19
     456:	70 f4       	brcc	.+28     	; 0x474 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     458:	c0 91 4e 02 	lds	r28, 0x024E
     45c:	d0 91 4f 02 	lds	r29, 0x024F
     460:	c4 0f       	add	r28, r20
     462:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     464:	30 93 51 02 	sts	0x0251, r19
     468:	20 93 50 02 	sts	0x0250, r18
     46c:	05 c0       	rjmp	.+10     	; 0x478 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     46e:	c0 e0       	ldi	r28, 0x00	; 0
     470:	d0 e0       	ldi	r29, 0x00	; 0
     472:	02 c0       	rjmp	.+4      	; 0x478 <pvPortMalloc+0x5e>
     474:	c0 e0       	ldi	r28, 0x00	; 0
     476:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     478:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     47c:	ce 01       	movw	r24, r28
     47e:	df 91       	pop	r29
     480:	cf 91       	pop	r28
     482:	08 95       	ret

00000484 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     484:	08 95       	ret

00000486 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     486:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     488:	03 96       	adiw	r24, 0x03	; 3
     48a:	92 83       	std	Z+2, r25	; 0x02
     48c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     48e:	2f ef       	ldi	r18, 0xFF	; 255
     490:	3f ef       	ldi	r19, 0xFF	; 255
     492:	34 83       	std	Z+4, r19	; 0x04
     494:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     496:	96 83       	std	Z+6, r25	; 0x06
     498:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     49a:	90 87       	std	Z+8, r25	; 0x08
     49c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     49e:	10 82       	st	Z, r1
     4a0:	08 95       	ret

000004a2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     4a2:	fc 01       	movw	r30, r24
     4a4:	11 86       	std	Z+9, r1	; 0x09
     4a6:	10 86       	std	Z+8, r1	; 0x08
     4a8:	08 95       	ret

000004aa <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4aa:	cf 93       	push	r28
     4ac:	df 93       	push	r29
     4ae:	9c 01       	movw	r18, r24
     4b0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     4b2:	dc 01       	movw	r26, r24
     4b4:	11 96       	adiw	r26, 0x01	; 1
     4b6:	cd 91       	ld	r28, X+
     4b8:	dc 91       	ld	r29, X
     4ba:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     4bc:	d3 83       	std	Z+3, r29	; 0x03
     4be:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     4c0:	8c 81       	ldd	r24, Y+4	; 0x04
     4c2:	9d 81       	ldd	r25, Y+5	; 0x05
     4c4:	95 83       	std	Z+5, r25	; 0x05
     4c6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     4c8:	8c 81       	ldd	r24, Y+4	; 0x04
     4ca:	9d 81       	ldd	r25, Y+5	; 0x05
     4cc:	dc 01       	movw	r26, r24
     4ce:	13 96       	adiw	r26, 0x03	; 3
     4d0:	7c 93       	st	X, r23
     4d2:	6e 93       	st	-X, r22
     4d4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     4d6:	7d 83       	std	Y+5, r23	; 0x05
     4d8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4da:	31 87       	std	Z+9, r19	; 0x09
     4dc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     4de:	f9 01       	movw	r30, r18
     4e0:	80 81       	ld	r24, Z
     4e2:	8f 5f       	subi	r24, 0xFF	; 255
     4e4:	80 83       	st	Z, r24
}
     4e6:	df 91       	pop	r29
     4e8:	cf 91       	pop	r28
     4ea:	08 95       	ret

000004ec <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4ec:	cf 93       	push	r28
     4ee:	df 93       	push	r29
     4f0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     4f2:	48 81       	ld	r20, Y
     4f4:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     4f6:	4f 3f       	cpi	r20, 0xFF	; 255
     4f8:	2f ef       	ldi	r18, 0xFF	; 255
     4fa:	52 07       	cpc	r21, r18
     4fc:	21 f4       	brne	.+8      	; 0x506 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4fe:	fc 01       	movw	r30, r24
     500:	a7 81       	ldd	r26, Z+7	; 0x07
     502:	b0 85       	ldd	r27, Z+8	; 0x08
     504:	0d c0       	rjmp	.+26     	; 0x520 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     506:	dc 01       	movw	r26, r24
     508:	13 96       	adiw	r26, 0x03	; 3
     50a:	12 96       	adiw	r26, 0x02	; 2
     50c:	ed 91       	ld	r30, X+
     50e:	fc 91       	ld	r31, X
     510:	13 97       	sbiw	r26, 0x03	; 3
     512:	20 81       	ld	r18, Z
     514:	31 81       	ldd	r19, Z+1	; 0x01
     516:	42 17       	cp	r20, r18
     518:	53 07       	cpc	r21, r19
     51a:	10 f0       	brcs	.+4      	; 0x520 <vListInsert+0x34>
     51c:	df 01       	movw	r26, r30
     51e:	f5 cf       	rjmp	.-22     	; 0x50a <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     520:	12 96       	adiw	r26, 0x02	; 2
     522:	ed 91       	ld	r30, X+
     524:	fc 91       	ld	r31, X
     526:	13 97       	sbiw	r26, 0x03	; 3
     528:	fb 83       	std	Y+3, r31	; 0x03
     52a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     52c:	d5 83       	std	Z+5, r29	; 0x05
     52e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     530:	bd 83       	std	Y+5, r27	; 0x05
     532:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     534:	13 96       	adiw	r26, 0x03	; 3
     536:	dc 93       	st	X, r29
     538:	ce 93       	st	-X, r28
     53a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     53c:	99 87       	std	Y+9, r25	; 0x09
     53e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     540:	fc 01       	movw	r30, r24
     542:	20 81       	ld	r18, Z
     544:	2f 5f       	subi	r18, 0xFF	; 255
     546:	20 83       	st	Z, r18
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	08 95       	ret

0000054e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     554:	a0 85       	ldd	r26, Z+8	; 0x08
     556:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     558:	c2 81       	ldd	r28, Z+2	; 0x02
     55a:	d3 81       	ldd	r29, Z+3	; 0x03
     55c:	84 81       	ldd	r24, Z+4	; 0x04
     55e:	95 81       	ldd	r25, Z+5	; 0x05
     560:	9d 83       	std	Y+5, r25	; 0x05
     562:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     564:	c4 81       	ldd	r28, Z+4	; 0x04
     566:	d5 81       	ldd	r29, Z+5	; 0x05
     568:	82 81       	ldd	r24, Z+2	; 0x02
     56a:	93 81       	ldd	r25, Z+3	; 0x03
     56c:	9b 83       	std	Y+3, r25	; 0x03
     56e:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     570:	11 96       	adiw	r26, 0x01	; 1
     572:	cd 91       	ld	r28, X+
     574:	dc 91       	ld	r29, X
     576:	12 97       	sbiw	r26, 0x02	; 2
     578:	ce 17       	cp	r28, r30
     57a:	df 07       	cpc	r29, r31
     57c:	31 f4       	brne	.+12     	; 0x58a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     57e:	8c 81       	ldd	r24, Y+4	; 0x04
     580:	9d 81       	ldd	r25, Y+5	; 0x05
     582:	12 96       	adiw	r26, 0x02	; 2
     584:	9c 93       	st	X, r25
     586:	8e 93       	st	-X, r24
     588:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     58a:	11 86       	std	Z+9, r1	; 0x09
     58c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     58e:	8c 91       	ld	r24, X
     590:	81 50       	subi	r24, 0x01	; 1
     592:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     594:	df 91       	pop	r29
     596:	cf 91       	pop	r28
     598:	08 95       	ret

0000059a <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     59a:	1f 92       	push	r1
     59c:	0f 92       	push	r0
     59e:	0f b6       	in	r0, 0x3f	; 63
     5a0:	0f 92       	push	r0
     5a2:	11 24       	eor	r1, r1
     5a4:	0b b6       	in	r0, 0x3b	; 59
     5a6:	0f 92       	push	r0
     5a8:	2f 93       	push	r18
     5aa:	3f 93       	push	r19
     5ac:	4f 93       	push	r20
     5ae:	5f 93       	push	r21
     5b0:	6f 93       	push	r22
     5b2:	7f 93       	push	r23
     5b4:	8f 93       	push	r24
     5b6:	9f 93       	push	r25
     5b8:	af 93       	push	r26
     5ba:	bf 93       	push	r27
     5bc:	ef 93       	push	r30
     5be:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     5c0:	1b 9b       	sbis	0x03, 3	; 3
     5c2:	0d c0       	rjmp	.+26     	; 0x5de <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     5c4:	72 d1       	rcall	.+740    	; 0x8aa <myTimer_Read>
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	90 93 a2 08 	sts	0x08A2, r25
     5cc:	80 93 a1 08 	sts	0x08A1, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     5d0:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xTaskGetTickCountFromISR>
     5d4:	90 93 9e 08 	sts	0x089E, r25
     5d8:	80 93 9d 08 	sts	0x089D, r24
     5dc:	55 c0       	rjmp	.+170    	; 0x688 <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     5de:	1b 99       	sbic	0x03, 3	; 3
     5e0:	53 c0       	rjmp	.+166    	; 0x688 <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     5e2:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xTaskGetTickCountFromISR>
     5e6:	90 93 a8 08 	sts	0x08A8, r25
     5ea:	80 93 a7 08 	sts	0x08A7, r24
     5ee:	20 91 9d 08 	lds	r18, 0x089D
     5f2:	30 91 9e 08 	lds	r19, 0x089E
     5f6:	82 17       	cp	r24, r18
     5f8:	93 07       	cpc	r25, r19
     5fa:	4c f4       	brge	.+18     	; 0x60e <__vector_9+0x74>
			ms_tickEnd += 65535;
     5fc:	80 91 a7 08 	lds	r24, 0x08A7
     600:	90 91 a8 08 	lds	r25, 0x08A8
     604:	01 97       	sbiw	r24, 0x01	; 1
     606:	90 93 a8 08 	sts	0x08A8, r25
     60a:	80 93 a7 08 	sts	0x08A7, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     60e:	4d d1       	rcall	.+666    	; 0x8aa <myTimer_Read>
     610:	90 e0       	ldi	r25, 0x00	; 0
     612:	90 93 aa 08 	sts	0x08AA, r25
     616:	80 93 a9 08 	sts	0x08A9, r24
     61a:	20 91 a1 08 	lds	r18, 0x08A1
     61e:	30 91 a2 08 	lds	r19, 0x08A2
     622:	82 17       	cp	r24, r18
     624:	93 07       	cpc	r25, r19
     626:	54 f4       	brge	.+20     	; 0x63c <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     628:	80 91 a9 08 	lds	r24, 0x08A9
     62c:	90 91 aa 08 	lds	r25, 0x08AA
     630:	86 50       	subi	r24, 0x06	; 6
     632:	9f 4f       	sbci	r25, 0xFF	; 255
     634:	90 93 aa 08 	sts	0x08AA, r25
     638:	80 93 a9 08 	sts	0x08A9, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     63c:	80 91 a9 08 	lds	r24, 0x08A9
     640:	90 91 aa 08 	lds	r25, 0x08AA
     644:	20 91 a1 08 	lds	r18, 0x08A1
     648:	30 91 a2 08 	lds	r19, 0x08A2
     64c:	82 1b       	sub	r24, r18
     64e:	93 0b       	sbc	r25, r19
     650:	90 93 a4 08 	sts	0x08A4, r25
     654:	80 93 a3 08 	sts	0x08A3, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     658:	80 91 a7 08 	lds	r24, 0x08A7
     65c:	90 91 a8 08 	lds	r25, 0x08A8
     660:	20 91 9d 08 	lds	r18, 0x089D
     664:	30 91 9e 08 	lds	r19, 0x089E
     668:	82 1b       	sub	r24, r18
     66a:	93 0b       	sbc	r25, r19
     66c:	90 93 a0 08 	sts	0x08A0, r25
     670:	80 93 9f 08 	sts	0x089F, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     674:	20 e0       	ldi	r18, 0x00	; 0
     676:	40 e0       	ldi	r20, 0x00	; 0
     678:	50 e0       	ldi	r21, 0x00	; 0
     67a:	60 e0       	ldi	r22, 0x00	; 0
     67c:	70 e0       	ldi	r23, 0x00	; 0
     67e:	80 91 a5 08 	lds	r24, 0x08A5
     682:	90 91 a6 08 	lds	r25, 0x08A6
     686:	a4 d6       	rcall	.+3400   	; 0x13d0 <xQueueGenericSendFromISR>
	}	
}
     688:	ff 91       	pop	r31
     68a:	ef 91       	pop	r30
     68c:	bf 91       	pop	r27
     68e:	af 91       	pop	r26
     690:	9f 91       	pop	r25
     692:	8f 91       	pop	r24
     694:	7f 91       	pop	r23
     696:	6f 91       	pop	r22
     698:	5f 91       	pop	r21
     69a:	4f 91       	pop	r20
     69c:	3f 91       	pop	r19
     69e:	2f 91       	pop	r18
     6a0:	0f 90       	pop	r0
     6a2:	0b be       	out	0x3b, r0	; 59
     6a4:	0f 90       	pop	r0
     6a6:	0f be       	out	0x3f, r0	; 63
     6a8:	0f 90       	pop	r0
     6aa:	1f 90       	pop	r1
     6ac:	18 95       	reti

000006ae <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     6ae:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     6b0:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     6b2:	e8 e6       	ldi	r30, 0x68	; 104
     6b4:	f0 e0       	ldi	r31, 0x00	; 0
     6b6:	80 81       	ld	r24, Z
     6b8:	81 60       	ori	r24, 0x01	; 1
     6ba:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     6bc:	eb e6       	ldi	r30, 0x6B	; 107
     6be:	f0 e0       	ldi	r31, 0x00	; 0
     6c0:	80 81       	ld	r24, Z
     6c2:	88 60       	ori	r24, 0x08	; 8
     6c4:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     6c6:	43 e0       	ldi	r20, 0x03	; 3
     6c8:	60 e0       	ldi	r22, 0x00	; 0
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	9c d5       	rcall	.+2872   	; 0x1206 <xQueueGenericCreate>
     6ce:	90 93 a6 08 	sts	0x08A6, r25
     6d2:	80 93 a5 08 	sts	0x08A5, r24
     6d6:	08 95       	ret

000006d8 <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     6d8:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     6da:	8e e1       	ldi	r24, 0x1E	; 30
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	0b d1       	rcall	.+534    	; 0x8f6 <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     6e0:	2a 98       	cbi	0x05, 2	; 5
     6e2:	08 95       	ret

000006e4 <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     6e4:	f9 df       	rcall	.-14     	; 0x6d8 <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	4f ef       	ldi	r20, 0xFF	; 255
     6ea:	5f ef       	ldi	r21, 0xFF	; 255
     6ec:	60 e0       	ldi	r22, 0x00	; 0
     6ee:	70 e0       	ldi	r23, 0x00	; 0
     6f0:	80 91 a5 08 	lds	r24, 0x08A5
     6f4:	90 91 a6 08 	lds	r25, 0x08A6
     6f8:	a5 d6       	rcall	.+3402   	; 0x1444 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     6fa:	80 91 a3 08 	lds	r24, 0x08A3
     6fe:	90 91 a4 08 	lds	r25, 0x08A4
	msLength = ms_tickLapsed * 5;
     702:	20 91 9f 08 	lds	r18, 0x089F
     706:	30 91 a0 08 	lds	r19, 0x08A0
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     70a:	6e e0       	ldi	r22, 0x0E	; 14
     70c:	70 e0       	ldi	r23, 0x00	; 0
     70e:	0e 94 ed 10 	call	0x21da	; 0x21da <__divmodhi4>
	msLength = ms_tickLapsed * 5;
     712:	c9 01       	movw	r24, r18
     714:	88 0f       	add	r24, r24
     716:	99 1f       	adc	r25, r25
     718:	88 0f       	add	r24, r24
     71a:	99 1f       	adc	r25, r25
     71c:	82 0f       	add	r24, r18
     71e:	93 1f       	adc	r25, r19
	return usLength + msLength;
	
     720:	86 0f       	add	r24, r22
     722:	97 1f       	adc	r25, r23
     724:	08 95       	ret

00000726 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     726:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     728:	89 e1       	ldi	r24, 0x19	; 25
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	c0 d0       	rcall	.+384    	; 0x8ae <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     72e:	a1 98       	cbi	0x14, 1	; 20
     730:	08 95       	ret

00000732 <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     732:	9a d0       	rcall	.+308    	; 0x868 <myADC_analogRead>
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	9c 01       	movw	r18, r24
     738:	22 0f       	add	r18, r18
     73a:	33 1f       	adc	r19, r19
     73c:	22 0f       	add	r18, r18
     73e:	33 1f       	adc	r19, r19
}
     740:	82 0f       	add	r24, r18
     742:	93 1f       	adc	r25, r19
     744:	08 95       	ret

00000746 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     746:	1f 92       	push	r1
     748:	0f 92       	push	r0
     74a:	0f b6       	in	r0, 0x3f	; 63
     74c:	0f 92       	push	r0
     74e:	11 24       	eor	r1, r1
     750:	0b b6       	in	r0, 0x3b	; 59
     752:	0f 92       	push	r0
     754:	2f 93       	push	r18
     756:	3f 93       	push	r19
     758:	4f 93       	push	r20
     75a:	5f 93       	push	r21
     75c:	6f 93       	push	r22
     75e:	7f 93       	push	r23
     760:	8f 93       	push	r24
     762:	9f 93       	push	r25
     764:	af 93       	push	r26
     766:	bf 93       	push	r27
     768:	ef 93       	push	r30
     76a:	ff 93       	push	r31
	adcReading = ADCH; // read value
     76c:	80 91 79 00 	lds	r24, 0x0079
     770:	80 93 ab 08 	sts	0x08AB, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     774:	20 e0       	ldi	r18, 0x00	; 0
     776:	40 e0       	ldi	r20, 0x00	; 0
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	70 e0       	ldi	r23, 0x00	; 0
     77e:	80 91 ae 08 	lds	r24, 0x08AE
     782:	90 91 af 08 	lds	r25, 0x08AF
     786:	24 d6       	rcall	.+3144   	; 0x13d0 <xQueueGenericSendFromISR>
}
     788:	ff 91       	pop	r31
     78a:	ef 91       	pop	r30
     78c:	bf 91       	pop	r27
     78e:	af 91       	pop	r26
     790:	9f 91       	pop	r25
     792:	8f 91       	pop	r24
     794:	7f 91       	pop	r23
     796:	6f 91       	pop	r22
     798:	5f 91       	pop	r21
     79a:	4f 91       	pop	r20
     79c:	3f 91       	pop	r19
     79e:	2f 91       	pop	r18
     7a0:	0f 90       	pop	r0
     7a2:	0b be       	out	0x3b, r0	; 59
     7a4:	0f 90       	pop	r0
     7a6:	0f be       	out	0x3f, r0	; 63
     7a8:	0f 90       	pop	r0
     7aa:	1f 90       	pop	r1
     7ac:	18 95       	reti

000007ae <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     7ae:	8f e8       	ldi	r24, 0x8F	; 143
     7b0:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     7b4:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     7b8:	80 e6       	ldi	r24, 0x60	; 96
     7ba:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     7be:	43 e0       	ldi	r20, 0x03	; 3
     7c0:	60 e0       	ldi	r22, 0x00	; 0
     7c2:	81 e0       	ldi	r24, 0x01	; 1
     7c4:	20 d5       	rcall	.+2624   	; 0x1206 <xQueueGenericCreate>
     7c6:	90 93 af 08 	sts	0x08AF, r25
     7ca:	80 93 ae 08 	sts	0x08AE, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	d7 d5       	rcall	.+2990   	; 0x1380 <xQueueCreateMutex>
     7d2:	90 93 ad 08 	sts	0x08AD, r25
     7d6:	80 93 ac 08 	sts	0x08AC, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     7da:	20 e0       	ldi	r18, 0x00	; 0
     7dc:	40 e0       	ldi	r20, 0x00	; 0
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	70 e0       	ldi	r23, 0x00	; 0
     7e4:	3a c5       	rjmp	.+2676   	; 0x125a <xQueueGenericSend>
     7e6:	08 95       	ret

000007e8 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     7e8:	cf 93       	push	r28
     7ea:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	4f ef       	ldi	r20, 0xFF	; 255
     7f0:	5f ef       	ldi	r21, 0xFF	; 255
     7f2:	60 e0       	ldi	r22, 0x00	; 0
     7f4:	70 e0       	ldi	r23, 0x00	; 0
     7f6:	80 91 ac 08 	lds	r24, 0x08AC
     7fa:	90 91 ad 08 	lds	r25, 0x08AD
     7fe:	22 d6       	rcall	.+3140   	; 0x1444 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     800:	ec e7       	ldi	r30, 0x7C	; 124
     802:	f0 e0       	ldi	r31, 0x00	; 0
     804:	80 81       	ld	r24, Z
     806:	9c 2f       	mov	r25, r28
     808:	9f 71       	andi	r25, 0x1F	; 31
     80a:	80 76       	andi	r24, 0x60	; 96
     80c:	89 2b       	or	r24, r25
     80e:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     810:	eb e7       	ldi	r30, 0x7B	; 123
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	20 81       	ld	r18, Z
     816:	c0 72       	andi	r28, 0x20	; 32
     818:	8c 2f       	mov	r24, r28
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	95 95       	asr	r25
     81e:	87 95       	ror	r24
     820:	95 95       	asr	r25
     822:	87 95       	ror	r24
     824:	92 2f       	mov	r25, r18
     826:	90 76       	andi	r25, 0x60	; 96
     828:	89 2b       	or	r24, r25
     82a:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     82c:	ea e7       	ldi	r30, 0x7A	; 122
     82e:	f0 e0       	ldi	r31, 0x00	; 0
     830:	80 81       	ld	r24, Z
     832:	80 64       	ori	r24, 0x40	; 64
     834:	80 83       	st	Z, r24
}
     836:	cf 91       	pop	r28
     838:	08 95       	ret

0000083a <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     83a:	20 e0       	ldi	r18, 0x00	; 0
     83c:	4f ef       	ldi	r20, 0xFF	; 255
     83e:	5f ef       	ldi	r21, 0xFF	; 255
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	80 91 ae 08 	lds	r24, 0x08AE
     848:	90 91 af 08 	lds	r25, 0x08AF
     84c:	fb d5       	rcall	.+3062   	; 0x1444 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	40 e0       	ldi	r20, 0x00	; 0
     852:	50 e0       	ldi	r21, 0x00	; 0
     854:	60 e0       	ldi	r22, 0x00	; 0
     856:	70 e0       	ldi	r23, 0x00	; 0
     858:	80 91 ac 08 	lds	r24, 0x08AC
     85c:	90 91 ad 08 	lds	r25, 0x08AD
     860:	fc d4       	rcall	.+2552   	; 0x125a <xQueueGenericSend>
	return adcReading;
     862:	80 91 ab 08 	lds	r24, 0x08AB
     866:	08 95       	ret

00000868 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     868:	cf 93       	push	r28
     86a:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     86c:	bd df       	rcall	.-134    	; 0x7e8 <myADC_startADC>
	return myADC_readADC(channel);
     86e:	8c 2f       	mov	r24, r28
     870:	e4 df       	rcall	.-56     	; 0x83a <myADC_readADC>
}
     872:	cf 91       	pop	r28
     874:	08 95       	ret

00000876 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     876:	90 93 b5 08 	sts	0x08B5, r25
     87a:	80 93 b4 08 	sts	0x08B4, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     87e:	fc 01       	movw	r30, r24
     880:	80 81       	ld	r24, Z
     882:	91 81       	ldd	r25, Z+1	; 0x01
     884:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     888:	43 e0       	ldi	r20, 0x03	; 3
     88a:	60 e0       	ldi	r22, 0x00	; 0
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	bb d4       	rcall	.+2422   	; 0x1206 <xQueueGenericCreate>
     890:	90 93 b1 08 	sts	0x08B1, r25
     894:	80 93 b0 08 	sts	0x08B0, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     898:	43 e0       	ldi	r20, 0x03	; 3
     89a:	60 e0       	ldi	r22, 0x00	; 0
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	b3 d4       	rcall	.+2406   	; 0x1206 <xQueueGenericCreate>
     8a0:	90 93 b3 08 	sts	0x08B3, r25
     8a4:	80 93 b2 08 	sts	0x08B2, r24
     8a8:	08 95       	ret

000008aa <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8aa:	86 b5       	in	r24, 0x26	; 38
}
     8ac:	08 95       	ret

000008ae <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8ae:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     8b0:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     8b2:	9c 01       	movw	r18, r24
     8b4:	99 23       	and	r25, r25
     8b6:	14 f4       	brge	.+4      	; 0x8bc <myTimer_DelayMicro+0xe>
     8b8:	2d 5f       	subi	r18, 0xFD	; 253
     8ba:	3f 4f       	sbci	r19, 0xFF	; 255
     8bc:	35 95       	asr	r19
     8be:	27 95       	ror	r18
     8c0:	35 95       	asr	r19
     8c2:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     8c4:	24 0f       	add	r18, r20
     8c6:	35 1f       	adc	r19, r21
     8c8:	30 93 03 02 	sts	0x0203, r19
     8cc:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     8d0:	e0 91 b4 08 	lds	r30, 0x08B4
     8d4:	f0 91 b5 08 	lds	r31, 0x08B5
     8d8:	80 81       	ld	r24, Z
     8da:	91 81       	ldd	r25, Z+1	; 0x01
     8dc:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	42 e0       	ldi	r20, 0x02	; 2
     8e4:	50 e0       	ldi	r21, 0x00	; 0
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	80 91 b0 08 	lds	r24, 0x08B0
     8ee:	90 91 b1 08 	lds	r25, 0x08B1
     8f2:	a8 c5       	rjmp	.+2896   	; 0x1444 <xQueueGenericReceive>
     8f4:	08 95       	ret

000008f6 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8f6:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     8f8:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     8fa:	9c 01       	movw	r18, r24
     8fc:	99 23       	and	r25, r25
     8fe:	14 f4       	brge	.+4      	; 0x904 <myTimer_DelayMicro2+0xe>
     900:	2d 5f       	subi	r18, 0xFD	; 253
     902:	3f 4f       	sbci	r19, 0xFF	; 255
     904:	35 95       	asr	r19
     906:	27 95       	ror	r18
     908:	35 95       	asr	r19
     90a:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     90c:	24 0f       	add	r18, r20
     90e:	35 1f       	adc	r19, r21
     910:	30 93 01 02 	sts	0x0201, r19
     914:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     918:	e0 91 b4 08 	lds	r30, 0x08B4
     91c:	f0 91 b5 08 	lds	r31, 0x08B5
     920:	80 81       	ld	r24, Z
     922:	91 81       	ldd	r25, Z+1	; 0x01
     924:	eb d7       	rcall	.+4054   	; 0x18fc <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     926:	20 e0       	ldi	r18, 0x00	; 0
     928:	42 e0       	ldi	r20, 0x02	; 2
     92a:	50 e0       	ldi	r21, 0x00	; 0
     92c:	60 e0       	ldi	r22, 0x00	; 0
     92e:	70 e0       	ldi	r23, 0x00	; 0
     930:	80 91 b2 08 	lds	r24, 0x08B2
     934:	90 91 b3 08 	lds	r25, 0x08B3
     938:	85 c5       	rjmp	.+2826   	; 0x1444 <xQueueGenericReceive>
     93a:	08 95       	ret

0000093c <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     940:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     942:	c1 11       	cpse	r28, r1
     944:	22 c0       	rjmp	.+68     	; 0x98a <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     946:	80 91 02 02 	lds	r24, 0x0202
     94a:	90 91 03 02 	lds	r25, 0x0203
     94e:	88 38       	cpi	r24, 0x88	; 136
     950:	93 41       	sbci	r25, 0x13	; 19
     952:	51 f0       	breq	.+20     	; 0x968 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     954:	80 91 02 02 	lds	r24, 0x0202
     958:	90 91 03 02 	lds	r25, 0x0203
     95c:	8a 5f       	subi	r24, 0xFA	; 250
     95e:	91 09       	sbc	r25, r1
     960:	90 93 03 02 	sts	0x0203, r25
     964:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     968:	80 91 00 02 	lds	r24, 0x0200
     96c:	90 91 01 02 	lds	r25, 0x0201
     970:	88 38       	cpi	r24, 0x88	; 136
     972:	93 41       	sbci	r25, 0x13	; 19
     974:	51 f0       	breq	.+20     	; 0x98a <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     976:	80 91 00 02 	lds	r24, 0x0200
     97a:	90 91 01 02 	lds	r25, 0x0201
     97e:	8a 5f       	subi	r24, 0xFA	; 250
     980:	91 09       	sbc	r25, r1
     982:	90 93 01 02 	sts	0x0201, r25
     986:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     98a:	d0 e0       	ldi	r29, 0x00	; 0
     98c:	80 91 02 02 	lds	r24, 0x0202
     990:	90 91 03 02 	lds	r25, 0x0203
     994:	8c 17       	cp	r24, r28
     996:	9d 07       	cpc	r25, r29
     998:	84 f4       	brge	.+32     	; 0x9ba <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     99a:	88 e8       	ldi	r24, 0x88	; 136
     99c:	93 e1       	ldi	r25, 0x13	; 19
     99e:	90 93 03 02 	sts	0x0203, r25
     9a2:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     9a6:	20 e0       	ldi	r18, 0x00	; 0
     9a8:	40 e0       	ldi	r20, 0x00	; 0
     9aa:	50 e0       	ldi	r21, 0x00	; 0
     9ac:	60 e0       	ldi	r22, 0x00	; 0
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	80 91 b0 08 	lds	r24, 0x08B0
     9b4:	90 91 b1 08 	lds	r25, 0x08B1
     9b8:	50 d4       	rcall	.+2208   	; 0x125a <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     9ba:	80 91 00 02 	lds	r24, 0x0200
     9be:	90 91 01 02 	lds	r25, 0x0201
     9c2:	8c 17       	cp	r24, r28
     9c4:	9d 07       	cpc	r25, r29
     9c6:	84 f4       	brge	.+32     	; 0x9e8 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     9c8:	88 e8       	ldi	r24, 0x88	; 136
     9ca:	93 e1       	ldi	r25, 0x13	; 19
     9cc:	90 93 01 02 	sts	0x0201, r25
     9d0:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     9d4:	20 e0       	ldi	r18, 0x00	; 0
     9d6:	40 e0       	ldi	r20, 0x00	; 0
     9d8:	50 e0       	ldi	r21, 0x00	; 0
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	70 e0       	ldi	r23, 0x00	; 0
     9de:	80 91 b2 08 	lds	r24, 0x08B2
     9e2:	90 91 b3 08 	lds	r25, 0x08B3
     9e6:	39 d4       	rcall	.+2162   	; 0x125a <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     9e8:	80 91 02 02 	lds	r24, 0x0202
     9ec:	90 91 03 02 	lds	r25, 0x0203
     9f0:	88 38       	cpi	r24, 0x88	; 136
     9f2:	93 41       	sbci	r25, 0x13	; 19
     9f4:	79 f4       	brne	.+30     	; 0xa14 <myTimer_DelayChecker+0xd8>
     9f6:	80 91 00 02 	lds	r24, 0x0200
     9fa:	90 91 01 02 	lds	r25, 0x0201
     9fe:	88 38       	cpi	r24, 0x88	; 136
     a00:	93 41       	sbci	r25, 0x13	; 19
     a02:	41 f4       	brne	.+16     	; 0xa14 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     a04:	e0 91 b4 08 	lds	r30, 0x08B4
     a08:	f0 91 b5 08 	lds	r31, 0x08B5
     a0c:	80 81       	ld	r24, Z
     a0e:	91 81       	ldd	r25, Z+1	; 0x01
     a10:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <vTaskSuspend>
	}
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	08 95       	ret

00000a1a <__vector_36>:
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     a1a:	1f 92       	push	r1
     a1c:	0f 92       	push	r0
     a1e:	0f b6       	in	r0, 0x3f	; 63
     a20:	0f 92       	push	r0
     a22:	11 24       	eor	r1, r1
     a24:	0b b6       	in	r0, 0x3b	; 59
     a26:	0f 92       	push	r0
     a28:	2f 93       	push	r18
     a2a:	3f 93       	push	r19
     a2c:	4f 93       	push	r20
     a2e:	5f 93       	push	r21
     a30:	6f 93       	push	r22
     a32:	7f 93       	push	r23
     a34:	8f 93       	push	r24
     a36:	9f 93       	push	r25
     a38:	af 93       	push	r26
     a3a:	bf 93       	push	r27
     a3c:	ef 93       	push	r30
     a3e:	ff 93       	push	r31
     a40:	60 91 ce 00 	lds	r22, 0x00CE
     a44:	89 e4       	ldi	r24, 0x49	; 73
     a46:	99 e0       	ldi	r25, 0x09	; 9
     a48:	c9 d5       	rcall	.+2962   	; 0x15dc <ringBufferPush>
     a4a:	20 e0       	ldi	r18, 0x00	; 0
     a4c:	40 e0       	ldi	r20, 0x00	; 0
     a4e:	50 e0       	ldi	r21, 0x00	; 0
     a50:	60 e0       	ldi	r22, 0x00	; 0
     a52:	70 e0       	ldi	r23, 0x00	; 0
     a54:	80 91 3d 09 	lds	r24, 0x093D
     a58:	90 91 3e 09 	lds	r25, 0x093E
     a5c:	b9 d4       	rcall	.+2418   	; 0x13d0 <xQueueGenericSendFromISR>
     a5e:	89 e4       	ldi	r24, 0x49	; 73
     a60:	99 e0       	ldi	r25, 0x09	; 9
     a62:	d2 d5       	rcall	.+2980   	; 0x1608 <ringBufferFull>
     a64:	ff 91       	pop	r31
     a66:	ef 91       	pop	r30
     a68:	bf 91       	pop	r27
     a6a:	af 91       	pop	r26
     a6c:	9f 91       	pop	r25
     a6e:	8f 91       	pop	r24
     a70:	7f 91       	pop	r23
     a72:	6f 91       	pop	r22
     a74:	5f 91       	pop	r21
     a76:	4f 91       	pop	r20
     a78:	3f 91       	pop	r19
     a7a:	2f 91       	pop	r18
     a7c:	0f 90       	pop	r0
     a7e:	0b be       	out	0x3b, r0	; 59
     a80:	0f 90       	pop	r0
     a82:	0f be       	out	0x3f, r0	; 63
     a84:	0f 90       	pop	r0
     a86:	1f 90       	pop	r1
     a88:	18 95       	reti

00000a8a <__vector_25>:
     a8a:	1f 92       	push	r1
     a8c:	0f 92       	push	r0
     a8e:	0f b6       	in	r0, 0x3f	; 63
     a90:	0f 92       	push	r0
     a92:	11 24       	eor	r1, r1
     a94:	0b b6       	in	r0, 0x3b	; 59
     a96:	0f 92       	push	r0
     a98:	2f 93       	push	r18
     a9a:	3f 93       	push	r19
     a9c:	4f 93       	push	r20
     a9e:	5f 93       	push	r21
     aa0:	6f 93       	push	r22
     aa2:	7f 93       	push	r23
     aa4:	8f 93       	push	r24
     aa6:	9f 93       	push	r25
     aa8:	af 93       	push	r26
     aaa:	bf 93       	push	r27
     aac:	ef 93       	push	r30
     aae:	ff 93       	push	r31
     ab0:	60 91 c6 00 	lds	r22, 0x00C6
     ab4:	86 ed       	ldi	r24, 0xD6	; 214
     ab6:	98 e0       	ldi	r25, 0x08	; 8
     ab8:	91 d5       	rcall	.+2850   	; 0x15dc <ringBufferPush>
     aba:	20 e0       	ldi	r18, 0x00	; 0
     abc:	40 e0       	ldi	r20, 0x00	; 0
     abe:	50 e0       	ldi	r21, 0x00	; 0
     ac0:	60 e0       	ldi	r22, 0x00	; 0
     ac2:	70 e0       	ldi	r23, 0x00	; 0
     ac4:	80 91 3d 09 	lds	r24, 0x093D
     ac8:	90 91 3e 09 	lds	r25, 0x093E
     acc:	81 d4       	rcall	.+2306   	; 0x13d0 <xQueueGenericSendFromISR>
     ace:	86 ed       	ldi	r24, 0xD6	; 214
     ad0:	98 e0       	ldi	r25, 0x08	; 8
     ad2:	9a d5       	rcall	.+2868   	; 0x1608 <ringBufferFull>
     ad4:	ff 91       	pop	r31
     ad6:	ef 91       	pop	r30
     ad8:	bf 91       	pop	r27
     ada:	af 91       	pop	r26
     adc:	9f 91       	pop	r25
     ade:	8f 91       	pop	r24
     ae0:	7f 91       	pop	r23
     ae2:	6f 91       	pop	r22
     ae4:	5f 91       	pop	r21
     ae6:	4f 91       	pop	r20
     ae8:	3f 91       	pop	r19
     aea:	2f 91       	pop	r18
     aec:	0f 90       	pop	r0
     aee:	0b be       	out	0x3b, r0	; 59
     af0:	0f 90       	pop	r0
     af2:	0f be       	out	0x3f, r0	; 63
     af4:	0f 90       	pop	r0
     af6:	1f 90       	pop	r1
     af8:	18 95       	reti

00000afa <__vector_37>:
     afa:	1f 92       	push	r1
     afc:	0f 92       	push	r0
     afe:	0f b6       	in	r0, 0x3f	; 63
     b00:	0f 92       	push	r0
     b02:	11 24       	eor	r1, r1
     b04:	0b b6       	in	r0, 0x3b	; 59
     b06:	0f 92       	push	r0
     b08:	2f 93       	push	r18
     b0a:	3f 93       	push	r19
     b0c:	4f 93       	push	r20
     b0e:	5f 93       	push	r21
     b10:	6f 93       	push	r22
     b12:	7f 93       	push	r23
     b14:	8f 93       	push	r24
     b16:	9f 93       	push	r25
     b18:	af 93       	push	r26
     b1a:	bf 93       	push	r27
     b1c:	ef 93       	push	r30
     b1e:	ff 93       	push	r31
     b20:	8f e3       	ldi	r24, 0x3F	; 63
     b22:	99 e0       	ldi	r25, 0x09	; 9
     b24:	78 d5       	rcall	.+2800   	; 0x1616 <ringBufferNotEmpty>
     b26:	88 23       	and	r24, r24
     b28:	31 f0       	breq	.+12     	; 0xb36 <__vector_37+0x3c>
     b2a:	8f e3       	ldi	r24, 0x3F	; 63
     b2c:	99 e0       	ldi	r25, 0x09	; 9
     b2e:	44 d5       	rcall	.+2696   	; 0x15b8 <ringBufferPop>
     b30:	80 93 ce 00 	sts	0x00CE, r24
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__vector_37+0x46>
     b36:	e9 ec       	ldi	r30, 0xC9	; 201
     b38:	f0 e0       	ldi	r31, 0x00	; 0
     b3a:	80 81       	ld	r24, Z
     b3c:	8f 7d       	andi	r24, 0xDF	; 223
     b3e:	80 83       	st	Z, r24
     b40:	ff 91       	pop	r31
     b42:	ef 91       	pop	r30
     b44:	bf 91       	pop	r27
     b46:	af 91       	pop	r26
     b48:	9f 91       	pop	r25
     b4a:	8f 91       	pop	r24
     b4c:	7f 91       	pop	r23
     b4e:	6f 91       	pop	r22
     b50:	5f 91       	pop	r21
     b52:	4f 91       	pop	r20
     b54:	3f 91       	pop	r19
     b56:	2f 91       	pop	r18
     b58:	0f 90       	pop	r0
     b5a:	0b be       	out	0x3b, r0	; 59
     b5c:	0f 90       	pop	r0
     b5e:	0f be       	out	0x3f, r0	; 63
     b60:	0f 90       	pop	r0
     b62:	1f 90       	pop	r1
     b64:	18 95       	reti

00000b66 <__vector_26>:
     b66:	1f 92       	push	r1
     b68:	0f 92       	push	r0
     b6a:	0f b6       	in	r0, 0x3f	; 63
     b6c:	0f 92       	push	r0
     b6e:	11 24       	eor	r1, r1
     b70:	0b b6       	in	r0, 0x3b	; 59
     b72:	0f 92       	push	r0
     b74:	2f 93       	push	r18
     b76:	3f 93       	push	r19
     b78:	4f 93       	push	r20
     b7a:	5f 93       	push	r21
     b7c:	6f 93       	push	r22
     b7e:	7f 93       	push	r23
     b80:	8f 93       	push	r24
     b82:	9f 93       	push	r25
     b84:	af 93       	push	r26
     b86:	bf 93       	push	r27
     b88:	ef 93       	push	r30
     b8a:	ff 93       	push	r31
     b8c:	84 e4       	ldi	r24, 0x44	; 68
     b8e:	99 e0       	ldi	r25, 0x09	; 9
     b90:	42 d5       	rcall	.+2692   	; 0x1616 <ringBufferNotEmpty>
     b92:	88 23       	and	r24, r24
     b94:	31 f0       	breq	.+12     	; 0xba2 <__vector_26+0x3c>
     b96:	84 e4       	ldi	r24, 0x44	; 68
     b98:	99 e0       	ldi	r25, 0x09	; 9
     b9a:	0e d5       	rcall	.+2588   	; 0x15b8 <ringBufferPop>
     b9c:	80 93 c6 00 	sts	0x00C6, r24
     ba0:	05 c0       	rjmp	.+10     	; 0xbac <__vector_26+0x46>
     ba2:	e1 ec       	ldi	r30, 0xC1	; 193
     ba4:	f0 e0       	ldi	r31, 0x00	; 0
     ba6:	80 81       	ld	r24, Z
     ba8:	8f 7d       	andi	r24, 0xDF	; 223
     baa:	80 83       	st	Z, r24
     bac:	ff 91       	pop	r31
     bae:	ef 91       	pop	r30
     bb0:	bf 91       	pop	r27
     bb2:	af 91       	pop	r26
     bb4:	9f 91       	pop	r25
     bb6:	8f 91       	pop	r24
     bb8:	7f 91       	pop	r23
     bba:	6f 91       	pop	r22
     bbc:	5f 91       	pop	r21
     bbe:	4f 91       	pop	r20
     bc0:	3f 91       	pop	r19
     bc2:	2f 91       	pop	r18
     bc4:	0f 90       	pop	r0
     bc6:	0b be       	out	0x3b, r0	; 59
     bc8:	0f 90       	pop	r0
     bca:	0f be       	out	0x3f, r0	; 63
     bcc:	0f 90       	pop	r0
     bce:	1f 90       	pop	r1
     bd0:	18 95       	reti

00000bd2 <myUSART_USART0_Init>:
     bd2:	10 92 c5 00 	sts	0x00C5, r1
     bd6:	87 e6       	ldi	r24, 0x67	; 103
     bd8:	80 93 c4 00 	sts	0x00C4, r24
     bdc:	88 eb       	ldi	r24, 0xB8	; 184
     bde:	80 93 c1 00 	sts	0x00C1, r24
     be2:	86 e0       	ldi	r24, 0x06	; 6
     be4:	80 93 c2 00 	sts	0x00C2, r24
     be8:	40 e2       	ldi	r20, 0x20	; 32
     bea:	6b ef       	ldi	r22, 0xFB	; 251
     bec:	78 e0       	ldi	r23, 0x08	; 8
     bee:	86 ed       	ldi	r24, 0xD6	; 214
     bf0:	98 e0       	ldi	r25, 0x08	; 8
     bf2:	db d4       	rcall	.+2486   	; 0x15aa <ringBufferInit>
     bf4:	40 e2       	ldi	r20, 0x20	; 32
     bf6:	6b ed       	ldi	r22, 0xDB	; 219
     bf8:	78 e0       	ldi	r23, 0x08	; 8
     bfa:	84 e4       	ldi	r24, 0x44	; 68
     bfc:	99 e0       	ldi	r25, 0x09	; 9
     bfe:	d5 d4       	rcall	.+2474   	; 0x15aa <ringBufferInit>
     c00:	43 e0       	ldi	r20, 0x03	; 3
     c02:	60 e0       	ldi	r22, 0x00	; 0
     c04:	81 e0       	ldi	r24, 0x01	; 1
     c06:	ff d2       	rcall	.+1534   	; 0x1206 <xQueueGenericCreate>
     c08:	90 93 3c 09 	sts	0x093C, r25
     c0c:	80 93 3b 09 	sts	0x093B, r24
     c10:	08 95       	ret

00000c12 <myUSART_USART1_Init>:
     c12:	10 92 cd 00 	sts	0x00CD, r1
     c16:	87 e6       	ldi	r24, 0x67	; 103
     c18:	80 93 cc 00 	sts	0x00CC, r24
     c1c:	88 eb       	ldi	r24, 0xB8	; 184
     c1e:	80 93 c9 00 	sts	0x00C9, r24
     c22:	86 e0       	ldi	r24, 0x06	; 6
     c24:	80 93 ca 00 	sts	0x00CA, r24
     c28:	40 e2       	ldi	r20, 0x20	; 32
     c2a:	66 eb       	ldi	r22, 0xB6	; 182
     c2c:	78 e0       	ldi	r23, 0x08	; 8
     c2e:	89 e4       	ldi	r24, 0x49	; 73
     c30:	99 e0       	ldi	r25, 0x09	; 9
     c32:	bb d4       	rcall	.+2422   	; 0x15aa <ringBufferInit>
     c34:	40 e2       	ldi	r20, 0x20	; 32
     c36:	6b e1       	ldi	r22, 0x1B	; 27
     c38:	79 e0       	ldi	r23, 0x09	; 9
     c3a:	8f e3       	ldi	r24, 0x3F	; 63
     c3c:	99 e0       	ldi	r25, 0x09	; 9
     c3e:	b5 d4       	rcall	.+2410   	; 0x15aa <ringBufferInit>
     c40:	43 e0       	ldi	r20, 0x03	; 3
     c42:	60 e0       	ldi	r22, 0x00	; 0
     c44:	81 e0       	ldi	r24, 0x01	; 1
     c46:	df d2       	rcall	.+1470   	; 0x1206 <xQueueGenericCreate>
     c48:	90 93 3e 09 	sts	0x093E, r25
     c4c:	80 93 3d 09 	sts	0x093D, r24
     c50:	08 95       	ret

00000c52 <myUSART_transmitUSART0_c>:
     c52:	cf 93       	push	r28
     c54:	c8 2f       	mov	r28, r24
     c56:	84 e4       	ldi	r24, 0x44	; 68
     c58:	99 e0       	ldi	r25, 0x09	; 9
     c5a:	d6 d4       	rcall	.+2476   	; 0x1608 <ringBufferFull>
     c5c:	81 11       	cpse	r24, r1
     c5e:	fb cf       	rjmp	.-10     	; 0xc56 <myUSART_transmitUSART0_c+0x4>
     c60:	6c 2f       	mov	r22, r28
     c62:	84 e4       	ldi	r24, 0x44	; 68
     c64:	99 e0       	ldi	r25, 0x09	; 9
     c66:	ba d4       	rcall	.+2420   	; 0x15dc <ringBufferPush>
     c68:	e1 ec       	ldi	r30, 0xC1	; 193
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	80 81       	ld	r24, Z
     c6e:	80 62       	ori	r24, 0x20	; 32
     c70:	80 83       	st	Z, r24
     c72:	e0 ec       	ldi	r30, 0xC0	; 192
     c74:	f0 e0       	ldi	r31, 0x00	; 0
     c76:	80 81       	ld	r24, Z
     c78:	80 64       	ori	r24, 0x40	; 64
     c7a:	80 83       	st	Z, r24
     c7c:	cf 91       	pop	r28
     c7e:	08 95       	ret

00000c80 <myUSART_transmitUSART1_c>:
     c80:	cf 93       	push	r28
     c82:	c8 2f       	mov	r28, r24
     c84:	8f e3       	ldi	r24, 0x3F	; 63
     c86:	99 e0       	ldi	r25, 0x09	; 9
     c88:	bf d4       	rcall	.+2430   	; 0x1608 <ringBufferFull>
     c8a:	81 11       	cpse	r24, r1
     c8c:	fb cf       	rjmp	.-10     	; 0xc84 <myUSART_transmitUSART1_c+0x4>
     c8e:	6c 2f       	mov	r22, r28
     c90:	8f e3       	ldi	r24, 0x3F	; 63
     c92:	99 e0       	ldi	r25, 0x09	; 9
     c94:	a3 d4       	rcall	.+2374   	; 0x15dc <ringBufferPush>
     c96:	e9 ec       	ldi	r30, 0xC9	; 201
     c98:	f0 e0       	ldi	r31, 0x00	; 0
     c9a:	80 81       	ld	r24, Z
     c9c:	80 62       	ori	r24, 0x20	; 32
     c9e:	80 83       	st	Z, r24
     ca0:	e8 ec       	ldi	r30, 0xC8	; 200
     ca2:	f0 e0       	ldi	r31, 0x00	; 0
     ca4:	80 81       	ld	r24, Z
     ca6:	80 64       	ori	r24, 0x40	; 64
     ca8:	80 83       	st	Z, r24
     caa:	cf 91       	pop	r28
     cac:	08 95       	ret

00000cae <myUSART_transmitUSART0>:
     cae:	cf 93       	push	r28
     cb0:	df 93       	push	r29
     cb2:	ec 01       	movw	r28, r24
     cb4:	88 81       	ld	r24, Y
     cb6:	88 23       	and	r24, r24
     cb8:	29 f0       	breq	.+10     	; 0xcc4 <myUSART_transmitUSART0+0x16>
     cba:	21 96       	adiw	r28, 0x01	; 1
     cbc:	ca df       	rcall	.-108    	; 0xc52 <myUSART_transmitUSART0_c>
     cbe:	89 91       	ld	r24, Y+
     cc0:	81 11       	cpse	r24, r1
     cc2:	fc cf       	rjmp	.-8      	; 0xcbc <myUSART_transmitUSART0+0xe>
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	08 95       	ret

00000cca <myUSART_receiveUSART1>:
     cca:	cf 93       	push	r28
     ccc:	20 e0       	ldi	r18, 0x00	; 0
     cce:	4f ef       	ldi	r20, 0xFF	; 255
     cd0:	5f ef       	ldi	r21, 0xFF	; 255
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	70 e0       	ldi	r23, 0x00	; 0
     cd6:	80 91 3b 09 	lds	r24, 0x093B
     cda:	90 91 3c 09 	lds	r25, 0x093C
     cde:	b2 d3       	rcall	.+1892   	; 0x1444 <xQueueGenericReceive>
     ce0:	89 e4       	ldi	r24, 0x49	; 73
     ce2:	99 e0       	ldi	r25, 0x09	; 9
     ce4:	69 d4       	rcall	.+2258   	; 0x15b8 <ringBufferPop>
     ce6:	c8 2f       	mov	r28, r24
     ce8:	89 e4       	ldi	r24, 0x49	; 73
     cea:	99 e0       	ldi	r25, 0x09	; 9
     cec:	94 d4       	rcall	.+2344   	; 0x1616 <ringBufferNotEmpty>
     cee:	88 23       	and	r24, r24
     cf0:	51 f0       	breq	.+20     	; 0xd06 <myUSART_receiveUSART1+0x3c>
     cf2:	20 e0       	ldi	r18, 0x00	; 0
     cf4:	40 e0       	ldi	r20, 0x00	; 0
     cf6:	50 e0       	ldi	r21, 0x00	; 0
     cf8:	60 e0       	ldi	r22, 0x00	; 0
     cfa:	70 e0       	ldi	r23, 0x00	; 0
     cfc:	80 91 3b 09 	lds	r24, 0x093B
     d00:	90 91 3c 09 	lds	r25, 0x093C
     d04:	aa d2       	rcall	.+1364   	; 0x125a <xQueueGenericSend>
     d06:	8c 2f       	mov	r24, r28
     d08:	cf 91       	pop	r28
     d0a:	08 95       	ret

00000d0c <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d0c:	de df       	rcall	.-68     	; 0xcca <myUSART_receiveUSART1>
     d0e:	81 11       	cpse	r24, r1
     d10:	0a c0       	rjmp	.+20     	; 0xd26 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     d12:	85 e5       	ldi	r24, 0x55	; 85
     d14:	b5 df       	rcall	.-150    	; 0xc80 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d16:	d9 df       	rcall	.-78     	; 0xcca <myUSART_receiveUSART1>
     d18:	91 e0       	ldi	r25, 0x01	; 1
     d1a:	81 11       	cpse	r24, r1
     d1c:	01 c0       	rjmp	.+2      	; 0xd20 <myUSART_waitForHandshake+0x14>
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	89 2f       	mov	r24, r25
     d22:	81 95       	neg	r24
     d24:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     d26:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     d28:	08 95       	ret

00000d2a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d2a:	31 e1       	ldi	r19, 0x11	; 17
     d2c:	fc 01       	movw	r30, r24
     d2e:	30 83       	st	Z, r19
     d30:	31 97       	sbiw	r30, 0x01	; 1
     d32:	22 e2       	ldi	r18, 0x22	; 34
     d34:	20 83       	st	Z, r18
     d36:	31 97       	sbiw	r30, 0x01	; 1
     d38:	a3 e3       	ldi	r26, 0x33	; 51
     d3a:	a0 83       	st	Z, r26
     d3c:	31 97       	sbiw	r30, 0x01	; 1
     d3e:	60 83       	st	Z, r22
     d40:	31 97       	sbiw	r30, 0x01	; 1
     d42:	70 83       	st	Z, r23
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	10 82       	st	Z, r1
     d48:	31 97       	sbiw	r30, 0x01	; 1
     d4a:	10 82       	st	Z, r1
     d4c:	31 97       	sbiw	r30, 0x01	; 1
     d4e:	60 e8       	ldi	r22, 0x80	; 128
     d50:	60 83       	st	Z, r22
     d52:	31 97       	sbiw	r30, 0x01	; 1
     d54:	10 82       	st	Z, r1
     d56:	31 97       	sbiw	r30, 0x01	; 1
     d58:	10 82       	st	Z, r1
     d5a:	31 97       	sbiw	r30, 0x01	; 1
     d5c:	10 82       	st	Z, r1
     d5e:	31 97       	sbiw	r30, 0x01	; 1
     d60:	62 e0       	ldi	r22, 0x02	; 2
     d62:	60 83       	st	Z, r22
     d64:	31 97       	sbiw	r30, 0x01	; 1
     d66:	63 e0       	ldi	r22, 0x03	; 3
     d68:	60 83       	st	Z, r22
     d6a:	31 97       	sbiw	r30, 0x01	; 1
     d6c:	64 e0       	ldi	r22, 0x04	; 4
     d6e:	60 83       	st	Z, r22
     d70:	31 97       	sbiw	r30, 0x01	; 1
     d72:	65 e0       	ldi	r22, 0x05	; 5
     d74:	60 83       	st	Z, r22
     d76:	31 97       	sbiw	r30, 0x01	; 1
     d78:	66 e0       	ldi	r22, 0x06	; 6
     d7a:	60 83       	st	Z, r22
     d7c:	31 97       	sbiw	r30, 0x01	; 1
     d7e:	67 e0       	ldi	r22, 0x07	; 7
     d80:	60 83       	st	Z, r22
     d82:	31 97       	sbiw	r30, 0x01	; 1
     d84:	68 e0       	ldi	r22, 0x08	; 8
     d86:	60 83       	st	Z, r22
     d88:	31 97       	sbiw	r30, 0x01	; 1
     d8a:	69 e0       	ldi	r22, 0x09	; 9
     d8c:	60 83       	st	Z, r22
     d8e:	31 97       	sbiw	r30, 0x01	; 1
     d90:	60 e1       	ldi	r22, 0x10	; 16
     d92:	60 83       	st	Z, r22
     d94:	31 97       	sbiw	r30, 0x01	; 1
     d96:	30 83       	st	Z, r19
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	32 e1       	ldi	r19, 0x12	; 18
     d9c:	30 83       	st	Z, r19
     d9e:	31 97       	sbiw	r30, 0x01	; 1
     da0:	33 e1       	ldi	r19, 0x13	; 19
     da2:	30 83       	st	Z, r19
     da4:	31 97       	sbiw	r30, 0x01	; 1
     da6:	34 e1       	ldi	r19, 0x14	; 20
     da8:	30 83       	st	Z, r19
     daa:	31 97       	sbiw	r30, 0x01	; 1
     dac:	35 e1       	ldi	r19, 0x15	; 21
     dae:	30 83       	st	Z, r19
     db0:	31 97       	sbiw	r30, 0x01	; 1
     db2:	36 e1       	ldi	r19, 0x16	; 22
     db4:	30 83       	st	Z, r19
     db6:	31 97       	sbiw	r30, 0x01	; 1
     db8:	37 e1       	ldi	r19, 0x17	; 23
     dba:	30 83       	st	Z, r19
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	38 e1       	ldi	r19, 0x18	; 24
     dc0:	30 83       	st	Z, r19
     dc2:	31 97       	sbiw	r30, 0x01	; 1
     dc4:	39 e1       	ldi	r19, 0x19	; 25
     dc6:	30 83       	st	Z, r19
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	30 e2       	ldi	r19, 0x20	; 32
     dcc:	30 83       	st	Z, r19
     dce:	31 97       	sbiw	r30, 0x01	; 1
     dd0:	31 e2       	ldi	r19, 0x21	; 33
     dd2:	30 83       	st	Z, r19
     dd4:	31 97       	sbiw	r30, 0x01	; 1
     dd6:	20 83       	st	Z, r18
     dd8:	31 97       	sbiw	r30, 0x01	; 1
     dda:	23 e2       	ldi	r18, 0x23	; 35
     ddc:	20 83       	st	Z, r18
     dde:	31 97       	sbiw	r30, 0x01	; 1
     de0:	40 83       	st	Z, r20
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	50 83       	st	Z, r21
     de6:	31 97       	sbiw	r30, 0x01	; 1
     de8:	26 e2       	ldi	r18, 0x26	; 38
     dea:	20 83       	st	Z, r18
     dec:	31 97       	sbiw	r30, 0x01	; 1
     dee:	27 e2       	ldi	r18, 0x27	; 39
     df0:	20 83       	st	Z, r18
     df2:	31 97       	sbiw	r30, 0x01	; 1
     df4:	28 e2       	ldi	r18, 0x28	; 40
     df6:	20 83       	st	Z, r18
     df8:	31 97       	sbiw	r30, 0x01	; 1
     dfa:	29 e2       	ldi	r18, 0x29	; 41
     dfc:	20 83       	st	Z, r18
     dfe:	31 97       	sbiw	r30, 0x01	; 1
     e00:	20 e3       	ldi	r18, 0x30	; 48
     e02:	20 83       	st	Z, r18
     e04:	31 97       	sbiw	r30, 0x01	; 1
     e06:	21 e3       	ldi	r18, 0x31	; 49
     e08:	20 83       	st	Z, r18
     e0a:	89 97       	sbiw	r24, 0x29	; 41
     e0c:	08 95       	ret

00000e0e <xPortStartScheduler>:
     e0e:	82 e0       	ldi	r24, 0x02	; 2
     e10:	84 bd       	out	0x24, r24	; 36
     e12:	16 bc       	out	0x26, r1	; 38
     e14:	80 e3       	ldi	r24, 0x30	; 48
     e16:	87 bd       	out	0x27, r24	; 39
     e18:	ee e6       	ldi	r30, 0x6E	; 110
     e1a:	f0 e0       	ldi	r31, 0x00	; 0
     e1c:	80 81       	ld	r24, Z
     e1e:	82 60       	ori	r24, 0x02	; 2
     e20:	80 83       	st	Z, r24
     e22:	83 e0       	ldi	r24, 0x03	; 3
     e24:	85 bd       	out	0x25, r24	; 37
     e26:	a0 91 97 08 	lds	r26, 0x0897
     e2a:	b0 91 98 08 	lds	r27, 0x0898
     e2e:	cd 91       	ld	r28, X+
     e30:	cd bf       	out	0x3d, r28	; 61
     e32:	dd 91       	ld	r29, X+
     e34:	de bf       	out	0x3e, r29	; 62
     e36:	ff 91       	pop	r31
     e38:	ef 91       	pop	r30
     e3a:	df 91       	pop	r29
     e3c:	cf 91       	pop	r28
     e3e:	bf 91       	pop	r27
     e40:	af 91       	pop	r26
     e42:	9f 91       	pop	r25
     e44:	8f 91       	pop	r24
     e46:	7f 91       	pop	r23
     e48:	6f 91       	pop	r22
     e4a:	5f 91       	pop	r21
     e4c:	4f 91       	pop	r20
     e4e:	3f 91       	pop	r19
     e50:	2f 91       	pop	r18
     e52:	1f 91       	pop	r17
     e54:	0f 91       	pop	r16
     e56:	ff 90       	pop	r15
     e58:	ef 90       	pop	r14
     e5a:	df 90       	pop	r13
     e5c:	cf 90       	pop	r12
     e5e:	bf 90       	pop	r11
     e60:	af 90       	pop	r10
     e62:	9f 90       	pop	r9
     e64:	8f 90       	pop	r8
     e66:	7f 90       	pop	r7
     e68:	6f 90       	pop	r6
     e6a:	5f 90       	pop	r5
     e6c:	4f 90       	pop	r4
     e6e:	3f 90       	pop	r3
     e70:	2f 90       	pop	r2
     e72:	1f 90       	pop	r1
     e74:	0f 90       	pop	r0
     e76:	0c be       	out	0x3c, r0	; 60
     e78:	0f 90       	pop	r0
     e7a:	0b be       	out	0x3b, r0	; 59
     e7c:	0f 90       	pop	r0
     e7e:	0f be       	out	0x3f, r0	; 63
     e80:	0f 90       	pop	r0
     e82:	08 95       	ret
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	08 95       	ret

00000e88 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e88:	0f 92       	push	r0
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	f8 94       	cli
     e8e:	0f 92       	push	r0
     e90:	0b b6       	in	r0, 0x3b	; 59
     e92:	0f 92       	push	r0
     e94:	0c b6       	in	r0, 0x3c	; 60
     e96:	0f 92       	push	r0
     e98:	1f 92       	push	r1
     e9a:	11 24       	eor	r1, r1
     e9c:	2f 92       	push	r2
     e9e:	3f 92       	push	r3
     ea0:	4f 92       	push	r4
     ea2:	5f 92       	push	r5
     ea4:	6f 92       	push	r6
     ea6:	7f 92       	push	r7
     ea8:	8f 92       	push	r8
     eaa:	9f 92       	push	r9
     eac:	af 92       	push	r10
     eae:	bf 92       	push	r11
     eb0:	cf 92       	push	r12
     eb2:	df 92       	push	r13
     eb4:	ef 92       	push	r14
     eb6:	ff 92       	push	r15
     eb8:	0f 93       	push	r16
     eba:	1f 93       	push	r17
     ebc:	2f 93       	push	r18
     ebe:	3f 93       	push	r19
     ec0:	4f 93       	push	r20
     ec2:	5f 93       	push	r21
     ec4:	6f 93       	push	r22
     ec6:	7f 93       	push	r23
     ec8:	8f 93       	push	r24
     eca:	9f 93       	push	r25
     ecc:	af 93       	push	r26
     ece:	bf 93       	push	r27
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
     ed4:	ef 93       	push	r30
     ed6:	ff 93       	push	r31
     ed8:	a0 91 97 08 	lds	r26, 0x0897
     edc:	b0 91 98 08 	lds	r27, 0x0898
     ee0:	0d b6       	in	r0, 0x3d	; 61
     ee2:	0d 92       	st	X+, r0
     ee4:	0e b6       	in	r0, 0x3e	; 62
     ee6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ee8:	64 d7       	rcall	.+3784   	; 0x1db2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     eea:	a0 91 97 08 	lds	r26, 0x0897
     eee:	b0 91 98 08 	lds	r27, 0x0898
     ef2:	cd 91       	ld	r28, X+
     ef4:	cd bf       	out	0x3d, r28	; 61
     ef6:	dd 91       	ld	r29, X+
     ef8:	de bf       	out	0x3e, r29	; 62
     efa:	ff 91       	pop	r31
     efc:	ef 91       	pop	r30
     efe:	df 91       	pop	r29
     f00:	cf 91       	pop	r28
     f02:	bf 91       	pop	r27
     f04:	af 91       	pop	r26
     f06:	9f 91       	pop	r25
     f08:	8f 91       	pop	r24
     f0a:	7f 91       	pop	r23
     f0c:	6f 91       	pop	r22
     f0e:	5f 91       	pop	r21
     f10:	4f 91       	pop	r20
     f12:	3f 91       	pop	r19
     f14:	2f 91       	pop	r18
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	ff 90       	pop	r15
     f1c:	ef 90       	pop	r14
     f1e:	df 90       	pop	r13
     f20:	cf 90       	pop	r12
     f22:	bf 90       	pop	r11
     f24:	af 90       	pop	r10
     f26:	9f 90       	pop	r9
     f28:	8f 90       	pop	r8
     f2a:	7f 90       	pop	r7
     f2c:	6f 90       	pop	r6
     f2e:	5f 90       	pop	r5
     f30:	4f 90       	pop	r4
     f32:	3f 90       	pop	r3
     f34:	2f 90       	pop	r2
     f36:	1f 90       	pop	r1
     f38:	0f 90       	pop	r0
     f3a:	0c be       	out	0x3c, r0	; 60
     f3c:	0f 90       	pop	r0
     f3e:	0b be       	out	0x3b, r0	; 59
     f40:	0f 90       	pop	r0
     f42:	0f be       	out	0x3f, r0	; 63
     f44:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f46:	08 95       	ret

00000f48 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f48:	0f 92       	push	r0
     f4a:	0f b6       	in	r0, 0x3f	; 63
     f4c:	f8 94       	cli
     f4e:	0f 92       	push	r0
     f50:	0b b6       	in	r0, 0x3b	; 59
     f52:	0f 92       	push	r0
     f54:	0c b6       	in	r0, 0x3c	; 60
     f56:	0f 92       	push	r0
     f58:	1f 92       	push	r1
     f5a:	11 24       	eor	r1, r1
     f5c:	2f 92       	push	r2
     f5e:	3f 92       	push	r3
     f60:	4f 92       	push	r4
     f62:	5f 92       	push	r5
     f64:	6f 92       	push	r6
     f66:	7f 92       	push	r7
     f68:	8f 92       	push	r8
     f6a:	9f 92       	push	r9
     f6c:	af 92       	push	r10
     f6e:	bf 92       	push	r11
     f70:	cf 92       	push	r12
     f72:	df 92       	push	r13
     f74:	ef 92       	push	r14
     f76:	ff 92       	push	r15
     f78:	0f 93       	push	r16
     f7a:	1f 93       	push	r17
     f7c:	2f 93       	push	r18
     f7e:	3f 93       	push	r19
     f80:	4f 93       	push	r20
     f82:	5f 93       	push	r21
     f84:	6f 93       	push	r22
     f86:	7f 93       	push	r23
     f88:	8f 93       	push	r24
     f8a:	9f 93       	push	r25
     f8c:	af 93       	push	r26
     f8e:	bf 93       	push	r27
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	ef 93       	push	r30
     f96:	ff 93       	push	r31
     f98:	a0 91 97 08 	lds	r26, 0x0897
     f9c:	b0 91 98 08 	lds	r27, 0x0898
     fa0:	0d b6       	in	r0, 0x3d	; 61
     fa2:	0d 92       	st	X+, r0
     fa4:	0e b6       	in	r0, 0x3e	; 62
     fa6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     fa8:	32 d5       	rcall	.+2660   	; 0x1a0e <xTaskIncrementTick>
     faa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     fac:	02 d7       	rcall	.+3588   	; 0x1db2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     fae:	a0 91 97 08 	lds	r26, 0x0897
     fb2:	b0 91 98 08 	lds	r27, 0x0898
     fb6:	cd 91       	ld	r28, X+
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	dd 91       	ld	r29, X+
     fbc:	de bf       	out	0x3e, r29	; 62
     fbe:	ff 91       	pop	r31
     fc0:	ef 91       	pop	r30
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	bf 91       	pop	r27
     fc8:	af 91       	pop	r26
     fca:	9f 91       	pop	r25
     fcc:	8f 91       	pop	r24
     fce:	7f 91       	pop	r23
     fd0:	6f 91       	pop	r22
     fd2:	5f 91       	pop	r21
     fd4:	4f 91       	pop	r20
     fd6:	3f 91       	pop	r19
     fd8:	2f 91       	pop	r18
     fda:	1f 91       	pop	r17
     fdc:	0f 91       	pop	r16
     fde:	ff 90       	pop	r15
     fe0:	ef 90       	pop	r14
     fe2:	df 90       	pop	r13
     fe4:	cf 90       	pop	r12
     fe6:	bf 90       	pop	r11
     fe8:	af 90       	pop	r10
     fea:	9f 90       	pop	r9
     fec:	8f 90       	pop	r8
     fee:	7f 90       	pop	r7
     ff0:	6f 90       	pop	r6
     ff2:	5f 90       	pop	r5
     ff4:	4f 90       	pop	r4
     ff6:	3f 90       	pop	r3
     ff8:	2f 90       	pop	r2
     ffa:	1f 90       	pop	r1
     ffc:	0f 90       	pop	r0
     ffe:	0c be       	out	0x3c, r0	; 60
    1000:	0f 90       	pop	r0
    1002:	0b be       	out	0x3b, r0	; 59
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	0f 90       	pop	r0

	asm volatile ( "ret" );
    100a:	08 95       	ret

0000100c <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    100c:	9d df       	rcall	.-198    	; 0xf48 <vPortYieldFromTick>
		 asm volatile ("reti");
    100e:	18 95       	reti

00001010 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	ec 01       	movw	r28, r24
    1018:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    101a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    101c:	81 11       	cpse	r24, r1
    101e:	0c c0       	rjmp	.+24     	; 0x1038 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1020:	88 81       	ld	r24, Y
    1022:	99 81       	ldd	r25, Y+1	; 0x01
    1024:	89 2b       	or	r24, r25
    1026:	09 f0       	breq	.+2      	; 0x102a <prvCopyDataToQueue+0x1a>
    1028:	47 c0       	rjmp	.+142    	; 0x10b8 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    102a:	8a 81       	ldd	r24, Y+2	; 0x02
    102c:	9b 81       	ldd	r25, Y+3	; 0x03
    102e:	0e 94 9c 10 	call	0x2138	; 0x2138 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1032:	1b 82       	std	Y+3, r1	; 0x03
    1034:	1a 82       	std	Y+2, r1	; 0x02
    1036:	47 c0       	rjmp	.+142    	; 0x10c6 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1038:	41 11       	cpse	r20, r1
    103a:	18 c0       	rjmp	.+48     	; 0x106c <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    103c:	48 2f       	mov	r20, r24
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	8c 81       	ldd	r24, Y+4	; 0x04
    1042:	9d 81       	ldd	r25, Y+5	; 0x05
    1044:	0e 94 14 11 	call	0x2228	; 0x2228 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1048:	2c 8d       	ldd	r18, Y+28	; 0x1c
    104a:	8c 81       	ldd	r24, Y+4	; 0x04
    104c:	9d 81       	ldd	r25, Y+5	; 0x05
    104e:	82 0f       	add	r24, r18
    1050:	91 1d       	adc	r25, r1
    1052:	9d 83       	std	Y+5, r25	; 0x05
    1054:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1056:	2a 81       	ldd	r18, Y+2	; 0x02
    1058:	3b 81       	ldd	r19, Y+3	; 0x03
    105a:	82 17       	cp	r24, r18
    105c:	93 07       	cpc	r25, r19
    105e:	70 f1       	brcs	.+92     	; 0x10bc <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1060:	88 81       	ld	r24, Y
    1062:	99 81       	ldd	r25, Y+1	; 0x01
    1064:	9d 83       	std	Y+5, r25	; 0x05
    1066:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1068:	80 e0       	ldi	r24, 0x00	; 0
    106a:	2d c0       	rjmp	.+90     	; 0x10c6 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    106c:	48 2f       	mov	r20, r24
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	8e 81       	ldd	r24, Y+6	; 0x06
    1072:	9f 81       	ldd	r25, Y+7	; 0x07
    1074:	0e 94 14 11 	call	0x2228	; 0x2228 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1078:	2c 8d       	ldd	r18, Y+28	; 0x1c
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	31 95       	neg	r19
    107e:	21 95       	neg	r18
    1080:	31 09       	sbc	r19, r1
    1082:	8e 81       	ldd	r24, Y+6	; 0x06
    1084:	9f 81       	ldd	r25, Y+7	; 0x07
    1086:	82 0f       	add	r24, r18
    1088:	93 1f       	adc	r25, r19
    108a:	9f 83       	std	Y+7, r25	; 0x07
    108c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    108e:	68 81       	ld	r22, Y
    1090:	79 81       	ldd	r23, Y+1	; 0x01
    1092:	86 17       	cp	r24, r22
    1094:	97 07       	cpc	r25, r23
    1096:	30 f4       	brcc	.+12     	; 0x10a4 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1098:	8a 81       	ldd	r24, Y+2	; 0x02
    109a:	9b 81       	ldd	r25, Y+3	; 0x03
    109c:	28 0f       	add	r18, r24
    109e:	39 1f       	adc	r19, r25
    10a0:	3f 83       	std	Y+7, r19	; 0x07
    10a2:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    10a4:	12 30       	cpi	r17, 0x02	; 2
    10a6:	61 f4       	brne	.+24     	; 0x10c0 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    10a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10aa:	88 23       	and	r24, r24
    10ac:	59 f0       	breq	.+22     	; 0x10c4 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    10ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10b0:	81 50       	subi	r24, 0x01	; 1
    10b2:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	07 c0       	rjmp	.+14     	; 0x10c6 <prvCopyDataToQueue+0xb6>
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	05 c0       	rjmp	.+10     	; 0x10c6 <prvCopyDataToQueue+0xb6>
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	03 c0       	rjmp	.+6      	; 0x10c6 <prvCopyDataToQueue+0xb6>
    10c0:	80 e0       	ldi	r24, 0x00	; 0
    10c2:	01 c0       	rjmp	.+2      	; 0x10c6 <prvCopyDataToQueue+0xb6>
    10c4:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    10c6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    10c8:	9f 5f       	subi	r25, 0xFF	; 255
    10ca:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    10cc:	df 91       	pop	r29
    10ce:	cf 91       	pop	r28
    10d0:	1f 91       	pop	r17
    10d2:	08 95       	ret

000010d4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    10d4:	fc 01       	movw	r30, r24
    10d6:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    10d8:	44 8d       	ldd	r20, Z+28	; 0x1c
    10da:	44 23       	and	r20, r20
    10dc:	a1 f0       	breq	.+40     	; 0x1106 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    10de:	50 e0       	ldi	r21, 0x00	; 0
    10e0:	26 81       	ldd	r18, Z+6	; 0x06
    10e2:	37 81       	ldd	r19, Z+7	; 0x07
    10e4:	24 0f       	add	r18, r20
    10e6:	35 1f       	adc	r19, r21
    10e8:	37 83       	std	Z+7, r19	; 0x07
    10ea:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    10ec:	62 81       	ldd	r22, Z+2	; 0x02
    10ee:	73 81       	ldd	r23, Z+3	; 0x03
    10f0:	26 17       	cp	r18, r22
    10f2:	37 07       	cpc	r19, r23
    10f4:	20 f0       	brcs	.+8      	; 0x10fe <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    10f6:	20 81       	ld	r18, Z
    10f8:	31 81       	ldd	r19, Z+1	; 0x01
    10fa:	37 83       	std	Z+7, r19	; 0x07
    10fc:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    10fe:	66 81       	ldd	r22, Z+6	; 0x06
    1100:	77 81       	ldd	r23, Z+7	; 0x07
    1102:	0c 94 14 11 	jmp	0x2228	; 0x2228 <memcpy>
    1106:	08 95       	ret

00001108 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
    1110:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1112:	0f b6       	in	r0, 0x3f	; 63
    1114:	f8 94       	cli
    1116:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1118:	8e 8d       	ldd	r24, Y+30	; 0x1e
    111a:	18 16       	cp	r1, r24
    111c:	a4 f4       	brge	.+40     	; 0x1146 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    111e:	89 89       	ldd	r24, Y+17	; 0x11
    1120:	88 23       	and	r24, r24
    1122:	89 f0       	breq	.+34     	; 0x1146 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1124:	8e 01       	movw	r16, r28
    1126:	0f 5e       	subi	r16, 0xEF	; 239
    1128:	1f 4f       	sbci	r17, 0xFF	; 255
    112a:	03 c0       	rjmp	.+6      	; 0x1132 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    112c:	89 89       	ldd	r24, Y+17	; 0x11
    112e:	88 23       	and	r24, r24
    1130:	51 f0       	breq	.+20     	; 0x1146 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1132:	c8 01       	movw	r24, r16
    1134:	14 d7       	rcall	.+3624   	; 0x1f5e <xTaskRemoveFromEventList>
    1136:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1138:	9d d7       	rcall	.+3898   	; 0x2074 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    113a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    113c:	81 50       	subi	r24, 0x01	; 1
    113e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1140:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1142:	18 16       	cp	r1, r24
    1144:	9c f3       	brlt	.-26     	; 0x112c <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1146:	8f ef       	ldi	r24, 0xFF	; 255
    1148:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    114a:	0f 90       	pop	r0
    114c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1154:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1156:	18 16       	cp	r1, r24
    1158:	a4 f4       	brge	.+40     	; 0x1182 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    115a:	88 85       	ldd	r24, Y+8	; 0x08
    115c:	88 23       	and	r24, r24
    115e:	89 f0       	breq	.+34     	; 0x1182 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1160:	8e 01       	movw	r16, r28
    1162:	08 5f       	subi	r16, 0xF8	; 248
    1164:	1f 4f       	sbci	r17, 0xFF	; 255
    1166:	03 c0       	rjmp	.+6      	; 0x116e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1168:	88 85       	ldd	r24, Y+8	; 0x08
    116a:	88 23       	and	r24, r24
    116c:	51 f0       	breq	.+20     	; 0x1182 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    116e:	c8 01       	movw	r24, r16
    1170:	f6 d6       	rcall	.+3564   	; 0x1f5e <xTaskRemoveFromEventList>
    1172:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1174:	7f d7       	rcall	.+3838   	; 0x2074 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1176:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1178:	81 50       	subi	r24, 0x01	; 1
    117a:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    117c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    117e:	18 16       	cp	r1, r24
    1180:	9c f3       	brlt	.-26     	; 0x1168 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1182:	8f ef       	ldi	r24, 0xFF	; 255
    1184:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1186:	0f 90       	pop	r0
    1188:	0f be       	out	0x3f, r0	; 63
}
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	1f 91       	pop	r17
    1190:	0f 91       	pop	r16
    1192:	08 95       	ret

00001194 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1194:	cf 93       	push	r28
    1196:	df 93       	push	r29
    1198:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    119a:	0f b6       	in	r0, 0x3f	; 63
    119c:	f8 94       	cli
    119e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    11a0:	88 81       	ld	r24, Y
    11a2:	99 81       	ldd	r25, Y+1	; 0x01
    11a4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11a6:	30 e0       	ldi	r19, 0x00	; 0
    11a8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    11aa:	72 9f       	mul	r23, r18
    11ac:	a0 01       	movw	r20, r0
    11ae:	73 9f       	mul	r23, r19
    11b0:	50 0d       	add	r21, r0
    11b2:	11 24       	eor	r1, r1
    11b4:	fc 01       	movw	r30, r24
    11b6:	e4 0f       	add	r30, r20
    11b8:	f5 1f       	adc	r31, r21
    11ba:	fb 83       	std	Y+3, r31	; 0x03
    11bc:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    11be:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    11c0:	9d 83       	std	Y+5, r25	; 0x05
    11c2:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    11c4:	42 1b       	sub	r20, r18
    11c6:	53 0b       	sbc	r21, r19
    11c8:	84 0f       	add	r24, r20
    11ca:	95 1f       	adc	r25, r21
    11cc:	9f 83       	std	Y+7, r25	; 0x07
    11ce:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    11d4:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    11d6:	61 11       	cpse	r22, r1
    11d8:	0a c0       	rjmp	.+20     	; 0x11ee <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11da:	88 85       	ldd	r24, Y+8	; 0x08
    11dc:	88 23       	and	r24, r24
    11de:	69 f0       	breq	.+26     	; 0x11fa <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    11e0:	ce 01       	movw	r24, r28
    11e2:	08 96       	adiw	r24, 0x08	; 8
    11e4:	bc d6       	rcall	.+3448   	; 0x1f5e <xTaskRemoveFromEventList>
    11e6:	81 30       	cpi	r24, 0x01	; 1
    11e8:	41 f4       	brne	.+16     	; 0x11fa <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    11ea:	4e de       	rcall	.-868    	; 0xe88 <vPortYield>
    11ec:	06 c0       	rjmp	.+12     	; 0x11fa <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    11ee:	ce 01       	movw	r24, r28
    11f0:	08 96       	adiw	r24, 0x08	; 8
    11f2:	49 d9       	rcall	.-3438   	; 0x486 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    11f4:	ce 01       	movw	r24, r28
    11f6:	41 96       	adiw	r24, 0x11	; 17
    11f8:	46 d9       	rcall	.-3444   	; 0x486 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	08 95       	ret

00001206 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1206:	0f 93       	push	r16
    1208:	1f 93       	push	r17
    120a:	cf 93       	push	r28
    120c:	df 93       	push	r29
    120e:	18 2f       	mov	r17, r24
    1210:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1212:	88 23       	and	r24, r24
    1214:	d1 f0       	breq	.+52     	; 0x124a <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1216:	8f e1       	ldi	r24, 0x1F	; 31
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	ff d8       	rcall	.-3586   	; 0x41a <pvPortMalloc>
    121c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    121e:	00 97       	sbiw	r24, 0x00	; 0
    1220:	b1 f0       	breq	.+44     	; 0x124e <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1222:	10 9f       	mul	r17, r16
    1224:	c0 01       	movw	r24, r0
    1226:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	f7 d8       	rcall	.-3602   	; 0x41a <pvPortMalloc>
    122c:	99 83       	std	Y+1, r25	; 0x01
    122e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1230:	89 2b       	or	r24, r25
    1232:	31 f0       	breq	.+12     	; 0x1240 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1234:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1236:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1238:	61 e0       	ldi	r22, 0x01	; 1
    123a:	ce 01       	movw	r24, r28
    123c:	ab df       	rcall	.-170    	; 0x1194 <xQueueGenericReset>
    123e:	07 c0       	rjmp	.+14     	; 0x124e <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1240:	ce 01       	movw	r24, r28
    1242:	20 d9       	rcall	.-3520   	; 0x484 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1244:	c0 e0       	ldi	r28, 0x00	; 0
    1246:	d0 e0       	ldi	r29, 0x00	; 0
    1248:	02 c0       	rjmp	.+4      	; 0x124e <xQueueGenericCreate+0x48>
    124a:	c0 e0       	ldi	r28, 0x00	; 0
    124c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    124e:	ce 01       	movw	r24, r28
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    125a:	9f 92       	push	r9
    125c:	af 92       	push	r10
    125e:	bf 92       	push	r11
    1260:	cf 92       	push	r12
    1262:	df 92       	push	r13
    1264:	ef 92       	push	r14
    1266:	ff 92       	push	r15
    1268:	0f 93       	push	r16
    126a:	1f 93       	push	r17
    126c:	cf 93       	push	r28
    126e:	df 93       	push	r29
    1270:	00 d0       	rcall	.+0      	; 0x1272 <xQueueGenericSend+0x18>
    1272:	1f 92       	push	r1
    1274:	1f 92       	push	r1
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	8c 01       	movw	r16, r24
    127c:	6b 01       	movw	r12, r22
    127e:	5d 83       	std	Y+5, r21	; 0x05
    1280:	4c 83       	std	Y+4, r20	; 0x04
    1282:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1284:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1286:	99 24       	eor	r9, r9
    1288:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    128a:	7c 01       	movw	r14, r24
    128c:	88 e0       	ldi	r24, 0x08	; 8
    128e:	e8 0e       	add	r14, r24
    1290:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1298:	f8 01       	movw	r30, r16
    129a:	92 8d       	ldd	r25, Z+26	; 0x1a
    129c:	83 8d       	ldd	r24, Z+27	; 0x1b
    129e:	98 17       	cp	r25, r24
    12a0:	18 f0       	brcs	.+6      	; 0x12a8 <xQueueGenericSend+0x4e>
    12a2:	f2 e0       	ldi	r31, 0x02	; 2
    12a4:	af 12       	cpse	r10, r31
    12a6:	15 c0       	rjmp	.+42     	; 0x12d2 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12a8:	4a 2d       	mov	r20, r10
    12aa:	b6 01       	movw	r22, r12
    12ac:	c8 01       	movw	r24, r16
    12ae:	b0 de       	rcall	.-672    	; 0x1010 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12b0:	f8 01       	movw	r30, r16
    12b2:	91 89       	ldd	r25, Z+17	; 0x11
    12b4:	99 23       	and	r25, r25
    12b6:	39 f0       	breq	.+14     	; 0x12c6 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    12b8:	c8 01       	movw	r24, r16
    12ba:	41 96       	adiw	r24, 0x11	; 17
    12bc:	50 d6       	rcall	.+3232   	; 0x1f5e <xTaskRemoveFromEventList>
    12be:	81 30       	cpi	r24, 0x01	; 1
    12c0:	21 f4       	brne	.+8      	; 0x12ca <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    12c2:	e2 dd       	rcall	.-1084   	; 0xe88 <vPortYield>
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    12c6:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    12c8:	df dd       	rcall	.-1090   	; 0xe88 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    12ca:	0f 90       	pop	r0
    12cc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    12ce:	81 e0       	ldi	r24, 0x01	; 1
    12d0:	46 c0       	rjmp	.+140    	; 0x135e <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    12d2:	ec 81       	ldd	r30, Y+4	; 0x04
    12d4:	fd 81       	ldd	r31, Y+5	; 0x05
    12d6:	ef 2b       	or	r30, r31
    12d8:	21 f4       	brne	.+8      	; 0x12e2 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    12da:	0f 90       	pop	r0
    12dc:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12de:	80 e0       	ldi	r24, 0x00	; 0
    12e0:	3e c0       	rjmp	.+124    	; 0x135e <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    12e2:	b1 10       	cpse	r11, r1
    12e4:	04 c0       	rjmp	.+8      	; 0x12ee <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12e6:	ce 01       	movw	r24, r28
    12e8:	01 96       	adiw	r24, 0x01	; 1
    12ea:	81 d6       	rcall	.+3330   	; 0x1fee <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12ec:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12f2:	78 d3       	rcall	.+1776   	; 0x19e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
    12fa:	f8 01       	movw	r30, r16
    12fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    12fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1300:	09 f4       	brne	.+2      	; 0x1304 <xQueueGenericSend+0xaa>
    1302:	15 8e       	std	Z+29, r1	; 0x1d
    1304:	f8 01       	movw	r30, r16
    1306:	86 8d       	ldd	r24, Z+30	; 0x1e
    1308:	8f 3f       	cpi	r24, 0xFF	; 255
    130a:	09 f4       	brne	.+2      	; 0x130e <xQueueGenericSend+0xb4>
    130c:	16 8e       	std	Z+30, r1	; 0x1e
    130e:	0f 90       	pop	r0
    1310:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1312:	be 01       	movw	r22, r28
    1314:	6c 5f       	subi	r22, 0xFC	; 252
    1316:	7f 4f       	sbci	r23, 0xFF	; 255
    1318:	ce 01       	movw	r24, r28
    131a:	01 96       	adiw	r24, 0x01	; 1
    131c:	73 d6       	rcall	.+3302   	; 0x2004 <xTaskCheckForTimeOut>
    131e:	81 11       	cpse	r24, r1
    1320:	1a c0       	rjmp	.+52     	; 0x1356 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1322:	0f b6       	in	r0, 0x3f	; 63
    1324:	f8 94       	cli
    1326:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1328:	f8 01       	movw	r30, r16
    132a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1330:	f8 01       	movw	r30, r16
    1332:	83 8d       	ldd	r24, Z+27	; 0x1b
    1334:	98 13       	cpse	r25, r24
    1336:	0b c0       	rjmp	.+22     	; 0x134e <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1338:	6c 81       	ldd	r22, Y+4	; 0x04
    133a:	7d 81       	ldd	r23, Y+5	; 0x05
    133c:	c7 01       	movw	r24, r14
    133e:	e4 d5       	rcall	.+3016   	; 0x1f08 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1340:	c8 01       	movw	r24, r16
    1342:	e2 de       	rcall	.-572    	; 0x1108 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1344:	22 d4       	rcall	.+2116   	; 0x1b8a <xTaskResumeAll>
    1346:	81 11       	cpse	r24, r1
    1348:	a4 cf       	rjmp	.-184    	; 0x1292 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    134a:	9e dd       	rcall	.-1220   	; 0xe88 <vPortYield>
    134c:	a2 cf       	rjmp	.-188    	; 0x1292 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    134e:	c8 01       	movw	r24, r16
    1350:	db de       	rcall	.-586    	; 0x1108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1352:	1b d4       	rcall	.+2102   	; 0x1b8a <xTaskResumeAll>
    1354:	9e cf       	rjmp	.-196    	; 0x1292 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1356:	c8 01       	movw	r24, r16
    1358:	d7 de       	rcall	.-594    	; 0x1108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    135a:	17 d4       	rcall	.+2094   	; 0x1b8a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    135c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    135e:	0f 90       	pop	r0
    1360:	0f 90       	pop	r0
    1362:	0f 90       	pop	r0
    1364:	0f 90       	pop	r0
    1366:	0f 90       	pop	r0
    1368:	df 91       	pop	r29
    136a:	cf 91       	pop	r28
    136c:	1f 91       	pop	r17
    136e:	0f 91       	pop	r16
    1370:	ff 90       	pop	r15
    1372:	ef 90       	pop	r14
    1374:	df 90       	pop	r13
    1376:	cf 90       	pop	r12
    1378:	bf 90       	pop	r11
    137a:	af 90       	pop	r10
    137c:	9f 90       	pop	r9
    137e:	08 95       	ret

00001380 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1380:	cf 93       	push	r28
    1382:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1384:	8f e1       	ldi	r24, 0x1F	; 31
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	48 d8       	rcall	.-3952   	; 0x41a <pvPortMalloc>
    138a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    138c:	00 97       	sbiw	r24, 0x00	; 0
    138e:	e1 f0       	breq	.+56     	; 0x13c8 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1390:	1b 82       	std	Y+3, r1	; 0x03
    1392:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1394:	19 82       	std	Y+1, r1	; 0x01
    1396:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1398:	1d 82       	std	Y+5, r1	; 0x05
    139a:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    139c:	1f 82       	std	Y+7, r1	; 0x07
    139e:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    13a0:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    13a2:	81 e0       	ldi	r24, 0x01	; 1
    13a4:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    13a6:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    13a8:	8f ef       	ldi	r24, 0xFF	; 255
    13aa:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    13ac:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    13ae:	ce 01       	movw	r24, r28
    13b0:	08 96       	adiw	r24, 0x08	; 8
    13b2:	69 d8       	rcall	.-3886   	; 0x486 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    13b4:	ce 01       	movw	r24, r28
    13b6:	41 96       	adiw	r24, 0x11	; 17
    13b8:	66 d8       	rcall	.-3892   	; 0x486 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    13ba:	20 e0       	ldi	r18, 0x00	; 0
    13bc:	40 e0       	ldi	r20, 0x00	; 0
    13be:	50 e0       	ldi	r21, 0x00	; 0
    13c0:	60 e0       	ldi	r22, 0x00	; 0
    13c2:	70 e0       	ldi	r23, 0x00	; 0
    13c4:	ce 01       	movw	r24, r28
    13c6:	49 df       	rcall	.-366    	; 0x125a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    13c8:	ce 01       	movw	r24, r28
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	08 95       	ret

000013d0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	ec 01       	movw	r28, r24
    13da:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13e0:	98 17       	cp	r25, r24
    13e2:	10 f0       	brcs	.+4      	; 0x13e8 <xQueueGenericSendFromISR+0x18>
    13e4:	22 30       	cpi	r18, 0x02	; 2
    13e6:	11 f5       	brne	.+68     	; 0x142c <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    13e8:	42 2f       	mov	r20, r18
    13ea:	ce 01       	movw	r24, r28
    13ec:	11 de       	rcall	.-990    	; 0x1010 <prvCopyDataToQueue>
    13ee:	88 23       	and	r24, r24
    13f0:	31 f0       	breq	.+12     	; 0x13fe <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    13f2:	01 15       	cp	r16, r1
    13f4:	11 05       	cpc	r17, r1
    13f6:	19 f0       	breq	.+6      	; 0x13fe <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	f8 01       	movw	r30, r16
    13fc:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1400:	8f 3f       	cpi	r24, 0xFF	; 255
    1402:	79 f4       	brne	.+30     	; 0x1422 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1404:	89 89       	ldd	r24, Y+17	; 0x11
    1406:	88 23       	and	r24, r24
    1408:	99 f0       	breq	.+38     	; 0x1430 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    140a:	ce 01       	movw	r24, r28
    140c:	41 96       	adiw	r24, 0x11	; 17
    140e:	a7 d5       	rcall	.+2894   	; 0x1f5e <xTaskRemoveFromEventList>
    1410:	88 23       	and	r24, r24
    1412:	81 f0       	breq	.+32     	; 0x1434 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1414:	01 15       	cp	r16, r1
    1416:	11 05       	cpc	r17, r1
    1418:	79 f0       	breq	.+30     	; 0x1438 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	f8 01       	movw	r30, r16
    141e:	80 83       	st	Z, r24
    1420:	0c c0       	rjmp	.+24     	; 0x143a <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1422:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1424:	8f 5f       	subi	r24, 0xFF	; 255
    1426:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	07 c0       	rjmp	.+14     	; 0x143a <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	05 c0       	rjmp	.+10     	; 0x143a <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1430:	81 e0       	ldi	r24, 0x01	; 1
    1432:	03 c0       	rjmp	.+6      	; 0x143a <xQueueGenericSendFromISR+0x6a>
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	01 c0       	rjmp	.+2      	; 0x143a <xQueueGenericSendFromISR+0x6a>
    1438:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    143a:	df 91       	pop	r29
    143c:	cf 91       	pop	r28
    143e:	1f 91       	pop	r17
    1440:	0f 91       	pop	r16
    1442:	08 95       	ret

00001444 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1444:	9f 92       	push	r9
    1446:	af 92       	push	r10
    1448:	bf 92       	push	r11
    144a:	cf 92       	push	r12
    144c:	df 92       	push	r13
    144e:	ef 92       	push	r14
    1450:	ff 92       	push	r15
    1452:	0f 93       	push	r16
    1454:	1f 93       	push	r17
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	00 d0       	rcall	.+0      	; 0x145c <xQueueGenericReceive+0x18>
    145c:	1f 92       	push	r1
    145e:	1f 92       	push	r1
    1460:	cd b7       	in	r28, 0x3d	; 61
    1462:	de b7       	in	r29, 0x3e	; 62
    1464:	8c 01       	movw	r16, r24
    1466:	6b 01       	movw	r12, r22
    1468:	5d 83       	std	Y+5, r21	; 0x05
    146a:	4c 83       	std	Y+4, r20	; 0x04
    146c:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    146e:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1470:	99 24       	eor	r9, r9
    1472:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1474:	7c 01       	movw	r14, r24
    1476:	81 e1       	ldi	r24, 0x11	; 17
    1478:	e8 0e       	add	r14, r24
    147a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    147c:	0f b6       	in	r0, 0x3f	; 63
    147e:	f8 94       	cli
    1480:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1482:	f8 01       	movw	r30, r16
    1484:	82 8d       	ldd	r24, Z+26	; 0x1a
    1486:	88 23       	and	r24, r24
    1488:	69 f1       	breq	.+90     	; 0x14e4 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    148a:	e6 80       	ldd	r14, Z+6	; 0x06
    148c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    148e:	b6 01       	movw	r22, r12
    1490:	c8 01       	movw	r24, r16
    1492:	20 de       	rcall	.-960    	; 0x10d4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1494:	b1 10       	cpse	r11, r1
    1496:	17 c0       	rjmp	.+46     	; 0x14c6 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1498:	f8 01       	movw	r30, r16
    149a:	82 8d       	ldd	r24, Z+26	; 0x1a
    149c:	81 50       	subi	r24, 0x01	; 1
    149e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14a0:	80 81       	ld	r24, Z
    14a2:	91 81       	ldd	r25, Z+1	; 0x01
    14a4:	89 2b       	or	r24, r25
    14a6:	21 f4       	brne	.+8      	; 0x14b0 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    14a8:	86 d6       	rcall	.+3340   	; 0x21b6 <pvTaskIncrementMutexHeldCount>
    14aa:	f8 01       	movw	r30, r16
    14ac:	93 83       	std	Z+3, r25	; 0x03
    14ae:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14b0:	f8 01       	movw	r30, r16
    14b2:	80 85       	ldd	r24, Z+8	; 0x08
    14b4:	88 23       	and	r24, r24
    14b6:	91 f0       	breq	.+36     	; 0x14dc <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    14b8:	c8 01       	movw	r24, r16
    14ba:	08 96       	adiw	r24, 0x08	; 8
    14bc:	50 d5       	rcall	.+2720   	; 0x1f5e <xTaskRemoveFromEventList>
    14be:	81 30       	cpi	r24, 0x01	; 1
    14c0:	69 f4       	brne	.+26     	; 0x14dc <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    14c2:	e2 dc       	rcall	.-1596   	; 0xe88 <vPortYield>
    14c4:	0b c0       	rjmp	.+22     	; 0x14dc <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    14c6:	f8 01       	movw	r30, r16
    14c8:	f7 82       	std	Z+7, r15	; 0x07
    14ca:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14cc:	81 89       	ldd	r24, Z+17	; 0x11
    14ce:	88 23       	and	r24, r24
    14d0:	29 f0       	breq	.+10     	; 0x14dc <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14d2:	c8 01       	movw	r24, r16
    14d4:	41 96       	adiw	r24, 0x11	; 17
    14d6:	43 d5       	rcall	.+2694   	; 0x1f5e <xTaskRemoveFromEventList>
    14d8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    14da:	d6 dc       	rcall	.-1620   	; 0xe88 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	52 c0       	rjmp	.+164    	; 0x1588 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14e4:	4c 81       	ldd	r20, Y+4	; 0x04
    14e6:	5d 81       	ldd	r21, Y+5	; 0x05
    14e8:	45 2b       	or	r20, r21
    14ea:	21 f4       	brne	.+8      	; 0x14f4 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14ec:	0f 90       	pop	r0
    14ee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	4a c0       	rjmp	.+148    	; 0x1588 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    14f4:	a1 10       	cpse	r10, r1
    14f6:	04 c0       	rjmp	.+8      	; 0x1500 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14f8:	ce 01       	movw	r24, r28
    14fa:	01 96       	adiw	r24, 0x01	; 1
    14fc:	78 d5       	rcall	.+2800   	; 0x1fee <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14fe:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1500:	0f 90       	pop	r0
    1502:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1504:	6f d2       	rcall	.+1246   	; 0x19e4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	f8 94       	cli
    150a:	0f 92       	push	r0
    150c:	f8 01       	movw	r30, r16
    150e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1510:	8f 3f       	cpi	r24, 0xFF	; 255
    1512:	09 f4       	brne	.+2      	; 0x1516 <xQueueGenericReceive+0xd2>
    1514:	15 8e       	std	Z+29, r1	; 0x1d
    1516:	f8 01       	movw	r30, r16
    1518:	86 8d       	ldd	r24, Z+30	; 0x1e
    151a:	8f 3f       	cpi	r24, 0xFF	; 255
    151c:	09 f4       	brne	.+2      	; 0x1520 <xQueueGenericReceive+0xdc>
    151e:	16 8e       	std	Z+30, r1	; 0x1e
    1520:	0f 90       	pop	r0
    1522:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1524:	be 01       	movw	r22, r28
    1526:	6c 5f       	subi	r22, 0xFC	; 252
    1528:	7f 4f       	sbci	r23, 0xFF	; 255
    152a:	ce 01       	movw	r24, r28
    152c:	01 96       	adiw	r24, 0x01	; 1
    152e:	6a d5       	rcall	.+2772   	; 0x2004 <xTaskCheckForTimeOut>
    1530:	81 11       	cpse	r24, r1
    1532:	26 c0       	rjmp	.+76     	; 0x1580 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1534:	0f b6       	in	r0, 0x3f	; 63
    1536:	f8 94       	cli
    1538:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    153a:	f8 01       	movw	r30, r16
    153c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1542:	81 11       	cpse	r24, r1
    1544:	19 c0       	rjmp	.+50     	; 0x1578 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1546:	f8 01       	movw	r30, r16
    1548:	80 81       	ld	r24, Z
    154a:	91 81       	ldd	r25, Z+1	; 0x01
    154c:	89 2b       	or	r24, r25
    154e:	49 f4       	brne	.+18     	; 0x1562 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	f8 94       	cli
    1554:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1556:	f8 01       	movw	r30, r16
    1558:	82 81       	ldd	r24, Z+2	; 0x02
    155a:	93 81       	ldd	r25, Z+3	; 0x03
    155c:	8f d5       	rcall	.+2846   	; 0x207c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    155e:	0f 90       	pop	r0
    1560:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1562:	6c 81       	ldd	r22, Y+4	; 0x04
    1564:	7d 81       	ldd	r23, Y+5	; 0x05
    1566:	c7 01       	movw	r24, r14
    1568:	cf d4       	rcall	.+2462   	; 0x1f08 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    156a:	c8 01       	movw	r24, r16
    156c:	cd dd       	rcall	.-1126   	; 0x1108 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    156e:	0d d3       	rcall	.+1562   	; 0x1b8a <xTaskResumeAll>
    1570:	81 11       	cpse	r24, r1
    1572:	84 cf       	rjmp	.-248    	; 0x147c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1574:	89 dc       	rcall	.-1774   	; 0xe88 <vPortYield>
    1576:	82 cf       	rjmp	.-252    	; 0x147c <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1578:	c8 01       	movw	r24, r16
    157a:	c6 dd       	rcall	.-1140   	; 0x1108 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    157c:	06 d3       	rcall	.+1548   	; 0x1b8a <xTaskResumeAll>
    157e:	7e cf       	rjmp	.-260    	; 0x147c <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1580:	c8 01       	movw	r24, r16
    1582:	c2 dd       	rcall	.-1148   	; 0x1108 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1584:	02 d3       	rcall	.+1540   	; 0x1b8a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1586:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1588:	0f 90       	pop	r0
    158a:	0f 90       	pop	r0
    158c:	0f 90       	pop	r0
    158e:	0f 90       	pop	r0
    1590:	0f 90       	pop	r0
    1592:	df 91       	pop	r29
    1594:	cf 91       	pop	r28
    1596:	1f 91       	pop	r17
    1598:	0f 91       	pop	r16
    159a:	ff 90       	pop	r15
    159c:	ef 90       	pop	r14
    159e:	df 90       	pop	r13
    15a0:	cf 90       	pop	r12
    15a2:	bf 90       	pop	r11
    15a4:	af 90       	pop	r10
    15a6:	9f 90       	pop	r9
    15a8:	08 95       	ret

000015aa <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    15aa:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    15ac:	71 83       	std	Z+1, r23	; 0x01
    15ae:	60 83       	st	Z, r22
	ring->rSize = size;
    15b0:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    15b2:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    15b4:	13 82       	std	Z+3, r1	; 0x03
    15b6:	08 95       	ret

000015b8 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    15b8:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    15ba:	94 81       	ldd	r25, Z+4	; 0x04
    15bc:	a0 81       	ld	r26, Z
    15be:	b1 81       	ldd	r27, Z+1	; 0x01
    15c0:	a9 0f       	add	r26, r25
    15c2:	b1 1d       	adc	r27, r1
    15c4:	8c 91       	ld	r24, X
            ring->rIndex ++;
    15c6:	9f 5f       	subi	r25, 0xFF	; 255
    15c8:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    15ca:	22 81       	ldd	r18, Z+2	; 0x02
    15cc:	92 17       	cp	r25, r18
    15ce:	10 f0       	brcs	.+4      	; 0x15d4 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    15d0:	92 1b       	sub	r25, r18
    15d2:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    15d4:	93 81       	ldd	r25, Z+3	; 0x03
    15d6:	91 50       	subi	r25, 0x01	; 1
    15d8:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    15da:	08 95       	ret

000015dc <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    15dc:	fc 01       	movw	r30, r24
    15de:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    15e0:	83 81       	ldd	r24, Z+3	; 0x03
    15e2:	22 81       	ldd	r18, Z+2	; 0x02
    15e4:	82 17       	cp	r24, r18
    15e6:	78 f4       	brcc	.+30     	; 0x1606 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    15e8:	34 81       	ldd	r19, Z+4	; 0x04
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	83 0f       	add	r24, r19
    15ee:	91 1d       	adc	r25, r1
    15f0:	62 2f       	mov	r22, r18
    15f2:	70 e0       	ldi	r23, 0x00	; 0
    15f4:	f2 d5       	rcall	.+3044   	; 0x21da <__divmodhi4>
    15f6:	a0 81       	ld	r26, Z
    15f8:	b1 81       	ldd	r27, Z+1	; 0x01
    15fa:	a8 0f       	add	r26, r24
    15fc:	b9 1f       	adc	r27, r25
    15fe:	4c 93       	st	X, r20
            ring->rLength++;
    1600:	83 81       	ldd	r24, Z+3	; 0x03
    1602:	8f 5f       	subi	r24, 0xFF	; 255
    1604:	83 83       	std	Z+3, r24	; 0x03
    1606:	08 95       	ret

00001608 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1608:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	22 81       	ldd	r18, Z+2	; 0x02
    160e:	93 81       	ldd	r25, Z+3	; 0x03
    1610:	29 13       	cpse	r18, r25
    1612:	80 e0       	ldi	r24, 0x00	; 0
}
    1614:	08 95       	ret

00001616 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1616:	21 e0       	ldi	r18, 0x01	; 1
    1618:	fc 01       	movw	r30, r24
    161a:	83 81       	ldd	r24, Z+3	; 0x03
    161c:	81 11       	cpse	r24, r1
    161e:	01 c0       	rjmp	.+2      	; 0x1622 <ringBufferNotEmpty+0xc>
    1620:	20 e0       	ldi	r18, 0x00	; 0
}
    1622:	82 2f       	mov	r24, r18
    1624:	08 95       	ret

00001626 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1626:	e0 91 56 08 	lds	r30, 0x0856
    162a:	f0 91 57 08 	lds	r31, 0x0857
    162e:	80 81       	ld	r24, Z
    1630:	81 11       	cpse	r24, r1
    1632:	07 c0       	rjmp	.+14     	; 0x1642 <prvResetNextTaskUnblockTime+0x1c>
    1634:	8f ef       	ldi	r24, 0xFF	; 255
    1636:	9f ef       	ldi	r25, 0xFF	; 255
    1638:	90 93 05 02 	sts	0x0205, r25
    163c:	80 93 04 02 	sts	0x0204, r24
    1640:	08 95       	ret
    1642:	e0 91 56 08 	lds	r30, 0x0856
    1646:	f0 91 57 08 	lds	r31, 0x0857
    164a:	05 80       	ldd	r0, Z+5	; 0x05
    164c:	f6 81       	ldd	r31, Z+6	; 0x06
    164e:	e0 2d       	mov	r30, r0
    1650:	06 80       	ldd	r0, Z+6	; 0x06
    1652:	f7 81       	ldd	r31, Z+7	; 0x07
    1654:	e0 2d       	mov	r30, r0
    1656:	82 81       	ldd	r24, Z+2	; 0x02
    1658:	93 81       	ldd	r25, Z+3	; 0x03
    165a:	90 93 05 02 	sts	0x0205, r25
    165e:	80 93 04 02 	sts	0x0204, r24
    1662:	08 95       	ret

00001664 <prvAddCurrentTaskToDelayedList>:
    1664:	cf 93       	push	r28
    1666:	df 93       	push	r29
    1668:	ec 01       	movw	r28, r24
    166a:	e0 91 97 08 	lds	r30, 0x0897
    166e:	f0 91 98 08 	lds	r31, 0x0898
    1672:	93 83       	std	Z+3, r25	; 0x03
    1674:	82 83       	std	Z+2, r24	; 0x02
    1676:	80 91 35 08 	lds	r24, 0x0835
    167a:	90 91 36 08 	lds	r25, 0x0836
    167e:	c8 17       	cp	r28, r24
    1680:	d9 07       	cpc	r29, r25
    1682:	68 f4       	brcc	.+26     	; 0x169e <prvAddCurrentTaskToDelayedList+0x3a>
    1684:	60 91 97 08 	lds	r22, 0x0897
    1688:	70 91 98 08 	lds	r23, 0x0898
    168c:	80 91 54 08 	lds	r24, 0x0854
    1690:	90 91 55 08 	lds	r25, 0x0855
    1694:	6e 5f       	subi	r22, 0xFE	; 254
    1696:	7f 4f       	sbci	r23, 0xFF	; 255
    1698:	0e 94 76 02 	call	0x4ec	; 0x4ec <vListInsert>
    169c:	17 c0       	rjmp	.+46     	; 0x16cc <prvAddCurrentTaskToDelayedList+0x68>
    169e:	60 91 97 08 	lds	r22, 0x0897
    16a2:	70 91 98 08 	lds	r23, 0x0898
    16a6:	80 91 56 08 	lds	r24, 0x0856
    16aa:	90 91 57 08 	lds	r25, 0x0857
    16ae:	6e 5f       	subi	r22, 0xFE	; 254
    16b0:	7f 4f       	sbci	r23, 0xFF	; 255
    16b2:	0e 94 76 02 	call	0x4ec	; 0x4ec <vListInsert>
    16b6:	80 91 04 02 	lds	r24, 0x0204
    16ba:	90 91 05 02 	lds	r25, 0x0205
    16be:	c8 17       	cp	r28, r24
    16c0:	d9 07       	cpc	r29, r25
    16c2:	20 f4       	brcc	.+8      	; 0x16cc <prvAddCurrentTaskToDelayedList+0x68>
    16c4:	d0 93 05 02 	sts	0x0205, r29
    16c8:	c0 93 04 02 	sts	0x0204, r28
    16cc:	df 91       	pop	r29
    16ce:	cf 91       	pop	r28
    16d0:	08 95       	ret

000016d2 <xTaskGenericCreate>:
    16d2:	4f 92       	push	r4
    16d4:	5f 92       	push	r5
    16d6:	6f 92       	push	r6
    16d8:	7f 92       	push	r7
    16da:	8f 92       	push	r8
    16dc:	9f 92       	push	r9
    16de:	af 92       	push	r10
    16e0:	bf 92       	push	r11
    16e2:	cf 92       	push	r12
    16e4:	df 92       	push	r13
    16e6:	ef 92       	push	r14
    16e8:	ff 92       	push	r15
    16ea:	0f 93       	push	r16
    16ec:	1f 93       	push	r17
    16ee:	cf 93       	push	r28
    16f0:	df 93       	push	r29
    16f2:	4c 01       	movw	r8, r24
    16f4:	5b 01       	movw	r10, r22
    16f6:	2a 01       	movw	r4, r20
    16f8:	39 01       	movw	r6, r18
    16fa:	83 e2       	ldi	r24, 0x23	; 35
    16fc:	90 e0       	ldi	r25, 0x00	; 0
    16fe:	0e 94 0d 02 	call	0x41a	; 0x41a <pvPortMalloc>
    1702:	ec 01       	movw	r28, r24
    1704:	00 97       	sbiw	r24, 0x00	; 0
    1706:	09 f4       	brne	.+2      	; 0x170a <xTaskGenericCreate+0x38>
    1708:	e7 c0       	rjmp	.+462    	; 0x18d8 <xTaskGenericCreate+0x206>
    170a:	c1 14       	cp	r12, r1
    170c:	d1 04       	cpc	r13, r1
    170e:	09 f0       	breq	.+2      	; 0x1712 <xTaskGenericCreate+0x40>
    1710:	cc c0       	rjmp	.+408    	; 0x18aa <xTaskGenericCreate+0x1d8>
    1712:	c2 01       	movw	r24, r4
    1714:	0e 94 0d 02 	call	0x41a	; 0x41a <pvPortMalloc>
    1718:	98 8f       	std	Y+24, r25	; 0x18
    171a:	8f 8b       	std	Y+23, r24	; 0x17
    171c:	89 2b       	or	r24, r25
    171e:	09 f0       	breq	.+2      	; 0x1722 <xTaskGenericCreate+0x50>
    1720:	c6 c0       	rjmp	.+396    	; 0x18ae <xTaskGenericCreate+0x1dc>
    1722:	ce 01       	movw	r24, r28
    1724:	0e 94 42 02 	call	0x484	; 0x484 <vPortFree>
    1728:	d7 c0       	rjmp	.+430    	; 0x18d8 <xTaskGenericCreate+0x206>
    172a:	cf 01       	movw	r24, r30
    172c:	31 91       	ld	r19, Z+
    172e:	da 01       	movw	r26, r20
    1730:	3d 93       	st	X+, r19
    1732:	ad 01       	movw	r20, r26
    1734:	dc 01       	movw	r26, r24
    1736:	8c 91       	ld	r24, X
    1738:	88 23       	and	r24, r24
    173a:	11 f0       	breq	.+4      	; 0x1740 <xTaskGenericCreate+0x6e>
    173c:	21 50       	subi	r18, 0x01	; 1
    173e:	a9 f7       	brne	.-22     	; 0x172a <xTaskGenericCreate+0x58>
    1740:	18 a2       	std	Y+32, r1	; 0x20
    1742:	10 2f       	mov	r17, r16
    1744:	05 30       	cpi	r16, 0x05	; 5
    1746:	08 f0       	brcs	.+2      	; 0x174a <xTaskGenericCreate+0x78>
    1748:	14 e0       	ldi	r17, 0x04	; 4
    174a:	1e 8b       	std	Y+22, r17	; 0x16
    174c:	19 a3       	std	Y+33, r17	; 0x21
    174e:	1a a2       	std	Y+34, r1	; 0x22
    1750:	5e 01       	movw	r10, r28
    1752:	b2 e0       	ldi	r27, 0x02	; 2
    1754:	ab 0e       	add	r10, r27
    1756:	b1 1c       	adc	r11, r1
    1758:	c5 01       	movw	r24, r10
    175a:	0e 94 51 02 	call	0x4a2	; 0x4a2 <vListInitialiseItem>
    175e:	ce 01       	movw	r24, r28
    1760:	0c 96       	adiw	r24, 0x0c	; 12
    1762:	0e 94 51 02 	call	0x4a2	; 0x4a2 <vListInitialiseItem>
    1766:	d9 87       	std	Y+9, r29	; 0x09
    1768:	c8 87       	std	Y+8, r28	; 0x08
    176a:	85 e0       	ldi	r24, 0x05	; 5
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	81 1b       	sub	r24, r17
    1770:	91 09       	sbc	r25, r1
    1772:	9d 87       	std	Y+13, r25	; 0x0d
    1774:	8c 87       	std	Y+12, r24	; 0x0c
    1776:	db 8b       	std	Y+19, r29	; 0x13
    1778:	ca 8b       	std	Y+18, r28	; 0x12
    177a:	a3 01       	movw	r20, r6
    177c:	b4 01       	movw	r22, r8
    177e:	c6 01       	movw	r24, r12
    1780:	d4 da       	rcall	.-2648   	; 0xd2a <pxPortInitialiseStack>
    1782:	99 83       	std	Y+1, r25	; 0x01
    1784:	88 83       	st	Y, r24
    1786:	e1 14       	cp	r14, r1
    1788:	f1 04       	cpc	r15, r1
    178a:	19 f0       	breq	.+6      	; 0x1792 <xTaskGenericCreate+0xc0>
    178c:	f7 01       	movw	r30, r14
    178e:	d1 83       	std	Z+1, r29	; 0x01
    1790:	c0 83       	st	Z, r28
    1792:	0f b6       	in	r0, 0x3f	; 63
    1794:	f8 94       	cli
    1796:	0f 92       	push	r0
    1798:	80 91 37 08 	lds	r24, 0x0837
    179c:	8f 5f       	subi	r24, 0xFF	; 255
    179e:	80 93 37 08 	sts	0x0837, r24
    17a2:	80 91 97 08 	lds	r24, 0x0897
    17a6:	90 91 98 08 	lds	r25, 0x0898
    17aa:	89 2b       	or	r24, r25
    17ac:	09 f0       	breq	.+2      	; 0x17b0 <xTaskGenericCreate+0xde>
    17ae:	3f c0       	rjmp	.+126    	; 0x182e <xTaskGenericCreate+0x15c>
    17b0:	d0 93 98 08 	sts	0x0898, r29
    17b4:	c0 93 97 08 	sts	0x0897, r28
    17b8:	80 91 37 08 	lds	r24, 0x0837
    17bc:	81 30       	cpi	r24, 0x01	; 1
    17be:	09 f0       	breq	.+2      	; 0x17c2 <xTaskGenericCreate+0xf0>
    17c0:	45 c0       	rjmp	.+138    	; 0x184c <xTaskGenericCreate+0x17a>
    17c2:	0f 2e       	mov	r0, r31
    17c4:	fa e6       	ldi	r31, 0x6A	; 106
    17c6:	ef 2e       	mov	r14, r31
    17c8:	f8 e0       	ldi	r31, 0x08	; 8
    17ca:	ff 2e       	mov	r15, r31
    17cc:	f0 2d       	mov	r31, r0
    17ce:	0f 2e       	mov	r0, r31
    17d0:	f7 e9       	ldi	r31, 0x97	; 151
    17d2:	cf 2e       	mov	r12, r31
    17d4:	f8 e0       	ldi	r31, 0x08	; 8
    17d6:	df 2e       	mov	r13, r31
    17d8:	f0 2d       	mov	r31, r0
    17da:	c7 01       	movw	r24, r14
    17dc:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    17e0:	f9 e0       	ldi	r31, 0x09	; 9
    17e2:	ef 0e       	add	r14, r31
    17e4:	f1 1c       	adc	r15, r1
    17e6:	ec 14       	cp	r14, r12
    17e8:	fd 04       	cpc	r15, r13
    17ea:	b9 f7       	brne	.-18     	; 0x17da <xTaskGenericCreate+0x108>
    17ec:	81 e6       	ldi	r24, 0x61	; 97
    17ee:	98 e0       	ldi	r25, 0x08	; 8
    17f0:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    17f4:	88 e5       	ldi	r24, 0x58	; 88
    17f6:	98 e0       	ldi	r25, 0x08	; 8
    17f8:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    17fc:	8b e4       	ldi	r24, 0x4B	; 75
    17fe:	98 e0       	ldi	r25, 0x08	; 8
    1800:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    1804:	82 e4       	ldi	r24, 0x42	; 66
    1806:	98 e0       	ldi	r25, 0x08	; 8
    1808:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    180c:	88 e3       	ldi	r24, 0x38	; 56
    180e:	98 e0       	ldi	r25, 0x08	; 8
    1810:	0e 94 43 02 	call	0x486	; 0x486 <vListInitialise>
    1814:	81 e6       	ldi	r24, 0x61	; 97
    1816:	98 e0       	ldi	r25, 0x08	; 8
    1818:	90 93 57 08 	sts	0x0857, r25
    181c:	80 93 56 08 	sts	0x0856, r24
    1820:	88 e5       	ldi	r24, 0x58	; 88
    1822:	98 e0       	ldi	r25, 0x08	; 8
    1824:	90 93 55 08 	sts	0x0855, r25
    1828:	80 93 54 08 	sts	0x0854, r24
    182c:	0f c0       	rjmp	.+30     	; 0x184c <xTaskGenericCreate+0x17a>
    182e:	80 91 33 08 	lds	r24, 0x0833
    1832:	81 11       	cpse	r24, r1
    1834:	0b c0       	rjmp	.+22     	; 0x184c <xTaskGenericCreate+0x17a>
    1836:	e0 91 97 08 	lds	r30, 0x0897
    183a:	f0 91 98 08 	lds	r31, 0x0898
    183e:	86 89       	ldd	r24, Z+22	; 0x16
    1840:	08 17       	cp	r16, r24
    1842:	20 f0       	brcs	.+8      	; 0x184c <xTaskGenericCreate+0x17a>
    1844:	d0 93 98 08 	sts	0x0898, r29
    1848:	c0 93 97 08 	sts	0x0897, r28
    184c:	80 91 2f 08 	lds	r24, 0x082F
    1850:	8f 5f       	subi	r24, 0xFF	; 255
    1852:	80 93 2f 08 	sts	0x082F, r24
    1856:	8e 89       	ldd	r24, Y+22	; 0x16
    1858:	90 91 34 08 	lds	r25, 0x0834
    185c:	98 17       	cp	r25, r24
    185e:	10 f4       	brcc	.+4      	; 0x1864 <xTaskGenericCreate+0x192>
    1860:	80 93 34 08 	sts	0x0834, r24
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	9c 01       	movw	r18, r24
    1868:	22 0f       	add	r18, r18
    186a:	33 1f       	adc	r19, r19
    186c:	22 0f       	add	r18, r18
    186e:	33 1f       	adc	r19, r19
    1870:	22 0f       	add	r18, r18
    1872:	33 1f       	adc	r19, r19
    1874:	82 0f       	add	r24, r18
    1876:	93 1f       	adc	r25, r19
    1878:	b5 01       	movw	r22, r10
    187a:	86 59       	subi	r24, 0x96	; 150
    187c:	97 4f       	sbci	r25, 0xF7	; 247
    187e:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1882:	0f 90       	pop	r0
    1884:	0f be       	out	0x3f, r0	; 63
    1886:	80 91 33 08 	lds	r24, 0x0833
    188a:	88 23       	and	r24, r24
    188c:	51 f0       	breq	.+20     	; 0x18a2 <xTaskGenericCreate+0x1d0>
    188e:	e0 91 97 08 	lds	r30, 0x0897
    1892:	f0 91 98 08 	lds	r31, 0x0898
    1896:	86 89       	ldd	r24, Z+22	; 0x16
    1898:	80 17       	cp	r24, r16
    189a:	28 f4       	brcc	.+10     	; 0x18a6 <xTaskGenericCreate+0x1d4>
    189c:	f5 da       	rcall	.-2582   	; 0xe88 <vPortYield>
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	1c c0       	rjmp	.+56     	; 0x18da <xTaskGenericCreate+0x208>
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	1a c0       	rjmp	.+52     	; 0x18da <xTaskGenericCreate+0x208>
    18a6:	81 e0       	ldi	r24, 0x01	; 1
    18a8:	18 c0       	rjmp	.+48     	; 0x18da <xTaskGenericCreate+0x208>
    18aa:	d8 8e       	std	Y+24, r13	; 0x18
    18ac:	cf 8a       	std	Y+23, r12	; 0x17
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	48 1a       	sub	r4, r24
    18b2:	51 08       	sbc	r5, r1
    18b4:	cf 88       	ldd	r12, Y+23	; 0x17
    18b6:	d8 8c       	ldd	r13, Y+24	; 0x18
    18b8:	c4 0c       	add	r12, r4
    18ba:	d5 1c       	adc	r13, r5
    18bc:	d5 01       	movw	r26, r10
    18be:	8c 91       	ld	r24, X
    18c0:	89 8f       	std	Y+25, r24	; 0x19
    18c2:	8c 91       	ld	r24, X
    18c4:	88 23       	and	r24, r24
    18c6:	09 f4       	brne	.+2      	; 0x18ca <xTaskGenericCreate+0x1f8>
    18c8:	3b cf       	rjmp	.-394    	; 0x1740 <xTaskGenericCreate+0x6e>
    18ca:	ae 01       	movw	r20, r28
    18cc:	46 5e       	subi	r20, 0xE6	; 230
    18ce:	5f 4f       	sbci	r21, 0xFF	; 255
    18d0:	f5 01       	movw	r30, r10
    18d2:	31 96       	adiw	r30, 0x01	; 1
    18d4:	27 e0       	ldi	r18, 0x07	; 7
    18d6:	29 cf       	rjmp	.-430    	; 0x172a <xTaskGenericCreate+0x58>
    18d8:	8f ef       	ldi	r24, 0xFF	; 255
    18da:	df 91       	pop	r29
    18dc:	cf 91       	pop	r28
    18de:	1f 91       	pop	r17
    18e0:	0f 91       	pop	r16
    18e2:	ff 90       	pop	r15
    18e4:	ef 90       	pop	r14
    18e6:	df 90       	pop	r13
    18e8:	cf 90       	pop	r12
    18ea:	bf 90       	pop	r11
    18ec:	af 90       	pop	r10
    18ee:	9f 90       	pop	r9
    18f0:	8f 90       	pop	r8
    18f2:	7f 90       	pop	r7
    18f4:	6f 90       	pop	r6
    18f6:	5f 90       	pop	r5
    18f8:	4f 90       	pop	r4
    18fa:	08 95       	ret

000018fc <vTaskResume>:
    18fc:	0f 93       	push	r16
    18fe:	1f 93       	push	r17
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	ec 01       	movw	r28, r24
    1906:	00 97       	sbiw	r24, 0x00	; 0
    1908:	09 f4       	brne	.+2      	; 0x190c <vTaskResume+0x10>
    190a:	3e c0       	rjmp	.+124    	; 0x1988 <vTaskResume+0x8c>
    190c:	80 91 97 08 	lds	r24, 0x0897
    1910:	90 91 98 08 	lds	r25, 0x0898
    1914:	c8 17       	cp	r28, r24
    1916:	d9 07       	cpc	r29, r25
    1918:	b9 f1       	breq	.+110    	; 0x1988 <vTaskResume+0x8c>
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	0f 92       	push	r0
    1920:	8a 85       	ldd	r24, Y+10	; 0x0a
    1922:	9b 85       	ldd	r25, Y+11	; 0x0b
    1924:	88 53       	subi	r24, 0x38	; 56
    1926:	98 40       	sbci	r25, 0x08	; 8
    1928:	69 f5       	brne	.+90     	; 0x1984 <vTaskResume+0x88>
    192a:	8c 89       	ldd	r24, Y+20	; 0x14
    192c:	9d 89       	ldd	r25, Y+21	; 0x15
    192e:	28 e0       	ldi	r18, 0x08	; 8
    1930:	8b 34       	cpi	r24, 0x4B	; 75
    1932:	92 07       	cpc	r25, r18
    1934:	39 f1       	breq	.+78     	; 0x1984 <vTaskResume+0x88>
    1936:	89 2b       	or	r24, r25
    1938:	29 f5       	brne	.+74     	; 0x1984 <vTaskResume+0x88>
    193a:	8e 01       	movw	r16, r28
    193c:	0e 5f       	subi	r16, 0xFE	; 254
    193e:	1f 4f       	sbci	r17, 0xFF	; 255
    1940:	c8 01       	movw	r24, r16
    1942:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1946:	8e 89       	ldd	r24, Y+22	; 0x16
    1948:	90 91 34 08 	lds	r25, 0x0834
    194c:	98 17       	cp	r25, r24
    194e:	10 f4       	brcc	.+4      	; 0x1954 <vTaskResume+0x58>
    1950:	80 93 34 08 	sts	0x0834, r24
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	9c 01       	movw	r18, r24
    1958:	22 0f       	add	r18, r18
    195a:	33 1f       	adc	r19, r19
    195c:	22 0f       	add	r18, r18
    195e:	33 1f       	adc	r19, r19
    1960:	22 0f       	add	r18, r18
    1962:	33 1f       	adc	r19, r19
    1964:	82 0f       	add	r24, r18
    1966:	93 1f       	adc	r25, r19
    1968:	b8 01       	movw	r22, r16
    196a:	86 59       	subi	r24, 0x96	; 150
    196c:	97 4f       	sbci	r25, 0xF7	; 247
    196e:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1972:	e0 91 97 08 	lds	r30, 0x0897
    1976:	f0 91 98 08 	lds	r31, 0x0898
    197a:	9e 89       	ldd	r25, Y+22	; 0x16
    197c:	86 89       	ldd	r24, Z+22	; 0x16
    197e:	98 17       	cp	r25, r24
    1980:	08 f0       	brcs	.+2      	; 0x1984 <vTaskResume+0x88>
    1982:	82 da       	rcall	.-2812   	; 0xe88 <vPortYield>
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63
    1988:	df 91       	pop	r29
    198a:	cf 91       	pop	r28
    198c:	1f 91       	pop	r17
    198e:	0f 91       	pop	r16
    1990:	08 95       	ret

00001992 <vTaskStartScheduler>:
    1992:	af 92       	push	r10
    1994:	bf 92       	push	r11
    1996:	cf 92       	push	r12
    1998:	df 92       	push	r13
    199a:	ef 92       	push	r14
    199c:	ff 92       	push	r15
    199e:	0f 93       	push	r16
    19a0:	a1 2c       	mov	r10, r1
    19a2:	b1 2c       	mov	r11, r1
    19a4:	c1 2c       	mov	r12, r1
    19a6:	d1 2c       	mov	r13, r1
    19a8:	e1 2c       	mov	r14, r1
    19aa:	f1 2c       	mov	r15, r1
    19ac:	00 e0       	ldi	r16, 0x00	; 0
    19ae:	20 e0       	ldi	r18, 0x00	; 0
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	45 e5       	ldi	r20, 0x55	; 85
    19b4:	50 e0       	ldi	r21, 0x00	; 0
    19b6:	69 e4       	ldi	r22, 0x49	; 73
    19b8:	72 e0       	ldi	r23, 0x02	; 2
    19ba:	80 ea       	ldi	r24, 0xA0	; 160
    19bc:	9e e0       	ldi	r25, 0x0E	; 14
    19be:	89 de       	rcall	.-750    	; 0x16d2 <xTaskGenericCreate>
    19c0:	81 30       	cpi	r24, 0x01	; 1
    19c2:	41 f4       	brne	.+16     	; 0x19d4 <vTaskStartScheduler+0x42>
    19c4:	f8 94       	cli
    19c6:	80 93 33 08 	sts	0x0833, r24
    19ca:	10 92 36 08 	sts	0x0836, r1
    19ce:	10 92 35 08 	sts	0x0835, r1
    19d2:	1d da       	rcall	.-3014   	; 0xe0e <xPortStartScheduler>
    19d4:	0f 91       	pop	r16
    19d6:	ff 90       	pop	r15
    19d8:	ef 90       	pop	r14
    19da:	df 90       	pop	r13
    19dc:	cf 90       	pop	r12
    19de:	bf 90       	pop	r11
    19e0:	af 90       	pop	r10
    19e2:	08 95       	ret

000019e4 <vTaskSuspendAll>:
    19e4:	80 91 2e 08 	lds	r24, 0x082E
    19e8:	8f 5f       	subi	r24, 0xFF	; 255
    19ea:	80 93 2e 08 	sts	0x082E, r24
    19ee:	08 95       	ret

000019f0 <xTaskGetTickCount>:
    19f0:	0f b6       	in	r0, 0x3f	; 63
    19f2:	f8 94       	cli
    19f4:	0f 92       	push	r0
    19f6:	80 91 35 08 	lds	r24, 0x0835
    19fa:	90 91 36 08 	lds	r25, 0x0836
    19fe:	0f 90       	pop	r0
    1a00:	0f be       	out	0x3f, r0	; 63
    1a02:	08 95       	ret

00001a04 <xTaskGetTickCountFromISR>:
    1a04:	80 91 35 08 	lds	r24, 0x0835
    1a08:	90 91 36 08 	lds	r25, 0x0836
    1a0c:	08 95       	ret

00001a0e <xTaskIncrementTick>:
    1a0e:	cf 92       	push	r12
    1a10:	df 92       	push	r13
    1a12:	ef 92       	push	r14
    1a14:	ff 92       	push	r15
    1a16:	0f 93       	push	r16
    1a18:	1f 93       	push	r17
    1a1a:	cf 93       	push	r28
    1a1c:	df 93       	push	r29
    1a1e:	80 91 2e 08 	lds	r24, 0x082E
    1a22:	81 11       	cpse	r24, r1
    1a24:	99 c0       	rjmp	.+306    	; 0x1b58 <xTaskIncrementTick+0x14a>
    1a26:	80 91 35 08 	lds	r24, 0x0835
    1a2a:	90 91 36 08 	lds	r25, 0x0836
    1a2e:	01 96       	adiw	r24, 0x01	; 1
    1a30:	90 93 36 08 	sts	0x0836, r25
    1a34:	80 93 35 08 	sts	0x0835, r24
    1a38:	e0 90 35 08 	lds	r14, 0x0835
    1a3c:	f0 90 36 08 	lds	r15, 0x0836
    1a40:	e1 14       	cp	r14, r1
    1a42:	f1 04       	cpc	r15, r1
    1a44:	b1 f4       	brne	.+44     	; 0x1a72 <xTaskIncrementTick+0x64>
    1a46:	80 91 56 08 	lds	r24, 0x0856
    1a4a:	90 91 57 08 	lds	r25, 0x0857
    1a4e:	20 91 54 08 	lds	r18, 0x0854
    1a52:	30 91 55 08 	lds	r19, 0x0855
    1a56:	30 93 57 08 	sts	0x0857, r19
    1a5a:	20 93 56 08 	sts	0x0856, r18
    1a5e:	90 93 55 08 	sts	0x0855, r25
    1a62:	80 93 54 08 	sts	0x0854, r24
    1a66:	80 91 30 08 	lds	r24, 0x0830
    1a6a:	8f 5f       	subi	r24, 0xFF	; 255
    1a6c:	80 93 30 08 	sts	0x0830, r24
    1a70:	da dd       	rcall	.-1100   	; 0x1626 <prvResetNextTaskUnblockTime>
    1a72:	80 91 04 02 	lds	r24, 0x0204
    1a76:	90 91 05 02 	lds	r25, 0x0205
    1a7a:	e8 16       	cp	r14, r24
    1a7c:	f9 06       	cpc	r15, r25
    1a7e:	08 f4       	brcc	.+2      	; 0x1a82 <xTaskIncrementTick+0x74>
    1a80:	54 c0       	rjmp	.+168    	; 0x1b2a <xTaskIncrementTick+0x11c>
    1a82:	d1 2c       	mov	r13, r1
    1a84:	cc 24       	eor	r12, r12
    1a86:	c3 94       	inc	r12
    1a88:	01 c0       	rjmp	.+2      	; 0x1a8c <xTaskIncrementTick+0x7e>
    1a8a:	dc 2c       	mov	r13, r12
    1a8c:	e0 91 56 08 	lds	r30, 0x0856
    1a90:	f0 91 57 08 	lds	r31, 0x0857
    1a94:	80 81       	ld	r24, Z
    1a96:	81 11       	cpse	r24, r1
    1a98:	07 c0       	rjmp	.+14     	; 0x1aa8 <xTaskIncrementTick+0x9a>
    1a9a:	8f ef       	ldi	r24, 0xFF	; 255
    1a9c:	9f ef       	ldi	r25, 0xFF	; 255
    1a9e:	90 93 05 02 	sts	0x0205, r25
    1aa2:	80 93 04 02 	sts	0x0204, r24
    1aa6:	42 c0       	rjmp	.+132    	; 0x1b2c <xTaskIncrementTick+0x11e>
    1aa8:	e0 91 56 08 	lds	r30, 0x0856
    1aac:	f0 91 57 08 	lds	r31, 0x0857
    1ab0:	05 80       	ldd	r0, Z+5	; 0x05
    1ab2:	f6 81       	ldd	r31, Z+6	; 0x06
    1ab4:	e0 2d       	mov	r30, r0
    1ab6:	c6 81       	ldd	r28, Z+6	; 0x06
    1ab8:	d7 81       	ldd	r29, Z+7	; 0x07
    1aba:	2a 81       	ldd	r18, Y+2	; 0x02
    1abc:	3b 81       	ldd	r19, Y+3	; 0x03
    1abe:	e2 16       	cp	r14, r18
    1ac0:	f3 06       	cpc	r15, r19
    1ac2:	28 f4       	brcc	.+10     	; 0x1ace <xTaskIncrementTick+0xc0>
    1ac4:	30 93 05 02 	sts	0x0205, r19
    1ac8:	20 93 04 02 	sts	0x0204, r18
    1acc:	2f c0       	rjmp	.+94     	; 0x1b2c <xTaskIncrementTick+0x11e>
    1ace:	8e 01       	movw	r16, r28
    1ad0:	0e 5f       	subi	r16, 0xFE	; 254
    1ad2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad4:	c8 01       	movw	r24, r16
    1ad6:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1ada:	8c 89       	ldd	r24, Y+20	; 0x14
    1adc:	9d 89       	ldd	r25, Y+21	; 0x15
    1ade:	89 2b       	or	r24, r25
    1ae0:	21 f0       	breq	.+8      	; 0x1aea <xTaskIncrementTick+0xdc>
    1ae2:	ce 01       	movw	r24, r28
    1ae4:	0c 96       	adiw	r24, 0x0c	; 12
    1ae6:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1aea:	2e 89       	ldd	r18, Y+22	; 0x16
    1aec:	80 91 34 08 	lds	r24, 0x0834
    1af0:	82 17       	cp	r24, r18
    1af2:	10 f4       	brcc	.+4      	; 0x1af8 <xTaskIncrementTick+0xea>
    1af4:	20 93 34 08 	sts	0x0834, r18
    1af8:	30 e0       	ldi	r19, 0x00	; 0
    1afa:	c9 01       	movw	r24, r18
    1afc:	88 0f       	add	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	88 0f       	add	r24, r24
    1b06:	99 1f       	adc	r25, r25
    1b08:	82 0f       	add	r24, r18
    1b0a:	93 1f       	adc	r25, r19
    1b0c:	b8 01       	movw	r22, r16
    1b0e:	86 59       	subi	r24, 0x96	; 150
    1b10:	97 4f       	sbci	r25, 0xF7	; 247
    1b12:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1b16:	e0 91 97 08 	lds	r30, 0x0897
    1b1a:	f0 91 98 08 	lds	r31, 0x0898
    1b1e:	9e 89       	ldd	r25, Y+22	; 0x16
    1b20:	86 89       	ldd	r24, Z+22	; 0x16
    1b22:	98 17       	cp	r25, r24
    1b24:	08 f0       	brcs	.+2      	; 0x1b28 <xTaskIncrementTick+0x11a>
    1b26:	b1 cf       	rjmp	.-158    	; 0x1a8a <xTaskIncrementTick+0x7c>
    1b28:	b1 cf       	rjmp	.-158    	; 0x1a8c <xTaskIncrementTick+0x7e>
    1b2a:	d1 2c       	mov	r13, r1
    1b2c:	e0 91 97 08 	lds	r30, 0x0897
    1b30:	f0 91 98 08 	lds	r31, 0x0898
    1b34:	86 89       	ldd	r24, Z+22	; 0x16
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	fc 01       	movw	r30, r24
    1b3a:	ee 0f       	add	r30, r30
    1b3c:	ff 1f       	adc	r31, r31
    1b3e:	ee 0f       	add	r30, r30
    1b40:	ff 1f       	adc	r31, r31
    1b42:	ee 0f       	add	r30, r30
    1b44:	ff 1f       	adc	r31, r31
    1b46:	8e 0f       	add	r24, r30
    1b48:	9f 1f       	adc	r25, r31
    1b4a:	fc 01       	movw	r30, r24
    1b4c:	e6 59       	subi	r30, 0x96	; 150
    1b4e:	f7 4f       	sbci	r31, 0xF7	; 247
    1b50:	80 81       	ld	r24, Z
    1b52:	82 30       	cpi	r24, 0x02	; 2
    1b54:	40 f4       	brcc	.+16     	; 0x1b66 <xTaskIncrementTick+0x158>
    1b56:	09 c0       	rjmp	.+18     	; 0x1b6a <xTaskIncrementTick+0x15c>
    1b58:	80 91 32 08 	lds	r24, 0x0832
    1b5c:	8f 5f       	subi	r24, 0xFF	; 255
    1b5e:	80 93 32 08 	sts	0x0832, r24
    1b62:	d1 2c       	mov	r13, r1
    1b64:	02 c0       	rjmp	.+4      	; 0x1b6a <xTaskIncrementTick+0x15c>
    1b66:	dd 24       	eor	r13, r13
    1b68:	d3 94       	inc	r13
    1b6a:	80 91 31 08 	lds	r24, 0x0831
    1b6e:	88 23       	and	r24, r24
    1b70:	11 f0       	breq	.+4      	; 0x1b76 <xTaskIncrementTick+0x168>
    1b72:	dd 24       	eor	r13, r13
    1b74:	d3 94       	inc	r13
    1b76:	8d 2d       	mov	r24, r13
    1b78:	df 91       	pop	r29
    1b7a:	cf 91       	pop	r28
    1b7c:	1f 91       	pop	r17
    1b7e:	0f 91       	pop	r16
    1b80:	ff 90       	pop	r15
    1b82:	ef 90       	pop	r14
    1b84:	df 90       	pop	r13
    1b86:	cf 90       	pop	r12
    1b88:	08 95       	ret

00001b8a <xTaskResumeAll>:
    1b8a:	df 92       	push	r13
    1b8c:	ef 92       	push	r14
    1b8e:	ff 92       	push	r15
    1b90:	0f 93       	push	r16
    1b92:	1f 93       	push	r17
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	0f 92       	push	r0
    1b9e:	80 91 2e 08 	lds	r24, 0x082E
    1ba2:	81 50       	subi	r24, 0x01	; 1
    1ba4:	80 93 2e 08 	sts	0x082E, r24
    1ba8:	80 91 2e 08 	lds	r24, 0x082E
    1bac:	81 11       	cpse	r24, r1
    1bae:	5f c0       	rjmp	.+190    	; 0x1c6e <xTaskResumeAll+0xe4>
    1bb0:	80 91 37 08 	lds	r24, 0x0837
    1bb4:	88 23       	and	r24, r24
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <xTaskResumeAll+0x30>
    1bb8:	5c c0       	rjmp	.+184    	; 0x1c72 <xTaskResumeAll+0xe8>
    1bba:	0f 2e       	mov	r0, r31
    1bbc:	fb e4       	ldi	r31, 0x4B	; 75
    1bbe:	ef 2e       	mov	r14, r31
    1bc0:	f8 e0       	ldi	r31, 0x08	; 8
    1bc2:	ff 2e       	mov	r15, r31
    1bc4:	f0 2d       	mov	r31, r0
    1bc6:	dd 24       	eor	r13, r13
    1bc8:	d3 94       	inc	r13
    1bca:	30 c0       	rjmp	.+96     	; 0x1c2c <xTaskResumeAll+0xa2>
    1bcc:	e0 91 50 08 	lds	r30, 0x0850
    1bd0:	f0 91 51 08 	lds	r31, 0x0851
    1bd4:	c6 81       	ldd	r28, Z+6	; 0x06
    1bd6:	d7 81       	ldd	r29, Z+7	; 0x07
    1bd8:	ce 01       	movw	r24, r28
    1bda:	0c 96       	adiw	r24, 0x0c	; 12
    1bdc:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1be0:	8e 01       	movw	r16, r28
    1be2:	0e 5f       	subi	r16, 0xFE	; 254
    1be4:	1f 4f       	sbci	r17, 0xFF	; 255
    1be6:	c8 01       	movw	r24, r16
    1be8:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1bec:	8e 89       	ldd	r24, Y+22	; 0x16
    1bee:	90 91 34 08 	lds	r25, 0x0834
    1bf2:	98 17       	cp	r25, r24
    1bf4:	10 f4       	brcc	.+4      	; 0x1bfa <xTaskResumeAll+0x70>
    1bf6:	80 93 34 08 	sts	0x0834, r24
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	9c 01       	movw	r18, r24
    1bfe:	22 0f       	add	r18, r18
    1c00:	33 1f       	adc	r19, r19
    1c02:	22 0f       	add	r18, r18
    1c04:	33 1f       	adc	r19, r19
    1c06:	22 0f       	add	r18, r18
    1c08:	33 1f       	adc	r19, r19
    1c0a:	82 0f       	add	r24, r18
    1c0c:	93 1f       	adc	r25, r19
    1c0e:	b8 01       	movw	r22, r16
    1c10:	86 59       	subi	r24, 0x96	; 150
    1c12:	97 4f       	sbci	r25, 0xF7	; 247
    1c14:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1c18:	e0 91 97 08 	lds	r30, 0x0897
    1c1c:	f0 91 98 08 	lds	r31, 0x0898
    1c20:	9e 89       	ldd	r25, Y+22	; 0x16
    1c22:	86 89       	ldd	r24, Z+22	; 0x16
    1c24:	98 17       	cp	r25, r24
    1c26:	10 f0       	brcs	.+4      	; 0x1c2c <xTaskResumeAll+0xa2>
    1c28:	d0 92 31 08 	sts	0x0831, r13
    1c2c:	f7 01       	movw	r30, r14
    1c2e:	80 81       	ld	r24, Z
    1c30:	81 11       	cpse	r24, r1
    1c32:	cc cf       	rjmp	.-104    	; 0x1bcc <xTaskResumeAll+0x42>
    1c34:	80 91 32 08 	lds	r24, 0x0832
    1c38:	88 23       	and	r24, r24
    1c3a:	91 f0       	breq	.+36     	; 0x1c60 <xTaskResumeAll+0xd6>
    1c3c:	80 91 32 08 	lds	r24, 0x0832
    1c40:	88 23       	and	r24, r24
    1c42:	71 f0       	breq	.+28     	; 0x1c60 <xTaskResumeAll+0xd6>
    1c44:	c1 e0       	ldi	r28, 0x01	; 1
    1c46:	e3 de       	rcall	.-570    	; 0x1a0e <xTaskIncrementTick>
    1c48:	81 11       	cpse	r24, r1
    1c4a:	c0 93 31 08 	sts	0x0831, r28
    1c4e:	80 91 32 08 	lds	r24, 0x0832
    1c52:	81 50       	subi	r24, 0x01	; 1
    1c54:	80 93 32 08 	sts	0x0832, r24
    1c58:	80 91 32 08 	lds	r24, 0x0832
    1c5c:	81 11       	cpse	r24, r1
    1c5e:	f3 cf       	rjmp	.-26     	; 0x1c46 <xTaskResumeAll+0xbc>
    1c60:	80 91 31 08 	lds	r24, 0x0831
    1c64:	81 30       	cpi	r24, 0x01	; 1
    1c66:	39 f4       	brne	.+14     	; 0x1c76 <xTaskResumeAll+0xec>
    1c68:	0f d9       	rcall	.-3554   	; 0xe88 <vPortYield>
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	05 c0       	rjmp	.+10     	; 0x1c78 <xTaskResumeAll+0xee>
    1c6e:	80 e0       	ldi	r24, 0x00	; 0
    1c70:	03 c0       	rjmp	.+6      	; 0x1c78 <xTaskResumeAll+0xee>
    1c72:	80 e0       	ldi	r24, 0x00	; 0
    1c74:	01 c0       	rjmp	.+2      	; 0x1c78 <xTaskResumeAll+0xee>
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	0f 90       	pop	r0
    1c7a:	0f be       	out	0x3f, r0	; 63
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	ff 90       	pop	r15
    1c86:	ef 90       	pop	r14
    1c88:	df 90       	pop	r13
    1c8a:	08 95       	ret

00001c8c <vTaskDelayUntil>:
    1c8c:	0f 93       	push	r16
    1c8e:	1f 93       	push	r17
    1c90:	cf 93       	push	r28
    1c92:	df 93       	push	r29
    1c94:	8c 01       	movw	r16, r24
    1c96:	eb 01       	movw	r28, r22
    1c98:	a5 de       	rcall	.-694    	; 0x19e4 <vTaskSuspendAll>
    1c9a:	80 91 35 08 	lds	r24, 0x0835
    1c9e:	90 91 36 08 	lds	r25, 0x0836
    1ca2:	f8 01       	movw	r30, r16
    1ca4:	20 81       	ld	r18, Z
    1ca6:	31 81       	ldd	r19, Z+1	; 0x01
    1ca8:	c2 0f       	add	r28, r18
    1caa:	d3 1f       	adc	r29, r19
    1cac:	82 17       	cp	r24, r18
    1cae:	93 07       	cpc	r25, r19
    1cb0:	48 f4       	brcc	.+18     	; 0x1cc4 <vTaskDelayUntil+0x38>
    1cb2:	c2 17       	cp	r28, r18
    1cb4:	d3 07       	cpc	r29, r19
    1cb6:	f8 f4       	brcc	.+62     	; 0x1cf6 <vTaskDelayUntil+0x6a>
    1cb8:	d1 83       	std	Z+1, r29	; 0x01
    1cba:	c0 83       	st	Z, r28
    1cbc:	8c 17       	cp	r24, r28
    1cbe:	9d 07       	cpc	r25, r29
    1cc0:	88 f4       	brcc	.+34     	; 0x1ce4 <vTaskDelayUntil+0x58>
    1cc2:	07 c0       	rjmp	.+14     	; 0x1cd2 <vTaskDelayUntil+0x46>
    1cc4:	c2 17       	cp	r28, r18
    1cc6:	d3 07       	cpc	r29, r19
    1cc8:	90 f0       	brcs	.+36     	; 0x1cee <vTaskDelayUntil+0x62>
    1cca:	8c 17       	cp	r24, r28
    1ccc:	9d 07       	cpc	r25, r29
    1cce:	78 f0       	brcs	.+30     	; 0x1cee <vTaskDelayUntil+0x62>
    1cd0:	12 c0       	rjmp	.+36     	; 0x1cf6 <vTaskDelayUntil+0x6a>
    1cd2:	80 91 97 08 	lds	r24, 0x0897
    1cd6:	90 91 98 08 	lds	r25, 0x0898
    1cda:	02 96       	adiw	r24, 0x02	; 2
    1cdc:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1ce0:	ce 01       	movw	r24, r28
    1ce2:	c0 dc       	rcall	.-1664   	; 0x1664 <prvAddCurrentTaskToDelayedList>
    1ce4:	52 df       	rcall	.-348    	; 0x1b8a <xTaskResumeAll>
    1ce6:	81 11       	cpse	r24, r1
    1ce8:	0a c0       	rjmp	.+20     	; 0x1cfe <vTaskDelayUntil+0x72>
    1cea:	ce d8       	rcall	.-3684   	; 0xe88 <vPortYield>
    1cec:	08 c0       	rjmp	.+16     	; 0x1cfe <vTaskDelayUntil+0x72>
    1cee:	f8 01       	movw	r30, r16
    1cf0:	d1 83       	std	Z+1, r29	; 0x01
    1cf2:	c0 83       	st	Z, r28
    1cf4:	ee cf       	rjmp	.-36     	; 0x1cd2 <vTaskDelayUntil+0x46>
    1cf6:	f8 01       	movw	r30, r16
    1cf8:	d1 83       	std	Z+1, r29	; 0x01
    1cfa:	c0 83       	st	Z, r28
    1cfc:	f3 cf       	rjmp	.-26     	; 0x1ce4 <vTaskDelayUntil+0x58>
    1cfe:	df 91       	pop	r29
    1d00:	cf 91       	pop	r28
    1d02:	1f 91       	pop	r17
    1d04:	0f 91       	pop	r16
    1d06:	08 95       	ret

00001d08 <vTaskDelay>:
    1d08:	cf 93       	push	r28
    1d0a:	df 93       	push	r29
    1d0c:	ec 01       	movw	r28, r24
    1d0e:	00 97       	sbiw	r24, 0x00	; 0
    1d10:	99 f0       	breq	.+38     	; 0x1d38 <vTaskDelay+0x30>
    1d12:	68 de       	rcall	.-816    	; 0x19e4 <vTaskSuspendAll>
    1d14:	80 91 35 08 	lds	r24, 0x0835
    1d18:	90 91 36 08 	lds	r25, 0x0836
    1d1c:	c8 0f       	add	r28, r24
    1d1e:	d9 1f       	adc	r29, r25
    1d20:	80 91 97 08 	lds	r24, 0x0897
    1d24:	90 91 98 08 	lds	r25, 0x0898
    1d28:	02 96       	adiw	r24, 0x02	; 2
    1d2a:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1d2e:	ce 01       	movw	r24, r28
    1d30:	99 dc       	rcall	.-1742   	; 0x1664 <prvAddCurrentTaskToDelayedList>
    1d32:	2b df       	rcall	.-426    	; 0x1b8a <xTaskResumeAll>
    1d34:	81 11       	cpse	r24, r1
    1d36:	01 c0       	rjmp	.+2      	; 0x1d3a <vTaskDelay+0x32>
    1d38:	a7 d8       	rcall	.-3762   	; 0xe88 <vPortYield>
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	08 95       	ret

00001d40 <prvIdleTask>:
    1d40:	0f 2e       	mov	r0, r31
    1d42:	fa e6       	ldi	r31, 0x6A	; 106
    1d44:	ef 2e       	mov	r14, r31
    1d46:	f8 e0       	ldi	r31, 0x08	; 8
    1d48:	ff 2e       	mov	r15, r31
    1d4a:	f0 2d       	mov	r31, r0
    1d4c:	c2 e4       	ldi	r28, 0x42	; 66
    1d4e:	d8 e0       	ldi	r29, 0x08	; 8
    1d50:	26 c0       	rjmp	.+76     	; 0x1d9e <prvIdleTask+0x5e>
    1d52:	48 de       	rcall	.-880    	; 0x19e4 <vTaskSuspendAll>
    1d54:	18 81       	ld	r17, Y
    1d56:	19 df       	rcall	.-462    	; 0x1b8a <xTaskResumeAll>
    1d58:	11 23       	and	r17, r17
    1d5a:	09 f1       	breq	.+66     	; 0x1d9e <prvIdleTask+0x5e>
    1d5c:	0f b6       	in	r0, 0x3f	; 63
    1d5e:	f8 94       	cli
    1d60:	0f 92       	push	r0
    1d62:	e0 91 47 08 	lds	r30, 0x0847
    1d66:	f0 91 48 08 	lds	r31, 0x0848
    1d6a:	06 81       	ldd	r16, Z+6	; 0x06
    1d6c:	17 81       	ldd	r17, Z+7	; 0x07
    1d6e:	c8 01       	movw	r24, r16
    1d70:	02 96       	adiw	r24, 0x02	; 2
    1d72:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1d76:	80 91 37 08 	lds	r24, 0x0837
    1d7a:	81 50       	subi	r24, 0x01	; 1
    1d7c:	80 93 37 08 	sts	0x0837, r24
    1d80:	80 91 41 08 	lds	r24, 0x0841
    1d84:	81 50       	subi	r24, 0x01	; 1
    1d86:	80 93 41 08 	sts	0x0841, r24
    1d8a:	0f 90       	pop	r0
    1d8c:	0f be       	out	0x3f, r0	; 63
    1d8e:	f8 01       	movw	r30, r16
    1d90:	87 89       	ldd	r24, Z+23	; 0x17
    1d92:	90 8d       	ldd	r25, Z+24	; 0x18
    1d94:	0e 94 42 02 	call	0x484	; 0x484 <vPortFree>
    1d98:	c8 01       	movw	r24, r16
    1d9a:	0e 94 42 02 	call	0x484	; 0x484 <vPortFree>
    1d9e:	80 91 41 08 	lds	r24, 0x0841
    1da2:	81 11       	cpse	r24, r1
    1da4:	d6 cf       	rjmp	.-84     	; 0x1d52 <prvIdleTask+0x12>
    1da6:	f7 01       	movw	r30, r14
    1da8:	80 81       	ld	r24, Z
    1daa:	82 30       	cpi	r24, 0x02	; 2
    1dac:	c0 f3       	brcs	.-16     	; 0x1d9e <prvIdleTask+0x5e>
    1dae:	6c d8       	rcall	.-3880   	; 0xe88 <vPortYield>
    1db0:	f6 cf       	rjmp	.-20     	; 0x1d9e <prvIdleTask+0x5e>

00001db2 <vTaskSwitchContext>:
    1db2:	80 91 2e 08 	lds	r24, 0x082E
    1db6:	88 23       	and	r24, r24
    1db8:	21 f0       	breq	.+8      	; 0x1dc2 <vTaskSwitchContext+0x10>
    1dba:	81 e0       	ldi	r24, 0x01	; 1
    1dbc:	80 93 31 08 	sts	0x0831, r24
    1dc0:	08 95       	ret
    1dc2:	10 92 31 08 	sts	0x0831, r1
    1dc6:	80 91 34 08 	lds	r24, 0x0834
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	fc 01       	movw	r30, r24
    1dce:	ee 0f       	add	r30, r30
    1dd0:	ff 1f       	adc	r31, r31
    1dd2:	ee 0f       	add	r30, r30
    1dd4:	ff 1f       	adc	r31, r31
    1dd6:	ee 0f       	add	r30, r30
    1dd8:	ff 1f       	adc	r31, r31
    1dda:	8e 0f       	add	r24, r30
    1ddc:	9f 1f       	adc	r25, r31
    1dde:	fc 01       	movw	r30, r24
    1de0:	e6 59       	subi	r30, 0x96	; 150
    1de2:	f7 4f       	sbci	r31, 0xF7	; 247
    1de4:	80 81       	ld	r24, Z
    1de6:	81 11       	cpse	r24, r1
    1de8:	17 c0       	rjmp	.+46     	; 0x1e18 <vTaskSwitchContext+0x66>
    1dea:	80 91 34 08 	lds	r24, 0x0834
    1dee:	81 50       	subi	r24, 0x01	; 1
    1df0:	80 93 34 08 	sts	0x0834, r24
    1df4:	80 91 34 08 	lds	r24, 0x0834
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	fc 01       	movw	r30, r24
    1dfc:	ee 0f       	add	r30, r30
    1dfe:	ff 1f       	adc	r31, r31
    1e00:	ee 0f       	add	r30, r30
    1e02:	ff 1f       	adc	r31, r31
    1e04:	ee 0f       	add	r30, r30
    1e06:	ff 1f       	adc	r31, r31
    1e08:	8e 0f       	add	r24, r30
    1e0a:	9f 1f       	adc	r25, r31
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	e6 59       	subi	r30, 0x96	; 150
    1e10:	f7 4f       	sbci	r31, 0xF7	; 247
    1e12:	80 81       	ld	r24, Z
    1e14:	88 23       	and	r24, r24
    1e16:	49 f3       	breq	.-46     	; 0x1dea <vTaskSwitchContext+0x38>
    1e18:	e0 91 34 08 	lds	r30, 0x0834
    1e1c:	f0 e0       	ldi	r31, 0x00	; 0
    1e1e:	cf 01       	movw	r24, r30
    1e20:	88 0f       	add	r24, r24
    1e22:	99 1f       	adc	r25, r25
    1e24:	88 0f       	add	r24, r24
    1e26:	99 1f       	adc	r25, r25
    1e28:	88 0f       	add	r24, r24
    1e2a:	99 1f       	adc	r25, r25
    1e2c:	e8 0f       	add	r30, r24
    1e2e:	f9 1f       	adc	r31, r25
    1e30:	e6 59       	subi	r30, 0x96	; 150
    1e32:	f7 4f       	sbci	r31, 0xF7	; 247
    1e34:	a1 81       	ldd	r26, Z+1	; 0x01
    1e36:	b2 81       	ldd	r27, Z+2	; 0x02
    1e38:	12 96       	adiw	r26, 0x02	; 2
    1e3a:	0d 90       	ld	r0, X+
    1e3c:	bc 91       	ld	r27, X
    1e3e:	a0 2d       	mov	r26, r0
    1e40:	b2 83       	std	Z+2, r27	; 0x02
    1e42:	a1 83       	std	Z+1, r26	; 0x01
    1e44:	cf 01       	movw	r24, r30
    1e46:	03 96       	adiw	r24, 0x03	; 3
    1e48:	a8 17       	cp	r26, r24
    1e4a:	b9 07       	cpc	r27, r25
    1e4c:	31 f4       	brne	.+12     	; 0x1e5a <vTaskSwitchContext+0xa8>
    1e4e:	12 96       	adiw	r26, 0x02	; 2
    1e50:	8d 91       	ld	r24, X+
    1e52:	9c 91       	ld	r25, X
    1e54:	13 97       	sbiw	r26, 0x03	; 3
    1e56:	92 83       	std	Z+2, r25	; 0x02
    1e58:	81 83       	std	Z+1, r24	; 0x01
    1e5a:	01 80       	ldd	r0, Z+1	; 0x01
    1e5c:	f2 81       	ldd	r31, Z+2	; 0x02
    1e5e:	e0 2d       	mov	r30, r0
    1e60:	86 81       	ldd	r24, Z+6	; 0x06
    1e62:	97 81       	ldd	r25, Z+7	; 0x07
    1e64:	90 93 98 08 	sts	0x0898, r25
    1e68:	80 93 97 08 	sts	0x0897, r24
    1e6c:	08 95       	ret

00001e6e <vTaskSuspend>:
    1e6e:	0f 93       	push	r16
    1e70:	1f 93       	push	r17
    1e72:	cf 93       	push	r28
    1e74:	df 93       	push	r29
    1e76:	ec 01       	movw	r28, r24
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	0f 92       	push	r0
    1e7e:	00 97       	sbiw	r24, 0x00	; 0
    1e80:	21 f4       	brne	.+8      	; 0x1e8a <vTaskSuspend+0x1c>
    1e82:	c0 91 97 08 	lds	r28, 0x0897
    1e86:	d0 91 98 08 	lds	r29, 0x0898
    1e8a:	8e 01       	movw	r16, r28
    1e8c:	0e 5f       	subi	r16, 0xFE	; 254
    1e8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e90:	c8 01       	movw	r24, r16
    1e92:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1e96:	8c 89       	ldd	r24, Y+20	; 0x14
    1e98:	9d 89       	ldd	r25, Y+21	; 0x15
    1e9a:	89 2b       	or	r24, r25
    1e9c:	21 f0       	breq	.+8      	; 0x1ea6 <vTaskSuspend+0x38>
    1e9e:	ce 01       	movw	r24, r28
    1ea0:	0c 96       	adiw	r24, 0x0c	; 12
    1ea2:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1ea6:	b8 01       	movw	r22, r16
    1ea8:	88 e3       	ldi	r24, 0x38	; 56
    1eaa:	98 e0       	ldi	r25, 0x08	; 8
    1eac:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1eb0:	0f 90       	pop	r0
    1eb2:	0f be       	out	0x3f, r0	; 63
    1eb4:	80 91 97 08 	lds	r24, 0x0897
    1eb8:	90 91 98 08 	lds	r25, 0x0898
    1ebc:	c8 17       	cp	r28, r24
    1ebe:	d9 07       	cpc	r29, r25
    1ec0:	a1 f4       	brne	.+40     	; 0x1eea <vTaskSuspend+0x7c>
    1ec2:	80 91 33 08 	lds	r24, 0x0833
    1ec6:	88 23       	and	r24, r24
    1ec8:	19 f0       	breq	.+6      	; 0x1ed0 <vTaskSuspend+0x62>
    1eca:	0e 94 44 07 	call	0xe88	; 0xe88 <vPortYield>
    1ece:	17 c0       	rjmp	.+46     	; 0x1efe <vTaskSuspend+0x90>
    1ed0:	80 91 37 08 	lds	r24, 0x0837
    1ed4:	90 91 38 08 	lds	r25, 0x0838
    1ed8:	98 13       	cpse	r25, r24
    1eda:	05 c0       	rjmp	.+10     	; 0x1ee6 <vTaskSuspend+0x78>
    1edc:	10 92 98 08 	sts	0x0898, r1
    1ee0:	10 92 97 08 	sts	0x0897, r1
    1ee4:	0c c0       	rjmp	.+24     	; 0x1efe <vTaskSuspend+0x90>
    1ee6:	65 df       	rcall	.-310    	; 0x1db2 <vTaskSwitchContext>
    1ee8:	0a c0       	rjmp	.+20     	; 0x1efe <vTaskSuspend+0x90>
    1eea:	80 91 33 08 	lds	r24, 0x0833
    1eee:	88 23       	and	r24, r24
    1ef0:	31 f0       	breq	.+12     	; 0x1efe <vTaskSuspend+0x90>
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	f8 94       	cli
    1ef6:	0f 92       	push	r0
    1ef8:	96 db       	rcall	.-2260   	; 0x1626 <prvResetNextTaskUnblockTime>
    1efa:	0f 90       	pop	r0
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	df 91       	pop	r29
    1f00:	cf 91       	pop	r28
    1f02:	1f 91       	pop	r17
    1f04:	0f 91       	pop	r16
    1f06:	08 95       	ret

00001f08 <vTaskPlaceOnEventList>:
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
    1f0c:	eb 01       	movw	r28, r22
    1f0e:	60 91 97 08 	lds	r22, 0x0897
    1f12:	70 91 98 08 	lds	r23, 0x0898
    1f16:	64 5f       	subi	r22, 0xF4	; 244
    1f18:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1a:	0e 94 76 02 	call	0x4ec	; 0x4ec <vListInsert>
    1f1e:	80 91 97 08 	lds	r24, 0x0897
    1f22:	90 91 98 08 	lds	r25, 0x0898
    1f26:	02 96       	adiw	r24, 0x02	; 2
    1f28:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1f2c:	cf 3f       	cpi	r28, 0xFF	; 255
    1f2e:	8f ef       	ldi	r24, 0xFF	; 255
    1f30:	d8 07       	cpc	r29, r24
    1f32:	59 f4       	brne	.+22     	; 0x1f4a <vTaskPlaceOnEventList+0x42>
    1f34:	60 91 97 08 	lds	r22, 0x0897
    1f38:	70 91 98 08 	lds	r23, 0x0898
    1f3c:	6e 5f       	subi	r22, 0xFE	; 254
    1f3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f40:	88 e3       	ldi	r24, 0x38	; 56
    1f42:	98 e0       	ldi	r25, 0x08	; 8
    1f44:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1f48:	07 c0       	rjmp	.+14     	; 0x1f58 <vTaskPlaceOnEventList+0x50>
    1f4a:	80 91 35 08 	lds	r24, 0x0835
    1f4e:	90 91 36 08 	lds	r25, 0x0836
    1f52:	8c 0f       	add	r24, r28
    1f54:	9d 1f       	adc	r25, r29
    1f56:	86 db       	rcall	.-2292   	; 0x1664 <prvAddCurrentTaskToDelayedList>
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	08 95       	ret

00001f5e <xTaskRemoveFromEventList>:
    1f5e:	0f 93       	push	r16
    1f60:	1f 93       	push	r17
    1f62:	cf 93       	push	r28
    1f64:	df 93       	push	r29
    1f66:	dc 01       	movw	r26, r24
    1f68:	15 96       	adiw	r26, 0x05	; 5
    1f6a:	ed 91       	ld	r30, X+
    1f6c:	fc 91       	ld	r31, X
    1f6e:	16 97       	sbiw	r26, 0x06	; 6
    1f70:	c6 81       	ldd	r28, Z+6	; 0x06
    1f72:	d7 81       	ldd	r29, Z+7	; 0x07
    1f74:	8e 01       	movw	r16, r28
    1f76:	04 5f       	subi	r16, 0xF4	; 244
    1f78:	1f 4f       	sbci	r17, 0xFF	; 255
    1f7a:	c8 01       	movw	r24, r16
    1f7c:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1f80:	80 91 2e 08 	lds	r24, 0x082E
    1f84:	81 11       	cpse	r24, r1
    1f86:	1c c0       	rjmp	.+56     	; 0x1fc0 <xTaskRemoveFromEventList+0x62>
    1f88:	0a 50       	subi	r16, 0x0A	; 10
    1f8a:	11 09       	sbc	r17, r1
    1f8c:	c8 01       	movw	r24, r16
    1f8e:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    1f92:	8e 89       	ldd	r24, Y+22	; 0x16
    1f94:	90 91 34 08 	lds	r25, 0x0834
    1f98:	98 17       	cp	r25, r24
    1f9a:	10 f4       	brcc	.+4      	; 0x1fa0 <xTaskRemoveFromEventList+0x42>
    1f9c:	80 93 34 08 	sts	0x0834, r24
    1fa0:	90 e0       	ldi	r25, 0x00	; 0
    1fa2:	9c 01       	movw	r18, r24
    1fa4:	22 0f       	add	r18, r18
    1fa6:	33 1f       	adc	r19, r19
    1fa8:	22 0f       	add	r18, r18
    1faa:	33 1f       	adc	r19, r19
    1fac:	22 0f       	add	r18, r18
    1fae:	33 1f       	adc	r19, r19
    1fb0:	82 0f       	add	r24, r18
    1fb2:	93 1f       	adc	r25, r19
    1fb4:	b8 01       	movw	r22, r16
    1fb6:	86 59       	subi	r24, 0x96	; 150
    1fb8:	97 4f       	sbci	r25, 0xF7	; 247
    1fba:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1fbe:	05 c0       	rjmp	.+10     	; 0x1fca <xTaskRemoveFromEventList+0x6c>
    1fc0:	b8 01       	movw	r22, r16
    1fc2:	8b e4       	ldi	r24, 0x4B	; 75
    1fc4:	98 e0       	ldi	r25, 0x08	; 8
    1fc6:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    1fca:	e0 91 97 08 	lds	r30, 0x0897
    1fce:	f0 91 98 08 	lds	r31, 0x0898
    1fd2:	9e 89       	ldd	r25, Y+22	; 0x16
    1fd4:	86 89       	ldd	r24, Z+22	; 0x16
    1fd6:	89 17       	cp	r24, r25
    1fd8:	20 f4       	brcc	.+8      	; 0x1fe2 <xTaskRemoveFromEventList+0x84>
    1fda:	81 e0       	ldi	r24, 0x01	; 1
    1fdc:	80 93 31 08 	sts	0x0831, r24
    1fe0:	01 c0       	rjmp	.+2      	; 0x1fe4 <xTaskRemoveFromEventList+0x86>
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	08 95       	ret

00001fee <vTaskSetTimeOutState>:
    1fee:	20 91 30 08 	lds	r18, 0x0830
    1ff2:	fc 01       	movw	r30, r24
    1ff4:	20 83       	st	Z, r18
    1ff6:	20 91 35 08 	lds	r18, 0x0835
    1ffa:	30 91 36 08 	lds	r19, 0x0836
    1ffe:	32 83       	std	Z+2, r19	; 0x02
    2000:	21 83       	std	Z+1, r18	; 0x01
    2002:	08 95       	ret

00002004 <xTaskCheckForTimeOut>:
    2004:	0f b6       	in	r0, 0x3f	; 63
    2006:	f8 94       	cli
    2008:	0f 92       	push	r0
    200a:	40 91 35 08 	lds	r20, 0x0835
    200e:	50 91 36 08 	lds	r21, 0x0836
    2012:	db 01       	movw	r26, r22
    2014:	2d 91       	ld	r18, X+
    2016:	3c 91       	ld	r19, X
    2018:	2f 3f       	cpi	r18, 0xFF	; 255
    201a:	bf ef       	ldi	r27, 0xFF	; 255
    201c:	3b 07       	cpc	r19, r27
    201e:	11 f1       	breq	.+68     	; 0x2064 <xTaskCheckForTimeOut+0x60>
    2020:	e0 91 30 08 	lds	r30, 0x0830
    2024:	dc 01       	movw	r26, r24
    2026:	fc 91       	ld	r31, X
    2028:	fe 17       	cp	r31, r30
    202a:	39 f0       	breq	.+14     	; 0x203a <xTaskCheckForTimeOut+0x36>
    202c:	11 96       	adiw	r26, 0x01	; 1
    202e:	ed 91       	ld	r30, X+
    2030:	fc 91       	ld	r31, X
    2032:	12 97       	sbiw	r26, 0x02	; 2
    2034:	4e 17       	cp	r20, r30
    2036:	5f 07       	cpc	r21, r31
    2038:	b8 f4       	brcc	.+46     	; 0x2068 <xTaskCheckForTimeOut+0x64>
    203a:	dc 01       	movw	r26, r24
    203c:	11 96       	adiw	r26, 0x01	; 1
    203e:	ed 91       	ld	r30, X+
    2040:	fc 91       	ld	r31, X
    2042:	12 97       	sbiw	r26, 0x02	; 2
    2044:	da 01       	movw	r26, r20
    2046:	ae 1b       	sub	r26, r30
    2048:	bf 0b       	sbc	r27, r31
    204a:	a2 17       	cp	r26, r18
    204c:	b3 07       	cpc	r27, r19
    204e:	70 f4       	brcc	.+28     	; 0x206c <xTaskCheckForTimeOut+0x68>
    2050:	e4 1b       	sub	r30, r20
    2052:	f5 0b       	sbc	r31, r21
    2054:	2e 0f       	add	r18, r30
    2056:	3f 1f       	adc	r19, r31
    2058:	fb 01       	movw	r30, r22
    205a:	31 83       	std	Z+1, r19	; 0x01
    205c:	20 83       	st	Z, r18
    205e:	c7 df       	rcall	.-114    	; 0x1fee <vTaskSetTimeOutState>
    2060:	80 e0       	ldi	r24, 0x00	; 0
    2062:	05 c0       	rjmp	.+10     	; 0x206e <xTaskCheckForTimeOut+0x6a>
    2064:	80 e0       	ldi	r24, 0x00	; 0
    2066:	03 c0       	rjmp	.+6      	; 0x206e <xTaskCheckForTimeOut+0x6a>
    2068:	81 e0       	ldi	r24, 0x01	; 1
    206a:	01 c0       	rjmp	.+2      	; 0x206e <xTaskCheckForTimeOut+0x6a>
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	08 95       	ret

00002074 <vTaskMissedYield>:
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	80 93 31 08 	sts	0x0831, r24
    207a:	08 95       	ret

0000207c <vTaskPriorityInherit>:
    207c:	0f 93       	push	r16
    207e:	1f 93       	push	r17
    2080:	cf 93       	push	r28
    2082:	df 93       	push	r29
    2084:	ec 01       	movw	r28, r24
    2086:	00 97       	sbiw	r24, 0x00	; 0
    2088:	09 f4       	brne	.+2      	; 0x208c <vTaskPriorityInherit+0x10>
    208a:	51 c0       	rjmp	.+162    	; 0x212e <vTaskPriorityInherit+0xb2>
    208c:	8e 89       	ldd	r24, Y+22	; 0x16
    208e:	e0 91 97 08 	lds	r30, 0x0897
    2092:	f0 91 98 08 	lds	r31, 0x0898
    2096:	96 89       	ldd	r25, Z+22	; 0x16
    2098:	89 17       	cp	r24, r25
    209a:	08 f0       	brcs	.+2      	; 0x209e <vTaskPriorityInherit+0x22>
    209c:	48 c0       	rjmp	.+144    	; 0x212e <vTaskPriorityInherit+0xb2>
    209e:	2c 85       	ldd	r18, Y+12	; 0x0c
    20a0:	3d 85       	ldd	r19, Y+13	; 0x0d
    20a2:	33 23       	and	r19, r19
    20a4:	5c f0       	brlt	.+22     	; 0x20bc <vTaskPriorityInherit+0x40>
    20a6:	e0 91 97 08 	lds	r30, 0x0897
    20aa:	f0 91 98 08 	lds	r31, 0x0898
    20ae:	96 89       	ldd	r25, Z+22	; 0x16
    20b0:	25 e0       	ldi	r18, 0x05	; 5
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	29 1b       	sub	r18, r25
    20b6:	31 09       	sbc	r19, r1
    20b8:	3d 87       	std	Y+13, r19	; 0x0d
    20ba:	2c 87       	std	Y+12, r18	; 0x0c
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	9c 01       	movw	r18, r24
    20c0:	22 0f       	add	r18, r18
    20c2:	33 1f       	adc	r19, r19
    20c4:	22 0f       	add	r18, r18
    20c6:	33 1f       	adc	r19, r19
    20c8:	22 0f       	add	r18, r18
    20ca:	33 1f       	adc	r19, r19
    20cc:	82 0f       	add	r24, r18
    20ce:	93 1f       	adc	r25, r19
    20d0:	86 59       	subi	r24, 0x96	; 150
    20d2:	97 4f       	sbci	r25, 0xF7	; 247
    20d4:	2a 85       	ldd	r18, Y+10	; 0x0a
    20d6:	3b 85       	ldd	r19, Y+11	; 0x0b
    20d8:	28 17       	cp	r18, r24
    20da:	39 07       	cpc	r19, r25
    20dc:	11 f5       	brne	.+68     	; 0x2122 <vTaskPriorityInherit+0xa6>
    20de:	8e 01       	movw	r16, r28
    20e0:	0e 5f       	subi	r16, 0xFE	; 254
    20e2:	1f 4f       	sbci	r17, 0xFF	; 255
    20e4:	c8 01       	movw	r24, r16
    20e6:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    20ea:	e0 91 97 08 	lds	r30, 0x0897
    20ee:	f0 91 98 08 	lds	r31, 0x0898
    20f2:	86 89       	ldd	r24, Z+22	; 0x16
    20f4:	8e 8b       	std	Y+22, r24	; 0x16
    20f6:	90 91 34 08 	lds	r25, 0x0834
    20fa:	98 17       	cp	r25, r24
    20fc:	10 f4       	brcc	.+4      	; 0x2102 <vTaskPriorityInherit+0x86>
    20fe:	80 93 34 08 	sts	0x0834, r24
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	9c 01       	movw	r18, r24
    2106:	22 0f       	add	r18, r18
    2108:	33 1f       	adc	r19, r19
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	82 0f       	add	r24, r18
    2114:	93 1f       	adc	r25, r19
    2116:	b8 01       	movw	r22, r16
    2118:	86 59       	subi	r24, 0x96	; 150
    211a:	97 4f       	sbci	r25, 0xF7	; 247
    211c:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    2120:	06 c0       	rjmp	.+12     	; 0x212e <vTaskPriorityInherit+0xb2>
    2122:	e0 91 97 08 	lds	r30, 0x0897
    2126:	f0 91 98 08 	lds	r31, 0x0898
    212a:	86 89       	ldd	r24, Z+22	; 0x16
    212c:	8e 8b       	std	Y+22, r24	; 0x16
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	1f 91       	pop	r17
    2134:	0f 91       	pop	r16
    2136:	08 95       	ret

00002138 <xTaskPriorityDisinherit>:
    2138:	0f 93       	push	r16
    213a:	1f 93       	push	r17
    213c:	cf 93       	push	r28
    213e:	df 93       	push	r29
    2140:	ec 01       	movw	r28, r24
    2142:	00 97       	sbiw	r24, 0x00	; 0
    2144:	71 f1       	breq	.+92     	; 0x21a2 <xTaskPriorityDisinherit+0x6a>
    2146:	8a a1       	ldd	r24, Y+34	; 0x22
    2148:	81 50       	subi	r24, 0x01	; 1
    214a:	8a a3       	std	Y+34, r24	; 0x22
    214c:	2e 89       	ldd	r18, Y+22	; 0x16
    214e:	99 a1       	ldd	r25, Y+33	; 0x21
    2150:	29 17       	cp	r18, r25
    2152:	49 f1       	breq	.+82     	; 0x21a6 <xTaskPriorityDisinherit+0x6e>
    2154:	81 11       	cpse	r24, r1
    2156:	29 c0       	rjmp	.+82     	; 0x21aa <xTaskPriorityDisinherit+0x72>
    2158:	8e 01       	movw	r16, r28
    215a:	0e 5f       	subi	r16, 0xFE	; 254
    215c:	1f 4f       	sbci	r17, 0xFF	; 255
    215e:	c8 01       	movw	r24, r16
    2160:	0e 94 a7 02 	call	0x54e	; 0x54e <uxListRemove>
    2164:	89 a1       	ldd	r24, Y+33	; 0x21
    2166:	8e 8b       	std	Y+22, r24	; 0x16
    2168:	25 e0       	ldi	r18, 0x05	; 5
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	28 1b       	sub	r18, r24
    216e:	31 09       	sbc	r19, r1
    2170:	3d 87       	std	Y+13, r19	; 0x0d
    2172:	2c 87       	std	Y+12, r18	; 0x0c
    2174:	90 91 34 08 	lds	r25, 0x0834
    2178:	98 17       	cp	r25, r24
    217a:	10 f4       	brcc	.+4      	; 0x2180 <xTaskPriorityDisinherit+0x48>
    217c:	80 93 34 08 	sts	0x0834, r24
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	9c 01       	movw	r18, r24
    2184:	22 0f       	add	r18, r18
    2186:	33 1f       	adc	r19, r19
    2188:	22 0f       	add	r18, r18
    218a:	33 1f       	adc	r19, r19
    218c:	22 0f       	add	r18, r18
    218e:	33 1f       	adc	r19, r19
    2190:	82 0f       	add	r24, r18
    2192:	93 1f       	adc	r25, r19
    2194:	b8 01       	movw	r22, r16
    2196:	86 59       	subi	r24, 0x96	; 150
    2198:	97 4f       	sbci	r25, 0xF7	; 247
    219a:	0e 94 55 02 	call	0x4aa	; 0x4aa <vListInsertEnd>
    219e:	81 e0       	ldi	r24, 0x01	; 1
    21a0:	05 c0       	rjmp	.+10     	; 0x21ac <xTaskPriorityDisinherit+0x74>
    21a2:	80 e0       	ldi	r24, 0x00	; 0
    21a4:	03 c0       	rjmp	.+6      	; 0x21ac <xTaskPriorityDisinherit+0x74>
    21a6:	80 e0       	ldi	r24, 0x00	; 0
    21a8:	01 c0       	rjmp	.+2      	; 0x21ac <xTaskPriorityDisinherit+0x74>
    21aa:	80 e0       	ldi	r24, 0x00	; 0
    21ac:	df 91       	pop	r29
    21ae:	cf 91       	pop	r28
    21b0:	1f 91       	pop	r17
    21b2:	0f 91       	pop	r16
    21b4:	08 95       	ret

000021b6 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    21b6:	80 91 97 08 	lds	r24, 0x0897
    21ba:	90 91 98 08 	lds	r25, 0x0898
    21be:	89 2b       	or	r24, r25
    21c0:	39 f0       	breq	.+14     	; 0x21d0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    21c2:	e0 91 97 08 	lds	r30, 0x0897
    21c6:	f0 91 98 08 	lds	r31, 0x0898
    21ca:	82 a1       	ldd	r24, Z+34	; 0x22
    21cc:	8f 5f       	subi	r24, 0xFF	; 255
    21ce:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    21d0:	80 91 97 08 	lds	r24, 0x0897
    21d4:	90 91 98 08 	lds	r25, 0x0898
	}
    21d8:	08 95       	ret

000021da <__divmodhi4>:
    21da:	97 fb       	bst	r25, 7
    21dc:	07 2e       	mov	r0, r23
    21de:	16 f4       	brtc	.+4      	; 0x21e4 <__divmodhi4+0xa>
    21e0:	00 94       	com	r0
    21e2:	06 d0       	rcall	.+12     	; 0x21f0 <__divmodhi4_neg1>
    21e4:	77 fd       	sbrc	r23, 7
    21e6:	08 d0       	rcall	.+16     	; 0x21f8 <__divmodhi4_neg2>
    21e8:	0b d0       	rcall	.+22     	; 0x2200 <__udivmodhi4>
    21ea:	07 fc       	sbrc	r0, 7
    21ec:	05 d0       	rcall	.+10     	; 0x21f8 <__divmodhi4_neg2>
    21ee:	3e f4       	brtc	.+14     	; 0x21fe <__divmodhi4_exit>

000021f0 <__divmodhi4_neg1>:
    21f0:	90 95       	com	r25
    21f2:	81 95       	neg	r24
    21f4:	9f 4f       	sbci	r25, 0xFF	; 255
    21f6:	08 95       	ret

000021f8 <__divmodhi4_neg2>:
    21f8:	70 95       	com	r23
    21fa:	61 95       	neg	r22
    21fc:	7f 4f       	sbci	r23, 0xFF	; 255

000021fe <__divmodhi4_exit>:
    21fe:	08 95       	ret

00002200 <__udivmodhi4>:
    2200:	aa 1b       	sub	r26, r26
    2202:	bb 1b       	sub	r27, r27
    2204:	51 e1       	ldi	r21, 0x11	; 17
    2206:	07 c0       	rjmp	.+14     	; 0x2216 <__udivmodhi4_ep>

00002208 <__udivmodhi4_loop>:
    2208:	aa 1f       	adc	r26, r26
    220a:	bb 1f       	adc	r27, r27
    220c:	a6 17       	cp	r26, r22
    220e:	b7 07       	cpc	r27, r23
    2210:	10 f0       	brcs	.+4      	; 0x2216 <__udivmodhi4_ep>
    2212:	a6 1b       	sub	r26, r22
    2214:	b7 0b       	sbc	r27, r23

00002216 <__udivmodhi4_ep>:
    2216:	88 1f       	adc	r24, r24
    2218:	99 1f       	adc	r25, r25
    221a:	5a 95       	dec	r21
    221c:	a9 f7       	brne	.-22     	; 0x2208 <__udivmodhi4_loop>
    221e:	80 95       	com	r24
    2220:	90 95       	com	r25
    2222:	bc 01       	movw	r22, r24
    2224:	cd 01       	movw	r24, r26
    2226:	08 95       	ret

00002228 <memcpy>:
    2228:	fb 01       	movw	r30, r22
    222a:	dc 01       	movw	r26, r24
    222c:	02 c0       	rjmp	.+4      	; 0x2232 <memcpy+0xa>
    222e:	01 90       	ld	r0, Z+
    2230:	0d 92       	st	X+, r0
    2232:	41 50       	subi	r20, 0x01	; 1
    2234:	50 40       	sbci	r21, 0x00	; 0
    2236:	d8 f7       	brcc	.-10     	; 0x222e <memcpy+0x6>
    2238:	08 95       	ret

0000223a <__itoa_ncheck>:
    223a:	bb 27       	eor	r27, r27
    223c:	4a 30       	cpi	r20, 0x0A	; 10
    223e:	31 f4       	brne	.+12     	; 0x224c <__itoa_ncheck+0x12>
    2240:	99 23       	and	r25, r25
    2242:	22 f4       	brpl	.+8      	; 0x224c <__itoa_ncheck+0x12>
    2244:	bd e2       	ldi	r27, 0x2D	; 45
    2246:	90 95       	com	r25
    2248:	81 95       	neg	r24
    224a:	9f 4f       	sbci	r25, 0xFF	; 255
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <__utoa_common>

0000224e <__utoa_ncheck>:
    224e:	bb 27       	eor	r27, r27

00002250 <__utoa_common>:
    2250:	fb 01       	movw	r30, r22
    2252:	55 27       	eor	r21, r21
    2254:	aa 27       	eor	r26, r26
    2256:	88 0f       	add	r24, r24
    2258:	99 1f       	adc	r25, r25
    225a:	aa 1f       	adc	r26, r26
    225c:	a4 17       	cp	r26, r20
    225e:	10 f0       	brcs	.+4      	; 0x2264 <__utoa_common+0x14>
    2260:	a4 1b       	sub	r26, r20
    2262:	83 95       	inc	r24
    2264:	50 51       	subi	r21, 0x10	; 16
    2266:	b9 f7       	brne	.-18     	; 0x2256 <__utoa_common+0x6>
    2268:	a0 5d       	subi	r26, 0xD0	; 208
    226a:	aa 33       	cpi	r26, 0x3A	; 58
    226c:	08 f0       	brcs	.+2      	; 0x2270 <__utoa_common+0x20>
    226e:	a9 5d       	subi	r26, 0xD9	; 217
    2270:	a1 93       	st	Z+, r26
    2272:	00 97       	sbiw	r24, 0x00	; 0
    2274:	79 f7       	brne	.-34     	; 0x2254 <__utoa_common+0x4>
    2276:	b1 11       	cpse	r27, r1
    2278:	b1 93       	st	Z+, r27
    227a:	11 92       	st	Z+, r1
    227c:	cb 01       	movw	r24, r22
    227e:	00 c0       	rjmp	.+0      	; 0x2280 <strrev>

00002280 <strrev>:
    2280:	dc 01       	movw	r26, r24
    2282:	fc 01       	movw	r30, r24
    2284:	67 2f       	mov	r22, r23
    2286:	71 91       	ld	r23, Z+
    2288:	77 23       	and	r23, r23
    228a:	e1 f7       	brne	.-8      	; 0x2284 <strrev+0x4>
    228c:	32 97       	sbiw	r30, 0x02	; 2
    228e:	04 c0       	rjmp	.+8      	; 0x2298 <strrev+0x18>
    2290:	7c 91       	ld	r23, X
    2292:	6d 93       	st	X+, r22
    2294:	70 83       	st	Z, r23
    2296:	62 91       	ld	r22, -Z
    2298:	ae 17       	cp	r26, r30
    229a:	bf 07       	cpc	r27, r31
    229c:	c8 f3       	brcs	.-14     	; 0x2290 <strrev+0x10>
    229e:	08 95       	ret

000022a0 <_exit>:
    22a0:	f8 94       	cli

000022a2 <__stop_program>:
    22a2:	ff cf       	rjmp	.-2      	; 0x22a2 <__stop_program>
