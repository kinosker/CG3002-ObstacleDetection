
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002eb6  00002f4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002eb6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070d  00800238  00800238  00002f82  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f82  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000568  00000000  00000000  00002fb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f0b  00000000  00000000  0000351a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001664  00000000  00000000  00009425  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000038d4  00000000  00000000  0000aa89  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f68  00000000  00000000  0000e360  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001797  00000000  00000000  0000f2c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000042d8  00000000  00000000  00010a5f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f8  00000000  00000000  00014d37  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	bb c3       	rjmp	.+1910   	; 0x79c <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 01 0b 	jmp	0x1602	; 0x1602 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	9b c7       	rjmp	.+3894   	; 0xf9c <__vector_25>
      66:	00 00       	nop
      68:	0c 94 46 08 	jmp	0x108c	; 0x108c <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	96 c4       	rjmp	.+2348   	; 0x9a2 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	4d c7       	rjmp	.+3738   	; 0xf2c <__vector_36>
      92:	00 00       	nop
      94:	bb c7       	rjmp	.+3958   	; 0x100c <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x3c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e6 eb       	ldi	r30, 0xB6	; 182
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a5 34       	cpi	r26, 0x45	; 69
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	d9 d0       	rcall	.+434    	; 0x354 <main>
     1a2:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 38 09 	call	0x1270	; 0x1270 <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 78 09 	call	0x12f0	; 0x12f0 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 6d 09 	call	0x12da	; 0x12da <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 8a 09 	call	0x1314	; 0x1314 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 38 02 	lds	r24, 0x0238
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 7e 09 	call	0x12fc	; 0x12fc <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 fb 08 	call	0x11f6	; 0x11f6 <myUSART_transmitUSART1_c>
     1e2:	d0 93 38 02 	sts	0x0238, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 84 09 	call	0x1308	; 0x1308 <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 38 02 	sts	0x0238, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 38 02 	sts	0x0238, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 38 02 	sts	0x0238, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 59 09 	call	0x12b2	; 0x12b2 <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 93 08 	lds	r24, 0x0893
     232:	90 91 94 08 	lds	r25, 0x0894
     236:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <xQueueGenericReceive>
     23a:	11 23       	and	r17, r17
     23c:	31 f1       	breq	.+76     	; 0x28a <RPI_sendTask+0x7a>
     23e:	8e 81       	ldd	r24, Y+6	; 0x06
     240:	80 5d       	subi	r24, 0xD0	; 208
     242:	d9 d7       	rcall	.+4018   	; 0x11f6 <myUSART_transmitUSART1_c>
     244:	8a e0       	ldi	r24, 0x0A	; 10
     246:	d7 d7       	rcall	.+4014   	; 0x11f6 <myUSART_transmitUSART1_c>
     248:	20 c0       	rjmp	.+64     	; 0x28a <RPI_sendTask+0x7a>
     24a:	20 e0       	ldi	r18, 0x00	; 0
     24c:	4f ef       	ldi	r20, 0xFF	; 255
     24e:	5f ef       	ldi	r21, 0xFF	; 255
     250:	be 01       	movw	r22, r28
     252:	6f 5f       	subi	r22, 0xFF	; 255
     254:	7f 4f       	sbci	r23, 0xFF	; 255
     256:	80 91 95 08 	lds	r24, 0x0895
     25a:	90 91 96 08 	lds	r25, 0x0896
     25e:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <xQueueGenericReceive>
     262:	89 81       	ldd	r24, Y+1	; 0x01
     264:	a7 d7       	rcall	.+3918   	; 0x11b4 <myUSART_transmitUSART0_c>
     266:	87 e0       	ldi	r24, 0x07	; 7
     268:	92 e0       	ldi	r25, 0x02	; 2
     26a:	f4 d7       	rcall	.+4072   	; 0x1254 <myUSART_transmitUSART0>
     26c:	ce 01       	movw	r24, r28
     26e:	02 96       	adiw	r24, 0x02	; 2
     270:	f1 d7       	rcall	.+4066   	; 0x1254 <myUSART_transmitUSART0>
     272:	8a e0       	ldi	r24, 0x0A	; 10
     274:	92 e0       	ldi	r25, 0x02	; 2
     276:	ee d7       	rcall	.+4060   	; 0x1254 <myUSART_transmitUSART0>
     278:	11 23       	and	r17, r17
     27a:	39 f0       	breq	.+14     	; 0x28a <RPI_sendTask+0x7a>
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	bb d7       	rcall	.+3958   	; 0x11f6 <myUSART_transmitUSART1_c>
     280:	ce 01       	movw	r24, r28
     282:	02 96       	adiw	r24, 0x02	; 2
     284:	d9 d7       	rcall	.+4018   	; 0x1238 <myUSART_transmitUSART1>
     286:	8a e0       	ldi	r24, 0x0A	; 10
     288:	b6 d7       	rcall	.+3948   	; 0x11f6 <myUSART_transmitUSART1_c>
     28a:	9e 81       	ldd	r25, Y+6	; 0x06
     28c:	2f ef       	ldi	r18, 0xFF	; 255
     28e:	29 0f       	add	r18, r25
     290:	2e 83       	std	Y+6, r18	; 0x06
     292:	91 11       	cpse	r25, r1
     294:	da cf       	rjmp	.-76     	; 0x24a <RPI_sendTask+0x3a>
     296:	8a e0       	ldi	r24, 0x0A	; 10
     298:	8d d7       	rcall	.+3866   	; 0x11b4 <myUSART_transmitUSART0_c>
     29a:	c0 cf       	rjmp	.-128    	; 0x21c <RPI_sendTask+0xc>

0000029c <myTimerTask>:
     29c:	74 d5       	rcall	.+2792   	; 0xd86 <myTimer_Init>
     29e:	d7 d5       	rcall	.+2990   	; 0xe4e <myTimer_DelayChecker>
     2a0:	fe cf       	rjmp	.-4      	; 0x29e <myTimerTask+0x2>

000002a2 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2a2:	8f ef       	ldi	r24, 0xFF	; 255
     2a4:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2a8:	ef e7       	ldi	r30, 0x7F	; 127
     2aa:	f0 e0       	ldi	r31, 0x00	; 0
     2ac:	90 81       	ld	r25, Z
     2ae:	93 60       	ori	r25, 0x03	; 3
     2b0:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2b2:	80 93 7d 00 	sts	0x007D, r24
     2b6:	08 95       	ret

000002b8 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2b8:	8c ec       	ldi	r24, 0xCC	; 204
     2ba:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2be:	8e e3       	ldi	r24, 0x3E	; 62
     2c0:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2c4:	ee cf       	rjmp	.-36     	; 0x2a2 <setDigitalInputPowerReduction>
     2c6:	08 95       	ret

000002c8 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2c8:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2cc:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2d0:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2d4:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2d8:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2dc:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2e0:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2e4:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2e8:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2ec:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2f0:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2f4:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2f8:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2fc:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     300:	10 92 73 00 	sts	0x0073, r1
     304:	08 95       	ret

00000306 <init>:
}

void init()
{
     306:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     308:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     30a:	f8 94       	cli
	{
		clearTimer();
     30c:	dd df       	rcall	.-70     	; 0x2c8 <clearTimer>
		setPowerReduction();
     30e:	d4 df       	rcall	.-88     	; 0x2b8 <setPowerReduction>
		myUSART_USART0_Init();
     310:	fd d6       	rcall	.+3578   	; 0x110c <myUSART_USART0_Init>
		myUSART_USART1_Init();
     312:	22 d7       	rcall	.+3652   	; 0x1158 <myUSART_USART1_Init>
		myADC_Init();
     314:	7e d3       	rcall	.+1788   	; 0xa12 <myADC_Init>
		
		MaxSonar_Init();
     316:	83 b3       	in	r24, 0x13	; 19
     318:	83 60       	ori	r24, 0x03	; 3
     31a:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     31c:	40 e0       	ldi	r20, 0x00	; 0
     31e:	61 e0       	ldi	r22, 0x01	; 1
     320:	85 e0       	ldi	r24, 0x05	; 5
     322:	0e 94 00 0c 	call	0x1800	; 0x1800 <xQueueGenericCreate>
     326:	90 93 94 08 	sts	0x0894, r25
     32a:	80 93 93 08 	sts	0x0893, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     32e:	40 e0       	ldi	r20, 0x00	; 0
     330:	65 e0       	ldi	r22, 0x05	; 5
     332:	84 e1       	ldi	r24, 0x14	; 20
     334:	0e 94 00 0c 	call	0x1800	; 0x1800 <xQueueGenericCreate>
     338:	90 93 96 08 	sts	0x0896, r25
     33c:	80 93 95 08 	sts	0x0895, r24
		
		MOTOR_LEFT_INIT();
     340:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     342:	e1 e0       	ldi	r30, 0x01	; 1
     344:	f1 e0       	ldi	r31, 0x01	; 1
     346:	80 81       	ld	r24, Z
     348:	80 61       	ori	r24, 0x10	; 16
     34a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     34c:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     34e:	78 94       	sei
}
     350:	cf 91       	pop	r28
     352:	08 95       	ret

00000354 <main>:
	
	// do nth
}

int main(void)
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	cd b7       	in	r28, 0x3d	; 61
     35a:	de b7       	in	r29, 0x3e	; 62
     35c:	28 97       	sbiw	r28, 0x08	; 8
     35e:	0f b6       	in	r0, 0x3f	; 63
     360:	f8 94       	cli
     362:	de bf       	out	0x3e, r29	; 62
     364:	0f be       	out	0x3f, r0	; 63
     366:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     368:	ce df       	rcall	.-100    	; 0x306 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     36a:	a1 2c       	mov	r10, r1
     36c:	b1 2c       	mov	r11, r1
     36e:	c1 2c       	mov	r12, r1
     370:	d1 2c       	mov	r13, r1
     372:	ce 01       	movw	r24, r28
     374:	01 96       	adiw	r24, 0x01	; 1
     376:	7c 01       	movw	r14, r24
     378:	04 e0       	ldi	r16, 0x04	; 4
     37a:	9c 01       	movw	r18, r24
     37c:	49 e6       	ldi	r20, 0x69	; 105
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	6d e0       	ldi	r22, 0x0D	; 13
     382:	72 e0       	ldi	r23, 0x02	; 2
     384:	8e e4       	ldi	r24, 0x4E	; 78
     386:	91 e0       	ldi	r25, 0x01	; 1
     388:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     38c:	ce 01       	movw	r24, r28
     38e:	07 96       	adiw	r24, 0x07	; 7
     390:	7c 01       	movw	r14, r24
     392:	02 e0       	ldi	r16, 0x02	; 2
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	4d e6       	ldi	r20, 0x6D	; 109
     39a:	51 e0       	ldi	r21, 0x01	; 1
     39c:	65 e1       	ldi	r22, 0x15	; 21
     39e:	72 e0       	ldi	r23, 0x02	; 2
     3a0:	83 e8       	ldi	r24, 0x83	; 131
     3a2:	92 e0       	ldi	r25, 0x02	; 2
     3a4:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a8:	ce 01       	movw	r24, r28
     3aa:	05 96       	adiw	r24, 0x05	; 5
     3ac:	7c 01       	movw	r14, r24
     3ae:	03 e0       	ldi	r16, 0x03	; 3
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	47 e8       	ldi	r20, 0x87	; 135
     3b6:	50 e0       	ldi	r21, 0x00	; 0
     3b8:	6e e1       	ldi	r22, 0x1E	; 30
     3ba:	72 e0       	ldi	r23, 0x02	; 2
     3bc:	84 ed       	ldi	r24, 0xD4	; 212
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3c4:	ce 01       	movw	r24, r28
     3c6:	03 96       	adiw	r24, 0x03	; 3
     3c8:	7c 01       	movw	r14, r24
     3ca:	01 e0       	ldi	r16, 0x01	; 1
     3cc:	20 e0       	ldi	r18, 0x00	; 0
     3ce:	30 e0       	ldi	r19, 0x00	; 0
     3d0:	47 e8       	ldi	r20, 0x87	; 135
     3d2:	50 e0       	ldi	r21, 0x00	; 0
     3d4:	6a e2       	ldi	r22, 0x2A	; 42
     3d6:	72 e0       	ldi	r23, 0x02	; 2
     3d8:	88 e0       	ldi	r24, 0x08	; 8
     3da:	91 e0       	ldi	r25, 0x01	; 1
     3dc:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3e0:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <vTaskStartScheduler>
     3e4:	c1 cf       	rjmp	.-126    	; 0x368 <main+0x14>

000003e6 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3e6:	9c 01       	movw	r18, r24
     3e8:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3ea:	64 e6       	ldi	r22, 0x64	; 100
     3ec:	70 e0       	ldi	r23, 0x00	; 0
     3ee:	0e 94 29 17 	call	0x2e52	; 0x2e52 <__divmodhi4>
	
	if(input)
     3f2:	61 15       	cp	r22, r1
     3f4:	71 05       	cpc	r23, r1
     3f6:	21 f0       	breq	.+8      	; 0x400 <myItoa+0x1a>
		*buffer++ = input + '0';
     3f8:	80 e3       	ldi	r24, 0x30	; 48
     3fa:	86 0f       	add	r24, r22
     3fc:	80 83       	st	Z, r24
     3fe:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     400:	4c e9       	ldi	r20, 0x9C	; 156
     402:	46 03       	mulsu	r20, r22
     404:	c0 01       	movw	r24, r0
     406:	47 9f       	mul	r20, r23
     408:	90 0d       	add	r25, r0
     40a:	11 24       	eor	r1, r1
     40c:	28 0f       	add	r18, r24
     40e:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     410:	c9 01       	movw	r24, r18
     412:	6a e0       	ldi	r22, 0x0A	; 10
     414:	70 e0       	ldi	r23, 0x00	; 0
     416:	0e 94 29 17 	call	0x2e52	; 0x2e52 <__divmodhi4>
	*buffer++ = input + '0';
     41a:	80 e3       	ldi	r24, 0x30	; 48
     41c:	86 0f       	add	r24, r22
     41e:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     420:	8a e0       	ldi	r24, 0x0A	; 10
     422:	68 9f       	mul	r22, r24
     424:	20 19       	sub	r18, r0
     426:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     428:	20 5d       	subi	r18, 0xD0	; 208
     42a:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     42c:	12 82       	std	Z+2, r1	; 0x02
     42e:	08 95       	ret

00000430 <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     430:	1f 93       	push	r17
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	00 d0       	rcall	.+0      	; 0x438 <obstacleSend+0x8>
     438:	1f 92       	push	r1
     43a:	1f 92       	push	r1
     43c:	cd b7       	in	r28, 0x3d	; 61
     43e:	de b7       	in	r29, 0x3e	; 62
     440:	18 2f       	mov	r17, r24
     442:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     444:	11 23       	and	r17, r17
     446:	89 f0       	breq	.+34     	; 0x46a <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     448:	be 01       	movw	r22, r28
     44a:	6e 5f       	subi	r22, 0xFE	; 254
     44c:	7f 4f       	sbci	r23, 0xFF	; 255
     44e:	cb df       	rcall	.-106    	; 0x3e6 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     450:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     452:	20 e0       	ldi	r18, 0x00	; 0
     454:	4f ef       	ldi	r20, 0xFF	; 255
     456:	5f ef       	ldi	r21, 0xFF	; 255
     458:	be 01       	movw	r22, r28
     45a:	6f 5f       	subi	r22, 0xFF	; 255
     45c:	7f 4f       	sbci	r23, 0xFF	; 255
     45e:	80 91 95 08 	lds	r24, 0x0895
     462:	90 91 96 08 	lds	r25, 0x0896
     466:	0e 94 2d 0c 	call	0x185a	; 0x185a <xQueueGenericSend>
	}
}
     46a:	0f 90       	pop	r0
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	1f 91       	pop	r17
     47a:	08 95       	ret

0000047c <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     47c:	6f 92       	push	r6
     47e:	7f 92       	push	r7
     480:	8f 92       	push	r8
     482:	9f 92       	push	r9
     484:	af 92       	push	r10
     486:	bf 92       	push	r11
     488:	cf 92       	push	r12
     48a:	df 92       	push	r13
     48c:	ef 92       	push	r14
     48e:	ff 92       	push	r15
     490:	0f 93       	push	r16
     492:	1f 93       	push	r17
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	1f 92       	push	r1
     49a:	cd b7       	in	r28, 0x3d	; 61
     49c:	de b7       	in	r29, 0x3e	; 62
     49e:	89 83       	std	Y+1, r24	; 0x01
     4a0:	5b 01       	movw	r10, r22
     4a2:	3a 01       	movw	r6, r20
     4a4:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4a6:	20 e0       	ldi	r18, 0x00	; 0
     4a8:	4f ef       	ldi	r20, 0xFF	; 255
     4aa:	5f ef       	ldi	r21, 0xFF	; 255
     4ac:	be 01       	movw	r22, r28
     4ae:	6f 5f       	subi	r22, 0xFF	; 255
     4b0:	7f 4f       	sbci	r23, 0xFF	; 255
     4b2:	80 91 93 08 	lds	r24, 0x0893
     4b6:	90 91 94 08 	lds	r25, 0x0894
     4ba:	0e 94 2d 0c 	call	0x185a	; 0x185a <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4be:	b3 01       	movw	r22, r6
     4c0:	f5 01       	movw	r30, r10
     4c2:	80 81       	ld	r24, Z
     4c4:	b5 df       	rcall	.-150    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4c6:	b4 01       	movw	r22, r8
     4c8:	f5 01       	movw	r30, r10
     4ca:	81 81       	ldd	r24, Z+1	; 0x01
     4cc:	b1 df       	rcall	.-158    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4ce:	b8 01       	movw	r22, r16
     4d0:	f5 01       	movw	r30, r10
     4d2:	82 81       	ldd	r24, Z+2	; 0x02
     4d4:	ad df       	rcall	.-166    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4d6:	b7 01       	movw	r22, r14
     4d8:	f5 01       	movw	r30, r10
     4da:	83 81       	ldd	r24, Z+3	; 0x03
     4dc:	a9 df       	rcall	.-174    	; 0x430 <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4de:	b6 01       	movw	r22, r12
     4e0:	f5 01       	movw	r30, r10
     4e2:	84 81       	ldd	r24, Z+4	; 0x04
     4e4:	a5 df       	rcall	.-182    	; 0x430 <obstacleSend>
		
	}
}
     4e6:	0f 90       	pop	r0
     4e8:	df 91       	pop	r29
     4ea:	cf 91       	pop	r28
     4ec:	1f 91       	pop	r17
     4ee:	0f 91       	pop	r16
     4f0:	ff 90       	pop	r15
     4f2:	ef 90       	pop	r14
     4f4:	df 90       	pop	r13
     4f6:	cf 90       	pop	r12
     4f8:	bf 90       	pop	r11
     4fa:	af 90       	pop	r10
     4fc:	9f 90       	pop	r9
     4fe:	8f 90       	pop	r8
     500:	7f 90       	pop	r7
     502:	6f 90       	pop	r6
     504:	08 95       	ret

00000506 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	cd b7       	in	r28, 0x3d	; 61
     50c:	de b7       	in	r29, 0x3e	; 62
     50e:	a4 97       	sbiw	r28, 0x24	; 36
     510:	0f b6       	in	r0, 0x3f	; 63
     512:	f8 94       	cli
     514:	de bf       	out	0x3e, r29	; 62
     516:	0f be       	out	0x3f, r0	; 63
     518:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     51a:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     51c:	86 e0       	ldi	r24, 0x06	; 6
     51e:	fe 01       	movw	r30, r28
     520:	34 96       	adiw	r30, 0x04	; 4
     522:	df 01       	movw	r26, r30
     524:	98 2f       	mov	r25, r24
     526:	1d 92       	st	X+, r1
     528:	9a 95       	dec	r25
     52a:	e9 f7       	brne	.-6      	; 0x526 <Sonar_Task+0x20>
     52c:	36 96       	adiw	r30, 0x06	; 6
     52e:	df 01       	movw	r26, r30
     530:	98 2f       	mov	r25, r24
     532:	1d 92       	st	X+, r1
     534:	9a 95       	dec	r25
     536:	e9 f7       	brne	.-6      	; 0x532 <Sonar_Task+0x2c>
     538:	36 96       	adiw	r30, 0x06	; 6
     53a:	df 01       	movw	r26, r30
     53c:	98 2f       	mov	r25, r24
     53e:	1d 92       	st	X+, r1
     540:	9a 95       	dec	r25
     542:	e9 f7       	brne	.-6      	; 0x53e <Sonar_Task+0x38>
     544:	36 96       	adiw	r30, 0x06	; 6
     546:	df 01       	movw	r26, r30
     548:	1d 92       	st	X+, r1
     54a:	8a 95       	dec	r24
     54c:	e9 f7       	brne	.-6      	; 0x548 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     54e:	36 96       	adiw	r30, 0x06	; 6
     550:	85 e0       	ldi	r24, 0x05	; 5
     552:	df 01       	movw	r26, r30
     554:	1d 92       	st	X+, r1
     556:	8a 95       	dec	r24
     558:	e9 f7       	brne	.-6      	; 0x554 <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     55a:	84 e2       	ldi	r24, 0x24	; 36
     55c:	8b d3       	rcall	.+1814   	; 0xc74 <mySharpIR_Read>
     55e:	9a a3       	std	Y+34, r25	; 0x22
     560:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     562:	0e 94 fc 0f 	call	0x1ff8	; 0x1ff8 <xTaskGetTickCount>
     566:	9a 83       	std	Y+2, r25	; 0x02
     568:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     56a:	a3 d1       	rcall	.+838    	; 0x8b2 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     56c:	87 e2       	ldi	r24, 0x27	; 39
     56e:	07 d2       	rcall	.+1038   	; 0x97e <myMaxSonar_Read>
     570:	be 01       	movw	r22, r28
     572:	66 5f       	subi	r22, 0xF6	; 246
     574:	7f 4f       	sbci	r23, 0xFF	; 255
     576:	fa d1       	rcall	.+1012   	; 0x96c <myMaxSonar_getFilteredReading>
     578:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     57a:	86 e2       	ldi	r24, 0x26	; 38
     57c:	00 d2       	rcall	.+1024   	; 0x97e <myMaxSonar_Read>
     57e:	be 01       	movw	r22, r28
     580:	60 5f       	subi	r22, 0xF0	; 240
     582:	7f 4f       	sbci	r23, 0xFF	; 255
     584:	f3 d1       	rcall	.+998    	; 0x96c <myMaxSonar_getFilteredReading>
     586:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     588:	85 e2       	ldi	r24, 0x25	; 37
     58a:	f9 d1       	rcall	.+1010   	; 0x97e <myMaxSonar_Read>
     58c:	be 01       	movw	r22, r28
     58e:	6a 5e       	subi	r22, 0xEA	; 234
     590:	7f 4f       	sbci	r23, 0xFF	; 255
     592:	ec d1       	rcall	.+984    	; 0x96c <myMaxSonar_getFilteredReading>
     594:	2c 01       	movw	r4, r24
		
		myMaxSonar_TopStart();
     596:	93 d1       	rcall	.+806    	; 0x8be <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     598:	83 e2       	ldi	r24, 0x23	; 35
     59a:	f1 d1       	rcall	.+994    	; 0x97e <myMaxSonar_Read>
     59c:	be 01       	movw	r22, r28
     59e:	6c 5f       	subi	r22, 0xFC	; 252
     5a0:	7f 4f       	sbci	r23, 0xFF	; 255
     5a2:	e4 d1       	rcall	.+968    	; 0x96c <myMaxSonar_getFilteredReading>
     5a4:	9c a3       	std	Y+36, r25	; 0x24
     5a6:	8b a3       	std	Y+35, r24	; 0x23
			
			
		btmIR		= mySharpIR_Read(AN12);
     5a8:	84 e2       	ldi	r24, 0x24	; 36
     5aa:	64 d3       	rcall	.+1736   	; 0xc74 <mySharpIR_Read>
     5ac:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5ae:	bc 01       	movw	r22, r24
     5b0:	ce 01       	movw	r24, r28
     5b2:	81 96       	adiw	r24, 0x21	; 33
     5b4:	98 d3       	rcall	.+1840   	; 0xce6 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5b6:	c9 a0       	ldd	r12, Y+33	; 0x21
     5b8:	da a0       	ldd	r13, Y+34	; 0x22
     5ba:	54 01       	movw	r10, r8
     5bc:	eb a0       	ldd	r14, Y+35	; 0x23
     5be:	fc a0       	ldd	r15, Y+36	; 0x24
     5c0:	82 01       	movw	r16, r4
     5c2:	91 01       	movw	r18, r2
     5c4:	ae 01       	movw	r20, r28
     5c6:	44 5e       	subi	r20, 0xE4	; 228
     5c8:	5f 4f       	sbci	r21, 0xFF	; 255
     5ca:	6b 81       	ldd	r22, Y+3	; 0x03
     5cc:	c3 01       	movw	r24, r6
     5ce:	18 d3       	rcall	.+1584   	; 0xc00 <obstacleDetection>
     5d0:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5d2:	8e 01       	movw	r16, r28
     5d4:	04 5e       	subi	r16, 0xE4	; 228
     5d6:	1f 4f       	sbci	r17, 0xFF	; 255
     5d8:	94 01       	movw	r18, r8
     5da:	a2 01       	movw	r20, r4
     5dc:	b1 01       	movw	r22, r2
     5de:	c3 01       	movw	r24, r6
     5e0:	99 d2       	rcall	.+1330   	; 0xb14 <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5e2:	be 01       	movw	r22, r28
     5e4:	6d 5f       	subi	r22, 0xFD	; 253
     5e6:	7f 4f       	sbci	r23, 0xFF	; 255
     5e8:	c8 01       	movw	r24, r16
     5ea:	fb d2       	rcall	.+1526   	; 0xbe2 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5ec:	cb a0       	ldd	r12, Y+35	; 0x23
     5ee:	dc a0       	ldd	r13, Y+36	; 0x24
     5f0:	74 01       	movw	r14, r8
     5f2:	82 01       	movw	r16, r4
     5f4:	91 01       	movw	r18, r2
     5f6:	a3 01       	movw	r20, r6
     5f8:	be 01       	movw	r22, r28
     5fa:	64 5e       	subi	r22, 0xE4	; 228
     5fc:	7f 4f       	sbci	r23, 0xFF	; 255
     5fe:	8b 81       	ldd	r24, Y+3	; 0x03
     600:	3d df       	rcall	.-390    	; 0x47c <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     602:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     604:	18 a2       	std	Y+32, r1	; 0x20
     606:	1f 8e       	std	Y+31, r1	; 0x1f
     608:	1e 8e       	std	Y+30, r1	; 0x1e
     60a:	1d 8e       	std	Y+29, r1	; 0x1d
     60c:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     60e:	66 e9       	ldi	r22, 0x96	; 150
     610:	70 e0       	ldi	r23, 0x00	; 0
     612:	ce 01       	movw	r24, r28
     614:	01 96       	adiw	r24, 0x01	; 1
     616:	0e 94 4a 11 	call	0x2294	; 0x2294 <vTaskDelayUntil>
     61a:	a7 cf       	rjmp	.-178    	; 0x56a <Sonar_Task+0x64>

0000061c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     61c:	cf 93       	push	r28
     61e:	df 93       	push	r29
     620:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     622:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     626:	80 91 39 02 	lds	r24, 0x0239
     62a:	90 91 3a 02 	lds	r25, 0x023A
     62e:	89 2b       	or	r24, r25
     630:	31 f4       	brne	.+12     	; 0x63e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     632:	8e e3       	ldi	r24, 0x3E	; 62
     634:	92 e0       	ldi	r25, 0x02	; 2
     636:	90 93 3a 02 	sts	0x023A, r25
     63a:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     63e:	40 91 3b 02 	lds	r20, 0x023B
     642:	50 91 3c 02 	lds	r21, 0x023C
     646:	9e 01       	movw	r18, r28
     648:	24 0f       	add	r18, r20
     64a:	35 1f       	adc	r19, r21
     64c:	2b 3d       	cpi	r18, 0xDB	; 219
     64e:	85 e0       	ldi	r24, 0x05	; 5
     650:	38 07       	cpc	r19, r24
     652:	70 f4       	brcc	.+28     	; 0x670 <pvPortMalloc+0x54>
     654:	42 17       	cp	r20, r18
     656:	53 07       	cpc	r21, r19
     658:	70 f4       	brcc	.+28     	; 0x676 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     65a:	c0 91 39 02 	lds	r28, 0x0239
     65e:	d0 91 3a 02 	lds	r29, 0x023A
     662:	c4 0f       	add	r28, r20
     664:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     666:	30 93 3c 02 	sts	0x023C, r19
     66a:	20 93 3b 02 	sts	0x023B, r18
     66e:	05 c0       	rjmp	.+10     	; 0x67a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     670:	c0 e0       	ldi	r28, 0x00	; 0
     672:	d0 e0       	ldi	r29, 0x00	; 0
     674:	02 c0       	rjmp	.+4      	; 0x67a <pvPortMalloc+0x5e>
     676:	c0 e0       	ldi	r28, 0x00	; 0
     678:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     67a:	0e 94 c9 10 	call	0x2192	; 0x2192 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     67e:	ce 01       	movw	r24, r28
     680:	df 91       	pop	r29
     682:	cf 91       	pop	r28
     684:	08 95       	ret

00000686 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     686:	08 95       	ret

00000688 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     688:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     68a:	03 96       	adiw	r24, 0x03	; 3
     68c:	92 83       	std	Z+2, r25	; 0x02
     68e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     690:	2f ef       	ldi	r18, 0xFF	; 255
     692:	3f ef       	ldi	r19, 0xFF	; 255
     694:	34 83       	std	Z+4, r19	; 0x04
     696:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     698:	96 83       	std	Z+6, r25	; 0x06
     69a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     69c:	90 87       	std	Z+8, r25	; 0x08
     69e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6a0:	10 82       	st	Z, r1
     6a2:	08 95       	ret

000006a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6a4:	fc 01       	movw	r30, r24
     6a6:	11 86       	std	Z+9, r1	; 0x09
     6a8:	10 86       	std	Z+8, r1	; 0x08
     6aa:	08 95       	ret

000006ac <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
     6b0:	9c 01       	movw	r18, r24
     6b2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6b4:	dc 01       	movw	r26, r24
     6b6:	11 96       	adiw	r26, 0x01	; 1
     6b8:	cd 91       	ld	r28, X+
     6ba:	dc 91       	ld	r29, X
     6bc:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6be:	d3 83       	std	Z+3, r29	; 0x03
     6c0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6c2:	8c 81       	ldd	r24, Y+4	; 0x04
     6c4:	9d 81       	ldd	r25, Y+5	; 0x05
     6c6:	95 83       	std	Z+5, r25	; 0x05
     6c8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6ca:	8c 81       	ldd	r24, Y+4	; 0x04
     6cc:	9d 81       	ldd	r25, Y+5	; 0x05
     6ce:	dc 01       	movw	r26, r24
     6d0:	13 96       	adiw	r26, 0x03	; 3
     6d2:	7c 93       	st	X, r23
     6d4:	6e 93       	st	-X, r22
     6d6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6d8:	7d 83       	std	Y+5, r23	; 0x05
     6da:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6dc:	31 87       	std	Z+9, r19	; 0x09
     6de:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6e0:	f9 01       	movw	r30, r18
     6e2:	80 81       	ld	r24, Z
     6e4:	8f 5f       	subi	r24, 0xFF	; 255
     6e6:	80 83       	st	Z, r24
}
     6e8:	df 91       	pop	r29
     6ea:	cf 91       	pop	r28
     6ec:	08 95       	ret

000006ee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6f4:	48 81       	ld	r20, Y
     6f6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6f8:	4f 3f       	cpi	r20, 0xFF	; 255
     6fa:	2f ef       	ldi	r18, 0xFF	; 255
     6fc:	52 07       	cpc	r21, r18
     6fe:	21 f4       	brne	.+8      	; 0x708 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     700:	fc 01       	movw	r30, r24
     702:	a7 81       	ldd	r26, Z+7	; 0x07
     704:	b0 85       	ldd	r27, Z+8	; 0x08
     706:	0d c0       	rjmp	.+26     	; 0x722 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     708:	dc 01       	movw	r26, r24
     70a:	13 96       	adiw	r26, 0x03	; 3
     70c:	12 96       	adiw	r26, 0x02	; 2
     70e:	ed 91       	ld	r30, X+
     710:	fc 91       	ld	r31, X
     712:	13 97       	sbiw	r26, 0x03	; 3
     714:	20 81       	ld	r18, Z
     716:	31 81       	ldd	r19, Z+1	; 0x01
     718:	42 17       	cp	r20, r18
     71a:	53 07       	cpc	r21, r19
     71c:	10 f0       	brcs	.+4      	; 0x722 <vListInsert+0x34>
     71e:	df 01       	movw	r26, r30
     720:	f5 cf       	rjmp	.-22     	; 0x70c <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     722:	12 96       	adiw	r26, 0x02	; 2
     724:	ed 91       	ld	r30, X+
     726:	fc 91       	ld	r31, X
     728:	13 97       	sbiw	r26, 0x03	; 3
     72a:	fb 83       	std	Y+3, r31	; 0x03
     72c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     72e:	d5 83       	std	Z+5, r29	; 0x05
     730:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     732:	bd 83       	std	Y+5, r27	; 0x05
     734:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     736:	13 96       	adiw	r26, 0x03	; 3
     738:	dc 93       	st	X, r29
     73a:	ce 93       	st	-X, r28
     73c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     73e:	99 87       	std	Y+9, r25	; 0x09
     740:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     742:	fc 01       	movw	r30, r24
     744:	20 81       	ld	r18, Z
     746:	2f 5f       	subi	r18, 0xFF	; 255
     748:	20 83       	st	Z, r18
}
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     750:	cf 93       	push	r28
     752:	df 93       	push	r29
     754:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     756:	a0 85       	ldd	r26, Z+8	; 0x08
     758:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     75a:	c2 81       	ldd	r28, Z+2	; 0x02
     75c:	d3 81       	ldd	r29, Z+3	; 0x03
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9d 83       	std	Y+5, r25	; 0x05
     764:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     766:	c4 81       	ldd	r28, Z+4	; 0x04
     768:	d5 81       	ldd	r29, Z+5	; 0x05
     76a:	82 81       	ldd	r24, Z+2	; 0x02
     76c:	93 81       	ldd	r25, Z+3	; 0x03
     76e:	9b 83       	std	Y+3, r25	; 0x03
     770:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     772:	11 96       	adiw	r26, 0x01	; 1
     774:	cd 91       	ld	r28, X+
     776:	dc 91       	ld	r29, X
     778:	12 97       	sbiw	r26, 0x02	; 2
     77a:	ce 17       	cp	r28, r30
     77c:	df 07       	cpc	r29, r31
     77e:	31 f4       	brne	.+12     	; 0x78c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     780:	8c 81       	ldd	r24, Y+4	; 0x04
     782:	9d 81       	ldd	r25, Y+5	; 0x05
     784:	12 96       	adiw	r26, 0x02	; 2
     786:	9c 93       	st	X, r25
     788:	8e 93       	st	-X, r24
     78a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     78c:	11 86       	std	Z+9, r1	; 0x09
     78e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     790:	8c 91       	ld	r24, X
     792:	81 50       	subi	r24, 0x01	; 1
     794:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret

0000079c <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     79c:	1f 92       	push	r1
     79e:	0f 92       	push	r0
     7a0:	0f b6       	in	r0, 0x3f	; 63
     7a2:	0f 92       	push	r0
     7a4:	11 24       	eor	r1, r1
     7a6:	0b b6       	in	r0, 0x3b	; 59
     7a8:	0f 92       	push	r0
     7aa:	2f 93       	push	r18
     7ac:	3f 93       	push	r19
     7ae:	4f 93       	push	r20
     7b0:	5f 93       	push	r21
     7b2:	6f 93       	push	r22
     7b4:	7f 93       	push	r23
     7b6:	8f 93       	push	r24
     7b8:	9f 93       	push	r25
     7ba:	af 93       	push	r26
     7bc:	bf 93       	push	r27
     7be:	ef 93       	push	r30
     7c0:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7c2:	1b 9b       	sbis	0x03, 3	; 3
     7c4:	0d c0       	rjmp	.+26     	; 0x7e0 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7c6:	f9 d2       	rcall	.+1522   	; 0xdba <myTimer_Read>
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	90 93 9c 08 	sts	0x089C, r25
     7ce:	80 93 9b 08 	sts	0x089B, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7d2:	0e 94 06 10 	call	0x200c	; 0x200c <xTaskGetTickCountFromISR>
     7d6:	90 93 98 08 	sts	0x0898, r25
     7da:	80 93 97 08 	sts	0x0897, r24
     7de:	56 c0       	rjmp	.+172    	; 0x88c <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7e0:	1b 99       	sbic	0x03, 3	; 3
     7e2:	54 c0       	rjmp	.+168    	; 0x88c <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7e4:	0e 94 06 10 	call	0x200c	; 0x200c <xTaskGetTickCountFromISR>
     7e8:	90 93 a2 08 	sts	0x08A2, r25
     7ec:	80 93 a1 08 	sts	0x08A1, r24
     7f0:	20 91 97 08 	lds	r18, 0x0897
     7f4:	30 91 98 08 	lds	r19, 0x0898
     7f8:	82 17       	cp	r24, r18
     7fa:	93 07       	cpc	r25, r19
     7fc:	4c f4       	brge	.+18     	; 0x810 <__vector_9+0x74>
			ms_tickEnd += 65535;
     7fe:	80 91 a1 08 	lds	r24, 0x08A1
     802:	90 91 a2 08 	lds	r25, 0x08A2
     806:	01 97       	sbiw	r24, 0x01	; 1
     808:	90 93 a2 08 	sts	0x08A2, r25
     80c:	80 93 a1 08 	sts	0x08A1, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     810:	d4 d2       	rcall	.+1448   	; 0xdba <myTimer_Read>
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	90 93 a4 08 	sts	0x08A4, r25
     818:	80 93 a3 08 	sts	0x08A3, r24
     81c:	20 91 9b 08 	lds	r18, 0x089B
     820:	30 91 9c 08 	lds	r19, 0x089C
     824:	82 17       	cp	r24, r18
     826:	93 07       	cpc	r25, r19
     828:	54 f4       	brge	.+20     	; 0x83e <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     82a:	80 91 a3 08 	lds	r24, 0x08A3
     82e:	90 91 a4 08 	lds	r25, 0x08A4
     832:	86 50       	subi	r24, 0x06	; 6
     834:	9f 4f       	sbci	r25, 0xFF	; 255
     836:	90 93 a4 08 	sts	0x08A4, r25
     83a:	80 93 a3 08 	sts	0x08A3, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     83e:	80 91 a3 08 	lds	r24, 0x08A3
     842:	90 91 a4 08 	lds	r25, 0x08A4
     846:	20 91 9b 08 	lds	r18, 0x089B
     84a:	30 91 9c 08 	lds	r19, 0x089C
     84e:	82 1b       	sub	r24, r18
     850:	93 0b       	sbc	r25, r19
     852:	90 93 9e 08 	sts	0x089E, r25
     856:	80 93 9d 08 	sts	0x089D, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     85a:	80 91 a1 08 	lds	r24, 0x08A1
     85e:	90 91 a2 08 	lds	r25, 0x08A2
     862:	20 91 97 08 	lds	r18, 0x0897
     866:	30 91 98 08 	lds	r19, 0x0898
     86a:	82 1b       	sub	r24, r18
     86c:	93 0b       	sbc	r25, r19
     86e:	90 93 9a 08 	sts	0x089A, r25
     872:	80 93 99 08 	sts	0x0899, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     876:	20 e0       	ldi	r18, 0x00	; 0
     878:	40 e0       	ldi	r20, 0x00	; 0
     87a:	50 e0       	ldi	r21, 0x00	; 0
     87c:	60 e0       	ldi	r22, 0x00	; 0
     87e:	70 e0       	ldi	r23, 0x00	; 0
     880:	80 91 9f 08 	lds	r24, 0x089F
     884:	90 91 a0 08 	lds	r25, 0x08A0
     888:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <xQueueGenericSendFromISR>
	}	
}
     88c:	ff 91       	pop	r31
     88e:	ef 91       	pop	r30
     890:	bf 91       	pop	r27
     892:	af 91       	pop	r26
     894:	9f 91       	pop	r25
     896:	8f 91       	pop	r24
     898:	7f 91       	pop	r23
     89a:	6f 91       	pop	r22
     89c:	5f 91       	pop	r21
     89e:	4f 91       	pop	r20
     8a0:	3f 91       	pop	r19
     8a2:	2f 91       	pop	r18
     8a4:	0f 90       	pop	r0
     8a6:	0b be       	out	0x3b, r0	; 59
     8a8:	0f 90       	pop	r0
     8aa:	0f be       	out	0x3f, r0	; 63
     8ac:	0f 90       	pop	r0
     8ae:	1f 90       	pop	r1
     8b0:	18 95       	reti

000008b2 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8b2:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8b4:	89 e1       	ldi	r24, 0x19	; 25
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	82 d2       	rcall	.+1284   	; 0xdbe <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8ba:	a1 98       	cbi	0x14, 1	; 20
     8bc:	08 95       	ret

000008be <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8be:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro2(25); // delay 25 micro seconds...
     8c0:	89 e1       	ldi	r24, 0x19	; 25
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	a0 d2       	rcall	.+1344   	; 0xe06 <myTimer_DelayMicro2>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8c6:	a0 98       	cbi	0x14, 0	; 20
     8c8:	08 95       	ret

000008ca <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8ca:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8cc:	80 81       	ld	r24, Z
     8ce:	91 81       	ldd	r25, Z+1	; 0x01
     8d0:	22 81       	ldd	r18, Z+2	; 0x02
     8d2:	33 81       	ldd	r19, Z+3	; 0x03
     8d4:	28 17       	cp	r18, r24
     8d6:	39 07       	cpc	r19, r25
     8d8:	54 f4       	brge	.+20     	; 0x8ee <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8da:	44 81       	ldd	r20, Z+4	; 0x04
     8dc:	55 81       	ldd	r21, Z+5	; 0x05
     8de:	42 17       	cp	r20, r18
     8e0:	53 07       	cpc	r21, r19
     8e2:	84 f0       	brlt	.+32     	; 0x904 <myMaxSonar_extractMedian+0x3a>
     8e4:	48 17       	cp	r20, r24
     8e6:	59 07       	cpc	r21, r25
     8e8:	74 f4       	brge	.+28     	; 0x906 <myMaxSonar_extractMedian+0x3c>
     8ea:	ca 01       	movw	r24, r20
     8ec:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8ee:	44 81       	ldd	r20, Z+4	; 0x04
     8f0:	55 81       	ldd	r21, Z+5	; 0x05
     8f2:	48 17       	cp	r20, r24
     8f4:	59 07       	cpc	r21, r25
     8f6:	3c f0       	brlt	.+14     	; 0x906 <myMaxSonar_extractMedian+0x3c>
     8f8:	ca 01       	movw	r24, r20
     8fa:	24 17       	cp	r18, r20
     8fc:	35 07       	cpc	r19, r21
     8fe:	1c f4       	brge	.+6      	; 0x906 <myMaxSonar_extractMedian+0x3c>
     900:	c9 01       	movw	r24, r18
     902:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     904:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     906:	08 95       	ret

00000908 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_RANGE) || currentReading < (prevReading - NOISE_RANGE))
     908:	9b 01       	movw	r18, r22
     90a:	28 5f       	subi	r18, 0xF8	; 248
     90c:	3f 4f       	sbci	r19, 0xFF	; 255
     90e:	28 17       	cp	r18, r24
     910:	39 07       	cpc	r19, r25
     912:	3c f0       	brlt	.+14     	; 0x922 <myMaxSonar_Stabilizer+0x1a>
     914:	20 51       	subi	r18, 0x10	; 16
     916:	31 09       	sbc	r19, r1
     918:	82 17       	cp	r24, r18
     91a:	93 07       	cpc	r25, r19
     91c:	14 f0       	brlt	.+4      	; 0x922 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     91e:	86 2f       	mov	r24, r22
     920:	97 2f       	mov	r25, r23
}
     922:	08 95       	ret

00000924 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     924:	0f 93       	push	r16
     926:	1f 93       	push	r17
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     92e:	00 91 00 02 	lds	r16, 0x0200
     932:	10 e0       	ldi	r17, 0x00	; 0
     934:	f8 01       	movw	r30, r16
     936:	ee 0f       	add	r30, r30
     938:	ff 1f       	adc	r31, r31
     93a:	e6 0f       	add	r30, r22
     93c:	f7 1f       	adc	r31, r23
     93e:	60 81       	ld	r22, Z
     940:	71 81       	ldd	r23, Z+1	; 0x01
     942:	e2 df       	rcall	.-60     	; 0x908 <myMaxSonar_Stabilizer>
     944:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     946:	c8 01       	movw	r24, r16
     948:	01 96       	adiw	r24, 0x01	; 1
     94a:	63 e0       	ldi	r22, 0x03	; 3
     94c:	70 e0       	ldi	r23, 0x00	; 0
     94e:	0e 94 29 17 	call	0x2e52	; 0x2e52 <__divmodhi4>
     952:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     956:	88 0f       	add	r24, r24
     958:	99 1f       	adc	r25, r25
     95a:	c8 0f       	add	r28, r24
     95c:	d9 1f       	adc	r29, r25
     95e:	39 83       	std	Y+1, r19	; 0x01
     960:	28 83       	st	Y, r18
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	08 95       	ret

0000096c <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     972:	d8 df       	rcall	.-80     	; 0x924 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     974:	ce 01       	movw	r24, r28
     976:	a9 df       	rcall	.-174    	; 0x8ca <myMaxSonar_extractMedian>

}
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     97e:	b3 d0       	rcall	.+358    	; 0xae6 <myADC_analogRead>
     980:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     982:	63 e0       	ldi	r22, 0x03	; 3
     984:	70 e0       	ldi	r23, 0x00	; 0
     986:	0e 94 29 17 	call	0x2e52	; 0x2e52 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     98a:	26 0f       	add	r18, r22
     98c:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     98e:	29 3e       	cpi	r18, 0xE9	; 233
     990:	83 e0       	ldi	r24, 0x03	; 3
     992:	38 07       	cpc	r19, r24
     994:	1c f0       	brlt	.+6      	; 0x99c <myMaxSonar_Read+0x1e>
		return 999;
     996:	87 ee       	ldi	r24, 0xE7	; 231
     998:	93 e0       	ldi	r25, 0x03	; 3
     99a:	08 95       	ret
	
	return reading;
     99c:	82 2f       	mov	r24, r18
     99e:	93 2f       	mov	r25, r19
}
     9a0:	08 95       	ret

000009a2 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9a2:	1f 92       	push	r1
     9a4:	0f 92       	push	r0
     9a6:	0f b6       	in	r0, 0x3f	; 63
     9a8:	0f 92       	push	r0
     9aa:	11 24       	eor	r1, r1
     9ac:	0b b6       	in	r0, 0x3b	; 59
     9ae:	0f 92       	push	r0
     9b0:	2f 93       	push	r18
     9b2:	3f 93       	push	r19
     9b4:	4f 93       	push	r20
     9b6:	5f 93       	push	r21
     9b8:	6f 93       	push	r22
     9ba:	7f 93       	push	r23
     9bc:	8f 93       	push	r24
     9be:	9f 93       	push	r25
     9c0:	af 93       	push	r26
     9c2:	bf 93       	push	r27
     9c4:	ef 93       	push	r30
     9c6:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9c8:	80 91 78 00 	lds	r24, 0x0078
     9cc:	80 93 a5 08 	sts	0x08A5, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9d0:	80 91 79 00 	lds	r24, 0x0079
     9d4:	80 93 a6 08 	sts	0x08A6, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9d8:	20 e0       	ldi	r18, 0x00	; 0
     9da:	40 e0       	ldi	r20, 0x00	; 0
     9dc:	50 e0       	ldi	r21, 0x00	; 0
     9de:	60 e0       	ldi	r22, 0x00	; 0
     9e0:	70 e0       	ldi	r23, 0x00	; 0
     9e2:	80 91 a9 08 	lds	r24, 0x08A9
     9e6:	90 91 aa 08 	lds	r25, 0x08AA
     9ea:	f5 d7       	rcall	.+4074   	; 0x19d6 <xQueueGenericSendFromISR>
}
     9ec:	ff 91       	pop	r31
     9ee:	ef 91       	pop	r30
     9f0:	bf 91       	pop	r27
     9f2:	af 91       	pop	r26
     9f4:	9f 91       	pop	r25
     9f6:	8f 91       	pop	r24
     9f8:	7f 91       	pop	r23
     9fa:	6f 91       	pop	r22
     9fc:	5f 91       	pop	r21
     9fe:	4f 91       	pop	r20
     a00:	3f 91       	pop	r19
     a02:	2f 91       	pop	r18
     a04:	0f 90       	pop	r0
     a06:	0b be       	out	0x3b, r0	; 59
     a08:	0f 90       	pop	r0
     a0a:	0f be       	out	0x3f, r0	; 63
     a0c:	0f 90       	pop	r0
     a0e:	1f 90       	pop	r1
     a10:	18 95       	reti

00000a12 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a12:	8f e8       	ldi	r24, 0x8F	; 143
     a14:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a18:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a1c:	80 e4       	ldi	r24, 0x40	; 64
     a1e:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a22:	43 e0       	ldi	r20, 0x03	; 3
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	eb d6       	rcall	.+3542   	; 0x1800 <xQueueGenericCreate>
     a2a:	90 93 aa 08 	sts	0x08AA, r25
     a2e:	80 93 a9 08 	sts	0x08A9, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a32:	81 e0       	ldi	r24, 0x01	; 1
     a34:	a5 d7       	rcall	.+3914   	; 0x1980 <xQueueCreateMutex>
     a36:	90 93 a8 08 	sts	0x08A8, r25
     a3a:	80 93 a7 08 	sts	0x08A7, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	40 e0       	ldi	r20, 0x00	; 0
     a42:	50 e0       	ldi	r21, 0x00	; 0
     a44:	60 e0       	ldi	r22, 0x00	; 0
     a46:	70 e0       	ldi	r23, 0x00	; 0
     a48:	08 c7       	rjmp	.+3600   	; 0x185a <xQueueGenericSend>
     a4a:	08 95       	ret

00000a4c <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a4c:	cf 93       	push	r28
     a4e:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	4f ef       	ldi	r20, 0xFF	; 255
     a54:	5f ef       	ldi	r21, 0xFF	; 255
     a56:	60 e0       	ldi	r22, 0x00	; 0
     a58:	70 e0       	ldi	r23, 0x00	; 0
     a5a:	80 91 a7 08 	lds	r24, 0x08A7
     a5e:	90 91 a8 08 	lds	r25, 0x08A8
     a62:	f3 d7       	rcall	.+4070   	; 0x1a4a <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a64:	ec e7       	ldi	r30, 0x7C	; 124
     a66:	f0 e0       	ldi	r31, 0x00	; 0
     a68:	80 81       	ld	r24, Z
     a6a:	9c 2f       	mov	r25, r28
     a6c:	9f 71       	andi	r25, 0x1F	; 31
     a6e:	80 76       	andi	r24, 0x60	; 96
     a70:	89 2b       	or	r24, r25
     a72:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a74:	eb e7       	ldi	r30, 0x7B	; 123
     a76:	f0 e0       	ldi	r31, 0x00	; 0
     a78:	20 81       	ld	r18, Z
     a7a:	c0 72       	andi	r28, 0x20	; 32
     a7c:	8c 2f       	mov	r24, r28
     a7e:	90 e0       	ldi	r25, 0x00	; 0
     a80:	95 95       	asr	r25
     a82:	87 95       	ror	r24
     a84:	95 95       	asr	r25
     a86:	87 95       	ror	r24
     a88:	92 2f       	mov	r25, r18
     a8a:	90 76       	andi	r25, 0x60	; 96
     a8c:	89 2b       	or	r24, r25
     a8e:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a90:	ea e7       	ldi	r30, 0x7A	; 122
     a92:	f0 e0       	ldi	r31, 0x00	; 0
     a94:	80 81       	ld	r24, Z
     a96:	80 64       	ori	r24, 0x40	; 64
     a98:	80 83       	st	Z, r24
}
     a9a:	cf 91       	pop	r28
     a9c:	08 95       	ret

00000a9e <myADC_readADC>:

int myADC_readADC(char channel)
{
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     aa2:	20 e0       	ldi	r18, 0x00	; 0
     aa4:	4f ef       	ldi	r20, 0xFF	; 255
     aa6:	5f ef       	ldi	r21, 0xFF	; 255
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	80 91 a9 08 	lds	r24, 0x08A9
     ab0:	90 91 aa 08 	lds	r25, 0x08AA
     ab4:	ca d7       	rcall	.+3988   	; 0x1a4a <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     ab6:	c0 91 a6 08 	lds	r28, 0x08A6
     aba:	c3 70       	andi	r28, 0x03	; 3
     abc:	d0 e0       	ldi	r29, 0x00	; 0
     abe:	dc 2f       	mov	r29, r28
     ac0:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ac2:	80 91 a5 08 	lds	r24, 0x08A5
     ac6:	c8 0f       	add	r28, r24
     ac8:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     aca:	20 e0       	ldi	r18, 0x00	; 0
     acc:	40 e0       	ldi	r20, 0x00	; 0
     ace:	50 e0       	ldi	r21, 0x00	; 0
     ad0:	60 e0       	ldi	r22, 0x00	; 0
     ad2:	70 e0       	ldi	r23, 0x00	; 0
     ad4:	80 91 a7 08 	lds	r24, 0x08A7
     ad8:	90 91 a8 08 	lds	r25, 0x08A8
     adc:	be d6       	rcall	.+3452   	; 0x185a <xQueueGenericSend>
	
	return adcReading;
     ade:	ce 01       	movw	r24, r28
     ae0:	df 91       	pop	r29
     ae2:	cf 91       	pop	r28
     ae4:	08 95       	ret

00000ae6 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     ae6:	cf 93       	push	r28
     ae8:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     aea:	b0 df       	rcall	.-160    	; 0xa4c <myADC_startADC>
	return myADC_readADC(channel);
     aec:	8c 2f       	mov	r24, r28
     aee:	d7 df       	rcall	.-82     	; 0xa9e <myADC_readADC>
}
     af0:	cf 91       	pop	r28
     af2:	08 95       	ret

00000af4 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     af4:	9c 01       	movw	r18, r24
     af6:	29 5f       	subi	r18, 0xF9	; 249
     af8:	3f 4f       	sbci	r19, 0xFF	; 255
     afa:	26 17       	cp	r18, r22
     afc:	37 07       	cpc	r19, r23
     afe:	44 f0       	brlt	.+16     	; 0xb10 <detectStairs+0x1c>
     b00:	2e 50       	subi	r18, 0x0E	; 14
     b02:	31 09       	sbc	r19, r1
     b04:	81 e0       	ldi	r24, 0x01	; 1
     b06:	62 17       	cp	r22, r18
     b08:	73 07       	cpc	r23, r19
     b0a:	1c f0       	brlt	.+6      	; 0xb12 <detectStairs+0x1e>
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	08 95       	ret
	{
		return 1; // stairs found
     b10:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b12:	08 95       	ret

00000b14 <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b14:	0f 93       	push	r16
     b16:	1f 93       	push	r17
     b18:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     b1a:	83 81       	ldd	r24, Z+3	; 0x03
     b1c:	88 23       	and	r24, r24
     b1e:	39 f0       	breq	.+14     	; 0xb2e <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b20:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b22:	e2 e0       	ldi	r30, 0x02	; 2
     b24:	f1 e0       	ldi	r31, 0x01	; 1
     b26:	80 81       	ld	r24, Z
     b28:	80 61       	ori	r24, 0x10	; 16
     b2a:	80 83       	st	Z, r24
     b2c:	57 c0       	rjmp	.+174    	; 0xbdc <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b2e:	80 81       	ld	r24, Z
     b30:	88 23       	and	r24, r24
     b32:	b1 f1       	breq	.+108    	; 0xba0 <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b34:	81 81       	ldd	r24, Z+1	; 0x01
     b36:	81 11       	cpse	r24, r1
     b38:	18 c0       	rjmp	.+48     	; 0xb6a <obstacleAvoidance+0x56>
     b3a:	82 81       	ldd	r24, Z+2	; 0x02
     b3c:	81 11       	cpse	r24, r1
     b3e:	24 c0       	rjmp	.+72     	; 0xb88 <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar - 20) // if right sonar greater than....
     b40:	cb 01       	movw	r24, r22
     b42:	44 97       	sbiw	r24, 0x14	; 20
     b44:	84 17       	cp	r24, r20
     b46:	95 07       	cpc	r25, r21
     b48:	3c f4       	brge	.+14     	; 0xb58 <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b4a:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b4c:	a2 e0       	ldi	r26, 0x02	; 2
     b4e:	b1 e0       	ldi	r27, 0x01	; 1
     b50:	8c 91       	ld	r24, X
     b52:	80 61       	ori	r24, 0x10	; 16
     b54:	8c 93       	st	X, r24
     b56:	06 c0       	rjmp	.+12     	; 0xb64 <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b58:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b5a:	a2 e0       	ldi	r26, 0x02	; 2
     b5c:	b1 e0       	ldi	r27, 0x01	; 1
     b5e:	8c 91       	ld	r24, X
     b60:	8f 7e       	andi	r24, 0xEF	; 239
     b62:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b64:	81 81       	ldd	r24, Z+1	; 0x01
     b66:	88 23       	and	r24, r24
     b68:	b1 f1       	breq	.+108    	; 0xbd6 <obstacleAvoidance+0xc2>
     b6a:	82 81       	ldd	r24, Z+2	; 0x02
     b6c:	81 11       	cpse	r24, r1
     b6e:	36 c0       	rjmp	.+108    	; 0xbdc <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b70:	46 1b       	sub	r20, r22
     b72:	57 0b       	sbc	r21, r23
     b74:	45 30       	cpi	r20, 0x05	; 5
     b76:	51 05       	cpc	r21, r1
     b78:	8c f1       	brlt	.+98     	; 0xbdc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     b7a:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     b7c:	e2 e0       	ldi	r30, 0x02	; 2
     b7e:	f1 e0       	ldi	r31, 0x01	; 1
     b80:	80 81       	ld	r24, Z
     b82:	80 61       	ori	r24, 0x10	; 16
     b84:	80 83       	st	Z, r24
     b86:	2a c0       	rjmp	.+84     	; 0xbdc <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     b88:	64 1b       	sub	r22, r20
     b8a:	75 0b       	sbc	r23, r21
     b8c:	65 30       	cpi	r22, 0x05	; 5
     b8e:	71 05       	cpc	r23, r1
     b90:	2c f1       	brlt	.+74     	; 0xbdc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     b92:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     b94:	e2 e0       	ldi	r30, 0x02	; 2
     b96:	f1 e0       	ldi	r31, 0x01	; 1
     b98:	80 81       	ld	r24, Z
     b9a:	8f 7e       	andi	r24, 0xEF	; 239
     b9c:	80 83       	st	Z, r24
     b9e:	1e c0       	rjmp	.+60     	; 0xbdc <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     ba0:	63 32       	cpi	r22, 0x23	; 35
     ba2:	71 05       	cpc	r23, r1
     ba4:	3c f4       	brge	.+14     	; 0xbb4 <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     ba6:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     ba8:	e2 e0       	ldi	r30, 0x02	; 2
     baa:	f1 e0       	ldi	r31, 0x01	; 1
     bac:	80 81       	ld	r24, Z
     bae:	80 61       	ori	r24, 0x10	; 16
     bb0:	80 83       	st	Z, r24
     bb2:	14 c0       	rjmp	.+40     	; 0xbdc <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     bb4:	44 31       	cpi	r20, 0x14	; 20
     bb6:	51 05       	cpc	r21, r1
     bb8:	3c f4       	brge	.+14     	; 0xbc8 <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     bba:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bbc:	e2 e0       	ldi	r30, 0x02	; 2
     bbe:	f1 e0       	ldi	r31, 0x01	; 1
     bc0:	80 81       	ld	r24, Z
     bc2:	8f 7e       	andi	r24, 0xEF	; 239
     bc4:	80 83       	st	Z, r24
     bc6:	0a c0       	rjmp	.+20     	; 0xbdc <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     bc8:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bca:	e2 e0       	ldi	r30, 0x02	; 2
     bcc:	f1 e0       	ldi	r31, 0x01	; 1
     bce:	80 81       	ld	r24, Z
     bd0:	8f 7e       	andi	r24, 0xEF	; 239
     bd2:	80 83       	st	Z, r24
     bd4:	03 c0       	rjmp	.+6      	; 0xbdc <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     bd6:	82 81       	ldd	r24, Z+2	; 0x02
     bd8:	81 11       	cpse	r24, r1
     bda:	d6 cf       	rjmp	.-84     	; 0xb88 <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     bdc:	1f 91       	pop	r17
     bde:	0f 91       	pop	r16
     be0:	08 95       	ret

00000be2 <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     be2:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     be4:	85 e0       	ldi	r24, 0x05	; 5
     be6:	db 01       	movw	r26, r22
     be8:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     bea:	86 e4       	ldi	r24, 0x46	; 70
     bec:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     bee:	8c e4       	ldi	r24, 0x4C	; 76
     bf0:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     bf2:	82 e5       	ldi	r24, 0x52	; 82
     bf4:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     bf6:	82 e4       	ldi	r24, 0x42	; 66
     bf8:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     bfa:	84 e5       	ldi	r24, 0x54	; 84
     bfc:	84 83       	std	Z+4, r24	; 0x04
     bfe:	08 95       	ret

00000c00 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c00:	9f 92       	push	r9
     c02:	af 92       	push	r10
     c04:	bf 92       	push	r11
     c06:	cf 92       	push	r12
     c08:	df 92       	push	r13
     c0a:	ef 92       	push	r14
     c0c:	ff 92       	push	r15
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
     c12:	cf 93       	push	r28
     c14:	df 93       	push	r29
     c16:	96 2e       	mov	r9, r22
     c18:	ea 01       	movw	r28, r20
     c1a:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c1c:	c2 97       	sbiw	r24, 0x32	; 50
     c1e:	1c f4       	brge	.+6      	; 0xc26 <obstacleDetection+0x26>
	{
		obstacleDetected ++;
     c20:	93 94       	inc	r9
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c22:	86 e4       	ldi	r24, 0x46	; 70
     c24:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c26:	23 32       	cpi	r18, 0x23	; 35
     c28:	31 05       	cpc	r19, r1
     c2a:	1c f4       	brge	.+6      	; 0xc32 <obstacleDetection+0x32>
	{
		obstacleDetected ++;
     c2c:	93 94       	inc	r9
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c2e:	8c e4       	ldi	r24, 0x4C	; 76
     c30:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c32:	0e 31       	cpi	r16, 0x1E	; 30
     c34:	11 05       	cpc	r17, r1
     c36:	1c f4       	brge	.+6      	; 0xc3e <obstacleDetection+0x3e>
	{
		obstacleDetected++;
     c38:	93 94       	inc	r9
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c3a:	82 e5       	ldi	r24, 0x52	; 82
     c3c:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c3e:	c6 01       	movw	r24, r12
     c40:	59 df       	rcall	.-334    	; 0xaf4 <detectStairs>
     c42:	88 23       	and	r24, r24
     c44:	19 f0       	breq	.+6      	; 0xc4c <obstacleDetection+0x4c>
	{
		obstacleDetected++;
     c46:	93 94       	inc	r9
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c48:	82 e4       	ldi	r24, 0x42	; 66
     c4a:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     c4c:	87 e3       	ldi	r24, 0x37	; 55
     c4e:	e8 16       	cp	r14, r24
     c50:	f1 04       	cpc	r15, r1
     c52:	1c f4       	brge	.+6      	; 0xc5a <obstacleDetection+0x5a>
	{
		obstacleDetected++;
     c54:	93 94       	inc	r9
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     c56:	84 e5       	ldi	r24, 0x54	; 84
     c58:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     c5a:	89 2d       	mov	r24, r9
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	1f 91       	pop	r17
     c62:	0f 91       	pop	r16
     c64:	ff 90       	pop	r15
     c66:	ef 90       	pop	r14
     c68:	df 90       	pop	r13
     c6a:	cf 90       	pop	r12
     c6c:	bf 90       	pop	r11
     c6e:	af 90       	pop	r10
     c70:	9f 90       	pop	r9
     c72:	08 95       	ret

00000c74 <mySharpIR_Read>:
#include <stdint.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c74:	38 df       	rcall	.-400    	; 0xae6 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c76:	bc 01       	movw	r22, r24
     c78:	88 27       	eor	r24, r24
     c7a:	77 fd       	sbrc	r23, 7
     c7c:	80 95       	com	r24
     c7e:	98 2f       	mov	r25, r24
     c80:	0e 94 6d 14 	call	0x28da	; 0x28da <__floatsisf>
     c84:	29 e2       	ldi	r18, 0x29	; 41
     c86:	3c e5       	ldi	r19, 0x5C	; 92
     c88:	4f e6       	ldi	r20, 0x6F	; 111
     c8a:	5f eb       	ldi	r21, 0xBF	; 191
     c8c:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <pow>
     c90:	22 e5       	ldi	r18, 0x52	; 82
     c92:	38 e6       	ldi	r19, 0x68	; 104
     c94:	46 e2       	ldi	r20, 0x26	; 38
     c96:	56 e4       	ldi	r21, 0x46	; 70
     c98:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <__mulsf3>
     c9c:	20 e0       	ldi	r18, 0x00	; 0
     c9e:	30 e0       	ldi	r19, 0x00	; 0
     ca0:	40 e2       	ldi	r20, 0x20	; 32
     ca2:	51 e4       	ldi	r21, 0x41	; 65
     ca4:	0e 94 d5 13 	call	0x27aa	; 0x27aa <__subsf3>
     ca8:	0e 94 3a 14 	call	0x2874	; 0x2874 <__fixsfsi>
     cac:	cb 01       	movw	r24, r22
     cae:	68 3e       	cpi	r22, 0xE8	; 232
     cb0:	23 e0       	ldi	r18, 0x03	; 3
     cb2:	72 07       	cpc	r23, r18
     cb4:	14 f0       	brlt	.+4      	; 0xcba <mySharpIR_Read+0x46>
     cb6:	87 ee       	ldi	r24, 0xE7	; 231
     cb8:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     cba:	08 95       	ret

00000cbc <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     cbc:	fb 01       	movw	r30, r22
     cbe:	20 81       	ld	r18, Z
     cc0:	31 81       	ldd	r19, Z+1	; 0x01
     cc2:	50 e0       	ldi	r21, 0x00	; 0
     cc4:	b9 01       	movw	r22, r18
     cc6:	64 0f       	add	r22, r20
     cc8:	75 1f       	adc	r23, r21
     cca:	68 17       	cp	r22, r24
     ccc:	79 07       	cpc	r23, r25
     cce:	4c f0       	brlt	.+18     	; 0xce2 <checkWithinRange+0x26>
     cd0:	24 1b       	sub	r18, r20
     cd2:	35 0b       	sbc	r19, r21
     cd4:	41 e0       	ldi	r20, 0x01	; 1
     cd6:	82 17       	cp	r24, r18
     cd8:	93 07       	cpc	r25, r19
     cda:	0c f0       	brlt	.+2      	; 0xcde <checkWithinRange+0x22>
     cdc:	40 e0       	ldi	r20, 0x00	; 0
     cde:	84 2f       	mov	r24, r20
     ce0:	08 95       	ret
     ce2:	81 e0       	ldi	r24, 0x01	; 1
}
     ce4:	08 95       	ret

00000ce6 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     ce6:	0f 93       	push	r16
     ce8:	1f 93       	push	r17
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
     cee:	8c 01       	movw	r16, r24
     cf0:	eb 01       	movw	r28, r22
	static uint8_t i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     cf2:	45 e0       	ldi	r20, 0x05	; 5
     cf4:	bc 01       	movw	r22, r24
     cf6:	ce 01       	movw	r24, r28
     cf8:	e1 df       	rcall	.-62     	; 0xcbc <checkWithinRange>
     cfa:	88 23       	and	r24, r24
     cfc:	29 f0       	breq	.+10     	; 0xd08 <mySharpIR_ReCalibrate+0x22>
     cfe:	80 91 1d 08 	lds	r24, 0x081D
     d02:	81 11       	cpse	r24, r1
     d04:	0a c0       	rjmp	.+20     	; 0xd1a <mySharpIR_ReCalibrate+0x34>
     d06:	3a c0       	rjmp	.+116    	; 0xd7c <mySharpIR_ReCalibrate+0x96>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     d08:	80 91 1d 08 	lds	r24, 0x081D
     d0c:	81 11       	cpse	r24, r1
     d0e:	05 c0       	rjmp	.+10     	; 0xd1a <mySharpIR_ReCalibrate+0x34>
	{
		checkReading[0] = reading;
     d10:	d0 93 1a 08 	sts	0x081A, r29
     d14:	c0 93 19 08 	sts	0x0819, r28
     d18:	2c c0       	rjmp	.+88     	; 0xd72 <mySharpIR_ReCalibrate+0x8c>
	}
	else if (i == CALIBRATE_COUNT/2)
     d1a:	84 36       	cpi	r24, 0x64	; 100
     d1c:	99 f4       	brne	.+38     	; 0xd44 <mySharpIR_ReCalibrate+0x5e>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d1e:	45 e0       	ldi	r20, 0x05	; 5
     d20:	69 e1       	ldi	r22, 0x19	; 25
     d22:	78 e0       	ldi	r23, 0x08	; 8
     d24:	ce 01       	movw	r24, r28
     d26:	ca df       	rcall	.-108    	; 0xcbc <checkWithinRange>
     d28:	88 23       	and	r24, r24
     d2a:	39 f0       	breq	.+14     	; 0xd3a <mySharpIR_ReCalibrate+0x54>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d2c:	d0 93 1a 08 	sts	0x081A, r29
     d30:	c0 93 19 08 	sts	0x0819, r28
			i = 0; // reset to count...
     d34:	10 92 1d 08 	sts	0x081D, r1
     d38:	1c c0       	rjmp	.+56     	; 0xd72 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d3a:	d0 93 1c 08 	sts	0x081C, r29
     d3e:	c0 93 1b 08 	sts	0x081B, r28
     d42:	17 c0       	rjmp	.+46     	; 0xd72 <mySharpIR_ReCalibrate+0x8c>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d44:	88 3c       	cpi	r24, 0xC8	; 200
     d46:	a9 f4       	brne	.+42     	; 0xd72 <mySharpIR_ReCalibrate+0x8c>
	{
		i = 0; // reset to count..
     d48:	10 92 1d 08 	sts	0x081D, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d4c:	45 e0       	ldi	r20, 0x05	; 5
     d4e:	69 e1       	ldi	r22, 0x19	; 25
     d50:	78 e0       	ldi	r23, 0x08	; 8
     d52:	ce 01       	movw	r24, r28
     d54:	b3 df       	rcall	.-154    	; 0xcbc <checkWithinRange>
     d56:	88 23       	and	r24, r24
     d58:	29 f0       	breq	.+10     	; 0xd64 <mySharpIR_ReCalibrate+0x7e>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d5a:	d0 93 1a 08 	sts	0x081A, r29
     d5e:	c0 93 19 08 	sts	0x0819, r28
     d62:	07 c0       	rjmp	.+14     	; 0xd72 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     d64:	80 91 19 08 	lds	r24, 0x0819
     d68:	90 91 1a 08 	lds	r25, 0x081A
     d6c:	f8 01       	movw	r30, r16
     d6e:	91 83       	std	Z+1, r25	; 0x01
     d70:	80 83       	st	Z, r24
		}
	}
	
	i++;
     d72:	80 91 1d 08 	lds	r24, 0x081D
     d76:	8f 5f       	subi	r24, 0xFF	; 255
     d78:	80 93 1d 08 	sts	0x081D, r24
}
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	1f 91       	pop	r17
     d82:	0f 91       	pop	r16
     d84:	08 95       	ret

00000d86 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     d86:	90 93 b0 08 	sts	0x08B0, r25
     d8a:	80 93 af 08 	sts	0x08AF, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     d8e:	fc 01       	movw	r30, r24
     d90:	80 81       	ld	r24, Z
     d92:	91 81       	ldd	r25, Z+1	; 0x01
     d94:	0e 94 1f 12 	call	0x243e	; 0x243e <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     d98:	43 e0       	ldi	r20, 0x03	; 3
     d9a:	60 e0       	ldi	r22, 0x00	; 0
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	30 d5       	rcall	.+2656   	; 0x1800 <xQueueGenericCreate>
     da0:	90 93 ac 08 	sts	0x08AC, r25
     da4:	80 93 ab 08 	sts	0x08AB, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     da8:	43 e0       	ldi	r20, 0x03	; 3
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	81 e0       	ldi	r24, 0x01	; 1
     dae:	28 d5       	rcall	.+2640   	; 0x1800 <xQueueGenericCreate>
     db0:	90 93 ae 08 	sts	0x08AE, r25
     db4:	80 93 ad 08 	sts	0x08AD, r24
     db8:	08 95       	ret

00000dba <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     dba:	86 b5       	in	r24, 0x26	; 38
}
     dbc:	08 95       	ret

00000dbe <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     dbe:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     dc0:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     dc2:	9c 01       	movw	r18, r24
     dc4:	99 23       	and	r25, r25
     dc6:	14 f4       	brge	.+4      	; 0xdcc <myTimer_DelayMicro+0xe>
     dc8:	2d 5f       	subi	r18, 0xFD	; 253
     dca:	3f 4f       	sbci	r19, 0xFF	; 255
     dcc:	35 95       	asr	r19
     dce:	27 95       	ror	r18
     dd0:	35 95       	asr	r19
     dd2:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     dd4:	24 0f       	add	r18, r20
     dd6:	35 1f       	adc	r19, r21
     dd8:	30 93 04 02 	sts	0x0204, r19
     ddc:	20 93 03 02 	sts	0x0203, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     de0:	e0 91 af 08 	lds	r30, 0x08AF
     de4:	f0 91 b0 08 	lds	r31, 0x08B0
     de8:	80 81       	ld	r24, Z
     dea:	91 81       	ldd	r25, Z+1	; 0x01
     dec:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     df0:	20 e0       	ldi	r18, 0x00	; 0
     df2:	42 e0       	ldi	r20, 0x02	; 2
     df4:	50 e0       	ldi	r21, 0x00	; 0
     df6:	60 e0       	ldi	r22, 0x00	; 0
     df8:	70 e0       	ldi	r23, 0x00	; 0
     dfa:	80 91 ab 08 	lds	r24, 0x08AB
     dfe:	90 91 ac 08 	lds	r25, 0x08AC
     e02:	23 c6       	rjmp	.+3142   	; 0x1a4a <xQueueGenericReceive>
     e04:	08 95       	ret

00000e06 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e06:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     e08:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e0a:	9c 01       	movw	r18, r24
     e0c:	99 23       	and	r25, r25
     e0e:	14 f4       	brge	.+4      	; 0xe14 <myTimer_DelayMicro2+0xe>
     e10:	2d 5f       	subi	r18, 0xFD	; 253
     e12:	3f 4f       	sbci	r19, 0xFF	; 255
     e14:	35 95       	asr	r19
     e16:	27 95       	ror	r18
     e18:	35 95       	asr	r19
     e1a:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     e1c:	24 0f       	add	r18, r20
     e1e:	35 1f       	adc	r19, r21
     e20:	30 93 02 02 	sts	0x0202, r19
     e24:	20 93 01 02 	sts	0x0201, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e28:	e0 91 af 08 	lds	r30, 0x08AF
     e2c:	f0 91 b0 08 	lds	r31, 0x08B0
     e30:	80 81       	ld	r24, Z
     e32:	91 81       	ldd	r25, Z+1	; 0x01
     e34:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e38:	20 e0       	ldi	r18, 0x00	; 0
     e3a:	42 e0       	ldi	r20, 0x02	; 2
     e3c:	50 e0       	ldi	r21, 0x00	; 0
     e3e:	60 e0       	ldi	r22, 0x00	; 0
     e40:	70 e0       	ldi	r23, 0x00	; 0
     e42:	80 91 ad 08 	lds	r24, 0x08AD
     e46:	90 91 ae 08 	lds	r25, 0x08AE
     e4a:	ff c5       	rjmp	.+3070   	; 0x1a4a <xQueueGenericReceive>
     e4c:	08 95       	ret

00000e4e <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e4e:	cf 93       	push	r28
     e50:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e52:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e54:	c1 11       	cpse	r28, r1
     e56:	22 c0       	rjmp	.+68     	; 0xe9c <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e58:	80 91 03 02 	lds	r24, 0x0203
     e5c:	90 91 04 02 	lds	r25, 0x0204
     e60:	88 38       	cpi	r24, 0x88	; 136
     e62:	93 41       	sbci	r25, 0x13	; 19
     e64:	51 f0       	breq	.+20     	; 0xe7a <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e66:	80 91 03 02 	lds	r24, 0x0203
     e6a:	90 91 04 02 	lds	r25, 0x0204
     e6e:	8a 5f       	subi	r24, 0xFA	; 250
     e70:	91 09       	sbc	r25, r1
     e72:	90 93 04 02 	sts	0x0204, r25
     e76:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e7a:	80 91 01 02 	lds	r24, 0x0201
     e7e:	90 91 02 02 	lds	r25, 0x0202
     e82:	88 38       	cpi	r24, 0x88	; 136
     e84:	93 41       	sbci	r25, 0x13	; 19
     e86:	51 f0       	breq	.+20     	; 0xe9c <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e88:	80 91 01 02 	lds	r24, 0x0201
     e8c:	90 91 02 02 	lds	r25, 0x0202
     e90:	8a 5f       	subi	r24, 0xFA	; 250
     e92:	91 09       	sbc	r25, r1
     e94:	90 93 02 02 	sts	0x0202, r25
     e98:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e9c:	d0 e0       	ldi	r29, 0x00	; 0
     e9e:	80 91 03 02 	lds	r24, 0x0203
     ea2:	90 91 04 02 	lds	r25, 0x0204
     ea6:	8c 17       	cp	r24, r28
     ea8:	9d 07       	cpc	r25, r29
     eaa:	84 f4       	brge	.+32     	; 0xecc <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     eac:	88 e8       	ldi	r24, 0x88	; 136
     eae:	93 e1       	ldi	r25, 0x13	; 19
     eb0:	90 93 04 02 	sts	0x0204, r25
     eb4:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	40 e0       	ldi	r20, 0x00	; 0
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	60 e0       	ldi	r22, 0x00	; 0
     ec0:	70 e0       	ldi	r23, 0x00	; 0
     ec2:	80 91 ab 08 	lds	r24, 0x08AB
     ec6:	90 91 ac 08 	lds	r25, 0x08AC
     eca:	c7 d4       	rcall	.+2446   	; 0x185a <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     ecc:	80 91 01 02 	lds	r24, 0x0201
     ed0:	90 91 02 02 	lds	r25, 0x0202
     ed4:	8c 17       	cp	r24, r28
     ed6:	9d 07       	cpc	r25, r29
     ed8:	84 f4       	brge	.+32     	; 0xefa <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     eda:	88 e8       	ldi	r24, 0x88	; 136
     edc:	93 e1       	ldi	r25, 0x13	; 19
     ede:	90 93 02 02 	sts	0x0202, r25
     ee2:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     ee6:	20 e0       	ldi	r18, 0x00	; 0
     ee8:	40 e0       	ldi	r20, 0x00	; 0
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	60 e0       	ldi	r22, 0x00	; 0
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	80 91 ad 08 	lds	r24, 0x08AD
     ef4:	90 91 ae 08 	lds	r25, 0x08AE
     ef8:	b0 d4       	rcall	.+2400   	; 0x185a <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     efa:	80 91 03 02 	lds	r24, 0x0203
     efe:	90 91 04 02 	lds	r25, 0x0204
     f02:	88 38       	cpi	r24, 0x88	; 136
     f04:	93 41       	sbci	r25, 0x13	; 19
     f06:	79 f4       	brne	.+30     	; 0xf26 <myTimer_DelayChecker+0xd8>
     f08:	80 91 01 02 	lds	r24, 0x0201
     f0c:	90 91 02 02 	lds	r25, 0x0202
     f10:	88 38       	cpi	r24, 0x88	; 136
     f12:	93 41       	sbci	r25, 0x13	; 19
     f14:	41 f4       	brne	.+16     	; 0xf26 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f16:	e0 91 af 08 	lds	r30, 0x08AF
     f1a:	f0 91 b0 08 	lds	r31, 0x08B0
     f1e:	80 81       	ld	r24, Z
     f20:	91 81       	ldd	r25, Z+1	; 0x01
     f22:	0e 94 1f 12 	call	0x243e	; 0x243e <vTaskSuspend>
	}
     f26:	df 91       	pop	r29
     f28:	cf 91       	pop	r28
     f2a:	08 95       	ret

00000f2c <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     f2c:	1f 92       	push	r1
     f2e:	0f 92       	push	r0
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	0f 92       	push	r0
     f34:	11 24       	eor	r1, r1
     f36:	0b b6       	in	r0, 0x3b	; 59
     f38:	0f 92       	push	r0
     f3a:	2f 93       	push	r18
     f3c:	3f 93       	push	r19
     f3e:	4f 93       	push	r20
     f40:	5f 93       	push	r21
     f42:	6f 93       	push	r22
     f44:	7f 93       	push	r23
     f46:	8f 93       	push	r24
     f48:	9f 93       	push	r25
     f4a:	af 93       	push	r26
     f4c:	bf 93       	push	r27
     f4e:	ef 93       	push	r30
     f50:	ff 93       	push	r31
     f52:	60 91 ce 00 	lds	r22, 0x00CE
     f56:	80 e4       	ldi	r24, 0x40	; 64
     f58:	99 e0       	ldi	r25, 0x09	; 9
     f5a:	43 d6       	rcall	.+3206   	; 0x1be2 <ringBufferPush>
     f5c:	20 e0       	ldi	r18, 0x00	; 0
     f5e:	40 e0       	ldi	r20, 0x00	; 0
     f60:	50 e0       	ldi	r21, 0x00	; 0
     f62:	60 e0       	ldi	r22, 0x00	; 0
     f64:	70 e0       	ldi	r23, 0x00	; 0
     f66:	80 91 26 08 	lds	r24, 0x0826
     f6a:	90 91 27 08 	lds	r25, 0x0827
     f6e:	33 d5       	rcall	.+2662   	; 0x19d6 <xQueueGenericSendFromISR>
     f70:	80 e4       	ldi	r24, 0x40	; 64
     f72:	99 e0       	ldi	r25, 0x09	; 9
     f74:	4d d6       	rcall	.+3226   	; 0x1c10 <ringBufferFull>
     f76:	ff 91       	pop	r31
     f78:	ef 91       	pop	r30
     f7a:	bf 91       	pop	r27
     f7c:	af 91       	pop	r26
     f7e:	9f 91       	pop	r25
     f80:	8f 91       	pop	r24
     f82:	7f 91       	pop	r23
     f84:	6f 91       	pop	r22
     f86:	5f 91       	pop	r21
     f88:	4f 91       	pop	r20
     f8a:	3f 91       	pop	r19
     f8c:	2f 91       	pop	r18
     f8e:	0f 90       	pop	r0
     f90:	0b be       	out	0x3b, r0	; 59
     f92:	0f 90       	pop	r0
     f94:	0f be       	out	0x3f, r0	; 63
     f96:	0f 90       	pop	r0
     f98:	1f 90       	pop	r1
     f9a:	18 95       	reti

00000f9c <__vector_25>:
     f9c:	1f 92       	push	r1
     f9e:	0f 92       	push	r0
     fa0:	0f b6       	in	r0, 0x3f	; 63
     fa2:	0f 92       	push	r0
     fa4:	11 24       	eor	r1, r1
     fa6:	0b b6       	in	r0, 0x3b	; 59
     fa8:	0f 92       	push	r0
     faa:	2f 93       	push	r18
     fac:	3f 93       	push	r19
     fae:	4f 93       	push	r20
     fb0:	5f 93       	push	r21
     fb2:	6f 93       	push	r22
     fb4:	7f 93       	push	r23
     fb6:	8f 93       	push	r24
     fb8:	9f 93       	push	r25
     fba:	af 93       	push	r26
     fbc:	bf 93       	push	r27
     fbe:	ef 93       	push	r30
     fc0:	ff 93       	push	r31
     fc2:	60 91 c6 00 	lds	r22, 0x00C6
     fc6:	81 ed       	ldi	r24, 0xD1	; 209
     fc8:	98 e0       	ldi	r25, 0x08	; 8
     fca:	0b d6       	rcall	.+3094   	; 0x1be2 <ringBufferPush>
     fcc:	20 e0       	ldi	r18, 0x00	; 0
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	60 e0       	ldi	r22, 0x00	; 0
     fd4:	70 e0       	ldi	r23, 0x00	; 0
     fd6:	80 91 26 08 	lds	r24, 0x0826
     fda:	90 91 27 08 	lds	r25, 0x0827
     fde:	fb d4       	rcall	.+2550   	; 0x19d6 <xQueueGenericSendFromISR>
     fe0:	81 ed       	ldi	r24, 0xD1	; 209
     fe2:	98 e0       	ldi	r25, 0x08	; 8
     fe4:	15 d6       	rcall	.+3114   	; 0x1c10 <ringBufferFull>
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	0f 90       	pop	r0
    1000:	0b be       	out	0x3b, r0	; 59
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	0f 90       	pop	r0
    1008:	1f 90       	pop	r1
    100a:	18 95       	reti

0000100c <__vector_37>:
    100c:	1f 92       	push	r1
    100e:	0f 92       	push	r0
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	0f 92       	push	r0
    1014:	11 24       	eor	r1, r1
    1016:	0b b6       	in	r0, 0x3b	; 59
    1018:	0f 92       	push	r0
    101a:	2f 93       	push	r18
    101c:	3f 93       	push	r19
    101e:	4f 93       	push	r20
    1020:	5f 93       	push	r21
    1022:	6f 93       	push	r22
    1024:	7f 93       	push	r23
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	af 93       	push	r26
    102c:	bf 93       	push	r27
    102e:	ef 93       	push	r30
    1030:	ff 93       	push	r31
    1032:	86 e3       	ldi	r24, 0x36	; 54
    1034:	99 e0       	ldi	r25, 0x09	; 9
    1036:	f3 d5       	rcall	.+3046   	; 0x1c1e <ringBufferNotEmpty>
    1038:	88 23       	and	r24, r24
    103a:	31 f0       	breq	.+12     	; 0x1048 <__vector_37+0x3c>
    103c:	86 e3       	ldi	r24, 0x36	; 54
    103e:	99 e0       	ldi	r25, 0x09	; 9
    1040:	be d5       	rcall	.+2940   	; 0x1bbe <ringBufferPop>
    1042:	80 93 ce 00 	sts	0x00CE, r24
    1046:	0f c0       	rjmp	.+30     	; 0x1066 <__vector_37+0x5a>
    1048:	e9 ec       	ldi	r30, 0xC9	; 201
    104a:	f0 e0       	ldi	r31, 0x00	; 0
    104c:	80 81       	ld	r24, Z
    104e:	8f 7d       	andi	r24, 0xDF	; 223
    1050:	80 83       	st	Z, r24
    1052:	20 e0       	ldi	r18, 0x00	; 0
    1054:	40 e0       	ldi	r20, 0x00	; 0
    1056:	50 e0       	ldi	r21, 0x00	; 0
    1058:	60 e0       	ldi	r22, 0x00	; 0
    105a:	70 e0       	ldi	r23, 0x00	; 0
    105c:	80 91 1e 08 	lds	r24, 0x081E
    1060:	90 91 1f 08 	lds	r25, 0x081F
    1064:	b8 d4       	rcall	.+2416   	; 0x19d6 <xQueueGenericSendFromISR>
    1066:	ff 91       	pop	r31
    1068:	ef 91       	pop	r30
    106a:	bf 91       	pop	r27
    106c:	af 91       	pop	r26
    106e:	9f 91       	pop	r25
    1070:	8f 91       	pop	r24
    1072:	7f 91       	pop	r23
    1074:	6f 91       	pop	r22
    1076:	5f 91       	pop	r21
    1078:	4f 91       	pop	r20
    107a:	3f 91       	pop	r19
    107c:	2f 91       	pop	r18
    107e:	0f 90       	pop	r0
    1080:	0b be       	out	0x3b, r0	; 59
    1082:	0f 90       	pop	r0
    1084:	0f be       	out	0x3f, r0	; 63
    1086:	0f 90       	pop	r0
    1088:	1f 90       	pop	r1
    108a:	18 95       	reti

0000108c <__vector_26>:
    108c:	1f 92       	push	r1
    108e:	0f 92       	push	r0
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	0f 92       	push	r0
    1094:	11 24       	eor	r1, r1
    1096:	0b b6       	in	r0, 0x3b	; 59
    1098:	0f 92       	push	r0
    109a:	2f 93       	push	r18
    109c:	3f 93       	push	r19
    109e:	4f 93       	push	r20
    10a0:	5f 93       	push	r21
    10a2:	6f 93       	push	r22
    10a4:	7f 93       	push	r23
    10a6:	8f 93       	push	r24
    10a8:	9f 93       	push	r25
    10aa:	af 93       	push	r26
    10ac:	bf 93       	push	r27
    10ae:	ef 93       	push	r30
    10b0:	ff 93       	push	r31
    10b2:	8b e3       	ldi	r24, 0x3B	; 59
    10b4:	99 e0       	ldi	r25, 0x09	; 9
    10b6:	b3 d5       	rcall	.+2918   	; 0x1c1e <ringBufferNotEmpty>
    10b8:	88 23       	and	r24, r24
    10ba:	31 f0       	breq	.+12     	; 0x10c8 <__vector_26+0x3c>
    10bc:	8b e3       	ldi	r24, 0x3B	; 59
    10be:	99 e0       	ldi	r25, 0x09	; 9
    10c0:	7e d5       	rcall	.+2812   	; 0x1bbe <ringBufferPop>
    10c2:	80 93 c6 00 	sts	0x00C6, r24
    10c6:	0f c0       	rjmp	.+30     	; 0x10e6 <__vector_26+0x5a>
    10c8:	e1 ec       	ldi	r30, 0xC1	; 193
    10ca:	f0 e0       	ldi	r31, 0x00	; 0
    10cc:	80 81       	ld	r24, Z
    10ce:	8f 7d       	andi	r24, 0xDF	; 223
    10d0:	80 83       	st	Z, r24
    10d2:	20 e0       	ldi	r18, 0x00	; 0
    10d4:	40 e0       	ldi	r20, 0x00	; 0
    10d6:	50 e0       	ldi	r21, 0x00	; 0
    10d8:	60 e0       	ldi	r22, 0x00	; 0
    10da:	70 e0       	ldi	r23, 0x00	; 0
    10dc:	80 91 20 08 	lds	r24, 0x0820
    10e0:	90 91 21 08 	lds	r25, 0x0821
    10e4:	78 d4       	rcall	.+2288   	; 0x19d6 <xQueueGenericSendFromISR>
    10e6:	ff 91       	pop	r31
    10e8:	ef 91       	pop	r30
    10ea:	bf 91       	pop	r27
    10ec:	af 91       	pop	r26
    10ee:	9f 91       	pop	r25
    10f0:	8f 91       	pop	r24
    10f2:	7f 91       	pop	r23
    10f4:	6f 91       	pop	r22
    10f6:	5f 91       	pop	r21
    10f8:	4f 91       	pop	r20
    10fa:	3f 91       	pop	r19
    10fc:	2f 91       	pop	r18
    10fe:	0f 90       	pop	r0
    1100:	0b be       	out	0x3b, r0	; 59
    1102:	0f 90       	pop	r0
    1104:	0f be       	out	0x3f, r0	; 63
    1106:	0f 90       	pop	r0
    1108:	1f 90       	pop	r1
    110a:	18 95       	reti

0000110c <myUSART_USART0_Init>:
    110c:	10 92 c5 00 	sts	0x00C5, r1
    1110:	87 e6       	ldi	r24, 0x67	; 103
    1112:	80 93 c4 00 	sts	0x00C4, r24
    1116:	88 eb       	ldi	r24, 0xB8	; 184
    1118:	80 93 c1 00 	sts	0x00C1, r24
    111c:	86 e0       	ldi	r24, 0x06	; 6
    111e:	80 93 c2 00 	sts	0x00C2, r24
    1122:	40 e2       	ldi	r20, 0x20	; 32
    1124:	66 ef       	ldi	r22, 0xF6	; 246
    1126:	78 e0       	ldi	r23, 0x08	; 8
    1128:	81 ed       	ldi	r24, 0xD1	; 209
    112a:	98 e0       	ldi	r25, 0x08	; 8
    112c:	41 d5       	rcall	.+2690   	; 0x1bb0 <ringBufferInit>
    112e:	40 e2       	ldi	r20, 0x20	; 32
    1130:	66 ed       	ldi	r22, 0xD6	; 214
    1132:	78 e0       	ldi	r23, 0x08	; 8
    1134:	8b e3       	ldi	r24, 0x3B	; 59
    1136:	99 e0       	ldi	r25, 0x09	; 9
    1138:	3b d5       	rcall	.+2678   	; 0x1bb0 <ringBufferInit>
    113a:	43 e0       	ldi	r20, 0x03	; 3
    113c:	60 e0       	ldi	r22, 0x00	; 0
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	5f d3       	rcall	.+1726   	; 0x1800 <xQueueGenericCreate>
    1142:	90 93 25 08 	sts	0x0825, r25
    1146:	80 93 24 08 	sts	0x0824, r24
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	19 d4       	rcall	.+2098   	; 0x1980 <xQueueCreateMutex>
    114e:	90 93 21 08 	sts	0x0821, r25
    1152:	80 93 20 08 	sts	0x0820, r24
    1156:	08 95       	ret

00001158 <myUSART_USART1_Init>:
    1158:	10 92 cd 00 	sts	0x00CD, r1
    115c:	87 e6       	ldi	r24, 0x67	; 103
    115e:	80 93 cc 00 	sts	0x00CC, r24
    1162:	88 eb       	ldi	r24, 0xB8	; 184
    1164:	80 93 c9 00 	sts	0x00C9, r24
    1168:	86 e0       	ldi	r24, 0x06	; 6
    116a:	80 93 ca 00 	sts	0x00CA, r24
    116e:	40 e2       	ldi	r20, 0x20	; 32
    1170:	61 eb       	ldi	r22, 0xB1	; 177
    1172:	78 e0       	ldi	r23, 0x08	; 8
    1174:	80 e4       	ldi	r24, 0x40	; 64
    1176:	99 e0       	ldi	r25, 0x09	; 9
    1178:	1b d5       	rcall	.+2614   	; 0x1bb0 <ringBufferInit>
    117a:	40 e2       	ldi	r20, 0x20	; 32
    117c:	66 e1       	ldi	r22, 0x16	; 22
    117e:	79 e0       	ldi	r23, 0x09	; 9
    1180:	86 e3       	ldi	r24, 0x36	; 54
    1182:	99 e0       	ldi	r25, 0x09	; 9
    1184:	15 d5       	rcall	.+2602   	; 0x1bb0 <ringBufferInit>
    1186:	43 e0       	ldi	r20, 0x03	; 3
    1188:	60 e0       	ldi	r22, 0x00	; 0
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	39 d3       	rcall	.+1650   	; 0x1800 <xQueueGenericCreate>
    118e:	90 93 27 08 	sts	0x0827, r25
    1192:	80 93 26 08 	sts	0x0826, r24
    1196:	43 e0       	ldi	r20, 0x03	; 3
    1198:	60 e0       	ldi	r22, 0x00	; 0
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	31 d3       	rcall	.+1634   	; 0x1800 <xQueueGenericCreate>
    119e:	90 93 23 08 	sts	0x0823, r25
    11a2:	80 93 22 08 	sts	0x0822, r24
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	eb d3       	rcall	.+2006   	; 0x1980 <xQueueCreateMutex>
    11aa:	90 93 1f 08 	sts	0x081F, r25
    11ae:	80 93 1e 08 	sts	0x081E, r24
    11b2:	08 95       	ret

000011b4 <myUSART_transmitUSART0_c>:
    11b4:	cf 93       	push	r28
    11b6:	c8 2f       	mov	r28, r24
    11b8:	20 e0       	ldi	r18, 0x00	; 0
    11ba:	4f ef       	ldi	r20, 0xFF	; 255
    11bc:	5f ef       	ldi	r21, 0xFF	; 255
    11be:	60 e0       	ldi	r22, 0x00	; 0
    11c0:	70 e0       	ldi	r23, 0x00	; 0
    11c2:	80 91 20 08 	lds	r24, 0x0820
    11c6:	90 91 21 08 	lds	r25, 0x0821
    11ca:	3f d4       	rcall	.+2174   	; 0x1a4a <xQueueGenericReceive>
    11cc:	8b e3       	ldi	r24, 0x3B	; 59
    11ce:	99 e0       	ldi	r25, 0x09	; 9
    11d0:	1f d5       	rcall	.+2622   	; 0x1c10 <ringBufferFull>
    11d2:	81 11       	cpse	r24, r1
    11d4:	fb cf       	rjmp	.-10     	; 0x11cc <myUSART_transmitUSART0_c+0x18>
    11d6:	6c 2f       	mov	r22, r28
    11d8:	8b e3       	ldi	r24, 0x3B	; 59
    11da:	99 e0       	ldi	r25, 0x09	; 9
    11dc:	02 d5       	rcall	.+2564   	; 0x1be2 <ringBufferPush>
    11de:	e1 ec       	ldi	r30, 0xC1	; 193
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	80 81       	ld	r24, Z
    11e4:	80 62       	ori	r24, 0x20	; 32
    11e6:	80 83       	st	Z, r24
    11e8:	e0 ec       	ldi	r30, 0xC0	; 192
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	80 81       	ld	r24, Z
    11ee:	80 64       	ori	r24, 0x40	; 64
    11f0:	80 83       	st	Z, r24
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

000011f6 <myUSART_transmitUSART1_c>:
    11f6:	cf 93       	push	r28
    11f8:	c8 2f       	mov	r28, r24
    11fa:	20 e0       	ldi	r18, 0x00	; 0
    11fc:	4f ef       	ldi	r20, 0xFF	; 255
    11fe:	5f ef       	ldi	r21, 0xFF	; 255
    1200:	60 e0       	ldi	r22, 0x00	; 0
    1202:	70 e0       	ldi	r23, 0x00	; 0
    1204:	80 91 1e 08 	lds	r24, 0x081E
    1208:	90 91 1f 08 	lds	r25, 0x081F
    120c:	1e d4       	rcall	.+2108   	; 0x1a4a <xQueueGenericReceive>
    120e:	86 e3       	ldi	r24, 0x36	; 54
    1210:	99 e0       	ldi	r25, 0x09	; 9
    1212:	fe d4       	rcall	.+2556   	; 0x1c10 <ringBufferFull>
    1214:	81 11       	cpse	r24, r1
    1216:	fb cf       	rjmp	.-10     	; 0x120e <myUSART_transmitUSART1_c+0x18>
    1218:	6c 2f       	mov	r22, r28
    121a:	86 e3       	ldi	r24, 0x36	; 54
    121c:	99 e0       	ldi	r25, 0x09	; 9
    121e:	e1 d4       	rcall	.+2498   	; 0x1be2 <ringBufferPush>
    1220:	e9 ec       	ldi	r30, 0xC9	; 201
    1222:	f0 e0       	ldi	r31, 0x00	; 0
    1224:	80 81       	ld	r24, Z
    1226:	80 62       	ori	r24, 0x20	; 32
    1228:	80 83       	st	Z, r24
    122a:	e8 ec       	ldi	r30, 0xC8	; 200
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	80 81       	ld	r24, Z
    1230:	80 64       	ori	r24, 0x40	; 64
    1232:	80 83       	st	Z, r24
    1234:	cf 91       	pop	r28
    1236:	08 95       	ret

00001238 <myUSART_transmitUSART1>:
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
    123c:	ec 01       	movw	r28, r24
    123e:	88 81       	ld	r24, Y
    1240:	88 23       	and	r24, r24
    1242:	29 f0       	breq	.+10     	; 0x124e <myUSART_transmitUSART1+0x16>
    1244:	21 96       	adiw	r28, 0x01	; 1
    1246:	d7 df       	rcall	.-82     	; 0x11f6 <myUSART_transmitUSART1_c>
    1248:	89 91       	ld	r24, Y+
    124a:	81 11       	cpse	r24, r1
    124c:	fc cf       	rjmp	.-8      	; 0x1246 <myUSART_transmitUSART1+0xe>
    124e:	df 91       	pop	r29
    1250:	cf 91       	pop	r28
    1252:	08 95       	ret

00001254 <myUSART_transmitUSART0>:
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	ec 01       	movw	r28, r24
    125a:	88 81       	ld	r24, Y
    125c:	88 23       	and	r24, r24
    125e:	29 f0       	breq	.+10     	; 0x126a <myUSART_transmitUSART0+0x16>
    1260:	21 96       	adiw	r28, 0x01	; 1
    1262:	a8 df       	rcall	.-176    	; 0x11b4 <myUSART_transmitUSART0_c>
    1264:	89 91       	ld	r24, Y+
    1266:	81 11       	cpse	r24, r1
    1268:	fc cf       	rjmp	.-8      	; 0x1262 <myUSART_transmitUSART0+0xe>
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	08 95       	ret

00001270 <myUSART_receiveUSART1>:
    1270:	cf 93       	push	r28
    1272:	20 e0       	ldi	r18, 0x00	; 0
    1274:	4f ef       	ldi	r20, 0xFF	; 255
    1276:	5f ef       	ldi	r21, 0xFF	; 255
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	70 e0       	ldi	r23, 0x00	; 0
    127c:	80 91 26 08 	lds	r24, 0x0826
    1280:	90 91 27 08 	lds	r25, 0x0827
    1284:	e2 d3       	rcall	.+1988   	; 0x1a4a <xQueueGenericReceive>
    1286:	80 e4       	ldi	r24, 0x40	; 64
    1288:	99 e0       	ldi	r25, 0x09	; 9
    128a:	99 d4       	rcall	.+2354   	; 0x1bbe <ringBufferPop>
    128c:	c8 2f       	mov	r28, r24
    128e:	80 e4       	ldi	r24, 0x40	; 64
    1290:	99 e0       	ldi	r25, 0x09	; 9
    1292:	c5 d4       	rcall	.+2442   	; 0x1c1e <ringBufferNotEmpty>
    1294:	88 23       	and	r24, r24
    1296:	51 f0       	breq	.+20     	; 0x12ac <myUSART_receiveUSART1+0x3c>
    1298:	20 e0       	ldi	r18, 0x00	; 0
    129a:	40 e0       	ldi	r20, 0x00	; 0
    129c:	50 e0       	ldi	r21, 0x00	; 0
    129e:	60 e0       	ldi	r22, 0x00	; 0
    12a0:	70 e0       	ldi	r23, 0x00	; 0
    12a2:	80 91 26 08 	lds	r24, 0x0826
    12a6:	90 91 27 08 	lds	r25, 0x0827
    12aa:	d7 d2       	rcall	.+1454   	; 0x185a <xQueueGenericSend>
    12ac:	8c 2f       	mov	r24, r28
    12ae:	cf 91       	pop	r28
    12b0:	08 95       	ret

000012b2 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    12b2:	86 e1       	ldi	r24, 0x16	; 22
    12b4:	a0 df       	rcall	.-192    	; 0x11f6 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    12b6:	20 e0       	ldi	r18, 0x00	; 0
    12b8:	4a ef       	ldi	r20, 0xFA	; 250
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	60 e0       	ldi	r22, 0x00	; 0
    12be:	70 e0       	ldi	r23, 0x00	; 0
    12c0:	80 91 22 08 	lds	r24, 0x0822
    12c4:	90 91 23 08 	lds	r25, 0x0823
    12c8:	c0 d3       	rcall	.+1920   	; 0x1a4a <xQueueGenericReceive>
    12ca:	81 30       	cpi	r24, 0x01	; 1
    12cc:	21 f4       	brne	.+8      	; 0x12d6 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    12ce:	82 e0       	ldi	r24, 0x02	; 2
    12d0:	92 df       	rcall	.-220    	; 0x11f6 <myUSART_transmitUSART1_c>
		return 1;
    12d2:	81 e0       	ldi	r24, 0x01	; 1
    12d4:	08 95       	ret
	}
	else
	{
		return 0;
    12d6:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    12d8:	08 95       	ret

000012da <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    12da:	20 e0       	ldi	r18, 0x00	; 0
    12dc:	40 e0       	ldi	r20, 0x00	; 0
    12de:	50 e0       	ldi	r21, 0x00	; 0
    12e0:	60 e0       	ldi	r22, 0x00	; 0
    12e2:	70 e0       	ldi	r23, 0x00	; 0
    12e4:	80 91 22 08 	lds	r24, 0x0822
    12e8:	90 91 23 08 	lds	r25, 0x0823
    12ec:	b6 c2       	rjmp	.+1388   	; 0x185a <xQueueGenericSend>
    12ee:	08 95       	ret

000012f0 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    12f0:	91 e0       	ldi	r25, 0x01	; 1
    12f2:	85 30       	cpi	r24, 0x05	; 5
    12f4:	09 f0       	breq	.+2      	; 0x12f8 <myUSART_receiveHandShakeAck+0x8>
    12f6:	90 e0       	ldi	r25, 0x00	; 0
}
    12f8:	89 2f       	mov	r24, r25
    12fa:	08 95       	ret

000012fc <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    12fc:	91 e0       	ldi	r25, 0x01	; 1
    12fe:	86 31       	cpi	r24, 0x16	; 22
    1300:	09 f0       	breq	.+2      	; 0x1304 <myUSART_receiveHandShakeStart+0x8>
    1302:	90 e0       	ldi	r25, 0x00	; 0
}
    1304:	89 2f       	mov	r24, r25
    1306:	08 95       	ret

00001308 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    1308:	91 e0       	ldi	r25, 0x01	; 1
    130a:	82 30       	cpi	r24, 0x02	; 2
    130c:	09 f0       	breq	.+2      	; 0x1310 <myUSART_receiveHandShakeFin+0x8>
    130e:	90 e0       	ldi	r25, 0x00	; 0
}
    1310:	89 2f       	mov	r24, r25
    1312:	08 95       	ret

00001314 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1314:	91 e0       	ldi	r25, 0x01	; 1
    1316:	86 30       	cpi	r24, 0x06	; 6
    1318:	09 f0       	breq	.+2      	; 0x131c <myUSART_receiveMessageACK+0x8>
    131a:	90 e0       	ldi	r25, 0x00	; 0
}
    131c:	89 2f       	mov	r24, r25
    131e:	08 95       	ret

00001320 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1320:	31 e1       	ldi	r19, 0x11	; 17
    1322:	fc 01       	movw	r30, r24
    1324:	30 83       	st	Z, r19
    1326:	31 97       	sbiw	r30, 0x01	; 1
    1328:	22 e2       	ldi	r18, 0x22	; 34
    132a:	20 83       	st	Z, r18
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	a3 e3       	ldi	r26, 0x33	; 51
    1330:	a0 83       	st	Z, r26
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	60 83       	st	Z, r22
    1336:	31 97       	sbiw	r30, 0x01	; 1
    1338:	70 83       	st	Z, r23
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	10 82       	st	Z, r1
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	10 82       	st	Z, r1
    1342:	31 97       	sbiw	r30, 0x01	; 1
    1344:	60 e8       	ldi	r22, 0x80	; 128
    1346:	60 83       	st	Z, r22
    1348:	31 97       	sbiw	r30, 0x01	; 1
    134a:	10 82       	st	Z, r1
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	10 82       	st	Z, r1
    1350:	31 97       	sbiw	r30, 0x01	; 1
    1352:	10 82       	st	Z, r1
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	62 e0       	ldi	r22, 0x02	; 2
    1358:	60 83       	st	Z, r22
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	63 e0       	ldi	r22, 0x03	; 3
    135e:	60 83       	st	Z, r22
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	64 e0       	ldi	r22, 0x04	; 4
    1364:	60 83       	st	Z, r22
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	65 e0       	ldi	r22, 0x05	; 5
    136a:	60 83       	st	Z, r22
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	66 e0       	ldi	r22, 0x06	; 6
    1370:	60 83       	st	Z, r22
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	67 e0       	ldi	r22, 0x07	; 7
    1376:	60 83       	st	Z, r22
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	68 e0       	ldi	r22, 0x08	; 8
    137c:	60 83       	st	Z, r22
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	69 e0       	ldi	r22, 0x09	; 9
    1382:	60 83       	st	Z, r22
    1384:	31 97       	sbiw	r30, 0x01	; 1
    1386:	60 e1       	ldi	r22, 0x10	; 16
    1388:	60 83       	st	Z, r22
    138a:	31 97       	sbiw	r30, 0x01	; 1
    138c:	30 83       	st	Z, r19
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	32 e1       	ldi	r19, 0x12	; 18
    1392:	30 83       	st	Z, r19
    1394:	31 97       	sbiw	r30, 0x01	; 1
    1396:	33 e1       	ldi	r19, 0x13	; 19
    1398:	30 83       	st	Z, r19
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	34 e1       	ldi	r19, 0x14	; 20
    139e:	30 83       	st	Z, r19
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	35 e1       	ldi	r19, 0x15	; 21
    13a4:	30 83       	st	Z, r19
    13a6:	31 97       	sbiw	r30, 0x01	; 1
    13a8:	36 e1       	ldi	r19, 0x16	; 22
    13aa:	30 83       	st	Z, r19
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	37 e1       	ldi	r19, 0x17	; 23
    13b0:	30 83       	st	Z, r19
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	38 e1       	ldi	r19, 0x18	; 24
    13b6:	30 83       	st	Z, r19
    13b8:	31 97       	sbiw	r30, 0x01	; 1
    13ba:	39 e1       	ldi	r19, 0x19	; 25
    13bc:	30 83       	st	Z, r19
    13be:	31 97       	sbiw	r30, 0x01	; 1
    13c0:	30 e2       	ldi	r19, 0x20	; 32
    13c2:	30 83       	st	Z, r19
    13c4:	31 97       	sbiw	r30, 0x01	; 1
    13c6:	31 e2       	ldi	r19, 0x21	; 33
    13c8:	30 83       	st	Z, r19
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	20 83       	st	Z, r18
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	23 e2       	ldi	r18, 0x23	; 35
    13d2:	20 83       	st	Z, r18
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	40 83       	st	Z, r20
    13d8:	31 97       	sbiw	r30, 0x01	; 1
    13da:	50 83       	st	Z, r21
    13dc:	31 97       	sbiw	r30, 0x01	; 1
    13de:	26 e2       	ldi	r18, 0x26	; 38
    13e0:	20 83       	st	Z, r18
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	27 e2       	ldi	r18, 0x27	; 39
    13e6:	20 83       	st	Z, r18
    13e8:	31 97       	sbiw	r30, 0x01	; 1
    13ea:	28 e2       	ldi	r18, 0x28	; 40
    13ec:	20 83       	st	Z, r18
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	29 e2       	ldi	r18, 0x29	; 41
    13f2:	20 83       	st	Z, r18
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	20 e3       	ldi	r18, 0x30	; 48
    13f8:	20 83       	st	Z, r18
    13fa:	31 97       	sbiw	r30, 0x01	; 1
    13fc:	21 e3       	ldi	r18, 0x31	; 49
    13fe:	20 83       	st	Z, r18
    1400:	89 97       	sbiw	r24, 0x29	; 41
    1402:	08 95       	ret

00001404 <xPortStartScheduler>:
    1404:	82 e0       	ldi	r24, 0x02	; 2
    1406:	84 bd       	out	0x24, r24	; 36
    1408:	16 bc       	out	0x26, r1	; 38
    140a:	80 e3       	ldi	r24, 0x30	; 48
    140c:	87 bd       	out	0x27, r24	; 39
    140e:	ee e6       	ldi	r30, 0x6E	; 110
    1410:	f0 e0       	ldi	r31, 0x00	; 0
    1412:	80 81       	ld	r24, Z
    1414:	82 60       	ori	r24, 0x02	; 2
    1416:	80 83       	st	Z, r24
    1418:	83 e0       	ldi	r24, 0x03	; 3
    141a:	85 bd       	out	0x25, r24	; 37
    141c:	a0 91 91 08 	lds	r26, 0x0891
    1420:	b0 91 92 08 	lds	r27, 0x0892
    1424:	cd 91       	ld	r28, X+
    1426:	cd bf       	out	0x3d, r28	; 61
    1428:	dd 91       	ld	r29, X+
    142a:	de bf       	out	0x3e, r29	; 62
    142c:	ff 91       	pop	r31
    142e:	ef 91       	pop	r30
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	bf 91       	pop	r27
    1436:	af 91       	pop	r26
    1438:	9f 91       	pop	r25
    143a:	8f 91       	pop	r24
    143c:	7f 91       	pop	r23
    143e:	6f 91       	pop	r22
    1440:	5f 91       	pop	r21
    1442:	4f 91       	pop	r20
    1444:	3f 91       	pop	r19
    1446:	2f 91       	pop	r18
    1448:	1f 91       	pop	r17
    144a:	0f 91       	pop	r16
    144c:	ff 90       	pop	r15
    144e:	ef 90       	pop	r14
    1450:	df 90       	pop	r13
    1452:	cf 90       	pop	r12
    1454:	bf 90       	pop	r11
    1456:	af 90       	pop	r10
    1458:	9f 90       	pop	r9
    145a:	8f 90       	pop	r8
    145c:	7f 90       	pop	r7
    145e:	6f 90       	pop	r6
    1460:	5f 90       	pop	r5
    1462:	4f 90       	pop	r4
    1464:	3f 90       	pop	r3
    1466:	2f 90       	pop	r2
    1468:	1f 90       	pop	r1
    146a:	0f 90       	pop	r0
    146c:	0c be       	out	0x3c, r0	; 60
    146e:	0f 90       	pop	r0
    1470:	0b be       	out	0x3b, r0	; 59
    1472:	0f 90       	pop	r0
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	0f 90       	pop	r0
    1478:	08 95       	ret
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	08 95       	ret

0000147e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    147e:	0f 92       	push	r0
    1480:	0f b6       	in	r0, 0x3f	; 63
    1482:	f8 94       	cli
    1484:	0f 92       	push	r0
    1486:	0b b6       	in	r0, 0x3b	; 59
    1488:	0f 92       	push	r0
    148a:	0c b6       	in	r0, 0x3c	; 60
    148c:	0f 92       	push	r0
    148e:	1f 92       	push	r1
    1490:	11 24       	eor	r1, r1
    1492:	2f 92       	push	r2
    1494:	3f 92       	push	r3
    1496:	4f 92       	push	r4
    1498:	5f 92       	push	r5
    149a:	6f 92       	push	r6
    149c:	7f 92       	push	r7
    149e:	8f 92       	push	r8
    14a0:	9f 92       	push	r9
    14a2:	af 92       	push	r10
    14a4:	bf 92       	push	r11
    14a6:	cf 92       	push	r12
    14a8:	df 92       	push	r13
    14aa:	ef 92       	push	r14
    14ac:	ff 92       	push	r15
    14ae:	0f 93       	push	r16
    14b0:	1f 93       	push	r17
    14b2:	2f 93       	push	r18
    14b4:	3f 93       	push	r19
    14b6:	4f 93       	push	r20
    14b8:	5f 93       	push	r21
    14ba:	6f 93       	push	r22
    14bc:	7f 93       	push	r23
    14be:	8f 93       	push	r24
    14c0:	9f 93       	push	r25
    14c2:	af 93       	push	r26
    14c4:	bf 93       	push	r27
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	ef 93       	push	r30
    14cc:	ff 93       	push	r31
    14ce:	a0 91 91 08 	lds	r26, 0x0891
    14d2:	b0 91 92 08 	lds	r27, 0x0892
    14d6:	0d b6       	in	r0, 0x3d	; 61
    14d8:	0d 92       	st	X+, r0
    14da:	0e b6       	in	r0, 0x3e	; 62
    14dc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14de:	51 d7       	rcall	.+3746   	; 0x2382 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14e0:	a0 91 91 08 	lds	r26, 0x0891
    14e4:	b0 91 92 08 	lds	r27, 0x0892
    14e8:	cd 91       	ld	r28, X+
    14ea:	cd bf       	out	0x3d, r28	; 61
    14ec:	dd 91       	ld	r29, X+
    14ee:	de bf       	out	0x3e, r29	; 62
    14f0:	ff 91       	pop	r31
    14f2:	ef 91       	pop	r30
    14f4:	df 91       	pop	r29
    14f6:	cf 91       	pop	r28
    14f8:	bf 91       	pop	r27
    14fa:	af 91       	pop	r26
    14fc:	9f 91       	pop	r25
    14fe:	8f 91       	pop	r24
    1500:	7f 91       	pop	r23
    1502:	6f 91       	pop	r22
    1504:	5f 91       	pop	r21
    1506:	4f 91       	pop	r20
    1508:	3f 91       	pop	r19
    150a:	2f 91       	pop	r18
    150c:	1f 91       	pop	r17
    150e:	0f 91       	pop	r16
    1510:	ff 90       	pop	r15
    1512:	ef 90       	pop	r14
    1514:	df 90       	pop	r13
    1516:	cf 90       	pop	r12
    1518:	bf 90       	pop	r11
    151a:	af 90       	pop	r10
    151c:	9f 90       	pop	r9
    151e:	8f 90       	pop	r8
    1520:	7f 90       	pop	r7
    1522:	6f 90       	pop	r6
    1524:	5f 90       	pop	r5
    1526:	4f 90       	pop	r4
    1528:	3f 90       	pop	r3
    152a:	2f 90       	pop	r2
    152c:	1f 90       	pop	r1
    152e:	0f 90       	pop	r0
    1530:	0c be       	out	0x3c, r0	; 60
    1532:	0f 90       	pop	r0
    1534:	0b be       	out	0x3b, r0	; 59
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63
    153a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    153c:	08 95       	ret

0000153e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    153e:	0f 92       	push	r0
    1540:	0f b6       	in	r0, 0x3f	; 63
    1542:	f8 94       	cli
    1544:	0f 92       	push	r0
    1546:	0b b6       	in	r0, 0x3b	; 59
    1548:	0f 92       	push	r0
    154a:	0c b6       	in	r0, 0x3c	; 60
    154c:	0f 92       	push	r0
    154e:	1f 92       	push	r1
    1550:	11 24       	eor	r1, r1
    1552:	2f 92       	push	r2
    1554:	3f 92       	push	r3
    1556:	4f 92       	push	r4
    1558:	5f 92       	push	r5
    155a:	6f 92       	push	r6
    155c:	7f 92       	push	r7
    155e:	8f 92       	push	r8
    1560:	9f 92       	push	r9
    1562:	af 92       	push	r10
    1564:	bf 92       	push	r11
    1566:	cf 92       	push	r12
    1568:	df 92       	push	r13
    156a:	ef 92       	push	r14
    156c:	ff 92       	push	r15
    156e:	0f 93       	push	r16
    1570:	1f 93       	push	r17
    1572:	2f 93       	push	r18
    1574:	3f 93       	push	r19
    1576:	4f 93       	push	r20
    1578:	5f 93       	push	r21
    157a:	6f 93       	push	r22
    157c:	7f 93       	push	r23
    157e:	8f 93       	push	r24
    1580:	9f 93       	push	r25
    1582:	af 93       	push	r26
    1584:	bf 93       	push	r27
    1586:	cf 93       	push	r28
    1588:	df 93       	push	r29
    158a:	ef 93       	push	r30
    158c:	ff 93       	push	r31
    158e:	a0 91 91 08 	lds	r26, 0x0891
    1592:	b0 91 92 08 	lds	r27, 0x0892
    1596:	0d b6       	in	r0, 0x3d	; 61
    1598:	0d 92       	st	X+, r0
    159a:	0e b6       	in	r0, 0x3e	; 62
    159c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    159e:	3b d5       	rcall	.+2678   	; 0x2016 <xTaskIncrementTick>
    15a0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    15a2:	ef d6       	rcall	.+3550   	; 0x2382 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    15a4:	a0 91 91 08 	lds	r26, 0x0891
    15a8:	b0 91 92 08 	lds	r27, 0x0892
    15ac:	cd 91       	ld	r28, X+
    15ae:	cd bf       	out	0x3d, r28	; 61
    15b0:	dd 91       	ld	r29, X+
    15b2:	de bf       	out	0x3e, r29	; 62
    15b4:	ff 91       	pop	r31
    15b6:	ef 91       	pop	r30
    15b8:	df 91       	pop	r29
    15ba:	cf 91       	pop	r28
    15bc:	bf 91       	pop	r27
    15be:	af 91       	pop	r26
    15c0:	9f 91       	pop	r25
    15c2:	8f 91       	pop	r24
    15c4:	7f 91       	pop	r23
    15c6:	6f 91       	pop	r22
    15c8:	5f 91       	pop	r21
    15ca:	4f 91       	pop	r20
    15cc:	3f 91       	pop	r19
    15ce:	2f 91       	pop	r18
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	ff 90       	pop	r15
    15d6:	ef 90       	pop	r14
    15d8:	df 90       	pop	r13
    15da:	cf 90       	pop	r12
    15dc:	bf 90       	pop	r11
    15de:	af 90       	pop	r10
    15e0:	9f 90       	pop	r9
    15e2:	8f 90       	pop	r8
    15e4:	7f 90       	pop	r7
    15e6:	6f 90       	pop	r6
    15e8:	5f 90       	pop	r5
    15ea:	4f 90       	pop	r4
    15ec:	3f 90       	pop	r3
    15ee:	2f 90       	pop	r2
    15f0:	1f 90       	pop	r1
    15f2:	0f 90       	pop	r0
    15f4:	0c be       	out	0x3c, r0	; 60
    15f6:	0f 90       	pop	r0
    15f8:	0b be       	out	0x3b, r0	; 59
    15fa:	0f 90       	pop	r0
    15fc:	0f be       	out	0x3f, r0	; 63
    15fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1600:	08 95       	ret

00001602 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1602:	9d df       	rcall	.-198    	; 0x153e <vPortYieldFromTick>
		 asm volatile ("reti");
    1604:	18 95       	reti

00001606 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1606:	1f 93       	push	r17
    1608:	cf 93       	push	r28
    160a:	df 93       	push	r29
    160c:	ec 01       	movw	r28, r24
    160e:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1610:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1612:	81 11       	cpse	r24, r1
    1614:	0c c0       	rjmp	.+24     	; 0x162e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1616:	88 81       	ld	r24, Y
    1618:	99 81       	ldd	r25, Y+1	; 0x01
    161a:	89 2b       	or	r24, r25
    161c:	09 f0       	breq	.+2      	; 0x1620 <prvCopyDataToQueue+0x1a>
    161e:	47 c0       	rjmp	.+142    	; 0x16ae <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1620:	8a 81       	ldd	r24, Y+2	; 0x02
    1622:	9b 81       	ldd	r25, Y+3	; 0x03
    1624:	0e 94 84 13 	call	0x2708	; 0x2708 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1628:	1b 82       	std	Y+3, r1	; 0x03
    162a:	1a 82       	std	Y+2, r1	; 0x02
    162c:	47 c0       	rjmp	.+142    	; 0x16bc <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    162e:	41 11       	cpse	r20, r1
    1630:	18 c0       	rjmp	.+48     	; 0x1662 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1632:	48 2f       	mov	r20, r24
    1634:	50 e0       	ldi	r21, 0x00	; 0
    1636:	8c 81       	ldd	r24, Y+4	; 0x04
    1638:	9d 81       	ldd	r25, Y+5	; 0x05
    163a:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    163e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1640:	8c 81       	ldd	r24, Y+4	; 0x04
    1642:	9d 81       	ldd	r25, Y+5	; 0x05
    1644:	82 0f       	add	r24, r18
    1646:	91 1d       	adc	r25, r1
    1648:	9d 83       	std	Y+5, r25	; 0x05
    164a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    164c:	2a 81       	ldd	r18, Y+2	; 0x02
    164e:	3b 81       	ldd	r19, Y+3	; 0x03
    1650:	82 17       	cp	r24, r18
    1652:	93 07       	cpc	r25, r19
    1654:	70 f1       	brcs	.+92     	; 0x16b2 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1656:	88 81       	ld	r24, Y
    1658:	99 81       	ldd	r25, Y+1	; 0x01
    165a:	9d 83       	std	Y+5, r25	; 0x05
    165c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    165e:	80 e0       	ldi	r24, 0x00	; 0
    1660:	2d c0       	rjmp	.+90     	; 0x16bc <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1662:	48 2f       	mov	r20, r24
    1664:	50 e0       	ldi	r21, 0x00	; 0
    1666:	8e 81       	ldd	r24, Y+6	; 0x06
    1668:	9f 81       	ldd	r25, Y+7	; 0x07
    166a:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    166e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	31 95       	neg	r19
    1674:	21 95       	neg	r18
    1676:	31 09       	sbc	r19, r1
    1678:	8e 81       	ldd	r24, Y+6	; 0x06
    167a:	9f 81       	ldd	r25, Y+7	; 0x07
    167c:	82 0f       	add	r24, r18
    167e:	93 1f       	adc	r25, r19
    1680:	9f 83       	std	Y+7, r25	; 0x07
    1682:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1684:	68 81       	ld	r22, Y
    1686:	79 81       	ldd	r23, Y+1	; 0x01
    1688:	86 17       	cp	r24, r22
    168a:	97 07       	cpc	r25, r23
    168c:	30 f4       	brcc	.+12     	; 0x169a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	9b 81       	ldd	r25, Y+3	; 0x03
    1692:	28 0f       	add	r18, r24
    1694:	39 1f       	adc	r19, r25
    1696:	3f 83       	std	Y+7, r19	; 0x07
    1698:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    169a:	12 30       	cpi	r17, 0x02	; 2
    169c:	61 f4       	brne	.+24     	; 0x16b6 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    169e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16a0:	88 23       	and	r24, r24
    16a2:	59 f0       	breq	.+22     	; 0x16ba <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    16a4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16a6:	81 50       	subi	r24, 0x01	; 1
    16a8:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	07 c0       	rjmp	.+14     	; 0x16bc <prvCopyDataToQueue+0xb6>
    16ae:	80 e0       	ldi	r24, 0x00	; 0
    16b0:	05 c0       	rjmp	.+10     	; 0x16bc <prvCopyDataToQueue+0xb6>
    16b2:	80 e0       	ldi	r24, 0x00	; 0
    16b4:	03 c0       	rjmp	.+6      	; 0x16bc <prvCopyDataToQueue+0xb6>
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	01 c0       	rjmp	.+2      	; 0x16bc <prvCopyDataToQueue+0xb6>
    16ba:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16bc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    16be:	9f 5f       	subi	r25, 0xFF	; 255
    16c0:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    16c2:	df 91       	pop	r29
    16c4:	cf 91       	pop	r28
    16c6:	1f 91       	pop	r17
    16c8:	08 95       	ret

000016ca <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    16ca:	fc 01       	movw	r30, r24
    16cc:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    16ce:	44 8d       	ldd	r20, Z+28	; 0x1c
    16d0:	44 23       	and	r20, r20
    16d2:	a1 f0       	breq	.+40     	; 0x16fc <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    16d4:	50 e0       	ldi	r21, 0x00	; 0
    16d6:	26 81       	ldd	r18, Z+6	; 0x06
    16d8:	37 81       	ldd	r19, Z+7	; 0x07
    16da:	24 0f       	add	r18, r20
    16dc:	35 1f       	adc	r19, r21
    16de:	37 83       	std	Z+7, r19	; 0x07
    16e0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    16e2:	62 81       	ldd	r22, Z+2	; 0x02
    16e4:	73 81       	ldd	r23, Z+3	; 0x03
    16e6:	26 17       	cp	r18, r22
    16e8:	37 07       	cpc	r19, r23
    16ea:	20 f0       	brcs	.+8      	; 0x16f4 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    16ec:	20 81       	ld	r18, Z
    16ee:	31 81       	ldd	r19, Z+1	; 0x01
    16f0:	37 83       	std	Z+7, r19	; 0x07
    16f2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    16f4:	66 81       	ldd	r22, Z+6	; 0x06
    16f6:	77 81       	ldd	r23, Z+7	; 0x07
    16f8:	0c 94 50 17 	jmp	0x2ea0	; 0x2ea0 <memcpy>
    16fc:	08 95       	ret

000016fe <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	cf 93       	push	r28
    1704:	df 93       	push	r29
    1706:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    170e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1710:	18 16       	cp	r1, r24
    1712:	a4 f4       	brge	.+40     	; 0x173c <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1714:	89 89       	ldd	r24, Y+17	; 0x11
    1716:	88 23       	and	r24, r24
    1718:	89 f0       	breq	.+34     	; 0x173c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    171a:	8e 01       	movw	r16, r28
    171c:	0f 5e       	subi	r16, 0xEF	; 239
    171e:	1f 4f       	sbci	r17, 0xFF	; 255
    1720:	03 c0       	rjmp	.+6      	; 0x1728 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1722:	89 89       	ldd	r24, Y+17	; 0x11
    1724:	88 23       	and	r24, r24
    1726:	51 f0       	breq	.+20     	; 0x173c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1728:	c8 01       	movw	r24, r16
    172a:	01 d7       	rcall	.+3586   	; 0x252e <xTaskRemoveFromEventList>
    172c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    172e:	8a d7       	rcall	.+3860   	; 0x2644 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1730:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1732:	81 50       	subi	r24, 0x01	; 1
    1734:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1736:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1738:	18 16       	cp	r1, r24
    173a:	9c f3       	brlt	.-26     	; 0x1722 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    173c:	8f ef       	ldi	r24, 0xFF	; 255
    173e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1740:	0f 90       	pop	r0
    1742:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1744:	0f b6       	in	r0, 0x3f	; 63
    1746:	f8 94       	cli
    1748:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    174a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    174c:	18 16       	cp	r1, r24
    174e:	a4 f4       	brge	.+40     	; 0x1778 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1750:	88 85       	ldd	r24, Y+8	; 0x08
    1752:	88 23       	and	r24, r24
    1754:	89 f0       	breq	.+34     	; 0x1778 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1756:	8e 01       	movw	r16, r28
    1758:	08 5f       	subi	r16, 0xF8	; 248
    175a:	1f 4f       	sbci	r17, 0xFF	; 255
    175c:	03 c0       	rjmp	.+6      	; 0x1764 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    175e:	88 85       	ldd	r24, Y+8	; 0x08
    1760:	88 23       	and	r24, r24
    1762:	51 f0       	breq	.+20     	; 0x1778 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1764:	c8 01       	movw	r24, r16
    1766:	e3 d6       	rcall	.+3526   	; 0x252e <xTaskRemoveFromEventList>
    1768:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    176a:	6c d7       	rcall	.+3800   	; 0x2644 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    176c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    176e:	81 50       	subi	r24, 0x01	; 1
    1770:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1772:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1774:	18 16       	cp	r1, r24
    1776:	9c f3       	brlt	.-26     	; 0x175e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1778:	8f ef       	ldi	r24, 0xFF	; 255
    177a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
}
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	1f 91       	pop	r17
    1786:	0f 91       	pop	r16
    1788:	08 95       	ret

0000178a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    178a:	cf 93       	push	r28
    178c:	df 93       	push	r29
    178e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1796:	88 81       	ld	r24, Y
    1798:	99 81       	ldd	r25, Y+1	; 0x01
    179a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    17a0:	72 9f       	mul	r23, r18
    17a2:	a0 01       	movw	r20, r0
    17a4:	73 9f       	mul	r23, r19
    17a6:	50 0d       	add	r21, r0
    17a8:	11 24       	eor	r1, r1
    17aa:	fc 01       	movw	r30, r24
    17ac:	e4 0f       	add	r30, r20
    17ae:	f5 1f       	adc	r31, r21
    17b0:	fb 83       	std	Y+3, r31	; 0x03
    17b2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17b4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17b6:	9d 83       	std	Y+5, r25	; 0x05
    17b8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    17ba:	42 1b       	sub	r20, r18
    17bc:	53 0b       	sbc	r21, r19
    17be:	84 0f       	add	r24, r20
    17c0:	95 1f       	adc	r25, r21
    17c2:	9f 83       	std	Y+7, r25	; 0x07
    17c4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17c6:	8f ef       	ldi	r24, 0xFF	; 255
    17c8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17ca:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17cc:	61 11       	cpse	r22, r1
    17ce:	0a c0       	rjmp	.+20     	; 0x17e4 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17d0:	88 85       	ldd	r24, Y+8	; 0x08
    17d2:	88 23       	and	r24, r24
    17d4:	79 f0       	breq	.+30     	; 0x17f4 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17d6:	ce 01       	movw	r24, r28
    17d8:	08 96       	adiw	r24, 0x08	; 8
    17da:	a9 d6       	rcall	.+3410   	; 0x252e <xTaskRemoveFromEventList>
    17dc:	81 30       	cpi	r24, 0x01	; 1
    17de:	51 f4       	brne	.+20     	; 0x17f4 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    17e0:	4e de       	rcall	.-868    	; 0x147e <vPortYield>
    17e2:	08 c0       	rjmp	.+16     	; 0x17f4 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17e4:	ce 01       	movw	r24, r28
    17e6:	08 96       	adiw	r24, 0x08	; 8
    17e8:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    17ec:	ce 01       	movw	r24, r28
    17ee:	41 96       	adiw	r24, 0x11	; 17
    17f0:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    17f8:	81 e0       	ldi	r24, 0x01	; 1
    17fa:	df 91       	pop	r29
    17fc:	cf 91       	pop	r28
    17fe:	08 95       	ret

00001800 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1800:	0f 93       	push	r16
    1802:	1f 93       	push	r17
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
    1808:	18 2f       	mov	r17, r24
    180a:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    180c:	88 23       	and	r24, r24
    180e:	e9 f0       	breq	.+58     	; 0x184a <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1810:	8f e1       	ldi	r24, 0x1F	; 31
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	0e 94 0e 03 	call	0x61c	; 0x61c <pvPortMalloc>
    1818:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	c1 f0       	breq	.+48     	; 0x184e <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    181e:	10 9f       	mul	r17, r16
    1820:	c0 01       	movw	r24, r0
    1822:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1824:	01 96       	adiw	r24, 0x01	; 1
    1826:	0e 94 0e 03 	call	0x61c	; 0x61c <pvPortMalloc>
    182a:	99 83       	std	Y+1, r25	; 0x01
    182c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    182e:	89 2b       	or	r24, r25
    1830:	31 f0       	breq	.+12     	; 0x183e <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1832:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1834:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1836:	61 e0       	ldi	r22, 0x01	; 1
    1838:	ce 01       	movw	r24, r28
    183a:	a7 df       	rcall	.-178    	; 0x178a <xQueueGenericReset>
    183c:	08 c0       	rjmp	.+16     	; 0x184e <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    183e:	ce 01       	movw	r24, r28
    1840:	0e 94 43 03 	call	0x686	; 0x686 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1844:	c0 e0       	ldi	r28, 0x00	; 0
    1846:	d0 e0       	ldi	r29, 0x00	; 0
    1848:	02 c0       	rjmp	.+4      	; 0x184e <xQueueGenericCreate+0x4e>
    184a:	c0 e0       	ldi	r28, 0x00	; 0
    184c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    184e:	ce 01       	movw	r24, r28
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	1f 91       	pop	r17
    1856:	0f 91       	pop	r16
    1858:	08 95       	ret

0000185a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    185a:	9f 92       	push	r9
    185c:	af 92       	push	r10
    185e:	bf 92       	push	r11
    1860:	cf 92       	push	r12
    1862:	df 92       	push	r13
    1864:	ef 92       	push	r14
    1866:	ff 92       	push	r15
    1868:	0f 93       	push	r16
    186a:	1f 93       	push	r17
    186c:	cf 93       	push	r28
    186e:	df 93       	push	r29
    1870:	00 d0       	rcall	.+0      	; 0x1872 <xQueueGenericSend+0x18>
    1872:	1f 92       	push	r1
    1874:	1f 92       	push	r1
    1876:	cd b7       	in	r28, 0x3d	; 61
    1878:	de b7       	in	r29, 0x3e	; 62
    187a:	8c 01       	movw	r16, r24
    187c:	6b 01       	movw	r12, r22
    187e:	5d 83       	std	Y+5, r21	; 0x05
    1880:	4c 83       	std	Y+4, r20	; 0x04
    1882:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1884:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1886:	99 24       	eor	r9, r9
    1888:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    188a:	7c 01       	movw	r14, r24
    188c:	88 e0       	ldi	r24, 0x08	; 8
    188e:	e8 0e       	add	r14, r24
    1890:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1898:	f8 01       	movw	r30, r16
    189a:	92 8d       	ldd	r25, Z+26	; 0x1a
    189c:	83 8d       	ldd	r24, Z+27	; 0x1b
    189e:	98 17       	cp	r25, r24
    18a0:	18 f0       	brcs	.+6      	; 0x18a8 <xQueueGenericSend+0x4e>
    18a2:	f2 e0       	ldi	r31, 0x02	; 2
    18a4:	af 12       	cpse	r10, r31
    18a6:	15 c0       	rjmp	.+42     	; 0x18d2 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18a8:	4a 2d       	mov	r20, r10
    18aa:	b6 01       	movw	r22, r12
    18ac:	c8 01       	movw	r24, r16
    18ae:	ab de       	rcall	.-682    	; 0x1606 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18b0:	f8 01       	movw	r30, r16
    18b2:	91 89       	ldd	r25, Z+17	; 0x11
    18b4:	99 23       	and	r25, r25
    18b6:	39 f0       	breq	.+14     	; 0x18c6 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18b8:	c8 01       	movw	r24, r16
    18ba:	41 96       	adiw	r24, 0x11	; 17
    18bc:	38 d6       	rcall	.+3184   	; 0x252e <xTaskRemoveFromEventList>
    18be:	81 30       	cpi	r24, 0x01	; 1
    18c0:	21 f4       	brne	.+8      	; 0x18ca <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    18c2:	dd dd       	rcall	.-1094   	; 0x147e <vPortYield>
    18c4:	02 c0       	rjmp	.+4      	; 0x18ca <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    18c6:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    18c8:	da dd       	rcall	.-1100   	; 0x147e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    18ca:	0f 90       	pop	r0
    18cc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	46 c0       	rjmp	.+140    	; 0x195e <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18d2:	ec 81       	ldd	r30, Y+4	; 0x04
    18d4:	fd 81       	ldd	r31, Y+5	; 0x05
    18d6:	ef 2b       	or	r30, r31
    18d8:	21 f4       	brne	.+8      	; 0x18e2 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    18de:	80 e0       	ldi	r24, 0x00	; 0
    18e0:	3e c0       	rjmp	.+124    	; 0x195e <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    18e2:	b1 10       	cpse	r11, r1
    18e4:	04 c0       	rjmp	.+8      	; 0x18ee <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18e6:	ce 01       	movw	r24, r28
    18e8:	01 96       	adiw	r24, 0x01	; 1
    18ea:	69 d6       	rcall	.+3282   	; 0x25be <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18ec:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18ee:	0f 90       	pop	r0
    18f0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18f2:	7c d3       	rcall	.+1784   	; 0x1fec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
    18fa:	f8 01       	movw	r30, r16
    18fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    18fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1900:	09 f4       	brne	.+2      	; 0x1904 <xQueueGenericSend+0xaa>
    1902:	15 8e       	std	Z+29, r1	; 0x1d
    1904:	f8 01       	movw	r30, r16
    1906:	86 8d       	ldd	r24, Z+30	; 0x1e
    1908:	8f 3f       	cpi	r24, 0xFF	; 255
    190a:	09 f4       	brne	.+2      	; 0x190e <xQueueGenericSend+0xb4>
    190c:	16 8e       	std	Z+30, r1	; 0x1e
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1912:	be 01       	movw	r22, r28
    1914:	6c 5f       	subi	r22, 0xFC	; 252
    1916:	7f 4f       	sbci	r23, 0xFF	; 255
    1918:	ce 01       	movw	r24, r28
    191a:	01 96       	adiw	r24, 0x01	; 1
    191c:	5b d6       	rcall	.+3254   	; 0x25d4 <xTaskCheckForTimeOut>
    191e:	81 11       	cpse	r24, r1
    1920:	1a c0       	rjmp	.+52     	; 0x1956 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	f8 94       	cli
    1926:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1928:	f8 01       	movw	r30, r16
    192a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1930:	f8 01       	movw	r30, r16
    1932:	83 8d       	ldd	r24, Z+27	; 0x1b
    1934:	98 13       	cpse	r25, r24
    1936:	0b c0       	rjmp	.+22     	; 0x194e <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1938:	6c 81       	ldd	r22, Y+4	; 0x04
    193a:	7d 81       	ldd	r23, Y+5	; 0x05
    193c:	c7 01       	movw	r24, r14
    193e:	cc d5       	rcall	.+2968   	; 0x24d8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1940:	c8 01       	movw	r24, r16
    1942:	dd de       	rcall	.-582    	; 0x16fe <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1944:	26 d4       	rcall	.+2124   	; 0x2192 <xTaskResumeAll>
    1946:	81 11       	cpse	r24, r1
    1948:	a4 cf       	rjmp	.-184    	; 0x1892 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    194a:	99 dd       	rcall	.-1230   	; 0x147e <vPortYield>
    194c:	a2 cf       	rjmp	.-188    	; 0x1892 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    194e:	c8 01       	movw	r24, r16
    1950:	d6 de       	rcall	.-596    	; 0x16fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1952:	1f d4       	rcall	.+2110   	; 0x2192 <xTaskResumeAll>
    1954:	9e cf       	rjmp	.-196    	; 0x1892 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1956:	c8 01       	movw	r24, r16
    1958:	d2 de       	rcall	.-604    	; 0x16fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    195a:	1b d4       	rcall	.+2102   	; 0x2192 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    195c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
    1962:	0f 90       	pop	r0
    1964:	0f 90       	pop	r0
    1966:	0f 90       	pop	r0
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	df 90       	pop	r13
    1976:	cf 90       	pop	r12
    1978:	bf 90       	pop	r11
    197a:	af 90       	pop	r10
    197c:	9f 90       	pop	r9
    197e:	08 95       	ret

00001980 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1980:	cf 93       	push	r28
    1982:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1984:	8f e1       	ldi	r24, 0x1F	; 31
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	0e 94 0e 03 	call	0x61c	; 0x61c <pvPortMalloc>
    198c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    198e:	00 97       	sbiw	r24, 0x00	; 0
    1990:	f1 f0       	breq	.+60     	; 0x19ce <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1992:	1b 82       	std	Y+3, r1	; 0x03
    1994:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1996:	19 82       	std	Y+1, r1	; 0x01
    1998:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    199a:	1d 82       	std	Y+5, r1	; 0x05
    199c:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    199e:	1f 82       	std	Y+7, r1	; 0x07
    19a0:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19a2:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    19a8:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    19aa:	8f ef       	ldi	r24, 0xFF	; 255
    19ac:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    19ae:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19b0:	ce 01       	movw	r24, r28
    19b2:	08 96       	adiw	r24, 0x08	; 8
    19b4:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19b8:	ce 01       	movw	r24, r28
    19ba:	41 96       	adiw	r24, 0x11	; 17
    19bc:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    19c0:	20 e0       	ldi	r18, 0x00	; 0
    19c2:	40 e0       	ldi	r20, 0x00	; 0
    19c4:	50 e0       	ldi	r21, 0x00	; 0
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	70 e0       	ldi	r23, 0x00	; 0
    19ca:	ce 01       	movw	r24, r28
    19cc:	46 df       	rcall	.-372    	; 0x185a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    19ce:	ce 01       	movw	r24, r28
    19d0:	df 91       	pop	r29
    19d2:	cf 91       	pop	r28
    19d4:	08 95       	ret

000019d6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	ec 01       	movw	r28, r24
    19e0:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19e2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19e6:	98 17       	cp	r25, r24
    19e8:	10 f0       	brcs	.+4      	; 0x19ee <xQueueGenericSendFromISR+0x18>
    19ea:	22 30       	cpi	r18, 0x02	; 2
    19ec:	11 f5       	brne	.+68     	; 0x1a32 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    19ee:	42 2f       	mov	r20, r18
    19f0:	ce 01       	movw	r24, r28
    19f2:	09 de       	rcall	.-1006   	; 0x1606 <prvCopyDataToQueue>
    19f4:	88 23       	and	r24, r24
    19f6:	31 f0       	breq	.+12     	; 0x1a04 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    19f8:	01 15       	cp	r16, r1
    19fa:	11 05       	cpc	r17, r1
    19fc:	19 f0       	breq	.+6      	; 0x1a04 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    19fe:	81 e0       	ldi	r24, 0x01	; 1
    1a00:	f8 01       	movw	r30, r16
    1a02:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a04:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a06:	8f 3f       	cpi	r24, 0xFF	; 255
    1a08:	79 f4       	brne	.+30     	; 0x1a28 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a0a:	89 89       	ldd	r24, Y+17	; 0x11
    1a0c:	88 23       	and	r24, r24
    1a0e:	99 f0       	breq	.+38     	; 0x1a36 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a10:	ce 01       	movw	r24, r28
    1a12:	41 96       	adiw	r24, 0x11	; 17
    1a14:	8c d5       	rcall	.+2840   	; 0x252e <xTaskRemoveFromEventList>
    1a16:	88 23       	and	r24, r24
    1a18:	81 f0       	breq	.+32     	; 0x1a3a <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a1a:	01 15       	cp	r16, r1
    1a1c:	11 05       	cpc	r17, r1
    1a1e:	79 f0       	breq	.+30     	; 0x1a3e <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	f8 01       	movw	r30, r16
    1a24:	80 83       	st	Z, r24
    1a26:	0c c0       	rjmp	.+24     	; 0x1a40 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a28:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a2a:	8f 5f       	subi	r24, 0xFF	; 255
    1a2c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	07 c0       	rjmp	.+14     	; 0x1a40 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	05 c0       	rjmp	.+10     	; 0x1a40 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a36:	81 e0       	ldi	r24, 0x01	; 1
    1a38:	03 c0       	rjmp	.+6      	; 0x1a40 <xQueueGenericSendFromISR+0x6a>
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	01 c0       	rjmp	.+2      	; 0x1a40 <xQueueGenericSendFromISR+0x6a>
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a40:	df 91       	pop	r29
    1a42:	cf 91       	pop	r28
    1a44:	1f 91       	pop	r17
    1a46:	0f 91       	pop	r16
    1a48:	08 95       	ret

00001a4a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a4a:	9f 92       	push	r9
    1a4c:	af 92       	push	r10
    1a4e:	bf 92       	push	r11
    1a50:	cf 92       	push	r12
    1a52:	df 92       	push	r13
    1a54:	ef 92       	push	r14
    1a56:	ff 92       	push	r15
    1a58:	0f 93       	push	r16
    1a5a:	1f 93       	push	r17
    1a5c:	cf 93       	push	r28
    1a5e:	df 93       	push	r29
    1a60:	00 d0       	rcall	.+0      	; 0x1a62 <xQueueGenericReceive+0x18>
    1a62:	1f 92       	push	r1
    1a64:	1f 92       	push	r1
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	8c 01       	movw	r16, r24
    1a6c:	6b 01       	movw	r12, r22
    1a6e:	5d 83       	std	Y+5, r21	; 0x05
    1a70:	4c 83       	std	Y+4, r20	; 0x04
    1a72:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1a74:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1a76:	99 24       	eor	r9, r9
    1a78:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a7a:	7c 01       	movw	r14, r24
    1a7c:	81 e1       	ldi	r24, 0x11	; 17
    1a7e:	e8 0e       	add	r14, r24
    1a80:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a88:	f8 01       	movw	r30, r16
    1a8a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a8c:	88 23       	and	r24, r24
    1a8e:	69 f1       	breq	.+90     	; 0x1aea <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a90:	e6 80       	ldd	r14, Z+6	; 0x06
    1a92:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a94:	b6 01       	movw	r22, r12
    1a96:	c8 01       	movw	r24, r16
    1a98:	18 de       	rcall	.-976    	; 0x16ca <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a9a:	b1 10       	cpse	r11, r1
    1a9c:	17 c0       	rjmp	.+46     	; 0x1acc <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aa2:	81 50       	subi	r24, 0x01	; 1
    1aa4:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1aa6:	80 81       	ld	r24, Z
    1aa8:	91 81       	ldd	r25, Z+1	; 0x01
    1aaa:	89 2b       	or	r24, r25
    1aac:	21 f4       	brne	.+8      	; 0x1ab6 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1aae:	6b d6       	rcall	.+3286   	; 0x2786 <pvTaskIncrementMutexHeldCount>
    1ab0:	f8 01       	movw	r30, r16
    1ab2:	93 83       	std	Z+3, r25	; 0x03
    1ab4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	80 85       	ldd	r24, Z+8	; 0x08
    1aba:	88 23       	and	r24, r24
    1abc:	91 f0       	breq	.+36     	; 0x1ae2 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1abe:	c8 01       	movw	r24, r16
    1ac0:	08 96       	adiw	r24, 0x08	; 8
    1ac2:	35 d5       	rcall	.+2666   	; 0x252e <xTaskRemoveFromEventList>
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	69 f4       	brne	.+26     	; 0x1ae2 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1ac8:	da dc       	rcall	.-1612   	; 0x147e <vPortYield>
    1aca:	0b c0       	rjmp	.+22     	; 0x1ae2 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1acc:	f8 01       	movw	r30, r16
    1ace:	f7 82       	std	Z+7, r15	; 0x07
    1ad0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ad2:	81 89       	ldd	r24, Z+17	; 0x11
    1ad4:	88 23       	and	r24, r24
    1ad6:	29 f0       	breq	.+10     	; 0x1ae2 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ad8:	c8 01       	movw	r24, r16
    1ada:	41 96       	adiw	r24, 0x11	; 17
    1adc:	28 d5       	rcall	.+2640   	; 0x252e <xTaskRemoveFromEventList>
    1ade:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1ae0:	ce dc       	rcall	.-1636   	; 0x147e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	52 c0       	rjmp	.+164    	; 0x1b8e <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1aea:	4c 81       	ldd	r20, Y+4	; 0x04
    1aec:	5d 81       	ldd	r21, Y+5	; 0x05
    1aee:	45 2b       	or	r20, r21
    1af0:	21 f4       	brne	.+8      	; 0x1afa <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1af2:	0f 90       	pop	r0
    1af4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1af6:	80 e0       	ldi	r24, 0x00	; 0
    1af8:	4a c0       	rjmp	.+148    	; 0x1b8e <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1afa:	a1 10       	cpse	r10, r1
    1afc:	04 c0       	rjmp	.+8      	; 0x1b06 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1afe:	ce 01       	movw	r24, r28
    1b00:	01 96       	adiw	r24, 0x01	; 1
    1b02:	5d d5       	rcall	.+2746   	; 0x25be <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b04:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b06:	0f 90       	pop	r0
    1b08:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b0a:	70 d2       	rcall	.+1248   	; 0x1fec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b0c:	0f b6       	in	r0, 0x3f	; 63
    1b0e:	f8 94       	cli
    1b10:	0f 92       	push	r0
    1b12:	f8 01       	movw	r30, r16
    1b14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b16:	8f 3f       	cpi	r24, 0xFF	; 255
    1b18:	09 f4       	brne	.+2      	; 0x1b1c <xQueueGenericReceive+0xd2>
    1b1a:	15 8e       	std	Z+29, r1	; 0x1d
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b20:	8f 3f       	cpi	r24, 0xFF	; 255
    1b22:	09 f4       	brne	.+2      	; 0x1b26 <xQueueGenericReceive+0xdc>
    1b24:	16 8e       	std	Z+30, r1	; 0x1e
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b2a:	be 01       	movw	r22, r28
    1b2c:	6c 5f       	subi	r22, 0xFC	; 252
    1b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b30:	ce 01       	movw	r24, r28
    1b32:	01 96       	adiw	r24, 0x01	; 1
    1b34:	4f d5       	rcall	.+2718   	; 0x25d4 <xTaskCheckForTimeOut>
    1b36:	81 11       	cpse	r24, r1
    1b38:	26 c0       	rjmp	.+76     	; 0x1b86 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b40:	f8 01       	movw	r30, r16
    1b42:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b44:	0f 90       	pop	r0
    1b46:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b48:	81 11       	cpse	r24, r1
    1b4a:	19 c0       	rjmp	.+50     	; 0x1b7e <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b4c:	f8 01       	movw	r30, r16
    1b4e:	80 81       	ld	r24, Z
    1b50:	91 81       	ldd	r25, Z+1	; 0x01
    1b52:	89 2b       	or	r24, r25
    1b54:	49 f4       	brne	.+18     	; 0x1b68 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	f8 94       	cli
    1b5a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b5c:	f8 01       	movw	r30, r16
    1b5e:	82 81       	ldd	r24, Z+2	; 0x02
    1b60:	93 81       	ldd	r25, Z+3	; 0x03
    1b62:	74 d5       	rcall	.+2792   	; 0x264c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b64:	0f 90       	pop	r0
    1b66:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b68:	6c 81       	ldd	r22, Y+4	; 0x04
    1b6a:	7d 81       	ldd	r23, Y+5	; 0x05
    1b6c:	c7 01       	movw	r24, r14
    1b6e:	b4 d4       	rcall	.+2408   	; 0x24d8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b70:	c8 01       	movw	r24, r16
    1b72:	c5 dd       	rcall	.-1142   	; 0x16fe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b74:	0e d3       	rcall	.+1564   	; 0x2192 <xTaskResumeAll>
    1b76:	81 11       	cpse	r24, r1
    1b78:	84 cf       	rjmp	.-248    	; 0x1a82 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1b7a:	81 dc       	rcall	.-1790   	; 0x147e <vPortYield>
    1b7c:	82 cf       	rjmp	.-252    	; 0x1a82 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b7e:	c8 01       	movw	r24, r16
    1b80:	be dd       	rcall	.-1156   	; 0x16fe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b82:	07 d3       	rcall	.+1550   	; 0x2192 <xTaskResumeAll>
    1b84:	7e cf       	rjmp	.-260    	; 0x1a82 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b86:	c8 01       	movw	r24, r16
    1b88:	ba dd       	rcall	.-1164   	; 0x16fe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b8a:	03 d3       	rcall	.+1542   	; 0x2192 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b8e:	0f 90       	pop	r0
    1b90:	0f 90       	pop	r0
    1b92:	0f 90       	pop	r0
    1b94:	0f 90       	pop	r0
    1b96:	0f 90       	pop	r0
    1b98:	df 91       	pop	r29
    1b9a:	cf 91       	pop	r28
    1b9c:	1f 91       	pop	r17
    1b9e:	0f 91       	pop	r16
    1ba0:	ff 90       	pop	r15
    1ba2:	ef 90       	pop	r14
    1ba4:	df 90       	pop	r13
    1ba6:	cf 90       	pop	r12
    1ba8:	bf 90       	pop	r11
    1baa:	af 90       	pop	r10
    1bac:	9f 90       	pop	r9
    1bae:	08 95       	ret

00001bb0 <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	71 83       	std	Z+1, r23	; 0x01
    1bb4:	60 83       	st	Z, r22
    1bb6:	42 83       	std	Z+2, r20	; 0x02
    1bb8:	14 82       	std	Z+4, r1	; 0x04
    1bba:	13 82       	std	Z+3, r1	; 0x03
    1bbc:	08 95       	ret

00001bbe <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1bbe:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1bc0:	94 81       	ldd	r25, Z+4	; 0x04
    1bc2:	a0 81       	ld	r26, Z
    1bc4:	b1 81       	ldd	r27, Z+1	; 0x01
    1bc6:	a9 0f       	add	r26, r25
    1bc8:	b1 1d       	adc	r27, r1
    1bca:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1bcc:	9f 5f       	subi	r25, 0xFF	; 255
    1bce:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1bd0:	22 81       	ldd	r18, Z+2	; 0x02
    1bd2:	92 17       	cp	r25, r18
    1bd4:	10 f0       	brcs	.+4      	; 0x1bda <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1bd6:	92 1b       	sub	r25, r18
    1bd8:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1bda:	93 81       	ldd	r25, Z+3	; 0x03
    1bdc:	91 50       	subi	r25, 0x01	; 1
    1bde:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1be0:	08 95       	ret

00001be2 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1be2:	fc 01       	movw	r30, r24
    1be4:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1be6:	83 81       	ldd	r24, Z+3	; 0x03
    1be8:	22 81       	ldd	r18, Z+2	; 0x02
    1bea:	82 17       	cp	r24, r18
    1bec:	80 f4       	brcc	.+32     	; 0x1c0e <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1bee:	34 81       	ldd	r19, Z+4	; 0x04
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	83 0f       	add	r24, r19
    1bf4:	91 1d       	adc	r25, r1
    1bf6:	62 2f       	mov	r22, r18
    1bf8:	70 e0       	ldi	r23, 0x00	; 0
    1bfa:	0e 94 29 17 	call	0x2e52	; 0x2e52 <__divmodhi4>
    1bfe:	a0 81       	ld	r26, Z
    1c00:	b1 81       	ldd	r27, Z+1	; 0x01
    1c02:	a8 0f       	add	r26, r24
    1c04:	b9 1f       	adc	r27, r25
    1c06:	4c 93       	st	X, r20
            ring->rLength++;
    1c08:	83 81       	ldd	r24, Z+3	; 0x03
    1c0a:	8f 5f       	subi	r24, 0xFF	; 255
    1c0c:	83 83       	std	Z+3, r24	; 0x03
    1c0e:	08 95       	ret

00001c10 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c10:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	22 81       	ldd	r18, Z+2	; 0x02
    1c16:	93 81       	ldd	r25, Z+3	; 0x03
    1c18:	29 13       	cpse	r18, r25
    1c1a:	80 e0       	ldi	r24, 0x00	; 0
}
    1c1c:	08 95       	ret

00001c1e <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c1e:	21 e0       	ldi	r18, 0x01	; 1
    1c20:	fc 01       	movw	r30, r24
    1c22:	83 81       	ldd	r24, Z+3	; 0x03
    1c24:	81 11       	cpse	r24, r1
    1c26:	01 c0       	rjmp	.+2      	; 0x1c2a <ringBufferNotEmpty+0xc>
    1c28:	20 e0       	ldi	r18, 0x00	; 0
}
    1c2a:	82 2f       	mov	r24, r18
    1c2c:	08 95       	ret

00001c2e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c2e:	e0 91 50 08 	lds	r30, 0x0850
    1c32:	f0 91 51 08 	lds	r31, 0x0851
    1c36:	80 81       	ld	r24, Z
    1c38:	81 11       	cpse	r24, r1
    1c3a:	07 c0       	rjmp	.+14     	; 0x1c4a <prvResetNextTaskUnblockTime+0x1c>
    1c3c:	8f ef       	ldi	r24, 0xFF	; 255
    1c3e:	9f ef       	ldi	r25, 0xFF	; 255
    1c40:	90 93 06 02 	sts	0x0206, r25
    1c44:	80 93 05 02 	sts	0x0205, r24
    1c48:	08 95       	ret
    1c4a:	e0 91 50 08 	lds	r30, 0x0850
    1c4e:	f0 91 51 08 	lds	r31, 0x0851
    1c52:	05 80       	ldd	r0, Z+5	; 0x05
    1c54:	f6 81       	ldd	r31, Z+6	; 0x06
    1c56:	e0 2d       	mov	r30, r0
    1c58:	06 80       	ldd	r0, Z+6	; 0x06
    1c5a:	f7 81       	ldd	r31, Z+7	; 0x07
    1c5c:	e0 2d       	mov	r30, r0
    1c5e:	82 81       	ldd	r24, Z+2	; 0x02
    1c60:	93 81       	ldd	r25, Z+3	; 0x03
    1c62:	90 93 06 02 	sts	0x0206, r25
    1c66:	80 93 05 02 	sts	0x0205, r24
    1c6a:	08 95       	ret

00001c6c <prvAddCurrentTaskToDelayedList>:
    1c6c:	cf 93       	push	r28
    1c6e:	df 93       	push	r29
    1c70:	ec 01       	movw	r28, r24
    1c72:	e0 91 91 08 	lds	r30, 0x0891
    1c76:	f0 91 92 08 	lds	r31, 0x0892
    1c7a:	93 83       	std	Z+3, r25	; 0x03
    1c7c:	82 83       	std	Z+2, r24	; 0x02
    1c7e:	80 91 2f 08 	lds	r24, 0x082F
    1c82:	90 91 30 08 	lds	r25, 0x0830
    1c86:	c8 17       	cp	r28, r24
    1c88:	d9 07       	cpc	r29, r25
    1c8a:	68 f4       	brcc	.+26     	; 0x1ca6 <prvAddCurrentTaskToDelayedList+0x3a>
    1c8c:	60 91 91 08 	lds	r22, 0x0891
    1c90:	70 91 92 08 	lds	r23, 0x0892
    1c94:	80 91 4e 08 	lds	r24, 0x084E
    1c98:	90 91 4f 08 	lds	r25, 0x084F
    1c9c:	6e 5f       	subi	r22, 0xFE	; 254
    1c9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca0:	0e 94 77 03 	call	0x6ee	; 0x6ee <vListInsert>
    1ca4:	17 c0       	rjmp	.+46     	; 0x1cd4 <prvAddCurrentTaskToDelayedList+0x68>
    1ca6:	60 91 91 08 	lds	r22, 0x0891
    1caa:	70 91 92 08 	lds	r23, 0x0892
    1cae:	80 91 50 08 	lds	r24, 0x0850
    1cb2:	90 91 51 08 	lds	r25, 0x0851
    1cb6:	6e 5f       	subi	r22, 0xFE	; 254
    1cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1cba:	0e 94 77 03 	call	0x6ee	; 0x6ee <vListInsert>
    1cbe:	80 91 05 02 	lds	r24, 0x0205
    1cc2:	90 91 06 02 	lds	r25, 0x0206
    1cc6:	c8 17       	cp	r28, r24
    1cc8:	d9 07       	cpc	r29, r25
    1cca:	20 f4       	brcc	.+8      	; 0x1cd4 <prvAddCurrentTaskToDelayedList+0x68>
    1ccc:	d0 93 06 02 	sts	0x0206, r29
    1cd0:	c0 93 05 02 	sts	0x0205, r28
    1cd4:	df 91       	pop	r29
    1cd6:	cf 91       	pop	r28
    1cd8:	08 95       	ret

00001cda <xTaskGenericCreate>:
    1cda:	4f 92       	push	r4
    1cdc:	5f 92       	push	r5
    1cde:	6f 92       	push	r6
    1ce0:	7f 92       	push	r7
    1ce2:	8f 92       	push	r8
    1ce4:	9f 92       	push	r9
    1ce6:	af 92       	push	r10
    1ce8:	bf 92       	push	r11
    1cea:	cf 92       	push	r12
    1cec:	df 92       	push	r13
    1cee:	ef 92       	push	r14
    1cf0:	ff 92       	push	r15
    1cf2:	0f 93       	push	r16
    1cf4:	1f 93       	push	r17
    1cf6:	cf 93       	push	r28
    1cf8:	df 93       	push	r29
    1cfa:	4c 01       	movw	r8, r24
    1cfc:	5b 01       	movw	r10, r22
    1cfe:	2a 01       	movw	r4, r20
    1d00:	39 01       	movw	r6, r18
    1d02:	83 e2       	ldi	r24, 0x23	; 35
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	0e 94 0e 03 	call	0x61c	; 0x61c <pvPortMalloc>
    1d0a:	ec 01       	movw	r28, r24
    1d0c:	00 97       	sbiw	r24, 0x00	; 0
    1d0e:	09 f4       	brne	.+2      	; 0x1d12 <xTaskGenericCreate+0x38>
    1d10:	e7 c0       	rjmp	.+462    	; 0x1ee0 <xTaskGenericCreate+0x206>
    1d12:	c1 14       	cp	r12, r1
    1d14:	d1 04       	cpc	r13, r1
    1d16:	09 f0       	breq	.+2      	; 0x1d1a <xTaskGenericCreate+0x40>
    1d18:	cc c0       	rjmp	.+408    	; 0x1eb2 <xTaskGenericCreate+0x1d8>
    1d1a:	c2 01       	movw	r24, r4
    1d1c:	0e 94 0e 03 	call	0x61c	; 0x61c <pvPortMalloc>
    1d20:	98 8f       	std	Y+24, r25	; 0x18
    1d22:	8f 8b       	std	Y+23, r24	; 0x17
    1d24:	89 2b       	or	r24, r25
    1d26:	09 f0       	breq	.+2      	; 0x1d2a <xTaskGenericCreate+0x50>
    1d28:	c6 c0       	rjmp	.+396    	; 0x1eb6 <xTaskGenericCreate+0x1dc>
    1d2a:	ce 01       	movw	r24, r28
    1d2c:	0e 94 43 03 	call	0x686	; 0x686 <vPortFree>
    1d30:	d7 c0       	rjmp	.+430    	; 0x1ee0 <xTaskGenericCreate+0x206>
    1d32:	cf 01       	movw	r24, r30
    1d34:	31 91       	ld	r19, Z+
    1d36:	da 01       	movw	r26, r20
    1d38:	3d 93       	st	X+, r19
    1d3a:	ad 01       	movw	r20, r26
    1d3c:	dc 01       	movw	r26, r24
    1d3e:	8c 91       	ld	r24, X
    1d40:	88 23       	and	r24, r24
    1d42:	11 f0       	breq	.+4      	; 0x1d48 <xTaskGenericCreate+0x6e>
    1d44:	21 50       	subi	r18, 0x01	; 1
    1d46:	a9 f7       	brne	.-22     	; 0x1d32 <xTaskGenericCreate+0x58>
    1d48:	18 a2       	std	Y+32, r1	; 0x20
    1d4a:	10 2f       	mov	r17, r16
    1d4c:	05 30       	cpi	r16, 0x05	; 5
    1d4e:	08 f0       	brcs	.+2      	; 0x1d52 <xTaskGenericCreate+0x78>
    1d50:	14 e0       	ldi	r17, 0x04	; 4
    1d52:	1e 8b       	std	Y+22, r17	; 0x16
    1d54:	19 a3       	std	Y+33, r17	; 0x21
    1d56:	1a a2       	std	Y+34, r1	; 0x22
    1d58:	5e 01       	movw	r10, r28
    1d5a:	b2 e0       	ldi	r27, 0x02	; 2
    1d5c:	ab 0e       	add	r10, r27
    1d5e:	b1 1c       	adc	r11, r1
    1d60:	c5 01       	movw	r24, r10
    1d62:	0e 94 52 03 	call	0x6a4	; 0x6a4 <vListInitialiseItem>
    1d66:	ce 01       	movw	r24, r28
    1d68:	0c 96       	adiw	r24, 0x0c	; 12
    1d6a:	0e 94 52 03 	call	0x6a4	; 0x6a4 <vListInitialiseItem>
    1d6e:	d9 87       	std	Y+9, r29	; 0x09
    1d70:	c8 87       	std	Y+8, r28	; 0x08
    1d72:	85 e0       	ldi	r24, 0x05	; 5
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	81 1b       	sub	r24, r17
    1d78:	91 09       	sbc	r25, r1
    1d7a:	9d 87       	std	Y+13, r25	; 0x0d
    1d7c:	8c 87       	std	Y+12, r24	; 0x0c
    1d7e:	db 8b       	std	Y+19, r29	; 0x13
    1d80:	ca 8b       	std	Y+18, r28	; 0x12
    1d82:	a3 01       	movw	r20, r6
    1d84:	b4 01       	movw	r22, r8
    1d86:	c6 01       	movw	r24, r12
    1d88:	cb da       	rcall	.-2666   	; 0x1320 <pxPortInitialiseStack>
    1d8a:	99 83       	std	Y+1, r25	; 0x01
    1d8c:	88 83       	st	Y, r24
    1d8e:	e1 14       	cp	r14, r1
    1d90:	f1 04       	cpc	r15, r1
    1d92:	19 f0       	breq	.+6      	; 0x1d9a <xTaskGenericCreate+0xc0>
    1d94:	f7 01       	movw	r30, r14
    1d96:	d1 83       	std	Z+1, r29	; 0x01
    1d98:	c0 83       	st	Z, r28
    1d9a:	0f b6       	in	r0, 0x3f	; 63
    1d9c:	f8 94       	cli
    1d9e:	0f 92       	push	r0
    1da0:	80 91 31 08 	lds	r24, 0x0831
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	80 93 31 08 	sts	0x0831, r24
    1daa:	80 91 91 08 	lds	r24, 0x0891
    1dae:	90 91 92 08 	lds	r25, 0x0892
    1db2:	89 2b       	or	r24, r25
    1db4:	09 f0       	breq	.+2      	; 0x1db8 <xTaskGenericCreate+0xde>
    1db6:	3f c0       	rjmp	.+126    	; 0x1e36 <xTaskGenericCreate+0x15c>
    1db8:	d0 93 92 08 	sts	0x0892, r29
    1dbc:	c0 93 91 08 	sts	0x0891, r28
    1dc0:	80 91 31 08 	lds	r24, 0x0831
    1dc4:	81 30       	cpi	r24, 0x01	; 1
    1dc6:	09 f0       	breq	.+2      	; 0x1dca <xTaskGenericCreate+0xf0>
    1dc8:	45 c0       	rjmp	.+138    	; 0x1e54 <xTaskGenericCreate+0x17a>
    1dca:	0f 2e       	mov	r0, r31
    1dcc:	f4 e6       	ldi	r31, 0x64	; 100
    1dce:	ef 2e       	mov	r14, r31
    1dd0:	f8 e0       	ldi	r31, 0x08	; 8
    1dd2:	ff 2e       	mov	r15, r31
    1dd4:	f0 2d       	mov	r31, r0
    1dd6:	0f 2e       	mov	r0, r31
    1dd8:	f1 e9       	ldi	r31, 0x91	; 145
    1dda:	cf 2e       	mov	r12, r31
    1ddc:	f8 e0       	ldi	r31, 0x08	; 8
    1dde:	df 2e       	mov	r13, r31
    1de0:	f0 2d       	mov	r31, r0
    1de2:	c7 01       	movw	r24, r14
    1de4:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1de8:	f9 e0       	ldi	r31, 0x09	; 9
    1dea:	ef 0e       	add	r14, r31
    1dec:	f1 1c       	adc	r15, r1
    1dee:	ec 14       	cp	r14, r12
    1df0:	fd 04       	cpc	r15, r13
    1df2:	b9 f7       	brne	.-18     	; 0x1de2 <xTaskGenericCreate+0x108>
    1df4:	8b e5       	ldi	r24, 0x5B	; 91
    1df6:	98 e0       	ldi	r25, 0x08	; 8
    1df8:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1dfc:	82 e5       	ldi	r24, 0x52	; 82
    1dfe:	98 e0       	ldi	r25, 0x08	; 8
    1e00:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1e04:	85 e4       	ldi	r24, 0x45	; 69
    1e06:	98 e0       	ldi	r25, 0x08	; 8
    1e08:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1e0c:	8c e3       	ldi	r24, 0x3C	; 60
    1e0e:	98 e0       	ldi	r25, 0x08	; 8
    1e10:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1e14:	82 e3       	ldi	r24, 0x32	; 50
    1e16:	98 e0       	ldi	r25, 0x08	; 8
    1e18:	0e 94 44 03 	call	0x688	; 0x688 <vListInitialise>
    1e1c:	8b e5       	ldi	r24, 0x5B	; 91
    1e1e:	98 e0       	ldi	r25, 0x08	; 8
    1e20:	90 93 51 08 	sts	0x0851, r25
    1e24:	80 93 50 08 	sts	0x0850, r24
    1e28:	82 e5       	ldi	r24, 0x52	; 82
    1e2a:	98 e0       	ldi	r25, 0x08	; 8
    1e2c:	90 93 4f 08 	sts	0x084F, r25
    1e30:	80 93 4e 08 	sts	0x084E, r24
    1e34:	0f c0       	rjmp	.+30     	; 0x1e54 <xTaskGenericCreate+0x17a>
    1e36:	80 91 2d 08 	lds	r24, 0x082D
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	0b c0       	rjmp	.+22     	; 0x1e54 <xTaskGenericCreate+0x17a>
    1e3e:	e0 91 91 08 	lds	r30, 0x0891
    1e42:	f0 91 92 08 	lds	r31, 0x0892
    1e46:	86 89       	ldd	r24, Z+22	; 0x16
    1e48:	08 17       	cp	r16, r24
    1e4a:	20 f0       	brcs	.+8      	; 0x1e54 <xTaskGenericCreate+0x17a>
    1e4c:	d0 93 92 08 	sts	0x0892, r29
    1e50:	c0 93 91 08 	sts	0x0891, r28
    1e54:	80 91 29 08 	lds	r24, 0x0829
    1e58:	8f 5f       	subi	r24, 0xFF	; 255
    1e5a:	80 93 29 08 	sts	0x0829, r24
    1e5e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e60:	90 91 2e 08 	lds	r25, 0x082E
    1e64:	98 17       	cp	r25, r24
    1e66:	10 f4       	brcc	.+4      	; 0x1e6c <xTaskGenericCreate+0x192>
    1e68:	80 93 2e 08 	sts	0x082E, r24
    1e6c:	90 e0       	ldi	r25, 0x00	; 0
    1e6e:	9c 01       	movw	r18, r24
    1e70:	22 0f       	add	r18, r18
    1e72:	33 1f       	adc	r19, r19
    1e74:	22 0f       	add	r18, r18
    1e76:	33 1f       	adc	r19, r19
    1e78:	22 0f       	add	r18, r18
    1e7a:	33 1f       	adc	r19, r19
    1e7c:	82 0f       	add	r24, r18
    1e7e:	93 1f       	adc	r25, r19
    1e80:	b5 01       	movw	r22, r10
    1e82:	8c 59       	subi	r24, 0x9C	; 156
    1e84:	97 4f       	sbci	r25, 0xF7	; 247
    1e86:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    1e8a:	0f 90       	pop	r0
    1e8c:	0f be       	out	0x3f, r0	; 63
    1e8e:	80 91 2d 08 	lds	r24, 0x082D
    1e92:	88 23       	and	r24, r24
    1e94:	51 f0       	breq	.+20     	; 0x1eaa <xTaskGenericCreate+0x1d0>
    1e96:	e0 91 91 08 	lds	r30, 0x0891
    1e9a:	f0 91 92 08 	lds	r31, 0x0892
    1e9e:	86 89       	ldd	r24, Z+22	; 0x16
    1ea0:	80 17       	cp	r24, r16
    1ea2:	28 f4       	brcc	.+10     	; 0x1eae <xTaskGenericCreate+0x1d4>
    1ea4:	ec da       	rcall	.-2600   	; 0x147e <vPortYield>
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	1c c0       	rjmp	.+56     	; 0x1ee2 <xTaskGenericCreate+0x208>
    1eaa:	81 e0       	ldi	r24, 0x01	; 1
    1eac:	1a c0       	rjmp	.+52     	; 0x1ee2 <xTaskGenericCreate+0x208>
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	18 c0       	rjmp	.+48     	; 0x1ee2 <xTaskGenericCreate+0x208>
    1eb2:	d8 8e       	std	Y+24, r13	; 0x18
    1eb4:	cf 8a       	std	Y+23, r12	; 0x17
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	48 1a       	sub	r4, r24
    1eba:	51 08       	sbc	r5, r1
    1ebc:	cf 88       	ldd	r12, Y+23	; 0x17
    1ebe:	d8 8c       	ldd	r13, Y+24	; 0x18
    1ec0:	c4 0c       	add	r12, r4
    1ec2:	d5 1c       	adc	r13, r5
    1ec4:	d5 01       	movw	r26, r10
    1ec6:	8c 91       	ld	r24, X
    1ec8:	89 8f       	std	Y+25, r24	; 0x19
    1eca:	8c 91       	ld	r24, X
    1ecc:	88 23       	and	r24, r24
    1ece:	09 f4       	brne	.+2      	; 0x1ed2 <xTaskGenericCreate+0x1f8>
    1ed0:	3b cf       	rjmp	.-394    	; 0x1d48 <xTaskGenericCreate+0x6e>
    1ed2:	ae 01       	movw	r20, r28
    1ed4:	46 5e       	subi	r20, 0xE6	; 230
    1ed6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ed8:	f5 01       	movw	r30, r10
    1eda:	31 96       	adiw	r30, 0x01	; 1
    1edc:	27 e0       	ldi	r18, 0x07	; 7
    1ede:	29 cf       	rjmp	.-430    	; 0x1d32 <xTaskGenericCreate+0x58>
    1ee0:	8f ef       	ldi	r24, 0xFF	; 255
    1ee2:	df 91       	pop	r29
    1ee4:	cf 91       	pop	r28
    1ee6:	1f 91       	pop	r17
    1ee8:	0f 91       	pop	r16
    1eea:	ff 90       	pop	r15
    1eec:	ef 90       	pop	r14
    1eee:	df 90       	pop	r13
    1ef0:	cf 90       	pop	r12
    1ef2:	bf 90       	pop	r11
    1ef4:	af 90       	pop	r10
    1ef6:	9f 90       	pop	r9
    1ef8:	8f 90       	pop	r8
    1efa:	7f 90       	pop	r7
    1efc:	6f 90       	pop	r6
    1efe:	5f 90       	pop	r5
    1f00:	4f 90       	pop	r4
    1f02:	08 95       	ret

00001f04 <vTaskResume>:
    1f04:	0f 93       	push	r16
    1f06:	1f 93       	push	r17
    1f08:	cf 93       	push	r28
    1f0a:	df 93       	push	r29
    1f0c:	ec 01       	movw	r28, r24
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	09 f4       	brne	.+2      	; 0x1f14 <vTaskResume+0x10>
    1f12:	3e c0       	rjmp	.+124    	; 0x1f90 <vTaskResume+0x8c>
    1f14:	80 91 91 08 	lds	r24, 0x0891
    1f18:	90 91 92 08 	lds	r25, 0x0892
    1f1c:	c8 17       	cp	r28, r24
    1f1e:	d9 07       	cpc	r29, r25
    1f20:	b9 f1       	breq	.+110    	; 0x1f90 <vTaskResume+0x8c>
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
    1f28:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f2c:	82 53       	subi	r24, 0x32	; 50
    1f2e:	98 40       	sbci	r25, 0x08	; 8
    1f30:	69 f5       	brne	.+90     	; 0x1f8c <vTaskResume+0x88>
    1f32:	8c 89       	ldd	r24, Y+20	; 0x14
    1f34:	9d 89       	ldd	r25, Y+21	; 0x15
    1f36:	28 e0       	ldi	r18, 0x08	; 8
    1f38:	85 34       	cpi	r24, 0x45	; 69
    1f3a:	92 07       	cpc	r25, r18
    1f3c:	39 f1       	breq	.+78     	; 0x1f8c <vTaskResume+0x88>
    1f3e:	89 2b       	or	r24, r25
    1f40:	29 f5       	brne	.+74     	; 0x1f8c <vTaskResume+0x88>
    1f42:	8e 01       	movw	r16, r28
    1f44:	0e 5f       	subi	r16, 0xFE	; 254
    1f46:	1f 4f       	sbci	r17, 0xFF	; 255
    1f48:	c8 01       	movw	r24, r16
    1f4a:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    1f4e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f50:	90 91 2e 08 	lds	r25, 0x082E
    1f54:	98 17       	cp	r25, r24
    1f56:	10 f4       	brcc	.+4      	; 0x1f5c <vTaskResume+0x58>
    1f58:	80 93 2e 08 	sts	0x082E, r24
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	9c 01       	movw	r18, r24
    1f60:	22 0f       	add	r18, r18
    1f62:	33 1f       	adc	r19, r19
    1f64:	22 0f       	add	r18, r18
    1f66:	33 1f       	adc	r19, r19
    1f68:	22 0f       	add	r18, r18
    1f6a:	33 1f       	adc	r19, r19
    1f6c:	82 0f       	add	r24, r18
    1f6e:	93 1f       	adc	r25, r19
    1f70:	b8 01       	movw	r22, r16
    1f72:	8c 59       	subi	r24, 0x9C	; 156
    1f74:	97 4f       	sbci	r25, 0xF7	; 247
    1f76:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    1f7a:	e0 91 91 08 	lds	r30, 0x0891
    1f7e:	f0 91 92 08 	lds	r31, 0x0892
    1f82:	9e 89       	ldd	r25, Y+22	; 0x16
    1f84:	86 89       	ldd	r24, Z+22	; 0x16
    1f86:	98 17       	cp	r25, r24
    1f88:	08 f0       	brcs	.+2      	; 0x1f8c <vTaskResume+0x88>
    1f8a:	79 da       	rcall	.-2830   	; 0x147e <vPortYield>
    1f8c:	0f 90       	pop	r0
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	df 91       	pop	r29
    1f92:	cf 91       	pop	r28
    1f94:	1f 91       	pop	r17
    1f96:	0f 91       	pop	r16
    1f98:	08 95       	ret

00001f9a <vTaskStartScheduler>:
    1f9a:	af 92       	push	r10
    1f9c:	bf 92       	push	r11
    1f9e:	cf 92       	push	r12
    1fa0:	df 92       	push	r13
    1fa2:	ef 92       	push	r14
    1fa4:	ff 92       	push	r15
    1fa6:	0f 93       	push	r16
    1fa8:	a1 2c       	mov	r10, r1
    1faa:	b1 2c       	mov	r11, r1
    1fac:	c1 2c       	mov	r12, r1
    1fae:	d1 2c       	mov	r13, r1
    1fb0:	e1 2c       	mov	r14, r1
    1fb2:	f1 2c       	mov	r15, r1
    1fb4:	00 e0       	ldi	r16, 0x00	; 0
    1fb6:	20 e0       	ldi	r18, 0x00	; 0
    1fb8:	30 e0       	ldi	r19, 0x00	; 0
    1fba:	45 e5       	ldi	r20, 0x55	; 85
    1fbc:	50 e0       	ldi	r21, 0x00	; 0
    1fbe:	63 e3       	ldi	r22, 0x33	; 51
    1fc0:	72 e0       	ldi	r23, 0x02	; 2
    1fc2:	88 e8       	ldi	r24, 0x88	; 136
    1fc4:	91 e1       	ldi	r25, 0x11	; 17
    1fc6:	89 de       	rcall	.-750    	; 0x1cda <xTaskGenericCreate>
    1fc8:	81 30       	cpi	r24, 0x01	; 1
    1fca:	41 f4       	brne	.+16     	; 0x1fdc <vTaskStartScheduler+0x42>
    1fcc:	f8 94       	cli
    1fce:	80 93 2d 08 	sts	0x082D, r24
    1fd2:	10 92 30 08 	sts	0x0830, r1
    1fd6:	10 92 2f 08 	sts	0x082F, r1
    1fda:	14 da       	rcall	.-3032   	; 0x1404 <xPortStartScheduler>
    1fdc:	0f 91       	pop	r16
    1fde:	ff 90       	pop	r15
    1fe0:	ef 90       	pop	r14
    1fe2:	df 90       	pop	r13
    1fe4:	cf 90       	pop	r12
    1fe6:	bf 90       	pop	r11
    1fe8:	af 90       	pop	r10
    1fea:	08 95       	ret

00001fec <vTaskSuspendAll>:
    1fec:	80 91 28 08 	lds	r24, 0x0828
    1ff0:	8f 5f       	subi	r24, 0xFF	; 255
    1ff2:	80 93 28 08 	sts	0x0828, r24
    1ff6:	08 95       	ret

00001ff8 <xTaskGetTickCount>:
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	0f 92       	push	r0
    1ffe:	80 91 2f 08 	lds	r24, 0x082F
    2002:	90 91 30 08 	lds	r25, 0x0830
    2006:	0f 90       	pop	r0
    2008:	0f be       	out	0x3f, r0	; 63
    200a:	08 95       	ret

0000200c <xTaskGetTickCountFromISR>:
    200c:	80 91 2f 08 	lds	r24, 0x082F
    2010:	90 91 30 08 	lds	r25, 0x0830
    2014:	08 95       	ret

00002016 <xTaskIncrementTick>:
    2016:	cf 92       	push	r12
    2018:	df 92       	push	r13
    201a:	ef 92       	push	r14
    201c:	ff 92       	push	r15
    201e:	0f 93       	push	r16
    2020:	1f 93       	push	r17
    2022:	cf 93       	push	r28
    2024:	df 93       	push	r29
    2026:	80 91 28 08 	lds	r24, 0x0828
    202a:	81 11       	cpse	r24, r1
    202c:	99 c0       	rjmp	.+306    	; 0x2160 <xTaskIncrementTick+0x14a>
    202e:	80 91 2f 08 	lds	r24, 0x082F
    2032:	90 91 30 08 	lds	r25, 0x0830
    2036:	01 96       	adiw	r24, 0x01	; 1
    2038:	90 93 30 08 	sts	0x0830, r25
    203c:	80 93 2f 08 	sts	0x082F, r24
    2040:	e0 90 2f 08 	lds	r14, 0x082F
    2044:	f0 90 30 08 	lds	r15, 0x0830
    2048:	e1 14       	cp	r14, r1
    204a:	f1 04       	cpc	r15, r1
    204c:	b1 f4       	brne	.+44     	; 0x207a <xTaskIncrementTick+0x64>
    204e:	80 91 50 08 	lds	r24, 0x0850
    2052:	90 91 51 08 	lds	r25, 0x0851
    2056:	20 91 4e 08 	lds	r18, 0x084E
    205a:	30 91 4f 08 	lds	r19, 0x084F
    205e:	30 93 51 08 	sts	0x0851, r19
    2062:	20 93 50 08 	sts	0x0850, r18
    2066:	90 93 4f 08 	sts	0x084F, r25
    206a:	80 93 4e 08 	sts	0x084E, r24
    206e:	80 91 2a 08 	lds	r24, 0x082A
    2072:	8f 5f       	subi	r24, 0xFF	; 255
    2074:	80 93 2a 08 	sts	0x082A, r24
    2078:	da dd       	rcall	.-1100   	; 0x1c2e <prvResetNextTaskUnblockTime>
    207a:	80 91 05 02 	lds	r24, 0x0205
    207e:	90 91 06 02 	lds	r25, 0x0206
    2082:	e8 16       	cp	r14, r24
    2084:	f9 06       	cpc	r15, r25
    2086:	08 f4       	brcc	.+2      	; 0x208a <xTaskIncrementTick+0x74>
    2088:	54 c0       	rjmp	.+168    	; 0x2132 <xTaskIncrementTick+0x11c>
    208a:	d1 2c       	mov	r13, r1
    208c:	cc 24       	eor	r12, r12
    208e:	c3 94       	inc	r12
    2090:	01 c0       	rjmp	.+2      	; 0x2094 <xTaskIncrementTick+0x7e>
    2092:	dc 2c       	mov	r13, r12
    2094:	e0 91 50 08 	lds	r30, 0x0850
    2098:	f0 91 51 08 	lds	r31, 0x0851
    209c:	80 81       	ld	r24, Z
    209e:	81 11       	cpse	r24, r1
    20a0:	07 c0       	rjmp	.+14     	; 0x20b0 <xTaskIncrementTick+0x9a>
    20a2:	8f ef       	ldi	r24, 0xFF	; 255
    20a4:	9f ef       	ldi	r25, 0xFF	; 255
    20a6:	90 93 06 02 	sts	0x0206, r25
    20aa:	80 93 05 02 	sts	0x0205, r24
    20ae:	42 c0       	rjmp	.+132    	; 0x2134 <xTaskIncrementTick+0x11e>
    20b0:	e0 91 50 08 	lds	r30, 0x0850
    20b4:	f0 91 51 08 	lds	r31, 0x0851
    20b8:	05 80       	ldd	r0, Z+5	; 0x05
    20ba:	f6 81       	ldd	r31, Z+6	; 0x06
    20bc:	e0 2d       	mov	r30, r0
    20be:	c6 81       	ldd	r28, Z+6	; 0x06
    20c0:	d7 81       	ldd	r29, Z+7	; 0x07
    20c2:	2a 81       	ldd	r18, Y+2	; 0x02
    20c4:	3b 81       	ldd	r19, Y+3	; 0x03
    20c6:	e2 16       	cp	r14, r18
    20c8:	f3 06       	cpc	r15, r19
    20ca:	28 f4       	brcc	.+10     	; 0x20d6 <xTaskIncrementTick+0xc0>
    20cc:	30 93 06 02 	sts	0x0206, r19
    20d0:	20 93 05 02 	sts	0x0205, r18
    20d4:	2f c0       	rjmp	.+94     	; 0x2134 <xTaskIncrementTick+0x11e>
    20d6:	8e 01       	movw	r16, r28
    20d8:	0e 5f       	subi	r16, 0xFE	; 254
    20da:	1f 4f       	sbci	r17, 0xFF	; 255
    20dc:	c8 01       	movw	r24, r16
    20de:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    20e2:	8c 89       	ldd	r24, Y+20	; 0x14
    20e4:	9d 89       	ldd	r25, Y+21	; 0x15
    20e6:	89 2b       	or	r24, r25
    20e8:	21 f0       	breq	.+8      	; 0x20f2 <xTaskIncrementTick+0xdc>
    20ea:	ce 01       	movw	r24, r28
    20ec:	0c 96       	adiw	r24, 0x0c	; 12
    20ee:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    20f2:	2e 89       	ldd	r18, Y+22	; 0x16
    20f4:	80 91 2e 08 	lds	r24, 0x082E
    20f8:	82 17       	cp	r24, r18
    20fa:	10 f4       	brcc	.+4      	; 0x2100 <xTaskIncrementTick+0xea>
    20fc:	20 93 2e 08 	sts	0x082E, r18
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	c9 01       	movw	r24, r18
    2104:	88 0f       	add	r24, r24
    2106:	99 1f       	adc	r25, r25
    2108:	88 0f       	add	r24, r24
    210a:	99 1f       	adc	r25, r25
    210c:	88 0f       	add	r24, r24
    210e:	99 1f       	adc	r25, r25
    2110:	82 0f       	add	r24, r18
    2112:	93 1f       	adc	r25, r19
    2114:	b8 01       	movw	r22, r16
    2116:	8c 59       	subi	r24, 0x9C	; 156
    2118:	97 4f       	sbci	r25, 0xF7	; 247
    211a:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    211e:	e0 91 91 08 	lds	r30, 0x0891
    2122:	f0 91 92 08 	lds	r31, 0x0892
    2126:	9e 89       	ldd	r25, Y+22	; 0x16
    2128:	86 89       	ldd	r24, Z+22	; 0x16
    212a:	98 17       	cp	r25, r24
    212c:	08 f0       	brcs	.+2      	; 0x2130 <xTaskIncrementTick+0x11a>
    212e:	b1 cf       	rjmp	.-158    	; 0x2092 <xTaskIncrementTick+0x7c>
    2130:	b1 cf       	rjmp	.-158    	; 0x2094 <xTaskIncrementTick+0x7e>
    2132:	d1 2c       	mov	r13, r1
    2134:	e0 91 91 08 	lds	r30, 0x0891
    2138:	f0 91 92 08 	lds	r31, 0x0892
    213c:	86 89       	ldd	r24, Z+22	; 0x16
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	fc 01       	movw	r30, r24
    2142:	ee 0f       	add	r30, r30
    2144:	ff 1f       	adc	r31, r31
    2146:	ee 0f       	add	r30, r30
    2148:	ff 1f       	adc	r31, r31
    214a:	ee 0f       	add	r30, r30
    214c:	ff 1f       	adc	r31, r31
    214e:	8e 0f       	add	r24, r30
    2150:	9f 1f       	adc	r25, r31
    2152:	fc 01       	movw	r30, r24
    2154:	ec 59       	subi	r30, 0x9C	; 156
    2156:	f7 4f       	sbci	r31, 0xF7	; 247
    2158:	80 81       	ld	r24, Z
    215a:	82 30       	cpi	r24, 0x02	; 2
    215c:	40 f4       	brcc	.+16     	; 0x216e <xTaskIncrementTick+0x158>
    215e:	09 c0       	rjmp	.+18     	; 0x2172 <xTaskIncrementTick+0x15c>
    2160:	80 91 2c 08 	lds	r24, 0x082C
    2164:	8f 5f       	subi	r24, 0xFF	; 255
    2166:	80 93 2c 08 	sts	0x082C, r24
    216a:	d1 2c       	mov	r13, r1
    216c:	02 c0       	rjmp	.+4      	; 0x2172 <xTaskIncrementTick+0x15c>
    216e:	dd 24       	eor	r13, r13
    2170:	d3 94       	inc	r13
    2172:	80 91 2b 08 	lds	r24, 0x082B
    2176:	88 23       	and	r24, r24
    2178:	11 f0       	breq	.+4      	; 0x217e <xTaskIncrementTick+0x168>
    217a:	dd 24       	eor	r13, r13
    217c:	d3 94       	inc	r13
    217e:	8d 2d       	mov	r24, r13
    2180:	df 91       	pop	r29
    2182:	cf 91       	pop	r28
    2184:	1f 91       	pop	r17
    2186:	0f 91       	pop	r16
    2188:	ff 90       	pop	r15
    218a:	ef 90       	pop	r14
    218c:	df 90       	pop	r13
    218e:	cf 90       	pop	r12
    2190:	08 95       	ret

00002192 <xTaskResumeAll>:
    2192:	df 92       	push	r13
    2194:	ef 92       	push	r14
    2196:	ff 92       	push	r15
    2198:	0f 93       	push	r16
    219a:	1f 93       	push	r17
    219c:	cf 93       	push	r28
    219e:	df 93       	push	r29
    21a0:	0f b6       	in	r0, 0x3f	; 63
    21a2:	f8 94       	cli
    21a4:	0f 92       	push	r0
    21a6:	80 91 28 08 	lds	r24, 0x0828
    21aa:	81 50       	subi	r24, 0x01	; 1
    21ac:	80 93 28 08 	sts	0x0828, r24
    21b0:	80 91 28 08 	lds	r24, 0x0828
    21b4:	81 11       	cpse	r24, r1
    21b6:	5f c0       	rjmp	.+190    	; 0x2276 <__stack+0x77>
    21b8:	80 91 31 08 	lds	r24, 0x0831
    21bc:	88 23       	and	r24, r24
    21be:	09 f4       	brne	.+2      	; 0x21c2 <xTaskResumeAll+0x30>
    21c0:	5c c0       	rjmp	.+184    	; 0x227a <__stack+0x7b>
    21c2:	0f 2e       	mov	r0, r31
    21c4:	f5 e4       	ldi	r31, 0x45	; 69
    21c6:	ef 2e       	mov	r14, r31
    21c8:	f8 e0       	ldi	r31, 0x08	; 8
    21ca:	ff 2e       	mov	r15, r31
    21cc:	f0 2d       	mov	r31, r0
    21ce:	dd 24       	eor	r13, r13
    21d0:	d3 94       	inc	r13
    21d2:	30 c0       	rjmp	.+96     	; 0x2234 <__stack+0x35>
    21d4:	e0 91 4a 08 	lds	r30, 0x084A
    21d8:	f0 91 4b 08 	lds	r31, 0x084B
    21dc:	c6 81       	ldd	r28, Z+6	; 0x06
    21de:	d7 81       	ldd	r29, Z+7	; 0x07
    21e0:	ce 01       	movw	r24, r28
    21e2:	0c 96       	adiw	r24, 0x0c	; 12
    21e4:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    21e8:	8e 01       	movw	r16, r28
    21ea:	0e 5f       	subi	r16, 0xFE	; 254
    21ec:	1f 4f       	sbci	r17, 0xFF	; 255
    21ee:	c8 01       	movw	r24, r16
    21f0:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    21f4:	8e 89       	ldd	r24, Y+22	; 0x16
    21f6:	90 91 2e 08 	lds	r25, 0x082E
    21fa:	98 17       	cp	r25, r24
    21fc:	10 f4       	brcc	.+4      	; 0x2202 <__stack+0x3>
    21fe:	80 93 2e 08 	sts	0x082E, r24
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	9c 01       	movw	r18, r24
    2206:	22 0f       	add	r18, r18
    2208:	33 1f       	adc	r19, r19
    220a:	22 0f       	add	r18, r18
    220c:	33 1f       	adc	r19, r19
    220e:	22 0f       	add	r18, r18
    2210:	33 1f       	adc	r19, r19
    2212:	82 0f       	add	r24, r18
    2214:	93 1f       	adc	r25, r19
    2216:	b8 01       	movw	r22, r16
    2218:	8c 59       	subi	r24, 0x9C	; 156
    221a:	97 4f       	sbci	r25, 0xF7	; 247
    221c:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    2220:	e0 91 91 08 	lds	r30, 0x0891
    2224:	f0 91 92 08 	lds	r31, 0x0892
    2228:	9e 89       	ldd	r25, Y+22	; 0x16
    222a:	86 89       	ldd	r24, Z+22	; 0x16
    222c:	98 17       	cp	r25, r24
    222e:	10 f0       	brcs	.+4      	; 0x2234 <__stack+0x35>
    2230:	d0 92 2b 08 	sts	0x082B, r13
    2234:	f7 01       	movw	r30, r14
    2236:	80 81       	ld	r24, Z
    2238:	81 11       	cpse	r24, r1
    223a:	cc cf       	rjmp	.-104    	; 0x21d4 <xTaskResumeAll+0x42>
    223c:	80 91 2c 08 	lds	r24, 0x082C
    2240:	88 23       	and	r24, r24
    2242:	91 f0       	breq	.+36     	; 0x2268 <__stack+0x69>
    2244:	80 91 2c 08 	lds	r24, 0x082C
    2248:	88 23       	and	r24, r24
    224a:	71 f0       	breq	.+28     	; 0x2268 <__stack+0x69>
    224c:	c1 e0       	ldi	r28, 0x01	; 1
    224e:	e3 de       	rcall	.-570    	; 0x2016 <xTaskIncrementTick>
    2250:	81 11       	cpse	r24, r1
    2252:	c0 93 2b 08 	sts	0x082B, r28
    2256:	80 91 2c 08 	lds	r24, 0x082C
    225a:	81 50       	subi	r24, 0x01	; 1
    225c:	80 93 2c 08 	sts	0x082C, r24
    2260:	80 91 2c 08 	lds	r24, 0x082C
    2264:	81 11       	cpse	r24, r1
    2266:	f3 cf       	rjmp	.-26     	; 0x224e <__stack+0x4f>
    2268:	80 91 2b 08 	lds	r24, 0x082B
    226c:	81 30       	cpi	r24, 0x01	; 1
    226e:	39 f4       	brne	.+14     	; 0x227e <__stack+0x7f>
    2270:	06 d9       	rcall	.-3572   	; 0x147e <vPortYield>
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	05 c0       	rjmp	.+10     	; 0x2280 <__stack+0x81>
    2276:	80 e0       	ldi	r24, 0x00	; 0
    2278:	03 c0       	rjmp	.+6      	; 0x2280 <__stack+0x81>
    227a:	80 e0       	ldi	r24, 0x00	; 0
    227c:	01 c0       	rjmp	.+2      	; 0x2280 <__stack+0x81>
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	0f 90       	pop	r0
    2282:	0f be       	out	0x3f, r0	; 63
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	1f 91       	pop	r17
    228a:	0f 91       	pop	r16
    228c:	ff 90       	pop	r15
    228e:	ef 90       	pop	r14
    2290:	df 90       	pop	r13
    2292:	08 95       	ret

00002294 <vTaskDelayUntil>:
    2294:	0f 93       	push	r16
    2296:	1f 93       	push	r17
    2298:	cf 93       	push	r28
    229a:	df 93       	push	r29
    229c:	8c 01       	movw	r16, r24
    229e:	eb 01       	movw	r28, r22
    22a0:	a5 de       	rcall	.-694    	; 0x1fec <vTaskSuspendAll>
    22a2:	80 91 2f 08 	lds	r24, 0x082F
    22a6:	90 91 30 08 	lds	r25, 0x0830
    22aa:	f8 01       	movw	r30, r16
    22ac:	20 81       	ld	r18, Z
    22ae:	31 81       	ldd	r19, Z+1	; 0x01
    22b0:	c2 0f       	add	r28, r18
    22b2:	d3 1f       	adc	r29, r19
    22b4:	82 17       	cp	r24, r18
    22b6:	93 07       	cpc	r25, r19
    22b8:	48 f4       	brcc	.+18     	; 0x22cc <vTaskDelayUntil+0x38>
    22ba:	c2 17       	cp	r28, r18
    22bc:	d3 07       	cpc	r29, r19
    22be:	f8 f4       	brcc	.+62     	; 0x22fe <vTaskDelayUntil+0x6a>
    22c0:	d1 83       	std	Z+1, r29	; 0x01
    22c2:	c0 83       	st	Z, r28
    22c4:	8c 17       	cp	r24, r28
    22c6:	9d 07       	cpc	r25, r29
    22c8:	88 f4       	brcc	.+34     	; 0x22ec <vTaskDelayUntil+0x58>
    22ca:	07 c0       	rjmp	.+14     	; 0x22da <vTaskDelayUntil+0x46>
    22cc:	c2 17       	cp	r28, r18
    22ce:	d3 07       	cpc	r29, r19
    22d0:	90 f0       	brcs	.+36     	; 0x22f6 <vTaskDelayUntil+0x62>
    22d2:	8c 17       	cp	r24, r28
    22d4:	9d 07       	cpc	r25, r29
    22d6:	78 f0       	brcs	.+30     	; 0x22f6 <vTaskDelayUntil+0x62>
    22d8:	12 c0       	rjmp	.+36     	; 0x22fe <vTaskDelayUntil+0x6a>
    22da:	80 91 91 08 	lds	r24, 0x0891
    22de:	90 91 92 08 	lds	r25, 0x0892
    22e2:	02 96       	adiw	r24, 0x02	; 2
    22e4:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    22e8:	ce 01       	movw	r24, r28
    22ea:	c0 dc       	rcall	.-1664   	; 0x1c6c <prvAddCurrentTaskToDelayedList>
    22ec:	52 df       	rcall	.-348    	; 0x2192 <xTaskResumeAll>
    22ee:	81 11       	cpse	r24, r1
    22f0:	0a c0       	rjmp	.+20     	; 0x2306 <vTaskDelayUntil+0x72>
    22f2:	c5 d8       	rcall	.-3702   	; 0x147e <vPortYield>
    22f4:	08 c0       	rjmp	.+16     	; 0x2306 <vTaskDelayUntil+0x72>
    22f6:	f8 01       	movw	r30, r16
    22f8:	d1 83       	std	Z+1, r29	; 0x01
    22fa:	c0 83       	st	Z, r28
    22fc:	ee cf       	rjmp	.-36     	; 0x22da <vTaskDelayUntil+0x46>
    22fe:	f8 01       	movw	r30, r16
    2300:	d1 83       	std	Z+1, r29	; 0x01
    2302:	c0 83       	st	Z, r28
    2304:	f3 cf       	rjmp	.-26     	; 0x22ec <vTaskDelayUntil+0x58>
    2306:	df 91       	pop	r29
    2308:	cf 91       	pop	r28
    230a:	1f 91       	pop	r17
    230c:	0f 91       	pop	r16
    230e:	08 95       	ret

00002310 <prvIdleTask>:
    2310:	0f 2e       	mov	r0, r31
    2312:	f4 e6       	ldi	r31, 0x64	; 100
    2314:	ef 2e       	mov	r14, r31
    2316:	f8 e0       	ldi	r31, 0x08	; 8
    2318:	ff 2e       	mov	r15, r31
    231a:	f0 2d       	mov	r31, r0
    231c:	cc e3       	ldi	r28, 0x3C	; 60
    231e:	d8 e0       	ldi	r29, 0x08	; 8
    2320:	26 c0       	rjmp	.+76     	; 0x236e <prvIdleTask+0x5e>
    2322:	64 de       	rcall	.-824    	; 0x1fec <vTaskSuspendAll>
    2324:	18 81       	ld	r17, Y
    2326:	35 df       	rcall	.-406    	; 0x2192 <xTaskResumeAll>
    2328:	11 23       	and	r17, r17
    232a:	09 f1       	breq	.+66     	; 0x236e <prvIdleTask+0x5e>
    232c:	0f b6       	in	r0, 0x3f	; 63
    232e:	f8 94       	cli
    2330:	0f 92       	push	r0
    2332:	e0 91 41 08 	lds	r30, 0x0841
    2336:	f0 91 42 08 	lds	r31, 0x0842
    233a:	06 81       	ldd	r16, Z+6	; 0x06
    233c:	17 81       	ldd	r17, Z+7	; 0x07
    233e:	c8 01       	movw	r24, r16
    2340:	02 96       	adiw	r24, 0x02	; 2
    2342:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2346:	80 91 31 08 	lds	r24, 0x0831
    234a:	81 50       	subi	r24, 0x01	; 1
    234c:	80 93 31 08 	sts	0x0831, r24
    2350:	80 91 3b 08 	lds	r24, 0x083B
    2354:	81 50       	subi	r24, 0x01	; 1
    2356:	80 93 3b 08 	sts	0x083B, r24
    235a:	0f 90       	pop	r0
    235c:	0f be       	out	0x3f, r0	; 63
    235e:	f8 01       	movw	r30, r16
    2360:	87 89       	ldd	r24, Z+23	; 0x17
    2362:	90 8d       	ldd	r25, Z+24	; 0x18
    2364:	0e 94 43 03 	call	0x686	; 0x686 <vPortFree>
    2368:	c8 01       	movw	r24, r16
    236a:	0e 94 43 03 	call	0x686	; 0x686 <vPortFree>
    236e:	80 91 3b 08 	lds	r24, 0x083B
    2372:	81 11       	cpse	r24, r1
    2374:	d6 cf       	rjmp	.-84     	; 0x2322 <prvIdleTask+0x12>
    2376:	f7 01       	movw	r30, r14
    2378:	80 81       	ld	r24, Z
    237a:	82 30       	cpi	r24, 0x02	; 2
    237c:	c0 f3       	brcs	.-16     	; 0x236e <prvIdleTask+0x5e>
    237e:	7f d8       	rcall	.-3842   	; 0x147e <vPortYield>
    2380:	f6 cf       	rjmp	.-20     	; 0x236e <prvIdleTask+0x5e>

00002382 <vTaskSwitchContext>:
    2382:	80 91 28 08 	lds	r24, 0x0828
    2386:	88 23       	and	r24, r24
    2388:	21 f0       	breq	.+8      	; 0x2392 <vTaskSwitchContext+0x10>
    238a:	81 e0       	ldi	r24, 0x01	; 1
    238c:	80 93 2b 08 	sts	0x082B, r24
    2390:	08 95       	ret
    2392:	10 92 2b 08 	sts	0x082B, r1
    2396:	80 91 2e 08 	lds	r24, 0x082E
    239a:	90 e0       	ldi	r25, 0x00	; 0
    239c:	fc 01       	movw	r30, r24
    239e:	ee 0f       	add	r30, r30
    23a0:	ff 1f       	adc	r31, r31
    23a2:	ee 0f       	add	r30, r30
    23a4:	ff 1f       	adc	r31, r31
    23a6:	ee 0f       	add	r30, r30
    23a8:	ff 1f       	adc	r31, r31
    23aa:	8e 0f       	add	r24, r30
    23ac:	9f 1f       	adc	r25, r31
    23ae:	fc 01       	movw	r30, r24
    23b0:	ec 59       	subi	r30, 0x9C	; 156
    23b2:	f7 4f       	sbci	r31, 0xF7	; 247
    23b4:	80 81       	ld	r24, Z
    23b6:	81 11       	cpse	r24, r1
    23b8:	17 c0       	rjmp	.+46     	; 0x23e8 <vTaskSwitchContext+0x66>
    23ba:	80 91 2e 08 	lds	r24, 0x082E
    23be:	81 50       	subi	r24, 0x01	; 1
    23c0:	80 93 2e 08 	sts	0x082E, r24
    23c4:	80 91 2e 08 	lds	r24, 0x082E
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	fc 01       	movw	r30, r24
    23cc:	ee 0f       	add	r30, r30
    23ce:	ff 1f       	adc	r31, r31
    23d0:	ee 0f       	add	r30, r30
    23d2:	ff 1f       	adc	r31, r31
    23d4:	ee 0f       	add	r30, r30
    23d6:	ff 1f       	adc	r31, r31
    23d8:	8e 0f       	add	r24, r30
    23da:	9f 1f       	adc	r25, r31
    23dc:	fc 01       	movw	r30, r24
    23de:	ec 59       	subi	r30, 0x9C	; 156
    23e0:	f7 4f       	sbci	r31, 0xF7	; 247
    23e2:	80 81       	ld	r24, Z
    23e4:	88 23       	and	r24, r24
    23e6:	49 f3       	breq	.-46     	; 0x23ba <vTaskSwitchContext+0x38>
    23e8:	e0 91 2e 08 	lds	r30, 0x082E
    23ec:	f0 e0       	ldi	r31, 0x00	; 0
    23ee:	cf 01       	movw	r24, r30
    23f0:	88 0f       	add	r24, r24
    23f2:	99 1f       	adc	r25, r25
    23f4:	88 0f       	add	r24, r24
    23f6:	99 1f       	adc	r25, r25
    23f8:	88 0f       	add	r24, r24
    23fa:	99 1f       	adc	r25, r25
    23fc:	e8 0f       	add	r30, r24
    23fe:	f9 1f       	adc	r31, r25
    2400:	ec 59       	subi	r30, 0x9C	; 156
    2402:	f7 4f       	sbci	r31, 0xF7	; 247
    2404:	a1 81       	ldd	r26, Z+1	; 0x01
    2406:	b2 81       	ldd	r27, Z+2	; 0x02
    2408:	12 96       	adiw	r26, 0x02	; 2
    240a:	0d 90       	ld	r0, X+
    240c:	bc 91       	ld	r27, X
    240e:	a0 2d       	mov	r26, r0
    2410:	b2 83       	std	Z+2, r27	; 0x02
    2412:	a1 83       	std	Z+1, r26	; 0x01
    2414:	cf 01       	movw	r24, r30
    2416:	03 96       	adiw	r24, 0x03	; 3
    2418:	a8 17       	cp	r26, r24
    241a:	b9 07       	cpc	r27, r25
    241c:	31 f4       	brne	.+12     	; 0x242a <vTaskSwitchContext+0xa8>
    241e:	12 96       	adiw	r26, 0x02	; 2
    2420:	8d 91       	ld	r24, X+
    2422:	9c 91       	ld	r25, X
    2424:	13 97       	sbiw	r26, 0x03	; 3
    2426:	92 83       	std	Z+2, r25	; 0x02
    2428:	81 83       	std	Z+1, r24	; 0x01
    242a:	01 80       	ldd	r0, Z+1	; 0x01
    242c:	f2 81       	ldd	r31, Z+2	; 0x02
    242e:	e0 2d       	mov	r30, r0
    2430:	86 81       	ldd	r24, Z+6	; 0x06
    2432:	97 81       	ldd	r25, Z+7	; 0x07
    2434:	90 93 92 08 	sts	0x0892, r25
    2438:	80 93 91 08 	sts	0x0891, r24
    243c:	08 95       	ret

0000243e <vTaskSuspend>:
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
    2446:	ec 01       	movw	r28, r24
    2448:	0f b6       	in	r0, 0x3f	; 63
    244a:	f8 94       	cli
    244c:	0f 92       	push	r0
    244e:	00 97       	sbiw	r24, 0x00	; 0
    2450:	21 f4       	brne	.+8      	; 0x245a <vTaskSuspend+0x1c>
    2452:	c0 91 91 08 	lds	r28, 0x0891
    2456:	d0 91 92 08 	lds	r29, 0x0892
    245a:	8e 01       	movw	r16, r28
    245c:	0e 5f       	subi	r16, 0xFE	; 254
    245e:	1f 4f       	sbci	r17, 0xFF	; 255
    2460:	c8 01       	movw	r24, r16
    2462:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2466:	8c 89       	ldd	r24, Y+20	; 0x14
    2468:	9d 89       	ldd	r25, Y+21	; 0x15
    246a:	89 2b       	or	r24, r25
    246c:	21 f0       	breq	.+8      	; 0x2476 <vTaskSuspend+0x38>
    246e:	ce 01       	movw	r24, r28
    2470:	0c 96       	adiw	r24, 0x0c	; 12
    2472:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2476:	b8 01       	movw	r22, r16
    2478:	82 e3       	ldi	r24, 0x32	; 50
    247a:	98 e0       	ldi	r25, 0x08	; 8
    247c:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    2480:	0f 90       	pop	r0
    2482:	0f be       	out	0x3f, r0	; 63
    2484:	80 91 91 08 	lds	r24, 0x0891
    2488:	90 91 92 08 	lds	r25, 0x0892
    248c:	c8 17       	cp	r28, r24
    248e:	d9 07       	cpc	r29, r25
    2490:	a1 f4       	brne	.+40     	; 0x24ba <vTaskSuspend+0x7c>
    2492:	80 91 2d 08 	lds	r24, 0x082D
    2496:	88 23       	and	r24, r24
    2498:	19 f0       	breq	.+6      	; 0x24a0 <vTaskSuspend+0x62>
    249a:	0e 94 3f 0a 	call	0x147e	; 0x147e <vPortYield>
    249e:	17 c0       	rjmp	.+46     	; 0x24ce <vTaskSuspend+0x90>
    24a0:	80 91 31 08 	lds	r24, 0x0831
    24a4:	90 91 32 08 	lds	r25, 0x0832
    24a8:	98 13       	cpse	r25, r24
    24aa:	05 c0       	rjmp	.+10     	; 0x24b6 <vTaskSuspend+0x78>
    24ac:	10 92 92 08 	sts	0x0892, r1
    24b0:	10 92 91 08 	sts	0x0891, r1
    24b4:	0c c0       	rjmp	.+24     	; 0x24ce <vTaskSuspend+0x90>
    24b6:	65 df       	rcall	.-310    	; 0x2382 <vTaskSwitchContext>
    24b8:	0a c0       	rjmp	.+20     	; 0x24ce <vTaskSuspend+0x90>
    24ba:	80 91 2d 08 	lds	r24, 0x082D
    24be:	88 23       	and	r24, r24
    24c0:	31 f0       	breq	.+12     	; 0x24ce <vTaskSuspend+0x90>
    24c2:	0f b6       	in	r0, 0x3f	; 63
    24c4:	f8 94       	cli
    24c6:	0f 92       	push	r0
    24c8:	b2 db       	rcall	.-2204   	; 0x1c2e <prvResetNextTaskUnblockTime>
    24ca:	0f 90       	pop	r0
    24cc:	0f be       	out	0x3f, r0	; 63
    24ce:	df 91       	pop	r29
    24d0:	cf 91       	pop	r28
    24d2:	1f 91       	pop	r17
    24d4:	0f 91       	pop	r16
    24d6:	08 95       	ret

000024d8 <vTaskPlaceOnEventList>:
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
    24dc:	eb 01       	movw	r28, r22
    24de:	60 91 91 08 	lds	r22, 0x0891
    24e2:	70 91 92 08 	lds	r23, 0x0892
    24e6:	64 5f       	subi	r22, 0xF4	; 244
    24e8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ea:	0e 94 77 03 	call	0x6ee	; 0x6ee <vListInsert>
    24ee:	80 91 91 08 	lds	r24, 0x0891
    24f2:	90 91 92 08 	lds	r25, 0x0892
    24f6:	02 96       	adiw	r24, 0x02	; 2
    24f8:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    24fc:	cf 3f       	cpi	r28, 0xFF	; 255
    24fe:	8f ef       	ldi	r24, 0xFF	; 255
    2500:	d8 07       	cpc	r29, r24
    2502:	59 f4       	brne	.+22     	; 0x251a <vTaskPlaceOnEventList+0x42>
    2504:	60 91 91 08 	lds	r22, 0x0891
    2508:	70 91 92 08 	lds	r23, 0x0892
    250c:	6e 5f       	subi	r22, 0xFE	; 254
    250e:	7f 4f       	sbci	r23, 0xFF	; 255
    2510:	82 e3       	ldi	r24, 0x32	; 50
    2512:	98 e0       	ldi	r25, 0x08	; 8
    2514:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    2518:	07 c0       	rjmp	.+14     	; 0x2528 <vTaskPlaceOnEventList+0x50>
    251a:	80 91 2f 08 	lds	r24, 0x082F
    251e:	90 91 30 08 	lds	r25, 0x0830
    2522:	8c 0f       	add	r24, r28
    2524:	9d 1f       	adc	r25, r29
    2526:	a2 db       	rcall	.-2236   	; 0x1c6c <prvAddCurrentTaskToDelayedList>
    2528:	df 91       	pop	r29
    252a:	cf 91       	pop	r28
    252c:	08 95       	ret

0000252e <xTaskRemoveFromEventList>:
    252e:	0f 93       	push	r16
    2530:	1f 93       	push	r17
    2532:	cf 93       	push	r28
    2534:	df 93       	push	r29
    2536:	dc 01       	movw	r26, r24
    2538:	15 96       	adiw	r26, 0x05	; 5
    253a:	ed 91       	ld	r30, X+
    253c:	fc 91       	ld	r31, X
    253e:	16 97       	sbiw	r26, 0x06	; 6
    2540:	c6 81       	ldd	r28, Z+6	; 0x06
    2542:	d7 81       	ldd	r29, Z+7	; 0x07
    2544:	8e 01       	movw	r16, r28
    2546:	04 5f       	subi	r16, 0xF4	; 244
    2548:	1f 4f       	sbci	r17, 0xFF	; 255
    254a:	c8 01       	movw	r24, r16
    254c:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2550:	80 91 28 08 	lds	r24, 0x0828
    2554:	81 11       	cpse	r24, r1
    2556:	1c c0       	rjmp	.+56     	; 0x2590 <xTaskRemoveFromEventList+0x62>
    2558:	0a 50       	subi	r16, 0x0A	; 10
    255a:	11 09       	sbc	r17, r1
    255c:	c8 01       	movw	r24, r16
    255e:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2562:	8e 89       	ldd	r24, Y+22	; 0x16
    2564:	90 91 2e 08 	lds	r25, 0x082E
    2568:	98 17       	cp	r25, r24
    256a:	10 f4       	brcc	.+4      	; 0x2570 <xTaskRemoveFromEventList+0x42>
    256c:	80 93 2e 08 	sts	0x082E, r24
    2570:	90 e0       	ldi	r25, 0x00	; 0
    2572:	9c 01       	movw	r18, r24
    2574:	22 0f       	add	r18, r18
    2576:	33 1f       	adc	r19, r19
    2578:	22 0f       	add	r18, r18
    257a:	33 1f       	adc	r19, r19
    257c:	22 0f       	add	r18, r18
    257e:	33 1f       	adc	r19, r19
    2580:	82 0f       	add	r24, r18
    2582:	93 1f       	adc	r25, r19
    2584:	b8 01       	movw	r22, r16
    2586:	8c 59       	subi	r24, 0x9C	; 156
    2588:	97 4f       	sbci	r25, 0xF7	; 247
    258a:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    258e:	05 c0       	rjmp	.+10     	; 0x259a <xTaskRemoveFromEventList+0x6c>
    2590:	b8 01       	movw	r22, r16
    2592:	85 e4       	ldi	r24, 0x45	; 69
    2594:	98 e0       	ldi	r25, 0x08	; 8
    2596:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    259a:	e0 91 91 08 	lds	r30, 0x0891
    259e:	f0 91 92 08 	lds	r31, 0x0892
    25a2:	9e 89       	ldd	r25, Y+22	; 0x16
    25a4:	86 89       	ldd	r24, Z+22	; 0x16
    25a6:	89 17       	cp	r24, r25
    25a8:	20 f4       	brcc	.+8      	; 0x25b2 <xTaskRemoveFromEventList+0x84>
    25aa:	81 e0       	ldi	r24, 0x01	; 1
    25ac:	80 93 2b 08 	sts	0x082B, r24
    25b0:	01 c0       	rjmp	.+2      	; 0x25b4 <xTaskRemoveFromEventList+0x86>
    25b2:	80 e0       	ldi	r24, 0x00	; 0
    25b4:	df 91       	pop	r29
    25b6:	cf 91       	pop	r28
    25b8:	1f 91       	pop	r17
    25ba:	0f 91       	pop	r16
    25bc:	08 95       	ret

000025be <vTaskSetTimeOutState>:
    25be:	20 91 2a 08 	lds	r18, 0x082A
    25c2:	fc 01       	movw	r30, r24
    25c4:	20 83       	st	Z, r18
    25c6:	20 91 2f 08 	lds	r18, 0x082F
    25ca:	30 91 30 08 	lds	r19, 0x0830
    25ce:	32 83       	std	Z+2, r19	; 0x02
    25d0:	21 83       	std	Z+1, r18	; 0x01
    25d2:	08 95       	ret

000025d4 <xTaskCheckForTimeOut>:
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	0f 92       	push	r0
    25da:	40 91 2f 08 	lds	r20, 0x082F
    25de:	50 91 30 08 	lds	r21, 0x0830
    25e2:	db 01       	movw	r26, r22
    25e4:	2d 91       	ld	r18, X+
    25e6:	3c 91       	ld	r19, X
    25e8:	2f 3f       	cpi	r18, 0xFF	; 255
    25ea:	bf ef       	ldi	r27, 0xFF	; 255
    25ec:	3b 07       	cpc	r19, r27
    25ee:	11 f1       	breq	.+68     	; 0x2634 <xTaskCheckForTimeOut+0x60>
    25f0:	e0 91 2a 08 	lds	r30, 0x082A
    25f4:	dc 01       	movw	r26, r24
    25f6:	fc 91       	ld	r31, X
    25f8:	fe 17       	cp	r31, r30
    25fa:	39 f0       	breq	.+14     	; 0x260a <xTaskCheckForTimeOut+0x36>
    25fc:	11 96       	adiw	r26, 0x01	; 1
    25fe:	ed 91       	ld	r30, X+
    2600:	fc 91       	ld	r31, X
    2602:	12 97       	sbiw	r26, 0x02	; 2
    2604:	4e 17       	cp	r20, r30
    2606:	5f 07       	cpc	r21, r31
    2608:	b8 f4       	brcc	.+46     	; 0x2638 <xTaskCheckForTimeOut+0x64>
    260a:	dc 01       	movw	r26, r24
    260c:	11 96       	adiw	r26, 0x01	; 1
    260e:	ed 91       	ld	r30, X+
    2610:	fc 91       	ld	r31, X
    2612:	12 97       	sbiw	r26, 0x02	; 2
    2614:	da 01       	movw	r26, r20
    2616:	ae 1b       	sub	r26, r30
    2618:	bf 0b       	sbc	r27, r31
    261a:	a2 17       	cp	r26, r18
    261c:	b3 07       	cpc	r27, r19
    261e:	70 f4       	brcc	.+28     	; 0x263c <xTaskCheckForTimeOut+0x68>
    2620:	e4 1b       	sub	r30, r20
    2622:	f5 0b       	sbc	r31, r21
    2624:	2e 0f       	add	r18, r30
    2626:	3f 1f       	adc	r19, r31
    2628:	fb 01       	movw	r30, r22
    262a:	31 83       	std	Z+1, r19	; 0x01
    262c:	20 83       	st	Z, r18
    262e:	c7 df       	rcall	.-114    	; 0x25be <vTaskSetTimeOutState>
    2630:	80 e0       	ldi	r24, 0x00	; 0
    2632:	05 c0       	rjmp	.+10     	; 0x263e <xTaskCheckForTimeOut+0x6a>
    2634:	80 e0       	ldi	r24, 0x00	; 0
    2636:	03 c0       	rjmp	.+6      	; 0x263e <xTaskCheckForTimeOut+0x6a>
    2638:	81 e0       	ldi	r24, 0x01	; 1
    263a:	01 c0       	rjmp	.+2      	; 0x263e <xTaskCheckForTimeOut+0x6a>
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	08 95       	ret

00002644 <vTaskMissedYield>:
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	80 93 2b 08 	sts	0x082B, r24
    264a:	08 95       	ret

0000264c <vTaskPriorityInherit>:
    264c:	0f 93       	push	r16
    264e:	1f 93       	push	r17
    2650:	cf 93       	push	r28
    2652:	df 93       	push	r29
    2654:	ec 01       	movw	r28, r24
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	09 f4       	brne	.+2      	; 0x265c <vTaskPriorityInherit+0x10>
    265a:	51 c0       	rjmp	.+162    	; 0x26fe <vTaskPriorityInherit+0xb2>
    265c:	8e 89       	ldd	r24, Y+22	; 0x16
    265e:	e0 91 91 08 	lds	r30, 0x0891
    2662:	f0 91 92 08 	lds	r31, 0x0892
    2666:	96 89       	ldd	r25, Z+22	; 0x16
    2668:	89 17       	cp	r24, r25
    266a:	08 f0       	brcs	.+2      	; 0x266e <vTaskPriorityInherit+0x22>
    266c:	48 c0       	rjmp	.+144    	; 0x26fe <vTaskPriorityInherit+0xb2>
    266e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2670:	3d 85       	ldd	r19, Y+13	; 0x0d
    2672:	33 23       	and	r19, r19
    2674:	5c f0       	brlt	.+22     	; 0x268c <vTaskPriorityInherit+0x40>
    2676:	e0 91 91 08 	lds	r30, 0x0891
    267a:	f0 91 92 08 	lds	r31, 0x0892
    267e:	96 89       	ldd	r25, Z+22	; 0x16
    2680:	25 e0       	ldi	r18, 0x05	; 5
    2682:	30 e0       	ldi	r19, 0x00	; 0
    2684:	29 1b       	sub	r18, r25
    2686:	31 09       	sbc	r19, r1
    2688:	3d 87       	std	Y+13, r19	; 0x0d
    268a:	2c 87       	std	Y+12, r18	; 0x0c
    268c:	90 e0       	ldi	r25, 0x00	; 0
    268e:	9c 01       	movw	r18, r24
    2690:	22 0f       	add	r18, r18
    2692:	33 1f       	adc	r19, r19
    2694:	22 0f       	add	r18, r18
    2696:	33 1f       	adc	r19, r19
    2698:	22 0f       	add	r18, r18
    269a:	33 1f       	adc	r19, r19
    269c:	82 0f       	add	r24, r18
    269e:	93 1f       	adc	r25, r19
    26a0:	8c 59       	subi	r24, 0x9C	; 156
    26a2:	97 4f       	sbci	r25, 0xF7	; 247
    26a4:	2a 85       	ldd	r18, Y+10	; 0x0a
    26a6:	3b 85       	ldd	r19, Y+11	; 0x0b
    26a8:	28 17       	cp	r18, r24
    26aa:	39 07       	cpc	r19, r25
    26ac:	11 f5       	brne	.+68     	; 0x26f2 <vTaskPriorityInherit+0xa6>
    26ae:	8e 01       	movw	r16, r28
    26b0:	0e 5f       	subi	r16, 0xFE	; 254
    26b2:	1f 4f       	sbci	r17, 0xFF	; 255
    26b4:	c8 01       	movw	r24, r16
    26b6:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    26ba:	e0 91 91 08 	lds	r30, 0x0891
    26be:	f0 91 92 08 	lds	r31, 0x0892
    26c2:	86 89       	ldd	r24, Z+22	; 0x16
    26c4:	8e 8b       	std	Y+22, r24	; 0x16
    26c6:	90 91 2e 08 	lds	r25, 0x082E
    26ca:	98 17       	cp	r25, r24
    26cc:	10 f4       	brcc	.+4      	; 0x26d2 <vTaskPriorityInherit+0x86>
    26ce:	80 93 2e 08 	sts	0x082E, r24
    26d2:	90 e0       	ldi	r25, 0x00	; 0
    26d4:	9c 01       	movw	r18, r24
    26d6:	22 0f       	add	r18, r18
    26d8:	33 1f       	adc	r19, r19
    26da:	22 0f       	add	r18, r18
    26dc:	33 1f       	adc	r19, r19
    26de:	22 0f       	add	r18, r18
    26e0:	33 1f       	adc	r19, r19
    26e2:	82 0f       	add	r24, r18
    26e4:	93 1f       	adc	r25, r19
    26e6:	b8 01       	movw	r22, r16
    26e8:	8c 59       	subi	r24, 0x9C	; 156
    26ea:	97 4f       	sbci	r25, 0xF7	; 247
    26ec:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    26f0:	06 c0       	rjmp	.+12     	; 0x26fe <vTaskPriorityInherit+0xb2>
    26f2:	e0 91 91 08 	lds	r30, 0x0891
    26f6:	f0 91 92 08 	lds	r31, 0x0892
    26fa:	86 89       	ldd	r24, Z+22	; 0x16
    26fc:	8e 8b       	std	Y+22, r24	; 0x16
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	1f 91       	pop	r17
    2704:	0f 91       	pop	r16
    2706:	08 95       	ret

00002708 <xTaskPriorityDisinherit>:
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	cf 93       	push	r28
    270e:	df 93       	push	r29
    2710:	ec 01       	movw	r28, r24
    2712:	00 97       	sbiw	r24, 0x00	; 0
    2714:	71 f1       	breq	.+92     	; 0x2772 <xTaskPriorityDisinherit+0x6a>
    2716:	8a a1       	ldd	r24, Y+34	; 0x22
    2718:	81 50       	subi	r24, 0x01	; 1
    271a:	8a a3       	std	Y+34, r24	; 0x22
    271c:	2e 89       	ldd	r18, Y+22	; 0x16
    271e:	99 a1       	ldd	r25, Y+33	; 0x21
    2720:	29 17       	cp	r18, r25
    2722:	49 f1       	breq	.+82     	; 0x2776 <xTaskPriorityDisinherit+0x6e>
    2724:	81 11       	cpse	r24, r1
    2726:	29 c0       	rjmp	.+82     	; 0x277a <xTaskPriorityDisinherit+0x72>
    2728:	8e 01       	movw	r16, r28
    272a:	0e 5f       	subi	r16, 0xFE	; 254
    272c:	1f 4f       	sbci	r17, 0xFF	; 255
    272e:	c8 01       	movw	r24, r16
    2730:	0e 94 a8 03 	call	0x750	; 0x750 <uxListRemove>
    2734:	89 a1       	ldd	r24, Y+33	; 0x21
    2736:	8e 8b       	std	Y+22, r24	; 0x16
    2738:	25 e0       	ldi	r18, 0x05	; 5
    273a:	30 e0       	ldi	r19, 0x00	; 0
    273c:	28 1b       	sub	r18, r24
    273e:	31 09       	sbc	r19, r1
    2740:	3d 87       	std	Y+13, r19	; 0x0d
    2742:	2c 87       	std	Y+12, r18	; 0x0c
    2744:	90 91 2e 08 	lds	r25, 0x082E
    2748:	98 17       	cp	r25, r24
    274a:	10 f4       	brcc	.+4      	; 0x2750 <xTaskPriorityDisinherit+0x48>
    274c:	80 93 2e 08 	sts	0x082E, r24
    2750:	90 e0       	ldi	r25, 0x00	; 0
    2752:	9c 01       	movw	r18, r24
    2754:	22 0f       	add	r18, r18
    2756:	33 1f       	adc	r19, r19
    2758:	22 0f       	add	r18, r18
    275a:	33 1f       	adc	r19, r19
    275c:	22 0f       	add	r18, r18
    275e:	33 1f       	adc	r19, r19
    2760:	82 0f       	add	r24, r18
    2762:	93 1f       	adc	r25, r19
    2764:	b8 01       	movw	r22, r16
    2766:	8c 59       	subi	r24, 0x9C	; 156
    2768:	97 4f       	sbci	r25, 0xF7	; 247
    276a:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInsertEnd>
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	05 c0       	rjmp	.+10     	; 0x277c <xTaskPriorityDisinherit+0x74>
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	03 c0       	rjmp	.+6      	; 0x277c <xTaskPriorityDisinherit+0x74>
    2776:	80 e0       	ldi	r24, 0x00	; 0
    2778:	01 c0       	rjmp	.+2      	; 0x277c <xTaskPriorityDisinherit+0x74>
    277a:	80 e0       	ldi	r24, 0x00	; 0
    277c:	df 91       	pop	r29
    277e:	cf 91       	pop	r28
    2780:	1f 91       	pop	r17
    2782:	0f 91       	pop	r16
    2784:	08 95       	ret

00002786 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2786:	80 91 91 08 	lds	r24, 0x0891
    278a:	90 91 92 08 	lds	r25, 0x0892
    278e:	89 2b       	or	r24, r25
    2790:	39 f0       	breq	.+14     	; 0x27a0 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2792:	e0 91 91 08 	lds	r30, 0x0891
    2796:	f0 91 92 08 	lds	r31, 0x0892
    279a:	82 a1       	ldd	r24, Z+34	; 0x22
    279c:	8f 5f       	subi	r24, 0xFF	; 255
    279e:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    27a0:	80 91 91 08 	lds	r24, 0x0891
    27a4:	90 91 92 08 	lds	r25, 0x0892
	}
    27a8:	08 95       	ret

000027aa <__subsf3>:
    27aa:	50 58       	subi	r21, 0x80	; 128

000027ac <__addsf3>:
    27ac:	bb 27       	eor	r27, r27
    27ae:	aa 27       	eor	r26, r26
    27b0:	0e d0       	rcall	.+28     	; 0x27ce <__addsf3x>
    27b2:	e5 c0       	rjmp	.+458    	; 0x297e <__fp_round>
    27b4:	d6 d0       	rcall	.+428    	; 0x2962 <__fp_pscA>
    27b6:	30 f0       	brcs	.+12     	; 0x27c4 <__addsf3+0x18>
    27b8:	db d0       	rcall	.+438    	; 0x2970 <__fp_pscB>
    27ba:	20 f0       	brcs	.+8      	; 0x27c4 <__addsf3+0x18>
    27bc:	31 f4       	brne	.+12     	; 0x27ca <__addsf3+0x1e>
    27be:	9f 3f       	cpi	r25, 0xFF	; 255
    27c0:	11 f4       	brne	.+4      	; 0x27c6 <__addsf3+0x1a>
    27c2:	1e f4       	brtc	.+6      	; 0x27ca <__addsf3+0x1e>
    27c4:	cb c0       	rjmp	.+406    	; 0x295c <__fp_nan>
    27c6:	0e f4       	brtc	.+2      	; 0x27ca <__addsf3+0x1e>
    27c8:	e0 95       	com	r30
    27ca:	e7 fb       	bst	r30, 7
    27cc:	c1 c0       	rjmp	.+386    	; 0x2950 <__fp_inf>

000027ce <__addsf3x>:
    27ce:	e9 2f       	mov	r30, r25
    27d0:	e7 d0       	rcall	.+462    	; 0x29a0 <__fp_split3>
    27d2:	80 f3       	brcs	.-32     	; 0x27b4 <__addsf3+0x8>
    27d4:	ba 17       	cp	r27, r26
    27d6:	62 07       	cpc	r22, r18
    27d8:	73 07       	cpc	r23, r19
    27da:	84 07       	cpc	r24, r20
    27dc:	95 07       	cpc	r25, r21
    27de:	18 f0       	brcs	.+6      	; 0x27e6 <__addsf3x+0x18>
    27e0:	71 f4       	brne	.+28     	; 0x27fe <__addsf3x+0x30>
    27e2:	9e f5       	brtc	.+102    	; 0x284a <__addsf3x+0x7c>
    27e4:	ff c0       	rjmp	.+510    	; 0x29e4 <__fp_zero>
    27e6:	0e f4       	brtc	.+2      	; 0x27ea <__addsf3x+0x1c>
    27e8:	e0 95       	com	r30
    27ea:	0b 2e       	mov	r0, r27
    27ec:	ba 2f       	mov	r27, r26
    27ee:	a0 2d       	mov	r26, r0
    27f0:	0b 01       	movw	r0, r22
    27f2:	b9 01       	movw	r22, r18
    27f4:	90 01       	movw	r18, r0
    27f6:	0c 01       	movw	r0, r24
    27f8:	ca 01       	movw	r24, r20
    27fa:	a0 01       	movw	r20, r0
    27fc:	11 24       	eor	r1, r1
    27fe:	ff 27       	eor	r31, r31
    2800:	59 1b       	sub	r21, r25
    2802:	99 f0       	breq	.+38     	; 0x282a <__addsf3x+0x5c>
    2804:	59 3f       	cpi	r21, 0xF9	; 249
    2806:	50 f4       	brcc	.+20     	; 0x281c <__addsf3x+0x4e>
    2808:	50 3e       	cpi	r21, 0xE0	; 224
    280a:	68 f1       	brcs	.+90     	; 0x2866 <__addsf3x+0x98>
    280c:	1a 16       	cp	r1, r26
    280e:	f0 40       	sbci	r31, 0x00	; 0
    2810:	a2 2f       	mov	r26, r18
    2812:	23 2f       	mov	r18, r19
    2814:	34 2f       	mov	r19, r20
    2816:	44 27       	eor	r20, r20
    2818:	58 5f       	subi	r21, 0xF8	; 248
    281a:	f3 cf       	rjmp	.-26     	; 0x2802 <__addsf3x+0x34>
    281c:	46 95       	lsr	r20
    281e:	37 95       	ror	r19
    2820:	27 95       	ror	r18
    2822:	a7 95       	ror	r26
    2824:	f0 40       	sbci	r31, 0x00	; 0
    2826:	53 95       	inc	r21
    2828:	c9 f7       	brne	.-14     	; 0x281c <__addsf3x+0x4e>
    282a:	7e f4       	brtc	.+30     	; 0x284a <__addsf3x+0x7c>
    282c:	1f 16       	cp	r1, r31
    282e:	ba 0b       	sbc	r27, r26
    2830:	62 0b       	sbc	r22, r18
    2832:	73 0b       	sbc	r23, r19
    2834:	84 0b       	sbc	r24, r20
    2836:	ba f0       	brmi	.+46     	; 0x2866 <__addsf3x+0x98>
    2838:	91 50       	subi	r25, 0x01	; 1
    283a:	a1 f0       	breq	.+40     	; 0x2864 <__addsf3x+0x96>
    283c:	ff 0f       	add	r31, r31
    283e:	bb 1f       	adc	r27, r27
    2840:	66 1f       	adc	r22, r22
    2842:	77 1f       	adc	r23, r23
    2844:	88 1f       	adc	r24, r24
    2846:	c2 f7       	brpl	.-16     	; 0x2838 <__addsf3x+0x6a>
    2848:	0e c0       	rjmp	.+28     	; 0x2866 <__addsf3x+0x98>
    284a:	ba 0f       	add	r27, r26
    284c:	62 1f       	adc	r22, r18
    284e:	73 1f       	adc	r23, r19
    2850:	84 1f       	adc	r24, r20
    2852:	48 f4       	brcc	.+18     	; 0x2866 <__addsf3x+0x98>
    2854:	87 95       	ror	r24
    2856:	77 95       	ror	r23
    2858:	67 95       	ror	r22
    285a:	b7 95       	ror	r27
    285c:	f7 95       	ror	r31
    285e:	9e 3f       	cpi	r25, 0xFE	; 254
    2860:	08 f0       	brcs	.+2      	; 0x2864 <__addsf3x+0x96>
    2862:	b3 cf       	rjmp	.-154    	; 0x27ca <__addsf3+0x1e>
    2864:	93 95       	inc	r25
    2866:	88 0f       	add	r24, r24
    2868:	08 f0       	brcs	.+2      	; 0x286c <__addsf3x+0x9e>
    286a:	99 27       	eor	r25, r25
    286c:	ee 0f       	add	r30, r30
    286e:	97 95       	ror	r25
    2870:	87 95       	ror	r24
    2872:	08 95       	ret

00002874 <__fixsfsi>:
    2874:	04 d0       	rcall	.+8      	; 0x287e <__fixunssfsi>
    2876:	68 94       	set
    2878:	b1 11       	cpse	r27, r1
    287a:	b5 c0       	rjmp	.+362    	; 0x29e6 <__fp_szero>
    287c:	08 95       	ret

0000287e <__fixunssfsi>:
    287e:	98 d0       	rcall	.+304    	; 0x29b0 <__fp_splitA>
    2880:	88 f0       	brcs	.+34     	; 0x28a4 <__fixunssfsi+0x26>
    2882:	9f 57       	subi	r25, 0x7F	; 127
    2884:	90 f0       	brcs	.+36     	; 0x28aa <__fixunssfsi+0x2c>
    2886:	b9 2f       	mov	r27, r25
    2888:	99 27       	eor	r25, r25
    288a:	b7 51       	subi	r27, 0x17	; 23
    288c:	a0 f0       	brcs	.+40     	; 0x28b6 <__fixunssfsi+0x38>
    288e:	d1 f0       	breq	.+52     	; 0x28c4 <__fixunssfsi+0x46>
    2890:	66 0f       	add	r22, r22
    2892:	77 1f       	adc	r23, r23
    2894:	88 1f       	adc	r24, r24
    2896:	99 1f       	adc	r25, r25
    2898:	1a f0       	brmi	.+6      	; 0x28a0 <__fixunssfsi+0x22>
    289a:	ba 95       	dec	r27
    289c:	c9 f7       	brne	.-14     	; 0x2890 <__fixunssfsi+0x12>
    289e:	12 c0       	rjmp	.+36     	; 0x28c4 <__fixunssfsi+0x46>
    28a0:	b1 30       	cpi	r27, 0x01	; 1
    28a2:	81 f0       	breq	.+32     	; 0x28c4 <__fixunssfsi+0x46>
    28a4:	9f d0       	rcall	.+318    	; 0x29e4 <__fp_zero>
    28a6:	b1 e0       	ldi	r27, 0x01	; 1
    28a8:	08 95       	ret
    28aa:	9c c0       	rjmp	.+312    	; 0x29e4 <__fp_zero>
    28ac:	67 2f       	mov	r22, r23
    28ae:	78 2f       	mov	r23, r24
    28b0:	88 27       	eor	r24, r24
    28b2:	b8 5f       	subi	r27, 0xF8	; 248
    28b4:	39 f0       	breq	.+14     	; 0x28c4 <__fixunssfsi+0x46>
    28b6:	b9 3f       	cpi	r27, 0xF9	; 249
    28b8:	cc f3       	brlt	.-14     	; 0x28ac <__fixunssfsi+0x2e>
    28ba:	86 95       	lsr	r24
    28bc:	77 95       	ror	r23
    28be:	67 95       	ror	r22
    28c0:	b3 95       	inc	r27
    28c2:	d9 f7       	brne	.-10     	; 0x28ba <__fixunssfsi+0x3c>
    28c4:	3e f4       	brtc	.+14     	; 0x28d4 <__fixunssfsi+0x56>
    28c6:	90 95       	com	r25
    28c8:	80 95       	com	r24
    28ca:	70 95       	com	r23
    28cc:	61 95       	neg	r22
    28ce:	7f 4f       	sbci	r23, 0xFF	; 255
    28d0:	8f 4f       	sbci	r24, 0xFF	; 255
    28d2:	9f 4f       	sbci	r25, 0xFF	; 255
    28d4:	08 95       	ret

000028d6 <__floatunsisf>:
    28d6:	e8 94       	clt
    28d8:	09 c0       	rjmp	.+18     	; 0x28ec <__floatsisf+0x12>

000028da <__floatsisf>:
    28da:	97 fb       	bst	r25, 7
    28dc:	3e f4       	brtc	.+14     	; 0x28ec <__floatsisf+0x12>
    28de:	90 95       	com	r25
    28e0:	80 95       	com	r24
    28e2:	70 95       	com	r23
    28e4:	61 95       	neg	r22
    28e6:	7f 4f       	sbci	r23, 0xFF	; 255
    28e8:	8f 4f       	sbci	r24, 0xFF	; 255
    28ea:	9f 4f       	sbci	r25, 0xFF	; 255
    28ec:	99 23       	and	r25, r25
    28ee:	a9 f0       	breq	.+42     	; 0x291a <__floatsisf+0x40>
    28f0:	f9 2f       	mov	r31, r25
    28f2:	96 e9       	ldi	r25, 0x96	; 150
    28f4:	bb 27       	eor	r27, r27
    28f6:	93 95       	inc	r25
    28f8:	f6 95       	lsr	r31
    28fa:	87 95       	ror	r24
    28fc:	77 95       	ror	r23
    28fe:	67 95       	ror	r22
    2900:	b7 95       	ror	r27
    2902:	f1 11       	cpse	r31, r1
    2904:	f8 cf       	rjmp	.-16     	; 0x28f6 <__floatsisf+0x1c>
    2906:	fa f4       	brpl	.+62     	; 0x2946 <__floatsisf+0x6c>
    2908:	bb 0f       	add	r27, r27
    290a:	11 f4       	brne	.+4      	; 0x2910 <__floatsisf+0x36>
    290c:	60 ff       	sbrs	r22, 0
    290e:	1b c0       	rjmp	.+54     	; 0x2946 <__floatsisf+0x6c>
    2910:	6f 5f       	subi	r22, 0xFF	; 255
    2912:	7f 4f       	sbci	r23, 0xFF	; 255
    2914:	8f 4f       	sbci	r24, 0xFF	; 255
    2916:	9f 4f       	sbci	r25, 0xFF	; 255
    2918:	16 c0       	rjmp	.+44     	; 0x2946 <__floatsisf+0x6c>
    291a:	88 23       	and	r24, r24
    291c:	11 f0       	breq	.+4      	; 0x2922 <__floatsisf+0x48>
    291e:	96 e9       	ldi	r25, 0x96	; 150
    2920:	11 c0       	rjmp	.+34     	; 0x2944 <__floatsisf+0x6a>
    2922:	77 23       	and	r23, r23
    2924:	21 f0       	breq	.+8      	; 0x292e <__floatsisf+0x54>
    2926:	9e e8       	ldi	r25, 0x8E	; 142
    2928:	87 2f       	mov	r24, r23
    292a:	76 2f       	mov	r23, r22
    292c:	05 c0       	rjmp	.+10     	; 0x2938 <__floatsisf+0x5e>
    292e:	66 23       	and	r22, r22
    2930:	71 f0       	breq	.+28     	; 0x294e <__floatsisf+0x74>
    2932:	96 e8       	ldi	r25, 0x86	; 134
    2934:	86 2f       	mov	r24, r22
    2936:	70 e0       	ldi	r23, 0x00	; 0
    2938:	60 e0       	ldi	r22, 0x00	; 0
    293a:	2a f0       	brmi	.+10     	; 0x2946 <__floatsisf+0x6c>
    293c:	9a 95       	dec	r25
    293e:	66 0f       	add	r22, r22
    2940:	77 1f       	adc	r23, r23
    2942:	88 1f       	adc	r24, r24
    2944:	da f7       	brpl	.-10     	; 0x293c <__floatsisf+0x62>
    2946:	88 0f       	add	r24, r24
    2948:	96 95       	lsr	r25
    294a:	87 95       	ror	r24
    294c:	97 f9       	bld	r25, 7
    294e:	08 95       	ret

00002950 <__fp_inf>:
    2950:	97 f9       	bld	r25, 7
    2952:	9f 67       	ori	r25, 0x7F	; 127
    2954:	80 e8       	ldi	r24, 0x80	; 128
    2956:	70 e0       	ldi	r23, 0x00	; 0
    2958:	60 e0       	ldi	r22, 0x00	; 0
    295a:	08 95       	ret

0000295c <__fp_nan>:
    295c:	9f ef       	ldi	r25, 0xFF	; 255
    295e:	80 ec       	ldi	r24, 0xC0	; 192
    2960:	08 95       	ret

00002962 <__fp_pscA>:
    2962:	00 24       	eor	r0, r0
    2964:	0a 94       	dec	r0
    2966:	16 16       	cp	r1, r22
    2968:	17 06       	cpc	r1, r23
    296a:	18 06       	cpc	r1, r24
    296c:	09 06       	cpc	r0, r25
    296e:	08 95       	ret

00002970 <__fp_pscB>:
    2970:	00 24       	eor	r0, r0
    2972:	0a 94       	dec	r0
    2974:	12 16       	cp	r1, r18
    2976:	13 06       	cpc	r1, r19
    2978:	14 06       	cpc	r1, r20
    297a:	05 06       	cpc	r0, r21
    297c:	08 95       	ret

0000297e <__fp_round>:
    297e:	09 2e       	mov	r0, r25
    2980:	03 94       	inc	r0
    2982:	00 0c       	add	r0, r0
    2984:	11 f4       	brne	.+4      	; 0x298a <__fp_round+0xc>
    2986:	88 23       	and	r24, r24
    2988:	52 f0       	brmi	.+20     	; 0x299e <__fp_round+0x20>
    298a:	bb 0f       	add	r27, r27
    298c:	40 f4       	brcc	.+16     	; 0x299e <__fp_round+0x20>
    298e:	bf 2b       	or	r27, r31
    2990:	11 f4       	brne	.+4      	; 0x2996 <__fp_round+0x18>
    2992:	60 ff       	sbrs	r22, 0
    2994:	04 c0       	rjmp	.+8      	; 0x299e <__fp_round+0x20>
    2996:	6f 5f       	subi	r22, 0xFF	; 255
    2998:	7f 4f       	sbci	r23, 0xFF	; 255
    299a:	8f 4f       	sbci	r24, 0xFF	; 255
    299c:	9f 4f       	sbci	r25, 0xFF	; 255
    299e:	08 95       	ret

000029a0 <__fp_split3>:
    29a0:	57 fd       	sbrc	r21, 7
    29a2:	90 58       	subi	r25, 0x80	; 128
    29a4:	44 0f       	add	r20, r20
    29a6:	55 1f       	adc	r21, r21
    29a8:	59 f0       	breq	.+22     	; 0x29c0 <__fp_splitA+0x10>
    29aa:	5f 3f       	cpi	r21, 0xFF	; 255
    29ac:	71 f0       	breq	.+28     	; 0x29ca <__fp_splitA+0x1a>
    29ae:	47 95       	ror	r20

000029b0 <__fp_splitA>:
    29b0:	88 0f       	add	r24, r24
    29b2:	97 fb       	bst	r25, 7
    29b4:	99 1f       	adc	r25, r25
    29b6:	61 f0       	breq	.+24     	; 0x29d0 <__fp_splitA+0x20>
    29b8:	9f 3f       	cpi	r25, 0xFF	; 255
    29ba:	79 f0       	breq	.+30     	; 0x29da <__fp_splitA+0x2a>
    29bc:	87 95       	ror	r24
    29be:	08 95       	ret
    29c0:	12 16       	cp	r1, r18
    29c2:	13 06       	cpc	r1, r19
    29c4:	14 06       	cpc	r1, r20
    29c6:	55 1f       	adc	r21, r21
    29c8:	f2 cf       	rjmp	.-28     	; 0x29ae <__fp_split3+0xe>
    29ca:	46 95       	lsr	r20
    29cc:	f1 df       	rcall	.-30     	; 0x29b0 <__fp_splitA>
    29ce:	08 c0       	rjmp	.+16     	; 0x29e0 <__fp_splitA+0x30>
    29d0:	16 16       	cp	r1, r22
    29d2:	17 06       	cpc	r1, r23
    29d4:	18 06       	cpc	r1, r24
    29d6:	99 1f       	adc	r25, r25
    29d8:	f1 cf       	rjmp	.-30     	; 0x29bc <__fp_splitA+0xc>
    29da:	86 95       	lsr	r24
    29dc:	71 05       	cpc	r23, r1
    29de:	61 05       	cpc	r22, r1
    29e0:	08 94       	sec
    29e2:	08 95       	ret

000029e4 <__fp_zero>:
    29e4:	e8 94       	clt

000029e6 <__fp_szero>:
    29e6:	bb 27       	eor	r27, r27
    29e8:	66 27       	eor	r22, r22
    29ea:	77 27       	eor	r23, r23
    29ec:	cb 01       	movw	r24, r22
    29ee:	97 f9       	bld	r25, 7
    29f0:	08 95       	ret

000029f2 <__mulsf3>:
    29f2:	0b d0       	rcall	.+22     	; 0x2a0a <__mulsf3x>
    29f4:	c4 cf       	rjmp	.-120    	; 0x297e <__fp_round>
    29f6:	b5 df       	rcall	.-150    	; 0x2962 <__fp_pscA>
    29f8:	28 f0       	brcs	.+10     	; 0x2a04 <__mulsf3+0x12>
    29fa:	ba df       	rcall	.-140    	; 0x2970 <__fp_pscB>
    29fc:	18 f0       	brcs	.+6      	; 0x2a04 <__mulsf3+0x12>
    29fe:	95 23       	and	r25, r21
    2a00:	09 f0       	breq	.+2      	; 0x2a04 <__mulsf3+0x12>
    2a02:	a6 cf       	rjmp	.-180    	; 0x2950 <__fp_inf>
    2a04:	ab cf       	rjmp	.-170    	; 0x295c <__fp_nan>
    2a06:	11 24       	eor	r1, r1
    2a08:	ee cf       	rjmp	.-36     	; 0x29e6 <__fp_szero>

00002a0a <__mulsf3x>:
    2a0a:	ca df       	rcall	.-108    	; 0x29a0 <__fp_split3>
    2a0c:	a0 f3       	brcs	.-24     	; 0x29f6 <__mulsf3+0x4>

00002a0e <__mulsf3_pse>:
    2a0e:	95 9f       	mul	r25, r21
    2a10:	d1 f3       	breq	.-12     	; 0x2a06 <__mulsf3+0x14>
    2a12:	95 0f       	add	r25, r21
    2a14:	50 e0       	ldi	r21, 0x00	; 0
    2a16:	55 1f       	adc	r21, r21
    2a18:	62 9f       	mul	r22, r18
    2a1a:	f0 01       	movw	r30, r0
    2a1c:	72 9f       	mul	r23, r18
    2a1e:	bb 27       	eor	r27, r27
    2a20:	f0 0d       	add	r31, r0
    2a22:	b1 1d       	adc	r27, r1
    2a24:	63 9f       	mul	r22, r19
    2a26:	aa 27       	eor	r26, r26
    2a28:	f0 0d       	add	r31, r0
    2a2a:	b1 1d       	adc	r27, r1
    2a2c:	aa 1f       	adc	r26, r26
    2a2e:	64 9f       	mul	r22, r20
    2a30:	66 27       	eor	r22, r22
    2a32:	b0 0d       	add	r27, r0
    2a34:	a1 1d       	adc	r26, r1
    2a36:	66 1f       	adc	r22, r22
    2a38:	82 9f       	mul	r24, r18
    2a3a:	22 27       	eor	r18, r18
    2a3c:	b0 0d       	add	r27, r0
    2a3e:	a1 1d       	adc	r26, r1
    2a40:	62 1f       	adc	r22, r18
    2a42:	73 9f       	mul	r23, r19
    2a44:	b0 0d       	add	r27, r0
    2a46:	a1 1d       	adc	r26, r1
    2a48:	62 1f       	adc	r22, r18
    2a4a:	83 9f       	mul	r24, r19
    2a4c:	a0 0d       	add	r26, r0
    2a4e:	61 1d       	adc	r22, r1
    2a50:	22 1f       	adc	r18, r18
    2a52:	74 9f       	mul	r23, r20
    2a54:	33 27       	eor	r19, r19
    2a56:	a0 0d       	add	r26, r0
    2a58:	61 1d       	adc	r22, r1
    2a5a:	23 1f       	adc	r18, r19
    2a5c:	84 9f       	mul	r24, r20
    2a5e:	60 0d       	add	r22, r0
    2a60:	21 1d       	adc	r18, r1
    2a62:	82 2f       	mov	r24, r18
    2a64:	76 2f       	mov	r23, r22
    2a66:	6a 2f       	mov	r22, r26
    2a68:	11 24       	eor	r1, r1
    2a6a:	9f 57       	subi	r25, 0x7F	; 127
    2a6c:	50 40       	sbci	r21, 0x00	; 0
    2a6e:	8a f0       	brmi	.+34     	; 0x2a92 <__mulsf3_pse+0x84>
    2a70:	e1 f0       	breq	.+56     	; 0x2aaa <__mulsf3_pse+0x9c>
    2a72:	88 23       	and	r24, r24
    2a74:	4a f0       	brmi	.+18     	; 0x2a88 <__mulsf3_pse+0x7a>
    2a76:	ee 0f       	add	r30, r30
    2a78:	ff 1f       	adc	r31, r31
    2a7a:	bb 1f       	adc	r27, r27
    2a7c:	66 1f       	adc	r22, r22
    2a7e:	77 1f       	adc	r23, r23
    2a80:	88 1f       	adc	r24, r24
    2a82:	91 50       	subi	r25, 0x01	; 1
    2a84:	50 40       	sbci	r21, 0x00	; 0
    2a86:	a9 f7       	brne	.-22     	; 0x2a72 <__mulsf3_pse+0x64>
    2a88:	9e 3f       	cpi	r25, 0xFE	; 254
    2a8a:	51 05       	cpc	r21, r1
    2a8c:	70 f0       	brcs	.+28     	; 0x2aaa <__mulsf3_pse+0x9c>
    2a8e:	60 cf       	rjmp	.-320    	; 0x2950 <__fp_inf>
    2a90:	aa cf       	rjmp	.-172    	; 0x29e6 <__fp_szero>
    2a92:	5f 3f       	cpi	r21, 0xFF	; 255
    2a94:	ec f3       	brlt	.-6      	; 0x2a90 <__mulsf3_pse+0x82>
    2a96:	98 3e       	cpi	r25, 0xE8	; 232
    2a98:	dc f3       	brlt	.-10     	; 0x2a90 <__mulsf3_pse+0x82>
    2a9a:	86 95       	lsr	r24
    2a9c:	77 95       	ror	r23
    2a9e:	67 95       	ror	r22
    2aa0:	b7 95       	ror	r27
    2aa2:	f7 95       	ror	r31
    2aa4:	e7 95       	ror	r30
    2aa6:	9f 5f       	subi	r25, 0xFF	; 255
    2aa8:	c1 f7       	brne	.-16     	; 0x2a9a <__mulsf3_pse+0x8c>
    2aaa:	fe 2b       	or	r31, r30
    2aac:	88 0f       	add	r24, r24
    2aae:	91 1d       	adc	r25, r1
    2ab0:	96 95       	lsr	r25
    2ab2:	87 95       	ror	r24
    2ab4:	97 f9       	bld	r25, 7
    2ab6:	08 95       	ret

00002ab8 <pow>:
    2ab8:	fa 01       	movw	r30, r20
    2aba:	ee 0f       	add	r30, r30
    2abc:	ff 1f       	adc	r31, r31
    2abe:	30 96       	adiw	r30, 0x00	; 0
    2ac0:	21 05       	cpc	r18, r1
    2ac2:	31 05       	cpc	r19, r1
    2ac4:	99 f1       	breq	.+102    	; 0x2b2c <pow+0x74>
    2ac6:	61 15       	cp	r22, r1
    2ac8:	71 05       	cpc	r23, r1
    2aca:	61 f4       	brne	.+24     	; 0x2ae4 <pow+0x2c>
    2acc:	80 38       	cpi	r24, 0x80	; 128
    2ace:	bf e3       	ldi	r27, 0x3F	; 63
    2ad0:	9b 07       	cpc	r25, r27
    2ad2:	49 f1       	breq	.+82     	; 0x2b26 <pow+0x6e>
    2ad4:	68 94       	set
    2ad6:	90 38       	cpi	r25, 0x80	; 128
    2ad8:	81 05       	cpc	r24, r1
    2ada:	61 f0       	breq	.+24     	; 0x2af4 <pow+0x3c>
    2adc:	80 38       	cpi	r24, 0x80	; 128
    2ade:	bf ef       	ldi	r27, 0xFF	; 255
    2ae0:	9b 07       	cpc	r25, r27
    2ae2:	41 f0       	breq	.+16     	; 0x2af4 <pow+0x3c>
    2ae4:	99 23       	and	r25, r25
    2ae6:	42 f5       	brpl	.+80     	; 0x2b38 <pow+0x80>
    2ae8:	ff 3f       	cpi	r31, 0xFF	; 255
    2aea:	e1 05       	cpc	r30, r1
    2aec:	31 05       	cpc	r19, r1
    2aee:	21 05       	cpc	r18, r1
    2af0:	11 f1       	breq	.+68     	; 0x2b36 <pow+0x7e>
    2af2:	e8 94       	clt
    2af4:	08 94       	sec
    2af6:	e7 95       	ror	r30
    2af8:	d9 01       	movw	r26, r18
    2afa:	aa 23       	and	r26, r26
    2afc:	29 f4       	brne	.+10     	; 0x2b08 <pow+0x50>
    2afe:	ab 2f       	mov	r26, r27
    2b00:	be 2f       	mov	r27, r30
    2b02:	f8 5f       	subi	r31, 0xF8	; 248
    2b04:	d0 f3       	brcs	.-12     	; 0x2afa <pow+0x42>
    2b06:	10 c0       	rjmp	.+32     	; 0x2b28 <pow+0x70>
    2b08:	ff 5f       	subi	r31, 0xFF	; 255
    2b0a:	70 f4       	brcc	.+28     	; 0x2b28 <pow+0x70>
    2b0c:	a6 95       	lsr	r26
    2b0e:	e0 f7       	brcc	.-8      	; 0x2b08 <pow+0x50>
    2b10:	f7 39       	cpi	r31, 0x97	; 151
    2b12:	50 f0       	brcs	.+20     	; 0x2b28 <pow+0x70>
    2b14:	19 f0       	breq	.+6      	; 0x2b1c <pow+0x64>
    2b16:	ff 3a       	cpi	r31, 0xAF	; 175
    2b18:	38 f4       	brcc	.+14     	; 0x2b28 <pow+0x70>
    2b1a:	9f 77       	andi	r25, 0x7F	; 127
    2b1c:	9f 93       	push	r25
    2b1e:	0c d0       	rcall	.+24     	; 0x2b38 <pow+0x80>
    2b20:	0f 90       	pop	r0
    2b22:	07 fc       	sbrc	r0, 7
    2b24:	90 58       	subi	r25, 0x80	; 128
    2b26:	08 95       	ret
    2b28:	3e f0       	brts	.+14     	; 0x2b38 <pow+0x80>
    2b2a:	18 cf       	rjmp	.-464    	; 0x295c <__fp_nan>
    2b2c:	60 e0       	ldi	r22, 0x00	; 0
    2b2e:	70 e0       	ldi	r23, 0x00	; 0
    2b30:	80 e8       	ldi	r24, 0x80	; 128
    2b32:	9f e3       	ldi	r25, 0x3F	; 63
    2b34:	08 95       	ret
    2b36:	4f e7       	ldi	r20, 0x7F	; 127
    2b38:	9f 77       	andi	r25, 0x7F	; 127
    2b3a:	5f 93       	push	r21
    2b3c:	4f 93       	push	r20
    2b3e:	3f 93       	push	r19
    2b40:	2f 93       	push	r18
    2b42:	9e d0       	rcall	.+316    	; 0x2c80 <log>
    2b44:	2f 91       	pop	r18
    2b46:	3f 91       	pop	r19
    2b48:	4f 91       	pop	r20
    2b4a:	5f 91       	pop	r21
    2b4c:	52 df       	rcall	.-348    	; 0x29f2 <__mulsf3>
    2b4e:	05 c0       	rjmp	.+10     	; 0x2b5a <exp>
    2b50:	19 f4       	brne	.+6      	; 0x2b58 <pow+0xa0>
    2b52:	0e f0       	brts	.+2      	; 0x2b56 <pow+0x9e>
    2b54:	fd ce       	rjmp	.-518    	; 0x2950 <__fp_inf>
    2b56:	46 cf       	rjmp	.-372    	; 0x29e4 <__fp_zero>
    2b58:	01 cf       	rjmp	.-510    	; 0x295c <__fp_nan>

00002b5a <exp>:
    2b5a:	2a df       	rcall	.-428    	; 0x29b0 <__fp_splitA>
    2b5c:	c8 f3       	brcs	.-14     	; 0x2b50 <pow+0x98>
    2b5e:	96 38       	cpi	r25, 0x86	; 134
    2b60:	c0 f7       	brcc	.-16     	; 0x2b52 <pow+0x9a>
    2b62:	07 f8       	bld	r0, 7
    2b64:	0f 92       	push	r0
    2b66:	e8 94       	clt
    2b68:	2b e3       	ldi	r18, 0x3B	; 59
    2b6a:	3a ea       	ldi	r19, 0xAA	; 170
    2b6c:	48 eb       	ldi	r20, 0xB8	; 184
    2b6e:	5f e7       	ldi	r21, 0x7F	; 127
    2b70:	4e df       	rcall	.-356    	; 0x2a0e <__mulsf3_pse>
    2b72:	0f 92       	push	r0
    2b74:	0f 92       	push	r0
    2b76:	0f 92       	push	r0
    2b78:	4d b7       	in	r20, 0x3d	; 61
    2b7a:	5e b7       	in	r21, 0x3e	; 62
    2b7c:	0f 92       	push	r0
    2b7e:	c0 d0       	rcall	.+384    	; 0x2d00 <modf>
    2b80:	e4 ee       	ldi	r30, 0xE4	; 228
    2b82:	f0 e0       	ldi	r31, 0x00	; 0
    2b84:	16 d0       	rcall	.+44     	; 0x2bb2 <__fp_powser>
    2b86:	4f 91       	pop	r20
    2b88:	5f 91       	pop	r21
    2b8a:	ef 91       	pop	r30
    2b8c:	ff 91       	pop	r31
    2b8e:	e5 95       	asr	r30
    2b90:	ee 1f       	adc	r30, r30
    2b92:	ff 1f       	adc	r31, r31
    2b94:	49 f0       	breq	.+18     	; 0x2ba8 <exp+0x4e>
    2b96:	fe 57       	subi	r31, 0x7E	; 126
    2b98:	e0 68       	ori	r30, 0x80	; 128
    2b9a:	44 27       	eor	r20, r20
    2b9c:	ee 0f       	add	r30, r30
    2b9e:	44 1f       	adc	r20, r20
    2ba0:	fa 95       	dec	r31
    2ba2:	e1 f7       	brne	.-8      	; 0x2b9c <exp+0x42>
    2ba4:	41 95       	neg	r20
    2ba6:	55 0b       	sbc	r21, r21
    2ba8:	32 d0       	rcall	.+100    	; 0x2c0e <ldexp>
    2baa:	0f 90       	pop	r0
    2bac:	07 fe       	sbrs	r0, 7
    2bae:	26 c0       	rjmp	.+76     	; 0x2bfc <inverse>
    2bb0:	08 95       	ret

00002bb2 <__fp_powser>:
    2bb2:	df 93       	push	r29
    2bb4:	cf 93       	push	r28
    2bb6:	1f 93       	push	r17
    2bb8:	0f 93       	push	r16
    2bba:	ff 92       	push	r15
    2bbc:	ef 92       	push	r14
    2bbe:	df 92       	push	r13
    2bc0:	7b 01       	movw	r14, r22
    2bc2:	8c 01       	movw	r16, r24
    2bc4:	68 94       	set
    2bc6:	05 c0       	rjmp	.+10     	; 0x2bd2 <__fp_powser+0x20>
    2bc8:	da 2e       	mov	r13, r26
    2bca:	ef 01       	movw	r28, r30
    2bcc:	1e df       	rcall	.-452    	; 0x2a0a <__mulsf3x>
    2bce:	fe 01       	movw	r30, r28
    2bd0:	e8 94       	clt
    2bd2:	a5 91       	lpm	r26, Z+
    2bd4:	25 91       	lpm	r18, Z+
    2bd6:	35 91       	lpm	r19, Z+
    2bd8:	45 91       	lpm	r20, Z+
    2bda:	55 91       	lpm	r21, Z+
    2bdc:	ae f3       	brts	.-22     	; 0x2bc8 <__fp_powser+0x16>
    2bde:	ef 01       	movw	r28, r30
    2be0:	f6 dd       	rcall	.-1044   	; 0x27ce <__addsf3x>
    2be2:	fe 01       	movw	r30, r28
    2be4:	97 01       	movw	r18, r14
    2be6:	a8 01       	movw	r20, r16
    2be8:	da 94       	dec	r13
    2bea:	79 f7       	brne	.-34     	; 0x2bca <__fp_powser+0x18>
    2bec:	df 90       	pop	r13
    2bee:	ef 90       	pop	r14
    2bf0:	ff 90       	pop	r15
    2bf2:	0f 91       	pop	r16
    2bf4:	1f 91       	pop	r17
    2bf6:	cf 91       	pop	r28
    2bf8:	df 91       	pop	r29
    2bfa:	08 95       	ret

00002bfc <inverse>:
    2bfc:	9b 01       	movw	r18, r22
    2bfe:	ac 01       	movw	r20, r24
    2c00:	60 e0       	ldi	r22, 0x00	; 0
    2c02:	70 e0       	ldi	r23, 0x00	; 0
    2c04:	80 e8       	ldi	r24, 0x80	; 128
    2c06:	9f e3       	ldi	r25, 0x3F	; 63
    2c08:	ae c0       	rjmp	.+348    	; 0x2d66 <__divsf3>
    2c0a:	a2 ce       	rjmp	.-700    	; 0x2950 <__fp_inf>
    2c0c:	14 c1       	rjmp	.+552    	; 0x2e36 <__fp_mpack>

00002c0e <ldexp>:
    2c0e:	d0 de       	rcall	.-608    	; 0x29b0 <__fp_splitA>
    2c10:	e8 f3       	brcs	.-6      	; 0x2c0c <inverse+0x10>
    2c12:	99 23       	and	r25, r25
    2c14:	d9 f3       	breq	.-10     	; 0x2c0c <inverse+0x10>
    2c16:	94 0f       	add	r25, r20
    2c18:	51 1d       	adc	r21, r1
    2c1a:	bb f3       	brvs	.-18     	; 0x2c0a <inverse+0xe>
    2c1c:	91 50       	subi	r25, 0x01	; 1
    2c1e:	50 40       	sbci	r21, 0x00	; 0
    2c20:	94 f0       	brlt	.+36     	; 0x2c46 <ldexp+0x38>
    2c22:	59 f0       	breq	.+22     	; 0x2c3a <ldexp+0x2c>
    2c24:	88 23       	and	r24, r24
    2c26:	32 f0       	brmi	.+12     	; 0x2c34 <ldexp+0x26>
    2c28:	66 0f       	add	r22, r22
    2c2a:	77 1f       	adc	r23, r23
    2c2c:	88 1f       	adc	r24, r24
    2c2e:	91 50       	subi	r25, 0x01	; 1
    2c30:	50 40       	sbci	r21, 0x00	; 0
    2c32:	c1 f7       	brne	.-16     	; 0x2c24 <ldexp+0x16>
    2c34:	9e 3f       	cpi	r25, 0xFE	; 254
    2c36:	51 05       	cpc	r21, r1
    2c38:	44 f7       	brge	.-48     	; 0x2c0a <inverse+0xe>
    2c3a:	88 0f       	add	r24, r24
    2c3c:	91 1d       	adc	r25, r1
    2c3e:	96 95       	lsr	r25
    2c40:	87 95       	ror	r24
    2c42:	97 f9       	bld	r25, 7
    2c44:	08 95       	ret
    2c46:	5f 3f       	cpi	r21, 0xFF	; 255
    2c48:	ac f0       	brlt	.+42     	; 0x2c74 <ldexp+0x66>
    2c4a:	98 3e       	cpi	r25, 0xE8	; 232
    2c4c:	9c f0       	brlt	.+38     	; 0x2c74 <ldexp+0x66>
    2c4e:	bb 27       	eor	r27, r27
    2c50:	86 95       	lsr	r24
    2c52:	77 95       	ror	r23
    2c54:	67 95       	ror	r22
    2c56:	b7 95       	ror	r27
    2c58:	08 f4       	brcc	.+2      	; 0x2c5c <ldexp+0x4e>
    2c5a:	b1 60       	ori	r27, 0x01	; 1
    2c5c:	93 95       	inc	r25
    2c5e:	c1 f7       	brne	.-16     	; 0x2c50 <ldexp+0x42>
    2c60:	bb 0f       	add	r27, r27
    2c62:	58 f7       	brcc	.-42     	; 0x2c3a <ldexp+0x2c>
    2c64:	11 f4       	brne	.+4      	; 0x2c6a <ldexp+0x5c>
    2c66:	60 ff       	sbrs	r22, 0
    2c68:	e8 cf       	rjmp	.-48     	; 0x2c3a <ldexp+0x2c>
    2c6a:	6f 5f       	subi	r22, 0xFF	; 255
    2c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c6e:	8f 4f       	sbci	r24, 0xFF	; 255
    2c70:	9f 4f       	sbci	r25, 0xFF	; 255
    2c72:	e3 cf       	rjmp	.-58     	; 0x2c3a <ldexp+0x2c>
    2c74:	b8 ce       	rjmp	.-656    	; 0x29e6 <__fp_szero>
    2c76:	0e f0       	brts	.+2      	; 0x2c7a <ldexp+0x6c>
    2c78:	de c0       	rjmp	.+444    	; 0x2e36 <__fp_mpack>
    2c7a:	70 ce       	rjmp	.-800    	; 0x295c <__fp_nan>
    2c7c:	68 94       	set
    2c7e:	68 ce       	rjmp	.-816    	; 0x2950 <__fp_inf>

00002c80 <log>:
    2c80:	97 de       	rcall	.-722    	; 0x29b0 <__fp_splitA>
    2c82:	c8 f3       	brcs	.-14     	; 0x2c76 <ldexp+0x68>
    2c84:	99 23       	and	r25, r25
    2c86:	d1 f3       	breq	.-12     	; 0x2c7c <ldexp+0x6e>
    2c88:	c6 f3       	brts	.-16     	; 0x2c7a <ldexp+0x6c>
    2c8a:	df 93       	push	r29
    2c8c:	cf 93       	push	r28
    2c8e:	1f 93       	push	r17
    2c90:	0f 93       	push	r16
    2c92:	ff 92       	push	r15
    2c94:	c9 2f       	mov	r28, r25
    2c96:	dd 27       	eor	r29, r29
    2c98:	88 23       	and	r24, r24
    2c9a:	2a f0       	brmi	.+10     	; 0x2ca6 <log+0x26>
    2c9c:	21 97       	sbiw	r28, 0x01	; 1
    2c9e:	66 0f       	add	r22, r22
    2ca0:	77 1f       	adc	r23, r23
    2ca2:	88 1f       	adc	r24, r24
    2ca4:	da f7       	brpl	.-10     	; 0x2c9c <log+0x1c>
    2ca6:	20 e0       	ldi	r18, 0x00	; 0
    2ca8:	30 e0       	ldi	r19, 0x00	; 0
    2caa:	40 e8       	ldi	r20, 0x80	; 128
    2cac:	5f eb       	ldi	r21, 0xBF	; 191
    2cae:	9f e3       	ldi	r25, 0x3F	; 63
    2cb0:	88 39       	cpi	r24, 0x98	; 152
    2cb2:	20 f0       	brcs	.+8      	; 0x2cbc <log+0x3c>
    2cb4:	80 3e       	cpi	r24, 0xE0	; 224
    2cb6:	30 f0       	brcs	.+12     	; 0x2cc4 <log+0x44>
    2cb8:	21 96       	adiw	r28, 0x01	; 1
    2cba:	8f 77       	andi	r24, 0x7F	; 127
    2cbc:	77 dd       	rcall	.-1298   	; 0x27ac <__addsf3>
    2cbe:	ec e0       	ldi	r30, 0x0C	; 12
    2cc0:	f1 e0       	ldi	r31, 0x01	; 1
    2cc2:	03 c0       	rjmp	.+6      	; 0x2cca <log+0x4a>
    2cc4:	73 dd       	rcall	.-1306   	; 0x27ac <__addsf3>
    2cc6:	e9 e3       	ldi	r30, 0x39	; 57
    2cc8:	f1 e0       	ldi	r31, 0x01	; 1
    2cca:	73 df       	rcall	.-282    	; 0x2bb2 <__fp_powser>
    2ccc:	8b 01       	movw	r16, r22
    2cce:	be 01       	movw	r22, r28
    2cd0:	ec 01       	movw	r28, r24
    2cd2:	fb 2e       	mov	r15, r27
    2cd4:	6f 57       	subi	r22, 0x7F	; 127
    2cd6:	71 09       	sbc	r23, r1
    2cd8:	75 95       	asr	r23
    2cda:	77 1f       	adc	r23, r23
    2cdc:	88 0b       	sbc	r24, r24
    2cde:	99 0b       	sbc	r25, r25
    2ce0:	fc dd       	rcall	.-1032   	; 0x28da <__floatsisf>
    2ce2:	28 e1       	ldi	r18, 0x18	; 24
    2ce4:	32 e7       	ldi	r19, 0x72	; 114
    2ce6:	41 e3       	ldi	r20, 0x31	; 49
    2ce8:	5f e3       	ldi	r21, 0x3F	; 63
    2cea:	8f de       	rcall	.-738    	; 0x2a0a <__mulsf3x>
    2cec:	af 2d       	mov	r26, r15
    2cee:	98 01       	movw	r18, r16
    2cf0:	ae 01       	movw	r20, r28
    2cf2:	ff 90       	pop	r15
    2cf4:	0f 91       	pop	r16
    2cf6:	1f 91       	pop	r17
    2cf8:	cf 91       	pop	r28
    2cfa:	df 91       	pop	r29
    2cfc:	68 dd       	rcall	.-1328   	; 0x27ce <__addsf3x>
    2cfe:	3f ce       	rjmp	.-898    	; 0x297e <__fp_round>

00002d00 <modf>:
    2d00:	fa 01       	movw	r30, r20
    2d02:	dc 01       	movw	r26, r24
    2d04:	aa 0f       	add	r26, r26
    2d06:	bb 1f       	adc	r27, r27
    2d08:	9b 01       	movw	r18, r22
    2d0a:	ac 01       	movw	r20, r24
    2d0c:	bf 57       	subi	r27, 0x7F	; 127
    2d0e:	28 f4       	brcc	.+10     	; 0x2d1a <modf+0x1a>
    2d10:	22 27       	eor	r18, r18
    2d12:	33 27       	eor	r19, r19
    2d14:	44 27       	eor	r20, r20
    2d16:	50 78       	andi	r21, 0x80	; 128
    2d18:	1f c0       	rjmp	.+62     	; 0x2d58 <modf+0x58>
    2d1a:	b7 51       	subi	r27, 0x17	; 23
    2d1c:	88 f4       	brcc	.+34     	; 0x2d40 <modf+0x40>
    2d1e:	ab 2f       	mov	r26, r27
    2d20:	00 24       	eor	r0, r0
    2d22:	46 95       	lsr	r20
    2d24:	37 95       	ror	r19
    2d26:	27 95       	ror	r18
    2d28:	01 1c       	adc	r0, r1
    2d2a:	a3 95       	inc	r26
    2d2c:	d2 f3       	brmi	.-12     	; 0x2d22 <modf+0x22>
    2d2e:	00 20       	and	r0, r0
    2d30:	69 f0       	breq	.+26     	; 0x2d4c <modf+0x4c>
    2d32:	22 0f       	add	r18, r18
    2d34:	33 1f       	adc	r19, r19
    2d36:	44 1f       	adc	r20, r20
    2d38:	b3 95       	inc	r27
    2d3a:	da f3       	brmi	.-10     	; 0x2d32 <modf+0x32>
    2d3c:	0d d0       	rcall	.+26     	; 0x2d58 <modf+0x58>
    2d3e:	35 cd       	rjmp	.-1430   	; 0x27aa <__subsf3>
    2d40:	61 30       	cpi	r22, 0x01	; 1
    2d42:	71 05       	cpc	r23, r1
    2d44:	a0 e8       	ldi	r26, 0x80	; 128
    2d46:	8a 07       	cpc	r24, r26
    2d48:	b9 46       	sbci	r27, 0x69	; 105
    2d4a:	30 f4       	brcc	.+12     	; 0x2d58 <modf+0x58>
    2d4c:	9b 01       	movw	r18, r22
    2d4e:	ac 01       	movw	r20, r24
    2d50:	66 27       	eor	r22, r22
    2d52:	77 27       	eor	r23, r23
    2d54:	88 27       	eor	r24, r24
    2d56:	90 78       	andi	r25, 0x80	; 128
    2d58:	30 96       	adiw	r30, 0x00	; 0
    2d5a:	21 f0       	breq	.+8      	; 0x2d64 <modf+0x64>
    2d5c:	20 83       	st	Z, r18
    2d5e:	31 83       	std	Z+1, r19	; 0x01
    2d60:	42 83       	std	Z+2, r20	; 0x02
    2d62:	53 83       	std	Z+3, r21	; 0x03
    2d64:	08 95       	ret

00002d66 <__divsf3>:
    2d66:	0c d0       	rcall	.+24     	; 0x2d80 <__divsf3x>
    2d68:	0a ce       	rjmp	.-1004   	; 0x297e <__fp_round>
    2d6a:	02 de       	rcall	.-1020   	; 0x2970 <__fp_pscB>
    2d6c:	40 f0       	brcs	.+16     	; 0x2d7e <__divsf3+0x18>
    2d6e:	f9 dd       	rcall	.-1038   	; 0x2962 <__fp_pscA>
    2d70:	30 f0       	brcs	.+12     	; 0x2d7e <__divsf3+0x18>
    2d72:	21 f4       	brne	.+8      	; 0x2d7c <__divsf3+0x16>
    2d74:	5f 3f       	cpi	r21, 0xFF	; 255
    2d76:	19 f0       	breq	.+6      	; 0x2d7e <__divsf3+0x18>
    2d78:	eb cd       	rjmp	.-1066   	; 0x2950 <__fp_inf>
    2d7a:	51 11       	cpse	r21, r1
    2d7c:	34 ce       	rjmp	.-920    	; 0x29e6 <__fp_szero>
    2d7e:	ee cd       	rjmp	.-1060   	; 0x295c <__fp_nan>

00002d80 <__divsf3x>:
    2d80:	0f de       	rcall	.-994    	; 0x29a0 <__fp_split3>
    2d82:	98 f3       	brcs	.-26     	; 0x2d6a <__divsf3+0x4>

00002d84 <__divsf3_pse>:
    2d84:	99 23       	and	r25, r25
    2d86:	c9 f3       	breq	.-14     	; 0x2d7a <__divsf3+0x14>
    2d88:	55 23       	and	r21, r21
    2d8a:	b1 f3       	breq	.-20     	; 0x2d78 <__divsf3+0x12>
    2d8c:	95 1b       	sub	r25, r21
    2d8e:	55 0b       	sbc	r21, r21
    2d90:	bb 27       	eor	r27, r27
    2d92:	aa 27       	eor	r26, r26
    2d94:	62 17       	cp	r22, r18
    2d96:	73 07       	cpc	r23, r19
    2d98:	84 07       	cpc	r24, r20
    2d9a:	38 f0       	brcs	.+14     	; 0x2daa <__divsf3_pse+0x26>
    2d9c:	9f 5f       	subi	r25, 0xFF	; 255
    2d9e:	5f 4f       	sbci	r21, 0xFF	; 255
    2da0:	22 0f       	add	r18, r18
    2da2:	33 1f       	adc	r19, r19
    2da4:	44 1f       	adc	r20, r20
    2da6:	aa 1f       	adc	r26, r26
    2da8:	a9 f3       	breq	.-22     	; 0x2d94 <__divsf3_pse+0x10>
    2daa:	33 d0       	rcall	.+102    	; 0x2e12 <__divsf3_pse+0x8e>
    2dac:	0e 2e       	mov	r0, r30
    2dae:	3a f0       	brmi	.+14     	; 0x2dbe <__divsf3_pse+0x3a>
    2db0:	e0 e8       	ldi	r30, 0x80	; 128
    2db2:	30 d0       	rcall	.+96     	; 0x2e14 <__divsf3_pse+0x90>
    2db4:	91 50       	subi	r25, 0x01	; 1
    2db6:	50 40       	sbci	r21, 0x00	; 0
    2db8:	e6 95       	lsr	r30
    2dba:	00 1c       	adc	r0, r0
    2dbc:	ca f7       	brpl	.-14     	; 0x2db0 <__divsf3_pse+0x2c>
    2dbe:	29 d0       	rcall	.+82     	; 0x2e12 <__divsf3_pse+0x8e>
    2dc0:	fe 2f       	mov	r31, r30
    2dc2:	27 d0       	rcall	.+78     	; 0x2e12 <__divsf3_pse+0x8e>
    2dc4:	66 0f       	add	r22, r22
    2dc6:	77 1f       	adc	r23, r23
    2dc8:	88 1f       	adc	r24, r24
    2dca:	bb 1f       	adc	r27, r27
    2dcc:	26 17       	cp	r18, r22
    2dce:	37 07       	cpc	r19, r23
    2dd0:	48 07       	cpc	r20, r24
    2dd2:	ab 07       	cpc	r26, r27
    2dd4:	b0 e8       	ldi	r27, 0x80	; 128
    2dd6:	09 f0       	breq	.+2      	; 0x2dda <__divsf3_pse+0x56>
    2dd8:	bb 0b       	sbc	r27, r27
    2dda:	80 2d       	mov	r24, r0
    2ddc:	bf 01       	movw	r22, r30
    2dde:	ff 27       	eor	r31, r31
    2de0:	93 58       	subi	r25, 0x83	; 131
    2de2:	5f 4f       	sbci	r21, 0xFF	; 255
    2de4:	2a f0       	brmi	.+10     	; 0x2df0 <__divsf3_pse+0x6c>
    2de6:	9e 3f       	cpi	r25, 0xFE	; 254
    2de8:	51 05       	cpc	r21, r1
    2dea:	68 f0       	brcs	.+26     	; 0x2e06 <__divsf3_pse+0x82>
    2dec:	b1 cd       	rjmp	.-1182   	; 0x2950 <__fp_inf>
    2dee:	fb cd       	rjmp	.-1034   	; 0x29e6 <__fp_szero>
    2df0:	5f 3f       	cpi	r21, 0xFF	; 255
    2df2:	ec f3       	brlt	.-6      	; 0x2dee <__divsf3_pse+0x6a>
    2df4:	98 3e       	cpi	r25, 0xE8	; 232
    2df6:	dc f3       	brlt	.-10     	; 0x2dee <__divsf3_pse+0x6a>
    2df8:	86 95       	lsr	r24
    2dfa:	77 95       	ror	r23
    2dfc:	67 95       	ror	r22
    2dfe:	b7 95       	ror	r27
    2e00:	f7 95       	ror	r31
    2e02:	9f 5f       	subi	r25, 0xFF	; 255
    2e04:	c9 f7       	brne	.-14     	; 0x2df8 <__divsf3_pse+0x74>
    2e06:	88 0f       	add	r24, r24
    2e08:	91 1d       	adc	r25, r1
    2e0a:	96 95       	lsr	r25
    2e0c:	87 95       	ror	r24
    2e0e:	97 f9       	bld	r25, 7
    2e10:	08 95       	ret
    2e12:	e1 e0       	ldi	r30, 0x01	; 1
    2e14:	66 0f       	add	r22, r22
    2e16:	77 1f       	adc	r23, r23
    2e18:	88 1f       	adc	r24, r24
    2e1a:	bb 1f       	adc	r27, r27
    2e1c:	62 17       	cp	r22, r18
    2e1e:	73 07       	cpc	r23, r19
    2e20:	84 07       	cpc	r24, r20
    2e22:	ba 07       	cpc	r27, r26
    2e24:	20 f0       	brcs	.+8      	; 0x2e2e <__divsf3_pse+0xaa>
    2e26:	62 1b       	sub	r22, r18
    2e28:	73 0b       	sbc	r23, r19
    2e2a:	84 0b       	sbc	r24, r20
    2e2c:	ba 0b       	sbc	r27, r26
    2e2e:	ee 1f       	adc	r30, r30
    2e30:	88 f7       	brcc	.-30     	; 0x2e14 <__divsf3_pse+0x90>
    2e32:	e0 95       	com	r30
    2e34:	08 95       	ret

00002e36 <__fp_mpack>:
    2e36:	9f 3f       	cpi	r25, 0xFF	; 255
    2e38:	31 f0       	breq	.+12     	; 0x2e46 <__fp_mpack_finite+0xc>

00002e3a <__fp_mpack_finite>:
    2e3a:	91 50       	subi	r25, 0x01	; 1
    2e3c:	20 f4       	brcc	.+8      	; 0x2e46 <__fp_mpack_finite+0xc>
    2e3e:	87 95       	ror	r24
    2e40:	77 95       	ror	r23
    2e42:	67 95       	ror	r22
    2e44:	b7 95       	ror	r27
    2e46:	88 0f       	add	r24, r24
    2e48:	91 1d       	adc	r25, r1
    2e4a:	96 95       	lsr	r25
    2e4c:	87 95       	ror	r24
    2e4e:	97 f9       	bld	r25, 7
    2e50:	08 95       	ret

00002e52 <__divmodhi4>:
    2e52:	97 fb       	bst	r25, 7
    2e54:	07 2e       	mov	r0, r23
    2e56:	16 f4       	brtc	.+4      	; 0x2e5c <__divmodhi4+0xa>
    2e58:	00 94       	com	r0
    2e5a:	06 d0       	rcall	.+12     	; 0x2e68 <__divmodhi4_neg1>
    2e5c:	77 fd       	sbrc	r23, 7
    2e5e:	08 d0       	rcall	.+16     	; 0x2e70 <__divmodhi4_neg2>
    2e60:	0b d0       	rcall	.+22     	; 0x2e78 <__udivmodhi4>
    2e62:	07 fc       	sbrc	r0, 7
    2e64:	05 d0       	rcall	.+10     	; 0x2e70 <__divmodhi4_neg2>
    2e66:	3e f4       	brtc	.+14     	; 0x2e76 <__divmodhi4_exit>

00002e68 <__divmodhi4_neg1>:
    2e68:	90 95       	com	r25
    2e6a:	81 95       	neg	r24
    2e6c:	9f 4f       	sbci	r25, 0xFF	; 255
    2e6e:	08 95       	ret

00002e70 <__divmodhi4_neg2>:
    2e70:	70 95       	com	r23
    2e72:	61 95       	neg	r22
    2e74:	7f 4f       	sbci	r23, 0xFF	; 255

00002e76 <__divmodhi4_exit>:
    2e76:	08 95       	ret

00002e78 <__udivmodhi4>:
    2e78:	aa 1b       	sub	r26, r26
    2e7a:	bb 1b       	sub	r27, r27
    2e7c:	51 e1       	ldi	r21, 0x11	; 17
    2e7e:	07 c0       	rjmp	.+14     	; 0x2e8e <__udivmodhi4_ep>

00002e80 <__udivmodhi4_loop>:
    2e80:	aa 1f       	adc	r26, r26
    2e82:	bb 1f       	adc	r27, r27
    2e84:	a6 17       	cp	r26, r22
    2e86:	b7 07       	cpc	r27, r23
    2e88:	10 f0       	brcs	.+4      	; 0x2e8e <__udivmodhi4_ep>
    2e8a:	a6 1b       	sub	r26, r22
    2e8c:	b7 0b       	sbc	r27, r23

00002e8e <__udivmodhi4_ep>:
    2e8e:	88 1f       	adc	r24, r24
    2e90:	99 1f       	adc	r25, r25
    2e92:	5a 95       	dec	r21
    2e94:	a9 f7       	brne	.-22     	; 0x2e80 <__udivmodhi4_loop>
    2e96:	80 95       	com	r24
    2e98:	90 95       	com	r25
    2e9a:	bc 01       	movw	r22, r24
    2e9c:	cd 01       	movw	r24, r26
    2e9e:	08 95       	ret

00002ea0 <memcpy>:
    2ea0:	fb 01       	movw	r30, r22
    2ea2:	dc 01       	movw	r26, r24
    2ea4:	02 c0       	rjmp	.+4      	; 0x2eaa <memcpy+0xa>
    2ea6:	01 90       	ld	r0, Z+
    2ea8:	0d 92       	st	X+, r0
    2eaa:	41 50       	subi	r20, 0x01	; 1
    2eac:	50 40       	sbci	r21, 0x00	; 0
    2eae:	d8 f7       	brcc	.-10     	; 0x2ea6 <memcpy+0x6>
    2eb0:	08 95       	ret

00002eb2 <_exit>:
    2eb2:	f8 94       	cli

00002eb4 <__stop_program>:
    2eb4:	ff cf       	rjmp	.-2      	; 0x2eb4 <__stop_program>
