
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800200  000022f2  00002386  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022f2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000700  00800256  00800256  000023dc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023dc  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  0000240c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000534f  00000000  00000000  000028c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001428  00000000  00000000  00007c13  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000032cb  00000000  00000000  0000903b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d68  00000000  00000000  0000c308  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000151a  00000000  00000000  0000d070  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003862  00000000  00000000  0000e58a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011dec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	d5 c2       	rjmp	.+1450   	; 0x5d0 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 2d 08 	jmp	0x105a	; 0x105a <__vector_21>
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	39 c5       	rjmp	.+2674   	; 0xad8 <__vector_25>
      66:	00 00       	nop
      68:	a5 c5       	rjmp	.+2890   	; 0xbb4 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	8f c3       	rjmp	.+1822   	; 0x794 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	eb c4       	rjmp	.+2518   	; 0xa68 <__vector_36>
      92:	00 00       	nop
      94:	59 c5       	rjmp	.+2738   	; 0xb48 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ef       	ldi	r30, 0xF2	; 242
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a6 35       	cpi	r26, 0x56	; 86
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a6 e5       	ldi	r26, 0x56	; 86
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a6 35       	cpi	r26, 0x56	; 86
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	41 d1       	rcall	.+642    	; 0x3a2 <main>
     120:	0c 94 77 11 	jmp	0x22ee	; 0x22ee <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	19 d6       	rcall	.+3122   	; 0xd5a <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	e7 d5       	rcall	.+3022   	; 0xcfc <myUSART_transmitUSART0>
     12e:	fb cf       	rjmp	.-10     	; 0x126 <RPI_receiveTask>

00000130 <RPI_sendTask>:
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	00 d0       	rcall	.+0      	; 0x136 <RPI_sendTask+0x6>
     136:	00 d0       	rcall	.+0      	; 0x138 <RPI_sendTask+0x8>
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	4f ef       	ldi	r20, 0xFF	; 255
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	be 01       	movw	r22, r28
     144:	6a 5f       	subi	r22, 0xFA	; 250
     146:	7f 4f       	sbci	r23, 0xFF	; 255
     148:	80 91 a1 08 	lds	r24, 0x08A1
     14c:	90 91 a2 08 	lds	r25, 0x08A2
     150:	0e 94 49 0a 	call	0x1492	; 0x1492 <xQueueGenericReceive>
     154:	8e 81       	ldd	r24, Y+6	; 0x06
     156:	9f ef       	ldi	r25, 0xFF	; 255
     158:	98 0f       	add	r25, r24
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	88 23       	and	r24, r24
     15e:	e9 f0       	breq	.+58     	; 0x19a <RPI_sendTask+0x6a>
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	be 01       	movw	r22, r28
     168:	6f 5f       	subi	r22, 0xFF	; 255
     16a:	7f 4f       	sbci	r23, 0xFF	; 255
     16c:	80 91 a3 08 	lds	r24, 0x08A3
     170:	90 91 a4 08 	lds	r25, 0x08A4
     174:	0e 94 49 0a 	call	0x1492	; 0x1492 <xQueueGenericReceive>
     178:	89 81       	ldd	r24, Y+1	; 0x01
     17a:	92 d5       	rcall	.+2852   	; 0xca0 <myUSART_transmitUSART0_c>
     17c:	8d e1       	ldi	r24, 0x1D	; 29
     17e:	92 e0       	ldi	r25, 0x02	; 2
     180:	bd d5       	rcall	.+2938   	; 0xcfc <myUSART_transmitUSART0>
     182:	ce 01       	movw	r24, r28
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	ba d5       	rcall	.+2932   	; 0xcfc <myUSART_transmitUSART0>
     188:	80 e2       	ldi	r24, 0x20	; 32
     18a:	92 e0       	ldi	r25, 0x02	; 2
     18c:	b7 d5       	rcall	.+2926   	; 0xcfc <myUSART_transmitUSART0>
     18e:	8e 81       	ldd	r24, Y+6	; 0x06
     190:	9f ef       	ldi	r25, 0xFF	; 255
     192:	98 0f       	add	r25, r24
     194:	9e 83       	std	Y+6, r25	; 0x06
     196:	81 11       	cpse	r24, r1
     198:	e3 cf       	rjmp	.-58     	; 0x160 <RPI_sendTask+0x30>
     19a:	8a e0       	ldi	r24, 0x0A	; 10
     19c:	81 d5       	rcall	.+2818   	; 0xca0 <myUSART_transmitUSART0_c>
     19e:	84 ef       	ldi	r24, 0xF4	; 244
     1a0:	91 e0       	ldi	r25, 0x01	; 1
     1a2:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskDelay>
     1a6:	ca cf       	rjmp	.-108    	; 0x13c <RPI_sendTask+0xc>

000001a8 <task1>:
     1a8:	26 9a       	sbi	0x04, 6	; 4
     1aa:	2e 9a       	sbi	0x05, 6	; 5
     1ac:	88 ee       	ldi	r24, 0xE8	; 232
     1ae:	93 e0       	ldi	r25, 0x03	; 3
     1b0:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskDelay>
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	15 b8       	out	0x05, r1	; 5
     1b8:	88 ee       	ldi	r24, 0xE8	; 232
     1ba:	93 e0       	ldi	r25, 0x03	; 3
     1bc:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskDelay>
     1c0:	f4 cf       	rjmp	.-24     	; 0x1aa <task1+0x2>

000001c2 <myTimerTask>:
     1c2:	80 d3       	rcall	.+1792   	; 0x8c4 <myTimer_Init>
     1c4:	e2 d3       	rcall	.+1988   	; 0x98a <myTimer_DelayChecker>
     1c6:	fe cf       	rjmp	.-4      	; 0x1c4 <myTimerTask+0x2>

000001c8 <obstacleSend>:
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
     1ce:	00 d0       	rcall	.+0      	; 0x1d0 <obstacleSend+0x8>
     1d0:	1f 92       	push	r1
     1d2:	1f 92       	push	r1
     1d4:	cd b7       	in	r28, 0x3d	; 61
     1d6:	de b7       	in	r29, 0x3e	; 62
     1d8:	18 2f       	mov	r17, r24
     1da:	cb 01       	movw	r24, r22
     1dc:	11 23       	and	r17, r17
     1de:	99 f0       	breq	.+38     	; 0x206 <obstacleSend+0x3e>
     1e0:	4a e0       	ldi	r20, 0x0A	; 10
     1e2:	be 01       	movw	r22, r28
     1e4:	6e 5f       	subi	r22, 0xFE	; 254
     1e6:	7f 4f       	sbci	r23, 0xFF	; 255
     1e8:	0e 94 44 11 	call	0x2288	; 0x2288 <__itoa_ncheck>
     1ec:	19 83       	std	Y+1, r17	; 0x01
     1ee:	20 e0       	ldi	r18, 0x00	; 0
     1f0:	4f ef       	ldi	r20, 0xFF	; 255
     1f2:	5f ef       	ldi	r21, 0xFF	; 255
     1f4:	be 01       	movw	r22, r28
     1f6:	6f 5f       	subi	r22, 0xFF	; 255
     1f8:	7f 4f       	sbci	r23, 0xFF	; 255
     1fa:	80 91 a3 08 	lds	r24, 0x08A3
     1fe:	90 91 a4 08 	lds	r25, 0x08A4
     202:	0e 94 54 09 	call	0x12a8	; 0x12a8 <xQueueGenericSend>
     206:	0f 90       	pop	r0
     208:	0f 90       	pop	r0
     20a:	0f 90       	pop	r0
     20c:	0f 90       	pop	r0
     20e:	0f 90       	pop	r0
     210:	df 91       	pop	r29
     212:	cf 91       	pop	r28
     214:	1f 91       	pop	r17
     216:	08 95       	ret

00000218 <Sonar_Task>:
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	00 d0       	rcall	.+0      	; 0x21e <Sonar_Task+0x6>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	1b 82       	std	Y+3, r1	; 0x03
     224:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <xTaskGetTickCount>
     228:	9a 83       	std	Y+2, r25	; 0x02
     22a:	89 83       	std	Y+1, r24	; 0x01
     22c:	0f 2e       	mov	r0, r31
     22e:	f8 e7       	ldi	r31, 0x78	; 120
     230:	6f 2e       	mov	r6, r31
     232:	f0 2d       	mov	r31, r0
     234:	0f 2e       	mov	r0, r31
     236:	f3 e0       	ldi	r31, 0x03	; 3
     238:	7f 2e       	mov	r7, r31
     23a:	f0 2d       	mov	r31, r0
     23c:	68 94       	set
     23e:	88 24       	eor	r8, r8
     240:	81 f8       	bld	r8, 1
     242:	99 24       	eor	r9, r9
     244:	93 94       	inc	r9
     246:	8a d2       	rcall	.+1300   	; 0x75c <myMaxSonar_Start>
     248:	87 e2       	ldi	r24, 0x27	; 39
     24a:	8e d2       	rcall	.+1308   	; 0x768 <myMaxSonar_Read>
     24c:	7c 01       	movw	r14, r24
     24e:	86 e2       	ldi	r24, 0x26	; 38
     250:	8b d2       	rcall	.+1302   	; 0x768 <myMaxSonar_Read>
     252:	6c 01       	movw	r12, r24
     254:	85 e2       	ldi	r24, 0x25	; 37
     256:	88 d2       	rcall	.+1296   	; 0x768 <myMaxSonar_Read>
     258:	0a 97       	sbiw	r24, 0x0a	; 10
     25a:	5c 01       	movw	r10, r24
     25c:	82 e3       	ldi	r24, 0x32	; 50
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <vTaskDelay>
     264:	5a d2       	rcall	.+1204   	; 0x71a <myHcSonar_Read>
     266:	8c 01       	movw	r16, r24
     268:	08 3e       	cpi	r16, 0xE8	; 232
     26a:	83 e0       	ldi	r24, 0x03	; 3
     26c:	18 07       	cpc	r17, r24
     26e:	14 f0       	brlt	.+4      	; 0x274 <Sonar_Task+0x5c>
     270:	06 2d       	mov	r16, r6
     272:	17 2d       	mov	r17, r7
     274:	e6 e4       	ldi	r30, 0x46	; 70
     276:	ee 16       	cp	r14, r30
     278:	f1 04       	cpc	r15, r1
     27a:	14 f5       	brge	.+68     	; 0x2c0 <Sonar_Task+0xa8>
     27c:	fd e2       	ldi	r31, 0x2D	; 45
     27e:	cf 16       	cp	r12, r31
     280:	d1 04       	cpc	r13, r1
     282:	54 f4       	brge	.+20     	; 0x298 <Sonar_Task+0x80>
     284:	8d e2       	ldi	r24, 0x2D	; 45
     286:	a8 16       	cp	r10, r24
     288:	b1 04       	cpc	r11, r1
     28a:	34 f4       	brge	.+12     	; 0x298 <Sonar_Task+0x80>
     28c:	74 9a       	sbi	0x0e, 4	; 14
     28e:	f4 01       	movw	r30, r8
     290:	80 81       	ld	r24, Z
     292:	80 61       	ori	r24, 0x10	; 16
     294:	80 83       	st	Z, r24
     296:	19 c0       	rjmp	.+50     	; 0x2ca <Sonar_Task+0xb2>
     298:	c6 01       	movw	r24, r12
     29a:	0a 96       	adiw	r24, 0x0a	; 10
     29c:	a8 16       	cp	r10, r24
     29e:	b9 06       	cpc	r11, r25
     2a0:	34 f4       	brge	.+12     	; 0x2ae <Sonar_Task+0x96>
     2a2:	f4 01       	movw	r30, r8
     2a4:	80 81       	ld	r24, Z
     2a6:	8f 7e       	andi	r24, 0xEF	; 239
     2a8:	80 83       	st	Z, r24
     2aa:	74 9a       	sbi	0x0e, 4	; 14
     2ac:	0e c0       	rjmp	.+28     	; 0x2ca <Sonar_Task+0xb2>
     2ae:	8a 15       	cp	r24, r10
     2b0:	9b 05       	cpc	r25, r11
     2b2:	5c f4       	brge	.+22     	; 0x2ca <Sonar_Task+0xb2>
     2b4:	74 98       	cbi	0x0e, 4	; 14
     2b6:	f4 01       	movw	r30, r8
     2b8:	80 81       	ld	r24, Z
     2ba:	80 61       	ori	r24, 0x10	; 16
     2bc:	80 83       	st	Z, r24
     2be:	05 c0       	rjmp	.+10     	; 0x2ca <Sonar_Task+0xb2>
     2c0:	f4 01       	movw	r30, r8
     2c2:	80 81       	ld	r24, Z
     2c4:	8f 7e       	andi	r24, 0xEF	; 239
     2c6:	80 83       	st	Z, r24
     2c8:	74 98       	cbi	0x0e, 4	; 14
     2ca:	8b 81       	ldd	r24, Y+3	; 0x03
     2cc:	8c 5f       	subi	r24, 0xFC	; 252
     2ce:	8b 83       	std	Y+3, r24	; 0x03
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	4f ef       	ldi	r20, 0xFF	; 255
     2d4:	5f ef       	ldi	r21, 0xFF	; 255
     2d6:	be 01       	movw	r22, r28
     2d8:	6d 5f       	subi	r22, 0xFD	; 253
     2da:	7f 4f       	sbci	r23, 0xFF	; 255
     2dc:	80 91 a1 08 	lds	r24, 0x08A1
     2e0:	90 91 a2 08 	lds	r25, 0x08A2
     2e4:	e1 d7       	rcall	.+4034   	; 0x12a8 <xQueueGenericSend>
     2e6:	b7 01       	movw	r22, r14
     2e8:	86 e4       	ldi	r24, 0x46	; 70
     2ea:	6e df       	rcall	.-292    	; 0x1c8 <obstacleSend>
     2ec:	b6 01       	movw	r22, r12
     2ee:	8c e4       	ldi	r24, 0x4C	; 76
     2f0:	6b df       	rcall	.-298    	; 0x1c8 <obstacleSend>
     2f2:	b5 01       	movw	r22, r10
     2f4:	82 e5       	ldi	r24, 0x52	; 82
     2f6:	68 df       	rcall	.-304    	; 0x1c8 <obstacleSend>
     2f8:	b8 01       	movw	r22, r16
     2fa:	82 e4       	ldi	r24, 0x42	; 66
     2fc:	65 df       	rcall	.-310    	; 0x1c8 <obstacleSend>
     2fe:	1b 82       	std	Y+3, r1	; 0x03
     300:	68 ec       	ldi	r22, 0xC8	; 200
     302:	70 e0       	ldi	r23, 0x00	; 0
     304:	ce 01       	movw	r24, r28
     306:	01 96       	adiw	r24, 0x01	; 1
     308:	0e 94 6d 0e 	call	0x1cda	; 0x1cda <vTaskDelayUntil>
     30c:	9c cf       	rjmp	.-200    	; 0x246 <Sonar_Task+0x2e>

0000030e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     30e:	8c ec       	ldi	r24, 0xCC	; 204
     310:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     314:	8e e3       	ldi	r24, 0x3E	; 62
     316:	80 93 65 00 	sts	0x0065, r24
     31a:	08 95       	ret

0000031c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     31c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     320:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     324:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     328:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     32c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     330:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     334:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     338:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     33c:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     340:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     344:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     348:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     34c:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     350:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     354:	10 92 73 00 	sts	0x0073, r1
     358:	08 95       	ret

0000035a <init>:
}

void init()
{
     35a:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     35c:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     35e:	f8 94       	cli
	{
		clearTimer();
     360:	dd df       	rcall	.-70     	; 0x31c <clearTimer>
		setPowerReduction();
     362:	d5 df       	rcall	.-86     	; 0x30e <setPowerReduction>
		myUSART_USART0_Init();
     364:	5d d4       	rcall	.+2234   	; 0xc20 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     366:	7c d4       	rcall	.+2296   	; 0xc60 <myUSART_USART1_Init>
		myADC_Init();
     368:	49 d2       	rcall	.+1170   	; 0x7fc <myADC_Init>
		MaxSonar_Init();
     36a:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     36c:	bb d1       	rcall	.+886    	; 0x6e4 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     36e:	40 e0       	ldi	r20, 0x00	; 0
     370:	61 e0       	ldi	r22, 0x01	; 1
     372:	85 e0       	ldi	r24, 0x05	; 5
     374:	6f d7       	rcall	.+3806   	; 0x1254 <xQueueGenericCreate>
     376:	90 93 a2 08 	sts	0x08A2, r25
     37a:	80 93 a1 08 	sts	0x08A1, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     37e:	40 e0       	ldi	r20, 0x00	; 0
     380:	65 e0       	ldi	r22, 0x05	; 5
     382:	84 e1       	ldi	r24, 0x14	; 20
     384:	67 d7       	rcall	.+3790   	; 0x1254 <xQueueGenericCreate>
     386:	90 93 a4 08 	sts	0x08A4, r25
     38a:	80 93 a3 08 	sts	0x08A3, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     38e:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     390:	e1 e0       	ldi	r30, 0x01	; 1
     392:	f1 e0       	ldi	r31, 0x01	; 1
     394:	80 81       	ld	r24, Z
     396:	80 61       	ori	r24, 0x10	; 16
     398:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     39a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     39c:	78 94       	sei
}
     39e:	cf 91       	pop	r28
     3a0:	08 95       	ret

000003a2 <main>:
	
	// do nth
}

int main(void)
{
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	cd b7       	in	r28, 0x3d	; 61
     3a8:	de b7       	in	r29, 0x3e	; 62
     3aa:	2a 97       	sbiw	r28, 0x0a	; 10
     3ac:	0f b6       	in	r0, 0x3f	; 63
     3ae:	f8 94       	cli
     3b0:	de bf       	out	0x3e, r29	; 62
     3b2:	0f be       	out	0x3f, r0	; 63
     3b4:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
		
		init();
     3b6:	d1 df       	rcall	.-94     	; 0x35a <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     3b8:	a1 2c       	mov	r10, r1
     3ba:	b1 2c       	mov	r11, r1
     3bc:	c1 2c       	mov	r12, r1
     3be:	d1 2c       	mov	r13, r1
     3c0:	ce 01       	movw	r24, r28
     3c2:	01 96       	adiw	r24, 0x01	; 1
     3c4:	7c 01       	movw	r14, r24
     3c6:	01 e0       	ldi	r16, 0x01	; 1
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	45 e5       	ldi	r20, 0x55	; 85
     3ce:	50 e0       	ldi	r21, 0x00	; 0
     3d0:	63 e2       	ldi	r22, 0x23	; 35
     3d2:	72 e0       	ldi	r23, 0x02	; 2
     3d4:	84 ed       	ldi	r24, 0xD4	; 212
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     3dc:	ce 01       	movw	r24, r28
     3de:	03 96       	adiw	r24, 0x03	; 3
     3e0:	7c 01       	movw	r14, r24
     3e2:	04 e0       	ldi	r16, 0x04	; 4
     3e4:	9c 01       	movw	r18, r24
     3e6:	49 e6       	ldi	r20, 0x69	; 105
     3e8:	50 e0       	ldi	r21, 0x00	; 0
     3ea:	6a e2       	ldi	r22, 0x2A	; 42
     3ec:	72 e0       	ldi	r23, 0x02	; 2
     3ee:	81 ee       	ldi	r24, 0xE1	; 225
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     3f6:	ce 01       	movw	r24, r28
     3f8:	09 96       	adiw	r24, 0x09	; 9
     3fa:	7c 01       	movw	r14, r24
     3fc:	02 e0       	ldi	r16, 0x02	; 2
     3fe:	20 e0       	ldi	r18, 0x00	; 0
     400:	30 e0       	ldi	r19, 0x00	; 0
     402:	4f e4       	ldi	r20, 0x4F	; 79
     404:	51 e0       	ldi	r21, 0x01	; 1
     406:	62 e3       	ldi	r22, 0x32	; 50
     408:	72 e0       	ldi	r23, 0x02	; 2
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	91 e0       	ldi	r25, 0x01	; 1
     40e:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     412:	ce 01       	movw	r24, r28
     414:	07 96       	adiw	r24, 0x07	; 7
     416:	7c 01       	movw	r14, r24
     418:	03 e0       	ldi	r16, 0x03	; 3
     41a:	20 e0       	ldi	r18, 0x00	; 0
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	47 e8       	ldi	r20, 0x87	; 135
     420:	50 e0       	ldi	r21, 0x00	; 0
     422:	6b e3       	ldi	r22, 0x3B	; 59
     424:	72 e0       	ldi	r23, 0x02	; 2
     426:	83 e9       	ldi	r24, 0x93	; 147
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     42e:	ce 01       	movw	r24, r28
     430:	05 96       	adiw	r24, 0x05	; 5
     432:	7c 01       	movw	r14, r24
     434:	01 e0       	ldi	r16, 0x01	; 1
     436:	20 e0       	ldi	r18, 0x00	; 0
     438:	30 e0       	ldi	r19, 0x00	; 0
     43a:	47 e8       	ldi	r20, 0x87	; 135
     43c:	50 e0       	ldi	r21, 0x00	; 0
     43e:	67 e4       	ldi	r22, 0x47	; 71
     440:	72 e0       	ldi	r23, 0x02	; 2
     442:	88 e9       	ldi	r24, 0x98	; 152
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	0e 94 90 0b 	call	0x1720	; 0x1720 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     44a:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <vTaskStartScheduler>
     44e:	b3 cf       	rjmp	.-154    	; 0x3b6 <main+0x14>

00000450 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     456:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     45a:	80 91 56 02 	lds	r24, 0x0256
     45e:	90 91 57 02 	lds	r25, 0x0257
     462:	89 2b       	or	r24, r25
     464:	31 f4       	brne	.+12     	; 0x472 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     466:	8b e5       	ldi	r24, 0x5B	; 91
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	90 93 57 02 	sts	0x0257, r25
     46e:	80 93 56 02 	sts	0x0256, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     472:	40 91 58 02 	lds	r20, 0x0258
     476:	50 91 59 02 	lds	r21, 0x0259
     47a:	9e 01       	movw	r18, r28
     47c:	24 0f       	add	r18, r20
     47e:	35 1f       	adc	r19, r21
     480:	2b 3d       	cpi	r18, 0xDB	; 219
     482:	85 e0       	ldi	r24, 0x05	; 5
     484:	38 07       	cpc	r19, r24
     486:	70 f4       	brcc	.+28     	; 0x4a4 <pvPortMalloc+0x54>
     488:	42 17       	cp	r20, r18
     48a:	53 07       	cpc	r21, r19
     48c:	70 f4       	brcc	.+28     	; 0x4aa <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     48e:	c0 91 56 02 	lds	r28, 0x0256
     492:	d0 91 57 02 	lds	r29, 0x0257
     496:	c4 0f       	add	r28, r20
     498:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     49a:	30 93 59 02 	sts	0x0259, r19
     49e:	20 93 58 02 	sts	0x0258, r18
     4a2:	05 c0       	rjmp	.+10     	; 0x4ae <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     4a4:	c0 e0       	ldi	r28, 0x00	; 0
     4a6:	d0 e0       	ldi	r29, 0x00	; 0
     4a8:	02 c0       	rjmp	.+4      	; 0x4ae <pvPortMalloc+0x5e>
     4aa:	c0 e0       	ldi	r28, 0x00	; 0
     4ac:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     4ae:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     4b2:	ce 01       	movw	r24, r28
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	08 95       	ret

000004ba <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     4ba:	08 95       	ret

000004bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     4bc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4be:	03 96       	adiw	r24, 0x03	; 3
     4c0:	92 83       	std	Z+2, r25	; 0x02
     4c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     4c4:	2f ef       	ldi	r18, 0xFF	; 255
     4c6:	3f ef       	ldi	r19, 0xFF	; 255
     4c8:	34 83       	std	Z+4, r19	; 0x04
     4ca:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4cc:	96 83       	std	Z+6, r25	; 0x06
     4ce:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4d0:	90 87       	std	Z+8, r25	; 0x08
     4d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     4d4:	10 82       	st	Z, r1
     4d6:	08 95       	ret

000004d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     4d8:	fc 01       	movw	r30, r24
     4da:	11 86       	std	Z+9, r1	; 0x09
     4dc:	10 86       	std	Z+8, r1	; 0x08
     4de:	08 95       	ret

000004e0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	9c 01       	movw	r18, r24
     4e6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     4e8:	dc 01       	movw	r26, r24
     4ea:	11 96       	adiw	r26, 0x01	; 1
     4ec:	cd 91       	ld	r28, X+
     4ee:	dc 91       	ld	r29, X
     4f0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     4f2:	d3 83       	std	Z+3, r29	; 0x03
     4f4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     4f6:	8c 81       	ldd	r24, Y+4	; 0x04
     4f8:	9d 81       	ldd	r25, Y+5	; 0x05
     4fa:	95 83       	std	Z+5, r25	; 0x05
     4fc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     4fe:	8c 81       	ldd	r24, Y+4	; 0x04
     500:	9d 81       	ldd	r25, Y+5	; 0x05
     502:	dc 01       	movw	r26, r24
     504:	13 96       	adiw	r26, 0x03	; 3
     506:	7c 93       	st	X, r23
     508:	6e 93       	st	-X, r22
     50a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     50c:	7d 83       	std	Y+5, r23	; 0x05
     50e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     510:	31 87       	std	Z+9, r19	; 0x09
     512:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     514:	f9 01       	movw	r30, r18
     516:	80 81       	ld	r24, Z
     518:	8f 5f       	subi	r24, 0xFF	; 255
     51a:	80 83       	st	Z, r24
}
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	08 95       	ret

00000522 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     522:	cf 93       	push	r28
     524:	df 93       	push	r29
     526:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     528:	48 81       	ld	r20, Y
     52a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     52c:	4f 3f       	cpi	r20, 0xFF	; 255
     52e:	2f ef       	ldi	r18, 0xFF	; 255
     530:	52 07       	cpc	r21, r18
     532:	21 f4       	brne	.+8      	; 0x53c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     534:	fc 01       	movw	r30, r24
     536:	a7 81       	ldd	r26, Z+7	; 0x07
     538:	b0 85       	ldd	r27, Z+8	; 0x08
     53a:	0d c0       	rjmp	.+26     	; 0x556 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     53c:	dc 01       	movw	r26, r24
     53e:	13 96       	adiw	r26, 0x03	; 3
     540:	12 96       	adiw	r26, 0x02	; 2
     542:	ed 91       	ld	r30, X+
     544:	fc 91       	ld	r31, X
     546:	13 97       	sbiw	r26, 0x03	; 3
     548:	20 81       	ld	r18, Z
     54a:	31 81       	ldd	r19, Z+1	; 0x01
     54c:	42 17       	cp	r20, r18
     54e:	53 07       	cpc	r21, r19
     550:	10 f0       	brcs	.+4      	; 0x556 <vListInsert+0x34>
     552:	df 01       	movw	r26, r30
     554:	f5 cf       	rjmp	.-22     	; 0x540 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     556:	12 96       	adiw	r26, 0x02	; 2
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	13 97       	sbiw	r26, 0x03	; 3
     55e:	fb 83       	std	Y+3, r31	; 0x03
     560:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     562:	d5 83       	std	Z+5, r29	; 0x05
     564:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     566:	bd 83       	std	Y+5, r27	; 0x05
     568:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     56a:	13 96       	adiw	r26, 0x03	; 3
     56c:	dc 93       	st	X, r29
     56e:	ce 93       	st	-X, r28
     570:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     572:	99 87       	std	Y+9, r25	; 0x09
     574:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     576:	fc 01       	movw	r30, r24
     578:	20 81       	ld	r18, Z
     57a:	2f 5f       	subi	r18, 0xFF	; 255
     57c:	20 83       	st	Z, r18
}
     57e:	df 91       	pop	r29
     580:	cf 91       	pop	r28
     582:	08 95       	ret

00000584 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     584:	cf 93       	push	r28
     586:	df 93       	push	r29
     588:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     58a:	a0 85       	ldd	r26, Z+8	; 0x08
     58c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     58e:	c2 81       	ldd	r28, Z+2	; 0x02
     590:	d3 81       	ldd	r29, Z+3	; 0x03
     592:	84 81       	ldd	r24, Z+4	; 0x04
     594:	95 81       	ldd	r25, Z+5	; 0x05
     596:	9d 83       	std	Y+5, r25	; 0x05
     598:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     59a:	c4 81       	ldd	r28, Z+4	; 0x04
     59c:	d5 81       	ldd	r29, Z+5	; 0x05
     59e:	82 81       	ldd	r24, Z+2	; 0x02
     5a0:	93 81       	ldd	r25, Z+3	; 0x03
     5a2:	9b 83       	std	Y+3, r25	; 0x03
     5a4:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5a6:	11 96       	adiw	r26, 0x01	; 1
     5a8:	cd 91       	ld	r28, X+
     5aa:	dc 91       	ld	r29, X
     5ac:	12 97       	sbiw	r26, 0x02	; 2
     5ae:	ce 17       	cp	r28, r30
     5b0:	df 07       	cpc	r29, r31
     5b2:	31 f4       	brne	.+12     	; 0x5c0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     5b4:	8c 81       	ldd	r24, Y+4	; 0x04
     5b6:	9d 81       	ldd	r25, Y+5	; 0x05
     5b8:	12 96       	adiw	r26, 0x02	; 2
     5ba:	9c 93       	st	X, r25
     5bc:	8e 93       	st	-X, r24
     5be:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     5c0:	11 86       	std	Z+9, r1	; 0x09
     5c2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     5c4:	8c 91       	ld	r24, X
     5c6:	81 50       	subi	r24, 0x01	; 1
     5c8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	08 95       	ret

000005d0 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     5d0:	1f 92       	push	r1
     5d2:	0f 92       	push	r0
     5d4:	0f b6       	in	r0, 0x3f	; 63
     5d6:	0f 92       	push	r0
     5d8:	11 24       	eor	r1, r1
     5da:	0b b6       	in	r0, 0x3b	; 59
     5dc:	0f 92       	push	r0
     5de:	2f 93       	push	r18
     5e0:	3f 93       	push	r19
     5e2:	4f 93       	push	r20
     5e4:	5f 93       	push	r21
     5e6:	6f 93       	push	r22
     5e8:	7f 93       	push	r23
     5ea:	8f 93       	push	r24
     5ec:	9f 93       	push	r25
     5ee:	af 93       	push	r26
     5f0:	bf 93       	push	r27
     5f2:	ef 93       	push	r30
     5f4:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     5f6:	1b 9b       	sbis	0x03, 3	; 3
     5f8:	0d c0       	rjmp	.+26     	; 0x614 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     5fa:	7e d1       	rcall	.+764    	; 0x8f8 <myTimer_Read>
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	90 93 aa 08 	sts	0x08AA, r25
     602:	80 93 a9 08 	sts	0x08A9, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     606:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xTaskGetTickCountFromISR>
     60a:	90 93 a6 08 	sts	0x08A6, r25
     60e:	80 93 a5 08 	sts	0x08A5, r24
     612:	55 c0       	rjmp	.+170    	; 0x6be <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     614:	1b 99       	sbic	0x03, 3	; 3
     616:	53 c0       	rjmp	.+166    	; 0x6be <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     618:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <xTaskGetTickCountFromISR>
     61c:	90 93 b0 08 	sts	0x08B0, r25
     620:	80 93 af 08 	sts	0x08AF, r24
     624:	20 91 a5 08 	lds	r18, 0x08A5
     628:	30 91 a6 08 	lds	r19, 0x08A6
     62c:	82 17       	cp	r24, r18
     62e:	93 07       	cpc	r25, r19
     630:	4c f4       	brge	.+18     	; 0x644 <__vector_9+0x74>
			ms_tickEnd += 65535;
     632:	80 91 af 08 	lds	r24, 0x08AF
     636:	90 91 b0 08 	lds	r25, 0x08B0
     63a:	01 97       	sbiw	r24, 0x01	; 1
     63c:	90 93 b0 08 	sts	0x08B0, r25
     640:	80 93 af 08 	sts	0x08AF, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     644:	59 d1       	rcall	.+690    	; 0x8f8 <myTimer_Read>
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	90 93 b2 08 	sts	0x08B2, r25
     64c:	80 93 b1 08 	sts	0x08B1, r24
     650:	20 91 a9 08 	lds	r18, 0x08A9
     654:	30 91 aa 08 	lds	r19, 0x08AA
     658:	82 17       	cp	r24, r18
     65a:	93 07       	cpc	r25, r19
     65c:	54 f4       	brge	.+20     	; 0x672 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     65e:	80 91 b1 08 	lds	r24, 0x08B1
     662:	90 91 b2 08 	lds	r25, 0x08B2
     666:	86 50       	subi	r24, 0x06	; 6
     668:	9f 4f       	sbci	r25, 0xFF	; 255
     66a:	90 93 b2 08 	sts	0x08B2, r25
     66e:	80 93 b1 08 	sts	0x08B1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     672:	80 91 b1 08 	lds	r24, 0x08B1
     676:	90 91 b2 08 	lds	r25, 0x08B2
     67a:	20 91 a9 08 	lds	r18, 0x08A9
     67e:	30 91 aa 08 	lds	r19, 0x08AA
     682:	82 1b       	sub	r24, r18
     684:	93 0b       	sbc	r25, r19
     686:	90 93 ac 08 	sts	0x08AC, r25
     68a:	80 93 ab 08 	sts	0x08AB, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     68e:	80 91 af 08 	lds	r24, 0x08AF
     692:	90 91 b0 08 	lds	r25, 0x08B0
     696:	20 91 a5 08 	lds	r18, 0x08A5
     69a:	30 91 a6 08 	lds	r19, 0x08A6
     69e:	82 1b       	sub	r24, r18
     6a0:	93 0b       	sbc	r25, r19
     6a2:	90 93 a8 08 	sts	0x08A8, r25
     6a6:	80 93 a7 08 	sts	0x08A7, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	40 e0       	ldi	r20, 0x00	; 0
     6ae:	50 e0       	ldi	r21, 0x00	; 0
     6b0:	60 e0       	ldi	r22, 0x00	; 0
     6b2:	70 e0       	ldi	r23, 0x00	; 0
     6b4:	80 91 ad 08 	lds	r24, 0x08AD
     6b8:	90 91 ae 08 	lds	r25, 0x08AE
     6bc:	b0 d6       	rcall	.+3424   	; 0x141e <xQueueGenericSendFromISR>
	}	
}
     6be:	ff 91       	pop	r31
     6c0:	ef 91       	pop	r30
     6c2:	bf 91       	pop	r27
     6c4:	af 91       	pop	r26
     6c6:	9f 91       	pop	r25
     6c8:	8f 91       	pop	r24
     6ca:	7f 91       	pop	r23
     6cc:	6f 91       	pop	r22
     6ce:	5f 91       	pop	r21
     6d0:	4f 91       	pop	r20
     6d2:	3f 91       	pop	r19
     6d4:	2f 91       	pop	r18
     6d6:	0f 90       	pop	r0
     6d8:	0b be       	out	0x3b, r0	; 59
     6da:	0f 90       	pop	r0
     6dc:	0f be       	out	0x3f, r0	; 63
     6de:	0f 90       	pop	r0
     6e0:	1f 90       	pop	r1
     6e2:	18 95       	reti

000006e4 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     6e4:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     6e6:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     6e8:	e8 e6       	ldi	r30, 0x68	; 104
     6ea:	f0 e0       	ldi	r31, 0x00	; 0
     6ec:	80 81       	ld	r24, Z
     6ee:	81 60       	ori	r24, 0x01	; 1
     6f0:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     6f2:	eb e6       	ldi	r30, 0x6B	; 107
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	80 81       	ld	r24, Z
     6f8:	88 60       	ori	r24, 0x08	; 8
     6fa:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     6fc:	43 e0       	ldi	r20, 0x03	; 3
     6fe:	60 e0       	ldi	r22, 0x00	; 0
     700:	81 e0       	ldi	r24, 0x01	; 1
     702:	a8 d5       	rcall	.+2896   	; 0x1254 <xQueueGenericCreate>
     704:	90 93 ae 08 	sts	0x08AE, r25
     708:	80 93 ad 08 	sts	0x08AD, r24
     70c:	08 95       	ret

0000070e <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     70e:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     710:	8e e1       	ldi	r24, 0x1E	; 30
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	17 d1       	rcall	.+558    	; 0x944 <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     716:	2a 98       	cbi	0x05, 2	; 5
     718:	08 95       	ret

0000071a <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     71a:	f9 df       	rcall	.-14     	; 0x70e <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	4f ef       	ldi	r20, 0xFF	; 255
     720:	5f ef       	ldi	r21, 0xFF	; 255
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	80 91 ad 08 	lds	r24, 0x08AD
     72a:	90 91 ae 08 	lds	r25, 0x08AE
     72e:	b1 d6       	rcall	.+3426   	; 0x1492 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     730:	80 91 ab 08 	lds	r24, 0x08AB
     734:	90 91 ac 08 	lds	r25, 0x08AC
	msLength = ms_tickLapsed * 5;
     738:	20 91 a7 08 	lds	r18, 0x08A7
     73c:	30 91 a8 08 	lds	r19, 0x08A8
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     740:	6e e0       	ldi	r22, 0x0E	; 14
     742:	70 e0       	ldi	r23, 0x00	; 0
     744:	0e 94 14 11 	call	0x2228	; 0x2228 <__divmodhi4>
	msLength = ms_tickLapsed * 5;
     748:	c9 01       	movw	r24, r18
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	88 0f       	add	r24, r24
     750:	99 1f       	adc	r25, r25
     752:	82 0f       	add	r24, r18
     754:	93 1f       	adc	r25, r19
	return usLength + msLength;
	
     756:	86 0f       	add	r24, r22
     758:	97 1f       	adc	r25, r23
     75a:	08 95       	ret

0000075c <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     75c:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     75e:	89 e1       	ldi	r24, 0x19	; 25
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	cc d0       	rcall	.+408    	; 0x8fc <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     764:	a1 98       	cbi	0x14, 1	; 20
     766:	08 95       	ret

00000768 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	unsigned char adcReading = myADC_analogRead(analogChannel);
     768:	a6 d0       	rcall	.+332    	; 0x8b6 <myADC_analogRead>
	reading = adcReading * valueToCM;
     76a:	28 2f       	mov	r18, r24
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	a9 01       	movw	r20, r18
     770:	44 0f       	add	r20, r20
     772:	55 1f       	adc	r21, r21
     774:	44 0f       	add	r20, r20
     776:	55 1f       	adc	r21, r21
     778:	24 0f       	add	r18, r20
     77a:	35 1f       	adc	r19, r21
	reading = reading + (adcReading/12); // divided by 12 for float compensation
     77c:	9b ea       	ldi	r25, 0xAB	; 171
     77e:	89 9f       	mul	r24, r25
     780:	81 2d       	mov	r24, r1
     782:	11 24       	eor	r1, r1
     784:	86 95       	lsr	r24
     786:	86 95       	lsr	r24
     788:	86 95       	lsr	r24
	
	return reading;
}
     78a:	a9 01       	movw	r20, r18
     78c:	48 0f       	add	r20, r24
     78e:	51 1d       	adc	r21, r1
     790:	ca 01       	movw	r24, r20
     792:	08 95       	ret

00000794 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     794:	1f 92       	push	r1
     796:	0f 92       	push	r0
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	0f 92       	push	r0
     79c:	11 24       	eor	r1, r1
     79e:	0b b6       	in	r0, 0x3b	; 59
     7a0:	0f 92       	push	r0
     7a2:	2f 93       	push	r18
     7a4:	3f 93       	push	r19
     7a6:	4f 93       	push	r20
     7a8:	5f 93       	push	r21
     7aa:	6f 93       	push	r22
     7ac:	7f 93       	push	r23
     7ae:	8f 93       	push	r24
     7b0:	9f 93       	push	r25
     7b2:	af 93       	push	r26
     7b4:	bf 93       	push	r27
     7b6:	ef 93       	push	r30
     7b8:	ff 93       	push	r31
	adcReading = ADCH; // read value
     7ba:	80 91 79 00 	lds	r24, 0x0079
     7be:	80 93 b3 08 	sts	0x08B3, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     7c2:	20 e0       	ldi	r18, 0x00	; 0
     7c4:	40 e0       	ldi	r20, 0x00	; 0
     7c6:	50 e0       	ldi	r21, 0x00	; 0
     7c8:	60 e0       	ldi	r22, 0x00	; 0
     7ca:	70 e0       	ldi	r23, 0x00	; 0
     7cc:	80 91 b6 08 	lds	r24, 0x08B6
     7d0:	90 91 b7 08 	lds	r25, 0x08B7
     7d4:	24 d6       	rcall	.+3144   	; 0x141e <xQueueGenericSendFromISR>
}
     7d6:	ff 91       	pop	r31
     7d8:	ef 91       	pop	r30
     7da:	bf 91       	pop	r27
     7dc:	af 91       	pop	r26
     7de:	9f 91       	pop	r25
     7e0:	8f 91       	pop	r24
     7e2:	7f 91       	pop	r23
     7e4:	6f 91       	pop	r22
     7e6:	5f 91       	pop	r21
     7e8:	4f 91       	pop	r20
     7ea:	3f 91       	pop	r19
     7ec:	2f 91       	pop	r18
     7ee:	0f 90       	pop	r0
     7f0:	0b be       	out	0x3b, r0	; 59
     7f2:	0f 90       	pop	r0
     7f4:	0f be       	out	0x3f, r0	; 63
     7f6:	0f 90       	pop	r0
     7f8:	1f 90       	pop	r1
     7fa:	18 95       	reti

000007fc <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     7fc:	8f e8       	ldi	r24, 0x8F	; 143
     7fe:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     802:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     806:	80 e6       	ldi	r24, 0x60	; 96
     808:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     80c:	43 e0       	ldi	r20, 0x03	; 3
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	20 d5       	rcall	.+2624   	; 0x1254 <xQueueGenericCreate>
     814:	90 93 b7 08 	sts	0x08B7, r25
     818:	80 93 b6 08 	sts	0x08B6, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	d7 d5       	rcall	.+2990   	; 0x13ce <xQueueCreateMutex>
     820:	90 93 b5 08 	sts	0x08B5, r25
     824:	80 93 b4 08 	sts	0x08B4, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     828:	20 e0       	ldi	r18, 0x00	; 0
     82a:	40 e0       	ldi	r20, 0x00	; 0
     82c:	50 e0       	ldi	r21, 0x00	; 0
     82e:	60 e0       	ldi	r22, 0x00	; 0
     830:	70 e0       	ldi	r23, 0x00	; 0
     832:	3a c5       	rjmp	.+2676   	; 0x12a8 <xQueueGenericSend>
     834:	08 95       	ret

00000836 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     836:	cf 93       	push	r28
     838:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     83a:	20 e0       	ldi	r18, 0x00	; 0
     83c:	4f ef       	ldi	r20, 0xFF	; 255
     83e:	5f ef       	ldi	r21, 0xFF	; 255
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	80 91 b4 08 	lds	r24, 0x08B4
     848:	90 91 b5 08 	lds	r25, 0x08B5
     84c:	22 d6       	rcall	.+3140   	; 0x1492 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     84e:	ec e7       	ldi	r30, 0x7C	; 124
     850:	f0 e0       	ldi	r31, 0x00	; 0
     852:	80 81       	ld	r24, Z
     854:	9c 2f       	mov	r25, r28
     856:	9f 71       	andi	r25, 0x1F	; 31
     858:	80 76       	andi	r24, 0x60	; 96
     85a:	89 2b       	or	r24, r25
     85c:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     85e:	eb e7       	ldi	r30, 0x7B	; 123
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	20 81       	ld	r18, Z
     864:	c0 72       	andi	r28, 0x20	; 32
     866:	8c 2f       	mov	r24, r28
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	95 95       	asr	r25
     86c:	87 95       	ror	r24
     86e:	95 95       	asr	r25
     870:	87 95       	ror	r24
     872:	92 2f       	mov	r25, r18
     874:	90 76       	andi	r25, 0x60	; 96
     876:	89 2b       	or	r24, r25
     878:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     87a:	ea e7       	ldi	r30, 0x7A	; 122
     87c:	f0 e0       	ldi	r31, 0x00	; 0
     87e:	80 81       	ld	r24, Z
     880:	80 64       	ori	r24, 0x40	; 64
     882:	80 83       	st	Z, r24
}
     884:	cf 91       	pop	r28
     886:	08 95       	ret

00000888 <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	4f ef       	ldi	r20, 0xFF	; 255
     88c:	5f ef       	ldi	r21, 0xFF	; 255
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	70 e0       	ldi	r23, 0x00	; 0
     892:	80 91 b6 08 	lds	r24, 0x08B6
     896:	90 91 b7 08 	lds	r25, 0x08B7
     89a:	fb d5       	rcall	.+3062   	; 0x1492 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     89c:	20 e0       	ldi	r18, 0x00	; 0
     89e:	40 e0       	ldi	r20, 0x00	; 0
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	60 e0       	ldi	r22, 0x00	; 0
     8a4:	70 e0       	ldi	r23, 0x00	; 0
     8a6:	80 91 b4 08 	lds	r24, 0x08B4
     8aa:	90 91 b5 08 	lds	r25, 0x08B5
     8ae:	fc d4       	rcall	.+2552   	; 0x12a8 <xQueueGenericSend>
	return adcReading;
     8b0:	80 91 b3 08 	lds	r24, 0x08B3
     8b4:	08 95       	ret

000008b6 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     8b6:	cf 93       	push	r28
     8b8:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     8ba:	bd df       	rcall	.-134    	; 0x836 <myADC_startADC>
	return myADC_readADC(channel);
     8bc:	8c 2f       	mov	r24, r28
     8be:	e4 df       	rcall	.-56     	; 0x888 <myADC_readADC>
}
     8c0:	cf 91       	pop	r28
     8c2:	08 95       	ret

000008c4 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     8c4:	90 93 bd 08 	sts	0x08BD, r25
     8c8:	80 93 bc 08 	sts	0x08BC, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     8cc:	fc 01       	movw	r30, r24
     8ce:	80 81       	ld	r24, Z
     8d0:	91 81       	ldd	r25, Z+1	; 0x01
     8d2:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     8d6:	43 e0       	ldi	r20, 0x03	; 3
     8d8:	60 e0       	ldi	r22, 0x00	; 0
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	bb d4       	rcall	.+2422   	; 0x1254 <xQueueGenericCreate>
     8de:	90 93 b9 08 	sts	0x08B9, r25
     8e2:	80 93 b8 08 	sts	0x08B8, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     8e6:	43 e0       	ldi	r20, 0x03	; 3
     8e8:	60 e0       	ldi	r22, 0x00	; 0
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	b3 d4       	rcall	.+2406   	; 0x1254 <xQueueGenericCreate>
     8ee:	90 93 bb 08 	sts	0x08BB, r25
     8f2:	80 93 ba 08 	sts	0x08BA, r24
     8f6:	08 95       	ret

000008f8 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8f8:	86 b5       	in	r24, 0x26	; 38
}
     8fa:	08 95       	ret

000008fc <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8fc:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     8fe:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     900:	9c 01       	movw	r18, r24
     902:	99 23       	and	r25, r25
     904:	14 f4       	brge	.+4      	; 0x90a <myTimer_DelayMicro+0xe>
     906:	2d 5f       	subi	r18, 0xFD	; 253
     908:	3f 4f       	sbci	r19, 0xFF	; 255
     90a:	35 95       	asr	r19
     90c:	27 95       	ror	r18
     90e:	35 95       	asr	r19
     910:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     912:	24 0f       	add	r18, r20
     914:	35 1f       	adc	r19, r21
     916:	30 93 03 02 	sts	0x0203, r19
     91a:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     91e:	e0 91 bc 08 	lds	r30, 0x08BC
     922:	f0 91 bd 08 	lds	r31, 0x08BD
     926:	80 81       	ld	r24, Z
     928:	91 81       	ldd	r25, Z+1	; 0x01
     92a:	0e 94 a5 0c 	call	0x194a	; 0x194a <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     92e:	20 e0       	ldi	r18, 0x00	; 0
     930:	42 e0       	ldi	r20, 0x02	; 2
     932:	50 e0       	ldi	r21, 0x00	; 0
     934:	60 e0       	ldi	r22, 0x00	; 0
     936:	70 e0       	ldi	r23, 0x00	; 0
     938:	80 91 b8 08 	lds	r24, 0x08B8
     93c:	90 91 b9 08 	lds	r25, 0x08B9
     940:	a8 c5       	rjmp	.+2896   	; 0x1492 <xQueueGenericReceive>
     942:	08 95       	ret

00000944 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     944:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     946:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     948:	9c 01       	movw	r18, r24
     94a:	99 23       	and	r25, r25
     94c:	14 f4       	brge	.+4      	; 0x952 <myTimer_DelayMicro2+0xe>
     94e:	2d 5f       	subi	r18, 0xFD	; 253
     950:	3f 4f       	sbci	r19, 0xFF	; 255
     952:	35 95       	asr	r19
     954:	27 95       	ror	r18
     956:	35 95       	asr	r19
     958:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     95a:	24 0f       	add	r18, r20
     95c:	35 1f       	adc	r19, r21
     95e:	30 93 01 02 	sts	0x0201, r19
     962:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     966:	e0 91 bc 08 	lds	r30, 0x08BC
     96a:	f0 91 bd 08 	lds	r31, 0x08BD
     96e:	80 81       	ld	r24, Z
     970:	91 81       	ldd	r25, Z+1	; 0x01
     972:	eb d7       	rcall	.+4054   	; 0x194a <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     974:	20 e0       	ldi	r18, 0x00	; 0
     976:	42 e0       	ldi	r20, 0x02	; 2
     978:	50 e0       	ldi	r21, 0x00	; 0
     97a:	60 e0       	ldi	r22, 0x00	; 0
     97c:	70 e0       	ldi	r23, 0x00	; 0
     97e:	80 91 ba 08 	lds	r24, 0x08BA
     982:	90 91 bb 08 	lds	r25, 0x08BB
     986:	85 c5       	rjmp	.+2826   	; 0x1492 <xQueueGenericReceive>
     988:	08 95       	ret

0000098a <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     98a:	cf 93       	push	r28
     98c:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     98e:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     990:	c1 11       	cpse	r28, r1
     992:	22 c0       	rjmp	.+68     	; 0x9d8 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     994:	80 91 02 02 	lds	r24, 0x0202
     998:	90 91 03 02 	lds	r25, 0x0203
     99c:	88 38       	cpi	r24, 0x88	; 136
     99e:	93 41       	sbci	r25, 0x13	; 19
     9a0:	51 f0       	breq	.+20     	; 0x9b6 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     9a2:	80 91 02 02 	lds	r24, 0x0202
     9a6:	90 91 03 02 	lds	r25, 0x0203
     9aa:	8a 5f       	subi	r24, 0xFA	; 250
     9ac:	91 09       	sbc	r25, r1
     9ae:	90 93 03 02 	sts	0x0203, r25
     9b2:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     9b6:	80 91 00 02 	lds	r24, 0x0200
     9ba:	90 91 01 02 	lds	r25, 0x0201
     9be:	88 38       	cpi	r24, 0x88	; 136
     9c0:	93 41       	sbci	r25, 0x13	; 19
     9c2:	51 f0       	breq	.+20     	; 0x9d8 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     9c4:	80 91 00 02 	lds	r24, 0x0200
     9c8:	90 91 01 02 	lds	r25, 0x0201
     9cc:	8a 5f       	subi	r24, 0xFA	; 250
     9ce:	91 09       	sbc	r25, r1
     9d0:	90 93 01 02 	sts	0x0201, r25
     9d4:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     9d8:	d0 e0       	ldi	r29, 0x00	; 0
     9da:	80 91 02 02 	lds	r24, 0x0202
     9de:	90 91 03 02 	lds	r25, 0x0203
     9e2:	8c 17       	cp	r24, r28
     9e4:	9d 07       	cpc	r25, r29
     9e6:	84 f4       	brge	.+32     	; 0xa08 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     9e8:	88 e8       	ldi	r24, 0x88	; 136
     9ea:	93 e1       	ldi	r25, 0x13	; 19
     9ec:	90 93 03 02 	sts	0x0203, r25
     9f0:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     9f4:	20 e0       	ldi	r18, 0x00	; 0
     9f6:	40 e0       	ldi	r20, 0x00	; 0
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	60 e0       	ldi	r22, 0x00	; 0
     9fc:	70 e0       	ldi	r23, 0x00	; 0
     9fe:	80 91 b8 08 	lds	r24, 0x08B8
     a02:	90 91 b9 08 	lds	r25, 0x08B9
     a06:	50 d4       	rcall	.+2208   	; 0x12a8 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     a08:	80 91 00 02 	lds	r24, 0x0200
     a0c:	90 91 01 02 	lds	r25, 0x0201
     a10:	8c 17       	cp	r24, r28
     a12:	9d 07       	cpc	r25, r29
     a14:	84 f4       	brge	.+32     	; 0xa36 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     a16:	88 e8       	ldi	r24, 0x88	; 136
     a18:	93 e1       	ldi	r25, 0x13	; 19
     a1a:	90 93 01 02 	sts	0x0201, r25
     a1e:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     a22:	20 e0       	ldi	r18, 0x00	; 0
     a24:	40 e0       	ldi	r20, 0x00	; 0
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	60 e0       	ldi	r22, 0x00	; 0
     a2a:	70 e0       	ldi	r23, 0x00	; 0
     a2c:	80 91 ba 08 	lds	r24, 0x08BA
     a30:	90 91 bb 08 	lds	r25, 0x08BB
     a34:	39 d4       	rcall	.+2162   	; 0x12a8 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     a36:	80 91 02 02 	lds	r24, 0x0202
     a3a:	90 91 03 02 	lds	r25, 0x0203
     a3e:	88 38       	cpi	r24, 0x88	; 136
     a40:	93 41       	sbci	r25, 0x13	; 19
     a42:	79 f4       	brne	.+30     	; 0xa62 <myTimer_DelayChecker+0xd8>
     a44:	80 91 00 02 	lds	r24, 0x0200
     a48:	90 91 01 02 	lds	r25, 0x0201
     a4c:	88 38       	cpi	r24, 0x88	; 136
     a4e:	93 41       	sbci	r25, 0x13	; 19
     a50:	41 f4       	brne	.+16     	; 0xa62 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     a52:	e0 91 bc 08 	lds	r30, 0x08BC
     a56:	f0 91 bd 08 	lds	r31, 0x08BD
     a5a:	80 81       	ld	r24, Z
     a5c:	91 81       	ldd	r25, Z+1	; 0x01
     a5e:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <vTaskSuspend>
	}
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <__vector_36>:

	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     a68:	1f 92       	push	r1
     a6a:	0f 92       	push	r0
     a6c:	0f b6       	in	r0, 0x3f	; 63
     a6e:	0f 92       	push	r0
     a70:	11 24       	eor	r1, r1
     a72:	0b b6       	in	r0, 0x3b	; 59
     a74:	0f 92       	push	r0
     a76:	2f 93       	push	r18
     a78:	3f 93       	push	r19
     a7a:	4f 93       	push	r20
     a7c:	5f 93       	push	r21
     a7e:	6f 93       	push	r22
     a80:	7f 93       	push	r23
     a82:	8f 93       	push	r24
     a84:	9f 93       	push	r25
     a86:	af 93       	push	r26
     a88:	bf 93       	push	r27
     a8a:	ef 93       	push	r30
     a8c:	ff 93       	push	r31
     a8e:	60 91 ce 00 	lds	r22, 0x00CE
     a92:	81 e5       	ldi	r24, 0x51	; 81
     a94:	99 e0       	ldi	r25, 0x09	; 9
     a96:	c9 d5       	rcall	.+2962   	; 0x162a <ringBufferPush>
     a98:	20 e0       	ldi	r18, 0x00	; 0
     a9a:	40 e0       	ldi	r20, 0x00	; 0
     a9c:	50 e0       	ldi	r21, 0x00	; 0
     a9e:	60 e0       	ldi	r22, 0x00	; 0
     aa0:	70 e0       	ldi	r23, 0x00	; 0
     aa2:	80 91 45 09 	lds	r24, 0x0945
     aa6:	90 91 46 09 	lds	r25, 0x0946
     aaa:	b9 d4       	rcall	.+2418   	; 0x141e <xQueueGenericSendFromISR>
     aac:	81 e5       	ldi	r24, 0x51	; 81
     aae:	99 e0       	ldi	r25, 0x09	; 9
     ab0:	d2 d5       	rcall	.+2980   	; 0x1656 <ringBufferFull>
     ab2:	ff 91       	pop	r31
     ab4:	ef 91       	pop	r30
     ab6:	bf 91       	pop	r27
     ab8:	af 91       	pop	r26
     aba:	9f 91       	pop	r25
     abc:	8f 91       	pop	r24
     abe:	7f 91       	pop	r23
     ac0:	6f 91       	pop	r22
     ac2:	5f 91       	pop	r21
     ac4:	4f 91       	pop	r20
     ac6:	3f 91       	pop	r19
     ac8:	2f 91       	pop	r18
     aca:	0f 90       	pop	r0
     acc:	0b be       	out	0x3b, r0	; 59
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	0f 90       	pop	r0
     ad4:	1f 90       	pop	r1
     ad6:	18 95       	reti

00000ad8 <__vector_25>:
     ad8:	1f 92       	push	r1
     ada:	0f 92       	push	r0
     adc:	0f b6       	in	r0, 0x3f	; 63
     ade:	0f 92       	push	r0
     ae0:	11 24       	eor	r1, r1
     ae2:	0b b6       	in	r0, 0x3b	; 59
     ae4:	0f 92       	push	r0
     ae6:	2f 93       	push	r18
     ae8:	3f 93       	push	r19
     aea:	4f 93       	push	r20
     aec:	5f 93       	push	r21
     aee:	6f 93       	push	r22
     af0:	7f 93       	push	r23
     af2:	8f 93       	push	r24
     af4:	9f 93       	push	r25
     af6:	af 93       	push	r26
     af8:	bf 93       	push	r27
     afa:	ef 93       	push	r30
     afc:	ff 93       	push	r31
     afe:	60 91 c6 00 	lds	r22, 0x00C6
     b02:	8e ed       	ldi	r24, 0xDE	; 222
     b04:	98 e0       	ldi	r25, 0x08	; 8
     b06:	91 d5       	rcall	.+2850   	; 0x162a <ringBufferPush>
     b08:	20 e0       	ldi	r18, 0x00	; 0
     b0a:	40 e0       	ldi	r20, 0x00	; 0
     b0c:	50 e0       	ldi	r21, 0x00	; 0
     b0e:	60 e0       	ldi	r22, 0x00	; 0
     b10:	70 e0       	ldi	r23, 0x00	; 0
     b12:	80 91 45 09 	lds	r24, 0x0945
     b16:	90 91 46 09 	lds	r25, 0x0946
     b1a:	81 d4       	rcall	.+2306   	; 0x141e <xQueueGenericSendFromISR>
     b1c:	8e ed       	ldi	r24, 0xDE	; 222
     b1e:	98 e0       	ldi	r25, 0x08	; 8
     b20:	9a d5       	rcall	.+2868   	; 0x1656 <ringBufferFull>
     b22:	ff 91       	pop	r31
     b24:	ef 91       	pop	r30
     b26:	bf 91       	pop	r27
     b28:	af 91       	pop	r26
     b2a:	9f 91       	pop	r25
     b2c:	8f 91       	pop	r24
     b2e:	7f 91       	pop	r23
     b30:	6f 91       	pop	r22
     b32:	5f 91       	pop	r21
     b34:	4f 91       	pop	r20
     b36:	3f 91       	pop	r19
     b38:	2f 91       	pop	r18
     b3a:	0f 90       	pop	r0
     b3c:	0b be       	out	0x3b, r0	; 59
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63
     b42:	0f 90       	pop	r0
     b44:	1f 90       	pop	r1
     b46:	18 95       	reti

00000b48 <__vector_37>:
     b48:	1f 92       	push	r1
     b4a:	0f 92       	push	r0
     b4c:	0f b6       	in	r0, 0x3f	; 63
     b4e:	0f 92       	push	r0
     b50:	11 24       	eor	r1, r1
     b52:	0b b6       	in	r0, 0x3b	; 59
     b54:	0f 92       	push	r0
     b56:	2f 93       	push	r18
     b58:	3f 93       	push	r19
     b5a:	4f 93       	push	r20
     b5c:	5f 93       	push	r21
     b5e:	6f 93       	push	r22
     b60:	7f 93       	push	r23
     b62:	8f 93       	push	r24
     b64:	9f 93       	push	r25
     b66:	af 93       	push	r26
     b68:	bf 93       	push	r27
     b6a:	ef 93       	push	r30
     b6c:	ff 93       	push	r31
     b6e:	87 e4       	ldi	r24, 0x47	; 71
     b70:	99 e0       	ldi	r25, 0x09	; 9
     b72:	78 d5       	rcall	.+2800   	; 0x1664 <ringBufferNotEmpty>
     b74:	88 23       	and	r24, r24
     b76:	31 f0       	breq	.+12     	; 0xb84 <__vector_37+0x3c>
     b78:	87 e4       	ldi	r24, 0x47	; 71
     b7a:	99 e0       	ldi	r25, 0x09	; 9
     b7c:	44 d5       	rcall	.+2696   	; 0x1606 <ringBufferPop>
     b7e:	80 93 ce 00 	sts	0x00CE, r24
     b82:	05 c0       	rjmp	.+10     	; 0xb8e <__vector_37+0x46>
     b84:	e9 ec       	ldi	r30, 0xC9	; 201
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	80 81       	ld	r24, Z
     b8a:	8f 7d       	andi	r24, 0xDF	; 223
     b8c:	80 83       	st	Z, r24
     b8e:	ff 91       	pop	r31
     b90:	ef 91       	pop	r30
     b92:	bf 91       	pop	r27
     b94:	af 91       	pop	r26
     b96:	9f 91       	pop	r25
     b98:	8f 91       	pop	r24
     b9a:	7f 91       	pop	r23
     b9c:	6f 91       	pop	r22
     b9e:	5f 91       	pop	r21
     ba0:	4f 91       	pop	r20
     ba2:	3f 91       	pop	r19
     ba4:	2f 91       	pop	r18
     ba6:	0f 90       	pop	r0
     ba8:	0b be       	out	0x3b, r0	; 59
     baa:	0f 90       	pop	r0
     bac:	0f be       	out	0x3f, r0	; 63
     bae:	0f 90       	pop	r0
     bb0:	1f 90       	pop	r1
     bb2:	18 95       	reti

00000bb4 <__vector_26>:
     bb4:	1f 92       	push	r1
     bb6:	0f 92       	push	r0
     bb8:	0f b6       	in	r0, 0x3f	; 63
     bba:	0f 92       	push	r0
     bbc:	11 24       	eor	r1, r1
     bbe:	0b b6       	in	r0, 0x3b	; 59
     bc0:	0f 92       	push	r0
     bc2:	2f 93       	push	r18
     bc4:	3f 93       	push	r19
     bc6:	4f 93       	push	r20
     bc8:	5f 93       	push	r21
     bca:	6f 93       	push	r22
     bcc:	7f 93       	push	r23
     bce:	8f 93       	push	r24
     bd0:	9f 93       	push	r25
     bd2:	af 93       	push	r26
     bd4:	bf 93       	push	r27
     bd6:	ef 93       	push	r30
     bd8:	ff 93       	push	r31
     bda:	8c e4       	ldi	r24, 0x4C	; 76
     bdc:	99 e0       	ldi	r25, 0x09	; 9
     bde:	42 d5       	rcall	.+2692   	; 0x1664 <ringBufferNotEmpty>
     be0:	88 23       	and	r24, r24
     be2:	31 f0       	breq	.+12     	; 0xbf0 <__vector_26+0x3c>
     be4:	8c e4       	ldi	r24, 0x4C	; 76
     be6:	99 e0       	ldi	r25, 0x09	; 9
     be8:	0e d5       	rcall	.+2588   	; 0x1606 <ringBufferPop>
     bea:	80 93 c6 00 	sts	0x00C6, r24
     bee:	05 c0       	rjmp	.+10     	; 0xbfa <__vector_26+0x46>
     bf0:	e1 ec       	ldi	r30, 0xC1	; 193
     bf2:	f0 e0       	ldi	r31, 0x00	; 0
     bf4:	80 81       	ld	r24, Z
     bf6:	8f 7d       	andi	r24, 0xDF	; 223
     bf8:	80 83       	st	Z, r24
     bfa:	ff 91       	pop	r31
     bfc:	ef 91       	pop	r30
     bfe:	bf 91       	pop	r27
     c00:	af 91       	pop	r26
     c02:	9f 91       	pop	r25
     c04:	8f 91       	pop	r24
     c06:	7f 91       	pop	r23
     c08:	6f 91       	pop	r22
     c0a:	5f 91       	pop	r21
     c0c:	4f 91       	pop	r20
     c0e:	3f 91       	pop	r19
     c10:	2f 91       	pop	r18
     c12:	0f 90       	pop	r0
     c14:	0b be       	out	0x3b, r0	; 59
     c16:	0f 90       	pop	r0
     c18:	0f be       	out	0x3f, r0	; 63
     c1a:	0f 90       	pop	r0
     c1c:	1f 90       	pop	r1
     c1e:	18 95       	reti

00000c20 <myUSART_USART0_Init>:
     c20:	10 92 c5 00 	sts	0x00C5, r1
     c24:	87 e6       	ldi	r24, 0x67	; 103
     c26:	80 93 c4 00 	sts	0x00C4, r24
     c2a:	88 eb       	ldi	r24, 0xB8	; 184
     c2c:	80 93 c1 00 	sts	0x00C1, r24
     c30:	86 e0       	ldi	r24, 0x06	; 6
     c32:	80 93 c2 00 	sts	0x00C2, r24
     c36:	40 e2       	ldi	r20, 0x20	; 32
     c38:	63 e0       	ldi	r22, 0x03	; 3
     c3a:	79 e0       	ldi	r23, 0x09	; 9
     c3c:	8e ed       	ldi	r24, 0xDE	; 222
     c3e:	98 e0       	ldi	r25, 0x08	; 8
     c40:	db d4       	rcall	.+2486   	; 0x15f8 <ringBufferInit>
     c42:	40 e2       	ldi	r20, 0x20	; 32
     c44:	63 ee       	ldi	r22, 0xE3	; 227
     c46:	78 e0       	ldi	r23, 0x08	; 8
     c48:	8c e4       	ldi	r24, 0x4C	; 76
     c4a:	99 e0       	ldi	r25, 0x09	; 9
     c4c:	d5 d4       	rcall	.+2474   	; 0x15f8 <ringBufferInit>
     c4e:	43 e0       	ldi	r20, 0x03	; 3
     c50:	60 e0       	ldi	r22, 0x00	; 0
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	ff d2       	rcall	.+1534   	; 0x1254 <xQueueGenericCreate>
     c56:	90 93 44 09 	sts	0x0944, r25
     c5a:	80 93 43 09 	sts	0x0943, r24
     c5e:	08 95       	ret

00000c60 <myUSART_USART1_Init>:
     c60:	10 92 cd 00 	sts	0x00CD, r1
     c64:	87 e6       	ldi	r24, 0x67	; 103
     c66:	80 93 cc 00 	sts	0x00CC, r24
     c6a:	88 eb       	ldi	r24, 0xB8	; 184
     c6c:	80 93 c9 00 	sts	0x00C9, r24
     c70:	86 e0       	ldi	r24, 0x06	; 6
     c72:	80 93 ca 00 	sts	0x00CA, r24
     c76:	40 e2       	ldi	r20, 0x20	; 32
     c78:	6e eb       	ldi	r22, 0xBE	; 190
     c7a:	78 e0       	ldi	r23, 0x08	; 8
     c7c:	81 e5       	ldi	r24, 0x51	; 81
     c7e:	99 e0       	ldi	r25, 0x09	; 9
     c80:	bb d4       	rcall	.+2422   	; 0x15f8 <ringBufferInit>
     c82:	40 e2       	ldi	r20, 0x20	; 32
     c84:	63 e2       	ldi	r22, 0x23	; 35
     c86:	79 e0       	ldi	r23, 0x09	; 9
     c88:	87 e4       	ldi	r24, 0x47	; 71
     c8a:	99 e0       	ldi	r25, 0x09	; 9
     c8c:	b5 d4       	rcall	.+2410   	; 0x15f8 <ringBufferInit>
     c8e:	43 e0       	ldi	r20, 0x03	; 3
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	df d2       	rcall	.+1470   	; 0x1254 <xQueueGenericCreate>
     c96:	90 93 46 09 	sts	0x0946, r25
     c9a:	80 93 45 09 	sts	0x0945, r24
     c9e:	08 95       	ret

00000ca0 <myUSART_transmitUSART0_c>:
     ca0:	cf 93       	push	r28
     ca2:	c8 2f       	mov	r28, r24
     ca4:	8c e4       	ldi	r24, 0x4C	; 76
     ca6:	99 e0       	ldi	r25, 0x09	; 9
     ca8:	d6 d4       	rcall	.+2476   	; 0x1656 <ringBufferFull>
     caa:	81 11       	cpse	r24, r1
     cac:	fb cf       	rjmp	.-10     	; 0xca4 <myUSART_transmitUSART0_c+0x4>
     cae:	6c 2f       	mov	r22, r28
     cb0:	8c e4       	ldi	r24, 0x4C	; 76
     cb2:	99 e0       	ldi	r25, 0x09	; 9
     cb4:	ba d4       	rcall	.+2420   	; 0x162a <ringBufferPush>
     cb6:	e1 ec       	ldi	r30, 0xC1	; 193
     cb8:	f0 e0       	ldi	r31, 0x00	; 0
     cba:	80 81       	ld	r24, Z
     cbc:	80 62       	ori	r24, 0x20	; 32
     cbe:	80 83       	st	Z, r24
     cc0:	e0 ec       	ldi	r30, 0xC0	; 192
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	80 81       	ld	r24, Z
     cc6:	80 64       	ori	r24, 0x40	; 64
     cc8:	80 83       	st	Z, r24
     cca:	cf 91       	pop	r28
     ccc:	08 95       	ret

00000cce <myUSART_transmitUSART1_c>:
     cce:	cf 93       	push	r28
     cd0:	c8 2f       	mov	r28, r24
     cd2:	87 e4       	ldi	r24, 0x47	; 71
     cd4:	99 e0       	ldi	r25, 0x09	; 9
     cd6:	bf d4       	rcall	.+2430   	; 0x1656 <ringBufferFull>
     cd8:	81 11       	cpse	r24, r1
     cda:	fb cf       	rjmp	.-10     	; 0xcd2 <myUSART_transmitUSART1_c+0x4>
     cdc:	6c 2f       	mov	r22, r28
     cde:	87 e4       	ldi	r24, 0x47	; 71
     ce0:	99 e0       	ldi	r25, 0x09	; 9
     ce2:	a3 d4       	rcall	.+2374   	; 0x162a <ringBufferPush>
     ce4:	e9 ec       	ldi	r30, 0xC9	; 201
     ce6:	f0 e0       	ldi	r31, 0x00	; 0
     ce8:	80 81       	ld	r24, Z
     cea:	80 62       	ori	r24, 0x20	; 32
     cec:	80 83       	st	Z, r24
     cee:	e8 ec       	ldi	r30, 0xC8	; 200
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	80 81       	ld	r24, Z
     cf4:	80 64       	ori	r24, 0x40	; 64
     cf6:	80 83       	st	Z, r24
     cf8:	cf 91       	pop	r28
     cfa:	08 95       	ret

00000cfc <myUSART_transmitUSART0>:
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
     d00:	ec 01       	movw	r28, r24
     d02:	88 81       	ld	r24, Y
     d04:	88 23       	and	r24, r24
     d06:	29 f0       	breq	.+10     	; 0xd12 <myUSART_transmitUSART0+0x16>
     d08:	21 96       	adiw	r28, 0x01	; 1
     d0a:	ca df       	rcall	.-108    	; 0xca0 <myUSART_transmitUSART0_c>
     d0c:	89 91       	ld	r24, Y+
     d0e:	81 11       	cpse	r24, r1
     d10:	fc cf       	rjmp	.-8      	; 0xd0a <myUSART_transmitUSART0+0xe>
     d12:	df 91       	pop	r29
     d14:	cf 91       	pop	r28
     d16:	08 95       	ret

00000d18 <myUSART_receiveUSART1>:
     d18:	cf 93       	push	r28
     d1a:	20 e0       	ldi	r18, 0x00	; 0
     d1c:	4f ef       	ldi	r20, 0xFF	; 255
     d1e:	5f ef       	ldi	r21, 0xFF	; 255
     d20:	60 e0       	ldi	r22, 0x00	; 0
     d22:	70 e0       	ldi	r23, 0x00	; 0
     d24:	80 91 43 09 	lds	r24, 0x0943
     d28:	90 91 44 09 	lds	r25, 0x0944
     d2c:	b2 d3       	rcall	.+1892   	; 0x1492 <xQueueGenericReceive>
     d2e:	81 e5       	ldi	r24, 0x51	; 81
     d30:	99 e0       	ldi	r25, 0x09	; 9
     d32:	69 d4       	rcall	.+2258   	; 0x1606 <ringBufferPop>
     d34:	c8 2f       	mov	r28, r24
     d36:	81 e5       	ldi	r24, 0x51	; 81
     d38:	99 e0       	ldi	r25, 0x09	; 9
     d3a:	94 d4       	rcall	.+2344   	; 0x1664 <ringBufferNotEmpty>
     d3c:	88 23       	and	r24, r24
     d3e:	51 f0       	breq	.+20     	; 0xd54 <myUSART_receiveUSART1+0x3c>
     d40:	20 e0       	ldi	r18, 0x00	; 0
     d42:	40 e0       	ldi	r20, 0x00	; 0
     d44:	50 e0       	ldi	r21, 0x00	; 0
     d46:	60 e0       	ldi	r22, 0x00	; 0
     d48:	70 e0       	ldi	r23, 0x00	; 0
     d4a:	80 91 43 09 	lds	r24, 0x0943
     d4e:	90 91 44 09 	lds	r25, 0x0944
     d52:	aa d2       	rcall	.+1364   	; 0x12a8 <xQueueGenericSend>
     d54:	8c 2f       	mov	r24, r28
     d56:	cf 91       	pop	r28
     d58:	08 95       	ret

00000d5a <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d5a:	de df       	rcall	.-68     	; 0xd18 <myUSART_receiveUSART1>
     d5c:	81 11       	cpse	r24, r1
     d5e:	0a c0       	rjmp	.+20     	; 0xd74 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     d60:	85 e5       	ldi	r24, 0x55	; 85
     d62:	b5 df       	rcall	.-150    	; 0xcce <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d64:	d9 df       	rcall	.-78     	; 0xd18 <myUSART_receiveUSART1>
     d66:	91 e0       	ldi	r25, 0x01	; 1
     d68:	81 11       	cpse	r24, r1
     d6a:	01 c0       	rjmp	.+2      	; 0xd6e <myUSART_waitForHandshake+0x14>
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	89 2f       	mov	r24, r25
     d70:	81 95       	neg	r24
     d72:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     d74:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     d76:	08 95       	ret

00000d78 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d78:	31 e1       	ldi	r19, 0x11	; 17
     d7a:	fc 01       	movw	r30, r24
     d7c:	30 83       	st	Z, r19
     d7e:	31 97       	sbiw	r30, 0x01	; 1
     d80:	22 e2       	ldi	r18, 0x22	; 34
     d82:	20 83       	st	Z, r18
     d84:	31 97       	sbiw	r30, 0x01	; 1
     d86:	a3 e3       	ldi	r26, 0x33	; 51
     d88:	a0 83       	st	Z, r26
     d8a:	31 97       	sbiw	r30, 0x01	; 1
     d8c:	60 83       	st	Z, r22
     d8e:	31 97       	sbiw	r30, 0x01	; 1
     d90:	70 83       	st	Z, r23
     d92:	31 97       	sbiw	r30, 0x01	; 1
     d94:	10 82       	st	Z, r1
     d96:	31 97       	sbiw	r30, 0x01	; 1
     d98:	10 82       	st	Z, r1
     d9a:	31 97       	sbiw	r30, 0x01	; 1
     d9c:	60 e8       	ldi	r22, 0x80	; 128
     d9e:	60 83       	st	Z, r22
     da0:	31 97       	sbiw	r30, 0x01	; 1
     da2:	10 82       	st	Z, r1
     da4:	31 97       	sbiw	r30, 0x01	; 1
     da6:	10 82       	st	Z, r1
     da8:	31 97       	sbiw	r30, 0x01	; 1
     daa:	10 82       	st	Z, r1
     dac:	31 97       	sbiw	r30, 0x01	; 1
     dae:	62 e0       	ldi	r22, 0x02	; 2
     db0:	60 83       	st	Z, r22
     db2:	31 97       	sbiw	r30, 0x01	; 1
     db4:	63 e0       	ldi	r22, 0x03	; 3
     db6:	60 83       	st	Z, r22
     db8:	31 97       	sbiw	r30, 0x01	; 1
     dba:	64 e0       	ldi	r22, 0x04	; 4
     dbc:	60 83       	st	Z, r22
     dbe:	31 97       	sbiw	r30, 0x01	; 1
     dc0:	65 e0       	ldi	r22, 0x05	; 5
     dc2:	60 83       	st	Z, r22
     dc4:	31 97       	sbiw	r30, 0x01	; 1
     dc6:	66 e0       	ldi	r22, 0x06	; 6
     dc8:	60 83       	st	Z, r22
     dca:	31 97       	sbiw	r30, 0x01	; 1
     dcc:	67 e0       	ldi	r22, 0x07	; 7
     dce:	60 83       	st	Z, r22
     dd0:	31 97       	sbiw	r30, 0x01	; 1
     dd2:	68 e0       	ldi	r22, 0x08	; 8
     dd4:	60 83       	st	Z, r22
     dd6:	31 97       	sbiw	r30, 0x01	; 1
     dd8:	69 e0       	ldi	r22, 0x09	; 9
     dda:	60 83       	st	Z, r22
     ddc:	31 97       	sbiw	r30, 0x01	; 1
     dde:	60 e1       	ldi	r22, 0x10	; 16
     de0:	60 83       	st	Z, r22
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	30 83       	st	Z, r19
     de6:	31 97       	sbiw	r30, 0x01	; 1
     de8:	32 e1       	ldi	r19, 0x12	; 18
     dea:	30 83       	st	Z, r19
     dec:	31 97       	sbiw	r30, 0x01	; 1
     dee:	33 e1       	ldi	r19, 0x13	; 19
     df0:	30 83       	st	Z, r19
     df2:	31 97       	sbiw	r30, 0x01	; 1
     df4:	34 e1       	ldi	r19, 0x14	; 20
     df6:	30 83       	st	Z, r19
     df8:	31 97       	sbiw	r30, 0x01	; 1
     dfa:	35 e1       	ldi	r19, 0x15	; 21
     dfc:	30 83       	st	Z, r19
     dfe:	31 97       	sbiw	r30, 0x01	; 1
     e00:	36 e1       	ldi	r19, 0x16	; 22
     e02:	30 83       	st	Z, r19
     e04:	31 97       	sbiw	r30, 0x01	; 1
     e06:	37 e1       	ldi	r19, 0x17	; 23
     e08:	30 83       	st	Z, r19
     e0a:	31 97       	sbiw	r30, 0x01	; 1
     e0c:	38 e1       	ldi	r19, 0x18	; 24
     e0e:	30 83       	st	Z, r19
     e10:	31 97       	sbiw	r30, 0x01	; 1
     e12:	39 e1       	ldi	r19, 0x19	; 25
     e14:	30 83       	st	Z, r19
     e16:	31 97       	sbiw	r30, 0x01	; 1
     e18:	30 e2       	ldi	r19, 0x20	; 32
     e1a:	30 83       	st	Z, r19
     e1c:	31 97       	sbiw	r30, 0x01	; 1
     e1e:	31 e2       	ldi	r19, 0x21	; 33
     e20:	30 83       	st	Z, r19
     e22:	31 97       	sbiw	r30, 0x01	; 1
     e24:	20 83       	st	Z, r18
     e26:	31 97       	sbiw	r30, 0x01	; 1
     e28:	23 e2       	ldi	r18, 0x23	; 35
     e2a:	20 83       	st	Z, r18
     e2c:	31 97       	sbiw	r30, 0x01	; 1
     e2e:	40 83       	st	Z, r20
     e30:	31 97       	sbiw	r30, 0x01	; 1
     e32:	50 83       	st	Z, r21
     e34:	31 97       	sbiw	r30, 0x01	; 1
     e36:	26 e2       	ldi	r18, 0x26	; 38
     e38:	20 83       	st	Z, r18
     e3a:	31 97       	sbiw	r30, 0x01	; 1
     e3c:	27 e2       	ldi	r18, 0x27	; 39
     e3e:	20 83       	st	Z, r18
     e40:	31 97       	sbiw	r30, 0x01	; 1
     e42:	28 e2       	ldi	r18, 0x28	; 40
     e44:	20 83       	st	Z, r18
     e46:	31 97       	sbiw	r30, 0x01	; 1
     e48:	29 e2       	ldi	r18, 0x29	; 41
     e4a:	20 83       	st	Z, r18
     e4c:	31 97       	sbiw	r30, 0x01	; 1
     e4e:	20 e3       	ldi	r18, 0x30	; 48
     e50:	20 83       	st	Z, r18
     e52:	31 97       	sbiw	r30, 0x01	; 1
     e54:	21 e3       	ldi	r18, 0x31	; 49
     e56:	20 83       	st	Z, r18
     e58:	89 97       	sbiw	r24, 0x29	; 41
     e5a:	08 95       	ret

00000e5c <xPortStartScheduler>:
     e5c:	82 e0       	ldi	r24, 0x02	; 2
     e5e:	84 bd       	out	0x24, r24	; 36
     e60:	16 bc       	out	0x26, r1	; 38
     e62:	80 e3       	ldi	r24, 0x30	; 48
     e64:	87 bd       	out	0x27, r24	; 39
     e66:	ee e6       	ldi	r30, 0x6E	; 110
     e68:	f0 e0       	ldi	r31, 0x00	; 0
     e6a:	80 81       	ld	r24, Z
     e6c:	82 60       	ori	r24, 0x02	; 2
     e6e:	80 83       	st	Z, r24
     e70:	83 e0       	ldi	r24, 0x03	; 3
     e72:	85 bd       	out	0x25, r24	; 37
     e74:	a0 91 9f 08 	lds	r26, 0x089F
     e78:	b0 91 a0 08 	lds	r27, 0x08A0
     e7c:	cd 91       	ld	r28, X+
     e7e:	cd bf       	out	0x3d, r28	; 61
     e80:	dd 91       	ld	r29, X+
     e82:	de bf       	out	0x3e, r29	; 62
     e84:	ff 91       	pop	r31
     e86:	ef 91       	pop	r30
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	bf 91       	pop	r27
     e8e:	af 91       	pop	r26
     e90:	9f 91       	pop	r25
     e92:	8f 91       	pop	r24
     e94:	7f 91       	pop	r23
     e96:	6f 91       	pop	r22
     e98:	5f 91       	pop	r21
     e9a:	4f 91       	pop	r20
     e9c:	3f 91       	pop	r19
     e9e:	2f 91       	pop	r18
     ea0:	1f 91       	pop	r17
     ea2:	0f 91       	pop	r16
     ea4:	ff 90       	pop	r15
     ea6:	ef 90       	pop	r14
     ea8:	df 90       	pop	r13
     eaa:	cf 90       	pop	r12
     eac:	bf 90       	pop	r11
     eae:	af 90       	pop	r10
     eb0:	9f 90       	pop	r9
     eb2:	8f 90       	pop	r8
     eb4:	7f 90       	pop	r7
     eb6:	6f 90       	pop	r6
     eb8:	5f 90       	pop	r5
     eba:	4f 90       	pop	r4
     ebc:	3f 90       	pop	r3
     ebe:	2f 90       	pop	r2
     ec0:	1f 90       	pop	r1
     ec2:	0f 90       	pop	r0
     ec4:	0c be       	out	0x3c, r0	; 60
     ec6:	0f 90       	pop	r0
     ec8:	0b be       	out	0x3b, r0	; 59
     eca:	0f 90       	pop	r0
     ecc:	0f be       	out	0x3f, r0	; 63
     ece:	0f 90       	pop	r0
     ed0:	08 95       	ret
     ed2:	81 e0       	ldi	r24, 0x01	; 1
     ed4:	08 95       	ret

00000ed6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ed6:	0f 92       	push	r0
     ed8:	0f b6       	in	r0, 0x3f	; 63
     eda:	f8 94       	cli
     edc:	0f 92       	push	r0
     ede:	0b b6       	in	r0, 0x3b	; 59
     ee0:	0f 92       	push	r0
     ee2:	0c b6       	in	r0, 0x3c	; 60
     ee4:	0f 92       	push	r0
     ee6:	1f 92       	push	r1
     ee8:	11 24       	eor	r1, r1
     eea:	2f 92       	push	r2
     eec:	3f 92       	push	r3
     eee:	4f 92       	push	r4
     ef0:	5f 92       	push	r5
     ef2:	6f 92       	push	r6
     ef4:	7f 92       	push	r7
     ef6:	8f 92       	push	r8
     ef8:	9f 92       	push	r9
     efa:	af 92       	push	r10
     efc:	bf 92       	push	r11
     efe:	cf 92       	push	r12
     f00:	df 92       	push	r13
     f02:	ef 92       	push	r14
     f04:	ff 92       	push	r15
     f06:	0f 93       	push	r16
     f08:	1f 93       	push	r17
     f0a:	2f 93       	push	r18
     f0c:	3f 93       	push	r19
     f0e:	4f 93       	push	r20
     f10:	5f 93       	push	r21
     f12:	6f 93       	push	r22
     f14:	7f 93       	push	r23
     f16:	8f 93       	push	r24
     f18:	9f 93       	push	r25
     f1a:	af 93       	push	r26
     f1c:	bf 93       	push	r27
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ef 93       	push	r30
     f24:	ff 93       	push	r31
     f26:	a0 91 9f 08 	lds	r26, 0x089F
     f2a:	b0 91 a0 08 	lds	r27, 0x08A0
     f2e:	0d b6       	in	r0, 0x3d	; 61
     f30:	0d 92       	st	X+, r0
     f32:	0e b6       	in	r0, 0x3e	; 62
     f34:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f36:	64 d7       	rcall	.+3784   	; 0x1e00 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f38:	a0 91 9f 08 	lds	r26, 0x089F
     f3c:	b0 91 a0 08 	lds	r27, 0x08A0
     f40:	cd 91       	ld	r28, X+
     f42:	cd bf       	out	0x3d, r28	; 61
     f44:	dd 91       	ld	r29, X+
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	ff 91       	pop	r31
     f4a:	ef 91       	pop	r30
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	bf 91       	pop	r27
     f52:	af 91       	pop	r26
     f54:	9f 91       	pop	r25
     f56:	8f 91       	pop	r24
     f58:	7f 91       	pop	r23
     f5a:	6f 91       	pop	r22
     f5c:	5f 91       	pop	r21
     f5e:	4f 91       	pop	r20
     f60:	3f 91       	pop	r19
     f62:	2f 91       	pop	r18
     f64:	1f 91       	pop	r17
     f66:	0f 91       	pop	r16
     f68:	ff 90       	pop	r15
     f6a:	ef 90       	pop	r14
     f6c:	df 90       	pop	r13
     f6e:	cf 90       	pop	r12
     f70:	bf 90       	pop	r11
     f72:	af 90       	pop	r10
     f74:	9f 90       	pop	r9
     f76:	8f 90       	pop	r8
     f78:	7f 90       	pop	r7
     f7a:	6f 90       	pop	r6
     f7c:	5f 90       	pop	r5
     f7e:	4f 90       	pop	r4
     f80:	3f 90       	pop	r3
     f82:	2f 90       	pop	r2
     f84:	1f 90       	pop	r1
     f86:	0f 90       	pop	r0
     f88:	0c be       	out	0x3c, r0	; 60
     f8a:	0f 90       	pop	r0
     f8c:	0b be       	out	0x3b, r0	; 59
     f8e:	0f 90       	pop	r0
     f90:	0f be       	out	0x3f, r0	; 63
     f92:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f94:	08 95       	ret

00000f96 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f96:	0f 92       	push	r0
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	f8 94       	cli
     f9c:	0f 92       	push	r0
     f9e:	0b b6       	in	r0, 0x3b	; 59
     fa0:	0f 92       	push	r0
     fa2:	0c b6       	in	r0, 0x3c	; 60
     fa4:	0f 92       	push	r0
     fa6:	1f 92       	push	r1
     fa8:	11 24       	eor	r1, r1
     faa:	2f 92       	push	r2
     fac:	3f 92       	push	r3
     fae:	4f 92       	push	r4
     fb0:	5f 92       	push	r5
     fb2:	6f 92       	push	r6
     fb4:	7f 92       	push	r7
     fb6:	8f 92       	push	r8
     fb8:	9f 92       	push	r9
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
     fc8:	1f 93       	push	r17
     fca:	2f 93       	push	r18
     fcc:	3f 93       	push	r19
     fce:	4f 93       	push	r20
     fd0:	5f 93       	push	r21
     fd2:	6f 93       	push	r22
     fd4:	7f 93       	push	r23
     fd6:	8f 93       	push	r24
     fd8:	9f 93       	push	r25
     fda:	af 93       	push	r26
     fdc:	bf 93       	push	r27
     fde:	cf 93       	push	r28
     fe0:	df 93       	push	r29
     fe2:	ef 93       	push	r30
     fe4:	ff 93       	push	r31
     fe6:	a0 91 9f 08 	lds	r26, 0x089F
     fea:	b0 91 a0 08 	lds	r27, 0x08A0
     fee:	0d b6       	in	r0, 0x3d	; 61
     ff0:	0d 92       	st	X+, r0
     ff2:	0e b6       	in	r0, 0x3e	; 62
     ff4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     ff6:	32 d5       	rcall	.+2660   	; 0x1a5c <xTaskIncrementTick>
     ff8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ffa:	02 d7       	rcall	.+3588   	; 0x1e00 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     ffc:	a0 91 9f 08 	lds	r26, 0x089F
    1000:	b0 91 a0 08 	lds	r27, 0x08A0
    1004:	cd 91       	ld	r28, X+
    1006:	cd bf       	out	0x3d, r28	; 61
    1008:	dd 91       	ld	r29, X+
    100a:	de bf       	out	0x3e, r29	; 62
    100c:	ff 91       	pop	r31
    100e:	ef 91       	pop	r30
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	bf 91       	pop	r27
    1016:	af 91       	pop	r26
    1018:	9f 91       	pop	r25
    101a:	8f 91       	pop	r24
    101c:	7f 91       	pop	r23
    101e:	6f 91       	pop	r22
    1020:	5f 91       	pop	r21
    1022:	4f 91       	pop	r20
    1024:	3f 91       	pop	r19
    1026:	2f 91       	pop	r18
    1028:	1f 91       	pop	r17
    102a:	0f 91       	pop	r16
    102c:	ff 90       	pop	r15
    102e:	ef 90       	pop	r14
    1030:	df 90       	pop	r13
    1032:	cf 90       	pop	r12
    1034:	bf 90       	pop	r11
    1036:	af 90       	pop	r10
    1038:	9f 90       	pop	r9
    103a:	8f 90       	pop	r8
    103c:	7f 90       	pop	r7
    103e:	6f 90       	pop	r6
    1040:	5f 90       	pop	r5
    1042:	4f 90       	pop	r4
    1044:	3f 90       	pop	r3
    1046:	2f 90       	pop	r2
    1048:	1f 90       	pop	r1
    104a:	0f 90       	pop	r0
    104c:	0c be       	out	0x3c, r0	; 60
    104e:	0f 90       	pop	r0
    1050:	0b be       	out	0x3b, r0	; 59
    1052:	0f 90       	pop	r0
    1054:	0f be       	out	0x3f, r0	; 63
    1056:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1058:	08 95       	ret

0000105a <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    105a:	9d df       	rcall	.-198    	; 0xf96 <vPortYieldFromTick>
		 asm volatile ("reti");
    105c:	18 95       	reti

0000105e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    105e:	1f 93       	push	r17
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	ec 01       	movw	r28, r24
    1066:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1068:	8c 8d       	ldd	r24, Y+28	; 0x1c
    106a:	81 11       	cpse	r24, r1
    106c:	0c c0       	rjmp	.+24     	; 0x1086 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    106e:	88 81       	ld	r24, Y
    1070:	99 81       	ldd	r25, Y+1	; 0x01
    1072:	89 2b       	or	r24, r25
    1074:	09 f0       	breq	.+2      	; 0x1078 <prvCopyDataToQueue+0x1a>
    1076:	47 c0       	rjmp	.+142    	; 0x1106 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1078:	8a 81       	ldd	r24, Y+2	; 0x02
    107a:	9b 81       	ldd	r25, Y+3	; 0x03
    107c:	0e 94 c3 10 	call	0x2186	; 0x2186 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1080:	1b 82       	std	Y+3, r1	; 0x03
    1082:	1a 82       	std	Y+2, r1	; 0x02
    1084:	47 c0       	rjmp	.+142    	; 0x1114 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1086:	41 11       	cpse	r20, r1
    1088:	18 c0       	rjmp	.+48     	; 0x10ba <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    108a:	48 2f       	mov	r20, r24
    108c:	50 e0       	ldi	r21, 0x00	; 0
    108e:	8c 81       	ldd	r24, Y+4	; 0x04
    1090:	9d 81       	ldd	r25, Y+5	; 0x05
    1092:	0e 94 3b 11 	call	0x2276	; 0x2276 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1096:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1098:	8c 81       	ldd	r24, Y+4	; 0x04
    109a:	9d 81       	ldd	r25, Y+5	; 0x05
    109c:	82 0f       	add	r24, r18
    109e:	91 1d       	adc	r25, r1
    10a0:	9d 83       	std	Y+5, r25	; 0x05
    10a2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    10a4:	2a 81       	ldd	r18, Y+2	; 0x02
    10a6:	3b 81       	ldd	r19, Y+3	; 0x03
    10a8:	82 17       	cp	r24, r18
    10aa:	93 07       	cpc	r25, r19
    10ac:	70 f1       	brcs	.+92     	; 0x110a <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    10ae:	88 81       	ld	r24, Y
    10b0:	99 81       	ldd	r25, Y+1	; 0x01
    10b2:	9d 83       	std	Y+5, r25	; 0x05
    10b4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    10b6:	80 e0       	ldi	r24, 0x00	; 0
    10b8:	2d c0       	rjmp	.+90     	; 0x1114 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10ba:	48 2f       	mov	r20, r24
    10bc:	50 e0       	ldi	r21, 0x00	; 0
    10be:	8e 81       	ldd	r24, Y+6	; 0x06
    10c0:	9f 81       	ldd	r25, Y+7	; 0x07
    10c2:	0e 94 3b 11 	call	0x2276	; 0x2276 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    10c6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	31 95       	neg	r19
    10cc:	21 95       	neg	r18
    10ce:	31 09       	sbc	r19, r1
    10d0:	8e 81       	ldd	r24, Y+6	; 0x06
    10d2:	9f 81       	ldd	r25, Y+7	; 0x07
    10d4:	82 0f       	add	r24, r18
    10d6:	93 1f       	adc	r25, r19
    10d8:	9f 83       	std	Y+7, r25	; 0x07
    10da:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    10dc:	68 81       	ld	r22, Y
    10de:	79 81       	ldd	r23, Y+1	; 0x01
    10e0:	86 17       	cp	r24, r22
    10e2:	97 07       	cpc	r25, r23
    10e4:	30 f4       	brcc	.+12     	; 0x10f2 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    10e6:	8a 81       	ldd	r24, Y+2	; 0x02
    10e8:	9b 81       	ldd	r25, Y+3	; 0x03
    10ea:	28 0f       	add	r18, r24
    10ec:	39 1f       	adc	r19, r25
    10ee:	3f 83       	std	Y+7, r19	; 0x07
    10f0:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    10f2:	12 30       	cpi	r17, 0x02	; 2
    10f4:	61 f4       	brne	.+24     	; 0x110e <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    10f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10f8:	88 23       	and	r24, r24
    10fa:	59 f0       	breq	.+22     	; 0x1112 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    10fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10fe:	81 50       	subi	r24, 0x01	; 1
    1100:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	07 c0       	rjmp	.+14     	; 0x1114 <prvCopyDataToQueue+0xb6>
    1106:	80 e0       	ldi	r24, 0x00	; 0
    1108:	05 c0       	rjmp	.+10     	; 0x1114 <prvCopyDataToQueue+0xb6>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	03 c0       	rjmp	.+6      	; 0x1114 <prvCopyDataToQueue+0xb6>
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	01 c0       	rjmp	.+2      	; 0x1114 <prvCopyDataToQueue+0xb6>
    1112:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1114:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1116:	9f 5f       	subi	r25, 0xFF	; 255
    1118:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	1f 91       	pop	r17
    1120:	08 95       	ret

00001122 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1122:	fc 01       	movw	r30, r24
    1124:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1126:	44 8d       	ldd	r20, Z+28	; 0x1c
    1128:	44 23       	and	r20, r20
    112a:	a1 f0       	breq	.+40     	; 0x1154 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    112c:	50 e0       	ldi	r21, 0x00	; 0
    112e:	26 81       	ldd	r18, Z+6	; 0x06
    1130:	37 81       	ldd	r19, Z+7	; 0x07
    1132:	24 0f       	add	r18, r20
    1134:	35 1f       	adc	r19, r21
    1136:	37 83       	std	Z+7, r19	; 0x07
    1138:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    113a:	62 81       	ldd	r22, Z+2	; 0x02
    113c:	73 81       	ldd	r23, Z+3	; 0x03
    113e:	26 17       	cp	r18, r22
    1140:	37 07       	cpc	r19, r23
    1142:	20 f0       	brcs	.+8      	; 0x114c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1144:	20 81       	ld	r18, Z
    1146:	31 81       	ldd	r19, Z+1	; 0x01
    1148:	37 83       	std	Z+7, r19	; 0x07
    114a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    114c:	66 81       	ldd	r22, Z+6	; 0x06
    114e:	77 81       	ldd	r23, Z+7	; 0x07
    1150:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <memcpy>
    1154:	08 95       	ret

00001156 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1166:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1168:	18 16       	cp	r1, r24
    116a:	a4 f4       	brge	.+40     	; 0x1194 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    116c:	89 89       	ldd	r24, Y+17	; 0x11
    116e:	88 23       	and	r24, r24
    1170:	89 f0       	breq	.+34     	; 0x1194 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1172:	8e 01       	movw	r16, r28
    1174:	0f 5e       	subi	r16, 0xEF	; 239
    1176:	1f 4f       	sbci	r17, 0xFF	; 255
    1178:	03 c0       	rjmp	.+6      	; 0x1180 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    117a:	89 89       	ldd	r24, Y+17	; 0x11
    117c:	88 23       	and	r24, r24
    117e:	51 f0       	breq	.+20     	; 0x1194 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1180:	c8 01       	movw	r24, r16
    1182:	14 d7       	rcall	.+3624   	; 0x1fac <xTaskRemoveFromEventList>
    1184:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1186:	9d d7       	rcall	.+3898   	; 0x20c2 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1188:	8e 8d       	ldd	r24, Y+30	; 0x1e
    118a:	81 50       	subi	r24, 0x01	; 1
    118c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    118e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1190:	18 16       	cp	r1, r24
    1192:	9c f3       	brlt	.-26     	; 0x117a <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1194:	8f ef       	ldi	r24, 0xFF	; 255
    1196:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1198:	0f 90       	pop	r0
    119a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    119c:	0f b6       	in	r0, 0x3f	; 63
    119e:	f8 94       	cli
    11a0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    11a2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11a4:	18 16       	cp	r1, r24
    11a6:	a4 f4       	brge	.+40     	; 0x11d0 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11a8:	88 85       	ldd	r24, Y+8	; 0x08
    11aa:	88 23       	and	r24, r24
    11ac:	89 f0       	breq	.+34     	; 0x11d0 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11ae:	8e 01       	movw	r16, r28
    11b0:	08 5f       	subi	r16, 0xF8	; 248
    11b2:	1f 4f       	sbci	r17, 0xFF	; 255
    11b4:	03 c0       	rjmp	.+6      	; 0x11bc <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11b6:	88 85       	ldd	r24, Y+8	; 0x08
    11b8:	88 23       	and	r24, r24
    11ba:	51 f0       	breq	.+20     	; 0x11d0 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11bc:	c8 01       	movw	r24, r16
    11be:	f6 d6       	rcall	.+3564   	; 0x1fac <xTaskRemoveFromEventList>
    11c0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    11c2:	7f d7       	rcall	.+3838   	; 0x20c2 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    11c4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11c6:	81 50       	subi	r24, 0x01	; 1
    11c8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    11ca:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11cc:	18 16       	cp	r1, r24
    11ce:	9c f3       	brlt	.-26     	; 0x11b6 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    11d4:	0f 90       	pop	r0
    11d6:	0f be       	out	0x3f, r0	; 63
}
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	1f 91       	pop	r17
    11de:	0f 91       	pop	r16
    11e0:	08 95       	ret

000011e2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    11e2:	cf 93       	push	r28
    11e4:	df 93       	push	r29
    11e6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    11e8:	0f b6       	in	r0, 0x3f	; 63
    11ea:	f8 94       	cli
    11ec:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    11ee:	88 81       	ld	r24, Y
    11f0:	99 81       	ldd	r25, Y+1	; 0x01
    11f2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    11f8:	72 9f       	mul	r23, r18
    11fa:	a0 01       	movw	r20, r0
    11fc:	73 9f       	mul	r23, r19
    11fe:	50 0d       	add	r21, r0
    1200:	11 24       	eor	r1, r1
    1202:	fc 01       	movw	r30, r24
    1204:	e4 0f       	add	r30, r20
    1206:	f5 1f       	adc	r31, r21
    1208:	fb 83       	std	Y+3, r31	; 0x03
    120a:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    120c:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    120e:	9d 83       	std	Y+5, r25	; 0x05
    1210:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1212:	42 1b       	sub	r20, r18
    1214:	53 0b       	sbc	r21, r19
    1216:	84 0f       	add	r24, r20
    1218:	95 1f       	adc	r25, r21
    121a:	9f 83       	std	Y+7, r25	; 0x07
    121c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    121e:	8f ef       	ldi	r24, 0xFF	; 255
    1220:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1222:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1224:	61 11       	cpse	r22, r1
    1226:	0a c0       	rjmp	.+20     	; 0x123c <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1228:	88 85       	ldd	r24, Y+8	; 0x08
    122a:	88 23       	and	r24, r24
    122c:	69 f0       	breq	.+26     	; 0x1248 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    122e:	ce 01       	movw	r24, r28
    1230:	08 96       	adiw	r24, 0x08	; 8
    1232:	bc d6       	rcall	.+3448   	; 0x1fac <xTaskRemoveFromEventList>
    1234:	81 30       	cpi	r24, 0x01	; 1
    1236:	41 f4       	brne	.+16     	; 0x1248 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1238:	4e de       	rcall	.-868    	; 0xed6 <vPortYield>
    123a:	06 c0       	rjmp	.+12     	; 0x1248 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    123c:	ce 01       	movw	r24, r28
    123e:	08 96       	adiw	r24, 0x08	; 8
    1240:	3d d9       	rcall	.-3462   	; 0x4bc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1242:	ce 01       	movw	r24, r28
    1244:	41 96       	adiw	r24, 0x11	; 17
    1246:	3a d9       	rcall	.-3468   	; 0x4bc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1248:	0f 90       	pop	r0
    124a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	df 91       	pop	r29
    1250:	cf 91       	pop	r28
    1252:	08 95       	ret

00001254 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1254:	0f 93       	push	r16
    1256:	1f 93       	push	r17
    1258:	cf 93       	push	r28
    125a:	df 93       	push	r29
    125c:	18 2f       	mov	r17, r24
    125e:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1260:	88 23       	and	r24, r24
    1262:	d1 f0       	breq	.+52     	; 0x1298 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1264:	8f e1       	ldi	r24, 0x1F	; 31
    1266:	90 e0       	ldi	r25, 0x00	; 0
    1268:	f3 d8       	rcall	.-3610   	; 0x450 <pvPortMalloc>
    126a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    126c:	00 97       	sbiw	r24, 0x00	; 0
    126e:	b1 f0       	breq	.+44     	; 0x129c <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1270:	10 9f       	mul	r17, r16
    1272:	c0 01       	movw	r24, r0
    1274:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1276:	01 96       	adiw	r24, 0x01	; 1
    1278:	eb d8       	rcall	.-3626   	; 0x450 <pvPortMalloc>
    127a:	99 83       	std	Y+1, r25	; 0x01
    127c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    127e:	89 2b       	or	r24, r25
    1280:	31 f0       	breq	.+12     	; 0x128e <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1282:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1284:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1286:	61 e0       	ldi	r22, 0x01	; 1
    1288:	ce 01       	movw	r24, r28
    128a:	ab df       	rcall	.-170    	; 0x11e2 <xQueueGenericReset>
    128c:	07 c0       	rjmp	.+14     	; 0x129c <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    128e:	ce 01       	movw	r24, r28
    1290:	14 d9       	rcall	.-3544   	; 0x4ba <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1292:	c0 e0       	ldi	r28, 0x00	; 0
    1294:	d0 e0       	ldi	r29, 0x00	; 0
    1296:	02 c0       	rjmp	.+4      	; 0x129c <xQueueGenericCreate+0x48>
    1298:	c0 e0       	ldi	r28, 0x00	; 0
    129a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    129c:	ce 01       	movw	r24, r28
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	1f 91       	pop	r17
    12a4:	0f 91       	pop	r16
    12a6:	08 95       	ret

000012a8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    12a8:	9f 92       	push	r9
    12aa:	af 92       	push	r10
    12ac:	bf 92       	push	r11
    12ae:	cf 92       	push	r12
    12b0:	df 92       	push	r13
    12b2:	ef 92       	push	r14
    12b4:	ff 92       	push	r15
    12b6:	0f 93       	push	r16
    12b8:	1f 93       	push	r17
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	00 d0       	rcall	.+0      	; 0x12c0 <xQueueGenericSend+0x18>
    12c0:	1f 92       	push	r1
    12c2:	1f 92       	push	r1
    12c4:	cd b7       	in	r28, 0x3d	; 61
    12c6:	de b7       	in	r29, 0x3e	; 62
    12c8:	8c 01       	movw	r16, r24
    12ca:	6b 01       	movw	r12, r22
    12cc:	5d 83       	std	Y+5, r21	; 0x05
    12ce:	4c 83       	std	Y+4, r20	; 0x04
    12d0:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    12d2:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    12d4:	99 24       	eor	r9, r9
    12d6:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12d8:	7c 01       	movw	r14, r24
    12da:	88 e0       	ldi	r24, 0x08	; 8
    12dc:	e8 0e       	add	r14, r24
    12de:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    12e0:	0f b6       	in	r0, 0x3f	; 63
    12e2:	f8 94       	cli
    12e4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12e6:	f8 01       	movw	r30, r16
    12e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    12ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    12ec:	98 17       	cp	r25, r24
    12ee:	18 f0       	brcs	.+6      	; 0x12f6 <xQueueGenericSend+0x4e>
    12f0:	f2 e0       	ldi	r31, 0x02	; 2
    12f2:	af 12       	cpse	r10, r31
    12f4:	15 c0       	rjmp	.+42     	; 0x1320 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12f6:	4a 2d       	mov	r20, r10
    12f8:	b6 01       	movw	r22, r12
    12fa:	c8 01       	movw	r24, r16
    12fc:	b0 de       	rcall	.-672    	; 0x105e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12fe:	f8 01       	movw	r30, r16
    1300:	91 89       	ldd	r25, Z+17	; 0x11
    1302:	99 23       	and	r25, r25
    1304:	39 f0       	breq	.+14     	; 0x1314 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1306:	c8 01       	movw	r24, r16
    1308:	41 96       	adiw	r24, 0x11	; 17
    130a:	50 d6       	rcall	.+3232   	; 0x1fac <xTaskRemoveFromEventList>
    130c:	81 30       	cpi	r24, 0x01	; 1
    130e:	21 f4       	brne	.+8      	; 0x1318 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1310:	e2 dd       	rcall	.-1084   	; 0xed6 <vPortYield>
    1312:	02 c0       	rjmp	.+4      	; 0x1318 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1314:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1316:	df dd       	rcall	.-1090   	; 0xed6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1318:	0f 90       	pop	r0
    131a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	46 c0       	rjmp	.+140    	; 0x13ac <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1320:	ec 81       	ldd	r30, Y+4	; 0x04
    1322:	fd 81       	ldd	r31, Y+5	; 0x05
    1324:	ef 2b       	or	r30, r31
    1326:	21 f4       	brne	.+8      	; 0x1330 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1328:	0f 90       	pop	r0
    132a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	3e c0       	rjmp	.+124    	; 0x13ac <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1330:	b1 10       	cpse	r11, r1
    1332:	04 c0       	rjmp	.+8      	; 0x133c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1334:	ce 01       	movw	r24, r28
    1336:	01 96       	adiw	r24, 0x01	; 1
    1338:	81 d6       	rcall	.+3330   	; 0x203c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    133a:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    133c:	0f 90       	pop	r0
    133e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1340:	78 d3       	rcall	.+1776   	; 0x1a32 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1342:	0f b6       	in	r0, 0x3f	; 63
    1344:	f8 94       	cli
    1346:	0f 92       	push	r0
    1348:	f8 01       	movw	r30, r16
    134a:	85 8d       	ldd	r24, Z+29	; 0x1d
    134c:	8f 3f       	cpi	r24, 0xFF	; 255
    134e:	09 f4       	brne	.+2      	; 0x1352 <xQueueGenericSend+0xaa>
    1350:	15 8e       	std	Z+29, r1	; 0x1d
    1352:	f8 01       	movw	r30, r16
    1354:	86 8d       	ldd	r24, Z+30	; 0x1e
    1356:	8f 3f       	cpi	r24, 0xFF	; 255
    1358:	09 f4       	brne	.+2      	; 0x135c <xQueueGenericSend+0xb4>
    135a:	16 8e       	std	Z+30, r1	; 0x1e
    135c:	0f 90       	pop	r0
    135e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1360:	be 01       	movw	r22, r28
    1362:	6c 5f       	subi	r22, 0xFC	; 252
    1364:	7f 4f       	sbci	r23, 0xFF	; 255
    1366:	ce 01       	movw	r24, r28
    1368:	01 96       	adiw	r24, 0x01	; 1
    136a:	73 d6       	rcall	.+3302   	; 0x2052 <xTaskCheckForTimeOut>
    136c:	81 11       	cpse	r24, r1
    136e:	1a c0       	rjmp	.+52     	; 0x13a4 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1376:	f8 01       	movw	r30, r16
    1378:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    137a:	0f 90       	pop	r0
    137c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    137e:	f8 01       	movw	r30, r16
    1380:	83 8d       	ldd	r24, Z+27	; 0x1b
    1382:	98 13       	cpse	r25, r24
    1384:	0b c0       	rjmp	.+22     	; 0x139c <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1386:	6c 81       	ldd	r22, Y+4	; 0x04
    1388:	7d 81       	ldd	r23, Y+5	; 0x05
    138a:	c7 01       	movw	r24, r14
    138c:	e4 d5       	rcall	.+3016   	; 0x1f56 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    138e:	c8 01       	movw	r24, r16
    1390:	e2 de       	rcall	.-572    	; 0x1156 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1392:	22 d4       	rcall	.+2116   	; 0x1bd8 <xTaskResumeAll>
    1394:	81 11       	cpse	r24, r1
    1396:	a4 cf       	rjmp	.-184    	; 0x12e0 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1398:	9e dd       	rcall	.-1220   	; 0xed6 <vPortYield>
    139a:	a2 cf       	rjmp	.-188    	; 0x12e0 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    139c:	c8 01       	movw	r24, r16
    139e:	db de       	rcall	.-586    	; 0x1156 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13a0:	1b d4       	rcall	.+2102   	; 0x1bd8 <xTaskResumeAll>
    13a2:	9e cf       	rjmp	.-196    	; 0x12e0 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    13a4:	c8 01       	movw	r24, r16
    13a6:	d7 de       	rcall	.-594    	; 0x1156 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13a8:	17 d4       	rcall	.+2094   	; 0x1bd8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    13aa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    13ac:	0f 90       	pop	r0
    13ae:	0f 90       	pop	r0
    13b0:	0f 90       	pop	r0
    13b2:	0f 90       	pop	r0
    13b4:	0f 90       	pop	r0
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	ff 90       	pop	r15
    13c0:	ef 90       	pop	r14
    13c2:	df 90       	pop	r13
    13c4:	cf 90       	pop	r12
    13c6:	bf 90       	pop	r11
    13c8:	af 90       	pop	r10
    13ca:	9f 90       	pop	r9
    13cc:	08 95       	ret

000013ce <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    13d2:	8f e1       	ldi	r24, 0x1F	; 31
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	3c d8       	rcall	.-3976   	; 0x450 <pvPortMalloc>
    13d8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    13da:	00 97       	sbiw	r24, 0x00	; 0
    13dc:	e1 f0       	breq	.+56     	; 0x1416 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    13de:	1b 82       	std	Y+3, r1	; 0x03
    13e0:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    13e2:	19 82       	std	Y+1, r1	; 0x01
    13e4:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    13e6:	1d 82       	std	Y+5, r1	; 0x05
    13e8:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    13ea:	1f 82       	std	Y+7, r1	; 0x07
    13ec:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    13ee:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    13f4:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    13f6:	8f ef       	ldi	r24, 0xFF	; 255
    13f8:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    13fa:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    13fc:	ce 01       	movw	r24, r28
    13fe:	08 96       	adiw	r24, 0x08	; 8
    1400:	5d d8       	rcall	.-3910   	; 0x4bc <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1402:	ce 01       	movw	r24, r28
    1404:	41 96       	adiw	r24, 0x11	; 17
    1406:	5a d8       	rcall	.-3916   	; 0x4bc <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1408:	20 e0       	ldi	r18, 0x00	; 0
    140a:	40 e0       	ldi	r20, 0x00	; 0
    140c:	50 e0       	ldi	r21, 0x00	; 0
    140e:	60 e0       	ldi	r22, 0x00	; 0
    1410:	70 e0       	ldi	r23, 0x00	; 0
    1412:	ce 01       	movw	r24, r28
    1414:	49 df       	rcall	.-366    	; 0x12a8 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1416:	ce 01       	movw	r24, r28
    1418:	df 91       	pop	r29
    141a:	cf 91       	pop	r28
    141c:	08 95       	ret

0000141e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    141e:	0f 93       	push	r16
    1420:	1f 93       	push	r17
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	ec 01       	movw	r28, r24
    1428:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    142a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    142c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    142e:	98 17       	cp	r25, r24
    1430:	10 f0       	brcs	.+4      	; 0x1436 <xQueueGenericSendFromISR+0x18>
    1432:	22 30       	cpi	r18, 0x02	; 2
    1434:	11 f5       	brne	.+68     	; 0x147a <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1436:	42 2f       	mov	r20, r18
    1438:	ce 01       	movw	r24, r28
    143a:	11 de       	rcall	.-990    	; 0x105e <prvCopyDataToQueue>
    143c:	88 23       	and	r24, r24
    143e:	31 f0       	breq	.+12     	; 0x144c <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1440:	01 15       	cp	r16, r1
    1442:	11 05       	cpc	r17, r1
    1444:	19 f0       	breq	.+6      	; 0x144c <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	f8 01       	movw	r30, r16
    144a:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    144c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    144e:	8f 3f       	cpi	r24, 0xFF	; 255
    1450:	79 f4       	brne	.+30     	; 0x1470 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1452:	89 89       	ldd	r24, Y+17	; 0x11
    1454:	88 23       	and	r24, r24
    1456:	99 f0       	breq	.+38     	; 0x147e <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1458:	ce 01       	movw	r24, r28
    145a:	41 96       	adiw	r24, 0x11	; 17
    145c:	a7 d5       	rcall	.+2894   	; 0x1fac <xTaskRemoveFromEventList>
    145e:	88 23       	and	r24, r24
    1460:	81 f0       	breq	.+32     	; 0x1482 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1462:	01 15       	cp	r16, r1
    1464:	11 05       	cpc	r17, r1
    1466:	79 f0       	breq	.+30     	; 0x1486 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	f8 01       	movw	r30, r16
    146c:	80 83       	st	Z, r24
    146e:	0c c0       	rjmp	.+24     	; 0x1488 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1470:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1472:	8f 5f       	subi	r24, 0xFF	; 255
    1474:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1476:	81 e0       	ldi	r24, 0x01	; 1
    1478:	07 c0       	rjmp	.+14     	; 0x1488 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	05 c0       	rjmp	.+10     	; 0x1488 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	03 c0       	rjmp	.+6      	; 0x1488 <xQueueGenericSendFromISR+0x6a>
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	01 c0       	rjmp	.+2      	; 0x1488 <xQueueGenericSendFromISR+0x6a>
    1486:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	1f 91       	pop	r17
    148e:	0f 91       	pop	r16
    1490:	08 95       	ret

00001492 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1492:	9f 92       	push	r9
    1494:	af 92       	push	r10
    1496:	bf 92       	push	r11
    1498:	cf 92       	push	r12
    149a:	df 92       	push	r13
    149c:	ef 92       	push	r14
    149e:	ff 92       	push	r15
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	00 d0       	rcall	.+0      	; 0x14aa <xQueueGenericReceive+0x18>
    14aa:	1f 92       	push	r1
    14ac:	1f 92       	push	r1
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
    14b2:	8c 01       	movw	r16, r24
    14b4:	6b 01       	movw	r12, r22
    14b6:	5d 83       	std	Y+5, r21	; 0x05
    14b8:	4c 83       	std	Y+4, r20	; 0x04
    14ba:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    14bc:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    14be:	99 24       	eor	r9, r9
    14c0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14c2:	7c 01       	movw	r14, r24
    14c4:	81 e1       	ldi	r24, 0x11	; 17
    14c6:	e8 0e       	add	r14, r24
    14c8:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14d0:	f8 01       	movw	r30, r16
    14d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    14d4:	88 23       	and	r24, r24
    14d6:	69 f1       	breq	.+90     	; 0x1532 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14d8:	e6 80       	ldd	r14, Z+6	; 0x06
    14da:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    14dc:	b6 01       	movw	r22, r12
    14de:	c8 01       	movw	r24, r16
    14e0:	20 de       	rcall	.-960    	; 0x1122 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    14e2:	b1 10       	cpse	r11, r1
    14e4:	17 c0       	rjmp	.+46     	; 0x1514 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    14e6:	f8 01       	movw	r30, r16
    14e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ea:	81 50       	subi	r24, 0x01	; 1
    14ec:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14ee:	80 81       	ld	r24, Z
    14f0:	91 81       	ldd	r25, Z+1	; 0x01
    14f2:	89 2b       	or	r24, r25
    14f4:	21 f4       	brne	.+8      	; 0x14fe <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    14f6:	86 d6       	rcall	.+3340   	; 0x2204 <pvTaskIncrementMutexHeldCount>
    14f8:	f8 01       	movw	r30, r16
    14fa:	93 83       	std	Z+3, r25	; 0x03
    14fc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14fe:	f8 01       	movw	r30, r16
    1500:	80 85       	ldd	r24, Z+8	; 0x08
    1502:	88 23       	and	r24, r24
    1504:	91 f0       	breq	.+36     	; 0x152a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1506:	c8 01       	movw	r24, r16
    1508:	08 96       	adiw	r24, 0x08	; 8
    150a:	50 d5       	rcall	.+2720   	; 0x1fac <xTaskRemoveFromEventList>
    150c:	81 30       	cpi	r24, 0x01	; 1
    150e:	69 f4       	brne	.+26     	; 0x152a <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1510:	e2 dc       	rcall	.-1596   	; 0xed6 <vPortYield>
    1512:	0b c0       	rjmp	.+22     	; 0x152a <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1514:	f8 01       	movw	r30, r16
    1516:	f7 82       	std	Z+7, r15	; 0x07
    1518:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    151a:	81 89       	ldd	r24, Z+17	; 0x11
    151c:	88 23       	and	r24, r24
    151e:	29 f0       	breq	.+10     	; 0x152a <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1520:	c8 01       	movw	r24, r16
    1522:	41 96       	adiw	r24, 0x11	; 17
    1524:	43 d5       	rcall	.+2694   	; 0x1fac <xTaskRemoveFromEventList>
    1526:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1528:	d6 dc       	rcall	.-1620   	; 0xed6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    152a:	0f 90       	pop	r0
    152c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	52 c0       	rjmp	.+164    	; 0x15d6 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1532:	4c 81       	ldd	r20, Y+4	; 0x04
    1534:	5d 81       	ldd	r21, Y+5	; 0x05
    1536:	45 2b       	or	r20, r21
    1538:	21 f4       	brne	.+8      	; 0x1542 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	4a c0       	rjmp	.+148    	; 0x15d6 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1542:	a1 10       	cpse	r10, r1
    1544:	04 c0       	rjmp	.+8      	; 0x154e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1546:	ce 01       	movw	r24, r28
    1548:	01 96       	adiw	r24, 0x01	; 1
    154a:	78 d5       	rcall	.+2800   	; 0x203c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    154c:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    154e:	0f 90       	pop	r0
    1550:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1552:	6f d2       	rcall	.+1246   	; 0x1a32 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	0f 92       	push	r0
    155a:	f8 01       	movw	r30, r16
    155c:	85 8d       	ldd	r24, Z+29	; 0x1d
    155e:	8f 3f       	cpi	r24, 0xFF	; 255
    1560:	09 f4       	brne	.+2      	; 0x1564 <xQueueGenericReceive+0xd2>
    1562:	15 8e       	std	Z+29, r1	; 0x1d
    1564:	f8 01       	movw	r30, r16
    1566:	86 8d       	ldd	r24, Z+30	; 0x1e
    1568:	8f 3f       	cpi	r24, 0xFF	; 255
    156a:	09 f4       	brne	.+2      	; 0x156e <xQueueGenericReceive+0xdc>
    156c:	16 8e       	std	Z+30, r1	; 0x1e
    156e:	0f 90       	pop	r0
    1570:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1572:	be 01       	movw	r22, r28
    1574:	6c 5f       	subi	r22, 0xFC	; 252
    1576:	7f 4f       	sbci	r23, 0xFF	; 255
    1578:	ce 01       	movw	r24, r28
    157a:	01 96       	adiw	r24, 0x01	; 1
    157c:	6a d5       	rcall	.+2772   	; 0x2052 <xTaskCheckForTimeOut>
    157e:	81 11       	cpse	r24, r1
    1580:	26 c0       	rjmp	.+76     	; 0x15ce <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1588:	f8 01       	movw	r30, r16
    158a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1590:	81 11       	cpse	r24, r1
    1592:	19 c0       	rjmp	.+50     	; 0x15c6 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1594:	f8 01       	movw	r30, r16
    1596:	80 81       	ld	r24, Z
    1598:	91 81       	ldd	r25, Z+1	; 0x01
    159a:	89 2b       	or	r24, r25
    159c:	49 f4       	brne	.+18     	; 0x15b0 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    15a4:	f8 01       	movw	r30, r16
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	93 81       	ldd	r25, Z+3	; 0x03
    15aa:	8f d5       	rcall	.+2846   	; 0x20ca <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    15ac:	0f 90       	pop	r0
    15ae:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15b0:	6c 81       	ldd	r22, Y+4	; 0x04
    15b2:	7d 81       	ldd	r23, Y+5	; 0x05
    15b4:	c7 01       	movw	r24, r14
    15b6:	cf d4       	rcall	.+2462   	; 0x1f56 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15b8:	c8 01       	movw	r24, r16
    15ba:	cd dd       	rcall	.-1126   	; 0x1156 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    15bc:	0d d3       	rcall	.+1562   	; 0x1bd8 <xTaskResumeAll>
    15be:	81 11       	cpse	r24, r1
    15c0:	84 cf       	rjmp	.-248    	; 0x14ca <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    15c2:	89 dc       	rcall	.-1774   	; 0xed6 <vPortYield>
    15c4:	82 cf       	rjmp	.-252    	; 0x14ca <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15c6:	c8 01       	movw	r24, r16
    15c8:	c6 dd       	rcall	.-1140   	; 0x1156 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15ca:	06 d3       	rcall	.+1548   	; 0x1bd8 <xTaskResumeAll>
    15cc:	7e cf       	rjmp	.-260    	; 0x14ca <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    15ce:	c8 01       	movw	r24, r16
    15d0:	c2 dd       	rcall	.-1148   	; 0x1156 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15d2:	02 d3       	rcall	.+1540   	; 0x1bd8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    15d4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	0f 90       	pop	r0
    15dc:	0f 90       	pop	r0
    15de:	0f 90       	pop	r0
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	ff 90       	pop	r15
    15ea:	ef 90       	pop	r14
    15ec:	df 90       	pop	r13
    15ee:	cf 90       	pop	r12
    15f0:	bf 90       	pop	r11
    15f2:	af 90       	pop	r10
    15f4:	9f 90       	pop	r9
    15f6:	08 95       	ret

000015f8 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    15f8:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    15fa:	71 83       	std	Z+1, r23	; 0x01
    15fc:	60 83       	st	Z, r22
	ring->rSize = size;
    15fe:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1600:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1602:	13 82       	std	Z+3, r1	; 0x03
    1604:	08 95       	ret

00001606 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1606:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1608:	94 81       	ldd	r25, Z+4	; 0x04
    160a:	a0 81       	ld	r26, Z
    160c:	b1 81       	ldd	r27, Z+1	; 0x01
    160e:	a9 0f       	add	r26, r25
    1610:	b1 1d       	adc	r27, r1
    1612:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1614:	9f 5f       	subi	r25, 0xFF	; 255
    1616:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1618:	22 81       	ldd	r18, Z+2	; 0x02
    161a:	92 17       	cp	r25, r18
    161c:	10 f0       	brcs	.+4      	; 0x1622 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    161e:	92 1b       	sub	r25, r18
    1620:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1622:	93 81       	ldd	r25, Z+3	; 0x03
    1624:	91 50       	subi	r25, 0x01	; 1
    1626:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1628:	08 95       	ret

0000162a <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    162a:	fc 01       	movw	r30, r24
    162c:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    162e:	83 81       	ldd	r24, Z+3	; 0x03
    1630:	22 81       	ldd	r18, Z+2	; 0x02
    1632:	82 17       	cp	r24, r18
    1634:	78 f4       	brcc	.+30     	; 0x1654 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1636:	34 81       	ldd	r19, Z+4	; 0x04
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	83 0f       	add	r24, r19
    163c:	91 1d       	adc	r25, r1
    163e:	62 2f       	mov	r22, r18
    1640:	70 e0       	ldi	r23, 0x00	; 0
    1642:	f2 d5       	rcall	.+3044   	; 0x2228 <__divmodhi4>
    1644:	a0 81       	ld	r26, Z
    1646:	b1 81       	ldd	r27, Z+1	; 0x01
    1648:	a8 0f       	add	r26, r24
    164a:	b9 1f       	adc	r27, r25
    164c:	4c 93       	st	X, r20
            ring->rLength++;
    164e:	83 81       	ldd	r24, Z+3	; 0x03
    1650:	8f 5f       	subi	r24, 0xFF	; 255
    1652:	83 83       	std	Z+3, r24	; 0x03
    1654:	08 95       	ret

00001656 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1656:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	22 81       	ldd	r18, Z+2	; 0x02
    165c:	93 81       	ldd	r25, Z+3	; 0x03
    165e:	29 13       	cpse	r18, r25
    1660:	80 e0       	ldi	r24, 0x00	; 0
}
    1662:	08 95       	ret

00001664 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1664:	21 e0       	ldi	r18, 0x01	; 1
    1666:	fc 01       	movw	r30, r24
    1668:	83 81       	ldd	r24, Z+3	; 0x03
    166a:	81 11       	cpse	r24, r1
    166c:	01 c0       	rjmp	.+2      	; 0x1670 <ringBufferNotEmpty+0xc>
    166e:	20 e0       	ldi	r18, 0x00	; 0
}
    1670:	82 2f       	mov	r24, r18
    1672:	08 95       	ret

00001674 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1674:	e0 91 5e 08 	lds	r30, 0x085E
    1678:	f0 91 5f 08 	lds	r31, 0x085F
    167c:	80 81       	ld	r24, Z
    167e:	81 11       	cpse	r24, r1
    1680:	07 c0       	rjmp	.+14     	; 0x1690 <prvResetNextTaskUnblockTime+0x1c>
    1682:	8f ef       	ldi	r24, 0xFF	; 255
    1684:	9f ef       	ldi	r25, 0xFF	; 255
    1686:	90 93 05 02 	sts	0x0205, r25
    168a:	80 93 04 02 	sts	0x0204, r24
    168e:	08 95       	ret
    1690:	e0 91 5e 08 	lds	r30, 0x085E
    1694:	f0 91 5f 08 	lds	r31, 0x085F
    1698:	05 80       	ldd	r0, Z+5	; 0x05
    169a:	f6 81       	ldd	r31, Z+6	; 0x06
    169c:	e0 2d       	mov	r30, r0
    169e:	06 80       	ldd	r0, Z+6	; 0x06
    16a0:	f7 81       	ldd	r31, Z+7	; 0x07
    16a2:	e0 2d       	mov	r30, r0
    16a4:	82 81       	ldd	r24, Z+2	; 0x02
    16a6:	93 81       	ldd	r25, Z+3	; 0x03
    16a8:	90 93 05 02 	sts	0x0205, r25
    16ac:	80 93 04 02 	sts	0x0204, r24
    16b0:	08 95       	ret

000016b2 <prvAddCurrentTaskToDelayedList>:
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	ec 01       	movw	r28, r24
    16b8:	e0 91 9f 08 	lds	r30, 0x089F
    16bc:	f0 91 a0 08 	lds	r31, 0x08A0
    16c0:	93 83       	std	Z+3, r25	; 0x03
    16c2:	82 83       	std	Z+2, r24	; 0x02
    16c4:	80 91 3d 08 	lds	r24, 0x083D
    16c8:	90 91 3e 08 	lds	r25, 0x083E
    16cc:	c8 17       	cp	r28, r24
    16ce:	d9 07       	cpc	r29, r25
    16d0:	68 f4       	brcc	.+26     	; 0x16ec <prvAddCurrentTaskToDelayedList+0x3a>
    16d2:	60 91 9f 08 	lds	r22, 0x089F
    16d6:	70 91 a0 08 	lds	r23, 0x08A0
    16da:	80 91 5c 08 	lds	r24, 0x085C
    16de:	90 91 5d 08 	lds	r25, 0x085D
    16e2:	6e 5f       	subi	r22, 0xFE	; 254
    16e4:	7f 4f       	sbci	r23, 0xFF	; 255
    16e6:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    16ea:	17 c0       	rjmp	.+46     	; 0x171a <prvAddCurrentTaskToDelayedList+0x68>
    16ec:	60 91 9f 08 	lds	r22, 0x089F
    16f0:	70 91 a0 08 	lds	r23, 0x08A0
    16f4:	80 91 5e 08 	lds	r24, 0x085E
    16f8:	90 91 5f 08 	lds	r25, 0x085F
    16fc:	6e 5f       	subi	r22, 0xFE	; 254
    16fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1700:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    1704:	80 91 04 02 	lds	r24, 0x0204
    1708:	90 91 05 02 	lds	r25, 0x0205
    170c:	c8 17       	cp	r28, r24
    170e:	d9 07       	cpc	r29, r25
    1710:	20 f4       	brcc	.+8      	; 0x171a <prvAddCurrentTaskToDelayedList+0x68>
    1712:	d0 93 05 02 	sts	0x0205, r29
    1716:	c0 93 04 02 	sts	0x0204, r28
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	08 95       	ret

00001720 <xTaskGenericCreate>:
    1720:	4f 92       	push	r4
    1722:	5f 92       	push	r5
    1724:	6f 92       	push	r6
    1726:	7f 92       	push	r7
    1728:	8f 92       	push	r8
    172a:	9f 92       	push	r9
    172c:	af 92       	push	r10
    172e:	bf 92       	push	r11
    1730:	cf 92       	push	r12
    1732:	df 92       	push	r13
    1734:	ef 92       	push	r14
    1736:	ff 92       	push	r15
    1738:	0f 93       	push	r16
    173a:	1f 93       	push	r17
    173c:	cf 93       	push	r28
    173e:	df 93       	push	r29
    1740:	4c 01       	movw	r8, r24
    1742:	5b 01       	movw	r10, r22
    1744:	2a 01       	movw	r4, r20
    1746:	39 01       	movw	r6, r18
    1748:	83 e2       	ldi	r24, 0x23	; 35
    174a:	90 e0       	ldi	r25, 0x00	; 0
    174c:	0e 94 28 02 	call	0x450	; 0x450 <pvPortMalloc>
    1750:	ec 01       	movw	r28, r24
    1752:	00 97       	sbiw	r24, 0x00	; 0
    1754:	09 f4       	brne	.+2      	; 0x1758 <xTaskGenericCreate+0x38>
    1756:	e7 c0       	rjmp	.+462    	; 0x1926 <xTaskGenericCreate+0x206>
    1758:	c1 14       	cp	r12, r1
    175a:	d1 04       	cpc	r13, r1
    175c:	09 f0       	breq	.+2      	; 0x1760 <xTaskGenericCreate+0x40>
    175e:	cc c0       	rjmp	.+408    	; 0x18f8 <xTaskGenericCreate+0x1d8>
    1760:	c2 01       	movw	r24, r4
    1762:	0e 94 28 02 	call	0x450	; 0x450 <pvPortMalloc>
    1766:	98 8f       	std	Y+24, r25	; 0x18
    1768:	8f 8b       	std	Y+23, r24	; 0x17
    176a:	89 2b       	or	r24, r25
    176c:	09 f0       	breq	.+2      	; 0x1770 <xTaskGenericCreate+0x50>
    176e:	c6 c0       	rjmp	.+396    	; 0x18fc <xTaskGenericCreate+0x1dc>
    1770:	ce 01       	movw	r24, r28
    1772:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1776:	d7 c0       	rjmp	.+430    	; 0x1926 <xTaskGenericCreate+0x206>
    1778:	cf 01       	movw	r24, r30
    177a:	31 91       	ld	r19, Z+
    177c:	da 01       	movw	r26, r20
    177e:	3d 93       	st	X+, r19
    1780:	ad 01       	movw	r20, r26
    1782:	dc 01       	movw	r26, r24
    1784:	8c 91       	ld	r24, X
    1786:	88 23       	and	r24, r24
    1788:	11 f0       	breq	.+4      	; 0x178e <xTaskGenericCreate+0x6e>
    178a:	21 50       	subi	r18, 0x01	; 1
    178c:	a9 f7       	brne	.-22     	; 0x1778 <xTaskGenericCreate+0x58>
    178e:	18 a2       	std	Y+32, r1	; 0x20
    1790:	10 2f       	mov	r17, r16
    1792:	05 30       	cpi	r16, 0x05	; 5
    1794:	08 f0       	brcs	.+2      	; 0x1798 <xTaskGenericCreate+0x78>
    1796:	14 e0       	ldi	r17, 0x04	; 4
    1798:	1e 8b       	std	Y+22, r17	; 0x16
    179a:	19 a3       	std	Y+33, r17	; 0x21
    179c:	1a a2       	std	Y+34, r1	; 0x22
    179e:	5e 01       	movw	r10, r28
    17a0:	b2 e0       	ldi	r27, 0x02	; 2
    17a2:	ab 0e       	add	r10, r27
    17a4:	b1 1c       	adc	r11, r1
    17a6:	c5 01       	movw	r24, r10
    17a8:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <vListInitialiseItem>
    17ac:	ce 01       	movw	r24, r28
    17ae:	0c 96       	adiw	r24, 0x0c	; 12
    17b0:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <vListInitialiseItem>
    17b4:	d9 87       	std	Y+9, r29	; 0x09
    17b6:	c8 87       	std	Y+8, r28	; 0x08
    17b8:	85 e0       	ldi	r24, 0x05	; 5
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	81 1b       	sub	r24, r17
    17be:	91 09       	sbc	r25, r1
    17c0:	9d 87       	std	Y+13, r25	; 0x0d
    17c2:	8c 87       	std	Y+12, r24	; 0x0c
    17c4:	db 8b       	std	Y+19, r29	; 0x13
    17c6:	ca 8b       	std	Y+18, r28	; 0x12
    17c8:	a3 01       	movw	r20, r6
    17ca:	b4 01       	movw	r22, r8
    17cc:	c6 01       	movw	r24, r12
    17ce:	d4 da       	rcall	.-2648   	; 0xd78 <pxPortInitialiseStack>
    17d0:	99 83       	std	Y+1, r25	; 0x01
    17d2:	88 83       	st	Y, r24
    17d4:	e1 14       	cp	r14, r1
    17d6:	f1 04       	cpc	r15, r1
    17d8:	19 f0       	breq	.+6      	; 0x17e0 <xTaskGenericCreate+0xc0>
    17da:	f7 01       	movw	r30, r14
    17dc:	d1 83       	std	Z+1, r29	; 0x01
    17de:	c0 83       	st	Z, r28
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	f8 94       	cli
    17e4:	0f 92       	push	r0
    17e6:	80 91 3f 08 	lds	r24, 0x083F
    17ea:	8f 5f       	subi	r24, 0xFF	; 255
    17ec:	80 93 3f 08 	sts	0x083F, r24
    17f0:	80 91 9f 08 	lds	r24, 0x089F
    17f4:	90 91 a0 08 	lds	r25, 0x08A0
    17f8:	89 2b       	or	r24, r25
    17fa:	09 f0       	breq	.+2      	; 0x17fe <xTaskGenericCreate+0xde>
    17fc:	3f c0       	rjmp	.+126    	; 0x187c <xTaskGenericCreate+0x15c>
    17fe:	d0 93 a0 08 	sts	0x08A0, r29
    1802:	c0 93 9f 08 	sts	0x089F, r28
    1806:	80 91 3f 08 	lds	r24, 0x083F
    180a:	81 30       	cpi	r24, 0x01	; 1
    180c:	09 f0       	breq	.+2      	; 0x1810 <xTaskGenericCreate+0xf0>
    180e:	45 c0       	rjmp	.+138    	; 0x189a <xTaskGenericCreate+0x17a>
    1810:	0f 2e       	mov	r0, r31
    1812:	f2 e7       	ldi	r31, 0x72	; 114
    1814:	ef 2e       	mov	r14, r31
    1816:	f8 e0       	ldi	r31, 0x08	; 8
    1818:	ff 2e       	mov	r15, r31
    181a:	f0 2d       	mov	r31, r0
    181c:	0f 2e       	mov	r0, r31
    181e:	ff e9       	ldi	r31, 0x9F	; 159
    1820:	cf 2e       	mov	r12, r31
    1822:	f8 e0       	ldi	r31, 0x08	; 8
    1824:	df 2e       	mov	r13, r31
    1826:	f0 2d       	mov	r31, r0
    1828:	c7 01       	movw	r24, r14
    182a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    182e:	f9 e0       	ldi	r31, 0x09	; 9
    1830:	ef 0e       	add	r14, r31
    1832:	f1 1c       	adc	r15, r1
    1834:	ec 14       	cp	r14, r12
    1836:	fd 04       	cpc	r15, r13
    1838:	b9 f7       	brne	.-18     	; 0x1828 <xTaskGenericCreate+0x108>
    183a:	89 e6       	ldi	r24, 0x69	; 105
    183c:	98 e0       	ldi	r25, 0x08	; 8
    183e:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    1842:	80 e6       	ldi	r24, 0x60	; 96
    1844:	98 e0       	ldi	r25, 0x08	; 8
    1846:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    184a:	83 e5       	ldi	r24, 0x53	; 83
    184c:	98 e0       	ldi	r25, 0x08	; 8
    184e:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    1852:	8a e4       	ldi	r24, 0x4A	; 74
    1854:	98 e0       	ldi	r25, 0x08	; 8
    1856:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    185a:	80 e4       	ldi	r24, 0x40	; 64
    185c:	98 e0       	ldi	r25, 0x08	; 8
    185e:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    1862:	89 e6       	ldi	r24, 0x69	; 105
    1864:	98 e0       	ldi	r25, 0x08	; 8
    1866:	90 93 5f 08 	sts	0x085F, r25
    186a:	80 93 5e 08 	sts	0x085E, r24
    186e:	80 e6       	ldi	r24, 0x60	; 96
    1870:	98 e0       	ldi	r25, 0x08	; 8
    1872:	90 93 5d 08 	sts	0x085D, r25
    1876:	80 93 5c 08 	sts	0x085C, r24
    187a:	0f c0       	rjmp	.+30     	; 0x189a <xTaskGenericCreate+0x17a>
    187c:	80 91 3b 08 	lds	r24, 0x083B
    1880:	81 11       	cpse	r24, r1
    1882:	0b c0       	rjmp	.+22     	; 0x189a <xTaskGenericCreate+0x17a>
    1884:	e0 91 9f 08 	lds	r30, 0x089F
    1888:	f0 91 a0 08 	lds	r31, 0x08A0
    188c:	86 89       	ldd	r24, Z+22	; 0x16
    188e:	08 17       	cp	r16, r24
    1890:	20 f0       	brcs	.+8      	; 0x189a <xTaskGenericCreate+0x17a>
    1892:	d0 93 a0 08 	sts	0x08A0, r29
    1896:	c0 93 9f 08 	sts	0x089F, r28
    189a:	80 91 37 08 	lds	r24, 0x0837
    189e:	8f 5f       	subi	r24, 0xFF	; 255
    18a0:	80 93 37 08 	sts	0x0837, r24
    18a4:	8e 89       	ldd	r24, Y+22	; 0x16
    18a6:	90 91 3c 08 	lds	r25, 0x083C
    18aa:	98 17       	cp	r25, r24
    18ac:	10 f4       	brcc	.+4      	; 0x18b2 <xTaskGenericCreate+0x192>
    18ae:	80 93 3c 08 	sts	0x083C, r24
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	9c 01       	movw	r18, r24
    18b6:	22 0f       	add	r18, r18
    18b8:	33 1f       	adc	r19, r19
    18ba:	22 0f       	add	r18, r18
    18bc:	33 1f       	adc	r19, r19
    18be:	22 0f       	add	r18, r18
    18c0:	33 1f       	adc	r19, r19
    18c2:	82 0f       	add	r24, r18
    18c4:	93 1f       	adc	r25, r19
    18c6:	b5 01       	movw	r22, r10
    18c8:	8e 58       	subi	r24, 0x8E	; 142
    18ca:	97 4f       	sbci	r25, 0xF7	; 247
    18cc:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	80 91 3b 08 	lds	r24, 0x083B
    18d8:	88 23       	and	r24, r24
    18da:	51 f0       	breq	.+20     	; 0x18f0 <xTaskGenericCreate+0x1d0>
    18dc:	e0 91 9f 08 	lds	r30, 0x089F
    18e0:	f0 91 a0 08 	lds	r31, 0x08A0
    18e4:	86 89       	ldd	r24, Z+22	; 0x16
    18e6:	80 17       	cp	r24, r16
    18e8:	28 f4       	brcc	.+10     	; 0x18f4 <xTaskGenericCreate+0x1d4>
    18ea:	f5 da       	rcall	.-2582   	; 0xed6 <vPortYield>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	1c c0       	rjmp	.+56     	; 0x1928 <xTaskGenericCreate+0x208>
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	1a c0       	rjmp	.+52     	; 0x1928 <xTaskGenericCreate+0x208>
    18f4:	81 e0       	ldi	r24, 0x01	; 1
    18f6:	18 c0       	rjmp	.+48     	; 0x1928 <xTaskGenericCreate+0x208>
    18f8:	d8 8e       	std	Y+24, r13	; 0x18
    18fa:	cf 8a       	std	Y+23, r12	; 0x17
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	48 1a       	sub	r4, r24
    1900:	51 08       	sbc	r5, r1
    1902:	cf 88       	ldd	r12, Y+23	; 0x17
    1904:	d8 8c       	ldd	r13, Y+24	; 0x18
    1906:	c4 0c       	add	r12, r4
    1908:	d5 1c       	adc	r13, r5
    190a:	d5 01       	movw	r26, r10
    190c:	8c 91       	ld	r24, X
    190e:	89 8f       	std	Y+25, r24	; 0x19
    1910:	8c 91       	ld	r24, X
    1912:	88 23       	and	r24, r24
    1914:	09 f4       	brne	.+2      	; 0x1918 <xTaskGenericCreate+0x1f8>
    1916:	3b cf       	rjmp	.-394    	; 0x178e <xTaskGenericCreate+0x6e>
    1918:	ae 01       	movw	r20, r28
    191a:	46 5e       	subi	r20, 0xE6	; 230
    191c:	5f 4f       	sbci	r21, 0xFF	; 255
    191e:	f5 01       	movw	r30, r10
    1920:	31 96       	adiw	r30, 0x01	; 1
    1922:	27 e0       	ldi	r18, 0x07	; 7
    1924:	29 cf       	rjmp	.-430    	; 0x1778 <xTaskGenericCreate+0x58>
    1926:	8f ef       	ldi	r24, 0xFF	; 255
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	1f 91       	pop	r17
    192e:	0f 91       	pop	r16
    1930:	ff 90       	pop	r15
    1932:	ef 90       	pop	r14
    1934:	df 90       	pop	r13
    1936:	cf 90       	pop	r12
    1938:	bf 90       	pop	r11
    193a:	af 90       	pop	r10
    193c:	9f 90       	pop	r9
    193e:	8f 90       	pop	r8
    1940:	7f 90       	pop	r7
    1942:	6f 90       	pop	r6
    1944:	5f 90       	pop	r5
    1946:	4f 90       	pop	r4
    1948:	08 95       	ret

0000194a <vTaskResume>:
    194a:	0f 93       	push	r16
    194c:	1f 93       	push	r17
    194e:	cf 93       	push	r28
    1950:	df 93       	push	r29
    1952:	ec 01       	movw	r28, r24
    1954:	00 97       	sbiw	r24, 0x00	; 0
    1956:	09 f4       	brne	.+2      	; 0x195a <vTaskResume+0x10>
    1958:	3e c0       	rjmp	.+124    	; 0x19d6 <vTaskResume+0x8c>
    195a:	80 91 9f 08 	lds	r24, 0x089F
    195e:	90 91 a0 08 	lds	r25, 0x08A0
    1962:	c8 17       	cp	r28, r24
    1964:	d9 07       	cpc	r29, r25
    1966:	b9 f1       	breq	.+110    	; 0x19d6 <vTaskResume+0x8c>
    1968:	0f b6       	in	r0, 0x3f	; 63
    196a:	f8 94       	cli
    196c:	0f 92       	push	r0
    196e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1970:	9b 85       	ldd	r25, Y+11	; 0x0b
    1972:	80 54       	subi	r24, 0x40	; 64
    1974:	98 40       	sbci	r25, 0x08	; 8
    1976:	69 f5       	brne	.+90     	; 0x19d2 <vTaskResume+0x88>
    1978:	8c 89       	ldd	r24, Y+20	; 0x14
    197a:	9d 89       	ldd	r25, Y+21	; 0x15
    197c:	28 e0       	ldi	r18, 0x08	; 8
    197e:	83 35       	cpi	r24, 0x53	; 83
    1980:	92 07       	cpc	r25, r18
    1982:	39 f1       	breq	.+78     	; 0x19d2 <vTaskResume+0x88>
    1984:	89 2b       	or	r24, r25
    1986:	29 f5       	brne	.+74     	; 0x19d2 <vTaskResume+0x88>
    1988:	8e 01       	movw	r16, r28
    198a:	0e 5f       	subi	r16, 0xFE	; 254
    198c:	1f 4f       	sbci	r17, 0xFF	; 255
    198e:	c8 01       	movw	r24, r16
    1990:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1994:	8e 89       	ldd	r24, Y+22	; 0x16
    1996:	90 91 3c 08 	lds	r25, 0x083C
    199a:	98 17       	cp	r25, r24
    199c:	10 f4       	brcc	.+4      	; 0x19a2 <vTaskResume+0x58>
    199e:	80 93 3c 08 	sts	0x083C, r24
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	9c 01       	movw	r18, r24
    19a6:	22 0f       	add	r18, r18
    19a8:	33 1f       	adc	r19, r19
    19aa:	22 0f       	add	r18, r18
    19ac:	33 1f       	adc	r19, r19
    19ae:	22 0f       	add	r18, r18
    19b0:	33 1f       	adc	r19, r19
    19b2:	82 0f       	add	r24, r18
    19b4:	93 1f       	adc	r25, r19
    19b6:	b8 01       	movw	r22, r16
    19b8:	8e 58       	subi	r24, 0x8E	; 142
    19ba:	97 4f       	sbci	r25, 0xF7	; 247
    19bc:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    19c0:	e0 91 9f 08 	lds	r30, 0x089F
    19c4:	f0 91 a0 08 	lds	r31, 0x08A0
    19c8:	9e 89       	ldd	r25, Y+22	; 0x16
    19ca:	86 89       	ldd	r24, Z+22	; 0x16
    19cc:	98 17       	cp	r25, r24
    19ce:	08 f0       	brcs	.+2      	; 0x19d2 <vTaskResume+0x88>
    19d0:	82 da       	rcall	.-2812   	; 0xed6 <vPortYield>
    19d2:	0f 90       	pop	r0
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	df 91       	pop	r29
    19d8:	cf 91       	pop	r28
    19da:	1f 91       	pop	r17
    19dc:	0f 91       	pop	r16
    19de:	08 95       	ret

000019e0 <vTaskStartScheduler>:
    19e0:	af 92       	push	r10
    19e2:	bf 92       	push	r11
    19e4:	cf 92       	push	r12
    19e6:	df 92       	push	r13
    19e8:	ef 92       	push	r14
    19ea:	ff 92       	push	r15
    19ec:	0f 93       	push	r16
    19ee:	a1 2c       	mov	r10, r1
    19f0:	b1 2c       	mov	r11, r1
    19f2:	c1 2c       	mov	r12, r1
    19f4:	d1 2c       	mov	r13, r1
    19f6:	e1 2c       	mov	r14, r1
    19f8:	f1 2c       	mov	r15, r1
    19fa:	00 e0       	ldi	r16, 0x00	; 0
    19fc:	20 e0       	ldi	r18, 0x00	; 0
    19fe:	30 e0       	ldi	r19, 0x00	; 0
    1a00:	45 e5       	ldi	r20, 0x55	; 85
    1a02:	50 e0       	ldi	r21, 0x00	; 0
    1a04:	60 e5       	ldi	r22, 0x50	; 80
    1a06:	72 e0       	ldi	r23, 0x02	; 2
    1a08:	87 ec       	ldi	r24, 0xC7	; 199
    1a0a:	9e e0       	ldi	r25, 0x0E	; 14
    1a0c:	89 de       	rcall	.-750    	; 0x1720 <xTaskGenericCreate>
    1a0e:	81 30       	cpi	r24, 0x01	; 1
    1a10:	41 f4       	brne	.+16     	; 0x1a22 <vTaskStartScheduler+0x42>
    1a12:	f8 94       	cli
    1a14:	80 93 3b 08 	sts	0x083B, r24
    1a18:	10 92 3e 08 	sts	0x083E, r1
    1a1c:	10 92 3d 08 	sts	0x083D, r1
    1a20:	1d da       	rcall	.-3014   	; 0xe5c <xPortStartScheduler>
    1a22:	0f 91       	pop	r16
    1a24:	ff 90       	pop	r15
    1a26:	ef 90       	pop	r14
    1a28:	df 90       	pop	r13
    1a2a:	cf 90       	pop	r12
    1a2c:	bf 90       	pop	r11
    1a2e:	af 90       	pop	r10
    1a30:	08 95       	ret

00001a32 <vTaskSuspendAll>:
    1a32:	80 91 36 08 	lds	r24, 0x0836
    1a36:	8f 5f       	subi	r24, 0xFF	; 255
    1a38:	80 93 36 08 	sts	0x0836, r24
    1a3c:	08 95       	ret

00001a3e <xTaskGetTickCount>:
    1a3e:	0f b6       	in	r0, 0x3f	; 63
    1a40:	f8 94       	cli
    1a42:	0f 92       	push	r0
    1a44:	80 91 3d 08 	lds	r24, 0x083D
    1a48:	90 91 3e 08 	lds	r25, 0x083E
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63
    1a50:	08 95       	ret

00001a52 <xTaskGetTickCountFromISR>:
    1a52:	80 91 3d 08 	lds	r24, 0x083D
    1a56:	90 91 3e 08 	lds	r25, 0x083E
    1a5a:	08 95       	ret

00001a5c <xTaskIncrementTick>:
    1a5c:	cf 92       	push	r12
    1a5e:	df 92       	push	r13
    1a60:	ef 92       	push	r14
    1a62:	ff 92       	push	r15
    1a64:	0f 93       	push	r16
    1a66:	1f 93       	push	r17
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29
    1a6c:	80 91 36 08 	lds	r24, 0x0836
    1a70:	81 11       	cpse	r24, r1
    1a72:	99 c0       	rjmp	.+306    	; 0x1ba6 <xTaskIncrementTick+0x14a>
    1a74:	80 91 3d 08 	lds	r24, 0x083D
    1a78:	90 91 3e 08 	lds	r25, 0x083E
    1a7c:	01 96       	adiw	r24, 0x01	; 1
    1a7e:	90 93 3e 08 	sts	0x083E, r25
    1a82:	80 93 3d 08 	sts	0x083D, r24
    1a86:	e0 90 3d 08 	lds	r14, 0x083D
    1a8a:	f0 90 3e 08 	lds	r15, 0x083E
    1a8e:	e1 14       	cp	r14, r1
    1a90:	f1 04       	cpc	r15, r1
    1a92:	b1 f4       	brne	.+44     	; 0x1ac0 <xTaskIncrementTick+0x64>
    1a94:	80 91 5e 08 	lds	r24, 0x085E
    1a98:	90 91 5f 08 	lds	r25, 0x085F
    1a9c:	20 91 5c 08 	lds	r18, 0x085C
    1aa0:	30 91 5d 08 	lds	r19, 0x085D
    1aa4:	30 93 5f 08 	sts	0x085F, r19
    1aa8:	20 93 5e 08 	sts	0x085E, r18
    1aac:	90 93 5d 08 	sts	0x085D, r25
    1ab0:	80 93 5c 08 	sts	0x085C, r24
    1ab4:	80 91 38 08 	lds	r24, 0x0838
    1ab8:	8f 5f       	subi	r24, 0xFF	; 255
    1aba:	80 93 38 08 	sts	0x0838, r24
    1abe:	da dd       	rcall	.-1100   	; 0x1674 <prvResetNextTaskUnblockTime>
    1ac0:	80 91 04 02 	lds	r24, 0x0204
    1ac4:	90 91 05 02 	lds	r25, 0x0205
    1ac8:	e8 16       	cp	r14, r24
    1aca:	f9 06       	cpc	r15, r25
    1acc:	08 f4       	brcc	.+2      	; 0x1ad0 <xTaskIncrementTick+0x74>
    1ace:	54 c0       	rjmp	.+168    	; 0x1b78 <xTaskIncrementTick+0x11c>
    1ad0:	d1 2c       	mov	r13, r1
    1ad2:	cc 24       	eor	r12, r12
    1ad4:	c3 94       	inc	r12
    1ad6:	01 c0       	rjmp	.+2      	; 0x1ada <xTaskIncrementTick+0x7e>
    1ad8:	dc 2c       	mov	r13, r12
    1ada:	e0 91 5e 08 	lds	r30, 0x085E
    1ade:	f0 91 5f 08 	lds	r31, 0x085F
    1ae2:	80 81       	ld	r24, Z
    1ae4:	81 11       	cpse	r24, r1
    1ae6:	07 c0       	rjmp	.+14     	; 0x1af6 <xTaskIncrementTick+0x9a>
    1ae8:	8f ef       	ldi	r24, 0xFF	; 255
    1aea:	9f ef       	ldi	r25, 0xFF	; 255
    1aec:	90 93 05 02 	sts	0x0205, r25
    1af0:	80 93 04 02 	sts	0x0204, r24
    1af4:	42 c0       	rjmp	.+132    	; 0x1b7a <xTaskIncrementTick+0x11e>
    1af6:	e0 91 5e 08 	lds	r30, 0x085E
    1afa:	f0 91 5f 08 	lds	r31, 0x085F
    1afe:	05 80       	ldd	r0, Z+5	; 0x05
    1b00:	f6 81       	ldd	r31, Z+6	; 0x06
    1b02:	e0 2d       	mov	r30, r0
    1b04:	c6 81       	ldd	r28, Z+6	; 0x06
    1b06:	d7 81       	ldd	r29, Z+7	; 0x07
    1b08:	2a 81       	ldd	r18, Y+2	; 0x02
    1b0a:	3b 81       	ldd	r19, Y+3	; 0x03
    1b0c:	e2 16       	cp	r14, r18
    1b0e:	f3 06       	cpc	r15, r19
    1b10:	28 f4       	brcc	.+10     	; 0x1b1c <xTaskIncrementTick+0xc0>
    1b12:	30 93 05 02 	sts	0x0205, r19
    1b16:	20 93 04 02 	sts	0x0204, r18
    1b1a:	2f c0       	rjmp	.+94     	; 0x1b7a <xTaskIncrementTick+0x11e>
    1b1c:	8e 01       	movw	r16, r28
    1b1e:	0e 5f       	subi	r16, 0xFE	; 254
    1b20:	1f 4f       	sbci	r17, 0xFF	; 255
    1b22:	c8 01       	movw	r24, r16
    1b24:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1b28:	8c 89       	ldd	r24, Y+20	; 0x14
    1b2a:	9d 89       	ldd	r25, Y+21	; 0x15
    1b2c:	89 2b       	or	r24, r25
    1b2e:	21 f0       	breq	.+8      	; 0x1b38 <xTaskIncrementTick+0xdc>
    1b30:	ce 01       	movw	r24, r28
    1b32:	0c 96       	adiw	r24, 0x0c	; 12
    1b34:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1b38:	2e 89       	ldd	r18, Y+22	; 0x16
    1b3a:	80 91 3c 08 	lds	r24, 0x083C
    1b3e:	82 17       	cp	r24, r18
    1b40:	10 f4       	brcc	.+4      	; 0x1b46 <xTaskIncrementTick+0xea>
    1b42:	20 93 3c 08 	sts	0x083C, r18
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	c9 01       	movw	r24, r18
    1b4a:	88 0f       	add	r24, r24
    1b4c:	99 1f       	adc	r25, r25
    1b4e:	88 0f       	add	r24, r24
    1b50:	99 1f       	adc	r25, r25
    1b52:	88 0f       	add	r24, r24
    1b54:	99 1f       	adc	r25, r25
    1b56:	82 0f       	add	r24, r18
    1b58:	93 1f       	adc	r25, r19
    1b5a:	b8 01       	movw	r22, r16
    1b5c:	8e 58       	subi	r24, 0x8E	; 142
    1b5e:	97 4f       	sbci	r25, 0xF7	; 247
    1b60:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1b64:	e0 91 9f 08 	lds	r30, 0x089F
    1b68:	f0 91 a0 08 	lds	r31, 0x08A0
    1b6c:	9e 89       	ldd	r25, Y+22	; 0x16
    1b6e:	86 89       	ldd	r24, Z+22	; 0x16
    1b70:	98 17       	cp	r25, r24
    1b72:	08 f0       	brcs	.+2      	; 0x1b76 <xTaskIncrementTick+0x11a>
    1b74:	b1 cf       	rjmp	.-158    	; 0x1ad8 <xTaskIncrementTick+0x7c>
    1b76:	b1 cf       	rjmp	.-158    	; 0x1ada <xTaskIncrementTick+0x7e>
    1b78:	d1 2c       	mov	r13, r1
    1b7a:	e0 91 9f 08 	lds	r30, 0x089F
    1b7e:	f0 91 a0 08 	lds	r31, 0x08A0
    1b82:	86 89       	ldd	r24, Z+22	; 0x16
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	fc 01       	movw	r30, r24
    1b88:	ee 0f       	add	r30, r30
    1b8a:	ff 1f       	adc	r31, r31
    1b8c:	ee 0f       	add	r30, r30
    1b8e:	ff 1f       	adc	r31, r31
    1b90:	ee 0f       	add	r30, r30
    1b92:	ff 1f       	adc	r31, r31
    1b94:	8e 0f       	add	r24, r30
    1b96:	9f 1f       	adc	r25, r31
    1b98:	fc 01       	movw	r30, r24
    1b9a:	ee 58       	subi	r30, 0x8E	; 142
    1b9c:	f7 4f       	sbci	r31, 0xF7	; 247
    1b9e:	80 81       	ld	r24, Z
    1ba0:	82 30       	cpi	r24, 0x02	; 2
    1ba2:	40 f4       	brcc	.+16     	; 0x1bb4 <xTaskIncrementTick+0x158>
    1ba4:	09 c0       	rjmp	.+18     	; 0x1bb8 <xTaskIncrementTick+0x15c>
    1ba6:	80 91 3a 08 	lds	r24, 0x083A
    1baa:	8f 5f       	subi	r24, 0xFF	; 255
    1bac:	80 93 3a 08 	sts	0x083A, r24
    1bb0:	d1 2c       	mov	r13, r1
    1bb2:	02 c0       	rjmp	.+4      	; 0x1bb8 <xTaskIncrementTick+0x15c>
    1bb4:	dd 24       	eor	r13, r13
    1bb6:	d3 94       	inc	r13
    1bb8:	80 91 39 08 	lds	r24, 0x0839
    1bbc:	88 23       	and	r24, r24
    1bbe:	11 f0       	breq	.+4      	; 0x1bc4 <xTaskIncrementTick+0x168>
    1bc0:	dd 24       	eor	r13, r13
    1bc2:	d3 94       	inc	r13
    1bc4:	8d 2d       	mov	r24, r13
    1bc6:	df 91       	pop	r29
    1bc8:	cf 91       	pop	r28
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	08 95       	ret

00001bd8 <xTaskResumeAll>:
    1bd8:	df 92       	push	r13
    1bda:	ef 92       	push	r14
    1bdc:	ff 92       	push	r15
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	0f 92       	push	r0
    1bec:	80 91 36 08 	lds	r24, 0x0836
    1bf0:	81 50       	subi	r24, 0x01	; 1
    1bf2:	80 93 36 08 	sts	0x0836, r24
    1bf6:	80 91 36 08 	lds	r24, 0x0836
    1bfa:	81 11       	cpse	r24, r1
    1bfc:	5f c0       	rjmp	.+190    	; 0x1cbc <xTaskResumeAll+0xe4>
    1bfe:	80 91 3f 08 	lds	r24, 0x083F
    1c02:	88 23       	and	r24, r24
    1c04:	09 f4       	brne	.+2      	; 0x1c08 <xTaskResumeAll+0x30>
    1c06:	5c c0       	rjmp	.+184    	; 0x1cc0 <xTaskResumeAll+0xe8>
    1c08:	0f 2e       	mov	r0, r31
    1c0a:	f3 e5       	ldi	r31, 0x53	; 83
    1c0c:	ef 2e       	mov	r14, r31
    1c0e:	f8 e0       	ldi	r31, 0x08	; 8
    1c10:	ff 2e       	mov	r15, r31
    1c12:	f0 2d       	mov	r31, r0
    1c14:	dd 24       	eor	r13, r13
    1c16:	d3 94       	inc	r13
    1c18:	30 c0       	rjmp	.+96     	; 0x1c7a <xTaskResumeAll+0xa2>
    1c1a:	e0 91 58 08 	lds	r30, 0x0858
    1c1e:	f0 91 59 08 	lds	r31, 0x0859
    1c22:	c6 81       	ldd	r28, Z+6	; 0x06
    1c24:	d7 81       	ldd	r29, Z+7	; 0x07
    1c26:	ce 01       	movw	r24, r28
    1c28:	0c 96       	adiw	r24, 0x0c	; 12
    1c2a:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1c2e:	8e 01       	movw	r16, r28
    1c30:	0e 5f       	subi	r16, 0xFE	; 254
    1c32:	1f 4f       	sbci	r17, 0xFF	; 255
    1c34:	c8 01       	movw	r24, r16
    1c36:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1c3a:	8e 89       	ldd	r24, Y+22	; 0x16
    1c3c:	90 91 3c 08 	lds	r25, 0x083C
    1c40:	98 17       	cp	r25, r24
    1c42:	10 f4       	brcc	.+4      	; 0x1c48 <xTaskResumeAll+0x70>
    1c44:	80 93 3c 08 	sts	0x083C, r24
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	9c 01       	movw	r18, r24
    1c4c:	22 0f       	add	r18, r18
    1c4e:	33 1f       	adc	r19, r19
    1c50:	22 0f       	add	r18, r18
    1c52:	33 1f       	adc	r19, r19
    1c54:	22 0f       	add	r18, r18
    1c56:	33 1f       	adc	r19, r19
    1c58:	82 0f       	add	r24, r18
    1c5a:	93 1f       	adc	r25, r19
    1c5c:	b8 01       	movw	r22, r16
    1c5e:	8e 58       	subi	r24, 0x8E	; 142
    1c60:	97 4f       	sbci	r25, 0xF7	; 247
    1c62:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1c66:	e0 91 9f 08 	lds	r30, 0x089F
    1c6a:	f0 91 a0 08 	lds	r31, 0x08A0
    1c6e:	9e 89       	ldd	r25, Y+22	; 0x16
    1c70:	86 89       	ldd	r24, Z+22	; 0x16
    1c72:	98 17       	cp	r25, r24
    1c74:	10 f0       	brcs	.+4      	; 0x1c7a <xTaskResumeAll+0xa2>
    1c76:	d0 92 39 08 	sts	0x0839, r13
    1c7a:	f7 01       	movw	r30, r14
    1c7c:	80 81       	ld	r24, Z
    1c7e:	81 11       	cpse	r24, r1
    1c80:	cc cf       	rjmp	.-104    	; 0x1c1a <xTaskResumeAll+0x42>
    1c82:	80 91 3a 08 	lds	r24, 0x083A
    1c86:	88 23       	and	r24, r24
    1c88:	91 f0       	breq	.+36     	; 0x1cae <xTaskResumeAll+0xd6>
    1c8a:	80 91 3a 08 	lds	r24, 0x083A
    1c8e:	88 23       	and	r24, r24
    1c90:	71 f0       	breq	.+28     	; 0x1cae <xTaskResumeAll+0xd6>
    1c92:	c1 e0       	ldi	r28, 0x01	; 1
    1c94:	e3 de       	rcall	.-570    	; 0x1a5c <xTaskIncrementTick>
    1c96:	81 11       	cpse	r24, r1
    1c98:	c0 93 39 08 	sts	0x0839, r28
    1c9c:	80 91 3a 08 	lds	r24, 0x083A
    1ca0:	81 50       	subi	r24, 0x01	; 1
    1ca2:	80 93 3a 08 	sts	0x083A, r24
    1ca6:	80 91 3a 08 	lds	r24, 0x083A
    1caa:	81 11       	cpse	r24, r1
    1cac:	f3 cf       	rjmp	.-26     	; 0x1c94 <xTaskResumeAll+0xbc>
    1cae:	80 91 39 08 	lds	r24, 0x0839
    1cb2:	81 30       	cpi	r24, 0x01	; 1
    1cb4:	39 f4       	brne	.+14     	; 0x1cc4 <xTaskResumeAll+0xec>
    1cb6:	0f d9       	rcall	.-3554   	; 0xed6 <vPortYield>
    1cb8:	81 e0       	ldi	r24, 0x01	; 1
    1cba:	05 c0       	rjmp	.+10     	; 0x1cc6 <xTaskResumeAll+0xee>
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	03 c0       	rjmp	.+6      	; 0x1cc6 <xTaskResumeAll+0xee>
    1cc0:	80 e0       	ldi	r24, 0x00	; 0
    1cc2:	01 c0       	rjmp	.+2      	; 0x1cc6 <xTaskResumeAll+0xee>
    1cc4:	80 e0       	ldi	r24, 0x00	; 0
    1cc6:	0f 90       	pop	r0
    1cc8:	0f be       	out	0x3f, r0	; 63
    1cca:	df 91       	pop	r29
    1ccc:	cf 91       	pop	r28
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	ff 90       	pop	r15
    1cd4:	ef 90       	pop	r14
    1cd6:	df 90       	pop	r13
    1cd8:	08 95       	ret

00001cda <vTaskDelayUntil>:
    1cda:	0f 93       	push	r16
    1cdc:	1f 93       	push	r17
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
    1ce2:	8c 01       	movw	r16, r24
    1ce4:	eb 01       	movw	r28, r22
    1ce6:	a5 de       	rcall	.-694    	; 0x1a32 <vTaskSuspendAll>
    1ce8:	80 91 3d 08 	lds	r24, 0x083D
    1cec:	90 91 3e 08 	lds	r25, 0x083E
    1cf0:	f8 01       	movw	r30, r16
    1cf2:	20 81       	ld	r18, Z
    1cf4:	31 81       	ldd	r19, Z+1	; 0x01
    1cf6:	c2 0f       	add	r28, r18
    1cf8:	d3 1f       	adc	r29, r19
    1cfa:	82 17       	cp	r24, r18
    1cfc:	93 07       	cpc	r25, r19
    1cfe:	48 f4       	brcc	.+18     	; 0x1d12 <vTaskDelayUntil+0x38>
    1d00:	c2 17       	cp	r28, r18
    1d02:	d3 07       	cpc	r29, r19
    1d04:	f8 f4       	brcc	.+62     	; 0x1d44 <vTaskDelayUntil+0x6a>
    1d06:	d1 83       	std	Z+1, r29	; 0x01
    1d08:	c0 83       	st	Z, r28
    1d0a:	8c 17       	cp	r24, r28
    1d0c:	9d 07       	cpc	r25, r29
    1d0e:	88 f4       	brcc	.+34     	; 0x1d32 <vTaskDelayUntil+0x58>
    1d10:	07 c0       	rjmp	.+14     	; 0x1d20 <vTaskDelayUntil+0x46>
    1d12:	c2 17       	cp	r28, r18
    1d14:	d3 07       	cpc	r29, r19
    1d16:	90 f0       	brcs	.+36     	; 0x1d3c <vTaskDelayUntil+0x62>
    1d18:	8c 17       	cp	r24, r28
    1d1a:	9d 07       	cpc	r25, r29
    1d1c:	78 f0       	brcs	.+30     	; 0x1d3c <vTaskDelayUntil+0x62>
    1d1e:	12 c0       	rjmp	.+36     	; 0x1d44 <vTaskDelayUntil+0x6a>
    1d20:	80 91 9f 08 	lds	r24, 0x089F
    1d24:	90 91 a0 08 	lds	r25, 0x08A0
    1d28:	02 96       	adiw	r24, 0x02	; 2
    1d2a:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1d2e:	ce 01       	movw	r24, r28
    1d30:	c0 dc       	rcall	.-1664   	; 0x16b2 <prvAddCurrentTaskToDelayedList>
    1d32:	52 df       	rcall	.-348    	; 0x1bd8 <xTaskResumeAll>
    1d34:	81 11       	cpse	r24, r1
    1d36:	0a c0       	rjmp	.+20     	; 0x1d4c <vTaskDelayUntil+0x72>
    1d38:	ce d8       	rcall	.-3684   	; 0xed6 <vPortYield>
    1d3a:	08 c0       	rjmp	.+16     	; 0x1d4c <vTaskDelayUntil+0x72>
    1d3c:	f8 01       	movw	r30, r16
    1d3e:	d1 83       	std	Z+1, r29	; 0x01
    1d40:	c0 83       	st	Z, r28
    1d42:	ee cf       	rjmp	.-36     	; 0x1d20 <vTaskDelayUntil+0x46>
    1d44:	f8 01       	movw	r30, r16
    1d46:	d1 83       	std	Z+1, r29	; 0x01
    1d48:	c0 83       	st	Z, r28
    1d4a:	f3 cf       	rjmp	.-26     	; 0x1d32 <vTaskDelayUntil+0x58>
    1d4c:	df 91       	pop	r29
    1d4e:	cf 91       	pop	r28
    1d50:	1f 91       	pop	r17
    1d52:	0f 91       	pop	r16
    1d54:	08 95       	ret

00001d56 <vTaskDelay>:
    1d56:	cf 93       	push	r28
    1d58:	df 93       	push	r29
    1d5a:	ec 01       	movw	r28, r24
    1d5c:	00 97       	sbiw	r24, 0x00	; 0
    1d5e:	99 f0       	breq	.+38     	; 0x1d86 <vTaskDelay+0x30>
    1d60:	68 de       	rcall	.-816    	; 0x1a32 <vTaskSuspendAll>
    1d62:	80 91 3d 08 	lds	r24, 0x083D
    1d66:	90 91 3e 08 	lds	r25, 0x083E
    1d6a:	c8 0f       	add	r28, r24
    1d6c:	d9 1f       	adc	r29, r25
    1d6e:	80 91 9f 08 	lds	r24, 0x089F
    1d72:	90 91 a0 08 	lds	r25, 0x08A0
    1d76:	02 96       	adiw	r24, 0x02	; 2
    1d78:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1d7c:	ce 01       	movw	r24, r28
    1d7e:	99 dc       	rcall	.-1742   	; 0x16b2 <prvAddCurrentTaskToDelayedList>
    1d80:	2b df       	rcall	.-426    	; 0x1bd8 <xTaskResumeAll>
    1d82:	81 11       	cpse	r24, r1
    1d84:	01 c0       	rjmp	.+2      	; 0x1d88 <vTaskDelay+0x32>
    1d86:	a7 d8       	rcall	.-3762   	; 0xed6 <vPortYield>
    1d88:	df 91       	pop	r29
    1d8a:	cf 91       	pop	r28
    1d8c:	08 95       	ret

00001d8e <prvIdleTask>:
    1d8e:	0f 2e       	mov	r0, r31
    1d90:	f2 e7       	ldi	r31, 0x72	; 114
    1d92:	ef 2e       	mov	r14, r31
    1d94:	f8 e0       	ldi	r31, 0x08	; 8
    1d96:	ff 2e       	mov	r15, r31
    1d98:	f0 2d       	mov	r31, r0
    1d9a:	ca e4       	ldi	r28, 0x4A	; 74
    1d9c:	d8 e0       	ldi	r29, 0x08	; 8
    1d9e:	26 c0       	rjmp	.+76     	; 0x1dec <prvIdleTask+0x5e>
    1da0:	48 de       	rcall	.-880    	; 0x1a32 <vTaskSuspendAll>
    1da2:	18 81       	ld	r17, Y
    1da4:	19 df       	rcall	.-462    	; 0x1bd8 <xTaskResumeAll>
    1da6:	11 23       	and	r17, r17
    1da8:	09 f1       	breq	.+66     	; 0x1dec <prvIdleTask+0x5e>
    1daa:	0f b6       	in	r0, 0x3f	; 63
    1dac:	f8 94       	cli
    1dae:	0f 92       	push	r0
    1db0:	e0 91 4f 08 	lds	r30, 0x084F
    1db4:	f0 91 50 08 	lds	r31, 0x0850
    1db8:	06 81       	ldd	r16, Z+6	; 0x06
    1dba:	17 81       	ldd	r17, Z+7	; 0x07
    1dbc:	c8 01       	movw	r24, r16
    1dbe:	02 96       	adiw	r24, 0x02	; 2
    1dc0:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1dc4:	80 91 3f 08 	lds	r24, 0x083F
    1dc8:	81 50       	subi	r24, 0x01	; 1
    1dca:	80 93 3f 08 	sts	0x083F, r24
    1dce:	80 91 49 08 	lds	r24, 0x0849
    1dd2:	81 50       	subi	r24, 0x01	; 1
    1dd4:	80 93 49 08 	sts	0x0849, r24
    1dd8:	0f 90       	pop	r0
    1dda:	0f be       	out	0x3f, r0	; 63
    1ddc:	f8 01       	movw	r30, r16
    1dde:	87 89       	ldd	r24, Z+23	; 0x17
    1de0:	90 8d       	ldd	r25, Z+24	; 0x18
    1de2:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1de6:	c8 01       	movw	r24, r16
    1de8:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1dec:	80 91 49 08 	lds	r24, 0x0849
    1df0:	81 11       	cpse	r24, r1
    1df2:	d6 cf       	rjmp	.-84     	; 0x1da0 <prvIdleTask+0x12>
    1df4:	f7 01       	movw	r30, r14
    1df6:	80 81       	ld	r24, Z
    1df8:	82 30       	cpi	r24, 0x02	; 2
    1dfa:	c0 f3       	brcs	.-16     	; 0x1dec <prvIdleTask+0x5e>
    1dfc:	6c d8       	rcall	.-3880   	; 0xed6 <vPortYield>
    1dfe:	f6 cf       	rjmp	.-20     	; 0x1dec <prvIdleTask+0x5e>

00001e00 <vTaskSwitchContext>:
    1e00:	80 91 36 08 	lds	r24, 0x0836
    1e04:	88 23       	and	r24, r24
    1e06:	21 f0       	breq	.+8      	; 0x1e10 <vTaskSwitchContext+0x10>
    1e08:	81 e0       	ldi	r24, 0x01	; 1
    1e0a:	80 93 39 08 	sts	0x0839, r24
    1e0e:	08 95       	ret
    1e10:	10 92 39 08 	sts	0x0839, r1
    1e14:	80 91 3c 08 	lds	r24, 0x083C
    1e18:	90 e0       	ldi	r25, 0x00	; 0
    1e1a:	fc 01       	movw	r30, r24
    1e1c:	ee 0f       	add	r30, r30
    1e1e:	ff 1f       	adc	r31, r31
    1e20:	ee 0f       	add	r30, r30
    1e22:	ff 1f       	adc	r31, r31
    1e24:	ee 0f       	add	r30, r30
    1e26:	ff 1f       	adc	r31, r31
    1e28:	8e 0f       	add	r24, r30
    1e2a:	9f 1f       	adc	r25, r31
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	ee 58       	subi	r30, 0x8E	; 142
    1e30:	f7 4f       	sbci	r31, 0xF7	; 247
    1e32:	80 81       	ld	r24, Z
    1e34:	81 11       	cpse	r24, r1
    1e36:	17 c0       	rjmp	.+46     	; 0x1e66 <vTaskSwitchContext+0x66>
    1e38:	80 91 3c 08 	lds	r24, 0x083C
    1e3c:	81 50       	subi	r24, 0x01	; 1
    1e3e:	80 93 3c 08 	sts	0x083C, r24
    1e42:	80 91 3c 08 	lds	r24, 0x083C
    1e46:	90 e0       	ldi	r25, 0x00	; 0
    1e48:	fc 01       	movw	r30, r24
    1e4a:	ee 0f       	add	r30, r30
    1e4c:	ff 1f       	adc	r31, r31
    1e4e:	ee 0f       	add	r30, r30
    1e50:	ff 1f       	adc	r31, r31
    1e52:	ee 0f       	add	r30, r30
    1e54:	ff 1f       	adc	r31, r31
    1e56:	8e 0f       	add	r24, r30
    1e58:	9f 1f       	adc	r25, r31
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	ee 58       	subi	r30, 0x8E	; 142
    1e5e:	f7 4f       	sbci	r31, 0xF7	; 247
    1e60:	80 81       	ld	r24, Z
    1e62:	88 23       	and	r24, r24
    1e64:	49 f3       	breq	.-46     	; 0x1e38 <vTaskSwitchContext+0x38>
    1e66:	e0 91 3c 08 	lds	r30, 0x083C
    1e6a:	f0 e0       	ldi	r31, 0x00	; 0
    1e6c:	cf 01       	movw	r24, r30
    1e6e:	88 0f       	add	r24, r24
    1e70:	99 1f       	adc	r25, r25
    1e72:	88 0f       	add	r24, r24
    1e74:	99 1f       	adc	r25, r25
    1e76:	88 0f       	add	r24, r24
    1e78:	99 1f       	adc	r25, r25
    1e7a:	e8 0f       	add	r30, r24
    1e7c:	f9 1f       	adc	r31, r25
    1e7e:	ee 58       	subi	r30, 0x8E	; 142
    1e80:	f7 4f       	sbci	r31, 0xF7	; 247
    1e82:	a1 81       	ldd	r26, Z+1	; 0x01
    1e84:	b2 81       	ldd	r27, Z+2	; 0x02
    1e86:	12 96       	adiw	r26, 0x02	; 2
    1e88:	0d 90       	ld	r0, X+
    1e8a:	bc 91       	ld	r27, X
    1e8c:	a0 2d       	mov	r26, r0
    1e8e:	b2 83       	std	Z+2, r27	; 0x02
    1e90:	a1 83       	std	Z+1, r26	; 0x01
    1e92:	cf 01       	movw	r24, r30
    1e94:	03 96       	adiw	r24, 0x03	; 3
    1e96:	a8 17       	cp	r26, r24
    1e98:	b9 07       	cpc	r27, r25
    1e9a:	31 f4       	brne	.+12     	; 0x1ea8 <vTaskSwitchContext+0xa8>
    1e9c:	12 96       	adiw	r26, 0x02	; 2
    1e9e:	8d 91       	ld	r24, X+
    1ea0:	9c 91       	ld	r25, X
    1ea2:	13 97       	sbiw	r26, 0x03	; 3
    1ea4:	92 83       	std	Z+2, r25	; 0x02
    1ea6:	81 83       	std	Z+1, r24	; 0x01
    1ea8:	01 80       	ldd	r0, Z+1	; 0x01
    1eaa:	f2 81       	ldd	r31, Z+2	; 0x02
    1eac:	e0 2d       	mov	r30, r0
    1eae:	86 81       	ldd	r24, Z+6	; 0x06
    1eb0:	97 81       	ldd	r25, Z+7	; 0x07
    1eb2:	90 93 a0 08 	sts	0x08A0, r25
    1eb6:	80 93 9f 08 	sts	0x089F, r24
    1eba:	08 95       	ret

00001ebc <vTaskSuspend>:
    1ebc:	0f 93       	push	r16
    1ebe:	1f 93       	push	r17
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	ec 01       	movw	r28, r24
    1ec6:	0f b6       	in	r0, 0x3f	; 63
    1ec8:	f8 94       	cli
    1eca:	0f 92       	push	r0
    1ecc:	00 97       	sbiw	r24, 0x00	; 0
    1ece:	21 f4       	brne	.+8      	; 0x1ed8 <vTaskSuspend+0x1c>
    1ed0:	c0 91 9f 08 	lds	r28, 0x089F
    1ed4:	d0 91 a0 08 	lds	r29, 0x08A0
    1ed8:	8e 01       	movw	r16, r28
    1eda:	0e 5f       	subi	r16, 0xFE	; 254
    1edc:	1f 4f       	sbci	r17, 0xFF	; 255
    1ede:	c8 01       	movw	r24, r16
    1ee0:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1ee4:	8c 89       	ldd	r24, Y+20	; 0x14
    1ee6:	9d 89       	ldd	r25, Y+21	; 0x15
    1ee8:	89 2b       	or	r24, r25
    1eea:	21 f0       	breq	.+8      	; 0x1ef4 <vTaskSuspend+0x38>
    1eec:	ce 01       	movw	r24, r28
    1eee:	0c 96       	adiw	r24, 0x0c	; 12
    1ef0:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1ef4:	b8 01       	movw	r22, r16
    1ef6:	80 e4       	ldi	r24, 0x40	; 64
    1ef8:	98 e0       	ldi	r25, 0x08	; 8
    1efa:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	80 91 9f 08 	lds	r24, 0x089F
    1f06:	90 91 a0 08 	lds	r25, 0x08A0
    1f0a:	c8 17       	cp	r28, r24
    1f0c:	d9 07       	cpc	r29, r25
    1f0e:	a1 f4       	brne	.+40     	; 0x1f38 <vTaskSuspend+0x7c>
    1f10:	80 91 3b 08 	lds	r24, 0x083B
    1f14:	88 23       	and	r24, r24
    1f16:	19 f0       	breq	.+6      	; 0x1f1e <vTaskSuspend+0x62>
    1f18:	0e 94 6b 07 	call	0xed6	; 0xed6 <vPortYield>
    1f1c:	17 c0       	rjmp	.+46     	; 0x1f4c <vTaskSuspend+0x90>
    1f1e:	80 91 3f 08 	lds	r24, 0x083F
    1f22:	90 91 40 08 	lds	r25, 0x0840
    1f26:	98 13       	cpse	r25, r24
    1f28:	05 c0       	rjmp	.+10     	; 0x1f34 <vTaskSuspend+0x78>
    1f2a:	10 92 a0 08 	sts	0x08A0, r1
    1f2e:	10 92 9f 08 	sts	0x089F, r1
    1f32:	0c c0       	rjmp	.+24     	; 0x1f4c <vTaskSuspend+0x90>
    1f34:	65 df       	rcall	.-310    	; 0x1e00 <vTaskSwitchContext>
    1f36:	0a c0       	rjmp	.+20     	; 0x1f4c <vTaskSuspend+0x90>
    1f38:	80 91 3b 08 	lds	r24, 0x083B
    1f3c:	88 23       	and	r24, r24
    1f3e:	31 f0       	breq	.+12     	; 0x1f4c <vTaskSuspend+0x90>
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	0f 92       	push	r0
    1f46:	96 db       	rcall	.-2260   	; 0x1674 <prvResetNextTaskUnblockTime>
    1f48:	0f 90       	pop	r0
    1f4a:	0f be       	out	0x3f, r0	; 63
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	1f 91       	pop	r17
    1f52:	0f 91       	pop	r16
    1f54:	08 95       	ret

00001f56 <vTaskPlaceOnEventList>:
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	eb 01       	movw	r28, r22
    1f5c:	60 91 9f 08 	lds	r22, 0x089F
    1f60:	70 91 a0 08 	lds	r23, 0x08A0
    1f64:	64 5f       	subi	r22, 0xF4	; 244
    1f66:	7f 4f       	sbci	r23, 0xFF	; 255
    1f68:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    1f6c:	80 91 9f 08 	lds	r24, 0x089F
    1f70:	90 91 a0 08 	lds	r25, 0x08A0
    1f74:	02 96       	adiw	r24, 0x02	; 2
    1f76:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1f7a:	cf 3f       	cpi	r28, 0xFF	; 255
    1f7c:	8f ef       	ldi	r24, 0xFF	; 255
    1f7e:	d8 07       	cpc	r29, r24
    1f80:	59 f4       	brne	.+22     	; 0x1f98 <vTaskPlaceOnEventList+0x42>
    1f82:	60 91 9f 08 	lds	r22, 0x089F
    1f86:	70 91 a0 08 	lds	r23, 0x08A0
    1f8a:	6e 5f       	subi	r22, 0xFE	; 254
    1f8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f8e:	80 e4       	ldi	r24, 0x40	; 64
    1f90:	98 e0       	ldi	r25, 0x08	; 8
    1f92:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1f96:	07 c0       	rjmp	.+14     	; 0x1fa6 <vTaskPlaceOnEventList+0x50>
    1f98:	80 91 3d 08 	lds	r24, 0x083D
    1f9c:	90 91 3e 08 	lds	r25, 0x083E
    1fa0:	8c 0f       	add	r24, r28
    1fa2:	9d 1f       	adc	r25, r29
    1fa4:	86 db       	rcall	.-2292   	; 0x16b2 <prvAddCurrentTaskToDelayedList>
    1fa6:	df 91       	pop	r29
    1fa8:	cf 91       	pop	r28
    1faa:	08 95       	ret

00001fac <xTaskRemoveFromEventList>:
    1fac:	0f 93       	push	r16
    1fae:	1f 93       	push	r17
    1fb0:	cf 93       	push	r28
    1fb2:	df 93       	push	r29
    1fb4:	dc 01       	movw	r26, r24
    1fb6:	15 96       	adiw	r26, 0x05	; 5
    1fb8:	ed 91       	ld	r30, X+
    1fba:	fc 91       	ld	r31, X
    1fbc:	16 97       	sbiw	r26, 0x06	; 6
    1fbe:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc0:	d7 81       	ldd	r29, Z+7	; 0x07
    1fc2:	8e 01       	movw	r16, r28
    1fc4:	04 5f       	subi	r16, 0xF4	; 244
    1fc6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc8:	c8 01       	movw	r24, r16
    1fca:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1fce:	80 91 36 08 	lds	r24, 0x0836
    1fd2:	81 11       	cpse	r24, r1
    1fd4:	1c c0       	rjmp	.+56     	; 0x200e <xTaskRemoveFromEventList+0x62>
    1fd6:	0a 50       	subi	r16, 0x0A	; 10
    1fd8:	11 09       	sbc	r17, r1
    1fda:	c8 01       	movw	r24, r16
    1fdc:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1fe0:	8e 89       	ldd	r24, Y+22	; 0x16
    1fe2:	90 91 3c 08 	lds	r25, 0x083C
    1fe6:	98 17       	cp	r25, r24
    1fe8:	10 f4       	brcc	.+4      	; 0x1fee <xTaskRemoveFromEventList+0x42>
    1fea:	80 93 3c 08 	sts	0x083C, r24
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	9c 01       	movw	r18, r24
    1ff2:	22 0f       	add	r18, r18
    1ff4:	33 1f       	adc	r19, r19
    1ff6:	22 0f       	add	r18, r18
    1ff8:	33 1f       	adc	r19, r19
    1ffa:	22 0f       	add	r18, r18
    1ffc:	33 1f       	adc	r19, r19
    1ffe:	82 0f       	add	r24, r18
    2000:	93 1f       	adc	r25, r19
    2002:	b8 01       	movw	r22, r16
    2004:	8e 58       	subi	r24, 0x8E	; 142
    2006:	97 4f       	sbci	r25, 0xF7	; 247
    2008:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    200c:	05 c0       	rjmp	.+10     	; 0x2018 <xTaskRemoveFromEventList+0x6c>
    200e:	b8 01       	movw	r22, r16
    2010:	83 e5       	ldi	r24, 0x53	; 83
    2012:	98 e0       	ldi	r25, 0x08	; 8
    2014:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    2018:	e0 91 9f 08 	lds	r30, 0x089F
    201c:	f0 91 a0 08 	lds	r31, 0x08A0
    2020:	9e 89       	ldd	r25, Y+22	; 0x16
    2022:	86 89       	ldd	r24, Z+22	; 0x16
    2024:	89 17       	cp	r24, r25
    2026:	20 f4       	brcc	.+8      	; 0x2030 <xTaskRemoveFromEventList+0x84>
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	80 93 39 08 	sts	0x0839, r24
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xTaskRemoveFromEventList+0x86>
    2030:	80 e0       	ldi	r24, 0x00	; 0
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	1f 91       	pop	r17
    2038:	0f 91       	pop	r16
    203a:	08 95       	ret

0000203c <vTaskSetTimeOutState>:
    203c:	20 91 38 08 	lds	r18, 0x0838
    2040:	fc 01       	movw	r30, r24
    2042:	20 83       	st	Z, r18
    2044:	20 91 3d 08 	lds	r18, 0x083D
    2048:	30 91 3e 08 	lds	r19, 0x083E
    204c:	32 83       	std	Z+2, r19	; 0x02
    204e:	21 83       	std	Z+1, r18	; 0x01
    2050:	08 95       	ret

00002052 <xTaskCheckForTimeOut>:
    2052:	0f b6       	in	r0, 0x3f	; 63
    2054:	f8 94       	cli
    2056:	0f 92       	push	r0
    2058:	40 91 3d 08 	lds	r20, 0x083D
    205c:	50 91 3e 08 	lds	r21, 0x083E
    2060:	db 01       	movw	r26, r22
    2062:	2d 91       	ld	r18, X+
    2064:	3c 91       	ld	r19, X
    2066:	2f 3f       	cpi	r18, 0xFF	; 255
    2068:	bf ef       	ldi	r27, 0xFF	; 255
    206a:	3b 07       	cpc	r19, r27
    206c:	11 f1       	breq	.+68     	; 0x20b2 <xTaskCheckForTimeOut+0x60>
    206e:	e0 91 38 08 	lds	r30, 0x0838
    2072:	dc 01       	movw	r26, r24
    2074:	fc 91       	ld	r31, X
    2076:	fe 17       	cp	r31, r30
    2078:	39 f0       	breq	.+14     	; 0x2088 <xTaskCheckForTimeOut+0x36>
    207a:	11 96       	adiw	r26, 0x01	; 1
    207c:	ed 91       	ld	r30, X+
    207e:	fc 91       	ld	r31, X
    2080:	12 97       	sbiw	r26, 0x02	; 2
    2082:	4e 17       	cp	r20, r30
    2084:	5f 07       	cpc	r21, r31
    2086:	b8 f4       	brcc	.+46     	; 0x20b6 <xTaskCheckForTimeOut+0x64>
    2088:	dc 01       	movw	r26, r24
    208a:	11 96       	adiw	r26, 0x01	; 1
    208c:	ed 91       	ld	r30, X+
    208e:	fc 91       	ld	r31, X
    2090:	12 97       	sbiw	r26, 0x02	; 2
    2092:	da 01       	movw	r26, r20
    2094:	ae 1b       	sub	r26, r30
    2096:	bf 0b       	sbc	r27, r31
    2098:	a2 17       	cp	r26, r18
    209a:	b3 07       	cpc	r27, r19
    209c:	70 f4       	brcc	.+28     	; 0x20ba <xTaskCheckForTimeOut+0x68>
    209e:	e4 1b       	sub	r30, r20
    20a0:	f5 0b       	sbc	r31, r21
    20a2:	2e 0f       	add	r18, r30
    20a4:	3f 1f       	adc	r19, r31
    20a6:	fb 01       	movw	r30, r22
    20a8:	31 83       	std	Z+1, r19	; 0x01
    20aa:	20 83       	st	Z, r18
    20ac:	c7 df       	rcall	.-114    	; 0x203c <vTaskSetTimeOutState>
    20ae:	80 e0       	ldi	r24, 0x00	; 0
    20b0:	05 c0       	rjmp	.+10     	; 0x20bc <xTaskCheckForTimeOut+0x6a>
    20b2:	80 e0       	ldi	r24, 0x00	; 0
    20b4:	03 c0       	rjmp	.+6      	; 0x20bc <xTaskCheckForTimeOut+0x6a>
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	01 c0       	rjmp	.+2      	; 0x20bc <xTaskCheckForTimeOut+0x6a>
    20ba:	81 e0       	ldi	r24, 0x01	; 1
    20bc:	0f 90       	pop	r0
    20be:	0f be       	out	0x3f, r0	; 63
    20c0:	08 95       	ret

000020c2 <vTaskMissedYield>:
    20c2:	81 e0       	ldi	r24, 0x01	; 1
    20c4:	80 93 39 08 	sts	0x0839, r24
    20c8:	08 95       	ret

000020ca <vTaskPriorityInherit>:
    20ca:	0f 93       	push	r16
    20cc:	1f 93       	push	r17
    20ce:	cf 93       	push	r28
    20d0:	df 93       	push	r29
    20d2:	ec 01       	movw	r28, r24
    20d4:	00 97       	sbiw	r24, 0x00	; 0
    20d6:	09 f4       	brne	.+2      	; 0x20da <vTaskPriorityInherit+0x10>
    20d8:	51 c0       	rjmp	.+162    	; 0x217c <vTaskPriorityInherit+0xb2>
    20da:	8e 89       	ldd	r24, Y+22	; 0x16
    20dc:	e0 91 9f 08 	lds	r30, 0x089F
    20e0:	f0 91 a0 08 	lds	r31, 0x08A0
    20e4:	96 89       	ldd	r25, Z+22	; 0x16
    20e6:	89 17       	cp	r24, r25
    20e8:	08 f0       	brcs	.+2      	; 0x20ec <vTaskPriorityInherit+0x22>
    20ea:	48 c0       	rjmp	.+144    	; 0x217c <vTaskPriorityInherit+0xb2>
    20ec:	2c 85       	ldd	r18, Y+12	; 0x0c
    20ee:	3d 85       	ldd	r19, Y+13	; 0x0d
    20f0:	33 23       	and	r19, r19
    20f2:	5c f0       	brlt	.+22     	; 0x210a <vTaskPriorityInherit+0x40>
    20f4:	e0 91 9f 08 	lds	r30, 0x089F
    20f8:	f0 91 a0 08 	lds	r31, 0x08A0
    20fc:	96 89       	ldd	r25, Z+22	; 0x16
    20fe:	25 e0       	ldi	r18, 0x05	; 5
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	29 1b       	sub	r18, r25
    2104:	31 09       	sbc	r19, r1
    2106:	3d 87       	std	Y+13, r19	; 0x0d
    2108:	2c 87       	std	Y+12, r18	; 0x0c
    210a:	90 e0       	ldi	r25, 0x00	; 0
    210c:	9c 01       	movw	r18, r24
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	22 0f       	add	r18, r18
    2114:	33 1f       	adc	r19, r19
    2116:	22 0f       	add	r18, r18
    2118:	33 1f       	adc	r19, r19
    211a:	82 0f       	add	r24, r18
    211c:	93 1f       	adc	r25, r19
    211e:	8e 58       	subi	r24, 0x8E	; 142
    2120:	97 4f       	sbci	r25, 0xF7	; 247
    2122:	2a 85       	ldd	r18, Y+10	; 0x0a
    2124:	3b 85       	ldd	r19, Y+11	; 0x0b
    2126:	28 17       	cp	r18, r24
    2128:	39 07       	cpc	r19, r25
    212a:	11 f5       	brne	.+68     	; 0x2170 <vTaskPriorityInherit+0xa6>
    212c:	8e 01       	movw	r16, r28
    212e:	0e 5f       	subi	r16, 0xFE	; 254
    2130:	1f 4f       	sbci	r17, 0xFF	; 255
    2132:	c8 01       	movw	r24, r16
    2134:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    2138:	e0 91 9f 08 	lds	r30, 0x089F
    213c:	f0 91 a0 08 	lds	r31, 0x08A0
    2140:	86 89       	ldd	r24, Z+22	; 0x16
    2142:	8e 8b       	std	Y+22, r24	; 0x16
    2144:	90 91 3c 08 	lds	r25, 0x083C
    2148:	98 17       	cp	r25, r24
    214a:	10 f4       	brcc	.+4      	; 0x2150 <vTaskPriorityInherit+0x86>
    214c:	80 93 3c 08 	sts	0x083C, r24
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	9c 01       	movw	r18, r24
    2154:	22 0f       	add	r18, r18
    2156:	33 1f       	adc	r19, r19
    2158:	22 0f       	add	r18, r18
    215a:	33 1f       	adc	r19, r19
    215c:	22 0f       	add	r18, r18
    215e:	33 1f       	adc	r19, r19
    2160:	82 0f       	add	r24, r18
    2162:	93 1f       	adc	r25, r19
    2164:	b8 01       	movw	r22, r16
    2166:	8e 58       	subi	r24, 0x8E	; 142
    2168:	97 4f       	sbci	r25, 0xF7	; 247
    216a:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    216e:	06 c0       	rjmp	.+12     	; 0x217c <vTaskPriorityInherit+0xb2>
    2170:	e0 91 9f 08 	lds	r30, 0x089F
    2174:	f0 91 a0 08 	lds	r31, 0x08A0
    2178:	86 89       	ldd	r24, Z+22	; 0x16
    217a:	8e 8b       	std	Y+22, r24	; 0x16
    217c:	df 91       	pop	r29
    217e:	cf 91       	pop	r28
    2180:	1f 91       	pop	r17
    2182:	0f 91       	pop	r16
    2184:	08 95       	ret

00002186 <xTaskPriorityDisinherit>:
    2186:	0f 93       	push	r16
    2188:	1f 93       	push	r17
    218a:	cf 93       	push	r28
    218c:	df 93       	push	r29
    218e:	ec 01       	movw	r28, r24
    2190:	00 97       	sbiw	r24, 0x00	; 0
    2192:	71 f1       	breq	.+92     	; 0x21f0 <xTaskPriorityDisinherit+0x6a>
    2194:	8a a1       	ldd	r24, Y+34	; 0x22
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	8a a3       	std	Y+34, r24	; 0x22
    219a:	2e 89       	ldd	r18, Y+22	; 0x16
    219c:	99 a1       	ldd	r25, Y+33	; 0x21
    219e:	29 17       	cp	r18, r25
    21a0:	49 f1       	breq	.+82     	; 0x21f4 <xTaskPriorityDisinherit+0x6e>
    21a2:	81 11       	cpse	r24, r1
    21a4:	29 c0       	rjmp	.+82     	; 0x21f8 <xTaskPriorityDisinherit+0x72>
    21a6:	8e 01       	movw	r16, r28
    21a8:	0e 5f       	subi	r16, 0xFE	; 254
    21aa:	1f 4f       	sbci	r17, 0xFF	; 255
    21ac:	c8 01       	movw	r24, r16
    21ae:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    21b2:	89 a1       	ldd	r24, Y+33	; 0x21
    21b4:	8e 8b       	std	Y+22, r24	; 0x16
    21b6:	25 e0       	ldi	r18, 0x05	; 5
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	28 1b       	sub	r18, r24
    21bc:	31 09       	sbc	r19, r1
    21be:	3d 87       	std	Y+13, r19	; 0x0d
    21c0:	2c 87       	std	Y+12, r18	; 0x0c
    21c2:	90 91 3c 08 	lds	r25, 0x083C
    21c6:	98 17       	cp	r25, r24
    21c8:	10 f4       	brcc	.+4      	; 0x21ce <xTaskPriorityDisinherit+0x48>
    21ca:	80 93 3c 08 	sts	0x083C, r24
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	9c 01       	movw	r18, r24
    21d2:	22 0f       	add	r18, r18
    21d4:	33 1f       	adc	r19, r19
    21d6:	22 0f       	add	r18, r18
    21d8:	33 1f       	adc	r19, r19
    21da:	22 0f       	add	r18, r18
    21dc:	33 1f       	adc	r19, r19
    21de:	82 0f       	add	r24, r18
    21e0:	93 1f       	adc	r25, r19
    21e2:	b8 01       	movw	r22, r16
    21e4:	8e 58       	subi	r24, 0x8E	; 142
    21e6:	97 4f       	sbci	r25, 0xF7	; 247
    21e8:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	05 c0       	rjmp	.+10     	; 0x21fa <xTaskPriorityDisinherit+0x74>
    21f0:	80 e0       	ldi	r24, 0x00	; 0
    21f2:	03 c0       	rjmp	.+6      	; 0x21fa <xTaskPriorityDisinherit+0x74>
    21f4:	80 e0       	ldi	r24, 0x00	; 0
    21f6:	01 c0       	rjmp	.+2      	; 0x21fa <xTaskPriorityDisinherit+0x74>
    21f8:	80 e0       	ldi	r24, 0x00	; 0
    21fa:	df 91       	pop	r29
    21fc:	cf 91       	pop	r28
    21fe:	1f 91       	pop	r17
    2200:	0f 91       	pop	r16
    2202:	08 95       	ret

00002204 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2204:	80 91 9f 08 	lds	r24, 0x089F
    2208:	90 91 a0 08 	lds	r25, 0x08A0
    220c:	89 2b       	or	r24, r25
    220e:	39 f0       	breq	.+14     	; 0x221e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2210:	e0 91 9f 08 	lds	r30, 0x089F
    2214:	f0 91 a0 08 	lds	r31, 0x08A0
    2218:	82 a1       	ldd	r24, Z+34	; 0x22
    221a:	8f 5f       	subi	r24, 0xFF	; 255
    221c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    221e:	80 91 9f 08 	lds	r24, 0x089F
    2222:	90 91 a0 08 	lds	r25, 0x08A0
	}
    2226:	08 95       	ret

00002228 <__divmodhi4>:
    2228:	97 fb       	bst	r25, 7
    222a:	07 2e       	mov	r0, r23
    222c:	16 f4       	brtc	.+4      	; 0x2232 <__divmodhi4+0xa>
    222e:	00 94       	com	r0
    2230:	06 d0       	rcall	.+12     	; 0x223e <__divmodhi4_neg1>
    2232:	77 fd       	sbrc	r23, 7
    2234:	08 d0       	rcall	.+16     	; 0x2246 <__divmodhi4_neg2>
    2236:	0b d0       	rcall	.+22     	; 0x224e <__udivmodhi4>
    2238:	07 fc       	sbrc	r0, 7
    223a:	05 d0       	rcall	.+10     	; 0x2246 <__divmodhi4_neg2>
    223c:	3e f4       	brtc	.+14     	; 0x224c <__divmodhi4_exit>

0000223e <__divmodhi4_neg1>:
    223e:	90 95       	com	r25
    2240:	81 95       	neg	r24
    2242:	9f 4f       	sbci	r25, 0xFF	; 255
    2244:	08 95       	ret

00002246 <__divmodhi4_neg2>:
    2246:	70 95       	com	r23
    2248:	61 95       	neg	r22
    224a:	7f 4f       	sbci	r23, 0xFF	; 255

0000224c <__divmodhi4_exit>:
    224c:	08 95       	ret

0000224e <__udivmodhi4>:
    224e:	aa 1b       	sub	r26, r26
    2250:	bb 1b       	sub	r27, r27
    2252:	51 e1       	ldi	r21, 0x11	; 17
    2254:	07 c0       	rjmp	.+14     	; 0x2264 <__udivmodhi4_ep>

00002256 <__udivmodhi4_loop>:
    2256:	aa 1f       	adc	r26, r26
    2258:	bb 1f       	adc	r27, r27
    225a:	a6 17       	cp	r26, r22
    225c:	b7 07       	cpc	r27, r23
    225e:	10 f0       	brcs	.+4      	; 0x2264 <__udivmodhi4_ep>
    2260:	a6 1b       	sub	r26, r22
    2262:	b7 0b       	sbc	r27, r23

00002264 <__udivmodhi4_ep>:
    2264:	88 1f       	adc	r24, r24
    2266:	99 1f       	adc	r25, r25
    2268:	5a 95       	dec	r21
    226a:	a9 f7       	brne	.-22     	; 0x2256 <__udivmodhi4_loop>
    226c:	80 95       	com	r24
    226e:	90 95       	com	r25
    2270:	bc 01       	movw	r22, r24
    2272:	cd 01       	movw	r24, r26
    2274:	08 95       	ret

00002276 <memcpy>:
    2276:	fb 01       	movw	r30, r22
    2278:	dc 01       	movw	r26, r24
    227a:	02 c0       	rjmp	.+4      	; 0x2280 <memcpy+0xa>
    227c:	01 90       	ld	r0, Z+
    227e:	0d 92       	st	X+, r0
    2280:	41 50       	subi	r20, 0x01	; 1
    2282:	50 40       	sbci	r21, 0x00	; 0
    2284:	d8 f7       	brcc	.-10     	; 0x227c <memcpy+0x6>
    2286:	08 95       	ret

00002288 <__itoa_ncheck>:
    2288:	bb 27       	eor	r27, r27
    228a:	4a 30       	cpi	r20, 0x0A	; 10
    228c:	31 f4       	brne	.+12     	; 0x229a <__itoa_ncheck+0x12>
    228e:	99 23       	and	r25, r25
    2290:	22 f4       	brpl	.+8      	; 0x229a <__itoa_ncheck+0x12>
    2292:	bd e2       	ldi	r27, 0x2D	; 45
    2294:	90 95       	com	r25
    2296:	81 95       	neg	r24
    2298:	9f 4f       	sbci	r25, 0xFF	; 255
    229a:	01 c0       	rjmp	.+2      	; 0x229e <__utoa_common>

0000229c <__utoa_ncheck>:
    229c:	bb 27       	eor	r27, r27

0000229e <__utoa_common>:
    229e:	fb 01       	movw	r30, r22
    22a0:	55 27       	eor	r21, r21
    22a2:	aa 27       	eor	r26, r26
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	aa 1f       	adc	r26, r26
    22aa:	a4 17       	cp	r26, r20
    22ac:	10 f0       	brcs	.+4      	; 0x22b2 <__utoa_common+0x14>
    22ae:	a4 1b       	sub	r26, r20
    22b0:	83 95       	inc	r24
    22b2:	50 51       	subi	r21, 0x10	; 16
    22b4:	b9 f7       	brne	.-18     	; 0x22a4 <__utoa_common+0x6>
    22b6:	a0 5d       	subi	r26, 0xD0	; 208
    22b8:	aa 33       	cpi	r26, 0x3A	; 58
    22ba:	08 f0       	brcs	.+2      	; 0x22be <__utoa_common+0x20>
    22bc:	a9 5d       	subi	r26, 0xD9	; 217
    22be:	a1 93       	st	Z+, r26
    22c0:	00 97       	sbiw	r24, 0x00	; 0
    22c2:	79 f7       	brne	.-34     	; 0x22a2 <__utoa_common+0x4>
    22c4:	b1 11       	cpse	r27, r1
    22c6:	b1 93       	st	Z+, r27
    22c8:	11 92       	st	Z+, r1
    22ca:	cb 01       	movw	r24, r22
    22cc:	00 c0       	rjmp	.+0      	; 0x22ce <strrev>

000022ce <strrev>:
    22ce:	dc 01       	movw	r26, r24
    22d0:	fc 01       	movw	r30, r24
    22d2:	67 2f       	mov	r22, r23
    22d4:	71 91       	ld	r23, Z+
    22d6:	77 23       	and	r23, r23
    22d8:	e1 f7       	brne	.-8      	; 0x22d2 <strrev+0x4>
    22da:	32 97       	sbiw	r30, 0x02	; 2
    22dc:	04 c0       	rjmp	.+8      	; 0x22e6 <strrev+0x18>
    22de:	7c 91       	ld	r23, X
    22e0:	6d 93       	st	X+, r22
    22e2:	70 83       	st	Z, r23
    22e4:	62 91       	ld	r22, -Z
    22e6:	ae 17       	cp	r26, r30
    22e8:	bf 07       	cpc	r27, r31
    22ea:	c8 f3       	brcs	.-14     	; 0x22de <strrev+0x10>
    22ec:	08 95       	ret

000022ee <_exit>:
    22ee:	f8 94       	cli

000022f0 <__stop_program>:
    22f0:	ff cf       	rjmp	.-2      	; 0x22f0 <__stop_program>
