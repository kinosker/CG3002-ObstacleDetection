
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000060  00800200  00002b08  00002b9c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b08  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000703  00800260  00800260  00002bfc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002bfc  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004f8  00000000  00000000  00002c2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005833  00000000  00000000  00003124  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000155c  00000000  00000000  00008957  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000034ce  00000000  00000000  00009eb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000dd4  00000000  00000000  0000d384  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000015cf  00000000  00000000  0000e158  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003974  00000000  00000000  0000f727  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000498  00000000  00000000  0001309b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	46 c3       	rjmp	.+1676   	; 0x6b2 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 d9 08 	jmp	0x11b2	; 0x11b2 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	7e c5       	rjmp	.+2812   	; 0xb62 <__vector_25>
      66:	00 00       	nop
      68:	ea c5       	rjmp	.+3028   	; 0xc3e <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	cd c3       	rjmp	.+1946   	; 0x810 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	30 c5       	rjmp	.+2656   	; 0xaf2 <__vector_36>
      92:	00 00       	nop
      94:	9e c5       	rjmp	.+2876   	; 0xbd2 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <mySharpIR_Read+0x8>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e8 e0       	ldi	r30, 0x08	; 8
     17e:	fb e2       	ldi	r31, 0x2B	; 43
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a0 36       	cpi	r26, 0x60	; 96
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a0 e6       	ldi	r26, 0x60	; 96
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a3 36       	cpi	r26, 0x63	; 99
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	71 d1       	rcall	.+738    	; 0x484 <main>
     1a2:	0c 94 82 15 	jmp	0x2b04	; 0x2b04 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     1a8:	72 d6       	rcall	.+3300   	; 0xe8e <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	5e d6       	rcall	.+3260   	; 0xe6a <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	0d d6       	rcall	.+3098   	; 0xdce <myUSART_receiveUSART1>
     1b4:	4f d6       	rcall	.+3230   	; 0xe54 <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	63 d6       	rcall	.+3270   	; 0xe82 <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	29 f0       	breq	.+10     	; 0x1ca <RPI_receiveTask+0x22>
     1c0:	06 d6       	rcall	.+3084   	; 0xdce <myUSART_receiveUSART1>
     1c2:	86 e0       	ldi	r24, 0x06	; 6
     1c4:	92 e0       	ldi	r25, 0x02	; 2
     1c6:	f5 d5       	rcall	.+3050   	; 0xdb2 <myUSART_transmitUSART0>
     1c8:	ef cf       	rjmp	.-34     	; 0x1a8 <RPI_receiveTask>
     1ca:	8c 2f       	mov	r24, r28
     1cc:	54 d6       	rcall	.+3240   	; 0xe76 <myUSART_receiveHandShakeStart>
     1ce:	88 23       	and	r24, r24
     1d0:	11 f0       	breq	.+4      	; 0x1d6 <RPI_receiveTask+0x2e>
     1d2:	31 d6       	rcall	.+3170   	; 0xe36 <myUSART_waitForHandshake>
     1d4:	e9 cf       	rjmp	.-46     	; 0x1a8 <RPI_receiveTask>
     1d6:	fb d5       	rcall	.+3062   	; 0xdce <myUSART_receiveUSART1>
     1d8:	e7 cf       	rjmp	.-50     	; 0x1a8 <RPI_receiveTask>

000001da <RPI_sendTask>:
     1da:	cf 93       	push	r28
     1dc:	df 93       	push	r29
     1de:	00 d0       	rcall	.+0      	; 0x1e0 <RPI_sendTask+0x6>
     1e0:	00 d0       	rcall	.+0      	; 0x1e2 <RPI_sendTask+0x8>
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
     1e6:	80 e1       	ldi	r24, 0x10	; 16
     1e8:	92 e0       	ldi	r25, 0x02	; 2
     1ea:	e3 d5       	rcall	.+3014   	; 0xdb2 <myUSART_transmitUSART0>
     1ec:	11 d6       	rcall	.+3106   	; 0xe10 <myUSART_startHandShake>
     1ee:	86 e1       	ldi	r24, 0x16	; 22
     1f0:	92 e0       	ldi	r25, 0x02	; 2
     1f2:	df d5       	rcall	.+3006   	; 0xdb2 <myUSART_transmitUSART0>
     1f4:	20 e0       	ldi	r18, 0x00	; 0
     1f6:	4f ef       	ldi	r20, 0xFF	; 255
     1f8:	5f ef       	ldi	r21, 0xFF	; 255
     1fa:	be 01       	movw	r22, r28
     1fc:	6a 5f       	subi	r22, 0xFA	; 250
     1fe:	7f 4f       	sbci	r23, 0xFF	; 255
     200:	80 91 ab 08 	lds	r24, 0x08AB
     204:	90 91 ac 08 	lds	r25, 0x08AC
     208:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <xQueueGenericReceive>
     20c:	8e 81       	ldd	r24, Y+6	; 0x06
     20e:	80 5d       	subi	r24, 0xD0	; 208
     210:	ab d5       	rcall	.+2902   	; 0xd68 <myUSART_transmitUSART1_c>
     212:	8a e0       	ldi	r24, 0x0A	; 10
     214:	a9 d5       	rcall	.+2898   	; 0xd68 <myUSART_transmitUSART1_c>
     216:	8e 81       	ldd	r24, Y+6	; 0x06
     218:	9f ef       	ldi	r25, 0xFF	; 255
     21a:	98 0f       	add	r25, r24
     21c:	9e 83       	std	Y+6, r25	; 0x06
     21e:	88 23       	and	r24, r24
     220:	21 f1       	breq	.+72     	; 0x26a <RPI_sendTask+0x90>
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6f 5f       	subi	r22, 0xFF	; 255
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 ad 08 	lds	r24, 0x08AD
     232:	90 91 ae 08 	lds	r25, 0x08AE
     236:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <xQueueGenericReceive>
     23a:	89 81       	ldd	r24, Y+1	; 0x01
     23c:	7e d5       	rcall	.+2812   	; 0xd3a <myUSART_transmitUSART0_c>
     23e:	89 81       	ldd	r24, Y+1	; 0x01
     240:	93 d5       	rcall	.+2854   	; 0xd68 <myUSART_transmitUSART1_c>
     242:	8f e1       	ldi	r24, 0x1F	; 31
     244:	92 e0       	ldi	r25, 0x02	; 2
     246:	b5 d5       	rcall	.+2922   	; 0xdb2 <myUSART_transmitUSART0>
     248:	ce 01       	movw	r24, r28
     24a:	02 96       	adiw	r24, 0x02	; 2
     24c:	b2 d5       	rcall	.+2916   	; 0xdb2 <myUSART_transmitUSART0>
     24e:	ce 01       	movw	r24, r28
     250:	02 96       	adiw	r24, 0x02	; 2
     252:	a1 d5       	rcall	.+2882   	; 0xd96 <myUSART_transmitUSART1>
     254:	8a e0       	ldi	r24, 0x0A	; 10
     256:	88 d5       	rcall	.+2832   	; 0xd68 <myUSART_transmitUSART1_c>
     258:	82 e2       	ldi	r24, 0x22	; 34
     25a:	92 e0       	ldi	r25, 0x02	; 2
     25c:	aa d5       	rcall	.+2900   	; 0xdb2 <myUSART_transmitUSART0>
     25e:	8e 81       	ldd	r24, Y+6	; 0x06
     260:	9f ef       	ldi	r25, 0xFF	; 255
     262:	98 0f       	add	r25, r24
     264:	9e 83       	std	Y+6, r25	; 0x06
     266:	81 11       	cpse	r24, r1
     268:	dc cf       	rjmp	.-72     	; 0x222 <RPI_sendTask+0x48>
     26a:	8a e0       	ldi	r24, 0x0A	; 10
     26c:	66 d5       	rcall	.+2764   	; 0xd3a <myUSART_transmitUSART0_c>
     26e:	bb cf       	rjmp	.-138    	; 0x1e6 <RPI_sendTask+0xc>

00000270 <task1>:
     270:	26 9a       	sbi	0x04, 6	; 4
     272:	2e 9a       	sbi	0x05, 6	; 5
     274:	88 ee       	ldi	r24, 0xE8	; 232
     276:	93 e0       	ldi	r25, 0x03	; 3
     278:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <vTaskDelay>
     27c:	85 b1       	in	r24, 0x05	; 5
     27e:	15 b8       	out	0x05, r1	; 5
     280:	88 ee       	ldi	r24, 0xE8	; 232
     282:	93 e0       	ldi	r25, 0x03	; 3
     284:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <vTaskDelay>
     288:	f4 cf       	rjmp	.-24     	; 0x272 <task1+0x2>

0000028a <myTimerTask>:
     28a:	84 d3       	rcall	.+1800   	; 0x994 <myTimer_Init>
     28c:	c3 d3       	rcall	.+1926   	; 0xa14 <myTimer_DelayChecker>
     28e:	fe cf       	rjmp	.-4      	; 0x28c <myTimerTask+0x2>

00000290 <obstacleSend>:
     290:	1f 93       	push	r17
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	00 d0       	rcall	.+0      	; 0x298 <obstacleSend+0x8>
     298:	1f 92       	push	r1
     29a:	1f 92       	push	r1
     29c:	cd b7       	in	r28, 0x3d	; 61
     29e:	de b7       	in	r29, 0x3e	; 62
     2a0:	18 2f       	mov	r17, r24
     2a2:	cb 01       	movw	r24, r22
     2a4:	11 23       	and	r17, r17
     2a6:	99 f0       	breq	.+38     	; 0x2ce <obstacleSend+0x3e>
     2a8:	4a e0       	ldi	r20, 0x0A	; 10
     2aa:	be 01       	movw	r22, r28
     2ac:	6e 5f       	subi	r22, 0xFE	; 254
     2ae:	7f 4f       	sbci	r23, 0xFF	; 255
     2b0:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <__itoa_ncheck>
     2b4:	19 83       	std	Y+1, r17	; 0x01
     2b6:	20 e0       	ldi	r18, 0x00	; 0
     2b8:	4f ef       	ldi	r20, 0xFF	; 255
     2ba:	5f ef       	ldi	r21, 0xFF	; 255
     2bc:	be 01       	movw	r22, r28
     2be:	6f 5f       	subi	r22, 0xFF	; 255
     2c0:	7f 4f       	sbci	r23, 0xFF	; 255
     2c2:	80 91 ad 08 	lds	r24, 0x08AD
     2c6:	90 91 ae 08 	lds	r25, 0x08AE
     2ca:	0e 94 00 0a 	call	0x1400	; 0x1400 <xQueueGenericSend>
     2ce:	0f 90       	pop	r0
     2d0:	0f 90       	pop	r0
     2d2:	0f 90       	pop	r0
     2d4:	0f 90       	pop	r0
     2d6:	0f 90       	pop	r0
     2d8:	df 91       	pop	r29
     2da:	cf 91       	pop	r28
     2dc:	1f 91       	pop	r17
     2de:	08 95       	ret

000002e0 <Sonar_Task>:
     2e0:	cf 93       	push	r28
     2e2:	df 93       	push	r29
     2e4:	00 d0       	rcall	.+0      	; 0x2e6 <Sonar_Task+0x6>
     2e6:	cd b7       	in	r28, 0x3d	; 61
     2e8:	de b7       	in	r29, 0x3e	; 62
     2ea:	1b 82       	std	Y+3, r1	; 0x03
     2ec:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <xTaskGetTickCount>
     2f0:	9a 83       	std	Y+2, r25	; 0x02
     2f2:	89 83       	std	Y+1, r24	; 0x01
     2f4:	68 94       	set
     2f6:	88 24       	eor	r8, r8
     2f8:	81 f8       	bld	r8, 1
     2fa:	99 24       	eor	r9, r9
     2fc:	93 94       	inc	r9
     2fe:	78 d2       	rcall	.+1264   	; 0x7f0 <myMaxSonar_Start>
     300:	87 e2       	ldi	r24, 0x27	; 39
     302:	7c d2       	rcall	.+1272   	; 0x7fc <myMaxSonar_Read>
     304:	6c 01       	movw	r12, r24
     306:	86 e2       	ldi	r24, 0x26	; 38
     308:	79 d2       	rcall	.+1266   	; 0x7fc <myMaxSonar_Read>
     30a:	8c 01       	movw	r16, r24
     30c:	85 e2       	ldi	r24, 0x25	; 37
     30e:	76 d2       	rcall	.+1260   	; 0x7fc <myMaxSonar_Read>
     310:	7c 01       	movw	r14, r24
     312:	84 e2       	ldi	r24, 0x24	; 36
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	20 d3       	rcall	.+1600   	; 0x958 <mySharpIR_Read>
     318:	5c 01       	movw	r10, r24
     31a:	82 e3       	ldi	r24, 0x32	; 50
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <vTaskDelay>
     322:	86 e4       	ldi	r24, 0x46	; 70
     324:	c8 16       	cp	r12, r24
     326:	d1 04       	cpc	r13, r1
     328:	0c f5       	brge	.+66     	; 0x36c <Sonar_Task+0x8c>
     32a:	0d 32       	cpi	r16, 0x2D	; 45
     32c:	11 05       	cpc	r17, r1
     32e:	54 f4       	brge	.+20     	; 0x344 <Sonar_Task+0x64>
     330:	ed e2       	ldi	r30, 0x2D	; 45
     332:	ee 16       	cp	r14, r30
     334:	f1 04       	cpc	r15, r1
     336:	34 f4       	brge	.+12     	; 0x344 <Sonar_Task+0x64>
     338:	74 9a       	sbi	0x0e, 4	; 14
     33a:	f4 01       	movw	r30, r8
     33c:	80 81       	ld	r24, Z
     33e:	80 61       	ori	r24, 0x10	; 16
     340:	80 83       	st	Z, r24
     342:	33 c0       	rjmp	.+102    	; 0x3aa <Sonar_Task+0xca>
     344:	c8 01       	movw	r24, r16
     346:	0a 96       	adiw	r24, 0x0a	; 10
     348:	e8 16       	cp	r14, r24
     34a:	f9 06       	cpc	r15, r25
     34c:	34 f4       	brge	.+12     	; 0x35a <Sonar_Task+0x7a>
     34e:	f4 01       	movw	r30, r8
     350:	80 81       	ld	r24, Z
     352:	8f 7e       	andi	r24, 0xEF	; 239
     354:	80 83       	st	Z, r24
     356:	74 9a       	sbi	0x0e, 4	; 14
     358:	28 c0       	rjmp	.+80     	; 0x3aa <Sonar_Task+0xca>
     35a:	8e 15       	cp	r24, r14
     35c:	9f 05       	cpc	r25, r15
     35e:	2c f5       	brge	.+74     	; 0x3aa <Sonar_Task+0xca>
     360:	74 98       	cbi	0x0e, 4	; 14
     362:	f4 01       	movw	r30, r8
     364:	80 81       	ld	r24, Z
     366:	80 61       	ori	r24, 0x10	; 16
     368:	80 83       	st	Z, r24
     36a:	1f c0       	rjmp	.+62     	; 0x3aa <Sonar_Task+0xca>
     36c:	fe e1       	ldi	r31, 0x1E	; 30
     36e:	ef 16       	cp	r14, r31
     370:	f1 04       	cpc	r15, r1
     372:	4c f4       	brge	.+18     	; 0x386 <Sonar_Task+0xa6>
     374:	0f 31       	cpi	r16, 0x1F	; 31
     376:	11 05       	cpc	r17, r1
     378:	34 f0       	brlt	.+12     	; 0x386 <Sonar_Task+0xa6>
     37a:	f4 01       	movw	r30, r8
     37c:	80 81       	ld	r24, Z
     37e:	8f 7e       	andi	r24, 0xEF	; 239
     380:	80 83       	st	Z, r24
     382:	74 9a       	sbi	0x0e, 4	; 14
     384:	12 c0       	rjmp	.+36     	; 0x3aa <Sonar_Task+0xca>
     386:	0e 31       	cpi	r16, 0x1E	; 30
     388:	11 05       	cpc	r17, r1
     38a:	54 f4       	brge	.+20     	; 0x3a0 <Sonar_Task+0xc0>
     38c:	ff e1       	ldi	r31, 0x1F	; 31
     38e:	ef 16       	cp	r14, r31
     390:	f1 04       	cpc	r15, r1
     392:	34 f0       	brlt	.+12     	; 0x3a0 <Sonar_Task+0xc0>
     394:	f4 01       	movw	r30, r8
     396:	80 81       	ld	r24, Z
     398:	80 61       	ori	r24, 0x10	; 16
     39a:	80 83       	st	Z, r24
     39c:	74 98       	cbi	0x0e, 4	; 14
     39e:	05 c0       	rjmp	.+10     	; 0x3aa <Sonar_Task+0xca>
     3a0:	f4 01       	movw	r30, r8
     3a2:	80 81       	ld	r24, Z
     3a4:	8f 7e       	andi	r24, 0xEF	; 239
     3a6:	80 83       	st	Z, r24
     3a8:	74 98       	cbi	0x0e, 4	; 14
     3aa:	8b 81       	ldd	r24, Y+3	; 0x03
     3ac:	8c 5f       	subi	r24, 0xFC	; 252
     3ae:	8b 83       	std	Y+3, r24	; 0x03
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	4f ef       	ldi	r20, 0xFF	; 255
     3b4:	5f ef       	ldi	r21, 0xFF	; 255
     3b6:	be 01       	movw	r22, r28
     3b8:	6d 5f       	subi	r22, 0xFD	; 253
     3ba:	7f 4f       	sbci	r23, 0xFF	; 255
     3bc:	80 91 ab 08 	lds	r24, 0x08AB
     3c0:	90 91 ac 08 	lds	r25, 0x08AC
     3c4:	0e 94 00 0a 	call	0x1400	; 0x1400 <xQueueGenericSend>
     3c8:	b6 01       	movw	r22, r12
     3ca:	86 e4       	ldi	r24, 0x46	; 70
     3cc:	61 df       	rcall	.-318    	; 0x290 <obstacleSend>
     3ce:	b8 01       	movw	r22, r16
     3d0:	8c e4       	ldi	r24, 0x4C	; 76
     3d2:	5e df       	rcall	.-324    	; 0x290 <obstacleSend>
     3d4:	b7 01       	movw	r22, r14
     3d6:	82 e5       	ldi	r24, 0x52	; 82
     3d8:	5b df       	rcall	.-330    	; 0x290 <obstacleSend>
     3da:	b5 01       	movw	r22, r10
     3dc:	82 e4       	ldi	r24, 0x42	; 66
     3de:	58 df       	rcall	.-336    	; 0x290 <obstacleSend>
     3e0:	1b 82       	std	Y+3, r1	; 0x03
     3e2:	68 ec       	ldi	r22, 0xC8	; 200
     3e4:	70 e0       	ldi	r23, 0x00	; 0
     3e6:	ce 01       	movw	r24, r28
     3e8:	01 96       	adiw	r24, 0x01	; 1
     3ea:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <vTaskDelayUntil>
     3ee:	87 cf       	rjmp	.-242    	; 0x2fe <Sonar_Task+0x1e>

000003f0 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     3f0:	8c ec       	ldi	r24, 0xCC	; 204
     3f2:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     3f6:	8e e3       	ldi	r24, 0x3E	; 62
     3f8:	80 93 65 00 	sts	0x0065, r24
     3fc:	08 95       	ret

000003fe <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     3fe:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     402:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     406:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     40a:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     40e:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     412:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     416:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     41a:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     41e:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     422:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     426:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     42a:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     42e:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     432:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     436:	10 92 73 00 	sts	0x0073, r1
     43a:	08 95       	ret

0000043c <init>:
}

void init()
{
     43c:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     43e:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     440:	f8 94       	cli
	{
		clearTimer();
     442:	dd df       	rcall	.-70     	; 0x3fe <clearTimer>
		setPowerReduction();
     444:	d5 df       	rcall	.-86     	; 0x3f0 <setPowerReduction>
		myUSART_USART0_Init();
     446:	31 d4       	rcall	.+2146   	; 0xcaa <myUSART_USART0_Init>
		myUSART_USART1_Init();
     448:	50 d4       	rcall	.+2208   	; 0xcea <myUSART_USART1_Init>
		myADC_Init();
     44a:	1a d2       	rcall	.+1076   	; 0x880 <myADC_Init>
		MaxSonar_Init();
     44c:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     44e:	bb d1       	rcall	.+886    	; 0x7c6 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	61 e0       	ldi	r22, 0x01	; 1
     454:	85 e0       	ldi	r24, 0x05	; 5
     456:	aa d7       	rcall	.+3924   	; 0x13ac <xQueueGenericCreate>
     458:	90 93 ac 08 	sts	0x08AC, r25
     45c:	80 93 ab 08 	sts	0x08AB, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     460:	40 e0       	ldi	r20, 0x00	; 0
     462:	65 e0       	ldi	r22, 0x05	; 5
     464:	84 e1       	ldi	r24, 0x14	; 20
     466:	a2 d7       	rcall	.+3908   	; 0x13ac <xQueueGenericCreate>
     468:	90 93 ae 08 	sts	0x08AE, r25
     46c:	80 93 ad 08 	sts	0x08AD, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     470:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     472:	e1 e0       	ldi	r30, 0x01	; 1
     474:	f1 e0       	ldi	r31, 0x01	; 1
     476:	80 81       	ld	r24, Z
     478:	80 61       	ori	r24, 0x10	; 16
     47a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     47c:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     47e:	78 94       	sei
}
     480:	cf 91       	pop	r28
     482:	08 95       	ret

00000484 <main>:
	
	// do nth
}

int main(void)
{
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	cd b7       	in	r28, 0x3d	; 61
     48a:	de b7       	in	r29, 0x3e	; 62
     48c:	2a 97       	sbiw	r28, 0x0a	; 10
     48e:	0f b6       	in	r0, 0x3f	; 63
     490:	f8 94       	cli
     492:	de bf       	out	0x3e, r29	; 62
     494:	0f be       	out	0x3f, r0	; 63
     496:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     498:	d1 df       	rcall	.-94     	; 0x43c <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     49a:	a1 2c       	mov	r10, r1
     49c:	b1 2c       	mov	r11, r1
     49e:	c1 2c       	mov	r12, r1
     4a0:	d1 2c       	mov	r13, r1
     4a2:	ce 01       	movw	r24, r28
     4a4:	01 96       	adiw	r24, 0x01	; 1
     4a6:	7c 01       	movw	r14, r24
     4a8:	01 e0       	ldi	r16, 0x01	; 1
     4aa:	20 e0       	ldi	r18, 0x00	; 0
     4ac:	30 e0       	ldi	r19, 0x00	; 0
     4ae:	45 e5       	ldi	r20, 0x55	; 85
     4b0:	50 e0       	ldi	r21, 0x00	; 0
     4b2:	65 e2       	ldi	r22, 0x25	; 37
     4b4:	72 e0       	ldi	r23, 0x02	; 2
     4b6:	88 e3       	ldi	r24, 0x38	; 56
     4b8:	91 e0       	ldi	r25, 0x01	; 1
     4ba:	0e 94 47 0c 	call	0x188e	; 0x188e <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     4be:	ce 01       	movw	r24, r28
     4c0:	03 96       	adiw	r24, 0x03	; 3
     4c2:	7c 01       	movw	r14, r24
     4c4:	04 e0       	ldi	r16, 0x04	; 4
     4c6:	9c 01       	movw	r18, r24
     4c8:	49 e6       	ldi	r20, 0x69	; 105
     4ca:	50 e0       	ldi	r21, 0x00	; 0
     4cc:	6c e2       	ldi	r22, 0x2C	; 44
     4ce:	72 e0       	ldi	r23, 0x02	; 2
     4d0:	85 e4       	ldi	r24, 0x45	; 69
     4d2:	91 e0       	ldi	r25, 0x01	; 1
     4d4:	0e 94 47 0c 	call	0x188e	; 0x188e <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     4d8:	ce 01       	movw	r24, r28
     4da:	09 96       	adiw	r24, 0x09	; 9
     4dc:	7c 01       	movw	r14, r24
     4de:	02 e0       	ldi	r16, 0x02	; 2
     4e0:	20 e0       	ldi	r18, 0x00	; 0
     4e2:	30 e0       	ldi	r19, 0x00	; 0
     4e4:	4f e4       	ldi	r20, 0x4F	; 79
     4e6:	51 e0       	ldi	r21, 0x01	; 1
     4e8:	64 e3       	ldi	r22, 0x34	; 52
     4ea:	72 e0       	ldi	r23, 0x02	; 2
     4ec:	80 e7       	ldi	r24, 0x70	; 112
     4ee:	91 e0       	ldi	r25, 0x01	; 1
     4f0:	0e 94 47 0c 	call	0x188e	; 0x188e <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     4f4:	ce 01       	movw	r24, r28
     4f6:	07 96       	adiw	r24, 0x07	; 7
     4f8:	7c 01       	movw	r14, r24
     4fa:	03 e0       	ldi	r16, 0x03	; 3
     4fc:	20 e0       	ldi	r18, 0x00	; 0
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	47 e8       	ldi	r20, 0x87	; 135
     502:	50 e0       	ldi	r21, 0x00	; 0
     504:	6d e3       	ldi	r22, 0x3D	; 61
     506:	72 e0       	ldi	r23, 0x02	; 2
     508:	84 ed       	ldi	r24, 0xD4	; 212
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	0e 94 47 0c 	call	0x188e	; 0x188e <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     510:	ce 01       	movw	r24, r28
     512:	05 96       	adiw	r24, 0x05	; 5
     514:	7c 01       	movw	r14, r24
     516:	01 e0       	ldi	r16, 0x01	; 1
     518:	20 e0       	ldi	r18, 0x00	; 0
     51a:	30 e0       	ldi	r19, 0x00	; 0
     51c:	47 e8       	ldi	r20, 0x87	; 135
     51e:	50 e0       	ldi	r21, 0x00	; 0
     520:	69 e4       	ldi	r22, 0x49	; 73
     522:	72 e0       	ldi	r23, 0x02	; 2
     524:	8d ee       	ldi	r24, 0xED	; 237
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 47 0c 	call	0x188e	; 0x188e <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     52c:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <vTaskStartScheduler>
     530:	b3 cf       	rjmp	.-154    	; 0x498 <main+0x14>

00000532 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     532:	cf 93       	push	r28
     534:	df 93       	push	r29
     536:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     538:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     53c:	80 91 60 02 	lds	r24, 0x0260
     540:	90 91 61 02 	lds	r25, 0x0261
     544:	89 2b       	or	r24, r25
     546:	31 f4       	brne	.+12     	; 0x554 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     548:	85 e6       	ldi	r24, 0x65	; 101
     54a:	92 e0       	ldi	r25, 0x02	; 2
     54c:	90 93 61 02 	sts	0x0261, r25
     550:	80 93 60 02 	sts	0x0260, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     554:	40 91 62 02 	lds	r20, 0x0262
     558:	50 91 63 02 	lds	r21, 0x0263
     55c:	9e 01       	movw	r18, r28
     55e:	24 0f       	add	r18, r20
     560:	35 1f       	adc	r19, r21
     562:	2b 3d       	cpi	r18, 0xDB	; 219
     564:	85 e0       	ldi	r24, 0x05	; 5
     566:	38 07       	cpc	r19, r24
     568:	70 f4       	brcc	.+28     	; 0x586 <pvPortMalloc+0x54>
     56a:	42 17       	cp	r20, r18
     56c:	53 07       	cpc	r21, r19
     56e:	70 f4       	brcc	.+28     	; 0x58c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     570:	c0 91 60 02 	lds	r28, 0x0260
     574:	d0 91 61 02 	lds	r29, 0x0261
     578:	c4 0f       	add	r28, r20
     57a:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     57c:	30 93 63 02 	sts	0x0263, r19
     580:	20 93 62 02 	sts	0x0262, r18
     584:	05 c0       	rjmp	.+10     	; 0x590 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     586:	c0 e0       	ldi	r28, 0x00	; 0
     588:	d0 e0       	ldi	r29, 0x00	; 0
     58a:	02 c0       	rjmp	.+4      	; 0x590 <pvPortMalloc+0x5e>
     58c:	c0 e0       	ldi	r28, 0x00	; 0
     58e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     590:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     594:	ce 01       	movw	r24, r28
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	08 95       	ret

0000059c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     59c:	08 95       	ret

0000059e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     59e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5a0:	03 96       	adiw	r24, 0x03	; 3
     5a2:	92 83       	std	Z+2, r25	; 0x02
     5a4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5a6:	2f ef       	ldi	r18, 0xFF	; 255
     5a8:	3f ef       	ldi	r19, 0xFF	; 255
     5aa:	34 83       	std	Z+4, r19	; 0x04
     5ac:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ae:	96 83       	std	Z+6, r25	; 0x06
     5b0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5b2:	90 87       	std	Z+8, r25	; 0x08
     5b4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     5b6:	10 82       	st	Z, r1
     5b8:	08 95       	ret

000005ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     5ba:	fc 01       	movw	r30, r24
     5bc:	11 86       	std	Z+9, r1	; 0x09
     5be:	10 86       	std	Z+8, r1	; 0x08
     5c0:	08 95       	ret

000005c2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	9c 01       	movw	r18, r24
     5c8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     5ca:	dc 01       	movw	r26, r24
     5cc:	11 96       	adiw	r26, 0x01	; 1
     5ce:	cd 91       	ld	r28, X+
     5d0:	dc 91       	ld	r29, X
     5d2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5d4:	d3 83       	std	Z+3, r29	; 0x03
     5d6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5d8:	8c 81       	ldd	r24, Y+4	; 0x04
     5da:	9d 81       	ldd	r25, Y+5	; 0x05
     5dc:	95 83       	std	Z+5, r25	; 0x05
     5de:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5e0:	8c 81       	ldd	r24, Y+4	; 0x04
     5e2:	9d 81       	ldd	r25, Y+5	; 0x05
     5e4:	dc 01       	movw	r26, r24
     5e6:	13 96       	adiw	r26, 0x03	; 3
     5e8:	7c 93       	st	X, r23
     5ea:	6e 93       	st	-X, r22
     5ec:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     5ee:	7d 83       	std	Y+5, r23	; 0x05
     5f0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5f2:	31 87       	std	Z+9, r19	; 0x09
     5f4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     5f6:	f9 01       	movw	r30, r18
     5f8:	80 81       	ld	r24, Z
     5fa:	8f 5f       	subi	r24, 0xFF	; 255
     5fc:	80 83       	st	Z, r24
}
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     60a:	48 81       	ld	r20, Y
     60c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     60e:	4f 3f       	cpi	r20, 0xFF	; 255
     610:	2f ef       	ldi	r18, 0xFF	; 255
     612:	52 07       	cpc	r21, r18
     614:	21 f4       	brne	.+8      	; 0x61e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     616:	fc 01       	movw	r30, r24
     618:	a7 81       	ldd	r26, Z+7	; 0x07
     61a:	b0 85       	ldd	r27, Z+8	; 0x08
     61c:	0d c0       	rjmp	.+26     	; 0x638 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     61e:	dc 01       	movw	r26, r24
     620:	13 96       	adiw	r26, 0x03	; 3
     622:	12 96       	adiw	r26, 0x02	; 2
     624:	ed 91       	ld	r30, X+
     626:	fc 91       	ld	r31, X
     628:	13 97       	sbiw	r26, 0x03	; 3
     62a:	20 81       	ld	r18, Z
     62c:	31 81       	ldd	r19, Z+1	; 0x01
     62e:	42 17       	cp	r20, r18
     630:	53 07       	cpc	r21, r19
     632:	10 f0       	brcs	.+4      	; 0x638 <vListInsert+0x34>
     634:	df 01       	movw	r26, r30
     636:	f5 cf       	rjmp	.-22     	; 0x622 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     638:	12 96       	adiw	r26, 0x02	; 2
     63a:	ed 91       	ld	r30, X+
     63c:	fc 91       	ld	r31, X
     63e:	13 97       	sbiw	r26, 0x03	; 3
     640:	fb 83       	std	Y+3, r31	; 0x03
     642:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     644:	d5 83       	std	Z+5, r29	; 0x05
     646:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     648:	bd 83       	std	Y+5, r27	; 0x05
     64a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     64c:	13 96       	adiw	r26, 0x03	; 3
     64e:	dc 93       	st	X, r29
     650:	ce 93       	st	-X, r28
     652:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     654:	99 87       	std	Y+9, r25	; 0x09
     656:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     658:	fc 01       	movw	r30, r24
     65a:	20 81       	ld	r18, Z
     65c:	2f 5f       	subi	r18, 0xFF	; 255
     65e:	20 83       	st	Z, r18
}
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	08 95       	ret

00000666 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     66c:	a0 85       	ldd	r26, Z+8	; 0x08
     66e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     670:	c2 81       	ldd	r28, Z+2	; 0x02
     672:	d3 81       	ldd	r29, Z+3	; 0x03
     674:	84 81       	ldd	r24, Z+4	; 0x04
     676:	95 81       	ldd	r25, Z+5	; 0x05
     678:	9d 83       	std	Y+5, r25	; 0x05
     67a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     67c:	c4 81       	ldd	r28, Z+4	; 0x04
     67e:	d5 81       	ldd	r29, Z+5	; 0x05
     680:	82 81       	ldd	r24, Z+2	; 0x02
     682:	93 81       	ldd	r25, Z+3	; 0x03
     684:	9b 83       	std	Y+3, r25	; 0x03
     686:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     688:	11 96       	adiw	r26, 0x01	; 1
     68a:	cd 91       	ld	r28, X+
     68c:	dc 91       	ld	r29, X
     68e:	12 97       	sbiw	r26, 0x02	; 2
     690:	ce 17       	cp	r28, r30
     692:	df 07       	cpc	r29, r31
     694:	31 f4       	brne	.+12     	; 0x6a2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     696:	8c 81       	ldd	r24, Y+4	; 0x04
     698:	9d 81       	ldd	r25, Y+5	; 0x05
     69a:	12 96       	adiw	r26, 0x02	; 2
     69c:	9c 93       	st	X, r25
     69e:	8e 93       	st	-X, r24
     6a0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6a2:	11 86       	std	Z+9, r1	; 0x09
     6a4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6a6:	8c 91       	ld	r24, X
     6a8:	81 50       	subi	r24, 0x01	; 1
     6aa:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6ac:	df 91       	pop	r29
     6ae:	cf 91       	pop	r28
     6b0:	08 95       	ret

000006b2 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     6b2:	1f 92       	push	r1
     6b4:	0f 92       	push	r0
     6b6:	0f b6       	in	r0, 0x3f	; 63
     6b8:	0f 92       	push	r0
     6ba:	11 24       	eor	r1, r1
     6bc:	0b b6       	in	r0, 0x3b	; 59
     6be:	0f 92       	push	r0
     6c0:	2f 93       	push	r18
     6c2:	3f 93       	push	r19
     6c4:	4f 93       	push	r20
     6c6:	5f 93       	push	r21
     6c8:	6f 93       	push	r22
     6ca:	7f 93       	push	r23
     6cc:	8f 93       	push	r24
     6ce:	9f 93       	push	r25
     6d0:	af 93       	push	r26
     6d2:	bf 93       	push	r27
     6d4:	ef 93       	push	r30
     6d6:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     6d8:	1b 9b       	sbis	0x03, 3	; 3
     6da:	0d c0       	rjmp	.+26     	; 0x6f6 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     6dc:	75 d1       	rcall	.+746    	; 0x9c8 <myTimer_Read>
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	90 93 b4 08 	sts	0x08B4, r25
     6e4:	80 93 b3 08 	sts	0x08B3, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     6e8:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskGetTickCountFromISR>
     6ec:	90 93 b0 08 	sts	0x08B0, r25
     6f0:	80 93 af 08 	sts	0x08AF, r24
     6f4:	55 c0       	rjmp	.+170    	; 0x7a0 <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     6f6:	1b 99       	sbic	0x03, 3	; 3
     6f8:	53 c0       	rjmp	.+166    	; 0x7a0 <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     6fa:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <xTaskGetTickCountFromISR>
     6fe:	90 93 ba 08 	sts	0x08BA, r25
     702:	80 93 b9 08 	sts	0x08B9, r24
     706:	20 91 af 08 	lds	r18, 0x08AF
     70a:	30 91 b0 08 	lds	r19, 0x08B0
     70e:	82 17       	cp	r24, r18
     710:	93 07       	cpc	r25, r19
     712:	4c f4       	brge	.+18     	; 0x726 <__vector_9+0x74>
			ms_tickEnd += 65535;
     714:	80 91 b9 08 	lds	r24, 0x08B9
     718:	90 91 ba 08 	lds	r25, 0x08BA
     71c:	01 97       	sbiw	r24, 0x01	; 1
     71e:	90 93 ba 08 	sts	0x08BA, r25
     722:	80 93 b9 08 	sts	0x08B9, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     726:	50 d1       	rcall	.+672    	; 0x9c8 <myTimer_Read>
     728:	90 e0       	ldi	r25, 0x00	; 0
     72a:	90 93 bc 08 	sts	0x08BC, r25
     72e:	80 93 bb 08 	sts	0x08BB, r24
     732:	20 91 b3 08 	lds	r18, 0x08B3
     736:	30 91 b4 08 	lds	r19, 0x08B4
     73a:	82 17       	cp	r24, r18
     73c:	93 07       	cpc	r25, r19
     73e:	54 f4       	brge	.+20     	; 0x754 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     740:	80 91 bb 08 	lds	r24, 0x08BB
     744:	90 91 bc 08 	lds	r25, 0x08BC
     748:	86 50       	subi	r24, 0x06	; 6
     74a:	9f 4f       	sbci	r25, 0xFF	; 255
     74c:	90 93 bc 08 	sts	0x08BC, r25
     750:	80 93 bb 08 	sts	0x08BB, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     754:	80 91 bb 08 	lds	r24, 0x08BB
     758:	90 91 bc 08 	lds	r25, 0x08BC
     75c:	20 91 b3 08 	lds	r18, 0x08B3
     760:	30 91 b4 08 	lds	r19, 0x08B4
     764:	82 1b       	sub	r24, r18
     766:	93 0b       	sbc	r25, r19
     768:	90 93 b6 08 	sts	0x08B6, r25
     76c:	80 93 b5 08 	sts	0x08B5, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     770:	80 91 b9 08 	lds	r24, 0x08B9
     774:	90 91 ba 08 	lds	r25, 0x08BA
     778:	20 91 af 08 	lds	r18, 0x08AF
     77c:	30 91 b0 08 	lds	r19, 0x08B0
     780:	82 1b       	sub	r24, r18
     782:	93 0b       	sbc	r25, r19
     784:	90 93 b2 08 	sts	0x08B2, r25
     788:	80 93 b1 08 	sts	0x08B1, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     78c:	20 e0       	ldi	r18, 0x00	; 0
     78e:	40 e0       	ldi	r20, 0x00	; 0
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	60 e0       	ldi	r22, 0x00	; 0
     794:	70 e0       	ldi	r23, 0x00	; 0
     796:	80 91 b7 08 	lds	r24, 0x08B7
     79a:	90 91 b8 08 	lds	r25, 0x08B8
     79e:	eb d6       	rcall	.+3542   	; 0x1576 <xQueueGenericSendFromISR>
	}	
}
     7a0:	ff 91       	pop	r31
     7a2:	ef 91       	pop	r30
     7a4:	bf 91       	pop	r27
     7a6:	af 91       	pop	r26
     7a8:	9f 91       	pop	r25
     7aa:	8f 91       	pop	r24
     7ac:	7f 91       	pop	r23
     7ae:	6f 91       	pop	r22
     7b0:	5f 91       	pop	r21
     7b2:	4f 91       	pop	r20
     7b4:	3f 91       	pop	r19
     7b6:	2f 91       	pop	r18
     7b8:	0f 90       	pop	r0
     7ba:	0b be       	out	0x3b, r0	; 59
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	0f 90       	pop	r0
     7c2:	1f 90       	pop	r1
     7c4:	18 95       	reti

000007c6 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     7c6:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     7c8:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     7ca:	e8 e6       	ldi	r30, 0x68	; 104
     7cc:	f0 e0       	ldi	r31, 0x00	; 0
     7ce:	80 81       	ld	r24, Z
     7d0:	81 60       	ori	r24, 0x01	; 1
     7d2:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     7d4:	eb e6       	ldi	r30, 0x6B	; 107
     7d6:	f0 e0       	ldi	r31, 0x00	; 0
     7d8:	80 81       	ld	r24, Z
     7da:	88 60       	ori	r24, 0x08	; 8
     7dc:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     7de:	43 e0       	ldi	r20, 0x03	; 3
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	81 e0       	ldi	r24, 0x01	; 1
     7e4:	e3 d5       	rcall	.+3014   	; 0x13ac <xQueueGenericCreate>
     7e6:	90 93 b8 08 	sts	0x08B8, r25
     7ea:	80 93 b7 08 	sts	0x08B7, r24
     7ee:	08 95       	ret

000007f0 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     7f0:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     7f2:	89 e1       	ldi	r24, 0x19	; 25
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	ea d0       	rcall	.+468    	; 0x9cc <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     7f8:	a1 98       	cbi	0x14, 1	; 20
     7fa:	08 95       	ret

000007fc <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     7fc:	a6 d0       	rcall	.+332    	; 0x94a <myADC_analogRead>
     7fe:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     800:	63 e0       	ldi	r22, 0x03	; 3
     802:	70 e0       	ldi	r23, 0x00	; 0
     804:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     808:	cb 01       	movw	r24, r22
     80a:	82 0f       	add	r24, r18
     80c:	93 1f       	adc	r25, r19
     80e:	08 95       	ret

00000810 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     810:	1f 92       	push	r1
     812:	0f 92       	push	r0
     814:	0f b6       	in	r0, 0x3f	; 63
     816:	0f 92       	push	r0
     818:	11 24       	eor	r1, r1
     81a:	0b b6       	in	r0, 0x3b	; 59
     81c:	0f 92       	push	r0
     81e:	2f 93       	push	r18
     820:	3f 93       	push	r19
     822:	4f 93       	push	r20
     824:	5f 93       	push	r21
     826:	6f 93       	push	r22
     828:	7f 93       	push	r23
     82a:	8f 93       	push	r24
     82c:	9f 93       	push	r25
     82e:	af 93       	push	r26
     830:	bf 93       	push	r27
     832:	ef 93       	push	r30
     834:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     836:	80 91 78 00 	lds	r24, 0x0078
     83a:	80 93 bd 08 	sts	0x08BD, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     83e:	80 91 79 00 	lds	r24, 0x0079
     842:	80 93 be 08 	sts	0x08BE, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	60 e0       	ldi	r22, 0x00	; 0
     84e:	70 e0       	ldi	r23, 0x00	; 0
     850:	80 91 c1 08 	lds	r24, 0x08C1
     854:	90 91 c2 08 	lds	r25, 0x08C2
     858:	8e d6       	rcall	.+3356   	; 0x1576 <xQueueGenericSendFromISR>
}
     85a:	ff 91       	pop	r31
     85c:	ef 91       	pop	r30
     85e:	bf 91       	pop	r27
     860:	af 91       	pop	r26
     862:	9f 91       	pop	r25
     864:	8f 91       	pop	r24
     866:	7f 91       	pop	r23
     868:	6f 91       	pop	r22
     86a:	5f 91       	pop	r21
     86c:	4f 91       	pop	r20
     86e:	3f 91       	pop	r19
     870:	2f 91       	pop	r18
     872:	0f 90       	pop	r0
     874:	0b be       	out	0x3b, r0	; 59
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	0f 90       	pop	r0
     87c:	1f 90       	pop	r1
     87e:	18 95       	reti

00000880 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     880:	8f e8       	ldi	r24, 0x8F	; 143
     882:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     886:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     88a:	80 e4       	ldi	r24, 0x40	; 64
     88c:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     890:	43 e0       	ldi	r20, 0x03	; 3
     892:	60 e0       	ldi	r22, 0x00	; 0
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	8a d5       	rcall	.+2836   	; 0x13ac <xQueueGenericCreate>
     898:	90 93 c2 08 	sts	0x08C2, r25
     89c:	80 93 c1 08 	sts	0x08C1, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	41 d6       	rcall	.+3202   	; 0x1526 <xQueueCreateMutex>
     8a4:	90 93 c0 08 	sts	0x08C0, r25
     8a8:	80 93 bf 08 	sts	0x08BF, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     8ac:	20 e0       	ldi	r18, 0x00	; 0
     8ae:	40 e0       	ldi	r20, 0x00	; 0
     8b0:	50 e0       	ldi	r21, 0x00	; 0
     8b2:	60 e0       	ldi	r22, 0x00	; 0
     8b4:	70 e0       	ldi	r23, 0x00	; 0
     8b6:	a4 c5       	rjmp	.+2888   	; 0x1400 <xQueueGenericSend>
     8b8:	08 95       	ret

000008ba <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     8ba:	cf 93       	push	r28
     8bc:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     8be:	20 e0       	ldi	r18, 0x00	; 0
     8c0:	4f ef       	ldi	r20, 0xFF	; 255
     8c2:	5f ef       	ldi	r21, 0xFF	; 255
     8c4:	60 e0       	ldi	r22, 0x00	; 0
     8c6:	70 e0       	ldi	r23, 0x00	; 0
     8c8:	80 91 bf 08 	lds	r24, 0x08BF
     8cc:	90 91 c0 08 	lds	r25, 0x08C0
     8d0:	8c d6       	rcall	.+3352   	; 0x15ea <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     8d2:	ec e7       	ldi	r30, 0x7C	; 124
     8d4:	f0 e0       	ldi	r31, 0x00	; 0
     8d6:	80 81       	ld	r24, Z
     8d8:	9c 2f       	mov	r25, r28
     8da:	9f 71       	andi	r25, 0x1F	; 31
     8dc:	80 76       	andi	r24, 0x60	; 96
     8de:	89 2b       	or	r24, r25
     8e0:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     8e2:	eb e7       	ldi	r30, 0x7B	; 123
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	20 81       	ld	r18, Z
     8e8:	c0 72       	andi	r28, 0x20	; 32
     8ea:	8c 2f       	mov	r24, r28
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	95 95       	asr	r25
     8f0:	87 95       	ror	r24
     8f2:	95 95       	asr	r25
     8f4:	87 95       	ror	r24
     8f6:	92 2f       	mov	r25, r18
     8f8:	90 76       	andi	r25, 0x60	; 96
     8fa:	89 2b       	or	r24, r25
     8fc:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     8fe:	ea e7       	ldi	r30, 0x7A	; 122
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	80 81       	ld	r24, Z
     904:	80 64       	ori	r24, 0x40	; 64
     906:	80 83       	st	Z, r24
}
     908:	cf 91       	pop	r28
     90a:	08 95       	ret

0000090c <myADC_readADC>:

int myADC_readADC(char channel)
{
	int adcReading;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     90c:	20 e0       	ldi	r18, 0x00	; 0
     90e:	4f ef       	ldi	r20, 0xFF	; 255
     910:	5f ef       	ldi	r21, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 91 c1 08 	lds	r24, 0x08C1
     91a:	90 91 c2 08 	lds	r25, 0x08C2
     91e:	65 d6       	rcall	.+3274   	; 0x15ea <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     920:	20 e0       	ldi	r18, 0x00	; 0
     922:	40 e0       	ldi	r20, 0x00	; 0
     924:	50 e0       	ldi	r21, 0x00	; 0
     926:	60 e0       	ldi	r22, 0x00	; 0
     928:	70 e0       	ldi	r23, 0x00	; 0
     92a:	80 91 bf 08 	lds	r24, 0x08BF
     92e:	90 91 c0 08 	lds	r25, 0x08C0
     932:	66 d5       	rcall	.+2764   	; 0x1400 <xQueueGenericSend>

	adcReading = ((adcReading_H &0b11) << 8);
     934:	80 91 be 08 	lds	r24, 0x08BE
     938:	83 70       	andi	r24, 0x03	; 3
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	98 2f       	mov	r25, r24
     93e:	88 27       	eor	r24, r24
	adcReading += adcReading_L;
     940:	20 91 bd 08 	lds	r18, 0x08BD
	
	return adcReading;
     944:	82 0f       	add	r24, r18
     946:	91 1d       	adc	r25, r1
     948:	08 95       	ret

0000094a <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     94a:	cf 93       	push	r28
     94c:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     94e:	b5 df       	rcall	.-150    	; 0x8ba <myADC_startADC>
	return myADC_readADC(channel);
     950:	8c 2f       	mov	r24, r28
     952:	dc df       	rcall	.-72     	; 0x90c <myADC_readADC>
}
     954:	cf 91       	pop	r28
     956:	08 95       	ret

00000958 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     958:	f8 df       	rcall	.-16     	; 0x94a <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     95a:	bc 01       	movw	r22, r24
     95c:	88 27       	eor	r24, r24
     95e:	77 fd       	sbrc	r23, 7
     960:	80 95       	com	r24
     962:	98 2f       	mov	r25, r24
     964:	0e 94 63 12 	call	0x24c6	; 0x24c6 <__floatsisf>
     968:	29 e2       	ldi	r18, 0x29	; 41
     96a:	3c e5       	ldi	r19, 0x5C	; 92
     96c:	4f e6       	ldi	r20, 0x6F	; 111
     96e:	5f eb       	ldi	r21, 0xBF	; 191
     970:	0e 94 52 13 	call	0x26a4	; 0x26a4 <pow>
     974:	22 e5       	ldi	r18, 0x52	; 82
     976:	38 e6       	ldi	r19, 0x68	; 104
     978:	46 e2       	ldi	r20, 0x26	; 38
     97a:	56 e4       	ldi	r21, 0x46	; 70
     97c:	0e 94 ef 12 	call	0x25de	; 0x25de <__mulsf3>
     980:	20 e0       	ldi	r18, 0x00	; 0
     982:	30 e0       	ldi	r19, 0x00	; 0
     984:	40 e2       	ldi	r20, 0x20	; 32
     986:	51 e4       	ldi	r21, 0x41	; 65
     988:	0e 94 cb 11 	call	0x2396	; 0x2396 <__subsf3>
     98c:	0e 94 30 12 	call	0x2460	; 0x2460 <__fixsfsi>
	
	return adcReading;
     990:	cb 01       	movw	r24, r22
     992:	08 95       	ret

00000994 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     994:	90 93 c8 08 	sts	0x08C8, r25
     998:	80 93 c7 08 	sts	0x08C7, r24
     99c:	fc 01       	movw	r30, r24
     99e:	80 81       	ld	r24, Z
     9a0:	91 81       	ldd	r25, Z+1	; 0x01
     9a2:	0e 94 15 10 	call	0x202a	; 0x202a <vTaskSuspend>
     9a6:	43 e0       	ldi	r20, 0x03	; 3
     9a8:	60 e0       	ldi	r22, 0x00	; 0
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	ff d4       	rcall	.+2558   	; 0x13ac <xQueueGenericCreate>
     9ae:	90 93 c4 08 	sts	0x08C4, r25
     9b2:	80 93 c3 08 	sts	0x08C3, r24
     9b6:	43 e0       	ldi	r20, 0x03	; 3
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	f7 d4       	rcall	.+2542   	; 0x13ac <xQueueGenericCreate>
     9be:	90 93 c6 08 	sts	0x08C6, r25
     9c2:	80 93 c5 08 	sts	0x08C5, r24
     9c6:	08 95       	ret

000009c8 <myTimer_Read>:
     9c8:	86 b5       	in	r24, 0x26	; 38
     9ca:	08 95       	ret

000009cc <myTimer_DelayMicro>:
     9cc:	46 b5       	in	r20, 0x26	; 38
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	9c 01       	movw	r18, r24
     9d2:	99 23       	and	r25, r25
     9d4:	14 f4       	brge	.+4      	; 0x9da <myTimer_DelayMicro+0xe>
     9d6:	2d 5f       	subi	r18, 0xFD	; 253
     9d8:	3f 4f       	sbci	r19, 0xFF	; 255
     9da:	35 95       	asr	r19
     9dc:	27 95       	ror	r18
     9de:	35 95       	asr	r19
     9e0:	27 95       	ror	r18
     9e2:	24 0f       	add	r18, r20
     9e4:	35 1f       	adc	r19, r21
     9e6:	30 93 03 02 	sts	0x0203, r19
     9ea:	20 93 02 02 	sts	0x0202, r18
     9ee:	e0 91 c7 08 	lds	r30, 0x08C7
     9f2:	f0 91 c8 08 	lds	r31, 0x08C8
     9f6:	80 81       	ld	r24, Z
     9f8:	91 81       	ldd	r25, Z+1	; 0x01
     9fa:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vTaskResume>
     9fe:	20 e0       	ldi	r18, 0x00	; 0
     a00:	42 e0       	ldi	r20, 0x02	; 2
     a02:	50 e0       	ldi	r21, 0x00	; 0
     a04:	60 e0       	ldi	r22, 0x00	; 0
     a06:	70 e0       	ldi	r23, 0x00	; 0
     a08:	80 91 c3 08 	lds	r24, 0x08C3
     a0c:	90 91 c4 08 	lds	r25, 0x08C4
     a10:	ec c5       	rjmp	.+3032   	; 0x15ea <xQueueGenericReceive>
     a12:	08 95       	ret

00000a14 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     a14:	cf 93       	push	r28
     a16:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     a18:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     a1a:	c1 11       	cpse	r28, r1
     a1c:	22 c0       	rjmp	.+68     	; 0xa62 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     a1e:	80 91 02 02 	lds	r24, 0x0202
     a22:	90 91 03 02 	lds	r25, 0x0203
     a26:	88 38       	cpi	r24, 0x88	; 136
     a28:	93 41       	sbci	r25, 0x13	; 19
     a2a:	51 f0       	breq	.+20     	; 0xa40 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     a2c:	80 91 02 02 	lds	r24, 0x0202
     a30:	90 91 03 02 	lds	r25, 0x0203
     a34:	8a 5f       	subi	r24, 0xFA	; 250
     a36:	91 09       	sbc	r25, r1
     a38:	90 93 03 02 	sts	0x0203, r25
     a3c:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     a40:	80 91 00 02 	lds	r24, 0x0200
     a44:	90 91 01 02 	lds	r25, 0x0201
     a48:	88 38       	cpi	r24, 0x88	; 136
     a4a:	93 41       	sbci	r25, 0x13	; 19
     a4c:	51 f0       	breq	.+20     	; 0xa62 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     a4e:	80 91 00 02 	lds	r24, 0x0200
     a52:	90 91 01 02 	lds	r25, 0x0201
     a56:	8a 5f       	subi	r24, 0xFA	; 250
     a58:	91 09       	sbc	r25, r1
     a5a:	90 93 01 02 	sts	0x0201, r25
     a5e:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     a62:	d0 e0       	ldi	r29, 0x00	; 0
     a64:	80 91 02 02 	lds	r24, 0x0202
     a68:	90 91 03 02 	lds	r25, 0x0203
     a6c:	8c 17       	cp	r24, r28
     a6e:	9d 07       	cpc	r25, r29
     a70:	84 f4       	brge	.+32     	; 0xa92 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     a72:	88 e8       	ldi	r24, 0x88	; 136
     a74:	93 e1       	ldi	r25, 0x13	; 19
     a76:	90 93 03 02 	sts	0x0203, r25
     a7a:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     a7e:	20 e0       	ldi	r18, 0x00	; 0
     a80:	40 e0       	ldi	r20, 0x00	; 0
     a82:	50 e0       	ldi	r21, 0x00	; 0
     a84:	60 e0       	ldi	r22, 0x00	; 0
     a86:	70 e0       	ldi	r23, 0x00	; 0
     a88:	80 91 c3 08 	lds	r24, 0x08C3
     a8c:	90 91 c4 08 	lds	r25, 0x08C4
     a90:	b7 d4       	rcall	.+2414   	; 0x1400 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     a92:	80 91 00 02 	lds	r24, 0x0200
     a96:	90 91 01 02 	lds	r25, 0x0201
     a9a:	8c 17       	cp	r24, r28
     a9c:	9d 07       	cpc	r25, r29
     a9e:	84 f4       	brge	.+32     	; 0xac0 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     aa0:	88 e8       	ldi	r24, 0x88	; 136
     aa2:	93 e1       	ldi	r25, 0x13	; 19
     aa4:	90 93 01 02 	sts	0x0201, r25
     aa8:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     aac:	20 e0       	ldi	r18, 0x00	; 0
     aae:	40 e0       	ldi	r20, 0x00	; 0
     ab0:	50 e0       	ldi	r21, 0x00	; 0
     ab2:	60 e0       	ldi	r22, 0x00	; 0
     ab4:	70 e0       	ldi	r23, 0x00	; 0
     ab6:	80 91 c5 08 	lds	r24, 0x08C5
     aba:	90 91 c6 08 	lds	r25, 0x08C6
     abe:	a0 d4       	rcall	.+2368   	; 0x1400 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     ac0:	80 91 02 02 	lds	r24, 0x0202
     ac4:	90 91 03 02 	lds	r25, 0x0203
     ac8:	88 38       	cpi	r24, 0x88	; 136
     aca:	93 41       	sbci	r25, 0x13	; 19
     acc:	79 f4       	brne	.+30     	; 0xaec <myTimer_DelayChecker+0xd8>
     ace:	80 91 00 02 	lds	r24, 0x0200
     ad2:	90 91 01 02 	lds	r25, 0x0201
     ad6:	88 38       	cpi	r24, 0x88	; 136
     ad8:	93 41       	sbci	r25, 0x13	; 19
     ada:	41 f4       	brne	.+16     	; 0xaec <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     adc:	e0 91 c7 08 	lds	r30, 0x08C7
     ae0:	f0 91 c8 08 	lds	r31, 0x08C8
     ae4:	80 81       	ld	r24, Z
     ae6:	91 81       	ldd	r25, Z+1	; 0x01
     ae8:	0e 94 15 10 	call	0x202a	; 0x202a <vTaskSuspend>
	}
     aec:	df 91       	pop	r29
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     af2:	1f 92       	push	r1
     af4:	0f 92       	push	r0
     af6:	0f b6       	in	r0, 0x3f	; 63
     af8:	0f 92       	push	r0
     afa:	11 24       	eor	r1, r1
     afc:	0b b6       	in	r0, 0x3b	; 59
     afe:	0f 92       	push	r0
     b00:	2f 93       	push	r18
     b02:	3f 93       	push	r19
     b04:	4f 93       	push	r20
     b06:	5f 93       	push	r21
     b08:	6f 93       	push	r22
     b0a:	7f 93       	push	r23
     b0c:	8f 93       	push	r24
     b0e:	9f 93       	push	r25
     b10:	af 93       	push	r26
     b12:	bf 93       	push	r27
     b14:	ef 93       	push	r30
     b16:	ff 93       	push	r31
     b18:	60 91 ce 00 	lds	r22, 0x00CE
     b1c:	8e e5       	ldi	r24, 0x5E	; 94
     b1e:	99 e0       	ldi	r25, 0x09	; 9
     b20:	3a d6       	rcall	.+3188   	; 0x1796 <ringBufferPush>
     b22:	20 e0       	ldi	r18, 0x00	; 0
     b24:	40 e0       	ldi	r20, 0x00	; 0
     b26:	50 e0       	ldi	r21, 0x00	; 0
     b28:	60 e0       	ldi	r22, 0x00	; 0
     b2a:	70 e0       	ldi	r23, 0x00	; 0
     b2c:	80 91 52 09 	lds	r24, 0x0952
     b30:	90 91 53 09 	lds	r25, 0x0953
     b34:	20 d5       	rcall	.+2624   	; 0x1576 <xQueueGenericSendFromISR>
     b36:	8e e5       	ldi	r24, 0x5E	; 94
     b38:	99 e0       	ldi	r25, 0x09	; 9
     b3a:	44 d6       	rcall	.+3208   	; 0x17c4 <ringBufferFull>
     b3c:	ff 91       	pop	r31
     b3e:	ef 91       	pop	r30
     b40:	bf 91       	pop	r27
     b42:	af 91       	pop	r26
     b44:	9f 91       	pop	r25
     b46:	8f 91       	pop	r24
     b48:	7f 91       	pop	r23
     b4a:	6f 91       	pop	r22
     b4c:	5f 91       	pop	r21
     b4e:	4f 91       	pop	r20
     b50:	3f 91       	pop	r19
     b52:	2f 91       	pop	r18
     b54:	0f 90       	pop	r0
     b56:	0b be       	out	0x3b, r0	; 59
     b58:	0f 90       	pop	r0
     b5a:	0f be       	out	0x3f, r0	; 63
     b5c:	0f 90       	pop	r0
     b5e:	1f 90       	pop	r1
     b60:	18 95       	reti

00000b62 <__vector_25>:
     b62:	1f 92       	push	r1
     b64:	0f 92       	push	r0
     b66:	0f b6       	in	r0, 0x3f	; 63
     b68:	0f 92       	push	r0
     b6a:	11 24       	eor	r1, r1
     b6c:	0b b6       	in	r0, 0x3b	; 59
     b6e:	0f 92       	push	r0
     b70:	2f 93       	push	r18
     b72:	3f 93       	push	r19
     b74:	4f 93       	push	r20
     b76:	5f 93       	push	r21
     b78:	6f 93       	push	r22
     b7a:	7f 93       	push	r23
     b7c:	8f 93       	push	r24
     b7e:	9f 93       	push	r25
     b80:	af 93       	push	r26
     b82:	bf 93       	push	r27
     b84:	ef 93       	push	r30
     b86:	ff 93       	push	r31
     b88:	60 91 c6 00 	lds	r22, 0x00C6
     b8c:	89 ee       	ldi	r24, 0xE9	; 233
     b8e:	98 e0       	ldi	r25, 0x08	; 8
     b90:	02 d6       	rcall	.+3076   	; 0x1796 <ringBufferPush>
     b92:	20 e0       	ldi	r18, 0x00	; 0
     b94:	40 e0       	ldi	r20, 0x00	; 0
     b96:	50 e0       	ldi	r21, 0x00	; 0
     b98:	60 e0       	ldi	r22, 0x00	; 0
     b9a:	70 e0       	ldi	r23, 0x00	; 0
     b9c:	80 91 52 09 	lds	r24, 0x0952
     ba0:	90 91 53 09 	lds	r25, 0x0953
     ba4:	e8 d4       	rcall	.+2512   	; 0x1576 <xQueueGenericSendFromISR>
     ba6:	89 ee       	ldi	r24, 0xE9	; 233
     ba8:	98 e0       	ldi	r25, 0x08	; 8
     baa:	0c d6       	rcall	.+3096   	; 0x17c4 <ringBufferFull>
     bac:	ff 91       	pop	r31
     bae:	ef 91       	pop	r30
     bb0:	bf 91       	pop	r27
     bb2:	af 91       	pop	r26
     bb4:	9f 91       	pop	r25
     bb6:	8f 91       	pop	r24
     bb8:	7f 91       	pop	r23
     bba:	6f 91       	pop	r22
     bbc:	5f 91       	pop	r21
     bbe:	4f 91       	pop	r20
     bc0:	3f 91       	pop	r19
     bc2:	2f 91       	pop	r18
     bc4:	0f 90       	pop	r0
     bc6:	0b be       	out	0x3b, r0	; 59
     bc8:	0f 90       	pop	r0
     bca:	0f be       	out	0x3f, r0	; 63
     bcc:	0f 90       	pop	r0
     bce:	1f 90       	pop	r1
     bd0:	18 95       	reti

00000bd2 <__vector_37>:
     bd2:	1f 92       	push	r1
     bd4:	0f 92       	push	r0
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	0f 92       	push	r0
     bda:	11 24       	eor	r1, r1
     bdc:	0b b6       	in	r0, 0x3b	; 59
     bde:	0f 92       	push	r0
     be0:	2f 93       	push	r18
     be2:	3f 93       	push	r19
     be4:	4f 93       	push	r20
     be6:	5f 93       	push	r21
     be8:	6f 93       	push	r22
     bea:	7f 93       	push	r23
     bec:	8f 93       	push	r24
     bee:	9f 93       	push	r25
     bf0:	af 93       	push	r26
     bf2:	bf 93       	push	r27
     bf4:	ef 93       	push	r30
     bf6:	ff 93       	push	r31
     bf8:	84 e5       	ldi	r24, 0x54	; 84
     bfa:	99 e0       	ldi	r25, 0x09	; 9
     bfc:	ea d5       	rcall	.+3028   	; 0x17d2 <ringBufferNotEmpty>
     bfe:	88 23       	and	r24, r24
     c00:	31 f0       	breq	.+12     	; 0xc0e <__vector_37+0x3c>
     c02:	84 e5       	ldi	r24, 0x54	; 84
     c04:	99 e0       	ldi	r25, 0x09	; 9
     c06:	b5 d5       	rcall	.+2922   	; 0x1772 <ringBufferPop>
     c08:	80 93 ce 00 	sts	0x00CE, r24
     c0c:	05 c0       	rjmp	.+10     	; 0xc18 <__vector_37+0x46>
     c0e:	e9 ec       	ldi	r30, 0xC9	; 201
     c10:	f0 e0       	ldi	r31, 0x00	; 0
     c12:	80 81       	ld	r24, Z
     c14:	8f 7d       	andi	r24, 0xDF	; 223
     c16:	80 83       	st	Z, r24
     c18:	ff 91       	pop	r31
     c1a:	ef 91       	pop	r30
     c1c:	bf 91       	pop	r27
     c1e:	af 91       	pop	r26
     c20:	9f 91       	pop	r25
     c22:	8f 91       	pop	r24
     c24:	7f 91       	pop	r23
     c26:	6f 91       	pop	r22
     c28:	5f 91       	pop	r21
     c2a:	4f 91       	pop	r20
     c2c:	3f 91       	pop	r19
     c2e:	2f 91       	pop	r18
     c30:	0f 90       	pop	r0
     c32:	0b be       	out	0x3b, r0	; 59
     c34:	0f 90       	pop	r0
     c36:	0f be       	out	0x3f, r0	; 63
     c38:	0f 90       	pop	r0
     c3a:	1f 90       	pop	r1
     c3c:	18 95       	reti

00000c3e <__vector_26>:
     c3e:	1f 92       	push	r1
     c40:	0f 92       	push	r0
     c42:	0f b6       	in	r0, 0x3f	; 63
     c44:	0f 92       	push	r0
     c46:	11 24       	eor	r1, r1
     c48:	0b b6       	in	r0, 0x3b	; 59
     c4a:	0f 92       	push	r0
     c4c:	2f 93       	push	r18
     c4e:	3f 93       	push	r19
     c50:	4f 93       	push	r20
     c52:	5f 93       	push	r21
     c54:	6f 93       	push	r22
     c56:	7f 93       	push	r23
     c58:	8f 93       	push	r24
     c5a:	9f 93       	push	r25
     c5c:	af 93       	push	r26
     c5e:	bf 93       	push	r27
     c60:	ef 93       	push	r30
     c62:	ff 93       	push	r31
     c64:	89 e5       	ldi	r24, 0x59	; 89
     c66:	99 e0       	ldi	r25, 0x09	; 9
     c68:	b4 d5       	rcall	.+2920   	; 0x17d2 <ringBufferNotEmpty>
     c6a:	88 23       	and	r24, r24
     c6c:	31 f0       	breq	.+12     	; 0xc7a <__vector_26+0x3c>
     c6e:	89 e5       	ldi	r24, 0x59	; 89
     c70:	99 e0       	ldi	r25, 0x09	; 9
     c72:	7f d5       	rcall	.+2814   	; 0x1772 <ringBufferPop>
     c74:	80 93 c6 00 	sts	0x00C6, r24
     c78:	05 c0       	rjmp	.+10     	; 0xc84 <__vector_26+0x46>
     c7a:	e1 ec       	ldi	r30, 0xC1	; 193
     c7c:	f0 e0       	ldi	r31, 0x00	; 0
     c7e:	80 81       	ld	r24, Z
     c80:	8f 7d       	andi	r24, 0xDF	; 223
     c82:	80 83       	st	Z, r24
     c84:	ff 91       	pop	r31
     c86:	ef 91       	pop	r30
     c88:	bf 91       	pop	r27
     c8a:	af 91       	pop	r26
     c8c:	9f 91       	pop	r25
     c8e:	8f 91       	pop	r24
     c90:	7f 91       	pop	r23
     c92:	6f 91       	pop	r22
     c94:	5f 91       	pop	r21
     c96:	4f 91       	pop	r20
     c98:	3f 91       	pop	r19
     c9a:	2f 91       	pop	r18
     c9c:	0f 90       	pop	r0
     c9e:	0b be       	out	0x3b, r0	; 59
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
     ca4:	0f 90       	pop	r0
     ca6:	1f 90       	pop	r1
     ca8:	18 95       	reti

00000caa <myUSART_USART0_Init>:
     caa:	10 92 c5 00 	sts	0x00C5, r1
     cae:	87 e6       	ldi	r24, 0x67	; 103
     cb0:	80 93 c4 00 	sts	0x00C4, r24
     cb4:	88 eb       	ldi	r24, 0xB8	; 184
     cb6:	80 93 c1 00 	sts	0x00C1, r24
     cba:	86 e0       	ldi	r24, 0x06	; 6
     cbc:	80 93 c2 00 	sts	0x00C2, r24
     cc0:	40 e2       	ldi	r20, 0x20	; 32
     cc2:	60 e1       	ldi	r22, 0x10	; 16
     cc4:	79 e0       	ldi	r23, 0x09	; 9
     cc6:	89 ee       	ldi	r24, 0xE9	; 233
     cc8:	98 e0       	ldi	r25, 0x08	; 8
     cca:	42 d5       	rcall	.+2692   	; 0x1750 <ringBufferInit>
     ccc:	40 e2       	ldi	r20, 0x20	; 32
     cce:	6e ee       	ldi	r22, 0xEE	; 238
     cd0:	78 e0       	ldi	r23, 0x08	; 8
     cd2:	89 e5       	ldi	r24, 0x59	; 89
     cd4:	99 e0       	ldi	r25, 0x09	; 9
     cd6:	3c d5       	rcall	.+2680   	; 0x1750 <ringBufferInit>
     cd8:	43 e0       	ldi	r20, 0x03	; 3
     cda:	60 e0       	ldi	r22, 0x00	; 0
     cdc:	81 e0       	ldi	r24, 0x01	; 1
     cde:	66 d3       	rcall	.+1740   	; 0x13ac <xQueueGenericCreate>
     ce0:	90 93 51 09 	sts	0x0951, r25
     ce4:	80 93 50 09 	sts	0x0950, r24
     ce8:	08 95       	ret

00000cea <myUSART_USART1_Init>:
     cea:	10 92 cd 00 	sts	0x00CD, r1
     cee:	87 e6       	ldi	r24, 0x67	; 103
     cf0:	80 93 cc 00 	sts	0x00CC, r24
     cf4:	88 eb       	ldi	r24, 0xB8	; 184
     cf6:	80 93 c9 00 	sts	0x00C9, r24
     cfa:	86 e0       	ldi	r24, 0x06	; 6
     cfc:	80 93 ca 00 	sts	0x00CA, r24
     d00:	40 e2       	ldi	r20, 0x20	; 32
     d02:	69 ec       	ldi	r22, 0xC9	; 201
     d04:	78 e0       	ldi	r23, 0x08	; 8
     d06:	8e e5       	ldi	r24, 0x5E	; 94
     d08:	99 e0       	ldi	r25, 0x09	; 9
     d0a:	22 d5       	rcall	.+2628   	; 0x1750 <ringBufferInit>
     d0c:	40 e2       	ldi	r20, 0x20	; 32
     d0e:	60 e3       	ldi	r22, 0x30	; 48
     d10:	79 e0       	ldi	r23, 0x09	; 9
     d12:	84 e5       	ldi	r24, 0x54	; 84
     d14:	99 e0       	ldi	r25, 0x09	; 9
     d16:	1c d5       	rcall	.+2616   	; 0x1750 <ringBufferInit>
     d18:	43 e0       	ldi	r20, 0x03	; 3
     d1a:	60 e0       	ldi	r22, 0x00	; 0
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	46 d3       	rcall	.+1676   	; 0x13ac <xQueueGenericCreate>
     d20:	90 93 53 09 	sts	0x0953, r25
     d24:	80 93 52 09 	sts	0x0952, r24
     d28:	43 e0       	ldi	r20, 0x03	; 3
     d2a:	60 e0       	ldi	r22, 0x00	; 0
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	3e d3       	rcall	.+1660   	; 0x13ac <xQueueGenericCreate>
     d30:	90 93 0f 09 	sts	0x090F, r25
     d34:	80 93 0e 09 	sts	0x090E, r24
     d38:	08 95       	ret

00000d3a <myUSART_transmitUSART0_c>:
     d3a:	cf 93       	push	r28
     d3c:	c8 2f       	mov	r28, r24
     d3e:	89 e5       	ldi	r24, 0x59	; 89
     d40:	99 e0       	ldi	r25, 0x09	; 9
     d42:	40 d5       	rcall	.+2688   	; 0x17c4 <ringBufferFull>
     d44:	81 11       	cpse	r24, r1
     d46:	fb cf       	rjmp	.-10     	; 0xd3e <myUSART_transmitUSART0_c+0x4>
     d48:	6c 2f       	mov	r22, r28
     d4a:	89 e5       	ldi	r24, 0x59	; 89
     d4c:	99 e0       	ldi	r25, 0x09	; 9
     d4e:	23 d5       	rcall	.+2630   	; 0x1796 <ringBufferPush>
     d50:	e1 ec       	ldi	r30, 0xC1	; 193
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	80 81       	ld	r24, Z
     d56:	80 62       	ori	r24, 0x20	; 32
     d58:	80 83       	st	Z, r24
     d5a:	e0 ec       	ldi	r30, 0xC0	; 192
     d5c:	f0 e0       	ldi	r31, 0x00	; 0
     d5e:	80 81       	ld	r24, Z
     d60:	80 64       	ori	r24, 0x40	; 64
     d62:	80 83       	st	Z, r24
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <myUSART_transmitUSART1_c>:
     d68:	cf 93       	push	r28
     d6a:	c8 2f       	mov	r28, r24
     d6c:	84 e5       	ldi	r24, 0x54	; 84
     d6e:	99 e0       	ldi	r25, 0x09	; 9
     d70:	29 d5       	rcall	.+2642   	; 0x17c4 <ringBufferFull>
     d72:	81 11       	cpse	r24, r1
     d74:	fb cf       	rjmp	.-10     	; 0xd6c <myUSART_transmitUSART1_c+0x4>
     d76:	6c 2f       	mov	r22, r28
     d78:	84 e5       	ldi	r24, 0x54	; 84
     d7a:	99 e0       	ldi	r25, 0x09	; 9
     d7c:	0c d5       	rcall	.+2584   	; 0x1796 <ringBufferPush>
     d7e:	e9 ec       	ldi	r30, 0xC9	; 201
     d80:	f0 e0       	ldi	r31, 0x00	; 0
     d82:	80 81       	ld	r24, Z
     d84:	80 62       	ori	r24, 0x20	; 32
     d86:	80 83       	st	Z, r24
     d88:	e8 ec       	ldi	r30, 0xC8	; 200
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	80 81       	ld	r24, Z
     d8e:	80 64       	ori	r24, 0x40	; 64
     d90:	80 83       	st	Z, r24
     d92:	cf 91       	pop	r28
     d94:	08 95       	ret

00000d96 <myUSART_transmitUSART1>:
     d96:	cf 93       	push	r28
     d98:	df 93       	push	r29
     d9a:	ec 01       	movw	r28, r24
     d9c:	88 81       	ld	r24, Y
     d9e:	88 23       	and	r24, r24
     da0:	29 f0       	breq	.+10     	; 0xdac <myUSART_transmitUSART1+0x16>
     da2:	21 96       	adiw	r28, 0x01	; 1
     da4:	e1 df       	rcall	.-62     	; 0xd68 <myUSART_transmitUSART1_c>
     da6:	89 91       	ld	r24, Y+
     da8:	81 11       	cpse	r24, r1
     daa:	fc cf       	rjmp	.-8      	; 0xda4 <myUSART_transmitUSART1+0xe>
     dac:	df 91       	pop	r29
     dae:	cf 91       	pop	r28
     db0:	08 95       	ret

00000db2 <myUSART_transmitUSART0>:
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	ec 01       	movw	r28, r24
     db8:	88 81       	ld	r24, Y
     dba:	88 23       	and	r24, r24
     dbc:	29 f0       	breq	.+10     	; 0xdc8 <myUSART_transmitUSART0+0x16>
     dbe:	21 96       	adiw	r28, 0x01	; 1
     dc0:	bc df       	rcall	.-136    	; 0xd3a <myUSART_transmitUSART0_c>
     dc2:	89 91       	ld	r24, Y+
     dc4:	81 11       	cpse	r24, r1
     dc6:	fc cf       	rjmp	.-8      	; 0xdc0 <myUSART_transmitUSART0+0xe>
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	08 95       	ret

00000dce <myUSART_receiveUSART1>:
     dce:	cf 93       	push	r28
     dd0:	20 e0       	ldi	r18, 0x00	; 0
     dd2:	4f ef       	ldi	r20, 0xFF	; 255
     dd4:	5f ef       	ldi	r21, 0xFF	; 255
     dd6:	60 e0       	ldi	r22, 0x00	; 0
     dd8:	70 e0       	ldi	r23, 0x00	; 0
     dda:	80 91 52 09 	lds	r24, 0x0952
     dde:	90 91 53 09 	lds	r25, 0x0953
     de2:	03 d4       	rcall	.+2054   	; 0x15ea <xQueueGenericReceive>
     de4:	8e e5       	ldi	r24, 0x5E	; 94
     de6:	99 e0       	ldi	r25, 0x09	; 9
     de8:	c4 d4       	rcall	.+2440   	; 0x1772 <ringBufferPop>
     dea:	c8 2f       	mov	r28, r24
     dec:	8e e5       	ldi	r24, 0x5E	; 94
     dee:	99 e0       	ldi	r25, 0x09	; 9
     df0:	f0 d4       	rcall	.+2528   	; 0x17d2 <ringBufferNotEmpty>
     df2:	88 23       	and	r24, r24
     df4:	51 f0       	breq	.+20     	; 0xe0a <myUSART_receiveUSART1+0x3c>
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	50 e0       	ldi	r21, 0x00	; 0
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	70 e0       	ldi	r23, 0x00	; 0
     e00:	80 91 52 09 	lds	r24, 0x0952
     e04:	90 91 53 09 	lds	r25, 0x0953
     e08:	fb d2       	rcall	.+1526   	; 0x1400 <xQueueGenericSend>
     e0a:	8c 2f       	mov	r24, r28
     e0c:	cf 91       	pop	r28
     e0e:	08 95       	ret

00000e10 <myUSART_startHandShake>:
     e10:	86 e1       	ldi	r24, 0x16	; 22
     e12:	aa df       	rcall	.-172    	; 0xd68 <myUSART_transmitUSART1_c>
     e14:	20 e0       	ldi	r18, 0x00	; 0
     e16:	4f ef       	ldi	r20, 0xFF	; 255
     e18:	5f ef       	ldi	r21, 0xFF	; 255
     e1a:	60 e0       	ldi	r22, 0x00	; 0
     e1c:	70 e0       	ldi	r23, 0x00	; 0
     e1e:	80 91 0e 09 	lds	r24, 0x090E
     e22:	90 91 0f 09 	lds	r25, 0x090F
     e26:	e1 d3       	rcall	.+1986   	; 0x15ea <xQueueGenericReceive>
     e28:	82 e5       	ldi	r24, 0x52	; 82
     e2a:	92 e0       	ldi	r25, 0x02	; 2
     e2c:	c2 df       	rcall	.-124    	; 0xdb2 <myUSART_transmitUSART0>
     e2e:	82 e0       	ldi	r24, 0x02	; 2
     e30:	9b df       	rcall	.-202    	; 0xd68 <myUSART_transmitUSART1_c>
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	08 95       	ret

00000e36 <myUSART_waitForHandshake>:
     e36:	cb df       	rcall	.-106    	; 0xdce <myUSART_receiveUSART1>
     e38:	86 31       	cpi	r24, 0x16	; 22
     e3a:	51 f4       	brne	.+20     	; 0xe50 <myUSART_waitForHandshake+0x1a>
     e3c:	85 e0       	ldi	r24, 0x05	; 5
     e3e:	94 df       	rcall	.-216    	; 0xd68 <myUSART_transmitUSART1_c>
     e40:	c6 df       	rcall	.-116    	; 0xdce <myUSART_receiveUSART1>
     e42:	91 e0       	ldi	r25, 0x01	; 1
     e44:	86 31       	cpi	r24, 0x16	; 22
     e46:	09 f4       	brne	.+2      	; 0xe4a <myUSART_waitForHandshake+0x14>
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	89 2f       	mov	r24, r25
     e4c:	81 95       	neg	r24
     e4e:	08 95       	ret
     e50:	8f ef       	ldi	r24, 0xFF	; 255
     e52:	08 95       	ret

00000e54 <myUSART_completeHandShake>:
     e54:	20 e0       	ldi	r18, 0x00	; 0
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	60 e0       	ldi	r22, 0x00	; 0
     e5c:	70 e0       	ldi	r23, 0x00	; 0
     e5e:	80 91 0e 09 	lds	r24, 0x090E
     e62:	90 91 0f 09 	lds	r25, 0x090F
     e66:	cc c2       	rjmp	.+1432   	; 0x1400 <xQueueGenericSend>
     e68:	08 95       	ret

00000e6a <myUSART_receiveHandShakeAck>:
     e6a:	91 e0       	ldi	r25, 0x01	; 1
     e6c:	85 30       	cpi	r24, 0x05	; 5
     e6e:	09 f0       	breq	.+2      	; 0xe72 <myUSART_receiveHandShakeAck+0x8>
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	89 2f       	mov	r24, r25
     e74:	08 95       	ret

00000e76 <myUSART_receiveHandShakeStart>:
     e76:	91 e0       	ldi	r25, 0x01	; 1
     e78:	86 31       	cpi	r24, 0x16	; 22
     e7a:	09 f0       	breq	.+2      	; 0xe7e <myUSART_receiveHandShakeStart+0x8>
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	89 2f       	mov	r24, r25
     e80:	08 95       	ret

00000e82 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
     e82:	91 e0       	ldi	r25, 0x01	; 1
     e84:	86 30       	cpi	r24, 0x06	; 6
     e86:	09 f0       	breq	.+2      	; 0xe8a <myUSART_receiveMessageACK+0x8>
     e88:	90 e0       	ldi	r25, 0x00	; 0
}
     e8a:	89 2f       	mov	r24, r25
     e8c:	08 95       	ret

00000e8e <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
     e8e:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
     e90:	20 e0       	ldi	r18, 0x00	; 0
     e92:	4f ef       	ldi	r20, 0xFF	; 255
     e94:	5f ef       	ldi	r21, 0xFF	; 255
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	70 e0       	ldi	r23, 0x00	; 0
     e9a:	80 91 52 09 	lds	r24, 0x0952
     e9e:	90 91 53 09 	lds	r25, 0x0953
     ea2:	a3 d3       	rcall	.+1862   	; 0x15ea <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
     ea4:	8e e5       	ldi	r24, 0x5E	; 94
     ea6:	99 e0       	ldi	r25, 0x09	; 9
     ea8:	5a d4       	rcall	.+2228   	; 0x175e <ringBufferPeek>
     eaa:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
     eac:	8e e5       	ldi	r24, 0x5E	; 94
     eae:	99 e0       	ldi	r25, 0x09	; 9
     eb0:	90 d4       	rcall	.+2336   	; 0x17d2 <ringBufferNotEmpty>
     eb2:	88 23       	and	r24, r24
     eb4:	51 f0       	breq	.+20     	; 0xeca <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	40 e0       	ldi	r20, 0x00	; 0
     eba:	50 e0       	ldi	r21, 0x00	; 0
     ebc:	60 e0       	ldi	r22, 0x00	; 0
     ebe:	70 e0       	ldi	r23, 0x00	; 0
     ec0:	80 91 52 09 	lds	r24, 0x0952
     ec4:	90 91 53 09 	lds	r25, 0x0953
     ec8:	9b d2       	rcall	.+1334   	; 0x1400 <xQueueGenericSend>
	}
	
	return data;
     eca:	8c 2f       	mov	r24, r28
     ecc:	cf 91       	pop	r28
     ece:	08 95       	ret

00000ed0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ed0:	31 e1       	ldi	r19, 0x11	; 17
     ed2:	fc 01       	movw	r30, r24
     ed4:	30 83       	st	Z, r19
     ed6:	31 97       	sbiw	r30, 0x01	; 1
     ed8:	22 e2       	ldi	r18, 0x22	; 34
     eda:	20 83       	st	Z, r18
     edc:	31 97       	sbiw	r30, 0x01	; 1
     ede:	a3 e3       	ldi	r26, 0x33	; 51
     ee0:	a0 83       	st	Z, r26
     ee2:	31 97       	sbiw	r30, 0x01	; 1
     ee4:	60 83       	st	Z, r22
     ee6:	31 97       	sbiw	r30, 0x01	; 1
     ee8:	70 83       	st	Z, r23
     eea:	31 97       	sbiw	r30, 0x01	; 1
     eec:	10 82       	st	Z, r1
     eee:	31 97       	sbiw	r30, 0x01	; 1
     ef0:	10 82       	st	Z, r1
     ef2:	31 97       	sbiw	r30, 0x01	; 1
     ef4:	60 e8       	ldi	r22, 0x80	; 128
     ef6:	60 83       	st	Z, r22
     ef8:	31 97       	sbiw	r30, 0x01	; 1
     efa:	10 82       	st	Z, r1
     efc:	31 97       	sbiw	r30, 0x01	; 1
     efe:	10 82       	st	Z, r1
     f00:	31 97       	sbiw	r30, 0x01	; 1
     f02:	10 82       	st	Z, r1
     f04:	31 97       	sbiw	r30, 0x01	; 1
     f06:	62 e0       	ldi	r22, 0x02	; 2
     f08:	60 83       	st	Z, r22
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	63 e0       	ldi	r22, 0x03	; 3
     f0e:	60 83       	st	Z, r22
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	64 e0       	ldi	r22, 0x04	; 4
     f14:	60 83       	st	Z, r22
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	65 e0       	ldi	r22, 0x05	; 5
     f1a:	60 83       	st	Z, r22
     f1c:	31 97       	sbiw	r30, 0x01	; 1
     f1e:	66 e0       	ldi	r22, 0x06	; 6
     f20:	60 83       	st	Z, r22
     f22:	31 97       	sbiw	r30, 0x01	; 1
     f24:	67 e0       	ldi	r22, 0x07	; 7
     f26:	60 83       	st	Z, r22
     f28:	31 97       	sbiw	r30, 0x01	; 1
     f2a:	68 e0       	ldi	r22, 0x08	; 8
     f2c:	60 83       	st	Z, r22
     f2e:	31 97       	sbiw	r30, 0x01	; 1
     f30:	69 e0       	ldi	r22, 0x09	; 9
     f32:	60 83       	st	Z, r22
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	60 e1       	ldi	r22, 0x10	; 16
     f38:	60 83       	st	Z, r22
     f3a:	31 97       	sbiw	r30, 0x01	; 1
     f3c:	30 83       	st	Z, r19
     f3e:	31 97       	sbiw	r30, 0x01	; 1
     f40:	32 e1       	ldi	r19, 0x12	; 18
     f42:	30 83       	st	Z, r19
     f44:	31 97       	sbiw	r30, 0x01	; 1
     f46:	33 e1       	ldi	r19, 0x13	; 19
     f48:	30 83       	st	Z, r19
     f4a:	31 97       	sbiw	r30, 0x01	; 1
     f4c:	34 e1       	ldi	r19, 0x14	; 20
     f4e:	30 83       	st	Z, r19
     f50:	31 97       	sbiw	r30, 0x01	; 1
     f52:	35 e1       	ldi	r19, 0x15	; 21
     f54:	30 83       	st	Z, r19
     f56:	31 97       	sbiw	r30, 0x01	; 1
     f58:	36 e1       	ldi	r19, 0x16	; 22
     f5a:	30 83       	st	Z, r19
     f5c:	31 97       	sbiw	r30, 0x01	; 1
     f5e:	37 e1       	ldi	r19, 0x17	; 23
     f60:	30 83       	st	Z, r19
     f62:	31 97       	sbiw	r30, 0x01	; 1
     f64:	38 e1       	ldi	r19, 0x18	; 24
     f66:	30 83       	st	Z, r19
     f68:	31 97       	sbiw	r30, 0x01	; 1
     f6a:	39 e1       	ldi	r19, 0x19	; 25
     f6c:	30 83       	st	Z, r19
     f6e:	31 97       	sbiw	r30, 0x01	; 1
     f70:	30 e2       	ldi	r19, 0x20	; 32
     f72:	30 83       	st	Z, r19
     f74:	31 97       	sbiw	r30, 0x01	; 1
     f76:	31 e2       	ldi	r19, 0x21	; 33
     f78:	30 83       	st	Z, r19
     f7a:	31 97       	sbiw	r30, 0x01	; 1
     f7c:	20 83       	st	Z, r18
     f7e:	31 97       	sbiw	r30, 0x01	; 1
     f80:	23 e2       	ldi	r18, 0x23	; 35
     f82:	20 83       	st	Z, r18
     f84:	31 97       	sbiw	r30, 0x01	; 1
     f86:	40 83       	st	Z, r20
     f88:	31 97       	sbiw	r30, 0x01	; 1
     f8a:	50 83       	st	Z, r21
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	26 e2       	ldi	r18, 0x26	; 38
     f90:	20 83       	st	Z, r18
     f92:	31 97       	sbiw	r30, 0x01	; 1
     f94:	27 e2       	ldi	r18, 0x27	; 39
     f96:	20 83       	st	Z, r18
     f98:	31 97       	sbiw	r30, 0x01	; 1
     f9a:	28 e2       	ldi	r18, 0x28	; 40
     f9c:	20 83       	st	Z, r18
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	29 e2       	ldi	r18, 0x29	; 41
     fa2:	20 83       	st	Z, r18
     fa4:	31 97       	sbiw	r30, 0x01	; 1
     fa6:	20 e3       	ldi	r18, 0x30	; 48
     fa8:	20 83       	st	Z, r18
     faa:	31 97       	sbiw	r30, 0x01	; 1
     fac:	21 e3       	ldi	r18, 0x31	; 49
     fae:	20 83       	st	Z, r18
     fb0:	89 97       	sbiw	r24, 0x29	; 41
     fb2:	08 95       	ret

00000fb4 <xPortStartScheduler>:
     fb4:	82 e0       	ldi	r24, 0x02	; 2
     fb6:	84 bd       	out	0x24, r24	; 36
     fb8:	16 bc       	out	0x26, r1	; 38
     fba:	80 e3       	ldi	r24, 0x30	; 48
     fbc:	87 bd       	out	0x27, r24	; 39
     fbe:	ee e6       	ldi	r30, 0x6E	; 110
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	80 81       	ld	r24, Z
     fc4:	82 60       	ori	r24, 0x02	; 2
     fc6:	80 83       	st	Z, r24
     fc8:	83 e0       	ldi	r24, 0x03	; 3
     fca:	85 bd       	out	0x25, r24	; 37
     fcc:	a0 91 a9 08 	lds	r26, 0x08A9
     fd0:	b0 91 aa 08 	lds	r27, 0x08AA
     fd4:	cd 91       	ld	r28, X+
     fd6:	cd bf       	out	0x3d, r28	; 61
     fd8:	dd 91       	ld	r29, X+
     fda:	de bf       	out	0x3e, r29	; 62
     fdc:	ff 91       	pop	r31
     fde:	ef 91       	pop	r30
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	bf 91       	pop	r27
     fe6:	af 91       	pop	r26
     fe8:	9f 91       	pop	r25
     fea:	8f 91       	pop	r24
     fec:	7f 91       	pop	r23
     fee:	6f 91       	pop	r22
     ff0:	5f 91       	pop	r21
     ff2:	4f 91       	pop	r20
     ff4:	3f 91       	pop	r19
     ff6:	2f 91       	pop	r18
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	cf 90       	pop	r12
    1004:	bf 90       	pop	r11
    1006:	af 90       	pop	r10
    1008:	9f 90       	pop	r9
    100a:	8f 90       	pop	r8
    100c:	7f 90       	pop	r7
    100e:	6f 90       	pop	r6
    1010:	5f 90       	pop	r5
    1012:	4f 90       	pop	r4
    1014:	3f 90       	pop	r3
    1016:	2f 90       	pop	r2
    1018:	1f 90       	pop	r1
    101a:	0f 90       	pop	r0
    101c:	0c be       	out	0x3c, r0	; 60
    101e:	0f 90       	pop	r0
    1020:	0b be       	out	0x3b, r0	; 59
    1022:	0f 90       	pop	r0
    1024:	0f be       	out	0x3f, r0	; 63
    1026:	0f 90       	pop	r0
    1028:	08 95       	ret
    102a:	81 e0       	ldi	r24, 0x01	; 1
    102c:	08 95       	ret

0000102e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    102e:	0f 92       	push	r0
    1030:	0f b6       	in	r0, 0x3f	; 63
    1032:	f8 94       	cli
    1034:	0f 92       	push	r0
    1036:	0b b6       	in	r0, 0x3b	; 59
    1038:	0f 92       	push	r0
    103a:	0c b6       	in	r0, 0x3c	; 60
    103c:	0f 92       	push	r0
    103e:	1f 92       	push	r1
    1040:	11 24       	eor	r1, r1
    1042:	2f 92       	push	r2
    1044:	3f 92       	push	r3
    1046:	4f 92       	push	r4
    1048:	5f 92       	push	r5
    104a:	6f 92       	push	r6
    104c:	7f 92       	push	r7
    104e:	8f 92       	push	r8
    1050:	9f 92       	push	r9
    1052:	af 92       	push	r10
    1054:	bf 92       	push	r11
    1056:	cf 92       	push	r12
    1058:	df 92       	push	r13
    105a:	ef 92       	push	r14
    105c:	ff 92       	push	r15
    105e:	0f 93       	push	r16
    1060:	1f 93       	push	r17
    1062:	2f 93       	push	r18
    1064:	3f 93       	push	r19
    1066:	4f 93       	push	r20
    1068:	5f 93       	push	r21
    106a:	6f 93       	push	r22
    106c:	7f 93       	push	r23
    106e:	8f 93       	push	r24
    1070:	9f 93       	push	r25
    1072:	af 93       	push	r26
    1074:	bf 93       	push	r27
    1076:	cf 93       	push	r28
    1078:	df 93       	push	r29
    107a:	ef 93       	push	r30
    107c:	ff 93       	push	r31
    107e:	a0 91 a9 08 	lds	r26, 0x08A9
    1082:	b0 91 aa 08 	lds	r27, 0x08AA
    1086:	0d b6       	in	r0, 0x3d	; 61
    1088:	0d 92       	st	X+, r0
    108a:	0e b6       	in	r0, 0x3e	; 62
    108c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    108e:	6f d7       	rcall	.+3806   	; 0x1f6e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1090:	a0 91 a9 08 	lds	r26, 0x08A9
    1094:	b0 91 aa 08 	lds	r27, 0x08AA
    1098:	cd 91       	ld	r28, X+
    109a:	cd bf       	out	0x3d, r28	; 61
    109c:	dd 91       	ld	r29, X+
    109e:	de bf       	out	0x3e, r29	; 62
    10a0:	ff 91       	pop	r31
    10a2:	ef 91       	pop	r30
    10a4:	df 91       	pop	r29
    10a6:	cf 91       	pop	r28
    10a8:	bf 91       	pop	r27
    10aa:	af 91       	pop	r26
    10ac:	9f 91       	pop	r25
    10ae:	8f 91       	pop	r24
    10b0:	7f 91       	pop	r23
    10b2:	6f 91       	pop	r22
    10b4:	5f 91       	pop	r21
    10b6:	4f 91       	pop	r20
    10b8:	3f 91       	pop	r19
    10ba:	2f 91       	pop	r18
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	af 90       	pop	r10
    10cc:	9f 90       	pop	r9
    10ce:	8f 90       	pop	r8
    10d0:	7f 90       	pop	r7
    10d2:	6f 90       	pop	r6
    10d4:	5f 90       	pop	r5
    10d6:	4f 90       	pop	r4
    10d8:	3f 90       	pop	r3
    10da:	2f 90       	pop	r2
    10dc:	1f 90       	pop	r1
    10de:	0f 90       	pop	r0
    10e0:	0c be       	out	0x3c, r0	; 60
    10e2:	0f 90       	pop	r0
    10e4:	0b be       	out	0x3b, r0	; 59
    10e6:	0f 90       	pop	r0
    10e8:	0f be       	out	0x3f, r0	; 63
    10ea:	0f 90       	pop	r0

	asm volatile ( "ret" );
    10ec:	08 95       	ret

000010ee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    10ee:	0f 92       	push	r0
    10f0:	0f b6       	in	r0, 0x3f	; 63
    10f2:	f8 94       	cli
    10f4:	0f 92       	push	r0
    10f6:	0b b6       	in	r0, 0x3b	; 59
    10f8:	0f 92       	push	r0
    10fa:	0c b6       	in	r0, 0x3c	; 60
    10fc:	0f 92       	push	r0
    10fe:	1f 92       	push	r1
    1100:	11 24       	eor	r1, r1
    1102:	2f 92       	push	r2
    1104:	3f 92       	push	r3
    1106:	4f 92       	push	r4
    1108:	5f 92       	push	r5
    110a:	6f 92       	push	r6
    110c:	7f 92       	push	r7
    110e:	8f 92       	push	r8
    1110:	9f 92       	push	r9
    1112:	af 92       	push	r10
    1114:	bf 92       	push	r11
    1116:	cf 92       	push	r12
    1118:	df 92       	push	r13
    111a:	ef 92       	push	r14
    111c:	ff 92       	push	r15
    111e:	0f 93       	push	r16
    1120:	1f 93       	push	r17
    1122:	2f 93       	push	r18
    1124:	3f 93       	push	r19
    1126:	4f 93       	push	r20
    1128:	5f 93       	push	r21
    112a:	6f 93       	push	r22
    112c:	7f 93       	push	r23
    112e:	8f 93       	push	r24
    1130:	9f 93       	push	r25
    1132:	af 93       	push	r26
    1134:	bf 93       	push	r27
    1136:	cf 93       	push	r28
    1138:	df 93       	push	r29
    113a:	ef 93       	push	r30
    113c:	ff 93       	push	r31
    113e:	a0 91 a9 08 	lds	r26, 0x08A9
    1142:	b0 91 aa 08 	lds	r27, 0x08AA
    1146:	0d b6       	in	r0, 0x3d	; 61
    1148:	0d 92       	st	X+, r0
    114a:	0e b6       	in	r0, 0x3e	; 62
    114c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    114e:	3d d5       	rcall	.+2682   	; 0x1bca <xTaskIncrementTick>
    1150:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1152:	0d d7       	rcall	.+3610   	; 0x1f6e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1154:	a0 91 a9 08 	lds	r26, 0x08A9
    1158:	b0 91 aa 08 	lds	r27, 0x08AA
    115c:	cd 91       	ld	r28, X+
    115e:	cd bf       	out	0x3d, r28	; 61
    1160:	dd 91       	ld	r29, X+
    1162:	de bf       	out	0x3e, r29	; 62
    1164:	ff 91       	pop	r31
    1166:	ef 91       	pop	r30
    1168:	df 91       	pop	r29
    116a:	cf 91       	pop	r28
    116c:	bf 91       	pop	r27
    116e:	af 91       	pop	r26
    1170:	9f 91       	pop	r25
    1172:	8f 91       	pop	r24
    1174:	7f 91       	pop	r23
    1176:	6f 91       	pop	r22
    1178:	5f 91       	pop	r21
    117a:	4f 91       	pop	r20
    117c:	3f 91       	pop	r19
    117e:	2f 91       	pop	r18
    1180:	1f 91       	pop	r17
    1182:	0f 91       	pop	r16
    1184:	ff 90       	pop	r15
    1186:	ef 90       	pop	r14
    1188:	df 90       	pop	r13
    118a:	cf 90       	pop	r12
    118c:	bf 90       	pop	r11
    118e:	af 90       	pop	r10
    1190:	9f 90       	pop	r9
    1192:	8f 90       	pop	r8
    1194:	7f 90       	pop	r7
    1196:	6f 90       	pop	r6
    1198:	5f 90       	pop	r5
    119a:	4f 90       	pop	r4
    119c:	3f 90       	pop	r3
    119e:	2f 90       	pop	r2
    11a0:	1f 90       	pop	r1
    11a2:	0f 90       	pop	r0
    11a4:	0c be       	out	0x3c, r0	; 60
    11a6:	0f 90       	pop	r0
    11a8:	0b be       	out	0x3b, r0	; 59
    11aa:	0f 90       	pop	r0
    11ac:	0f be       	out	0x3f, r0	; 63
    11ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11b0:	08 95       	ret

000011b2 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    11b2:	9d df       	rcall	.-198    	; 0x10ee <vPortYieldFromTick>
		 asm volatile ("reti");
    11b4:	18 95       	reti

000011b6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    11b6:	1f 93       	push	r17
    11b8:	cf 93       	push	r28
    11ba:	df 93       	push	r29
    11bc:	ec 01       	movw	r28, r24
    11be:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    11c0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11c2:	81 11       	cpse	r24, r1
    11c4:	0c c0       	rjmp	.+24     	; 0x11de <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    11c6:	88 81       	ld	r24, Y
    11c8:	99 81       	ldd	r25, Y+1	; 0x01
    11ca:	89 2b       	or	r24, r25
    11cc:	09 f0       	breq	.+2      	; 0x11d0 <prvCopyDataToQueue+0x1a>
    11ce:	47 c0       	rjmp	.+142    	; 0x125e <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    11d0:	8a 81       	ldd	r24, Y+2	; 0x02
    11d2:	9b 81       	ldd	r25, Y+3	; 0x03
    11d4:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    11d8:	1b 82       	std	Y+3, r1	; 0x03
    11da:	1a 82       	std	Y+2, r1	; 0x02
    11dc:	47 c0       	rjmp	.+142    	; 0x126c <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    11de:	41 11       	cpse	r20, r1
    11e0:	18 c0       	rjmp	.+48     	; 0x1212 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    11e2:	48 2f       	mov	r20, r24
    11e4:	50 e0       	ldi	r21, 0x00	; 0
    11e6:	8c 81       	ldd	r24, Y+4	; 0x04
    11e8:	9d 81       	ldd	r25, Y+5	; 0x05
    11ea:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    11ee:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11f0:	8c 81       	ldd	r24, Y+4	; 0x04
    11f2:	9d 81       	ldd	r25, Y+5	; 0x05
    11f4:	82 0f       	add	r24, r18
    11f6:	91 1d       	adc	r25, r1
    11f8:	9d 83       	std	Y+5, r25	; 0x05
    11fa:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    11fc:	2a 81       	ldd	r18, Y+2	; 0x02
    11fe:	3b 81       	ldd	r19, Y+3	; 0x03
    1200:	82 17       	cp	r24, r18
    1202:	93 07       	cpc	r25, r19
    1204:	70 f1       	brcs	.+92     	; 0x1262 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1206:	88 81       	ld	r24, Y
    1208:	99 81       	ldd	r25, Y+1	; 0x01
    120a:	9d 83       	std	Y+5, r25	; 0x05
    120c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	2d c0       	rjmp	.+90     	; 0x126c <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1212:	48 2f       	mov	r20, r24
    1214:	50 e0       	ldi	r21, 0x00	; 0
    1216:	8e 81       	ldd	r24, Y+6	; 0x06
    1218:	9f 81       	ldd	r25, Y+7	; 0x07
    121a:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    121e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1220:	30 e0       	ldi	r19, 0x00	; 0
    1222:	31 95       	neg	r19
    1224:	21 95       	neg	r18
    1226:	31 09       	sbc	r19, r1
    1228:	8e 81       	ldd	r24, Y+6	; 0x06
    122a:	9f 81       	ldd	r25, Y+7	; 0x07
    122c:	82 0f       	add	r24, r18
    122e:	93 1f       	adc	r25, r19
    1230:	9f 83       	std	Y+7, r25	; 0x07
    1232:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1234:	68 81       	ld	r22, Y
    1236:	79 81       	ldd	r23, Y+1	; 0x01
    1238:	86 17       	cp	r24, r22
    123a:	97 07       	cpc	r25, r23
    123c:	30 f4       	brcc	.+12     	; 0x124a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    123e:	8a 81       	ldd	r24, Y+2	; 0x02
    1240:	9b 81       	ldd	r25, Y+3	; 0x03
    1242:	28 0f       	add	r18, r24
    1244:	39 1f       	adc	r19, r25
    1246:	3f 83       	std	Y+7, r19	; 0x07
    1248:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    124a:	12 30       	cpi	r17, 0x02	; 2
    124c:	61 f4       	brne	.+24     	; 0x1266 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    124e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1250:	88 23       	and	r24, r24
    1252:	59 f0       	breq	.+22     	; 0x126a <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1254:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1256:	81 50       	subi	r24, 0x01	; 1
    1258:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	07 c0       	rjmp	.+14     	; 0x126c <prvCopyDataToQueue+0xb6>
    125e:	80 e0       	ldi	r24, 0x00	; 0
    1260:	05 c0       	rjmp	.+10     	; 0x126c <prvCopyDataToQueue+0xb6>
    1262:	80 e0       	ldi	r24, 0x00	; 0
    1264:	03 c0       	rjmp	.+6      	; 0x126c <prvCopyDataToQueue+0xb6>
    1266:	80 e0       	ldi	r24, 0x00	; 0
    1268:	01 c0       	rjmp	.+2      	; 0x126c <prvCopyDataToQueue+0xb6>
    126a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    126c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    126e:	9f 5f       	subi	r25, 0xFF	; 255
    1270:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	1f 91       	pop	r17
    1278:	08 95       	ret

0000127a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    127a:	fc 01       	movw	r30, r24
    127c:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    127e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1280:	44 23       	and	r20, r20
    1282:	a1 f0       	breq	.+40     	; 0x12ac <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1284:	50 e0       	ldi	r21, 0x00	; 0
    1286:	26 81       	ldd	r18, Z+6	; 0x06
    1288:	37 81       	ldd	r19, Z+7	; 0x07
    128a:	24 0f       	add	r18, r20
    128c:	35 1f       	adc	r19, r21
    128e:	37 83       	std	Z+7, r19	; 0x07
    1290:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1292:	62 81       	ldd	r22, Z+2	; 0x02
    1294:	73 81       	ldd	r23, Z+3	; 0x03
    1296:	26 17       	cp	r18, r22
    1298:	37 07       	cpc	r19, r23
    129a:	20 f0       	brcs	.+8      	; 0x12a4 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    129c:	20 81       	ld	r18, Z
    129e:	31 81       	ldd	r19, Z+1	; 0x01
    12a0:	37 83       	std	Z+7, r19	; 0x07
    12a2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    12a4:	66 81       	ldd	r22, Z+6	; 0x06
    12a6:	77 81       	ldd	r23, Z+7	; 0x07
    12a8:	0c 94 46 15 	jmp	0x2a8c	; 0x2a8c <memcpy>
    12ac:	08 95       	ret

000012ae <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    12ae:	0f 93       	push	r16
    12b0:	1f 93       	push	r17
    12b2:	cf 93       	push	r28
    12b4:	df 93       	push	r29
    12b6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    12be:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12c0:	18 16       	cp	r1, r24
    12c2:	a4 f4       	brge	.+40     	; 0x12ec <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12c4:	89 89       	ldd	r24, Y+17	; 0x11
    12c6:	88 23       	and	r24, r24
    12c8:	89 f0       	breq	.+34     	; 0x12ec <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12ca:	8e 01       	movw	r16, r28
    12cc:	0f 5e       	subi	r16, 0xEF	; 239
    12ce:	1f 4f       	sbci	r17, 0xFF	; 255
    12d0:	03 c0       	rjmp	.+6      	; 0x12d8 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12d2:	89 89       	ldd	r24, Y+17	; 0x11
    12d4:	88 23       	and	r24, r24
    12d6:	51 f0       	breq	.+20     	; 0x12ec <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12d8:	c8 01       	movw	r24, r16
    12da:	1f d7       	rcall	.+3646   	; 0x211a <xTaskRemoveFromEventList>
    12dc:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    12de:	a8 d7       	rcall	.+3920   	; 0x2230 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    12e0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12e2:	81 50       	subi	r24, 0x01	; 1
    12e4:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    12e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    12e8:	18 16       	cp	r1, r24
    12ea:	9c f3       	brlt	.-26     	; 0x12d2 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    12ec:	8f ef       	ldi	r24, 0xFF	; 255
    12ee:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    12f0:	0f 90       	pop	r0
    12f2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    12fa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    12fc:	18 16       	cp	r1, r24
    12fe:	a4 f4       	brge	.+40     	; 0x1328 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1300:	88 85       	ldd	r24, Y+8	; 0x08
    1302:	88 23       	and	r24, r24
    1304:	89 f0       	breq	.+34     	; 0x1328 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1306:	8e 01       	movw	r16, r28
    1308:	08 5f       	subi	r16, 0xF8	; 248
    130a:	1f 4f       	sbci	r17, 0xFF	; 255
    130c:	03 c0       	rjmp	.+6      	; 0x1314 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    130e:	88 85       	ldd	r24, Y+8	; 0x08
    1310:	88 23       	and	r24, r24
    1312:	51 f0       	breq	.+20     	; 0x1328 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1314:	c8 01       	movw	r24, r16
    1316:	01 d7       	rcall	.+3586   	; 0x211a <xTaskRemoveFromEventList>
    1318:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    131a:	8a d7       	rcall	.+3860   	; 0x2230 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    131c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    131e:	81 50       	subi	r24, 0x01	; 1
    1320:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1322:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1324:	18 16       	cp	r1, r24
    1326:	9c f3       	brlt	.-26     	; 0x130e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1328:	8f ef       	ldi	r24, 0xFF	; 255
    132a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    132c:	0f 90       	pop	r0
    132e:	0f be       	out	0x3f, r0	; 63
}
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	08 95       	ret

0000133a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	f8 94       	cli
    1344:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1346:	88 81       	ld	r24, Y
    1348:	99 81       	ldd	r25, Y+1	; 0x01
    134a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    134c:	30 e0       	ldi	r19, 0x00	; 0
    134e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1350:	72 9f       	mul	r23, r18
    1352:	a0 01       	movw	r20, r0
    1354:	73 9f       	mul	r23, r19
    1356:	50 0d       	add	r21, r0
    1358:	11 24       	eor	r1, r1
    135a:	fc 01       	movw	r30, r24
    135c:	e4 0f       	add	r30, r20
    135e:	f5 1f       	adc	r31, r21
    1360:	fb 83       	std	Y+3, r31	; 0x03
    1362:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1364:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1366:	9d 83       	std	Y+5, r25	; 0x05
    1368:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    136a:	42 1b       	sub	r20, r18
    136c:	53 0b       	sbc	r21, r19
    136e:	84 0f       	add	r24, r20
    1370:	95 1f       	adc	r25, r21
    1372:	9f 83       	std	Y+7, r25	; 0x07
    1374:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1376:	8f ef       	ldi	r24, 0xFF	; 255
    1378:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    137a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    137c:	61 11       	cpse	r22, r1
    137e:	0a c0       	rjmp	.+20     	; 0x1394 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1380:	88 85       	ldd	r24, Y+8	; 0x08
    1382:	88 23       	and	r24, r24
    1384:	69 f0       	breq	.+26     	; 0x13a0 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1386:	ce 01       	movw	r24, r28
    1388:	08 96       	adiw	r24, 0x08	; 8
    138a:	c7 d6       	rcall	.+3470   	; 0x211a <xTaskRemoveFromEventList>
    138c:	81 30       	cpi	r24, 0x01	; 1
    138e:	41 f4       	brne	.+16     	; 0x13a0 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1390:	4e de       	rcall	.-868    	; 0x102e <vPortYield>
    1392:	06 c0       	rjmp	.+12     	; 0x13a0 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1394:	ce 01       	movw	r24, r28
    1396:	08 96       	adiw	r24, 0x08	; 8
    1398:	02 d9       	rcall	.-3580   	; 0x59e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    139a:	ce 01       	movw	r24, r28
    139c:	41 96       	adiw	r24, 0x11	; 17
    139e:	ff d8       	rcall	.-3586   	; 0x59e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    13a0:	0f 90       	pop	r0
    13a2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	08 95       	ret

000013ac <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    13ac:	0f 93       	push	r16
    13ae:	1f 93       	push	r17
    13b0:	cf 93       	push	r28
    13b2:	df 93       	push	r29
    13b4:	18 2f       	mov	r17, r24
    13b6:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    13b8:	88 23       	and	r24, r24
    13ba:	d1 f0       	breq	.+52     	; 0x13f0 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    13bc:	8f e1       	ldi	r24, 0x1F	; 31
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	b8 d8       	rcall	.-3728   	; 0x532 <pvPortMalloc>
    13c2:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    13c4:	00 97       	sbiw	r24, 0x00	; 0
    13c6:	b1 f0       	breq	.+44     	; 0x13f4 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    13c8:	10 9f       	mul	r17, r16
    13ca:	c0 01       	movw	r24, r0
    13cc:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    13ce:	01 96       	adiw	r24, 0x01	; 1
    13d0:	b0 d8       	rcall	.-3744   	; 0x532 <pvPortMalloc>
    13d2:	99 83       	std	Y+1, r25	; 0x01
    13d4:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    13d6:	89 2b       	or	r24, r25
    13d8:	31 f0       	breq	.+12     	; 0x13e6 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    13da:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    13dc:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    13de:	61 e0       	ldi	r22, 0x01	; 1
    13e0:	ce 01       	movw	r24, r28
    13e2:	ab df       	rcall	.-170    	; 0x133a <xQueueGenericReset>
    13e4:	07 c0       	rjmp	.+14     	; 0x13f4 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    13e6:	ce 01       	movw	r24, r28
    13e8:	d9 d8       	rcall	.-3662   	; 0x59c <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    13ea:	c0 e0       	ldi	r28, 0x00	; 0
    13ec:	d0 e0       	ldi	r29, 0x00	; 0
    13ee:	02 c0       	rjmp	.+4      	; 0x13f4 <xQueueGenericCreate+0x48>
    13f0:	c0 e0       	ldi	r28, 0x00	; 0
    13f2:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    13f4:	ce 01       	movw	r24, r28
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	08 95       	ret

00001400 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1400:	9f 92       	push	r9
    1402:	af 92       	push	r10
    1404:	bf 92       	push	r11
    1406:	cf 92       	push	r12
    1408:	df 92       	push	r13
    140a:	ef 92       	push	r14
    140c:	ff 92       	push	r15
    140e:	0f 93       	push	r16
    1410:	1f 93       	push	r17
    1412:	cf 93       	push	r28
    1414:	df 93       	push	r29
    1416:	00 d0       	rcall	.+0      	; 0x1418 <xQueueGenericSend+0x18>
    1418:	1f 92       	push	r1
    141a:	1f 92       	push	r1
    141c:	cd b7       	in	r28, 0x3d	; 61
    141e:	de b7       	in	r29, 0x3e	; 62
    1420:	8c 01       	movw	r16, r24
    1422:	6b 01       	movw	r12, r22
    1424:	5d 83       	std	Y+5, r21	; 0x05
    1426:	4c 83       	std	Y+4, r20	; 0x04
    1428:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    142a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    142c:	99 24       	eor	r9, r9
    142e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1430:	7c 01       	movw	r14, r24
    1432:	88 e0       	ldi	r24, 0x08	; 8
    1434:	e8 0e       	add	r14, r24
    1436:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1438:	0f b6       	in	r0, 0x3f	; 63
    143a:	f8 94       	cli
    143c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    143e:	f8 01       	movw	r30, r16
    1440:	92 8d       	ldd	r25, Z+26	; 0x1a
    1442:	83 8d       	ldd	r24, Z+27	; 0x1b
    1444:	98 17       	cp	r25, r24
    1446:	18 f0       	brcs	.+6      	; 0x144e <xQueueGenericSend+0x4e>
    1448:	f2 e0       	ldi	r31, 0x02	; 2
    144a:	af 12       	cpse	r10, r31
    144c:	15 c0       	rjmp	.+42     	; 0x1478 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    144e:	4a 2d       	mov	r20, r10
    1450:	b6 01       	movw	r22, r12
    1452:	c8 01       	movw	r24, r16
    1454:	b0 de       	rcall	.-672    	; 0x11b6 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1456:	f8 01       	movw	r30, r16
    1458:	91 89       	ldd	r25, Z+17	; 0x11
    145a:	99 23       	and	r25, r25
    145c:	39 f0       	breq	.+14     	; 0x146c <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    145e:	c8 01       	movw	r24, r16
    1460:	41 96       	adiw	r24, 0x11	; 17
    1462:	5b d6       	rcall	.+3254   	; 0x211a <xTaskRemoveFromEventList>
    1464:	81 30       	cpi	r24, 0x01	; 1
    1466:	21 f4       	brne	.+8      	; 0x1470 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1468:	e2 dd       	rcall	.-1084   	; 0x102e <vPortYield>
    146a:	02 c0       	rjmp	.+4      	; 0x1470 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    146c:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    146e:	df dd       	rcall	.-1090   	; 0x102e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	46 c0       	rjmp	.+140    	; 0x1504 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1478:	ec 81       	ldd	r30, Y+4	; 0x04
    147a:	fd 81       	ldd	r31, Y+5	; 0x05
    147c:	ef 2b       	or	r30, r31
    147e:	21 f4       	brne	.+8      	; 0x1488 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1480:	0f 90       	pop	r0
    1482:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1484:	80 e0       	ldi	r24, 0x00	; 0
    1486:	3e c0       	rjmp	.+124    	; 0x1504 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1488:	b1 10       	cpse	r11, r1
    148a:	04 c0       	rjmp	.+8      	; 0x1494 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    148c:	ce 01       	movw	r24, r28
    148e:	01 96       	adiw	r24, 0x01	; 1
    1490:	8c d6       	rcall	.+3352   	; 0x21aa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1492:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1494:	0f 90       	pop	r0
    1496:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1498:	83 d3       	rcall	.+1798   	; 0x1ba0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	0f 92       	push	r0
    14a0:	f8 01       	movw	r30, r16
    14a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    14a4:	8f 3f       	cpi	r24, 0xFF	; 255
    14a6:	09 f4       	brne	.+2      	; 0x14aa <xQueueGenericSend+0xaa>
    14a8:	15 8e       	std	Z+29, r1	; 0x1d
    14aa:	f8 01       	movw	r30, r16
    14ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    14ae:	8f 3f       	cpi	r24, 0xFF	; 255
    14b0:	09 f4       	brne	.+2      	; 0x14b4 <xQueueGenericSend+0xb4>
    14b2:	16 8e       	std	Z+30, r1	; 0x1e
    14b4:	0f 90       	pop	r0
    14b6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14b8:	be 01       	movw	r22, r28
    14ba:	6c 5f       	subi	r22, 0xFC	; 252
    14bc:	7f 4f       	sbci	r23, 0xFF	; 255
    14be:	ce 01       	movw	r24, r28
    14c0:	01 96       	adiw	r24, 0x01	; 1
    14c2:	7e d6       	rcall	.+3324   	; 0x21c0 <xTaskCheckForTimeOut>
    14c4:	81 11       	cpse	r24, r1
    14c6:	1a c0       	rjmp	.+52     	; 0x14fc <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    14ce:	f8 01       	movw	r30, r16
    14d0:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14d2:	0f 90       	pop	r0
    14d4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    14d6:	f8 01       	movw	r30, r16
    14d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    14da:	98 13       	cpse	r25, r24
    14dc:	0b c0       	rjmp	.+22     	; 0x14f4 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    14de:	6c 81       	ldd	r22, Y+4	; 0x04
    14e0:	7d 81       	ldd	r23, Y+5	; 0x05
    14e2:	c7 01       	movw	r24, r14
    14e4:	ef d5       	rcall	.+3038   	; 0x20c4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    14e6:	c8 01       	movw	r24, r16
    14e8:	e2 de       	rcall	.-572    	; 0x12ae <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    14ea:	2d d4       	rcall	.+2138   	; 0x1d46 <xTaskResumeAll>
    14ec:	81 11       	cpse	r24, r1
    14ee:	a4 cf       	rjmp	.-184    	; 0x1438 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    14f0:	9e dd       	rcall	.-1220   	; 0x102e <vPortYield>
    14f2:	a2 cf       	rjmp	.-188    	; 0x1438 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14f4:	c8 01       	movw	r24, r16
    14f6:	db de       	rcall	.-586    	; 0x12ae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14f8:	26 d4       	rcall	.+2124   	; 0x1d46 <xTaskResumeAll>
    14fa:	9e cf       	rjmp	.-196    	; 0x1438 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    14fc:	c8 01       	movw	r24, r16
    14fe:	d7 de       	rcall	.-594    	; 0x12ae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1500:	22 d4       	rcall	.+2116   	; 0x1d46 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1502:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1504:	0f 90       	pop	r0
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	ff 90       	pop	r15
    1518:	ef 90       	pop	r14
    151a:	df 90       	pop	r13
    151c:	cf 90       	pop	r12
    151e:	bf 90       	pop	r11
    1520:	af 90       	pop	r10
    1522:	9f 90       	pop	r9
    1524:	08 95       	ret

00001526 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1526:	cf 93       	push	r28
    1528:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    152a:	8f e1       	ldi	r24, 0x1F	; 31
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	01 d8       	rcall	.-4094   	; 0x532 <pvPortMalloc>
    1530:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1532:	00 97       	sbiw	r24, 0x00	; 0
    1534:	e1 f0       	breq	.+56     	; 0x156e <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1536:	1b 82       	std	Y+3, r1	; 0x03
    1538:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    153a:	19 82       	std	Y+1, r1	; 0x01
    153c:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    153e:	1d 82       	std	Y+5, r1	; 0x05
    1540:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1542:	1f 82       	std	Y+7, r1	; 0x07
    1544:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1546:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1548:	81 e0       	ldi	r24, 0x01	; 1
    154a:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    154c:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    154e:	8f ef       	ldi	r24, 0xFF	; 255
    1550:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1552:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1554:	ce 01       	movw	r24, r28
    1556:	08 96       	adiw	r24, 0x08	; 8
    1558:	22 d8       	rcall	.-4028   	; 0x59e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    155a:	ce 01       	movw	r24, r28
    155c:	41 96       	adiw	r24, 0x11	; 17
    155e:	1f d8       	rcall	.-4034   	; 0x59e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1560:	20 e0       	ldi	r18, 0x00	; 0
    1562:	40 e0       	ldi	r20, 0x00	; 0
    1564:	50 e0       	ldi	r21, 0x00	; 0
    1566:	60 e0       	ldi	r22, 0x00	; 0
    1568:	70 e0       	ldi	r23, 0x00	; 0
    156a:	ce 01       	movw	r24, r28
    156c:	49 df       	rcall	.-366    	; 0x1400 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    156e:	ce 01       	movw	r24, r28
    1570:	df 91       	pop	r29
    1572:	cf 91       	pop	r28
    1574:	08 95       	ret

00001576 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1576:	0f 93       	push	r16
    1578:	1f 93       	push	r17
    157a:	cf 93       	push	r28
    157c:	df 93       	push	r29
    157e:	ec 01       	movw	r28, r24
    1580:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1582:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1584:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1586:	98 17       	cp	r25, r24
    1588:	10 f0       	brcs	.+4      	; 0x158e <xQueueGenericSendFromISR+0x18>
    158a:	22 30       	cpi	r18, 0x02	; 2
    158c:	11 f5       	brne	.+68     	; 0x15d2 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    158e:	42 2f       	mov	r20, r18
    1590:	ce 01       	movw	r24, r28
    1592:	11 de       	rcall	.-990    	; 0x11b6 <prvCopyDataToQueue>
    1594:	88 23       	and	r24, r24
    1596:	31 f0       	breq	.+12     	; 0x15a4 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1598:	01 15       	cp	r16, r1
    159a:	11 05       	cpc	r17, r1
    159c:	19 f0       	breq	.+6      	; 0x15a4 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    159e:	81 e0       	ldi	r24, 0x01	; 1
    15a0:	f8 01       	movw	r30, r16
    15a2:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    15a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15a6:	8f 3f       	cpi	r24, 0xFF	; 255
    15a8:	79 f4       	brne	.+30     	; 0x15c8 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15aa:	89 89       	ldd	r24, Y+17	; 0x11
    15ac:	88 23       	and	r24, r24
    15ae:	99 f0       	breq	.+38     	; 0x15d6 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15b0:	ce 01       	movw	r24, r28
    15b2:	41 96       	adiw	r24, 0x11	; 17
    15b4:	b2 d5       	rcall	.+2916   	; 0x211a <xTaskRemoveFromEventList>
    15b6:	88 23       	and	r24, r24
    15b8:	81 f0       	breq	.+32     	; 0x15da <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    15ba:	01 15       	cp	r16, r1
    15bc:	11 05       	cpc	r17, r1
    15be:	79 f0       	breq	.+30     	; 0x15de <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	f8 01       	movw	r30, r16
    15c4:	80 83       	st	Z, r24
    15c6:	0c c0       	rjmp	.+24     	; 0x15e0 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    15c8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15ca:	8f 5f       	subi	r24, 0xFF	; 255
    15cc:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	07 c0       	rjmp	.+14     	; 0x15e0 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    15d2:	80 e0       	ldi	r24, 0x00	; 0
    15d4:	05 c0       	rjmp	.+10     	; 0x15e0 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    15d6:	81 e0       	ldi	r24, 0x01	; 1
    15d8:	03 c0       	rjmp	.+6      	; 0x15e0 <xQueueGenericSendFromISR+0x6a>
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	01 c0       	rjmp	.+2      	; 0x15e0 <xQueueGenericSendFromISR+0x6a>
    15de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	08 95       	ret

000015ea <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    15ea:	9f 92       	push	r9
    15ec:	af 92       	push	r10
    15ee:	bf 92       	push	r11
    15f0:	cf 92       	push	r12
    15f2:	df 92       	push	r13
    15f4:	ef 92       	push	r14
    15f6:	ff 92       	push	r15
    15f8:	0f 93       	push	r16
    15fa:	1f 93       	push	r17
    15fc:	cf 93       	push	r28
    15fe:	df 93       	push	r29
    1600:	00 d0       	rcall	.+0      	; 0x1602 <xQueueGenericReceive+0x18>
    1602:	1f 92       	push	r1
    1604:	1f 92       	push	r1
    1606:	cd b7       	in	r28, 0x3d	; 61
    1608:	de b7       	in	r29, 0x3e	; 62
    160a:	8c 01       	movw	r16, r24
    160c:	6b 01       	movw	r12, r22
    160e:	5d 83       	std	Y+5, r21	; 0x05
    1610:	4c 83       	std	Y+4, r20	; 0x04
    1612:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1614:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1616:	99 24       	eor	r9, r9
    1618:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    161a:	7c 01       	movw	r14, r24
    161c:	81 e1       	ldi	r24, 0x11	; 17
    161e:	e8 0e       	add	r14, r24
    1620:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1622:	0f b6       	in	r0, 0x3f	; 63
    1624:	f8 94       	cli
    1626:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1628:	f8 01       	movw	r30, r16
    162a:	82 8d       	ldd	r24, Z+26	; 0x1a
    162c:	88 23       	and	r24, r24
    162e:	69 f1       	breq	.+90     	; 0x168a <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1630:	e6 80       	ldd	r14, Z+6	; 0x06
    1632:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1634:	b6 01       	movw	r22, r12
    1636:	c8 01       	movw	r24, r16
    1638:	20 de       	rcall	.-960    	; 0x127a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    163a:	b1 10       	cpse	r11, r1
    163c:	17 c0       	rjmp	.+46     	; 0x166c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    163e:	f8 01       	movw	r30, r16
    1640:	82 8d       	ldd	r24, Z+26	; 0x1a
    1642:	81 50       	subi	r24, 0x01	; 1
    1644:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1646:	80 81       	ld	r24, Z
    1648:	91 81       	ldd	r25, Z+1	; 0x01
    164a:	89 2b       	or	r24, r25
    164c:	21 f4       	brne	.+8      	; 0x1656 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    164e:	91 d6       	rcall	.+3362   	; 0x2372 <pvTaskIncrementMutexHeldCount>
    1650:	f8 01       	movw	r30, r16
    1652:	93 83       	std	Z+3, r25	; 0x03
    1654:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1656:	f8 01       	movw	r30, r16
    1658:	80 85       	ldd	r24, Z+8	; 0x08
    165a:	88 23       	and	r24, r24
    165c:	91 f0       	breq	.+36     	; 0x1682 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    165e:	c8 01       	movw	r24, r16
    1660:	08 96       	adiw	r24, 0x08	; 8
    1662:	5b d5       	rcall	.+2742   	; 0x211a <xTaskRemoveFromEventList>
    1664:	81 30       	cpi	r24, 0x01	; 1
    1666:	69 f4       	brne	.+26     	; 0x1682 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1668:	e2 dc       	rcall	.-1596   	; 0x102e <vPortYield>
    166a:	0b c0       	rjmp	.+22     	; 0x1682 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    166c:	f8 01       	movw	r30, r16
    166e:	f7 82       	std	Z+7, r15	; 0x07
    1670:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1672:	81 89       	ldd	r24, Z+17	; 0x11
    1674:	88 23       	and	r24, r24
    1676:	29 f0       	breq	.+10     	; 0x1682 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1678:	c8 01       	movw	r24, r16
    167a:	41 96       	adiw	r24, 0x11	; 17
    167c:	4e d5       	rcall	.+2716   	; 0x211a <xTaskRemoveFromEventList>
    167e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1680:	d6 dc       	rcall	.-1620   	; 0x102e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1682:	0f 90       	pop	r0
    1684:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	52 c0       	rjmp	.+164    	; 0x172e <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    168a:	4c 81       	ldd	r20, Y+4	; 0x04
    168c:	5d 81       	ldd	r21, Y+5	; 0x05
    168e:	45 2b       	or	r20, r21
    1690:	21 f4       	brne	.+8      	; 0x169a <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	4a c0       	rjmp	.+148    	; 0x172e <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    169a:	a1 10       	cpse	r10, r1
    169c:	04 c0       	rjmp	.+8      	; 0x16a6 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    169e:	ce 01       	movw	r24, r28
    16a0:	01 96       	adiw	r24, 0x01	; 1
    16a2:	83 d5       	rcall	.+2822   	; 0x21aa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16a4:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16aa:	7a d2       	rcall	.+1268   	; 0x1ba0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	f8 94       	cli
    16b0:	0f 92       	push	r0
    16b2:	f8 01       	movw	r30, r16
    16b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    16b6:	8f 3f       	cpi	r24, 0xFF	; 255
    16b8:	09 f4       	brne	.+2      	; 0x16bc <xQueueGenericReceive+0xd2>
    16ba:	15 8e       	std	Z+29, r1	; 0x1d
    16bc:	f8 01       	movw	r30, r16
    16be:	86 8d       	ldd	r24, Z+30	; 0x1e
    16c0:	8f 3f       	cpi	r24, 0xFF	; 255
    16c2:	09 f4       	brne	.+2      	; 0x16c6 <xQueueGenericReceive+0xdc>
    16c4:	16 8e       	std	Z+30, r1	; 0x1e
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16ca:	be 01       	movw	r22, r28
    16cc:	6c 5f       	subi	r22, 0xFC	; 252
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	ce 01       	movw	r24, r28
    16d2:	01 96       	adiw	r24, 0x01	; 1
    16d4:	75 d5       	rcall	.+2794   	; 0x21c0 <xTaskCheckForTimeOut>
    16d6:	81 11       	cpse	r24, r1
    16d8:	26 c0       	rjmp	.+76     	; 0x1726 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    16da:	0f b6       	in	r0, 0x3f	; 63
    16dc:	f8 94       	cli
    16de:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    16e0:	f8 01       	movw	r30, r16
    16e2:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    16e4:	0f 90       	pop	r0
    16e6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16e8:	81 11       	cpse	r24, r1
    16ea:	19 c0       	rjmp	.+50     	; 0x171e <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16ec:	f8 01       	movw	r30, r16
    16ee:	80 81       	ld	r24, Z
    16f0:	91 81       	ldd	r25, Z+1	; 0x01
    16f2:	89 2b       	or	r24, r25
    16f4:	49 f4       	brne	.+18     	; 0x1708 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    16f6:	0f b6       	in	r0, 0x3f	; 63
    16f8:	f8 94       	cli
    16fa:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    16fc:	f8 01       	movw	r30, r16
    16fe:	82 81       	ldd	r24, Z+2	; 0x02
    1700:	93 81       	ldd	r25, Z+3	; 0x03
    1702:	9a d5       	rcall	.+2868   	; 0x2238 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1704:	0f 90       	pop	r0
    1706:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1708:	6c 81       	ldd	r22, Y+4	; 0x04
    170a:	7d 81       	ldd	r23, Y+5	; 0x05
    170c:	c7 01       	movw	r24, r14
    170e:	da d4       	rcall	.+2484   	; 0x20c4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1710:	c8 01       	movw	r24, r16
    1712:	cd dd       	rcall	.-1126   	; 0x12ae <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1714:	18 d3       	rcall	.+1584   	; 0x1d46 <xTaskResumeAll>
    1716:	81 11       	cpse	r24, r1
    1718:	84 cf       	rjmp	.-248    	; 0x1622 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    171a:	89 dc       	rcall	.-1774   	; 0x102e <vPortYield>
    171c:	82 cf       	rjmp	.-252    	; 0x1622 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    171e:	c8 01       	movw	r24, r16
    1720:	c6 dd       	rcall	.-1140   	; 0x12ae <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1722:	11 d3       	rcall	.+1570   	; 0x1d46 <xTaskResumeAll>
    1724:	7e cf       	rjmp	.-260    	; 0x1622 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1726:	c8 01       	movw	r24, r16
    1728:	c2 dd       	rcall	.-1148   	; 0x12ae <prvUnlockQueue>
			( void ) xTaskResumeAll();
    172a:	0d d3       	rcall	.+1562   	; 0x1d46 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    172c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    172e:	0f 90       	pop	r0
    1730:	0f 90       	pop	r0
    1732:	0f 90       	pop	r0
    1734:	0f 90       	pop	r0
    1736:	0f 90       	pop	r0
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	ff 90       	pop	r15
    1742:	ef 90       	pop	r14
    1744:	df 90       	pop	r13
    1746:	cf 90       	pop	r12
    1748:	bf 90       	pop	r11
    174a:	af 90       	pop	r10
    174c:	9f 90       	pop	r9
    174e:	08 95       	ret

00001750 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1750:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1752:	71 83       	std	Z+1, r23	; 0x01
    1754:	60 83       	st	Z, r22
	ring->rSize = size;
    1756:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1758:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    175a:	13 82       	std	Z+3, r1	; 0x03
    175c:	08 95       	ret

0000175e <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    175e:	dc 01       	movw	r26, r24
    1760:	14 96       	adiw	r26, 0x04	; 4
    1762:	2c 91       	ld	r18, X
    1764:	14 97       	sbiw	r26, 0x04	; 4
    1766:	ed 91       	ld	r30, X+
    1768:	fc 91       	ld	r31, X
    176a:	e2 0f       	add	r30, r18
    176c:	f1 1d       	adc	r31, r1
}
    176e:	80 81       	ld	r24, Z
    1770:	08 95       	ret

00001772 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1772:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1774:	94 81       	ldd	r25, Z+4	; 0x04
    1776:	a0 81       	ld	r26, Z
    1778:	b1 81       	ldd	r27, Z+1	; 0x01
    177a:	a9 0f       	add	r26, r25
    177c:	b1 1d       	adc	r27, r1
    177e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1780:	9f 5f       	subi	r25, 0xFF	; 255
    1782:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1784:	22 81       	ldd	r18, Z+2	; 0x02
    1786:	92 17       	cp	r25, r18
    1788:	10 f0       	brcs	.+4      	; 0x178e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    178a:	92 1b       	sub	r25, r18
    178c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    178e:	93 81       	ldd	r25, Z+3	; 0x03
    1790:	91 50       	subi	r25, 0x01	; 1
    1792:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1794:	08 95       	ret

00001796 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1796:	fc 01       	movw	r30, r24
    1798:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    179a:	83 81       	ldd	r24, Z+3	; 0x03
    179c:	22 81       	ldd	r18, Z+2	; 0x02
    179e:	82 17       	cp	r24, r18
    17a0:	80 f4       	brcc	.+32     	; 0x17c2 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    17a2:	34 81       	ldd	r19, Z+4	; 0x04
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	83 0f       	add	r24, r19
    17a8:	91 1d       	adc	r25, r1
    17aa:	62 2f       	mov	r22, r18
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <__divmodhi4>
    17b2:	a0 81       	ld	r26, Z
    17b4:	b1 81       	ldd	r27, Z+1	; 0x01
    17b6:	a8 0f       	add	r26, r24
    17b8:	b9 1f       	adc	r27, r25
    17ba:	4c 93       	st	X, r20
            ring->rLength++;
    17bc:	83 81       	ldd	r24, Z+3	; 0x03
    17be:	8f 5f       	subi	r24, 0xFF	; 255
    17c0:	83 83       	std	Z+3, r24	; 0x03
    17c2:	08 95       	ret

000017c4 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    17c4:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    17c6:	81 e0       	ldi	r24, 0x01	; 1
    17c8:	22 81       	ldd	r18, Z+2	; 0x02
    17ca:	93 81       	ldd	r25, Z+3	; 0x03
    17cc:	29 13       	cpse	r18, r25
    17ce:	80 e0       	ldi	r24, 0x00	; 0
}
    17d0:	08 95       	ret

000017d2 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    17d2:	21 e0       	ldi	r18, 0x01	; 1
    17d4:	fc 01       	movw	r30, r24
    17d6:	83 81       	ldd	r24, Z+3	; 0x03
    17d8:	81 11       	cpse	r24, r1
    17da:	01 c0       	rjmp	.+2      	; 0x17de <ringBufferNotEmpty+0xc>
    17dc:	20 e0       	ldi	r18, 0x00	; 0
}
    17de:	82 2f       	mov	r24, r18
    17e0:	08 95       	ret

000017e2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    17e2:	e0 91 68 08 	lds	r30, 0x0868
    17e6:	f0 91 69 08 	lds	r31, 0x0869
    17ea:	80 81       	ld	r24, Z
    17ec:	81 11       	cpse	r24, r1
    17ee:	07 c0       	rjmp	.+14     	; 0x17fe <prvResetNextTaskUnblockTime+0x1c>
    17f0:	8f ef       	ldi	r24, 0xFF	; 255
    17f2:	9f ef       	ldi	r25, 0xFF	; 255
    17f4:	90 93 05 02 	sts	0x0205, r25
    17f8:	80 93 04 02 	sts	0x0204, r24
    17fc:	08 95       	ret
    17fe:	e0 91 68 08 	lds	r30, 0x0868
    1802:	f0 91 69 08 	lds	r31, 0x0869
    1806:	05 80       	ldd	r0, Z+5	; 0x05
    1808:	f6 81       	ldd	r31, Z+6	; 0x06
    180a:	e0 2d       	mov	r30, r0
    180c:	06 80       	ldd	r0, Z+6	; 0x06
    180e:	f7 81       	ldd	r31, Z+7	; 0x07
    1810:	e0 2d       	mov	r30, r0
    1812:	82 81       	ldd	r24, Z+2	; 0x02
    1814:	93 81       	ldd	r25, Z+3	; 0x03
    1816:	90 93 05 02 	sts	0x0205, r25
    181a:	80 93 04 02 	sts	0x0204, r24
    181e:	08 95       	ret

00001820 <prvAddCurrentTaskToDelayedList>:
    1820:	cf 93       	push	r28
    1822:	df 93       	push	r29
    1824:	ec 01       	movw	r28, r24
    1826:	e0 91 a9 08 	lds	r30, 0x08A9
    182a:	f0 91 aa 08 	lds	r31, 0x08AA
    182e:	93 83       	std	Z+3, r25	; 0x03
    1830:	82 83       	std	Z+2, r24	; 0x02
    1832:	80 91 47 08 	lds	r24, 0x0847
    1836:	90 91 48 08 	lds	r25, 0x0848
    183a:	c8 17       	cp	r28, r24
    183c:	d9 07       	cpc	r29, r25
    183e:	68 f4       	brcc	.+26     	; 0x185a <prvAddCurrentTaskToDelayedList+0x3a>
    1840:	60 91 a9 08 	lds	r22, 0x08A9
    1844:	70 91 aa 08 	lds	r23, 0x08AA
    1848:	80 91 66 08 	lds	r24, 0x0866
    184c:	90 91 67 08 	lds	r25, 0x0867
    1850:	6e 5f       	subi	r22, 0xFE	; 254
    1852:	7f 4f       	sbci	r23, 0xFF	; 255
    1854:	0e 94 02 03 	call	0x604	; 0x604 <vListInsert>
    1858:	17 c0       	rjmp	.+46     	; 0x1888 <prvAddCurrentTaskToDelayedList+0x68>
    185a:	60 91 a9 08 	lds	r22, 0x08A9
    185e:	70 91 aa 08 	lds	r23, 0x08AA
    1862:	80 91 68 08 	lds	r24, 0x0868
    1866:	90 91 69 08 	lds	r25, 0x0869
    186a:	6e 5f       	subi	r22, 0xFE	; 254
    186c:	7f 4f       	sbci	r23, 0xFF	; 255
    186e:	0e 94 02 03 	call	0x604	; 0x604 <vListInsert>
    1872:	80 91 04 02 	lds	r24, 0x0204
    1876:	90 91 05 02 	lds	r25, 0x0205
    187a:	c8 17       	cp	r28, r24
    187c:	d9 07       	cpc	r29, r25
    187e:	20 f4       	brcc	.+8      	; 0x1888 <prvAddCurrentTaskToDelayedList+0x68>
    1880:	d0 93 05 02 	sts	0x0205, r29
    1884:	c0 93 04 02 	sts	0x0204, r28
    1888:	df 91       	pop	r29
    188a:	cf 91       	pop	r28
    188c:	08 95       	ret

0000188e <xTaskGenericCreate>:
    188e:	4f 92       	push	r4
    1890:	5f 92       	push	r5
    1892:	6f 92       	push	r6
    1894:	7f 92       	push	r7
    1896:	8f 92       	push	r8
    1898:	9f 92       	push	r9
    189a:	af 92       	push	r10
    189c:	bf 92       	push	r11
    189e:	cf 92       	push	r12
    18a0:	df 92       	push	r13
    18a2:	ef 92       	push	r14
    18a4:	ff 92       	push	r15
    18a6:	0f 93       	push	r16
    18a8:	1f 93       	push	r17
    18aa:	cf 93       	push	r28
    18ac:	df 93       	push	r29
    18ae:	4c 01       	movw	r8, r24
    18b0:	5b 01       	movw	r10, r22
    18b2:	2a 01       	movw	r4, r20
    18b4:	39 01       	movw	r6, r18
    18b6:	83 e2       	ldi	r24, 0x23	; 35
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	0e 94 99 02 	call	0x532	; 0x532 <pvPortMalloc>
    18be:	ec 01       	movw	r28, r24
    18c0:	00 97       	sbiw	r24, 0x00	; 0
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <xTaskGenericCreate+0x38>
    18c4:	e7 c0       	rjmp	.+462    	; 0x1a94 <xTaskGenericCreate+0x206>
    18c6:	c1 14       	cp	r12, r1
    18c8:	d1 04       	cpc	r13, r1
    18ca:	09 f0       	breq	.+2      	; 0x18ce <xTaskGenericCreate+0x40>
    18cc:	cc c0       	rjmp	.+408    	; 0x1a66 <xTaskGenericCreate+0x1d8>
    18ce:	c2 01       	movw	r24, r4
    18d0:	0e 94 99 02 	call	0x532	; 0x532 <pvPortMalloc>
    18d4:	98 8f       	std	Y+24, r25	; 0x18
    18d6:	8f 8b       	std	Y+23, r24	; 0x17
    18d8:	89 2b       	or	r24, r25
    18da:	09 f0       	breq	.+2      	; 0x18de <xTaskGenericCreate+0x50>
    18dc:	c6 c0       	rjmp	.+396    	; 0x1a6a <xTaskGenericCreate+0x1dc>
    18de:	ce 01       	movw	r24, r28
    18e0:	0e 94 ce 02 	call	0x59c	; 0x59c <vPortFree>
    18e4:	d7 c0       	rjmp	.+430    	; 0x1a94 <xTaskGenericCreate+0x206>
    18e6:	cf 01       	movw	r24, r30
    18e8:	31 91       	ld	r19, Z+
    18ea:	da 01       	movw	r26, r20
    18ec:	3d 93       	st	X+, r19
    18ee:	ad 01       	movw	r20, r26
    18f0:	dc 01       	movw	r26, r24
    18f2:	8c 91       	ld	r24, X
    18f4:	88 23       	and	r24, r24
    18f6:	11 f0       	breq	.+4      	; 0x18fc <xTaskGenericCreate+0x6e>
    18f8:	21 50       	subi	r18, 0x01	; 1
    18fa:	a9 f7       	brne	.-22     	; 0x18e6 <xTaskGenericCreate+0x58>
    18fc:	18 a2       	std	Y+32, r1	; 0x20
    18fe:	10 2f       	mov	r17, r16
    1900:	05 30       	cpi	r16, 0x05	; 5
    1902:	08 f0       	brcs	.+2      	; 0x1906 <xTaskGenericCreate+0x78>
    1904:	14 e0       	ldi	r17, 0x04	; 4
    1906:	1e 8b       	std	Y+22, r17	; 0x16
    1908:	19 a3       	std	Y+33, r17	; 0x21
    190a:	1a a2       	std	Y+34, r1	; 0x22
    190c:	5e 01       	movw	r10, r28
    190e:	b2 e0       	ldi	r27, 0x02	; 2
    1910:	ab 0e       	add	r10, r27
    1912:	b1 1c       	adc	r11, r1
    1914:	c5 01       	movw	r24, r10
    1916:	0e 94 dd 02 	call	0x5ba	; 0x5ba <vListInitialiseItem>
    191a:	ce 01       	movw	r24, r28
    191c:	0c 96       	adiw	r24, 0x0c	; 12
    191e:	0e 94 dd 02 	call	0x5ba	; 0x5ba <vListInitialiseItem>
    1922:	d9 87       	std	Y+9, r29	; 0x09
    1924:	c8 87       	std	Y+8, r28	; 0x08
    1926:	85 e0       	ldi	r24, 0x05	; 5
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	81 1b       	sub	r24, r17
    192c:	91 09       	sbc	r25, r1
    192e:	9d 87       	std	Y+13, r25	; 0x0d
    1930:	8c 87       	std	Y+12, r24	; 0x0c
    1932:	db 8b       	std	Y+19, r29	; 0x13
    1934:	ca 8b       	std	Y+18, r28	; 0x12
    1936:	a3 01       	movw	r20, r6
    1938:	b4 01       	movw	r22, r8
    193a:	c6 01       	movw	r24, r12
    193c:	c9 da       	rcall	.-2670   	; 0xed0 <pxPortInitialiseStack>
    193e:	99 83       	std	Y+1, r25	; 0x01
    1940:	88 83       	st	Y, r24
    1942:	e1 14       	cp	r14, r1
    1944:	f1 04       	cpc	r15, r1
    1946:	19 f0       	breq	.+6      	; 0x194e <xTaskGenericCreate+0xc0>
    1948:	f7 01       	movw	r30, r14
    194a:	d1 83       	std	Z+1, r29	; 0x01
    194c:	c0 83       	st	Z, r28
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	0f 92       	push	r0
    1954:	80 91 49 08 	lds	r24, 0x0849
    1958:	8f 5f       	subi	r24, 0xFF	; 255
    195a:	80 93 49 08 	sts	0x0849, r24
    195e:	80 91 a9 08 	lds	r24, 0x08A9
    1962:	90 91 aa 08 	lds	r25, 0x08AA
    1966:	89 2b       	or	r24, r25
    1968:	09 f0       	breq	.+2      	; 0x196c <xTaskGenericCreate+0xde>
    196a:	3f c0       	rjmp	.+126    	; 0x19ea <xTaskGenericCreate+0x15c>
    196c:	d0 93 aa 08 	sts	0x08AA, r29
    1970:	c0 93 a9 08 	sts	0x08A9, r28
    1974:	80 91 49 08 	lds	r24, 0x0849
    1978:	81 30       	cpi	r24, 0x01	; 1
    197a:	09 f0       	breq	.+2      	; 0x197e <xTaskGenericCreate+0xf0>
    197c:	45 c0       	rjmp	.+138    	; 0x1a08 <xTaskGenericCreate+0x17a>
    197e:	0f 2e       	mov	r0, r31
    1980:	fc e7       	ldi	r31, 0x7C	; 124
    1982:	ef 2e       	mov	r14, r31
    1984:	f8 e0       	ldi	r31, 0x08	; 8
    1986:	ff 2e       	mov	r15, r31
    1988:	f0 2d       	mov	r31, r0
    198a:	0f 2e       	mov	r0, r31
    198c:	f9 ea       	ldi	r31, 0xA9	; 169
    198e:	cf 2e       	mov	r12, r31
    1990:	f8 e0       	ldi	r31, 0x08	; 8
    1992:	df 2e       	mov	r13, r31
    1994:	f0 2d       	mov	r31, r0
    1996:	c7 01       	movw	r24, r14
    1998:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    199c:	f9 e0       	ldi	r31, 0x09	; 9
    199e:	ef 0e       	add	r14, r31
    19a0:	f1 1c       	adc	r15, r1
    19a2:	ec 14       	cp	r14, r12
    19a4:	fd 04       	cpc	r15, r13
    19a6:	b9 f7       	brne	.-18     	; 0x1996 <xTaskGenericCreate+0x108>
    19a8:	83 e7       	ldi	r24, 0x73	; 115
    19aa:	98 e0       	ldi	r25, 0x08	; 8
    19ac:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    19b0:	8a e6       	ldi	r24, 0x6A	; 106
    19b2:	98 e0       	ldi	r25, 0x08	; 8
    19b4:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    19b8:	8d e5       	ldi	r24, 0x5D	; 93
    19ba:	98 e0       	ldi	r25, 0x08	; 8
    19bc:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    19c0:	84 e5       	ldi	r24, 0x54	; 84
    19c2:	98 e0       	ldi	r25, 0x08	; 8
    19c4:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    19c8:	8a e4       	ldi	r24, 0x4A	; 74
    19ca:	98 e0       	ldi	r25, 0x08	; 8
    19cc:	0e 94 cf 02 	call	0x59e	; 0x59e <vListInitialise>
    19d0:	83 e7       	ldi	r24, 0x73	; 115
    19d2:	98 e0       	ldi	r25, 0x08	; 8
    19d4:	90 93 69 08 	sts	0x0869, r25
    19d8:	80 93 68 08 	sts	0x0868, r24
    19dc:	8a e6       	ldi	r24, 0x6A	; 106
    19de:	98 e0       	ldi	r25, 0x08	; 8
    19e0:	90 93 67 08 	sts	0x0867, r25
    19e4:	80 93 66 08 	sts	0x0866, r24
    19e8:	0f c0       	rjmp	.+30     	; 0x1a08 <xTaskGenericCreate+0x17a>
    19ea:	80 91 45 08 	lds	r24, 0x0845
    19ee:	81 11       	cpse	r24, r1
    19f0:	0b c0       	rjmp	.+22     	; 0x1a08 <xTaskGenericCreate+0x17a>
    19f2:	e0 91 a9 08 	lds	r30, 0x08A9
    19f6:	f0 91 aa 08 	lds	r31, 0x08AA
    19fa:	86 89       	ldd	r24, Z+22	; 0x16
    19fc:	08 17       	cp	r16, r24
    19fe:	20 f0       	brcs	.+8      	; 0x1a08 <xTaskGenericCreate+0x17a>
    1a00:	d0 93 aa 08 	sts	0x08AA, r29
    1a04:	c0 93 a9 08 	sts	0x08A9, r28
    1a08:	80 91 41 08 	lds	r24, 0x0841
    1a0c:	8f 5f       	subi	r24, 0xFF	; 255
    1a0e:	80 93 41 08 	sts	0x0841, r24
    1a12:	8e 89       	ldd	r24, Y+22	; 0x16
    1a14:	90 91 46 08 	lds	r25, 0x0846
    1a18:	98 17       	cp	r25, r24
    1a1a:	10 f4       	brcc	.+4      	; 0x1a20 <xTaskGenericCreate+0x192>
    1a1c:	80 93 46 08 	sts	0x0846, r24
    1a20:	90 e0       	ldi	r25, 0x00	; 0
    1a22:	9c 01       	movw	r18, r24
    1a24:	22 0f       	add	r18, r18
    1a26:	33 1f       	adc	r19, r19
    1a28:	22 0f       	add	r18, r18
    1a2a:	33 1f       	adc	r19, r19
    1a2c:	22 0f       	add	r18, r18
    1a2e:	33 1f       	adc	r19, r19
    1a30:	82 0f       	add	r24, r18
    1a32:	93 1f       	adc	r25, r19
    1a34:	b5 01       	movw	r22, r10
    1a36:	84 58       	subi	r24, 0x84	; 132
    1a38:	97 4f       	sbci	r25, 0xF7	; 247
    1a3a:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    1a3e:	0f 90       	pop	r0
    1a40:	0f be       	out	0x3f, r0	; 63
    1a42:	80 91 45 08 	lds	r24, 0x0845
    1a46:	88 23       	and	r24, r24
    1a48:	51 f0       	breq	.+20     	; 0x1a5e <xTaskGenericCreate+0x1d0>
    1a4a:	e0 91 a9 08 	lds	r30, 0x08A9
    1a4e:	f0 91 aa 08 	lds	r31, 0x08AA
    1a52:	86 89       	ldd	r24, Z+22	; 0x16
    1a54:	80 17       	cp	r24, r16
    1a56:	28 f4       	brcc	.+10     	; 0x1a62 <xTaskGenericCreate+0x1d4>
    1a58:	ea da       	rcall	.-2604   	; 0x102e <vPortYield>
    1a5a:	81 e0       	ldi	r24, 0x01	; 1
    1a5c:	1c c0       	rjmp	.+56     	; 0x1a96 <xTaskGenericCreate+0x208>
    1a5e:	81 e0       	ldi	r24, 0x01	; 1
    1a60:	1a c0       	rjmp	.+52     	; 0x1a96 <xTaskGenericCreate+0x208>
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	18 c0       	rjmp	.+48     	; 0x1a96 <xTaskGenericCreate+0x208>
    1a66:	d8 8e       	std	Y+24, r13	; 0x18
    1a68:	cf 8a       	std	Y+23, r12	; 0x17
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	48 1a       	sub	r4, r24
    1a6e:	51 08       	sbc	r5, r1
    1a70:	cf 88       	ldd	r12, Y+23	; 0x17
    1a72:	d8 8c       	ldd	r13, Y+24	; 0x18
    1a74:	c4 0c       	add	r12, r4
    1a76:	d5 1c       	adc	r13, r5
    1a78:	d5 01       	movw	r26, r10
    1a7a:	8c 91       	ld	r24, X
    1a7c:	89 8f       	std	Y+25, r24	; 0x19
    1a7e:	8c 91       	ld	r24, X
    1a80:	88 23       	and	r24, r24
    1a82:	09 f4       	brne	.+2      	; 0x1a86 <xTaskGenericCreate+0x1f8>
    1a84:	3b cf       	rjmp	.-394    	; 0x18fc <xTaskGenericCreate+0x6e>
    1a86:	ae 01       	movw	r20, r28
    1a88:	46 5e       	subi	r20, 0xE6	; 230
    1a8a:	5f 4f       	sbci	r21, 0xFF	; 255
    1a8c:	f5 01       	movw	r30, r10
    1a8e:	31 96       	adiw	r30, 0x01	; 1
    1a90:	27 e0       	ldi	r18, 0x07	; 7
    1a92:	29 cf       	rjmp	.-430    	; 0x18e6 <xTaskGenericCreate+0x58>
    1a94:	8f ef       	ldi	r24, 0xFF	; 255
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	1f 91       	pop	r17
    1a9c:	0f 91       	pop	r16
    1a9e:	ff 90       	pop	r15
    1aa0:	ef 90       	pop	r14
    1aa2:	df 90       	pop	r13
    1aa4:	cf 90       	pop	r12
    1aa6:	bf 90       	pop	r11
    1aa8:	af 90       	pop	r10
    1aaa:	9f 90       	pop	r9
    1aac:	8f 90       	pop	r8
    1aae:	7f 90       	pop	r7
    1ab0:	6f 90       	pop	r6
    1ab2:	5f 90       	pop	r5
    1ab4:	4f 90       	pop	r4
    1ab6:	08 95       	ret

00001ab8 <vTaskResume>:
    1ab8:	0f 93       	push	r16
    1aba:	1f 93       	push	r17
    1abc:	cf 93       	push	r28
    1abe:	df 93       	push	r29
    1ac0:	ec 01       	movw	r28, r24
    1ac2:	00 97       	sbiw	r24, 0x00	; 0
    1ac4:	09 f4       	brne	.+2      	; 0x1ac8 <vTaskResume+0x10>
    1ac6:	3e c0       	rjmp	.+124    	; 0x1b44 <vTaskResume+0x8c>
    1ac8:	80 91 a9 08 	lds	r24, 0x08A9
    1acc:	90 91 aa 08 	lds	r25, 0x08AA
    1ad0:	c8 17       	cp	r28, r24
    1ad2:	d9 07       	cpc	r29, r25
    1ad4:	b9 f1       	breq	.+110    	; 0x1b44 <vTaskResume+0x8c>
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	f8 94       	cli
    1ada:	0f 92       	push	r0
    1adc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ade:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ae0:	8a 54       	subi	r24, 0x4A	; 74
    1ae2:	98 40       	sbci	r25, 0x08	; 8
    1ae4:	69 f5       	brne	.+90     	; 0x1b40 <vTaskResume+0x88>
    1ae6:	8c 89       	ldd	r24, Y+20	; 0x14
    1ae8:	9d 89       	ldd	r25, Y+21	; 0x15
    1aea:	28 e0       	ldi	r18, 0x08	; 8
    1aec:	8d 35       	cpi	r24, 0x5D	; 93
    1aee:	92 07       	cpc	r25, r18
    1af0:	39 f1       	breq	.+78     	; 0x1b40 <vTaskResume+0x88>
    1af2:	89 2b       	or	r24, r25
    1af4:	29 f5       	brne	.+74     	; 0x1b40 <vTaskResume+0x88>
    1af6:	8e 01       	movw	r16, r28
    1af8:	0e 5f       	subi	r16, 0xFE	; 254
    1afa:	1f 4f       	sbci	r17, 0xFF	; 255
    1afc:	c8 01       	movw	r24, r16
    1afe:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1b02:	8e 89       	ldd	r24, Y+22	; 0x16
    1b04:	90 91 46 08 	lds	r25, 0x0846
    1b08:	98 17       	cp	r25, r24
    1b0a:	10 f4       	brcc	.+4      	; 0x1b10 <vTaskResume+0x58>
    1b0c:	80 93 46 08 	sts	0x0846, r24
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	9c 01       	movw	r18, r24
    1b14:	22 0f       	add	r18, r18
    1b16:	33 1f       	adc	r19, r19
    1b18:	22 0f       	add	r18, r18
    1b1a:	33 1f       	adc	r19, r19
    1b1c:	22 0f       	add	r18, r18
    1b1e:	33 1f       	adc	r19, r19
    1b20:	82 0f       	add	r24, r18
    1b22:	93 1f       	adc	r25, r19
    1b24:	b8 01       	movw	r22, r16
    1b26:	84 58       	subi	r24, 0x84	; 132
    1b28:	97 4f       	sbci	r25, 0xF7	; 247
    1b2a:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    1b2e:	e0 91 a9 08 	lds	r30, 0x08A9
    1b32:	f0 91 aa 08 	lds	r31, 0x08AA
    1b36:	9e 89       	ldd	r25, Y+22	; 0x16
    1b38:	86 89       	ldd	r24, Z+22	; 0x16
    1b3a:	98 17       	cp	r25, r24
    1b3c:	08 f0       	brcs	.+2      	; 0x1b40 <vTaskResume+0x88>
    1b3e:	77 da       	rcall	.-2834   	; 0x102e <vPortYield>
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	08 95       	ret

00001b4e <vTaskStartScheduler>:
    1b4e:	af 92       	push	r10
    1b50:	bf 92       	push	r11
    1b52:	cf 92       	push	r12
    1b54:	df 92       	push	r13
    1b56:	ef 92       	push	r14
    1b58:	ff 92       	push	r15
    1b5a:	0f 93       	push	r16
    1b5c:	a1 2c       	mov	r10, r1
    1b5e:	b1 2c       	mov	r11, r1
    1b60:	c1 2c       	mov	r12, r1
    1b62:	d1 2c       	mov	r13, r1
    1b64:	e1 2c       	mov	r14, r1
    1b66:	f1 2c       	mov	r15, r1
    1b68:	00 e0       	ldi	r16, 0x00	; 0
    1b6a:	20 e0       	ldi	r18, 0x00	; 0
    1b6c:	30 e0       	ldi	r19, 0x00	; 0
    1b6e:	45 e5       	ldi	r20, 0x55	; 85
    1b70:	50 e0       	ldi	r21, 0x00	; 0
    1b72:	6a e5       	ldi	r22, 0x5A	; 90
    1b74:	72 e0       	ldi	r23, 0x02	; 2
    1b76:	8e e7       	ldi	r24, 0x7E	; 126
    1b78:	9f e0       	ldi	r25, 0x0F	; 15
    1b7a:	89 de       	rcall	.-750    	; 0x188e <xTaskGenericCreate>
    1b7c:	81 30       	cpi	r24, 0x01	; 1
    1b7e:	41 f4       	brne	.+16     	; 0x1b90 <vTaskStartScheduler+0x42>
    1b80:	f8 94       	cli
    1b82:	80 93 45 08 	sts	0x0845, r24
    1b86:	10 92 48 08 	sts	0x0848, r1
    1b8a:	10 92 47 08 	sts	0x0847, r1
    1b8e:	12 da       	rcall	.-3036   	; 0xfb4 <xPortStartScheduler>
    1b90:	0f 91       	pop	r16
    1b92:	ff 90       	pop	r15
    1b94:	ef 90       	pop	r14
    1b96:	df 90       	pop	r13
    1b98:	cf 90       	pop	r12
    1b9a:	bf 90       	pop	r11
    1b9c:	af 90       	pop	r10
    1b9e:	08 95       	ret

00001ba0 <vTaskSuspendAll>:
    1ba0:	80 91 40 08 	lds	r24, 0x0840
    1ba4:	8f 5f       	subi	r24, 0xFF	; 255
    1ba6:	80 93 40 08 	sts	0x0840, r24
    1baa:	08 95       	ret

00001bac <xTaskGetTickCount>:
    1bac:	0f b6       	in	r0, 0x3f	; 63
    1bae:	f8 94       	cli
    1bb0:	0f 92       	push	r0
    1bb2:	80 91 47 08 	lds	r24, 0x0847
    1bb6:	90 91 48 08 	lds	r25, 0x0848
    1bba:	0f 90       	pop	r0
    1bbc:	0f be       	out	0x3f, r0	; 63
    1bbe:	08 95       	ret

00001bc0 <xTaskGetTickCountFromISR>:
    1bc0:	80 91 47 08 	lds	r24, 0x0847
    1bc4:	90 91 48 08 	lds	r25, 0x0848
    1bc8:	08 95       	ret

00001bca <xTaskIncrementTick>:
    1bca:	cf 92       	push	r12
    1bcc:	df 92       	push	r13
    1bce:	ef 92       	push	r14
    1bd0:	ff 92       	push	r15
    1bd2:	0f 93       	push	r16
    1bd4:	1f 93       	push	r17
    1bd6:	cf 93       	push	r28
    1bd8:	df 93       	push	r29
    1bda:	80 91 40 08 	lds	r24, 0x0840
    1bde:	81 11       	cpse	r24, r1
    1be0:	99 c0       	rjmp	.+306    	; 0x1d14 <xTaskIncrementTick+0x14a>
    1be2:	80 91 47 08 	lds	r24, 0x0847
    1be6:	90 91 48 08 	lds	r25, 0x0848
    1bea:	01 96       	adiw	r24, 0x01	; 1
    1bec:	90 93 48 08 	sts	0x0848, r25
    1bf0:	80 93 47 08 	sts	0x0847, r24
    1bf4:	e0 90 47 08 	lds	r14, 0x0847
    1bf8:	f0 90 48 08 	lds	r15, 0x0848
    1bfc:	e1 14       	cp	r14, r1
    1bfe:	f1 04       	cpc	r15, r1
    1c00:	b1 f4       	brne	.+44     	; 0x1c2e <xTaskIncrementTick+0x64>
    1c02:	80 91 68 08 	lds	r24, 0x0868
    1c06:	90 91 69 08 	lds	r25, 0x0869
    1c0a:	20 91 66 08 	lds	r18, 0x0866
    1c0e:	30 91 67 08 	lds	r19, 0x0867
    1c12:	30 93 69 08 	sts	0x0869, r19
    1c16:	20 93 68 08 	sts	0x0868, r18
    1c1a:	90 93 67 08 	sts	0x0867, r25
    1c1e:	80 93 66 08 	sts	0x0866, r24
    1c22:	80 91 42 08 	lds	r24, 0x0842
    1c26:	8f 5f       	subi	r24, 0xFF	; 255
    1c28:	80 93 42 08 	sts	0x0842, r24
    1c2c:	da dd       	rcall	.-1100   	; 0x17e2 <prvResetNextTaskUnblockTime>
    1c2e:	80 91 04 02 	lds	r24, 0x0204
    1c32:	90 91 05 02 	lds	r25, 0x0205
    1c36:	e8 16       	cp	r14, r24
    1c38:	f9 06       	cpc	r15, r25
    1c3a:	08 f4       	brcc	.+2      	; 0x1c3e <xTaskIncrementTick+0x74>
    1c3c:	54 c0       	rjmp	.+168    	; 0x1ce6 <xTaskIncrementTick+0x11c>
    1c3e:	d1 2c       	mov	r13, r1
    1c40:	cc 24       	eor	r12, r12
    1c42:	c3 94       	inc	r12
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <xTaskIncrementTick+0x7e>
    1c46:	dc 2c       	mov	r13, r12
    1c48:	e0 91 68 08 	lds	r30, 0x0868
    1c4c:	f0 91 69 08 	lds	r31, 0x0869
    1c50:	80 81       	ld	r24, Z
    1c52:	81 11       	cpse	r24, r1
    1c54:	07 c0       	rjmp	.+14     	; 0x1c64 <xTaskIncrementTick+0x9a>
    1c56:	8f ef       	ldi	r24, 0xFF	; 255
    1c58:	9f ef       	ldi	r25, 0xFF	; 255
    1c5a:	90 93 05 02 	sts	0x0205, r25
    1c5e:	80 93 04 02 	sts	0x0204, r24
    1c62:	42 c0       	rjmp	.+132    	; 0x1ce8 <xTaskIncrementTick+0x11e>
    1c64:	e0 91 68 08 	lds	r30, 0x0868
    1c68:	f0 91 69 08 	lds	r31, 0x0869
    1c6c:	05 80       	ldd	r0, Z+5	; 0x05
    1c6e:	f6 81       	ldd	r31, Z+6	; 0x06
    1c70:	e0 2d       	mov	r30, r0
    1c72:	c6 81       	ldd	r28, Z+6	; 0x06
    1c74:	d7 81       	ldd	r29, Z+7	; 0x07
    1c76:	2a 81       	ldd	r18, Y+2	; 0x02
    1c78:	3b 81       	ldd	r19, Y+3	; 0x03
    1c7a:	e2 16       	cp	r14, r18
    1c7c:	f3 06       	cpc	r15, r19
    1c7e:	28 f4       	brcc	.+10     	; 0x1c8a <xTaskIncrementTick+0xc0>
    1c80:	30 93 05 02 	sts	0x0205, r19
    1c84:	20 93 04 02 	sts	0x0204, r18
    1c88:	2f c0       	rjmp	.+94     	; 0x1ce8 <xTaskIncrementTick+0x11e>
    1c8a:	8e 01       	movw	r16, r28
    1c8c:	0e 5f       	subi	r16, 0xFE	; 254
    1c8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c90:	c8 01       	movw	r24, r16
    1c92:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1c96:	8c 89       	ldd	r24, Y+20	; 0x14
    1c98:	9d 89       	ldd	r25, Y+21	; 0x15
    1c9a:	89 2b       	or	r24, r25
    1c9c:	21 f0       	breq	.+8      	; 0x1ca6 <xTaskIncrementTick+0xdc>
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	0c 96       	adiw	r24, 0x0c	; 12
    1ca2:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1ca6:	2e 89       	ldd	r18, Y+22	; 0x16
    1ca8:	80 91 46 08 	lds	r24, 0x0846
    1cac:	82 17       	cp	r24, r18
    1cae:	10 f4       	brcc	.+4      	; 0x1cb4 <xTaskIncrementTick+0xea>
    1cb0:	20 93 46 08 	sts	0x0846, r18
    1cb4:	30 e0       	ldi	r19, 0x00	; 0
    1cb6:	c9 01       	movw	r24, r18
    1cb8:	88 0f       	add	r24, r24
    1cba:	99 1f       	adc	r25, r25
    1cbc:	88 0f       	add	r24, r24
    1cbe:	99 1f       	adc	r25, r25
    1cc0:	88 0f       	add	r24, r24
    1cc2:	99 1f       	adc	r25, r25
    1cc4:	82 0f       	add	r24, r18
    1cc6:	93 1f       	adc	r25, r19
    1cc8:	b8 01       	movw	r22, r16
    1cca:	84 58       	subi	r24, 0x84	; 132
    1ccc:	97 4f       	sbci	r25, 0xF7	; 247
    1cce:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    1cd2:	e0 91 a9 08 	lds	r30, 0x08A9
    1cd6:	f0 91 aa 08 	lds	r31, 0x08AA
    1cda:	9e 89       	ldd	r25, Y+22	; 0x16
    1cdc:	86 89       	ldd	r24, Z+22	; 0x16
    1cde:	98 17       	cp	r25, r24
    1ce0:	08 f0       	brcs	.+2      	; 0x1ce4 <xTaskIncrementTick+0x11a>
    1ce2:	b1 cf       	rjmp	.-158    	; 0x1c46 <xTaskIncrementTick+0x7c>
    1ce4:	b1 cf       	rjmp	.-158    	; 0x1c48 <xTaskIncrementTick+0x7e>
    1ce6:	d1 2c       	mov	r13, r1
    1ce8:	e0 91 a9 08 	lds	r30, 0x08A9
    1cec:	f0 91 aa 08 	lds	r31, 0x08AA
    1cf0:	86 89       	ldd	r24, Z+22	; 0x16
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	fc 01       	movw	r30, r24
    1cf6:	ee 0f       	add	r30, r30
    1cf8:	ff 1f       	adc	r31, r31
    1cfa:	ee 0f       	add	r30, r30
    1cfc:	ff 1f       	adc	r31, r31
    1cfe:	ee 0f       	add	r30, r30
    1d00:	ff 1f       	adc	r31, r31
    1d02:	8e 0f       	add	r24, r30
    1d04:	9f 1f       	adc	r25, r31
    1d06:	fc 01       	movw	r30, r24
    1d08:	e4 58       	subi	r30, 0x84	; 132
    1d0a:	f7 4f       	sbci	r31, 0xF7	; 247
    1d0c:	80 81       	ld	r24, Z
    1d0e:	82 30       	cpi	r24, 0x02	; 2
    1d10:	40 f4       	brcc	.+16     	; 0x1d22 <xTaskIncrementTick+0x158>
    1d12:	09 c0       	rjmp	.+18     	; 0x1d26 <xTaskIncrementTick+0x15c>
    1d14:	80 91 44 08 	lds	r24, 0x0844
    1d18:	8f 5f       	subi	r24, 0xFF	; 255
    1d1a:	80 93 44 08 	sts	0x0844, r24
    1d1e:	d1 2c       	mov	r13, r1
    1d20:	02 c0       	rjmp	.+4      	; 0x1d26 <xTaskIncrementTick+0x15c>
    1d22:	dd 24       	eor	r13, r13
    1d24:	d3 94       	inc	r13
    1d26:	80 91 43 08 	lds	r24, 0x0843
    1d2a:	88 23       	and	r24, r24
    1d2c:	11 f0       	breq	.+4      	; 0x1d32 <xTaskIncrementTick+0x168>
    1d2e:	dd 24       	eor	r13, r13
    1d30:	d3 94       	inc	r13
    1d32:	8d 2d       	mov	r24, r13
    1d34:	df 91       	pop	r29
    1d36:	cf 91       	pop	r28
    1d38:	1f 91       	pop	r17
    1d3a:	0f 91       	pop	r16
    1d3c:	ff 90       	pop	r15
    1d3e:	ef 90       	pop	r14
    1d40:	df 90       	pop	r13
    1d42:	cf 90       	pop	r12
    1d44:	08 95       	ret

00001d46 <xTaskResumeAll>:
    1d46:	df 92       	push	r13
    1d48:	ef 92       	push	r14
    1d4a:	ff 92       	push	r15
    1d4c:	0f 93       	push	r16
    1d4e:	1f 93       	push	r17
    1d50:	cf 93       	push	r28
    1d52:	df 93       	push	r29
    1d54:	0f b6       	in	r0, 0x3f	; 63
    1d56:	f8 94       	cli
    1d58:	0f 92       	push	r0
    1d5a:	80 91 40 08 	lds	r24, 0x0840
    1d5e:	81 50       	subi	r24, 0x01	; 1
    1d60:	80 93 40 08 	sts	0x0840, r24
    1d64:	80 91 40 08 	lds	r24, 0x0840
    1d68:	81 11       	cpse	r24, r1
    1d6a:	5f c0       	rjmp	.+190    	; 0x1e2a <xTaskResumeAll+0xe4>
    1d6c:	80 91 49 08 	lds	r24, 0x0849
    1d70:	88 23       	and	r24, r24
    1d72:	09 f4       	brne	.+2      	; 0x1d76 <xTaskResumeAll+0x30>
    1d74:	5c c0       	rjmp	.+184    	; 0x1e2e <xTaskResumeAll+0xe8>
    1d76:	0f 2e       	mov	r0, r31
    1d78:	fd e5       	ldi	r31, 0x5D	; 93
    1d7a:	ef 2e       	mov	r14, r31
    1d7c:	f8 e0       	ldi	r31, 0x08	; 8
    1d7e:	ff 2e       	mov	r15, r31
    1d80:	f0 2d       	mov	r31, r0
    1d82:	dd 24       	eor	r13, r13
    1d84:	d3 94       	inc	r13
    1d86:	30 c0       	rjmp	.+96     	; 0x1de8 <xTaskResumeAll+0xa2>
    1d88:	e0 91 62 08 	lds	r30, 0x0862
    1d8c:	f0 91 63 08 	lds	r31, 0x0863
    1d90:	c6 81       	ldd	r28, Z+6	; 0x06
    1d92:	d7 81       	ldd	r29, Z+7	; 0x07
    1d94:	ce 01       	movw	r24, r28
    1d96:	0c 96       	adiw	r24, 0x0c	; 12
    1d98:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1d9c:	8e 01       	movw	r16, r28
    1d9e:	0e 5f       	subi	r16, 0xFE	; 254
    1da0:	1f 4f       	sbci	r17, 0xFF	; 255
    1da2:	c8 01       	movw	r24, r16
    1da4:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1da8:	8e 89       	ldd	r24, Y+22	; 0x16
    1daa:	90 91 46 08 	lds	r25, 0x0846
    1dae:	98 17       	cp	r25, r24
    1db0:	10 f4       	brcc	.+4      	; 0x1db6 <xTaskResumeAll+0x70>
    1db2:	80 93 46 08 	sts	0x0846, r24
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	9c 01       	movw	r18, r24
    1dba:	22 0f       	add	r18, r18
    1dbc:	33 1f       	adc	r19, r19
    1dbe:	22 0f       	add	r18, r18
    1dc0:	33 1f       	adc	r19, r19
    1dc2:	22 0f       	add	r18, r18
    1dc4:	33 1f       	adc	r19, r19
    1dc6:	82 0f       	add	r24, r18
    1dc8:	93 1f       	adc	r25, r19
    1dca:	b8 01       	movw	r22, r16
    1dcc:	84 58       	subi	r24, 0x84	; 132
    1dce:	97 4f       	sbci	r25, 0xF7	; 247
    1dd0:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    1dd4:	e0 91 a9 08 	lds	r30, 0x08A9
    1dd8:	f0 91 aa 08 	lds	r31, 0x08AA
    1ddc:	9e 89       	ldd	r25, Y+22	; 0x16
    1dde:	86 89       	ldd	r24, Z+22	; 0x16
    1de0:	98 17       	cp	r25, r24
    1de2:	10 f0       	brcs	.+4      	; 0x1de8 <xTaskResumeAll+0xa2>
    1de4:	d0 92 43 08 	sts	0x0843, r13
    1de8:	f7 01       	movw	r30, r14
    1dea:	80 81       	ld	r24, Z
    1dec:	81 11       	cpse	r24, r1
    1dee:	cc cf       	rjmp	.-104    	; 0x1d88 <xTaskResumeAll+0x42>
    1df0:	80 91 44 08 	lds	r24, 0x0844
    1df4:	88 23       	and	r24, r24
    1df6:	91 f0       	breq	.+36     	; 0x1e1c <xTaskResumeAll+0xd6>
    1df8:	80 91 44 08 	lds	r24, 0x0844
    1dfc:	88 23       	and	r24, r24
    1dfe:	71 f0       	breq	.+28     	; 0x1e1c <xTaskResumeAll+0xd6>
    1e00:	c1 e0       	ldi	r28, 0x01	; 1
    1e02:	e3 de       	rcall	.-570    	; 0x1bca <xTaskIncrementTick>
    1e04:	81 11       	cpse	r24, r1
    1e06:	c0 93 43 08 	sts	0x0843, r28
    1e0a:	80 91 44 08 	lds	r24, 0x0844
    1e0e:	81 50       	subi	r24, 0x01	; 1
    1e10:	80 93 44 08 	sts	0x0844, r24
    1e14:	80 91 44 08 	lds	r24, 0x0844
    1e18:	81 11       	cpse	r24, r1
    1e1a:	f3 cf       	rjmp	.-26     	; 0x1e02 <xTaskResumeAll+0xbc>
    1e1c:	80 91 43 08 	lds	r24, 0x0843
    1e20:	81 30       	cpi	r24, 0x01	; 1
    1e22:	39 f4       	brne	.+14     	; 0x1e32 <xTaskResumeAll+0xec>
    1e24:	04 d9       	rcall	.-3576   	; 0x102e <vPortYield>
    1e26:	81 e0       	ldi	r24, 0x01	; 1
    1e28:	05 c0       	rjmp	.+10     	; 0x1e34 <xTaskResumeAll+0xee>
    1e2a:	80 e0       	ldi	r24, 0x00	; 0
    1e2c:	03 c0       	rjmp	.+6      	; 0x1e34 <xTaskResumeAll+0xee>
    1e2e:	80 e0       	ldi	r24, 0x00	; 0
    1e30:	01 c0       	rjmp	.+2      	; 0x1e34 <xTaskResumeAll+0xee>
    1e32:	80 e0       	ldi	r24, 0x00	; 0
    1e34:	0f 90       	pop	r0
    1e36:	0f be       	out	0x3f, r0	; 63
    1e38:	df 91       	pop	r29
    1e3a:	cf 91       	pop	r28
    1e3c:	1f 91       	pop	r17
    1e3e:	0f 91       	pop	r16
    1e40:	ff 90       	pop	r15
    1e42:	ef 90       	pop	r14
    1e44:	df 90       	pop	r13
    1e46:	08 95       	ret

00001e48 <vTaskDelayUntil>:
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	cf 93       	push	r28
    1e4e:	df 93       	push	r29
    1e50:	8c 01       	movw	r16, r24
    1e52:	eb 01       	movw	r28, r22
    1e54:	a5 de       	rcall	.-694    	; 0x1ba0 <vTaskSuspendAll>
    1e56:	80 91 47 08 	lds	r24, 0x0847
    1e5a:	90 91 48 08 	lds	r25, 0x0848
    1e5e:	f8 01       	movw	r30, r16
    1e60:	20 81       	ld	r18, Z
    1e62:	31 81       	ldd	r19, Z+1	; 0x01
    1e64:	c2 0f       	add	r28, r18
    1e66:	d3 1f       	adc	r29, r19
    1e68:	82 17       	cp	r24, r18
    1e6a:	93 07       	cpc	r25, r19
    1e6c:	48 f4       	brcc	.+18     	; 0x1e80 <vTaskDelayUntil+0x38>
    1e6e:	c2 17       	cp	r28, r18
    1e70:	d3 07       	cpc	r29, r19
    1e72:	f8 f4       	brcc	.+62     	; 0x1eb2 <vTaskDelayUntil+0x6a>
    1e74:	d1 83       	std	Z+1, r29	; 0x01
    1e76:	c0 83       	st	Z, r28
    1e78:	8c 17       	cp	r24, r28
    1e7a:	9d 07       	cpc	r25, r29
    1e7c:	88 f4       	brcc	.+34     	; 0x1ea0 <vTaskDelayUntil+0x58>
    1e7e:	07 c0       	rjmp	.+14     	; 0x1e8e <vTaskDelayUntil+0x46>
    1e80:	c2 17       	cp	r28, r18
    1e82:	d3 07       	cpc	r29, r19
    1e84:	90 f0       	brcs	.+36     	; 0x1eaa <vTaskDelayUntil+0x62>
    1e86:	8c 17       	cp	r24, r28
    1e88:	9d 07       	cpc	r25, r29
    1e8a:	78 f0       	brcs	.+30     	; 0x1eaa <vTaskDelayUntil+0x62>
    1e8c:	12 c0       	rjmp	.+36     	; 0x1eb2 <vTaskDelayUntil+0x6a>
    1e8e:	80 91 a9 08 	lds	r24, 0x08A9
    1e92:	90 91 aa 08 	lds	r25, 0x08AA
    1e96:	02 96       	adiw	r24, 0x02	; 2
    1e98:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1e9c:	ce 01       	movw	r24, r28
    1e9e:	c0 dc       	rcall	.-1664   	; 0x1820 <prvAddCurrentTaskToDelayedList>
    1ea0:	52 df       	rcall	.-348    	; 0x1d46 <xTaskResumeAll>
    1ea2:	81 11       	cpse	r24, r1
    1ea4:	0a c0       	rjmp	.+20     	; 0x1eba <vTaskDelayUntil+0x72>
    1ea6:	c3 d8       	rcall	.-3706   	; 0x102e <vPortYield>
    1ea8:	08 c0       	rjmp	.+16     	; 0x1eba <vTaskDelayUntil+0x72>
    1eaa:	f8 01       	movw	r30, r16
    1eac:	d1 83       	std	Z+1, r29	; 0x01
    1eae:	c0 83       	st	Z, r28
    1eb0:	ee cf       	rjmp	.-36     	; 0x1e8e <vTaskDelayUntil+0x46>
    1eb2:	f8 01       	movw	r30, r16
    1eb4:	d1 83       	std	Z+1, r29	; 0x01
    1eb6:	c0 83       	st	Z, r28
    1eb8:	f3 cf       	rjmp	.-26     	; 0x1ea0 <vTaskDelayUntil+0x58>
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	1f 91       	pop	r17
    1ec0:	0f 91       	pop	r16
    1ec2:	08 95       	ret

00001ec4 <vTaskDelay>:
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	ec 01       	movw	r28, r24
    1eca:	00 97       	sbiw	r24, 0x00	; 0
    1ecc:	99 f0       	breq	.+38     	; 0x1ef4 <vTaskDelay+0x30>
    1ece:	68 de       	rcall	.-816    	; 0x1ba0 <vTaskSuspendAll>
    1ed0:	80 91 47 08 	lds	r24, 0x0847
    1ed4:	90 91 48 08 	lds	r25, 0x0848
    1ed8:	c8 0f       	add	r28, r24
    1eda:	d9 1f       	adc	r29, r25
    1edc:	80 91 a9 08 	lds	r24, 0x08A9
    1ee0:	90 91 aa 08 	lds	r25, 0x08AA
    1ee4:	02 96       	adiw	r24, 0x02	; 2
    1ee6:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1eea:	ce 01       	movw	r24, r28
    1eec:	99 dc       	rcall	.-1742   	; 0x1820 <prvAddCurrentTaskToDelayedList>
    1eee:	2b df       	rcall	.-426    	; 0x1d46 <xTaskResumeAll>
    1ef0:	81 11       	cpse	r24, r1
    1ef2:	01 c0       	rjmp	.+2      	; 0x1ef6 <vTaskDelay+0x32>
    1ef4:	9c d8       	rcall	.-3784   	; 0x102e <vPortYield>
    1ef6:	df 91       	pop	r29
    1ef8:	cf 91       	pop	r28
    1efa:	08 95       	ret

00001efc <prvIdleTask>:
    1efc:	0f 2e       	mov	r0, r31
    1efe:	fc e7       	ldi	r31, 0x7C	; 124
    1f00:	ef 2e       	mov	r14, r31
    1f02:	f8 e0       	ldi	r31, 0x08	; 8
    1f04:	ff 2e       	mov	r15, r31
    1f06:	f0 2d       	mov	r31, r0
    1f08:	c4 e5       	ldi	r28, 0x54	; 84
    1f0a:	d8 e0       	ldi	r29, 0x08	; 8
    1f0c:	26 c0       	rjmp	.+76     	; 0x1f5a <prvIdleTask+0x5e>
    1f0e:	48 de       	rcall	.-880    	; 0x1ba0 <vTaskSuspendAll>
    1f10:	18 81       	ld	r17, Y
    1f12:	19 df       	rcall	.-462    	; 0x1d46 <xTaskResumeAll>
    1f14:	11 23       	and	r17, r17
    1f16:	09 f1       	breq	.+66     	; 0x1f5a <prvIdleTask+0x5e>
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	0f 92       	push	r0
    1f1e:	e0 91 59 08 	lds	r30, 0x0859
    1f22:	f0 91 5a 08 	lds	r31, 0x085A
    1f26:	06 81       	ldd	r16, Z+6	; 0x06
    1f28:	17 81       	ldd	r17, Z+7	; 0x07
    1f2a:	c8 01       	movw	r24, r16
    1f2c:	02 96       	adiw	r24, 0x02	; 2
    1f2e:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    1f32:	80 91 49 08 	lds	r24, 0x0849
    1f36:	81 50       	subi	r24, 0x01	; 1
    1f38:	80 93 49 08 	sts	0x0849, r24
    1f3c:	80 91 53 08 	lds	r24, 0x0853
    1f40:	81 50       	subi	r24, 0x01	; 1
    1f42:	80 93 53 08 	sts	0x0853, r24
    1f46:	0f 90       	pop	r0
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	f8 01       	movw	r30, r16
    1f4c:	87 89       	ldd	r24, Z+23	; 0x17
    1f4e:	90 8d       	ldd	r25, Z+24	; 0x18
    1f50:	0e 94 ce 02 	call	0x59c	; 0x59c <vPortFree>
    1f54:	c8 01       	movw	r24, r16
    1f56:	0e 94 ce 02 	call	0x59c	; 0x59c <vPortFree>
    1f5a:	80 91 53 08 	lds	r24, 0x0853
    1f5e:	81 11       	cpse	r24, r1
    1f60:	d6 cf       	rjmp	.-84     	; 0x1f0e <prvIdleTask+0x12>
    1f62:	f7 01       	movw	r30, r14
    1f64:	80 81       	ld	r24, Z
    1f66:	82 30       	cpi	r24, 0x02	; 2
    1f68:	c0 f3       	brcs	.-16     	; 0x1f5a <prvIdleTask+0x5e>
    1f6a:	61 d8       	rcall	.-3902   	; 0x102e <vPortYield>
    1f6c:	f6 cf       	rjmp	.-20     	; 0x1f5a <prvIdleTask+0x5e>

00001f6e <vTaskSwitchContext>:
    1f6e:	80 91 40 08 	lds	r24, 0x0840
    1f72:	88 23       	and	r24, r24
    1f74:	21 f0       	breq	.+8      	; 0x1f7e <vTaskSwitchContext+0x10>
    1f76:	81 e0       	ldi	r24, 0x01	; 1
    1f78:	80 93 43 08 	sts	0x0843, r24
    1f7c:	08 95       	ret
    1f7e:	10 92 43 08 	sts	0x0843, r1
    1f82:	80 91 46 08 	lds	r24, 0x0846
    1f86:	90 e0       	ldi	r25, 0x00	; 0
    1f88:	fc 01       	movw	r30, r24
    1f8a:	ee 0f       	add	r30, r30
    1f8c:	ff 1f       	adc	r31, r31
    1f8e:	ee 0f       	add	r30, r30
    1f90:	ff 1f       	adc	r31, r31
    1f92:	ee 0f       	add	r30, r30
    1f94:	ff 1f       	adc	r31, r31
    1f96:	8e 0f       	add	r24, r30
    1f98:	9f 1f       	adc	r25, r31
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	e4 58       	subi	r30, 0x84	; 132
    1f9e:	f7 4f       	sbci	r31, 0xF7	; 247
    1fa0:	80 81       	ld	r24, Z
    1fa2:	81 11       	cpse	r24, r1
    1fa4:	17 c0       	rjmp	.+46     	; 0x1fd4 <vTaskSwitchContext+0x66>
    1fa6:	80 91 46 08 	lds	r24, 0x0846
    1faa:	81 50       	subi	r24, 0x01	; 1
    1fac:	80 93 46 08 	sts	0x0846, r24
    1fb0:	80 91 46 08 	lds	r24, 0x0846
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	ee 0f       	add	r30, r30
    1fba:	ff 1f       	adc	r31, r31
    1fbc:	ee 0f       	add	r30, r30
    1fbe:	ff 1f       	adc	r31, r31
    1fc0:	ee 0f       	add	r30, r30
    1fc2:	ff 1f       	adc	r31, r31
    1fc4:	8e 0f       	add	r24, r30
    1fc6:	9f 1f       	adc	r25, r31
    1fc8:	fc 01       	movw	r30, r24
    1fca:	e4 58       	subi	r30, 0x84	; 132
    1fcc:	f7 4f       	sbci	r31, 0xF7	; 247
    1fce:	80 81       	ld	r24, Z
    1fd0:	88 23       	and	r24, r24
    1fd2:	49 f3       	breq	.-46     	; 0x1fa6 <vTaskSwitchContext+0x38>
    1fd4:	e0 91 46 08 	lds	r30, 0x0846
    1fd8:	f0 e0       	ldi	r31, 0x00	; 0
    1fda:	cf 01       	movw	r24, r30
    1fdc:	88 0f       	add	r24, r24
    1fde:	99 1f       	adc	r25, r25
    1fe0:	88 0f       	add	r24, r24
    1fe2:	99 1f       	adc	r25, r25
    1fe4:	88 0f       	add	r24, r24
    1fe6:	99 1f       	adc	r25, r25
    1fe8:	e8 0f       	add	r30, r24
    1fea:	f9 1f       	adc	r31, r25
    1fec:	e4 58       	subi	r30, 0x84	; 132
    1fee:	f7 4f       	sbci	r31, 0xF7	; 247
    1ff0:	a1 81       	ldd	r26, Z+1	; 0x01
    1ff2:	b2 81       	ldd	r27, Z+2	; 0x02
    1ff4:	12 96       	adiw	r26, 0x02	; 2
    1ff6:	0d 90       	ld	r0, X+
    1ff8:	bc 91       	ld	r27, X
    1ffa:	a0 2d       	mov	r26, r0
    1ffc:	b2 83       	std	Z+2, r27	; 0x02
    1ffe:	a1 83       	std	Z+1, r26	; 0x01
    2000:	cf 01       	movw	r24, r30
    2002:	03 96       	adiw	r24, 0x03	; 3
    2004:	a8 17       	cp	r26, r24
    2006:	b9 07       	cpc	r27, r25
    2008:	31 f4       	brne	.+12     	; 0x2016 <vTaskSwitchContext+0xa8>
    200a:	12 96       	adiw	r26, 0x02	; 2
    200c:	8d 91       	ld	r24, X+
    200e:	9c 91       	ld	r25, X
    2010:	13 97       	sbiw	r26, 0x03	; 3
    2012:	92 83       	std	Z+2, r25	; 0x02
    2014:	81 83       	std	Z+1, r24	; 0x01
    2016:	01 80       	ldd	r0, Z+1	; 0x01
    2018:	f2 81       	ldd	r31, Z+2	; 0x02
    201a:	e0 2d       	mov	r30, r0
    201c:	86 81       	ldd	r24, Z+6	; 0x06
    201e:	97 81       	ldd	r25, Z+7	; 0x07
    2020:	90 93 aa 08 	sts	0x08AA, r25
    2024:	80 93 a9 08 	sts	0x08A9, r24
    2028:	08 95       	ret

0000202a <vTaskSuspend>:
    202a:	0f 93       	push	r16
    202c:	1f 93       	push	r17
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	ec 01       	movw	r28, r24
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	f8 94       	cli
    2038:	0f 92       	push	r0
    203a:	00 97       	sbiw	r24, 0x00	; 0
    203c:	21 f4       	brne	.+8      	; 0x2046 <vTaskSuspend+0x1c>
    203e:	c0 91 a9 08 	lds	r28, 0x08A9
    2042:	d0 91 aa 08 	lds	r29, 0x08AA
    2046:	8e 01       	movw	r16, r28
    2048:	0e 5f       	subi	r16, 0xFE	; 254
    204a:	1f 4f       	sbci	r17, 0xFF	; 255
    204c:	c8 01       	movw	r24, r16
    204e:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    2052:	8c 89       	ldd	r24, Y+20	; 0x14
    2054:	9d 89       	ldd	r25, Y+21	; 0x15
    2056:	89 2b       	or	r24, r25
    2058:	21 f0       	breq	.+8      	; 0x2062 <vTaskSuspend+0x38>
    205a:	ce 01       	movw	r24, r28
    205c:	0c 96       	adiw	r24, 0x0c	; 12
    205e:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    2062:	b8 01       	movw	r22, r16
    2064:	8a e4       	ldi	r24, 0x4A	; 74
    2066:	98 e0       	ldi	r25, 0x08	; 8
    2068:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63
    2070:	80 91 a9 08 	lds	r24, 0x08A9
    2074:	90 91 aa 08 	lds	r25, 0x08AA
    2078:	c8 17       	cp	r28, r24
    207a:	d9 07       	cpc	r29, r25
    207c:	a1 f4       	brne	.+40     	; 0x20a6 <vTaskSuspend+0x7c>
    207e:	80 91 45 08 	lds	r24, 0x0845
    2082:	88 23       	and	r24, r24
    2084:	19 f0       	breq	.+6      	; 0x208c <vTaskSuspend+0x62>
    2086:	0e 94 17 08 	call	0x102e	; 0x102e <vPortYield>
    208a:	17 c0       	rjmp	.+46     	; 0x20ba <vTaskSuspend+0x90>
    208c:	80 91 49 08 	lds	r24, 0x0849
    2090:	90 91 4a 08 	lds	r25, 0x084A
    2094:	98 13       	cpse	r25, r24
    2096:	05 c0       	rjmp	.+10     	; 0x20a2 <vTaskSuspend+0x78>
    2098:	10 92 aa 08 	sts	0x08AA, r1
    209c:	10 92 a9 08 	sts	0x08A9, r1
    20a0:	0c c0       	rjmp	.+24     	; 0x20ba <vTaskSuspend+0x90>
    20a2:	65 df       	rcall	.-310    	; 0x1f6e <vTaskSwitchContext>
    20a4:	0a c0       	rjmp	.+20     	; 0x20ba <vTaskSuspend+0x90>
    20a6:	80 91 45 08 	lds	r24, 0x0845
    20aa:	88 23       	and	r24, r24
    20ac:	31 f0       	breq	.+12     	; 0x20ba <vTaskSuspend+0x90>
    20ae:	0f b6       	in	r0, 0x3f	; 63
    20b0:	f8 94       	cli
    20b2:	0f 92       	push	r0
    20b4:	96 db       	rcall	.-2260   	; 0x17e2 <prvResetNextTaskUnblockTime>
    20b6:	0f 90       	pop	r0
    20b8:	0f be       	out	0x3f, r0	; 63
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	08 95       	ret

000020c4 <vTaskPlaceOnEventList>:
    20c4:	cf 93       	push	r28
    20c6:	df 93       	push	r29
    20c8:	eb 01       	movw	r28, r22
    20ca:	60 91 a9 08 	lds	r22, 0x08A9
    20ce:	70 91 aa 08 	lds	r23, 0x08AA
    20d2:	64 5f       	subi	r22, 0xF4	; 244
    20d4:	7f 4f       	sbci	r23, 0xFF	; 255
    20d6:	0e 94 02 03 	call	0x604	; 0x604 <vListInsert>
    20da:	80 91 a9 08 	lds	r24, 0x08A9
    20de:	90 91 aa 08 	lds	r25, 0x08AA
    20e2:	02 96       	adiw	r24, 0x02	; 2
    20e4:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    20e8:	cf 3f       	cpi	r28, 0xFF	; 255
    20ea:	8f ef       	ldi	r24, 0xFF	; 255
    20ec:	d8 07       	cpc	r29, r24
    20ee:	59 f4       	brne	.+22     	; 0x2106 <vTaskPlaceOnEventList+0x42>
    20f0:	60 91 a9 08 	lds	r22, 0x08A9
    20f4:	70 91 aa 08 	lds	r23, 0x08AA
    20f8:	6e 5f       	subi	r22, 0xFE	; 254
    20fa:	7f 4f       	sbci	r23, 0xFF	; 255
    20fc:	8a e4       	ldi	r24, 0x4A	; 74
    20fe:	98 e0       	ldi	r25, 0x08	; 8
    2100:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    2104:	07 c0       	rjmp	.+14     	; 0x2114 <vTaskPlaceOnEventList+0x50>
    2106:	80 91 47 08 	lds	r24, 0x0847
    210a:	90 91 48 08 	lds	r25, 0x0848
    210e:	8c 0f       	add	r24, r28
    2110:	9d 1f       	adc	r25, r29
    2112:	86 db       	rcall	.-2292   	; 0x1820 <prvAddCurrentTaskToDelayedList>
    2114:	df 91       	pop	r29
    2116:	cf 91       	pop	r28
    2118:	08 95       	ret

0000211a <xTaskRemoveFromEventList>:
    211a:	0f 93       	push	r16
    211c:	1f 93       	push	r17
    211e:	cf 93       	push	r28
    2120:	df 93       	push	r29
    2122:	dc 01       	movw	r26, r24
    2124:	15 96       	adiw	r26, 0x05	; 5
    2126:	ed 91       	ld	r30, X+
    2128:	fc 91       	ld	r31, X
    212a:	16 97       	sbiw	r26, 0x06	; 6
    212c:	c6 81       	ldd	r28, Z+6	; 0x06
    212e:	d7 81       	ldd	r29, Z+7	; 0x07
    2130:	8e 01       	movw	r16, r28
    2132:	04 5f       	subi	r16, 0xF4	; 244
    2134:	1f 4f       	sbci	r17, 0xFF	; 255
    2136:	c8 01       	movw	r24, r16
    2138:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    213c:	80 91 40 08 	lds	r24, 0x0840
    2140:	81 11       	cpse	r24, r1
    2142:	1c c0       	rjmp	.+56     	; 0x217c <xTaskRemoveFromEventList+0x62>
    2144:	0a 50       	subi	r16, 0x0A	; 10
    2146:	11 09       	sbc	r17, r1
    2148:	c8 01       	movw	r24, r16
    214a:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    214e:	8e 89       	ldd	r24, Y+22	; 0x16
    2150:	90 91 46 08 	lds	r25, 0x0846
    2154:	98 17       	cp	r25, r24
    2156:	10 f4       	brcc	.+4      	; 0x215c <xTaskRemoveFromEventList+0x42>
    2158:	80 93 46 08 	sts	0x0846, r24
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	9c 01       	movw	r18, r24
    2160:	22 0f       	add	r18, r18
    2162:	33 1f       	adc	r19, r19
    2164:	22 0f       	add	r18, r18
    2166:	33 1f       	adc	r19, r19
    2168:	22 0f       	add	r18, r18
    216a:	33 1f       	adc	r19, r19
    216c:	82 0f       	add	r24, r18
    216e:	93 1f       	adc	r25, r19
    2170:	b8 01       	movw	r22, r16
    2172:	84 58       	subi	r24, 0x84	; 132
    2174:	97 4f       	sbci	r25, 0xF7	; 247
    2176:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    217a:	05 c0       	rjmp	.+10     	; 0x2186 <xTaskRemoveFromEventList+0x6c>
    217c:	b8 01       	movw	r22, r16
    217e:	8d e5       	ldi	r24, 0x5D	; 93
    2180:	98 e0       	ldi	r25, 0x08	; 8
    2182:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    2186:	e0 91 a9 08 	lds	r30, 0x08A9
    218a:	f0 91 aa 08 	lds	r31, 0x08AA
    218e:	9e 89       	ldd	r25, Y+22	; 0x16
    2190:	86 89       	ldd	r24, Z+22	; 0x16
    2192:	89 17       	cp	r24, r25
    2194:	20 f4       	brcc	.+8      	; 0x219e <xTaskRemoveFromEventList+0x84>
    2196:	81 e0       	ldi	r24, 0x01	; 1
    2198:	80 93 43 08 	sts	0x0843, r24
    219c:	01 c0       	rjmp	.+2      	; 0x21a0 <xTaskRemoveFromEventList+0x86>
    219e:	80 e0       	ldi	r24, 0x00	; 0
    21a0:	df 91       	pop	r29
    21a2:	cf 91       	pop	r28
    21a4:	1f 91       	pop	r17
    21a6:	0f 91       	pop	r16
    21a8:	08 95       	ret

000021aa <vTaskSetTimeOutState>:
    21aa:	20 91 42 08 	lds	r18, 0x0842
    21ae:	fc 01       	movw	r30, r24
    21b0:	20 83       	st	Z, r18
    21b2:	20 91 47 08 	lds	r18, 0x0847
    21b6:	30 91 48 08 	lds	r19, 0x0848
    21ba:	32 83       	std	Z+2, r19	; 0x02
    21bc:	21 83       	std	Z+1, r18	; 0x01
    21be:	08 95       	ret

000021c0 <xTaskCheckForTimeOut>:
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	0f 92       	push	r0
    21c6:	40 91 47 08 	lds	r20, 0x0847
    21ca:	50 91 48 08 	lds	r21, 0x0848
    21ce:	db 01       	movw	r26, r22
    21d0:	2d 91       	ld	r18, X+
    21d2:	3c 91       	ld	r19, X
    21d4:	2f 3f       	cpi	r18, 0xFF	; 255
    21d6:	bf ef       	ldi	r27, 0xFF	; 255
    21d8:	3b 07       	cpc	r19, r27
    21da:	11 f1       	breq	.+68     	; 0x2220 <__stack+0x21>
    21dc:	e0 91 42 08 	lds	r30, 0x0842
    21e0:	dc 01       	movw	r26, r24
    21e2:	fc 91       	ld	r31, X
    21e4:	fe 17       	cp	r31, r30
    21e6:	39 f0       	breq	.+14     	; 0x21f6 <xTaskCheckForTimeOut+0x36>
    21e8:	11 96       	adiw	r26, 0x01	; 1
    21ea:	ed 91       	ld	r30, X+
    21ec:	fc 91       	ld	r31, X
    21ee:	12 97       	sbiw	r26, 0x02	; 2
    21f0:	4e 17       	cp	r20, r30
    21f2:	5f 07       	cpc	r21, r31
    21f4:	b8 f4       	brcc	.+46     	; 0x2224 <__stack+0x25>
    21f6:	dc 01       	movw	r26, r24
    21f8:	11 96       	adiw	r26, 0x01	; 1
    21fa:	ed 91       	ld	r30, X+
    21fc:	fc 91       	ld	r31, X
    21fe:	12 97       	sbiw	r26, 0x02	; 2
    2200:	da 01       	movw	r26, r20
    2202:	ae 1b       	sub	r26, r30
    2204:	bf 0b       	sbc	r27, r31
    2206:	a2 17       	cp	r26, r18
    2208:	b3 07       	cpc	r27, r19
    220a:	70 f4       	brcc	.+28     	; 0x2228 <__stack+0x29>
    220c:	e4 1b       	sub	r30, r20
    220e:	f5 0b       	sbc	r31, r21
    2210:	2e 0f       	add	r18, r30
    2212:	3f 1f       	adc	r19, r31
    2214:	fb 01       	movw	r30, r22
    2216:	31 83       	std	Z+1, r19	; 0x01
    2218:	20 83       	st	Z, r18
    221a:	c7 df       	rcall	.-114    	; 0x21aa <vTaskSetTimeOutState>
    221c:	80 e0       	ldi	r24, 0x00	; 0
    221e:	05 c0       	rjmp	.+10     	; 0x222a <__stack+0x2b>
    2220:	80 e0       	ldi	r24, 0x00	; 0
    2222:	03 c0       	rjmp	.+6      	; 0x222a <__stack+0x2b>
    2224:	81 e0       	ldi	r24, 0x01	; 1
    2226:	01 c0       	rjmp	.+2      	; 0x222a <__stack+0x2b>
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	0f 90       	pop	r0
    222c:	0f be       	out	0x3f, r0	; 63
    222e:	08 95       	ret

00002230 <vTaskMissedYield>:
    2230:	81 e0       	ldi	r24, 0x01	; 1
    2232:	80 93 43 08 	sts	0x0843, r24
    2236:	08 95       	ret

00002238 <vTaskPriorityInherit>:
    2238:	0f 93       	push	r16
    223a:	1f 93       	push	r17
    223c:	cf 93       	push	r28
    223e:	df 93       	push	r29
    2240:	ec 01       	movw	r28, r24
    2242:	00 97       	sbiw	r24, 0x00	; 0
    2244:	09 f4       	brne	.+2      	; 0x2248 <vTaskPriorityInherit+0x10>
    2246:	51 c0       	rjmp	.+162    	; 0x22ea <vTaskPriorityInherit+0xb2>
    2248:	8e 89       	ldd	r24, Y+22	; 0x16
    224a:	e0 91 a9 08 	lds	r30, 0x08A9
    224e:	f0 91 aa 08 	lds	r31, 0x08AA
    2252:	96 89       	ldd	r25, Z+22	; 0x16
    2254:	89 17       	cp	r24, r25
    2256:	08 f0       	brcs	.+2      	; 0x225a <vTaskPriorityInherit+0x22>
    2258:	48 c0       	rjmp	.+144    	; 0x22ea <vTaskPriorityInherit+0xb2>
    225a:	2c 85       	ldd	r18, Y+12	; 0x0c
    225c:	3d 85       	ldd	r19, Y+13	; 0x0d
    225e:	33 23       	and	r19, r19
    2260:	5c f0       	brlt	.+22     	; 0x2278 <vTaskPriorityInherit+0x40>
    2262:	e0 91 a9 08 	lds	r30, 0x08A9
    2266:	f0 91 aa 08 	lds	r31, 0x08AA
    226a:	96 89       	ldd	r25, Z+22	; 0x16
    226c:	25 e0       	ldi	r18, 0x05	; 5
    226e:	30 e0       	ldi	r19, 0x00	; 0
    2270:	29 1b       	sub	r18, r25
    2272:	31 09       	sbc	r19, r1
    2274:	3d 87       	std	Y+13, r19	; 0x0d
    2276:	2c 87       	std	Y+12, r18	; 0x0c
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	9c 01       	movw	r18, r24
    227c:	22 0f       	add	r18, r18
    227e:	33 1f       	adc	r19, r19
    2280:	22 0f       	add	r18, r18
    2282:	33 1f       	adc	r19, r19
    2284:	22 0f       	add	r18, r18
    2286:	33 1f       	adc	r19, r19
    2288:	82 0f       	add	r24, r18
    228a:	93 1f       	adc	r25, r19
    228c:	84 58       	subi	r24, 0x84	; 132
    228e:	97 4f       	sbci	r25, 0xF7	; 247
    2290:	2a 85       	ldd	r18, Y+10	; 0x0a
    2292:	3b 85       	ldd	r19, Y+11	; 0x0b
    2294:	28 17       	cp	r18, r24
    2296:	39 07       	cpc	r19, r25
    2298:	11 f5       	brne	.+68     	; 0x22de <vTaskPriorityInherit+0xa6>
    229a:	8e 01       	movw	r16, r28
    229c:	0e 5f       	subi	r16, 0xFE	; 254
    229e:	1f 4f       	sbci	r17, 0xFF	; 255
    22a0:	c8 01       	movw	r24, r16
    22a2:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    22a6:	e0 91 a9 08 	lds	r30, 0x08A9
    22aa:	f0 91 aa 08 	lds	r31, 0x08AA
    22ae:	86 89       	ldd	r24, Z+22	; 0x16
    22b0:	8e 8b       	std	Y+22, r24	; 0x16
    22b2:	90 91 46 08 	lds	r25, 0x0846
    22b6:	98 17       	cp	r25, r24
    22b8:	10 f4       	brcc	.+4      	; 0x22be <vTaskPriorityInherit+0x86>
    22ba:	80 93 46 08 	sts	0x0846, r24
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	9c 01       	movw	r18, r24
    22c2:	22 0f       	add	r18, r18
    22c4:	33 1f       	adc	r19, r19
    22c6:	22 0f       	add	r18, r18
    22c8:	33 1f       	adc	r19, r19
    22ca:	22 0f       	add	r18, r18
    22cc:	33 1f       	adc	r19, r19
    22ce:	82 0f       	add	r24, r18
    22d0:	93 1f       	adc	r25, r19
    22d2:	b8 01       	movw	r22, r16
    22d4:	84 58       	subi	r24, 0x84	; 132
    22d6:	97 4f       	sbci	r25, 0xF7	; 247
    22d8:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    22dc:	06 c0       	rjmp	.+12     	; 0x22ea <vTaskPriorityInherit+0xb2>
    22de:	e0 91 a9 08 	lds	r30, 0x08A9
    22e2:	f0 91 aa 08 	lds	r31, 0x08AA
    22e6:	86 89       	ldd	r24, Z+22	; 0x16
    22e8:	8e 8b       	std	Y+22, r24	; 0x16
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	1f 91       	pop	r17
    22f0:	0f 91       	pop	r16
    22f2:	08 95       	ret

000022f4 <xTaskPriorityDisinherit>:
    22f4:	0f 93       	push	r16
    22f6:	1f 93       	push	r17
    22f8:	cf 93       	push	r28
    22fa:	df 93       	push	r29
    22fc:	ec 01       	movw	r28, r24
    22fe:	00 97       	sbiw	r24, 0x00	; 0
    2300:	71 f1       	breq	.+92     	; 0x235e <xTaskPriorityDisinherit+0x6a>
    2302:	8a a1       	ldd	r24, Y+34	; 0x22
    2304:	81 50       	subi	r24, 0x01	; 1
    2306:	8a a3       	std	Y+34, r24	; 0x22
    2308:	2e 89       	ldd	r18, Y+22	; 0x16
    230a:	99 a1       	ldd	r25, Y+33	; 0x21
    230c:	29 17       	cp	r18, r25
    230e:	49 f1       	breq	.+82     	; 0x2362 <xTaskPriorityDisinherit+0x6e>
    2310:	81 11       	cpse	r24, r1
    2312:	29 c0       	rjmp	.+82     	; 0x2366 <xTaskPriorityDisinherit+0x72>
    2314:	8e 01       	movw	r16, r28
    2316:	0e 5f       	subi	r16, 0xFE	; 254
    2318:	1f 4f       	sbci	r17, 0xFF	; 255
    231a:	c8 01       	movw	r24, r16
    231c:	0e 94 33 03 	call	0x666	; 0x666 <uxListRemove>
    2320:	89 a1       	ldd	r24, Y+33	; 0x21
    2322:	8e 8b       	std	Y+22, r24	; 0x16
    2324:	25 e0       	ldi	r18, 0x05	; 5
    2326:	30 e0       	ldi	r19, 0x00	; 0
    2328:	28 1b       	sub	r18, r24
    232a:	31 09       	sbc	r19, r1
    232c:	3d 87       	std	Y+13, r19	; 0x0d
    232e:	2c 87       	std	Y+12, r18	; 0x0c
    2330:	90 91 46 08 	lds	r25, 0x0846
    2334:	98 17       	cp	r25, r24
    2336:	10 f4       	brcc	.+4      	; 0x233c <xTaskPriorityDisinherit+0x48>
    2338:	80 93 46 08 	sts	0x0846, r24
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	9c 01       	movw	r18, r24
    2340:	22 0f       	add	r18, r18
    2342:	33 1f       	adc	r19, r19
    2344:	22 0f       	add	r18, r18
    2346:	33 1f       	adc	r19, r19
    2348:	22 0f       	add	r18, r18
    234a:	33 1f       	adc	r19, r19
    234c:	82 0f       	add	r24, r18
    234e:	93 1f       	adc	r25, r19
    2350:	b8 01       	movw	r22, r16
    2352:	84 58       	subi	r24, 0x84	; 132
    2354:	97 4f       	sbci	r25, 0xF7	; 247
    2356:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vListInsertEnd>
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	05 c0       	rjmp	.+10     	; 0x2368 <xTaskPriorityDisinherit+0x74>
    235e:	80 e0       	ldi	r24, 0x00	; 0
    2360:	03 c0       	rjmp	.+6      	; 0x2368 <xTaskPriorityDisinherit+0x74>
    2362:	80 e0       	ldi	r24, 0x00	; 0
    2364:	01 c0       	rjmp	.+2      	; 0x2368 <xTaskPriorityDisinherit+0x74>
    2366:	80 e0       	ldi	r24, 0x00	; 0
    2368:	df 91       	pop	r29
    236a:	cf 91       	pop	r28
    236c:	1f 91       	pop	r17
    236e:	0f 91       	pop	r16
    2370:	08 95       	ret

00002372 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2372:	80 91 a9 08 	lds	r24, 0x08A9
    2376:	90 91 aa 08 	lds	r25, 0x08AA
    237a:	89 2b       	or	r24, r25
    237c:	39 f0       	breq	.+14     	; 0x238c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    237e:	e0 91 a9 08 	lds	r30, 0x08A9
    2382:	f0 91 aa 08 	lds	r31, 0x08AA
    2386:	82 a1       	ldd	r24, Z+34	; 0x22
    2388:	8f 5f       	subi	r24, 0xFF	; 255
    238a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    238c:	80 91 a9 08 	lds	r24, 0x08A9
    2390:	90 91 aa 08 	lds	r25, 0x08AA
	}
    2394:	08 95       	ret

00002396 <__subsf3>:
    2396:	50 58       	subi	r21, 0x80	; 128

00002398 <__addsf3>:
    2398:	bb 27       	eor	r27, r27
    239a:	aa 27       	eor	r26, r26
    239c:	0e d0       	rcall	.+28     	; 0x23ba <__addsf3x>
    239e:	e5 c0       	rjmp	.+458    	; 0x256a <__fp_round>
    23a0:	d6 d0       	rcall	.+428    	; 0x254e <__fp_pscA>
    23a2:	30 f0       	brcs	.+12     	; 0x23b0 <__addsf3+0x18>
    23a4:	db d0       	rcall	.+438    	; 0x255c <__fp_pscB>
    23a6:	20 f0       	brcs	.+8      	; 0x23b0 <__addsf3+0x18>
    23a8:	31 f4       	brne	.+12     	; 0x23b6 <__addsf3+0x1e>
    23aa:	9f 3f       	cpi	r25, 0xFF	; 255
    23ac:	11 f4       	brne	.+4      	; 0x23b2 <__addsf3+0x1a>
    23ae:	1e f4       	brtc	.+6      	; 0x23b6 <__addsf3+0x1e>
    23b0:	cb c0       	rjmp	.+406    	; 0x2548 <__fp_nan>
    23b2:	0e f4       	brtc	.+2      	; 0x23b6 <__addsf3+0x1e>
    23b4:	e0 95       	com	r30
    23b6:	e7 fb       	bst	r30, 7
    23b8:	c1 c0       	rjmp	.+386    	; 0x253c <__fp_inf>

000023ba <__addsf3x>:
    23ba:	e9 2f       	mov	r30, r25
    23bc:	e7 d0       	rcall	.+462    	; 0x258c <__fp_split3>
    23be:	80 f3       	brcs	.-32     	; 0x23a0 <__addsf3+0x8>
    23c0:	ba 17       	cp	r27, r26
    23c2:	62 07       	cpc	r22, r18
    23c4:	73 07       	cpc	r23, r19
    23c6:	84 07       	cpc	r24, r20
    23c8:	95 07       	cpc	r25, r21
    23ca:	18 f0       	brcs	.+6      	; 0x23d2 <__addsf3x+0x18>
    23cc:	71 f4       	brne	.+28     	; 0x23ea <__addsf3x+0x30>
    23ce:	9e f5       	brtc	.+102    	; 0x2436 <__addsf3x+0x7c>
    23d0:	ff c0       	rjmp	.+510    	; 0x25d0 <__fp_zero>
    23d2:	0e f4       	brtc	.+2      	; 0x23d6 <__addsf3x+0x1c>
    23d4:	e0 95       	com	r30
    23d6:	0b 2e       	mov	r0, r27
    23d8:	ba 2f       	mov	r27, r26
    23da:	a0 2d       	mov	r26, r0
    23dc:	0b 01       	movw	r0, r22
    23de:	b9 01       	movw	r22, r18
    23e0:	90 01       	movw	r18, r0
    23e2:	0c 01       	movw	r0, r24
    23e4:	ca 01       	movw	r24, r20
    23e6:	a0 01       	movw	r20, r0
    23e8:	11 24       	eor	r1, r1
    23ea:	ff 27       	eor	r31, r31
    23ec:	59 1b       	sub	r21, r25
    23ee:	99 f0       	breq	.+38     	; 0x2416 <__addsf3x+0x5c>
    23f0:	59 3f       	cpi	r21, 0xF9	; 249
    23f2:	50 f4       	brcc	.+20     	; 0x2408 <__addsf3x+0x4e>
    23f4:	50 3e       	cpi	r21, 0xE0	; 224
    23f6:	68 f1       	brcs	.+90     	; 0x2452 <__addsf3x+0x98>
    23f8:	1a 16       	cp	r1, r26
    23fa:	f0 40       	sbci	r31, 0x00	; 0
    23fc:	a2 2f       	mov	r26, r18
    23fe:	23 2f       	mov	r18, r19
    2400:	34 2f       	mov	r19, r20
    2402:	44 27       	eor	r20, r20
    2404:	58 5f       	subi	r21, 0xF8	; 248
    2406:	f3 cf       	rjmp	.-26     	; 0x23ee <__addsf3x+0x34>
    2408:	46 95       	lsr	r20
    240a:	37 95       	ror	r19
    240c:	27 95       	ror	r18
    240e:	a7 95       	ror	r26
    2410:	f0 40       	sbci	r31, 0x00	; 0
    2412:	53 95       	inc	r21
    2414:	c9 f7       	brne	.-14     	; 0x2408 <__addsf3x+0x4e>
    2416:	7e f4       	brtc	.+30     	; 0x2436 <__addsf3x+0x7c>
    2418:	1f 16       	cp	r1, r31
    241a:	ba 0b       	sbc	r27, r26
    241c:	62 0b       	sbc	r22, r18
    241e:	73 0b       	sbc	r23, r19
    2420:	84 0b       	sbc	r24, r20
    2422:	ba f0       	brmi	.+46     	; 0x2452 <__addsf3x+0x98>
    2424:	91 50       	subi	r25, 0x01	; 1
    2426:	a1 f0       	breq	.+40     	; 0x2450 <__addsf3x+0x96>
    2428:	ff 0f       	add	r31, r31
    242a:	bb 1f       	adc	r27, r27
    242c:	66 1f       	adc	r22, r22
    242e:	77 1f       	adc	r23, r23
    2430:	88 1f       	adc	r24, r24
    2432:	c2 f7       	brpl	.-16     	; 0x2424 <__addsf3x+0x6a>
    2434:	0e c0       	rjmp	.+28     	; 0x2452 <__addsf3x+0x98>
    2436:	ba 0f       	add	r27, r26
    2438:	62 1f       	adc	r22, r18
    243a:	73 1f       	adc	r23, r19
    243c:	84 1f       	adc	r24, r20
    243e:	48 f4       	brcc	.+18     	; 0x2452 <__addsf3x+0x98>
    2440:	87 95       	ror	r24
    2442:	77 95       	ror	r23
    2444:	67 95       	ror	r22
    2446:	b7 95       	ror	r27
    2448:	f7 95       	ror	r31
    244a:	9e 3f       	cpi	r25, 0xFE	; 254
    244c:	08 f0       	brcs	.+2      	; 0x2450 <__addsf3x+0x96>
    244e:	b3 cf       	rjmp	.-154    	; 0x23b6 <__addsf3+0x1e>
    2450:	93 95       	inc	r25
    2452:	88 0f       	add	r24, r24
    2454:	08 f0       	brcs	.+2      	; 0x2458 <__addsf3x+0x9e>
    2456:	99 27       	eor	r25, r25
    2458:	ee 0f       	add	r30, r30
    245a:	97 95       	ror	r25
    245c:	87 95       	ror	r24
    245e:	08 95       	ret

00002460 <__fixsfsi>:
    2460:	04 d0       	rcall	.+8      	; 0x246a <__fixunssfsi>
    2462:	68 94       	set
    2464:	b1 11       	cpse	r27, r1
    2466:	b5 c0       	rjmp	.+362    	; 0x25d2 <__fp_szero>
    2468:	08 95       	ret

0000246a <__fixunssfsi>:
    246a:	98 d0       	rcall	.+304    	; 0x259c <__fp_splitA>
    246c:	88 f0       	brcs	.+34     	; 0x2490 <__fixunssfsi+0x26>
    246e:	9f 57       	subi	r25, 0x7F	; 127
    2470:	90 f0       	brcs	.+36     	; 0x2496 <__fixunssfsi+0x2c>
    2472:	b9 2f       	mov	r27, r25
    2474:	99 27       	eor	r25, r25
    2476:	b7 51       	subi	r27, 0x17	; 23
    2478:	a0 f0       	brcs	.+40     	; 0x24a2 <__fixunssfsi+0x38>
    247a:	d1 f0       	breq	.+52     	; 0x24b0 <__fixunssfsi+0x46>
    247c:	66 0f       	add	r22, r22
    247e:	77 1f       	adc	r23, r23
    2480:	88 1f       	adc	r24, r24
    2482:	99 1f       	adc	r25, r25
    2484:	1a f0       	brmi	.+6      	; 0x248c <__fixunssfsi+0x22>
    2486:	ba 95       	dec	r27
    2488:	c9 f7       	brne	.-14     	; 0x247c <__fixunssfsi+0x12>
    248a:	12 c0       	rjmp	.+36     	; 0x24b0 <__fixunssfsi+0x46>
    248c:	b1 30       	cpi	r27, 0x01	; 1
    248e:	81 f0       	breq	.+32     	; 0x24b0 <__fixunssfsi+0x46>
    2490:	9f d0       	rcall	.+318    	; 0x25d0 <__fp_zero>
    2492:	b1 e0       	ldi	r27, 0x01	; 1
    2494:	08 95       	ret
    2496:	9c c0       	rjmp	.+312    	; 0x25d0 <__fp_zero>
    2498:	67 2f       	mov	r22, r23
    249a:	78 2f       	mov	r23, r24
    249c:	88 27       	eor	r24, r24
    249e:	b8 5f       	subi	r27, 0xF8	; 248
    24a0:	39 f0       	breq	.+14     	; 0x24b0 <__fixunssfsi+0x46>
    24a2:	b9 3f       	cpi	r27, 0xF9	; 249
    24a4:	cc f3       	brlt	.-14     	; 0x2498 <__fixunssfsi+0x2e>
    24a6:	86 95       	lsr	r24
    24a8:	77 95       	ror	r23
    24aa:	67 95       	ror	r22
    24ac:	b3 95       	inc	r27
    24ae:	d9 f7       	brne	.-10     	; 0x24a6 <__fixunssfsi+0x3c>
    24b0:	3e f4       	brtc	.+14     	; 0x24c0 <__fixunssfsi+0x56>
    24b2:	90 95       	com	r25
    24b4:	80 95       	com	r24
    24b6:	70 95       	com	r23
    24b8:	61 95       	neg	r22
    24ba:	7f 4f       	sbci	r23, 0xFF	; 255
    24bc:	8f 4f       	sbci	r24, 0xFF	; 255
    24be:	9f 4f       	sbci	r25, 0xFF	; 255
    24c0:	08 95       	ret

000024c2 <__floatunsisf>:
    24c2:	e8 94       	clt
    24c4:	09 c0       	rjmp	.+18     	; 0x24d8 <__floatsisf+0x12>

000024c6 <__floatsisf>:
    24c6:	97 fb       	bst	r25, 7
    24c8:	3e f4       	brtc	.+14     	; 0x24d8 <__floatsisf+0x12>
    24ca:	90 95       	com	r25
    24cc:	80 95       	com	r24
    24ce:	70 95       	com	r23
    24d0:	61 95       	neg	r22
    24d2:	7f 4f       	sbci	r23, 0xFF	; 255
    24d4:	8f 4f       	sbci	r24, 0xFF	; 255
    24d6:	9f 4f       	sbci	r25, 0xFF	; 255
    24d8:	99 23       	and	r25, r25
    24da:	a9 f0       	breq	.+42     	; 0x2506 <__floatsisf+0x40>
    24dc:	f9 2f       	mov	r31, r25
    24de:	96 e9       	ldi	r25, 0x96	; 150
    24e0:	bb 27       	eor	r27, r27
    24e2:	93 95       	inc	r25
    24e4:	f6 95       	lsr	r31
    24e6:	87 95       	ror	r24
    24e8:	77 95       	ror	r23
    24ea:	67 95       	ror	r22
    24ec:	b7 95       	ror	r27
    24ee:	f1 11       	cpse	r31, r1
    24f0:	f8 cf       	rjmp	.-16     	; 0x24e2 <__floatsisf+0x1c>
    24f2:	fa f4       	brpl	.+62     	; 0x2532 <__floatsisf+0x6c>
    24f4:	bb 0f       	add	r27, r27
    24f6:	11 f4       	brne	.+4      	; 0x24fc <__floatsisf+0x36>
    24f8:	60 ff       	sbrs	r22, 0
    24fa:	1b c0       	rjmp	.+54     	; 0x2532 <__floatsisf+0x6c>
    24fc:	6f 5f       	subi	r22, 0xFF	; 255
    24fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2500:	8f 4f       	sbci	r24, 0xFF	; 255
    2502:	9f 4f       	sbci	r25, 0xFF	; 255
    2504:	16 c0       	rjmp	.+44     	; 0x2532 <__floatsisf+0x6c>
    2506:	88 23       	and	r24, r24
    2508:	11 f0       	breq	.+4      	; 0x250e <__floatsisf+0x48>
    250a:	96 e9       	ldi	r25, 0x96	; 150
    250c:	11 c0       	rjmp	.+34     	; 0x2530 <__floatsisf+0x6a>
    250e:	77 23       	and	r23, r23
    2510:	21 f0       	breq	.+8      	; 0x251a <__floatsisf+0x54>
    2512:	9e e8       	ldi	r25, 0x8E	; 142
    2514:	87 2f       	mov	r24, r23
    2516:	76 2f       	mov	r23, r22
    2518:	05 c0       	rjmp	.+10     	; 0x2524 <__floatsisf+0x5e>
    251a:	66 23       	and	r22, r22
    251c:	71 f0       	breq	.+28     	; 0x253a <__floatsisf+0x74>
    251e:	96 e8       	ldi	r25, 0x86	; 134
    2520:	86 2f       	mov	r24, r22
    2522:	70 e0       	ldi	r23, 0x00	; 0
    2524:	60 e0       	ldi	r22, 0x00	; 0
    2526:	2a f0       	brmi	.+10     	; 0x2532 <__floatsisf+0x6c>
    2528:	9a 95       	dec	r25
    252a:	66 0f       	add	r22, r22
    252c:	77 1f       	adc	r23, r23
    252e:	88 1f       	adc	r24, r24
    2530:	da f7       	brpl	.-10     	; 0x2528 <__floatsisf+0x62>
    2532:	88 0f       	add	r24, r24
    2534:	96 95       	lsr	r25
    2536:	87 95       	ror	r24
    2538:	97 f9       	bld	r25, 7
    253a:	08 95       	ret

0000253c <__fp_inf>:
    253c:	97 f9       	bld	r25, 7
    253e:	9f 67       	ori	r25, 0x7F	; 127
    2540:	80 e8       	ldi	r24, 0x80	; 128
    2542:	70 e0       	ldi	r23, 0x00	; 0
    2544:	60 e0       	ldi	r22, 0x00	; 0
    2546:	08 95       	ret

00002548 <__fp_nan>:
    2548:	9f ef       	ldi	r25, 0xFF	; 255
    254a:	80 ec       	ldi	r24, 0xC0	; 192
    254c:	08 95       	ret

0000254e <__fp_pscA>:
    254e:	00 24       	eor	r0, r0
    2550:	0a 94       	dec	r0
    2552:	16 16       	cp	r1, r22
    2554:	17 06       	cpc	r1, r23
    2556:	18 06       	cpc	r1, r24
    2558:	09 06       	cpc	r0, r25
    255a:	08 95       	ret

0000255c <__fp_pscB>:
    255c:	00 24       	eor	r0, r0
    255e:	0a 94       	dec	r0
    2560:	12 16       	cp	r1, r18
    2562:	13 06       	cpc	r1, r19
    2564:	14 06       	cpc	r1, r20
    2566:	05 06       	cpc	r0, r21
    2568:	08 95       	ret

0000256a <__fp_round>:
    256a:	09 2e       	mov	r0, r25
    256c:	03 94       	inc	r0
    256e:	00 0c       	add	r0, r0
    2570:	11 f4       	brne	.+4      	; 0x2576 <__fp_round+0xc>
    2572:	88 23       	and	r24, r24
    2574:	52 f0       	brmi	.+20     	; 0x258a <__fp_round+0x20>
    2576:	bb 0f       	add	r27, r27
    2578:	40 f4       	brcc	.+16     	; 0x258a <__fp_round+0x20>
    257a:	bf 2b       	or	r27, r31
    257c:	11 f4       	brne	.+4      	; 0x2582 <__fp_round+0x18>
    257e:	60 ff       	sbrs	r22, 0
    2580:	04 c0       	rjmp	.+8      	; 0x258a <__fp_round+0x20>
    2582:	6f 5f       	subi	r22, 0xFF	; 255
    2584:	7f 4f       	sbci	r23, 0xFF	; 255
    2586:	8f 4f       	sbci	r24, 0xFF	; 255
    2588:	9f 4f       	sbci	r25, 0xFF	; 255
    258a:	08 95       	ret

0000258c <__fp_split3>:
    258c:	57 fd       	sbrc	r21, 7
    258e:	90 58       	subi	r25, 0x80	; 128
    2590:	44 0f       	add	r20, r20
    2592:	55 1f       	adc	r21, r21
    2594:	59 f0       	breq	.+22     	; 0x25ac <__fp_splitA+0x10>
    2596:	5f 3f       	cpi	r21, 0xFF	; 255
    2598:	71 f0       	breq	.+28     	; 0x25b6 <__fp_splitA+0x1a>
    259a:	47 95       	ror	r20

0000259c <__fp_splitA>:
    259c:	88 0f       	add	r24, r24
    259e:	97 fb       	bst	r25, 7
    25a0:	99 1f       	adc	r25, r25
    25a2:	61 f0       	breq	.+24     	; 0x25bc <__fp_splitA+0x20>
    25a4:	9f 3f       	cpi	r25, 0xFF	; 255
    25a6:	79 f0       	breq	.+30     	; 0x25c6 <__fp_splitA+0x2a>
    25a8:	87 95       	ror	r24
    25aa:	08 95       	ret
    25ac:	12 16       	cp	r1, r18
    25ae:	13 06       	cpc	r1, r19
    25b0:	14 06       	cpc	r1, r20
    25b2:	55 1f       	adc	r21, r21
    25b4:	f2 cf       	rjmp	.-28     	; 0x259a <__fp_split3+0xe>
    25b6:	46 95       	lsr	r20
    25b8:	f1 df       	rcall	.-30     	; 0x259c <__fp_splitA>
    25ba:	08 c0       	rjmp	.+16     	; 0x25cc <__fp_splitA+0x30>
    25bc:	16 16       	cp	r1, r22
    25be:	17 06       	cpc	r1, r23
    25c0:	18 06       	cpc	r1, r24
    25c2:	99 1f       	adc	r25, r25
    25c4:	f1 cf       	rjmp	.-30     	; 0x25a8 <__fp_splitA+0xc>
    25c6:	86 95       	lsr	r24
    25c8:	71 05       	cpc	r23, r1
    25ca:	61 05       	cpc	r22, r1
    25cc:	08 94       	sec
    25ce:	08 95       	ret

000025d0 <__fp_zero>:
    25d0:	e8 94       	clt

000025d2 <__fp_szero>:
    25d2:	bb 27       	eor	r27, r27
    25d4:	66 27       	eor	r22, r22
    25d6:	77 27       	eor	r23, r23
    25d8:	cb 01       	movw	r24, r22
    25da:	97 f9       	bld	r25, 7
    25dc:	08 95       	ret

000025de <__mulsf3>:
    25de:	0b d0       	rcall	.+22     	; 0x25f6 <__mulsf3x>
    25e0:	c4 cf       	rjmp	.-120    	; 0x256a <__fp_round>
    25e2:	b5 df       	rcall	.-150    	; 0x254e <__fp_pscA>
    25e4:	28 f0       	brcs	.+10     	; 0x25f0 <__mulsf3+0x12>
    25e6:	ba df       	rcall	.-140    	; 0x255c <__fp_pscB>
    25e8:	18 f0       	brcs	.+6      	; 0x25f0 <__mulsf3+0x12>
    25ea:	95 23       	and	r25, r21
    25ec:	09 f0       	breq	.+2      	; 0x25f0 <__mulsf3+0x12>
    25ee:	a6 cf       	rjmp	.-180    	; 0x253c <__fp_inf>
    25f0:	ab cf       	rjmp	.-170    	; 0x2548 <__fp_nan>
    25f2:	11 24       	eor	r1, r1
    25f4:	ee cf       	rjmp	.-36     	; 0x25d2 <__fp_szero>

000025f6 <__mulsf3x>:
    25f6:	ca df       	rcall	.-108    	; 0x258c <__fp_split3>
    25f8:	a0 f3       	brcs	.-24     	; 0x25e2 <__mulsf3+0x4>

000025fa <__mulsf3_pse>:
    25fa:	95 9f       	mul	r25, r21
    25fc:	d1 f3       	breq	.-12     	; 0x25f2 <__mulsf3+0x14>
    25fe:	95 0f       	add	r25, r21
    2600:	50 e0       	ldi	r21, 0x00	; 0
    2602:	55 1f       	adc	r21, r21
    2604:	62 9f       	mul	r22, r18
    2606:	f0 01       	movw	r30, r0
    2608:	72 9f       	mul	r23, r18
    260a:	bb 27       	eor	r27, r27
    260c:	f0 0d       	add	r31, r0
    260e:	b1 1d       	adc	r27, r1
    2610:	63 9f       	mul	r22, r19
    2612:	aa 27       	eor	r26, r26
    2614:	f0 0d       	add	r31, r0
    2616:	b1 1d       	adc	r27, r1
    2618:	aa 1f       	adc	r26, r26
    261a:	64 9f       	mul	r22, r20
    261c:	66 27       	eor	r22, r22
    261e:	b0 0d       	add	r27, r0
    2620:	a1 1d       	adc	r26, r1
    2622:	66 1f       	adc	r22, r22
    2624:	82 9f       	mul	r24, r18
    2626:	22 27       	eor	r18, r18
    2628:	b0 0d       	add	r27, r0
    262a:	a1 1d       	adc	r26, r1
    262c:	62 1f       	adc	r22, r18
    262e:	73 9f       	mul	r23, r19
    2630:	b0 0d       	add	r27, r0
    2632:	a1 1d       	adc	r26, r1
    2634:	62 1f       	adc	r22, r18
    2636:	83 9f       	mul	r24, r19
    2638:	a0 0d       	add	r26, r0
    263a:	61 1d       	adc	r22, r1
    263c:	22 1f       	adc	r18, r18
    263e:	74 9f       	mul	r23, r20
    2640:	33 27       	eor	r19, r19
    2642:	a0 0d       	add	r26, r0
    2644:	61 1d       	adc	r22, r1
    2646:	23 1f       	adc	r18, r19
    2648:	84 9f       	mul	r24, r20
    264a:	60 0d       	add	r22, r0
    264c:	21 1d       	adc	r18, r1
    264e:	82 2f       	mov	r24, r18
    2650:	76 2f       	mov	r23, r22
    2652:	6a 2f       	mov	r22, r26
    2654:	11 24       	eor	r1, r1
    2656:	9f 57       	subi	r25, 0x7F	; 127
    2658:	50 40       	sbci	r21, 0x00	; 0
    265a:	8a f0       	brmi	.+34     	; 0x267e <__mulsf3_pse+0x84>
    265c:	e1 f0       	breq	.+56     	; 0x2696 <__mulsf3_pse+0x9c>
    265e:	88 23       	and	r24, r24
    2660:	4a f0       	brmi	.+18     	; 0x2674 <__mulsf3_pse+0x7a>
    2662:	ee 0f       	add	r30, r30
    2664:	ff 1f       	adc	r31, r31
    2666:	bb 1f       	adc	r27, r27
    2668:	66 1f       	adc	r22, r22
    266a:	77 1f       	adc	r23, r23
    266c:	88 1f       	adc	r24, r24
    266e:	91 50       	subi	r25, 0x01	; 1
    2670:	50 40       	sbci	r21, 0x00	; 0
    2672:	a9 f7       	brne	.-22     	; 0x265e <__mulsf3_pse+0x64>
    2674:	9e 3f       	cpi	r25, 0xFE	; 254
    2676:	51 05       	cpc	r21, r1
    2678:	70 f0       	brcs	.+28     	; 0x2696 <__mulsf3_pse+0x9c>
    267a:	60 cf       	rjmp	.-320    	; 0x253c <__fp_inf>
    267c:	aa cf       	rjmp	.-172    	; 0x25d2 <__fp_szero>
    267e:	5f 3f       	cpi	r21, 0xFF	; 255
    2680:	ec f3       	brlt	.-6      	; 0x267c <__mulsf3_pse+0x82>
    2682:	98 3e       	cpi	r25, 0xE8	; 232
    2684:	dc f3       	brlt	.-10     	; 0x267c <__mulsf3_pse+0x82>
    2686:	86 95       	lsr	r24
    2688:	77 95       	ror	r23
    268a:	67 95       	ror	r22
    268c:	b7 95       	ror	r27
    268e:	f7 95       	ror	r31
    2690:	e7 95       	ror	r30
    2692:	9f 5f       	subi	r25, 0xFF	; 255
    2694:	c1 f7       	brne	.-16     	; 0x2686 <__mulsf3_pse+0x8c>
    2696:	fe 2b       	or	r31, r30
    2698:	88 0f       	add	r24, r24
    269a:	91 1d       	adc	r25, r1
    269c:	96 95       	lsr	r25
    269e:	87 95       	ror	r24
    26a0:	97 f9       	bld	r25, 7
    26a2:	08 95       	ret

000026a4 <pow>:
    26a4:	fa 01       	movw	r30, r20
    26a6:	ee 0f       	add	r30, r30
    26a8:	ff 1f       	adc	r31, r31
    26aa:	30 96       	adiw	r30, 0x00	; 0
    26ac:	21 05       	cpc	r18, r1
    26ae:	31 05       	cpc	r19, r1
    26b0:	99 f1       	breq	.+102    	; 0x2718 <pow+0x74>
    26b2:	61 15       	cp	r22, r1
    26b4:	71 05       	cpc	r23, r1
    26b6:	61 f4       	brne	.+24     	; 0x26d0 <pow+0x2c>
    26b8:	80 38       	cpi	r24, 0x80	; 128
    26ba:	bf e3       	ldi	r27, 0x3F	; 63
    26bc:	9b 07       	cpc	r25, r27
    26be:	49 f1       	breq	.+82     	; 0x2712 <pow+0x6e>
    26c0:	68 94       	set
    26c2:	90 38       	cpi	r25, 0x80	; 128
    26c4:	81 05       	cpc	r24, r1
    26c6:	61 f0       	breq	.+24     	; 0x26e0 <pow+0x3c>
    26c8:	80 38       	cpi	r24, 0x80	; 128
    26ca:	bf ef       	ldi	r27, 0xFF	; 255
    26cc:	9b 07       	cpc	r25, r27
    26ce:	41 f0       	breq	.+16     	; 0x26e0 <pow+0x3c>
    26d0:	99 23       	and	r25, r25
    26d2:	42 f5       	brpl	.+80     	; 0x2724 <pow+0x80>
    26d4:	ff 3f       	cpi	r31, 0xFF	; 255
    26d6:	e1 05       	cpc	r30, r1
    26d8:	31 05       	cpc	r19, r1
    26da:	21 05       	cpc	r18, r1
    26dc:	11 f1       	breq	.+68     	; 0x2722 <pow+0x7e>
    26de:	e8 94       	clt
    26e0:	08 94       	sec
    26e2:	e7 95       	ror	r30
    26e4:	d9 01       	movw	r26, r18
    26e6:	aa 23       	and	r26, r26
    26e8:	29 f4       	brne	.+10     	; 0x26f4 <pow+0x50>
    26ea:	ab 2f       	mov	r26, r27
    26ec:	be 2f       	mov	r27, r30
    26ee:	f8 5f       	subi	r31, 0xF8	; 248
    26f0:	d0 f3       	brcs	.-12     	; 0x26e6 <pow+0x42>
    26f2:	10 c0       	rjmp	.+32     	; 0x2714 <pow+0x70>
    26f4:	ff 5f       	subi	r31, 0xFF	; 255
    26f6:	70 f4       	brcc	.+28     	; 0x2714 <pow+0x70>
    26f8:	a6 95       	lsr	r26
    26fa:	e0 f7       	brcc	.-8      	; 0x26f4 <pow+0x50>
    26fc:	f7 39       	cpi	r31, 0x97	; 151
    26fe:	50 f0       	brcs	.+20     	; 0x2714 <pow+0x70>
    2700:	19 f0       	breq	.+6      	; 0x2708 <pow+0x64>
    2702:	ff 3a       	cpi	r31, 0xAF	; 175
    2704:	38 f4       	brcc	.+14     	; 0x2714 <pow+0x70>
    2706:	9f 77       	andi	r25, 0x7F	; 127
    2708:	9f 93       	push	r25
    270a:	0c d0       	rcall	.+24     	; 0x2724 <pow+0x80>
    270c:	0f 90       	pop	r0
    270e:	07 fc       	sbrc	r0, 7
    2710:	90 58       	subi	r25, 0x80	; 128
    2712:	08 95       	ret
    2714:	3e f0       	brts	.+14     	; 0x2724 <pow+0x80>
    2716:	18 cf       	rjmp	.-464    	; 0x2548 <__fp_nan>
    2718:	60 e0       	ldi	r22, 0x00	; 0
    271a:	70 e0       	ldi	r23, 0x00	; 0
    271c:	80 e8       	ldi	r24, 0x80	; 128
    271e:	9f e3       	ldi	r25, 0x3F	; 63
    2720:	08 95       	ret
    2722:	4f e7       	ldi	r20, 0x7F	; 127
    2724:	9f 77       	andi	r25, 0x7F	; 127
    2726:	5f 93       	push	r21
    2728:	4f 93       	push	r20
    272a:	3f 93       	push	r19
    272c:	2f 93       	push	r18
    272e:	9e d0       	rcall	.+316    	; 0x286c <log>
    2730:	2f 91       	pop	r18
    2732:	3f 91       	pop	r19
    2734:	4f 91       	pop	r20
    2736:	5f 91       	pop	r21
    2738:	52 df       	rcall	.-348    	; 0x25de <__mulsf3>
    273a:	05 c0       	rjmp	.+10     	; 0x2746 <exp>
    273c:	19 f4       	brne	.+6      	; 0x2744 <pow+0xa0>
    273e:	0e f0       	brts	.+2      	; 0x2742 <pow+0x9e>
    2740:	fd ce       	rjmp	.-518    	; 0x253c <__fp_inf>
    2742:	46 cf       	rjmp	.-372    	; 0x25d0 <__fp_zero>
    2744:	01 cf       	rjmp	.-510    	; 0x2548 <__fp_nan>

00002746 <exp>:
    2746:	2a df       	rcall	.-428    	; 0x259c <__fp_splitA>
    2748:	c8 f3       	brcs	.-14     	; 0x273c <pow+0x98>
    274a:	96 38       	cpi	r25, 0x86	; 134
    274c:	c0 f7       	brcc	.-16     	; 0x273e <pow+0x9a>
    274e:	07 f8       	bld	r0, 7
    2750:	0f 92       	push	r0
    2752:	e8 94       	clt
    2754:	2b e3       	ldi	r18, 0x3B	; 59
    2756:	3a ea       	ldi	r19, 0xAA	; 170
    2758:	48 eb       	ldi	r20, 0xB8	; 184
    275a:	5f e7       	ldi	r21, 0x7F	; 127
    275c:	4e df       	rcall	.-356    	; 0x25fa <__mulsf3_pse>
    275e:	0f 92       	push	r0
    2760:	0f 92       	push	r0
    2762:	0f 92       	push	r0
    2764:	4d b7       	in	r20, 0x3d	; 61
    2766:	5e b7       	in	r21, 0x3e	; 62
    2768:	0f 92       	push	r0
    276a:	c0 d0       	rcall	.+384    	; 0x28ec <modf>
    276c:	e4 ee       	ldi	r30, 0xE4	; 228
    276e:	f0 e0       	ldi	r31, 0x00	; 0
    2770:	16 d0       	rcall	.+44     	; 0x279e <__fp_powser>
    2772:	4f 91       	pop	r20
    2774:	5f 91       	pop	r21
    2776:	ef 91       	pop	r30
    2778:	ff 91       	pop	r31
    277a:	e5 95       	asr	r30
    277c:	ee 1f       	adc	r30, r30
    277e:	ff 1f       	adc	r31, r31
    2780:	49 f0       	breq	.+18     	; 0x2794 <exp+0x4e>
    2782:	fe 57       	subi	r31, 0x7E	; 126
    2784:	e0 68       	ori	r30, 0x80	; 128
    2786:	44 27       	eor	r20, r20
    2788:	ee 0f       	add	r30, r30
    278a:	44 1f       	adc	r20, r20
    278c:	fa 95       	dec	r31
    278e:	e1 f7       	brne	.-8      	; 0x2788 <exp+0x42>
    2790:	41 95       	neg	r20
    2792:	55 0b       	sbc	r21, r21
    2794:	32 d0       	rcall	.+100    	; 0x27fa <ldexp>
    2796:	0f 90       	pop	r0
    2798:	07 fe       	sbrs	r0, 7
    279a:	26 c0       	rjmp	.+76     	; 0x27e8 <inverse>
    279c:	08 95       	ret

0000279e <__fp_powser>:
    279e:	df 93       	push	r29
    27a0:	cf 93       	push	r28
    27a2:	1f 93       	push	r17
    27a4:	0f 93       	push	r16
    27a6:	ff 92       	push	r15
    27a8:	ef 92       	push	r14
    27aa:	df 92       	push	r13
    27ac:	7b 01       	movw	r14, r22
    27ae:	8c 01       	movw	r16, r24
    27b0:	68 94       	set
    27b2:	05 c0       	rjmp	.+10     	; 0x27be <__fp_powser+0x20>
    27b4:	da 2e       	mov	r13, r26
    27b6:	ef 01       	movw	r28, r30
    27b8:	1e df       	rcall	.-452    	; 0x25f6 <__mulsf3x>
    27ba:	fe 01       	movw	r30, r28
    27bc:	e8 94       	clt
    27be:	a5 91       	lpm	r26, Z+
    27c0:	25 91       	lpm	r18, Z+
    27c2:	35 91       	lpm	r19, Z+
    27c4:	45 91       	lpm	r20, Z+
    27c6:	55 91       	lpm	r21, Z+
    27c8:	ae f3       	brts	.-22     	; 0x27b4 <__fp_powser+0x16>
    27ca:	ef 01       	movw	r28, r30
    27cc:	f6 dd       	rcall	.-1044   	; 0x23ba <__addsf3x>
    27ce:	fe 01       	movw	r30, r28
    27d0:	97 01       	movw	r18, r14
    27d2:	a8 01       	movw	r20, r16
    27d4:	da 94       	dec	r13
    27d6:	79 f7       	brne	.-34     	; 0x27b6 <__fp_powser+0x18>
    27d8:	df 90       	pop	r13
    27da:	ef 90       	pop	r14
    27dc:	ff 90       	pop	r15
    27de:	0f 91       	pop	r16
    27e0:	1f 91       	pop	r17
    27e2:	cf 91       	pop	r28
    27e4:	df 91       	pop	r29
    27e6:	08 95       	ret

000027e8 <inverse>:
    27e8:	9b 01       	movw	r18, r22
    27ea:	ac 01       	movw	r20, r24
    27ec:	60 e0       	ldi	r22, 0x00	; 0
    27ee:	70 e0       	ldi	r23, 0x00	; 0
    27f0:	80 e8       	ldi	r24, 0x80	; 128
    27f2:	9f e3       	ldi	r25, 0x3F	; 63
    27f4:	ae c0       	rjmp	.+348    	; 0x2952 <__divsf3>
    27f6:	a2 ce       	rjmp	.-700    	; 0x253c <__fp_inf>
    27f8:	14 c1       	rjmp	.+552    	; 0x2a22 <__fp_mpack>

000027fa <ldexp>:
    27fa:	d0 de       	rcall	.-608    	; 0x259c <__fp_splitA>
    27fc:	e8 f3       	brcs	.-6      	; 0x27f8 <inverse+0x10>
    27fe:	99 23       	and	r25, r25
    2800:	d9 f3       	breq	.-10     	; 0x27f8 <inverse+0x10>
    2802:	94 0f       	add	r25, r20
    2804:	51 1d       	adc	r21, r1
    2806:	bb f3       	brvs	.-18     	; 0x27f6 <inverse+0xe>
    2808:	91 50       	subi	r25, 0x01	; 1
    280a:	50 40       	sbci	r21, 0x00	; 0
    280c:	94 f0       	brlt	.+36     	; 0x2832 <ldexp+0x38>
    280e:	59 f0       	breq	.+22     	; 0x2826 <ldexp+0x2c>
    2810:	88 23       	and	r24, r24
    2812:	32 f0       	brmi	.+12     	; 0x2820 <ldexp+0x26>
    2814:	66 0f       	add	r22, r22
    2816:	77 1f       	adc	r23, r23
    2818:	88 1f       	adc	r24, r24
    281a:	91 50       	subi	r25, 0x01	; 1
    281c:	50 40       	sbci	r21, 0x00	; 0
    281e:	c1 f7       	brne	.-16     	; 0x2810 <ldexp+0x16>
    2820:	9e 3f       	cpi	r25, 0xFE	; 254
    2822:	51 05       	cpc	r21, r1
    2824:	44 f7       	brge	.-48     	; 0x27f6 <inverse+0xe>
    2826:	88 0f       	add	r24, r24
    2828:	91 1d       	adc	r25, r1
    282a:	96 95       	lsr	r25
    282c:	87 95       	ror	r24
    282e:	97 f9       	bld	r25, 7
    2830:	08 95       	ret
    2832:	5f 3f       	cpi	r21, 0xFF	; 255
    2834:	ac f0       	brlt	.+42     	; 0x2860 <ldexp+0x66>
    2836:	98 3e       	cpi	r25, 0xE8	; 232
    2838:	9c f0       	brlt	.+38     	; 0x2860 <ldexp+0x66>
    283a:	bb 27       	eor	r27, r27
    283c:	86 95       	lsr	r24
    283e:	77 95       	ror	r23
    2840:	67 95       	ror	r22
    2842:	b7 95       	ror	r27
    2844:	08 f4       	brcc	.+2      	; 0x2848 <ldexp+0x4e>
    2846:	b1 60       	ori	r27, 0x01	; 1
    2848:	93 95       	inc	r25
    284a:	c1 f7       	brne	.-16     	; 0x283c <ldexp+0x42>
    284c:	bb 0f       	add	r27, r27
    284e:	58 f7       	brcc	.-42     	; 0x2826 <ldexp+0x2c>
    2850:	11 f4       	brne	.+4      	; 0x2856 <ldexp+0x5c>
    2852:	60 ff       	sbrs	r22, 0
    2854:	e8 cf       	rjmp	.-48     	; 0x2826 <ldexp+0x2c>
    2856:	6f 5f       	subi	r22, 0xFF	; 255
    2858:	7f 4f       	sbci	r23, 0xFF	; 255
    285a:	8f 4f       	sbci	r24, 0xFF	; 255
    285c:	9f 4f       	sbci	r25, 0xFF	; 255
    285e:	e3 cf       	rjmp	.-58     	; 0x2826 <ldexp+0x2c>
    2860:	b8 ce       	rjmp	.-656    	; 0x25d2 <__fp_szero>
    2862:	0e f0       	brts	.+2      	; 0x2866 <ldexp+0x6c>
    2864:	de c0       	rjmp	.+444    	; 0x2a22 <__fp_mpack>
    2866:	70 ce       	rjmp	.-800    	; 0x2548 <__fp_nan>
    2868:	68 94       	set
    286a:	68 ce       	rjmp	.-816    	; 0x253c <__fp_inf>

0000286c <log>:
    286c:	97 de       	rcall	.-722    	; 0x259c <__fp_splitA>
    286e:	c8 f3       	brcs	.-14     	; 0x2862 <ldexp+0x68>
    2870:	99 23       	and	r25, r25
    2872:	d1 f3       	breq	.-12     	; 0x2868 <ldexp+0x6e>
    2874:	c6 f3       	brts	.-16     	; 0x2866 <ldexp+0x6c>
    2876:	df 93       	push	r29
    2878:	cf 93       	push	r28
    287a:	1f 93       	push	r17
    287c:	0f 93       	push	r16
    287e:	ff 92       	push	r15
    2880:	c9 2f       	mov	r28, r25
    2882:	dd 27       	eor	r29, r29
    2884:	88 23       	and	r24, r24
    2886:	2a f0       	brmi	.+10     	; 0x2892 <log+0x26>
    2888:	21 97       	sbiw	r28, 0x01	; 1
    288a:	66 0f       	add	r22, r22
    288c:	77 1f       	adc	r23, r23
    288e:	88 1f       	adc	r24, r24
    2890:	da f7       	brpl	.-10     	; 0x2888 <log+0x1c>
    2892:	20 e0       	ldi	r18, 0x00	; 0
    2894:	30 e0       	ldi	r19, 0x00	; 0
    2896:	40 e8       	ldi	r20, 0x80	; 128
    2898:	5f eb       	ldi	r21, 0xBF	; 191
    289a:	9f e3       	ldi	r25, 0x3F	; 63
    289c:	88 39       	cpi	r24, 0x98	; 152
    289e:	20 f0       	brcs	.+8      	; 0x28a8 <log+0x3c>
    28a0:	80 3e       	cpi	r24, 0xE0	; 224
    28a2:	30 f0       	brcs	.+12     	; 0x28b0 <log+0x44>
    28a4:	21 96       	adiw	r28, 0x01	; 1
    28a6:	8f 77       	andi	r24, 0x7F	; 127
    28a8:	77 dd       	rcall	.-1298   	; 0x2398 <__addsf3>
    28aa:	ec e0       	ldi	r30, 0x0C	; 12
    28ac:	f1 e0       	ldi	r31, 0x01	; 1
    28ae:	03 c0       	rjmp	.+6      	; 0x28b6 <log+0x4a>
    28b0:	73 dd       	rcall	.-1306   	; 0x2398 <__addsf3>
    28b2:	e9 e3       	ldi	r30, 0x39	; 57
    28b4:	f1 e0       	ldi	r31, 0x01	; 1
    28b6:	73 df       	rcall	.-282    	; 0x279e <__fp_powser>
    28b8:	8b 01       	movw	r16, r22
    28ba:	be 01       	movw	r22, r28
    28bc:	ec 01       	movw	r28, r24
    28be:	fb 2e       	mov	r15, r27
    28c0:	6f 57       	subi	r22, 0x7F	; 127
    28c2:	71 09       	sbc	r23, r1
    28c4:	75 95       	asr	r23
    28c6:	77 1f       	adc	r23, r23
    28c8:	88 0b       	sbc	r24, r24
    28ca:	99 0b       	sbc	r25, r25
    28cc:	fc dd       	rcall	.-1032   	; 0x24c6 <__floatsisf>
    28ce:	28 e1       	ldi	r18, 0x18	; 24
    28d0:	32 e7       	ldi	r19, 0x72	; 114
    28d2:	41 e3       	ldi	r20, 0x31	; 49
    28d4:	5f e3       	ldi	r21, 0x3F	; 63
    28d6:	8f de       	rcall	.-738    	; 0x25f6 <__mulsf3x>
    28d8:	af 2d       	mov	r26, r15
    28da:	98 01       	movw	r18, r16
    28dc:	ae 01       	movw	r20, r28
    28de:	ff 90       	pop	r15
    28e0:	0f 91       	pop	r16
    28e2:	1f 91       	pop	r17
    28e4:	cf 91       	pop	r28
    28e6:	df 91       	pop	r29
    28e8:	68 dd       	rcall	.-1328   	; 0x23ba <__addsf3x>
    28ea:	3f ce       	rjmp	.-898    	; 0x256a <__fp_round>

000028ec <modf>:
    28ec:	fa 01       	movw	r30, r20
    28ee:	dc 01       	movw	r26, r24
    28f0:	aa 0f       	add	r26, r26
    28f2:	bb 1f       	adc	r27, r27
    28f4:	9b 01       	movw	r18, r22
    28f6:	ac 01       	movw	r20, r24
    28f8:	bf 57       	subi	r27, 0x7F	; 127
    28fa:	28 f4       	brcc	.+10     	; 0x2906 <modf+0x1a>
    28fc:	22 27       	eor	r18, r18
    28fe:	33 27       	eor	r19, r19
    2900:	44 27       	eor	r20, r20
    2902:	50 78       	andi	r21, 0x80	; 128
    2904:	1f c0       	rjmp	.+62     	; 0x2944 <modf+0x58>
    2906:	b7 51       	subi	r27, 0x17	; 23
    2908:	88 f4       	brcc	.+34     	; 0x292c <modf+0x40>
    290a:	ab 2f       	mov	r26, r27
    290c:	00 24       	eor	r0, r0
    290e:	46 95       	lsr	r20
    2910:	37 95       	ror	r19
    2912:	27 95       	ror	r18
    2914:	01 1c       	adc	r0, r1
    2916:	a3 95       	inc	r26
    2918:	d2 f3       	brmi	.-12     	; 0x290e <modf+0x22>
    291a:	00 20       	and	r0, r0
    291c:	69 f0       	breq	.+26     	; 0x2938 <modf+0x4c>
    291e:	22 0f       	add	r18, r18
    2920:	33 1f       	adc	r19, r19
    2922:	44 1f       	adc	r20, r20
    2924:	b3 95       	inc	r27
    2926:	da f3       	brmi	.-10     	; 0x291e <modf+0x32>
    2928:	0d d0       	rcall	.+26     	; 0x2944 <modf+0x58>
    292a:	35 cd       	rjmp	.-1430   	; 0x2396 <__subsf3>
    292c:	61 30       	cpi	r22, 0x01	; 1
    292e:	71 05       	cpc	r23, r1
    2930:	a0 e8       	ldi	r26, 0x80	; 128
    2932:	8a 07       	cpc	r24, r26
    2934:	b9 46       	sbci	r27, 0x69	; 105
    2936:	30 f4       	brcc	.+12     	; 0x2944 <modf+0x58>
    2938:	9b 01       	movw	r18, r22
    293a:	ac 01       	movw	r20, r24
    293c:	66 27       	eor	r22, r22
    293e:	77 27       	eor	r23, r23
    2940:	88 27       	eor	r24, r24
    2942:	90 78       	andi	r25, 0x80	; 128
    2944:	30 96       	adiw	r30, 0x00	; 0
    2946:	21 f0       	breq	.+8      	; 0x2950 <modf+0x64>
    2948:	20 83       	st	Z, r18
    294a:	31 83       	std	Z+1, r19	; 0x01
    294c:	42 83       	std	Z+2, r20	; 0x02
    294e:	53 83       	std	Z+3, r21	; 0x03
    2950:	08 95       	ret

00002952 <__divsf3>:
    2952:	0c d0       	rcall	.+24     	; 0x296c <__divsf3x>
    2954:	0a ce       	rjmp	.-1004   	; 0x256a <__fp_round>
    2956:	02 de       	rcall	.-1020   	; 0x255c <__fp_pscB>
    2958:	40 f0       	brcs	.+16     	; 0x296a <__divsf3+0x18>
    295a:	f9 dd       	rcall	.-1038   	; 0x254e <__fp_pscA>
    295c:	30 f0       	brcs	.+12     	; 0x296a <__divsf3+0x18>
    295e:	21 f4       	brne	.+8      	; 0x2968 <__divsf3+0x16>
    2960:	5f 3f       	cpi	r21, 0xFF	; 255
    2962:	19 f0       	breq	.+6      	; 0x296a <__divsf3+0x18>
    2964:	eb cd       	rjmp	.-1066   	; 0x253c <__fp_inf>
    2966:	51 11       	cpse	r21, r1
    2968:	34 ce       	rjmp	.-920    	; 0x25d2 <__fp_szero>
    296a:	ee cd       	rjmp	.-1060   	; 0x2548 <__fp_nan>

0000296c <__divsf3x>:
    296c:	0f de       	rcall	.-994    	; 0x258c <__fp_split3>
    296e:	98 f3       	brcs	.-26     	; 0x2956 <__divsf3+0x4>

00002970 <__divsf3_pse>:
    2970:	99 23       	and	r25, r25
    2972:	c9 f3       	breq	.-14     	; 0x2966 <__divsf3+0x14>
    2974:	55 23       	and	r21, r21
    2976:	b1 f3       	breq	.-20     	; 0x2964 <__divsf3+0x12>
    2978:	95 1b       	sub	r25, r21
    297a:	55 0b       	sbc	r21, r21
    297c:	bb 27       	eor	r27, r27
    297e:	aa 27       	eor	r26, r26
    2980:	62 17       	cp	r22, r18
    2982:	73 07       	cpc	r23, r19
    2984:	84 07       	cpc	r24, r20
    2986:	38 f0       	brcs	.+14     	; 0x2996 <__divsf3_pse+0x26>
    2988:	9f 5f       	subi	r25, 0xFF	; 255
    298a:	5f 4f       	sbci	r21, 0xFF	; 255
    298c:	22 0f       	add	r18, r18
    298e:	33 1f       	adc	r19, r19
    2990:	44 1f       	adc	r20, r20
    2992:	aa 1f       	adc	r26, r26
    2994:	a9 f3       	breq	.-22     	; 0x2980 <__divsf3_pse+0x10>
    2996:	33 d0       	rcall	.+102    	; 0x29fe <__divsf3_pse+0x8e>
    2998:	0e 2e       	mov	r0, r30
    299a:	3a f0       	brmi	.+14     	; 0x29aa <__divsf3_pse+0x3a>
    299c:	e0 e8       	ldi	r30, 0x80	; 128
    299e:	30 d0       	rcall	.+96     	; 0x2a00 <__divsf3_pse+0x90>
    29a0:	91 50       	subi	r25, 0x01	; 1
    29a2:	50 40       	sbci	r21, 0x00	; 0
    29a4:	e6 95       	lsr	r30
    29a6:	00 1c       	adc	r0, r0
    29a8:	ca f7       	brpl	.-14     	; 0x299c <__divsf3_pse+0x2c>
    29aa:	29 d0       	rcall	.+82     	; 0x29fe <__divsf3_pse+0x8e>
    29ac:	fe 2f       	mov	r31, r30
    29ae:	27 d0       	rcall	.+78     	; 0x29fe <__divsf3_pse+0x8e>
    29b0:	66 0f       	add	r22, r22
    29b2:	77 1f       	adc	r23, r23
    29b4:	88 1f       	adc	r24, r24
    29b6:	bb 1f       	adc	r27, r27
    29b8:	26 17       	cp	r18, r22
    29ba:	37 07       	cpc	r19, r23
    29bc:	48 07       	cpc	r20, r24
    29be:	ab 07       	cpc	r26, r27
    29c0:	b0 e8       	ldi	r27, 0x80	; 128
    29c2:	09 f0       	breq	.+2      	; 0x29c6 <__divsf3_pse+0x56>
    29c4:	bb 0b       	sbc	r27, r27
    29c6:	80 2d       	mov	r24, r0
    29c8:	bf 01       	movw	r22, r30
    29ca:	ff 27       	eor	r31, r31
    29cc:	93 58       	subi	r25, 0x83	; 131
    29ce:	5f 4f       	sbci	r21, 0xFF	; 255
    29d0:	2a f0       	brmi	.+10     	; 0x29dc <__divsf3_pse+0x6c>
    29d2:	9e 3f       	cpi	r25, 0xFE	; 254
    29d4:	51 05       	cpc	r21, r1
    29d6:	68 f0       	brcs	.+26     	; 0x29f2 <__divsf3_pse+0x82>
    29d8:	b1 cd       	rjmp	.-1182   	; 0x253c <__fp_inf>
    29da:	fb cd       	rjmp	.-1034   	; 0x25d2 <__fp_szero>
    29dc:	5f 3f       	cpi	r21, 0xFF	; 255
    29de:	ec f3       	brlt	.-6      	; 0x29da <__divsf3_pse+0x6a>
    29e0:	98 3e       	cpi	r25, 0xE8	; 232
    29e2:	dc f3       	brlt	.-10     	; 0x29da <__divsf3_pse+0x6a>
    29e4:	86 95       	lsr	r24
    29e6:	77 95       	ror	r23
    29e8:	67 95       	ror	r22
    29ea:	b7 95       	ror	r27
    29ec:	f7 95       	ror	r31
    29ee:	9f 5f       	subi	r25, 0xFF	; 255
    29f0:	c9 f7       	brne	.-14     	; 0x29e4 <__divsf3_pse+0x74>
    29f2:	88 0f       	add	r24, r24
    29f4:	91 1d       	adc	r25, r1
    29f6:	96 95       	lsr	r25
    29f8:	87 95       	ror	r24
    29fa:	97 f9       	bld	r25, 7
    29fc:	08 95       	ret
    29fe:	e1 e0       	ldi	r30, 0x01	; 1
    2a00:	66 0f       	add	r22, r22
    2a02:	77 1f       	adc	r23, r23
    2a04:	88 1f       	adc	r24, r24
    2a06:	bb 1f       	adc	r27, r27
    2a08:	62 17       	cp	r22, r18
    2a0a:	73 07       	cpc	r23, r19
    2a0c:	84 07       	cpc	r24, r20
    2a0e:	ba 07       	cpc	r27, r26
    2a10:	20 f0       	brcs	.+8      	; 0x2a1a <__divsf3_pse+0xaa>
    2a12:	62 1b       	sub	r22, r18
    2a14:	73 0b       	sbc	r23, r19
    2a16:	84 0b       	sbc	r24, r20
    2a18:	ba 0b       	sbc	r27, r26
    2a1a:	ee 1f       	adc	r30, r30
    2a1c:	88 f7       	brcc	.-30     	; 0x2a00 <__divsf3_pse+0x90>
    2a1e:	e0 95       	com	r30
    2a20:	08 95       	ret

00002a22 <__fp_mpack>:
    2a22:	9f 3f       	cpi	r25, 0xFF	; 255
    2a24:	31 f0       	breq	.+12     	; 0x2a32 <__fp_mpack_finite+0xc>

00002a26 <__fp_mpack_finite>:
    2a26:	91 50       	subi	r25, 0x01	; 1
    2a28:	20 f4       	brcc	.+8      	; 0x2a32 <__fp_mpack_finite+0xc>
    2a2a:	87 95       	ror	r24
    2a2c:	77 95       	ror	r23
    2a2e:	67 95       	ror	r22
    2a30:	b7 95       	ror	r27
    2a32:	88 0f       	add	r24, r24
    2a34:	91 1d       	adc	r25, r1
    2a36:	96 95       	lsr	r25
    2a38:	87 95       	ror	r24
    2a3a:	97 f9       	bld	r25, 7
    2a3c:	08 95       	ret

00002a3e <__divmodhi4>:
    2a3e:	97 fb       	bst	r25, 7
    2a40:	07 2e       	mov	r0, r23
    2a42:	16 f4       	brtc	.+4      	; 0x2a48 <__divmodhi4+0xa>
    2a44:	00 94       	com	r0
    2a46:	06 d0       	rcall	.+12     	; 0x2a54 <__divmodhi4_neg1>
    2a48:	77 fd       	sbrc	r23, 7
    2a4a:	08 d0       	rcall	.+16     	; 0x2a5c <__divmodhi4_neg2>
    2a4c:	0b d0       	rcall	.+22     	; 0x2a64 <__udivmodhi4>
    2a4e:	07 fc       	sbrc	r0, 7
    2a50:	05 d0       	rcall	.+10     	; 0x2a5c <__divmodhi4_neg2>
    2a52:	3e f4       	brtc	.+14     	; 0x2a62 <__divmodhi4_exit>

00002a54 <__divmodhi4_neg1>:
    2a54:	90 95       	com	r25
    2a56:	81 95       	neg	r24
    2a58:	9f 4f       	sbci	r25, 0xFF	; 255
    2a5a:	08 95       	ret

00002a5c <__divmodhi4_neg2>:
    2a5c:	70 95       	com	r23
    2a5e:	61 95       	neg	r22
    2a60:	7f 4f       	sbci	r23, 0xFF	; 255

00002a62 <__divmodhi4_exit>:
    2a62:	08 95       	ret

00002a64 <__udivmodhi4>:
    2a64:	aa 1b       	sub	r26, r26
    2a66:	bb 1b       	sub	r27, r27
    2a68:	51 e1       	ldi	r21, 0x11	; 17
    2a6a:	07 c0       	rjmp	.+14     	; 0x2a7a <__udivmodhi4_ep>

00002a6c <__udivmodhi4_loop>:
    2a6c:	aa 1f       	adc	r26, r26
    2a6e:	bb 1f       	adc	r27, r27
    2a70:	a6 17       	cp	r26, r22
    2a72:	b7 07       	cpc	r27, r23
    2a74:	10 f0       	brcs	.+4      	; 0x2a7a <__udivmodhi4_ep>
    2a76:	a6 1b       	sub	r26, r22
    2a78:	b7 0b       	sbc	r27, r23

00002a7a <__udivmodhi4_ep>:
    2a7a:	88 1f       	adc	r24, r24
    2a7c:	99 1f       	adc	r25, r25
    2a7e:	5a 95       	dec	r21
    2a80:	a9 f7       	brne	.-22     	; 0x2a6c <__udivmodhi4_loop>
    2a82:	80 95       	com	r24
    2a84:	90 95       	com	r25
    2a86:	bc 01       	movw	r22, r24
    2a88:	cd 01       	movw	r24, r26
    2a8a:	08 95       	ret

00002a8c <memcpy>:
    2a8c:	fb 01       	movw	r30, r22
    2a8e:	dc 01       	movw	r26, r24
    2a90:	02 c0       	rjmp	.+4      	; 0x2a96 <memcpy+0xa>
    2a92:	01 90       	ld	r0, Z+
    2a94:	0d 92       	st	X+, r0
    2a96:	41 50       	subi	r20, 0x01	; 1
    2a98:	50 40       	sbci	r21, 0x00	; 0
    2a9a:	d8 f7       	brcc	.-10     	; 0x2a92 <memcpy+0x6>
    2a9c:	08 95       	ret

00002a9e <__itoa_ncheck>:
    2a9e:	bb 27       	eor	r27, r27
    2aa0:	4a 30       	cpi	r20, 0x0A	; 10
    2aa2:	31 f4       	brne	.+12     	; 0x2ab0 <__itoa_ncheck+0x12>
    2aa4:	99 23       	and	r25, r25
    2aa6:	22 f4       	brpl	.+8      	; 0x2ab0 <__itoa_ncheck+0x12>
    2aa8:	bd e2       	ldi	r27, 0x2D	; 45
    2aaa:	90 95       	com	r25
    2aac:	81 95       	neg	r24
    2aae:	9f 4f       	sbci	r25, 0xFF	; 255
    2ab0:	01 c0       	rjmp	.+2      	; 0x2ab4 <__utoa_common>

00002ab2 <__utoa_ncheck>:
    2ab2:	bb 27       	eor	r27, r27

00002ab4 <__utoa_common>:
    2ab4:	fb 01       	movw	r30, r22
    2ab6:	55 27       	eor	r21, r21
    2ab8:	aa 27       	eor	r26, r26
    2aba:	88 0f       	add	r24, r24
    2abc:	99 1f       	adc	r25, r25
    2abe:	aa 1f       	adc	r26, r26
    2ac0:	a4 17       	cp	r26, r20
    2ac2:	10 f0       	brcs	.+4      	; 0x2ac8 <__utoa_common+0x14>
    2ac4:	a4 1b       	sub	r26, r20
    2ac6:	83 95       	inc	r24
    2ac8:	50 51       	subi	r21, 0x10	; 16
    2aca:	b9 f7       	brne	.-18     	; 0x2aba <__utoa_common+0x6>
    2acc:	a0 5d       	subi	r26, 0xD0	; 208
    2ace:	aa 33       	cpi	r26, 0x3A	; 58
    2ad0:	08 f0       	brcs	.+2      	; 0x2ad4 <__utoa_common+0x20>
    2ad2:	a9 5d       	subi	r26, 0xD9	; 217
    2ad4:	a1 93       	st	Z+, r26
    2ad6:	00 97       	sbiw	r24, 0x00	; 0
    2ad8:	79 f7       	brne	.-34     	; 0x2ab8 <__utoa_common+0x4>
    2ada:	b1 11       	cpse	r27, r1
    2adc:	b1 93       	st	Z+, r27
    2ade:	11 92       	st	Z+, r1
    2ae0:	cb 01       	movw	r24, r22
    2ae2:	00 c0       	rjmp	.+0      	; 0x2ae4 <strrev>

00002ae4 <strrev>:
    2ae4:	dc 01       	movw	r26, r24
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	67 2f       	mov	r22, r23
    2aea:	71 91       	ld	r23, Z+
    2aec:	77 23       	and	r23, r23
    2aee:	e1 f7       	brne	.-8      	; 0x2ae8 <strrev+0x4>
    2af0:	32 97       	sbiw	r30, 0x02	; 2
    2af2:	04 c0       	rjmp	.+8      	; 0x2afc <strrev+0x18>
    2af4:	7c 91       	ld	r23, X
    2af6:	6d 93       	st	X+, r22
    2af8:	70 83       	st	Z, r23
    2afa:	62 91       	ld	r22, -Z
    2afc:	ae 17       	cp	r26, r30
    2afe:	bf 07       	cpc	r27, r31
    2b00:	c8 f3       	brcs	.-14     	; 0x2af4 <strrev+0x10>
    2b02:	08 95       	ret

00002b04 <_exit>:
    2b04:	f8 94       	cli

00002b06 <__stop_program>:
    2b06:	ff cf       	rjmp	.-2      	; 0x2b06 <__stop_program>
