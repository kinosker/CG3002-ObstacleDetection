
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800200  00002df4  00002e88  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002df4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070b  00800236  00800236  00002ebe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002ebe  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002eee  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f4e  00000000  00000000  0000345e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001655  00000000  00000000  000093ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000039fd  00000000  00000000  0000aa01  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f90  00000000  00000000  0000e400  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017c2  00000000  00000000  0000f390  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004436  00000000  00000000  00010b52  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014f88  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	ae c3       	rjmp	.+1884   	; 0x782 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 d0 0a 	jmp	0x15a0	; 0x15a0 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	6a c7       	rjmp	.+3796   	; 0xf3a <__vector_25>
      66:	00 00       	nop
      68:	e0 c7       	rjmp	.+4032   	; 0x102a <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	8b c4       	rjmp	.+2326   	; 0x98c <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	1c c7       	rjmp	.+3640   	; 0xeca <__vector_36>
      92:	00 00       	nop
      94:	8a c7       	rjmp	.+3860   	; 0xfaa <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_getFilteredReading+0xa>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 ef       	ldi	r30, 0xF4	; 244
     17e:	fd e2       	ldi	r31, 0x2D	; 45
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 33       	cpi	r26, 0x36	; 54
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a6 e3       	ldi	r26, 0x36	; 54
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a1 34       	cpi	r26, 0x41	; 65
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	d8 d0       	rcall	.+432    	; 0x352 <main>
     1a2:	0c 94 f8 16 	jmp	0x2df0	; 0x2df0 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 07 09 	call	0x120e	; 0x120e <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 47 09 	call	0x128e	; 0x128e <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 3c 09 	call	0x1278	; 0x1278 <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 59 09 	call	0x12b2	; 0x12b2 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 36 02 	lds	r24, 0x0236
     1ce:	81 11       	cpse	r24, r1
     1d0:	0a c0       	rjmp	.+20     	; 0x1e6 <RPI_receiveTask+0x3e>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 4d 09 	call	0x129a	; 0x129a <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	da d7       	rcall	.+4020   	; 0x1194 <myUSART_transmitUSART1_c>
     1e0:	d0 93 36 02 	sts	0x0236, r29
     1e4:	e3 cf       	rjmp	.-58     	; 0x1ac <RPI_receiveTask+0x4>
     1e6:	81 30       	cpi	r24, 0x01	; 1
     1e8:	59 f4       	brne	.+22     	; 0x200 <RPI_receiveTask+0x58>
     1ea:	8c 2f       	mov	r24, r28
     1ec:	0e 94 53 09 	call	0x12a6	; 0x12a6 <myUSART_receiveHandShakeFin>
     1f0:	88 23       	and	r24, r24
     1f2:	19 f0       	breq	.+6      	; 0x1fa <RPI_receiveTask+0x52>
     1f4:	10 93 36 02 	sts	0x0236, r17
     1f8:	d9 cf       	rjmp	.-78     	; 0x1ac <RPI_receiveTask+0x4>
     1fa:	10 92 36 02 	sts	0x0236, r1
     1fe:	d6 cf       	rjmp	.-84     	; 0x1ac <RPI_receiveTask+0x4>
     200:	82 30       	cpi	r24, 0x02	; 2
     202:	a1 f6       	brne	.-88     	; 0x1ac <RPI_receiveTask+0x4>
     204:	c8 31       	cpi	r28, 0x18	; 24
     206:	91 f6       	brne	.-92     	; 0x1ac <RPI_receiveTask+0x4>
     208:	10 92 36 02 	sts	0x0236, r1
     20c:	cf cf       	rjmp	.-98     	; 0x1ac <RPI_receiveTask+0x4>

0000020e <RPI_sendTask>:
     20e:	cf 93       	push	r28
     210:	df 93       	push	r29
     212:	00 d0       	rcall	.+0      	; 0x214 <RPI_sendTask+0x6>
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x8>
     216:	cd b7       	in	r28, 0x3d	; 61
     218:	de b7       	in	r29, 0x3e	; 62
     21a:	0e 94 28 09 	call	0x1250	; 0x1250 <myUSART_startHandShake>
     21e:	18 2f       	mov	r17, r24
     220:	20 e0       	ldi	r18, 0x00	; 0
     222:	4f ef       	ldi	r20, 0xFF	; 255
     224:	5f ef       	ldi	r21, 0xFF	; 255
     226:	be 01       	movw	r22, r28
     228:	6a 5f       	subi	r22, 0xFA	; 250
     22a:	7f 4f       	sbci	r23, 0xFF	; 255
     22c:	80 91 8f 08 	lds	r24, 0x088F
     230:	90 91 90 08 	lds	r25, 0x0890
     234:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xQueueGenericReceive>
     238:	25 c0       	rjmp	.+74     	; 0x284 <RPI_sendTask+0x76>
     23a:	20 e0       	ldi	r18, 0x00	; 0
     23c:	4f ef       	ldi	r20, 0xFF	; 255
     23e:	5f ef       	ldi	r21, 0xFF	; 255
     240:	be 01       	movw	r22, r28
     242:	6f 5f       	subi	r22, 0xFF	; 255
     244:	7f 4f       	sbci	r23, 0xFF	; 255
     246:	80 91 91 08 	lds	r24, 0x0891
     24a:	90 91 92 08 	lds	r25, 0x0892
     24e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <xQueueGenericReceive>
     252:	89 81       	ldd	r24, Y+1	; 0x01
     254:	7e d7       	rcall	.+3836   	; 0x1152 <myUSART_transmitUSART0_c>
     256:	87 e0       	ldi	r24, 0x07	; 7
     258:	92 e0       	ldi	r25, 0x02	; 2
     25a:	cb d7       	rcall	.+3990   	; 0x11f2 <myUSART_transmitUSART0>
     25c:	ce 01       	movw	r24, r28
     25e:	02 96       	adiw	r24, 0x02	; 2
     260:	c8 d7       	rcall	.+3984   	; 0x11f2 <myUSART_transmitUSART0>
     262:	89 e0       	ldi	r24, 0x09	; 9
     264:	92 e0       	ldi	r25, 0x02	; 2
     266:	c5 d7       	rcall	.+3978   	; 0x11f2 <myUSART_transmitUSART0>
     268:	11 23       	and	r17, r17
     26a:	61 f0       	breq	.+24     	; 0x284 <RPI_sendTask+0x76>
     26c:	8e 81       	ldd	r24, Y+6	; 0x06
     26e:	80 5d       	subi	r24, 0xD0	; 208
     270:	91 d7       	rcall	.+3874   	; 0x1194 <myUSART_transmitUSART1_c>
     272:	8a e0       	ldi	r24, 0x0A	; 10
     274:	8f d7       	rcall	.+3870   	; 0x1194 <myUSART_transmitUSART1_c>
     276:	89 81       	ldd	r24, Y+1	; 0x01
     278:	8d d7       	rcall	.+3866   	; 0x1194 <myUSART_transmitUSART1_c>
     27a:	ce 01       	movw	r24, r28
     27c:	02 96       	adiw	r24, 0x02	; 2
     27e:	ab d7       	rcall	.+3926   	; 0x11d6 <myUSART_transmitUSART1>
     280:	8a e0       	ldi	r24, 0x0A	; 10
     282:	88 d7       	rcall	.+3856   	; 0x1194 <myUSART_transmitUSART1_c>
     284:	9e 81       	ldd	r25, Y+6	; 0x06
     286:	2f ef       	ldi	r18, 0xFF	; 255
     288:	29 0f       	add	r18, r25
     28a:	2e 83       	std	Y+6, r18	; 0x06
     28c:	91 11       	cpse	r25, r1
     28e:	d5 cf       	rjmp	.-86     	; 0x23a <RPI_sendTask+0x2c>
     290:	8a e0       	ldi	r24, 0x0A	; 10
     292:	5f d7       	rcall	.+3774   	; 0x1152 <myUSART_transmitUSART0_c>
     294:	c2 cf       	rjmp	.-124    	; 0x21a <RPI_sendTask+0xc>

00000296 <myTimerTask>:
     296:	8e d5       	rcall	.+2844   	; 0xdb4 <myTimer_Init>
     298:	a9 d5       	rcall	.+2898   	; 0xdec <myTimer_DelayChecker>
     29a:	fe cf       	rjmp	.-4      	; 0x298 <myTimerTask+0x2>

0000029c <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     29c:	8f ef       	ldi	r24, 0xFF	; 255
     29e:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2a2:	ef e7       	ldi	r30, 0x7F	; 127
     2a4:	f0 e0       	ldi	r31, 0x00	; 0
     2a6:	90 81       	ld	r25, Z
     2a8:	93 60       	ori	r25, 0x03	; 3
     2aa:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2ac:	80 93 7d 00 	sts	0x007D, r24
     2b0:	08 95       	ret

000002b2 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2b2:	8c ec       	ldi	r24, 0xCC	; 204
     2b4:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2b8:	8e e3       	ldi	r24, 0x3E	; 62
     2ba:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2be:	ee cf       	rjmp	.-36     	; 0x29c <setDigitalInputPowerReduction>
     2c0:	08 95       	ret

000002c2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2c2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2c6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2ca:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ce:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2d2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2d6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2da:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2de:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2e2:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2e6:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2ea:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2ee:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2f2:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2f6:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2fa:	10 92 73 00 	sts	0x0073, r1
     2fe:	08 95       	ret

00000300 <init>:
}

void init()
{
     300:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     302:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     304:	f8 94       	cli
	{
		clearTimer();
     306:	dd df       	rcall	.-70     	; 0x2c2 <clearTimer>
		setPowerReduction();
     308:	d4 df       	rcall	.-88     	; 0x2b2 <setPowerReduction>
		myUSART_USART0_Init();
     30a:	cf d6       	rcall	.+3486   	; 0x10aa <myUSART_USART0_Init>
		myUSART_USART1_Init();
     30c:	f4 d6       	rcall	.+3560   	; 0x10f6 <myUSART_USART1_Init>
		myADC_Init();
     30e:	76 d3       	rcall	.+1772   	; 0x9fc <myADC_Init>
		
		MaxSonar_Init();
     310:	83 b3       	in	r24, 0x13	; 19
     312:	83 60       	ori	r24, 0x03	; 3
     314:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     316:	40 e0       	ldi	r20, 0x00	; 0
     318:	61 e0       	ldi	r22, 0x01	; 1
     31a:	85 e0       	ldi	r24, 0x05	; 5
     31c:	0e 94 cf 0b 	call	0x179e	; 0x179e <xQueueGenericCreate>
     320:	90 93 90 08 	sts	0x0890, r25
     324:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     328:	40 e0       	ldi	r20, 0x00	; 0
     32a:	65 e0       	ldi	r22, 0x05	; 5
     32c:	89 e1       	ldi	r24, 0x19	; 25
     32e:	0e 94 cf 0b 	call	0x179e	; 0x179e <xQueueGenericCreate>
     332:	90 93 92 08 	sts	0x0892, r25
     336:	80 93 91 08 	sts	0x0891, r24
		
		MOTOR_LEFT_INIT();
     33a:	8d b1       	in	r24, 0x0d	; 13
     33c:	88 61       	ori	r24, 0x18	; 24
     33e:	8d b9       	out	0x0d, r24	; 13
		MOTOR_RIGHT_INIT();
     340:	e1 e0       	ldi	r30, 0x01	; 1
     342:	f1 e0       	ldi	r31, 0x01	; 1
     344:	80 81       	ld	r24, Z
     346:	80 61       	ori	r24, 0x10	; 16
     348:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     34a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     34c:	78 94       	sei
}
     34e:	cf 91       	pop	r28
     350:	08 95       	ret

00000352 <main>:
	
	// do nth
}

int main(void)
{
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
     35a:	28 97       	sbiw	r28, 0x08	; 8
     35c:	0f b6       	in	r0, 0x3f	; 63
     35e:	f8 94       	cli
     360:	de bf       	out	0x3e, r29	; 62
     362:	0f be       	out	0x3f, r0	; 63
     364:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     366:	cc df       	rcall	.-104    	; 0x300 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     368:	a1 2c       	mov	r10, r1
     36a:	b1 2c       	mov	r11, r1
     36c:	c1 2c       	mov	r12, r1
     36e:	d1 2c       	mov	r13, r1
     370:	ce 01       	movw	r24, r28
     372:	01 96       	adiw	r24, 0x01	; 1
     374:	7c 01       	movw	r14, r24
     376:	04 e0       	ldi	r16, 0x04	; 4
     378:	9c 01       	movw	r18, r24
     37a:	49 e6       	ldi	r20, 0x69	; 105
     37c:	50 e0       	ldi	r21, 0x00	; 0
     37e:	6b e0       	ldi	r22, 0x0B	; 11
     380:	72 e0       	ldi	r23, 0x02	; 2
     382:	8b e4       	ldi	r24, 0x4B	; 75
     384:	91 e0       	ldi	r25, 0x01	; 1
     386:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     38a:	ce 01       	movw	r24, r28
     38c:	07 96       	adiw	r24, 0x07	; 7
     38e:	7c 01       	movw	r14, r24
     390:	03 e0       	ldi	r16, 0x03	; 3
     392:	20 e0       	ldi	r18, 0x00	; 0
     394:	30 e0       	ldi	r19, 0x00	; 0
     396:	4d e6       	ldi	r20, 0x6D	; 109
     398:	51 e0       	ldi	r21, 0x01	; 1
     39a:	63 e1       	ldi	r22, 0x13	; 19
     39c:	72 e0       	ldi	r23, 0x02	; 2
     39e:	8f e7       	ldi	r24, 0x7F	; 127
     3a0:	92 e0       	ldi	r25, 0x02	; 2
     3a2:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a6:	ce 01       	movw	r24, r28
     3a8:	05 96       	adiw	r24, 0x05	; 5
     3aa:	7c 01       	movw	r14, r24
     3ac:	01 e0       	ldi	r16, 0x01	; 1
     3ae:	20 e0       	ldi	r18, 0x00	; 0
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	47 e8       	ldi	r20, 0x87	; 135
     3b4:	50 e0       	ldi	r21, 0x00	; 0
     3b6:	6c e1       	ldi	r22, 0x1C	; 28
     3b8:	72 e0       	ldi	r23, 0x02	; 2
     3ba:	84 ed       	ldi	r24, 0xD4	; 212
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3c2:	ce 01       	movw	r24, r28
     3c4:	03 96       	adiw	r24, 0x03	; 3
     3c6:	7c 01       	movw	r14, r24
     3c8:	02 e0       	ldi	r16, 0x02	; 2
     3ca:	20 e0       	ldi	r18, 0x00	; 0
     3cc:	30 e0       	ldi	r19, 0x00	; 0
     3ce:	47 e8       	ldi	r20, 0x87	; 135
     3d0:	50 e0       	ldi	r21, 0x00	; 0
     3d2:	68 e2       	ldi	r22, 0x28	; 40
     3d4:	72 e0       	ldi	r23, 0x02	; 2
     3d6:	87 e0       	ldi	r24, 0x07	; 7
     3d8:	91 e0       	ldi	r25, 0x01	; 1
     3da:	0e 94 3c 0e 	call	0x1c78	; 0x1c78 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3de:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <vTaskStartScheduler>
     3e2:	c1 cf       	rjmp	.-126    	; 0x366 <main+0x14>

000003e4 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3e4:	9c 01       	movw	r18, r24
     3e6:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3e8:	64 e6       	ldi	r22, 0x64	; 100
     3ea:	70 e0       	ldi	r23, 0x00	; 0
     3ec:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__divmodhi4>
	
	if(input)
     3f0:	61 15       	cp	r22, r1
     3f2:	71 05       	cpc	r23, r1
     3f4:	21 f0       	breq	.+8      	; 0x3fe <myItoa+0x1a>
		*buffer++ = input + '0';
     3f6:	80 e3       	ldi	r24, 0x30	; 48
     3f8:	86 0f       	add	r24, r22
     3fa:	80 83       	st	Z, r24
     3fc:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     3fe:	4c e9       	ldi	r20, 0x9C	; 156
     400:	46 03       	mulsu	r20, r22
     402:	c0 01       	movw	r24, r0
     404:	47 9f       	mul	r20, r23
     406:	90 0d       	add	r25, r0
     408:	11 24       	eor	r1, r1
     40a:	28 0f       	add	r18, r24
     40c:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     40e:	c9 01       	movw	r24, r18
     410:	6a e0       	ldi	r22, 0x0A	; 10
     412:	70 e0       	ldi	r23, 0x00	; 0
     414:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__divmodhi4>
	*buffer++ = input + '0';
     418:	80 e3       	ldi	r24, 0x30	; 48
     41a:	86 0f       	add	r24, r22
     41c:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     41e:	8a e0       	ldi	r24, 0x0A	; 10
     420:	68 9f       	mul	r22, r24
     422:	20 19       	sub	r18, r0
     424:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     426:	20 5d       	subi	r18, 0xD0	; 208
     428:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     42a:	12 82       	std	Z+2, r1	; 0x02
     42c:	08 95       	ret

0000042e <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{	
     42e:	1f 93       	push	r17
     430:	cf 93       	push	r28
     432:	df 93       	push	r29
     434:	00 d0       	rcall	.+0      	; 0x436 <obstacleSend+0x8>
     436:	1f 92       	push	r1
     438:	1f 92       	push	r1
     43a:	cd b7       	in	r28, 0x3d	; 61
     43c:	de b7       	in	r29, 0x3e	; 62
     43e:	18 2f       	mov	r17, r24
     440:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
		
	if(deviceBlocked)
     442:	11 23       	and	r17, r17
     444:	89 f0       	breq	.+34     	; 0x468 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     446:	be 01       	movw	r22, r28
     448:	6e 5f       	subi	r22, 0xFE	; 254
     44a:	7f 4f       	sbci	r23, 0xFF	; 255
     44c:	cb df       	rcall	.-106    	; 0x3e4 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     44e:	19 83       	std	Y+1, r17	; 0x01
		
		
		xQueueSendToBack(queueObstacleData, (void*) &obstacleInfo, portMAX_DELAY); // send data to queueData
     450:	20 e0       	ldi	r18, 0x00	; 0
     452:	4f ef       	ldi	r20, 0xFF	; 255
     454:	5f ef       	ldi	r21, 0xFF	; 255
     456:	be 01       	movw	r22, r28
     458:	6f 5f       	subi	r22, 0xFF	; 255
     45a:	7f 4f       	sbci	r23, 0xFF	; 255
     45c:	80 91 91 08 	lds	r24, 0x0891
     460:	90 91 92 08 	lds	r25, 0x0892
     464:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <xQueueGenericSend>
	}
}
     468:	0f 90       	pop	r0
     46a:	0f 90       	pop	r0
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	1f 91       	pop	r17
     478:	08 95       	ret

0000047a <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{	
     47a:	8f 92       	push	r8
     47c:	9f 92       	push	r9
     47e:	af 92       	push	r10
     480:	bf 92       	push	r11
     482:	cf 92       	push	r12
     484:	df 92       	push	r13
     486:	ef 92       	push	r14
     488:	ff 92       	push	r15
     48a:	0f 93       	push	r16
     48c:	1f 93       	push	r17
     48e:	cf 93       	push	r28
     490:	df 93       	push	r29
     492:	1f 92       	push	r1
     494:	cd b7       	in	r28, 0x3d	; 61
     496:	de b7       	in	r29, 0x3e	; 62
     498:	89 83       	std	Y+1, r24	; 0x01
     49a:	5b 01       	movw	r10, r22
     49c:	49 01       	movw	r8, r18
	
	if(obstacleDetected > 0)
     49e:	88 23       	and	r24, r24
     4a0:	01 f1       	breq	.+64     	; 0x4e2 <sendObstacleDetected+0x68>
	{
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4a2:	ba 01       	movw	r22, r20
     4a4:	f5 01       	movw	r30, r10
     4a6:	80 81       	ld	r24, Z
     4a8:	c2 df       	rcall	.-124    	; 0x42e <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4aa:	b4 01       	movw	r22, r8
     4ac:	f5 01       	movw	r30, r10
     4ae:	81 81       	ldd	r24, Z+1	; 0x01
     4b0:	be df       	rcall	.-132    	; 0x42e <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4b2:	b8 01       	movw	r22, r16
     4b4:	f5 01       	movw	r30, r10
     4b6:	82 81       	ldd	r24, Z+2	; 0x02
     4b8:	ba df       	rcall	.-140    	; 0x42e <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4ba:	b7 01       	movw	r22, r14
     4bc:	f5 01       	movw	r30, r10
     4be:	83 81       	ldd	r24, Z+3	; 0x03
     4c0:	b6 df       	rcall	.-148    	; 0x42e <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4c2:	b6 01       	movw	r22, r12
     4c4:	f5 01       	movw	r30, r10
     4c6:	84 81       	ldd	r24, Z+4	; 0x04
     4c8:	b2 df       	rcall	.-156    	; 0x42e <obstacleSend>
				//myUSART_transmitUSART0("p\n");
				//myUSART_transmitUSART0_c(totalObs + '0');
				//myUSART_transmitUSART0("M\n");
			//}
			
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4ca:	20 e0       	ldi	r18, 0x00	; 0
     4cc:	4f ef       	ldi	r20, 0xFF	; 255
     4ce:	5f ef       	ldi	r21, 0xFF	; 255
     4d0:	be 01       	movw	r22, r28
     4d2:	6f 5f       	subi	r22, 0xFF	; 255
     4d4:	7f 4f       	sbci	r23, 0xFF	; 255
     4d6:	80 91 8f 08 	lds	r24, 0x088F
     4da:	90 91 90 08 	lds	r25, 0x0890
     4de:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <xQueueGenericSend>
		
	}
}
     4e2:	0f 90       	pop	r0
     4e4:	df 91       	pop	r29
     4e6:	cf 91       	pop	r28
     4e8:	1f 91       	pop	r17
     4ea:	0f 91       	pop	r16
     4ec:	ff 90       	pop	r15
     4ee:	ef 90       	pop	r14
     4f0:	df 90       	pop	r13
     4f2:	cf 90       	pop	r12
     4f4:	bf 90       	pop	r11
     4f6:	af 90       	pop	r10
     4f8:	9f 90       	pop	r9
     4fa:	8f 90       	pop	r8
     4fc:	08 95       	ret

000004fe <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4fe:	cf 93       	push	r28
     500:	df 93       	push	r29
     502:	cd b7       	in	r28, 0x3d	; 61
     504:	de b7       	in	r29, 0x3e	; 62
     506:	a4 97       	sbiw	r28, 0x24	; 36
     508:	0f b6       	in	r0, 0x3f	; 63
     50a:	f8 94       	cli
     50c:	de bf       	out	0x3e, r29	; 62
     50e:	0f be       	out	0x3f, r0	; 63
     510:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     512:	86 e0       	ldi	r24, 0x06	; 6
     514:	fe 01       	movw	r30, r28
     516:	33 96       	adiw	r30, 0x03	; 3
     518:	df 01       	movw	r26, r30
     51a:	98 2f       	mov	r25, r24
     51c:	1d 92       	st	X+, r1
     51e:	9a 95       	dec	r25
     520:	e9 f7       	brne	.-6      	; 0x51c <Sonar_Task+0x1e>
     522:	36 96       	adiw	r30, 0x06	; 6
     524:	df 01       	movw	r26, r30
     526:	98 2f       	mov	r25, r24
     528:	1d 92       	st	X+, r1
     52a:	9a 95       	dec	r25
     52c:	e9 f7       	brne	.-6      	; 0x528 <Sonar_Task+0x2a>
     52e:	36 96       	adiw	r30, 0x06	; 6
     530:	df 01       	movw	r26, r30
     532:	98 2f       	mov	r25, r24
     534:	1d 92       	st	X+, r1
     536:	9a 95       	dec	r25
     538:	e9 f7       	brne	.-6      	; 0x534 <Sonar_Task+0x36>
     53a:	36 96       	adiw	r30, 0x06	; 6
     53c:	df 01       	movw	r26, r30
     53e:	1d 92       	st	X+, r1
     540:	8a 95       	dec	r24
     542:	e9 f7       	brne	.-6      	; 0x53e <Sonar_Task+0x40>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     544:	36 96       	adiw	r30, 0x06	; 6
     546:	85 e0       	ldi	r24, 0x05	; 5
     548:	df 01       	movw	r26, r30
     54a:	1d 92       	st	X+, r1
     54c:	8a 95       	dec	r24
     54e:	e9 f7       	brne	.-6      	; 0x54a <Sonar_Task+0x4c>
	
	
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     550:	84 e2       	ldi	r24, 0x24	; 36
     552:	92 d3       	rcall	.+1828   	; 0xc78 <mySharpIR_Read>
     554:	99 a3       	std	Y+33, r25	; 0x21
     556:	88 a3       	std	Y+32, r24	; 0x20
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     558:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <xTaskGetTickCount>
     55c:	9a 83       	std	Y+2, r25	; 0x02
     55e:	89 83       	std	Y+1, r24	; 0x01


void Sonar_Task(void *p)
{
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     560:	1c a2       	std	Y+36, r1	; 0x24
	xLastWakeTime = xTaskGetTickCount(); // get tick count
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     562:	9a d1       	rcall	.+820    	; 0x898 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     564:	87 e2       	ldi	r24, 0x27	; 39
     566:	00 d2       	rcall	.+1024   	; 0x968 <myMaxSonar_Read>
     568:	be 01       	movw	r22, r28
     56a:	67 5f       	subi	r22, 0xF7	; 247
     56c:	7f 4f       	sbci	r23, 0xFF	; 255
     56e:	f3 d1       	rcall	.+998    	; 0x956 <myMaxSonar_getFilteredReading>
     570:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     572:	86 e2       	ldi	r24, 0x26	; 38
     574:	f9 d1       	rcall	.+1010   	; 0x968 <myMaxSonar_Read>
     576:	be 01       	movw	r22, r28
     578:	61 5f       	subi	r22, 0xF1	; 241
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	ec d1       	rcall	.+984    	; 0x956 <myMaxSonar_getFilteredReading>
     57e:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     580:	85 e2       	ldi	r24, 0x25	; 37
     582:	f2 d1       	rcall	.+996    	; 0x968 <myMaxSonar_Read>
     584:	be 01       	movw	r22, r28
     586:	6b 5e       	subi	r22, 0xEB	; 235
     588:	7f 4f       	sbci	r23, 0xFF	; 255
     58a:	e5 d1       	rcall	.+970    	; 0x956 <myMaxSonar_getFilteredReading>
     58c:	2c 01       	movw	r4, r24
		
		myMaxSonar_TopStart();
     58e:	8b d1       	rcall	.+790    	; 0x8a6 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     590:	83 e2       	ldi	r24, 0x23	; 35
     592:	ea d1       	rcall	.+980    	; 0x968 <myMaxSonar_Read>
     594:	be 01       	movw	r22, r28
     596:	6d 5f       	subi	r22, 0xFD	; 253
     598:	7f 4f       	sbci	r23, 0xFF	; 255
     59a:	dd d1       	rcall	.+954    	; 0x956 <myMaxSonar_getFilteredReading>
     59c:	9b a3       	std	Y+35, r25	; 0x23
     59e:	8a a3       	std	Y+34, r24	; 0x22
			
			
		btmIR	= mySharpIR_Read(AN12);
     5a0:	84 e2       	ldi	r24, 0x24	; 36
     5a2:	6a d3       	rcall	.+1748   	; 0xc78 <mySharpIR_Read>
     5a4:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5a6:	bc 01       	movw	r22, r24
     5a8:	ce 01       	movw	r24, r28
     5aa:	80 96       	adiw	r24, 0x20	; 32
     5ac:	9e d3       	rcall	.+1852   	; 0xcea <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5ae:	c8 a0       	ldd	r12, Y+32	; 0x20
     5b0:	d9 a0       	ldd	r13, Y+33	; 0x21
     5b2:	54 01       	movw	r10, r8
     5b4:	ea a0       	ldd	r14, Y+34	; 0x22
     5b6:	fb a0       	ldd	r15, Y+35	; 0x23
     5b8:	82 01       	movw	r16, r4
     5ba:	91 01       	movw	r18, r2
     5bc:	ae 01       	movw	r20, r28
     5be:	45 5e       	subi	r20, 0xE5	; 229
     5c0:	5f 4f       	sbci	r21, 0xFF	; 255
     5c2:	6c a1       	ldd	r22, Y+36	; 0x24
     5c4:	c3 01       	movw	r24, r6
     5c6:	19 d3       	rcall	.+1586   	; 0xbfa <obstacleDetection>
     5c8:	8c a3       	std	Y+36, r24	; 0x24
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5ca:	ce 01       	movw	r24, r28
     5cc:	4b 96       	adiw	r24, 0x1b	; 27
     5ce:	7c 01       	movw	r14, r24
     5d0:	84 01       	movw	r16, r8
     5d2:	92 01       	movw	r18, r4
     5d4:	a1 01       	movw	r20, r2
     5d6:	6a a1       	ldd	r22, Y+34	; 0x22
     5d8:	7b a1       	ldd	r23, Y+35	; 0x23
     5da:	c3 01       	movw	r24, r6
     5dc:	9c d2       	rcall	.+1336   	; 0xb16 <obstacleAvoidance>
		//cheatPrintAll(deviceBlocked, &obstacleDetected); 
		// remove top statement... when not debuggin..
		
		
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5de:	ca a0       	ldd	r12, Y+34	; 0x22
     5e0:	db a0       	ldd	r13, Y+35	; 0x23
     5e2:	74 01       	movw	r14, r8
     5e4:	82 01       	movw	r16, r4
     5e6:	91 01       	movw	r18, r2
     5e8:	a3 01       	movw	r20, r6
     5ea:	be 01       	movw	r22, r28
     5ec:	65 5e       	subi	r22, 0xE5	; 229
     5ee:	7f 4f       	sbci	r23, 0xFF	; 255
     5f0:	8c a1       	ldd	r24, Y+36	; 0x24
     5f2:	43 df       	rcall	.-378    	; 0x47a <sendObstacleDetected>
	
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     5f4:	66 e9       	ldi	r22, 0x96	; 150
     5f6:	70 e0       	ldi	r23, 0x00	; 0
     5f8:	ce 01       	movw	r24, r28
     5fa:	01 96       	adiw	r24, 0x01	; 1
     5fc:	0e 94 ce 10 	call	0x219c	; 0x219c <vTaskDelayUntil>
     600:	b0 cf       	rjmp	.-160    	; 0x562 <Sonar_Task+0x64>

00000602 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     608:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     60c:	80 91 37 02 	lds	r24, 0x0237
     610:	90 91 38 02 	lds	r25, 0x0238
     614:	89 2b       	or	r24, r25
     616:	31 f4       	brne	.+12     	; 0x624 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     618:	8c e3       	ldi	r24, 0x3C	; 60
     61a:	92 e0       	ldi	r25, 0x02	; 2
     61c:	90 93 38 02 	sts	0x0238, r25
     620:	80 93 37 02 	sts	0x0237, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     624:	40 91 39 02 	lds	r20, 0x0239
     628:	50 91 3a 02 	lds	r21, 0x023A
     62c:	9e 01       	movw	r18, r28
     62e:	24 0f       	add	r18, r20
     630:	35 1f       	adc	r19, r21
     632:	2b 3d       	cpi	r18, 0xDB	; 219
     634:	85 e0       	ldi	r24, 0x05	; 5
     636:	38 07       	cpc	r19, r24
     638:	70 f4       	brcc	.+28     	; 0x656 <pvPortMalloc+0x54>
     63a:	42 17       	cp	r20, r18
     63c:	53 07       	cpc	r21, r19
     63e:	70 f4       	brcc	.+28     	; 0x65c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     640:	c0 91 37 02 	lds	r28, 0x0237
     644:	d0 91 38 02 	lds	r29, 0x0238
     648:	c4 0f       	add	r28, r20
     64a:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     64c:	30 93 3a 02 	sts	0x023A, r19
     650:	20 93 39 02 	sts	0x0239, r18
     654:	05 c0       	rjmp	.+10     	; 0x660 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     656:	c0 e0       	ldi	r28, 0x00	; 0
     658:	d0 e0       	ldi	r29, 0x00	; 0
     65a:	02 c0       	rjmp	.+4      	; 0x660 <pvPortMalloc+0x5e>
     65c:	c0 e0       	ldi	r28, 0x00	; 0
     65e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     660:	0e 94 4d 10 	call	0x209a	; 0x209a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     664:	ce 01       	movw	r24, r28
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	08 95       	ret

0000066c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     66c:	08 95       	ret

0000066e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     66e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     670:	03 96       	adiw	r24, 0x03	; 3
     672:	92 83       	std	Z+2, r25	; 0x02
     674:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     676:	2f ef       	ldi	r18, 0xFF	; 255
     678:	3f ef       	ldi	r19, 0xFF	; 255
     67a:	34 83       	std	Z+4, r19	; 0x04
     67c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     67e:	96 83       	std	Z+6, r25	; 0x06
     680:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     682:	90 87       	std	Z+8, r25	; 0x08
     684:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     686:	10 82       	st	Z, r1
     688:	08 95       	ret

0000068a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     68a:	fc 01       	movw	r30, r24
     68c:	11 86       	std	Z+9, r1	; 0x09
     68e:	10 86       	std	Z+8, r1	; 0x08
     690:	08 95       	ret

00000692 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	9c 01       	movw	r18, r24
     698:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     69a:	dc 01       	movw	r26, r24
     69c:	11 96       	adiw	r26, 0x01	; 1
     69e:	cd 91       	ld	r28, X+
     6a0:	dc 91       	ld	r29, X
     6a2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6a4:	d3 83       	std	Z+3, r29	; 0x03
     6a6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6a8:	8c 81       	ldd	r24, Y+4	; 0x04
     6aa:	9d 81       	ldd	r25, Y+5	; 0x05
     6ac:	95 83       	std	Z+5, r25	; 0x05
     6ae:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6b0:	8c 81       	ldd	r24, Y+4	; 0x04
     6b2:	9d 81       	ldd	r25, Y+5	; 0x05
     6b4:	dc 01       	movw	r26, r24
     6b6:	13 96       	adiw	r26, 0x03	; 3
     6b8:	7c 93       	st	X, r23
     6ba:	6e 93       	st	-X, r22
     6bc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6be:	7d 83       	std	Y+5, r23	; 0x05
     6c0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6c2:	31 87       	std	Z+9, r19	; 0x09
     6c4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6c6:	f9 01       	movw	r30, r18
     6c8:	80 81       	ld	r24, Z
     6ca:	8f 5f       	subi	r24, 0xFF	; 255
     6cc:	80 83       	st	Z, r24
}
     6ce:	df 91       	pop	r29
     6d0:	cf 91       	pop	r28
     6d2:	08 95       	ret

000006d4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6d4:	cf 93       	push	r28
     6d6:	df 93       	push	r29
     6d8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6da:	48 81       	ld	r20, Y
     6dc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6de:	4f 3f       	cpi	r20, 0xFF	; 255
     6e0:	2f ef       	ldi	r18, 0xFF	; 255
     6e2:	52 07       	cpc	r21, r18
     6e4:	21 f4       	brne	.+8      	; 0x6ee <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6e6:	fc 01       	movw	r30, r24
     6e8:	a7 81       	ldd	r26, Z+7	; 0x07
     6ea:	b0 85       	ldd	r27, Z+8	; 0x08
     6ec:	0d c0       	rjmp	.+26     	; 0x708 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ee:	dc 01       	movw	r26, r24
     6f0:	13 96       	adiw	r26, 0x03	; 3
     6f2:	12 96       	adiw	r26, 0x02	; 2
     6f4:	ed 91       	ld	r30, X+
     6f6:	fc 91       	ld	r31, X
     6f8:	13 97       	sbiw	r26, 0x03	; 3
     6fa:	20 81       	ld	r18, Z
     6fc:	31 81       	ldd	r19, Z+1	; 0x01
     6fe:	42 17       	cp	r20, r18
     700:	53 07       	cpc	r21, r19
     702:	10 f0       	brcs	.+4      	; 0x708 <vListInsert+0x34>
     704:	df 01       	movw	r26, r30
     706:	f5 cf       	rjmp	.-22     	; 0x6f2 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     708:	12 96       	adiw	r26, 0x02	; 2
     70a:	ed 91       	ld	r30, X+
     70c:	fc 91       	ld	r31, X
     70e:	13 97       	sbiw	r26, 0x03	; 3
     710:	fb 83       	std	Y+3, r31	; 0x03
     712:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     714:	d5 83       	std	Z+5, r29	; 0x05
     716:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     718:	bd 83       	std	Y+5, r27	; 0x05
     71a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     71c:	13 96       	adiw	r26, 0x03	; 3
     71e:	dc 93       	st	X, r29
     720:	ce 93       	st	-X, r28
     722:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     724:	99 87       	std	Y+9, r25	; 0x09
     726:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     728:	fc 01       	movw	r30, r24
     72a:	20 81       	ld	r18, Z
     72c:	2f 5f       	subi	r18, 0xFF	; 255
     72e:	20 83       	st	Z, r18
}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	08 95       	ret

00000736 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     73c:	a0 85       	ldd	r26, Z+8	; 0x08
     73e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     740:	c2 81       	ldd	r28, Z+2	; 0x02
     742:	d3 81       	ldd	r29, Z+3	; 0x03
     744:	84 81       	ldd	r24, Z+4	; 0x04
     746:	95 81       	ldd	r25, Z+5	; 0x05
     748:	9d 83       	std	Y+5, r25	; 0x05
     74a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     74c:	c4 81       	ldd	r28, Z+4	; 0x04
     74e:	d5 81       	ldd	r29, Z+5	; 0x05
     750:	82 81       	ldd	r24, Z+2	; 0x02
     752:	93 81       	ldd	r25, Z+3	; 0x03
     754:	9b 83       	std	Y+3, r25	; 0x03
     756:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     758:	11 96       	adiw	r26, 0x01	; 1
     75a:	cd 91       	ld	r28, X+
     75c:	dc 91       	ld	r29, X
     75e:	12 97       	sbiw	r26, 0x02	; 2
     760:	ce 17       	cp	r28, r30
     762:	df 07       	cpc	r29, r31
     764:	31 f4       	brne	.+12     	; 0x772 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     766:	8c 81       	ldd	r24, Y+4	; 0x04
     768:	9d 81       	ldd	r25, Y+5	; 0x05
     76a:	12 96       	adiw	r26, 0x02	; 2
     76c:	9c 93       	st	X, r25
     76e:	8e 93       	st	-X, r24
     770:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     772:	11 86       	std	Z+9, r1	; 0x09
     774:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     776:	8c 91       	ld	r24, X
     778:	81 50       	subi	r24, 0x01	; 1
     77a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	08 95       	ret

00000782 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     782:	1f 92       	push	r1
     784:	0f 92       	push	r0
     786:	0f b6       	in	r0, 0x3f	; 63
     788:	0f 92       	push	r0
     78a:	11 24       	eor	r1, r1
     78c:	0b b6       	in	r0, 0x3b	; 59
     78e:	0f 92       	push	r0
     790:	2f 93       	push	r18
     792:	3f 93       	push	r19
     794:	4f 93       	push	r20
     796:	5f 93       	push	r21
     798:	6f 93       	push	r22
     79a:	7f 93       	push	r23
     79c:	8f 93       	push	r24
     79e:	9f 93       	push	r25
     7a0:	af 93       	push	r26
     7a2:	bf 93       	push	r27
     7a4:	ef 93       	push	r30
     7a6:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7a8:	1b 9b       	sbis	0x03, 3	; 3
     7aa:	0d c0       	rjmp	.+26     	; 0x7c6 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7ac:	1d d3       	rcall	.+1594   	; 0xde8 <myTimer_Read>
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	90 93 98 08 	sts	0x0898, r25
     7b4:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7b8:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <xTaskGetTickCountFromISR>
     7bc:	90 93 94 08 	sts	0x0894, r25
     7c0:	80 93 93 08 	sts	0x0893, r24
     7c4:	56 c0       	rjmp	.+172    	; 0x872 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7c6:	1b 99       	sbic	0x03, 3	; 3
     7c8:	54 c0       	rjmp	.+168    	; 0x872 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7ca:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <xTaskGetTickCountFromISR>
     7ce:	90 93 9e 08 	sts	0x089E, r25
     7d2:	80 93 9d 08 	sts	0x089D, r24
     7d6:	20 91 93 08 	lds	r18, 0x0893
     7da:	30 91 94 08 	lds	r19, 0x0894
     7de:	82 17       	cp	r24, r18
     7e0:	93 07       	cpc	r25, r19
     7e2:	4c f4       	brge	.+18     	; 0x7f6 <__vector_9+0x74>
			ms_tickEnd += 65535;
     7e4:	80 91 9d 08 	lds	r24, 0x089D
     7e8:	90 91 9e 08 	lds	r25, 0x089E
     7ec:	01 97       	sbiw	r24, 0x01	; 1
     7ee:	90 93 9e 08 	sts	0x089E, r25
     7f2:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     7f6:	f8 d2       	rcall	.+1520   	; 0xde8 <myTimer_Read>
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	90 93 a0 08 	sts	0x08A0, r25
     7fe:	80 93 9f 08 	sts	0x089F, r24
     802:	20 91 97 08 	lds	r18, 0x0897
     806:	30 91 98 08 	lds	r19, 0x0898
     80a:	82 17       	cp	r24, r18
     80c:	93 07       	cpc	r25, r19
     80e:	54 f4       	brge	.+20     	; 0x824 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     810:	80 91 9f 08 	lds	r24, 0x089F
     814:	90 91 a0 08 	lds	r25, 0x08A0
     818:	86 50       	subi	r24, 0x06	; 6
     81a:	9f 4f       	sbci	r25, 0xFF	; 255
     81c:	90 93 a0 08 	sts	0x08A0, r25
     820:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     824:	80 91 9f 08 	lds	r24, 0x089F
     828:	90 91 a0 08 	lds	r25, 0x08A0
     82c:	20 91 97 08 	lds	r18, 0x0897
     830:	30 91 98 08 	lds	r19, 0x0898
     834:	82 1b       	sub	r24, r18
     836:	93 0b       	sbc	r25, r19
     838:	90 93 9a 08 	sts	0x089A, r25
     83c:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     840:	80 91 9d 08 	lds	r24, 0x089D
     844:	90 91 9e 08 	lds	r25, 0x089E
     848:	20 91 93 08 	lds	r18, 0x0893
     84c:	30 91 94 08 	lds	r19, 0x0894
     850:	82 1b       	sub	r24, r18
     852:	93 0b       	sbc	r25, r19
     854:	90 93 96 08 	sts	0x0896, r25
     858:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     85c:	20 e0       	ldi	r18, 0x00	; 0
     85e:	40 e0       	ldi	r20, 0x00	; 0
     860:	50 e0       	ldi	r21, 0x00	; 0
     862:	60 e0       	ldi	r22, 0x00	; 0
     864:	70 e0       	ldi	r23, 0x00	; 0
     866:	80 91 9b 08 	lds	r24, 0x089B
     86a:	90 91 9c 08 	lds	r25, 0x089C
     86e:	0e 94 ba 0c 	call	0x1974	; 0x1974 <xQueueGenericSendFromISR>
	}	
}
     872:	ff 91       	pop	r31
     874:	ef 91       	pop	r30
     876:	bf 91       	pop	r27
     878:	af 91       	pop	r26
     87a:	9f 91       	pop	r25
     87c:	8f 91       	pop	r24
     87e:	7f 91       	pop	r23
     880:	6f 91       	pop	r22
     882:	5f 91       	pop	r21
     884:	4f 91       	pop	r20
     886:	3f 91       	pop	r19
     888:	2f 91       	pop	r18
     88a:	0f 90       	pop	r0
     88c:	0b be       	out	0x3b, r0	; 59
     88e:	0f 90       	pop	r0
     890:	0f be       	out	0x3f, r0	; 63
     892:	0f 90       	pop	r0
     894:	1f 90       	pop	r1
     896:	18 95       	reti

00000898 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     898:	a1 9a       	sbi	0x14, 1	; 20
	
	//myTimer_DelayMicro(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     89a:	81 e0       	ldi	r24, 0x01	; 1
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskDelay>
	
	MaxSonar_BtmTriggerStop();
     8a2:	a1 98       	cbi	0x14, 1	; 20
     8a4:	08 95       	ret

000008a6 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8a6:	a0 9a       	sbi	0x14, 0	; 20
	
	//myTimer_DelayMicro2(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskDelay>
	
	MaxSonar_TopTriggerStop();
     8b0:	a0 98       	cbi	0x14, 0	; 20
     8b2:	08 95       	ret

000008b4 <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8b4:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8b6:	80 81       	ld	r24, Z
     8b8:	91 81       	ldd	r25, Z+1	; 0x01
     8ba:	22 81       	ldd	r18, Z+2	; 0x02
     8bc:	33 81       	ldd	r19, Z+3	; 0x03
     8be:	28 17       	cp	r18, r24
     8c0:	39 07       	cpc	r19, r25
     8c2:	54 f4       	brge	.+20     	; 0x8d8 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8c4:	44 81       	ldd	r20, Z+4	; 0x04
     8c6:	55 81       	ldd	r21, Z+5	; 0x05
     8c8:	42 17       	cp	r20, r18
     8ca:	53 07       	cpc	r21, r19
     8cc:	84 f0       	brlt	.+32     	; 0x8ee <myMaxSonar_extractMedian+0x3a>
     8ce:	48 17       	cp	r20, r24
     8d0:	59 07       	cpc	r21, r25
     8d2:	74 f4       	brge	.+28     	; 0x8f0 <myMaxSonar_extractMedian+0x3c>
     8d4:	ca 01       	movw	r24, r20
     8d6:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8d8:	44 81       	ldd	r20, Z+4	; 0x04
     8da:	55 81       	ldd	r21, Z+5	; 0x05
     8dc:	48 17       	cp	r20, r24
     8de:	59 07       	cpc	r21, r25
     8e0:	3c f0       	brlt	.+14     	; 0x8f0 <myMaxSonar_extractMedian+0x3c>
     8e2:	ca 01       	movw	r24, r20
     8e4:	24 17       	cp	r18, r20
     8e6:	35 07       	cpc	r19, r21
     8e8:	1c f4       	brge	.+6      	; 0x8f0 <myMaxSonar_extractMedian+0x3c>
     8ea:	c9 01       	movw	r24, r18
     8ec:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     8ee:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     8f0:	08 95       	ret

000008f2 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     8f2:	9b 01       	movw	r18, r22
     8f4:	28 5f       	subi	r18, 0xF8	; 248
     8f6:	3f 4f       	sbci	r19, 0xFF	; 255
     8f8:	28 17       	cp	r18, r24
     8fa:	39 07       	cpc	r19, r25
     8fc:	3c f0       	brlt	.+14     	; 0x90c <myMaxSonar_Stabilizer+0x1a>
     8fe:	20 51       	subi	r18, 0x10	; 16
     900:	31 09       	sbc	r19, r1
     902:	82 17       	cp	r24, r18
     904:	93 07       	cpc	r25, r19
     906:	14 f0       	brlt	.+4      	; 0x90c <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     908:	86 2f       	mov	r24, r22
     90a:	97 2f       	mov	r25, r23
}
     90c:	08 95       	ret

0000090e <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     90e:	0f 93       	push	r16
     910:	1f 93       	push	r17
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
     916:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     918:	00 91 00 02 	lds	r16, 0x0200
     91c:	10 e0       	ldi	r17, 0x00	; 0
     91e:	f8 01       	movw	r30, r16
     920:	ee 0f       	add	r30, r30
     922:	ff 1f       	adc	r31, r31
     924:	e6 0f       	add	r30, r22
     926:	f7 1f       	adc	r31, r23
     928:	60 81       	ld	r22, Z
     92a:	71 81       	ldd	r23, Z+1	; 0x01
     92c:	e2 df       	rcall	.-60     	; 0x8f2 <myMaxSonar_Stabilizer>
     92e:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     930:	c8 01       	movw	r24, r16
     932:	01 96       	adiw	r24, 0x01	; 1
     934:	63 e0       	ldi	r22, 0x03	; 3
     936:	70 e0       	ldi	r23, 0x00	; 0
     938:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__divmodhi4>
     93c:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     940:	88 0f       	add	r24, r24
     942:	99 1f       	adc	r25, r25
     944:	c8 0f       	add	r28, r24
     946:	d9 1f       	adc	r29, r25
     948:	39 83       	std	Y+1, r19	; 0x01
     94a:	28 83       	st	Y, r18
}
     94c:	df 91       	pop	r29
     94e:	cf 91       	pop	r28
     950:	1f 91       	pop	r17
     952:	0f 91       	pop	r16
     954:	08 95       	ret

00000956 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     956:	cf 93       	push	r28
     958:	df 93       	push	r29
     95a:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     95c:	d8 df       	rcall	.-80     	; 0x90e <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     95e:	ce 01       	movw	r24, r28
     960:	a9 df       	rcall	.-174    	; 0x8b4 <myMaxSonar_extractMedian>

}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	08 95       	ret

00000968 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     968:	b3 d0       	rcall	.+358    	; 0xad0 <myADC_analogRead>
     96a:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     96c:	63 e0       	ldi	r22, 0x03	; 3
     96e:	70 e0       	ldi	r23, 0x00	; 0
     970:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     974:	26 0f       	add	r18, r22
     976:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     978:	29 3e       	cpi	r18, 0xE9	; 233
     97a:	83 e0       	ldi	r24, 0x03	; 3
     97c:	38 07       	cpc	r19, r24
     97e:	1c f0       	brlt	.+6      	; 0x986 <myMaxSonar_Read+0x1e>
		return 999;
     980:	87 ee       	ldi	r24, 0xE7	; 231
     982:	93 e0       	ldi	r25, 0x03	; 3
     984:	08 95       	ret
	
	return reading;
     986:	82 2f       	mov	r24, r18
     988:	93 2f       	mov	r25, r19
}
     98a:	08 95       	ret

0000098c <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     98c:	1f 92       	push	r1
     98e:	0f 92       	push	r0
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	0f 92       	push	r0
     994:	11 24       	eor	r1, r1
     996:	0b b6       	in	r0, 0x3b	; 59
     998:	0f 92       	push	r0
     99a:	2f 93       	push	r18
     99c:	3f 93       	push	r19
     99e:	4f 93       	push	r20
     9a0:	5f 93       	push	r21
     9a2:	6f 93       	push	r22
     9a4:	7f 93       	push	r23
     9a6:	8f 93       	push	r24
     9a8:	9f 93       	push	r25
     9aa:	af 93       	push	r26
     9ac:	bf 93       	push	r27
     9ae:	ef 93       	push	r30
     9b0:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9b2:	80 91 78 00 	lds	r24, 0x0078
     9b6:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9ba:	80 91 79 00 	lds	r24, 0x0079
     9be:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	60 e0       	ldi	r22, 0x00	; 0
     9ca:	70 e0       	ldi	r23, 0x00	; 0
     9cc:	80 91 a5 08 	lds	r24, 0x08A5
     9d0:	90 91 a6 08 	lds	r25, 0x08A6
     9d4:	cf d7       	rcall	.+3998   	; 0x1974 <xQueueGenericSendFromISR>
}
     9d6:	ff 91       	pop	r31
     9d8:	ef 91       	pop	r30
     9da:	bf 91       	pop	r27
     9dc:	af 91       	pop	r26
     9de:	9f 91       	pop	r25
     9e0:	8f 91       	pop	r24
     9e2:	7f 91       	pop	r23
     9e4:	6f 91       	pop	r22
     9e6:	5f 91       	pop	r21
     9e8:	4f 91       	pop	r20
     9ea:	3f 91       	pop	r19
     9ec:	2f 91       	pop	r18
     9ee:	0f 90       	pop	r0
     9f0:	0b be       	out	0x3b, r0	; 59
     9f2:	0f 90       	pop	r0
     9f4:	0f be       	out	0x3f, r0	; 63
     9f6:	0f 90       	pop	r0
     9f8:	1f 90       	pop	r1
     9fa:	18 95       	reti

000009fc <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     9fc:	8f e8       	ldi	r24, 0x8F	; 143
     9fe:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a02:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a06:	80 e4       	ldi	r24, 0x40	; 64
     a08:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a0c:	43 e0       	ldi	r20, 0x03	; 3
     a0e:	60 e0       	ldi	r22, 0x00	; 0
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	c5 d6       	rcall	.+3466   	; 0x179e <xQueueGenericCreate>
     a14:	90 93 a6 08 	sts	0x08A6, r25
     a18:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a1c:	81 e0       	ldi	r24, 0x01	; 1
     a1e:	7f d7       	rcall	.+3838   	; 0x191e <xQueueCreateMutex>
     a20:	90 93 a4 08 	sts	0x08A4, r25
     a24:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a28:	20 e0       	ldi	r18, 0x00	; 0
     a2a:	40 e0       	ldi	r20, 0x00	; 0
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	60 e0       	ldi	r22, 0x00	; 0
     a30:	70 e0       	ldi	r23, 0x00	; 0
     a32:	e2 c6       	rjmp	.+3524   	; 0x17f8 <xQueueGenericSend>
     a34:	08 95       	ret

00000a36 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a36:	cf 93       	push	r28
     a38:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a3a:	20 e0       	ldi	r18, 0x00	; 0
     a3c:	4f ef       	ldi	r20, 0xFF	; 255
     a3e:	5f ef       	ldi	r21, 0xFF	; 255
     a40:	60 e0       	ldi	r22, 0x00	; 0
     a42:	70 e0       	ldi	r23, 0x00	; 0
     a44:	80 91 a3 08 	lds	r24, 0x08A3
     a48:	90 91 a4 08 	lds	r25, 0x08A4
     a4c:	cd d7       	rcall	.+3994   	; 0x19e8 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a4e:	ec e7       	ldi	r30, 0x7C	; 124
     a50:	f0 e0       	ldi	r31, 0x00	; 0
     a52:	80 81       	ld	r24, Z
     a54:	9c 2f       	mov	r25, r28
     a56:	9f 71       	andi	r25, 0x1F	; 31
     a58:	80 76       	andi	r24, 0x60	; 96
     a5a:	89 2b       	or	r24, r25
     a5c:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a5e:	eb e7       	ldi	r30, 0x7B	; 123
     a60:	f0 e0       	ldi	r31, 0x00	; 0
     a62:	20 81       	ld	r18, Z
     a64:	c0 72       	andi	r28, 0x20	; 32
     a66:	8c 2f       	mov	r24, r28
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	95 95       	asr	r25
     a6c:	87 95       	ror	r24
     a6e:	95 95       	asr	r25
     a70:	87 95       	ror	r24
     a72:	92 2f       	mov	r25, r18
     a74:	90 76       	andi	r25, 0x60	; 96
     a76:	89 2b       	or	r24, r25
     a78:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a7a:	ea e7       	ldi	r30, 0x7A	; 122
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	80 81       	ld	r24, Z
     a80:	80 64       	ori	r24, 0x40	; 64
     a82:	80 83       	st	Z, r24
}
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <myADC_readADC>:

int myADC_readADC(char channel)
{
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a8c:	20 e0       	ldi	r18, 0x00	; 0
     a8e:	4f ef       	ldi	r20, 0xFF	; 255
     a90:	5f ef       	ldi	r21, 0xFF	; 255
     a92:	60 e0       	ldi	r22, 0x00	; 0
     a94:	70 e0       	ldi	r23, 0x00	; 0
     a96:	80 91 a5 08 	lds	r24, 0x08A5
     a9a:	90 91 a6 08 	lds	r25, 0x08A6
     a9e:	a4 d7       	rcall	.+3912   	; 0x19e8 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     aa0:	c0 91 a2 08 	lds	r28, 0x08A2
     aa4:	c3 70       	andi	r28, 0x03	; 3
     aa6:	d0 e0       	ldi	r29, 0x00	; 0
     aa8:	dc 2f       	mov	r29, r28
     aaa:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     aac:	80 91 a1 08 	lds	r24, 0x08A1
     ab0:	c8 0f       	add	r28, r24
     ab2:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     ab4:	20 e0       	ldi	r18, 0x00	; 0
     ab6:	40 e0       	ldi	r20, 0x00	; 0
     ab8:	50 e0       	ldi	r21, 0x00	; 0
     aba:	60 e0       	ldi	r22, 0x00	; 0
     abc:	70 e0       	ldi	r23, 0x00	; 0
     abe:	80 91 a3 08 	lds	r24, 0x08A3
     ac2:	90 91 a4 08 	lds	r25, 0x08A4
     ac6:	98 d6       	rcall	.+3376   	; 0x17f8 <xQueueGenericSend>
	
	return adcReading;
     ac8:	ce 01       	movw	r24, r28
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	08 95       	ret

00000ad0 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     ad0:	cf 93       	push	r28
     ad2:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     ad4:	b0 df       	rcall	.-160    	; 0xa36 <myADC_startADC>
	return myADC_readADC(channel);
     ad6:	8c 2f       	mov	r24, r28
     ad8:	d7 df       	rcall	.-82     	; 0xa88 <myADC_readADC>
}
     ada:	cf 91       	pop	r28
     adc:	08 95       	ret

00000ade <detectStairs>:
	*obstacleDetected = 5;
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     ade:	9c 01       	movw	r18, r24
     ae0:	28 5f       	subi	r18, 0xF8	; 248
     ae2:	3f 4f       	sbci	r19, 0xFF	; 255
     ae4:	26 17       	cp	r18, r22
     ae6:	37 07       	cpc	r19, r23
     ae8:	44 f0       	brlt	.+16     	; 0xafa <detectStairs+0x1c>
     aea:	20 51       	subi	r18, 0x10	; 16
     aec:	31 09       	sbc	r19, r1
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	62 17       	cp	r22, r18
     af2:	73 07       	cpc	r23, r19
     af4:	1c f0       	brlt	.+6      	; 0xafc <detectStairs+0x1e>
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	08 95       	ret
     afa:	81 e0       	ldi	r24, 0x01	; 1
     afc:	08 95       	ret

00000afe <possibleStairs>:
}

// detect possibleStairs infront 
char possibleStairs(int frontSonar, int topSonar)
{
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
     afe:	c2 97       	sbiw	r24, 0x32	; 50
     b00:	44 f4       	brge	.+16     	; 0xb12 <possibleStairs+0x14>
     b02:	61 55       	subi	r22, 0x51	; 81
     b04:	71 09       	sbc	r23, r1
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	67 32       	cpi	r22, 0x27	; 39
     b0a:	71 05       	cpc	r23, r1
     b0c:	18 f0       	brcs	.+6      	; 0xb14 <possibleStairs+0x16>
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	08 95       	ret
		return 1;
	else 
		return 0;
     b12:	80 e0       	ldi	r24, 0x00	; 0
	
}
     b14:	08 95       	ret

00000b16 <obstacleAvoidance>:
}


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int topSonar, int leftSonar, int rightSonar, int btmIR,  char const * const deviceBlocked)
{
     b16:	cf 92       	push	r12
     b18:	df 92       	push	r13
     b1a:	ef 92       	push	r14
     b1c:	ff 92       	push	r15
     b1e:	0f 93       	push	r16
     b20:	1f 93       	push	r17
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
     b26:	8a 01       	movw	r16, r20
     b28:	69 01       	movw	r12, r18
     b2a:	e7 01       	movw	r28, r14
	
	if(deviceBlocked[BTM_DEVICE])
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	22 23       	and	r18, r18
     b30:	41 f0       	breq	.+16     	; 0xb42 <obstacleAvoidance+0x2c>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b32:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b34:	e2 e0       	ldi	r30, 0x02	; 2
     b36:	f1 e0       	ldi	r31, 0x01	; 1
     b38:	80 81       	ld	r24, Z
     b3a:	80 61       	ori	r24, 0x10	; 16
     b3c:	80 83       	st	Z, r24
			MOTOR_FRONT_STOP();
     b3e:	73 98       	cbi	0x0e, 3	; 14
     b40:	53 c0       	rjmp	.+166    	; 0xbe8 <obstacleAvoidance+0xd2>
	}
	else if( (deviceBlocked[FRONT_DEVICE] && (!possibleStairs(frontSonar, topSonar))) || deviceBlocked[TOP_DEVICE])
     b42:	28 81       	ld	r18, Y
     b44:	22 23       	and	r18, r18
     b46:	19 f0       	breq	.+6      	; 0xb4e <obstacleAvoidance+0x38>
     b48:	da df       	rcall	.-76     	; 0xafe <possibleStairs>
     b4a:	88 23       	and	r24, r24
     b4c:	19 f0       	breq	.+6      	; 0xb54 <obstacleAvoidance+0x3e>
     b4e:	8c 81       	ldd	r24, Y+4	; 0x04
     b50:	88 23       	and	r24, r24
     b52:	41 f1       	breq	.+80     	; 0xba4 <obstacleAvoidance+0x8e>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b54:	89 81       	ldd	r24, Y+1	; 0x01
     b56:	81 11       	cpse	r24, r1
     b58:	07 c0       	rjmp	.+14     	; 0xb68 <obstacleAvoidance+0x52>
     b5a:	8a 81       	ldd	r24, Y+2	; 0x02
     b5c:	81 11       	cpse	r24, r1
     b5e:	15 c0       	rjmp	.+42     	; 0xb8a <obstacleAvoidance+0x74>
		{
			
			MOTOR_FRONT_START();
     b60:	73 9a       	sbi	0x0e, 3	; 14
					//MOTOR_LEFT_START();
					//MOTOR_RIGHT_STOP();
					//
				//}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b62:	89 81       	ldd	r24, Y+1	; 0x01
     b64:	88 23       	and	r24, r24
     b66:	e9 f1       	breq	.+122    	; 0xbe2 <obstacleAvoidance+0xcc>
     b68:	8a 81       	ldd	r24, Y+2	; 0x02
     b6a:	81 11       	cpse	r24, r1
     b6c:	3d c0       	rjmp	.+122    	; 0xbe8 <obstacleAvoidance+0xd2>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b6e:	c0 1a       	sub	r12, r16
     b70:	d1 0a       	sbc	r13, r17
     b72:	88 e0       	ldi	r24, 0x08	; 8
     b74:	c8 16       	cp	r12, r24
     b76:	d1 04       	cpc	r13, r1
     b78:	bc f1       	brlt	.+110    	; 0xbe8 <obstacleAvoidance+0xd2>
			{
				MOTOR_FRONT_STOP();
     b7a:	73 98       	cbi	0x0e, 3	; 14
				MOTOR_LEFT_STOP();
     b7c:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     b7e:	e2 e0       	ldi	r30, 0x02	; 2
     b80:	f1 e0       	ldi	r31, 0x01	; 1
     b82:	80 81       	ld	r24, Z
     b84:	80 61       	ori	r24, 0x10	; 16
     b86:	80 83       	st	Z, r24
     b88:	2f c0       	rjmp	.+94     	; 0xbe8 <obstacleAvoidance+0xd2>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     b8a:	0c 19       	sub	r16, r12
     b8c:	1d 09       	sbc	r17, r13
     b8e:	08 30       	cpi	r16, 0x08	; 8
     b90:	11 05       	cpc	r17, r1
     b92:	54 f1       	brlt	.+84     	; 0xbe8 <obstacleAvoidance+0xd2>
			{
				MOTOR_FRONT_STOP();
     b94:	73 98       	cbi	0x0e, 3	; 14
				MOTOR_LEFT_START();
     b96:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     b98:	e2 e0       	ldi	r30, 0x02	; 2
     b9a:	f1 e0       	ldi	r31, 0x01	; 1
     b9c:	80 81       	ld	r24, Z
     b9e:	8f 7e       	andi	r24, 0xEF	; 239
     ba0:	80 83       	st	Z, r24
     ba2:	22 c0       	rjmp	.+68     	; 0xbe8 <obstacleAvoidance+0xd2>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     ba4:	0e 31       	cpi	r16, 0x1E	; 30
     ba6:	11 05       	cpc	r17, r1
     ba8:	44 f4       	brge	.+16     	; 0xbba <obstacleAvoidance+0xa4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_FRONT_STOP();
     baa:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_STOP();
     bac:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     bae:	e2 e0       	ldi	r30, 0x02	; 2
     bb0:	f1 e0       	ldi	r31, 0x01	; 1
     bb2:	80 81       	ld	r24, Z
     bb4:	80 61       	ori	r24, 0x10	; 16
     bb6:	80 83       	st	Z, r24
     bb8:	17 c0       	rjmp	.+46     	; 0xbe8 <obstacleAvoidance+0xd2>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     bba:	86 e1       	ldi	r24, 0x16	; 22
     bbc:	c8 16       	cp	r12, r24
     bbe:	d1 04       	cpc	r13, r1
     bc0:	44 f4       	brge	.+16     	; 0xbd2 <obstacleAvoidance+0xbc>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_FRONT_STOP();
     bc2:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_START();
     bc4:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bc6:	e2 e0       	ldi	r30, 0x02	; 2
     bc8:	f1 e0       	ldi	r31, 0x01	; 1
     bca:	80 81       	ld	r24, Z
     bcc:	8f 7e       	andi	r24, 0xEF	; 239
     bce:	80 83       	st	Z, r24
     bd0:	0b c0       	rjmp	.+22     	; 0xbe8 <obstacleAvoidance+0xd2>
	}
	else
	{
			MOTOR_FRONT_STOP();
     bd2:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_STOP();
     bd4:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bd6:	e2 e0       	ldi	r30, 0x02	; 2
     bd8:	f1 e0       	ldi	r31, 0x01	; 1
     bda:	80 81       	ld	r24, Z
     bdc:	8f 7e       	andi	r24, 0xEF	; 239
     bde:	80 83       	st	Z, r24
     be0:	03 c0       	rjmp	.+6      	; 0xbe8 <obstacleAvoidance+0xd2>
				MOTOR_FRONT_STOP();
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     be2:	8a 81       	ldd	r24, Y+2	; 0x02
     be4:	81 11       	cpse	r24, r1
     be6:	d1 cf       	rjmp	.-94     	; 0xb8a <obstacleAvoidance+0x74>
	{
			MOTOR_FRONT_STOP();
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	1f 91       	pop	r17
     bee:	0f 91       	pop	r16
     bf0:	ff 90       	pop	r15
     bf2:	ef 90       	pop	r14
     bf4:	df 90       	pop	r13
     bf6:	cf 90       	pop	r12
     bf8:	08 95       	ret

00000bfa <obstacleDetection>:
}

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     bfa:	af 92       	push	r10
     bfc:	bf 92       	push	r11
     bfe:	cf 92       	push	r12
     c00:	df 92       	push	r13
     c02:	ef 92       	push	r14
     c04:	ff 92       	push	r15
     c06:	0f 93       	push	r16
     c08:	1f 93       	push	r17
     c0a:	cf 93       	push	r28
     c0c:	df 93       	push	r29
     c0e:	ea 01       	movw	r28, r20
     c10:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = 0;
     c12:	1c 82       	std	Y+4, r1	; 0x04
     c14:	1b 82       	std	Y+3, r1	; 0x03
     c16:	1a 82       	std	Y+2, r1	; 0x02
     c18:	19 82       	std	Y+1, r1	; 0x01
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c1a:	c2 97       	sbiw	r24, 0x32	; 50
     c1c:	1c f0       	brlt	.+6      	; 0xc24 <obstacleDetection+0x2a>
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = 0;
     c1e:	18 82       	st	Y, r1
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
     c20:	b1 2c       	mov	r11, r1
     c22:	04 c0       	rjmp	.+8      	; 0xc2c <obstacleDetection+0x32>
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c24:	86 e4       	ldi	r24, 0x46	; 70
     c26:	88 83       	st	Y, r24
	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
     c28:	bb 24       	eor	r11, r11
     c2a:	b3 94       	inc	r11
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c2c:	2e 31       	cpi	r18, 0x1E	; 30
     c2e:	31 05       	cpc	r19, r1
     c30:	1c f4       	brge	.+6      	; 0xc38 <obstacleDetection+0x3e>
	{
		obstacleDetected ++;
     c32:	b3 94       	inc	r11
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c34:	8c e4       	ldi	r24, 0x4C	; 76
     c36:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c38:	0e 31       	cpi	r16, 0x1E	; 30
     c3a:	11 05       	cpc	r17, r1
     c3c:	1c f4       	brge	.+6      	; 0xc44 <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c3e:	b3 94       	inc	r11
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c40:	82 e5       	ldi	r24, 0x52	; 82
     c42:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c44:	c6 01       	movw	r24, r12
     c46:	4b df       	rcall	.-362    	; 0xade <detectStairs>
     c48:	88 23       	and	r24, r24
     c4a:	19 f0       	breq	.+6      	; 0xc52 <obstacleDetection+0x58>
	{
		obstacleDetected++;
     c4c:	b3 94       	inc	r11
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c4e:	82 e4       	ldi	r24, 0x42	; 66
     c50:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     c52:	87 e3       	ldi	r24, 0x37	; 55
     c54:	e8 16       	cp	r14, r24
     c56:	f1 04       	cpc	r15, r1
     c58:	1c f4       	brge	.+6      	; 0xc60 <obstacleDetection+0x66>
	{
		obstacleDetected++;
     c5a:	b3 94       	inc	r11
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     c5c:	84 e5       	ldi	r24, 0x54	; 84
     c5e:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     c60:	8b 2d       	mov	r24, r11
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	ff 90       	pop	r15
     c6c:	ef 90       	pop	r14
     c6e:	df 90       	pop	r13
     c70:	cf 90       	pop	r12
     c72:	bf 90       	pop	r11
     c74:	af 90       	pop	r10
     c76:	08 95       	ret

00000c78 <mySharpIR_Read>:
#include <myUSART.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c78:	2b df       	rcall	.-426    	; 0xad0 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c7a:	bc 01       	movw	r22, r24
     c7c:	88 27       	eor	r24, r24
     c7e:	77 fd       	sbrc	r23, 7
     c80:	80 95       	com	r24
     c82:	98 2f       	mov	r25, r24
     c84:	0e 94 0c 14 	call	0x2818	; 0x2818 <__floatsisf>
     c88:	29 e2       	ldi	r18, 0x29	; 41
     c8a:	3c e5       	ldi	r19, 0x5C	; 92
     c8c:	4f e6       	ldi	r20, 0x6F	; 111
     c8e:	5f eb       	ldi	r21, 0xBF	; 191
     c90:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <pow>
     c94:	22 e5       	ldi	r18, 0x52	; 82
     c96:	38 e6       	ldi	r19, 0x68	; 104
     c98:	46 e2       	ldi	r20, 0x26	; 38
     c9a:	56 e4       	ldi	r21, 0x46	; 70
     c9c:	0e 94 98 14 	call	0x2930	; 0x2930 <__mulsf3>
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	40 e2       	ldi	r20, 0x20	; 32
     ca6:	51 e4       	ldi	r21, 0x41	; 65
     ca8:	0e 94 74 13 	call	0x26e8	; 0x26e8 <__subsf3>
     cac:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <__fixsfsi>
     cb0:	cb 01       	movw	r24, r22
	if(adcReading > IR_MAX_VALUE || adcReading < IR_MIN_VALUE)
     cb2:	68 3e       	cpi	r22, 0xE8	; 232
     cb4:	23 e0       	ldi	r18, 0x03	; 3
     cb6:	72 07       	cpc	r23, r18
     cb8:	10 f0       	brcs	.+4      	; 0xcbe <mySharpIR_Read+0x46>
		adcReading = IR_MAX_VALUE;
     cba:	87 ee       	ldi	r24, 0xE7	; 231
     cbc:	93 e0       	ldi	r25, 0x03	; 3
	
	return adcReading;
}
     cbe:	08 95       	ret

00000cc0 <checkOutOfRange>:

// return 1 if out of range..
char checkOutOfRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     cc0:	fb 01       	movw	r30, r22
     cc2:	20 81       	ld	r18, Z
     cc4:	31 81       	ldd	r19, Z+1	; 0x01
     cc6:	50 e0       	ldi	r21, 0x00	; 0
     cc8:	b9 01       	movw	r22, r18
     cca:	64 0f       	add	r22, r20
     ccc:	75 1f       	adc	r23, r21
     cce:	68 17       	cp	r22, r24
     cd0:	79 07       	cpc	r23, r25
     cd2:	4c f0       	brlt	.+18     	; 0xce6 <checkOutOfRange+0x26>
     cd4:	24 1b       	sub	r18, r20
     cd6:	35 0b       	sbc	r19, r21
     cd8:	41 e0       	ldi	r20, 0x01	; 1
     cda:	82 17       	cp	r24, r18
     cdc:	93 07       	cpc	r25, r19
     cde:	0c f0       	brlt	.+2      	; 0xce2 <checkOutOfRange+0x22>
     ce0:	40 e0       	ldi	r20, 0x00	; 0
     ce2:	84 2f       	mov	r24, r20
     ce4:	08 95       	ret
     ce6:	81 e0       	ldi	r24, 0x01	; 1
}
     ce8:	08 95       	ret

00000cea <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     cea:	ff 92       	push	r15
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	8c 01       	movw	r16, r24
     cf6:	eb 01       	movw	r28, r22
	static uint8_t sampleCount = 0;
	static int referenceReading = 0;
	//static int testPrint = 0;
	
	if(!checkOutOfRange(reading, calibratedReading, CALIBRATE_RANGE) && sampleCount == 0)
     cf8:	45 e0       	ldi	r20, 0x05	; 5
     cfa:	bc 01       	movw	r22, r24
     cfc:	ce 01       	movw	r24, r28
     cfe:	e0 df       	rcall	.-64     	; 0xcc0 <checkOutOfRange>
     d00:	81 11       	cpse	r24, r1
     d02:	05 c0       	rjmp	.+10     	; 0xd0e <mySharpIR_ReCalibrate+0x24>
     d04:	80 91 19 08 	lds	r24, 0x0819
     d08:	88 23       	and	r24, r24
     d0a:	09 f4       	brne	.+2      	; 0xd0e <mySharpIR_ReCalibrate+0x24>
     d0c:	4d c0       	rjmp	.+154    	; 0xda8 <mySharpIR_ReCalibrate+0xbe>
		// if current reading and calibratedReading is within range and no checking in progess
		// skip the calibration process... not needed
		return;
	}
	
	if(reading < CALIBRATE_LOW_THRESHOLD || reading > CALIBRATE_HIGH_THRESHOLD)
     d0e:	ce 01       	movw	r24, r28
     d10:	49 97       	sbiw	r24, 0x19	; 25
     d12:	45 97       	sbiw	r24, 0x15	; 21
     d14:	28 f0       	brcs	.+10     	; 0xd20 <mySharpIR_ReCalibrate+0x36>
	{
		// Too low or Too high for it to be ground..
		referenceReading = 0;
     d16:	10 92 18 08 	sts	0x0818, r1
     d1a:	10 92 17 08 	sts	0x0817, r1
		return;		
     d1e:	44 c0       	rjmp	.+136    	; 0xda8 <mySharpIR_ReCalibrate+0xbe>
	}
	
	
	if (sampleCount == 0)
     d20:	f0 90 19 08 	lds	r15, 0x0819
     d24:	f1 10       	cpse	r15, r1
     d26:	05 c0       	rjmp	.+10     	; 0xd32 <mySharpIR_ReCalibrate+0x48>
	{
		// Possible calibration... take reference from reading
		//testPrint = 0;
		referenceReading = reading;
     d28:	d0 93 18 08 	sts	0x0818, r29
     d2c:	c0 93 17 08 	sts	0x0817, r28
     d30:	38 c0       	rjmp	.+112    	; 0xda2 <mySharpIR_ReCalibrate+0xb8>
		//myUSART_transmitUSART0("\n-----RS----\n");

	}
	else if ((sampleCount % CALIBRATE_SAMPLE_RATE) == 0) // when count reach 
     d32:	8d ec       	ldi	r24, 0xCD	; 205
     d34:	f8 9e       	mul	r15, r24
     d36:	81 2d       	mov	r24, r1
     d38:	11 24       	eor	r1, r1
     d3a:	86 95       	lsr	r24
     d3c:	86 95       	lsr	r24
     d3e:	98 2f       	mov	r25, r24
     d40:	99 0f       	add	r25, r25
     d42:	99 0f       	add	r25, r25
     d44:	89 0f       	add	r24, r25
     d46:	f8 12       	cpse	r15, r24
     d48:	13 c0       	rjmp	.+38     	; 0xd70 <mySharpIR_ReCalibrate+0x86>
	{
		//testPrint++;
		//myUSART_transmitUSART0_c(testPrint + '0');
		//myUSART_transmitUSART0("\n");
		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     d4a:	45 e0       	ldi	r20, 0x05	; 5
     d4c:	67 e1       	ldi	r22, 0x17	; 23
     d4e:	78 e0       	ldi	r23, 0x08	; 8
     d50:	ce 01       	movw	r24, r28
     d52:	b6 df       	rcall	.-148    	; 0xcc0 <checkOutOfRange>
     d54:	88 23       	and	r24, r24
     d56:	39 f0       	breq	.+14     	; 0xd66 <mySharpIR_ReCalibrate+0x7c>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     d58:	10 92 18 08 	sts	0x0818, r1
     d5c:	10 92 17 08 	sts	0x0817, r1
			sampleCount = 0; // reset to count...
     d60:	10 92 19 08 	sts	0x0819, r1
			return;
     d64:	21 c0       	rjmp	.+66     	; 0xda8 <mySharpIR_ReCalibrate+0xbe>
		}
		else
		{	// within range.. need more confirmation, update reference point..
			referenceReading = reading;
     d66:	d0 93 18 08 	sts	0x0818, r29
     d6a:	c0 93 17 08 	sts	0x0817, r28
     d6e:	19 c0       	rjmp	.+50     	; 0xda2 <mySharpIR_ReCalibrate+0xb8>
		}
	}
	else if (sampleCount >= CALIBRATE_SAMPLE_REQUIRE)
     d70:	81 e2       	ldi	r24, 0x21	; 33
     d72:	8f 15       	cp	r24, r15
     d74:	b0 f4       	brcc	.+44     	; 0xda2 <mySharpIR_ReCalibrate+0xb8>
	{
		// Sample long enough...
		sampleCount = 0; // reset to count..
     d76:	10 92 19 08 	sts	0x0819, r1

		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     d7a:	45 e0       	ldi	r20, 0x05	; 5
     d7c:	67 e1       	ldi	r22, 0x17	; 23
     d7e:	78 e0       	ldi	r23, 0x08	; 8
     d80:	ce 01       	movw	r24, r28
     d82:	9e df       	rcall	.-196    	; 0xcc0 <checkOutOfRange>
     d84:	88 23       	and	r24, r24
     d86:	29 f0       	breq	.+10     	; 0xd92 <mySharpIR_ReCalibrate+0xa8>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     d88:	10 92 18 08 	sts	0x0818, r1
     d8c:	10 92 17 08 	sts	0x0817, r1
			return;
     d90:	0b c0       	rjmp	.+22     	; 0xda8 <mySharpIR_ReCalibrate+0xbe>
		}
		else
		{
			// all readings within range... can calibrate as new stable.
			*calibratedReading = referenceReading; // btmIR is calibrated..
     d92:	80 91 17 08 	lds	r24, 0x0817
     d96:	90 91 18 08 	lds	r25, 0x0818
     d9a:	f8 01       	movw	r30, r16
     d9c:	91 83       	std	Z+1, r25	; 0x01
     d9e:	80 83       	st	Z, r24
			//myUSART_transmitUSART0("\nACK\n");
			return;
     da0:	03 c0       	rjmp	.+6      	; 0xda8 <mySharpIR_ReCalibrate+0xbe>
		}
	}
	
	sampleCount++;
     da2:	f3 94       	inc	r15
     da4:	f0 92 19 08 	sts	0x0819, r15
}
     da8:	df 91       	pop	r29
     daa:	cf 91       	pop	r28
     dac:	1f 91       	pop	r17
     dae:	0f 91       	pop	r16
     db0:	ff 90       	pop	r15
     db2:	08 95       	ret

00000db4 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     db4:	90 93 ac 08 	sts	0x08AC, r25
     db8:	80 93 ab 08 	sts	0x08AB, r24
     dbc:	fc 01       	movw	r30, r24
     dbe:	80 81       	ld	r24, Z
     dc0:	91 81       	ldd	r25, Z+1	; 0x01
     dc2:	0e 94 bf 11 	call	0x237e	; 0x237e <vTaskSuspend>
     dc6:	43 e0       	ldi	r20, 0x03	; 3
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	e8 d4       	rcall	.+2512   	; 0x179e <xQueueGenericCreate>
     dce:	90 93 a8 08 	sts	0x08A8, r25
     dd2:	80 93 a7 08 	sts	0x08A7, r24
     dd6:	43 e0       	ldi	r20, 0x03	; 3
     dd8:	60 e0       	ldi	r22, 0x00	; 0
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	e0 d4       	rcall	.+2496   	; 0x179e <xQueueGenericCreate>
     dde:	90 93 aa 08 	sts	0x08AA, r25
     de2:	80 93 a9 08 	sts	0x08A9, r24
     de6:	08 95       	ret

00000de8 <myTimer_Read>:
     de8:	86 b5       	in	r24, 0x26	; 38
     dea:	08 95       	ret

00000dec <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     dec:	cf 93       	push	r28
     dee:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     df0:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     df2:	c1 11       	cpse	r28, r1
     df4:	22 c0       	rjmp	.+68     	; 0xe3a <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     df6:	80 91 03 02 	lds	r24, 0x0203
     dfa:	90 91 04 02 	lds	r25, 0x0204
     dfe:	88 38       	cpi	r24, 0x88	; 136
     e00:	93 41       	sbci	r25, 0x13	; 19
     e02:	51 f0       	breq	.+20     	; 0xe18 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e04:	80 91 03 02 	lds	r24, 0x0203
     e08:	90 91 04 02 	lds	r25, 0x0204
     e0c:	8a 5f       	subi	r24, 0xFA	; 250
     e0e:	91 09       	sbc	r25, r1
     e10:	90 93 04 02 	sts	0x0204, r25
     e14:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e18:	80 91 01 02 	lds	r24, 0x0201
     e1c:	90 91 02 02 	lds	r25, 0x0202
     e20:	88 38       	cpi	r24, 0x88	; 136
     e22:	93 41       	sbci	r25, 0x13	; 19
     e24:	51 f0       	breq	.+20     	; 0xe3a <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e26:	80 91 01 02 	lds	r24, 0x0201
     e2a:	90 91 02 02 	lds	r25, 0x0202
     e2e:	8a 5f       	subi	r24, 0xFA	; 250
     e30:	91 09       	sbc	r25, r1
     e32:	90 93 02 02 	sts	0x0202, r25
     e36:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e3a:	d0 e0       	ldi	r29, 0x00	; 0
     e3c:	80 91 03 02 	lds	r24, 0x0203
     e40:	90 91 04 02 	lds	r25, 0x0204
     e44:	8c 17       	cp	r24, r28
     e46:	9d 07       	cpc	r25, r29
     e48:	84 f4       	brge	.+32     	; 0xe6a <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     e4a:	88 e8       	ldi	r24, 0x88	; 136
     e4c:	93 e1       	ldi	r25, 0x13	; 19
     e4e:	90 93 04 02 	sts	0x0204, r25
     e52:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     e56:	20 e0       	ldi	r18, 0x00	; 0
     e58:	40 e0       	ldi	r20, 0x00	; 0
     e5a:	50 e0       	ldi	r21, 0x00	; 0
     e5c:	60 e0       	ldi	r22, 0x00	; 0
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	80 91 a7 08 	lds	r24, 0x08A7
     e64:	90 91 a8 08 	lds	r25, 0x08A8
     e68:	c7 d4       	rcall	.+2446   	; 0x17f8 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     e6a:	80 91 01 02 	lds	r24, 0x0201
     e6e:	90 91 02 02 	lds	r25, 0x0202
     e72:	8c 17       	cp	r24, r28
     e74:	9d 07       	cpc	r25, r29
     e76:	84 f4       	brge	.+32     	; 0xe98 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     e78:	88 e8       	ldi	r24, 0x88	; 136
     e7a:	93 e1       	ldi	r25, 0x13	; 19
     e7c:	90 93 02 02 	sts	0x0202, r25
     e80:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     e84:	20 e0       	ldi	r18, 0x00	; 0
     e86:	40 e0       	ldi	r20, 0x00	; 0
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 91 a9 08 	lds	r24, 0x08A9
     e92:	90 91 aa 08 	lds	r25, 0x08AA
     e96:	b0 d4       	rcall	.+2400   	; 0x17f8 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     e98:	80 91 03 02 	lds	r24, 0x0203
     e9c:	90 91 04 02 	lds	r25, 0x0204
     ea0:	88 38       	cpi	r24, 0x88	; 136
     ea2:	93 41       	sbci	r25, 0x13	; 19
     ea4:	79 f4       	brne	.+30     	; 0xec4 <myTimer_DelayChecker+0xd8>
     ea6:	80 91 01 02 	lds	r24, 0x0201
     eaa:	90 91 02 02 	lds	r25, 0x0202
     eae:	88 38       	cpi	r24, 0x88	; 136
     eb0:	93 41       	sbci	r25, 0x13	; 19
     eb2:	41 f4       	brne	.+16     	; 0xec4 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     eb4:	e0 91 ab 08 	lds	r30, 0x08AB
     eb8:	f0 91 ac 08 	lds	r31, 0x08AC
     ebc:	80 81       	ld	r24, Z
     ebe:	91 81       	ldd	r25, Z+1	; 0x01
     ec0:	0e 94 bf 11 	call	0x237e	; 0x237e <vTaskSuspend>
	}
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	08 95       	ret

00000eca <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     eca:	1f 92       	push	r1
     ecc:	0f 92       	push	r0
     ece:	0f b6       	in	r0, 0x3f	; 63
     ed0:	0f 92       	push	r0
     ed2:	11 24       	eor	r1, r1
     ed4:	0b b6       	in	r0, 0x3b	; 59
     ed6:	0f 92       	push	r0
     ed8:	2f 93       	push	r18
     eda:	3f 93       	push	r19
     edc:	4f 93       	push	r20
     ede:	5f 93       	push	r21
     ee0:	6f 93       	push	r22
     ee2:	7f 93       	push	r23
     ee4:	8f 93       	push	r24
     ee6:	9f 93       	push	r25
     ee8:	af 93       	push	r26
     eea:	bf 93       	push	r27
     eec:	ef 93       	push	r30
     eee:	ff 93       	push	r31
     ef0:	60 91 ce 00 	lds	r22, 0x00CE
     ef4:	8c e3       	ldi	r24, 0x3C	; 60
     ef6:	99 e0       	ldi	r25, 0x09	; 9
     ef8:	43 d6       	rcall	.+3206   	; 0x1b80 <ringBufferPush>
     efa:	20 e0       	ldi	r18, 0x00	; 0
     efc:	40 e0       	ldi	r20, 0x00	; 0
     efe:	50 e0       	ldi	r21, 0x00	; 0
     f00:	60 e0       	ldi	r22, 0x00	; 0
     f02:	70 e0       	ldi	r23, 0x00	; 0
     f04:	80 91 22 08 	lds	r24, 0x0822
     f08:	90 91 23 08 	lds	r25, 0x0823
     f0c:	33 d5       	rcall	.+2662   	; 0x1974 <xQueueGenericSendFromISR>
     f0e:	8c e3       	ldi	r24, 0x3C	; 60
     f10:	99 e0       	ldi	r25, 0x09	; 9
     f12:	4d d6       	rcall	.+3226   	; 0x1bae <ringBufferFull>
     f14:	ff 91       	pop	r31
     f16:	ef 91       	pop	r30
     f18:	bf 91       	pop	r27
     f1a:	af 91       	pop	r26
     f1c:	9f 91       	pop	r25
     f1e:	8f 91       	pop	r24
     f20:	7f 91       	pop	r23
     f22:	6f 91       	pop	r22
     f24:	5f 91       	pop	r21
     f26:	4f 91       	pop	r20
     f28:	3f 91       	pop	r19
     f2a:	2f 91       	pop	r18
     f2c:	0f 90       	pop	r0
     f2e:	0b be       	out	0x3b, r0	; 59
     f30:	0f 90       	pop	r0
     f32:	0f be       	out	0x3f, r0	; 63
     f34:	0f 90       	pop	r0
     f36:	1f 90       	pop	r1
     f38:	18 95       	reti

00000f3a <__vector_25>:
     f3a:	1f 92       	push	r1
     f3c:	0f 92       	push	r0
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	0f 92       	push	r0
     f42:	11 24       	eor	r1, r1
     f44:	0b b6       	in	r0, 0x3b	; 59
     f46:	0f 92       	push	r0
     f48:	2f 93       	push	r18
     f4a:	3f 93       	push	r19
     f4c:	4f 93       	push	r20
     f4e:	5f 93       	push	r21
     f50:	6f 93       	push	r22
     f52:	7f 93       	push	r23
     f54:	8f 93       	push	r24
     f56:	9f 93       	push	r25
     f58:	af 93       	push	r26
     f5a:	bf 93       	push	r27
     f5c:	ef 93       	push	r30
     f5e:	ff 93       	push	r31
     f60:	60 91 c6 00 	lds	r22, 0x00C6
     f64:	8d ec       	ldi	r24, 0xCD	; 205
     f66:	98 e0       	ldi	r25, 0x08	; 8
     f68:	0b d6       	rcall	.+3094   	; 0x1b80 <ringBufferPush>
     f6a:	20 e0       	ldi	r18, 0x00	; 0
     f6c:	40 e0       	ldi	r20, 0x00	; 0
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	60 e0       	ldi	r22, 0x00	; 0
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	80 91 22 08 	lds	r24, 0x0822
     f78:	90 91 23 08 	lds	r25, 0x0823
     f7c:	fb d4       	rcall	.+2550   	; 0x1974 <xQueueGenericSendFromISR>
     f7e:	8d ec       	ldi	r24, 0xCD	; 205
     f80:	98 e0       	ldi	r25, 0x08	; 8
     f82:	15 d6       	rcall	.+3114   	; 0x1bae <ringBufferFull>
     f84:	ff 91       	pop	r31
     f86:	ef 91       	pop	r30
     f88:	bf 91       	pop	r27
     f8a:	af 91       	pop	r26
     f8c:	9f 91       	pop	r25
     f8e:	8f 91       	pop	r24
     f90:	7f 91       	pop	r23
     f92:	6f 91       	pop	r22
     f94:	5f 91       	pop	r21
     f96:	4f 91       	pop	r20
     f98:	3f 91       	pop	r19
     f9a:	2f 91       	pop	r18
     f9c:	0f 90       	pop	r0
     f9e:	0b be       	out	0x3b, r0	; 59
     fa0:	0f 90       	pop	r0
     fa2:	0f be       	out	0x3f, r0	; 63
     fa4:	0f 90       	pop	r0
     fa6:	1f 90       	pop	r1
     fa8:	18 95       	reti

00000faa <__vector_37>:
     faa:	1f 92       	push	r1
     fac:	0f 92       	push	r0
     fae:	0f b6       	in	r0, 0x3f	; 63
     fb0:	0f 92       	push	r0
     fb2:	11 24       	eor	r1, r1
     fb4:	0b b6       	in	r0, 0x3b	; 59
     fb6:	0f 92       	push	r0
     fb8:	2f 93       	push	r18
     fba:	3f 93       	push	r19
     fbc:	4f 93       	push	r20
     fbe:	5f 93       	push	r21
     fc0:	6f 93       	push	r22
     fc2:	7f 93       	push	r23
     fc4:	8f 93       	push	r24
     fc6:	9f 93       	push	r25
     fc8:	af 93       	push	r26
     fca:	bf 93       	push	r27
     fcc:	ef 93       	push	r30
     fce:	ff 93       	push	r31
     fd0:	82 e3       	ldi	r24, 0x32	; 50
     fd2:	99 e0       	ldi	r25, 0x09	; 9
     fd4:	f3 d5       	rcall	.+3046   	; 0x1bbc <ringBufferNotEmpty>
     fd6:	88 23       	and	r24, r24
     fd8:	31 f0       	breq	.+12     	; 0xfe6 <__vector_37+0x3c>
     fda:	82 e3       	ldi	r24, 0x32	; 50
     fdc:	99 e0       	ldi	r25, 0x09	; 9
     fde:	be d5       	rcall	.+2940   	; 0x1b5c <ringBufferPop>
     fe0:	80 93 ce 00 	sts	0x00CE, r24
     fe4:	0f c0       	rjmp	.+30     	; 0x1004 <__vector_37+0x5a>
     fe6:	e9 ec       	ldi	r30, 0xC9	; 201
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	8f 7d       	andi	r24, 0xDF	; 223
     fee:	80 83       	st	Z, r24
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	40 e0       	ldi	r20, 0x00	; 0
     ff4:	50 e0       	ldi	r21, 0x00	; 0
     ff6:	60 e0       	ldi	r22, 0x00	; 0
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	80 91 1a 08 	lds	r24, 0x081A
     ffe:	90 91 1b 08 	lds	r25, 0x081B
    1002:	b8 d4       	rcall	.+2416   	; 0x1974 <xQueueGenericSendFromISR>
    1004:	ff 91       	pop	r31
    1006:	ef 91       	pop	r30
    1008:	bf 91       	pop	r27
    100a:	af 91       	pop	r26
    100c:	9f 91       	pop	r25
    100e:	8f 91       	pop	r24
    1010:	7f 91       	pop	r23
    1012:	6f 91       	pop	r22
    1014:	5f 91       	pop	r21
    1016:	4f 91       	pop	r20
    1018:	3f 91       	pop	r19
    101a:	2f 91       	pop	r18
    101c:	0f 90       	pop	r0
    101e:	0b be       	out	0x3b, r0	; 59
    1020:	0f 90       	pop	r0
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	0f 90       	pop	r0
    1026:	1f 90       	pop	r1
    1028:	18 95       	reti

0000102a <__vector_26>:
    102a:	1f 92       	push	r1
    102c:	0f 92       	push	r0
    102e:	0f b6       	in	r0, 0x3f	; 63
    1030:	0f 92       	push	r0
    1032:	11 24       	eor	r1, r1
    1034:	0b b6       	in	r0, 0x3b	; 59
    1036:	0f 92       	push	r0
    1038:	2f 93       	push	r18
    103a:	3f 93       	push	r19
    103c:	4f 93       	push	r20
    103e:	5f 93       	push	r21
    1040:	6f 93       	push	r22
    1042:	7f 93       	push	r23
    1044:	8f 93       	push	r24
    1046:	9f 93       	push	r25
    1048:	af 93       	push	r26
    104a:	bf 93       	push	r27
    104c:	ef 93       	push	r30
    104e:	ff 93       	push	r31
    1050:	87 e3       	ldi	r24, 0x37	; 55
    1052:	99 e0       	ldi	r25, 0x09	; 9
    1054:	b3 d5       	rcall	.+2918   	; 0x1bbc <ringBufferNotEmpty>
    1056:	88 23       	and	r24, r24
    1058:	31 f0       	breq	.+12     	; 0x1066 <__vector_26+0x3c>
    105a:	87 e3       	ldi	r24, 0x37	; 55
    105c:	99 e0       	ldi	r25, 0x09	; 9
    105e:	7e d5       	rcall	.+2812   	; 0x1b5c <ringBufferPop>
    1060:	80 93 c6 00 	sts	0x00C6, r24
    1064:	0f c0       	rjmp	.+30     	; 0x1084 <__vector_26+0x5a>
    1066:	e1 ec       	ldi	r30, 0xC1	; 193
    1068:	f0 e0       	ldi	r31, 0x00	; 0
    106a:	80 81       	ld	r24, Z
    106c:	8f 7d       	andi	r24, 0xDF	; 223
    106e:	80 83       	st	Z, r24
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	40 e0       	ldi	r20, 0x00	; 0
    1074:	50 e0       	ldi	r21, 0x00	; 0
    1076:	60 e0       	ldi	r22, 0x00	; 0
    1078:	70 e0       	ldi	r23, 0x00	; 0
    107a:	80 91 1c 08 	lds	r24, 0x081C
    107e:	90 91 1d 08 	lds	r25, 0x081D
    1082:	78 d4       	rcall	.+2288   	; 0x1974 <xQueueGenericSendFromISR>
    1084:	ff 91       	pop	r31
    1086:	ef 91       	pop	r30
    1088:	bf 91       	pop	r27
    108a:	af 91       	pop	r26
    108c:	9f 91       	pop	r25
    108e:	8f 91       	pop	r24
    1090:	7f 91       	pop	r23
    1092:	6f 91       	pop	r22
    1094:	5f 91       	pop	r21
    1096:	4f 91       	pop	r20
    1098:	3f 91       	pop	r19
    109a:	2f 91       	pop	r18
    109c:	0f 90       	pop	r0
    109e:	0b be       	out	0x3b, r0	; 59
    10a0:	0f 90       	pop	r0
    10a2:	0f be       	out	0x3f, r0	; 63
    10a4:	0f 90       	pop	r0
    10a6:	1f 90       	pop	r1
    10a8:	18 95       	reti

000010aa <myUSART_USART0_Init>:
    10aa:	10 92 c5 00 	sts	0x00C5, r1
    10ae:	87 e6       	ldi	r24, 0x67	; 103
    10b0:	80 93 c4 00 	sts	0x00C4, r24
    10b4:	88 eb       	ldi	r24, 0xB8	; 184
    10b6:	80 93 c1 00 	sts	0x00C1, r24
    10ba:	86 e0       	ldi	r24, 0x06	; 6
    10bc:	80 93 c2 00 	sts	0x00C2, r24
    10c0:	40 e2       	ldi	r20, 0x20	; 32
    10c2:	62 ef       	ldi	r22, 0xF2	; 242
    10c4:	78 e0       	ldi	r23, 0x08	; 8
    10c6:	8d ec       	ldi	r24, 0xCD	; 205
    10c8:	98 e0       	ldi	r25, 0x08	; 8
    10ca:	41 d5       	rcall	.+2690   	; 0x1b4e <ringBufferInit>
    10cc:	40 e2       	ldi	r20, 0x20	; 32
    10ce:	62 ed       	ldi	r22, 0xD2	; 210
    10d0:	78 e0       	ldi	r23, 0x08	; 8
    10d2:	87 e3       	ldi	r24, 0x37	; 55
    10d4:	99 e0       	ldi	r25, 0x09	; 9
    10d6:	3b d5       	rcall	.+2678   	; 0x1b4e <ringBufferInit>
    10d8:	43 e0       	ldi	r20, 0x03	; 3
    10da:	60 e0       	ldi	r22, 0x00	; 0
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	5f d3       	rcall	.+1726   	; 0x179e <xQueueGenericCreate>
    10e0:	90 93 21 08 	sts	0x0821, r25
    10e4:	80 93 20 08 	sts	0x0820, r24
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	19 d4       	rcall	.+2098   	; 0x191e <xQueueCreateMutex>
    10ec:	90 93 1d 08 	sts	0x081D, r25
    10f0:	80 93 1c 08 	sts	0x081C, r24
    10f4:	08 95       	ret

000010f6 <myUSART_USART1_Init>:
    10f6:	10 92 cd 00 	sts	0x00CD, r1
    10fa:	87 e6       	ldi	r24, 0x67	; 103
    10fc:	80 93 cc 00 	sts	0x00CC, r24
    1100:	88 eb       	ldi	r24, 0xB8	; 184
    1102:	80 93 c9 00 	sts	0x00C9, r24
    1106:	86 e0       	ldi	r24, 0x06	; 6
    1108:	80 93 ca 00 	sts	0x00CA, r24
    110c:	40 e2       	ldi	r20, 0x20	; 32
    110e:	6d ea       	ldi	r22, 0xAD	; 173
    1110:	78 e0       	ldi	r23, 0x08	; 8
    1112:	8c e3       	ldi	r24, 0x3C	; 60
    1114:	99 e0       	ldi	r25, 0x09	; 9
    1116:	1b d5       	rcall	.+2614   	; 0x1b4e <ringBufferInit>
    1118:	40 e2       	ldi	r20, 0x20	; 32
    111a:	62 e1       	ldi	r22, 0x12	; 18
    111c:	79 e0       	ldi	r23, 0x09	; 9
    111e:	82 e3       	ldi	r24, 0x32	; 50
    1120:	99 e0       	ldi	r25, 0x09	; 9
    1122:	15 d5       	rcall	.+2602   	; 0x1b4e <ringBufferInit>
    1124:	43 e0       	ldi	r20, 0x03	; 3
    1126:	60 e0       	ldi	r22, 0x00	; 0
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	39 d3       	rcall	.+1650   	; 0x179e <xQueueGenericCreate>
    112c:	90 93 23 08 	sts	0x0823, r25
    1130:	80 93 22 08 	sts	0x0822, r24
    1134:	43 e0       	ldi	r20, 0x03	; 3
    1136:	60 e0       	ldi	r22, 0x00	; 0
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	31 d3       	rcall	.+1634   	; 0x179e <xQueueGenericCreate>
    113c:	90 93 1f 08 	sts	0x081F, r25
    1140:	80 93 1e 08 	sts	0x081E, r24
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	eb d3       	rcall	.+2006   	; 0x191e <xQueueCreateMutex>
    1148:	90 93 1b 08 	sts	0x081B, r25
    114c:	80 93 1a 08 	sts	0x081A, r24
    1150:	08 95       	ret

00001152 <myUSART_transmitUSART0_c>:
    1152:	cf 93       	push	r28
    1154:	c8 2f       	mov	r28, r24
    1156:	20 e0       	ldi	r18, 0x00	; 0
    1158:	4f ef       	ldi	r20, 0xFF	; 255
    115a:	5f ef       	ldi	r21, 0xFF	; 255
    115c:	60 e0       	ldi	r22, 0x00	; 0
    115e:	70 e0       	ldi	r23, 0x00	; 0
    1160:	80 91 1c 08 	lds	r24, 0x081C
    1164:	90 91 1d 08 	lds	r25, 0x081D
    1168:	3f d4       	rcall	.+2174   	; 0x19e8 <xQueueGenericReceive>
    116a:	87 e3       	ldi	r24, 0x37	; 55
    116c:	99 e0       	ldi	r25, 0x09	; 9
    116e:	1f d5       	rcall	.+2622   	; 0x1bae <ringBufferFull>
    1170:	81 11       	cpse	r24, r1
    1172:	fb cf       	rjmp	.-10     	; 0x116a <myUSART_transmitUSART0_c+0x18>
    1174:	6c 2f       	mov	r22, r28
    1176:	87 e3       	ldi	r24, 0x37	; 55
    1178:	99 e0       	ldi	r25, 0x09	; 9
    117a:	02 d5       	rcall	.+2564   	; 0x1b80 <ringBufferPush>
    117c:	e1 ec       	ldi	r30, 0xC1	; 193
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	80 81       	ld	r24, Z
    1182:	80 62       	ori	r24, 0x20	; 32
    1184:	80 83       	st	Z, r24
    1186:	e0 ec       	ldi	r30, 0xC0	; 192
    1188:	f0 e0       	ldi	r31, 0x00	; 0
    118a:	80 81       	ld	r24, Z
    118c:	80 64       	ori	r24, 0x40	; 64
    118e:	80 83       	st	Z, r24
    1190:	cf 91       	pop	r28
    1192:	08 95       	ret

00001194 <myUSART_transmitUSART1_c>:
    1194:	cf 93       	push	r28
    1196:	c8 2f       	mov	r28, r24
    1198:	20 e0       	ldi	r18, 0x00	; 0
    119a:	4f ef       	ldi	r20, 0xFF	; 255
    119c:	5f ef       	ldi	r21, 0xFF	; 255
    119e:	60 e0       	ldi	r22, 0x00	; 0
    11a0:	70 e0       	ldi	r23, 0x00	; 0
    11a2:	80 91 1a 08 	lds	r24, 0x081A
    11a6:	90 91 1b 08 	lds	r25, 0x081B
    11aa:	1e d4       	rcall	.+2108   	; 0x19e8 <xQueueGenericReceive>
    11ac:	82 e3       	ldi	r24, 0x32	; 50
    11ae:	99 e0       	ldi	r25, 0x09	; 9
    11b0:	fe d4       	rcall	.+2556   	; 0x1bae <ringBufferFull>
    11b2:	81 11       	cpse	r24, r1
    11b4:	fb cf       	rjmp	.-10     	; 0x11ac <myUSART_transmitUSART1_c+0x18>
    11b6:	6c 2f       	mov	r22, r28
    11b8:	82 e3       	ldi	r24, 0x32	; 50
    11ba:	99 e0       	ldi	r25, 0x09	; 9
    11bc:	e1 d4       	rcall	.+2498   	; 0x1b80 <ringBufferPush>
    11be:	e9 ec       	ldi	r30, 0xC9	; 201
    11c0:	f0 e0       	ldi	r31, 0x00	; 0
    11c2:	80 81       	ld	r24, Z
    11c4:	80 62       	ori	r24, 0x20	; 32
    11c6:	80 83       	st	Z, r24
    11c8:	e8 ec       	ldi	r30, 0xC8	; 200
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	80 81       	ld	r24, Z
    11ce:	80 64       	ori	r24, 0x40	; 64
    11d0:	80 83       	st	Z, r24
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <myUSART_transmitUSART1>:
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	ec 01       	movw	r28, r24
    11dc:	88 81       	ld	r24, Y
    11de:	88 23       	and	r24, r24
    11e0:	29 f0       	breq	.+10     	; 0x11ec <myUSART_transmitUSART1+0x16>
    11e2:	21 96       	adiw	r28, 0x01	; 1
    11e4:	d7 df       	rcall	.-82     	; 0x1194 <myUSART_transmitUSART1_c>
    11e6:	89 91       	ld	r24, Y+
    11e8:	81 11       	cpse	r24, r1
    11ea:	fc cf       	rjmp	.-8      	; 0x11e4 <myUSART_transmitUSART1+0xe>
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	08 95       	ret

000011f2 <myUSART_transmitUSART0>:
    11f2:	cf 93       	push	r28
    11f4:	df 93       	push	r29
    11f6:	ec 01       	movw	r28, r24
    11f8:	88 81       	ld	r24, Y
    11fa:	88 23       	and	r24, r24
    11fc:	29 f0       	breq	.+10     	; 0x1208 <myUSART_transmitUSART0+0x16>
    11fe:	21 96       	adiw	r28, 0x01	; 1
    1200:	a8 df       	rcall	.-176    	; 0x1152 <myUSART_transmitUSART0_c>
    1202:	89 91       	ld	r24, Y+
    1204:	81 11       	cpse	r24, r1
    1206:	fc cf       	rjmp	.-8      	; 0x1200 <myUSART_transmitUSART0+0xe>
    1208:	df 91       	pop	r29
    120a:	cf 91       	pop	r28
    120c:	08 95       	ret

0000120e <myUSART_receiveUSART1>:
    120e:	cf 93       	push	r28
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	4f ef       	ldi	r20, 0xFF	; 255
    1214:	5f ef       	ldi	r21, 0xFF	; 255
    1216:	60 e0       	ldi	r22, 0x00	; 0
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	80 91 22 08 	lds	r24, 0x0822
    121e:	90 91 23 08 	lds	r25, 0x0823
    1222:	e2 d3       	rcall	.+1988   	; 0x19e8 <xQueueGenericReceive>
    1224:	8c e3       	ldi	r24, 0x3C	; 60
    1226:	99 e0       	ldi	r25, 0x09	; 9
    1228:	99 d4       	rcall	.+2354   	; 0x1b5c <ringBufferPop>
    122a:	c8 2f       	mov	r28, r24
    122c:	8c e3       	ldi	r24, 0x3C	; 60
    122e:	99 e0       	ldi	r25, 0x09	; 9
    1230:	c5 d4       	rcall	.+2442   	; 0x1bbc <ringBufferNotEmpty>
    1232:	88 23       	and	r24, r24
    1234:	51 f0       	breq	.+20     	; 0x124a <myUSART_receiveUSART1+0x3c>
    1236:	20 e0       	ldi	r18, 0x00	; 0
    1238:	40 e0       	ldi	r20, 0x00	; 0
    123a:	50 e0       	ldi	r21, 0x00	; 0
    123c:	60 e0       	ldi	r22, 0x00	; 0
    123e:	70 e0       	ldi	r23, 0x00	; 0
    1240:	80 91 22 08 	lds	r24, 0x0822
    1244:	90 91 23 08 	lds	r25, 0x0823
    1248:	d7 d2       	rcall	.+1454   	; 0x17f8 <xQueueGenericSend>
    124a:	8c 2f       	mov	r24, r28
    124c:	cf 91       	pop	r28
    124e:	08 95       	ret

00001250 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    1250:	86 e1       	ldi	r24, 0x16	; 22
    1252:	a0 df       	rcall	.-192    	; 0x1194 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    1254:	20 e0       	ldi	r18, 0x00	; 0
    1256:	44 ef       	ldi	r20, 0xF4	; 244
    1258:	51 e0       	ldi	r21, 0x01	; 1
    125a:	60 e0       	ldi	r22, 0x00	; 0
    125c:	70 e0       	ldi	r23, 0x00	; 0
    125e:	80 91 1e 08 	lds	r24, 0x081E
    1262:	90 91 1f 08 	lds	r25, 0x081F
    1266:	c0 d3       	rcall	.+1920   	; 0x19e8 <xQueueGenericReceive>
    1268:	81 30       	cpi	r24, 0x01	; 1
    126a:	21 f4       	brne	.+8      	; 0x1274 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    126c:	82 e0       	ldi	r24, 0x02	; 2
    126e:	92 df       	rcall	.-220    	; 0x1194 <myUSART_transmitUSART1_c>
		return 1;
    1270:	81 e0       	ldi	r24, 0x01	; 1
    1272:	08 95       	ret
	}
	else
	{
		return 0;
    1274:	80 e0       	ldi	r24, 0x00	; 0
	}

}
    1276:	08 95       	ret

00001278 <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    1278:	20 e0       	ldi	r18, 0x00	; 0
    127a:	40 e0       	ldi	r20, 0x00	; 0
    127c:	50 e0       	ldi	r21, 0x00	; 0
    127e:	60 e0       	ldi	r22, 0x00	; 0
    1280:	70 e0       	ldi	r23, 0x00	; 0
    1282:	80 91 1e 08 	lds	r24, 0x081E
    1286:	90 91 1f 08 	lds	r25, 0x081F
    128a:	b6 c2       	rjmp	.+1388   	; 0x17f8 <xQueueGenericSend>
    128c:	08 95       	ret

0000128e <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    128e:	91 e0       	ldi	r25, 0x01	; 1
    1290:	85 30       	cpi	r24, 0x05	; 5
    1292:	09 f0       	breq	.+2      	; 0x1296 <myUSART_receiveHandShakeAck+0x8>
    1294:	90 e0       	ldi	r25, 0x00	; 0
}
    1296:	89 2f       	mov	r24, r25
    1298:	08 95       	ret

0000129a <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    129a:	91 e0       	ldi	r25, 0x01	; 1
    129c:	86 31       	cpi	r24, 0x16	; 22
    129e:	09 f0       	breq	.+2      	; 0x12a2 <myUSART_receiveHandShakeStart+0x8>
    12a0:	90 e0       	ldi	r25, 0x00	; 0
}
    12a2:	89 2f       	mov	r24, r25
    12a4:	08 95       	ret

000012a6 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    12a6:	91 e0       	ldi	r25, 0x01	; 1
    12a8:	82 30       	cpi	r24, 0x02	; 2
    12aa:	09 f0       	breq	.+2      	; 0x12ae <myUSART_receiveHandShakeFin+0x8>
    12ac:	90 e0       	ldi	r25, 0x00	; 0
}
    12ae:	89 2f       	mov	r24, r25
    12b0:	08 95       	ret

000012b2 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    12b2:	91 e0       	ldi	r25, 0x01	; 1
    12b4:	86 30       	cpi	r24, 0x06	; 6
    12b6:	09 f0       	breq	.+2      	; 0x12ba <myUSART_receiveMessageACK+0x8>
    12b8:	90 e0       	ldi	r25, 0x00	; 0
}
    12ba:	89 2f       	mov	r24, r25
    12bc:	08 95       	ret

000012be <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12be:	31 e1       	ldi	r19, 0x11	; 17
    12c0:	fc 01       	movw	r30, r24
    12c2:	30 83       	st	Z, r19
    12c4:	31 97       	sbiw	r30, 0x01	; 1
    12c6:	22 e2       	ldi	r18, 0x22	; 34
    12c8:	20 83       	st	Z, r18
    12ca:	31 97       	sbiw	r30, 0x01	; 1
    12cc:	a3 e3       	ldi	r26, 0x33	; 51
    12ce:	a0 83       	st	Z, r26
    12d0:	31 97       	sbiw	r30, 0x01	; 1
    12d2:	60 83       	st	Z, r22
    12d4:	31 97       	sbiw	r30, 0x01	; 1
    12d6:	70 83       	st	Z, r23
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	10 82       	st	Z, r1
    12dc:	31 97       	sbiw	r30, 0x01	; 1
    12de:	10 82       	st	Z, r1
    12e0:	31 97       	sbiw	r30, 0x01	; 1
    12e2:	60 e8       	ldi	r22, 0x80	; 128
    12e4:	60 83       	st	Z, r22
    12e6:	31 97       	sbiw	r30, 0x01	; 1
    12e8:	10 82       	st	Z, r1
    12ea:	31 97       	sbiw	r30, 0x01	; 1
    12ec:	10 82       	st	Z, r1
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	10 82       	st	Z, r1
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	62 e0       	ldi	r22, 0x02	; 2
    12f6:	60 83       	st	Z, r22
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	63 e0       	ldi	r22, 0x03	; 3
    12fc:	60 83       	st	Z, r22
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	64 e0       	ldi	r22, 0x04	; 4
    1302:	60 83       	st	Z, r22
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	65 e0       	ldi	r22, 0x05	; 5
    1308:	60 83       	st	Z, r22
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	66 e0       	ldi	r22, 0x06	; 6
    130e:	60 83       	st	Z, r22
    1310:	31 97       	sbiw	r30, 0x01	; 1
    1312:	67 e0       	ldi	r22, 0x07	; 7
    1314:	60 83       	st	Z, r22
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	68 e0       	ldi	r22, 0x08	; 8
    131a:	60 83       	st	Z, r22
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	69 e0       	ldi	r22, 0x09	; 9
    1320:	60 83       	st	Z, r22
    1322:	31 97       	sbiw	r30, 0x01	; 1
    1324:	60 e1       	ldi	r22, 0x10	; 16
    1326:	60 83       	st	Z, r22
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	30 83       	st	Z, r19
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	32 e1       	ldi	r19, 0x12	; 18
    1330:	30 83       	st	Z, r19
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	33 e1       	ldi	r19, 0x13	; 19
    1336:	30 83       	st	Z, r19
    1338:	31 97       	sbiw	r30, 0x01	; 1
    133a:	34 e1       	ldi	r19, 0x14	; 20
    133c:	30 83       	st	Z, r19
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	35 e1       	ldi	r19, 0x15	; 21
    1342:	30 83       	st	Z, r19
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	36 e1       	ldi	r19, 0x16	; 22
    1348:	30 83       	st	Z, r19
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	37 e1       	ldi	r19, 0x17	; 23
    134e:	30 83       	st	Z, r19
    1350:	31 97       	sbiw	r30, 0x01	; 1
    1352:	38 e1       	ldi	r19, 0x18	; 24
    1354:	30 83       	st	Z, r19
    1356:	31 97       	sbiw	r30, 0x01	; 1
    1358:	39 e1       	ldi	r19, 0x19	; 25
    135a:	30 83       	st	Z, r19
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	30 e2       	ldi	r19, 0x20	; 32
    1360:	30 83       	st	Z, r19
    1362:	31 97       	sbiw	r30, 0x01	; 1
    1364:	31 e2       	ldi	r19, 0x21	; 33
    1366:	30 83       	st	Z, r19
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	20 83       	st	Z, r18
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	23 e2       	ldi	r18, 0x23	; 35
    1370:	20 83       	st	Z, r18
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	40 83       	st	Z, r20
    1376:	31 97       	sbiw	r30, 0x01	; 1
    1378:	50 83       	st	Z, r21
    137a:	31 97       	sbiw	r30, 0x01	; 1
    137c:	26 e2       	ldi	r18, 0x26	; 38
    137e:	20 83       	st	Z, r18
    1380:	31 97       	sbiw	r30, 0x01	; 1
    1382:	27 e2       	ldi	r18, 0x27	; 39
    1384:	20 83       	st	Z, r18
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	28 e2       	ldi	r18, 0x28	; 40
    138a:	20 83       	st	Z, r18
    138c:	31 97       	sbiw	r30, 0x01	; 1
    138e:	29 e2       	ldi	r18, 0x29	; 41
    1390:	20 83       	st	Z, r18
    1392:	31 97       	sbiw	r30, 0x01	; 1
    1394:	20 e3       	ldi	r18, 0x30	; 48
    1396:	20 83       	st	Z, r18
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	21 e3       	ldi	r18, 0x31	; 49
    139c:	20 83       	st	Z, r18
    139e:	89 97       	sbiw	r24, 0x29	; 41
    13a0:	08 95       	ret

000013a2 <xPortStartScheduler>:
    13a2:	82 e0       	ldi	r24, 0x02	; 2
    13a4:	84 bd       	out	0x24, r24	; 36
    13a6:	16 bc       	out	0x26, r1	; 38
    13a8:	80 e3       	ldi	r24, 0x30	; 48
    13aa:	87 bd       	out	0x27, r24	; 39
    13ac:	ee e6       	ldi	r30, 0x6E	; 110
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	82 60       	ori	r24, 0x02	; 2
    13b4:	80 83       	st	Z, r24
    13b6:	83 e0       	ldi	r24, 0x03	; 3
    13b8:	85 bd       	out	0x25, r24	; 37
    13ba:	a0 91 8d 08 	lds	r26, 0x088D
    13be:	b0 91 8e 08 	lds	r27, 0x088E
    13c2:	cd 91       	ld	r28, X+
    13c4:	cd bf       	out	0x3d, r28	; 61
    13c6:	dd 91       	ld	r29, X+
    13c8:	de bf       	out	0x3e, r29	; 62
    13ca:	ff 91       	pop	r31
    13cc:	ef 91       	pop	r30
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
    13d2:	bf 91       	pop	r27
    13d4:	af 91       	pop	r26
    13d6:	9f 91       	pop	r25
    13d8:	8f 91       	pop	r24
    13da:	7f 91       	pop	r23
    13dc:	6f 91       	pop	r22
    13de:	5f 91       	pop	r21
    13e0:	4f 91       	pop	r20
    13e2:	3f 91       	pop	r19
    13e4:	2f 91       	pop	r18
    13e6:	1f 91       	pop	r17
    13e8:	0f 91       	pop	r16
    13ea:	ff 90       	pop	r15
    13ec:	ef 90       	pop	r14
    13ee:	df 90       	pop	r13
    13f0:	cf 90       	pop	r12
    13f2:	bf 90       	pop	r11
    13f4:	af 90       	pop	r10
    13f6:	9f 90       	pop	r9
    13f8:	8f 90       	pop	r8
    13fa:	7f 90       	pop	r7
    13fc:	6f 90       	pop	r6
    13fe:	5f 90       	pop	r5
    1400:	4f 90       	pop	r4
    1402:	3f 90       	pop	r3
    1404:	2f 90       	pop	r2
    1406:	1f 90       	pop	r1
    1408:	0f 90       	pop	r0
    140a:	0c be       	out	0x3c, r0	; 60
    140c:	0f 90       	pop	r0
    140e:	0b be       	out	0x3b, r0	; 59
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63
    1414:	0f 90       	pop	r0
    1416:	08 95       	ret
    1418:	81 e0       	ldi	r24, 0x01	; 1
    141a:	08 95       	ret

0000141c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    141c:	0f 92       	push	r0
    141e:	0f b6       	in	r0, 0x3f	; 63
    1420:	f8 94       	cli
    1422:	0f 92       	push	r0
    1424:	0b b6       	in	r0, 0x3b	; 59
    1426:	0f 92       	push	r0
    1428:	0c b6       	in	r0, 0x3c	; 60
    142a:	0f 92       	push	r0
    142c:	1f 92       	push	r1
    142e:	11 24       	eor	r1, r1
    1430:	2f 92       	push	r2
    1432:	3f 92       	push	r3
    1434:	4f 92       	push	r4
    1436:	5f 92       	push	r5
    1438:	6f 92       	push	r6
    143a:	7f 92       	push	r7
    143c:	8f 92       	push	r8
    143e:	9f 92       	push	r9
    1440:	af 92       	push	r10
    1442:	bf 92       	push	r11
    1444:	cf 92       	push	r12
    1446:	df 92       	push	r13
    1448:	ef 92       	push	r14
    144a:	ff 92       	push	r15
    144c:	0f 93       	push	r16
    144e:	1f 93       	push	r17
    1450:	2f 93       	push	r18
    1452:	3f 93       	push	r19
    1454:	4f 93       	push	r20
    1456:	5f 93       	push	r21
    1458:	6f 93       	push	r22
    145a:	7f 93       	push	r23
    145c:	8f 93       	push	r24
    145e:	9f 93       	push	r25
    1460:	af 93       	push	r26
    1462:	bf 93       	push	r27
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
    1468:	ef 93       	push	r30
    146a:	ff 93       	push	r31
    146c:	a0 91 8d 08 	lds	r26, 0x088D
    1470:	b0 91 8e 08 	lds	r27, 0x088E
    1474:	0d b6       	in	r0, 0x3d	; 61
    1476:	0d 92       	st	X+, r0
    1478:	0e b6       	in	r0, 0x3e	; 62
    147a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    147c:	22 d7       	rcall	.+3652   	; 0x22c2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    147e:	a0 91 8d 08 	lds	r26, 0x088D
    1482:	b0 91 8e 08 	lds	r27, 0x088E
    1486:	cd 91       	ld	r28, X+
    1488:	cd bf       	out	0x3d, r28	; 61
    148a:	dd 91       	ld	r29, X+
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	ff 91       	pop	r31
    1490:	ef 91       	pop	r30
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	bf 91       	pop	r27
    1498:	af 91       	pop	r26
    149a:	9f 91       	pop	r25
    149c:	8f 91       	pop	r24
    149e:	7f 91       	pop	r23
    14a0:	6f 91       	pop	r22
    14a2:	5f 91       	pop	r21
    14a4:	4f 91       	pop	r20
    14a6:	3f 91       	pop	r19
    14a8:	2f 91       	pop	r18
    14aa:	1f 91       	pop	r17
    14ac:	0f 91       	pop	r16
    14ae:	ff 90       	pop	r15
    14b0:	ef 90       	pop	r14
    14b2:	df 90       	pop	r13
    14b4:	cf 90       	pop	r12
    14b6:	bf 90       	pop	r11
    14b8:	af 90       	pop	r10
    14ba:	9f 90       	pop	r9
    14bc:	8f 90       	pop	r8
    14be:	7f 90       	pop	r7
    14c0:	6f 90       	pop	r6
    14c2:	5f 90       	pop	r5
    14c4:	4f 90       	pop	r4
    14c6:	3f 90       	pop	r3
    14c8:	2f 90       	pop	r2
    14ca:	1f 90       	pop	r1
    14cc:	0f 90       	pop	r0
    14ce:	0c be       	out	0x3c, r0	; 60
    14d0:	0f 90       	pop	r0
    14d2:	0b be       	out	0x3b, r0	; 59
    14d4:	0f 90       	pop	r0
    14d6:	0f be       	out	0x3f, r0	; 63
    14d8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14da:	08 95       	ret

000014dc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    14dc:	0f 92       	push	r0
    14de:	0f b6       	in	r0, 0x3f	; 63
    14e0:	f8 94       	cli
    14e2:	0f 92       	push	r0
    14e4:	0b b6       	in	r0, 0x3b	; 59
    14e6:	0f 92       	push	r0
    14e8:	0c b6       	in	r0, 0x3c	; 60
    14ea:	0f 92       	push	r0
    14ec:	1f 92       	push	r1
    14ee:	11 24       	eor	r1, r1
    14f0:	2f 92       	push	r2
    14f2:	3f 92       	push	r3
    14f4:	4f 92       	push	r4
    14f6:	5f 92       	push	r5
    14f8:	6f 92       	push	r6
    14fa:	7f 92       	push	r7
    14fc:	8f 92       	push	r8
    14fe:	9f 92       	push	r9
    1500:	af 92       	push	r10
    1502:	bf 92       	push	r11
    1504:	cf 92       	push	r12
    1506:	df 92       	push	r13
    1508:	ef 92       	push	r14
    150a:	ff 92       	push	r15
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	2f 93       	push	r18
    1512:	3f 93       	push	r19
    1514:	4f 93       	push	r20
    1516:	5f 93       	push	r21
    1518:	6f 93       	push	r22
    151a:	7f 93       	push	r23
    151c:	8f 93       	push	r24
    151e:	9f 93       	push	r25
    1520:	af 93       	push	r26
    1522:	bf 93       	push	r27
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	ef 93       	push	r30
    152a:	ff 93       	push	r31
    152c:	a0 91 8d 08 	lds	r26, 0x088D
    1530:	b0 91 8e 08 	lds	r27, 0x088E
    1534:	0d b6       	in	r0, 0x3d	; 61
    1536:	0d 92       	st	X+, r0
    1538:	0e b6       	in	r0, 0x3e	; 62
    153a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    153c:	f0 d4       	rcall	.+2528   	; 0x1f1e <xTaskIncrementTick>
    153e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1540:	c0 d6       	rcall	.+3456   	; 0x22c2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1542:	a0 91 8d 08 	lds	r26, 0x088D
    1546:	b0 91 8e 08 	lds	r27, 0x088E
    154a:	cd 91       	ld	r28, X+
    154c:	cd bf       	out	0x3d, r28	; 61
    154e:	dd 91       	ld	r29, X+
    1550:	de bf       	out	0x3e, r29	; 62
    1552:	ff 91       	pop	r31
    1554:	ef 91       	pop	r30
    1556:	df 91       	pop	r29
    1558:	cf 91       	pop	r28
    155a:	bf 91       	pop	r27
    155c:	af 91       	pop	r26
    155e:	9f 91       	pop	r25
    1560:	8f 91       	pop	r24
    1562:	7f 91       	pop	r23
    1564:	6f 91       	pop	r22
    1566:	5f 91       	pop	r21
    1568:	4f 91       	pop	r20
    156a:	3f 91       	pop	r19
    156c:	2f 91       	pop	r18
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	ff 90       	pop	r15
    1574:	ef 90       	pop	r14
    1576:	df 90       	pop	r13
    1578:	cf 90       	pop	r12
    157a:	bf 90       	pop	r11
    157c:	af 90       	pop	r10
    157e:	9f 90       	pop	r9
    1580:	8f 90       	pop	r8
    1582:	7f 90       	pop	r7
    1584:	6f 90       	pop	r6
    1586:	5f 90       	pop	r5
    1588:	4f 90       	pop	r4
    158a:	3f 90       	pop	r3
    158c:	2f 90       	pop	r2
    158e:	1f 90       	pop	r1
    1590:	0f 90       	pop	r0
    1592:	0c be       	out	0x3c, r0	; 60
    1594:	0f 90       	pop	r0
    1596:	0b be       	out	0x3b, r0	; 59
    1598:	0f 90       	pop	r0
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    159e:	08 95       	ret

000015a0 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    15a0:	9d df       	rcall	.-198    	; 0x14dc <vPortYieldFromTick>
		 asm volatile ("reti");
    15a2:	18 95       	reti

000015a4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    15a4:	1f 93       	push	r17
    15a6:	cf 93       	push	r28
    15a8:	df 93       	push	r29
    15aa:	ec 01       	movw	r28, r24
    15ac:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    15ae:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15b0:	81 11       	cpse	r24, r1
    15b2:	0c c0       	rjmp	.+24     	; 0x15cc <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    15b4:	88 81       	ld	r24, Y
    15b6:	99 81       	ldd	r25, Y+1	; 0x01
    15b8:	89 2b       	or	r24, r25
    15ba:	09 f0       	breq	.+2      	; 0x15be <prvCopyDataToQueue+0x1a>
    15bc:	47 c0       	rjmp	.+142    	; 0x164c <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    15be:	8a 81       	ldd	r24, Y+2	; 0x02
    15c0:	9b 81       	ldd	r25, Y+3	; 0x03
    15c2:	0e 94 23 13 	call	0x2646	; 0x2646 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    15c6:	1b 82       	std	Y+3, r1	; 0x03
    15c8:	1a 82       	std	Y+2, r1	; 0x02
    15ca:	47 c0       	rjmp	.+142    	; 0x165a <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    15cc:	41 11       	cpse	r20, r1
    15ce:	18 c0       	rjmp	.+48     	; 0x1600 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    15d0:	48 2f       	mov	r20, r24
    15d2:	50 e0       	ldi	r21, 0x00	; 0
    15d4:	8c 81       	ldd	r24, Y+4	; 0x04
    15d6:	9d 81       	ldd	r25, Y+5	; 0x05
    15d8:	0e 94 ef 16 	call	0x2dde	; 0x2dde <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15dc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15de:	8c 81       	ldd	r24, Y+4	; 0x04
    15e0:	9d 81       	ldd	r25, Y+5	; 0x05
    15e2:	82 0f       	add	r24, r18
    15e4:	91 1d       	adc	r25, r1
    15e6:	9d 83       	std	Y+5, r25	; 0x05
    15e8:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15ea:	2a 81       	ldd	r18, Y+2	; 0x02
    15ec:	3b 81       	ldd	r19, Y+3	; 0x03
    15ee:	82 17       	cp	r24, r18
    15f0:	93 07       	cpc	r25, r19
    15f2:	70 f1       	brcs	.+92     	; 0x1650 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15f4:	88 81       	ld	r24, Y
    15f6:	99 81       	ldd	r25, Y+1	; 0x01
    15f8:	9d 83       	std	Y+5, r25	; 0x05
    15fa:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    15fc:	80 e0       	ldi	r24, 0x00	; 0
    15fe:	2d c0       	rjmp	.+90     	; 0x165a <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1600:	48 2f       	mov	r20, r24
    1602:	50 e0       	ldi	r21, 0x00	; 0
    1604:	8e 81       	ldd	r24, Y+6	; 0x06
    1606:	9f 81       	ldd	r25, Y+7	; 0x07
    1608:	0e 94 ef 16 	call	0x2dde	; 0x2dde <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    160c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    160e:	30 e0       	ldi	r19, 0x00	; 0
    1610:	31 95       	neg	r19
    1612:	21 95       	neg	r18
    1614:	31 09       	sbc	r19, r1
    1616:	8e 81       	ldd	r24, Y+6	; 0x06
    1618:	9f 81       	ldd	r25, Y+7	; 0x07
    161a:	82 0f       	add	r24, r18
    161c:	93 1f       	adc	r25, r19
    161e:	9f 83       	std	Y+7, r25	; 0x07
    1620:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1622:	68 81       	ld	r22, Y
    1624:	79 81       	ldd	r23, Y+1	; 0x01
    1626:	86 17       	cp	r24, r22
    1628:	97 07       	cpc	r25, r23
    162a:	30 f4       	brcc	.+12     	; 0x1638 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    162c:	8a 81       	ldd	r24, Y+2	; 0x02
    162e:	9b 81       	ldd	r25, Y+3	; 0x03
    1630:	28 0f       	add	r18, r24
    1632:	39 1f       	adc	r19, r25
    1634:	3f 83       	std	Y+7, r19	; 0x07
    1636:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1638:	12 30       	cpi	r17, 0x02	; 2
    163a:	61 f4       	brne	.+24     	; 0x1654 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    163c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    163e:	88 23       	and	r24, r24
    1640:	59 f0       	breq	.+22     	; 0x1658 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1642:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1644:	81 50       	subi	r24, 0x01	; 1
    1646:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	07 c0       	rjmp	.+14     	; 0x165a <prvCopyDataToQueue+0xb6>
    164c:	80 e0       	ldi	r24, 0x00	; 0
    164e:	05 c0       	rjmp	.+10     	; 0x165a <prvCopyDataToQueue+0xb6>
    1650:	80 e0       	ldi	r24, 0x00	; 0
    1652:	03 c0       	rjmp	.+6      	; 0x165a <prvCopyDataToQueue+0xb6>
    1654:	80 e0       	ldi	r24, 0x00	; 0
    1656:	01 c0       	rjmp	.+2      	; 0x165a <prvCopyDataToQueue+0xb6>
    1658:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    165a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    165c:	9f 5f       	subi	r25, 0xFF	; 255
    165e:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1660:	df 91       	pop	r29
    1662:	cf 91       	pop	r28
    1664:	1f 91       	pop	r17
    1666:	08 95       	ret

00001668 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1668:	fc 01       	movw	r30, r24
    166a:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    166c:	44 8d       	ldd	r20, Z+28	; 0x1c
    166e:	44 23       	and	r20, r20
    1670:	a1 f0       	breq	.+40     	; 0x169a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1672:	50 e0       	ldi	r21, 0x00	; 0
    1674:	26 81       	ldd	r18, Z+6	; 0x06
    1676:	37 81       	ldd	r19, Z+7	; 0x07
    1678:	24 0f       	add	r18, r20
    167a:	35 1f       	adc	r19, r21
    167c:	37 83       	std	Z+7, r19	; 0x07
    167e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1680:	62 81       	ldd	r22, Z+2	; 0x02
    1682:	73 81       	ldd	r23, Z+3	; 0x03
    1684:	26 17       	cp	r18, r22
    1686:	37 07       	cpc	r19, r23
    1688:	20 f0       	brcs	.+8      	; 0x1692 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    168a:	20 81       	ld	r18, Z
    168c:	31 81       	ldd	r19, Z+1	; 0x01
    168e:	37 83       	std	Z+7, r19	; 0x07
    1690:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1692:	66 81       	ldd	r22, Z+6	; 0x06
    1694:	77 81       	ldd	r23, Z+7	; 0x07
    1696:	0c 94 ef 16 	jmp	0x2dde	; 0x2dde <memcpy>
    169a:	08 95       	ret

0000169c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    169c:	0f 93       	push	r16
    169e:	1f 93       	push	r17
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    16a6:	0f b6       	in	r0, 0x3f	; 63
    16a8:	f8 94       	cli
    16aa:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16ae:	18 16       	cp	r1, r24
    16b0:	a4 f4       	brge	.+40     	; 0x16da <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16b2:	89 89       	ldd	r24, Y+17	; 0x11
    16b4:	88 23       	and	r24, r24
    16b6:	89 f0       	breq	.+34     	; 0x16da <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16b8:	8e 01       	movw	r16, r28
    16ba:	0f 5e       	subi	r16, 0xEF	; 239
    16bc:	1f 4f       	sbci	r17, 0xFF	; 255
    16be:	03 c0       	rjmp	.+6      	; 0x16c6 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16c0:	89 89       	ldd	r24, Y+17	; 0x11
    16c2:	88 23       	and	r24, r24
    16c4:	51 f0       	breq	.+20     	; 0x16da <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16c6:	c8 01       	movw	r24, r16
    16c8:	d1 d6       	rcall	.+3490   	; 0x246c <xTaskRemoveFromEventList>
    16ca:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    16cc:	5a d7       	rcall	.+3764   	; 0x2582 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    16ce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16d0:	81 50       	subi	r24, 0x01	; 1
    16d2:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16d4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16d6:	18 16       	cp	r1, r24
    16d8:	9c f3       	brlt	.-26     	; 0x16c0 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    16e2:	0f b6       	in	r0, 0x3f	; 63
    16e4:	f8 94       	cli
    16e6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16e8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16ea:	18 16       	cp	r1, r24
    16ec:	a4 f4       	brge	.+40     	; 0x1716 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16ee:	88 85       	ldd	r24, Y+8	; 0x08
    16f0:	88 23       	and	r24, r24
    16f2:	89 f0       	breq	.+34     	; 0x1716 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16f4:	8e 01       	movw	r16, r28
    16f6:	08 5f       	subi	r16, 0xF8	; 248
    16f8:	1f 4f       	sbci	r17, 0xFF	; 255
    16fa:	03 c0       	rjmp	.+6      	; 0x1702 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16fc:	88 85       	ldd	r24, Y+8	; 0x08
    16fe:	88 23       	and	r24, r24
    1700:	51 f0       	breq	.+20     	; 0x1716 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1702:	c8 01       	movw	r24, r16
    1704:	b3 d6       	rcall	.+3430   	; 0x246c <xTaskRemoveFromEventList>
    1706:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1708:	3c d7       	rcall	.+3704   	; 0x2582 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    170a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    170c:	81 50       	subi	r24, 0x01	; 1
    170e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1710:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1712:	18 16       	cp	r1, r24
    1714:	9c f3       	brlt	.-26     	; 0x16fc <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1716:	8f ef       	ldi	r24, 0xFF	; 255
    1718:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    171a:	0f 90       	pop	r0
    171c:	0f be       	out	0x3f, r0	; 63
}
    171e:	df 91       	pop	r29
    1720:	cf 91       	pop	r28
    1722:	1f 91       	pop	r17
    1724:	0f 91       	pop	r16
    1726:	08 95       	ret

00001728 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1728:	cf 93       	push	r28
    172a:	df 93       	push	r29
    172c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1734:	88 81       	ld	r24, Y
    1736:	99 81       	ldd	r25, Y+1	; 0x01
    1738:	2c 8d       	ldd	r18, Y+28	; 0x1c
    173a:	30 e0       	ldi	r19, 0x00	; 0
    173c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    173e:	72 9f       	mul	r23, r18
    1740:	a0 01       	movw	r20, r0
    1742:	73 9f       	mul	r23, r19
    1744:	50 0d       	add	r21, r0
    1746:	11 24       	eor	r1, r1
    1748:	fc 01       	movw	r30, r24
    174a:	e4 0f       	add	r30, r20
    174c:	f5 1f       	adc	r31, r21
    174e:	fb 83       	std	Y+3, r31	; 0x03
    1750:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1752:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1754:	9d 83       	std	Y+5, r25	; 0x05
    1756:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1758:	42 1b       	sub	r20, r18
    175a:	53 0b       	sbc	r21, r19
    175c:	84 0f       	add	r24, r20
    175e:	95 1f       	adc	r25, r21
    1760:	9f 83       	std	Y+7, r25	; 0x07
    1762:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1764:	8f ef       	ldi	r24, 0xFF	; 255
    1766:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1768:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    176a:	61 11       	cpse	r22, r1
    176c:	0a c0       	rjmp	.+20     	; 0x1782 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    176e:	88 85       	ldd	r24, Y+8	; 0x08
    1770:	88 23       	and	r24, r24
    1772:	79 f0       	breq	.+30     	; 0x1792 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1774:	ce 01       	movw	r24, r28
    1776:	08 96       	adiw	r24, 0x08	; 8
    1778:	79 d6       	rcall	.+3314   	; 0x246c <xTaskRemoveFromEventList>
    177a:	81 30       	cpi	r24, 0x01	; 1
    177c:	51 f4       	brne	.+20     	; 0x1792 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    177e:	4e de       	rcall	.-868    	; 0x141c <vPortYield>
    1780:	08 c0       	rjmp	.+16     	; 0x1792 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1782:	ce 01       	movw	r24, r28
    1784:	08 96       	adiw	r24, 0x08	; 8
    1786:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    178a:	ce 01       	movw	r24, r28
    178c:	41 96       	adiw	r24, 0x11	; 17
    178e:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	df 91       	pop	r29
    179a:	cf 91       	pop	r28
    179c:	08 95       	ret

0000179e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	18 2f       	mov	r17, r24
    17a8:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    17aa:	88 23       	and	r24, r24
    17ac:	e9 f0       	breq	.+58     	; 0x17e8 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    17ae:	8f e1       	ldi	r24, 0x1F	; 31
    17b0:	90 e0       	ldi	r25, 0x00	; 0
    17b2:	0e 94 01 03 	call	0x602	; 0x602 <pvPortMalloc>
    17b6:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17b8:	00 97       	sbiw	r24, 0x00	; 0
    17ba:	c1 f0       	breq	.+48     	; 0x17ec <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17bc:	10 9f       	mul	r17, r16
    17be:	c0 01       	movw	r24, r0
    17c0:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	0e 94 01 03 	call	0x602	; 0x602 <pvPortMalloc>
    17c8:	99 83       	std	Y+1, r25	; 0x01
    17ca:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    17cc:	89 2b       	or	r24, r25
    17ce:	31 f0       	breq	.+12     	; 0x17dc <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    17d0:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    17d2:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    17d4:	61 e0       	ldi	r22, 0x01	; 1
    17d6:	ce 01       	movw	r24, r28
    17d8:	a7 df       	rcall	.-178    	; 0x1728 <xQueueGenericReset>
    17da:	08 c0       	rjmp	.+16     	; 0x17ec <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    17dc:	ce 01       	movw	r24, r28
    17de:	0e 94 36 03 	call	0x66c	; 0x66c <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    17e2:	c0 e0       	ldi	r28, 0x00	; 0
    17e4:	d0 e0       	ldi	r29, 0x00	; 0
    17e6:	02 c0       	rjmp	.+4      	; 0x17ec <xQueueGenericCreate+0x4e>
    17e8:	c0 e0       	ldi	r28, 0x00	; 0
    17ea:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    17ec:	ce 01       	movw	r24, r28
    17ee:	df 91       	pop	r29
    17f0:	cf 91       	pop	r28
    17f2:	1f 91       	pop	r17
    17f4:	0f 91       	pop	r16
    17f6:	08 95       	ret

000017f8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    17f8:	9f 92       	push	r9
    17fa:	af 92       	push	r10
    17fc:	bf 92       	push	r11
    17fe:	cf 92       	push	r12
    1800:	df 92       	push	r13
    1802:	ef 92       	push	r14
    1804:	ff 92       	push	r15
    1806:	0f 93       	push	r16
    1808:	1f 93       	push	r17
    180a:	cf 93       	push	r28
    180c:	df 93       	push	r29
    180e:	00 d0       	rcall	.+0      	; 0x1810 <xQueueGenericSend+0x18>
    1810:	1f 92       	push	r1
    1812:	1f 92       	push	r1
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	8c 01       	movw	r16, r24
    181a:	6b 01       	movw	r12, r22
    181c:	5d 83       	std	Y+5, r21	; 0x05
    181e:	4c 83       	std	Y+4, r20	; 0x04
    1820:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1822:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1824:	99 24       	eor	r9, r9
    1826:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1828:	7c 01       	movw	r14, r24
    182a:	88 e0       	ldi	r24, 0x08	; 8
    182c:	e8 0e       	add	r14, r24
    182e:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1830:	0f b6       	in	r0, 0x3f	; 63
    1832:	f8 94       	cli
    1834:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1836:	f8 01       	movw	r30, r16
    1838:	92 8d       	ldd	r25, Z+26	; 0x1a
    183a:	83 8d       	ldd	r24, Z+27	; 0x1b
    183c:	98 17       	cp	r25, r24
    183e:	18 f0       	brcs	.+6      	; 0x1846 <xQueueGenericSend+0x4e>
    1840:	f2 e0       	ldi	r31, 0x02	; 2
    1842:	af 12       	cpse	r10, r31
    1844:	15 c0       	rjmp	.+42     	; 0x1870 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1846:	4a 2d       	mov	r20, r10
    1848:	b6 01       	movw	r22, r12
    184a:	c8 01       	movw	r24, r16
    184c:	ab de       	rcall	.-682    	; 0x15a4 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    184e:	f8 01       	movw	r30, r16
    1850:	91 89       	ldd	r25, Z+17	; 0x11
    1852:	99 23       	and	r25, r25
    1854:	39 f0       	breq	.+14     	; 0x1864 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1856:	c8 01       	movw	r24, r16
    1858:	41 96       	adiw	r24, 0x11	; 17
    185a:	08 d6       	rcall	.+3088   	; 0x246c <xTaskRemoveFromEventList>
    185c:	81 30       	cpi	r24, 0x01	; 1
    185e:	21 f4       	brne	.+8      	; 0x1868 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1860:	dd dd       	rcall	.-1094   	; 0x141c <vPortYield>
    1862:	02 c0       	rjmp	.+4      	; 0x1868 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1864:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1866:	da dd       	rcall	.-1100   	; 0x141c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    186c:	81 e0       	ldi	r24, 0x01	; 1
    186e:	46 c0       	rjmp	.+140    	; 0x18fc <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1870:	ec 81       	ldd	r30, Y+4	; 0x04
    1872:	fd 81       	ldd	r31, Y+5	; 0x05
    1874:	ef 2b       	or	r30, r31
    1876:	21 f4       	brne	.+8      	; 0x1880 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1878:	0f 90       	pop	r0
    187a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    187c:	80 e0       	ldi	r24, 0x00	; 0
    187e:	3e c0       	rjmp	.+124    	; 0x18fc <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1880:	b1 10       	cpse	r11, r1
    1882:	04 c0       	rjmp	.+8      	; 0x188c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1884:	ce 01       	movw	r24, r28
    1886:	01 96       	adiw	r24, 0x01	; 1
    1888:	39 d6       	rcall	.+3186   	; 0x24fc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    188a:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    188c:	0f 90       	pop	r0
    188e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1890:	31 d3       	rcall	.+1634   	; 0x1ef4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
    1898:	f8 01       	movw	r30, r16
    189a:	85 8d       	ldd	r24, Z+29	; 0x1d
    189c:	8f 3f       	cpi	r24, 0xFF	; 255
    189e:	09 f4       	brne	.+2      	; 0x18a2 <xQueueGenericSend+0xaa>
    18a0:	15 8e       	std	Z+29, r1	; 0x1d
    18a2:	f8 01       	movw	r30, r16
    18a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    18a6:	8f 3f       	cpi	r24, 0xFF	; 255
    18a8:	09 f4       	brne	.+2      	; 0x18ac <xQueueGenericSend+0xb4>
    18aa:	16 8e       	std	Z+30, r1	; 0x1e
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18b0:	be 01       	movw	r22, r28
    18b2:	6c 5f       	subi	r22, 0xFC	; 252
    18b4:	7f 4f       	sbci	r23, 0xFF	; 255
    18b6:	ce 01       	movw	r24, r28
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	2b d6       	rcall	.+3158   	; 0x2512 <xTaskCheckForTimeOut>
    18bc:	81 11       	cpse	r24, r1
    18be:	1a c0       	rjmp	.+52     	; 0x18f4 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    18c6:	f8 01       	movw	r30, r16
    18c8:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18ca:	0f 90       	pop	r0
    18cc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18ce:	f8 01       	movw	r30, r16
    18d0:	83 8d       	ldd	r24, Z+27	; 0x1b
    18d2:	98 13       	cpse	r25, r24
    18d4:	0b c0       	rjmp	.+22     	; 0x18ec <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18d6:	6c 81       	ldd	r22, Y+4	; 0x04
    18d8:	7d 81       	ldd	r23, Y+5	; 0x05
    18da:	c7 01       	movw	r24, r14
    18dc:	9c d5       	rcall	.+2872   	; 0x2416 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    18de:	c8 01       	movw	r24, r16
    18e0:	dd de       	rcall	.-582    	; 0x169c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    18e2:	db d3       	rcall	.+1974   	; 0x209a <xTaskResumeAll>
    18e4:	81 11       	cpse	r24, r1
    18e6:	a4 cf       	rjmp	.-184    	; 0x1830 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    18e8:	99 dd       	rcall	.-1230   	; 0x141c <vPortYield>
    18ea:	a2 cf       	rjmp	.-188    	; 0x1830 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18ec:	c8 01       	movw	r24, r16
    18ee:	d6 de       	rcall	.-596    	; 0x169c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18f0:	d4 d3       	rcall	.+1960   	; 0x209a <xTaskResumeAll>
    18f2:	9e cf       	rjmp	.-196    	; 0x1830 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18f4:	c8 01       	movw	r24, r16
    18f6:	d2 de       	rcall	.-604    	; 0x169c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18f8:	d0 d3       	rcall	.+1952   	; 0x209a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    18fc:	0f 90       	pop	r0
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	1f 91       	pop	r17
    190c:	0f 91       	pop	r16
    190e:	ff 90       	pop	r15
    1910:	ef 90       	pop	r14
    1912:	df 90       	pop	r13
    1914:	cf 90       	pop	r12
    1916:	bf 90       	pop	r11
    1918:	af 90       	pop	r10
    191a:	9f 90       	pop	r9
    191c:	08 95       	ret

0000191e <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    191e:	cf 93       	push	r28
    1920:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1922:	8f e1       	ldi	r24, 0x1F	; 31
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	0e 94 01 03 	call	0x602	; 0x602 <pvPortMalloc>
    192a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    192c:	00 97       	sbiw	r24, 0x00	; 0
    192e:	f1 f0       	breq	.+60     	; 0x196c <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1930:	1b 82       	std	Y+3, r1	; 0x03
    1932:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1934:	19 82       	std	Y+1, r1	; 0x01
    1936:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1938:	1d 82       	std	Y+5, r1	; 0x05
    193a:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    193c:	1f 82       	std	Y+7, r1	; 0x07
    193e:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1940:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1946:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1948:	8f ef       	ldi	r24, 0xFF	; 255
    194a:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    194c:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    194e:	ce 01       	movw	r24, r28
    1950:	08 96       	adiw	r24, 0x08	; 8
    1952:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1956:	ce 01       	movw	r24, r28
    1958:	41 96       	adiw	r24, 0x11	; 17
    195a:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    195e:	20 e0       	ldi	r18, 0x00	; 0
    1960:	40 e0       	ldi	r20, 0x00	; 0
    1962:	50 e0       	ldi	r21, 0x00	; 0
    1964:	60 e0       	ldi	r22, 0x00	; 0
    1966:	70 e0       	ldi	r23, 0x00	; 0
    1968:	ce 01       	movw	r24, r28
    196a:	46 df       	rcall	.-372    	; 0x17f8 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    196c:	ce 01       	movw	r24, r28
    196e:	df 91       	pop	r29
    1970:	cf 91       	pop	r28
    1972:	08 95       	ret

00001974 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1974:	0f 93       	push	r16
    1976:	1f 93       	push	r17
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
    197c:	ec 01       	movw	r28, r24
    197e:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1980:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1982:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1984:	98 17       	cp	r25, r24
    1986:	10 f0       	brcs	.+4      	; 0x198c <xQueueGenericSendFromISR+0x18>
    1988:	22 30       	cpi	r18, 0x02	; 2
    198a:	11 f5       	brne	.+68     	; 0x19d0 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    198c:	42 2f       	mov	r20, r18
    198e:	ce 01       	movw	r24, r28
    1990:	09 de       	rcall	.-1006   	; 0x15a4 <prvCopyDataToQueue>
    1992:	88 23       	and	r24, r24
    1994:	31 f0       	breq	.+12     	; 0x19a2 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1996:	01 15       	cp	r16, r1
    1998:	11 05       	cpc	r17, r1
    199a:	19 f0       	breq	.+6      	; 0x19a2 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	f8 01       	movw	r30, r16
    19a0:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    19a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19a4:	8f 3f       	cpi	r24, 0xFF	; 255
    19a6:	79 f4       	brne	.+30     	; 0x19c6 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19a8:	89 89       	ldd	r24, Y+17	; 0x11
    19aa:	88 23       	and	r24, r24
    19ac:	99 f0       	breq	.+38     	; 0x19d4 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19ae:	ce 01       	movw	r24, r28
    19b0:	41 96       	adiw	r24, 0x11	; 17
    19b2:	5c d5       	rcall	.+2744   	; 0x246c <xTaskRemoveFromEventList>
    19b4:	88 23       	and	r24, r24
    19b6:	81 f0       	breq	.+32     	; 0x19d8 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    19b8:	01 15       	cp	r16, r1
    19ba:	11 05       	cpc	r17, r1
    19bc:	79 f0       	breq	.+30     	; 0x19dc <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	f8 01       	movw	r30, r16
    19c2:	80 83       	st	Z, r24
    19c4:	0c c0       	rjmp	.+24     	; 0x19de <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    19c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19c8:	8f 5f       	subi	r24, 0xFF	; 255
    19ca:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	07 c0       	rjmp	.+14     	; 0x19de <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19d0:	80 e0       	ldi	r24, 0x00	; 0
    19d2:	05 c0       	rjmp	.+10     	; 0x19de <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	03 c0       	rjmp	.+6      	; 0x19de <xQueueGenericSendFromISR+0x6a>
    19d8:	81 e0       	ldi	r24, 0x01	; 1
    19da:	01 c0       	rjmp	.+2      	; 0x19de <xQueueGenericSendFromISR+0x6a>
    19dc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19de:	df 91       	pop	r29
    19e0:	cf 91       	pop	r28
    19e2:	1f 91       	pop	r17
    19e4:	0f 91       	pop	r16
    19e6:	08 95       	ret

000019e8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    19e8:	9f 92       	push	r9
    19ea:	af 92       	push	r10
    19ec:	bf 92       	push	r11
    19ee:	cf 92       	push	r12
    19f0:	df 92       	push	r13
    19f2:	ef 92       	push	r14
    19f4:	ff 92       	push	r15
    19f6:	0f 93       	push	r16
    19f8:	1f 93       	push	r17
    19fa:	cf 93       	push	r28
    19fc:	df 93       	push	r29
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <xQueueGenericReceive+0x18>
    1a00:	1f 92       	push	r1
    1a02:	1f 92       	push	r1
    1a04:	cd b7       	in	r28, 0x3d	; 61
    1a06:	de b7       	in	r29, 0x3e	; 62
    1a08:	8c 01       	movw	r16, r24
    1a0a:	6b 01       	movw	r12, r22
    1a0c:	5d 83       	std	Y+5, r21	; 0x05
    1a0e:	4c 83       	std	Y+4, r20	; 0x04
    1a10:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1a12:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1a14:	99 24       	eor	r9, r9
    1a16:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a18:	7c 01       	movw	r14, r24
    1a1a:	81 e1       	ldi	r24, 0x11	; 17
    1a1c:	e8 0e       	add	r14, r24
    1a1e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a20:	0f b6       	in	r0, 0x3f	; 63
    1a22:	f8 94       	cli
    1a24:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a26:	f8 01       	movw	r30, r16
    1a28:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a2a:	88 23       	and	r24, r24
    1a2c:	69 f1       	breq	.+90     	; 0x1a88 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a2e:	e6 80       	ldd	r14, Z+6	; 0x06
    1a30:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a32:	b6 01       	movw	r22, r12
    1a34:	c8 01       	movw	r24, r16
    1a36:	18 de       	rcall	.-976    	; 0x1668 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a38:	b1 10       	cpse	r11, r1
    1a3a:	17 c0       	rjmp	.+46     	; 0x1a6a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a40:	81 50       	subi	r24, 0x01	; 1
    1a42:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a44:	80 81       	ld	r24, Z
    1a46:	91 81       	ldd	r25, Z+1	; 0x01
    1a48:	89 2b       	or	r24, r25
    1a4a:	21 f4       	brne	.+8      	; 0x1a54 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1a4c:	3b d6       	rcall	.+3190   	; 0x26c4 <pvTaskIncrementMutexHeldCount>
    1a4e:	f8 01       	movw	r30, r16
    1a50:	93 83       	std	Z+3, r25	; 0x03
    1a52:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a54:	f8 01       	movw	r30, r16
    1a56:	80 85       	ldd	r24, Z+8	; 0x08
    1a58:	88 23       	and	r24, r24
    1a5a:	91 f0       	breq	.+36     	; 0x1a80 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a5c:	c8 01       	movw	r24, r16
    1a5e:	08 96       	adiw	r24, 0x08	; 8
    1a60:	05 d5       	rcall	.+2570   	; 0x246c <xTaskRemoveFromEventList>
    1a62:	81 30       	cpi	r24, 0x01	; 1
    1a64:	69 f4       	brne	.+26     	; 0x1a80 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1a66:	da dc       	rcall	.-1612   	; 0x141c <vPortYield>
    1a68:	0b c0       	rjmp	.+22     	; 0x1a80 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	f7 82       	std	Z+7, r15	; 0x07
    1a6e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a70:	81 89       	ldd	r24, Z+17	; 0x11
    1a72:	88 23       	and	r24, r24
    1a74:	29 f0       	breq	.+10     	; 0x1a80 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a76:	c8 01       	movw	r24, r16
    1a78:	41 96       	adiw	r24, 0x11	; 17
    1a7a:	f8 d4       	rcall	.+2544   	; 0x246c <xTaskRemoveFromEventList>
    1a7c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1a7e:	ce dc       	rcall	.-1636   	; 0x141c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1a80:	0f 90       	pop	r0
    1a82:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	52 c0       	rjmp	.+164    	; 0x1b2c <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a88:	4c 81       	ldd	r20, Y+4	; 0x04
    1a8a:	5d 81       	ldd	r21, Y+5	; 0x05
    1a8c:	45 2b       	or	r20, r21
    1a8e:	21 f4       	brne	.+8      	; 0x1a98 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a90:	0f 90       	pop	r0
    1a92:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a94:	80 e0       	ldi	r24, 0x00	; 0
    1a96:	4a c0       	rjmp	.+148    	; 0x1b2c <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a98:	a1 10       	cpse	r10, r1
    1a9a:	04 c0       	rjmp	.+8      	; 0x1aa4 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a9c:	ce 01       	movw	r24, r28
    1a9e:	01 96       	adiw	r24, 0x01	; 1
    1aa0:	2d d5       	rcall	.+2650   	; 0x24fc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1aa2:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1aa4:	0f 90       	pop	r0
    1aa6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1aa8:	25 d2       	rcall	.+1098   	; 0x1ef4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1aaa:	0f b6       	in	r0, 0x3f	; 63
    1aac:	f8 94       	cli
    1aae:	0f 92       	push	r0
    1ab0:	f8 01       	movw	r30, r16
    1ab2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ab4:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab6:	09 f4       	brne	.+2      	; 0x1aba <xQueueGenericReceive+0xd2>
    1ab8:	15 8e       	std	Z+29, r1	; 0x1d
    1aba:	f8 01       	movw	r30, r16
    1abc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1abe:	8f 3f       	cpi	r24, 0xFF	; 255
    1ac0:	09 f4       	brne	.+2      	; 0x1ac4 <xQueueGenericReceive+0xdc>
    1ac2:	16 8e       	std	Z+30, r1	; 0x1e
    1ac4:	0f 90       	pop	r0
    1ac6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ac8:	be 01       	movw	r22, r28
    1aca:	6c 5f       	subi	r22, 0xFC	; 252
    1acc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ace:	ce 01       	movw	r24, r28
    1ad0:	01 96       	adiw	r24, 0x01	; 1
    1ad2:	1f d5       	rcall	.+2622   	; 0x2512 <xTaskCheckForTimeOut>
    1ad4:	81 11       	cpse	r24, r1
    1ad6:	26 c0       	rjmp	.+76     	; 0x1b24 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ade:	f8 01       	movw	r30, r16
    1ae0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ae6:	81 11       	cpse	r24, r1
    1ae8:	19 c0       	rjmp	.+50     	; 0x1b1c <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1aea:	f8 01       	movw	r30, r16
    1aec:	80 81       	ld	r24, Z
    1aee:	91 81       	ldd	r25, Z+1	; 0x01
    1af0:	89 2b       	or	r24, r25
    1af2:	49 f4       	brne	.+18     	; 0x1b06 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1af4:	0f b6       	in	r0, 0x3f	; 63
    1af6:	f8 94       	cli
    1af8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1afa:	f8 01       	movw	r30, r16
    1afc:	82 81       	ldd	r24, Z+2	; 0x02
    1afe:	93 81       	ldd	r25, Z+3	; 0x03
    1b00:	44 d5       	rcall	.+2696   	; 0x258a <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b06:	6c 81       	ldd	r22, Y+4	; 0x04
    1b08:	7d 81       	ldd	r23, Y+5	; 0x05
    1b0a:	c7 01       	movw	r24, r14
    1b0c:	84 d4       	rcall	.+2312   	; 0x2416 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b0e:	c8 01       	movw	r24, r16
    1b10:	c5 dd       	rcall	.-1142   	; 0x169c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b12:	c3 d2       	rcall	.+1414   	; 0x209a <xTaskResumeAll>
    1b14:	81 11       	cpse	r24, r1
    1b16:	84 cf       	rjmp	.-248    	; 0x1a20 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1b18:	81 dc       	rcall	.-1790   	; 0x141c <vPortYield>
    1b1a:	82 cf       	rjmp	.-252    	; 0x1a20 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b1c:	c8 01       	movw	r24, r16
    1b1e:	be dd       	rcall	.-1156   	; 0x169c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b20:	bc d2       	rcall	.+1400   	; 0x209a <xTaskResumeAll>
    1b22:	7e cf       	rjmp	.-260    	; 0x1a20 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b24:	c8 01       	movw	r24, r16
    1b26:	ba dd       	rcall	.-1164   	; 0x169c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b28:	b8 d2       	rcall	.+1392   	; 0x209a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b2c:	0f 90       	pop	r0
    1b2e:	0f 90       	pop	r0
    1b30:	0f 90       	pop	r0
    1b32:	0f 90       	pop	r0
    1b34:	0f 90       	pop	r0
    1b36:	df 91       	pop	r29
    1b38:	cf 91       	pop	r28
    1b3a:	1f 91       	pop	r17
    1b3c:	0f 91       	pop	r16
    1b3e:	ff 90       	pop	r15
    1b40:	ef 90       	pop	r14
    1b42:	df 90       	pop	r13
    1b44:	cf 90       	pop	r12
    1b46:	bf 90       	pop	r11
    1b48:	af 90       	pop	r10
    1b4a:	9f 90       	pop	r9
    1b4c:	08 95       	ret

00001b4e <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1b4e:	fc 01       	movw	r30, r24
    1b50:	71 83       	std	Z+1, r23	; 0x01
    1b52:	60 83       	st	Z, r22
    1b54:	42 83       	std	Z+2, r20	; 0x02
    1b56:	14 82       	std	Z+4, r1	; 0x04
    1b58:	13 82       	std	Z+3, r1	; 0x03
    1b5a:	08 95       	ret

00001b5c <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1b5c:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1b5e:	94 81       	ldd	r25, Z+4	; 0x04
    1b60:	a0 81       	ld	r26, Z
    1b62:	b1 81       	ldd	r27, Z+1	; 0x01
    1b64:	a9 0f       	add	r26, r25
    1b66:	b1 1d       	adc	r27, r1
    1b68:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1b6a:	9f 5f       	subi	r25, 0xFF	; 255
    1b6c:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1b6e:	22 81       	ldd	r18, Z+2	; 0x02
    1b70:	92 17       	cp	r25, r18
    1b72:	10 f0       	brcs	.+4      	; 0x1b78 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1b74:	92 1b       	sub	r25, r18
    1b76:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1b78:	93 81       	ldd	r25, Z+3	; 0x03
    1b7a:	91 50       	subi	r25, 0x01	; 1
    1b7c:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1b7e:	08 95       	ret

00001b80 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1b80:	fc 01       	movw	r30, r24
    1b82:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1b84:	83 81       	ldd	r24, Z+3	; 0x03
    1b86:	22 81       	ldd	r18, Z+2	; 0x02
    1b88:	82 17       	cp	r24, r18
    1b8a:	80 f4       	brcc	.+32     	; 0x1bac <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1b8c:	34 81       	ldd	r19, Z+4	; 0x04
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	83 0f       	add	r24, r19
    1b92:	91 1d       	adc	r25, r1
    1b94:	62 2f       	mov	r22, r18
    1b96:	70 e0       	ldi	r23, 0x00	; 0
    1b98:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <__divmodhi4>
    1b9c:	a0 81       	ld	r26, Z
    1b9e:	b1 81       	ldd	r27, Z+1	; 0x01
    1ba0:	a8 0f       	add	r26, r24
    1ba2:	b9 1f       	adc	r27, r25
    1ba4:	4c 93       	st	X, r20
            ring->rLength++;
    1ba6:	83 81       	ldd	r24, Z+3	; 0x03
    1ba8:	8f 5f       	subi	r24, 0xFF	; 255
    1baa:	83 83       	std	Z+3, r24	; 0x03
    1bac:	08 95       	ret

00001bae <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1bae:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1bb0:	81 e0       	ldi	r24, 0x01	; 1
    1bb2:	22 81       	ldd	r18, Z+2	; 0x02
    1bb4:	93 81       	ldd	r25, Z+3	; 0x03
    1bb6:	29 13       	cpse	r18, r25
    1bb8:	80 e0       	ldi	r24, 0x00	; 0
}
    1bba:	08 95       	ret

00001bbc <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1bbc:	21 e0       	ldi	r18, 0x01	; 1
    1bbe:	fc 01       	movw	r30, r24
    1bc0:	83 81       	ldd	r24, Z+3	; 0x03
    1bc2:	81 11       	cpse	r24, r1
    1bc4:	01 c0       	rjmp	.+2      	; 0x1bc8 <ringBufferNotEmpty+0xc>
    1bc6:	20 e0       	ldi	r18, 0x00	; 0
}
    1bc8:	82 2f       	mov	r24, r18
    1bca:	08 95       	ret

00001bcc <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1bcc:	e0 91 4c 08 	lds	r30, 0x084C
    1bd0:	f0 91 4d 08 	lds	r31, 0x084D
    1bd4:	80 81       	ld	r24, Z
    1bd6:	81 11       	cpse	r24, r1
    1bd8:	07 c0       	rjmp	.+14     	; 0x1be8 <prvResetNextTaskUnblockTime+0x1c>
    1bda:	8f ef       	ldi	r24, 0xFF	; 255
    1bdc:	9f ef       	ldi	r25, 0xFF	; 255
    1bde:	90 93 06 02 	sts	0x0206, r25
    1be2:	80 93 05 02 	sts	0x0205, r24
    1be6:	08 95       	ret
    1be8:	e0 91 4c 08 	lds	r30, 0x084C
    1bec:	f0 91 4d 08 	lds	r31, 0x084D
    1bf0:	05 80       	ldd	r0, Z+5	; 0x05
    1bf2:	f6 81       	ldd	r31, Z+6	; 0x06
    1bf4:	e0 2d       	mov	r30, r0
    1bf6:	06 80       	ldd	r0, Z+6	; 0x06
    1bf8:	f7 81       	ldd	r31, Z+7	; 0x07
    1bfa:	e0 2d       	mov	r30, r0
    1bfc:	82 81       	ldd	r24, Z+2	; 0x02
    1bfe:	93 81       	ldd	r25, Z+3	; 0x03
    1c00:	90 93 06 02 	sts	0x0206, r25
    1c04:	80 93 05 02 	sts	0x0205, r24
    1c08:	08 95       	ret

00001c0a <prvAddCurrentTaskToDelayedList>:
    1c0a:	cf 93       	push	r28
    1c0c:	df 93       	push	r29
    1c0e:	ec 01       	movw	r28, r24
    1c10:	e0 91 8d 08 	lds	r30, 0x088D
    1c14:	f0 91 8e 08 	lds	r31, 0x088E
    1c18:	93 83       	std	Z+3, r25	; 0x03
    1c1a:	82 83       	std	Z+2, r24	; 0x02
    1c1c:	80 91 2b 08 	lds	r24, 0x082B
    1c20:	90 91 2c 08 	lds	r25, 0x082C
    1c24:	c8 17       	cp	r28, r24
    1c26:	d9 07       	cpc	r29, r25
    1c28:	68 f4       	brcc	.+26     	; 0x1c44 <prvAddCurrentTaskToDelayedList+0x3a>
    1c2a:	60 91 8d 08 	lds	r22, 0x088D
    1c2e:	70 91 8e 08 	lds	r23, 0x088E
    1c32:	80 91 4a 08 	lds	r24, 0x084A
    1c36:	90 91 4b 08 	lds	r25, 0x084B
    1c3a:	6e 5f       	subi	r22, 0xFE	; 254
    1c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3e:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <vListInsert>
    1c42:	17 c0       	rjmp	.+46     	; 0x1c72 <prvAddCurrentTaskToDelayedList+0x68>
    1c44:	60 91 8d 08 	lds	r22, 0x088D
    1c48:	70 91 8e 08 	lds	r23, 0x088E
    1c4c:	80 91 4c 08 	lds	r24, 0x084C
    1c50:	90 91 4d 08 	lds	r25, 0x084D
    1c54:	6e 5f       	subi	r22, 0xFE	; 254
    1c56:	7f 4f       	sbci	r23, 0xFF	; 255
    1c58:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <vListInsert>
    1c5c:	80 91 05 02 	lds	r24, 0x0205
    1c60:	90 91 06 02 	lds	r25, 0x0206
    1c64:	c8 17       	cp	r28, r24
    1c66:	d9 07       	cpc	r29, r25
    1c68:	20 f4       	brcc	.+8      	; 0x1c72 <prvAddCurrentTaskToDelayedList+0x68>
    1c6a:	d0 93 06 02 	sts	0x0206, r29
    1c6e:	c0 93 05 02 	sts	0x0205, r28
    1c72:	df 91       	pop	r29
    1c74:	cf 91       	pop	r28
    1c76:	08 95       	ret

00001c78 <xTaskGenericCreate>:
    1c78:	4f 92       	push	r4
    1c7a:	5f 92       	push	r5
    1c7c:	6f 92       	push	r6
    1c7e:	7f 92       	push	r7
    1c80:	8f 92       	push	r8
    1c82:	9f 92       	push	r9
    1c84:	af 92       	push	r10
    1c86:	bf 92       	push	r11
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	4c 01       	movw	r8, r24
    1c9a:	5b 01       	movw	r10, r22
    1c9c:	2a 01       	movw	r4, r20
    1c9e:	39 01       	movw	r6, r18
    1ca0:	83 e2       	ldi	r24, 0x23	; 35
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	0e 94 01 03 	call	0x602	; 0x602 <pvPortMalloc>
    1ca8:	ec 01       	movw	r28, r24
    1caa:	00 97       	sbiw	r24, 0x00	; 0
    1cac:	09 f4       	brne	.+2      	; 0x1cb0 <xTaskGenericCreate+0x38>
    1cae:	e7 c0       	rjmp	.+462    	; 0x1e7e <xTaskGenericCreate+0x206>
    1cb0:	c1 14       	cp	r12, r1
    1cb2:	d1 04       	cpc	r13, r1
    1cb4:	09 f0       	breq	.+2      	; 0x1cb8 <xTaskGenericCreate+0x40>
    1cb6:	cc c0       	rjmp	.+408    	; 0x1e50 <xTaskGenericCreate+0x1d8>
    1cb8:	c2 01       	movw	r24, r4
    1cba:	0e 94 01 03 	call	0x602	; 0x602 <pvPortMalloc>
    1cbe:	98 8f       	std	Y+24, r25	; 0x18
    1cc0:	8f 8b       	std	Y+23, r24	; 0x17
    1cc2:	89 2b       	or	r24, r25
    1cc4:	09 f0       	breq	.+2      	; 0x1cc8 <xTaskGenericCreate+0x50>
    1cc6:	c6 c0       	rjmp	.+396    	; 0x1e54 <xTaskGenericCreate+0x1dc>
    1cc8:	ce 01       	movw	r24, r28
    1cca:	0e 94 36 03 	call	0x66c	; 0x66c <vPortFree>
    1cce:	d7 c0       	rjmp	.+430    	; 0x1e7e <xTaskGenericCreate+0x206>
    1cd0:	cf 01       	movw	r24, r30
    1cd2:	31 91       	ld	r19, Z+
    1cd4:	da 01       	movw	r26, r20
    1cd6:	3d 93       	st	X+, r19
    1cd8:	ad 01       	movw	r20, r26
    1cda:	dc 01       	movw	r26, r24
    1cdc:	8c 91       	ld	r24, X
    1cde:	88 23       	and	r24, r24
    1ce0:	11 f0       	breq	.+4      	; 0x1ce6 <xTaskGenericCreate+0x6e>
    1ce2:	21 50       	subi	r18, 0x01	; 1
    1ce4:	a9 f7       	brne	.-22     	; 0x1cd0 <xTaskGenericCreate+0x58>
    1ce6:	18 a2       	std	Y+32, r1	; 0x20
    1ce8:	10 2f       	mov	r17, r16
    1cea:	05 30       	cpi	r16, 0x05	; 5
    1cec:	08 f0       	brcs	.+2      	; 0x1cf0 <xTaskGenericCreate+0x78>
    1cee:	14 e0       	ldi	r17, 0x04	; 4
    1cf0:	1e 8b       	std	Y+22, r17	; 0x16
    1cf2:	19 a3       	std	Y+33, r17	; 0x21
    1cf4:	1a a2       	std	Y+34, r1	; 0x22
    1cf6:	5e 01       	movw	r10, r28
    1cf8:	b2 e0       	ldi	r27, 0x02	; 2
    1cfa:	ab 0e       	add	r10, r27
    1cfc:	b1 1c       	adc	r11, r1
    1cfe:	c5 01       	movw	r24, r10
    1d00:	0e 94 45 03 	call	0x68a	; 0x68a <vListInitialiseItem>
    1d04:	ce 01       	movw	r24, r28
    1d06:	0c 96       	adiw	r24, 0x0c	; 12
    1d08:	0e 94 45 03 	call	0x68a	; 0x68a <vListInitialiseItem>
    1d0c:	d9 87       	std	Y+9, r29	; 0x09
    1d0e:	c8 87       	std	Y+8, r28	; 0x08
    1d10:	85 e0       	ldi	r24, 0x05	; 5
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	81 1b       	sub	r24, r17
    1d16:	91 09       	sbc	r25, r1
    1d18:	9d 87       	std	Y+13, r25	; 0x0d
    1d1a:	8c 87       	std	Y+12, r24	; 0x0c
    1d1c:	db 8b       	std	Y+19, r29	; 0x13
    1d1e:	ca 8b       	std	Y+18, r28	; 0x12
    1d20:	a3 01       	movw	r20, r6
    1d22:	b4 01       	movw	r22, r8
    1d24:	c6 01       	movw	r24, r12
    1d26:	cb da       	rcall	.-2666   	; 0x12be <pxPortInitialiseStack>
    1d28:	99 83       	std	Y+1, r25	; 0x01
    1d2a:	88 83       	st	Y, r24
    1d2c:	e1 14       	cp	r14, r1
    1d2e:	f1 04       	cpc	r15, r1
    1d30:	19 f0       	breq	.+6      	; 0x1d38 <xTaskGenericCreate+0xc0>
    1d32:	f7 01       	movw	r30, r14
    1d34:	d1 83       	std	Z+1, r29	; 0x01
    1d36:	c0 83       	st	Z, r28
    1d38:	0f b6       	in	r0, 0x3f	; 63
    1d3a:	f8 94       	cli
    1d3c:	0f 92       	push	r0
    1d3e:	80 91 2d 08 	lds	r24, 0x082D
    1d42:	8f 5f       	subi	r24, 0xFF	; 255
    1d44:	80 93 2d 08 	sts	0x082D, r24
    1d48:	80 91 8d 08 	lds	r24, 0x088D
    1d4c:	90 91 8e 08 	lds	r25, 0x088E
    1d50:	89 2b       	or	r24, r25
    1d52:	09 f0       	breq	.+2      	; 0x1d56 <xTaskGenericCreate+0xde>
    1d54:	3f c0       	rjmp	.+126    	; 0x1dd4 <xTaskGenericCreate+0x15c>
    1d56:	d0 93 8e 08 	sts	0x088E, r29
    1d5a:	c0 93 8d 08 	sts	0x088D, r28
    1d5e:	80 91 2d 08 	lds	r24, 0x082D
    1d62:	81 30       	cpi	r24, 0x01	; 1
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <xTaskGenericCreate+0xf0>
    1d66:	45 c0       	rjmp	.+138    	; 0x1df2 <xTaskGenericCreate+0x17a>
    1d68:	0f 2e       	mov	r0, r31
    1d6a:	f0 e6       	ldi	r31, 0x60	; 96
    1d6c:	ef 2e       	mov	r14, r31
    1d6e:	f8 e0       	ldi	r31, 0x08	; 8
    1d70:	ff 2e       	mov	r15, r31
    1d72:	f0 2d       	mov	r31, r0
    1d74:	0f 2e       	mov	r0, r31
    1d76:	fd e8       	ldi	r31, 0x8D	; 141
    1d78:	cf 2e       	mov	r12, r31
    1d7a:	f8 e0       	ldi	r31, 0x08	; 8
    1d7c:	df 2e       	mov	r13, r31
    1d7e:	f0 2d       	mov	r31, r0
    1d80:	c7 01       	movw	r24, r14
    1d82:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1d86:	f9 e0       	ldi	r31, 0x09	; 9
    1d88:	ef 0e       	add	r14, r31
    1d8a:	f1 1c       	adc	r15, r1
    1d8c:	ec 14       	cp	r14, r12
    1d8e:	fd 04       	cpc	r15, r13
    1d90:	b9 f7       	brne	.-18     	; 0x1d80 <xTaskGenericCreate+0x108>
    1d92:	87 e5       	ldi	r24, 0x57	; 87
    1d94:	98 e0       	ldi	r25, 0x08	; 8
    1d96:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1d9a:	8e e4       	ldi	r24, 0x4E	; 78
    1d9c:	98 e0       	ldi	r25, 0x08	; 8
    1d9e:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1da2:	81 e4       	ldi	r24, 0x41	; 65
    1da4:	98 e0       	ldi	r25, 0x08	; 8
    1da6:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1daa:	88 e3       	ldi	r24, 0x38	; 56
    1dac:	98 e0       	ldi	r25, 0x08	; 8
    1dae:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1db2:	8e e2       	ldi	r24, 0x2E	; 46
    1db4:	98 e0       	ldi	r25, 0x08	; 8
    1db6:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1dba:	87 e5       	ldi	r24, 0x57	; 87
    1dbc:	98 e0       	ldi	r25, 0x08	; 8
    1dbe:	90 93 4d 08 	sts	0x084D, r25
    1dc2:	80 93 4c 08 	sts	0x084C, r24
    1dc6:	8e e4       	ldi	r24, 0x4E	; 78
    1dc8:	98 e0       	ldi	r25, 0x08	; 8
    1dca:	90 93 4b 08 	sts	0x084B, r25
    1dce:	80 93 4a 08 	sts	0x084A, r24
    1dd2:	0f c0       	rjmp	.+30     	; 0x1df2 <xTaskGenericCreate+0x17a>
    1dd4:	80 91 29 08 	lds	r24, 0x0829
    1dd8:	81 11       	cpse	r24, r1
    1dda:	0b c0       	rjmp	.+22     	; 0x1df2 <xTaskGenericCreate+0x17a>
    1ddc:	e0 91 8d 08 	lds	r30, 0x088D
    1de0:	f0 91 8e 08 	lds	r31, 0x088E
    1de4:	86 89       	ldd	r24, Z+22	; 0x16
    1de6:	08 17       	cp	r16, r24
    1de8:	20 f0       	brcs	.+8      	; 0x1df2 <xTaskGenericCreate+0x17a>
    1dea:	d0 93 8e 08 	sts	0x088E, r29
    1dee:	c0 93 8d 08 	sts	0x088D, r28
    1df2:	80 91 25 08 	lds	r24, 0x0825
    1df6:	8f 5f       	subi	r24, 0xFF	; 255
    1df8:	80 93 25 08 	sts	0x0825, r24
    1dfc:	8e 89       	ldd	r24, Y+22	; 0x16
    1dfe:	90 91 2a 08 	lds	r25, 0x082A
    1e02:	98 17       	cp	r25, r24
    1e04:	10 f4       	brcc	.+4      	; 0x1e0a <xTaskGenericCreate+0x192>
    1e06:	80 93 2a 08 	sts	0x082A, r24
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	9c 01       	movw	r18, r24
    1e0e:	22 0f       	add	r18, r18
    1e10:	33 1f       	adc	r19, r19
    1e12:	22 0f       	add	r18, r18
    1e14:	33 1f       	adc	r19, r19
    1e16:	22 0f       	add	r18, r18
    1e18:	33 1f       	adc	r19, r19
    1e1a:	82 0f       	add	r24, r18
    1e1c:	93 1f       	adc	r25, r19
    1e1e:	b5 01       	movw	r22, r10
    1e20:	80 5a       	subi	r24, 0xA0	; 160
    1e22:	97 4f       	sbci	r25, 0xF7	; 247
    1e24:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    1e28:	0f 90       	pop	r0
    1e2a:	0f be       	out	0x3f, r0	; 63
    1e2c:	80 91 29 08 	lds	r24, 0x0829
    1e30:	88 23       	and	r24, r24
    1e32:	51 f0       	breq	.+20     	; 0x1e48 <xTaskGenericCreate+0x1d0>
    1e34:	e0 91 8d 08 	lds	r30, 0x088D
    1e38:	f0 91 8e 08 	lds	r31, 0x088E
    1e3c:	86 89       	ldd	r24, Z+22	; 0x16
    1e3e:	80 17       	cp	r24, r16
    1e40:	28 f4       	brcc	.+10     	; 0x1e4c <xTaskGenericCreate+0x1d4>
    1e42:	ec da       	rcall	.-2600   	; 0x141c <vPortYield>
    1e44:	81 e0       	ldi	r24, 0x01	; 1
    1e46:	1c c0       	rjmp	.+56     	; 0x1e80 <xTaskGenericCreate+0x208>
    1e48:	81 e0       	ldi	r24, 0x01	; 1
    1e4a:	1a c0       	rjmp	.+52     	; 0x1e80 <xTaskGenericCreate+0x208>
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	18 c0       	rjmp	.+48     	; 0x1e80 <xTaskGenericCreate+0x208>
    1e50:	d8 8e       	std	Y+24, r13	; 0x18
    1e52:	cf 8a       	std	Y+23, r12	; 0x17
    1e54:	81 e0       	ldi	r24, 0x01	; 1
    1e56:	48 1a       	sub	r4, r24
    1e58:	51 08       	sbc	r5, r1
    1e5a:	cf 88       	ldd	r12, Y+23	; 0x17
    1e5c:	d8 8c       	ldd	r13, Y+24	; 0x18
    1e5e:	c4 0c       	add	r12, r4
    1e60:	d5 1c       	adc	r13, r5
    1e62:	d5 01       	movw	r26, r10
    1e64:	8c 91       	ld	r24, X
    1e66:	89 8f       	std	Y+25, r24	; 0x19
    1e68:	8c 91       	ld	r24, X
    1e6a:	88 23       	and	r24, r24
    1e6c:	09 f4       	brne	.+2      	; 0x1e70 <xTaskGenericCreate+0x1f8>
    1e6e:	3b cf       	rjmp	.-394    	; 0x1ce6 <xTaskGenericCreate+0x6e>
    1e70:	ae 01       	movw	r20, r28
    1e72:	46 5e       	subi	r20, 0xE6	; 230
    1e74:	5f 4f       	sbci	r21, 0xFF	; 255
    1e76:	f5 01       	movw	r30, r10
    1e78:	31 96       	adiw	r30, 0x01	; 1
    1e7a:	27 e0       	ldi	r18, 0x07	; 7
    1e7c:	29 cf       	rjmp	.-430    	; 0x1cd0 <xTaskGenericCreate+0x58>
    1e7e:	8f ef       	ldi	r24, 0xFF	; 255
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	df 90       	pop	r13
    1e8e:	cf 90       	pop	r12
    1e90:	bf 90       	pop	r11
    1e92:	af 90       	pop	r10
    1e94:	9f 90       	pop	r9
    1e96:	8f 90       	pop	r8
    1e98:	7f 90       	pop	r7
    1e9a:	6f 90       	pop	r6
    1e9c:	5f 90       	pop	r5
    1e9e:	4f 90       	pop	r4
    1ea0:	08 95       	ret

00001ea2 <vTaskStartScheduler>:
    1ea2:	af 92       	push	r10
    1ea4:	bf 92       	push	r11
    1ea6:	cf 92       	push	r12
    1ea8:	df 92       	push	r13
    1eaa:	ef 92       	push	r14
    1eac:	ff 92       	push	r15
    1eae:	0f 93       	push	r16
    1eb0:	a1 2c       	mov	r10, r1
    1eb2:	b1 2c       	mov	r11, r1
    1eb4:	c1 2c       	mov	r12, r1
    1eb6:	d1 2c       	mov	r13, r1
    1eb8:	e1 2c       	mov	r14, r1
    1eba:	f1 2c       	mov	r15, r1
    1ebc:	00 e0       	ldi	r16, 0x00	; 0
    1ebe:	20 e0       	ldi	r18, 0x00	; 0
    1ec0:	30 e0       	ldi	r19, 0x00	; 0
    1ec2:	45 e5       	ldi	r20, 0x55	; 85
    1ec4:	50 e0       	ldi	r21, 0x00	; 0
    1ec6:	61 e3       	ldi	r22, 0x31	; 49
    1ec8:	72 e0       	ldi	r23, 0x02	; 2
    1eca:	88 e2       	ldi	r24, 0x28	; 40
    1ecc:	91 e1       	ldi	r25, 0x11	; 17
    1ece:	d4 de       	rcall	.-600    	; 0x1c78 <xTaskGenericCreate>
    1ed0:	81 30       	cpi	r24, 0x01	; 1
    1ed2:	41 f4       	brne	.+16     	; 0x1ee4 <vTaskStartScheduler+0x42>
    1ed4:	f8 94       	cli
    1ed6:	80 93 29 08 	sts	0x0829, r24
    1eda:	10 92 2c 08 	sts	0x082C, r1
    1ede:	10 92 2b 08 	sts	0x082B, r1
    1ee2:	5f da       	rcall	.-2882   	; 0x13a2 <xPortStartScheduler>
    1ee4:	0f 91       	pop	r16
    1ee6:	ff 90       	pop	r15
    1ee8:	ef 90       	pop	r14
    1eea:	df 90       	pop	r13
    1eec:	cf 90       	pop	r12
    1eee:	bf 90       	pop	r11
    1ef0:	af 90       	pop	r10
    1ef2:	08 95       	ret

00001ef4 <vTaskSuspendAll>:
    1ef4:	80 91 24 08 	lds	r24, 0x0824
    1ef8:	8f 5f       	subi	r24, 0xFF	; 255
    1efa:	80 93 24 08 	sts	0x0824, r24
    1efe:	08 95       	ret

00001f00 <xTaskGetTickCount>:
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	0f 92       	push	r0
    1f06:	80 91 2b 08 	lds	r24, 0x082B
    1f0a:	90 91 2c 08 	lds	r25, 0x082C
    1f0e:	0f 90       	pop	r0
    1f10:	0f be       	out	0x3f, r0	; 63
    1f12:	08 95       	ret

00001f14 <xTaskGetTickCountFromISR>:
    1f14:	80 91 2b 08 	lds	r24, 0x082B
    1f18:	90 91 2c 08 	lds	r25, 0x082C
    1f1c:	08 95       	ret

00001f1e <xTaskIncrementTick>:
    1f1e:	cf 92       	push	r12
    1f20:	df 92       	push	r13
    1f22:	ef 92       	push	r14
    1f24:	ff 92       	push	r15
    1f26:	0f 93       	push	r16
    1f28:	1f 93       	push	r17
    1f2a:	cf 93       	push	r28
    1f2c:	df 93       	push	r29
    1f2e:	80 91 24 08 	lds	r24, 0x0824
    1f32:	81 11       	cpse	r24, r1
    1f34:	99 c0       	rjmp	.+306    	; 0x2068 <xTaskIncrementTick+0x14a>
    1f36:	80 91 2b 08 	lds	r24, 0x082B
    1f3a:	90 91 2c 08 	lds	r25, 0x082C
    1f3e:	01 96       	adiw	r24, 0x01	; 1
    1f40:	90 93 2c 08 	sts	0x082C, r25
    1f44:	80 93 2b 08 	sts	0x082B, r24
    1f48:	e0 90 2b 08 	lds	r14, 0x082B
    1f4c:	f0 90 2c 08 	lds	r15, 0x082C
    1f50:	e1 14       	cp	r14, r1
    1f52:	f1 04       	cpc	r15, r1
    1f54:	b1 f4       	brne	.+44     	; 0x1f82 <xTaskIncrementTick+0x64>
    1f56:	80 91 4c 08 	lds	r24, 0x084C
    1f5a:	90 91 4d 08 	lds	r25, 0x084D
    1f5e:	20 91 4a 08 	lds	r18, 0x084A
    1f62:	30 91 4b 08 	lds	r19, 0x084B
    1f66:	30 93 4d 08 	sts	0x084D, r19
    1f6a:	20 93 4c 08 	sts	0x084C, r18
    1f6e:	90 93 4b 08 	sts	0x084B, r25
    1f72:	80 93 4a 08 	sts	0x084A, r24
    1f76:	80 91 26 08 	lds	r24, 0x0826
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	80 93 26 08 	sts	0x0826, r24
    1f80:	25 de       	rcall	.-950    	; 0x1bcc <prvResetNextTaskUnblockTime>
    1f82:	80 91 05 02 	lds	r24, 0x0205
    1f86:	90 91 06 02 	lds	r25, 0x0206
    1f8a:	e8 16       	cp	r14, r24
    1f8c:	f9 06       	cpc	r15, r25
    1f8e:	08 f4       	brcc	.+2      	; 0x1f92 <xTaskIncrementTick+0x74>
    1f90:	54 c0       	rjmp	.+168    	; 0x203a <xTaskIncrementTick+0x11c>
    1f92:	d1 2c       	mov	r13, r1
    1f94:	cc 24       	eor	r12, r12
    1f96:	c3 94       	inc	r12
    1f98:	01 c0       	rjmp	.+2      	; 0x1f9c <xTaskIncrementTick+0x7e>
    1f9a:	dc 2c       	mov	r13, r12
    1f9c:	e0 91 4c 08 	lds	r30, 0x084C
    1fa0:	f0 91 4d 08 	lds	r31, 0x084D
    1fa4:	80 81       	ld	r24, Z
    1fa6:	81 11       	cpse	r24, r1
    1fa8:	07 c0       	rjmp	.+14     	; 0x1fb8 <xTaskIncrementTick+0x9a>
    1faa:	8f ef       	ldi	r24, 0xFF	; 255
    1fac:	9f ef       	ldi	r25, 0xFF	; 255
    1fae:	90 93 06 02 	sts	0x0206, r25
    1fb2:	80 93 05 02 	sts	0x0205, r24
    1fb6:	42 c0       	rjmp	.+132    	; 0x203c <xTaskIncrementTick+0x11e>
    1fb8:	e0 91 4c 08 	lds	r30, 0x084C
    1fbc:	f0 91 4d 08 	lds	r31, 0x084D
    1fc0:	05 80       	ldd	r0, Z+5	; 0x05
    1fc2:	f6 81       	ldd	r31, Z+6	; 0x06
    1fc4:	e0 2d       	mov	r30, r0
    1fc6:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc8:	d7 81       	ldd	r29, Z+7	; 0x07
    1fca:	2a 81       	ldd	r18, Y+2	; 0x02
    1fcc:	3b 81       	ldd	r19, Y+3	; 0x03
    1fce:	e2 16       	cp	r14, r18
    1fd0:	f3 06       	cpc	r15, r19
    1fd2:	28 f4       	brcc	.+10     	; 0x1fde <xTaskIncrementTick+0xc0>
    1fd4:	30 93 06 02 	sts	0x0206, r19
    1fd8:	20 93 05 02 	sts	0x0205, r18
    1fdc:	2f c0       	rjmp	.+94     	; 0x203c <xTaskIncrementTick+0x11e>
    1fde:	8e 01       	movw	r16, r28
    1fe0:	0e 5f       	subi	r16, 0xFE	; 254
    1fe2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fe4:	c8 01       	movw	r24, r16
    1fe6:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    1fea:	8c 89       	ldd	r24, Y+20	; 0x14
    1fec:	9d 89       	ldd	r25, Y+21	; 0x15
    1fee:	89 2b       	or	r24, r25
    1ff0:	21 f0       	breq	.+8      	; 0x1ffa <xTaskIncrementTick+0xdc>
    1ff2:	ce 01       	movw	r24, r28
    1ff4:	0c 96       	adiw	r24, 0x0c	; 12
    1ff6:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    1ffa:	2e 89       	ldd	r18, Y+22	; 0x16
    1ffc:	80 91 2a 08 	lds	r24, 0x082A
    2000:	82 17       	cp	r24, r18
    2002:	10 f4       	brcc	.+4      	; 0x2008 <xTaskIncrementTick+0xea>
    2004:	20 93 2a 08 	sts	0x082A, r18
    2008:	30 e0       	ldi	r19, 0x00	; 0
    200a:	c9 01       	movw	r24, r18
    200c:	88 0f       	add	r24, r24
    200e:	99 1f       	adc	r25, r25
    2010:	88 0f       	add	r24, r24
    2012:	99 1f       	adc	r25, r25
    2014:	88 0f       	add	r24, r24
    2016:	99 1f       	adc	r25, r25
    2018:	82 0f       	add	r24, r18
    201a:	93 1f       	adc	r25, r19
    201c:	b8 01       	movw	r22, r16
    201e:	80 5a       	subi	r24, 0xA0	; 160
    2020:	97 4f       	sbci	r25, 0xF7	; 247
    2022:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    2026:	e0 91 8d 08 	lds	r30, 0x088D
    202a:	f0 91 8e 08 	lds	r31, 0x088E
    202e:	9e 89       	ldd	r25, Y+22	; 0x16
    2030:	86 89       	ldd	r24, Z+22	; 0x16
    2032:	98 17       	cp	r25, r24
    2034:	08 f0       	brcs	.+2      	; 0x2038 <xTaskIncrementTick+0x11a>
    2036:	b1 cf       	rjmp	.-158    	; 0x1f9a <xTaskIncrementTick+0x7c>
    2038:	b1 cf       	rjmp	.-158    	; 0x1f9c <xTaskIncrementTick+0x7e>
    203a:	d1 2c       	mov	r13, r1
    203c:	e0 91 8d 08 	lds	r30, 0x088D
    2040:	f0 91 8e 08 	lds	r31, 0x088E
    2044:	86 89       	ldd	r24, Z+22	; 0x16
    2046:	90 e0       	ldi	r25, 0x00	; 0
    2048:	fc 01       	movw	r30, r24
    204a:	ee 0f       	add	r30, r30
    204c:	ff 1f       	adc	r31, r31
    204e:	ee 0f       	add	r30, r30
    2050:	ff 1f       	adc	r31, r31
    2052:	ee 0f       	add	r30, r30
    2054:	ff 1f       	adc	r31, r31
    2056:	8e 0f       	add	r24, r30
    2058:	9f 1f       	adc	r25, r31
    205a:	fc 01       	movw	r30, r24
    205c:	e0 5a       	subi	r30, 0xA0	; 160
    205e:	f7 4f       	sbci	r31, 0xF7	; 247
    2060:	80 81       	ld	r24, Z
    2062:	82 30       	cpi	r24, 0x02	; 2
    2064:	40 f4       	brcc	.+16     	; 0x2076 <xTaskIncrementTick+0x158>
    2066:	09 c0       	rjmp	.+18     	; 0x207a <xTaskIncrementTick+0x15c>
    2068:	80 91 28 08 	lds	r24, 0x0828
    206c:	8f 5f       	subi	r24, 0xFF	; 255
    206e:	80 93 28 08 	sts	0x0828, r24
    2072:	d1 2c       	mov	r13, r1
    2074:	02 c0       	rjmp	.+4      	; 0x207a <xTaskIncrementTick+0x15c>
    2076:	dd 24       	eor	r13, r13
    2078:	d3 94       	inc	r13
    207a:	80 91 27 08 	lds	r24, 0x0827
    207e:	88 23       	and	r24, r24
    2080:	11 f0       	breq	.+4      	; 0x2086 <xTaskIncrementTick+0x168>
    2082:	dd 24       	eor	r13, r13
    2084:	d3 94       	inc	r13
    2086:	8d 2d       	mov	r24, r13
    2088:	df 91       	pop	r29
    208a:	cf 91       	pop	r28
    208c:	1f 91       	pop	r17
    208e:	0f 91       	pop	r16
    2090:	ff 90       	pop	r15
    2092:	ef 90       	pop	r14
    2094:	df 90       	pop	r13
    2096:	cf 90       	pop	r12
    2098:	08 95       	ret

0000209a <xTaskResumeAll>:
    209a:	df 92       	push	r13
    209c:	ef 92       	push	r14
    209e:	ff 92       	push	r15
    20a0:	0f 93       	push	r16
    20a2:	1f 93       	push	r17
    20a4:	cf 93       	push	r28
    20a6:	df 93       	push	r29
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	f8 94       	cli
    20ac:	0f 92       	push	r0
    20ae:	80 91 24 08 	lds	r24, 0x0824
    20b2:	81 50       	subi	r24, 0x01	; 1
    20b4:	80 93 24 08 	sts	0x0824, r24
    20b8:	80 91 24 08 	lds	r24, 0x0824
    20bc:	81 11       	cpse	r24, r1
    20be:	5f c0       	rjmp	.+190    	; 0x217e <xTaskResumeAll+0xe4>
    20c0:	80 91 2d 08 	lds	r24, 0x082D
    20c4:	88 23       	and	r24, r24
    20c6:	09 f4       	brne	.+2      	; 0x20ca <xTaskResumeAll+0x30>
    20c8:	5c c0       	rjmp	.+184    	; 0x2182 <xTaskResumeAll+0xe8>
    20ca:	0f 2e       	mov	r0, r31
    20cc:	f1 e4       	ldi	r31, 0x41	; 65
    20ce:	ef 2e       	mov	r14, r31
    20d0:	f8 e0       	ldi	r31, 0x08	; 8
    20d2:	ff 2e       	mov	r15, r31
    20d4:	f0 2d       	mov	r31, r0
    20d6:	dd 24       	eor	r13, r13
    20d8:	d3 94       	inc	r13
    20da:	30 c0       	rjmp	.+96     	; 0x213c <xTaskResumeAll+0xa2>
    20dc:	e0 91 46 08 	lds	r30, 0x0846
    20e0:	f0 91 47 08 	lds	r31, 0x0847
    20e4:	c6 81       	ldd	r28, Z+6	; 0x06
    20e6:	d7 81       	ldd	r29, Z+7	; 0x07
    20e8:	ce 01       	movw	r24, r28
    20ea:	0c 96       	adiw	r24, 0x0c	; 12
    20ec:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    20f0:	8e 01       	movw	r16, r28
    20f2:	0e 5f       	subi	r16, 0xFE	; 254
    20f4:	1f 4f       	sbci	r17, 0xFF	; 255
    20f6:	c8 01       	movw	r24, r16
    20f8:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    20fc:	8e 89       	ldd	r24, Y+22	; 0x16
    20fe:	90 91 2a 08 	lds	r25, 0x082A
    2102:	98 17       	cp	r25, r24
    2104:	10 f4       	brcc	.+4      	; 0x210a <xTaskResumeAll+0x70>
    2106:	80 93 2a 08 	sts	0x082A, r24
    210a:	90 e0       	ldi	r25, 0x00	; 0
    210c:	9c 01       	movw	r18, r24
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	22 0f       	add	r18, r18
    2114:	33 1f       	adc	r19, r19
    2116:	22 0f       	add	r18, r18
    2118:	33 1f       	adc	r19, r19
    211a:	82 0f       	add	r24, r18
    211c:	93 1f       	adc	r25, r19
    211e:	b8 01       	movw	r22, r16
    2120:	80 5a       	subi	r24, 0xA0	; 160
    2122:	97 4f       	sbci	r25, 0xF7	; 247
    2124:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    2128:	e0 91 8d 08 	lds	r30, 0x088D
    212c:	f0 91 8e 08 	lds	r31, 0x088E
    2130:	9e 89       	ldd	r25, Y+22	; 0x16
    2132:	86 89       	ldd	r24, Z+22	; 0x16
    2134:	98 17       	cp	r25, r24
    2136:	10 f0       	brcs	.+4      	; 0x213c <xTaskResumeAll+0xa2>
    2138:	d0 92 27 08 	sts	0x0827, r13
    213c:	f7 01       	movw	r30, r14
    213e:	80 81       	ld	r24, Z
    2140:	81 11       	cpse	r24, r1
    2142:	cc cf       	rjmp	.-104    	; 0x20dc <xTaskResumeAll+0x42>
    2144:	80 91 28 08 	lds	r24, 0x0828
    2148:	88 23       	and	r24, r24
    214a:	91 f0       	breq	.+36     	; 0x2170 <xTaskResumeAll+0xd6>
    214c:	80 91 28 08 	lds	r24, 0x0828
    2150:	88 23       	and	r24, r24
    2152:	71 f0       	breq	.+28     	; 0x2170 <xTaskResumeAll+0xd6>
    2154:	c1 e0       	ldi	r28, 0x01	; 1
    2156:	e3 de       	rcall	.-570    	; 0x1f1e <xTaskIncrementTick>
    2158:	81 11       	cpse	r24, r1
    215a:	c0 93 27 08 	sts	0x0827, r28
    215e:	80 91 28 08 	lds	r24, 0x0828
    2162:	81 50       	subi	r24, 0x01	; 1
    2164:	80 93 28 08 	sts	0x0828, r24
    2168:	80 91 28 08 	lds	r24, 0x0828
    216c:	81 11       	cpse	r24, r1
    216e:	f3 cf       	rjmp	.-26     	; 0x2156 <xTaskResumeAll+0xbc>
    2170:	80 91 27 08 	lds	r24, 0x0827
    2174:	81 30       	cpi	r24, 0x01	; 1
    2176:	39 f4       	brne	.+14     	; 0x2186 <xTaskResumeAll+0xec>
    2178:	51 d9       	rcall	.-3422   	; 0x141c <vPortYield>
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	05 c0       	rjmp	.+10     	; 0x2188 <xTaskResumeAll+0xee>
    217e:	80 e0       	ldi	r24, 0x00	; 0
    2180:	03 c0       	rjmp	.+6      	; 0x2188 <xTaskResumeAll+0xee>
    2182:	80 e0       	ldi	r24, 0x00	; 0
    2184:	01 c0       	rjmp	.+2      	; 0x2188 <xTaskResumeAll+0xee>
    2186:	80 e0       	ldi	r24, 0x00	; 0
    2188:	0f 90       	pop	r0
    218a:	0f be       	out	0x3f, r0	; 63
    218c:	df 91       	pop	r29
    218e:	cf 91       	pop	r28
    2190:	1f 91       	pop	r17
    2192:	0f 91       	pop	r16
    2194:	ff 90       	pop	r15
    2196:	ef 90       	pop	r14
    2198:	df 90       	pop	r13
    219a:	08 95       	ret

0000219c <vTaskDelayUntil>:
    219c:	0f 93       	push	r16
    219e:	1f 93       	push	r17
    21a0:	cf 93       	push	r28
    21a2:	df 93       	push	r29
    21a4:	8c 01       	movw	r16, r24
    21a6:	eb 01       	movw	r28, r22
    21a8:	a5 de       	rcall	.-694    	; 0x1ef4 <vTaskSuspendAll>
    21aa:	80 91 2b 08 	lds	r24, 0x082B
    21ae:	90 91 2c 08 	lds	r25, 0x082C
    21b2:	f8 01       	movw	r30, r16
    21b4:	20 81       	ld	r18, Z
    21b6:	31 81       	ldd	r19, Z+1	; 0x01
    21b8:	c2 0f       	add	r28, r18
    21ba:	d3 1f       	adc	r29, r19
    21bc:	82 17       	cp	r24, r18
    21be:	93 07       	cpc	r25, r19
    21c0:	48 f4       	brcc	.+18     	; 0x21d4 <vTaskDelayUntil+0x38>
    21c2:	c2 17       	cp	r28, r18
    21c4:	d3 07       	cpc	r29, r19
    21c6:	f8 f4       	brcc	.+62     	; 0x2206 <__stack+0x7>
    21c8:	d1 83       	std	Z+1, r29	; 0x01
    21ca:	c0 83       	st	Z, r28
    21cc:	8c 17       	cp	r24, r28
    21ce:	9d 07       	cpc	r25, r29
    21d0:	88 f4       	brcc	.+34     	; 0x21f4 <vTaskDelayUntil+0x58>
    21d2:	07 c0       	rjmp	.+14     	; 0x21e2 <vTaskDelayUntil+0x46>
    21d4:	c2 17       	cp	r28, r18
    21d6:	d3 07       	cpc	r29, r19
    21d8:	90 f0       	brcs	.+36     	; 0x21fe <vTaskDelayUntil+0x62>
    21da:	8c 17       	cp	r24, r28
    21dc:	9d 07       	cpc	r25, r29
    21de:	78 f0       	brcs	.+30     	; 0x21fe <vTaskDelayUntil+0x62>
    21e0:	12 c0       	rjmp	.+36     	; 0x2206 <__stack+0x7>
    21e2:	80 91 8d 08 	lds	r24, 0x088D
    21e6:	90 91 8e 08 	lds	r25, 0x088E
    21ea:	02 96       	adiw	r24, 0x02	; 2
    21ec:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    21f0:	ce 01       	movw	r24, r28
    21f2:	0b dd       	rcall	.-1514   	; 0x1c0a <prvAddCurrentTaskToDelayedList>
    21f4:	52 df       	rcall	.-348    	; 0x209a <xTaskResumeAll>
    21f6:	81 11       	cpse	r24, r1
    21f8:	0a c0       	rjmp	.+20     	; 0x220e <__stack+0xf>
    21fa:	10 d9       	rcall	.-3552   	; 0x141c <vPortYield>
    21fc:	08 c0       	rjmp	.+16     	; 0x220e <__stack+0xf>
    21fe:	f8 01       	movw	r30, r16
    2200:	d1 83       	std	Z+1, r29	; 0x01
    2202:	c0 83       	st	Z, r28
    2204:	ee cf       	rjmp	.-36     	; 0x21e2 <vTaskDelayUntil+0x46>
    2206:	f8 01       	movw	r30, r16
    2208:	d1 83       	std	Z+1, r29	; 0x01
    220a:	c0 83       	st	Z, r28
    220c:	f3 cf       	rjmp	.-26     	; 0x21f4 <vTaskDelayUntil+0x58>
    220e:	df 91       	pop	r29
    2210:	cf 91       	pop	r28
    2212:	1f 91       	pop	r17
    2214:	0f 91       	pop	r16
    2216:	08 95       	ret

00002218 <vTaskDelay>:
    2218:	cf 93       	push	r28
    221a:	df 93       	push	r29
    221c:	ec 01       	movw	r28, r24
    221e:	00 97       	sbiw	r24, 0x00	; 0
    2220:	99 f0       	breq	.+38     	; 0x2248 <vTaskDelay+0x30>
    2222:	68 de       	rcall	.-816    	; 0x1ef4 <vTaskSuspendAll>
    2224:	80 91 2b 08 	lds	r24, 0x082B
    2228:	90 91 2c 08 	lds	r25, 0x082C
    222c:	c8 0f       	add	r28, r24
    222e:	d9 1f       	adc	r29, r25
    2230:	80 91 8d 08 	lds	r24, 0x088D
    2234:	90 91 8e 08 	lds	r25, 0x088E
    2238:	02 96       	adiw	r24, 0x02	; 2
    223a:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    223e:	ce 01       	movw	r24, r28
    2240:	e4 dc       	rcall	.-1592   	; 0x1c0a <prvAddCurrentTaskToDelayedList>
    2242:	2b df       	rcall	.-426    	; 0x209a <xTaskResumeAll>
    2244:	81 11       	cpse	r24, r1
    2246:	01 c0       	rjmp	.+2      	; 0x224a <vTaskDelay+0x32>
    2248:	e9 d8       	rcall	.-3630   	; 0x141c <vPortYield>
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	08 95       	ret

00002250 <prvIdleTask>:
    2250:	0f 2e       	mov	r0, r31
    2252:	f0 e6       	ldi	r31, 0x60	; 96
    2254:	ef 2e       	mov	r14, r31
    2256:	f8 e0       	ldi	r31, 0x08	; 8
    2258:	ff 2e       	mov	r15, r31
    225a:	f0 2d       	mov	r31, r0
    225c:	c8 e3       	ldi	r28, 0x38	; 56
    225e:	d8 e0       	ldi	r29, 0x08	; 8
    2260:	26 c0       	rjmp	.+76     	; 0x22ae <prvIdleTask+0x5e>
    2262:	48 de       	rcall	.-880    	; 0x1ef4 <vTaskSuspendAll>
    2264:	18 81       	ld	r17, Y
    2266:	19 df       	rcall	.-462    	; 0x209a <xTaskResumeAll>
    2268:	11 23       	and	r17, r17
    226a:	09 f1       	breq	.+66     	; 0x22ae <prvIdleTask+0x5e>
    226c:	0f b6       	in	r0, 0x3f	; 63
    226e:	f8 94       	cli
    2270:	0f 92       	push	r0
    2272:	e0 91 3d 08 	lds	r30, 0x083D
    2276:	f0 91 3e 08 	lds	r31, 0x083E
    227a:	06 81       	ldd	r16, Z+6	; 0x06
    227c:	17 81       	ldd	r17, Z+7	; 0x07
    227e:	c8 01       	movw	r24, r16
    2280:	02 96       	adiw	r24, 0x02	; 2
    2282:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    2286:	80 91 2d 08 	lds	r24, 0x082D
    228a:	81 50       	subi	r24, 0x01	; 1
    228c:	80 93 2d 08 	sts	0x082D, r24
    2290:	80 91 37 08 	lds	r24, 0x0837
    2294:	81 50       	subi	r24, 0x01	; 1
    2296:	80 93 37 08 	sts	0x0837, r24
    229a:	0f 90       	pop	r0
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	f8 01       	movw	r30, r16
    22a0:	87 89       	ldd	r24, Z+23	; 0x17
    22a2:	90 8d       	ldd	r25, Z+24	; 0x18
    22a4:	0e 94 36 03 	call	0x66c	; 0x66c <vPortFree>
    22a8:	c8 01       	movw	r24, r16
    22aa:	0e 94 36 03 	call	0x66c	; 0x66c <vPortFree>
    22ae:	80 91 37 08 	lds	r24, 0x0837
    22b2:	81 11       	cpse	r24, r1
    22b4:	d6 cf       	rjmp	.-84     	; 0x2262 <prvIdleTask+0x12>
    22b6:	f7 01       	movw	r30, r14
    22b8:	80 81       	ld	r24, Z
    22ba:	82 30       	cpi	r24, 0x02	; 2
    22bc:	c0 f3       	brcs	.-16     	; 0x22ae <prvIdleTask+0x5e>
    22be:	ae d8       	rcall	.-3748   	; 0x141c <vPortYield>
    22c0:	f6 cf       	rjmp	.-20     	; 0x22ae <prvIdleTask+0x5e>

000022c2 <vTaskSwitchContext>:
    22c2:	80 91 24 08 	lds	r24, 0x0824
    22c6:	88 23       	and	r24, r24
    22c8:	21 f0       	breq	.+8      	; 0x22d2 <vTaskSwitchContext+0x10>
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	80 93 27 08 	sts	0x0827, r24
    22d0:	08 95       	ret
    22d2:	10 92 27 08 	sts	0x0827, r1
    22d6:	80 91 2a 08 	lds	r24, 0x082A
    22da:	90 e0       	ldi	r25, 0x00	; 0
    22dc:	fc 01       	movw	r30, r24
    22de:	ee 0f       	add	r30, r30
    22e0:	ff 1f       	adc	r31, r31
    22e2:	ee 0f       	add	r30, r30
    22e4:	ff 1f       	adc	r31, r31
    22e6:	ee 0f       	add	r30, r30
    22e8:	ff 1f       	adc	r31, r31
    22ea:	8e 0f       	add	r24, r30
    22ec:	9f 1f       	adc	r25, r31
    22ee:	fc 01       	movw	r30, r24
    22f0:	e0 5a       	subi	r30, 0xA0	; 160
    22f2:	f7 4f       	sbci	r31, 0xF7	; 247
    22f4:	80 81       	ld	r24, Z
    22f6:	81 11       	cpse	r24, r1
    22f8:	17 c0       	rjmp	.+46     	; 0x2328 <vTaskSwitchContext+0x66>
    22fa:	80 91 2a 08 	lds	r24, 0x082A
    22fe:	81 50       	subi	r24, 0x01	; 1
    2300:	80 93 2a 08 	sts	0x082A, r24
    2304:	80 91 2a 08 	lds	r24, 0x082A
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	fc 01       	movw	r30, r24
    230c:	ee 0f       	add	r30, r30
    230e:	ff 1f       	adc	r31, r31
    2310:	ee 0f       	add	r30, r30
    2312:	ff 1f       	adc	r31, r31
    2314:	ee 0f       	add	r30, r30
    2316:	ff 1f       	adc	r31, r31
    2318:	8e 0f       	add	r24, r30
    231a:	9f 1f       	adc	r25, r31
    231c:	fc 01       	movw	r30, r24
    231e:	e0 5a       	subi	r30, 0xA0	; 160
    2320:	f7 4f       	sbci	r31, 0xF7	; 247
    2322:	80 81       	ld	r24, Z
    2324:	88 23       	and	r24, r24
    2326:	49 f3       	breq	.-46     	; 0x22fa <vTaskSwitchContext+0x38>
    2328:	e0 91 2a 08 	lds	r30, 0x082A
    232c:	f0 e0       	ldi	r31, 0x00	; 0
    232e:	cf 01       	movw	r24, r30
    2330:	88 0f       	add	r24, r24
    2332:	99 1f       	adc	r25, r25
    2334:	88 0f       	add	r24, r24
    2336:	99 1f       	adc	r25, r25
    2338:	88 0f       	add	r24, r24
    233a:	99 1f       	adc	r25, r25
    233c:	e8 0f       	add	r30, r24
    233e:	f9 1f       	adc	r31, r25
    2340:	e0 5a       	subi	r30, 0xA0	; 160
    2342:	f7 4f       	sbci	r31, 0xF7	; 247
    2344:	a1 81       	ldd	r26, Z+1	; 0x01
    2346:	b2 81       	ldd	r27, Z+2	; 0x02
    2348:	12 96       	adiw	r26, 0x02	; 2
    234a:	0d 90       	ld	r0, X+
    234c:	bc 91       	ld	r27, X
    234e:	a0 2d       	mov	r26, r0
    2350:	b2 83       	std	Z+2, r27	; 0x02
    2352:	a1 83       	std	Z+1, r26	; 0x01
    2354:	cf 01       	movw	r24, r30
    2356:	03 96       	adiw	r24, 0x03	; 3
    2358:	a8 17       	cp	r26, r24
    235a:	b9 07       	cpc	r27, r25
    235c:	31 f4       	brne	.+12     	; 0x236a <vTaskSwitchContext+0xa8>
    235e:	12 96       	adiw	r26, 0x02	; 2
    2360:	8d 91       	ld	r24, X+
    2362:	9c 91       	ld	r25, X
    2364:	13 97       	sbiw	r26, 0x03	; 3
    2366:	92 83       	std	Z+2, r25	; 0x02
    2368:	81 83       	std	Z+1, r24	; 0x01
    236a:	01 80       	ldd	r0, Z+1	; 0x01
    236c:	f2 81       	ldd	r31, Z+2	; 0x02
    236e:	e0 2d       	mov	r30, r0
    2370:	86 81       	ldd	r24, Z+6	; 0x06
    2372:	97 81       	ldd	r25, Z+7	; 0x07
    2374:	90 93 8e 08 	sts	0x088E, r25
    2378:	80 93 8d 08 	sts	0x088D, r24
    237c:	08 95       	ret

0000237e <vTaskSuspend>:
    237e:	0f 93       	push	r16
    2380:	1f 93       	push	r17
    2382:	cf 93       	push	r28
    2384:	df 93       	push	r29
    2386:	ec 01       	movw	r28, r24
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	f8 94       	cli
    238c:	0f 92       	push	r0
    238e:	00 97       	sbiw	r24, 0x00	; 0
    2390:	21 f4       	brne	.+8      	; 0x239a <vTaskSuspend+0x1c>
    2392:	c0 91 8d 08 	lds	r28, 0x088D
    2396:	d0 91 8e 08 	lds	r29, 0x088E
    239a:	8e 01       	movw	r16, r28
    239c:	0e 5f       	subi	r16, 0xFE	; 254
    239e:	1f 4f       	sbci	r17, 0xFF	; 255
    23a0:	c8 01       	movw	r24, r16
    23a2:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    23a6:	8c 89       	ldd	r24, Y+20	; 0x14
    23a8:	9d 89       	ldd	r25, Y+21	; 0x15
    23aa:	89 2b       	or	r24, r25
    23ac:	21 f0       	breq	.+8      	; 0x23b6 <vTaskSuspend+0x38>
    23ae:	ce 01       	movw	r24, r28
    23b0:	0c 96       	adiw	r24, 0x0c	; 12
    23b2:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    23b6:	b8 01       	movw	r22, r16
    23b8:	8e e2       	ldi	r24, 0x2E	; 46
    23ba:	98 e0       	ldi	r25, 0x08	; 8
    23bc:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	80 91 8d 08 	lds	r24, 0x088D
    23c8:	90 91 8e 08 	lds	r25, 0x088E
    23cc:	c8 17       	cp	r28, r24
    23ce:	d9 07       	cpc	r29, r25
    23d0:	99 f4       	brne	.+38     	; 0x23f8 <vTaskSuspend+0x7a>
    23d2:	80 91 29 08 	lds	r24, 0x0829
    23d6:	88 23       	and	r24, r24
    23d8:	11 f0       	breq	.+4      	; 0x23de <vTaskSuspend+0x60>
    23da:	20 d8       	rcall	.-4032   	; 0x141c <vPortYield>
    23dc:	17 c0       	rjmp	.+46     	; 0x240c <vTaskSuspend+0x8e>
    23de:	80 91 2d 08 	lds	r24, 0x082D
    23e2:	90 91 2e 08 	lds	r25, 0x082E
    23e6:	98 13       	cpse	r25, r24
    23e8:	05 c0       	rjmp	.+10     	; 0x23f4 <vTaskSuspend+0x76>
    23ea:	10 92 8e 08 	sts	0x088E, r1
    23ee:	10 92 8d 08 	sts	0x088D, r1
    23f2:	0c c0       	rjmp	.+24     	; 0x240c <vTaskSuspend+0x8e>
    23f4:	66 df       	rcall	.-308    	; 0x22c2 <vTaskSwitchContext>
    23f6:	0a c0       	rjmp	.+20     	; 0x240c <vTaskSuspend+0x8e>
    23f8:	80 91 29 08 	lds	r24, 0x0829
    23fc:	88 23       	and	r24, r24
    23fe:	31 f0       	breq	.+12     	; 0x240c <vTaskSuspend+0x8e>
    2400:	0f b6       	in	r0, 0x3f	; 63
    2402:	f8 94       	cli
    2404:	0f 92       	push	r0
    2406:	e2 db       	rcall	.-2108   	; 0x1bcc <prvResetNextTaskUnblockTime>
    2408:	0f 90       	pop	r0
    240a:	0f be       	out	0x3f, r0	; 63
    240c:	df 91       	pop	r29
    240e:	cf 91       	pop	r28
    2410:	1f 91       	pop	r17
    2412:	0f 91       	pop	r16
    2414:	08 95       	ret

00002416 <vTaskPlaceOnEventList>:
    2416:	cf 93       	push	r28
    2418:	df 93       	push	r29
    241a:	eb 01       	movw	r28, r22
    241c:	60 91 8d 08 	lds	r22, 0x088D
    2420:	70 91 8e 08 	lds	r23, 0x088E
    2424:	64 5f       	subi	r22, 0xF4	; 244
    2426:	7f 4f       	sbci	r23, 0xFF	; 255
    2428:	0e 94 6a 03 	call	0x6d4	; 0x6d4 <vListInsert>
    242c:	80 91 8d 08 	lds	r24, 0x088D
    2430:	90 91 8e 08 	lds	r25, 0x088E
    2434:	02 96       	adiw	r24, 0x02	; 2
    2436:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    243a:	cf 3f       	cpi	r28, 0xFF	; 255
    243c:	8f ef       	ldi	r24, 0xFF	; 255
    243e:	d8 07       	cpc	r29, r24
    2440:	59 f4       	brne	.+22     	; 0x2458 <vTaskPlaceOnEventList+0x42>
    2442:	60 91 8d 08 	lds	r22, 0x088D
    2446:	70 91 8e 08 	lds	r23, 0x088E
    244a:	6e 5f       	subi	r22, 0xFE	; 254
    244c:	7f 4f       	sbci	r23, 0xFF	; 255
    244e:	8e e2       	ldi	r24, 0x2E	; 46
    2450:	98 e0       	ldi	r25, 0x08	; 8
    2452:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    2456:	07 c0       	rjmp	.+14     	; 0x2466 <vTaskPlaceOnEventList+0x50>
    2458:	80 91 2b 08 	lds	r24, 0x082B
    245c:	90 91 2c 08 	lds	r25, 0x082C
    2460:	8c 0f       	add	r24, r28
    2462:	9d 1f       	adc	r25, r29
    2464:	d2 db       	rcall	.-2140   	; 0x1c0a <prvAddCurrentTaskToDelayedList>
    2466:	df 91       	pop	r29
    2468:	cf 91       	pop	r28
    246a:	08 95       	ret

0000246c <xTaskRemoveFromEventList>:
    246c:	0f 93       	push	r16
    246e:	1f 93       	push	r17
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	dc 01       	movw	r26, r24
    2476:	15 96       	adiw	r26, 0x05	; 5
    2478:	ed 91       	ld	r30, X+
    247a:	fc 91       	ld	r31, X
    247c:	16 97       	sbiw	r26, 0x06	; 6
    247e:	c6 81       	ldd	r28, Z+6	; 0x06
    2480:	d7 81       	ldd	r29, Z+7	; 0x07
    2482:	8e 01       	movw	r16, r28
    2484:	04 5f       	subi	r16, 0xF4	; 244
    2486:	1f 4f       	sbci	r17, 0xFF	; 255
    2488:	c8 01       	movw	r24, r16
    248a:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    248e:	80 91 24 08 	lds	r24, 0x0824
    2492:	81 11       	cpse	r24, r1
    2494:	1c c0       	rjmp	.+56     	; 0x24ce <xTaskRemoveFromEventList+0x62>
    2496:	0a 50       	subi	r16, 0x0A	; 10
    2498:	11 09       	sbc	r17, r1
    249a:	c8 01       	movw	r24, r16
    249c:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    24a0:	8e 89       	ldd	r24, Y+22	; 0x16
    24a2:	90 91 2a 08 	lds	r25, 0x082A
    24a6:	98 17       	cp	r25, r24
    24a8:	10 f4       	brcc	.+4      	; 0x24ae <xTaskRemoveFromEventList+0x42>
    24aa:	80 93 2a 08 	sts	0x082A, r24
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	9c 01       	movw	r18, r24
    24b2:	22 0f       	add	r18, r18
    24b4:	33 1f       	adc	r19, r19
    24b6:	22 0f       	add	r18, r18
    24b8:	33 1f       	adc	r19, r19
    24ba:	22 0f       	add	r18, r18
    24bc:	33 1f       	adc	r19, r19
    24be:	82 0f       	add	r24, r18
    24c0:	93 1f       	adc	r25, r19
    24c2:	b8 01       	movw	r22, r16
    24c4:	80 5a       	subi	r24, 0xA0	; 160
    24c6:	97 4f       	sbci	r25, 0xF7	; 247
    24c8:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    24cc:	05 c0       	rjmp	.+10     	; 0x24d8 <xTaskRemoveFromEventList+0x6c>
    24ce:	b8 01       	movw	r22, r16
    24d0:	81 e4       	ldi	r24, 0x41	; 65
    24d2:	98 e0       	ldi	r25, 0x08	; 8
    24d4:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    24d8:	e0 91 8d 08 	lds	r30, 0x088D
    24dc:	f0 91 8e 08 	lds	r31, 0x088E
    24e0:	9e 89       	ldd	r25, Y+22	; 0x16
    24e2:	86 89       	ldd	r24, Z+22	; 0x16
    24e4:	89 17       	cp	r24, r25
    24e6:	20 f4       	brcc	.+8      	; 0x24f0 <xTaskRemoveFromEventList+0x84>
    24e8:	81 e0       	ldi	r24, 0x01	; 1
    24ea:	80 93 27 08 	sts	0x0827, r24
    24ee:	01 c0       	rjmp	.+2      	; 0x24f2 <xTaskRemoveFromEventList+0x86>
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	df 91       	pop	r29
    24f4:	cf 91       	pop	r28
    24f6:	1f 91       	pop	r17
    24f8:	0f 91       	pop	r16
    24fa:	08 95       	ret

000024fc <vTaskSetTimeOutState>:
    24fc:	20 91 26 08 	lds	r18, 0x0826
    2500:	fc 01       	movw	r30, r24
    2502:	20 83       	st	Z, r18
    2504:	20 91 2b 08 	lds	r18, 0x082B
    2508:	30 91 2c 08 	lds	r19, 0x082C
    250c:	32 83       	std	Z+2, r19	; 0x02
    250e:	21 83       	std	Z+1, r18	; 0x01
    2510:	08 95       	ret

00002512 <xTaskCheckForTimeOut>:
    2512:	0f b6       	in	r0, 0x3f	; 63
    2514:	f8 94       	cli
    2516:	0f 92       	push	r0
    2518:	40 91 2b 08 	lds	r20, 0x082B
    251c:	50 91 2c 08 	lds	r21, 0x082C
    2520:	db 01       	movw	r26, r22
    2522:	2d 91       	ld	r18, X+
    2524:	3c 91       	ld	r19, X
    2526:	2f 3f       	cpi	r18, 0xFF	; 255
    2528:	bf ef       	ldi	r27, 0xFF	; 255
    252a:	3b 07       	cpc	r19, r27
    252c:	11 f1       	breq	.+68     	; 0x2572 <xTaskCheckForTimeOut+0x60>
    252e:	e0 91 26 08 	lds	r30, 0x0826
    2532:	dc 01       	movw	r26, r24
    2534:	fc 91       	ld	r31, X
    2536:	fe 17       	cp	r31, r30
    2538:	39 f0       	breq	.+14     	; 0x2548 <xTaskCheckForTimeOut+0x36>
    253a:	11 96       	adiw	r26, 0x01	; 1
    253c:	ed 91       	ld	r30, X+
    253e:	fc 91       	ld	r31, X
    2540:	12 97       	sbiw	r26, 0x02	; 2
    2542:	4e 17       	cp	r20, r30
    2544:	5f 07       	cpc	r21, r31
    2546:	b8 f4       	brcc	.+46     	; 0x2576 <xTaskCheckForTimeOut+0x64>
    2548:	dc 01       	movw	r26, r24
    254a:	11 96       	adiw	r26, 0x01	; 1
    254c:	ed 91       	ld	r30, X+
    254e:	fc 91       	ld	r31, X
    2550:	12 97       	sbiw	r26, 0x02	; 2
    2552:	da 01       	movw	r26, r20
    2554:	ae 1b       	sub	r26, r30
    2556:	bf 0b       	sbc	r27, r31
    2558:	a2 17       	cp	r26, r18
    255a:	b3 07       	cpc	r27, r19
    255c:	70 f4       	brcc	.+28     	; 0x257a <xTaskCheckForTimeOut+0x68>
    255e:	e4 1b       	sub	r30, r20
    2560:	f5 0b       	sbc	r31, r21
    2562:	2e 0f       	add	r18, r30
    2564:	3f 1f       	adc	r19, r31
    2566:	fb 01       	movw	r30, r22
    2568:	31 83       	std	Z+1, r19	; 0x01
    256a:	20 83       	st	Z, r18
    256c:	c7 df       	rcall	.-114    	; 0x24fc <vTaskSetTimeOutState>
    256e:	80 e0       	ldi	r24, 0x00	; 0
    2570:	05 c0       	rjmp	.+10     	; 0x257c <xTaskCheckForTimeOut+0x6a>
    2572:	80 e0       	ldi	r24, 0x00	; 0
    2574:	03 c0       	rjmp	.+6      	; 0x257c <xTaskCheckForTimeOut+0x6a>
    2576:	81 e0       	ldi	r24, 0x01	; 1
    2578:	01 c0       	rjmp	.+2      	; 0x257c <xTaskCheckForTimeOut+0x6a>
    257a:	81 e0       	ldi	r24, 0x01	; 1
    257c:	0f 90       	pop	r0
    257e:	0f be       	out	0x3f, r0	; 63
    2580:	08 95       	ret

00002582 <vTaskMissedYield>:
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	80 93 27 08 	sts	0x0827, r24
    2588:	08 95       	ret

0000258a <vTaskPriorityInherit>:
    258a:	0f 93       	push	r16
    258c:	1f 93       	push	r17
    258e:	cf 93       	push	r28
    2590:	df 93       	push	r29
    2592:	ec 01       	movw	r28, r24
    2594:	00 97       	sbiw	r24, 0x00	; 0
    2596:	09 f4       	brne	.+2      	; 0x259a <vTaskPriorityInherit+0x10>
    2598:	51 c0       	rjmp	.+162    	; 0x263c <vTaskPriorityInherit+0xb2>
    259a:	8e 89       	ldd	r24, Y+22	; 0x16
    259c:	e0 91 8d 08 	lds	r30, 0x088D
    25a0:	f0 91 8e 08 	lds	r31, 0x088E
    25a4:	96 89       	ldd	r25, Z+22	; 0x16
    25a6:	89 17       	cp	r24, r25
    25a8:	08 f0       	brcs	.+2      	; 0x25ac <vTaskPriorityInherit+0x22>
    25aa:	48 c0       	rjmp	.+144    	; 0x263c <vTaskPriorityInherit+0xb2>
    25ac:	2c 85       	ldd	r18, Y+12	; 0x0c
    25ae:	3d 85       	ldd	r19, Y+13	; 0x0d
    25b0:	33 23       	and	r19, r19
    25b2:	5c f0       	brlt	.+22     	; 0x25ca <vTaskPriorityInherit+0x40>
    25b4:	e0 91 8d 08 	lds	r30, 0x088D
    25b8:	f0 91 8e 08 	lds	r31, 0x088E
    25bc:	96 89       	ldd	r25, Z+22	; 0x16
    25be:	25 e0       	ldi	r18, 0x05	; 5
    25c0:	30 e0       	ldi	r19, 0x00	; 0
    25c2:	29 1b       	sub	r18, r25
    25c4:	31 09       	sbc	r19, r1
    25c6:	3d 87       	std	Y+13, r19	; 0x0d
    25c8:	2c 87       	std	Y+12, r18	; 0x0c
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	9c 01       	movw	r18, r24
    25ce:	22 0f       	add	r18, r18
    25d0:	33 1f       	adc	r19, r19
    25d2:	22 0f       	add	r18, r18
    25d4:	33 1f       	adc	r19, r19
    25d6:	22 0f       	add	r18, r18
    25d8:	33 1f       	adc	r19, r19
    25da:	82 0f       	add	r24, r18
    25dc:	93 1f       	adc	r25, r19
    25de:	80 5a       	subi	r24, 0xA0	; 160
    25e0:	97 4f       	sbci	r25, 0xF7	; 247
    25e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    25e4:	3b 85       	ldd	r19, Y+11	; 0x0b
    25e6:	28 17       	cp	r18, r24
    25e8:	39 07       	cpc	r19, r25
    25ea:	11 f5       	brne	.+68     	; 0x2630 <vTaskPriorityInherit+0xa6>
    25ec:	8e 01       	movw	r16, r28
    25ee:	0e 5f       	subi	r16, 0xFE	; 254
    25f0:	1f 4f       	sbci	r17, 0xFF	; 255
    25f2:	c8 01       	movw	r24, r16
    25f4:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    25f8:	e0 91 8d 08 	lds	r30, 0x088D
    25fc:	f0 91 8e 08 	lds	r31, 0x088E
    2600:	86 89       	ldd	r24, Z+22	; 0x16
    2602:	8e 8b       	std	Y+22, r24	; 0x16
    2604:	90 91 2a 08 	lds	r25, 0x082A
    2608:	98 17       	cp	r25, r24
    260a:	10 f4       	brcc	.+4      	; 0x2610 <vTaskPriorityInherit+0x86>
    260c:	80 93 2a 08 	sts	0x082A, r24
    2610:	90 e0       	ldi	r25, 0x00	; 0
    2612:	9c 01       	movw	r18, r24
    2614:	22 0f       	add	r18, r18
    2616:	33 1f       	adc	r19, r19
    2618:	22 0f       	add	r18, r18
    261a:	33 1f       	adc	r19, r19
    261c:	22 0f       	add	r18, r18
    261e:	33 1f       	adc	r19, r19
    2620:	82 0f       	add	r24, r18
    2622:	93 1f       	adc	r25, r19
    2624:	b8 01       	movw	r22, r16
    2626:	80 5a       	subi	r24, 0xA0	; 160
    2628:	97 4f       	sbci	r25, 0xF7	; 247
    262a:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    262e:	06 c0       	rjmp	.+12     	; 0x263c <vTaskPriorityInherit+0xb2>
    2630:	e0 91 8d 08 	lds	r30, 0x088D
    2634:	f0 91 8e 08 	lds	r31, 0x088E
    2638:	86 89       	ldd	r24, Z+22	; 0x16
    263a:	8e 8b       	std	Y+22, r24	; 0x16
    263c:	df 91       	pop	r29
    263e:	cf 91       	pop	r28
    2640:	1f 91       	pop	r17
    2642:	0f 91       	pop	r16
    2644:	08 95       	ret

00002646 <xTaskPriorityDisinherit>:
    2646:	0f 93       	push	r16
    2648:	1f 93       	push	r17
    264a:	cf 93       	push	r28
    264c:	df 93       	push	r29
    264e:	ec 01       	movw	r28, r24
    2650:	00 97       	sbiw	r24, 0x00	; 0
    2652:	71 f1       	breq	.+92     	; 0x26b0 <xTaskPriorityDisinherit+0x6a>
    2654:	8a a1       	ldd	r24, Y+34	; 0x22
    2656:	81 50       	subi	r24, 0x01	; 1
    2658:	8a a3       	std	Y+34, r24	; 0x22
    265a:	2e 89       	ldd	r18, Y+22	; 0x16
    265c:	99 a1       	ldd	r25, Y+33	; 0x21
    265e:	29 17       	cp	r18, r25
    2660:	49 f1       	breq	.+82     	; 0x26b4 <xTaskPriorityDisinherit+0x6e>
    2662:	81 11       	cpse	r24, r1
    2664:	29 c0       	rjmp	.+82     	; 0x26b8 <xTaskPriorityDisinherit+0x72>
    2666:	8e 01       	movw	r16, r28
    2668:	0e 5f       	subi	r16, 0xFE	; 254
    266a:	1f 4f       	sbci	r17, 0xFF	; 255
    266c:	c8 01       	movw	r24, r16
    266e:	0e 94 9b 03 	call	0x736	; 0x736 <uxListRemove>
    2672:	89 a1       	ldd	r24, Y+33	; 0x21
    2674:	8e 8b       	std	Y+22, r24	; 0x16
    2676:	25 e0       	ldi	r18, 0x05	; 5
    2678:	30 e0       	ldi	r19, 0x00	; 0
    267a:	28 1b       	sub	r18, r24
    267c:	31 09       	sbc	r19, r1
    267e:	3d 87       	std	Y+13, r19	; 0x0d
    2680:	2c 87       	std	Y+12, r18	; 0x0c
    2682:	90 91 2a 08 	lds	r25, 0x082A
    2686:	98 17       	cp	r25, r24
    2688:	10 f4       	brcc	.+4      	; 0x268e <xTaskPriorityDisinherit+0x48>
    268a:	80 93 2a 08 	sts	0x082A, r24
    268e:	90 e0       	ldi	r25, 0x00	; 0
    2690:	9c 01       	movw	r18, r24
    2692:	22 0f       	add	r18, r18
    2694:	33 1f       	adc	r19, r19
    2696:	22 0f       	add	r18, r18
    2698:	33 1f       	adc	r19, r19
    269a:	22 0f       	add	r18, r18
    269c:	33 1f       	adc	r19, r19
    269e:	82 0f       	add	r24, r18
    26a0:	93 1f       	adc	r25, r19
    26a2:	b8 01       	movw	r22, r16
    26a4:	80 5a       	subi	r24, 0xA0	; 160
    26a6:	97 4f       	sbci	r25, 0xF7	; 247
    26a8:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    26ac:	81 e0       	ldi	r24, 0x01	; 1
    26ae:	05 c0       	rjmp	.+10     	; 0x26ba <xTaskPriorityDisinherit+0x74>
    26b0:	80 e0       	ldi	r24, 0x00	; 0
    26b2:	03 c0       	rjmp	.+6      	; 0x26ba <xTaskPriorityDisinherit+0x74>
    26b4:	80 e0       	ldi	r24, 0x00	; 0
    26b6:	01 c0       	rjmp	.+2      	; 0x26ba <xTaskPriorityDisinherit+0x74>
    26b8:	80 e0       	ldi	r24, 0x00	; 0
    26ba:	df 91       	pop	r29
    26bc:	cf 91       	pop	r28
    26be:	1f 91       	pop	r17
    26c0:	0f 91       	pop	r16
    26c2:	08 95       	ret

000026c4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    26c4:	80 91 8d 08 	lds	r24, 0x088D
    26c8:	90 91 8e 08 	lds	r25, 0x088E
    26cc:	89 2b       	or	r24, r25
    26ce:	39 f0       	breq	.+14     	; 0x26de <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    26d0:	e0 91 8d 08 	lds	r30, 0x088D
    26d4:	f0 91 8e 08 	lds	r31, 0x088E
    26d8:	82 a1       	ldd	r24, Z+34	; 0x22
    26da:	8f 5f       	subi	r24, 0xFF	; 255
    26dc:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    26de:	80 91 8d 08 	lds	r24, 0x088D
    26e2:	90 91 8e 08 	lds	r25, 0x088E
	}
    26e6:	08 95       	ret

000026e8 <__subsf3>:
    26e8:	50 58       	subi	r21, 0x80	; 128

000026ea <__addsf3>:
    26ea:	bb 27       	eor	r27, r27
    26ec:	aa 27       	eor	r26, r26
    26ee:	0e d0       	rcall	.+28     	; 0x270c <__addsf3x>
    26f0:	e5 c0       	rjmp	.+458    	; 0x28bc <__fp_round>
    26f2:	d6 d0       	rcall	.+428    	; 0x28a0 <__fp_pscA>
    26f4:	30 f0       	brcs	.+12     	; 0x2702 <__addsf3+0x18>
    26f6:	db d0       	rcall	.+438    	; 0x28ae <__fp_pscB>
    26f8:	20 f0       	brcs	.+8      	; 0x2702 <__addsf3+0x18>
    26fa:	31 f4       	brne	.+12     	; 0x2708 <__addsf3+0x1e>
    26fc:	9f 3f       	cpi	r25, 0xFF	; 255
    26fe:	11 f4       	brne	.+4      	; 0x2704 <__addsf3+0x1a>
    2700:	1e f4       	brtc	.+6      	; 0x2708 <__addsf3+0x1e>
    2702:	cb c0       	rjmp	.+406    	; 0x289a <__fp_nan>
    2704:	0e f4       	brtc	.+2      	; 0x2708 <__addsf3+0x1e>
    2706:	e0 95       	com	r30
    2708:	e7 fb       	bst	r30, 7
    270a:	c1 c0       	rjmp	.+386    	; 0x288e <__fp_inf>

0000270c <__addsf3x>:
    270c:	e9 2f       	mov	r30, r25
    270e:	e7 d0       	rcall	.+462    	; 0x28de <__fp_split3>
    2710:	80 f3       	brcs	.-32     	; 0x26f2 <__addsf3+0x8>
    2712:	ba 17       	cp	r27, r26
    2714:	62 07       	cpc	r22, r18
    2716:	73 07       	cpc	r23, r19
    2718:	84 07       	cpc	r24, r20
    271a:	95 07       	cpc	r25, r21
    271c:	18 f0       	brcs	.+6      	; 0x2724 <__addsf3x+0x18>
    271e:	71 f4       	brne	.+28     	; 0x273c <__addsf3x+0x30>
    2720:	9e f5       	brtc	.+102    	; 0x2788 <__addsf3x+0x7c>
    2722:	ff c0       	rjmp	.+510    	; 0x2922 <__fp_zero>
    2724:	0e f4       	brtc	.+2      	; 0x2728 <__addsf3x+0x1c>
    2726:	e0 95       	com	r30
    2728:	0b 2e       	mov	r0, r27
    272a:	ba 2f       	mov	r27, r26
    272c:	a0 2d       	mov	r26, r0
    272e:	0b 01       	movw	r0, r22
    2730:	b9 01       	movw	r22, r18
    2732:	90 01       	movw	r18, r0
    2734:	0c 01       	movw	r0, r24
    2736:	ca 01       	movw	r24, r20
    2738:	a0 01       	movw	r20, r0
    273a:	11 24       	eor	r1, r1
    273c:	ff 27       	eor	r31, r31
    273e:	59 1b       	sub	r21, r25
    2740:	99 f0       	breq	.+38     	; 0x2768 <__addsf3x+0x5c>
    2742:	59 3f       	cpi	r21, 0xF9	; 249
    2744:	50 f4       	brcc	.+20     	; 0x275a <__addsf3x+0x4e>
    2746:	50 3e       	cpi	r21, 0xE0	; 224
    2748:	68 f1       	brcs	.+90     	; 0x27a4 <__addsf3x+0x98>
    274a:	1a 16       	cp	r1, r26
    274c:	f0 40       	sbci	r31, 0x00	; 0
    274e:	a2 2f       	mov	r26, r18
    2750:	23 2f       	mov	r18, r19
    2752:	34 2f       	mov	r19, r20
    2754:	44 27       	eor	r20, r20
    2756:	58 5f       	subi	r21, 0xF8	; 248
    2758:	f3 cf       	rjmp	.-26     	; 0x2740 <__addsf3x+0x34>
    275a:	46 95       	lsr	r20
    275c:	37 95       	ror	r19
    275e:	27 95       	ror	r18
    2760:	a7 95       	ror	r26
    2762:	f0 40       	sbci	r31, 0x00	; 0
    2764:	53 95       	inc	r21
    2766:	c9 f7       	brne	.-14     	; 0x275a <__addsf3x+0x4e>
    2768:	7e f4       	brtc	.+30     	; 0x2788 <__addsf3x+0x7c>
    276a:	1f 16       	cp	r1, r31
    276c:	ba 0b       	sbc	r27, r26
    276e:	62 0b       	sbc	r22, r18
    2770:	73 0b       	sbc	r23, r19
    2772:	84 0b       	sbc	r24, r20
    2774:	ba f0       	brmi	.+46     	; 0x27a4 <__addsf3x+0x98>
    2776:	91 50       	subi	r25, 0x01	; 1
    2778:	a1 f0       	breq	.+40     	; 0x27a2 <__addsf3x+0x96>
    277a:	ff 0f       	add	r31, r31
    277c:	bb 1f       	adc	r27, r27
    277e:	66 1f       	adc	r22, r22
    2780:	77 1f       	adc	r23, r23
    2782:	88 1f       	adc	r24, r24
    2784:	c2 f7       	brpl	.-16     	; 0x2776 <__addsf3x+0x6a>
    2786:	0e c0       	rjmp	.+28     	; 0x27a4 <__addsf3x+0x98>
    2788:	ba 0f       	add	r27, r26
    278a:	62 1f       	adc	r22, r18
    278c:	73 1f       	adc	r23, r19
    278e:	84 1f       	adc	r24, r20
    2790:	48 f4       	brcc	.+18     	; 0x27a4 <__addsf3x+0x98>
    2792:	87 95       	ror	r24
    2794:	77 95       	ror	r23
    2796:	67 95       	ror	r22
    2798:	b7 95       	ror	r27
    279a:	f7 95       	ror	r31
    279c:	9e 3f       	cpi	r25, 0xFE	; 254
    279e:	08 f0       	brcs	.+2      	; 0x27a2 <__addsf3x+0x96>
    27a0:	b3 cf       	rjmp	.-154    	; 0x2708 <__addsf3+0x1e>
    27a2:	93 95       	inc	r25
    27a4:	88 0f       	add	r24, r24
    27a6:	08 f0       	brcs	.+2      	; 0x27aa <__addsf3x+0x9e>
    27a8:	99 27       	eor	r25, r25
    27aa:	ee 0f       	add	r30, r30
    27ac:	97 95       	ror	r25
    27ae:	87 95       	ror	r24
    27b0:	08 95       	ret

000027b2 <__fixsfsi>:
    27b2:	04 d0       	rcall	.+8      	; 0x27bc <__fixunssfsi>
    27b4:	68 94       	set
    27b6:	b1 11       	cpse	r27, r1
    27b8:	b5 c0       	rjmp	.+362    	; 0x2924 <__fp_szero>
    27ba:	08 95       	ret

000027bc <__fixunssfsi>:
    27bc:	98 d0       	rcall	.+304    	; 0x28ee <__fp_splitA>
    27be:	88 f0       	brcs	.+34     	; 0x27e2 <__fixunssfsi+0x26>
    27c0:	9f 57       	subi	r25, 0x7F	; 127
    27c2:	90 f0       	brcs	.+36     	; 0x27e8 <__fixunssfsi+0x2c>
    27c4:	b9 2f       	mov	r27, r25
    27c6:	99 27       	eor	r25, r25
    27c8:	b7 51       	subi	r27, 0x17	; 23
    27ca:	a0 f0       	brcs	.+40     	; 0x27f4 <__fixunssfsi+0x38>
    27cc:	d1 f0       	breq	.+52     	; 0x2802 <__fixunssfsi+0x46>
    27ce:	66 0f       	add	r22, r22
    27d0:	77 1f       	adc	r23, r23
    27d2:	88 1f       	adc	r24, r24
    27d4:	99 1f       	adc	r25, r25
    27d6:	1a f0       	brmi	.+6      	; 0x27de <__fixunssfsi+0x22>
    27d8:	ba 95       	dec	r27
    27da:	c9 f7       	brne	.-14     	; 0x27ce <__fixunssfsi+0x12>
    27dc:	12 c0       	rjmp	.+36     	; 0x2802 <__fixunssfsi+0x46>
    27de:	b1 30       	cpi	r27, 0x01	; 1
    27e0:	81 f0       	breq	.+32     	; 0x2802 <__fixunssfsi+0x46>
    27e2:	9f d0       	rcall	.+318    	; 0x2922 <__fp_zero>
    27e4:	b1 e0       	ldi	r27, 0x01	; 1
    27e6:	08 95       	ret
    27e8:	9c c0       	rjmp	.+312    	; 0x2922 <__fp_zero>
    27ea:	67 2f       	mov	r22, r23
    27ec:	78 2f       	mov	r23, r24
    27ee:	88 27       	eor	r24, r24
    27f0:	b8 5f       	subi	r27, 0xF8	; 248
    27f2:	39 f0       	breq	.+14     	; 0x2802 <__fixunssfsi+0x46>
    27f4:	b9 3f       	cpi	r27, 0xF9	; 249
    27f6:	cc f3       	brlt	.-14     	; 0x27ea <__fixunssfsi+0x2e>
    27f8:	86 95       	lsr	r24
    27fa:	77 95       	ror	r23
    27fc:	67 95       	ror	r22
    27fe:	b3 95       	inc	r27
    2800:	d9 f7       	brne	.-10     	; 0x27f8 <__fixunssfsi+0x3c>
    2802:	3e f4       	brtc	.+14     	; 0x2812 <__fixunssfsi+0x56>
    2804:	90 95       	com	r25
    2806:	80 95       	com	r24
    2808:	70 95       	com	r23
    280a:	61 95       	neg	r22
    280c:	7f 4f       	sbci	r23, 0xFF	; 255
    280e:	8f 4f       	sbci	r24, 0xFF	; 255
    2810:	9f 4f       	sbci	r25, 0xFF	; 255
    2812:	08 95       	ret

00002814 <__floatunsisf>:
    2814:	e8 94       	clt
    2816:	09 c0       	rjmp	.+18     	; 0x282a <__floatsisf+0x12>

00002818 <__floatsisf>:
    2818:	97 fb       	bst	r25, 7
    281a:	3e f4       	brtc	.+14     	; 0x282a <__floatsisf+0x12>
    281c:	90 95       	com	r25
    281e:	80 95       	com	r24
    2820:	70 95       	com	r23
    2822:	61 95       	neg	r22
    2824:	7f 4f       	sbci	r23, 0xFF	; 255
    2826:	8f 4f       	sbci	r24, 0xFF	; 255
    2828:	9f 4f       	sbci	r25, 0xFF	; 255
    282a:	99 23       	and	r25, r25
    282c:	a9 f0       	breq	.+42     	; 0x2858 <__floatsisf+0x40>
    282e:	f9 2f       	mov	r31, r25
    2830:	96 e9       	ldi	r25, 0x96	; 150
    2832:	bb 27       	eor	r27, r27
    2834:	93 95       	inc	r25
    2836:	f6 95       	lsr	r31
    2838:	87 95       	ror	r24
    283a:	77 95       	ror	r23
    283c:	67 95       	ror	r22
    283e:	b7 95       	ror	r27
    2840:	f1 11       	cpse	r31, r1
    2842:	f8 cf       	rjmp	.-16     	; 0x2834 <__floatsisf+0x1c>
    2844:	fa f4       	brpl	.+62     	; 0x2884 <__floatsisf+0x6c>
    2846:	bb 0f       	add	r27, r27
    2848:	11 f4       	brne	.+4      	; 0x284e <__floatsisf+0x36>
    284a:	60 ff       	sbrs	r22, 0
    284c:	1b c0       	rjmp	.+54     	; 0x2884 <__floatsisf+0x6c>
    284e:	6f 5f       	subi	r22, 0xFF	; 255
    2850:	7f 4f       	sbci	r23, 0xFF	; 255
    2852:	8f 4f       	sbci	r24, 0xFF	; 255
    2854:	9f 4f       	sbci	r25, 0xFF	; 255
    2856:	16 c0       	rjmp	.+44     	; 0x2884 <__floatsisf+0x6c>
    2858:	88 23       	and	r24, r24
    285a:	11 f0       	breq	.+4      	; 0x2860 <__floatsisf+0x48>
    285c:	96 e9       	ldi	r25, 0x96	; 150
    285e:	11 c0       	rjmp	.+34     	; 0x2882 <__floatsisf+0x6a>
    2860:	77 23       	and	r23, r23
    2862:	21 f0       	breq	.+8      	; 0x286c <__floatsisf+0x54>
    2864:	9e e8       	ldi	r25, 0x8E	; 142
    2866:	87 2f       	mov	r24, r23
    2868:	76 2f       	mov	r23, r22
    286a:	05 c0       	rjmp	.+10     	; 0x2876 <__floatsisf+0x5e>
    286c:	66 23       	and	r22, r22
    286e:	71 f0       	breq	.+28     	; 0x288c <__floatsisf+0x74>
    2870:	96 e8       	ldi	r25, 0x86	; 134
    2872:	86 2f       	mov	r24, r22
    2874:	70 e0       	ldi	r23, 0x00	; 0
    2876:	60 e0       	ldi	r22, 0x00	; 0
    2878:	2a f0       	brmi	.+10     	; 0x2884 <__floatsisf+0x6c>
    287a:	9a 95       	dec	r25
    287c:	66 0f       	add	r22, r22
    287e:	77 1f       	adc	r23, r23
    2880:	88 1f       	adc	r24, r24
    2882:	da f7       	brpl	.-10     	; 0x287a <__floatsisf+0x62>
    2884:	88 0f       	add	r24, r24
    2886:	96 95       	lsr	r25
    2888:	87 95       	ror	r24
    288a:	97 f9       	bld	r25, 7
    288c:	08 95       	ret

0000288e <__fp_inf>:
    288e:	97 f9       	bld	r25, 7
    2890:	9f 67       	ori	r25, 0x7F	; 127
    2892:	80 e8       	ldi	r24, 0x80	; 128
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	60 e0       	ldi	r22, 0x00	; 0
    2898:	08 95       	ret

0000289a <__fp_nan>:
    289a:	9f ef       	ldi	r25, 0xFF	; 255
    289c:	80 ec       	ldi	r24, 0xC0	; 192
    289e:	08 95       	ret

000028a0 <__fp_pscA>:
    28a0:	00 24       	eor	r0, r0
    28a2:	0a 94       	dec	r0
    28a4:	16 16       	cp	r1, r22
    28a6:	17 06       	cpc	r1, r23
    28a8:	18 06       	cpc	r1, r24
    28aa:	09 06       	cpc	r0, r25
    28ac:	08 95       	ret

000028ae <__fp_pscB>:
    28ae:	00 24       	eor	r0, r0
    28b0:	0a 94       	dec	r0
    28b2:	12 16       	cp	r1, r18
    28b4:	13 06       	cpc	r1, r19
    28b6:	14 06       	cpc	r1, r20
    28b8:	05 06       	cpc	r0, r21
    28ba:	08 95       	ret

000028bc <__fp_round>:
    28bc:	09 2e       	mov	r0, r25
    28be:	03 94       	inc	r0
    28c0:	00 0c       	add	r0, r0
    28c2:	11 f4       	brne	.+4      	; 0x28c8 <__fp_round+0xc>
    28c4:	88 23       	and	r24, r24
    28c6:	52 f0       	brmi	.+20     	; 0x28dc <__fp_round+0x20>
    28c8:	bb 0f       	add	r27, r27
    28ca:	40 f4       	brcc	.+16     	; 0x28dc <__fp_round+0x20>
    28cc:	bf 2b       	or	r27, r31
    28ce:	11 f4       	brne	.+4      	; 0x28d4 <__fp_round+0x18>
    28d0:	60 ff       	sbrs	r22, 0
    28d2:	04 c0       	rjmp	.+8      	; 0x28dc <__fp_round+0x20>
    28d4:	6f 5f       	subi	r22, 0xFF	; 255
    28d6:	7f 4f       	sbci	r23, 0xFF	; 255
    28d8:	8f 4f       	sbci	r24, 0xFF	; 255
    28da:	9f 4f       	sbci	r25, 0xFF	; 255
    28dc:	08 95       	ret

000028de <__fp_split3>:
    28de:	57 fd       	sbrc	r21, 7
    28e0:	90 58       	subi	r25, 0x80	; 128
    28e2:	44 0f       	add	r20, r20
    28e4:	55 1f       	adc	r21, r21
    28e6:	59 f0       	breq	.+22     	; 0x28fe <__fp_splitA+0x10>
    28e8:	5f 3f       	cpi	r21, 0xFF	; 255
    28ea:	71 f0       	breq	.+28     	; 0x2908 <__fp_splitA+0x1a>
    28ec:	47 95       	ror	r20

000028ee <__fp_splitA>:
    28ee:	88 0f       	add	r24, r24
    28f0:	97 fb       	bst	r25, 7
    28f2:	99 1f       	adc	r25, r25
    28f4:	61 f0       	breq	.+24     	; 0x290e <__fp_splitA+0x20>
    28f6:	9f 3f       	cpi	r25, 0xFF	; 255
    28f8:	79 f0       	breq	.+30     	; 0x2918 <__fp_splitA+0x2a>
    28fa:	87 95       	ror	r24
    28fc:	08 95       	ret
    28fe:	12 16       	cp	r1, r18
    2900:	13 06       	cpc	r1, r19
    2902:	14 06       	cpc	r1, r20
    2904:	55 1f       	adc	r21, r21
    2906:	f2 cf       	rjmp	.-28     	; 0x28ec <__fp_split3+0xe>
    2908:	46 95       	lsr	r20
    290a:	f1 df       	rcall	.-30     	; 0x28ee <__fp_splitA>
    290c:	08 c0       	rjmp	.+16     	; 0x291e <__fp_splitA+0x30>
    290e:	16 16       	cp	r1, r22
    2910:	17 06       	cpc	r1, r23
    2912:	18 06       	cpc	r1, r24
    2914:	99 1f       	adc	r25, r25
    2916:	f1 cf       	rjmp	.-30     	; 0x28fa <__fp_splitA+0xc>
    2918:	86 95       	lsr	r24
    291a:	71 05       	cpc	r23, r1
    291c:	61 05       	cpc	r22, r1
    291e:	08 94       	sec
    2920:	08 95       	ret

00002922 <__fp_zero>:
    2922:	e8 94       	clt

00002924 <__fp_szero>:
    2924:	bb 27       	eor	r27, r27
    2926:	66 27       	eor	r22, r22
    2928:	77 27       	eor	r23, r23
    292a:	cb 01       	movw	r24, r22
    292c:	97 f9       	bld	r25, 7
    292e:	08 95       	ret

00002930 <__mulsf3>:
    2930:	0b d0       	rcall	.+22     	; 0x2948 <__mulsf3x>
    2932:	c4 cf       	rjmp	.-120    	; 0x28bc <__fp_round>
    2934:	b5 df       	rcall	.-150    	; 0x28a0 <__fp_pscA>
    2936:	28 f0       	brcs	.+10     	; 0x2942 <__mulsf3+0x12>
    2938:	ba df       	rcall	.-140    	; 0x28ae <__fp_pscB>
    293a:	18 f0       	brcs	.+6      	; 0x2942 <__mulsf3+0x12>
    293c:	95 23       	and	r25, r21
    293e:	09 f0       	breq	.+2      	; 0x2942 <__mulsf3+0x12>
    2940:	a6 cf       	rjmp	.-180    	; 0x288e <__fp_inf>
    2942:	ab cf       	rjmp	.-170    	; 0x289a <__fp_nan>
    2944:	11 24       	eor	r1, r1
    2946:	ee cf       	rjmp	.-36     	; 0x2924 <__fp_szero>

00002948 <__mulsf3x>:
    2948:	ca df       	rcall	.-108    	; 0x28de <__fp_split3>
    294a:	a0 f3       	brcs	.-24     	; 0x2934 <__mulsf3+0x4>

0000294c <__mulsf3_pse>:
    294c:	95 9f       	mul	r25, r21
    294e:	d1 f3       	breq	.-12     	; 0x2944 <__mulsf3+0x14>
    2950:	95 0f       	add	r25, r21
    2952:	50 e0       	ldi	r21, 0x00	; 0
    2954:	55 1f       	adc	r21, r21
    2956:	62 9f       	mul	r22, r18
    2958:	f0 01       	movw	r30, r0
    295a:	72 9f       	mul	r23, r18
    295c:	bb 27       	eor	r27, r27
    295e:	f0 0d       	add	r31, r0
    2960:	b1 1d       	adc	r27, r1
    2962:	63 9f       	mul	r22, r19
    2964:	aa 27       	eor	r26, r26
    2966:	f0 0d       	add	r31, r0
    2968:	b1 1d       	adc	r27, r1
    296a:	aa 1f       	adc	r26, r26
    296c:	64 9f       	mul	r22, r20
    296e:	66 27       	eor	r22, r22
    2970:	b0 0d       	add	r27, r0
    2972:	a1 1d       	adc	r26, r1
    2974:	66 1f       	adc	r22, r22
    2976:	82 9f       	mul	r24, r18
    2978:	22 27       	eor	r18, r18
    297a:	b0 0d       	add	r27, r0
    297c:	a1 1d       	adc	r26, r1
    297e:	62 1f       	adc	r22, r18
    2980:	73 9f       	mul	r23, r19
    2982:	b0 0d       	add	r27, r0
    2984:	a1 1d       	adc	r26, r1
    2986:	62 1f       	adc	r22, r18
    2988:	83 9f       	mul	r24, r19
    298a:	a0 0d       	add	r26, r0
    298c:	61 1d       	adc	r22, r1
    298e:	22 1f       	adc	r18, r18
    2990:	74 9f       	mul	r23, r20
    2992:	33 27       	eor	r19, r19
    2994:	a0 0d       	add	r26, r0
    2996:	61 1d       	adc	r22, r1
    2998:	23 1f       	adc	r18, r19
    299a:	84 9f       	mul	r24, r20
    299c:	60 0d       	add	r22, r0
    299e:	21 1d       	adc	r18, r1
    29a0:	82 2f       	mov	r24, r18
    29a2:	76 2f       	mov	r23, r22
    29a4:	6a 2f       	mov	r22, r26
    29a6:	11 24       	eor	r1, r1
    29a8:	9f 57       	subi	r25, 0x7F	; 127
    29aa:	50 40       	sbci	r21, 0x00	; 0
    29ac:	8a f0       	brmi	.+34     	; 0x29d0 <__mulsf3_pse+0x84>
    29ae:	e1 f0       	breq	.+56     	; 0x29e8 <__mulsf3_pse+0x9c>
    29b0:	88 23       	and	r24, r24
    29b2:	4a f0       	brmi	.+18     	; 0x29c6 <__mulsf3_pse+0x7a>
    29b4:	ee 0f       	add	r30, r30
    29b6:	ff 1f       	adc	r31, r31
    29b8:	bb 1f       	adc	r27, r27
    29ba:	66 1f       	adc	r22, r22
    29bc:	77 1f       	adc	r23, r23
    29be:	88 1f       	adc	r24, r24
    29c0:	91 50       	subi	r25, 0x01	; 1
    29c2:	50 40       	sbci	r21, 0x00	; 0
    29c4:	a9 f7       	brne	.-22     	; 0x29b0 <__mulsf3_pse+0x64>
    29c6:	9e 3f       	cpi	r25, 0xFE	; 254
    29c8:	51 05       	cpc	r21, r1
    29ca:	70 f0       	brcs	.+28     	; 0x29e8 <__mulsf3_pse+0x9c>
    29cc:	60 cf       	rjmp	.-320    	; 0x288e <__fp_inf>
    29ce:	aa cf       	rjmp	.-172    	; 0x2924 <__fp_szero>
    29d0:	5f 3f       	cpi	r21, 0xFF	; 255
    29d2:	ec f3       	brlt	.-6      	; 0x29ce <__mulsf3_pse+0x82>
    29d4:	98 3e       	cpi	r25, 0xE8	; 232
    29d6:	dc f3       	brlt	.-10     	; 0x29ce <__mulsf3_pse+0x82>
    29d8:	86 95       	lsr	r24
    29da:	77 95       	ror	r23
    29dc:	67 95       	ror	r22
    29de:	b7 95       	ror	r27
    29e0:	f7 95       	ror	r31
    29e2:	e7 95       	ror	r30
    29e4:	9f 5f       	subi	r25, 0xFF	; 255
    29e6:	c1 f7       	brne	.-16     	; 0x29d8 <__mulsf3_pse+0x8c>
    29e8:	fe 2b       	or	r31, r30
    29ea:	88 0f       	add	r24, r24
    29ec:	91 1d       	adc	r25, r1
    29ee:	96 95       	lsr	r25
    29f0:	87 95       	ror	r24
    29f2:	97 f9       	bld	r25, 7
    29f4:	08 95       	ret

000029f6 <pow>:
    29f6:	fa 01       	movw	r30, r20
    29f8:	ee 0f       	add	r30, r30
    29fa:	ff 1f       	adc	r31, r31
    29fc:	30 96       	adiw	r30, 0x00	; 0
    29fe:	21 05       	cpc	r18, r1
    2a00:	31 05       	cpc	r19, r1
    2a02:	99 f1       	breq	.+102    	; 0x2a6a <pow+0x74>
    2a04:	61 15       	cp	r22, r1
    2a06:	71 05       	cpc	r23, r1
    2a08:	61 f4       	brne	.+24     	; 0x2a22 <pow+0x2c>
    2a0a:	80 38       	cpi	r24, 0x80	; 128
    2a0c:	bf e3       	ldi	r27, 0x3F	; 63
    2a0e:	9b 07       	cpc	r25, r27
    2a10:	49 f1       	breq	.+82     	; 0x2a64 <pow+0x6e>
    2a12:	68 94       	set
    2a14:	90 38       	cpi	r25, 0x80	; 128
    2a16:	81 05       	cpc	r24, r1
    2a18:	61 f0       	breq	.+24     	; 0x2a32 <pow+0x3c>
    2a1a:	80 38       	cpi	r24, 0x80	; 128
    2a1c:	bf ef       	ldi	r27, 0xFF	; 255
    2a1e:	9b 07       	cpc	r25, r27
    2a20:	41 f0       	breq	.+16     	; 0x2a32 <pow+0x3c>
    2a22:	99 23       	and	r25, r25
    2a24:	42 f5       	brpl	.+80     	; 0x2a76 <pow+0x80>
    2a26:	ff 3f       	cpi	r31, 0xFF	; 255
    2a28:	e1 05       	cpc	r30, r1
    2a2a:	31 05       	cpc	r19, r1
    2a2c:	21 05       	cpc	r18, r1
    2a2e:	11 f1       	breq	.+68     	; 0x2a74 <pow+0x7e>
    2a30:	e8 94       	clt
    2a32:	08 94       	sec
    2a34:	e7 95       	ror	r30
    2a36:	d9 01       	movw	r26, r18
    2a38:	aa 23       	and	r26, r26
    2a3a:	29 f4       	brne	.+10     	; 0x2a46 <pow+0x50>
    2a3c:	ab 2f       	mov	r26, r27
    2a3e:	be 2f       	mov	r27, r30
    2a40:	f8 5f       	subi	r31, 0xF8	; 248
    2a42:	d0 f3       	brcs	.-12     	; 0x2a38 <pow+0x42>
    2a44:	10 c0       	rjmp	.+32     	; 0x2a66 <pow+0x70>
    2a46:	ff 5f       	subi	r31, 0xFF	; 255
    2a48:	70 f4       	brcc	.+28     	; 0x2a66 <pow+0x70>
    2a4a:	a6 95       	lsr	r26
    2a4c:	e0 f7       	brcc	.-8      	; 0x2a46 <pow+0x50>
    2a4e:	f7 39       	cpi	r31, 0x97	; 151
    2a50:	50 f0       	brcs	.+20     	; 0x2a66 <pow+0x70>
    2a52:	19 f0       	breq	.+6      	; 0x2a5a <pow+0x64>
    2a54:	ff 3a       	cpi	r31, 0xAF	; 175
    2a56:	38 f4       	brcc	.+14     	; 0x2a66 <pow+0x70>
    2a58:	9f 77       	andi	r25, 0x7F	; 127
    2a5a:	9f 93       	push	r25
    2a5c:	0c d0       	rcall	.+24     	; 0x2a76 <pow+0x80>
    2a5e:	0f 90       	pop	r0
    2a60:	07 fc       	sbrc	r0, 7
    2a62:	90 58       	subi	r25, 0x80	; 128
    2a64:	08 95       	ret
    2a66:	3e f0       	brts	.+14     	; 0x2a76 <pow+0x80>
    2a68:	18 cf       	rjmp	.-464    	; 0x289a <__fp_nan>
    2a6a:	60 e0       	ldi	r22, 0x00	; 0
    2a6c:	70 e0       	ldi	r23, 0x00	; 0
    2a6e:	80 e8       	ldi	r24, 0x80	; 128
    2a70:	9f e3       	ldi	r25, 0x3F	; 63
    2a72:	08 95       	ret
    2a74:	4f e7       	ldi	r20, 0x7F	; 127
    2a76:	9f 77       	andi	r25, 0x7F	; 127
    2a78:	5f 93       	push	r21
    2a7a:	4f 93       	push	r20
    2a7c:	3f 93       	push	r19
    2a7e:	2f 93       	push	r18
    2a80:	9e d0       	rcall	.+316    	; 0x2bbe <log>
    2a82:	2f 91       	pop	r18
    2a84:	3f 91       	pop	r19
    2a86:	4f 91       	pop	r20
    2a88:	5f 91       	pop	r21
    2a8a:	52 df       	rcall	.-348    	; 0x2930 <__mulsf3>
    2a8c:	05 c0       	rjmp	.+10     	; 0x2a98 <exp>
    2a8e:	19 f4       	brne	.+6      	; 0x2a96 <pow+0xa0>
    2a90:	0e f0       	brts	.+2      	; 0x2a94 <pow+0x9e>
    2a92:	fd ce       	rjmp	.-518    	; 0x288e <__fp_inf>
    2a94:	46 cf       	rjmp	.-372    	; 0x2922 <__fp_zero>
    2a96:	01 cf       	rjmp	.-510    	; 0x289a <__fp_nan>

00002a98 <exp>:
    2a98:	2a df       	rcall	.-428    	; 0x28ee <__fp_splitA>
    2a9a:	c8 f3       	brcs	.-14     	; 0x2a8e <pow+0x98>
    2a9c:	96 38       	cpi	r25, 0x86	; 134
    2a9e:	c0 f7       	brcc	.-16     	; 0x2a90 <pow+0x9a>
    2aa0:	07 f8       	bld	r0, 7
    2aa2:	0f 92       	push	r0
    2aa4:	e8 94       	clt
    2aa6:	2b e3       	ldi	r18, 0x3B	; 59
    2aa8:	3a ea       	ldi	r19, 0xAA	; 170
    2aaa:	48 eb       	ldi	r20, 0xB8	; 184
    2aac:	5f e7       	ldi	r21, 0x7F	; 127
    2aae:	4e df       	rcall	.-356    	; 0x294c <__mulsf3_pse>
    2ab0:	0f 92       	push	r0
    2ab2:	0f 92       	push	r0
    2ab4:	0f 92       	push	r0
    2ab6:	4d b7       	in	r20, 0x3d	; 61
    2ab8:	5e b7       	in	r21, 0x3e	; 62
    2aba:	0f 92       	push	r0
    2abc:	c0 d0       	rcall	.+384    	; 0x2c3e <modf>
    2abe:	e4 ee       	ldi	r30, 0xE4	; 228
    2ac0:	f0 e0       	ldi	r31, 0x00	; 0
    2ac2:	16 d0       	rcall	.+44     	; 0x2af0 <__fp_powser>
    2ac4:	4f 91       	pop	r20
    2ac6:	5f 91       	pop	r21
    2ac8:	ef 91       	pop	r30
    2aca:	ff 91       	pop	r31
    2acc:	e5 95       	asr	r30
    2ace:	ee 1f       	adc	r30, r30
    2ad0:	ff 1f       	adc	r31, r31
    2ad2:	49 f0       	breq	.+18     	; 0x2ae6 <exp+0x4e>
    2ad4:	fe 57       	subi	r31, 0x7E	; 126
    2ad6:	e0 68       	ori	r30, 0x80	; 128
    2ad8:	44 27       	eor	r20, r20
    2ada:	ee 0f       	add	r30, r30
    2adc:	44 1f       	adc	r20, r20
    2ade:	fa 95       	dec	r31
    2ae0:	e1 f7       	brne	.-8      	; 0x2ada <exp+0x42>
    2ae2:	41 95       	neg	r20
    2ae4:	55 0b       	sbc	r21, r21
    2ae6:	32 d0       	rcall	.+100    	; 0x2b4c <ldexp>
    2ae8:	0f 90       	pop	r0
    2aea:	07 fe       	sbrs	r0, 7
    2aec:	26 c0       	rjmp	.+76     	; 0x2b3a <inverse>
    2aee:	08 95       	ret

00002af0 <__fp_powser>:
    2af0:	df 93       	push	r29
    2af2:	cf 93       	push	r28
    2af4:	1f 93       	push	r17
    2af6:	0f 93       	push	r16
    2af8:	ff 92       	push	r15
    2afa:	ef 92       	push	r14
    2afc:	df 92       	push	r13
    2afe:	7b 01       	movw	r14, r22
    2b00:	8c 01       	movw	r16, r24
    2b02:	68 94       	set
    2b04:	05 c0       	rjmp	.+10     	; 0x2b10 <__fp_powser+0x20>
    2b06:	da 2e       	mov	r13, r26
    2b08:	ef 01       	movw	r28, r30
    2b0a:	1e df       	rcall	.-452    	; 0x2948 <__mulsf3x>
    2b0c:	fe 01       	movw	r30, r28
    2b0e:	e8 94       	clt
    2b10:	a5 91       	lpm	r26, Z+
    2b12:	25 91       	lpm	r18, Z+
    2b14:	35 91       	lpm	r19, Z+
    2b16:	45 91       	lpm	r20, Z+
    2b18:	55 91       	lpm	r21, Z+
    2b1a:	ae f3       	brts	.-22     	; 0x2b06 <__fp_powser+0x16>
    2b1c:	ef 01       	movw	r28, r30
    2b1e:	f6 dd       	rcall	.-1044   	; 0x270c <__addsf3x>
    2b20:	fe 01       	movw	r30, r28
    2b22:	97 01       	movw	r18, r14
    2b24:	a8 01       	movw	r20, r16
    2b26:	da 94       	dec	r13
    2b28:	79 f7       	brne	.-34     	; 0x2b08 <__fp_powser+0x18>
    2b2a:	df 90       	pop	r13
    2b2c:	ef 90       	pop	r14
    2b2e:	ff 90       	pop	r15
    2b30:	0f 91       	pop	r16
    2b32:	1f 91       	pop	r17
    2b34:	cf 91       	pop	r28
    2b36:	df 91       	pop	r29
    2b38:	08 95       	ret

00002b3a <inverse>:
    2b3a:	9b 01       	movw	r18, r22
    2b3c:	ac 01       	movw	r20, r24
    2b3e:	60 e0       	ldi	r22, 0x00	; 0
    2b40:	70 e0       	ldi	r23, 0x00	; 0
    2b42:	80 e8       	ldi	r24, 0x80	; 128
    2b44:	9f e3       	ldi	r25, 0x3F	; 63
    2b46:	ae c0       	rjmp	.+348    	; 0x2ca4 <__divsf3>
    2b48:	a2 ce       	rjmp	.-700    	; 0x288e <__fp_inf>
    2b4a:	14 c1       	rjmp	.+552    	; 0x2d74 <__fp_mpack>

00002b4c <ldexp>:
    2b4c:	d0 de       	rcall	.-608    	; 0x28ee <__fp_splitA>
    2b4e:	e8 f3       	brcs	.-6      	; 0x2b4a <inverse+0x10>
    2b50:	99 23       	and	r25, r25
    2b52:	d9 f3       	breq	.-10     	; 0x2b4a <inverse+0x10>
    2b54:	94 0f       	add	r25, r20
    2b56:	51 1d       	adc	r21, r1
    2b58:	bb f3       	brvs	.-18     	; 0x2b48 <inverse+0xe>
    2b5a:	91 50       	subi	r25, 0x01	; 1
    2b5c:	50 40       	sbci	r21, 0x00	; 0
    2b5e:	94 f0       	brlt	.+36     	; 0x2b84 <ldexp+0x38>
    2b60:	59 f0       	breq	.+22     	; 0x2b78 <ldexp+0x2c>
    2b62:	88 23       	and	r24, r24
    2b64:	32 f0       	brmi	.+12     	; 0x2b72 <ldexp+0x26>
    2b66:	66 0f       	add	r22, r22
    2b68:	77 1f       	adc	r23, r23
    2b6a:	88 1f       	adc	r24, r24
    2b6c:	91 50       	subi	r25, 0x01	; 1
    2b6e:	50 40       	sbci	r21, 0x00	; 0
    2b70:	c1 f7       	brne	.-16     	; 0x2b62 <ldexp+0x16>
    2b72:	9e 3f       	cpi	r25, 0xFE	; 254
    2b74:	51 05       	cpc	r21, r1
    2b76:	44 f7       	brge	.-48     	; 0x2b48 <inverse+0xe>
    2b78:	88 0f       	add	r24, r24
    2b7a:	91 1d       	adc	r25, r1
    2b7c:	96 95       	lsr	r25
    2b7e:	87 95       	ror	r24
    2b80:	97 f9       	bld	r25, 7
    2b82:	08 95       	ret
    2b84:	5f 3f       	cpi	r21, 0xFF	; 255
    2b86:	ac f0       	brlt	.+42     	; 0x2bb2 <ldexp+0x66>
    2b88:	98 3e       	cpi	r25, 0xE8	; 232
    2b8a:	9c f0       	brlt	.+38     	; 0x2bb2 <ldexp+0x66>
    2b8c:	bb 27       	eor	r27, r27
    2b8e:	86 95       	lsr	r24
    2b90:	77 95       	ror	r23
    2b92:	67 95       	ror	r22
    2b94:	b7 95       	ror	r27
    2b96:	08 f4       	brcc	.+2      	; 0x2b9a <ldexp+0x4e>
    2b98:	b1 60       	ori	r27, 0x01	; 1
    2b9a:	93 95       	inc	r25
    2b9c:	c1 f7       	brne	.-16     	; 0x2b8e <ldexp+0x42>
    2b9e:	bb 0f       	add	r27, r27
    2ba0:	58 f7       	brcc	.-42     	; 0x2b78 <ldexp+0x2c>
    2ba2:	11 f4       	brne	.+4      	; 0x2ba8 <ldexp+0x5c>
    2ba4:	60 ff       	sbrs	r22, 0
    2ba6:	e8 cf       	rjmp	.-48     	; 0x2b78 <ldexp+0x2c>
    2ba8:	6f 5f       	subi	r22, 0xFF	; 255
    2baa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bac:	8f 4f       	sbci	r24, 0xFF	; 255
    2bae:	9f 4f       	sbci	r25, 0xFF	; 255
    2bb0:	e3 cf       	rjmp	.-58     	; 0x2b78 <ldexp+0x2c>
    2bb2:	b8 ce       	rjmp	.-656    	; 0x2924 <__fp_szero>
    2bb4:	0e f0       	brts	.+2      	; 0x2bb8 <ldexp+0x6c>
    2bb6:	de c0       	rjmp	.+444    	; 0x2d74 <__fp_mpack>
    2bb8:	70 ce       	rjmp	.-800    	; 0x289a <__fp_nan>
    2bba:	68 94       	set
    2bbc:	68 ce       	rjmp	.-816    	; 0x288e <__fp_inf>

00002bbe <log>:
    2bbe:	97 de       	rcall	.-722    	; 0x28ee <__fp_splitA>
    2bc0:	c8 f3       	brcs	.-14     	; 0x2bb4 <ldexp+0x68>
    2bc2:	99 23       	and	r25, r25
    2bc4:	d1 f3       	breq	.-12     	; 0x2bba <ldexp+0x6e>
    2bc6:	c6 f3       	brts	.-16     	; 0x2bb8 <ldexp+0x6c>
    2bc8:	df 93       	push	r29
    2bca:	cf 93       	push	r28
    2bcc:	1f 93       	push	r17
    2bce:	0f 93       	push	r16
    2bd0:	ff 92       	push	r15
    2bd2:	c9 2f       	mov	r28, r25
    2bd4:	dd 27       	eor	r29, r29
    2bd6:	88 23       	and	r24, r24
    2bd8:	2a f0       	brmi	.+10     	; 0x2be4 <log+0x26>
    2bda:	21 97       	sbiw	r28, 0x01	; 1
    2bdc:	66 0f       	add	r22, r22
    2bde:	77 1f       	adc	r23, r23
    2be0:	88 1f       	adc	r24, r24
    2be2:	da f7       	brpl	.-10     	; 0x2bda <log+0x1c>
    2be4:	20 e0       	ldi	r18, 0x00	; 0
    2be6:	30 e0       	ldi	r19, 0x00	; 0
    2be8:	40 e8       	ldi	r20, 0x80	; 128
    2bea:	5f eb       	ldi	r21, 0xBF	; 191
    2bec:	9f e3       	ldi	r25, 0x3F	; 63
    2bee:	88 39       	cpi	r24, 0x98	; 152
    2bf0:	20 f0       	brcs	.+8      	; 0x2bfa <log+0x3c>
    2bf2:	80 3e       	cpi	r24, 0xE0	; 224
    2bf4:	30 f0       	brcs	.+12     	; 0x2c02 <log+0x44>
    2bf6:	21 96       	adiw	r28, 0x01	; 1
    2bf8:	8f 77       	andi	r24, 0x7F	; 127
    2bfa:	77 dd       	rcall	.-1298   	; 0x26ea <__addsf3>
    2bfc:	ec e0       	ldi	r30, 0x0C	; 12
    2bfe:	f1 e0       	ldi	r31, 0x01	; 1
    2c00:	03 c0       	rjmp	.+6      	; 0x2c08 <log+0x4a>
    2c02:	73 dd       	rcall	.-1306   	; 0x26ea <__addsf3>
    2c04:	e9 e3       	ldi	r30, 0x39	; 57
    2c06:	f1 e0       	ldi	r31, 0x01	; 1
    2c08:	73 df       	rcall	.-282    	; 0x2af0 <__fp_powser>
    2c0a:	8b 01       	movw	r16, r22
    2c0c:	be 01       	movw	r22, r28
    2c0e:	ec 01       	movw	r28, r24
    2c10:	fb 2e       	mov	r15, r27
    2c12:	6f 57       	subi	r22, 0x7F	; 127
    2c14:	71 09       	sbc	r23, r1
    2c16:	75 95       	asr	r23
    2c18:	77 1f       	adc	r23, r23
    2c1a:	88 0b       	sbc	r24, r24
    2c1c:	99 0b       	sbc	r25, r25
    2c1e:	fc dd       	rcall	.-1032   	; 0x2818 <__floatsisf>
    2c20:	28 e1       	ldi	r18, 0x18	; 24
    2c22:	32 e7       	ldi	r19, 0x72	; 114
    2c24:	41 e3       	ldi	r20, 0x31	; 49
    2c26:	5f e3       	ldi	r21, 0x3F	; 63
    2c28:	8f de       	rcall	.-738    	; 0x2948 <__mulsf3x>
    2c2a:	af 2d       	mov	r26, r15
    2c2c:	98 01       	movw	r18, r16
    2c2e:	ae 01       	movw	r20, r28
    2c30:	ff 90       	pop	r15
    2c32:	0f 91       	pop	r16
    2c34:	1f 91       	pop	r17
    2c36:	cf 91       	pop	r28
    2c38:	df 91       	pop	r29
    2c3a:	68 dd       	rcall	.-1328   	; 0x270c <__addsf3x>
    2c3c:	3f ce       	rjmp	.-898    	; 0x28bc <__fp_round>

00002c3e <modf>:
    2c3e:	fa 01       	movw	r30, r20
    2c40:	dc 01       	movw	r26, r24
    2c42:	aa 0f       	add	r26, r26
    2c44:	bb 1f       	adc	r27, r27
    2c46:	9b 01       	movw	r18, r22
    2c48:	ac 01       	movw	r20, r24
    2c4a:	bf 57       	subi	r27, 0x7F	; 127
    2c4c:	28 f4       	brcc	.+10     	; 0x2c58 <modf+0x1a>
    2c4e:	22 27       	eor	r18, r18
    2c50:	33 27       	eor	r19, r19
    2c52:	44 27       	eor	r20, r20
    2c54:	50 78       	andi	r21, 0x80	; 128
    2c56:	1f c0       	rjmp	.+62     	; 0x2c96 <modf+0x58>
    2c58:	b7 51       	subi	r27, 0x17	; 23
    2c5a:	88 f4       	brcc	.+34     	; 0x2c7e <modf+0x40>
    2c5c:	ab 2f       	mov	r26, r27
    2c5e:	00 24       	eor	r0, r0
    2c60:	46 95       	lsr	r20
    2c62:	37 95       	ror	r19
    2c64:	27 95       	ror	r18
    2c66:	01 1c       	adc	r0, r1
    2c68:	a3 95       	inc	r26
    2c6a:	d2 f3       	brmi	.-12     	; 0x2c60 <modf+0x22>
    2c6c:	00 20       	and	r0, r0
    2c6e:	69 f0       	breq	.+26     	; 0x2c8a <modf+0x4c>
    2c70:	22 0f       	add	r18, r18
    2c72:	33 1f       	adc	r19, r19
    2c74:	44 1f       	adc	r20, r20
    2c76:	b3 95       	inc	r27
    2c78:	da f3       	brmi	.-10     	; 0x2c70 <modf+0x32>
    2c7a:	0d d0       	rcall	.+26     	; 0x2c96 <modf+0x58>
    2c7c:	35 cd       	rjmp	.-1430   	; 0x26e8 <__subsf3>
    2c7e:	61 30       	cpi	r22, 0x01	; 1
    2c80:	71 05       	cpc	r23, r1
    2c82:	a0 e8       	ldi	r26, 0x80	; 128
    2c84:	8a 07       	cpc	r24, r26
    2c86:	b9 46       	sbci	r27, 0x69	; 105
    2c88:	30 f4       	brcc	.+12     	; 0x2c96 <modf+0x58>
    2c8a:	9b 01       	movw	r18, r22
    2c8c:	ac 01       	movw	r20, r24
    2c8e:	66 27       	eor	r22, r22
    2c90:	77 27       	eor	r23, r23
    2c92:	88 27       	eor	r24, r24
    2c94:	90 78       	andi	r25, 0x80	; 128
    2c96:	30 96       	adiw	r30, 0x00	; 0
    2c98:	21 f0       	breq	.+8      	; 0x2ca2 <modf+0x64>
    2c9a:	20 83       	st	Z, r18
    2c9c:	31 83       	std	Z+1, r19	; 0x01
    2c9e:	42 83       	std	Z+2, r20	; 0x02
    2ca0:	53 83       	std	Z+3, r21	; 0x03
    2ca2:	08 95       	ret

00002ca4 <__divsf3>:
    2ca4:	0c d0       	rcall	.+24     	; 0x2cbe <__divsf3x>
    2ca6:	0a ce       	rjmp	.-1004   	; 0x28bc <__fp_round>
    2ca8:	02 de       	rcall	.-1020   	; 0x28ae <__fp_pscB>
    2caa:	40 f0       	brcs	.+16     	; 0x2cbc <__divsf3+0x18>
    2cac:	f9 dd       	rcall	.-1038   	; 0x28a0 <__fp_pscA>
    2cae:	30 f0       	brcs	.+12     	; 0x2cbc <__divsf3+0x18>
    2cb0:	21 f4       	brne	.+8      	; 0x2cba <__divsf3+0x16>
    2cb2:	5f 3f       	cpi	r21, 0xFF	; 255
    2cb4:	19 f0       	breq	.+6      	; 0x2cbc <__divsf3+0x18>
    2cb6:	eb cd       	rjmp	.-1066   	; 0x288e <__fp_inf>
    2cb8:	51 11       	cpse	r21, r1
    2cba:	34 ce       	rjmp	.-920    	; 0x2924 <__fp_szero>
    2cbc:	ee cd       	rjmp	.-1060   	; 0x289a <__fp_nan>

00002cbe <__divsf3x>:
    2cbe:	0f de       	rcall	.-994    	; 0x28de <__fp_split3>
    2cc0:	98 f3       	brcs	.-26     	; 0x2ca8 <__divsf3+0x4>

00002cc2 <__divsf3_pse>:
    2cc2:	99 23       	and	r25, r25
    2cc4:	c9 f3       	breq	.-14     	; 0x2cb8 <__divsf3+0x14>
    2cc6:	55 23       	and	r21, r21
    2cc8:	b1 f3       	breq	.-20     	; 0x2cb6 <__divsf3+0x12>
    2cca:	95 1b       	sub	r25, r21
    2ccc:	55 0b       	sbc	r21, r21
    2cce:	bb 27       	eor	r27, r27
    2cd0:	aa 27       	eor	r26, r26
    2cd2:	62 17       	cp	r22, r18
    2cd4:	73 07       	cpc	r23, r19
    2cd6:	84 07       	cpc	r24, r20
    2cd8:	38 f0       	brcs	.+14     	; 0x2ce8 <__divsf3_pse+0x26>
    2cda:	9f 5f       	subi	r25, 0xFF	; 255
    2cdc:	5f 4f       	sbci	r21, 0xFF	; 255
    2cde:	22 0f       	add	r18, r18
    2ce0:	33 1f       	adc	r19, r19
    2ce2:	44 1f       	adc	r20, r20
    2ce4:	aa 1f       	adc	r26, r26
    2ce6:	a9 f3       	breq	.-22     	; 0x2cd2 <__divsf3_pse+0x10>
    2ce8:	33 d0       	rcall	.+102    	; 0x2d50 <__divsf3_pse+0x8e>
    2cea:	0e 2e       	mov	r0, r30
    2cec:	3a f0       	brmi	.+14     	; 0x2cfc <__divsf3_pse+0x3a>
    2cee:	e0 e8       	ldi	r30, 0x80	; 128
    2cf0:	30 d0       	rcall	.+96     	; 0x2d52 <__divsf3_pse+0x90>
    2cf2:	91 50       	subi	r25, 0x01	; 1
    2cf4:	50 40       	sbci	r21, 0x00	; 0
    2cf6:	e6 95       	lsr	r30
    2cf8:	00 1c       	adc	r0, r0
    2cfa:	ca f7       	brpl	.-14     	; 0x2cee <__divsf3_pse+0x2c>
    2cfc:	29 d0       	rcall	.+82     	; 0x2d50 <__divsf3_pse+0x8e>
    2cfe:	fe 2f       	mov	r31, r30
    2d00:	27 d0       	rcall	.+78     	; 0x2d50 <__divsf3_pse+0x8e>
    2d02:	66 0f       	add	r22, r22
    2d04:	77 1f       	adc	r23, r23
    2d06:	88 1f       	adc	r24, r24
    2d08:	bb 1f       	adc	r27, r27
    2d0a:	26 17       	cp	r18, r22
    2d0c:	37 07       	cpc	r19, r23
    2d0e:	48 07       	cpc	r20, r24
    2d10:	ab 07       	cpc	r26, r27
    2d12:	b0 e8       	ldi	r27, 0x80	; 128
    2d14:	09 f0       	breq	.+2      	; 0x2d18 <__divsf3_pse+0x56>
    2d16:	bb 0b       	sbc	r27, r27
    2d18:	80 2d       	mov	r24, r0
    2d1a:	bf 01       	movw	r22, r30
    2d1c:	ff 27       	eor	r31, r31
    2d1e:	93 58       	subi	r25, 0x83	; 131
    2d20:	5f 4f       	sbci	r21, 0xFF	; 255
    2d22:	2a f0       	brmi	.+10     	; 0x2d2e <__divsf3_pse+0x6c>
    2d24:	9e 3f       	cpi	r25, 0xFE	; 254
    2d26:	51 05       	cpc	r21, r1
    2d28:	68 f0       	brcs	.+26     	; 0x2d44 <__divsf3_pse+0x82>
    2d2a:	b1 cd       	rjmp	.-1182   	; 0x288e <__fp_inf>
    2d2c:	fb cd       	rjmp	.-1034   	; 0x2924 <__fp_szero>
    2d2e:	5f 3f       	cpi	r21, 0xFF	; 255
    2d30:	ec f3       	brlt	.-6      	; 0x2d2c <__divsf3_pse+0x6a>
    2d32:	98 3e       	cpi	r25, 0xE8	; 232
    2d34:	dc f3       	brlt	.-10     	; 0x2d2c <__divsf3_pse+0x6a>
    2d36:	86 95       	lsr	r24
    2d38:	77 95       	ror	r23
    2d3a:	67 95       	ror	r22
    2d3c:	b7 95       	ror	r27
    2d3e:	f7 95       	ror	r31
    2d40:	9f 5f       	subi	r25, 0xFF	; 255
    2d42:	c9 f7       	brne	.-14     	; 0x2d36 <__divsf3_pse+0x74>
    2d44:	88 0f       	add	r24, r24
    2d46:	91 1d       	adc	r25, r1
    2d48:	96 95       	lsr	r25
    2d4a:	87 95       	ror	r24
    2d4c:	97 f9       	bld	r25, 7
    2d4e:	08 95       	ret
    2d50:	e1 e0       	ldi	r30, 0x01	; 1
    2d52:	66 0f       	add	r22, r22
    2d54:	77 1f       	adc	r23, r23
    2d56:	88 1f       	adc	r24, r24
    2d58:	bb 1f       	adc	r27, r27
    2d5a:	62 17       	cp	r22, r18
    2d5c:	73 07       	cpc	r23, r19
    2d5e:	84 07       	cpc	r24, r20
    2d60:	ba 07       	cpc	r27, r26
    2d62:	20 f0       	brcs	.+8      	; 0x2d6c <__divsf3_pse+0xaa>
    2d64:	62 1b       	sub	r22, r18
    2d66:	73 0b       	sbc	r23, r19
    2d68:	84 0b       	sbc	r24, r20
    2d6a:	ba 0b       	sbc	r27, r26
    2d6c:	ee 1f       	adc	r30, r30
    2d6e:	88 f7       	brcc	.-30     	; 0x2d52 <__divsf3_pse+0x90>
    2d70:	e0 95       	com	r30
    2d72:	08 95       	ret

00002d74 <__fp_mpack>:
    2d74:	9f 3f       	cpi	r25, 0xFF	; 255
    2d76:	31 f0       	breq	.+12     	; 0x2d84 <__fp_mpack_finite+0xc>

00002d78 <__fp_mpack_finite>:
    2d78:	91 50       	subi	r25, 0x01	; 1
    2d7a:	20 f4       	brcc	.+8      	; 0x2d84 <__fp_mpack_finite+0xc>
    2d7c:	87 95       	ror	r24
    2d7e:	77 95       	ror	r23
    2d80:	67 95       	ror	r22
    2d82:	b7 95       	ror	r27
    2d84:	88 0f       	add	r24, r24
    2d86:	91 1d       	adc	r25, r1
    2d88:	96 95       	lsr	r25
    2d8a:	87 95       	ror	r24
    2d8c:	97 f9       	bld	r25, 7
    2d8e:	08 95       	ret

00002d90 <__divmodhi4>:
    2d90:	97 fb       	bst	r25, 7
    2d92:	07 2e       	mov	r0, r23
    2d94:	16 f4       	brtc	.+4      	; 0x2d9a <__divmodhi4+0xa>
    2d96:	00 94       	com	r0
    2d98:	06 d0       	rcall	.+12     	; 0x2da6 <__divmodhi4_neg1>
    2d9a:	77 fd       	sbrc	r23, 7
    2d9c:	08 d0       	rcall	.+16     	; 0x2dae <__divmodhi4_neg2>
    2d9e:	0b d0       	rcall	.+22     	; 0x2db6 <__udivmodhi4>
    2da0:	07 fc       	sbrc	r0, 7
    2da2:	05 d0       	rcall	.+10     	; 0x2dae <__divmodhi4_neg2>
    2da4:	3e f4       	brtc	.+14     	; 0x2db4 <__divmodhi4_exit>

00002da6 <__divmodhi4_neg1>:
    2da6:	90 95       	com	r25
    2da8:	81 95       	neg	r24
    2daa:	9f 4f       	sbci	r25, 0xFF	; 255
    2dac:	08 95       	ret

00002dae <__divmodhi4_neg2>:
    2dae:	70 95       	com	r23
    2db0:	61 95       	neg	r22
    2db2:	7f 4f       	sbci	r23, 0xFF	; 255

00002db4 <__divmodhi4_exit>:
    2db4:	08 95       	ret

00002db6 <__udivmodhi4>:
    2db6:	aa 1b       	sub	r26, r26
    2db8:	bb 1b       	sub	r27, r27
    2dba:	51 e1       	ldi	r21, 0x11	; 17
    2dbc:	07 c0       	rjmp	.+14     	; 0x2dcc <__udivmodhi4_ep>

00002dbe <__udivmodhi4_loop>:
    2dbe:	aa 1f       	adc	r26, r26
    2dc0:	bb 1f       	adc	r27, r27
    2dc2:	a6 17       	cp	r26, r22
    2dc4:	b7 07       	cpc	r27, r23
    2dc6:	10 f0       	brcs	.+4      	; 0x2dcc <__udivmodhi4_ep>
    2dc8:	a6 1b       	sub	r26, r22
    2dca:	b7 0b       	sbc	r27, r23

00002dcc <__udivmodhi4_ep>:
    2dcc:	88 1f       	adc	r24, r24
    2dce:	99 1f       	adc	r25, r25
    2dd0:	5a 95       	dec	r21
    2dd2:	a9 f7       	brne	.-22     	; 0x2dbe <__udivmodhi4_loop>
    2dd4:	80 95       	com	r24
    2dd6:	90 95       	com	r25
    2dd8:	bc 01       	movw	r22, r24
    2dda:	cd 01       	movw	r24, r26
    2ddc:	08 95       	ret

00002dde <memcpy>:
    2dde:	fb 01       	movw	r30, r22
    2de0:	dc 01       	movw	r26, r24
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <memcpy+0xa>
    2de4:	01 90       	ld	r0, Z+
    2de6:	0d 92       	st	X+, r0
    2de8:	41 50       	subi	r20, 0x01	; 1
    2dea:	50 40       	sbci	r21, 0x00	; 0
    2dec:	d8 f7       	brcc	.-10     	; 0x2de4 <memcpy+0x6>
    2dee:	08 95       	ret

00002df0 <_exit>:
    2df0:	f8 94       	cli

00002df2 <__stop_program>:
    2df2:	ff cf       	rjmp	.-2      	; 0x2df2 <__stop_program>
