
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800200  00001eea  00001f7e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001eea  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006ec  0080028c  0080028c  0000200a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000200a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000470  00000000  00000000  0000203a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004d8e  00000000  00000000  000024aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000120c  00000000  00000000  00007238  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002f0d  00000000  00000000  00008444  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c78  00000000  00000000  0000b354  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001330  00000000  00000000  0000bfcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000034f9  00000000  00000000  0000d2fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000430  00000000  00000000  000107f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	4e c6       	rjmp	.+3228   	; 0xcf2 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	7a c3       	rjmp	.+1780   	; 0x75a <__vector_25>
      66:	00 00       	nop
      68:	e6 c3       	rjmp	.+1996   	; 0x836 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	5c c2       	rjmp	.+1208   	; 0x52e <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2c c3       	rjmp	.+1624   	; 0x6ea <__vector_36>
      92:	00 00       	nop
      94:	9a c3       	rjmp	.+1844   	; 0x7ca <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ea ee       	ldi	r30, 0xEA	; 234
      fc:	fe e1       	ldi	r31, 0x1E	; 30
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 38       	cpi	r26, 0x8C	; 140
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ac e8       	ldi	r26, 0x8C	; 140
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a8 37       	cpi	r26, 0x78	; 120
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	ce d0       	rcall	.+412    	; 0x2bc <main>
     120:	0c 94 73 0f 	jmp	0x1ee6	; 0x1ee6 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	4d d4       	rcall	.+2202   	; 0x9f2 <waitForHandshake>
     158:	83 e0       	ldi	r24, 0x03	; 3
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	10 c4       	rjmp	.+2080   	; 0x97e <transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	3d d4       	rcall	.+2170   	; 0x9dc <startHandShake>
     162:	8a e1       	ldi	r24, 0x1A	; 26
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	0b c4       	rjmp	.+2070   	; 0x97e <transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a6 97       	sbiw	r28, 0x26	; 38
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e0 e3       	ldi	r30, 0x30	; 48
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	15 96       	adiw	r26, 0x05	; 5
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	e8 e3       	ldi	r30, 0x38	; 56
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1d 96       	adiw	r26, 0x0d	; 13
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	ef e3       	ldi	r30, 0x3F	; 63
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	54 96       	adiw	r26, 0x14	; 20
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	e7 e4       	ldi	r30, 0x47	; 71
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5c 96       	adiw	r26, 0x1c	; 28
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	ed e4       	ldi	r30, 0x4D	; 77
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	92 96       	adiw	r26, 0x22	; 34
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	99 d1       	rcall	.+818    	; 0x50c <MaxSonar_Start>
     1da:	87 e2       	ldi	r24, 0x27	; 39
     1dc:	9e d1       	rcall	.+828    	; 0x51a <MaxSonar_Read>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6f 5f       	subi	r22, 0xFF	; 255
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <__itoa_ncheck>
     1ea:	ce 01       	movw	r24, r28
     1ec:	05 96       	adiw	r24, 0x05	; 5
     1ee:	c7 d3       	rcall	.+1934   	; 0x97e <transmitUSART0>
     1f0:	ce 01       	movw	r24, r28
     1f2:	01 96       	adiw	r24, 0x01	; 1
     1f4:	c4 d3       	rcall	.+1928   	; 0x97e <transmitUSART0>
     1f6:	ce 01       	movw	r24, r28
     1f8:	4c 96       	adiw	r24, 0x1c	; 28
     1fa:	c1 d3       	rcall	.+1922   	; 0x97e <transmitUSART0>
     1fc:	86 e2       	ldi	r24, 0x26	; 38
     1fe:	8d d1       	rcall	.+794    	; 0x51a <MaxSonar_Read>
     200:	4a e0       	ldi	r20, 0x0A	; 10
     202:	be 01       	movw	r22, r28
     204:	6f 5f       	subi	r22, 0xFF	; 255
     206:	7f 4f       	sbci	r23, 0xFF	; 255
     208:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <__itoa_ncheck>
     20c:	ce 01       	movw	r24, r28
     20e:	0d 96       	adiw	r24, 0x0d	; 13
     210:	b6 d3       	rcall	.+1900   	; 0x97e <transmitUSART0>
     212:	ce 01       	movw	r24, r28
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	b3 d3       	rcall	.+1894   	; 0x97e <transmitUSART0>
     218:	ce 01       	movw	r24, r28
     21a:	4c 96       	adiw	r24, 0x1c	; 28
     21c:	b0 d3       	rcall	.+1888   	; 0x97e <transmitUSART0>
     21e:	85 e2       	ldi	r24, 0x25	; 37
     220:	7c d1       	rcall	.+760    	; 0x51a <MaxSonar_Read>
     222:	4a e0       	ldi	r20, 0x0A	; 10
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	0a 97       	sbiw	r24, 0x0a	; 10
     22c:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <__itoa_ncheck>
     230:	ce 01       	movw	r24, r28
     232:	44 96       	adiw	r24, 0x14	; 20
     234:	a4 d3       	rcall	.+1864   	; 0x97e <transmitUSART0>
     236:	ce 01       	movw	r24, r28
     238:	01 96       	adiw	r24, 0x01	; 1
     23a:	a1 d3       	rcall	.+1858   	; 0x97e <transmitUSART0>
     23c:	ce 01       	movw	r24, r28
     23e:	82 96       	adiw	r24, 0x22	; 34
     240:	9e d3       	rcall	.+1852   	; 0x97e <transmitUSART0>
     242:	86 e9       	ldi	r24, 0x96	; 150
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 a8 0c 	call	0x1950	; 0x1950 <vTaskDelay>
     24a:	c6 cf       	rjmp	.-116    	; 0x1d8 <maxSonarTask+0x6e>

0000024c <myTimerTask>:
     24c:	3a d2       	rcall	.+1140   	; 0x6c2 <delayMicroCheck>
     24e:	fe cf       	rjmp	.-4      	; 0x24c <myTimerTask>

00000250 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     250:	8c ec       	ldi	r24, 0xCC	; 204
     252:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     256:	8e e3       	ldi	r24, 0x3E	; 62
     258:	80 93 65 00 	sts	0x0065, r24
     25c:	08 95       	ret

0000025e <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     25e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     262:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     266:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     26a:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     26e:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     272:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     276:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     27a:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     27e:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     282:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     286:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     28a:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     28e:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     292:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     296:	10 92 73 00 	sts	0x0073, r1
     29a:	08 95       	ret

0000029c <init>:
}

void init()
{
     29c:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     29e:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2a0:	f8 94       	cli
	{
		clearTimer();
     2a2:	dd df       	rcall	.-70     	; 0x25e <clearTimer>
		setPowerReduction();
     2a4:	d5 df       	rcall	.-86     	; 0x250 <setPowerReduction>
		USART0_Init();
     2a6:	fd d2       	rcall	.+1530   	; 0x8a2 <USART0_Init>
		USART1_Init();
     2a8:	1c d3       	rcall	.+1592   	; 0x8e2 <USART1_Init>
		ADC_Init();
     2aa:	75 d1       	rcall	.+746    	; 0x596 <ADC_Init>
		MaxSonar_Init();
     2ac:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2ae:	84 b1       	in	r24, 0x04	; 4
     2b0:	80 6c       	ori	r24, 0xC0	; 192
     2b2:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2b4:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2b6:	78 94       	sei
}
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <main>:
	
	// do nth
}

int main(void)
{
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	cd b7       	in	r28, 0x3d	; 61
     2c2:	de b7       	in	r29, 0x3e	; 62
     2c4:	2c 97       	sbiw	r28, 0x0c	; 12
     2c6:	0f b6       	in	r0, 0x3f	; 63
     2c8:	f8 94       	cli
     2ca:	de bf       	out	0x3e, r29	; 62
     2cc:	0f be       	out	0x3f, r0	; 63
     2ce:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2d0:	e5 df       	rcall	.-54     	; 0x29c <init>
		
		MyTimer_Init(&t_delay);	
     2d2:	ce 01       	movw	r24, r28
     2d4:	01 96       	adiw	r24, 0x01	; 1
     2d6:	c3 d1       	rcall	.+902    	; 0x65e <MyTimer_Init>
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, NULL, MY_TIMER_PRIORITY, &t_delay); // danger?!?
     2d8:	a1 2c       	mov	r10, r1
     2da:	b1 2c       	mov	r11, r1
     2dc:	c1 2c       	mov	r12, r1
     2de:	d1 2c       	mov	r13, r1
     2e0:	ce 01       	movw	r24, r28
     2e2:	01 96       	adiw	r24, 0x01	; 1
     2e4:	7c 01       	movw	r14, r24
     2e6:	04 e0       	ldi	r16, 0x04	; 4
     2e8:	20 e0       	ldi	r18, 0x00	; 0
     2ea:	30 e0       	ldi	r19, 0x00	; 0
     2ec:	49 e6       	ldi	r20, 0x69	; 105
     2ee:	50 e0       	ldi	r21, 0x00	; 0
     2f0:	62 e5       	ldi	r22, 0x52	; 82
     2f2:	72 e0       	ldi	r23, 0x02	; 2
     2f4:	86 e2       	ldi	r24, 0x26	; 38
     2f6:	91 e0       	ldi	r25, 0x01	; 1
     2f8:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     2fc:	ce 01       	movw	r24, r28
     2fe:	07 96       	adiw	r24, 0x07	; 7
     300:	7c 01       	movw	r14, r24
     302:	02 e0       	ldi	r16, 0x02	; 2
     304:	20 e0       	ldi	r18, 0x00	; 0
     306:	30 e0       	ldi	r19, 0x00	; 0
     308:	4d e1       	ldi	r20, 0x1D	; 29
     30a:	51 e0       	ldi	r21, 0x01	; 1
     30c:	6a e5       	ldi	r22, 0x5A	; 90
     30e:	72 e0       	ldi	r23, 0x02	; 2
     310:	85 eb       	ldi	r24, 0xB5	; 181
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     318:	ce 01       	movw	r24, r28
     31a:	0b 96       	adiw	r24, 0x0b	; 11
     31c:	7c 01       	movw	r14, r24
     31e:	01 e0       	ldi	r16, 0x01	; 1
     320:	20 e0       	ldi	r18, 0x00	; 0
     322:	30 e0       	ldi	r19, 0x00	; 0
     324:	49 e6       	ldi	r20, 0x69	; 105
     326:	50 e0       	ldi	r21, 0x00	; 0
     328:	63 e6       	ldi	r22, 0x63	; 99
     32a:	72 e0       	ldi	r23, 0x02	; 2
     32c:	83 e9       	ldi	r24, 0x93	; 147
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     334:	ce 01       	movw	r24, r28
     336:	09 96       	adiw	r24, 0x09	; 9
     338:	7c 01       	movw	r14, r24
     33a:	20 e0       	ldi	r18, 0x00	; 0
     33c:	30 e0       	ldi	r19, 0x00	; 0
     33e:	49 e6       	ldi	r20, 0x69	; 105
     340:	50 e0       	ldi	r21, 0x00	; 0
     342:	6a e6       	ldi	r22, 0x6A	; 106
     344:	72 e0       	ldi	r23, 0x02	; 2
     346:	8f e9       	ldi	r24, 0x9F	; 159
     348:	90 e0       	ldi	r25, 0x00	; 0
     34a:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     34e:	ce 01       	movw	r24, r28
     350:	05 96       	adiw	r24, 0x05	; 5
     352:	7c 01       	movw	r14, r24
     354:	03 e0       	ldi	r16, 0x03	; 3
     356:	20 e0       	ldi	r18, 0x00	; 0
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	47 e8       	ldi	r20, 0x87	; 135
     35c:	50 e0       	ldi	r21, 0x00	; 0
     35e:	61 e7       	ldi	r22, 0x71	; 113
     360:	72 e0       	ldi	r23, 0x02	; 2
     362:	8b ea       	ldi	r24, 0xAB	; 171
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     36a:	ce 01       	movw	r24, r28
     36c:	03 96       	adiw	r24, 0x03	; 3
     36e:	7c 01       	movw	r14, r24
     370:	02 e0       	ldi	r16, 0x02	; 2
     372:	20 e0       	ldi	r18, 0x00	; 0
     374:	30 e0       	ldi	r19, 0x00	; 0
     376:	47 e8       	ldi	r20, 0x87	; 135
     378:	50 e0       	ldi	r21, 0x00	; 0
     37a:	6d e7       	ldi	r22, 0x7D	; 125
     37c:	72 e0       	ldi	r23, 0x02	; 2
     37e:	80 eb       	ldi	r24, 0xB0	; 176
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 da 09 	call	0x13b4	; 0x13b4 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     386:	0e 94 3a 0b 	call	0x1674	; 0x1674 <vTaskStartScheduler>
     38a:	a2 cf       	rjmp	.-188    	; 0x2d0 <main+0x14>

0000038c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     38c:	cf 93       	push	r28
     38e:	df 93       	push	r29
     390:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     392:	0e 94 63 0b 	call	0x16c6	; 0x16c6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     396:	80 91 8c 02 	lds	r24, 0x028C
     39a:	90 91 8d 02 	lds	r25, 0x028D
     39e:	89 2b       	or	r24, r25
     3a0:	31 f4       	brne	.+12     	; 0x3ae <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3a2:	81 e9       	ldi	r24, 0x91	; 145
     3a4:	92 e0       	ldi	r25, 0x02	; 2
     3a6:	90 93 8d 02 	sts	0x028D, r25
     3aa:	80 93 8c 02 	sts	0x028C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3ae:	40 91 8e 02 	lds	r20, 0x028E
     3b2:	50 91 8f 02 	lds	r21, 0x028F
     3b6:	9e 01       	movw	r18, r28
     3b8:	24 0f       	add	r18, r20
     3ba:	35 1f       	adc	r19, r21
     3bc:	2b 3d       	cpi	r18, 0xDB	; 219
     3be:	85 e0       	ldi	r24, 0x05	; 5
     3c0:	38 07       	cpc	r19, r24
     3c2:	70 f4       	brcc	.+28     	; 0x3e0 <pvPortMalloc+0x54>
     3c4:	42 17       	cp	r20, r18
     3c6:	53 07       	cpc	r21, r19
     3c8:	70 f4       	brcc	.+28     	; 0x3e6 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3ca:	c0 91 8c 02 	lds	r28, 0x028C
     3ce:	d0 91 8d 02 	lds	r29, 0x028D
     3d2:	c4 0f       	add	r28, r20
     3d4:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3d6:	30 93 8f 02 	sts	0x028F, r19
     3da:	20 93 8e 02 	sts	0x028E, r18
     3de:	05 c0       	rjmp	.+10     	; 0x3ea <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3e0:	c0 e0       	ldi	r28, 0x00	; 0
     3e2:	d0 e0       	ldi	r29, 0x00	; 0
     3e4:	02 c0       	rjmp	.+4      	; 0x3ea <pvPortMalloc+0x5e>
     3e6:	c0 e0       	ldi	r28, 0x00	; 0
     3e8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3ea:	0e 94 27 0c 	call	0x184e	; 0x184e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3ee:	ce 01       	movw	r24, r28
     3f0:	df 91       	pop	r29
     3f2:	cf 91       	pop	r28
     3f4:	08 95       	ret

000003f6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3f6:	08 95       	ret

000003f8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3f8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3fa:	03 96       	adiw	r24, 0x03	; 3
     3fc:	92 83       	std	Z+2, r25	; 0x02
     3fe:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     400:	2f ef       	ldi	r18, 0xFF	; 255
     402:	3f ef       	ldi	r19, 0xFF	; 255
     404:	34 83       	std	Z+4, r19	; 0x04
     406:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     408:	96 83       	std	Z+6, r25	; 0x06
     40a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     40c:	90 87       	std	Z+8, r25	; 0x08
     40e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     410:	10 82       	st	Z, r1
     412:	08 95       	ret

00000414 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     414:	fc 01       	movw	r30, r24
     416:	11 86       	std	Z+9, r1	; 0x09
     418:	10 86       	std	Z+8, r1	; 0x08
     41a:	08 95       	ret

0000041c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     41c:	cf 93       	push	r28
     41e:	df 93       	push	r29
     420:	9c 01       	movw	r18, r24
     422:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     424:	dc 01       	movw	r26, r24
     426:	11 96       	adiw	r26, 0x01	; 1
     428:	cd 91       	ld	r28, X+
     42a:	dc 91       	ld	r29, X
     42c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     42e:	d3 83       	std	Z+3, r29	; 0x03
     430:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     432:	8c 81       	ldd	r24, Y+4	; 0x04
     434:	9d 81       	ldd	r25, Y+5	; 0x05
     436:	95 83       	std	Z+5, r25	; 0x05
     438:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     43a:	8c 81       	ldd	r24, Y+4	; 0x04
     43c:	9d 81       	ldd	r25, Y+5	; 0x05
     43e:	dc 01       	movw	r26, r24
     440:	13 96       	adiw	r26, 0x03	; 3
     442:	7c 93       	st	X, r23
     444:	6e 93       	st	-X, r22
     446:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     448:	7d 83       	std	Y+5, r23	; 0x05
     44a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     44c:	31 87       	std	Z+9, r19	; 0x09
     44e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     450:	f9 01       	movw	r30, r18
     452:	80 81       	ld	r24, Z
     454:	8f 5f       	subi	r24, 0xFF	; 255
     456:	80 83       	st	Z, r24
}
     458:	df 91       	pop	r29
     45a:	cf 91       	pop	r28
     45c:	08 95       	ret

0000045e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     45e:	cf 93       	push	r28
     460:	df 93       	push	r29
     462:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     464:	48 81       	ld	r20, Y
     466:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     468:	4f 3f       	cpi	r20, 0xFF	; 255
     46a:	2f ef       	ldi	r18, 0xFF	; 255
     46c:	52 07       	cpc	r21, r18
     46e:	21 f4       	brne	.+8      	; 0x478 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     470:	fc 01       	movw	r30, r24
     472:	a7 81       	ldd	r26, Z+7	; 0x07
     474:	b0 85       	ldd	r27, Z+8	; 0x08
     476:	0d c0       	rjmp	.+26     	; 0x492 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     478:	dc 01       	movw	r26, r24
     47a:	13 96       	adiw	r26, 0x03	; 3
     47c:	12 96       	adiw	r26, 0x02	; 2
     47e:	ed 91       	ld	r30, X+
     480:	fc 91       	ld	r31, X
     482:	13 97       	sbiw	r26, 0x03	; 3
     484:	20 81       	ld	r18, Z
     486:	31 81       	ldd	r19, Z+1	; 0x01
     488:	42 17       	cp	r20, r18
     48a:	53 07       	cpc	r21, r19
     48c:	10 f0       	brcs	.+4      	; 0x492 <vListInsert+0x34>
     48e:	df 01       	movw	r26, r30
     490:	f5 cf       	rjmp	.-22     	; 0x47c <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     492:	12 96       	adiw	r26, 0x02	; 2
     494:	ed 91       	ld	r30, X+
     496:	fc 91       	ld	r31, X
     498:	13 97       	sbiw	r26, 0x03	; 3
     49a:	fb 83       	std	Y+3, r31	; 0x03
     49c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     49e:	d5 83       	std	Z+5, r29	; 0x05
     4a0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4a2:	bd 83       	std	Y+5, r27	; 0x05
     4a4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4a6:	13 96       	adiw	r26, 0x03	; 3
     4a8:	dc 93       	st	X, r29
     4aa:	ce 93       	st	-X, r28
     4ac:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4ae:	99 87       	std	Y+9, r25	; 0x09
     4b0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4b2:	fc 01       	movw	r30, r24
     4b4:	20 81       	ld	r18, Z
     4b6:	2f 5f       	subi	r18, 0xFF	; 255
     4b8:	20 83       	st	Z, r18
}
     4ba:	df 91       	pop	r29
     4bc:	cf 91       	pop	r28
     4be:	08 95       	ret

000004c0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4c6:	a0 85       	ldd	r26, Z+8	; 0x08
     4c8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4ca:	c2 81       	ldd	r28, Z+2	; 0x02
     4cc:	d3 81       	ldd	r29, Z+3	; 0x03
     4ce:	84 81       	ldd	r24, Z+4	; 0x04
     4d0:	95 81       	ldd	r25, Z+5	; 0x05
     4d2:	9d 83       	std	Y+5, r25	; 0x05
     4d4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4d6:	c4 81       	ldd	r28, Z+4	; 0x04
     4d8:	d5 81       	ldd	r29, Z+5	; 0x05
     4da:	82 81       	ldd	r24, Z+2	; 0x02
     4dc:	93 81       	ldd	r25, Z+3	; 0x03
     4de:	9b 83       	std	Y+3, r25	; 0x03
     4e0:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4e2:	11 96       	adiw	r26, 0x01	; 1
     4e4:	cd 91       	ld	r28, X+
     4e6:	dc 91       	ld	r29, X
     4e8:	12 97       	sbiw	r26, 0x02	; 2
     4ea:	ce 17       	cp	r28, r30
     4ec:	df 07       	cpc	r29, r31
     4ee:	31 f4       	brne	.+12     	; 0x4fc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4f0:	8c 81       	ldd	r24, Y+4	; 0x04
     4f2:	9d 81       	ldd	r25, Y+5	; 0x05
     4f4:	12 96       	adiw	r26, 0x02	; 2
     4f6:	9c 93       	st	X, r25
     4f8:	8e 93       	st	-X, r24
     4fa:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     4fc:	11 86       	std	Z+9, r1	; 0x09
     4fe:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     500:	8c 91       	ld	r24, X
     502:	81 50       	subi	r24, 0x01	; 1
     504:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	08 95       	ret

0000050c <MaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void MaxSonar_Start()
{
	MaxSonar_TriggerStart();
     50c:	a1 9a       	sbi	0x14, 1	; 20
	
	delayMicro(20); // delay 20 micro seconds...
     50e:	84 e1       	ldi	r24, 0x14	; 20
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	b7 d0       	rcall	.+366    	; 0x682 <delayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     514:	84 b3       	in	r24, 0x14	; 20
     516:	14 ba       	out	0x14, r1	; 20
     518:	08 95       	ret

0000051a <MaxSonar_Read>:
}

// Return distance in cm
int MaxSonar_Read(char analogChannel)
{
	return analogRead(analogChannel) * valueToCM;
     51a:	9a d0       	rcall	.+308    	; 0x650 <analogRead>
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	9c 01       	movw	r18, r24
     520:	22 0f       	add	r18, r18
     522:	33 1f       	adc	r19, r19
     524:	22 0f       	add	r18, r18
     526:	33 1f       	adc	r19, r19
}
     528:	82 0f       	add	r24, r18
     52a:	93 1f       	adc	r25, r19
     52c:	08 95       	ret

0000052e <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     52e:	1f 92       	push	r1
     530:	0f 92       	push	r0
     532:	0f b6       	in	r0, 0x3f	; 63
     534:	0f 92       	push	r0
     536:	11 24       	eor	r1, r1
     538:	0b b6       	in	r0, 0x3b	; 59
     53a:	0f 92       	push	r0
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	ef 93       	push	r30
     552:	ff 93       	push	r31
	adcReading = ADCH; // read value
     554:	80 91 79 00 	lds	r24, 0x0079
     558:	80 93 d7 08 	sts	0x08D7, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     55c:	20 e0       	ldi	r18, 0x00	; 0
     55e:	40 e0       	ldi	r20, 0x00	; 0
     560:	50 e0       	ldi	r21, 0x00	; 0
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	70 e0       	ldi	r23, 0x00	; 0
     566:	80 91 da 08 	lds	r24, 0x08DA
     56a:	90 91 db 08 	lds	r25, 0x08DB
     56e:	a3 d5       	rcall	.+2886   	; 0x10b6 <xQueueGenericSendFromISR>
}
     570:	ff 91       	pop	r31
     572:	ef 91       	pop	r30
     574:	bf 91       	pop	r27
     576:	af 91       	pop	r26
     578:	9f 91       	pop	r25
     57a:	8f 91       	pop	r24
     57c:	7f 91       	pop	r23
     57e:	6f 91       	pop	r22
     580:	5f 91       	pop	r21
     582:	4f 91       	pop	r20
     584:	3f 91       	pop	r19
     586:	2f 91       	pop	r18
     588:	0f 90       	pop	r0
     58a:	0b be       	out	0x3b, r0	; 59
     58c:	0f 90       	pop	r0
     58e:	0f be       	out	0x3f, r0	; 63
     590:	0f 90       	pop	r0
     592:	1f 90       	pop	r1
     594:	18 95       	reti

00000596 <ADC_Init>:

void ADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     596:	8f e8       	ldi	r24, 0x8F	; 143
     598:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     59c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     5a0:	80 e6       	ldi	r24, 0x60	; 96
     5a2:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     5a6:	43 e0       	ldi	r20, 0x03	; 3
     5a8:	60 e0       	ldi	r22, 0x00	; 0
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	9f d4       	rcall	.+2366   	; 0xeec <xQueueGenericCreate>
     5ae:	90 93 db 08 	sts	0x08DB, r25
     5b2:	80 93 da 08 	sts	0x08DA, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	56 d5       	rcall	.+2732   	; 0x1066 <xQueueCreateMutex>
     5ba:	90 93 d9 08 	sts	0x08D9, r25
     5be:	80 93 d8 08 	sts	0x08D8, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     5c2:	20 e0       	ldi	r18, 0x00	; 0
     5c4:	40 e0       	ldi	r20, 0x00	; 0
     5c6:	50 e0       	ldi	r21, 0x00	; 0
     5c8:	60 e0       	ldi	r22, 0x00	; 0
     5ca:	70 e0       	ldi	r23, 0x00	; 0
     5cc:	b9 c4       	rjmp	.+2418   	; 0xf40 <xQueueGenericSend>
     5ce:	08 95       	ret

000005d0 <startADC>:
	return readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void startADC(char channel)
{
     5d0:	cf 93       	push	r28
     5d2:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	4f ef       	ldi	r20, 0xFF	; 255
     5d8:	5f ef       	ldi	r21, 0xFF	; 255
     5da:	60 e0       	ldi	r22, 0x00	; 0
     5dc:	70 e0       	ldi	r23, 0x00	; 0
     5de:	80 91 d8 08 	lds	r24, 0x08D8
     5e2:	90 91 d9 08 	lds	r25, 0x08D9
     5e6:	a1 d5       	rcall	.+2882   	; 0x112a <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     5e8:	ec e7       	ldi	r30, 0x7C	; 124
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	80 81       	ld	r24, Z
     5ee:	9c 2f       	mov	r25, r28
     5f0:	9f 71       	andi	r25, 0x1F	; 31
     5f2:	80 76       	andi	r24, 0x60	; 96
     5f4:	89 2b       	or	r24, r25
     5f6:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     5f8:	eb e7       	ldi	r30, 0x7B	; 123
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	20 81       	ld	r18, Z
     5fe:	c0 72       	andi	r28, 0x20	; 32
     600:	8c 2f       	mov	r24, r28
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	95 95       	asr	r25
     606:	87 95       	ror	r24
     608:	95 95       	asr	r25
     60a:	87 95       	ror	r24
     60c:	92 2f       	mov	r25, r18
     60e:	90 76       	andi	r25, 0x60	; 96
     610:	89 2b       	or	r24, r25
     612:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     614:	ea e7       	ldi	r30, 0x7A	; 122
     616:	f0 e0       	ldi	r31, 0x00	; 0
     618:	80 81       	ld	r24, Z
     61a:	80 64       	ori	r24, 0x40	; 64
     61c:	80 83       	st	Z, r24
}
     61e:	cf 91       	pop	r28
     620:	08 95       	ret

00000622 <readADC>:

unsigned char readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	4f ef       	ldi	r20, 0xFF	; 255
     626:	5f ef       	ldi	r21, 0xFF	; 255
     628:	60 e0       	ldi	r22, 0x00	; 0
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	80 91 da 08 	lds	r24, 0x08DA
     630:	90 91 db 08 	lds	r25, 0x08DB
     634:	7a d5       	rcall	.+2804   	; 0x112a <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	40 e0       	ldi	r20, 0x00	; 0
     63a:	50 e0       	ldi	r21, 0x00	; 0
     63c:	60 e0       	ldi	r22, 0x00	; 0
     63e:	70 e0       	ldi	r23, 0x00	; 0
     640:	80 91 d8 08 	lds	r24, 0x08D8
     644:	90 91 d9 08 	lds	r25, 0x08D9
     648:	7b d4       	rcall	.+2294   	; 0xf40 <xQueueGenericSend>
	return adcReading;
     64a:	80 91 d7 08 	lds	r24, 0x08D7
     64e:	08 95       	ret

00000650 <analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char analogRead(char channel)
{
     650:	cf 93       	push	r28
     652:	c8 2f       	mov	r28, r24
	startADC(channel);
     654:	bd df       	rcall	.-134    	; 0x5d0 <startADC>
	return readADC(channel);
     656:	8c 2f       	mov	r24, r28
     658:	e4 df       	rcall	.-56     	; 0x622 <readADC>
}
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <MyTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void MyTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     65e:	90 93 df 08 	sts	0x08DF, r25
     662:	80 93 de 08 	sts	0x08DE, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     666:	fc 01       	movw	r30, r24
     668:	80 81       	ld	r24, Z
     66a:	91 81       	ldd	r25, Z+1	; 0x01
     66c:	0e 94 5b 0d 	call	0x1ab6	; 0x1ab6 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     670:	43 e0       	ldi	r20, 0x03	; 3
     672:	60 e0       	ldi	r22, 0x00	; 0
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	3a d4       	rcall	.+2164   	; 0xeec <xQueueGenericCreate>
     678:	90 93 dd 08 	sts	0x08DD, r25
     67c:	80 93 dc 08 	sts	0x08DC, r24
     680:	08 95       	ret

00000682 <delayMicro>:
}

// Return timer 0 value
inline unsigned char readTimer()
{
	return TCNT0;
     682:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     684:	4f 5f       	subi	r20, 0xFF	; 255
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     686:	9c 01       	movw	r18, r24
     688:	99 23       	and	r25, r25
     68a:	14 f4       	brge	.+4      	; 0x690 <delayMicro+0xe>
     68c:	2d 5f       	subi	r18, 0xFD	; 253
     68e:	3f 4f       	sbci	r19, 0xFF	; 255
     690:	35 95       	asr	r19
     692:	27 95       	ror	r18
     694:	35 95       	asr	r19
     696:	27 95       	ror	r18
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     698:	24 0f       	add	r18, r20
     69a:	20 93 00 02 	sts	0x0200, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     69e:	e0 91 de 08 	lds	r30, 0x08DE
     6a2:	f0 91 df 08 	lds	r31, 0x08DF
     6a6:	80 81       	ld	r24, Z
     6a8:	91 81       	ldd	r25, Z+1	; 0x01
     6aa:	99 d7       	rcall	.+3890   	; 0x15de <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... max wait for 2 ms... cannot be more than tht..
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	42 e0       	ldi	r20, 0x02	; 2
     6b0:	50 e0       	ldi	r21, 0x00	; 0
     6b2:	60 e0       	ldi	r22, 0x00	; 0
     6b4:	70 e0       	ldi	r23, 0x00	; 0
     6b6:	80 91 dc 08 	lds	r24, 0x08DC
     6ba:	90 91 dd 08 	lds	r25, 0x08DD
     6be:	35 c5       	rjmp	.+2666   	; 0x112a <xQueueGenericReceive>
     6c0:	08 95       	ret

000006c2 <delayMicroCheck>:
}

// Return timer 0 value
inline unsigned char readTimer()
{
	return TCNT0;
     6c2:	86 b5       	in	r24, 0x26	; 38
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... max wait for 2 ms... cannot be more than tht..
}

void delayMicroCheck()
{
	if(expectedTick >= readTimer())
     6c4:	90 91 00 02 	lds	r25, 0x0200
     6c8:	98 17       	cp	r25, r24
     6ca:	70 f0       	brcs	.+28     	; 0x6e8 <delayMicroCheck+0x26>
	{
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     6cc:	20 e0       	ldi	r18, 0x00	; 0
     6ce:	40 e0       	ldi	r20, 0x00	; 0
     6d0:	50 e0       	ldi	r21, 0x00	; 0
     6d2:	60 e0       	ldi	r22, 0x00	; 0
     6d4:	70 e0       	ldi	r23, 0x00	; 0
     6d6:	80 91 dc 08 	lds	r24, 0x08DC
     6da:	90 91 dd 08 	lds	r25, 0x08DD
     6de:	30 d4       	rcall	.+2144   	; 0xf40 <xQueueGenericSend>
		vTaskSuspend(NULL); // suspend again...
     6e0:	80 e0       	ldi	r24, 0x00	; 0
     6e2:	90 e0       	ldi	r25, 0x00	; 0
     6e4:	0c 94 5b 0d 	jmp	0x1ab6	; 0x1ab6 <vTaskSuspend>
     6e8:	08 95       	ret

000006ea <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     6ea:	1f 92       	push	r1
     6ec:	0f 92       	push	r0
     6ee:	0f b6       	in	r0, 0x3f	; 63
     6f0:	0f 92       	push	r0
     6f2:	11 24       	eor	r1, r1
     6f4:	0b b6       	in	r0, 0x3b	; 59
     6f6:	0f 92       	push	r0
     6f8:	2f 93       	push	r18
     6fa:	3f 93       	push	r19
     6fc:	4f 93       	push	r20
     6fe:	5f 93       	push	r21
     700:	6f 93       	push	r22
     702:	7f 93       	push	r23
     704:	8f 93       	push	r24
     706:	9f 93       	push	r25
     708:	af 93       	push	r26
     70a:	bf 93       	push	r27
     70c:	ef 93       	push	r30
     70e:	ff 93       	push	r31
     710:	60 91 ce 00 	lds	r22, 0x00CE
     714:	83 e7       	ldi	r24, 0x73	; 115
     716:	99 e0       	ldi	r25, 0x09	; 9
     718:	d4 d5       	rcall	.+2984   	; 0x12c2 <ringBufferPush>
     71a:	20 e0       	ldi	r18, 0x00	; 0
     71c:	40 e0       	ldi	r20, 0x00	; 0
     71e:	50 e0       	ldi	r21, 0x00	; 0
     720:	60 e0       	ldi	r22, 0x00	; 0
     722:	70 e0       	ldi	r23, 0x00	; 0
     724:	80 91 67 09 	lds	r24, 0x0967
     728:	90 91 68 09 	lds	r25, 0x0968
     72c:	c4 d4       	rcall	.+2440   	; 0x10b6 <xQueueGenericSendFromISR>
     72e:	83 e7       	ldi	r24, 0x73	; 115
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	dd d5       	rcall	.+3002   	; 0x12ee <ringBufferFull>
     734:	ff 91       	pop	r31
     736:	ef 91       	pop	r30
     738:	bf 91       	pop	r27
     73a:	af 91       	pop	r26
     73c:	9f 91       	pop	r25
     73e:	8f 91       	pop	r24
     740:	7f 91       	pop	r23
     742:	6f 91       	pop	r22
     744:	5f 91       	pop	r21
     746:	4f 91       	pop	r20
     748:	3f 91       	pop	r19
     74a:	2f 91       	pop	r18
     74c:	0f 90       	pop	r0
     74e:	0b be       	out	0x3b, r0	; 59
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	0f 90       	pop	r0
     756:	1f 90       	pop	r1
     758:	18 95       	reti

0000075a <__vector_25>:
     75a:	1f 92       	push	r1
     75c:	0f 92       	push	r0
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	0f 92       	push	r0
     762:	11 24       	eor	r1, r1
     764:	0b b6       	in	r0, 0x3b	; 59
     766:	0f 92       	push	r0
     768:	2f 93       	push	r18
     76a:	3f 93       	push	r19
     76c:	4f 93       	push	r20
     76e:	5f 93       	push	r21
     770:	6f 93       	push	r22
     772:	7f 93       	push	r23
     774:	8f 93       	push	r24
     776:	9f 93       	push	r25
     778:	af 93       	push	r26
     77a:	bf 93       	push	r27
     77c:	ef 93       	push	r30
     77e:	ff 93       	push	r31
     780:	60 91 c6 00 	lds	r22, 0x00C6
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	99 e0       	ldi	r25, 0x09	; 9
     788:	9c d5       	rcall	.+2872   	; 0x12c2 <ringBufferPush>
     78a:	20 e0       	ldi	r18, 0x00	; 0
     78c:	40 e0       	ldi	r20, 0x00	; 0
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	60 e0       	ldi	r22, 0x00	; 0
     792:	70 e0       	ldi	r23, 0x00	; 0
     794:	80 91 67 09 	lds	r24, 0x0967
     798:	90 91 68 09 	lds	r25, 0x0968
     79c:	8c d4       	rcall	.+2328   	; 0x10b6 <xQueueGenericSendFromISR>
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	99 e0       	ldi	r25, 0x09	; 9
     7a2:	a5 d5       	rcall	.+2890   	; 0x12ee <ringBufferFull>
     7a4:	ff 91       	pop	r31
     7a6:	ef 91       	pop	r30
     7a8:	bf 91       	pop	r27
     7aa:	af 91       	pop	r26
     7ac:	9f 91       	pop	r25
     7ae:	8f 91       	pop	r24
     7b0:	7f 91       	pop	r23
     7b2:	6f 91       	pop	r22
     7b4:	5f 91       	pop	r21
     7b6:	4f 91       	pop	r20
     7b8:	3f 91       	pop	r19
     7ba:	2f 91       	pop	r18
     7bc:	0f 90       	pop	r0
     7be:	0b be       	out	0x3b, r0	; 59
     7c0:	0f 90       	pop	r0
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	0f 90       	pop	r0
     7c6:	1f 90       	pop	r1
     7c8:	18 95       	reti

000007ca <__vector_37>:
     7ca:	1f 92       	push	r1
     7cc:	0f 92       	push	r0
     7ce:	0f b6       	in	r0, 0x3f	; 63
     7d0:	0f 92       	push	r0
     7d2:	11 24       	eor	r1, r1
     7d4:	0b b6       	in	r0, 0x3b	; 59
     7d6:	0f 92       	push	r0
     7d8:	2f 93       	push	r18
     7da:	3f 93       	push	r19
     7dc:	4f 93       	push	r20
     7de:	5f 93       	push	r21
     7e0:	6f 93       	push	r22
     7e2:	7f 93       	push	r23
     7e4:	8f 93       	push	r24
     7e6:	9f 93       	push	r25
     7e8:	af 93       	push	r26
     7ea:	bf 93       	push	r27
     7ec:	ef 93       	push	r30
     7ee:	ff 93       	push	r31
     7f0:	89 e6       	ldi	r24, 0x69	; 105
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	83 d5       	rcall	.+2822   	; 0x12fc <ringBufferNotEmpty>
     7f6:	88 23       	and	r24, r24
     7f8:	31 f0       	breq	.+12     	; 0x806 <__vector_37+0x3c>
     7fa:	89 e6       	ldi	r24, 0x69	; 105
     7fc:	99 e0       	ldi	r25, 0x09	; 9
     7fe:	4f d5       	rcall	.+2718   	; 0x129e <ringBufferPop>
     800:	80 93 ce 00 	sts	0x00CE, r24
     804:	05 c0       	rjmp	.+10     	; 0x810 <__vector_37+0x46>
     806:	e9 ec       	ldi	r30, 0xC9	; 201
     808:	f0 e0       	ldi	r31, 0x00	; 0
     80a:	80 81       	ld	r24, Z
     80c:	8f 7d       	andi	r24, 0xDF	; 223
     80e:	80 83       	st	Z, r24
     810:	ff 91       	pop	r31
     812:	ef 91       	pop	r30
     814:	bf 91       	pop	r27
     816:	af 91       	pop	r26
     818:	9f 91       	pop	r25
     81a:	8f 91       	pop	r24
     81c:	7f 91       	pop	r23
     81e:	6f 91       	pop	r22
     820:	5f 91       	pop	r21
     822:	4f 91       	pop	r20
     824:	3f 91       	pop	r19
     826:	2f 91       	pop	r18
     828:	0f 90       	pop	r0
     82a:	0b be       	out	0x3b, r0	; 59
     82c:	0f 90       	pop	r0
     82e:	0f be       	out	0x3f, r0	; 63
     830:	0f 90       	pop	r0
     832:	1f 90       	pop	r1
     834:	18 95       	reti

00000836 <__vector_26>:
     836:	1f 92       	push	r1
     838:	0f 92       	push	r0
     83a:	0f b6       	in	r0, 0x3f	; 63
     83c:	0f 92       	push	r0
     83e:	11 24       	eor	r1, r1
     840:	0b b6       	in	r0, 0x3b	; 59
     842:	0f 92       	push	r0
     844:	2f 93       	push	r18
     846:	3f 93       	push	r19
     848:	4f 93       	push	r20
     84a:	5f 93       	push	r21
     84c:	6f 93       	push	r22
     84e:	7f 93       	push	r23
     850:	8f 93       	push	r24
     852:	9f 93       	push	r25
     854:	af 93       	push	r26
     856:	bf 93       	push	r27
     858:	ef 93       	push	r30
     85a:	ff 93       	push	r31
     85c:	8e e6       	ldi	r24, 0x6E	; 110
     85e:	99 e0       	ldi	r25, 0x09	; 9
     860:	4d d5       	rcall	.+2714   	; 0x12fc <ringBufferNotEmpty>
     862:	88 23       	and	r24, r24
     864:	31 f0       	breq	.+12     	; 0x872 <__vector_26+0x3c>
     866:	8e e6       	ldi	r24, 0x6E	; 110
     868:	99 e0       	ldi	r25, 0x09	; 9
     86a:	19 d5       	rcall	.+2610   	; 0x129e <ringBufferPop>
     86c:	80 93 c6 00 	sts	0x00C6, r24
     870:	05 c0       	rjmp	.+10     	; 0x87c <__vector_26+0x46>
     872:	e1 ec       	ldi	r30, 0xC1	; 193
     874:	f0 e0       	ldi	r31, 0x00	; 0
     876:	80 81       	ld	r24, Z
     878:	8f 7d       	andi	r24, 0xDF	; 223
     87a:	80 83       	st	Z, r24
     87c:	ff 91       	pop	r31
     87e:	ef 91       	pop	r30
     880:	bf 91       	pop	r27
     882:	af 91       	pop	r26
     884:	9f 91       	pop	r25
     886:	8f 91       	pop	r24
     888:	7f 91       	pop	r23
     88a:	6f 91       	pop	r22
     88c:	5f 91       	pop	r21
     88e:	4f 91       	pop	r20
     890:	3f 91       	pop	r19
     892:	2f 91       	pop	r18
     894:	0f 90       	pop	r0
     896:	0b be       	out	0x3b, r0	; 59
     898:	0f 90       	pop	r0
     89a:	0f be       	out	0x3f, r0	; 63
     89c:	0f 90       	pop	r0
     89e:	1f 90       	pop	r1
     8a0:	18 95       	reti

000008a2 <USART0_Init>:
     8a2:	10 92 c5 00 	sts	0x00C5, r1
     8a6:	87 e6       	ldi	r24, 0x67	; 103
     8a8:	80 93 c4 00 	sts	0x00C4, r24
     8ac:	88 eb       	ldi	r24, 0xB8	; 184
     8ae:	80 93 c1 00 	sts	0x00C1, r24
     8b2:	86 e0       	ldi	r24, 0x06	; 6
     8b4:	80 93 c2 00 	sts	0x00C2, r24
     8b8:	40 e2       	ldi	r20, 0x20	; 32
     8ba:	65 e2       	ldi	r22, 0x25	; 37
     8bc:	79 e0       	ldi	r23, 0x09	; 9
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	99 e0       	ldi	r25, 0x09	; 9
     8c2:	e6 d4       	rcall	.+2508   	; 0x1290 <ringBufferInit>
     8c4:	40 e2       	ldi	r20, 0x20	; 32
     8c6:	65 e0       	ldi	r22, 0x05	; 5
     8c8:	79 e0       	ldi	r23, 0x09	; 9
     8ca:	8e e6       	ldi	r24, 0x6E	; 110
     8cc:	99 e0       	ldi	r25, 0x09	; 9
     8ce:	e0 d4       	rcall	.+2496   	; 0x1290 <ringBufferInit>
     8d0:	43 e0       	ldi	r20, 0x03	; 3
     8d2:	60 e0       	ldi	r22, 0x00	; 0
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0a d3       	rcall	.+1556   	; 0xeec <xQueueGenericCreate>
     8d8:	90 93 66 09 	sts	0x0966, r25
     8dc:	80 93 65 09 	sts	0x0965, r24
     8e0:	08 95       	ret

000008e2 <USART1_Init>:
     8e2:	10 92 cd 00 	sts	0x00CD, r1
     8e6:	87 e6       	ldi	r24, 0x67	; 103
     8e8:	80 93 cc 00 	sts	0x00CC, r24
     8ec:	88 eb       	ldi	r24, 0xB8	; 184
     8ee:	80 93 c9 00 	sts	0x00C9, r24
     8f2:	86 e0       	ldi	r24, 0x06	; 6
     8f4:	80 93 ca 00 	sts	0x00CA, r24
     8f8:	40 e2       	ldi	r20, 0x20	; 32
     8fa:	60 ee       	ldi	r22, 0xE0	; 224
     8fc:	78 e0       	ldi	r23, 0x08	; 8
     8fe:	83 e7       	ldi	r24, 0x73	; 115
     900:	99 e0       	ldi	r25, 0x09	; 9
     902:	c6 d4       	rcall	.+2444   	; 0x1290 <ringBufferInit>
     904:	40 e2       	ldi	r20, 0x20	; 32
     906:	65 e4       	ldi	r22, 0x45	; 69
     908:	79 e0       	ldi	r23, 0x09	; 9
     90a:	89 e6       	ldi	r24, 0x69	; 105
     90c:	99 e0       	ldi	r25, 0x09	; 9
     90e:	c0 d4       	rcall	.+2432   	; 0x1290 <ringBufferInit>
     910:	43 e0       	ldi	r20, 0x03	; 3
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	ea d2       	rcall	.+1492   	; 0xeec <xQueueGenericCreate>
     918:	90 93 68 09 	sts	0x0968, r25
     91c:	80 93 67 09 	sts	0x0967, r24
     920:	08 95       	ret

00000922 <transmitUSART0_c>:
     922:	cf 93       	push	r28
     924:	c8 2f       	mov	r28, r24
     926:	8e e6       	ldi	r24, 0x6E	; 110
     928:	99 e0       	ldi	r25, 0x09	; 9
     92a:	e1 d4       	rcall	.+2498   	; 0x12ee <ringBufferFull>
     92c:	81 11       	cpse	r24, r1
     92e:	fb cf       	rjmp	.-10     	; 0x926 <transmitUSART0_c+0x4>
     930:	6c 2f       	mov	r22, r28
     932:	8e e6       	ldi	r24, 0x6E	; 110
     934:	99 e0       	ldi	r25, 0x09	; 9
     936:	c5 d4       	rcall	.+2442   	; 0x12c2 <ringBufferPush>
     938:	e1 ec       	ldi	r30, 0xC1	; 193
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	80 81       	ld	r24, Z
     93e:	80 62       	ori	r24, 0x20	; 32
     940:	80 83       	st	Z, r24
     942:	e0 ec       	ldi	r30, 0xC0	; 192
     944:	f0 e0       	ldi	r31, 0x00	; 0
     946:	80 81       	ld	r24, Z
     948:	80 64       	ori	r24, 0x40	; 64
     94a:	80 83       	st	Z, r24
     94c:	cf 91       	pop	r28
     94e:	08 95       	ret

00000950 <transmitUSART1_c>:
     950:	cf 93       	push	r28
     952:	c8 2f       	mov	r28, r24
     954:	89 e6       	ldi	r24, 0x69	; 105
     956:	99 e0       	ldi	r25, 0x09	; 9
     958:	ca d4       	rcall	.+2452   	; 0x12ee <ringBufferFull>
     95a:	81 11       	cpse	r24, r1
     95c:	fb cf       	rjmp	.-10     	; 0x954 <transmitUSART1_c+0x4>
     95e:	6c 2f       	mov	r22, r28
     960:	89 e6       	ldi	r24, 0x69	; 105
     962:	99 e0       	ldi	r25, 0x09	; 9
     964:	ae d4       	rcall	.+2396   	; 0x12c2 <ringBufferPush>
     966:	e9 ec       	ldi	r30, 0xC9	; 201
     968:	f0 e0       	ldi	r31, 0x00	; 0
     96a:	80 81       	ld	r24, Z
     96c:	80 62       	ori	r24, 0x20	; 32
     96e:	80 83       	st	Z, r24
     970:	e8 ec       	ldi	r30, 0xC8	; 200
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	80 81       	ld	r24, Z
     976:	80 64       	ori	r24, 0x40	; 64
     978:	80 83       	st	Z, r24
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <transmitUSART0>:
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	ec 01       	movw	r28, r24
     984:	88 81       	ld	r24, Y
     986:	88 23       	and	r24, r24
     988:	29 f0       	breq	.+10     	; 0x994 <transmitUSART0+0x16>
     98a:	21 96       	adiw	r28, 0x01	; 1
     98c:	ca df       	rcall	.-108    	; 0x922 <transmitUSART0_c>
     98e:	89 91       	ld	r24, Y+
     990:	81 11       	cpse	r24, r1
     992:	fc cf       	rjmp	.-8      	; 0x98c <transmitUSART0+0xe>
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	08 95       	ret

0000099a <receiveUSART1>:
     99a:	cf 93       	push	r28
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	4f ef       	ldi	r20, 0xFF	; 255
     9a0:	5f ef       	ldi	r21, 0xFF	; 255
     9a2:	60 e0       	ldi	r22, 0x00	; 0
     9a4:	70 e0       	ldi	r23, 0x00	; 0
     9a6:	80 91 65 09 	lds	r24, 0x0965
     9aa:	90 91 66 09 	lds	r25, 0x0966
     9ae:	bd d3       	rcall	.+1914   	; 0x112a <xQueueGenericReceive>
     9b0:	83 e7       	ldi	r24, 0x73	; 115
     9b2:	99 e0       	ldi	r25, 0x09	; 9
     9b4:	74 d4       	rcall	.+2280   	; 0x129e <ringBufferPop>
     9b6:	c8 2f       	mov	r28, r24
     9b8:	83 e7       	ldi	r24, 0x73	; 115
     9ba:	99 e0       	ldi	r25, 0x09	; 9
     9bc:	9f d4       	rcall	.+2366   	; 0x12fc <ringBufferNotEmpty>
     9be:	88 23       	and	r24, r24
     9c0:	51 f0       	breq	.+20     	; 0x9d6 <receiveUSART1+0x3c>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	60 e0       	ldi	r22, 0x00	; 0
     9ca:	70 e0       	ldi	r23, 0x00	; 0
     9cc:	80 91 65 09 	lds	r24, 0x0965
     9d0:	90 91 66 09 	lds	r25, 0x0966
     9d4:	b5 d2       	rcall	.+1386   	; 0xf40 <xQueueGenericSend>
     9d6:	8c 2f       	mov	r24, r28
     9d8:	cf 91       	pop	r28
     9da:	08 95       	ret

000009dc <startHandShake>:

// -1 if fail, 0 success
char startHandShake()
{
	transmitUSART1_c(HANDSHAKE_START);
     9dc:	80 e0       	ldi	r24, 0x00	; 0
     9de:	b8 df       	rcall	.-144    	; 0x950 <transmitUSART1_c>
	
	if (! receiveHandShakeAck(receiveUSART1()))
     9e0:	dc df       	rcall	.-72     	; 0x99a <receiveUSART1>
     9e2:	85 35       	cpi	r24, 0x55	; 85
     9e4:	21 f4       	brne	.+8      	; 0x9ee <startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
     9e6:	8f ef       	ldi	r24, 0xFF	; 255
     9e8:	b3 df       	rcall	.-154    	; 0x950 <transmitUSART1_c>
	
	return 0;
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	08 95       	ret
{
	transmitUSART1_c(HANDSHAKE_START);
	
	if (! receiveHandShakeAck(receiveUSART1()))
	{
		return -1; //error handling
     9ee:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     9f0:	08 95       	ret

000009f2 <waitForHandshake>:


// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
     9f2:	d3 df       	rcall	.-90     	; 0x99a <receiveUSART1>
     9f4:	81 11       	cpse	r24, r1
     9f6:	0a c0       	rjmp	.+20     	; 0xa0c <waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	transmitUSART1_c(HANDSHAKE_ACK);
     9f8:	85 e5       	ldi	r24, 0x55	; 85
     9fa:	aa df       	rcall	.-172    	; 0x950 <transmitUSART1_c>
	
	if (! receiveHandShakeStart(receiveUSART1()))
     9fc:	ce df       	rcall	.-100    	; 0x99a <receiveUSART1>
     9fe:	91 e0       	ldi	r25, 0x01	; 1
     a00:	81 11       	cpse	r24, r1
     a02:	01 c0       	rjmp	.+2      	; 0xa06 <waitForHandshake+0x14>
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	89 2f       	mov	r24, r25
     a08:	81 95       	neg	r24
     a0a:	08 95       	ret
// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
	{
		return -1; // error handling
     a0c:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     a0e:	08 95       	ret

00000a10 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a10:	31 e1       	ldi	r19, 0x11	; 17
     a12:	fc 01       	movw	r30, r24
     a14:	30 83       	st	Z, r19
     a16:	31 97       	sbiw	r30, 0x01	; 1
     a18:	22 e2       	ldi	r18, 0x22	; 34
     a1a:	20 83       	st	Z, r18
     a1c:	31 97       	sbiw	r30, 0x01	; 1
     a1e:	a3 e3       	ldi	r26, 0x33	; 51
     a20:	a0 83       	st	Z, r26
     a22:	31 97       	sbiw	r30, 0x01	; 1
     a24:	60 83       	st	Z, r22
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	70 83       	st	Z, r23
     a2a:	31 97       	sbiw	r30, 0x01	; 1
     a2c:	10 82       	st	Z, r1
     a2e:	31 97       	sbiw	r30, 0x01	; 1
     a30:	10 82       	st	Z, r1
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	60 e8       	ldi	r22, 0x80	; 128
     a36:	60 83       	st	Z, r22
     a38:	31 97       	sbiw	r30, 0x01	; 1
     a3a:	10 82       	st	Z, r1
     a3c:	31 97       	sbiw	r30, 0x01	; 1
     a3e:	10 82       	st	Z, r1
     a40:	31 97       	sbiw	r30, 0x01	; 1
     a42:	10 82       	st	Z, r1
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	62 e0       	ldi	r22, 0x02	; 2
     a48:	60 83       	st	Z, r22
     a4a:	31 97       	sbiw	r30, 0x01	; 1
     a4c:	63 e0       	ldi	r22, 0x03	; 3
     a4e:	60 83       	st	Z, r22
     a50:	31 97       	sbiw	r30, 0x01	; 1
     a52:	64 e0       	ldi	r22, 0x04	; 4
     a54:	60 83       	st	Z, r22
     a56:	31 97       	sbiw	r30, 0x01	; 1
     a58:	65 e0       	ldi	r22, 0x05	; 5
     a5a:	60 83       	st	Z, r22
     a5c:	31 97       	sbiw	r30, 0x01	; 1
     a5e:	66 e0       	ldi	r22, 0x06	; 6
     a60:	60 83       	st	Z, r22
     a62:	31 97       	sbiw	r30, 0x01	; 1
     a64:	67 e0       	ldi	r22, 0x07	; 7
     a66:	60 83       	st	Z, r22
     a68:	31 97       	sbiw	r30, 0x01	; 1
     a6a:	68 e0       	ldi	r22, 0x08	; 8
     a6c:	60 83       	st	Z, r22
     a6e:	31 97       	sbiw	r30, 0x01	; 1
     a70:	69 e0       	ldi	r22, 0x09	; 9
     a72:	60 83       	st	Z, r22
     a74:	31 97       	sbiw	r30, 0x01	; 1
     a76:	60 e1       	ldi	r22, 0x10	; 16
     a78:	60 83       	st	Z, r22
     a7a:	31 97       	sbiw	r30, 0x01	; 1
     a7c:	30 83       	st	Z, r19
     a7e:	31 97       	sbiw	r30, 0x01	; 1
     a80:	32 e1       	ldi	r19, 0x12	; 18
     a82:	30 83       	st	Z, r19
     a84:	31 97       	sbiw	r30, 0x01	; 1
     a86:	33 e1       	ldi	r19, 0x13	; 19
     a88:	30 83       	st	Z, r19
     a8a:	31 97       	sbiw	r30, 0x01	; 1
     a8c:	34 e1       	ldi	r19, 0x14	; 20
     a8e:	30 83       	st	Z, r19
     a90:	31 97       	sbiw	r30, 0x01	; 1
     a92:	35 e1       	ldi	r19, 0x15	; 21
     a94:	30 83       	st	Z, r19
     a96:	31 97       	sbiw	r30, 0x01	; 1
     a98:	36 e1       	ldi	r19, 0x16	; 22
     a9a:	30 83       	st	Z, r19
     a9c:	31 97       	sbiw	r30, 0x01	; 1
     a9e:	37 e1       	ldi	r19, 0x17	; 23
     aa0:	30 83       	st	Z, r19
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	38 e1       	ldi	r19, 0x18	; 24
     aa6:	30 83       	st	Z, r19
     aa8:	31 97       	sbiw	r30, 0x01	; 1
     aaa:	39 e1       	ldi	r19, 0x19	; 25
     aac:	30 83       	st	Z, r19
     aae:	31 97       	sbiw	r30, 0x01	; 1
     ab0:	30 e2       	ldi	r19, 0x20	; 32
     ab2:	30 83       	st	Z, r19
     ab4:	31 97       	sbiw	r30, 0x01	; 1
     ab6:	31 e2       	ldi	r19, 0x21	; 33
     ab8:	30 83       	st	Z, r19
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	20 83       	st	Z, r18
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	23 e2       	ldi	r18, 0x23	; 35
     ac2:	20 83       	st	Z, r18
     ac4:	31 97       	sbiw	r30, 0x01	; 1
     ac6:	40 83       	st	Z, r20
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	50 83       	st	Z, r21
     acc:	31 97       	sbiw	r30, 0x01	; 1
     ace:	26 e2       	ldi	r18, 0x26	; 38
     ad0:	20 83       	st	Z, r18
     ad2:	31 97       	sbiw	r30, 0x01	; 1
     ad4:	27 e2       	ldi	r18, 0x27	; 39
     ad6:	20 83       	st	Z, r18
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	28 e2       	ldi	r18, 0x28	; 40
     adc:	20 83       	st	Z, r18
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	29 e2       	ldi	r18, 0x29	; 41
     ae2:	20 83       	st	Z, r18
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	20 e3       	ldi	r18, 0x30	; 48
     ae8:	20 83       	st	Z, r18
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	21 e3       	ldi	r18, 0x31	; 49
     aee:	20 83       	st	Z, r18
     af0:	89 97       	sbiw	r24, 0x29	; 41
     af2:	08 95       	ret

00000af4 <xPortStartScheduler>:
     af4:	82 e0       	ldi	r24, 0x02	; 2
     af6:	84 bd       	out	0x24, r24	; 36
     af8:	16 bc       	out	0x26, r1	; 38
     afa:	80 e3       	ldi	r24, 0x30	; 48
     afc:	87 bd       	out	0x27, r24	; 39
     afe:	ee e6       	ldi	r30, 0x6E	; 110
     b00:	f0 e0       	ldi	r31, 0x00	; 0
     b02:	80 81       	ld	r24, Z
     b04:	82 60       	ori	r24, 0x02	; 2
     b06:	80 83       	st	Z, r24
     b08:	83 e0       	ldi	r24, 0x03	; 3
     b0a:	85 bd       	out	0x25, r24	; 37
     b0c:	a0 91 d5 08 	lds	r26, 0x08D5
     b10:	b0 91 d6 08 	lds	r27, 0x08D6
     b14:	cd 91       	ld	r28, X+
     b16:	cd bf       	out	0x3d, r28	; 61
     b18:	dd 91       	ld	r29, X+
     b1a:	de bf       	out	0x3e, r29	; 62
     b1c:	ff 91       	pop	r31
     b1e:	ef 91       	pop	r30
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	bf 91       	pop	r27
     b26:	af 91       	pop	r26
     b28:	9f 91       	pop	r25
     b2a:	8f 91       	pop	r24
     b2c:	7f 91       	pop	r23
     b2e:	6f 91       	pop	r22
     b30:	5f 91       	pop	r21
     b32:	4f 91       	pop	r20
     b34:	3f 91       	pop	r19
     b36:	2f 91       	pop	r18
     b38:	1f 91       	pop	r17
     b3a:	0f 91       	pop	r16
     b3c:	ff 90       	pop	r15
     b3e:	ef 90       	pop	r14
     b40:	df 90       	pop	r13
     b42:	cf 90       	pop	r12
     b44:	bf 90       	pop	r11
     b46:	af 90       	pop	r10
     b48:	9f 90       	pop	r9
     b4a:	8f 90       	pop	r8
     b4c:	7f 90       	pop	r7
     b4e:	6f 90       	pop	r6
     b50:	5f 90       	pop	r5
     b52:	4f 90       	pop	r4
     b54:	3f 90       	pop	r3
     b56:	2f 90       	pop	r2
     b58:	1f 90       	pop	r1
     b5a:	0f 90       	pop	r0
     b5c:	0c be       	out	0x3c, r0	; 60
     b5e:	0f 90       	pop	r0
     b60:	0b be       	out	0x3b, r0	; 59
     b62:	0f 90       	pop	r0
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	0f 90       	pop	r0
     b68:	08 95       	ret
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	08 95       	ret

00000b6e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b6e:	0f 92       	push	r0
     b70:	0f b6       	in	r0, 0x3f	; 63
     b72:	f8 94       	cli
     b74:	0f 92       	push	r0
     b76:	0b b6       	in	r0, 0x3b	; 59
     b78:	0f 92       	push	r0
     b7a:	0c b6       	in	r0, 0x3c	; 60
     b7c:	0f 92       	push	r0
     b7e:	1f 92       	push	r1
     b80:	11 24       	eor	r1, r1
     b82:	2f 92       	push	r2
     b84:	3f 92       	push	r3
     b86:	4f 92       	push	r4
     b88:	5f 92       	push	r5
     b8a:	6f 92       	push	r6
     b8c:	7f 92       	push	r7
     b8e:	8f 92       	push	r8
     b90:	9f 92       	push	r9
     b92:	af 92       	push	r10
     b94:	bf 92       	push	r11
     b96:	cf 92       	push	r12
     b98:	df 92       	push	r13
     b9a:	ef 92       	push	r14
     b9c:	ff 92       	push	r15
     b9e:	0f 93       	push	r16
     ba0:	1f 93       	push	r17
     ba2:	2f 93       	push	r18
     ba4:	3f 93       	push	r19
     ba6:	4f 93       	push	r20
     ba8:	5f 93       	push	r21
     baa:	6f 93       	push	r22
     bac:	7f 93       	push	r23
     bae:	8f 93       	push	r24
     bb0:	9f 93       	push	r25
     bb2:	af 93       	push	r26
     bb4:	bf 93       	push	r27
     bb6:	cf 93       	push	r28
     bb8:	df 93       	push	r29
     bba:	ef 93       	push	r30
     bbc:	ff 93       	push	r31
     bbe:	a0 91 d5 08 	lds	r26, 0x08D5
     bc2:	b0 91 d6 08 	lds	r27, 0x08D6
     bc6:	0d b6       	in	r0, 0x3d	; 61
     bc8:	0d 92       	st	X+, r0
     bca:	0e b6       	in	r0, 0x3e	; 62
     bcc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bce:	15 d7       	rcall	.+3626   	; 0x19fa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bd0:	a0 91 d5 08 	lds	r26, 0x08D5
     bd4:	b0 91 d6 08 	lds	r27, 0x08D6
     bd8:	cd 91       	ld	r28, X+
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	dd 91       	ld	r29, X+
     bde:	de bf       	out	0x3e, r29	; 62
     be0:	ff 91       	pop	r31
     be2:	ef 91       	pop	r30
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	bf 91       	pop	r27
     bea:	af 91       	pop	r26
     bec:	9f 91       	pop	r25
     bee:	8f 91       	pop	r24
     bf0:	7f 91       	pop	r23
     bf2:	6f 91       	pop	r22
     bf4:	5f 91       	pop	r21
     bf6:	4f 91       	pop	r20
     bf8:	3f 91       	pop	r19
     bfa:	2f 91       	pop	r18
     bfc:	1f 91       	pop	r17
     bfe:	0f 91       	pop	r16
     c00:	ff 90       	pop	r15
     c02:	ef 90       	pop	r14
     c04:	df 90       	pop	r13
     c06:	cf 90       	pop	r12
     c08:	bf 90       	pop	r11
     c0a:	af 90       	pop	r10
     c0c:	9f 90       	pop	r9
     c0e:	8f 90       	pop	r8
     c10:	7f 90       	pop	r7
     c12:	6f 90       	pop	r6
     c14:	5f 90       	pop	r5
     c16:	4f 90       	pop	r4
     c18:	3f 90       	pop	r3
     c1a:	2f 90       	pop	r2
     c1c:	1f 90       	pop	r1
     c1e:	0f 90       	pop	r0
     c20:	0c be       	out	0x3c, r0	; 60
     c22:	0f 90       	pop	r0
     c24:	0b be       	out	0x3b, r0	; 59
     c26:	0f 90       	pop	r0
     c28:	0f be       	out	0x3f, r0	; 63
     c2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c2c:	08 95       	ret

00000c2e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c2e:	0f 92       	push	r0
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	0f 92       	push	r0
     c36:	0b b6       	in	r0, 0x3b	; 59
     c38:	0f 92       	push	r0
     c3a:	0c b6       	in	r0, 0x3c	; 60
     c3c:	0f 92       	push	r0
     c3e:	1f 92       	push	r1
     c40:	11 24       	eor	r1, r1
     c42:	2f 92       	push	r2
     c44:	3f 92       	push	r3
     c46:	4f 92       	push	r4
     c48:	5f 92       	push	r5
     c4a:	6f 92       	push	r6
     c4c:	7f 92       	push	r7
     c4e:	8f 92       	push	r8
     c50:	9f 92       	push	r9
     c52:	af 92       	push	r10
     c54:	bf 92       	push	r11
     c56:	cf 92       	push	r12
     c58:	df 92       	push	r13
     c5a:	ef 92       	push	r14
     c5c:	ff 92       	push	r15
     c5e:	0f 93       	push	r16
     c60:	1f 93       	push	r17
     c62:	2f 93       	push	r18
     c64:	3f 93       	push	r19
     c66:	4f 93       	push	r20
     c68:	5f 93       	push	r21
     c6a:	6f 93       	push	r22
     c6c:	7f 93       	push	r23
     c6e:	8f 93       	push	r24
     c70:	9f 93       	push	r25
     c72:	af 93       	push	r26
     c74:	bf 93       	push	r27
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
     c7a:	ef 93       	push	r30
     c7c:	ff 93       	push	r31
     c7e:	a0 91 d5 08 	lds	r26, 0x08D5
     c82:	b0 91 d6 08 	lds	r27, 0x08D6
     c86:	0d b6       	in	r0, 0x3d	; 61
     c88:	0d 92       	st	X+, r0
     c8a:	0e b6       	in	r0, 0x3e	; 62
     c8c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     c8e:	21 d5       	rcall	.+2626   	; 0x16d2 <xTaskIncrementTick>
     c90:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     c92:	b3 d6       	rcall	.+3430   	; 0x19fa <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     c94:	a0 91 d5 08 	lds	r26, 0x08D5
     c98:	b0 91 d6 08 	lds	r27, 0x08D6
     c9c:	cd 91       	ld	r28, X+
     c9e:	cd bf       	out	0x3d, r28	; 61
     ca0:	dd 91       	ld	r29, X+
     ca2:	de bf       	out	0x3e, r29	; 62
     ca4:	ff 91       	pop	r31
     ca6:	ef 91       	pop	r30
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	bf 91       	pop	r27
     cae:	af 91       	pop	r26
     cb0:	9f 91       	pop	r25
     cb2:	8f 91       	pop	r24
     cb4:	7f 91       	pop	r23
     cb6:	6f 91       	pop	r22
     cb8:	5f 91       	pop	r21
     cba:	4f 91       	pop	r20
     cbc:	3f 91       	pop	r19
     cbe:	2f 91       	pop	r18
     cc0:	1f 91       	pop	r17
     cc2:	0f 91       	pop	r16
     cc4:	ff 90       	pop	r15
     cc6:	ef 90       	pop	r14
     cc8:	df 90       	pop	r13
     cca:	cf 90       	pop	r12
     ccc:	bf 90       	pop	r11
     cce:	af 90       	pop	r10
     cd0:	9f 90       	pop	r9
     cd2:	8f 90       	pop	r8
     cd4:	7f 90       	pop	r7
     cd6:	6f 90       	pop	r6
     cd8:	5f 90       	pop	r5
     cda:	4f 90       	pop	r4
     cdc:	3f 90       	pop	r3
     cde:	2f 90       	pop	r2
     ce0:	1f 90       	pop	r1
     ce2:	0f 90       	pop	r0
     ce4:	0c be       	out	0x3c, r0	; 60
     ce6:	0f 90       	pop	r0
     ce8:	0b be       	out	0x3b, r0	; 59
     cea:	0f 90       	pop	r0
     cec:	0f be       	out	0x3f, r0	; 63
     cee:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cf0:	08 95       	ret

00000cf2 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     cf2:	9d df       	rcall	.-198    	; 0xc2e <vPortYieldFromTick>
		 asm volatile ("reti");
     cf4:	18 95       	reti

00000cf6 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     cf6:	1f 93       	push	r17
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	ec 01       	movw	r28, r24
     cfe:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     d00:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d02:	81 11       	cpse	r24, r1
     d04:	0c c0       	rjmp	.+24     	; 0xd1e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d06:	88 81       	ld	r24, Y
     d08:	99 81       	ldd	r25, Y+1	; 0x01
     d0a:	89 2b       	or	r24, r25
     d0c:	09 f0       	breq	.+2      	; 0xd10 <prvCopyDataToQueue+0x1a>
     d0e:	47 c0       	rjmp	.+142    	; 0xd9e <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     d10:	8a 81       	ldd	r24, Y+2	; 0x02
     d12:	9b 81       	ldd	r25, Y+3	; 0x03
     d14:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     d18:	1b 82       	std	Y+3, r1	; 0x03
     d1a:	1a 82       	std	Y+2, r1	; 0x02
     d1c:	47 c0       	rjmp	.+142    	; 0xdac <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     d1e:	41 11       	cpse	r20, r1
     d20:	18 c0       	rjmp	.+48     	; 0xd52 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     d22:	48 2f       	mov	r20, r24
     d24:	50 e0       	ldi	r21, 0x00	; 0
     d26:	8c 81       	ldd	r24, Y+4	; 0x04
     d28:	9d 81       	ldd	r25, Y+5	; 0x05
     d2a:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d2e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d30:	8c 81       	ldd	r24, Y+4	; 0x04
     d32:	9d 81       	ldd	r25, Y+5	; 0x05
     d34:	82 0f       	add	r24, r18
     d36:	91 1d       	adc	r25, r1
     d38:	9d 83       	std	Y+5, r25	; 0x05
     d3a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d3c:	2a 81       	ldd	r18, Y+2	; 0x02
     d3e:	3b 81       	ldd	r19, Y+3	; 0x03
     d40:	82 17       	cp	r24, r18
     d42:	93 07       	cpc	r25, r19
     d44:	70 f1       	brcs	.+92     	; 0xda2 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d46:	88 81       	ld	r24, Y
     d48:	99 81       	ldd	r25, Y+1	; 0x01
     d4a:	9d 83       	std	Y+5, r25	; 0x05
     d4c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d4e:	80 e0       	ldi	r24, 0x00	; 0
     d50:	2d c0       	rjmp	.+90     	; 0xdac <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d52:	48 2f       	mov	r20, r24
     d54:	50 e0       	ldi	r21, 0x00	; 0
     d56:	8e 81       	ldd	r24, Y+6	; 0x06
     d58:	9f 81       	ldd	r25, Y+7	; 0x07
     d5a:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     d5e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d60:	30 e0       	ldi	r19, 0x00	; 0
     d62:	31 95       	neg	r19
     d64:	21 95       	neg	r18
     d66:	31 09       	sbc	r19, r1
     d68:	8e 81       	ldd	r24, Y+6	; 0x06
     d6a:	9f 81       	ldd	r25, Y+7	; 0x07
     d6c:	82 0f       	add	r24, r18
     d6e:	93 1f       	adc	r25, r19
     d70:	9f 83       	std	Y+7, r25	; 0x07
     d72:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d74:	68 81       	ld	r22, Y
     d76:	79 81       	ldd	r23, Y+1	; 0x01
     d78:	86 17       	cp	r24, r22
     d7a:	97 07       	cpc	r25, r23
     d7c:	30 f4       	brcc	.+12     	; 0xd8a <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d7e:	8a 81       	ldd	r24, Y+2	; 0x02
     d80:	9b 81       	ldd	r25, Y+3	; 0x03
     d82:	28 0f       	add	r18, r24
     d84:	39 1f       	adc	r19, r25
     d86:	3f 83       	std	Y+7, r19	; 0x07
     d88:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     d8a:	12 30       	cpi	r17, 0x02	; 2
     d8c:	61 f4       	brne	.+24     	; 0xda6 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     d8e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d90:	88 23       	and	r24, r24
     d92:	59 f0       	breq	.+22     	; 0xdaa <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     d94:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d96:	81 50       	subi	r24, 0x01	; 1
     d98:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d9a:	80 e0       	ldi	r24, 0x00	; 0
     d9c:	07 c0       	rjmp	.+14     	; 0xdac <prvCopyDataToQueue+0xb6>
     d9e:	80 e0       	ldi	r24, 0x00	; 0
     da0:	05 c0       	rjmp	.+10     	; 0xdac <prvCopyDataToQueue+0xb6>
     da2:	80 e0       	ldi	r24, 0x00	; 0
     da4:	03 c0       	rjmp	.+6      	; 0xdac <prvCopyDataToQueue+0xb6>
     da6:	80 e0       	ldi	r24, 0x00	; 0
     da8:	01 c0       	rjmp	.+2      	; 0xdac <prvCopyDataToQueue+0xb6>
     daa:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     dac:	9a 8d       	ldd	r25, Y+26	; 0x1a
     dae:	9f 5f       	subi	r25, 0xFF	; 255
     db0:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	08 95       	ret

00000dba <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     dba:	fc 01       	movw	r30, r24
     dbc:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     dbe:	44 8d       	ldd	r20, Z+28	; 0x1c
     dc0:	44 23       	and	r20, r20
     dc2:	a1 f0       	breq	.+40     	; 0xdec <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     dc4:	50 e0       	ldi	r21, 0x00	; 0
     dc6:	26 81       	ldd	r18, Z+6	; 0x06
     dc8:	37 81       	ldd	r19, Z+7	; 0x07
     dca:	24 0f       	add	r18, r20
     dcc:	35 1f       	adc	r19, r21
     dce:	37 83       	std	Z+7, r19	; 0x07
     dd0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     dd2:	62 81       	ldd	r22, Z+2	; 0x02
     dd4:	73 81       	ldd	r23, Z+3	; 0x03
     dd6:	26 17       	cp	r18, r22
     dd8:	37 07       	cpc	r19, r23
     dda:	20 f0       	brcs	.+8      	; 0xde4 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ddc:	20 81       	ld	r18, Z
     dde:	31 81       	ldd	r19, Z+1	; 0x01
     de0:	37 83       	std	Z+7, r19	; 0x07
     de2:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     de4:	66 81       	ldd	r22, Z+6	; 0x06
     de6:	77 81       	ldd	r23, Z+7	; 0x07
     de8:	0c 94 37 0f 	jmp	0x1e6e	; 0x1e6e <memcpy>
     dec:	08 95       	ret

00000dee <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	cf 93       	push	r28
     df4:	df 93       	push	r29
     df6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     df8:	0f b6       	in	r0, 0x3f	; 63
     dfa:	f8 94       	cli
     dfc:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     dfe:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e00:	18 16       	cp	r1, r24
     e02:	a4 f4       	brge	.+40     	; 0xe2c <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e04:	89 89       	ldd	r24, Y+17	; 0x11
     e06:	88 23       	and	r24, r24
     e08:	89 f0       	breq	.+34     	; 0xe2c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e0a:	8e 01       	movw	r16, r28
     e0c:	0f 5e       	subi	r16, 0xEF	; 239
     e0e:	1f 4f       	sbci	r17, 0xFF	; 255
     e10:	03 c0       	rjmp	.+6      	; 0xe18 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e12:	89 89       	ldd	r24, Y+17	; 0x11
     e14:	88 23       	and	r24, r24
     e16:	51 f0       	breq	.+20     	; 0xe2c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e18:	c8 01       	movw	r24, r16
     e1a:	c4 d6       	rcall	.+3464   	; 0x1ba4 <xTaskRemoveFromEventList>
     e1c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     e1e:	4d d7       	rcall	.+3738   	; 0x1cba <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     e20:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e22:	81 50       	subi	r24, 0x01	; 1
     e24:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     e26:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e28:	18 16       	cp	r1, r24
     e2a:	9c f3       	brlt	.-26     	; 0xe12 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e30:	0f 90       	pop	r0
     e32:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e34:	0f b6       	in	r0, 0x3f	; 63
     e36:	f8 94       	cli
     e38:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e3a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e3c:	18 16       	cp	r1, r24
     e3e:	a4 f4       	brge	.+40     	; 0xe68 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e40:	88 85       	ldd	r24, Y+8	; 0x08
     e42:	88 23       	and	r24, r24
     e44:	89 f0       	breq	.+34     	; 0xe68 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e46:	8e 01       	movw	r16, r28
     e48:	08 5f       	subi	r16, 0xF8	; 248
     e4a:	1f 4f       	sbci	r17, 0xFF	; 255
     e4c:	03 c0       	rjmp	.+6      	; 0xe54 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e4e:	88 85       	ldd	r24, Y+8	; 0x08
     e50:	88 23       	and	r24, r24
     e52:	51 f0       	breq	.+20     	; 0xe68 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e54:	c8 01       	movw	r24, r16
     e56:	a6 d6       	rcall	.+3404   	; 0x1ba4 <xTaskRemoveFromEventList>
     e58:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     e5a:	2f d7       	rcall	.+3678   	; 0x1cba <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     e5c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e62:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e64:	18 16       	cp	r1, r24
     e66:	9c f3       	brlt	.-26     	; 0xe4e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     e68:	8f ef       	ldi	r24, 0xFF	; 255
     e6a:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e6c:	0f 90       	pop	r0
     e6e:	0f be       	out	0x3f, r0	; 63
}
     e70:	df 91       	pop	r29
     e72:	cf 91       	pop	r28
     e74:	1f 91       	pop	r17
     e76:	0f 91       	pop	r16
     e78:	08 95       	ret

00000e7a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     e7a:	cf 93       	push	r28
     e7c:	df 93       	push	r29
     e7e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     e80:	0f b6       	in	r0, 0x3f	; 63
     e82:	f8 94       	cli
     e84:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     e86:	88 81       	ld	r24, Y
     e88:	99 81       	ldd	r25, Y+1	; 0x01
     e8a:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e8c:	30 e0       	ldi	r19, 0x00	; 0
     e8e:	7b 8d       	ldd	r23, Y+27	; 0x1b
     e90:	72 9f       	mul	r23, r18
     e92:	a0 01       	movw	r20, r0
     e94:	73 9f       	mul	r23, r19
     e96:	50 0d       	add	r21, r0
     e98:	11 24       	eor	r1, r1
     e9a:	fc 01       	movw	r30, r24
     e9c:	e4 0f       	add	r30, r20
     e9e:	f5 1f       	adc	r31, r21
     ea0:	fb 83       	std	Y+3, r31	; 0x03
     ea2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     ea4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     ea6:	9d 83       	std	Y+5, r25	; 0x05
     ea8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     eaa:	42 1b       	sub	r20, r18
     eac:	53 0b       	sbc	r21, r19
     eae:	84 0f       	add	r24, r20
     eb0:	95 1f       	adc	r25, r21
     eb2:	9f 83       	std	Y+7, r25	; 0x07
     eb4:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     eb6:	8f ef       	ldi	r24, 0xFF	; 255
     eb8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     eba:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     ebc:	61 11       	cpse	r22, r1
     ebe:	0a c0       	rjmp	.+20     	; 0xed4 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ec0:	88 85       	ldd	r24, Y+8	; 0x08
     ec2:	88 23       	and	r24, r24
     ec4:	69 f0       	breq	.+26     	; 0xee0 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ec6:	ce 01       	movw	r24, r28
     ec8:	08 96       	adiw	r24, 0x08	; 8
     eca:	6c d6       	rcall	.+3288   	; 0x1ba4 <xTaskRemoveFromEventList>
     ecc:	81 30       	cpi	r24, 0x01	; 1
     ece:	41 f4       	brne	.+16     	; 0xee0 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
     ed0:	4e de       	rcall	.-868    	; 0xb6e <vPortYield>
     ed2:	06 c0       	rjmp	.+12     	; 0xee0 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     ed4:	ce 01       	movw	r24, r28
     ed6:	08 96       	adiw	r24, 0x08	; 8
     ed8:	8f da       	rcall	.-2786   	; 0x3f8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     eda:	ce 01       	movw	r24, r28
     edc:	41 96       	adiw	r24, 0x11	; 17
     ede:	8c da       	rcall	.-2792   	; 0x3f8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     ee0:	0f 90       	pop	r0
     ee2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	08 95       	ret

00000eec <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     eec:	0f 93       	push	r16
     eee:	1f 93       	push	r17
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	18 2f       	mov	r17, r24
     ef6:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
     ef8:	88 23       	and	r24, r24
     efa:	d1 f0       	breq	.+52     	; 0xf30 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
     efc:	8f e1       	ldi	r24, 0x1F	; 31
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	45 da       	rcall	.-2934   	; 0x38c <pvPortMalloc>
     f02:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f04:	00 97       	sbiw	r24, 0x00	; 0
     f06:	b1 f0       	breq	.+44     	; 0xf34 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f08:	10 9f       	mul	r17, r16
     f0a:	c0 01       	movw	r24, r0
     f0c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
     f0e:	01 96       	adiw	r24, 0x01	; 1
     f10:	3d da       	rcall	.-2950   	; 0x38c <pvPortMalloc>
     f12:	99 83       	std	Y+1, r25	; 0x01
     f14:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     f16:	89 2b       	or	r24, r25
     f18:	31 f0       	breq	.+12     	; 0xf26 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     f1a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     f1c:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     f1e:	61 e0       	ldi	r22, 0x01	; 1
     f20:	ce 01       	movw	r24, r28
     f22:	ab df       	rcall	.-170    	; 0xe7a <xQueueGenericReset>
     f24:	07 c0       	rjmp	.+14     	; 0xf34 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     f26:	ce 01       	movw	r24, r28
     f28:	66 da       	rcall	.-2868   	; 0x3f6 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
     f2a:	c0 e0       	ldi	r28, 0x00	; 0
     f2c:	d0 e0       	ldi	r29, 0x00	; 0
     f2e:	02 c0       	rjmp	.+4      	; 0xf34 <xQueueGenericCreate+0x48>
     f30:	c0 e0       	ldi	r28, 0x00	; 0
     f32:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     f34:	ce 01       	movw	r24, r28
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	08 95       	ret

00000f40 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     f40:	9f 92       	push	r9
     f42:	af 92       	push	r10
     f44:	bf 92       	push	r11
     f46:	cf 92       	push	r12
     f48:	df 92       	push	r13
     f4a:	ef 92       	push	r14
     f4c:	ff 92       	push	r15
     f4e:	0f 93       	push	r16
     f50:	1f 93       	push	r17
     f52:	cf 93       	push	r28
     f54:	df 93       	push	r29
     f56:	00 d0       	rcall	.+0      	; 0xf58 <xQueueGenericSend+0x18>
     f58:	1f 92       	push	r1
     f5a:	1f 92       	push	r1
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	8c 01       	movw	r16, r24
     f62:	6b 01       	movw	r12, r22
     f64:	5d 83       	std	Y+5, r21	; 0x05
     f66:	4c 83       	std	Y+4, r20	; 0x04
     f68:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     f6a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     f6c:	99 24       	eor	r9, r9
     f6e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f70:	7c 01       	movw	r14, r24
     f72:	88 e0       	ldi	r24, 0x08	; 8
     f74:	e8 0e       	add	r14, r24
     f76:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f7e:	f8 01       	movw	r30, r16
     f80:	92 8d       	ldd	r25, Z+26	; 0x1a
     f82:	83 8d       	ldd	r24, Z+27	; 0x1b
     f84:	98 17       	cp	r25, r24
     f86:	18 f0       	brcs	.+6      	; 0xf8e <xQueueGenericSend+0x4e>
     f88:	f2 e0       	ldi	r31, 0x02	; 2
     f8a:	af 12       	cpse	r10, r31
     f8c:	15 c0       	rjmp	.+42     	; 0xfb8 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f8e:	4a 2d       	mov	r20, r10
     f90:	b6 01       	movw	r22, r12
     f92:	c8 01       	movw	r24, r16
     f94:	b0 de       	rcall	.-672    	; 0xcf6 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f96:	f8 01       	movw	r30, r16
     f98:	91 89       	ldd	r25, Z+17	; 0x11
     f9a:	99 23       	and	r25, r25
     f9c:	39 f0       	breq	.+14     	; 0xfac <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     f9e:	c8 01       	movw	r24, r16
     fa0:	41 96       	adiw	r24, 0x11	; 17
     fa2:	00 d6       	rcall	.+3072   	; 0x1ba4 <xTaskRemoveFromEventList>
     fa4:	81 30       	cpi	r24, 0x01	; 1
     fa6:	21 f4       	brne	.+8      	; 0xfb0 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     fa8:	e2 dd       	rcall	.-1084   	; 0xb6e <vPortYield>
     faa:	02 c0       	rjmp	.+4      	; 0xfb0 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     fac:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     fae:	df dd       	rcall	.-1090   	; 0xb6e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     fb0:	0f 90       	pop	r0
     fb2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	46 c0       	rjmp	.+140    	; 0x1044 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     fb8:	ec 81       	ldd	r30, Y+4	; 0x04
     fba:	fd 81       	ldd	r31, Y+5	; 0x05
     fbc:	ef 2b       	or	r30, r31
     fbe:	21 f4       	brne	.+8      	; 0xfc8 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     fc4:	80 e0       	ldi	r24, 0x00	; 0
     fc6:	3e c0       	rjmp	.+124    	; 0x1044 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
     fc8:	b1 10       	cpse	r11, r1
     fca:	04 c0       	rjmp	.+8      	; 0xfd4 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     fcc:	ce 01       	movw	r24, r28
     fce:	01 96       	adiw	r24, 0x01	; 1
     fd0:	31 d6       	rcall	.+3170   	; 0x1c34 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     fd2:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     fd4:	0f 90       	pop	r0
     fd6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     fd8:	76 d3       	rcall	.+1772   	; 0x16c6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     fda:	0f b6       	in	r0, 0x3f	; 63
     fdc:	f8 94       	cli
     fde:	0f 92       	push	r0
     fe0:	f8 01       	movw	r30, r16
     fe2:	85 8d       	ldd	r24, Z+29	; 0x1d
     fe4:	8f 3f       	cpi	r24, 0xFF	; 255
     fe6:	09 f4       	brne	.+2      	; 0xfea <xQueueGenericSend+0xaa>
     fe8:	15 8e       	std	Z+29, r1	; 0x1d
     fea:	f8 01       	movw	r30, r16
     fec:	86 8d       	ldd	r24, Z+30	; 0x1e
     fee:	8f 3f       	cpi	r24, 0xFF	; 255
     ff0:	09 f4       	brne	.+2      	; 0xff4 <xQueueGenericSend+0xb4>
     ff2:	16 8e       	std	Z+30, r1	; 0x1e
     ff4:	0f 90       	pop	r0
     ff6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ff8:	be 01       	movw	r22, r28
     ffa:	6c 5f       	subi	r22, 0xFC	; 252
     ffc:	7f 4f       	sbci	r23, 0xFF	; 255
     ffe:	ce 01       	movw	r24, r28
    1000:	01 96       	adiw	r24, 0x01	; 1
    1002:	23 d6       	rcall	.+3142   	; 0x1c4a <xTaskCheckForTimeOut>
    1004:	81 11       	cpse	r24, r1
    1006:	1a c0       	rjmp	.+52     	; 0x103c <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    100e:	f8 01       	movw	r30, r16
    1010:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1012:	0f 90       	pop	r0
    1014:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1016:	f8 01       	movw	r30, r16
    1018:	83 8d       	ldd	r24, Z+27	; 0x1b
    101a:	98 13       	cpse	r25, r24
    101c:	0b c0       	rjmp	.+22     	; 0x1034 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    101e:	6c 81       	ldd	r22, Y+4	; 0x04
    1020:	7d 81       	ldd	r23, Y+5	; 0x05
    1022:	c7 01       	movw	r24, r14
    1024:	94 d5       	rcall	.+2856   	; 0x1b4e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1026:	c8 01       	movw	r24, r16
    1028:	e2 de       	rcall	.-572    	; 0xdee <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    102a:	11 d4       	rcall	.+2082   	; 0x184e <xTaskResumeAll>
    102c:	81 11       	cpse	r24, r1
    102e:	a4 cf       	rjmp	.-184    	; 0xf78 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1030:	9e dd       	rcall	.-1220   	; 0xb6e <vPortYield>
    1032:	a2 cf       	rjmp	.-188    	; 0xf78 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1034:	c8 01       	movw	r24, r16
    1036:	db de       	rcall	.-586    	; 0xdee <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1038:	0a d4       	rcall	.+2068   	; 0x184e <xTaskResumeAll>
    103a:	9e cf       	rjmp	.-196    	; 0xf78 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    103c:	c8 01       	movw	r24, r16
    103e:	d7 de       	rcall	.-594    	; 0xdee <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1040:	06 d4       	rcall	.+2060   	; 0x184e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1042:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1044:	0f 90       	pop	r0
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	0f 90       	pop	r0
    104c:	0f 90       	pop	r0
    104e:	df 91       	pop	r29
    1050:	cf 91       	pop	r28
    1052:	1f 91       	pop	r17
    1054:	0f 91       	pop	r16
    1056:	ff 90       	pop	r15
    1058:	ef 90       	pop	r14
    105a:	df 90       	pop	r13
    105c:	cf 90       	pop	r12
    105e:	bf 90       	pop	r11
    1060:	af 90       	pop	r10
    1062:	9f 90       	pop	r9
    1064:	08 95       	ret

00001066 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    106a:	8f e1       	ldi	r24, 0x1F	; 31
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	8e d9       	rcall	.-3300   	; 0x38c <pvPortMalloc>
    1070:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1072:	00 97       	sbiw	r24, 0x00	; 0
    1074:	e1 f0       	breq	.+56     	; 0x10ae <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1076:	1b 82       	std	Y+3, r1	; 0x03
    1078:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    107a:	19 82       	std	Y+1, r1	; 0x01
    107c:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    107e:	1d 82       	std	Y+5, r1	; 0x05
    1080:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1082:	1f 82       	std	Y+7, r1	; 0x07
    1084:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1086:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    108c:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    108e:	8f ef       	ldi	r24, 0xFF	; 255
    1090:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1092:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1094:	ce 01       	movw	r24, r28
    1096:	08 96       	adiw	r24, 0x08	; 8
    1098:	af d9       	rcall	.-3234   	; 0x3f8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    109a:	ce 01       	movw	r24, r28
    109c:	41 96       	adiw	r24, 0x11	; 17
    109e:	ac d9       	rcall	.-3240   	; 0x3f8 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    10a0:	20 e0       	ldi	r18, 0x00	; 0
    10a2:	40 e0       	ldi	r20, 0x00	; 0
    10a4:	50 e0       	ldi	r21, 0x00	; 0
    10a6:	60 e0       	ldi	r22, 0x00	; 0
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	ce 01       	movw	r24, r28
    10ac:	49 df       	rcall	.-366    	; 0xf40 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    10ae:	ce 01       	movw	r24, r28
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	08 95       	ret

000010b6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    10b6:	0f 93       	push	r16
    10b8:	1f 93       	push	r17
    10ba:	cf 93       	push	r28
    10bc:	df 93       	push	r29
    10be:	ec 01       	movw	r28, r24
    10c0:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    10c2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    10c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    10c6:	98 17       	cp	r25, r24
    10c8:	10 f0       	brcs	.+4      	; 0x10ce <xQueueGenericSendFromISR+0x18>
    10ca:	22 30       	cpi	r18, 0x02	; 2
    10cc:	11 f5       	brne	.+68     	; 0x1112 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    10ce:	42 2f       	mov	r20, r18
    10d0:	ce 01       	movw	r24, r28
    10d2:	11 de       	rcall	.-990    	; 0xcf6 <prvCopyDataToQueue>
    10d4:	88 23       	and	r24, r24
    10d6:	31 f0       	breq	.+12     	; 0x10e4 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    10d8:	01 15       	cp	r16, r1
    10da:	11 05       	cpc	r17, r1
    10dc:	19 f0       	breq	.+6      	; 0x10e4 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	f8 01       	movw	r30, r16
    10e2:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    10e4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10e6:	8f 3f       	cpi	r24, 0xFF	; 255
    10e8:	79 f4       	brne	.+30     	; 0x1108 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10ea:	89 89       	ldd	r24, Y+17	; 0x11
    10ec:	88 23       	and	r24, r24
    10ee:	99 f0       	breq	.+38     	; 0x1116 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10f0:	ce 01       	movw	r24, r28
    10f2:	41 96       	adiw	r24, 0x11	; 17
    10f4:	57 d5       	rcall	.+2734   	; 0x1ba4 <xTaskRemoveFromEventList>
    10f6:	88 23       	and	r24, r24
    10f8:	81 f0       	breq	.+32     	; 0x111a <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    10fa:	01 15       	cp	r16, r1
    10fc:	11 05       	cpc	r17, r1
    10fe:	79 f0       	breq	.+30     	; 0x111e <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	f8 01       	movw	r30, r16
    1104:	80 83       	st	Z, r24
    1106:	0c c0       	rjmp	.+24     	; 0x1120 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1108:	8e 8d       	ldd	r24, Y+30	; 0x1e
    110a:	8f 5f       	subi	r24, 0xFF	; 255
    110c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	07 c0       	rjmp	.+14     	; 0x1120 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	05 c0       	rjmp	.+10     	; 0x1120 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	03 c0       	rjmp	.+6      	; 0x1120 <xQueueGenericSendFromISR+0x6a>
    111a:	81 e0       	ldi	r24, 0x01	; 1
    111c:	01 c0       	rjmp	.+2      	; 0x1120 <xQueueGenericSendFromISR+0x6a>
    111e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	1f 91       	pop	r17
    1126:	0f 91       	pop	r16
    1128:	08 95       	ret

0000112a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    112a:	9f 92       	push	r9
    112c:	af 92       	push	r10
    112e:	bf 92       	push	r11
    1130:	cf 92       	push	r12
    1132:	df 92       	push	r13
    1134:	ef 92       	push	r14
    1136:	ff 92       	push	r15
    1138:	0f 93       	push	r16
    113a:	1f 93       	push	r17
    113c:	cf 93       	push	r28
    113e:	df 93       	push	r29
    1140:	00 d0       	rcall	.+0      	; 0x1142 <xQueueGenericReceive+0x18>
    1142:	1f 92       	push	r1
    1144:	1f 92       	push	r1
    1146:	cd b7       	in	r28, 0x3d	; 61
    1148:	de b7       	in	r29, 0x3e	; 62
    114a:	8c 01       	movw	r16, r24
    114c:	6b 01       	movw	r12, r22
    114e:	5d 83       	std	Y+5, r21	; 0x05
    1150:	4c 83       	std	Y+4, r20	; 0x04
    1152:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1154:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1156:	99 24       	eor	r9, r9
    1158:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    115a:	7c 01       	movw	r14, r24
    115c:	81 e1       	ldi	r24, 0x11	; 17
    115e:	e8 0e       	add	r14, r24
    1160:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1162:	0f b6       	in	r0, 0x3f	; 63
    1164:	f8 94       	cli
    1166:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1168:	f8 01       	movw	r30, r16
    116a:	82 8d       	ldd	r24, Z+26	; 0x1a
    116c:	88 23       	and	r24, r24
    116e:	69 f1       	breq	.+90     	; 0x11ca <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1170:	e6 80       	ldd	r14, Z+6	; 0x06
    1172:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1174:	b6 01       	movw	r22, r12
    1176:	c8 01       	movw	r24, r16
    1178:	20 de       	rcall	.-960    	; 0xdba <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    117a:	b1 10       	cpse	r11, r1
    117c:	17 c0       	rjmp	.+46     	; 0x11ac <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    117e:	f8 01       	movw	r30, r16
    1180:	82 8d       	ldd	r24, Z+26	; 0x1a
    1182:	81 50       	subi	r24, 0x01	; 1
    1184:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1186:	80 81       	ld	r24, Z
    1188:	91 81       	ldd	r25, Z+1	; 0x01
    118a:	89 2b       	or	r24, r25
    118c:	21 f4       	brne	.+8      	; 0x1196 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    118e:	36 d6       	rcall	.+3180   	; 0x1dfc <pvTaskIncrementMutexHeldCount>
    1190:	f8 01       	movw	r30, r16
    1192:	93 83       	std	Z+3, r25	; 0x03
    1194:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1196:	f8 01       	movw	r30, r16
    1198:	80 85       	ldd	r24, Z+8	; 0x08
    119a:	88 23       	and	r24, r24
    119c:	91 f0       	breq	.+36     	; 0x11c2 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    119e:	c8 01       	movw	r24, r16
    11a0:	08 96       	adiw	r24, 0x08	; 8
    11a2:	00 d5       	rcall	.+2560   	; 0x1ba4 <xTaskRemoveFromEventList>
    11a4:	81 30       	cpi	r24, 0x01	; 1
    11a6:	69 f4       	brne	.+26     	; 0x11c2 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11a8:	e2 dc       	rcall	.-1596   	; 0xb6e <vPortYield>
    11aa:	0b c0       	rjmp	.+22     	; 0x11c2 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11ac:	f8 01       	movw	r30, r16
    11ae:	f7 82       	std	Z+7, r15	; 0x07
    11b0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11b2:	81 89       	ldd	r24, Z+17	; 0x11
    11b4:	88 23       	and	r24, r24
    11b6:	29 f0       	breq	.+10     	; 0x11c2 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11b8:	c8 01       	movw	r24, r16
    11ba:	41 96       	adiw	r24, 0x11	; 17
    11bc:	f3 d4       	rcall	.+2534   	; 0x1ba4 <xTaskRemoveFromEventList>
    11be:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    11c0:	d6 dc       	rcall	.-1620   	; 0xb6e <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    11c2:	0f 90       	pop	r0
    11c4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11c6:	81 e0       	ldi	r24, 0x01	; 1
    11c8:	52 c0       	rjmp	.+164    	; 0x126e <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11ca:	4c 81       	ldd	r20, Y+4	; 0x04
    11cc:	5d 81       	ldd	r21, Y+5	; 0x05
    11ce:	45 2b       	or	r20, r21
    11d0:	21 f4       	brne	.+8      	; 0x11da <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11d2:	0f 90       	pop	r0
    11d4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    11d6:	80 e0       	ldi	r24, 0x00	; 0
    11d8:	4a c0       	rjmp	.+148    	; 0x126e <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    11da:	a1 10       	cpse	r10, r1
    11dc:	04 c0       	rjmp	.+8      	; 0x11e6 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11de:	ce 01       	movw	r24, r28
    11e0:	01 96       	adiw	r24, 0x01	; 1
    11e2:	28 d5       	rcall	.+2640   	; 0x1c34 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11e4:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11e6:	0f 90       	pop	r0
    11e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11ea:	6d d2       	rcall	.+1242   	; 0x16c6 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	0f 92       	push	r0
    11f2:	f8 01       	movw	r30, r16
    11f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    11f6:	8f 3f       	cpi	r24, 0xFF	; 255
    11f8:	09 f4       	brne	.+2      	; 0x11fc <xQueueGenericReceive+0xd2>
    11fa:	15 8e       	std	Z+29, r1	; 0x1d
    11fc:	f8 01       	movw	r30, r16
    11fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1200:	8f 3f       	cpi	r24, 0xFF	; 255
    1202:	09 f4       	brne	.+2      	; 0x1206 <xQueueGenericReceive+0xdc>
    1204:	16 8e       	std	Z+30, r1	; 0x1e
    1206:	0f 90       	pop	r0
    1208:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    120a:	be 01       	movw	r22, r28
    120c:	6c 5f       	subi	r22, 0xFC	; 252
    120e:	7f 4f       	sbci	r23, 0xFF	; 255
    1210:	ce 01       	movw	r24, r28
    1212:	01 96       	adiw	r24, 0x01	; 1
    1214:	1a d5       	rcall	.+2612   	; 0x1c4a <xTaskCheckForTimeOut>
    1216:	81 11       	cpse	r24, r1
    1218:	26 c0       	rjmp	.+76     	; 0x1266 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1220:	f8 01       	movw	r30, r16
    1222:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1228:	81 11       	cpse	r24, r1
    122a:	19 c0       	rjmp	.+50     	; 0x125e <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    122c:	f8 01       	movw	r30, r16
    122e:	80 81       	ld	r24, Z
    1230:	91 81       	ldd	r25, Z+1	; 0x01
    1232:	89 2b       	or	r24, r25
    1234:	49 f4       	brne	.+18     	; 0x1248 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1236:	0f b6       	in	r0, 0x3f	; 63
    1238:	f8 94       	cli
    123a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    123c:	f8 01       	movw	r30, r16
    123e:	82 81       	ldd	r24, Z+2	; 0x02
    1240:	93 81       	ldd	r25, Z+3	; 0x03
    1242:	3f d5       	rcall	.+2686   	; 0x1cc2 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1248:	6c 81       	ldd	r22, Y+4	; 0x04
    124a:	7d 81       	ldd	r23, Y+5	; 0x05
    124c:	c7 01       	movw	r24, r14
    124e:	7f d4       	rcall	.+2302   	; 0x1b4e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1250:	c8 01       	movw	r24, r16
    1252:	cd dd       	rcall	.-1126   	; 0xdee <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1254:	fc d2       	rcall	.+1528   	; 0x184e <xTaskResumeAll>
    1256:	81 11       	cpse	r24, r1
    1258:	84 cf       	rjmp	.-248    	; 0x1162 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    125a:	89 dc       	rcall	.-1774   	; 0xb6e <vPortYield>
    125c:	82 cf       	rjmp	.-252    	; 0x1162 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    125e:	c8 01       	movw	r24, r16
    1260:	c6 dd       	rcall	.-1140   	; 0xdee <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1262:	f5 d2       	rcall	.+1514   	; 0x184e <xTaskResumeAll>
    1264:	7e cf       	rjmp	.-260    	; 0x1162 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1266:	c8 01       	movw	r24, r16
    1268:	c2 dd       	rcall	.-1148   	; 0xdee <prvUnlockQueue>
			( void ) xTaskResumeAll();
    126a:	f1 d2       	rcall	.+1506   	; 0x184e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    126c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    126e:	0f 90       	pop	r0
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	cf 90       	pop	r12
    1288:	bf 90       	pop	r11
    128a:	af 90       	pop	r10
    128c:	9f 90       	pop	r9
    128e:	08 95       	ret

00001290 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1290:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1292:	71 83       	std	Z+1, r23	; 0x01
    1294:	60 83       	st	Z, r22
	ring->rSize = size;
    1296:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1298:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    129a:	13 82       	std	Z+3, r1	; 0x03
    129c:	08 95       	ret

0000129e <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    129e:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    12a0:	94 81       	ldd	r25, Z+4	; 0x04
    12a2:	a0 81       	ld	r26, Z
    12a4:	b1 81       	ldd	r27, Z+1	; 0x01
    12a6:	a9 0f       	add	r26, r25
    12a8:	b1 1d       	adc	r27, r1
    12aa:	8c 91       	ld	r24, X
            ring->rIndex ++;
    12ac:	9f 5f       	subi	r25, 0xFF	; 255
    12ae:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    12b0:	22 81       	ldd	r18, Z+2	; 0x02
    12b2:	92 17       	cp	r25, r18
    12b4:	10 f0       	brcs	.+4      	; 0x12ba <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    12b6:	92 1b       	sub	r25, r18
    12b8:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    12ba:	93 81       	ldd	r25, Z+3	; 0x03
    12bc:	91 50       	subi	r25, 0x01	; 1
    12be:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    12c0:	08 95       	ret

000012c2 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    12c2:	fc 01       	movw	r30, r24
    12c4:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    12c6:	83 81       	ldd	r24, Z+3	; 0x03
    12c8:	22 81       	ldd	r18, Z+2	; 0x02
    12ca:	82 17       	cp	r24, r18
    12cc:	78 f4       	brcc	.+30     	; 0x12ec <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    12ce:	34 81       	ldd	r19, Z+4	; 0x04
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	83 0f       	add	r24, r19
    12d4:	91 1d       	adc	r25, r1
    12d6:	62 2f       	mov	r22, r18
    12d8:	70 e0       	ldi	r23, 0x00	; 0
    12da:	a2 d5       	rcall	.+2884   	; 0x1e20 <__divmodhi4>
    12dc:	a0 81       	ld	r26, Z
    12de:	b1 81       	ldd	r27, Z+1	; 0x01
    12e0:	a8 0f       	add	r26, r24
    12e2:	b9 1f       	adc	r27, r25
    12e4:	4c 93       	st	X, r20
            ring->rLength++;
    12e6:	83 81       	ldd	r24, Z+3	; 0x03
    12e8:	8f 5f       	subi	r24, 0xFF	; 255
    12ea:	83 83       	std	Z+3, r24	; 0x03
    12ec:	08 95       	ret

000012ee <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    12ee:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	22 81       	ldd	r18, Z+2	; 0x02
    12f4:	93 81       	ldd	r25, Z+3	; 0x03
    12f6:	29 13       	cpse	r18, r25
    12f8:	80 e0       	ldi	r24, 0x00	; 0
}
    12fa:	08 95       	ret

000012fc <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    12fc:	21 e0       	ldi	r18, 0x01	; 1
    12fe:	fc 01       	movw	r30, r24
    1300:	83 81       	ldd	r24, Z+3	; 0x03
    1302:	81 11       	cpse	r24, r1
    1304:	01 c0       	rjmp	.+2      	; 0x1308 <ringBufferNotEmpty+0xc>
    1306:	20 e0       	ldi	r18, 0x00	; 0
}
    1308:	82 2f       	mov	r24, r18
    130a:	08 95       	ret

0000130c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    130c:	e0 91 94 08 	lds	r30, 0x0894
    1310:	f0 91 95 08 	lds	r31, 0x0895
    1314:	80 81       	ld	r24, Z
    1316:	81 11       	cpse	r24, r1
    1318:	07 c0       	rjmp	.+14     	; 0x1328 <prvResetNextTaskUnblockTime+0x1c>
    131a:	8f ef       	ldi	r24, 0xFF	; 255
    131c:	9f ef       	ldi	r25, 0xFF	; 255
    131e:	90 93 02 02 	sts	0x0202, r25
    1322:	80 93 01 02 	sts	0x0201, r24
    1326:	08 95       	ret
    1328:	e0 91 94 08 	lds	r30, 0x0894
    132c:	f0 91 95 08 	lds	r31, 0x0895
    1330:	05 80       	ldd	r0, Z+5	; 0x05
    1332:	f6 81       	ldd	r31, Z+6	; 0x06
    1334:	e0 2d       	mov	r30, r0
    1336:	06 80       	ldd	r0, Z+6	; 0x06
    1338:	f7 81       	ldd	r31, Z+7	; 0x07
    133a:	e0 2d       	mov	r30, r0
    133c:	82 81       	ldd	r24, Z+2	; 0x02
    133e:	93 81       	ldd	r25, Z+3	; 0x03
    1340:	90 93 02 02 	sts	0x0202, r25
    1344:	80 93 01 02 	sts	0x0201, r24
    1348:	08 95       	ret

0000134a <prvAddCurrentTaskToDelayedList>:
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	ec 01       	movw	r28, r24
    1350:	e0 91 d5 08 	lds	r30, 0x08D5
    1354:	f0 91 d6 08 	lds	r31, 0x08D6
    1358:	93 83       	std	Z+3, r25	; 0x03
    135a:	82 83       	std	Z+2, r24	; 0x02
    135c:	80 91 73 08 	lds	r24, 0x0873
    1360:	90 91 74 08 	lds	r25, 0x0874
    1364:	c8 17       	cp	r28, r24
    1366:	d9 07       	cpc	r29, r25
    1368:	60 f4       	brcc	.+24     	; 0x1382 <prvAddCurrentTaskToDelayedList+0x38>
    136a:	60 91 d5 08 	lds	r22, 0x08D5
    136e:	70 91 d6 08 	lds	r23, 0x08D6
    1372:	80 91 92 08 	lds	r24, 0x0892
    1376:	90 91 93 08 	lds	r25, 0x0893
    137a:	6e 5f       	subi	r22, 0xFE	; 254
    137c:	7f 4f       	sbci	r23, 0xFF	; 255
    137e:	6f d8       	rcall	.-3874   	; 0x45e <vListInsert>
    1380:	16 c0       	rjmp	.+44     	; 0x13ae <prvAddCurrentTaskToDelayedList+0x64>
    1382:	60 91 d5 08 	lds	r22, 0x08D5
    1386:	70 91 d6 08 	lds	r23, 0x08D6
    138a:	80 91 94 08 	lds	r24, 0x0894
    138e:	90 91 95 08 	lds	r25, 0x0895
    1392:	6e 5f       	subi	r22, 0xFE	; 254
    1394:	7f 4f       	sbci	r23, 0xFF	; 255
    1396:	63 d8       	rcall	.-3898   	; 0x45e <vListInsert>
    1398:	80 91 01 02 	lds	r24, 0x0201
    139c:	90 91 02 02 	lds	r25, 0x0202
    13a0:	c8 17       	cp	r28, r24
    13a2:	d9 07       	cpc	r29, r25
    13a4:	20 f4       	brcc	.+8      	; 0x13ae <prvAddCurrentTaskToDelayedList+0x64>
    13a6:	d0 93 02 02 	sts	0x0202, r29
    13aa:	c0 93 01 02 	sts	0x0201, r28
    13ae:	df 91       	pop	r29
    13b0:	cf 91       	pop	r28
    13b2:	08 95       	ret

000013b4 <xTaskGenericCreate>:
    13b4:	4f 92       	push	r4
    13b6:	5f 92       	push	r5
    13b8:	6f 92       	push	r6
    13ba:	7f 92       	push	r7
    13bc:	8f 92       	push	r8
    13be:	9f 92       	push	r9
    13c0:	af 92       	push	r10
    13c2:	bf 92       	push	r11
    13c4:	cf 92       	push	r12
    13c6:	df 92       	push	r13
    13c8:	ef 92       	push	r14
    13ca:	ff 92       	push	r15
    13cc:	0f 93       	push	r16
    13ce:	1f 93       	push	r17
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	4c 01       	movw	r8, r24
    13d6:	5b 01       	movw	r10, r22
    13d8:	2a 01       	movw	r4, r20
    13da:	39 01       	movw	r6, r18
    13dc:	83 e2       	ldi	r24, 0x23	; 35
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	0e 94 c6 01 	call	0x38c	; 0x38c <pvPortMalloc>
    13e4:	ec 01       	movw	r28, r24
    13e6:	00 97       	sbiw	r24, 0x00	; 0
    13e8:	09 f4       	brne	.+2      	; 0x13ec <xTaskGenericCreate+0x38>
    13ea:	e7 c0       	rjmp	.+462    	; 0x15ba <xTaskGenericCreate+0x206>
    13ec:	c1 14       	cp	r12, r1
    13ee:	d1 04       	cpc	r13, r1
    13f0:	09 f0       	breq	.+2      	; 0x13f4 <xTaskGenericCreate+0x40>
    13f2:	cc c0       	rjmp	.+408    	; 0x158c <xTaskGenericCreate+0x1d8>
    13f4:	c2 01       	movw	r24, r4
    13f6:	0e 94 c6 01 	call	0x38c	; 0x38c <pvPortMalloc>
    13fa:	98 8f       	std	Y+24, r25	; 0x18
    13fc:	8f 8b       	std	Y+23, r24	; 0x17
    13fe:	89 2b       	or	r24, r25
    1400:	09 f0       	breq	.+2      	; 0x1404 <xTaskGenericCreate+0x50>
    1402:	c6 c0       	rjmp	.+396    	; 0x1590 <xTaskGenericCreate+0x1dc>
    1404:	ce 01       	movw	r24, r28
    1406:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <vPortFree>
    140a:	d7 c0       	rjmp	.+430    	; 0x15ba <xTaskGenericCreate+0x206>
    140c:	cf 01       	movw	r24, r30
    140e:	31 91       	ld	r19, Z+
    1410:	da 01       	movw	r26, r20
    1412:	3d 93       	st	X+, r19
    1414:	ad 01       	movw	r20, r26
    1416:	dc 01       	movw	r26, r24
    1418:	8c 91       	ld	r24, X
    141a:	88 23       	and	r24, r24
    141c:	11 f0       	breq	.+4      	; 0x1422 <xTaskGenericCreate+0x6e>
    141e:	21 50       	subi	r18, 0x01	; 1
    1420:	a9 f7       	brne	.-22     	; 0x140c <xTaskGenericCreate+0x58>
    1422:	18 a2       	std	Y+32, r1	; 0x20
    1424:	10 2f       	mov	r17, r16
    1426:	05 30       	cpi	r16, 0x05	; 5
    1428:	08 f0       	brcs	.+2      	; 0x142c <xTaskGenericCreate+0x78>
    142a:	14 e0       	ldi	r17, 0x04	; 4
    142c:	1e 8b       	std	Y+22, r17	; 0x16
    142e:	19 a3       	std	Y+33, r17	; 0x21
    1430:	1a a2       	std	Y+34, r1	; 0x22
    1432:	5e 01       	movw	r10, r28
    1434:	b2 e0       	ldi	r27, 0x02	; 2
    1436:	ab 0e       	add	r10, r27
    1438:	b1 1c       	adc	r11, r1
    143a:	c5 01       	movw	r24, r10
    143c:	0e 94 0a 02 	call	0x414	; 0x414 <vListInitialiseItem>
    1440:	ce 01       	movw	r24, r28
    1442:	0c 96       	adiw	r24, 0x0c	; 12
    1444:	0e 94 0a 02 	call	0x414	; 0x414 <vListInitialiseItem>
    1448:	d9 87       	std	Y+9, r29	; 0x09
    144a:	c8 87       	std	Y+8, r28	; 0x08
    144c:	85 e0       	ldi	r24, 0x05	; 5
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	81 1b       	sub	r24, r17
    1452:	91 09       	sbc	r25, r1
    1454:	9d 87       	std	Y+13, r25	; 0x0d
    1456:	8c 87       	std	Y+12, r24	; 0x0c
    1458:	db 8b       	std	Y+19, r29	; 0x13
    145a:	ca 8b       	std	Y+18, r28	; 0x12
    145c:	a3 01       	movw	r20, r6
    145e:	b4 01       	movw	r22, r8
    1460:	c6 01       	movw	r24, r12
    1462:	d6 da       	rcall	.-2644   	; 0xa10 <pxPortInitialiseStack>
    1464:	99 83       	std	Y+1, r25	; 0x01
    1466:	88 83       	st	Y, r24
    1468:	e1 14       	cp	r14, r1
    146a:	f1 04       	cpc	r15, r1
    146c:	19 f0       	breq	.+6      	; 0x1474 <xTaskGenericCreate+0xc0>
    146e:	f7 01       	movw	r30, r14
    1470:	d1 83       	std	Z+1, r29	; 0x01
    1472:	c0 83       	st	Z, r28
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	f8 94       	cli
    1478:	0f 92       	push	r0
    147a:	80 91 75 08 	lds	r24, 0x0875
    147e:	8f 5f       	subi	r24, 0xFF	; 255
    1480:	80 93 75 08 	sts	0x0875, r24
    1484:	80 91 d5 08 	lds	r24, 0x08D5
    1488:	90 91 d6 08 	lds	r25, 0x08D6
    148c:	89 2b       	or	r24, r25
    148e:	09 f0       	breq	.+2      	; 0x1492 <xTaskGenericCreate+0xde>
    1490:	3f c0       	rjmp	.+126    	; 0x1510 <xTaskGenericCreate+0x15c>
    1492:	d0 93 d6 08 	sts	0x08D6, r29
    1496:	c0 93 d5 08 	sts	0x08D5, r28
    149a:	80 91 75 08 	lds	r24, 0x0875
    149e:	81 30       	cpi	r24, 0x01	; 1
    14a0:	09 f0       	breq	.+2      	; 0x14a4 <xTaskGenericCreate+0xf0>
    14a2:	45 c0       	rjmp	.+138    	; 0x152e <xTaskGenericCreate+0x17a>
    14a4:	0f 2e       	mov	r0, r31
    14a6:	f8 ea       	ldi	r31, 0xA8	; 168
    14a8:	ef 2e       	mov	r14, r31
    14aa:	f8 e0       	ldi	r31, 0x08	; 8
    14ac:	ff 2e       	mov	r15, r31
    14ae:	f0 2d       	mov	r31, r0
    14b0:	0f 2e       	mov	r0, r31
    14b2:	f5 ed       	ldi	r31, 0xD5	; 213
    14b4:	cf 2e       	mov	r12, r31
    14b6:	f8 e0       	ldi	r31, 0x08	; 8
    14b8:	df 2e       	mov	r13, r31
    14ba:	f0 2d       	mov	r31, r0
    14bc:	c7 01       	movw	r24, r14
    14be:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14c2:	f9 e0       	ldi	r31, 0x09	; 9
    14c4:	ef 0e       	add	r14, r31
    14c6:	f1 1c       	adc	r15, r1
    14c8:	ec 14       	cp	r14, r12
    14ca:	fd 04       	cpc	r15, r13
    14cc:	b9 f7       	brne	.-18     	; 0x14bc <xTaskGenericCreate+0x108>
    14ce:	8f e9       	ldi	r24, 0x9F	; 159
    14d0:	98 e0       	ldi	r25, 0x08	; 8
    14d2:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14d6:	86 e9       	ldi	r24, 0x96	; 150
    14d8:	98 e0       	ldi	r25, 0x08	; 8
    14da:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14de:	89 e8       	ldi	r24, 0x89	; 137
    14e0:	98 e0       	ldi	r25, 0x08	; 8
    14e2:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14e6:	80 e8       	ldi	r24, 0x80	; 128
    14e8:	98 e0       	ldi	r25, 0x08	; 8
    14ea:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14ee:	86 e7       	ldi	r24, 0x76	; 118
    14f0:	98 e0       	ldi	r25, 0x08	; 8
    14f2:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <vListInitialise>
    14f6:	8f e9       	ldi	r24, 0x9F	; 159
    14f8:	98 e0       	ldi	r25, 0x08	; 8
    14fa:	90 93 95 08 	sts	0x0895, r25
    14fe:	80 93 94 08 	sts	0x0894, r24
    1502:	86 e9       	ldi	r24, 0x96	; 150
    1504:	98 e0       	ldi	r25, 0x08	; 8
    1506:	90 93 93 08 	sts	0x0893, r25
    150a:	80 93 92 08 	sts	0x0892, r24
    150e:	0f c0       	rjmp	.+30     	; 0x152e <xTaskGenericCreate+0x17a>
    1510:	80 91 71 08 	lds	r24, 0x0871
    1514:	81 11       	cpse	r24, r1
    1516:	0b c0       	rjmp	.+22     	; 0x152e <xTaskGenericCreate+0x17a>
    1518:	e0 91 d5 08 	lds	r30, 0x08D5
    151c:	f0 91 d6 08 	lds	r31, 0x08D6
    1520:	86 89       	ldd	r24, Z+22	; 0x16
    1522:	08 17       	cp	r16, r24
    1524:	20 f0       	brcs	.+8      	; 0x152e <xTaskGenericCreate+0x17a>
    1526:	d0 93 d6 08 	sts	0x08D6, r29
    152a:	c0 93 d5 08 	sts	0x08D5, r28
    152e:	80 91 6d 08 	lds	r24, 0x086D
    1532:	8f 5f       	subi	r24, 0xFF	; 255
    1534:	80 93 6d 08 	sts	0x086D, r24
    1538:	8e 89       	ldd	r24, Y+22	; 0x16
    153a:	90 91 72 08 	lds	r25, 0x0872
    153e:	98 17       	cp	r25, r24
    1540:	10 f4       	brcc	.+4      	; 0x1546 <xTaskGenericCreate+0x192>
    1542:	80 93 72 08 	sts	0x0872, r24
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	9c 01       	movw	r18, r24
    154a:	22 0f       	add	r18, r18
    154c:	33 1f       	adc	r19, r19
    154e:	22 0f       	add	r18, r18
    1550:	33 1f       	adc	r19, r19
    1552:	22 0f       	add	r18, r18
    1554:	33 1f       	adc	r19, r19
    1556:	82 0f       	add	r24, r18
    1558:	93 1f       	adc	r25, r19
    155a:	b5 01       	movw	r22, r10
    155c:	88 55       	subi	r24, 0x58	; 88
    155e:	97 4f       	sbci	r25, 0xF7	; 247
    1560:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1564:	0f 90       	pop	r0
    1566:	0f be       	out	0x3f, r0	; 63
    1568:	80 91 71 08 	lds	r24, 0x0871
    156c:	88 23       	and	r24, r24
    156e:	51 f0       	breq	.+20     	; 0x1584 <xTaskGenericCreate+0x1d0>
    1570:	e0 91 d5 08 	lds	r30, 0x08D5
    1574:	f0 91 d6 08 	lds	r31, 0x08D6
    1578:	86 89       	ldd	r24, Z+22	; 0x16
    157a:	80 17       	cp	r24, r16
    157c:	28 f4       	brcc	.+10     	; 0x1588 <xTaskGenericCreate+0x1d4>
    157e:	f7 da       	rcall	.-2578   	; 0xb6e <vPortYield>
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	1c c0       	rjmp	.+56     	; 0x15bc <xTaskGenericCreate+0x208>
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	1a c0       	rjmp	.+52     	; 0x15bc <xTaskGenericCreate+0x208>
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	18 c0       	rjmp	.+48     	; 0x15bc <xTaskGenericCreate+0x208>
    158c:	d8 8e       	std	Y+24, r13	; 0x18
    158e:	cf 8a       	std	Y+23, r12	; 0x17
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	48 1a       	sub	r4, r24
    1594:	51 08       	sbc	r5, r1
    1596:	cf 88       	ldd	r12, Y+23	; 0x17
    1598:	d8 8c       	ldd	r13, Y+24	; 0x18
    159a:	c4 0c       	add	r12, r4
    159c:	d5 1c       	adc	r13, r5
    159e:	d5 01       	movw	r26, r10
    15a0:	8c 91       	ld	r24, X
    15a2:	89 8f       	std	Y+25, r24	; 0x19
    15a4:	8c 91       	ld	r24, X
    15a6:	88 23       	and	r24, r24
    15a8:	09 f4       	brne	.+2      	; 0x15ac <xTaskGenericCreate+0x1f8>
    15aa:	3b cf       	rjmp	.-394    	; 0x1422 <xTaskGenericCreate+0x6e>
    15ac:	ae 01       	movw	r20, r28
    15ae:	46 5e       	subi	r20, 0xE6	; 230
    15b0:	5f 4f       	sbci	r21, 0xFF	; 255
    15b2:	f5 01       	movw	r30, r10
    15b4:	31 96       	adiw	r30, 0x01	; 1
    15b6:	27 e0       	ldi	r18, 0x07	; 7
    15b8:	29 cf       	rjmp	.-430    	; 0x140c <xTaskGenericCreate+0x58>
    15ba:	8f ef       	ldi	r24, 0xFF	; 255
    15bc:	df 91       	pop	r29
    15be:	cf 91       	pop	r28
    15c0:	1f 91       	pop	r17
    15c2:	0f 91       	pop	r16
    15c4:	ff 90       	pop	r15
    15c6:	ef 90       	pop	r14
    15c8:	df 90       	pop	r13
    15ca:	cf 90       	pop	r12
    15cc:	bf 90       	pop	r11
    15ce:	af 90       	pop	r10
    15d0:	9f 90       	pop	r9
    15d2:	8f 90       	pop	r8
    15d4:	7f 90       	pop	r7
    15d6:	6f 90       	pop	r6
    15d8:	5f 90       	pop	r5
    15da:	4f 90       	pop	r4
    15dc:	08 95       	ret

000015de <vTaskResume>:
    15de:	0f 93       	push	r16
    15e0:	1f 93       	push	r17
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
    15e6:	ec 01       	movw	r28, r24
    15e8:	00 97       	sbiw	r24, 0x00	; 0
    15ea:	09 f4       	brne	.+2      	; 0x15ee <vTaskResume+0x10>
    15ec:	3e c0       	rjmp	.+124    	; 0x166a <vTaskResume+0x8c>
    15ee:	80 91 d5 08 	lds	r24, 0x08D5
    15f2:	90 91 d6 08 	lds	r25, 0x08D6
    15f6:	c8 17       	cp	r28, r24
    15f8:	d9 07       	cpc	r29, r25
    15fa:	b9 f1       	breq	.+110    	; 0x166a <vTaskResume+0x8c>
    15fc:	0f b6       	in	r0, 0x3f	; 63
    15fe:	f8 94       	cli
    1600:	0f 92       	push	r0
    1602:	8a 85       	ldd	r24, Y+10	; 0x0a
    1604:	9b 85       	ldd	r25, Y+11	; 0x0b
    1606:	86 57       	subi	r24, 0x76	; 118
    1608:	98 40       	sbci	r25, 0x08	; 8
    160a:	69 f5       	brne	.+90     	; 0x1666 <vTaskResume+0x88>
    160c:	8c 89       	ldd	r24, Y+20	; 0x14
    160e:	9d 89       	ldd	r25, Y+21	; 0x15
    1610:	28 e0       	ldi	r18, 0x08	; 8
    1612:	89 38       	cpi	r24, 0x89	; 137
    1614:	92 07       	cpc	r25, r18
    1616:	39 f1       	breq	.+78     	; 0x1666 <vTaskResume+0x88>
    1618:	89 2b       	or	r24, r25
    161a:	29 f5       	brne	.+74     	; 0x1666 <vTaskResume+0x88>
    161c:	8e 01       	movw	r16, r28
    161e:	0e 5f       	subi	r16, 0xFE	; 254
    1620:	1f 4f       	sbci	r17, 0xFF	; 255
    1622:	c8 01       	movw	r24, r16
    1624:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1628:	8e 89       	ldd	r24, Y+22	; 0x16
    162a:	90 91 72 08 	lds	r25, 0x0872
    162e:	98 17       	cp	r25, r24
    1630:	10 f4       	brcc	.+4      	; 0x1636 <vTaskResume+0x58>
    1632:	80 93 72 08 	sts	0x0872, r24
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	9c 01       	movw	r18, r24
    163a:	22 0f       	add	r18, r18
    163c:	33 1f       	adc	r19, r19
    163e:	22 0f       	add	r18, r18
    1640:	33 1f       	adc	r19, r19
    1642:	22 0f       	add	r18, r18
    1644:	33 1f       	adc	r19, r19
    1646:	82 0f       	add	r24, r18
    1648:	93 1f       	adc	r25, r19
    164a:	b8 01       	movw	r22, r16
    164c:	88 55       	subi	r24, 0x58	; 88
    164e:	97 4f       	sbci	r25, 0xF7	; 247
    1650:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1654:	e0 91 d5 08 	lds	r30, 0x08D5
    1658:	f0 91 d6 08 	lds	r31, 0x08D6
    165c:	9e 89       	ldd	r25, Y+22	; 0x16
    165e:	86 89       	ldd	r24, Z+22	; 0x16
    1660:	98 17       	cp	r25, r24
    1662:	08 f0       	brcs	.+2      	; 0x1666 <vTaskResume+0x88>
    1664:	84 da       	rcall	.-2808   	; 0xb6e <vPortYield>
    1666:	0f 90       	pop	r0
    1668:	0f be       	out	0x3f, r0	; 63
    166a:	df 91       	pop	r29
    166c:	cf 91       	pop	r28
    166e:	1f 91       	pop	r17
    1670:	0f 91       	pop	r16
    1672:	08 95       	ret

00001674 <vTaskStartScheduler>:
    1674:	af 92       	push	r10
    1676:	bf 92       	push	r11
    1678:	cf 92       	push	r12
    167a:	df 92       	push	r13
    167c:	ef 92       	push	r14
    167e:	ff 92       	push	r15
    1680:	0f 93       	push	r16
    1682:	a1 2c       	mov	r10, r1
    1684:	b1 2c       	mov	r11, r1
    1686:	c1 2c       	mov	r12, r1
    1688:	d1 2c       	mov	r13, r1
    168a:	e1 2c       	mov	r14, r1
    168c:	f1 2c       	mov	r15, r1
    168e:	00 e0       	ldi	r16, 0x00	; 0
    1690:	20 e0       	ldi	r18, 0x00	; 0
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	45 e5       	ldi	r20, 0x55	; 85
    1696:	50 e0       	ldi	r21, 0x00	; 0
    1698:	66 e8       	ldi	r22, 0x86	; 134
    169a:	72 e0       	ldi	r23, 0x02	; 2
    169c:	84 ec       	ldi	r24, 0xC4	; 196
    169e:	9c e0       	ldi	r25, 0x0C	; 12
    16a0:	89 de       	rcall	.-750    	; 0x13b4 <xTaskGenericCreate>
    16a2:	81 30       	cpi	r24, 0x01	; 1
    16a4:	41 f4       	brne	.+16     	; 0x16b6 <vTaskStartScheduler+0x42>
    16a6:	f8 94       	cli
    16a8:	80 93 71 08 	sts	0x0871, r24
    16ac:	10 92 74 08 	sts	0x0874, r1
    16b0:	10 92 73 08 	sts	0x0873, r1
    16b4:	1f da       	rcall	.-3010   	; 0xaf4 <xPortStartScheduler>
    16b6:	0f 91       	pop	r16
    16b8:	ff 90       	pop	r15
    16ba:	ef 90       	pop	r14
    16bc:	df 90       	pop	r13
    16be:	cf 90       	pop	r12
    16c0:	bf 90       	pop	r11
    16c2:	af 90       	pop	r10
    16c4:	08 95       	ret

000016c6 <vTaskSuspendAll>:
    16c6:	80 91 6c 08 	lds	r24, 0x086C
    16ca:	8f 5f       	subi	r24, 0xFF	; 255
    16cc:	80 93 6c 08 	sts	0x086C, r24
    16d0:	08 95       	ret

000016d2 <xTaskIncrementTick>:
    16d2:	cf 92       	push	r12
    16d4:	df 92       	push	r13
    16d6:	ef 92       	push	r14
    16d8:	ff 92       	push	r15
    16da:	0f 93       	push	r16
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	80 91 6c 08 	lds	r24, 0x086C
    16e6:	81 11       	cpse	r24, r1
    16e8:	99 c0       	rjmp	.+306    	; 0x181c <xTaskIncrementTick+0x14a>
    16ea:	80 91 73 08 	lds	r24, 0x0873
    16ee:	90 91 74 08 	lds	r25, 0x0874
    16f2:	01 96       	adiw	r24, 0x01	; 1
    16f4:	90 93 74 08 	sts	0x0874, r25
    16f8:	80 93 73 08 	sts	0x0873, r24
    16fc:	e0 90 73 08 	lds	r14, 0x0873
    1700:	f0 90 74 08 	lds	r15, 0x0874
    1704:	e1 14       	cp	r14, r1
    1706:	f1 04       	cpc	r15, r1
    1708:	b1 f4       	brne	.+44     	; 0x1736 <xTaskIncrementTick+0x64>
    170a:	80 91 94 08 	lds	r24, 0x0894
    170e:	90 91 95 08 	lds	r25, 0x0895
    1712:	20 91 92 08 	lds	r18, 0x0892
    1716:	30 91 93 08 	lds	r19, 0x0893
    171a:	30 93 95 08 	sts	0x0895, r19
    171e:	20 93 94 08 	sts	0x0894, r18
    1722:	90 93 93 08 	sts	0x0893, r25
    1726:	80 93 92 08 	sts	0x0892, r24
    172a:	80 91 6e 08 	lds	r24, 0x086E
    172e:	8f 5f       	subi	r24, 0xFF	; 255
    1730:	80 93 6e 08 	sts	0x086E, r24
    1734:	eb dd       	rcall	.-1066   	; 0x130c <prvResetNextTaskUnblockTime>
    1736:	80 91 01 02 	lds	r24, 0x0201
    173a:	90 91 02 02 	lds	r25, 0x0202
    173e:	e8 16       	cp	r14, r24
    1740:	f9 06       	cpc	r15, r25
    1742:	08 f4       	brcc	.+2      	; 0x1746 <xTaskIncrementTick+0x74>
    1744:	54 c0       	rjmp	.+168    	; 0x17ee <xTaskIncrementTick+0x11c>
    1746:	d1 2c       	mov	r13, r1
    1748:	cc 24       	eor	r12, r12
    174a:	c3 94       	inc	r12
    174c:	01 c0       	rjmp	.+2      	; 0x1750 <xTaskIncrementTick+0x7e>
    174e:	dc 2c       	mov	r13, r12
    1750:	e0 91 94 08 	lds	r30, 0x0894
    1754:	f0 91 95 08 	lds	r31, 0x0895
    1758:	80 81       	ld	r24, Z
    175a:	81 11       	cpse	r24, r1
    175c:	07 c0       	rjmp	.+14     	; 0x176c <xTaskIncrementTick+0x9a>
    175e:	8f ef       	ldi	r24, 0xFF	; 255
    1760:	9f ef       	ldi	r25, 0xFF	; 255
    1762:	90 93 02 02 	sts	0x0202, r25
    1766:	80 93 01 02 	sts	0x0201, r24
    176a:	42 c0       	rjmp	.+132    	; 0x17f0 <xTaskIncrementTick+0x11e>
    176c:	e0 91 94 08 	lds	r30, 0x0894
    1770:	f0 91 95 08 	lds	r31, 0x0895
    1774:	05 80       	ldd	r0, Z+5	; 0x05
    1776:	f6 81       	ldd	r31, Z+6	; 0x06
    1778:	e0 2d       	mov	r30, r0
    177a:	c6 81       	ldd	r28, Z+6	; 0x06
    177c:	d7 81       	ldd	r29, Z+7	; 0x07
    177e:	2a 81       	ldd	r18, Y+2	; 0x02
    1780:	3b 81       	ldd	r19, Y+3	; 0x03
    1782:	e2 16       	cp	r14, r18
    1784:	f3 06       	cpc	r15, r19
    1786:	28 f4       	brcc	.+10     	; 0x1792 <xTaskIncrementTick+0xc0>
    1788:	30 93 02 02 	sts	0x0202, r19
    178c:	20 93 01 02 	sts	0x0201, r18
    1790:	2f c0       	rjmp	.+94     	; 0x17f0 <xTaskIncrementTick+0x11e>
    1792:	8e 01       	movw	r16, r28
    1794:	0e 5f       	subi	r16, 0xFE	; 254
    1796:	1f 4f       	sbci	r17, 0xFF	; 255
    1798:	c8 01       	movw	r24, r16
    179a:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    179e:	8c 89       	ldd	r24, Y+20	; 0x14
    17a0:	9d 89       	ldd	r25, Y+21	; 0x15
    17a2:	89 2b       	or	r24, r25
    17a4:	21 f0       	breq	.+8      	; 0x17ae <xTaskIncrementTick+0xdc>
    17a6:	ce 01       	movw	r24, r28
    17a8:	0c 96       	adiw	r24, 0x0c	; 12
    17aa:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    17ae:	2e 89       	ldd	r18, Y+22	; 0x16
    17b0:	80 91 72 08 	lds	r24, 0x0872
    17b4:	82 17       	cp	r24, r18
    17b6:	10 f4       	brcc	.+4      	; 0x17bc <xTaskIncrementTick+0xea>
    17b8:	20 93 72 08 	sts	0x0872, r18
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	c9 01       	movw	r24, r18
    17c0:	88 0f       	add	r24, r24
    17c2:	99 1f       	adc	r25, r25
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	88 0f       	add	r24, r24
    17ca:	99 1f       	adc	r25, r25
    17cc:	82 0f       	add	r24, r18
    17ce:	93 1f       	adc	r25, r19
    17d0:	b8 01       	movw	r22, r16
    17d2:	88 55       	subi	r24, 0x58	; 88
    17d4:	97 4f       	sbci	r25, 0xF7	; 247
    17d6:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    17da:	e0 91 d5 08 	lds	r30, 0x08D5
    17de:	f0 91 d6 08 	lds	r31, 0x08D6
    17e2:	9e 89       	ldd	r25, Y+22	; 0x16
    17e4:	86 89       	ldd	r24, Z+22	; 0x16
    17e6:	98 17       	cp	r25, r24
    17e8:	08 f0       	brcs	.+2      	; 0x17ec <xTaskIncrementTick+0x11a>
    17ea:	b1 cf       	rjmp	.-158    	; 0x174e <xTaskIncrementTick+0x7c>
    17ec:	b1 cf       	rjmp	.-158    	; 0x1750 <xTaskIncrementTick+0x7e>
    17ee:	d1 2c       	mov	r13, r1
    17f0:	e0 91 d5 08 	lds	r30, 0x08D5
    17f4:	f0 91 d6 08 	lds	r31, 0x08D6
    17f8:	86 89       	ldd	r24, Z+22	; 0x16
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	fc 01       	movw	r30, r24
    17fe:	ee 0f       	add	r30, r30
    1800:	ff 1f       	adc	r31, r31
    1802:	ee 0f       	add	r30, r30
    1804:	ff 1f       	adc	r31, r31
    1806:	ee 0f       	add	r30, r30
    1808:	ff 1f       	adc	r31, r31
    180a:	8e 0f       	add	r24, r30
    180c:	9f 1f       	adc	r25, r31
    180e:	fc 01       	movw	r30, r24
    1810:	e8 55       	subi	r30, 0x58	; 88
    1812:	f7 4f       	sbci	r31, 0xF7	; 247
    1814:	80 81       	ld	r24, Z
    1816:	82 30       	cpi	r24, 0x02	; 2
    1818:	40 f4       	brcc	.+16     	; 0x182a <xTaskIncrementTick+0x158>
    181a:	09 c0       	rjmp	.+18     	; 0x182e <xTaskIncrementTick+0x15c>
    181c:	80 91 70 08 	lds	r24, 0x0870
    1820:	8f 5f       	subi	r24, 0xFF	; 255
    1822:	80 93 70 08 	sts	0x0870, r24
    1826:	d1 2c       	mov	r13, r1
    1828:	02 c0       	rjmp	.+4      	; 0x182e <xTaskIncrementTick+0x15c>
    182a:	dd 24       	eor	r13, r13
    182c:	d3 94       	inc	r13
    182e:	80 91 6f 08 	lds	r24, 0x086F
    1832:	88 23       	and	r24, r24
    1834:	11 f0       	breq	.+4      	; 0x183a <xTaskIncrementTick+0x168>
    1836:	dd 24       	eor	r13, r13
    1838:	d3 94       	inc	r13
    183a:	8d 2d       	mov	r24, r13
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	df 90       	pop	r13
    184a:	cf 90       	pop	r12
    184c:	08 95       	ret

0000184e <xTaskResumeAll>:
    184e:	df 92       	push	r13
    1850:	ef 92       	push	r14
    1852:	ff 92       	push	r15
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	df 93       	push	r29
    185c:	0f b6       	in	r0, 0x3f	; 63
    185e:	f8 94       	cli
    1860:	0f 92       	push	r0
    1862:	80 91 6c 08 	lds	r24, 0x086C
    1866:	81 50       	subi	r24, 0x01	; 1
    1868:	80 93 6c 08 	sts	0x086C, r24
    186c:	80 91 6c 08 	lds	r24, 0x086C
    1870:	81 11       	cpse	r24, r1
    1872:	5f c0       	rjmp	.+190    	; 0x1932 <xTaskResumeAll+0xe4>
    1874:	80 91 75 08 	lds	r24, 0x0875
    1878:	88 23       	and	r24, r24
    187a:	09 f4       	brne	.+2      	; 0x187e <xTaskResumeAll+0x30>
    187c:	5c c0       	rjmp	.+184    	; 0x1936 <xTaskResumeAll+0xe8>
    187e:	0f 2e       	mov	r0, r31
    1880:	f9 e8       	ldi	r31, 0x89	; 137
    1882:	ef 2e       	mov	r14, r31
    1884:	f8 e0       	ldi	r31, 0x08	; 8
    1886:	ff 2e       	mov	r15, r31
    1888:	f0 2d       	mov	r31, r0
    188a:	dd 24       	eor	r13, r13
    188c:	d3 94       	inc	r13
    188e:	30 c0       	rjmp	.+96     	; 0x18f0 <xTaskResumeAll+0xa2>
    1890:	e0 91 8e 08 	lds	r30, 0x088E
    1894:	f0 91 8f 08 	lds	r31, 0x088F
    1898:	c6 81       	ldd	r28, Z+6	; 0x06
    189a:	d7 81       	ldd	r29, Z+7	; 0x07
    189c:	ce 01       	movw	r24, r28
    189e:	0c 96       	adiw	r24, 0x0c	; 12
    18a0:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    18a4:	8e 01       	movw	r16, r28
    18a6:	0e 5f       	subi	r16, 0xFE	; 254
    18a8:	1f 4f       	sbci	r17, 0xFF	; 255
    18aa:	c8 01       	movw	r24, r16
    18ac:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    18b0:	8e 89       	ldd	r24, Y+22	; 0x16
    18b2:	90 91 72 08 	lds	r25, 0x0872
    18b6:	98 17       	cp	r25, r24
    18b8:	10 f4       	brcc	.+4      	; 0x18be <xTaskResumeAll+0x70>
    18ba:	80 93 72 08 	sts	0x0872, r24
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	9c 01       	movw	r18, r24
    18c2:	22 0f       	add	r18, r18
    18c4:	33 1f       	adc	r19, r19
    18c6:	22 0f       	add	r18, r18
    18c8:	33 1f       	adc	r19, r19
    18ca:	22 0f       	add	r18, r18
    18cc:	33 1f       	adc	r19, r19
    18ce:	82 0f       	add	r24, r18
    18d0:	93 1f       	adc	r25, r19
    18d2:	b8 01       	movw	r22, r16
    18d4:	88 55       	subi	r24, 0x58	; 88
    18d6:	97 4f       	sbci	r25, 0xF7	; 247
    18d8:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    18dc:	e0 91 d5 08 	lds	r30, 0x08D5
    18e0:	f0 91 d6 08 	lds	r31, 0x08D6
    18e4:	9e 89       	ldd	r25, Y+22	; 0x16
    18e6:	86 89       	ldd	r24, Z+22	; 0x16
    18e8:	98 17       	cp	r25, r24
    18ea:	10 f0       	brcs	.+4      	; 0x18f0 <xTaskResumeAll+0xa2>
    18ec:	d0 92 6f 08 	sts	0x086F, r13
    18f0:	f7 01       	movw	r30, r14
    18f2:	80 81       	ld	r24, Z
    18f4:	81 11       	cpse	r24, r1
    18f6:	cc cf       	rjmp	.-104    	; 0x1890 <xTaskResumeAll+0x42>
    18f8:	80 91 70 08 	lds	r24, 0x0870
    18fc:	88 23       	and	r24, r24
    18fe:	91 f0       	breq	.+36     	; 0x1924 <xTaskResumeAll+0xd6>
    1900:	80 91 70 08 	lds	r24, 0x0870
    1904:	88 23       	and	r24, r24
    1906:	71 f0       	breq	.+28     	; 0x1924 <xTaskResumeAll+0xd6>
    1908:	c1 e0       	ldi	r28, 0x01	; 1
    190a:	e3 de       	rcall	.-570    	; 0x16d2 <xTaskIncrementTick>
    190c:	81 11       	cpse	r24, r1
    190e:	c0 93 6f 08 	sts	0x086F, r28
    1912:	80 91 70 08 	lds	r24, 0x0870
    1916:	81 50       	subi	r24, 0x01	; 1
    1918:	80 93 70 08 	sts	0x0870, r24
    191c:	80 91 70 08 	lds	r24, 0x0870
    1920:	81 11       	cpse	r24, r1
    1922:	f3 cf       	rjmp	.-26     	; 0x190a <xTaskResumeAll+0xbc>
    1924:	80 91 6f 08 	lds	r24, 0x086F
    1928:	81 30       	cpi	r24, 0x01	; 1
    192a:	39 f4       	brne	.+14     	; 0x193a <xTaskResumeAll+0xec>
    192c:	20 d9       	rcall	.-3520   	; 0xb6e <vPortYield>
    192e:	81 e0       	ldi	r24, 0x01	; 1
    1930:	05 c0       	rjmp	.+10     	; 0x193c <xTaskResumeAll+0xee>
    1932:	80 e0       	ldi	r24, 0x00	; 0
    1934:	03 c0       	rjmp	.+6      	; 0x193c <xTaskResumeAll+0xee>
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	01 c0       	rjmp	.+2      	; 0x193c <xTaskResumeAll+0xee>
    193a:	80 e0       	ldi	r24, 0x00	; 0
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63
    1940:	df 91       	pop	r29
    1942:	cf 91       	pop	r28
    1944:	1f 91       	pop	r17
    1946:	0f 91       	pop	r16
    1948:	ff 90       	pop	r15
    194a:	ef 90       	pop	r14
    194c:	df 90       	pop	r13
    194e:	08 95       	ret

00001950 <vTaskDelay>:
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	ec 01       	movw	r28, r24
    1956:	00 97       	sbiw	r24, 0x00	; 0
    1958:	99 f0       	breq	.+38     	; 0x1980 <vTaskDelay+0x30>
    195a:	b5 de       	rcall	.-662    	; 0x16c6 <vTaskSuspendAll>
    195c:	80 91 73 08 	lds	r24, 0x0873
    1960:	90 91 74 08 	lds	r25, 0x0874
    1964:	c8 0f       	add	r28, r24
    1966:	d9 1f       	adc	r29, r25
    1968:	80 91 d5 08 	lds	r24, 0x08D5
    196c:	90 91 d6 08 	lds	r25, 0x08D6
    1970:	02 96       	adiw	r24, 0x02	; 2
    1972:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1976:	ce 01       	movw	r24, r28
    1978:	e8 dc       	rcall	.-1584   	; 0x134a <prvAddCurrentTaskToDelayedList>
    197a:	69 df       	rcall	.-302    	; 0x184e <xTaskResumeAll>
    197c:	81 11       	cpse	r24, r1
    197e:	01 c0       	rjmp	.+2      	; 0x1982 <vTaskDelay+0x32>
    1980:	f6 d8       	rcall	.-3604   	; 0xb6e <vPortYield>
    1982:	df 91       	pop	r29
    1984:	cf 91       	pop	r28
    1986:	08 95       	ret

00001988 <prvIdleTask>:
    1988:	0f 2e       	mov	r0, r31
    198a:	f8 ea       	ldi	r31, 0xA8	; 168
    198c:	ef 2e       	mov	r14, r31
    198e:	f8 e0       	ldi	r31, 0x08	; 8
    1990:	ff 2e       	mov	r15, r31
    1992:	f0 2d       	mov	r31, r0
    1994:	c0 e8       	ldi	r28, 0x80	; 128
    1996:	d8 e0       	ldi	r29, 0x08	; 8
    1998:	26 c0       	rjmp	.+76     	; 0x19e6 <prvIdleTask+0x5e>
    199a:	95 de       	rcall	.-726    	; 0x16c6 <vTaskSuspendAll>
    199c:	18 81       	ld	r17, Y
    199e:	57 df       	rcall	.-338    	; 0x184e <xTaskResumeAll>
    19a0:	11 23       	and	r17, r17
    19a2:	09 f1       	breq	.+66     	; 0x19e6 <prvIdleTask+0x5e>
    19a4:	0f b6       	in	r0, 0x3f	; 63
    19a6:	f8 94       	cli
    19a8:	0f 92       	push	r0
    19aa:	e0 91 85 08 	lds	r30, 0x0885
    19ae:	f0 91 86 08 	lds	r31, 0x0886
    19b2:	06 81       	ldd	r16, Z+6	; 0x06
    19b4:	17 81       	ldd	r17, Z+7	; 0x07
    19b6:	c8 01       	movw	r24, r16
    19b8:	02 96       	adiw	r24, 0x02	; 2
    19ba:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    19be:	80 91 75 08 	lds	r24, 0x0875
    19c2:	81 50       	subi	r24, 0x01	; 1
    19c4:	80 93 75 08 	sts	0x0875, r24
    19c8:	80 91 7f 08 	lds	r24, 0x087F
    19cc:	81 50       	subi	r24, 0x01	; 1
    19ce:	80 93 7f 08 	sts	0x087F, r24
    19d2:	0f 90       	pop	r0
    19d4:	0f be       	out	0x3f, r0	; 63
    19d6:	f8 01       	movw	r30, r16
    19d8:	87 89       	ldd	r24, Z+23	; 0x17
    19da:	90 8d       	ldd	r25, Z+24	; 0x18
    19dc:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <vPortFree>
    19e0:	c8 01       	movw	r24, r16
    19e2:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <vPortFree>
    19e6:	80 91 7f 08 	lds	r24, 0x087F
    19ea:	81 11       	cpse	r24, r1
    19ec:	d6 cf       	rjmp	.-84     	; 0x199a <prvIdleTask+0x12>
    19ee:	f7 01       	movw	r30, r14
    19f0:	80 81       	ld	r24, Z
    19f2:	82 30       	cpi	r24, 0x02	; 2
    19f4:	c0 f3       	brcs	.-16     	; 0x19e6 <prvIdleTask+0x5e>
    19f6:	bb d8       	rcall	.-3722   	; 0xb6e <vPortYield>
    19f8:	f6 cf       	rjmp	.-20     	; 0x19e6 <prvIdleTask+0x5e>

000019fa <vTaskSwitchContext>:
    19fa:	80 91 6c 08 	lds	r24, 0x086C
    19fe:	88 23       	and	r24, r24
    1a00:	21 f0       	breq	.+8      	; 0x1a0a <vTaskSwitchContext+0x10>
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	80 93 6f 08 	sts	0x086F, r24
    1a08:	08 95       	ret
    1a0a:	10 92 6f 08 	sts	0x086F, r1
    1a0e:	80 91 72 08 	lds	r24, 0x0872
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	fc 01       	movw	r30, r24
    1a16:	ee 0f       	add	r30, r30
    1a18:	ff 1f       	adc	r31, r31
    1a1a:	ee 0f       	add	r30, r30
    1a1c:	ff 1f       	adc	r31, r31
    1a1e:	ee 0f       	add	r30, r30
    1a20:	ff 1f       	adc	r31, r31
    1a22:	8e 0f       	add	r24, r30
    1a24:	9f 1f       	adc	r25, r31
    1a26:	fc 01       	movw	r30, r24
    1a28:	e8 55       	subi	r30, 0x58	; 88
    1a2a:	f7 4f       	sbci	r31, 0xF7	; 247
    1a2c:	80 81       	ld	r24, Z
    1a2e:	81 11       	cpse	r24, r1
    1a30:	17 c0       	rjmp	.+46     	; 0x1a60 <vTaskSwitchContext+0x66>
    1a32:	80 91 72 08 	lds	r24, 0x0872
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	80 93 72 08 	sts	0x0872, r24
    1a3c:	80 91 72 08 	lds	r24, 0x0872
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	fc 01       	movw	r30, r24
    1a44:	ee 0f       	add	r30, r30
    1a46:	ff 1f       	adc	r31, r31
    1a48:	ee 0f       	add	r30, r30
    1a4a:	ff 1f       	adc	r31, r31
    1a4c:	ee 0f       	add	r30, r30
    1a4e:	ff 1f       	adc	r31, r31
    1a50:	8e 0f       	add	r24, r30
    1a52:	9f 1f       	adc	r25, r31
    1a54:	fc 01       	movw	r30, r24
    1a56:	e8 55       	subi	r30, 0x58	; 88
    1a58:	f7 4f       	sbci	r31, 0xF7	; 247
    1a5a:	80 81       	ld	r24, Z
    1a5c:	88 23       	and	r24, r24
    1a5e:	49 f3       	breq	.-46     	; 0x1a32 <vTaskSwitchContext+0x38>
    1a60:	e0 91 72 08 	lds	r30, 0x0872
    1a64:	f0 e0       	ldi	r31, 0x00	; 0
    1a66:	cf 01       	movw	r24, r30
    1a68:	88 0f       	add	r24, r24
    1a6a:	99 1f       	adc	r25, r25
    1a6c:	88 0f       	add	r24, r24
    1a6e:	99 1f       	adc	r25, r25
    1a70:	88 0f       	add	r24, r24
    1a72:	99 1f       	adc	r25, r25
    1a74:	e8 0f       	add	r30, r24
    1a76:	f9 1f       	adc	r31, r25
    1a78:	e8 55       	subi	r30, 0x58	; 88
    1a7a:	f7 4f       	sbci	r31, 0xF7	; 247
    1a7c:	a1 81       	ldd	r26, Z+1	; 0x01
    1a7e:	b2 81       	ldd	r27, Z+2	; 0x02
    1a80:	12 96       	adiw	r26, 0x02	; 2
    1a82:	0d 90       	ld	r0, X+
    1a84:	bc 91       	ld	r27, X
    1a86:	a0 2d       	mov	r26, r0
    1a88:	b2 83       	std	Z+2, r27	; 0x02
    1a8a:	a1 83       	std	Z+1, r26	; 0x01
    1a8c:	cf 01       	movw	r24, r30
    1a8e:	03 96       	adiw	r24, 0x03	; 3
    1a90:	a8 17       	cp	r26, r24
    1a92:	b9 07       	cpc	r27, r25
    1a94:	31 f4       	brne	.+12     	; 0x1aa2 <vTaskSwitchContext+0xa8>
    1a96:	12 96       	adiw	r26, 0x02	; 2
    1a98:	8d 91       	ld	r24, X+
    1a9a:	9c 91       	ld	r25, X
    1a9c:	13 97       	sbiw	r26, 0x03	; 3
    1a9e:	92 83       	std	Z+2, r25	; 0x02
    1aa0:	81 83       	std	Z+1, r24	; 0x01
    1aa2:	01 80       	ldd	r0, Z+1	; 0x01
    1aa4:	f2 81       	ldd	r31, Z+2	; 0x02
    1aa6:	e0 2d       	mov	r30, r0
    1aa8:	86 81       	ldd	r24, Z+6	; 0x06
    1aaa:	97 81       	ldd	r25, Z+7	; 0x07
    1aac:	90 93 d6 08 	sts	0x08D6, r25
    1ab0:	80 93 d5 08 	sts	0x08D5, r24
    1ab4:	08 95       	ret

00001ab6 <vTaskSuspend>:
    1ab6:	0f 93       	push	r16
    1ab8:	1f 93       	push	r17
    1aba:	cf 93       	push	r28
    1abc:	df 93       	push	r29
    1abe:	ec 01       	movw	r28, r24
    1ac0:	0f b6       	in	r0, 0x3f	; 63
    1ac2:	f8 94       	cli
    1ac4:	0f 92       	push	r0
    1ac6:	00 97       	sbiw	r24, 0x00	; 0
    1ac8:	21 f4       	brne	.+8      	; 0x1ad2 <vTaskSuspend+0x1c>
    1aca:	c0 91 d5 08 	lds	r28, 0x08D5
    1ace:	d0 91 d6 08 	lds	r29, 0x08D6
    1ad2:	8e 01       	movw	r16, r28
    1ad4:	0e 5f       	subi	r16, 0xFE	; 254
    1ad6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad8:	c8 01       	movw	r24, r16
    1ada:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1ade:	8c 89       	ldd	r24, Y+20	; 0x14
    1ae0:	9d 89       	ldd	r25, Y+21	; 0x15
    1ae2:	89 2b       	or	r24, r25
    1ae4:	21 f0       	breq	.+8      	; 0x1aee <vTaskSuspend+0x38>
    1ae6:	ce 01       	movw	r24, r28
    1ae8:	0c 96       	adiw	r24, 0x0c	; 12
    1aea:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1aee:	b8 01       	movw	r22, r16
    1af0:	86 e7       	ldi	r24, 0x76	; 118
    1af2:	98 e0       	ldi	r25, 0x08	; 8
    1af4:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1af8:	0f 90       	pop	r0
    1afa:	0f be       	out	0x3f, r0	; 63
    1afc:	80 91 d5 08 	lds	r24, 0x08D5
    1b00:	90 91 d6 08 	lds	r25, 0x08D6
    1b04:	c8 17       	cp	r28, r24
    1b06:	d9 07       	cpc	r29, r25
    1b08:	99 f4       	brne	.+38     	; 0x1b30 <vTaskSuspend+0x7a>
    1b0a:	80 91 71 08 	lds	r24, 0x0871
    1b0e:	88 23       	and	r24, r24
    1b10:	11 f0       	breq	.+4      	; 0x1b16 <vTaskSuspend+0x60>
    1b12:	2d d8       	rcall	.-4006   	; 0xb6e <vPortYield>
    1b14:	17 c0       	rjmp	.+46     	; 0x1b44 <vTaskSuspend+0x8e>
    1b16:	80 91 75 08 	lds	r24, 0x0875
    1b1a:	90 91 76 08 	lds	r25, 0x0876
    1b1e:	98 13       	cpse	r25, r24
    1b20:	05 c0       	rjmp	.+10     	; 0x1b2c <vTaskSuspend+0x76>
    1b22:	10 92 d6 08 	sts	0x08D6, r1
    1b26:	10 92 d5 08 	sts	0x08D5, r1
    1b2a:	0c c0       	rjmp	.+24     	; 0x1b44 <vTaskSuspend+0x8e>
    1b2c:	66 df       	rcall	.-308    	; 0x19fa <vTaskSwitchContext>
    1b2e:	0a c0       	rjmp	.+20     	; 0x1b44 <vTaskSuspend+0x8e>
    1b30:	80 91 71 08 	lds	r24, 0x0871
    1b34:	88 23       	and	r24, r24
    1b36:	31 f0       	breq	.+12     	; 0x1b44 <vTaskSuspend+0x8e>
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	0f 92       	push	r0
    1b3e:	e6 db       	rcall	.-2100   	; 0x130c <prvResetNextTaskUnblockTime>
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	08 95       	ret

00001b4e <vTaskPlaceOnEventList>:
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	eb 01       	movw	r28, r22
    1b54:	60 91 d5 08 	lds	r22, 0x08D5
    1b58:	70 91 d6 08 	lds	r23, 0x08D6
    1b5c:	64 5f       	subi	r22, 0xF4	; 244
    1b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b60:	0e 94 2f 02 	call	0x45e	; 0x45e <vListInsert>
    1b64:	80 91 d5 08 	lds	r24, 0x08D5
    1b68:	90 91 d6 08 	lds	r25, 0x08D6
    1b6c:	02 96       	adiw	r24, 0x02	; 2
    1b6e:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1b72:	cf 3f       	cpi	r28, 0xFF	; 255
    1b74:	8f ef       	ldi	r24, 0xFF	; 255
    1b76:	d8 07       	cpc	r29, r24
    1b78:	59 f4       	brne	.+22     	; 0x1b90 <vTaskPlaceOnEventList+0x42>
    1b7a:	60 91 d5 08 	lds	r22, 0x08D5
    1b7e:	70 91 d6 08 	lds	r23, 0x08D6
    1b82:	6e 5f       	subi	r22, 0xFE	; 254
    1b84:	7f 4f       	sbci	r23, 0xFF	; 255
    1b86:	86 e7       	ldi	r24, 0x76	; 118
    1b88:	98 e0       	ldi	r25, 0x08	; 8
    1b8a:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1b8e:	07 c0       	rjmp	.+14     	; 0x1b9e <vTaskPlaceOnEventList+0x50>
    1b90:	80 91 73 08 	lds	r24, 0x0873
    1b94:	90 91 74 08 	lds	r25, 0x0874
    1b98:	8c 0f       	add	r24, r28
    1b9a:	9d 1f       	adc	r25, r29
    1b9c:	d6 db       	rcall	.-2132   	; 0x134a <prvAddCurrentTaskToDelayedList>
    1b9e:	df 91       	pop	r29
    1ba0:	cf 91       	pop	r28
    1ba2:	08 95       	ret

00001ba4 <xTaskRemoveFromEventList>:
    1ba4:	0f 93       	push	r16
    1ba6:	1f 93       	push	r17
    1ba8:	cf 93       	push	r28
    1baa:	df 93       	push	r29
    1bac:	dc 01       	movw	r26, r24
    1bae:	15 96       	adiw	r26, 0x05	; 5
    1bb0:	ed 91       	ld	r30, X+
    1bb2:	fc 91       	ld	r31, X
    1bb4:	16 97       	sbiw	r26, 0x06	; 6
    1bb6:	c6 81       	ldd	r28, Z+6	; 0x06
    1bb8:	d7 81       	ldd	r29, Z+7	; 0x07
    1bba:	8e 01       	movw	r16, r28
    1bbc:	04 5f       	subi	r16, 0xF4	; 244
    1bbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1bc0:	c8 01       	movw	r24, r16
    1bc2:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1bc6:	80 91 6c 08 	lds	r24, 0x086C
    1bca:	81 11       	cpse	r24, r1
    1bcc:	1c c0       	rjmp	.+56     	; 0x1c06 <xTaskRemoveFromEventList+0x62>
    1bce:	0a 50       	subi	r16, 0x0A	; 10
    1bd0:	11 09       	sbc	r17, r1
    1bd2:	c8 01       	movw	r24, r16
    1bd4:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1bd8:	8e 89       	ldd	r24, Y+22	; 0x16
    1bda:	90 91 72 08 	lds	r25, 0x0872
    1bde:	98 17       	cp	r25, r24
    1be0:	10 f4       	brcc	.+4      	; 0x1be6 <xTaskRemoveFromEventList+0x42>
    1be2:	80 93 72 08 	sts	0x0872, r24
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	9c 01       	movw	r18, r24
    1bea:	22 0f       	add	r18, r18
    1bec:	33 1f       	adc	r19, r19
    1bee:	22 0f       	add	r18, r18
    1bf0:	33 1f       	adc	r19, r19
    1bf2:	22 0f       	add	r18, r18
    1bf4:	33 1f       	adc	r19, r19
    1bf6:	82 0f       	add	r24, r18
    1bf8:	93 1f       	adc	r25, r19
    1bfa:	b8 01       	movw	r22, r16
    1bfc:	88 55       	subi	r24, 0x58	; 88
    1bfe:	97 4f       	sbci	r25, 0xF7	; 247
    1c00:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1c04:	05 c0       	rjmp	.+10     	; 0x1c10 <xTaskRemoveFromEventList+0x6c>
    1c06:	b8 01       	movw	r22, r16
    1c08:	89 e8       	ldi	r24, 0x89	; 137
    1c0a:	98 e0       	ldi	r25, 0x08	; 8
    1c0c:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1c10:	e0 91 d5 08 	lds	r30, 0x08D5
    1c14:	f0 91 d6 08 	lds	r31, 0x08D6
    1c18:	9e 89       	ldd	r25, Y+22	; 0x16
    1c1a:	86 89       	ldd	r24, Z+22	; 0x16
    1c1c:	89 17       	cp	r24, r25
    1c1e:	20 f4       	brcc	.+8      	; 0x1c28 <xTaskRemoveFromEventList+0x84>
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	80 93 6f 08 	sts	0x086F, r24
    1c26:	01 c0       	rjmp	.+2      	; 0x1c2a <xTaskRemoveFromEventList+0x86>
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	df 91       	pop	r29
    1c2c:	cf 91       	pop	r28
    1c2e:	1f 91       	pop	r17
    1c30:	0f 91       	pop	r16
    1c32:	08 95       	ret

00001c34 <vTaskSetTimeOutState>:
    1c34:	20 91 6e 08 	lds	r18, 0x086E
    1c38:	fc 01       	movw	r30, r24
    1c3a:	20 83       	st	Z, r18
    1c3c:	20 91 73 08 	lds	r18, 0x0873
    1c40:	30 91 74 08 	lds	r19, 0x0874
    1c44:	32 83       	std	Z+2, r19	; 0x02
    1c46:	21 83       	std	Z+1, r18	; 0x01
    1c48:	08 95       	ret

00001c4a <xTaskCheckForTimeOut>:
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
    1c50:	40 91 73 08 	lds	r20, 0x0873
    1c54:	50 91 74 08 	lds	r21, 0x0874
    1c58:	db 01       	movw	r26, r22
    1c5a:	2d 91       	ld	r18, X+
    1c5c:	3c 91       	ld	r19, X
    1c5e:	2f 3f       	cpi	r18, 0xFF	; 255
    1c60:	bf ef       	ldi	r27, 0xFF	; 255
    1c62:	3b 07       	cpc	r19, r27
    1c64:	11 f1       	breq	.+68     	; 0x1caa <xTaskCheckForTimeOut+0x60>
    1c66:	e0 91 6e 08 	lds	r30, 0x086E
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	fc 91       	ld	r31, X
    1c6e:	fe 17       	cp	r31, r30
    1c70:	39 f0       	breq	.+14     	; 0x1c80 <xTaskCheckForTimeOut+0x36>
    1c72:	11 96       	adiw	r26, 0x01	; 1
    1c74:	ed 91       	ld	r30, X+
    1c76:	fc 91       	ld	r31, X
    1c78:	12 97       	sbiw	r26, 0x02	; 2
    1c7a:	4e 17       	cp	r20, r30
    1c7c:	5f 07       	cpc	r21, r31
    1c7e:	b8 f4       	brcc	.+46     	; 0x1cae <xTaskCheckForTimeOut+0x64>
    1c80:	dc 01       	movw	r26, r24
    1c82:	11 96       	adiw	r26, 0x01	; 1
    1c84:	ed 91       	ld	r30, X+
    1c86:	fc 91       	ld	r31, X
    1c88:	12 97       	sbiw	r26, 0x02	; 2
    1c8a:	da 01       	movw	r26, r20
    1c8c:	ae 1b       	sub	r26, r30
    1c8e:	bf 0b       	sbc	r27, r31
    1c90:	a2 17       	cp	r26, r18
    1c92:	b3 07       	cpc	r27, r19
    1c94:	70 f4       	brcc	.+28     	; 0x1cb2 <xTaskCheckForTimeOut+0x68>
    1c96:	e4 1b       	sub	r30, r20
    1c98:	f5 0b       	sbc	r31, r21
    1c9a:	2e 0f       	add	r18, r30
    1c9c:	3f 1f       	adc	r19, r31
    1c9e:	fb 01       	movw	r30, r22
    1ca0:	31 83       	std	Z+1, r19	; 0x01
    1ca2:	20 83       	st	Z, r18
    1ca4:	c7 df       	rcall	.-114    	; 0x1c34 <vTaskSetTimeOutState>
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	05 c0       	rjmp	.+10     	; 0x1cb4 <xTaskCheckForTimeOut+0x6a>
    1caa:	80 e0       	ldi	r24, 0x00	; 0
    1cac:	03 c0       	rjmp	.+6      	; 0x1cb4 <xTaskCheckForTimeOut+0x6a>
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	01 c0       	rjmp	.+2      	; 0x1cb4 <xTaskCheckForTimeOut+0x6a>
    1cb2:	81 e0       	ldi	r24, 0x01	; 1
    1cb4:	0f 90       	pop	r0
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	08 95       	ret

00001cba <vTaskMissedYield>:
    1cba:	81 e0       	ldi	r24, 0x01	; 1
    1cbc:	80 93 6f 08 	sts	0x086F, r24
    1cc0:	08 95       	ret

00001cc2 <vTaskPriorityInherit>:
    1cc2:	0f 93       	push	r16
    1cc4:	1f 93       	push	r17
    1cc6:	cf 93       	push	r28
    1cc8:	df 93       	push	r29
    1cca:	ec 01       	movw	r28, r24
    1ccc:	00 97       	sbiw	r24, 0x00	; 0
    1cce:	09 f4       	brne	.+2      	; 0x1cd2 <vTaskPriorityInherit+0x10>
    1cd0:	51 c0       	rjmp	.+162    	; 0x1d74 <vTaskPriorityInherit+0xb2>
    1cd2:	8e 89       	ldd	r24, Y+22	; 0x16
    1cd4:	e0 91 d5 08 	lds	r30, 0x08D5
    1cd8:	f0 91 d6 08 	lds	r31, 0x08D6
    1cdc:	96 89       	ldd	r25, Z+22	; 0x16
    1cde:	89 17       	cp	r24, r25
    1ce0:	08 f0       	brcs	.+2      	; 0x1ce4 <vTaskPriorityInherit+0x22>
    1ce2:	48 c0       	rjmp	.+144    	; 0x1d74 <vTaskPriorityInherit+0xb2>
    1ce4:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ce6:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ce8:	33 23       	and	r19, r19
    1cea:	5c f0       	brlt	.+22     	; 0x1d02 <vTaskPriorityInherit+0x40>
    1cec:	e0 91 d5 08 	lds	r30, 0x08D5
    1cf0:	f0 91 d6 08 	lds	r31, 0x08D6
    1cf4:	96 89       	ldd	r25, Z+22	; 0x16
    1cf6:	25 e0       	ldi	r18, 0x05	; 5
    1cf8:	30 e0       	ldi	r19, 0x00	; 0
    1cfa:	29 1b       	sub	r18, r25
    1cfc:	31 09       	sbc	r19, r1
    1cfe:	3d 87       	std	Y+13, r19	; 0x0d
    1d00:	2c 87       	std	Y+12, r18	; 0x0c
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	9c 01       	movw	r18, r24
    1d06:	22 0f       	add	r18, r18
    1d08:	33 1f       	adc	r19, r19
    1d0a:	22 0f       	add	r18, r18
    1d0c:	33 1f       	adc	r19, r19
    1d0e:	22 0f       	add	r18, r18
    1d10:	33 1f       	adc	r19, r19
    1d12:	82 0f       	add	r24, r18
    1d14:	93 1f       	adc	r25, r19
    1d16:	88 55       	subi	r24, 0x58	; 88
    1d18:	97 4f       	sbci	r25, 0xF7	; 247
    1d1a:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d1c:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d1e:	28 17       	cp	r18, r24
    1d20:	39 07       	cpc	r19, r25
    1d22:	11 f5       	brne	.+68     	; 0x1d68 <vTaskPriorityInherit+0xa6>
    1d24:	8e 01       	movw	r16, r28
    1d26:	0e 5f       	subi	r16, 0xFE	; 254
    1d28:	1f 4f       	sbci	r17, 0xFF	; 255
    1d2a:	c8 01       	movw	r24, r16
    1d2c:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1d30:	e0 91 d5 08 	lds	r30, 0x08D5
    1d34:	f0 91 d6 08 	lds	r31, 0x08D6
    1d38:	86 89       	ldd	r24, Z+22	; 0x16
    1d3a:	8e 8b       	std	Y+22, r24	; 0x16
    1d3c:	90 91 72 08 	lds	r25, 0x0872
    1d40:	98 17       	cp	r25, r24
    1d42:	10 f4       	brcc	.+4      	; 0x1d48 <vTaskPriorityInherit+0x86>
    1d44:	80 93 72 08 	sts	0x0872, r24
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	9c 01       	movw	r18, r24
    1d4c:	22 0f       	add	r18, r18
    1d4e:	33 1f       	adc	r19, r19
    1d50:	22 0f       	add	r18, r18
    1d52:	33 1f       	adc	r19, r19
    1d54:	22 0f       	add	r18, r18
    1d56:	33 1f       	adc	r19, r19
    1d58:	82 0f       	add	r24, r18
    1d5a:	93 1f       	adc	r25, r19
    1d5c:	b8 01       	movw	r22, r16
    1d5e:	88 55       	subi	r24, 0x58	; 88
    1d60:	97 4f       	sbci	r25, 0xF7	; 247
    1d62:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1d66:	06 c0       	rjmp	.+12     	; 0x1d74 <vTaskPriorityInherit+0xb2>
    1d68:	e0 91 d5 08 	lds	r30, 0x08D5
    1d6c:	f0 91 d6 08 	lds	r31, 0x08D6
    1d70:	86 89       	ldd	r24, Z+22	; 0x16
    1d72:	8e 8b       	std	Y+22, r24	; 0x16
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	1f 91       	pop	r17
    1d7a:	0f 91       	pop	r16
    1d7c:	08 95       	ret

00001d7e <xTaskPriorityDisinherit>:
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
    1d82:	cf 93       	push	r28
    1d84:	df 93       	push	r29
    1d86:	ec 01       	movw	r28, r24
    1d88:	00 97       	sbiw	r24, 0x00	; 0
    1d8a:	71 f1       	breq	.+92     	; 0x1de8 <xTaskPriorityDisinherit+0x6a>
    1d8c:	8a a1       	ldd	r24, Y+34	; 0x22
    1d8e:	81 50       	subi	r24, 0x01	; 1
    1d90:	8a a3       	std	Y+34, r24	; 0x22
    1d92:	2e 89       	ldd	r18, Y+22	; 0x16
    1d94:	99 a1       	ldd	r25, Y+33	; 0x21
    1d96:	29 17       	cp	r18, r25
    1d98:	49 f1       	breq	.+82     	; 0x1dec <xTaskPriorityDisinherit+0x6e>
    1d9a:	81 11       	cpse	r24, r1
    1d9c:	29 c0       	rjmp	.+82     	; 0x1df0 <xTaskPriorityDisinherit+0x72>
    1d9e:	8e 01       	movw	r16, r28
    1da0:	0e 5f       	subi	r16, 0xFE	; 254
    1da2:	1f 4f       	sbci	r17, 0xFF	; 255
    1da4:	c8 01       	movw	r24, r16
    1da6:	0e 94 60 02 	call	0x4c0	; 0x4c0 <uxListRemove>
    1daa:	89 a1       	ldd	r24, Y+33	; 0x21
    1dac:	8e 8b       	std	Y+22, r24	; 0x16
    1dae:	25 e0       	ldi	r18, 0x05	; 5
    1db0:	30 e0       	ldi	r19, 0x00	; 0
    1db2:	28 1b       	sub	r18, r24
    1db4:	31 09       	sbc	r19, r1
    1db6:	3d 87       	std	Y+13, r19	; 0x0d
    1db8:	2c 87       	std	Y+12, r18	; 0x0c
    1dba:	90 91 72 08 	lds	r25, 0x0872
    1dbe:	98 17       	cp	r25, r24
    1dc0:	10 f4       	brcc	.+4      	; 0x1dc6 <xTaskPriorityDisinherit+0x48>
    1dc2:	80 93 72 08 	sts	0x0872, r24
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	9c 01       	movw	r18, r24
    1dca:	22 0f       	add	r18, r18
    1dcc:	33 1f       	adc	r19, r19
    1dce:	22 0f       	add	r18, r18
    1dd0:	33 1f       	adc	r19, r19
    1dd2:	22 0f       	add	r18, r18
    1dd4:	33 1f       	adc	r19, r19
    1dd6:	82 0f       	add	r24, r18
    1dd8:	93 1f       	adc	r25, r19
    1dda:	b8 01       	movw	r22, r16
    1ddc:	88 55       	subi	r24, 0x58	; 88
    1dde:	97 4f       	sbci	r25, 0xF7	; 247
    1de0:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsertEnd>
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	05 c0       	rjmp	.+10     	; 0x1df2 <xTaskPriorityDisinherit+0x74>
    1de8:	80 e0       	ldi	r24, 0x00	; 0
    1dea:	03 c0       	rjmp	.+6      	; 0x1df2 <xTaskPriorityDisinherit+0x74>
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	01 c0       	rjmp	.+2      	; 0x1df2 <xTaskPriorityDisinherit+0x74>
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	df 91       	pop	r29
    1df4:	cf 91       	pop	r28
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	08 95       	ret

00001dfc <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1dfc:	80 91 d5 08 	lds	r24, 0x08D5
    1e00:	90 91 d6 08 	lds	r25, 0x08D6
    1e04:	89 2b       	or	r24, r25
    1e06:	39 f0       	breq	.+14     	; 0x1e16 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1e08:	e0 91 d5 08 	lds	r30, 0x08D5
    1e0c:	f0 91 d6 08 	lds	r31, 0x08D6
    1e10:	82 a1       	ldd	r24, Z+34	; 0x22
    1e12:	8f 5f       	subi	r24, 0xFF	; 255
    1e14:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1e16:	80 91 d5 08 	lds	r24, 0x08D5
    1e1a:	90 91 d6 08 	lds	r25, 0x08D6
	}
    1e1e:	08 95       	ret

00001e20 <__divmodhi4>:
    1e20:	97 fb       	bst	r25, 7
    1e22:	07 2e       	mov	r0, r23
    1e24:	16 f4       	brtc	.+4      	; 0x1e2a <__divmodhi4+0xa>
    1e26:	00 94       	com	r0
    1e28:	06 d0       	rcall	.+12     	; 0x1e36 <__divmodhi4_neg1>
    1e2a:	77 fd       	sbrc	r23, 7
    1e2c:	08 d0       	rcall	.+16     	; 0x1e3e <__divmodhi4_neg2>
    1e2e:	0b d0       	rcall	.+22     	; 0x1e46 <__udivmodhi4>
    1e30:	07 fc       	sbrc	r0, 7
    1e32:	05 d0       	rcall	.+10     	; 0x1e3e <__divmodhi4_neg2>
    1e34:	3e f4       	brtc	.+14     	; 0x1e44 <__divmodhi4_exit>

00001e36 <__divmodhi4_neg1>:
    1e36:	90 95       	com	r25
    1e38:	81 95       	neg	r24
    1e3a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e3c:	08 95       	ret

00001e3e <__divmodhi4_neg2>:
    1e3e:	70 95       	com	r23
    1e40:	61 95       	neg	r22
    1e42:	7f 4f       	sbci	r23, 0xFF	; 255

00001e44 <__divmodhi4_exit>:
    1e44:	08 95       	ret

00001e46 <__udivmodhi4>:
    1e46:	aa 1b       	sub	r26, r26
    1e48:	bb 1b       	sub	r27, r27
    1e4a:	51 e1       	ldi	r21, 0x11	; 17
    1e4c:	07 c0       	rjmp	.+14     	; 0x1e5c <__udivmodhi4_ep>

00001e4e <__udivmodhi4_loop>:
    1e4e:	aa 1f       	adc	r26, r26
    1e50:	bb 1f       	adc	r27, r27
    1e52:	a6 17       	cp	r26, r22
    1e54:	b7 07       	cpc	r27, r23
    1e56:	10 f0       	brcs	.+4      	; 0x1e5c <__udivmodhi4_ep>
    1e58:	a6 1b       	sub	r26, r22
    1e5a:	b7 0b       	sbc	r27, r23

00001e5c <__udivmodhi4_ep>:
    1e5c:	88 1f       	adc	r24, r24
    1e5e:	99 1f       	adc	r25, r25
    1e60:	5a 95       	dec	r21
    1e62:	a9 f7       	brne	.-22     	; 0x1e4e <__udivmodhi4_loop>
    1e64:	80 95       	com	r24
    1e66:	90 95       	com	r25
    1e68:	bc 01       	movw	r22, r24
    1e6a:	cd 01       	movw	r24, r26
    1e6c:	08 95       	ret

00001e6e <memcpy>:
    1e6e:	fb 01       	movw	r30, r22
    1e70:	dc 01       	movw	r26, r24
    1e72:	02 c0       	rjmp	.+4      	; 0x1e78 <memcpy+0xa>
    1e74:	01 90       	ld	r0, Z+
    1e76:	0d 92       	st	X+, r0
    1e78:	41 50       	subi	r20, 0x01	; 1
    1e7a:	50 40       	sbci	r21, 0x00	; 0
    1e7c:	d8 f7       	brcc	.-10     	; 0x1e74 <memcpy+0x6>
    1e7e:	08 95       	ret

00001e80 <__itoa_ncheck>:
    1e80:	bb 27       	eor	r27, r27
    1e82:	4a 30       	cpi	r20, 0x0A	; 10
    1e84:	31 f4       	brne	.+12     	; 0x1e92 <__itoa_ncheck+0x12>
    1e86:	99 23       	and	r25, r25
    1e88:	22 f4       	brpl	.+8      	; 0x1e92 <__itoa_ncheck+0x12>
    1e8a:	bd e2       	ldi	r27, 0x2D	; 45
    1e8c:	90 95       	com	r25
    1e8e:	81 95       	neg	r24
    1e90:	9f 4f       	sbci	r25, 0xFF	; 255
    1e92:	01 c0       	rjmp	.+2      	; 0x1e96 <__utoa_common>

00001e94 <__utoa_ncheck>:
    1e94:	bb 27       	eor	r27, r27

00001e96 <__utoa_common>:
    1e96:	fb 01       	movw	r30, r22
    1e98:	55 27       	eor	r21, r21
    1e9a:	aa 27       	eor	r26, r26
    1e9c:	88 0f       	add	r24, r24
    1e9e:	99 1f       	adc	r25, r25
    1ea0:	aa 1f       	adc	r26, r26
    1ea2:	a4 17       	cp	r26, r20
    1ea4:	10 f0       	brcs	.+4      	; 0x1eaa <__utoa_common+0x14>
    1ea6:	a4 1b       	sub	r26, r20
    1ea8:	83 95       	inc	r24
    1eaa:	50 51       	subi	r21, 0x10	; 16
    1eac:	b9 f7       	brne	.-18     	; 0x1e9c <__utoa_common+0x6>
    1eae:	a0 5d       	subi	r26, 0xD0	; 208
    1eb0:	aa 33       	cpi	r26, 0x3A	; 58
    1eb2:	08 f0       	brcs	.+2      	; 0x1eb6 <__utoa_common+0x20>
    1eb4:	a9 5d       	subi	r26, 0xD9	; 217
    1eb6:	a1 93       	st	Z+, r26
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	79 f7       	brne	.-34     	; 0x1e9a <__utoa_common+0x4>
    1ebc:	b1 11       	cpse	r27, r1
    1ebe:	b1 93       	st	Z+, r27
    1ec0:	11 92       	st	Z+, r1
    1ec2:	cb 01       	movw	r24, r22
    1ec4:	00 c0       	rjmp	.+0      	; 0x1ec6 <strrev>

00001ec6 <strrev>:
    1ec6:	dc 01       	movw	r26, r24
    1ec8:	fc 01       	movw	r30, r24
    1eca:	67 2f       	mov	r22, r23
    1ecc:	71 91       	ld	r23, Z+
    1ece:	77 23       	and	r23, r23
    1ed0:	e1 f7       	brne	.-8      	; 0x1eca <strrev+0x4>
    1ed2:	32 97       	sbiw	r30, 0x02	; 2
    1ed4:	04 c0       	rjmp	.+8      	; 0x1ede <strrev+0x18>
    1ed6:	7c 91       	ld	r23, X
    1ed8:	6d 93       	st	X+, r22
    1eda:	70 83       	st	Z, r23
    1edc:	62 91       	ld	r22, -Z
    1ede:	ae 17       	cp	r26, r30
    1ee0:	bf 07       	cpc	r27, r31
    1ee2:	c8 f3       	brcs	.-14     	; 0x1ed6 <strrev+0x10>
    1ee4:	08 95       	ret

00001ee6 <_exit>:
    1ee6:	f8 94       	cli

00001ee8 <__stop_program>:
    1ee8:	ff cf       	rjmp	.-2      	; 0x1ee8 <__stop_program>
