
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800200  0000217c  00002210  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000217c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fa  0080025e  0080025e  0000226e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000226e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004c0  00000000  00000000  0000229e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005191  00000000  00000000  0000275e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000013e7  00000000  00000000  000078ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000327d  00000000  00000000  00008cd6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d68  00000000  00000000  0000bf54  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000014d8  00000000  00000000  0000ccbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000377c  00000000  00000000  0000e194  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000470  00000000  00000000  00011910  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	52 c2       	rjmp	.+1188   	; 0x4ca <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	63 c7       	rjmp	.+3782   	; 0xf1c <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	8f c4       	rjmp	.+2334   	; 0x984 <__vector_25>
      66:	00 00       	nop
      68:	fb c4       	rjmp	.+2550   	; 0xa60 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	e5 c2       	rjmp	.+1482   	; 0x640 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	41 c4       	rjmp	.+2178   	; 0x914 <__vector_36>
      92:	00 00       	nop
      94:	af c4       	rjmp	.+2398   	; 0x9f4 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ec e7       	ldi	r30, 0x7C	; 124
      fc:	f1 e2       	ldi	r31, 0x21	; 33
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 35       	cpi	r26, 0x5E	; 94
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ae e5       	ldi	r26, 0x5E	; 94
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a8 35       	cpi	r26, 0x58	; 88
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	cc d0       	rcall	.+408    	; 0x2b8 <main>
     120:	0c 94 bc 10 	jmp	0x2178	; 0x2178 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	7a d5       	rcall	.+2804   	; 0xc1c <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	3d c5       	rjmp	.+2682   	; 0xba8 <myUSART_transmitUSART0>
     12e:	08 95       	ret

00000130 <RPI_sendTask>:
     130:	6a d5       	rcall	.+2772   	; 0xc06 <myUSART_startHandShake>
     132:	8d e1       	ldi	r24, 0x1D	; 29
     134:	92 e0       	ldi	r25, 0x02	; 2
     136:	38 c5       	rjmp	.+2672   	; 0xba8 <myUSART_transmitUSART0>
     138:	08 95       	ret

0000013a <myTimerTask>:
     13a:	1a d3       	rcall	.+1588   	; 0x770 <myTimer_Init>
     13c:	7c d3       	rcall	.+1784   	; 0x836 <myTimer_DelayChecker>
     13e:	fe cf       	rjmp	.-4      	; 0x13c <myTimerTask+0x2>

00000140 <obstacleSend>:
     140:	1f 93       	push	r17
     142:	cf 93       	push	r28
     144:	df 93       	push	r29
     146:	00 d0       	rcall	.+0      	; 0x148 <obstacleSend+0x8>
     148:	1f 92       	push	r1
     14a:	cd b7       	in	r28, 0x3d	; 61
     14c:	de b7       	in	r29, 0x3e	; 62
     14e:	18 2f       	mov	r17, r24
     150:	cb 01       	movw	r24, r22
     152:	11 23       	and	r17, r17
     154:	59 f0       	breq	.+22     	; 0x16c <obstacleSend+0x2c>
     156:	4a e0       	ldi	r20, 0x0A	; 10
     158:	be 01       	movw	r22, r28
     15a:	6f 5f       	subi	r22, 0xFF	; 255
     15c:	7f 4f       	sbci	r23, 0xFF	; 255
     15e:	0e 94 89 10 	call	0x2112	; 0x2112 <__itoa_ncheck>
     162:	81 2f       	mov	r24, r17
     164:	f3 d4       	rcall	.+2534   	; 0xb4c <myUSART_transmitUSART0_c>
     166:	ce 01       	movw	r24, r28
     168:	01 96       	adiw	r24, 0x01	; 1
     16a:	1e d5       	rcall	.+2620   	; 0xba8 <myUSART_transmitUSART0>
     16c:	0f 90       	pop	r0
     16e:	0f 90       	pop	r0
     170:	0f 90       	pop	r0
     172:	0f 90       	pop	r0
     174:	df 91       	pop	r29
     176:	cf 91       	pop	r28
     178:	1f 91       	pop	r17
     17a:	08 95       	ret

0000017c <Sonar_Task>:
     17c:	cf 93       	push	r28
     17e:	df 93       	push	r29
     180:	00 d0       	rcall	.+0      	; 0x182 <Sonar_Task+0x6>
     182:	00 d0       	rcall	.+0      	; 0x184 <Sonar_Task+0x8>
     184:	cd b7       	in	r28, 0x3d	; 61
     186:	de b7       	in	r29, 0x3e	; 62
     188:	0e 94 80 0c 	call	0x1900	; 0x1900 <xTaskGetTickCount>
     18c:	9a 83       	std	Y+2, r25	; 0x02
     18e:	89 83       	std	Y+1, r24	; 0x01
     190:	41 2c       	mov	r4, r1
     192:	0f 2e       	mov	r0, r31
     194:	f6 e4       	ldi	r31, 0x46	; 70
     196:	5f 2e       	mov	r5, r31
     198:	f0 2d       	mov	r31, r0
     19a:	66 24       	eor	r6, r6
     19c:	63 94       	inc	r6
     19e:	0f 2e       	mov	r0, r31
     1a0:	fc e4       	ldi	r31, 0x4C	; 76
     1a2:	7f 2e       	mov	r7, r31
     1a4:	f0 2d       	mov	r31, r0
     1a6:	0f 2e       	mov	r0, r31
     1a8:	f2 e5       	ldi	r31, 0x52	; 82
     1aa:	8f 2e       	mov	r8, r31
     1ac:	f0 2d       	mov	r31, r0
     1ae:	0f 2e       	mov	r0, r31
     1b0:	f2 e4       	ldi	r31, 0x42	; 66
     1b2:	9f 2e       	mov	r9, r31
     1b4:	f0 2d       	mov	r31, r0
     1b6:	34 d2       	rcall	.+1128   	; 0x620 <myMaxSonar_Start>
     1b8:	87 e2       	ldi	r24, 0x27	; 39
     1ba:	38 d2       	rcall	.+1136   	; 0x62c <myMaxSonar_Read>
     1bc:	6c 01       	movw	r12, r24
     1be:	86 e2       	ldi	r24, 0x26	; 38
     1c0:	35 d2       	rcall	.+1130   	; 0x62c <myMaxSonar_Read>
     1c2:	7c 01       	movw	r14, r24
     1c4:	85 e2       	ldi	r24, 0x25	; 37
     1c6:	32 d2       	rcall	.+1124   	; 0x62c <myMaxSonar_Read>
     1c8:	8c 01       	movw	r16, r24
     1ca:	0a d2       	rcall	.+1044   	; 0x5e0 <myHcSonar_Read>
     1cc:	5c 01       	movw	r10, r24
     1ce:	82 e3       	ldi	r24, 0x32	; 50
     1d0:	c8 16       	cp	r12, r24
     1d2:	d1 04       	cpc	r13, r1
     1d4:	1c f4       	brge	.+6      	; 0x1dc <Sonar_Task+0x60>
     1d6:	5b 82       	std	Y+3, r5	; 0x03
     1d8:	86 2d       	mov	r24, r6
     1da:	01 c0       	rjmp	.+2      	; 0x1de <Sonar_Task+0x62>
     1dc:	84 2d       	mov	r24, r4
     1de:	92 e3       	ldi	r25, 0x32	; 50
     1e0:	e9 16       	cp	r14, r25
     1e2:	f1 04       	cpc	r15, r1
     1e4:	14 f4       	brge	.+4      	; 0x1ea <Sonar_Task+0x6e>
     1e6:	8f 5f       	subi	r24, 0xFF	; 255
     1e8:	7c 82       	std	Y+4, r7	; 0x04
     1ea:	02 33       	cpi	r16, 0x32	; 50
     1ec:	11 05       	cpc	r17, r1
     1ee:	14 f4       	brge	.+4      	; 0x1f4 <Sonar_Task+0x78>
     1f0:	8f 5f       	subi	r24, 0xFF	; 255
     1f2:	8d 82       	std	Y+5, r8	; 0x05
     1f4:	92 e3       	ldi	r25, 0x32	; 50
     1f6:	a9 16       	cp	r10, r25
     1f8:	b1 04       	cpc	r11, r1
     1fa:	14 f4       	brge	.+4      	; 0x200 <Sonar_Task+0x84>
     1fc:	8f 5f       	subi	r24, 0xFF	; 255
     1fe:	9e 82       	std	Y+6, r9	; 0x06
     200:	88 23       	and	r24, r24
     202:	e1 f0       	breq	.+56     	; 0x23c <Sonar_Task+0xc0>
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	d0 d4       	rcall	.+2464   	; 0xba8 <myUSART_transmitUSART0>
     208:	8a e0       	ldi	r24, 0x0A	; 10
     20a:	a0 d4       	rcall	.+2368   	; 0xb4c <myUSART_transmitUSART0_c>
     20c:	b6 01       	movw	r22, r12
     20e:	8b 81       	ldd	r24, Y+3	; 0x03
     210:	97 df       	rcall	.-210    	; 0x140 <obstacleSend>
     212:	8a e0       	ldi	r24, 0x0A	; 10
     214:	9b d4       	rcall	.+2358   	; 0xb4c <myUSART_transmitUSART0_c>
     216:	b7 01       	movw	r22, r14
     218:	8c 81       	ldd	r24, Y+4	; 0x04
     21a:	92 df       	rcall	.-220    	; 0x140 <obstacleSend>
     21c:	8a e0       	ldi	r24, 0x0A	; 10
     21e:	96 d4       	rcall	.+2348   	; 0xb4c <myUSART_transmitUSART0_c>
     220:	b8 01       	movw	r22, r16
     222:	8d 81       	ldd	r24, Y+5	; 0x05
     224:	8d df       	rcall	.-230    	; 0x140 <obstacleSend>
     226:	8a e0       	ldi	r24, 0x0A	; 10
     228:	91 d4       	rcall	.+2338   	; 0xb4c <myUSART_transmitUSART0_c>
     22a:	b5 01       	movw	r22, r10
     22c:	8e 81       	ldd	r24, Y+6	; 0x06
     22e:	88 df       	rcall	.-240    	; 0x140 <obstacleSend>
     230:	8a e0       	ldi	r24, 0x0A	; 10
     232:	8c d4       	rcall	.+2328   	; 0xb4c <myUSART_transmitUSART0_c>
     234:	1b 82       	std	Y+3, r1	; 0x03
     236:	1c 82       	std	Y+4, r1	; 0x04
     238:	1d 82       	std	Y+5, r1	; 0x05
     23a:	1e 82       	std	Y+6, r1	; 0x06
     23c:	66 e9       	ldi	r22, 0x96	; 150
     23e:	70 e0       	ldi	r23, 0x00	; 0
     240:	ce 01       	movw	r24, r28
     242:	01 96       	adiw	r24, 0x01	; 1
     244:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <vTaskDelayUntil>
     248:	b6 cf       	rjmp	.-148    	; 0x1b6 <Sonar_Task+0x3a>

0000024a <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     24a:	8c ec       	ldi	r24, 0xCC	; 204
     24c:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     250:	8e e3       	ldi	r24, 0x3E	; 62
     252:	80 93 65 00 	sts	0x0065, r24
     256:	08 95       	ret

00000258 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     258:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     25c:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     260:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     264:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     268:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     26c:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     270:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     274:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     278:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     27c:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     280:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     284:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     288:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     28c:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     290:	10 92 73 00 	sts	0x0073, r1
     294:	08 95       	ret

00000296 <init>:
}

void init()
{
     296:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     298:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     29a:	f8 94       	cli
	{
		clearTimer();
     29c:	dd df       	rcall	.-70     	; 0x258 <clearTimer>
		setPowerReduction();
     29e:	d5 df       	rcall	.-86     	; 0x24a <setPowerReduction>
		myUSART_USART0_Init();
     2a0:	15 d4       	rcall	.+2090   	; 0xacc <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2a2:	34 d4       	rcall	.+2152   	; 0xb0c <myUSART_USART1_Init>
		myADC_Init();
     2a4:	01 d2       	rcall	.+1026   	; 0x6a8 <myADC_Init>
		MaxSonar_Init();
     2a6:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     2a8:	80 d1       	rcall	.+768    	; 0x5aa <myHcSonar_Init>
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2aa:	84 b1       	in	r24, 0x04	; 4
     2ac:	80 6c       	ori	r24, 0xC0	; 192
     2ae:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2b0:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2b2:	78 94       	sei
}
     2b4:	cf 91       	pop	r28
     2b6:	08 95       	ret

000002b8 <main>:
	
	// do nth
}

int main(void)
{
     2b8:	cf 93       	push	r28
     2ba:	df 93       	push	r29
     2bc:	cd b7       	in	r28, 0x3d	; 61
     2be:	de b7       	in	r29, 0x3e	; 62
     2c0:	28 97       	sbiw	r28, 0x08	; 8
     2c2:	0f b6       	in	r0, 0x3f	; 63
     2c4:	f8 94       	cli
     2c6:	de bf       	out	0x3e, r29	; 62
     2c8:	0f be       	out	0x3f, r0	; 63
     2ca:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2cc:	e4 df       	rcall	.-56     	; 0x296 <init>

//		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
//		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     2ce:	a1 2c       	mov	r10, r1
     2d0:	b1 2c       	mov	r11, r1
     2d2:	c1 2c       	mov	r12, r1
     2d4:	d1 2c       	mov	r13, r1
     2d6:	ce 01       	movw	r24, r28
     2d8:	01 96       	adiw	r24, 0x01	; 1
     2da:	7c 01       	movw	r14, r24
     2dc:	04 e0       	ldi	r16, 0x04	; 4
     2de:	9c 01       	movw	r18, r24
     2e0:	49 e6       	ldi	r20, 0x69	; 105
     2e2:	50 e0       	ldi	r21, 0x00	; 0
     2e4:	63 e3       	ldi	r22, 0x33	; 51
     2e6:	72 e0       	ldi	r23, 0x02	; 2
     2e8:	8d e9       	ldi	r24, 0x9D	; 157
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     2f0:	ce 01       	movw	r24, r28
     2f2:	07 96       	adiw	r24, 0x07	; 7
     2f4:	7c 01       	movw	r14, r24
     2f6:	02 e0       	ldi	r16, 0x02	; 2
     2f8:	20 e0       	ldi	r18, 0x00	; 0
     2fa:	30 e0       	ldi	r19, 0x00	; 0
     2fc:	4f e4       	ldi	r20, 0x4F	; 79
     2fe:	51 e0       	ldi	r21, 0x01	; 1
     300:	6b e3       	ldi	r22, 0x3B	; 59
     302:	72 e0       	ldi	r23, 0x02	; 2
     304:	8e eb       	ldi	r24, 0xBE	; 190
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     30c:	ce 01       	movw	r24, r28
     30e:	05 96       	adiw	r24, 0x05	; 5
     310:	7c 01       	movw	r14, r24
     312:	03 e0       	ldi	r16, 0x03	; 3
     314:	20 e0       	ldi	r18, 0x00	; 0
     316:	30 e0       	ldi	r19, 0x00	; 0
     318:	47 e8       	ldi	r20, 0x87	; 135
     31a:	50 e0       	ldi	r21, 0x00	; 0
     31c:	64 e4       	ldi	r22, 0x44	; 68
     31e:	72 e0       	ldi	r23, 0x02	; 2
     320:	83 e9       	ldi	r24, 0x93	; 147
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     328:	ce 01       	movw	r24, r28
     32a:	03 96       	adiw	r24, 0x03	; 3
     32c:	7c 01       	movw	r14, r24
     32e:	02 e0       	ldi	r16, 0x02	; 2
     330:	20 e0       	ldi	r18, 0x00	; 0
     332:	30 e0       	ldi	r19, 0x00	; 0
     334:	47 e8       	ldi	r20, 0x87	; 135
     336:	50 e0       	ldi	r21, 0x00	; 0
     338:	60 e5       	ldi	r22, 0x50	; 80
     33a:	72 e0       	ldi	r23, 0x02	; 2
     33c:	88 e9       	ldi	r24, 0x98	; 152
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	0e 94 f1 0a 	call	0x15e2	; 0x15e2 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     344:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <vTaskStartScheduler>
     348:	c1 cf       	rjmp	.-126    	; 0x2cc <main+0x14>

0000034a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     34a:	cf 93       	push	r28
     34c:	df 93       	push	r29
     34e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     350:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     354:	80 91 5e 02 	lds	r24, 0x025E
     358:	90 91 5f 02 	lds	r25, 0x025F
     35c:	89 2b       	or	r24, r25
     35e:	31 f4       	brne	.+12     	; 0x36c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     360:	83 e6       	ldi	r24, 0x63	; 99
     362:	92 e0       	ldi	r25, 0x02	; 2
     364:	90 93 5f 02 	sts	0x025F, r25
     368:	80 93 5e 02 	sts	0x025E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     36c:	40 91 60 02 	lds	r20, 0x0260
     370:	50 91 61 02 	lds	r21, 0x0261
     374:	9e 01       	movw	r18, r28
     376:	24 0f       	add	r18, r20
     378:	35 1f       	adc	r19, r21
     37a:	2b 3d       	cpi	r18, 0xDB	; 219
     37c:	85 e0       	ldi	r24, 0x05	; 5
     37e:	38 07       	cpc	r19, r24
     380:	70 f4       	brcc	.+28     	; 0x39e <pvPortMalloc+0x54>
     382:	42 17       	cp	r20, r18
     384:	53 07       	cpc	r21, r19
     386:	70 f4       	brcc	.+28     	; 0x3a4 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     388:	c0 91 5e 02 	lds	r28, 0x025E
     38c:	d0 91 5f 02 	lds	r29, 0x025F
     390:	c4 0f       	add	r28, r20
     392:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     394:	30 93 61 02 	sts	0x0261, r19
     398:	20 93 60 02 	sts	0x0260, r18
     39c:	05 c0       	rjmp	.+10     	; 0x3a8 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     39e:	c0 e0       	ldi	r28, 0x00	; 0
     3a0:	d0 e0       	ldi	r29, 0x00	; 0
     3a2:	02 c0       	rjmp	.+4      	; 0x3a8 <pvPortMalloc+0x5e>
     3a4:	c0 e0       	ldi	r28, 0x00	; 0
     3a6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3a8:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3ac:	ce 01       	movw	r24, r28
     3ae:	df 91       	pop	r29
     3b0:	cf 91       	pop	r28
     3b2:	08 95       	ret

000003b4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3b4:	08 95       	ret

000003b6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3b6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3b8:	03 96       	adiw	r24, 0x03	; 3
     3ba:	92 83       	std	Z+2, r25	; 0x02
     3bc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3be:	2f ef       	ldi	r18, 0xFF	; 255
     3c0:	3f ef       	ldi	r19, 0xFF	; 255
     3c2:	34 83       	std	Z+4, r19	; 0x04
     3c4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3c6:	96 83       	std	Z+6, r25	; 0x06
     3c8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3ca:	90 87       	std	Z+8, r25	; 0x08
     3cc:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     3ce:	10 82       	st	Z, r1
     3d0:	08 95       	ret

000003d2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     3d2:	fc 01       	movw	r30, r24
     3d4:	11 86       	std	Z+9, r1	; 0x09
     3d6:	10 86       	std	Z+8, r1	; 0x08
     3d8:	08 95       	ret

000003da <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3da:	cf 93       	push	r28
     3dc:	df 93       	push	r29
     3de:	9c 01       	movw	r18, r24
     3e0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3e2:	dc 01       	movw	r26, r24
     3e4:	11 96       	adiw	r26, 0x01	; 1
     3e6:	cd 91       	ld	r28, X+
     3e8:	dc 91       	ld	r29, X
     3ea:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3ec:	d3 83       	std	Z+3, r29	; 0x03
     3ee:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3f0:	8c 81       	ldd	r24, Y+4	; 0x04
     3f2:	9d 81       	ldd	r25, Y+5	; 0x05
     3f4:	95 83       	std	Z+5, r25	; 0x05
     3f6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3f8:	8c 81       	ldd	r24, Y+4	; 0x04
     3fa:	9d 81       	ldd	r25, Y+5	; 0x05
     3fc:	dc 01       	movw	r26, r24
     3fe:	13 96       	adiw	r26, 0x03	; 3
     400:	7c 93       	st	X, r23
     402:	6e 93       	st	-X, r22
     404:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     406:	7d 83       	std	Y+5, r23	; 0x05
     408:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     40a:	31 87       	std	Z+9, r19	; 0x09
     40c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     40e:	f9 01       	movw	r30, r18
     410:	80 81       	ld	r24, Z
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	80 83       	st	Z, r24
}
     416:	df 91       	pop	r29
     418:	cf 91       	pop	r28
     41a:	08 95       	ret

0000041c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     41c:	cf 93       	push	r28
     41e:	df 93       	push	r29
     420:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     422:	48 81       	ld	r20, Y
     424:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     426:	4f 3f       	cpi	r20, 0xFF	; 255
     428:	2f ef       	ldi	r18, 0xFF	; 255
     42a:	52 07       	cpc	r21, r18
     42c:	21 f4       	brne	.+8      	; 0x436 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     42e:	fc 01       	movw	r30, r24
     430:	a7 81       	ldd	r26, Z+7	; 0x07
     432:	b0 85       	ldd	r27, Z+8	; 0x08
     434:	0d c0       	rjmp	.+26     	; 0x450 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     436:	dc 01       	movw	r26, r24
     438:	13 96       	adiw	r26, 0x03	; 3
     43a:	12 96       	adiw	r26, 0x02	; 2
     43c:	ed 91       	ld	r30, X+
     43e:	fc 91       	ld	r31, X
     440:	13 97       	sbiw	r26, 0x03	; 3
     442:	20 81       	ld	r18, Z
     444:	31 81       	ldd	r19, Z+1	; 0x01
     446:	42 17       	cp	r20, r18
     448:	53 07       	cpc	r21, r19
     44a:	10 f0       	brcs	.+4      	; 0x450 <vListInsert+0x34>
     44c:	df 01       	movw	r26, r30
     44e:	f5 cf       	rjmp	.-22     	; 0x43a <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     450:	12 96       	adiw	r26, 0x02	; 2
     452:	ed 91       	ld	r30, X+
     454:	fc 91       	ld	r31, X
     456:	13 97       	sbiw	r26, 0x03	; 3
     458:	fb 83       	std	Y+3, r31	; 0x03
     45a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     45c:	d5 83       	std	Z+5, r29	; 0x05
     45e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     460:	bd 83       	std	Y+5, r27	; 0x05
     462:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     464:	13 96       	adiw	r26, 0x03	; 3
     466:	dc 93       	st	X, r29
     468:	ce 93       	st	-X, r28
     46a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     46c:	99 87       	std	Y+9, r25	; 0x09
     46e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     470:	fc 01       	movw	r30, r24
     472:	20 81       	ld	r18, Z
     474:	2f 5f       	subi	r18, 0xFF	; 255
     476:	20 83       	st	Z, r18
}
     478:	df 91       	pop	r29
     47a:	cf 91       	pop	r28
     47c:	08 95       	ret

0000047e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     47e:	cf 93       	push	r28
     480:	df 93       	push	r29
     482:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     484:	a0 85       	ldd	r26, Z+8	; 0x08
     486:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     488:	c2 81       	ldd	r28, Z+2	; 0x02
     48a:	d3 81       	ldd	r29, Z+3	; 0x03
     48c:	84 81       	ldd	r24, Z+4	; 0x04
     48e:	95 81       	ldd	r25, Z+5	; 0x05
     490:	9d 83       	std	Y+5, r25	; 0x05
     492:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     494:	c4 81       	ldd	r28, Z+4	; 0x04
     496:	d5 81       	ldd	r29, Z+5	; 0x05
     498:	82 81       	ldd	r24, Z+2	; 0x02
     49a:	93 81       	ldd	r25, Z+3	; 0x03
     49c:	9b 83       	std	Y+3, r25	; 0x03
     49e:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4a0:	11 96       	adiw	r26, 0x01	; 1
     4a2:	cd 91       	ld	r28, X+
     4a4:	dc 91       	ld	r29, X
     4a6:	12 97       	sbiw	r26, 0x02	; 2
     4a8:	ce 17       	cp	r28, r30
     4aa:	df 07       	cpc	r29, r31
     4ac:	31 f4       	brne	.+12     	; 0x4ba <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4ae:	8c 81       	ldd	r24, Y+4	; 0x04
     4b0:	9d 81       	ldd	r25, Y+5	; 0x05
     4b2:	12 96       	adiw	r26, 0x02	; 2
     4b4:	9c 93       	st	X, r25
     4b6:	8e 93       	st	-X, r24
     4b8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     4ba:	11 86       	std	Z+9, r1	; 0x09
     4bc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4be:	8c 91       	ld	r24, X
     4c0:	81 50       	subi	r24, 0x01	; 1
     4c2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     4c4:	df 91       	pop	r29
     4c6:	cf 91       	pop	r28
     4c8:	08 95       	ret

000004ca <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     4ca:	1f 92       	push	r1
     4cc:	0f 92       	push	r0
     4ce:	0f b6       	in	r0, 0x3f	; 63
     4d0:	0f 92       	push	r0
     4d2:	11 24       	eor	r1, r1
     4d4:	0b b6       	in	r0, 0x3b	; 59
     4d6:	0f 92       	push	r0
     4d8:	2f 93       	push	r18
     4da:	3f 93       	push	r19
     4dc:	4f 93       	push	r20
     4de:	5f 93       	push	r21
     4e0:	6f 93       	push	r22
     4e2:	7f 93       	push	r23
     4e4:	8f 93       	push	r24
     4e6:	9f 93       	push	r25
     4e8:	af 93       	push	r26
     4ea:	bf 93       	push	r27
     4ec:	ef 93       	push	r30
     4ee:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     4f0:	1b 9b       	sbis	0x03, 3	; 3
     4f2:	0d c0       	rjmp	.+26     	; 0x50e <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     4f4:	57 d1       	rcall	.+686    	; 0x7a4 <myTimer_Read>
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	90 93 ae 08 	sts	0x08AE, r25
     4fc:	80 93 ad 08 	sts	0x08AD, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     500:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGetTickCountFromISR>
     504:	90 93 aa 08 	sts	0x08AA, r25
     508:	80 93 a9 08 	sts	0x08A9, r24
     50c:	3b c0       	rjmp	.+118    	; 0x584 <__vector_9+0xba>
	}	
	else if (!(HC_Echo_Read))
     50e:	1b 99       	sbic	0x03, 3	; 3
     510:	39 c0       	rjmp	.+114    	; 0x584 <__vector_9+0xba>
	{
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     512:	48 d1       	rcall	.+656    	; 0x7a4 <myTimer_Read>
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	90 93 b4 08 	sts	0x08B4, r25
     51a:	80 93 b3 08 	sts	0x08B3, r24
     51e:	20 91 ad 08 	lds	r18, 0x08AD
     522:	30 91 ae 08 	lds	r19, 0x08AE
     526:	82 17       	cp	r24, r18
     528:	93 07       	cpc	r25, r19
     52a:	54 f4       	brge	.+20     	; 0x540 <__vector_9+0x76>
		us_tickEnd += MAX_TICKS;
     52c:	80 91 b3 08 	lds	r24, 0x08B3
     530:	90 91 b4 08 	lds	r25, 0x08B4
     534:	86 50       	subi	r24, 0x06	; 6
     536:	9f 4f       	sbci	r25, 0xFF	; 255
     538:	90 93 b4 08 	sts	0x08B4, r25
     53c:	80 93 b3 08 	sts	0x08B3, r24
			
		us_tickLapsed = myTimer_Read() - us_tickStart;
     540:	31 d1       	rcall	.+610    	; 0x7a4 <myTimer_Read>
     542:	20 91 ad 08 	lds	r18, 0x08AD
     546:	30 91 ae 08 	lds	r19, 0x08AE
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	82 1b       	sub	r24, r18
     54e:	93 0b       	sbc	r25, r19
     550:	90 93 b0 08 	sts	0x08B0, r25
     554:	80 93 af 08 	sts	0x08AF, r24
		ms_tickLapsed = xTaskGetTickCountFromISR() - ms_tickStart;
     558:	0e 94 8a 0c 	call	0x1914	; 0x1914 <xTaskGetTickCountFromISR>
     55c:	20 91 a9 08 	lds	r18, 0x08A9
     560:	30 91 aa 08 	lds	r19, 0x08AA
     564:	82 1b       	sub	r24, r18
     566:	93 0b       	sbc	r25, r19
     568:	90 93 ac 08 	sts	0x08AC, r25
     56c:	80 93 ab 08 	sts	0x08AB, r24
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     570:	20 e0       	ldi	r18, 0x00	; 0
     572:	40 e0       	ldi	r20, 0x00	; 0
     574:	50 e0       	ldi	r21, 0x00	; 0
     576:	60 e0       	ldi	r22, 0x00	; 0
     578:	70 e0       	ldi	r23, 0x00	; 0
     57a:	80 91 b1 08 	lds	r24, 0x08B1
     57e:	90 91 b2 08 	lds	r25, 0x08B2
     582:	ae d6       	rcall	.+3420   	; 0x12e0 <xQueueGenericSendFromISR>
	}	
}
     584:	ff 91       	pop	r31
     586:	ef 91       	pop	r30
     588:	bf 91       	pop	r27
     58a:	af 91       	pop	r26
     58c:	9f 91       	pop	r25
     58e:	8f 91       	pop	r24
     590:	7f 91       	pop	r23
     592:	6f 91       	pop	r22
     594:	5f 91       	pop	r21
     596:	4f 91       	pop	r20
     598:	3f 91       	pop	r19
     59a:	2f 91       	pop	r18
     59c:	0f 90       	pop	r0
     59e:	0b be       	out	0x3b, r0	; 59
     5a0:	0f 90       	pop	r0
     5a2:	0f be       	out	0x3f, r0	; 63
     5a4:	0f 90       	pop	r0
     5a6:	1f 90       	pop	r1
     5a8:	18 95       	reti

000005aa <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     5aa:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     5ac:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     5ae:	e8 e6       	ldi	r30, 0x68	; 104
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	80 81       	ld	r24, Z
     5b4:	81 60       	ori	r24, 0x01	; 1
     5b6:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     5b8:	eb e6       	ldi	r30, 0x6B	; 107
     5ba:	f0 e0       	ldi	r31, 0x00	; 0
     5bc:	80 81       	ld	r24, Z
     5be:	88 60       	ori	r24, 0x08	; 8
     5c0:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     5c2:	43 e0       	ldi	r20, 0x03	; 3
     5c4:	60 e0       	ldi	r22, 0x00	; 0
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	a6 d5       	rcall	.+2892   	; 0x1116 <xQueueGenericCreate>
     5ca:	90 93 b2 08 	sts	0x08B2, r25
     5ce:	80 93 b1 08 	sts	0x08B1, r24
     5d2:	08 95       	ret

000005d4 <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     5d4:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     5d6:	8e e1       	ldi	r24, 0x1E	; 30
     5d8:	90 e0       	ldi	r25, 0x00	; 0
     5da:	0a d1       	rcall	.+532    	; 0x7f0 <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     5dc:	2a 98       	cbi	0x05, 2	; 5
     5de:	08 95       	ret

000005e0 <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     5e0:	f9 df       	rcall	.-14     	; 0x5d4 <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	4f ef       	ldi	r20, 0xFF	; 255
     5e6:	5f ef       	ldi	r21, 0xFF	; 255
     5e8:	60 e0       	ldi	r22, 0x00	; 0
     5ea:	70 e0       	ldi	r23, 0x00	; 0
     5ec:	80 91 b1 08 	lds	r24, 0x08B1
     5f0:	90 91 b2 08 	lds	r25, 0x08B2
     5f4:	af d6       	rcall	.+3422   	; 0x1354 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     5f6:	80 91 af 08 	lds	r24, 0x08AF
     5fa:	90 91 b0 08 	lds	r25, 0x08B0
	msLength = ms_tickLapsed * 17;
     5fe:	20 91 ab 08 	lds	r18, 0x08AB
     602:	30 91 ac 08 	lds	r19, 0x08AC
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     606:	6e e0       	ldi	r22, 0x0E	; 14
     608:	70 e0       	ldi	r23, 0x00	; 0
     60a:	0e 94 59 10 	call	0x20b2	; 0x20b2 <__divmodhi4>
	msLength = ms_tickLapsed * 17;
     60e:	41 e1       	ldi	r20, 0x11	; 17
     610:	42 9f       	mul	r20, r18
     612:	c0 01       	movw	r24, r0
     614:	43 9f       	mul	r20, r19
     616:	90 0d       	add	r25, r0
     618:	11 24       	eor	r1, r1
	return usLength + msLength;
	
     61a:	86 0f       	add	r24, r22
     61c:	97 1f       	adc	r25, r23
     61e:	08 95       	ret

00000620 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     620:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     622:	89 e1       	ldi	r24, 0x19	; 25
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	c0 d0       	rcall	.+384    	; 0x7a8 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     628:	a1 98       	cbi	0x14, 1	; 20
     62a:	08 95       	ret

0000062c <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     62c:	9a d0       	rcall	.+308    	; 0x762 <myADC_analogRead>
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	9c 01       	movw	r18, r24
     632:	22 0f       	add	r18, r18
     634:	33 1f       	adc	r19, r19
     636:	22 0f       	add	r18, r18
     638:	33 1f       	adc	r19, r19
}
     63a:	82 0f       	add	r24, r18
     63c:	93 1f       	adc	r25, r19
     63e:	08 95       	ret

00000640 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     640:	1f 92       	push	r1
     642:	0f 92       	push	r0
     644:	0f b6       	in	r0, 0x3f	; 63
     646:	0f 92       	push	r0
     648:	11 24       	eor	r1, r1
     64a:	0b b6       	in	r0, 0x3b	; 59
     64c:	0f 92       	push	r0
     64e:	2f 93       	push	r18
     650:	3f 93       	push	r19
     652:	4f 93       	push	r20
     654:	5f 93       	push	r21
     656:	6f 93       	push	r22
     658:	7f 93       	push	r23
     65a:	8f 93       	push	r24
     65c:	9f 93       	push	r25
     65e:	af 93       	push	r26
     660:	bf 93       	push	r27
     662:	ef 93       	push	r30
     664:	ff 93       	push	r31
	adcReading = ADCH; // read value
     666:	80 91 79 00 	lds	r24, 0x0079
     66a:	80 93 b5 08 	sts	0x08B5, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	40 e0       	ldi	r20, 0x00	; 0
     672:	50 e0       	ldi	r21, 0x00	; 0
     674:	60 e0       	ldi	r22, 0x00	; 0
     676:	70 e0       	ldi	r23, 0x00	; 0
     678:	80 91 b8 08 	lds	r24, 0x08B8
     67c:	90 91 b9 08 	lds	r25, 0x08B9
     680:	2f d6       	rcall	.+3166   	; 0x12e0 <xQueueGenericSendFromISR>
}
     682:	ff 91       	pop	r31
     684:	ef 91       	pop	r30
     686:	bf 91       	pop	r27
     688:	af 91       	pop	r26
     68a:	9f 91       	pop	r25
     68c:	8f 91       	pop	r24
     68e:	7f 91       	pop	r23
     690:	6f 91       	pop	r22
     692:	5f 91       	pop	r21
     694:	4f 91       	pop	r20
     696:	3f 91       	pop	r19
     698:	2f 91       	pop	r18
     69a:	0f 90       	pop	r0
     69c:	0b be       	out	0x3b, r0	; 59
     69e:	0f 90       	pop	r0
     6a0:	0f be       	out	0x3f, r0	; 63
     6a2:	0f 90       	pop	r0
     6a4:	1f 90       	pop	r1
     6a6:	18 95       	reti

000006a8 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     6a8:	8f e8       	ldi	r24, 0x8F	; 143
     6aa:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     6ae:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     6b2:	80 e6       	ldi	r24, 0x60	; 96
     6b4:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     6b8:	43 e0       	ldi	r20, 0x03	; 3
     6ba:	60 e0       	ldi	r22, 0x00	; 0
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	2b d5       	rcall	.+2646   	; 0x1116 <xQueueGenericCreate>
     6c0:	90 93 b9 08 	sts	0x08B9, r25
     6c4:	80 93 b8 08 	sts	0x08B8, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	e2 d5       	rcall	.+3012   	; 0x1290 <xQueueCreateMutex>
     6cc:	90 93 b7 08 	sts	0x08B7, r25
     6d0:	80 93 b6 08 	sts	0x08B6, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     6d4:	20 e0       	ldi	r18, 0x00	; 0
     6d6:	40 e0       	ldi	r20, 0x00	; 0
     6d8:	50 e0       	ldi	r21, 0x00	; 0
     6da:	60 e0       	ldi	r22, 0x00	; 0
     6dc:	70 e0       	ldi	r23, 0x00	; 0
     6de:	45 c5       	rjmp	.+2698   	; 0x116a <xQueueGenericSend>
     6e0:	08 95       	ret

000006e2 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     6e2:	cf 93       	push	r28
     6e4:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	4f ef       	ldi	r20, 0xFF	; 255
     6ea:	5f ef       	ldi	r21, 0xFF	; 255
     6ec:	60 e0       	ldi	r22, 0x00	; 0
     6ee:	70 e0       	ldi	r23, 0x00	; 0
     6f0:	80 91 b6 08 	lds	r24, 0x08B6
     6f4:	90 91 b7 08 	lds	r25, 0x08B7
     6f8:	2d d6       	rcall	.+3162   	; 0x1354 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     6fa:	ec e7       	ldi	r30, 0x7C	; 124
     6fc:	f0 e0       	ldi	r31, 0x00	; 0
     6fe:	80 81       	ld	r24, Z
     700:	9c 2f       	mov	r25, r28
     702:	9f 71       	andi	r25, 0x1F	; 31
     704:	80 76       	andi	r24, 0x60	; 96
     706:	89 2b       	or	r24, r25
     708:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     70a:	eb e7       	ldi	r30, 0x7B	; 123
     70c:	f0 e0       	ldi	r31, 0x00	; 0
     70e:	20 81       	ld	r18, Z
     710:	c0 72       	andi	r28, 0x20	; 32
     712:	8c 2f       	mov	r24, r28
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	95 95       	asr	r25
     718:	87 95       	ror	r24
     71a:	95 95       	asr	r25
     71c:	87 95       	ror	r24
     71e:	92 2f       	mov	r25, r18
     720:	90 76       	andi	r25, 0x60	; 96
     722:	89 2b       	or	r24, r25
     724:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     726:	ea e7       	ldi	r30, 0x7A	; 122
     728:	f0 e0       	ldi	r31, 0x00	; 0
     72a:	80 81       	ld	r24, Z
     72c:	80 64       	ori	r24, 0x40	; 64
     72e:	80 83       	st	Z, r24
}
     730:	cf 91       	pop	r28
     732:	08 95       	ret

00000734 <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	4f ef       	ldi	r20, 0xFF	; 255
     738:	5f ef       	ldi	r21, 0xFF	; 255
     73a:	60 e0       	ldi	r22, 0x00	; 0
     73c:	70 e0       	ldi	r23, 0x00	; 0
     73e:	80 91 b8 08 	lds	r24, 0x08B8
     742:	90 91 b9 08 	lds	r25, 0x08B9
     746:	06 d6       	rcall	.+3084   	; 0x1354 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	40 e0       	ldi	r20, 0x00	; 0
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	60 e0       	ldi	r22, 0x00	; 0
     750:	70 e0       	ldi	r23, 0x00	; 0
     752:	80 91 b6 08 	lds	r24, 0x08B6
     756:	90 91 b7 08 	lds	r25, 0x08B7
     75a:	07 d5       	rcall	.+2574   	; 0x116a <xQueueGenericSend>
	return adcReading;
     75c:	80 91 b5 08 	lds	r24, 0x08B5
     760:	08 95       	ret

00000762 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     762:	cf 93       	push	r28
     764:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     766:	bd df       	rcall	.-134    	; 0x6e2 <myADC_startADC>
	return myADC_readADC(channel);
     768:	8c 2f       	mov	r24, r28
     76a:	e4 df       	rcall	.-56     	; 0x734 <myADC_readADC>
}
     76c:	cf 91       	pop	r28
     76e:	08 95       	ret

00000770 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     770:	90 93 bf 08 	sts	0x08BF, r25
     774:	80 93 be 08 	sts	0x08BE, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     778:	fc 01       	movw	r30, r24
     77a:	80 81       	ld	r24, Z
     77c:	91 81       	ldd	r25, Z+1	; 0x01
     77e:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     782:	43 e0       	ldi	r20, 0x03	; 3
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	81 e0       	ldi	r24, 0x01	; 1
     788:	c6 d4       	rcall	.+2444   	; 0x1116 <xQueueGenericCreate>
     78a:	90 93 bb 08 	sts	0x08BB, r25
     78e:	80 93 ba 08 	sts	0x08BA, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     792:	43 e0       	ldi	r20, 0x03	; 3
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	be d4       	rcall	.+2428   	; 0x1116 <xQueueGenericCreate>
     79a:	90 93 bd 08 	sts	0x08BD, r25
     79e:	80 93 bc 08 	sts	0x08BC, r24
     7a2:	08 95       	ret

000007a4 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7a4:	86 b5       	in	r24, 0x26	; 38
}
     7a6:	08 95       	ret

000007a8 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7a8:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     7aa:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     7ac:	9c 01       	movw	r18, r24
     7ae:	99 23       	and	r25, r25
     7b0:	14 f4       	brge	.+4      	; 0x7b6 <myTimer_DelayMicro+0xe>
     7b2:	2d 5f       	subi	r18, 0xFD	; 253
     7b4:	3f 4f       	sbci	r19, 0xFF	; 255
     7b6:	35 95       	asr	r19
     7b8:	27 95       	ror	r18
     7ba:	35 95       	asr	r19
     7bc:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     7be:	24 0f       	add	r18, r20
     7c0:	35 1f       	adc	r19, r21
     7c2:	30 93 03 02 	sts	0x0203, r19
     7c6:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     7ca:	e0 91 be 08 	lds	r30, 0x08BE
     7ce:	f0 91 bf 08 	lds	r31, 0x08BF
     7d2:	80 81       	ld	r24, Z
     7d4:	91 81       	ldd	r25, Z+1	; 0x01
     7d6:	0e 94 06 0c 	call	0x180c	; 0x180c <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     7da:	20 e0       	ldi	r18, 0x00	; 0
     7dc:	42 e0       	ldi	r20, 0x02	; 2
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	70 e0       	ldi	r23, 0x00	; 0
     7e4:	80 91 ba 08 	lds	r24, 0x08BA
     7e8:	90 91 bb 08 	lds	r25, 0x08BB
     7ec:	b3 c5       	rjmp	.+2918   	; 0x1354 <xQueueGenericReceive>
     7ee:	08 95       	ret

000007f0 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7f0:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     7f2:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     7f4:	9c 01       	movw	r18, r24
     7f6:	99 23       	and	r25, r25
     7f8:	14 f4       	brge	.+4      	; 0x7fe <myTimer_DelayMicro2+0xe>
     7fa:	2d 5f       	subi	r18, 0xFD	; 253
     7fc:	3f 4f       	sbci	r19, 0xFF	; 255
     7fe:	35 95       	asr	r19
     800:	27 95       	ror	r18
     802:	35 95       	asr	r19
     804:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     806:	24 0f       	add	r18, r20
     808:	35 1f       	adc	r19, r21
     80a:	30 93 01 02 	sts	0x0201, r19
     80e:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     812:	e0 91 be 08 	lds	r30, 0x08BE
     816:	f0 91 bf 08 	lds	r31, 0x08BF
     81a:	80 81       	ld	r24, Z
     81c:	91 81       	ldd	r25, Z+1	; 0x01
     81e:	f6 d7       	rcall	.+4076   	; 0x180c <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     820:	20 e0       	ldi	r18, 0x00	; 0
     822:	42 e0       	ldi	r20, 0x02	; 2
     824:	50 e0       	ldi	r21, 0x00	; 0
     826:	60 e0       	ldi	r22, 0x00	; 0
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	80 91 bc 08 	lds	r24, 0x08BC
     82e:	90 91 bd 08 	lds	r25, 0x08BD
     832:	90 c5       	rjmp	.+2848   	; 0x1354 <xQueueGenericReceive>
     834:	08 95       	ret

00000836 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     83a:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     83c:	c1 11       	cpse	r28, r1
     83e:	22 c0       	rjmp	.+68     	; 0x884 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     840:	80 91 02 02 	lds	r24, 0x0202
     844:	90 91 03 02 	lds	r25, 0x0203
     848:	88 38       	cpi	r24, 0x88	; 136
     84a:	93 41       	sbci	r25, 0x13	; 19
     84c:	51 f0       	breq	.+20     	; 0x862 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     84e:	80 91 02 02 	lds	r24, 0x0202
     852:	90 91 03 02 	lds	r25, 0x0203
     856:	8a 5f       	subi	r24, 0xFA	; 250
     858:	91 09       	sbc	r25, r1
     85a:	90 93 03 02 	sts	0x0203, r25
     85e:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     862:	80 91 00 02 	lds	r24, 0x0200
     866:	90 91 01 02 	lds	r25, 0x0201
     86a:	88 38       	cpi	r24, 0x88	; 136
     86c:	93 41       	sbci	r25, 0x13	; 19
     86e:	51 f0       	breq	.+20     	; 0x884 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     870:	80 91 00 02 	lds	r24, 0x0200
     874:	90 91 01 02 	lds	r25, 0x0201
     878:	8a 5f       	subi	r24, 0xFA	; 250
     87a:	91 09       	sbc	r25, r1
     87c:	90 93 01 02 	sts	0x0201, r25
     880:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     884:	d0 e0       	ldi	r29, 0x00	; 0
     886:	80 91 02 02 	lds	r24, 0x0202
     88a:	90 91 03 02 	lds	r25, 0x0203
     88e:	8c 17       	cp	r24, r28
     890:	9d 07       	cpc	r25, r29
     892:	84 f4       	brge	.+32     	; 0x8b4 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     894:	88 e8       	ldi	r24, 0x88	; 136
     896:	93 e1       	ldi	r25, 0x13	; 19
     898:	90 93 03 02 	sts	0x0203, r25
     89c:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     8a0:	20 e0       	ldi	r18, 0x00	; 0
     8a2:	40 e0       	ldi	r20, 0x00	; 0
     8a4:	50 e0       	ldi	r21, 0x00	; 0
     8a6:	60 e0       	ldi	r22, 0x00	; 0
     8a8:	70 e0       	ldi	r23, 0x00	; 0
     8aa:	80 91 ba 08 	lds	r24, 0x08BA
     8ae:	90 91 bb 08 	lds	r25, 0x08BB
     8b2:	5b d4       	rcall	.+2230   	; 0x116a <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     8b4:	80 91 00 02 	lds	r24, 0x0200
     8b8:	90 91 01 02 	lds	r25, 0x0201
     8bc:	8c 17       	cp	r24, r28
     8be:	9d 07       	cpc	r25, r29
     8c0:	84 f4       	brge	.+32     	; 0x8e2 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     8c2:	88 e8       	ldi	r24, 0x88	; 136
     8c4:	93 e1       	ldi	r25, 0x13	; 19
     8c6:	90 93 01 02 	sts	0x0201, r25
     8ca:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     8ce:	20 e0       	ldi	r18, 0x00	; 0
     8d0:	40 e0       	ldi	r20, 0x00	; 0
     8d2:	50 e0       	ldi	r21, 0x00	; 0
     8d4:	60 e0       	ldi	r22, 0x00	; 0
     8d6:	70 e0       	ldi	r23, 0x00	; 0
     8d8:	80 91 bc 08 	lds	r24, 0x08BC
     8dc:	90 91 bd 08 	lds	r25, 0x08BD
     8e0:	44 d4       	rcall	.+2184   	; 0x116a <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     8e2:	80 91 02 02 	lds	r24, 0x0202
     8e6:	90 91 03 02 	lds	r25, 0x0203
     8ea:	88 38       	cpi	r24, 0x88	; 136
     8ec:	93 41       	sbci	r25, 0x13	; 19
     8ee:	79 f4       	brne	.+30     	; 0x90e <myTimer_DelayChecker+0xd8>
     8f0:	80 91 00 02 	lds	r24, 0x0200
     8f4:	90 91 01 02 	lds	r25, 0x0201
     8f8:	88 38       	cpi	r24, 0x88	; 136
     8fa:	93 41       	sbci	r25, 0x13	; 19
     8fc:	41 f4       	brne	.+16     	; 0x90e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     8fe:	e0 91 be 08 	lds	r30, 0x08BE
     902:	f0 91 bf 08 	lds	r31, 0x08BF
     906:	80 81       	ld	r24, Z
     908:	91 81       	ldd	r25, Z+1	; 0x01
     90a:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <vTaskSuspend>
	}
     90e:	df 91       	pop	r29
     910:	cf 91       	pop	r28
     912:	08 95       	ret

00000914 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     914:	1f 92       	push	r1
     916:	0f 92       	push	r0
     918:	0f b6       	in	r0, 0x3f	; 63
     91a:	0f 92       	push	r0
     91c:	11 24       	eor	r1, r1
     91e:	0b b6       	in	r0, 0x3b	; 59
     920:	0f 92       	push	r0
     922:	2f 93       	push	r18
     924:	3f 93       	push	r19
     926:	4f 93       	push	r20
     928:	5f 93       	push	r21
     92a:	6f 93       	push	r22
     92c:	7f 93       	push	r23
     92e:	8f 93       	push	r24
     930:	9f 93       	push	r25
     932:	af 93       	push	r26
     934:	bf 93       	push	r27
     936:	ef 93       	push	r30
     938:	ff 93       	push	r31
     93a:	60 91 ce 00 	lds	r22, 0x00CE
     93e:	83 e5       	ldi	r24, 0x53	; 83
     940:	99 e0       	ldi	r25, 0x09	; 9
     942:	d4 d5       	rcall	.+2984   	; 0x14ec <ringBufferPush>
     944:	20 e0       	ldi	r18, 0x00	; 0
     946:	40 e0       	ldi	r20, 0x00	; 0
     948:	50 e0       	ldi	r21, 0x00	; 0
     94a:	60 e0       	ldi	r22, 0x00	; 0
     94c:	70 e0       	ldi	r23, 0x00	; 0
     94e:	80 91 47 09 	lds	r24, 0x0947
     952:	90 91 48 09 	lds	r25, 0x0948
     956:	c4 d4       	rcall	.+2440   	; 0x12e0 <xQueueGenericSendFromISR>
     958:	83 e5       	ldi	r24, 0x53	; 83
     95a:	99 e0       	ldi	r25, 0x09	; 9
     95c:	dd d5       	rcall	.+3002   	; 0x1518 <ringBufferFull>
     95e:	ff 91       	pop	r31
     960:	ef 91       	pop	r30
     962:	bf 91       	pop	r27
     964:	af 91       	pop	r26
     966:	9f 91       	pop	r25
     968:	8f 91       	pop	r24
     96a:	7f 91       	pop	r23
     96c:	6f 91       	pop	r22
     96e:	5f 91       	pop	r21
     970:	4f 91       	pop	r20
     972:	3f 91       	pop	r19
     974:	2f 91       	pop	r18
     976:	0f 90       	pop	r0
     978:	0b be       	out	0x3b, r0	; 59
     97a:	0f 90       	pop	r0
     97c:	0f be       	out	0x3f, r0	; 63
     97e:	0f 90       	pop	r0
     980:	1f 90       	pop	r1
     982:	18 95       	reti

00000984 <__vector_25>:
     984:	1f 92       	push	r1
     986:	0f 92       	push	r0
     988:	0f b6       	in	r0, 0x3f	; 63
     98a:	0f 92       	push	r0
     98c:	11 24       	eor	r1, r1
     98e:	0b b6       	in	r0, 0x3b	; 59
     990:	0f 92       	push	r0
     992:	2f 93       	push	r18
     994:	3f 93       	push	r19
     996:	4f 93       	push	r20
     998:	5f 93       	push	r21
     99a:	6f 93       	push	r22
     99c:	7f 93       	push	r23
     99e:	8f 93       	push	r24
     9a0:	9f 93       	push	r25
     9a2:	af 93       	push	r26
     9a4:	bf 93       	push	r27
     9a6:	ef 93       	push	r30
     9a8:	ff 93       	push	r31
     9aa:	60 91 c6 00 	lds	r22, 0x00C6
     9ae:	80 ee       	ldi	r24, 0xE0	; 224
     9b0:	98 e0       	ldi	r25, 0x08	; 8
     9b2:	9c d5       	rcall	.+2872   	; 0x14ec <ringBufferPush>
     9b4:	20 e0       	ldi	r18, 0x00	; 0
     9b6:	40 e0       	ldi	r20, 0x00	; 0
     9b8:	50 e0       	ldi	r21, 0x00	; 0
     9ba:	60 e0       	ldi	r22, 0x00	; 0
     9bc:	70 e0       	ldi	r23, 0x00	; 0
     9be:	80 91 47 09 	lds	r24, 0x0947
     9c2:	90 91 48 09 	lds	r25, 0x0948
     9c6:	8c d4       	rcall	.+2328   	; 0x12e0 <xQueueGenericSendFromISR>
     9c8:	80 ee       	ldi	r24, 0xE0	; 224
     9ca:	98 e0       	ldi	r25, 0x08	; 8
     9cc:	a5 d5       	rcall	.+2890   	; 0x1518 <ringBufferFull>
     9ce:	ff 91       	pop	r31
     9d0:	ef 91       	pop	r30
     9d2:	bf 91       	pop	r27
     9d4:	af 91       	pop	r26
     9d6:	9f 91       	pop	r25
     9d8:	8f 91       	pop	r24
     9da:	7f 91       	pop	r23
     9dc:	6f 91       	pop	r22
     9de:	5f 91       	pop	r21
     9e0:	4f 91       	pop	r20
     9e2:	3f 91       	pop	r19
     9e4:	2f 91       	pop	r18
     9e6:	0f 90       	pop	r0
     9e8:	0b be       	out	0x3b, r0	; 59
     9ea:	0f 90       	pop	r0
     9ec:	0f be       	out	0x3f, r0	; 63
     9ee:	0f 90       	pop	r0
     9f0:	1f 90       	pop	r1
     9f2:	18 95       	reti

000009f4 <__vector_37>:
     9f4:	1f 92       	push	r1
     9f6:	0f 92       	push	r0
     9f8:	0f b6       	in	r0, 0x3f	; 63
     9fa:	0f 92       	push	r0
     9fc:	11 24       	eor	r1, r1
     9fe:	0b b6       	in	r0, 0x3b	; 59
     a00:	0f 92       	push	r0
     a02:	2f 93       	push	r18
     a04:	3f 93       	push	r19
     a06:	4f 93       	push	r20
     a08:	5f 93       	push	r21
     a0a:	6f 93       	push	r22
     a0c:	7f 93       	push	r23
     a0e:	8f 93       	push	r24
     a10:	9f 93       	push	r25
     a12:	af 93       	push	r26
     a14:	bf 93       	push	r27
     a16:	ef 93       	push	r30
     a18:	ff 93       	push	r31
     a1a:	89 e4       	ldi	r24, 0x49	; 73
     a1c:	99 e0       	ldi	r25, 0x09	; 9
     a1e:	83 d5       	rcall	.+2822   	; 0x1526 <ringBufferNotEmpty>
     a20:	88 23       	and	r24, r24
     a22:	31 f0       	breq	.+12     	; 0xa30 <__vector_37+0x3c>
     a24:	89 e4       	ldi	r24, 0x49	; 73
     a26:	99 e0       	ldi	r25, 0x09	; 9
     a28:	4f d5       	rcall	.+2718   	; 0x14c8 <ringBufferPop>
     a2a:	80 93 ce 00 	sts	0x00CE, r24
     a2e:	05 c0       	rjmp	.+10     	; 0xa3a <__vector_37+0x46>
     a30:	e9 ec       	ldi	r30, 0xC9	; 201
     a32:	f0 e0       	ldi	r31, 0x00	; 0
     a34:	80 81       	ld	r24, Z
     a36:	8f 7d       	andi	r24, 0xDF	; 223
     a38:	80 83       	st	Z, r24
     a3a:	ff 91       	pop	r31
     a3c:	ef 91       	pop	r30
     a3e:	bf 91       	pop	r27
     a40:	af 91       	pop	r26
     a42:	9f 91       	pop	r25
     a44:	8f 91       	pop	r24
     a46:	7f 91       	pop	r23
     a48:	6f 91       	pop	r22
     a4a:	5f 91       	pop	r21
     a4c:	4f 91       	pop	r20
     a4e:	3f 91       	pop	r19
     a50:	2f 91       	pop	r18
     a52:	0f 90       	pop	r0
     a54:	0b be       	out	0x3b, r0	; 59
     a56:	0f 90       	pop	r0
     a58:	0f be       	out	0x3f, r0	; 63
     a5a:	0f 90       	pop	r0
     a5c:	1f 90       	pop	r1
     a5e:	18 95       	reti

00000a60 <__vector_26>:
     a60:	1f 92       	push	r1
     a62:	0f 92       	push	r0
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	0f 92       	push	r0
     a68:	11 24       	eor	r1, r1
     a6a:	0b b6       	in	r0, 0x3b	; 59
     a6c:	0f 92       	push	r0
     a6e:	2f 93       	push	r18
     a70:	3f 93       	push	r19
     a72:	4f 93       	push	r20
     a74:	5f 93       	push	r21
     a76:	6f 93       	push	r22
     a78:	7f 93       	push	r23
     a7a:	8f 93       	push	r24
     a7c:	9f 93       	push	r25
     a7e:	af 93       	push	r26
     a80:	bf 93       	push	r27
     a82:	ef 93       	push	r30
     a84:	ff 93       	push	r31
     a86:	8e e4       	ldi	r24, 0x4E	; 78
     a88:	99 e0       	ldi	r25, 0x09	; 9
     a8a:	4d d5       	rcall	.+2714   	; 0x1526 <ringBufferNotEmpty>
     a8c:	88 23       	and	r24, r24
     a8e:	31 f0       	breq	.+12     	; 0xa9c <__vector_26+0x3c>
     a90:	8e e4       	ldi	r24, 0x4E	; 78
     a92:	99 e0       	ldi	r25, 0x09	; 9
     a94:	19 d5       	rcall	.+2610   	; 0x14c8 <ringBufferPop>
     a96:	80 93 c6 00 	sts	0x00C6, r24
     a9a:	05 c0       	rjmp	.+10     	; 0xaa6 <__vector_26+0x46>
     a9c:	e1 ec       	ldi	r30, 0xC1	; 193
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
     aa0:	80 81       	ld	r24, Z
     aa2:	8f 7d       	andi	r24, 0xDF	; 223
     aa4:	80 83       	st	Z, r24
     aa6:	ff 91       	pop	r31
     aa8:	ef 91       	pop	r30
     aaa:	bf 91       	pop	r27
     aac:	af 91       	pop	r26
     aae:	9f 91       	pop	r25
     ab0:	8f 91       	pop	r24
     ab2:	7f 91       	pop	r23
     ab4:	6f 91       	pop	r22
     ab6:	5f 91       	pop	r21
     ab8:	4f 91       	pop	r20
     aba:	3f 91       	pop	r19
     abc:	2f 91       	pop	r18
     abe:	0f 90       	pop	r0
     ac0:	0b be       	out	0x3b, r0	; 59
     ac2:	0f 90       	pop	r0
     ac4:	0f be       	out	0x3f, r0	; 63
     ac6:	0f 90       	pop	r0
     ac8:	1f 90       	pop	r1
     aca:	18 95       	reti

00000acc <myUSART_USART0_Init>:
     acc:	10 92 c5 00 	sts	0x00C5, r1
     ad0:	87 e6       	ldi	r24, 0x67	; 103
     ad2:	80 93 c4 00 	sts	0x00C4, r24
     ad6:	88 eb       	ldi	r24, 0xB8	; 184
     ad8:	80 93 c1 00 	sts	0x00C1, r24
     adc:	86 e0       	ldi	r24, 0x06	; 6
     ade:	80 93 c2 00 	sts	0x00C2, r24
     ae2:	40 e2       	ldi	r20, 0x20	; 32
     ae4:	65 e0       	ldi	r22, 0x05	; 5
     ae6:	79 e0       	ldi	r23, 0x09	; 9
     ae8:	80 ee       	ldi	r24, 0xE0	; 224
     aea:	98 e0       	ldi	r25, 0x08	; 8
     aec:	e6 d4       	rcall	.+2508   	; 0x14ba <ringBufferInit>
     aee:	40 e2       	ldi	r20, 0x20	; 32
     af0:	65 ee       	ldi	r22, 0xE5	; 229
     af2:	78 e0       	ldi	r23, 0x08	; 8
     af4:	8e e4       	ldi	r24, 0x4E	; 78
     af6:	99 e0       	ldi	r25, 0x09	; 9
     af8:	e0 d4       	rcall	.+2496   	; 0x14ba <ringBufferInit>
     afa:	43 e0       	ldi	r20, 0x03	; 3
     afc:	60 e0       	ldi	r22, 0x00	; 0
     afe:	81 e0       	ldi	r24, 0x01	; 1
     b00:	0a d3       	rcall	.+1556   	; 0x1116 <xQueueGenericCreate>
     b02:	90 93 46 09 	sts	0x0946, r25
     b06:	80 93 45 09 	sts	0x0945, r24
     b0a:	08 95       	ret

00000b0c <myUSART_USART1_Init>:
     b0c:	10 92 cd 00 	sts	0x00CD, r1
     b10:	87 e6       	ldi	r24, 0x67	; 103
     b12:	80 93 cc 00 	sts	0x00CC, r24
     b16:	88 eb       	ldi	r24, 0xB8	; 184
     b18:	80 93 c9 00 	sts	0x00C9, r24
     b1c:	86 e0       	ldi	r24, 0x06	; 6
     b1e:	80 93 ca 00 	sts	0x00CA, r24
     b22:	40 e2       	ldi	r20, 0x20	; 32
     b24:	60 ec       	ldi	r22, 0xC0	; 192
     b26:	78 e0       	ldi	r23, 0x08	; 8
     b28:	83 e5       	ldi	r24, 0x53	; 83
     b2a:	99 e0       	ldi	r25, 0x09	; 9
     b2c:	c6 d4       	rcall	.+2444   	; 0x14ba <ringBufferInit>
     b2e:	40 e2       	ldi	r20, 0x20	; 32
     b30:	65 e2       	ldi	r22, 0x25	; 37
     b32:	79 e0       	ldi	r23, 0x09	; 9
     b34:	89 e4       	ldi	r24, 0x49	; 73
     b36:	99 e0       	ldi	r25, 0x09	; 9
     b38:	c0 d4       	rcall	.+2432   	; 0x14ba <ringBufferInit>
     b3a:	43 e0       	ldi	r20, 0x03	; 3
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	81 e0       	ldi	r24, 0x01	; 1
     b40:	ea d2       	rcall	.+1492   	; 0x1116 <xQueueGenericCreate>
     b42:	90 93 48 09 	sts	0x0948, r25
     b46:	80 93 47 09 	sts	0x0947, r24
     b4a:	08 95       	ret

00000b4c <myUSART_transmitUSART0_c>:
     b4c:	cf 93       	push	r28
     b4e:	c8 2f       	mov	r28, r24
     b50:	8e e4       	ldi	r24, 0x4E	; 78
     b52:	99 e0       	ldi	r25, 0x09	; 9
     b54:	e1 d4       	rcall	.+2498   	; 0x1518 <ringBufferFull>
     b56:	81 11       	cpse	r24, r1
     b58:	fb cf       	rjmp	.-10     	; 0xb50 <myUSART_transmitUSART0_c+0x4>
     b5a:	6c 2f       	mov	r22, r28
     b5c:	8e e4       	ldi	r24, 0x4E	; 78
     b5e:	99 e0       	ldi	r25, 0x09	; 9
     b60:	c5 d4       	rcall	.+2442   	; 0x14ec <ringBufferPush>
     b62:	e1 ec       	ldi	r30, 0xC1	; 193
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	80 81       	ld	r24, Z
     b68:	80 62       	ori	r24, 0x20	; 32
     b6a:	80 83       	st	Z, r24
     b6c:	e0 ec       	ldi	r30, 0xC0	; 192
     b6e:	f0 e0       	ldi	r31, 0x00	; 0
     b70:	80 81       	ld	r24, Z
     b72:	80 64       	ori	r24, 0x40	; 64
     b74:	80 83       	st	Z, r24
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <myUSART_transmitUSART1_c>:
     b7a:	cf 93       	push	r28
     b7c:	c8 2f       	mov	r28, r24
     b7e:	89 e4       	ldi	r24, 0x49	; 73
     b80:	99 e0       	ldi	r25, 0x09	; 9
     b82:	ca d4       	rcall	.+2452   	; 0x1518 <ringBufferFull>
     b84:	81 11       	cpse	r24, r1
     b86:	fb cf       	rjmp	.-10     	; 0xb7e <myUSART_transmitUSART1_c+0x4>
     b88:	6c 2f       	mov	r22, r28
     b8a:	89 e4       	ldi	r24, 0x49	; 73
     b8c:	99 e0       	ldi	r25, 0x09	; 9
     b8e:	ae d4       	rcall	.+2396   	; 0x14ec <ringBufferPush>
     b90:	e9 ec       	ldi	r30, 0xC9	; 201
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	80 62       	ori	r24, 0x20	; 32
     b98:	80 83       	st	Z, r24
     b9a:	e8 ec       	ldi	r30, 0xC8	; 200
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	80 81       	ld	r24, Z
     ba0:	80 64       	ori	r24, 0x40	; 64
     ba2:	80 83       	st	Z, r24
     ba4:	cf 91       	pop	r28
     ba6:	08 95       	ret

00000ba8 <myUSART_transmitUSART0>:
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	ec 01       	movw	r28, r24
     bae:	88 81       	ld	r24, Y
     bb0:	88 23       	and	r24, r24
     bb2:	29 f0       	breq	.+10     	; 0xbbe <myUSART_transmitUSART0+0x16>
     bb4:	21 96       	adiw	r28, 0x01	; 1
     bb6:	ca df       	rcall	.-108    	; 0xb4c <myUSART_transmitUSART0_c>
     bb8:	89 91       	ld	r24, Y+
     bba:	81 11       	cpse	r24, r1
     bbc:	fc cf       	rjmp	.-8      	; 0xbb6 <myUSART_transmitUSART0+0xe>
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <myUSART_receiveUSART1>:
     bc4:	cf 93       	push	r28
     bc6:	20 e0       	ldi	r18, 0x00	; 0
     bc8:	4f ef       	ldi	r20, 0xFF	; 255
     bca:	5f ef       	ldi	r21, 0xFF	; 255
     bcc:	60 e0       	ldi	r22, 0x00	; 0
     bce:	70 e0       	ldi	r23, 0x00	; 0
     bd0:	80 91 45 09 	lds	r24, 0x0945
     bd4:	90 91 46 09 	lds	r25, 0x0946
     bd8:	bd d3       	rcall	.+1914   	; 0x1354 <xQueueGenericReceive>
     bda:	83 e5       	ldi	r24, 0x53	; 83
     bdc:	99 e0       	ldi	r25, 0x09	; 9
     bde:	74 d4       	rcall	.+2280   	; 0x14c8 <ringBufferPop>
     be0:	c8 2f       	mov	r28, r24
     be2:	83 e5       	ldi	r24, 0x53	; 83
     be4:	99 e0       	ldi	r25, 0x09	; 9
     be6:	9f d4       	rcall	.+2366   	; 0x1526 <ringBufferNotEmpty>
     be8:	88 23       	and	r24, r24
     bea:	51 f0       	breq	.+20     	; 0xc00 <myUSART_receiveUSART1+0x3c>
     bec:	20 e0       	ldi	r18, 0x00	; 0
     bee:	40 e0       	ldi	r20, 0x00	; 0
     bf0:	50 e0       	ldi	r21, 0x00	; 0
     bf2:	60 e0       	ldi	r22, 0x00	; 0
     bf4:	70 e0       	ldi	r23, 0x00	; 0
     bf6:	80 91 45 09 	lds	r24, 0x0945
     bfa:	90 91 46 09 	lds	r25, 0x0946
     bfe:	b5 d2       	rcall	.+1386   	; 0x116a <xQueueGenericSend>
     c00:	8c 2f       	mov	r24, r28
     c02:	cf 91       	pop	r28
     c04:	08 95       	ret

00000c06 <myUSART_startHandShake>:

// -1 if fail, 0 success
char myUSART_startHandShake()
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	b8 df       	rcall	.-144    	; 0xb7a <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
     c0a:	dc df       	rcall	.-72     	; 0xbc4 <myUSART_receiveUSART1>
     c0c:	85 35       	cpi	r24, 0x55	; 85
     c0e:	21 f4       	brne	.+8      	; 0xc18 <myUSART_startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	b3 df       	rcall	.-154    	; 0xb7a <myUSART_transmitUSART1_c>
	
	return 0;
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	08 95       	ret
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
	{
		return -1; //error handling
     c18:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     c1a:	08 95       	ret

00000c1c <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c1c:	d3 df       	rcall	.-90     	; 0xbc4 <myUSART_receiveUSART1>
     c1e:	81 11       	cpse	r24, r1
     c20:	0a c0       	rjmp	.+20     	; 0xc36 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     c22:	85 e5       	ldi	r24, 0x55	; 85
     c24:	aa df       	rcall	.-172    	; 0xb7a <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c26:	ce df       	rcall	.-100    	; 0xbc4 <myUSART_receiveUSART1>
     c28:	91 e0       	ldi	r25, 0x01	; 1
     c2a:	81 11       	cpse	r24, r1
     c2c:	01 c0       	rjmp	.+2      	; 0xc30 <myUSART_waitForHandshake+0x14>
     c2e:	90 e0       	ldi	r25, 0x00	; 0
     c30:	89 2f       	mov	r24, r25
     c32:	81 95       	neg	r24
     c34:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     c36:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     c38:	08 95       	ret

00000c3a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c3a:	31 e1       	ldi	r19, 0x11	; 17
     c3c:	fc 01       	movw	r30, r24
     c3e:	30 83       	st	Z, r19
     c40:	31 97       	sbiw	r30, 0x01	; 1
     c42:	22 e2       	ldi	r18, 0x22	; 34
     c44:	20 83       	st	Z, r18
     c46:	31 97       	sbiw	r30, 0x01	; 1
     c48:	a3 e3       	ldi	r26, 0x33	; 51
     c4a:	a0 83       	st	Z, r26
     c4c:	31 97       	sbiw	r30, 0x01	; 1
     c4e:	60 83       	st	Z, r22
     c50:	31 97       	sbiw	r30, 0x01	; 1
     c52:	70 83       	st	Z, r23
     c54:	31 97       	sbiw	r30, 0x01	; 1
     c56:	10 82       	st	Z, r1
     c58:	31 97       	sbiw	r30, 0x01	; 1
     c5a:	10 82       	st	Z, r1
     c5c:	31 97       	sbiw	r30, 0x01	; 1
     c5e:	60 e8       	ldi	r22, 0x80	; 128
     c60:	60 83       	st	Z, r22
     c62:	31 97       	sbiw	r30, 0x01	; 1
     c64:	10 82       	st	Z, r1
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	10 82       	st	Z, r1
     c6a:	31 97       	sbiw	r30, 0x01	; 1
     c6c:	10 82       	st	Z, r1
     c6e:	31 97       	sbiw	r30, 0x01	; 1
     c70:	62 e0       	ldi	r22, 0x02	; 2
     c72:	60 83       	st	Z, r22
     c74:	31 97       	sbiw	r30, 0x01	; 1
     c76:	63 e0       	ldi	r22, 0x03	; 3
     c78:	60 83       	st	Z, r22
     c7a:	31 97       	sbiw	r30, 0x01	; 1
     c7c:	64 e0       	ldi	r22, 0x04	; 4
     c7e:	60 83       	st	Z, r22
     c80:	31 97       	sbiw	r30, 0x01	; 1
     c82:	65 e0       	ldi	r22, 0x05	; 5
     c84:	60 83       	st	Z, r22
     c86:	31 97       	sbiw	r30, 0x01	; 1
     c88:	66 e0       	ldi	r22, 0x06	; 6
     c8a:	60 83       	st	Z, r22
     c8c:	31 97       	sbiw	r30, 0x01	; 1
     c8e:	67 e0       	ldi	r22, 0x07	; 7
     c90:	60 83       	st	Z, r22
     c92:	31 97       	sbiw	r30, 0x01	; 1
     c94:	68 e0       	ldi	r22, 0x08	; 8
     c96:	60 83       	st	Z, r22
     c98:	31 97       	sbiw	r30, 0x01	; 1
     c9a:	69 e0       	ldi	r22, 0x09	; 9
     c9c:	60 83       	st	Z, r22
     c9e:	31 97       	sbiw	r30, 0x01	; 1
     ca0:	60 e1       	ldi	r22, 0x10	; 16
     ca2:	60 83       	st	Z, r22
     ca4:	31 97       	sbiw	r30, 0x01	; 1
     ca6:	30 83       	st	Z, r19
     ca8:	31 97       	sbiw	r30, 0x01	; 1
     caa:	32 e1       	ldi	r19, 0x12	; 18
     cac:	30 83       	st	Z, r19
     cae:	31 97       	sbiw	r30, 0x01	; 1
     cb0:	33 e1       	ldi	r19, 0x13	; 19
     cb2:	30 83       	st	Z, r19
     cb4:	31 97       	sbiw	r30, 0x01	; 1
     cb6:	34 e1       	ldi	r19, 0x14	; 20
     cb8:	30 83       	st	Z, r19
     cba:	31 97       	sbiw	r30, 0x01	; 1
     cbc:	35 e1       	ldi	r19, 0x15	; 21
     cbe:	30 83       	st	Z, r19
     cc0:	31 97       	sbiw	r30, 0x01	; 1
     cc2:	36 e1       	ldi	r19, 0x16	; 22
     cc4:	30 83       	st	Z, r19
     cc6:	31 97       	sbiw	r30, 0x01	; 1
     cc8:	37 e1       	ldi	r19, 0x17	; 23
     cca:	30 83       	st	Z, r19
     ccc:	31 97       	sbiw	r30, 0x01	; 1
     cce:	38 e1       	ldi	r19, 0x18	; 24
     cd0:	30 83       	st	Z, r19
     cd2:	31 97       	sbiw	r30, 0x01	; 1
     cd4:	39 e1       	ldi	r19, 0x19	; 25
     cd6:	30 83       	st	Z, r19
     cd8:	31 97       	sbiw	r30, 0x01	; 1
     cda:	30 e2       	ldi	r19, 0x20	; 32
     cdc:	30 83       	st	Z, r19
     cde:	31 97       	sbiw	r30, 0x01	; 1
     ce0:	31 e2       	ldi	r19, 0x21	; 33
     ce2:	30 83       	st	Z, r19
     ce4:	31 97       	sbiw	r30, 0x01	; 1
     ce6:	20 83       	st	Z, r18
     ce8:	31 97       	sbiw	r30, 0x01	; 1
     cea:	23 e2       	ldi	r18, 0x23	; 35
     cec:	20 83       	st	Z, r18
     cee:	31 97       	sbiw	r30, 0x01	; 1
     cf0:	40 83       	st	Z, r20
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	50 83       	st	Z, r21
     cf6:	31 97       	sbiw	r30, 0x01	; 1
     cf8:	26 e2       	ldi	r18, 0x26	; 38
     cfa:	20 83       	st	Z, r18
     cfc:	31 97       	sbiw	r30, 0x01	; 1
     cfe:	27 e2       	ldi	r18, 0x27	; 39
     d00:	20 83       	st	Z, r18
     d02:	31 97       	sbiw	r30, 0x01	; 1
     d04:	28 e2       	ldi	r18, 0x28	; 40
     d06:	20 83       	st	Z, r18
     d08:	31 97       	sbiw	r30, 0x01	; 1
     d0a:	29 e2       	ldi	r18, 0x29	; 41
     d0c:	20 83       	st	Z, r18
     d0e:	31 97       	sbiw	r30, 0x01	; 1
     d10:	20 e3       	ldi	r18, 0x30	; 48
     d12:	20 83       	st	Z, r18
     d14:	31 97       	sbiw	r30, 0x01	; 1
     d16:	21 e3       	ldi	r18, 0x31	; 49
     d18:	20 83       	st	Z, r18
     d1a:	89 97       	sbiw	r24, 0x29	; 41
     d1c:	08 95       	ret

00000d1e <xPortStartScheduler>:
     d1e:	82 e0       	ldi	r24, 0x02	; 2
     d20:	84 bd       	out	0x24, r24	; 36
     d22:	16 bc       	out	0x26, r1	; 38
     d24:	80 e3       	ldi	r24, 0x30	; 48
     d26:	87 bd       	out	0x27, r24	; 39
     d28:	ee e6       	ldi	r30, 0x6E	; 110
     d2a:	f0 e0       	ldi	r31, 0x00	; 0
     d2c:	80 81       	ld	r24, Z
     d2e:	82 60       	ori	r24, 0x02	; 2
     d30:	80 83       	st	Z, r24
     d32:	83 e0       	ldi	r24, 0x03	; 3
     d34:	85 bd       	out	0x25, r24	; 37
     d36:	a0 91 a7 08 	lds	r26, 0x08A7
     d3a:	b0 91 a8 08 	lds	r27, 0x08A8
     d3e:	cd 91       	ld	r28, X+
     d40:	cd bf       	out	0x3d, r28	; 61
     d42:	dd 91       	ld	r29, X+
     d44:	de bf       	out	0x3e, r29	; 62
     d46:	ff 91       	pop	r31
     d48:	ef 91       	pop	r30
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	bf 91       	pop	r27
     d50:	af 91       	pop	r26
     d52:	9f 91       	pop	r25
     d54:	8f 91       	pop	r24
     d56:	7f 91       	pop	r23
     d58:	6f 91       	pop	r22
     d5a:	5f 91       	pop	r21
     d5c:	4f 91       	pop	r20
     d5e:	3f 91       	pop	r19
     d60:	2f 91       	pop	r18
     d62:	1f 91       	pop	r17
     d64:	0f 91       	pop	r16
     d66:	ff 90       	pop	r15
     d68:	ef 90       	pop	r14
     d6a:	df 90       	pop	r13
     d6c:	cf 90       	pop	r12
     d6e:	bf 90       	pop	r11
     d70:	af 90       	pop	r10
     d72:	9f 90       	pop	r9
     d74:	8f 90       	pop	r8
     d76:	7f 90       	pop	r7
     d78:	6f 90       	pop	r6
     d7a:	5f 90       	pop	r5
     d7c:	4f 90       	pop	r4
     d7e:	3f 90       	pop	r3
     d80:	2f 90       	pop	r2
     d82:	1f 90       	pop	r1
     d84:	0f 90       	pop	r0
     d86:	0c be       	out	0x3c, r0	; 60
     d88:	0f 90       	pop	r0
     d8a:	0b be       	out	0x3b, r0	; 59
     d8c:	0f 90       	pop	r0
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	0f 90       	pop	r0
     d92:	08 95       	ret
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	08 95       	ret

00000d98 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d98:	0f 92       	push	r0
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	0f 92       	push	r0
     da0:	0b b6       	in	r0, 0x3b	; 59
     da2:	0f 92       	push	r0
     da4:	0c b6       	in	r0, 0x3c	; 60
     da6:	0f 92       	push	r0
     da8:	1f 92       	push	r1
     daa:	11 24       	eor	r1, r1
     dac:	2f 92       	push	r2
     dae:	3f 92       	push	r3
     db0:	4f 92       	push	r4
     db2:	5f 92       	push	r5
     db4:	6f 92       	push	r6
     db6:	7f 92       	push	r7
     db8:	8f 92       	push	r8
     dba:	9f 92       	push	r9
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	cf 92       	push	r12
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	2f 93       	push	r18
     dce:	3f 93       	push	r19
     dd0:	4f 93       	push	r20
     dd2:	5f 93       	push	r21
     dd4:	6f 93       	push	r22
     dd6:	7f 93       	push	r23
     dd8:	8f 93       	push	r24
     dda:	9f 93       	push	r25
     ddc:	af 93       	push	r26
     dde:	bf 93       	push	r27
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	ef 93       	push	r30
     de6:	ff 93       	push	r31
     de8:	a0 91 a7 08 	lds	r26, 0x08A7
     dec:	b0 91 a8 08 	lds	r27, 0x08A8
     df0:	0d b6       	in	r0, 0x3d	; 61
     df2:	0d 92       	st	X+, r0
     df4:	0e b6       	in	r0, 0x3e	; 62
     df6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     df8:	48 d7       	rcall	.+3728   	; 0x1c8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     dfa:	a0 91 a7 08 	lds	r26, 0x08A7
     dfe:	b0 91 a8 08 	lds	r27, 0x08A8
     e02:	cd 91       	ld	r28, X+
     e04:	cd bf       	out	0x3d, r28	; 61
     e06:	dd 91       	ld	r29, X+
     e08:	de bf       	out	0x3e, r29	; 62
     e0a:	ff 91       	pop	r31
     e0c:	ef 91       	pop	r30
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	bf 91       	pop	r27
     e14:	af 91       	pop	r26
     e16:	9f 91       	pop	r25
     e18:	8f 91       	pop	r24
     e1a:	7f 91       	pop	r23
     e1c:	6f 91       	pop	r22
     e1e:	5f 91       	pop	r21
     e20:	4f 91       	pop	r20
     e22:	3f 91       	pop	r19
     e24:	2f 91       	pop	r18
     e26:	1f 91       	pop	r17
     e28:	0f 91       	pop	r16
     e2a:	ff 90       	pop	r15
     e2c:	ef 90       	pop	r14
     e2e:	df 90       	pop	r13
     e30:	cf 90       	pop	r12
     e32:	bf 90       	pop	r11
     e34:	af 90       	pop	r10
     e36:	9f 90       	pop	r9
     e38:	8f 90       	pop	r8
     e3a:	7f 90       	pop	r7
     e3c:	6f 90       	pop	r6
     e3e:	5f 90       	pop	r5
     e40:	4f 90       	pop	r4
     e42:	3f 90       	pop	r3
     e44:	2f 90       	pop	r2
     e46:	1f 90       	pop	r1
     e48:	0f 90       	pop	r0
     e4a:	0c be       	out	0x3c, r0	; 60
     e4c:	0f 90       	pop	r0
     e4e:	0b be       	out	0x3b, r0	; 59
     e50:	0f 90       	pop	r0
     e52:	0f be       	out	0x3f, r0	; 63
     e54:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e56:	08 95       	ret

00000e58 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e58:	0f 92       	push	r0
     e5a:	0f b6       	in	r0, 0x3f	; 63
     e5c:	f8 94       	cli
     e5e:	0f 92       	push	r0
     e60:	0b b6       	in	r0, 0x3b	; 59
     e62:	0f 92       	push	r0
     e64:	0c b6       	in	r0, 0x3c	; 60
     e66:	0f 92       	push	r0
     e68:	1f 92       	push	r1
     e6a:	11 24       	eor	r1, r1
     e6c:	2f 92       	push	r2
     e6e:	3f 92       	push	r3
     e70:	4f 92       	push	r4
     e72:	5f 92       	push	r5
     e74:	6f 92       	push	r6
     e76:	7f 92       	push	r7
     e78:	8f 92       	push	r8
     e7a:	9f 92       	push	r9
     e7c:	af 92       	push	r10
     e7e:	bf 92       	push	r11
     e80:	cf 92       	push	r12
     e82:	df 92       	push	r13
     e84:	ef 92       	push	r14
     e86:	ff 92       	push	r15
     e88:	0f 93       	push	r16
     e8a:	1f 93       	push	r17
     e8c:	2f 93       	push	r18
     e8e:	3f 93       	push	r19
     e90:	4f 93       	push	r20
     e92:	5f 93       	push	r21
     e94:	6f 93       	push	r22
     e96:	7f 93       	push	r23
     e98:	8f 93       	push	r24
     e9a:	9f 93       	push	r25
     e9c:	af 93       	push	r26
     e9e:	bf 93       	push	r27
     ea0:	cf 93       	push	r28
     ea2:	df 93       	push	r29
     ea4:	ef 93       	push	r30
     ea6:	ff 93       	push	r31
     ea8:	a0 91 a7 08 	lds	r26, 0x08A7
     eac:	b0 91 a8 08 	lds	r27, 0x08A8
     eb0:	0d b6       	in	r0, 0x3d	; 61
     eb2:	0d 92       	st	X+, r0
     eb4:	0e b6       	in	r0, 0x3e	; 62
     eb6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     eb8:	32 d5       	rcall	.+2660   	; 0x191e <xTaskIncrementTick>
     eba:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ebc:	e6 d6       	rcall	.+3532   	; 0x1c8a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     ebe:	a0 91 a7 08 	lds	r26, 0x08A7
     ec2:	b0 91 a8 08 	lds	r27, 0x08A8
     ec6:	cd 91       	ld	r28, X+
     ec8:	cd bf       	out	0x3d, r28	; 61
     eca:	dd 91       	ld	r29, X+
     ecc:	de bf       	out	0x3e, r29	; 62
     ece:	ff 91       	pop	r31
     ed0:	ef 91       	pop	r30
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	bf 91       	pop	r27
     ed8:	af 91       	pop	r26
     eda:	9f 91       	pop	r25
     edc:	8f 91       	pop	r24
     ede:	7f 91       	pop	r23
     ee0:	6f 91       	pop	r22
     ee2:	5f 91       	pop	r21
     ee4:	4f 91       	pop	r20
     ee6:	3f 91       	pop	r19
     ee8:	2f 91       	pop	r18
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	ff 90       	pop	r15
     ef0:	ef 90       	pop	r14
     ef2:	df 90       	pop	r13
     ef4:	cf 90       	pop	r12
     ef6:	bf 90       	pop	r11
     ef8:	af 90       	pop	r10
     efa:	9f 90       	pop	r9
     efc:	8f 90       	pop	r8
     efe:	7f 90       	pop	r7
     f00:	6f 90       	pop	r6
     f02:	5f 90       	pop	r5
     f04:	4f 90       	pop	r4
     f06:	3f 90       	pop	r3
     f08:	2f 90       	pop	r2
     f0a:	1f 90       	pop	r1
     f0c:	0f 90       	pop	r0
     f0e:	0c be       	out	0x3c, r0	; 60
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f1a:	08 95       	ret

00000f1c <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     f1c:	9d df       	rcall	.-198    	; 0xe58 <vPortYieldFromTick>
		 asm volatile ("reti");
     f1e:	18 95       	reti

00000f20 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f20:	1f 93       	push	r17
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
     f26:	ec 01       	movw	r28, r24
     f28:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f2a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f2c:	81 11       	cpse	r24, r1
     f2e:	0c c0       	rjmp	.+24     	; 0xf48 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     f30:	88 81       	ld	r24, Y
     f32:	99 81       	ldd	r25, Y+1	; 0x01
     f34:	89 2b       	or	r24, r25
     f36:	09 f0       	breq	.+2      	; 0xf3a <prvCopyDataToQueue+0x1a>
     f38:	47 c0       	rjmp	.+142    	; 0xfc8 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     f3a:	8a 81       	ldd	r24, Y+2	; 0x02
     f3c:	9b 81       	ldd	r25, Y+3	; 0x03
     f3e:	0e 94 08 10 	call	0x2010	; 0x2010 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     f42:	1b 82       	std	Y+3, r1	; 0x03
     f44:	1a 82       	std	Y+2, r1	; 0x02
     f46:	47 c0       	rjmp	.+142    	; 0xfd6 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f48:	41 11       	cpse	r20, r1
     f4a:	18 c0       	rjmp	.+48     	; 0xf7c <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f4c:	48 2f       	mov	r20, r24
     f4e:	50 e0       	ldi	r21, 0x00	; 0
     f50:	8c 81       	ldd	r24, Y+4	; 0x04
     f52:	9d 81       	ldd	r25, Y+5	; 0x05
     f54:	0e 94 80 10 	call	0x2100	; 0x2100 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     f58:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f5a:	8c 81       	ldd	r24, Y+4	; 0x04
     f5c:	9d 81       	ldd	r25, Y+5	; 0x05
     f5e:	82 0f       	add	r24, r18
     f60:	91 1d       	adc	r25, r1
     f62:	9d 83       	std	Y+5, r25	; 0x05
     f64:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f66:	2a 81       	ldd	r18, Y+2	; 0x02
     f68:	3b 81       	ldd	r19, Y+3	; 0x03
     f6a:	82 17       	cp	r24, r18
     f6c:	93 07       	cpc	r25, r19
     f6e:	70 f1       	brcs	.+92     	; 0xfcc <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     f70:	88 81       	ld	r24, Y
     f72:	99 81       	ldd	r25, Y+1	; 0x01
     f74:	9d 83       	std	Y+5, r25	; 0x05
     f76:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     f78:	80 e0       	ldi	r24, 0x00	; 0
     f7a:	2d c0       	rjmp	.+90     	; 0xfd6 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f7c:	48 2f       	mov	r20, r24
     f7e:	50 e0       	ldi	r21, 0x00	; 0
     f80:	8e 81       	ldd	r24, Y+6	; 0x06
     f82:	9f 81       	ldd	r25, Y+7	; 0x07
     f84:	0e 94 80 10 	call	0x2100	; 0x2100 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     f88:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	31 95       	neg	r19
     f8e:	21 95       	neg	r18
     f90:	31 09       	sbc	r19, r1
     f92:	8e 81       	ldd	r24, Y+6	; 0x06
     f94:	9f 81       	ldd	r25, Y+7	; 0x07
     f96:	82 0f       	add	r24, r18
     f98:	93 1f       	adc	r25, r19
     f9a:	9f 83       	std	Y+7, r25	; 0x07
     f9c:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     f9e:	68 81       	ld	r22, Y
     fa0:	79 81       	ldd	r23, Y+1	; 0x01
     fa2:	86 17       	cp	r24, r22
     fa4:	97 07       	cpc	r25, r23
     fa6:	30 f4       	brcc	.+12     	; 0xfb4 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     fa8:	8a 81       	ldd	r24, Y+2	; 0x02
     faa:	9b 81       	ldd	r25, Y+3	; 0x03
     fac:	28 0f       	add	r18, r24
     fae:	39 1f       	adc	r19, r25
     fb0:	3f 83       	std	Y+7, r19	; 0x07
     fb2:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     fb4:	12 30       	cpi	r17, 0x02	; 2
     fb6:	61 f4       	brne	.+24     	; 0xfd0 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     fb8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fba:	88 23       	and	r24, r24
     fbc:	59 f0       	breq	.+22     	; 0xfd4 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     fbe:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fc0:	81 50       	subi	r24, 0x01	; 1
     fc2:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     fc4:	80 e0       	ldi	r24, 0x00	; 0
     fc6:	07 c0       	rjmp	.+14     	; 0xfd6 <prvCopyDataToQueue+0xb6>
     fc8:	80 e0       	ldi	r24, 0x00	; 0
     fca:	05 c0       	rjmp	.+10     	; 0xfd6 <prvCopyDataToQueue+0xb6>
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	03 c0       	rjmp	.+6      	; 0xfd6 <prvCopyDataToQueue+0xb6>
     fd0:	80 e0       	ldi	r24, 0x00	; 0
     fd2:	01 c0       	rjmp	.+2      	; 0xfd6 <prvCopyDataToQueue+0xb6>
     fd4:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     fd6:	9a 8d       	ldd	r25, Y+26	; 0x1a
     fd8:	9f 5f       	subi	r25, 0xFF	; 255
     fda:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	08 95       	ret

00000fe4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     fe4:	fc 01       	movw	r30, r24
     fe6:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     fe8:	44 8d       	ldd	r20, Z+28	; 0x1c
     fea:	44 23       	and	r20, r20
     fec:	a1 f0       	breq	.+40     	; 0x1016 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     fee:	50 e0       	ldi	r21, 0x00	; 0
     ff0:	26 81       	ldd	r18, Z+6	; 0x06
     ff2:	37 81       	ldd	r19, Z+7	; 0x07
     ff4:	24 0f       	add	r18, r20
     ff6:	35 1f       	adc	r19, r21
     ff8:	37 83       	std	Z+7, r19	; 0x07
     ffa:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     ffc:	62 81       	ldd	r22, Z+2	; 0x02
     ffe:	73 81       	ldd	r23, Z+3	; 0x03
    1000:	26 17       	cp	r18, r22
    1002:	37 07       	cpc	r19, r23
    1004:	20 f0       	brcs	.+8      	; 0x100e <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1006:	20 81       	ld	r18, Z
    1008:	31 81       	ldd	r19, Z+1	; 0x01
    100a:	37 83       	std	Z+7, r19	; 0x07
    100c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    100e:	66 81       	ldd	r22, Z+6	; 0x06
    1010:	77 81       	ldd	r23, Z+7	; 0x07
    1012:	0c 94 80 10 	jmp	0x2100	; 0x2100 <memcpy>
    1016:	08 95       	ret

00001018 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1022:	0f b6       	in	r0, 0x3f	; 63
    1024:	f8 94       	cli
    1026:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1028:	8e 8d       	ldd	r24, Y+30	; 0x1e
    102a:	18 16       	cp	r1, r24
    102c:	a4 f4       	brge	.+40     	; 0x1056 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    102e:	89 89       	ldd	r24, Y+17	; 0x11
    1030:	88 23       	and	r24, r24
    1032:	89 f0       	breq	.+34     	; 0x1056 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1034:	8e 01       	movw	r16, r28
    1036:	0f 5e       	subi	r16, 0xEF	; 239
    1038:	1f 4f       	sbci	r17, 0xFF	; 255
    103a:	03 c0       	rjmp	.+6      	; 0x1042 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    103c:	89 89       	ldd	r24, Y+17	; 0x11
    103e:	88 23       	and	r24, r24
    1040:	51 f0       	breq	.+20     	; 0x1056 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1042:	c8 01       	movw	r24, r16
    1044:	f8 d6       	rcall	.+3568   	; 0x1e36 <xTaskRemoveFromEventList>
    1046:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1048:	81 d7       	rcall	.+3842   	; 0x1f4c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    104a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    104c:	81 50       	subi	r24, 0x01	; 1
    104e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1050:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1052:	18 16       	cp	r1, r24
    1054:	9c f3       	brlt	.-26     	; 0x103c <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    105e:	0f b6       	in	r0, 0x3f	; 63
    1060:	f8 94       	cli
    1062:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1064:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1066:	18 16       	cp	r1, r24
    1068:	a4 f4       	brge	.+40     	; 0x1092 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    106a:	88 85       	ldd	r24, Y+8	; 0x08
    106c:	88 23       	and	r24, r24
    106e:	89 f0       	breq	.+34     	; 0x1092 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1070:	8e 01       	movw	r16, r28
    1072:	08 5f       	subi	r16, 0xF8	; 248
    1074:	1f 4f       	sbci	r17, 0xFF	; 255
    1076:	03 c0       	rjmp	.+6      	; 0x107e <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1078:	88 85       	ldd	r24, Y+8	; 0x08
    107a:	88 23       	and	r24, r24
    107c:	51 f0       	breq	.+20     	; 0x1092 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    107e:	c8 01       	movw	r24, r16
    1080:	da d6       	rcall	.+3508   	; 0x1e36 <xTaskRemoveFromEventList>
    1082:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1084:	63 d7       	rcall	.+3782   	; 0x1f4c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1086:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1088:	81 50       	subi	r24, 0x01	; 1
    108a:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    108c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    108e:	18 16       	cp	r1, r24
    1090:	9c f3       	brlt	.-26     	; 0x1078 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1096:	0f 90       	pop	r0
    1098:	0f be       	out	0x3f, r0	; 63
}
    109a:	df 91       	pop	r29
    109c:	cf 91       	pop	r28
    109e:	1f 91       	pop	r17
    10a0:	0f 91       	pop	r16
    10a2:	08 95       	ret

000010a4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    10a4:	cf 93       	push	r28
    10a6:	df 93       	push	r29
    10a8:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	f8 94       	cli
    10ae:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    10b0:	88 81       	ld	r24, Y
    10b2:	99 81       	ldd	r25, Y+1	; 0x01
    10b4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10b6:	30 e0       	ldi	r19, 0x00	; 0
    10b8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    10ba:	72 9f       	mul	r23, r18
    10bc:	a0 01       	movw	r20, r0
    10be:	73 9f       	mul	r23, r19
    10c0:	50 0d       	add	r21, r0
    10c2:	11 24       	eor	r1, r1
    10c4:	fc 01       	movw	r30, r24
    10c6:	e4 0f       	add	r30, r20
    10c8:	f5 1f       	adc	r31, r21
    10ca:	fb 83       	std	Y+3, r31	; 0x03
    10cc:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    10ce:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    10d0:	9d 83       	std	Y+5, r25	; 0x05
    10d2:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    10d4:	42 1b       	sub	r20, r18
    10d6:	53 0b       	sbc	r21, r19
    10d8:	84 0f       	add	r24, r20
    10da:	95 1f       	adc	r25, r21
    10dc:	9f 83       	std	Y+7, r25	; 0x07
    10de:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    10e0:	8f ef       	ldi	r24, 0xFF	; 255
    10e2:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    10e4:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    10e6:	61 11       	cpse	r22, r1
    10e8:	0a c0       	rjmp	.+20     	; 0x10fe <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ea:	88 85       	ldd	r24, Y+8	; 0x08
    10ec:	88 23       	and	r24, r24
    10ee:	69 f0       	breq	.+26     	; 0x110a <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    10f0:	ce 01       	movw	r24, r28
    10f2:	08 96       	adiw	r24, 0x08	; 8
    10f4:	a0 d6       	rcall	.+3392   	; 0x1e36 <xTaskRemoveFromEventList>
    10f6:	81 30       	cpi	r24, 0x01	; 1
    10f8:	41 f4       	brne	.+16     	; 0x110a <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    10fa:	4e de       	rcall	.-868    	; 0xd98 <vPortYield>
    10fc:	06 c0       	rjmp	.+12     	; 0x110a <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    10fe:	ce 01       	movw	r24, r28
    1100:	08 96       	adiw	r24, 0x08	; 8
    1102:	59 d9       	rcall	.-3406   	; 0x3b6 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1104:	ce 01       	movw	r24, r28
    1106:	41 96       	adiw	r24, 0x11	; 17
    1108:	56 d9       	rcall	.-3412   	; 0x3b6 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    110a:	0f 90       	pop	r0
    110c:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	08 95       	ret

00001116 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1116:	0f 93       	push	r16
    1118:	1f 93       	push	r17
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	18 2f       	mov	r17, r24
    1120:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1122:	88 23       	and	r24, r24
    1124:	d1 f0       	breq	.+52     	; 0x115a <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1126:	8f e1       	ldi	r24, 0x1F	; 31
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	0f d9       	rcall	.-3554   	; 0x34a <pvPortMalloc>
    112c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    112e:	00 97       	sbiw	r24, 0x00	; 0
    1130:	b1 f0       	breq	.+44     	; 0x115e <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1132:	10 9f       	mul	r17, r16
    1134:	c0 01       	movw	r24, r0
    1136:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1138:	01 96       	adiw	r24, 0x01	; 1
    113a:	07 d9       	rcall	.-3570   	; 0x34a <pvPortMalloc>
    113c:	99 83       	std	Y+1, r25	; 0x01
    113e:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1140:	89 2b       	or	r24, r25
    1142:	31 f0       	breq	.+12     	; 0x1150 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1144:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1146:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1148:	61 e0       	ldi	r22, 0x01	; 1
    114a:	ce 01       	movw	r24, r28
    114c:	ab df       	rcall	.-170    	; 0x10a4 <xQueueGenericReset>
    114e:	07 c0       	rjmp	.+14     	; 0x115e <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1150:	ce 01       	movw	r24, r28
    1152:	30 d9       	rcall	.-3488   	; 0x3b4 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1154:	c0 e0       	ldi	r28, 0x00	; 0
    1156:	d0 e0       	ldi	r29, 0x00	; 0
    1158:	02 c0       	rjmp	.+4      	; 0x115e <xQueueGenericCreate+0x48>
    115a:	c0 e0       	ldi	r28, 0x00	; 0
    115c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    115e:	ce 01       	movw	r24, r28
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	08 95       	ret

0000116a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    116a:	9f 92       	push	r9
    116c:	af 92       	push	r10
    116e:	bf 92       	push	r11
    1170:	cf 92       	push	r12
    1172:	df 92       	push	r13
    1174:	ef 92       	push	r14
    1176:	ff 92       	push	r15
    1178:	0f 93       	push	r16
    117a:	1f 93       	push	r17
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	00 d0       	rcall	.+0      	; 0x1182 <xQueueGenericSend+0x18>
    1182:	1f 92       	push	r1
    1184:	1f 92       	push	r1
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	8c 01       	movw	r16, r24
    118c:	6b 01       	movw	r12, r22
    118e:	5d 83       	std	Y+5, r21	; 0x05
    1190:	4c 83       	std	Y+4, r20	; 0x04
    1192:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1194:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1196:	99 24       	eor	r9, r9
    1198:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    119a:	7c 01       	movw	r14, r24
    119c:	88 e0       	ldi	r24, 0x08	; 8
    119e:	e8 0e       	add	r14, r24
    11a0:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    11a2:	0f b6       	in	r0, 0x3f	; 63
    11a4:	f8 94       	cli
    11a6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11a8:	f8 01       	movw	r30, r16
    11aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    11ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    11ae:	98 17       	cp	r25, r24
    11b0:	18 f0       	brcs	.+6      	; 0x11b8 <xQueueGenericSend+0x4e>
    11b2:	f2 e0       	ldi	r31, 0x02	; 2
    11b4:	af 12       	cpse	r10, r31
    11b6:	15 c0       	rjmp	.+42     	; 0x11e2 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11b8:	4a 2d       	mov	r20, r10
    11ba:	b6 01       	movw	r22, r12
    11bc:	c8 01       	movw	r24, r16
    11be:	b0 de       	rcall	.-672    	; 0xf20 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11c0:	f8 01       	movw	r30, r16
    11c2:	91 89       	ldd	r25, Z+17	; 0x11
    11c4:	99 23       	and	r25, r25
    11c6:	39 f0       	breq	.+14     	; 0x11d6 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11c8:	c8 01       	movw	r24, r16
    11ca:	41 96       	adiw	r24, 0x11	; 17
    11cc:	34 d6       	rcall	.+3176   	; 0x1e36 <xTaskRemoveFromEventList>
    11ce:	81 30       	cpi	r24, 0x01	; 1
    11d0:	21 f4       	brne	.+8      	; 0x11da <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    11d2:	e2 dd       	rcall	.-1084   	; 0xd98 <vPortYield>
    11d4:	02 c0       	rjmp	.+4      	; 0x11da <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    11d6:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    11d8:	df dd       	rcall	.-1090   	; 0xd98 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    11da:	0f 90       	pop	r0
    11dc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	46 c0       	rjmp	.+140    	; 0x126e <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11e2:	ec 81       	ldd	r30, Y+4	; 0x04
    11e4:	fd 81       	ldd	r31, Y+5	; 0x05
    11e6:	ef 2b       	or	r30, r31
    11e8:	21 f4       	brne	.+8      	; 0x11f2 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11ea:	0f 90       	pop	r0
    11ec:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	3e c0       	rjmp	.+124    	; 0x126e <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    11f2:	b1 10       	cpse	r11, r1
    11f4:	04 c0       	rjmp	.+8      	; 0x11fe <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11f6:	ce 01       	movw	r24, r28
    11f8:	01 96       	adiw	r24, 0x01	; 1
    11fa:	65 d6       	rcall	.+3274   	; 0x1ec6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11fc:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1202:	78 d3       	rcall	.+1776   	; 0x18f4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	0f 92       	push	r0
    120a:	f8 01       	movw	r30, r16
    120c:	85 8d       	ldd	r24, Z+29	; 0x1d
    120e:	8f 3f       	cpi	r24, 0xFF	; 255
    1210:	09 f4       	brne	.+2      	; 0x1214 <xQueueGenericSend+0xaa>
    1212:	15 8e       	std	Z+29, r1	; 0x1d
    1214:	f8 01       	movw	r30, r16
    1216:	86 8d       	ldd	r24, Z+30	; 0x1e
    1218:	8f 3f       	cpi	r24, 0xFF	; 255
    121a:	09 f4       	brne	.+2      	; 0x121e <xQueueGenericSend+0xb4>
    121c:	16 8e       	std	Z+30, r1	; 0x1e
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1222:	be 01       	movw	r22, r28
    1224:	6c 5f       	subi	r22, 0xFC	; 252
    1226:	7f 4f       	sbci	r23, 0xFF	; 255
    1228:	ce 01       	movw	r24, r28
    122a:	01 96       	adiw	r24, 0x01	; 1
    122c:	57 d6       	rcall	.+3246   	; 0x1edc <xTaskCheckForTimeOut>
    122e:	81 11       	cpse	r24, r1
    1230:	1a c0       	rjmp	.+52     	; 0x1266 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1238:	f8 01       	movw	r30, r16
    123a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    123c:	0f 90       	pop	r0
    123e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1240:	f8 01       	movw	r30, r16
    1242:	83 8d       	ldd	r24, Z+27	; 0x1b
    1244:	98 13       	cpse	r25, r24
    1246:	0b c0       	rjmp	.+22     	; 0x125e <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1248:	6c 81       	ldd	r22, Y+4	; 0x04
    124a:	7d 81       	ldd	r23, Y+5	; 0x05
    124c:	c7 01       	movw	r24, r14
    124e:	c8 d5       	rcall	.+2960   	; 0x1de0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1250:	c8 01       	movw	r24, r16
    1252:	e2 de       	rcall	.-572    	; 0x1018 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1254:	22 d4       	rcall	.+2116   	; 0x1a9a <xTaskResumeAll>
    1256:	81 11       	cpse	r24, r1
    1258:	a4 cf       	rjmp	.-184    	; 0x11a2 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    125a:	9e dd       	rcall	.-1220   	; 0xd98 <vPortYield>
    125c:	a2 cf       	rjmp	.-188    	; 0x11a2 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    125e:	c8 01       	movw	r24, r16
    1260:	db de       	rcall	.-586    	; 0x1018 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1262:	1b d4       	rcall	.+2102   	; 0x1a9a <xTaskResumeAll>
    1264:	9e cf       	rjmp	.-196    	; 0x11a2 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1266:	c8 01       	movw	r24, r16
    1268:	d7 de       	rcall	.-594    	; 0x1018 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    126a:	17 d4       	rcall	.+2094   	; 0x1a9a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    126c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    126e:	0f 90       	pop	r0
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	cf 90       	pop	r12
    1288:	bf 90       	pop	r11
    128a:	af 90       	pop	r10
    128c:	9f 90       	pop	r9
    128e:	08 95       	ret

00001290 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1290:	cf 93       	push	r28
    1292:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1294:	8f e1       	ldi	r24, 0x1F	; 31
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	58 d8       	rcall	.-3920   	; 0x34a <pvPortMalloc>
    129a:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    129c:	00 97       	sbiw	r24, 0x00	; 0
    129e:	e1 f0       	breq	.+56     	; 0x12d8 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    12a0:	1b 82       	std	Y+3, r1	; 0x03
    12a2:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    12a4:	19 82       	std	Y+1, r1	; 0x01
    12a6:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    12a8:	1d 82       	std	Y+5, r1	; 0x05
    12aa:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    12ac:	1f 82       	std	Y+7, r1	; 0x07
    12ae:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    12b0:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    12b6:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    12b8:	8f ef       	ldi	r24, 0xFF	; 255
    12ba:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    12bc:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    12be:	ce 01       	movw	r24, r28
    12c0:	08 96       	adiw	r24, 0x08	; 8
    12c2:	79 d8       	rcall	.-3854   	; 0x3b6 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    12c4:	ce 01       	movw	r24, r28
    12c6:	41 96       	adiw	r24, 0x11	; 17
    12c8:	76 d8       	rcall	.-3860   	; 0x3b6 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    12ca:	20 e0       	ldi	r18, 0x00	; 0
    12cc:	40 e0       	ldi	r20, 0x00	; 0
    12ce:	50 e0       	ldi	r21, 0x00	; 0
    12d0:	60 e0       	ldi	r22, 0x00	; 0
    12d2:	70 e0       	ldi	r23, 0x00	; 0
    12d4:	ce 01       	movw	r24, r28
    12d6:	49 df       	rcall	.-366    	; 0x116a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    12d8:	ce 01       	movw	r24, r28
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	08 95       	ret

000012e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    12e0:	0f 93       	push	r16
    12e2:	1f 93       	push	r17
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	ec 01       	movw	r28, r24
    12ea:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    12ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    12f0:	98 17       	cp	r25, r24
    12f2:	10 f0       	brcs	.+4      	; 0x12f8 <xQueueGenericSendFromISR+0x18>
    12f4:	22 30       	cpi	r18, 0x02	; 2
    12f6:	11 f5       	brne	.+68     	; 0x133c <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    12f8:	42 2f       	mov	r20, r18
    12fa:	ce 01       	movw	r24, r28
    12fc:	11 de       	rcall	.-990    	; 0xf20 <prvCopyDataToQueue>
    12fe:	88 23       	and	r24, r24
    1300:	31 f0       	breq	.+12     	; 0x130e <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1302:	01 15       	cp	r16, r1
    1304:	11 05       	cpc	r17, r1
    1306:	19 f0       	breq	.+6      	; 0x130e <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	f8 01       	movw	r30, r16
    130c:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    130e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1310:	8f 3f       	cpi	r24, 0xFF	; 255
    1312:	79 f4       	brne	.+30     	; 0x1332 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1314:	89 89       	ldd	r24, Y+17	; 0x11
    1316:	88 23       	and	r24, r24
    1318:	99 f0       	breq	.+38     	; 0x1340 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    131a:	ce 01       	movw	r24, r28
    131c:	41 96       	adiw	r24, 0x11	; 17
    131e:	8b d5       	rcall	.+2838   	; 0x1e36 <xTaskRemoveFromEventList>
    1320:	88 23       	and	r24, r24
    1322:	81 f0       	breq	.+32     	; 0x1344 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1324:	01 15       	cp	r16, r1
    1326:	11 05       	cpc	r17, r1
    1328:	79 f0       	breq	.+30     	; 0x1348 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    132a:	81 e0       	ldi	r24, 0x01	; 1
    132c:	f8 01       	movw	r30, r16
    132e:	80 83       	st	Z, r24
    1330:	0c c0       	rjmp	.+24     	; 0x134a <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1332:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1334:	8f 5f       	subi	r24, 0xFF	; 255
    1336:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	07 c0       	rjmp	.+14     	; 0x134a <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    133c:	80 e0       	ldi	r24, 0x00	; 0
    133e:	05 c0       	rjmp	.+10     	; 0x134a <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	03 c0       	rjmp	.+6      	; 0x134a <xQueueGenericSendFromISR+0x6a>
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	01 c0       	rjmp	.+2      	; 0x134a <xQueueGenericSendFromISR+0x6a>
    1348:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    134a:	df 91       	pop	r29
    134c:	cf 91       	pop	r28
    134e:	1f 91       	pop	r17
    1350:	0f 91       	pop	r16
    1352:	08 95       	ret

00001354 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1354:	9f 92       	push	r9
    1356:	af 92       	push	r10
    1358:	bf 92       	push	r11
    135a:	cf 92       	push	r12
    135c:	df 92       	push	r13
    135e:	ef 92       	push	r14
    1360:	ff 92       	push	r15
    1362:	0f 93       	push	r16
    1364:	1f 93       	push	r17
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
    136a:	00 d0       	rcall	.+0      	; 0x136c <xQueueGenericReceive+0x18>
    136c:	1f 92       	push	r1
    136e:	1f 92       	push	r1
    1370:	cd b7       	in	r28, 0x3d	; 61
    1372:	de b7       	in	r29, 0x3e	; 62
    1374:	8c 01       	movw	r16, r24
    1376:	6b 01       	movw	r12, r22
    1378:	5d 83       	std	Y+5, r21	; 0x05
    137a:	4c 83       	std	Y+4, r20	; 0x04
    137c:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    137e:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1380:	99 24       	eor	r9, r9
    1382:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1384:	7c 01       	movw	r14, r24
    1386:	81 e1       	ldi	r24, 0x11	; 17
    1388:	e8 0e       	add	r14, r24
    138a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    138c:	0f b6       	in	r0, 0x3f	; 63
    138e:	f8 94       	cli
    1390:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1392:	f8 01       	movw	r30, r16
    1394:	82 8d       	ldd	r24, Z+26	; 0x1a
    1396:	88 23       	and	r24, r24
    1398:	69 f1       	breq	.+90     	; 0x13f4 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    139a:	e6 80       	ldd	r14, Z+6	; 0x06
    139c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    139e:	b6 01       	movw	r22, r12
    13a0:	c8 01       	movw	r24, r16
    13a2:	20 de       	rcall	.-960    	; 0xfe4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13a4:	b1 10       	cpse	r11, r1
    13a6:	17 c0       	rjmp	.+46     	; 0x13d6 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    13a8:	f8 01       	movw	r30, r16
    13aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    13ac:	81 50       	subi	r24, 0x01	; 1
    13ae:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13b0:	80 81       	ld	r24, Z
    13b2:	91 81       	ldd	r25, Z+1	; 0x01
    13b4:	89 2b       	or	r24, r25
    13b6:	21 f4       	brne	.+8      	; 0x13c0 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    13b8:	6a d6       	rcall	.+3284   	; 0x208e <pvTaskIncrementMutexHeldCount>
    13ba:	f8 01       	movw	r30, r16
    13bc:	93 83       	std	Z+3, r25	; 0x03
    13be:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13c0:	f8 01       	movw	r30, r16
    13c2:	80 85       	ldd	r24, Z+8	; 0x08
    13c4:	88 23       	and	r24, r24
    13c6:	91 f0       	breq	.+36     	; 0x13ec <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13c8:	c8 01       	movw	r24, r16
    13ca:	08 96       	adiw	r24, 0x08	; 8
    13cc:	34 d5       	rcall	.+2664   	; 0x1e36 <xTaskRemoveFromEventList>
    13ce:	81 30       	cpi	r24, 0x01	; 1
    13d0:	69 f4       	brne	.+26     	; 0x13ec <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    13d2:	e2 dc       	rcall	.-1596   	; 0xd98 <vPortYield>
    13d4:	0b c0       	rjmp	.+22     	; 0x13ec <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    13d6:	f8 01       	movw	r30, r16
    13d8:	f7 82       	std	Z+7, r15	; 0x07
    13da:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13dc:	81 89       	ldd	r24, Z+17	; 0x11
    13de:	88 23       	and	r24, r24
    13e0:	29 f0       	breq	.+10     	; 0x13ec <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13e2:	c8 01       	movw	r24, r16
    13e4:	41 96       	adiw	r24, 0x11	; 17
    13e6:	27 d5       	rcall	.+2638   	; 0x1e36 <xTaskRemoveFromEventList>
    13e8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    13ea:	d6 dc       	rcall	.-1620   	; 0xd98 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    13ec:	0f 90       	pop	r0
    13ee:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	52 c0       	rjmp	.+164    	; 0x1498 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    13f4:	4c 81       	ldd	r20, Y+4	; 0x04
    13f6:	5d 81       	ldd	r21, Y+5	; 0x05
    13f8:	45 2b       	or	r20, r21
    13fa:	21 f4       	brne	.+8      	; 0x1404 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13fc:	0f 90       	pop	r0
    13fe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	4a c0       	rjmp	.+148    	; 0x1498 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1404:	a1 10       	cpse	r10, r1
    1406:	04 c0       	rjmp	.+8      	; 0x1410 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1408:	ce 01       	movw	r24, r28
    140a:	01 96       	adiw	r24, 0x01	; 1
    140c:	5c d5       	rcall	.+2744   	; 0x1ec6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    140e:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1410:	0f 90       	pop	r0
    1412:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1414:	6f d2       	rcall	.+1246   	; 0x18f4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	0f 92       	push	r0
    141c:	f8 01       	movw	r30, r16
    141e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1420:	8f 3f       	cpi	r24, 0xFF	; 255
    1422:	09 f4       	brne	.+2      	; 0x1426 <xQueueGenericReceive+0xd2>
    1424:	15 8e       	std	Z+29, r1	; 0x1d
    1426:	f8 01       	movw	r30, r16
    1428:	86 8d       	ldd	r24, Z+30	; 0x1e
    142a:	8f 3f       	cpi	r24, 0xFF	; 255
    142c:	09 f4       	brne	.+2      	; 0x1430 <xQueueGenericReceive+0xdc>
    142e:	16 8e       	std	Z+30, r1	; 0x1e
    1430:	0f 90       	pop	r0
    1432:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1434:	be 01       	movw	r22, r28
    1436:	6c 5f       	subi	r22, 0xFC	; 252
    1438:	7f 4f       	sbci	r23, 0xFF	; 255
    143a:	ce 01       	movw	r24, r28
    143c:	01 96       	adiw	r24, 0x01	; 1
    143e:	4e d5       	rcall	.+2716   	; 0x1edc <xTaskCheckForTimeOut>
    1440:	81 11       	cpse	r24, r1
    1442:	26 c0       	rjmp	.+76     	; 0x1490 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1444:	0f b6       	in	r0, 0x3f	; 63
    1446:	f8 94       	cli
    1448:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    144a:	f8 01       	movw	r30, r16
    144c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    144e:	0f 90       	pop	r0
    1450:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1452:	81 11       	cpse	r24, r1
    1454:	19 c0       	rjmp	.+50     	; 0x1488 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1456:	f8 01       	movw	r30, r16
    1458:	80 81       	ld	r24, Z
    145a:	91 81       	ldd	r25, Z+1	; 0x01
    145c:	89 2b       	or	r24, r25
    145e:	49 f4       	brne	.+18     	; 0x1472 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1460:	0f b6       	in	r0, 0x3f	; 63
    1462:	f8 94       	cli
    1464:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1466:	f8 01       	movw	r30, r16
    1468:	82 81       	ldd	r24, Z+2	; 0x02
    146a:	93 81       	ldd	r25, Z+3	; 0x03
    146c:	73 d5       	rcall	.+2790   	; 0x1f54 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    146e:	0f 90       	pop	r0
    1470:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1472:	6c 81       	ldd	r22, Y+4	; 0x04
    1474:	7d 81       	ldd	r23, Y+5	; 0x05
    1476:	c7 01       	movw	r24, r14
    1478:	b3 d4       	rcall	.+2406   	; 0x1de0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    147a:	c8 01       	movw	r24, r16
    147c:	cd dd       	rcall	.-1126   	; 0x1018 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    147e:	0d d3       	rcall	.+1562   	; 0x1a9a <xTaskResumeAll>
    1480:	81 11       	cpse	r24, r1
    1482:	84 cf       	rjmp	.-248    	; 0x138c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1484:	89 dc       	rcall	.-1774   	; 0xd98 <vPortYield>
    1486:	82 cf       	rjmp	.-252    	; 0x138c <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1488:	c8 01       	movw	r24, r16
    148a:	c6 dd       	rcall	.-1140   	; 0x1018 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    148c:	06 d3       	rcall	.+1548   	; 0x1a9a <xTaskResumeAll>
    148e:	7e cf       	rjmp	.-260    	; 0x138c <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1490:	c8 01       	movw	r24, r16
    1492:	c2 dd       	rcall	.-1148   	; 0x1018 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1494:	02 d3       	rcall	.+1540   	; 0x1a9a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1496:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1498:	0f 90       	pop	r0
    149a:	0f 90       	pop	r0
    149c:	0f 90       	pop	r0
    149e:	0f 90       	pop	r0
    14a0:	0f 90       	pop	r0
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	1f 91       	pop	r17
    14a8:	0f 91       	pop	r16
    14aa:	ff 90       	pop	r15
    14ac:	ef 90       	pop	r14
    14ae:	df 90       	pop	r13
    14b0:	cf 90       	pop	r12
    14b2:	bf 90       	pop	r11
    14b4:	af 90       	pop	r10
    14b6:	9f 90       	pop	r9
    14b8:	08 95       	ret

000014ba <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    14ba:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    14bc:	71 83       	std	Z+1, r23	; 0x01
    14be:	60 83       	st	Z, r22
	ring->rSize = size;
    14c0:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    14c2:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    14c4:	13 82       	std	Z+3, r1	; 0x03
    14c6:	08 95       	ret

000014c8 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    14c8:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    14ca:	94 81       	ldd	r25, Z+4	; 0x04
    14cc:	a0 81       	ld	r26, Z
    14ce:	b1 81       	ldd	r27, Z+1	; 0x01
    14d0:	a9 0f       	add	r26, r25
    14d2:	b1 1d       	adc	r27, r1
    14d4:	8c 91       	ld	r24, X
            ring->rIndex ++;
    14d6:	9f 5f       	subi	r25, 0xFF	; 255
    14d8:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    14da:	22 81       	ldd	r18, Z+2	; 0x02
    14dc:	92 17       	cp	r25, r18
    14de:	10 f0       	brcs	.+4      	; 0x14e4 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    14e0:	92 1b       	sub	r25, r18
    14e2:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    14e4:	93 81       	ldd	r25, Z+3	; 0x03
    14e6:	91 50       	subi	r25, 0x01	; 1
    14e8:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    14ea:	08 95       	ret

000014ec <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    14ec:	fc 01       	movw	r30, r24
    14ee:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    14f0:	83 81       	ldd	r24, Z+3	; 0x03
    14f2:	22 81       	ldd	r18, Z+2	; 0x02
    14f4:	82 17       	cp	r24, r18
    14f6:	78 f4       	brcc	.+30     	; 0x1516 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    14f8:	34 81       	ldd	r19, Z+4	; 0x04
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	83 0f       	add	r24, r19
    14fe:	91 1d       	adc	r25, r1
    1500:	62 2f       	mov	r22, r18
    1502:	70 e0       	ldi	r23, 0x00	; 0
    1504:	d6 d5       	rcall	.+2988   	; 0x20b2 <__divmodhi4>
    1506:	a0 81       	ld	r26, Z
    1508:	b1 81       	ldd	r27, Z+1	; 0x01
    150a:	a8 0f       	add	r26, r24
    150c:	b9 1f       	adc	r27, r25
    150e:	4c 93       	st	X, r20
            ring->rLength++;
    1510:	83 81       	ldd	r24, Z+3	; 0x03
    1512:	8f 5f       	subi	r24, 0xFF	; 255
    1514:	83 83       	std	Z+3, r24	; 0x03
    1516:	08 95       	ret

00001518 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1518:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	22 81       	ldd	r18, Z+2	; 0x02
    151e:	93 81       	ldd	r25, Z+3	; 0x03
    1520:	29 13       	cpse	r18, r25
    1522:	80 e0       	ldi	r24, 0x00	; 0
}
    1524:	08 95       	ret

00001526 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1526:	21 e0       	ldi	r18, 0x01	; 1
    1528:	fc 01       	movw	r30, r24
    152a:	83 81       	ldd	r24, Z+3	; 0x03
    152c:	81 11       	cpse	r24, r1
    152e:	01 c0       	rjmp	.+2      	; 0x1532 <ringBufferNotEmpty+0xc>
    1530:	20 e0       	ldi	r18, 0x00	; 0
}
    1532:	82 2f       	mov	r24, r18
    1534:	08 95       	ret

00001536 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1536:	e0 91 66 08 	lds	r30, 0x0866
    153a:	f0 91 67 08 	lds	r31, 0x0867
    153e:	80 81       	ld	r24, Z
    1540:	81 11       	cpse	r24, r1
    1542:	07 c0       	rjmp	.+14     	; 0x1552 <prvResetNextTaskUnblockTime+0x1c>
    1544:	8f ef       	ldi	r24, 0xFF	; 255
    1546:	9f ef       	ldi	r25, 0xFF	; 255
    1548:	90 93 05 02 	sts	0x0205, r25
    154c:	80 93 04 02 	sts	0x0204, r24
    1550:	08 95       	ret
    1552:	e0 91 66 08 	lds	r30, 0x0866
    1556:	f0 91 67 08 	lds	r31, 0x0867
    155a:	05 80       	ldd	r0, Z+5	; 0x05
    155c:	f6 81       	ldd	r31, Z+6	; 0x06
    155e:	e0 2d       	mov	r30, r0
    1560:	06 80       	ldd	r0, Z+6	; 0x06
    1562:	f7 81       	ldd	r31, Z+7	; 0x07
    1564:	e0 2d       	mov	r30, r0
    1566:	82 81       	ldd	r24, Z+2	; 0x02
    1568:	93 81       	ldd	r25, Z+3	; 0x03
    156a:	90 93 05 02 	sts	0x0205, r25
    156e:	80 93 04 02 	sts	0x0204, r24
    1572:	08 95       	ret

00001574 <prvAddCurrentTaskToDelayedList>:
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	ec 01       	movw	r28, r24
    157a:	e0 91 a7 08 	lds	r30, 0x08A7
    157e:	f0 91 a8 08 	lds	r31, 0x08A8
    1582:	93 83       	std	Z+3, r25	; 0x03
    1584:	82 83       	std	Z+2, r24	; 0x02
    1586:	80 91 45 08 	lds	r24, 0x0845
    158a:	90 91 46 08 	lds	r25, 0x0846
    158e:	c8 17       	cp	r28, r24
    1590:	d9 07       	cpc	r29, r25
    1592:	68 f4       	brcc	.+26     	; 0x15ae <prvAddCurrentTaskToDelayedList+0x3a>
    1594:	60 91 a7 08 	lds	r22, 0x08A7
    1598:	70 91 a8 08 	lds	r23, 0x08A8
    159c:	80 91 64 08 	lds	r24, 0x0864
    15a0:	90 91 65 08 	lds	r25, 0x0865
    15a4:	6e 5f       	subi	r22, 0xFE	; 254
    15a6:	7f 4f       	sbci	r23, 0xFF	; 255
    15a8:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsert>
    15ac:	17 c0       	rjmp	.+46     	; 0x15dc <prvAddCurrentTaskToDelayedList+0x68>
    15ae:	60 91 a7 08 	lds	r22, 0x08A7
    15b2:	70 91 a8 08 	lds	r23, 0x08A8
    15b6:	80 91 66 08 	lds	r24, 0x0866
    15ba:	90 91 67 08 	lds	r25, 0x0867
    15be:	6e 5f       	subi	r22, 0xFE	; 254
    15c0:	7f 4f       	sbci	r23, 0xFF	; 255
    15c2:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsert>
    15c6:	80 91 04 02 	lds	r24, 0x0204
    15ca:	90 91 05 02 	lds	r25, 0x0205
    15ce:	c8 17       	cp	r28, r24
    15d0:	d9 07       	cpc	r29, r25
    15d2:	20 f4       	brcc	.+8      	; 0x15dc <prvAddCurrentTaskToDelayedList+0x68>
    15d4:	d0 93 05 02 	sts	0x0205, r29
    15d8:	c0 93 04 02 	sts	0x0204, r28
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	08 95       	ret

000015e2 <xTaskGenericCreate>:
    15e2:	4f 92       	push	r4
    15e4:	5f 92       	push	r5
    15e6:	6f 92       	push	r6
    15e8:	7f 92       	push	r7
    15ea:	8f 92       	push	r8
    15ec:	9f 92       	push	r9
    15ee:	af 92       	push	r10
    15f0:	bf 92       	push	r11
    15f2:	cf 92       	push	r12
    15f4:	df 92       	push	r13
    15f6:	ef 92       	push	r14
    15f8:	ff 92       	push	r15
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	4c 01       	movw	r8, r24
    1604:	5b 01       	movw	r10, r22
    1606:	2a 01       	movw	r4, r20
    1608:	39 01       	movw	r6, r18
    160a:	83 e2       	ldi	r24, 0x23	; 35
    160c:	90 e0       	ldi	r25, 0x00	; 0
    160e:	0e 94 a5 01 	call	0x34a	; 0x34a <pvPortMalloc>
    1612:	ec 01       	movw	r28, r24
    1614:	00 97       	sbiw	r24, 0x00	; 0
    1616:	09 f4       	brne	.+2      	; 0x161a <xTaskGenericCreate+0x38>
    1618:	e7 c0       	rjmp	.+462    	; 0x17e8 <xTaskGenericCreate+0x206>
    161a:	c1 14       	cp	r12, r1
    161c:	d1 04       	cpc	r13, r1
    161e:	09 f0       	breq	.+2      	; 0x1622 <xTaskGenericCreate+0x40>
    1620:	cc c0       	rjmp	.+408    	; 0x17ba <xTaskGenericCreate+0x1d8>
    1622:	c2 01       	movw	r24, r4
    1624:	0e 94 a5 01 	call	0x34a	; 0x34a <pvPortMalloc>
    1628:	98 8f       	std	Y+24, r25	; 0x18
    162a:	8f 8b       	std	Y+23, r24	; 0x17
    162c:	89 2b       	or	r24, r25
    162e:	09 f0       	breq	.+2      	; 0x1632 <xTaskGenericCreate+0x50>
    1630:	c6 c0       	rjmp	.+396    	; 0x17be <xTaskGenericCreate+0x1dc>
    1632:	ce 01       	movw	r24, r28
    1634:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortFree>
    1638:	d7 c0       	rjmp	.+430    	; 0x17e8 <xTaskGenericCreate+0x206>
    163a:	cf 01       	movw	r24, r30
    163c:	31 91       	ld	r19, Z+
    163e:	da 01       	movw	r26, r20
    1640:	3d 93       	st	X+, r19
    1642:	ad 01       	movw	r20, r26
    1644:	dc 01       	movw	r26, r24
    1646:	8c 91       	ld	r24, X
    1648:	88 23       	and	r24, r24
    164a:	11 f0       	breq	.+4      	; 0x1650 <xTaskGenericCreate+0x6e>
    164c:	21 50       	subi	r18, 0x01	; 1
    164e:	a9 f7       	brne	.-22     	; 0x163a <xTaskGenericCreate+0x58>
    1650:	18 a2       	std	Y+32, r1	; 0x20
    1652:	10 2f       	mov	r17, r16
    1654:	05 30       	cpi	r16, 0x05	; 5
    1656:	08 f0       	brcs	.+2      	; 0x165a <xTaskGenericCreate+0x78>
    1658:	14 e0       	ldi	r17, 0x04	; 4
    165a:	1e 8b       	std	Y+22, r17	; 0x16
    165c:	19 a3       	std	Y+33, r17	; 0x21
    165e:	1a a2       	std	Y+34, r1	; 0x22
    1660:	5e 01       	movw	r10, r28
    1662:	b2 e0       	ldi	r27, 0x02	; 2
    1664:	ab 0e       	add	r10, r27
    1666:	b1 1c       	adc	r11, r1
    1668:	c5 01       	movw	r24, r10
    166a:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <vListInitialiseItem>
    166e:	ce 01       	movw	r24, r28
    1670:	0c 96       	adiw	r24, 0x0c	; 12
    1672:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <vListInitialiseItem>
    1676:	d9 87       	std	Y+9, r29	; 0x09
    1678:	c8 87       	std	Y+8, r28	; 0x08
    167a:	85 e0       	ldi	r24, 0x05	; 5
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	81 1b       	sub	r24, r17
    1680:	91 09       	sbc	r25, r1
    1682:	9d 87       	std	Y+13, r25	; 0x0d
    1684:	8c 87       	std	Y+12, r24	; 0x0c
    1686:	db 8b       	std	Y+19, r29	; 0x13
    1688:	ca 8b       	std	Y+18, r28	; 0x12
    168a:	a3 01       	movw	r20, r6
    168c:	b4 01       	movw	r22, r8
    168e:	c6 01       	movw	r24, r12
    1690:	d4 da       	rcall	.-2648   	; 0xc3a <pxPortInitialiseStack>
    1692:	99 83       	std	Y+1, r25	; 0x01
    1694:	88 83       	st	Y, r24
    1696:	e1 14       	cp	r14, r1
    1698:	f1 04       	cpc	r15, r1
    169a:	19 f0       	breq	.+6      	; 0x16a2 <xTaskGenericCreate+0xc0>
    169c:	f7 01       	movw	r30, r14
    169e:	d1 83       	std	Z+1, r29	; 0x01
    16a0:	c0 83       	st	Z, r28
    16a2:	0f b6       	in	r0, 0x3f	; 63
    16a4:	f8 94       	cli
    16a6:	0f 92       	push	r0
    16a8:	80 91 47 08 	lds	r24, 0x0847
    16ac:	8f 5f       	subi	r24, 0xFF	; 255
    16ae:	80 93 47 08 	sts	0x0847, r24
    16b2:	80 91 a7 08 	lds	r24, 0x08A7
    16b6:	90 91 a8 08 	lds	r25, 0x08A8
    16ba:	89 2b       	or	r24, r25
    16bc:	09 f0       	breq	.+2      	; 0x16c0 <xTaskGenericCreate+0xde>
    16be:	3f c0       	rjmp	.+126    	; 0x173e <xTaskGenericCreate+0x15c>
    16c0:	d0 93 a8 08 	sts	0x08A8, r29
    16c4:	c0 93 a7 08 	sts	0x08A7, r28
    16c8:	80 91 47 08 	lds	r24, 0x0847
    16cc:	81 30       	cpi	r24, 0x01	; 1
    16ce:	09 f0       	breq	.+2      	; 0x16d2 <xTaskGenericCreate+0xf0>
    16d0:	45 c0       	rjmp	.+138    	; 0x175c <xTaskGenericCreate+0x17a>
    16d2:	0f 2e       	mov	r0, r31
    16d4:	fa e7       	ldi	r31, 0x7A	; 122
    16d6:	ef 2e       	mov	r14, r31
    16d8:	f8 e0       	ldi	r31, 0x08	; 8
    16da:	ff 2e       	mov	r15, r31
    16dc:	f0 2d       	mov	r31, r0
    16de:	0f 2e       	mov	r0, r31
    16e0:	f7 ea       	ldi	r31, 0xA7	; 167
    16e2:	cf 2e       	mov	r12, r31
    16e4:	f8 e0       	ldi	r31, 0x08	; 8
    16e6:	df 2e       	mov	r13, r31
    16e8:	f0 2d       	mov	r31, r0
    16ea:	c7 01       	movw	r24, r14
    16ec:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    16f0:	f9 e0       	ldi	r31, 0x09	; 9
    16f2:	ef 0e       	add	r14, r31
    16f4:	f1 1c       	adc	r15, r1
    16f6:	ec 14       	cp	r14, r12
    16f8:	fd 04       	cpc	r15, r13
    16fa:	b9 f7       	brne	.-18     	; 0x16ea <xTaskGenericCreate+0x108>
    16fc:	81 e7       	ldi	r24, 0x71	; 113
    16fe:	98 e0       	ldi	r25, 0x08	; 8
    1700:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    1704:	88 e6       	ldi	r24, 0x68	; 104
    1706:	98 e0       	ldi	r25, 0x08	; 8
    1708:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    170c:	8b e5       	ldi	r24, 0x5B	; 91
    170e:	98 e0       	ldi	r25, 0x08	; 8
    1710:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    1714:	82 e5       	ldi	r24, 0x52	; 82
    1716:	98 e0       	ldi	r25, 0x08	; 8
    1718:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    171c:	88 e4       	ldi	r24, 0x48	; 72
    171e:	98 e0       	ldi	r25, 0x08	; 8
    1720:	0e 94 db 01 	call	0x3b6	; 0x3b6 <vListInitialise>
    1724:	81 e7       	ldi	r24, 0x71	; 113
    1726:	98 e0       	ldi	r25, 0x08	; 8
    1728:	90 93 67 08 	sts	0x0867, r25
    172c:	80 93 66 08 	sts	0x0866, r24
    1730:	88 e6       	ldi	r24, 0x68	; 104
    1732:	98 e0       	ldi	r25, 0x08	; 8
    1734:	90 93 65 08 	sts	0x0865, r25
    1738:	80 93 64 08 	sts	0x0864, r24
    173c:	0f c0       	rjmp	.+30     	; 0x175c <xTaskGenericCreate+0x17a>
    173e:	80 91 43 08 	lds	r24, 0x0843
    1742:	81 11       	cpse	r24, r1
    1744:	0b c0       	rjmp	.+22     	; 0x175c <xTaskGenericCreate+0x17a>
    1746:	e0 91 a7 08 	lds	r30, 0x08A7
    174a:	f0 91 a8 08 	lds	r31, 0x08A8
    174e:	86 89       	ldd	r24, Z+22	; 0x16
    1750:	08 17       	cp	r16, r24
    1752:	20 f0       	brcs	.+8      	; 0x175c <xTaskGenericCreate+0x17a>
    1754:	d0 93 a8 08 	sts	0x08A8, r29
    1758:	c0 93 a7 08 	sts	0x08A7, r28
    175c:	80 91 3f 08 	lds	r24, 0x083F
    1760:	8f 5f       	subi	r24, 0xFF	; 255
    1762:	80 93 3f 08 	sts	0x083F, r24
    1766:	8e 89       	ldd	r24, Y+22	; 0x16
    1768:	90 91 44 08 	lds	r25, 0x0844
    176c:	98 17       	cp	r25, r24
    176e:	10 f4       	brcc	.+4      	; 0x1774 <xTaskGenericCreate+0x192>
    1770:	80 93 44 08 	sts	0x0844, r24
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	9c 01       	movw	r18, r24
    1778:	22 0f       	add	r18, r18
    177a:	33 1f       	adc	r19, r19
    177c:	22 0f       	add	r18, r18
    177e:	33 1f       	adc	r19, r19
    1780:	22 0f       	add	r18, r18
    1782:	33 1f       	adc	r19, r19
    1784:	82 0f       	add	r24, r18
    1786:	93 1f       	adc	r25, r19
    1788:	b5 01       	movw	r22, r10
    178a:	86 58       	subi	r24, 0x86	; 134
    178c:	97 4f       	sbci	r25, 0xF7	; 247
    178e:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1792:	0f 90       	pop	r0
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	80 91 43 08 	lds	r24, 0x0843
    179a:	88 23       	and	r24, r24
    179c:	51 f0       	breq	.+20     	; 0x17b2 <xTaskGenericCreate+0x1d0>
    179e:	e0 91 a7 08 	lds	r30, 0x08A7
    17a2:	f0 91 a8 08 	lds	r31, 0x08A8
    17a6:	86 89       	ldd	r24, Z+22	; 0x16
    17a8:	80 17       	cp	r24, r16
    17aa:	28 f4       	brcc	.+10     	; 0x17b6 <xTaskGenericCreate+0x1d4>
    17ac:	f5 da       	rcall	.-2582   	; 0xd98 <vPortYield>
    17ae:	81 e0       	ldi	r24, 0x01	; 1
    17b0:	1c c0       	rjmp	.+56     	; 0x17ea <xTaskGenericCreate+0x208>
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	1a c0       	rjmp	.+52     	; 0x17ea <xTaskGenericCreate+0x208>
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	18 c0       	rjmp	.+48     	; 0x17ea <xTaskGenericCreate+0x208>
    17ba:	d8 8e       	std	Y+24, r13	; 0x18
    17bc:	cf 8a       	std	Y+23, r12	; 0x17
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	48 1a       	sub	r4, r24
    17c2:	51 08       	sbc	r5, r1
    17c4:	cf 88       	ldd	r12, Y+23	; 0x17
    17c6:	d8 8c       	ldd	r13, Y+24	; 0x18
    17c8:	c4 0c       	add	r12, r4
    17ca:	d5 1c       	adc	r13, r5
    17cc:	d5 01       	movw	r26, r10
    17ce:	8c 91       	ld	r24, X
    17d0:	89 8f       	std	Y+25, r24	; 0x19
    17d2:	8c 91       	ld	r24, X
    17d4:	88 23       	and	r24, r24
    17d6:	09 f4       	brne	.+2      	; 0x17da <xTaskGenericCreate+0x1f8>
    17d8:	3b cf       	rjmp	.-394    	; 0x1650 <xTaskGenericCreate+0x6e>
    17da:	ae 01       	movw	r20, r28
    17dc:	46 5e       	subi	r20, 0xE6	; 230
    17de:	5f 4f       	sbci	r21, 0xFF	; 255
    17e0:	f5 01       	movw	r30, r10
    17e2:	31 96       	adiw	r30, 0x01	; 1
    17e4:	27 e0       	ldi	r18, 0x07	; 7
    17e6:	29 cf       	rjmp	.-430    	; 0x163a <xTaskGenericCreate+0x58>
    17e8:	8f ef       	ldi	r24, 0xFF	; 255
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	1f 91       	pop	r17
    17f0:	0f 91       	pop	r16
    17f2:	ff 90       	pop	r15
    17f4:	ef 90       	pop	r14
    17f6:	df 90       	pop	r13
    17f8:	cf 90       	pop	r12
    17fa:	bf 90       	pop	r11
    17fc:	af 90       	pop	r10
    17fe:	9f 90       	pop	r9
    1800:	8f 90       	pop	r8
    1802:	7f 90       	pop	r7
    1804:	6f 90       	pop	r6
    1806:	5f 90       	pop	r5
    1808:	4f 90       	pop	r4
    180a:	08 95       	ret

0000180c <vTaskResume>:
    180c:	0f 93       	push	r16
    180e:	1f 93       	push	r17
    1810:	cf 93       	push	r28
    1812:	df 93       	push	r29
    1814:	ec 01       	movw	r28, r24
    1816:	00 97       	sbiw	r24, 0x00	; 0
    1818:	09 f4       	brne	.+2      	; 0x181c <vTaskResume+0x10>
    181a:	3e c0       	rjmp	.+124    	; 0x1898 <vTaskResume+0x8c>
    181c:	80 91 a7 08 	lds	r24, 0x08A7
    1820:	90 91 a8 08 	lds	r25, 0x08A8
    1824:	c8 17       	cp	r28, r24
    1826:	d9 07       	cpc	r29, r25
    1828:	b9 f1       	breq	.+110    	; 0x1898 <vTaskResume+0x8c>
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	0f 92       	push	r0
    1830:	8a 85       	ldd	r24, Y+10	; 0x0a
    1832:	9b 85       	ldd	r25, Y+11	; 0x0b
    1834:	88 54       	subi	r24, 0x48	; 72
    1836:	98 40       	sbci	r25, 0x08	; 8
    1838:	69 f5       	brne	.+90     	; 0x1894 <vTaskResume+0x88>
    183a:	8c 89       	ldd	r24, Y+20	; 0x14
    183c:	9d 89       	ldd	r25, Y+21	; 0x15
    183e:	28 e0       	ldi	r18, 0x08	; 8
    1840:	8b 35       	cpi	r24, 0x5B	; 91
    1842:	92 07       	cpc	r25, r18
    1844:	39 f1       	breq	.+78     	; 0x1894 <vTaskResume+0x88>
    1846:	89 2b       	or	r24, r25
    1848:	29 f5       	brne	.+74     	; 0x1894 <vTaskResume+0x88>
    184a:	8e 01       	movw	r16, r28
    184c:	0e 5f       	subi	r16, 0xFE	; 254
    184e:	1f 4f       	sbci	r17, 0xFF	; 255
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1856:	8e 89       	ldd	r24, Y+22	; 0x16
    1858:	90 91 44 08 	lds	r25, 0x0844
    185c:	98 17       	cp	r25, r24
    185e:	10 f4       	brcc	.+4      	; 0x1864 <vTaskResume+0x58>
    1860:	80 93 44 08 	sts	0x0844, r24
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	9c 01       	movw	r18, r24
    1868:	22 0f       	add	r18, r18
    186a:	33 1f       	adc	r19, r19
    186c:	22 0f       	add	r18, r18
    186e:	33 1f       	adc	r19, r19
    1870:	22 0f       	add	r18, r18
    1872:	33 1f       	adc	r19, r19
    1874:	82 0f       	add	r24, r18
    1876:	93 1f       	adc	r25, r19
    1878:	b8 01       	movw	r22, r16
    187a:	86 58       	subi	r24, 0x86	; 134
    187c:	97 4f       	sbci	r25, 0xF7	; 247
    187e:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1882:	e0 91 a7 08 	lds	r30, 0x08A7
    1886:	f0 91 a8 08 	lds	r31, 0x08A8
    188a:	9e 89       	ldd	r25, Y+22	; 0x16
    188c:	86 89       	ldd	r24, Z+22	; 0x16
    188e:	98 17       	cp	r25, r24
    1890:	08 f0       	brcs	.+2      	; 0x1894 <vTaskResume+0x88>
    1892:	82 da       	rcall	.-2812   	; 0xd98 <vPortYield>
    1894:	0f 90       	pop	r0
    1896:	0f be       	out	0x3f, r0	; 63
    1898:	df 91       	pop	r29
    189a:	cf 91       	pop	r28
    189c:	1f 91       	pop	r17
    189e:	0f 91       	pop	r16
    18a0:	08 95       	ret

000018a2 <vTaskStartScheduler>:
    18a2:	af 92       	push	r10
    18a4:	bf 92       	push	r11
    18a6:	cf 92       	push	r12
    18a8:	df 92       	push	r13
    18aa:	ef 92       	push	r14
    18ac:	ff 92       	push	r15
    18ae:	0f 93       	push	r16
    18b0:	a1 2c       	mov	r10, r1
    18b2:	b1 2c       	mov	r11, r1
    18b4:	c1 2c       	mov	r12, r1
    18b6:	d1 2c       	mov	r13, r1
    18b8:	e1 2c       	mov	r14, r1
    18ba:	f1 2c       	mov	r15, r1
    18bc:	00 e0       	ldi	r16, 0x00	; 0
    18be:	20 e0       	ldi	r18, 0x00	; 0
    18c0:	30 e0       	ldi	r19, 0x00	; 0
    18c2:	45 e5       	ldi	r20, 0x55	; 85
    18c4:	50 e0       	ldi	r21, 0x00	; 0
    18c6:	69 e5       	ldi	r22, 0x59	; 89
    18c8:	72 e0       	ldi	r23, 0x02	; 2
    18ca:	8c e0       	ldi	r24, 0x0C	; 12
    18cc:	9e e0       	ldi	r25, 0x0E	; 14
    18ce:	89 de       	rcall	.-750    	; 0x15e2 <xTaskGenericCreate>
    18d0:	81 30       	cpi	r24, 0x01	; 1
    18d2:	41 f4       	brne	.+16     	; 0x18e4 <vTaskStartScheduler+0x42>
    18d4:	f8 94       	cli
    18d6:	80 93 43 08 	sts	0x0843, r24
    18da:	10 92 46 08 	sts	0x0846, r1
    18de:	10 92 45 08 	sts	0x0845, r1
    18e2:	1d da       	rcall	.-3014   	; 0xd1e <xPortStartScheduler>
    18e4:	0f 91       	pop	r16
    18e6:	ff 90       	pop	r15
    18e8:	ef 90       	pop	r14
    18ea:	df 90       	pop	r13
    18ec:	cf 90       	pop	r12
    18ee:	bf 90       	pop	r11
    18f0:	af 90       	pop	r10
    18f2:	08 95       	ret

000018f4 <vTaskSuspendAll>:
    18f4:	80 91 3e 08 	lds	r24, 0x083E
    18f8:	8f 5f       	subi	r24, 0xFF	; 255
    18fa:	80 93 3e 08 	sts	0x083E, r24
    18fe:	08 95       	ret

00001900 <xTaskGetTickCount>:
    1900:	0f b6       	in	r0, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	0f 92       	push	r0
    1906:	80 91 45 08 	lds	r24, 0x0845
    190a:	90 91 46 08 	lds	r25, 0x0846
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63
    1912:	08 95       	ret

00001914 <xTaskGetTickCountFromISR>:
    1914:	80 91 45 08 	lds	r24, 0x0845
    1918:	90 91 46 08 	lds	r25, 0x0846
    191c:	08 95       	ret

0000191e <xTaskIncrementTick>:
    191e:	cf 92       	push	r12
    1920:	df 92       	push	r13
    1922:	ef 92       	push	r14
    1924:	ff 92       	push	r15
    1926:	0f 93       	push	r16
    1928:	1f 93       	push	r17
    192a:	cf 93       	push	r28
    192c:	df 93       	push	r29
    192e:	80 91 3e 08 	lds	r24, 0x083E
    1932:	81 11       	cpse	r24, r1
    1934:	99 c0       	rjmp	.+306    	; 0x1a68 <xTaskIncrementTick+0x14a>
    1936:	80 91 45 08 	lds	r24, 0x0845
    193a:	90 91 46 08 	lds	r25, 0x0846
    193e:	01 96       	adiw	r24, 0x01	; 1
    1940:	90 93 46 08 	sts	0x0846, r25
    1944:	80 93 45 08 	sts	0x0845, r24
    1948:	e0 90 45 08 	lds	r14, 0x0845
    194c:	f0 90 46 08 	lds	r15, 0x0846
    1950:	e1 14       	cp	r14, r1
    1952:	f1 04       	cpc	r15, r1
    1954:	b1 f4       	brne	.+44     	; 0x1982 <xTaskIncrementTick+0x64>
    1956:	80 91 66 08 	lds	r24, 0x0866
    195a:	90 91 67 08 	lds	r25, 0x0867
    195e:	20 91 64 08 	lds	r18, 0x0864
    1962:	30 91 65 08 	lds	r19, 0x0865
    1966:	30 93 67 08 	sts	0x0867, r19
    196a:	20 93 66 08 	sts	0x0866, r18
    196e:	90 93 65 08 	sts	0x0865, r25
    1972:	80 93 64 08 	sts	0x0864, r24
    1976:	80 91 40 08 	lds	r24, 0x0840
    197a:	8f 5f       	subi	r24, 0xFF	; 255
    197c:	80 93 40 08 	sts	0x0840, r24
    1980:	da dd       	rcall	.-1100   	; 0x1536 <prvResetNextTaskUnblockTime>
    1982:	80 91 04 02 	lds	r24, 0x0204
    1986:	90 91 05 02 	lds	r25, 0x0205
    198a:	e8 16       	cp	r14, r24
    198c:	f9 06       	cpc	r15, r25
    198e:	08 f4       	brcc	.+2      	; 0x1992 <xTaskIncrementTick+0x74>
    1990:	54 c0       	rjmp	.+168    	; 0x1a3a <xTaskIncrementTick+0x11c>
    1992:	d1 2c       	mov	r13, r1
    1994:	cc 24       	eor	r12, r12
    1996:	c3 94       	inc	r12
    1998:	01 c0       	rjmp	.+2      	; 0x199c <xTaskIncrementTick+0x7e>
    199a:	dc 2c       	mov	r13, r12
    199c:	e0 91 66 08 	lds	r30, 0x0866
    19a0:	f0 91 67 08 	lds	r31, 0x0867
    19a4:	80 81       	ld	r24, Z
    19a6:	81 11       	cpse	r24, r1
    19a8:	07 c0       	rjmp	.+14     	; 0x19b8 <xTaskIncrementTick+0x9a>
    19aa:	8f ef       	ldi	r24, 0xFF	; 255
    19ac:	9f ef       	ldi	r25, 0xFF	; 255
    19ae:	90 93 05 02 	sts	0x0205, r25
    19b2:	80 93 04 02 	sts	0x0204, r24
    19b6:	42 c0       	rjmp	.+132    	; 0x1a3c <xTaskIncrementTick+0x11e>
    19b8:	e0 91 66 08 	lds	r30, 0x0866
    19bc:	f0 91 67 08 	lds	r31, 0x0867
    19c0:	05 80       	ldd	r0, Z+5	; 0x05
    19c2:	f6 81       	ldd	r31, Z+6	; 0x06
    19c4:	e0 2d       	mov	r30, r0
    19c6:	c6 81       	ldd	r28, Z+6	; 0x06
    19c8:	d7 81       	ldd	r29, Z+7	; 0x07
    19ca:	2a 81       	ldd	r18, Y+2	; 0x02
    19cc:	3b 81       	ldd	r19, Y+3	; 0x03
    19ce:	e2 16       	cp	r14, r18
    19d0:	f3 06       	cpc	r15, r19
    19d2:	28 f4       	brcc	.+10     	; 0x19de <xTaskIncrementTick+0xc0>
    19d4:	30 93 05 02 	sts	0x0205, r19
    19d8:	20 93 04 02 	sts	0x0204, r18
    19dc:	2f c0       	rjmp	.+94     	; 0x1a3c <xTaskIncrementTick+0x11e>
    19de:	8e 01       	movw	r16, r28
    19e0:	0e 5f       	subi	r16, 0xFE	; 254
    19e2:	1f 4f       	sbci	r17, 0xFF	; 255
    19e4:	c8 01       	movw	r24, r16
    19e6:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    19ea:	8c 89       	ldd	r24, Y+20	; 0x14
    19ec:	9d 89       	ldd	r25, Y+21	; 0x15
    19ee:	89 2b       	or	r24, r25
    19f0:	21 f0       	breq	.+8      	; 0x19fa <xTaskIncrementTick+0xdc>
    19f2:	ce 01       	movw	r24, r28
    19f4:	0c 96       	adiw	r24, 0x0c	; 12
    19f6:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    19fa:	2e 89       	ldd	r18, Y+22	; 0x16
    19fc:	80 91 44 08 	lds	r24, 0x0844
    1a00:	82 17       	cp	r24, r18
    1a02:	10 f4       	brcc	.+4      	; 0x1a08 <xTaskIncrementTick+0xea>
    1a04:	20 93 44 08 	sts	0x0844, r18
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	c9 01       	movw	r24, r18
    1a0c:	88 0f       	add	r24, r24
    1a0e:	99 1f       	adc	r25, r25
    1a10:	88 0f       	add	r24, r24
    1a12:	99 1f       	adc	r25, r25
    1a14:	88 0f       	add	r24, r24
    1a16:	99 1f       	adc	r25, r25
    1a18:	82 0f       	add	r24, r18
    1a1a:	93 1f       	adc	r25, r19
    1a1c:	b8 01       	movw	r22, r16
    1a1e:	86 58       	subi	r24, 0x86	; 134
    1a20:	97 4f       	sbci	r25, 0xF7	; 247
    1a22:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1a26:	e0 91 a7 08 	lds	r30, 0x08A7
    1a2a:	f0 91 a8 08 	lds	r31, 0x08A8
    1a2e:	9e 89       	ldd	r25, Y+22	; 0x16
    1a30:	86 89       	ldd	r24, Z+22	; 0x16
    1a32:	98 17       	cp	r25, r24
    1a34:	08 f0       	brcs	.+2      	; 0x1a38 <xTaskIncrementTick+0x11a>
    1a36:	b1 cf       	rjmp	.-158    	; 0x199a <xTaskIncrementTick+0x7c>
    1a38:	b1 cf       	rjmp	.-158    	; 0x199c <xTaskIncrementTick+0x7e>
    1a3a:	d1 2c       	mov	r13, r1
    1a3c:	e0 91 a7 08 	lds	r30, 0x08A7
    1a40:	f0 91 a8 08 	lds	r31, 0x08A8
    1a44:	86 89       	ldd	r24, Z+22	; 0x16
    1a46:	90 e0       	ldi	r25, 0x00	; 0
    1a48:	fc 01       	movw	r30, r24
    1a4a:	ee 0f       	add	r30, r30
    1a4c:	ff 1f       	adc	r31, r31
    1a4e:	ee 0f       	add	r30, r30
    1a50:	ff 1f       	adc	r31, r31
    1a52:	ee 0f       	add	r30, r30
    1a54:	ff 1f       	adc	r31, r31
    1a56:	8e 0f       	add	r24, r30
    1a58:	9f 1f       	adc	r25, r31
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	e6 58       	subi	r30, 0x86	; 134
    1a5e:	f7 4f       	sbci	r31, 0xF7	; 247
    1a60:	80 81       	ld	r24, Z
    1a62:	82 30       	cpi	r24, 0x02	; 2
    1a64:	40 f4       	brcc	.+16     	; 0x1a76 <xTaskIncrementTick+0x158>
    1a66:	09 c0       	rjmp	.+18     	; 0x1a7a <xTaskIncrementTick+0x15c>
    1a68:	80 91 42 08 	lds	r24, 0x0842
    1a6c:	8f 5f       	subi	r24, 0xFF	; 255
    1a6e:	80 93 42 08 	sts	0x0842, r24
    1a72:	d1 2c       	mov	r13, r1
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <xTaskIncrementTick+0x15c>
    1a76:	dd 24       	eor	r13, r13
    1a78:	d3 94       	inc	r13
    1a7a:	80 91 41 08 	lds	r24, 0x0841
    1a7e:	88 23       	and	r24, r24
    1a80:	11 f0       	breq	.+4      	; 0x1a86 <xTaskIncrementTick+0x168>
    1a82:	dd 24       	eor	r13, r13
    1a84:	d3 94       	inc	r13
    1a86:	8d 2d       	mov	r24, r13
    1a88:	df 91       	pop	r29
    1a8a:	cf 91       	pop	r28
    1a8c:	1f 91       	pop	r17
    1a8e:	0f 91       	pop	r16
    1a90:	ff 90       	pop	r15
    1a92:	ef 90       	pop	r14
    1a94:	df 90       	pop	r13
    1a96:	cf 90       	pop	r12
    1a98:	08 95       	ret

00001a9a <xTaskResumeAll>:
    1a9a:	df 92       	push	r13
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	0f 93       	push	r16
    1aa2:	1f 93       	push	r17
    1aa4:	cf 93       	push	r28
    1aa6:	df 93       	push	r29
    1aa8:	0f b6       	in	r0, 0x3f	; 63
    1aaa:	f8 94       	cli
    1aac:	0f 92       	push	r0
    1aae:	80 91 3e 08 	lds	r24, 0x083E
    1ab2:	81 50       	subi	r24, 0x01	; 1
    1ab4:	80 93 3e 08 	sts	0x083E, r24
    1ab8:	80 91 3e 08 	lds	r24, 0x083E
    1abc:	81 11       	cpse	r24, r1
    1abe:	5f c0       	rjmp	.+190    	; 0x1b7e <xTaskResumeAll+0xe4>
    1ac0:	80 91 47 08 	lds	r24, 0x0847
    1ac4:	88 23       	and	r24, r24
    1ac6:	09 f4       	brne	.+2      	; 0x1aca <xTaskResumeAll+0x30>
    1ac8:	5c c0       	rjmp	.+184    	; 0x1b82 <xTaskResumeAll+0xe8>
    1aca:	0f 2e       	mov	r0, r31
    1acc:	fb e5       	ldi	r31, 0x5B	; 91
    1ace:	ef 2e       	mov	r14, r31
    1ad0:	f8 e0       	ldi	r31, 0x08	; 8
    1ad2:	ff 2e       	mov	r15, r31
    1ad4:	f0 2d       	mov	r31, r0
    1ad6:	dd 24       	eor	r13, r13
    1ad8:	d3 94       	inc	r13
    1ada:	30 c0       	rjmp	.+96     	; 0x1b3c <xTaskResumeAll+0xa2>
    1adc:	e0 91 60 08 	lds	r30, 0x0860
    1ae0:	f0 91 61 08 	lds	r31, 0x0861
    1ae4:	c6 81       	ldd	r28, Z+6	; 0x06
    1ae6:	d7 81       	ldd	r29, Z+7	; 0x07
    1ae8:	ce 01       	movw	r24, r28
    1aea:	0c 96       	adiw	r24, 0x0c	; 12
    1aec:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1af0:	8e 01       	movw	r16, r28
    1af2:	0e 5f       	subi	r16, 0xFE	; 254
    1af4:	1f 4f       	sbci	r17, 0xFF	; 255
    1af6:	c8 01       	movw	r24, r16
    1af8:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1afc:	8e 89       	ldd	r24, Y+22	; 0x16
    1afe:	90 91 44 08 	lds	r25, 0x0844
    1b02:	98 17       	cp	r25, r24
    1b04:	10 f4       	brcc	.+4      	; 0x1b0a <xTaskResumeAll+0x70>
    1b06:	80 93 44 08 	sts	0x0844, r24
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	9c 01       	movw	r18, r24
    1b0e:	22 0f       	add	r18, r18
    1b10:	33 1f       	adc	r19, r19
    1b12:	22 0f       	add	r18, r18
    1b14:	33 1f       	adc	r19, r19
    1b16:	22 0f       	add	r18, r18
    1b18:	33 1f       	adc	r19, r19
    1b1a:	82 0f       	add	r24, r18
    1b1c:	93 1f       	adc	r25, r19
    1b1e:	b8 01       	movw	r22, r16
    1b20:	86 58       	subi	r24, 0x86	; 134
    1b22:	97 4f       	sbci	r25, 0xF7	; 247
    1b24:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1b28:	e0 91 a7 08 	lds	r30, 0x08A7
    1b2c:	f0 91 a8 08 	lds	r31, 0x08A8
    1b30:	9e 89       	ldd	r25, Y+22	; 0x16
    1b32:	86 89       	ldd	r24, Z+22	; 0x16
    1b34:	98 17       	cp	r25, r24
    1b36:	10 f0       	brcs	.+4      	; 0x1b3c <xTaskResumeAll+0xa2>
    1b38:	d0 92 41 08 	sts	0x0841, r13
    1b3c:	f7 01       	movw	r30, r14
    1b3e:	80 81       	ld	r24, Z
    1b40:	81 11       	cpse	r24, r1
    1b42:	cc cf       	rjmp	.-104    	; 0x1adc <xTaskResumeAll+0x42>
    1b44:	80 91 42 08 	lds	r24, 0x0842
    1b48:	88 23       	and	r24, r24
    1b4a:	91 f0       	breq	.+36     	; 0x1b70 <xTaskResumeAll+0xd6>
    1b4c:	80 91 42 08 	lds	r24, 0x0842
    1b50:	88 23       	and	r24, r24
    1b52:	71 f0       	breq	.+28     	; 0x1b70 <xTaskResumeAll+0xd6>
    1b54:	c1 e0       	ldi	r28, 0x01	; 1
    1b56:	e3 de       	rcall	.-570    	; 0x191e <xTaskIncrementTick>
    1b58:	81 11       	cpse	r24, r1
    1b5a:	c0 93 41 08 	sts	0x0841, r28
    1b5e:	80 91 42 08 	lds	r24, 0x0842
    1b62:	81 50       	subi	r24, 0x01	; 1
    1b64:	80 93 42 08 	sts	0x0842, r24
    1b68:	80 91 42 08 	lds	r24, 0x0842
    1b6c:	81 11       	cpse	r24, r1
    1b6e:	f3 cf       	rjmp	.-26     	; 0x1b56 <xTaskResumeAll+0xbc>
    1b70:	80 91 41 08 	lds	r24, 0x0841
    1b74:	81 30       	cpi	r24, 0x01	; 1
    1b76:	39 f4       	brne	.+14     	; 0x1b86 <xTaskResumeAll+0xec>
    1b78:	0f d9       	rcall	.-3554   	; 0xd98 <vPortYield>
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	05 c0       	rjmp	.+10     	; 0x1b88 <xTaskResumeAll+0xee>
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
    1b80:	03 c0       	rjmp	.+6      	; 0x1b88 <xTaskResumeAll+0xee>
    1b82:	80 e0       	ldi	r24, 0x00	; 0
    1b84:	01 c0       	rjmp	.+2      	; 0x1b88 <xTaskResumeAll+0xee>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	0f 90       	pop	r0
    1b8a:	0f be       	out	0x3f, r0	; 63
    1b8c:	df 91       	pop	r29
    1b8e:	cf 91       	pop	r28
    1b90:	1f 91       	pop	r17
    1b92:	0f 91       	pop	r16
    1b94:	ff 90       	pop	r15
    1b96:	ef 90       	pop	r14
    1b98:	df 90       	pop	r13
    1b9a:	08 95       	ret

00001b9c <vTaskDelayUntil>:
    1b9c:	0f 93       	push	r16
    1b9e:	1f 93       	push	r17
    1ba0:	cf 93       	push	r28
    1ba2:	df 93       	push	r29
    1ba4:	8c 01       	movw	r16, r24
    1ba6:	eb 01       	movw	r28, r22
    1ba8:	a5 de       	rcall	.-694    	; 0x18f4 <vTaskSuspendAll>
    1baa:	80 91 45 08 	lds	r24, 0x0845
    1bae:	90 91 46 08 	lds	r25, 0x0846
    1bb2:	f8 01       	movw	r30, r16
    1bb4:	20 81       	ld	r18, Z
    1bb6:	31 81       	ldd	r19, Z+1	; 0x01
    1bb8:	c2 0f       	add	r28, r18
    1bba:	d3 1f       	adc	r29, r19
    1bbc:	82 17       	cp	r24, r18
    1bbe:	93 07       	cpc	r25, r19
    1bc0:	48 f4       	brcc	.+18     	; 0x1bd4 <vTaskDelayUntil+0x38>
    1bc2:	c2 17       	cp	r28, r18
    1bc4:	d3 07       	cpc	r29, r19
    1bc6:	f8 f4       	brcc	.+62     	; 0x1c06 <vTaskDelayUntil+0x6a>
    1bc8:	d1 83       	std	Z+1, r29	; 0x01
    1bca:	c0 83       	st	Z, r28
    1bcc:	8c 17       	cp	r24, r28
    1bce:	9d 07       	cpc	r25, r29
    1bd0:	88 f4       	brcc	.+34     	; 0x1bf4 <vTaskDelayUntil+0x58>
    1bd2:	07 c0       	rjmp	.+14     	; 0x1be2 <vTaskDelayUntil+0x46>
    1bd4:	c2 17       	cp	r28, r18
    1bd6:	d3 07       	cpc	r29, r19
    1bd8:	90 f0       	brcs	.+36     	; 0x1bfe <vTaskDelayUntil+0x62>
    1bda:	8c 17       	cp	r24, r28
    1bdc:	9d 07       	cpc	r25, r29
    1bde:	78 f0       	brcs	.+30     	; 0x1bfe <vTaskDelayUntil+0x62>
    1be0:	12 c0       	rjmp	.+36     	; 0x1c06 <vTaskDelayUntil+0x6a>
    1be2:	80 91 a7 08 	lds	r24, 0x08A7
    1be6:	90 91 a8 08 	lds	r25, 0x08A8
    1bea:	02 96       	adiw	r24, 0x02	; 2
    1bec:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	c0 dc       	rcall	.-1664   	; 0x1574 <prvAddCurrentTaskToDelayedList>
    1bf4:	52 df       	rcall	.-348    	; 0x1a9a <xTaskResumeAll>
    1bf6:	81 11       	cpse	r24, r1
    1bf8:	0a c0       	rjmp	.+20     	; 0x1c0e <vTaskDelayUntil+0x72>
    1bfa:	ce d8       	rcall	.-3684   	; 0xd98 <vPortYield>
    1bfc:	08 c0       	rjmp	.+16     	; 0x1c0e <vTaskDelayUntil+0x72>
    1bfe:	f8 01       	movw	r30, r16
    1c00:	d1 83       	std	Z+1, r29	; 0x01
    1c02:	c0 83       	st	Z, r28
    1c04:	ee cf       	rjmp	.-36     	; 0x1be2 <vTaskDelayUntil+0x46>
    1c06:	f8 01       	movw	r30, r16
    1c08:	d1 83       	std	Z+1, r29	; 0x01
    1c0a:	c0 83       	st	Z, r28
    1c0c:	f3 cf       	rjmp	.-26     	; 0x1bf4 <vTaskDelayUntil+0x58>
    1c0e:	df 91       	pop	r29
    1c10:	cf 91       	pop	r28
    1c12:	1f 91       	pop	r17
    1c14:	0f 91       	pop	r16
    1c16:	08 95       	ret

00001c18 <prvIdleTask>:
    1c18:	0f 2e       	mov	r0, r31
    1c1a:	fa e7       	ldi	r31, 0x7A	; 122
    1c1c:	ef 2e       	mov	r14, r31
    1c1e:	f8 e0       	ldi	r31, 0x08	; 8
    1c20:	ff 2e       	mov	r15, r31
    1c22:	f0 2d       	mov	r31, r0
    1c24:	c2 e5       	ldi	r28, 0x52	; 82
    1c26:	d8 e0       	ldi	r29, 0x08	; 8
    1c28:	26 c0       	rjmp	.+76     	; 0x1c76 <prvIdleTask+0x5e>
    1c2a:	64 de       	rcall	.-824    	; 0x18f4 <vTaskSuspendAll>
    1c2c:	18 81       	ld	r17, Y
    1c2e:	35 df       	rcall	.-406    	; 0x1a9a <xTaskResumeAll>
    1c30:	11 23       	and	r17, r17
    1c32:	09 f1       	breq	.+66     	; 0x1c76 <prvIdleTask+0x5e>
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	0f 92       	push	r0
    1c3a:	e0 91 57 08 	lds	r30, 0x0857
    1c3e:	f0 91 58 08 	lds	r31, 0x0858
    1c42:	06 81       	ldd	r16, Z+6	; 0x06
    1c44:	17 81       	ldd	r17, Z+7	; 0x07
    1c46:	c8 01       	movw	r24, r16
    1c48:	02 96       	adiw	r24, 0x02	; 2
    1c4a:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1c4e:	80 91 47 08 	lds	r24, 0x0847
    1c52:	81 50       	subi	r24, 0x01	; 1
    1c54:	80 93 47 08 	sts	0x0847, r24
    1c58:	80 91 51 08 	lds	r24, 0x0851
    1c5c:	81 50       	subi	r24, 0x01	; 1
    1c5e:	80 93 51 08 	sts	0x0851, r24
    1c62:	0f 90       	pop	r0
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	f8 01       	movw	r30, r16
    1c68:	87 89       	ldd	r24, Z+23	; 0x17
    1c6a:	90 8d       	ldd	r25, Z+24	; 0x18
    1c6c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortFree>
    1c70:	c8 01       	movw	r24, r16
    1c72:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortFree>
    1c76:	80 91 51 08 	lds	r24, 0x0851
    1c7a:	81 11       	cpse	r24, r1
    1c7c:	d6 cf       	rjmp	.-84     	; 0x1c2a <prvIdleTask+0x12>
    1c7e:	f7 01       	movw	r30, r14
    1c80:	80 81       	ld	r24, Z
    1c82:	82 30       	cpi	r24, 0x02	; 2
    1c84:	c0 f3       	brcs	.-16     	; 0x1c76 <prvIdleTask+0x5e>
    1c86:	88 d8       	rcall	.-3824   	; 0xd98 <vPortYield>
    1c88:	f6 cf       	rjmp	.-20     	; 0x1c76 <prvIdleTask+0x5e>

00001c8a <vTaskSwitchContext>:
    1c8a:	80 91 3e 08 	lds	r24, 0x083E
    1c8e:	88 23       	and	r24, r24
    1c90:	21 f0       	breq	.+8      	; 0x1c9a <vTaskSwitchContext+0x10>
    1c92:	81 e0       	ldi	r24, 0x01	; 1
    1c94:	80 93 41 08 	sts	0x0841, r24
    1c98:	08 95       	ret
    1c9a:	10 92 41 08 	sts	0x0841, r1
    1c9e:	80 91 44 08 	lds	r24, 0x0844
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	ee 0f       	add	r30, r30
    1ca8:	ff 1f       	adc	r31, r31
    1caa:	ee 0f       	add	r30, r30
    1cac:	ff 1f       	adc	r31, r31
    1cae:	ee 0f       	add	r30, r30
    1cb0:	ff 1f       	adc	r31, r31
    1cb2:	8e 0f       	add	r24, r30
    1cb4:	9f 1f       	adc	r25, r31
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	e6 58       	subi	r30, 0x86	; 134
    1cba:	f7 4f       	sbci	r31, 0xF7	; 247
    1cbc:	80 81       	ld	r24, Z
    1cbe:	81 11       	cpse	r24, r1
    1cc0:	17 c0       	rjmp	.+46     	; 0x1cf0 <vTaskSwitchContext+0x66>
    1cc2:	80 91 44 08 	lds	r24, 0x0844
    1cc6:	81 50       	subi	r24, 0x01	; 1
    1cc8:	80 93 44 08 	sts	0x0844, r24
    1ccc:	80 91 44 08 	lds	r24, 0x0844
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	fc 01       	movw	r30, r24
    1cd4:	ee 0f       	add	r30, r30
    1cd6:	ff 1f       	adc	r31, r31
    1cd8:	ee 0f       	add	r30, r30
    1cda:	ff 1f       	adc	r31, r31
    1cdc:	ee 0f       	add	r30, r30
    1cde:	ff 1f       	adc	r31, r31
    1ce0:	8e 0f       	add	r24, r30
    1ce2:	9f 1f       	adc	r25, r31
    1ce4:	fc 01       	movw	r30, r24
    1ce6:	e6 58       	subi	r30, 0x86	; 134
    1ce8:	f7 4f       	sbci	r31, 0xF7	; 247
    1cea:	80 81       	ld	r24, Z
    1cec:	88 23       	and	r24, r24
    1cee:	49 f3       	breq	.-46     	; 0x1cc2 <vTaskSwitchContext+0x38>
    1cf0:	e0 91 44 08 	lds	r30, 0x0844
    1cf4:	f0 e0       	ldi	r31, 0x00	; 0
    1cf6:	cf 01       	movw	r24, r30
    1cf8:	88 0f       	add	r24, r24
    1cfa:	99 1f       	adc	r25, r25
    1cfc:	88 0f       	add	r24, r24
    1cfe:	99 1f       	adc	r25, r25
    1d00:	88 0f       	add	r24, r24
    1d02:	99 1f       	adc	r25, r25
    1d04:	e8 0f       	add	r30, r24
    1d06:	f9 1f       	adc	r31, r25
    1d08:	e6 58       	subi	r30, 0x86	; 134
    1d0a:	f7 4f       	sbci	r31, 0xF7	; 247
    1d0c:	a1 81       	ldd	r26, Z+1	; 0x01
    1d0e:	b2 81       	ldd	r27, Z+2	; 0x02
    1d10:	12 96       	adiw	r26, 0x02	; 2
    1d12:	0d 90       	ld	r0, X+
    1d14:	bc 91       	ld	r27, X
    1d16:	a0 2d       	mov	r26, r0
    1d18:	b2 83       	std	Z+2, r27	; 0x02
    1d1a:	a1 83       	std	Z+1, r26	; 0x01
    1d1c:	cf 01       	movw	r24, r30
    1d1e:	03 96       	adiw	r24, 0x03	; 3
    1d20:	a8 17       	cp	r26, r24
    1d22:	b9 07       	cpc	r27, r25
    1d24:	31 f4       	brne	.+12     	; 0x1d32 <vTaskSwitchContext+0xa8>
    1d26:	12 96       	adiw	r26, 0x02	; 2
    1d28:	8d 91       	ld	r24, X+
    1d2a:	9c 91       	ld	r25, X
    1d2c:	13 97       	sbiw	r26, 0x03	; 3
    1d2e:	92 83       	std	Z+2, r25	; 0x02
    1d30:	81 83       	std	Z+1, r24	; 0x01
    1d32:	01 80       	ldd	r0, Z+1	; 0x01
    1d34:	f2 81       	ldd	r31, Z+2	; 0x02
    1d36:	e0 2d       	mov	r30, r0
    1d38:	86 81       	ldd	r24, Z+6	; 0x06
    1d3a:	97 81       	ldd	r25, Z+7	; 0x07
    1d3c:	90 93 a8 08 	sts	0x08A8, r25
    1d40:	80 93 a7 08 	sts	0x08A7, r24
    1d44:	08 95       	ret

00001d46 <vTaskSuspend>:
    1d46:	0f 93       	push	r16
    1d48:	1f 93       	push	r17
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	ec 01       	movw	r28, r24
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	0f 92       	push	r0
    1d56:	00 97       	sbiw	r24, 0x00	; 0
    1d58:	21 f4       	brne	.+8      	; 0x1d62 <vTaskSuspend+0x1c>
    1d5a:	c0 91 a7 08 	lds	r28, 0x08A7
    1d5e:	d0 91 a8 08 	lds	r29, 0x08A8
    1d62:	8e 01       	movw	r16, r28
    1d64:	0e 5f       	subi	r16, 0xFE	; 254
    1d66:	1f 4f       	sbci	r17, 0xFF	; 255
    1d68:	c8 01       	movw	r24, r16
    1d6a:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1d6e:	8c 89       	ldd	r24, Y+20	; 0x14
    1d70:	9d 89       	ldd	r25, Y+21	; 0x15
    1d72:	89 2b       	or	r24, r25
    1d74:	21 f0       	breq	.+8      	; 0x1d7e <vTaskSuspend+0x38>
    1d76:	ce 01       	movw	r24, r28
    1d78:	0c 96       	adiw	r24, 0x0c	; 12
    1d7a:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1d7e:	b8 01       	movw	r22, r16
    1d80:	88 e4       	ldi	r24, 0x48	; 72
    1d82:	98 e0       	ldi	r25, 0x08	; 8
    1d84:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1d88:	0f 90       	pop	r0
    1d8a:	0f be       	out	0x3f, r0	; 63
    1d8c:	80 91 a7 08 	lds	r24, 0x08A7
    1d90:	90 91 a8 08 	lds	r25, 0x08A8
    1d94:	c8 17       	cp	r28, r24
    1d96:	d9 07       	cpc	r29, r25
    1d98:	a1 f4       	brne	.+40     	; 0x1dc2 <vTaskSuspend+0x7c>
    1d9a:	80 91 43 08 	lds	r24, 0x0843
    1d9e:	88 23       	and	r24, r24
    1da0:	19 f0       	breq	.+6      	; 0x1da8 <vTaskSuspend+0x62>
    1da2:	0e 94 cc 06 	call	0xd98	; 0xd98 <vPortYield>
    1da6:	17 c0       	rjmp	.+46     	; 0x1dd6 <vTaskSuspend+0x90>
    1da8:	80 91 47 08 	lds	r24, 0x0847
    1dac:	90 91 48 08 	lds	r25, 0x0848
    1db0:	98 13       	cpse	r25, r24
    1db2:	05 c0       	rjmp	.+10     	; 0x1dbe <vTaskSuspend+0x78>
    1db4:	10 92 a8 08 	sts	0x08A8, r1
    1db8:	10 92 a7 08 	sts	0x08A7, r1
    1dbc:	0c c0       	rjmp	.+24     	; 0x1dd6 <vTaskSuspend+0x90>
    1dbe:	65 df       	rcall	.-310    	; 0x1c8a <vTaskSwitchContext>
    1dc0:	0a c0       	rjmp	.+20     	; 0x1dd6 <vTaskSuspend+0x90>
    1dc2:	80 91 43 08 	lds	r24, 0x0843
    1dc6:	88 23       	and	r24, r24
    1dc8:	31 f0       	breq	.+12     	; 0x1dd6 <vTaskSuspend+0x90>
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	0f 92       	push	r0
    1dd0:	b2 db       	rcall	.-2204   	; 0x1536 <prvResetNextTaskUnblockTime>
    1dd2:	0f 90       	pop	r0
    1dd4:	0f be       	out	0x3f, r0	; 63
    1dd6:	df 91       	pop	r29
    1dd8:	cf 91       	pop	r28
    1dda:	1f 91       	pop	r17
    1ddc:	0f 91       	pop	r16
    1dde:	08 95       	ret

00001de0 <vTaskPlaceOnEventList>:
    1de0:	cf 93       	push	r28
    1de2:	df 93       	push	r29
    1de4:	eb 01       	movw	r28, r22
    1de6:	60 91 a7 08 	lds	r22, 0x08A7
    1dea:	70 91 a8 08 	lds	r23, 0x08A8
    1dee:	64 5f       	subi	r22, 0xF4	; 244
    1df0:	7f 4f       	sbci	r23, 0xFF	; 255
    1df2:	0e 94 0e 02 	call	0x41c	; 0x41c <vListInsert>
    1df6:	80 91 a7 08 	lds	r24, 0x08A7
    1dfa:	90 91 a8 08 	lds	r25, 0x08A8
    1dfe:	02 96       	adiw	r24, 0x02	; 2
    1e00:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1e04:	cf 3f       	cpi	r28, 0xFF	; 255
    1e06:	8f ef       	ldi	r24, 0xFF	; 255
    1e08:	d8 07       	cpc	r29, r24
    1e0a:	59 f4       	brne	.+22     	; 0x1e22 <vTaskPlaceOnEventList+0x42>
    1e0c:	60 91 a7 08 	lds	r22, 0x08A7
    1e10:	70 91 a8 08 	lds	r23, 0x08A8
    1e14:	6e 5f       	subi	r22, 0xFE	; 254
    1e16:	7f 4f       	sbci	r23, 0xFF	; 255
    1e18:	88 e4       	ldi	r24, 0x48	; 72
    1e1a:	98 e0       	ldi	r25, 0x08	; 8
    1e1c:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1e20:	07 c0       	rjmp	.+14     	; 0x1e30 <vTaskPlaceOnEventList+0x50>
    1e22:	80 91 45 08 	lds	r24, 0x0845
    1e26:	90 91 46 08 	lds	r25, 0x0846
    1e2a:	8c 0f       	add	r24, r28
    1e2c:	9d 1f       	adc	r25, r29
    1e2e:	a2 db       	rcall	.-2236   	; 0x1574 <prvAddCurrentTaskToDelayedList>
    1e30:	df 91       	pop	r29
    1e32:	cf 91       	pop	r28
    1e34:	08 95       	ret

00001e36 <xTaskRemoveFromEventList>:
    1e36:	0f 93       	push	r16
    1e38:	1f 93       	push	r17
    1e3a:	cf 93       	push	r28
    1e3c:	df 93       	push	r29
    1e3e:	dc 01       	movw	r26, r24
    1e40:	15 96       	adiw	r26, 0x05	; 5
    1e42:	ed 91       	ld	r30, X+
    1e44:	fc 91       	ld	r31, X
    1e46:	16 97       	sbiw	r26, 0x06	; 6
    1e48:	c6 81       	ldd	r28, Z+6	; 0x06
    1e4a:	d7 81       	ldd	r29, Z+7	; 0x07
    1e4c:	8e 01       	movw	r16, r28
    1e4e:	04 5f       	subi	r16, 0xF4	; 244
    1e50:	1f 4f       	sbci	r17, 0xFF	; 255
    1e52:	c8 01       	movw	r24, r16
    1e54:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1e58:	80 91 3e 08 	lds	r24, 0x083E
    1e5c:	81 11       	cpse	r24, r1
    1e5e:	1c c0       	rjmp	.+56     	; 0x1e98 <xTaskRemoveFromEventList+0x62>
    1e60:	0a 50       	subi	r16, 0x0A	; 10
    1e62:	11 09       	sbc	r17, r1
    1e64:	c8 01       	movw	r24, r16
    1e66:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1e6a:	8e 89       	ldd	r24, Y+22	; 0x16
    1e6c:	90 91 44 08 	lds	r25, 0x0844
    1e70:	98 17       	cp	r25, r24
    1e72:	10 f4       	brcc	.+4      	; 0x1e78 <xTaskRemoveFromEventList+0x42>
    1e74:	80 93 44 08 	sts	0x0844, r24
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	9c 01       	movw	r18, r24
    1e7c:	22 0f       	add	r18, r18
    1e7e:	33 1f       	adc	r19, r19
    1e80:	22 0f       	add	r18, r18
    1e82:	33 1f       	adc	r19, r19
    1e84:	22 0f       	add	r18, r18
    1e86:	33 1f       	adc	r19, r19
    1e88:	82 0f       	add	r24, r18
    1e8a:	93 1f       	adc	r25, r19
    1e8c:	b8 01       	movw	r22, r16
    1e8e:	86 58       	subi	r24, 0x86	; 134
    1e90:	97 4f       	sbci	r25, 0xF7	; 247
    1e92:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1e96:	05 c0       	rjmp	.+10     	; 0x1ea2 <xTaskRemoveFromEventList+0x6c>
    1e98:	b8 01       	movw	r22, r16
    1e9a:	8b e5       	ldi	r24, 0x5B	; 91
    1e9c:	98 e0       	ldi	r25, 0x08	; 8
    1e9e:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1ea2:	e0 91 a7 08 	lds	r30, 0x08A7
    1ea6:	f0 91 a8 08 	lds	r31, 0x08A8
    1eaa:	9e 89       	ldd	r25, Y+22	; 0x16
    1eac:	86 89       	ldd	r24, Z+22	; 0x16
    1eae:	89 17       	cp	r24, r25
    1eb0:	20 f4       	brcc	.+8      	; 0x1eba <xTaskRemoveFromEventList+0x84>
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	80 93 41 08 	sts	0x0841, r24
    1eb8:	01 c0       	rjmp	.+2      	; 0x1ebc <xTaskRemoveFromEventList+0x86>
    1eba:	80 e0       	ldi	r24, 0x00	; 0
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	1f 91       	pop	r17
    1ec2:	0f 91       	pop	r16
    1ec4:	08 95       	ret

00001ec6 <vTaskSetTimeOutState>:
    1ec6:	20 91 40 08 	lds	r18, 0x0840
    1eca:	fc 01       	movw	r30, r24
    1ecc:	20 83       	st	Z, r18
    1ece:	20 91 45 08 	lds	r18, 0x0845
    1ed2:	30 91 46 08 	lds	r19, 0x0846
    1ed6:	32 83       	std	Z+2, r19	; 0x02
    1ed8:	21 83       	std	Z+1, r18	; 0x01
    1eda:	08 95       	ret

00001edc <xTaskCheckForTimeOut>:
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	f8 94       	cli
    1ee0:	0f 92       	push	r0
    1ee2:	40 91 45 08 	lds	r20, 0x0845
    1ee6:	50 91 46 08 	lds	r21, 0x0846
    1eea:	db 01       	movw	r26, r22
    1eec:	2d 91       	ld	r18, X+
    1eee:	3c 91       	ld	r19, X
    1ef0:	2f 3f       	cpi	r18, 0xFF	; 255
    1ef2:	bf ef       	ldi	r27, 0xFF	; 255
    1ef4:	3b 07       	cpc	r19, r27
    1ef6:	11 f1       	breq	.+68     	; 0x1f3c <xTaskCheckForTimeOut+0x60>
    1ef8:	e0 91 40 08 	lds	r30, 0x0840
    1efc:	dc 01       	movw	r26, r24
    1efe:	fc 91       	ld	r31, X
    1f00:	fe 17       	cp	r31, r30
    1f02:	39 f0       	breq	.+14     	; 0x1f12 <xTaskCheckForTimeOut+0x36>
    1f04:	11 96       	adiw	r26, 0x01	; 1
    1f06:	ed 91       	ld	r30, X+
    1f08:	fc 91       	ld	r31, X
    1f0a:	12 97       	sbiw	r26, 0x02	; 2
    1f0c:	4e 17       	cp	r20, r30
    1f0e:	5f 07       	cpc	r21, r31
    1f10:	b8 f4       	brcc	.+46     	; 0x1f40 <xTaskCheckForTimeOut+0x64>
    1f12:	dc 01       	movw	r26, r24
    1f14:	11 96       	adiw	r26, 0x01	; 1
    1f16:	ed 91       	ld	r30, X+
    1f18:	fc 91       	ld	r31, X
    1f1a:	12 97       	sbiw	r26, 0x02	; 2
    1f1c:	da 01       	movw	r26, r20
    1f1e:	ae 1b       	sub	r26, r30
    1f20:	bf 0b       	sbc	r27, r31
    1f22:	a2 17       	cp	r26, r18
    1f24:	b3 07       	cpc	r27, r19
    1f26:	70 f4       	brcc	.+28     	; 0x1f44 <xTaskCheckForTimeOut+0x68>
    1f28:	e4 1b       	sub	r30, r20
    1f2a:	f5 0b       	sbc	r31, r21
    1f2c:	2e 0f       	add	r18, r30
    1f2e:	3f 1f       	adc	r19, r31
    1f30:	fb 01       	movw	r30, r22
    1f32:	31 83       	std	Z+1, r19	; 0x01
    1f34:	20 83       	st	Z, r18
    1f36:	c7 df       	rcall	.-114    	; 0x1ec6 <vTaskSetTimeOutState>
    1f38:	80 e0       	ldi	r24, 0x00	; 0
    1f3a:	05 c0       	rjmp	.+10     	; 0x1f46 <xTaskCheckForTimeOut+0x6a>
    1f3c:	80 e0       	ldi	r24, 0x00	; 0
    1f3e:	03 c0       	rjmp	.+6      	; 0x1f46 <xTaskCheckForTimeOut+0x6a>
    1f40:	81 e0       	ldi	r24, 0x01	; 1
    1f42:	01 c0       	rjmp	.+2      	; 0x1f46 <xTaskCheckForTimeOut+0x6a>
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	0f 90       	pop	r0
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	08 95       	ret

00001f4c <vTaskMissedYield>:
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	80 93 41 08 	sts	0x0841, r24
    1f52:	08 95       	ret

00001f54 <vTaskPriorityInherit>:
    1f54:	0f 93       	push	r16
    1f56:	1f 93       	push	r17
    1f58:	cf 93       	push	r28
    1f5a:	df 93       	push	r29
    1f5c:	ec 01       	movw	r28, r24
    1f5e:	00 97       	sbiw	r24, 0x00	; 0
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <vTaskPriorityInherit+0x10>
    1f62:	51 c0       	rjmp	.+162    	; 0x2006 <vTaskPriorityInherit+0xb2>
    1f64:	8e 89       	ldd	r24, Y+22	; 0x16
    1f66:	e0 91 a7 08 	lds	r30, 0x08A7
    1f6a:	f0 91 a8 08 	lds	r31, 0x08A8
    1f6e:	96 89       	ldd	r25, Z+22	; 0x16
    1f70:	89 17       	cp	r24, r25
    1f72:	08 f0       	brcs	.+2      	; 0x1f76 <vTaskPriorityInherit+0x22>
    1f74:	48 c0       	rjmp	.+144    	; 0x2006 <vTaskPriorityInherit+0xb2>
    1f76:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f78:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f7a:	33 23       	and	r19, r19
    1f7c:	5c f0       	brlt	.+22     	; 0x1f94 <vTaskPriorityInherit+0x40>
    1f7e:	e0 91 a7 08 	lds	r30, 0x08A7
    1f82:	f0 91 a8 08 	lds	r31, 0x08A8
    1f86:	96 89       	ldd	r25, Z+22	; 0x16
    1f88:	25 e0       	ldi	r18, 0x05	; 5
    1f8a:	30 e0       	ldi	r19, 0x00	; 0
    1f8c:	29 1b       	sub	r18, r25
    1f8e:	31 09       	sbc	r19, r1
    1f90:	3d 87       	std	Y+13, r19	; 0x0d
    1f92:	2c 87       	std	Y+12, r18	; 0x0c
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	9c 01       	movw	r18, r24
    1f98:	22 0f       	add	r18, r18
    1f9a:	33 1f       	adc	r19, r19
    1f9c:	22 0f       	add	r18, r18
    1f9e:	33 1f       	adc	r19, r19
    1fa0:	22 0f       	add	r18, r18
    1fa2:	33 1f       	adc	r19, r19
    1fa4:	82 0f       	add	r24, r18
    1fa6:	93 1f       	adc	r25, r19
    1fa8:	86 58       	subi	r24, 0x86	; 134
    1faa:	97 4f       	sbci	r25, 0xF7	; 247
    1fac:	2a 85       	ldd	r18, Y+10	; 0x0a
    1fae:	3b 85       	ldd	r19, Y+11	; 0x0b
    1fb0:	28 17       	cp	r18, r24
    1fb2:	39 07       	cpc	r19, r25
    1fb4:	11 f5       	brne	.+68     	; 0x1ffa <vTaskPriorityInherit+0xa6>
    1fb6:	8e 01       	movw	r16, r28
    1fb8:	0e 5f       	subi	r16, 0xFE	; 254
    1fba:	1f 4f       	sbci	r17, 0xFF	; 255
    1fbc:	c8 01       	movw	r24, r16
    1fbe:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    1fc2:	e0 91 a7 08 	lds	r30, 0x08A7
    1fc6:	f0 91 a8 08 	lds	r31, 0x08A8
    1fca:	86 89       	ldd	r24, Z+22	; 0x16
    1fcc:	8e 8b       	std	Y+22, r24	; 0x16
    1fce:	90 91 44 08 	lds	r25, 0x0844
    1fd2:	98 17       	cp	r25, r24
    1fd4:	10 f4       	brcc	.+4      	; 0x1fda <vTaskPriorityInherit+0x86>
    1fd6:	80 93 44 08 	sts	0x0844, r24
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	9c 01       	movw	r18, r24
    1fde:	22 0f       	add	r18, r18
    1fe0:	33 1f       	adc	r19, r19
    1fe2:	22 0f       	add	r18, r18
    1fe4:	33 1f       	adc	r19, r19
    1fe6:	22 0f       	add	r18, r18
    1fe8:	33 1f       	adc	r19, r19
    1fea:	82 0f       	add	r24, r18
    1fec:	93 1f       	adc	r25, r19
    1fee:	b8 01       	movw	r22, r16
    1ff0:	86 58       	subi	r24, 0x86	; 134
    1ff2:	97 4f       	sbci	r25, 0xF7	; 247
    1ff4:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    1ff8:	06 c0       	rjmp	.+12     	; 0x2006 <vTaskPriorityInherit+0xb2>
    1ffa:	e0 91 a7 08 	lds	r30, 0x08A7
    1ffe:	f0 91 a8 08 	lds	r31, 0x08A8
    2002:	86 89       	ldd	r24, Z+22	; 0x16
    2004:	8e 8b       	std	Y+22, r24	; 0x16
    2006:	df 91       	pop	r29
    2008:	cf 91       	pop	r28
    200a:	1f 91       	pop	r17
    200c:	0f 91       	pop	r16
    200e:	08 95       	ret

00002010 <xTaskPriorityDisinherit>:
    2010:	0f 93       	push	r16
    2012:	1f 93       	push	r17
    2014:	cf 93       	push	r28
    2016:	df 93       	push	r29
    2018:	ec 01       	movw	r28, r24
    201a:	00 97       	sbiw	r24, 0x00	; 0
    201c:	71 f1       	breq	.+92     	; 0x207a <xTaskPriorityDisinherit+0x6a>
    201e:	8a a1       	ldd	r24, Y+34	; 0x22
    2020:	81 50       	subi	r24, 0x01	; 1
    2022:	8a a3       	std	Y+34, r24	; 0x22
    2024:	2e 89       	ldd	r18, Y+22	; 0x16
    2026:	99 a1       	ldd	r25, Y+33	; 0x21
    2028:	29 17       	cp	r18, r25
    202a:	49 f1       	breq	.+82     	; 0x207e <xTaskPriorityDisinherit+0x6e>
    202c:	81 11       	cpse	r24, r1
    202e:	29 c0       	rjmp	.+82     	; 0x2082 <xTaskPriorityDisinherit+0x72>
    2030:	8e 01       	movw	r16, r28
    2032:	0e 5f       	subi	r16, 0xFE	; 254
    2034:	1f 4f       	sbci	r17, 0xFF	; 255
    2036:	c8 01       	movw	r24, r16
    2038:	0e 94 3f 02 	call	0x47e	; 0x47e <uxListRemove>
    203c:	89 a1       	ldd	r24, Y+33	; 0x21
    203e:	8e 8b       	std	Y+22, r24	; 0x16
    2040:	25 e0       	ldi	r18, 0x05	; 5
    2042:	30 e0       	ldi	r19, 0x00	; 0
    2044:	28 1b       	sub	r18, r24
    2046:	31 09       	sbc	r19, r1
    2048:	3d 87       	std	Y+13, r19	; 0x0d
    204a:	2c 87       	std	Y+12, r18	; 0x0c
    204c:	90 91 44 08 	lds	r25, 0x0844
    2050:	98 17       	cp	r25, r24
    2052:	10 f4       	brcc	.+4      	; 0x2058 <xTaskPriorityDisinherit+0x48>
    2054:	80 93 44 08 	sts	0x0844, r24
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	9c 01       	movw	r18, r24
    205c:	22 0f       	add	r18, r18
    205e:	33 1f       	adc	r19, r19
    2060:	22 0f       	add	r18, r18
    2062:	33 1f       	adc	r19, r19
    2064:	22 0f       	add	r18, r18
    2066:	33 1f       	adc	r19, r19
    2068:	82 0f       	add	r24, r18
    206a:	93 1f       	adc	r25, r19
    206c:	b8 01       	movw	r22, r16
    206e:	86 58       	subi	r24, 0x86	; 134
    2070:	97 4f       	sbci	r25, 0xF7	; 247
    2072:	0e 94 ed 01 	call	0x3da	; 0x3da <vListInsertEnd>
    2076:	81 e0       	ldi	r24, 0x01	; 1
    2078:	05 c0       	rjmp	.+10     	; 0x2084 <xTaskPriorityDisinherit+0x74>
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	03 c0       	rjmp	.+6      	; 0x2084 <xTaskPriorityDisinherit+0x74>
    207e:	80 e0       	ldi	r24, 0x00	; 0
    2080:	01 c0       	rjmp	.+2      	; 0x2084 <xTaskPriorityDisinherit+0x74>
    2082:	80 e0       	ldi	r24, 0x00	; 0
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	1f 91       	pop	r17
    208a:	0f 91       	pop	r16
    208c:	08 95       	ret

0000208e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    208e:	80 91 a7 08 	lds	r24, 0x08A7
    2092:	90 91 a8 08 	lds	r25, 0x08A8
    2096:	89 2b       	or	r24, r25
    2098:	39 f0       	breq	.+14     	; 0x20a8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    209a:	e0 91 a7 08 	lds	r30, 0x08A7
    209e:	f0 91 a8 08 	lds	r31, 0x08A8
    20a2:	82 a1       	ldd	r24, Z+34	; 0x22
    20a4:	8f 5f       	subi	r24, 0xFF	; 255
    20a6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    20a8:	80 91 a7 08 	lds	r24, 0x08A7
    20ac:	90 91 a8 08 	lds	r25, 0x08A8
	}
    20b0:	08 95       	ret

000020b2 <__divmodhi4>:
    20b2:	97 fb       	bst	r25, 7
    20b4:	07 2e       	mov	r0, r23
    20b6:	16 f4       	brtc	.+4      	; 0x20bc <__divmodhi4+0xa>
    20b8:	00 94       	com	r0
    20ba:	06 d0       	rcall	.+12     	; 0x20c8 <__divmodhi4_neg1>
    20bc:	77 fd       	sbrc	r23, 7
    20be:	08 d0       	rcall	.+16     	; 0x20d0 <__divmodhi4_neg2>
    20c0:	0b d0       	rcall	.+22     	; 0x20d8 <__udivmodhi4>
    20c2:	07 fc       	sbrc	r0, 7
    20c4:	05 d0       	rcall	.+10     	; 0x20d0 <__divmodhi4_neg2>
    20c6:	3e f4       	brtc	.+14     	; 0x20d6 <__divmodhi4_exit>

000020c8 <__divmodhi4_neg1>:
    20c8:	90 95       	com	r25
    20ca:	81 95       	neg	r24
    20cc:	9f 4f       	sbci	r25, 0xFF	; 255
    20ce:	08 95       	ret

000020d0 <__divmodhi4_neg2>:
    20d0:	70 95       	com	r23
    20d2:	61 95       	neg	r22
    20d4:	7f 4f       	sbci	r23, 0xFF	; 255

000020d6 <__divmodhi4_exit>:
    20d6:	08 95       	ret

000020d8 <__udivmodhi4>:
    20d8:	aa 1b       	sub	r26, r26
    20da:	bb 1b       	sub	r27, r27
    20dc:	51 e1       	ldi	r21, 0x11	; 17
    20de:	07 c0       	rjmp	.+14     	; 0x20ee <__udivmodhi4_ep>

000020e0 <__udivmodhi4_loop>:
    20e0:	aa 1f       	adc	r26, r26
    20e2:	bb 1f       	adc	r27, r27
    20e4:	a6 17       	cp	r26, r22
    20e6:	b7 07       	cpc	r27, r23
    20e8:	10 f0       	brcs	.+4      	; 0x20ee <__udivmodhi4_ep>
    20ea:	a6 1b       	sub	r26, r22
    20ec:	b7 0b       	sbc	r27, r23

000020ee <__udivmodhi4_ep>:
    20ee:	88 1f       	adc	r24, r24
    20f0:	99 1f       	adc	r25, r25
    20f2:	5a 95       	dec	r21
    20f4:	a9 f7       	brne	.-22     	; 0x20e0 <__udivmodhi4_loop>
    20f6:	80 95       	com	r24
    20f8:	90 95       	com	r25
    20fa:	bc 01       	movw	r22, r24
    20fc:	cd 01       	movw	r24, r26
    20fe:	08 95       	ret

00002100 <memcpy>:
    2100:	fb 01       	movw	r30, r22
    2102:	dc 01       	movw	r26, r24
    2104:	02 c0       	rjmp	.+4      	; 0x210a <memcpy+0xa>
    2106:	01 90       	ld	r0, Z+
    2108:	0d 92       	st	X+, r0
    210a:	41 50       	subi	r20, 0x01	; 1
    210c:	50 40       	sbci	r21, 0x00	; 0
    210e:	d8 f7       	brcc	.-10     	; 0x2106 <memcpy+0x6>
    2110:	08 95       	ret

00002112 <__itoa_ncheck>:
    2112:	bb 27       	eor	r27, r27
    2114:	4a 30       	cpi	r20, 0x0A	; 10
    2116:	31 f4       	brne	.+12     	; 0x2124 <__itoa_ncheck+0x12>
    2118:	99 23       	and	r25, r25
    211a:	22 f4       	brpl	.+8      	; 0x2124 <__itoa_ncheck+0x12>
    211c:	bd e2       	ldi	r27, 0x2D	; 45
    211e:	90 95       	com	r25
    2120:	81 95       	neg	r24
    2122:	9f 4f       	sbci	r25, 0xFF	; 255
    2124:	01 c0       	rjmp	.+2      	; 0x2128 <__utoa_common>

00002126 <__utoa_ncheck>:
    2126:	bb 27       	eor	r27, r27

00002128 <__utoa_common>:
    2128:	fb 01       	movw	r30, r22
    212a:	55 27       	eor	r21, r21
    212c:	aa 27       	eor	r26, r26
    212e:	88 0f       	add	r24, r24
    2130:	99 1f       	adc	r25, r25
    2132:	aa 1f       	adc	r26, r26
    2134:	a4 17       	cp	r26, r20
    2136:	10 f0       	brcs	.+4      	; 0x213c <__utoa_common+0x14>
    2138:	a4 1b       	sub	r26, r20
    213a:	83 95       	inc	r24
    213c:	50 51       	subi	r21, 0x10	; 16
    213e:	b9 f7       	brne	.-18     	; 0x212e <__utoa_common+0x6>
    2140:	a0 5d       	subi	r26, 0xD0	; 208
    2142:	aa 33       	cpi	r26, 0x3A	; 58
    2144:	08 f0       	brcs	.+2      	; 0x2148 <__utoa_common+0x20>
    2146:	a9 5d       	subi	r26, 0xD9	; 217
    2148:	a1 93       	st	Z+, r26
    214a:	00 97       	sbiw	r24, 0x00	; 0
    214c:	79 f7       	brne	.-34     	; 0x212c <__utoa_common+0x4>
    214e:	b1 11       	cpse	r27, r1
    2150:	b1 93       	st	Z+, r27
    2152:	11 92       	st	Z+, r1
    2154:	cb 01       	movw	r24, r22
    2156:	00 c0       	rjmp	.+0      	; 0x2158 <strrev>

00002158 <strrev>:
    2158:	dc 01       	movw	r26, r24
    215a:	fc 01       	movw	r30, r24
    215c:	67 2f       	mov	r22, r23
    215e:	71 91       	ld	r23, Z+
    2160:	77 23       	and	r23, r23
    2162:	e1 f7       	brne	.-8      	; 0x215c <strrev+0x4>
    2164:	32 97       	sbiw	r30, 0x02	; 2
    2166:	04 c0       	rjmp	.+8      	; 0x2170 <strrev+0x18>
    2168:	7c 91       	ld	r23, X
    216a:	6d 93       	st	X+, r22
    216c:	70 83       	st	Z, r23
    216e:	62 91       	ld	r22, -Z
    2170:	ae 17       	cp	r26, r30
    2172:	bf 07       	cpc	r27, r31
    2174:	c8 f3       	brcs	.-14     	; 0x2168 <strrev+0x10>
    2176:	08 95       	ret

00002178 <_exit>:
    2178:	f8 94       	cli

0000217a <__stop_program>:
    217a:	ff cf       	rjmp	.-2      	; 0x217a <__stop_program>
