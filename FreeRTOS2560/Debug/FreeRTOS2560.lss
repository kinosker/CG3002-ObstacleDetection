
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000094  00800200  00002230  000022c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002230  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fa  00800294  00800294  00002358  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002358  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  00002388  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005349  00000000  00000000  00002840  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000013a3  00000000  00000000  00007b89  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000328e  00000000  00000000  00008f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d40  00000000  00000000  0000c1bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000014b6  00000000  00000000  0000cefc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000368f  00000000  00000000  0000e3b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011a41  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	90 c2       	rjmp	.+1312   	; 0x546 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	a1 c7       	rjmp	.+3906   	; 0xf98 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	cd c4       	rjmp	.+2458   	; 0xa00 <__vector_25>
      66:	00 00       	nop
      68:	39 c5       	rjmp	.+2674   	; 0xadc <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	23 c3       	rjmp	.+1606   	; 0x6bc <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	7f c4       	rjmp	.+2302   	; 0x990 <__vector_36>
      92:	00 00       	nop
      94:	ed c4       	rjmp	.+2522   	; 0xa70 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e0 e3       	ldi	r30, 0x30	; 48
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a4 39       	cpi	r26, 0x94	; 148
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a4 e9       	ldi	r26, 0x94	; 148
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ae 38       	cpi	r26, 0x8E	; 142
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	ef d0       	rcall	.+478    	; 0x2fe <main>
     120:	0c 94 16 11 	jmp	0x222c	; 0x222c <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	a0 d5       	rcall	.+2880   	; 0xc98 <myUSART_waitForHandshake>
     158:	86 e0       	ldi	r24, 0x06	; 6
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	63 c5       	rjmp	.+2758   	; 0xc24 <myUSART_transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	90 d5       	rcall	.+2848   	; 0xc82 <myUSART_startHandShake>
     162:	8d e1       	ldi	r24, 0x1D	; 29
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	5e c5       	rjmp	.+2748   	; 0xc24 <myUSART_transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	ae 97       	sbiw	r28, 0x2e	; 46
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e3 e3       	ldi	r30, 0x33	; 51
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	17 96       	adiw	r26, 0x07	; 7
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	eb e3       	ldi	r30, 0x3B	; 59
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1f 96       	adiw	r26, 0x0f	; 15
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e2 e4       	ldi	r30, 0x42	; 66
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	56 96       	adiw	r26, 0x16	; 22
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	ea e4       	ldi	r30, 0x4A	; 74
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5e 96       	adiw	r26, 0x1e	; 30
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	86 e0       	ldi	r24, 0x06	; 6
     1c8:	e0 e5       	ldi	r30, 0x50	; 80
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	94 96       	adiw	r26, 0x24	; 36
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	85 e0       	ldi	r24, 0x05	; 5
     1da:	e6 e5       	ldi	r30, 0x56	; 86
     1dc:	f2 e0       	ldi	r31, 0x02	; 2
     1de:	de 01       	movw	r26, r28
     1e0:	9a 96       	adiw	r26, 0x2a	; 42
     1e2:	01 90       	ld	r0, Z+
     1e4:	0d 92       	st	X+, r0
     1e6:	8a 95       	dec	r24
     1e8:	e1 f7       	brne	.-8      	; 0x1e2 <maxSonarTask+0x78>
     1ea:	0e 94 be 0c 	call	0x197c	; 0x197c <xTaskGetTickCount>
     1ee:	9a 83       	std	Y+2, r25	; 0x02
     1f0:	89 83       	std	Y+1, r24	; 0x01
     1f2:	54 d2       	rcall	.+1192   	; 0x69c <myMaxSonar_Start>
     1f4:	87 e2       	ldi	r24, 0x27	; 39
     1f6:	58 d2       	rcall	.+1200   	; 0x6a8 <myMaxSonar_Read>
     1f8:	4a e0       	ldi	r20, 0x0A	; 10
     1fa:	be 01       	movw	r22, r28
     1fc:	6d 5f       	subi	r22, 0xFD	; 253
     1fe:	7f 4f       	sbci	r23, 0xFF	; 255
     200:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <__itoa_ncheck>
     204:	ce 01       	movw	r24, r28
     206:	07 96       	adiw	r24, 0x07	; 7
     208:	0d d5       	rcall	.+2586   	; 0xc24 <myUSART_transmitUSART0>
     20a:	ce 01       	movw	r24, r28
     20c:	03 96       	adiw	r24, 0x03	; 3
     20e:	0a d5       	rcall	.+2580   	; 0xc24 <myUSART_transmitUSART0>
     210:	ce 01       	movw	r24, r28
     212:	84 96       	adiw	r24, 0x24	; 36
     214:	07 d5       	rcall	.+2574   	; 0xc24 <myUSART_transmitUSART0>
     216:	86 e2       	ldi	r24, 0x26	; 38
     218:	47 d2       	rcall	.+1166   	; 0x6a8 <myMaxSonar_Read>
     21a:	4a e0       	ldi	r20, 0x0A	; 10
     21c:	be 01       	movw	r22, r28
     21e:	6d 5f       	subi	r22, 0xFD	; 253
     220:	7f 4f       	sbci	r23, 0xFF	; 255
     222:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <__itoa_ncheck>
     226:	ce 01       	movw	r24, r28
     228:	0f 96       	adiw	r24, 0x0f	; 15
     22a:	fc d4       	rcall	.+2552   	; 0xc24 <myUSART_transmitUSART0>
     22c:	ce 01       	movw	r24, r28
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	f9 d4       	rcall	.+2546   	; 0xc24 <myUSART_transmitUSART0>
     232:	ce 01       	movw	r24, r28
     234:	84 96       	adiw	r24, 0x24	; 36
     236:	f6 d4       	rcall	.+2540   	; 0xc24 <myUSART_transmitUSART0>
     238:	85 e2       	ldi	r24, 0x25	; 37
     23a:	36 d2       	rcall	.+1132   	; 0x6a8 <myMaxSonar_Read>
     23c:	4a e0       	ldi	r20, 0x0A	; 10
     23e:	be 01       	movw	r22, r28
     240:	6d 5f       	subi	r22, 0xFD	; 253
     242:	7f 4f       	sbci	r23, 0xFF	; 255
     244:	0a 97       	sbiw	r24, 0x0a	; 10
     246:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <__itoa_ncheck>
     24a:	ce 01       	movw	r24, r28
     24c:	46 96       	adiw	r24, 0x16	; 22
     24e:	ea d4       	rcall	.+2516   	; 0xc24 <myUSART_transmitUSART0>
     250:	ce 01       	movw	r24, r28
     252:	03 96       	adiw	r24, 0x03	; 3
     254:	e7 d4       	rcall	.+2510   	; 0xc24 <myUSART_transmitUSART0>
     256:	ce 01       	movw	r24, r28
     258:	84 96       	adiw	r24, 0x24	; 36
     25a:	e4 d4       	rcall	.+2504   	; 0xc24 <myUSART_transmitUSART0>
     25c:	ff d1       	rcall	.+1022   	; 0x65c <myHcSonar_Read>
     25e:	4a e0       	ldi	r20, 0x0A	; 10
     260:	be 01       	movw	r22, r28
     262:	6d 5f       	subi	r22, 0xFD	; 253
     264:	7f 4f       	sbci	r23, 0xFF	; 255
     266:	0e 94 e3 10 	call	0x21c6	; 0x21c6 <__itoa_ncheck>
     26a:	ce 01       	movw	r24, r28
     26c:	4e 96       	adiw	r24, 0x1e	; 30
     26e:	da d4       	rcall	.+2484   	; 0xc24 <myUSART_transmitUSART0>
     270:	ce 01       	movw	r24, r28
     272:	03 96       	adiw	r24, 0x03	; 3
     274:	d7 d4       	rcall	.+2478   	; 0xc24 <myUSART_transmitUSART0>
     276:	ce 01       	movw	r24, r28
     278:	8a 96       	adiw	r24, 0x2a	; 42
     27a:	d4 d4       	rcall	.+2472   	; 0xc24 <myUSART_transmitUSART0>
     27c:	68 ec       	ldi	r22, 0xC8	; 200
     27e:	70 e0       	ldi	r23, 0x00	; 0
     280:	ce 01       	movw	r24, r28
     282:	01 96       	adiw	r24, 0x01	; 1
     284:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vTaskDelayUntil>
     288:	b4 cf       	rjmp	.-152    	; 0x1f2 <maxSonarTask+0x88>

0000028a <myTimerTask>:
     28a:	b0 d2       	rcall	.+1376   	; 0x7ec <myTimer_Init>
     28c:	12 d3       	rcall	.+1572   	; 0x8b2 <myTimer_DelayChecker>
     28e:	fe cf       	rjmp	.-4      	; 0x28c <myTimerTask+0x2>

00000290 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     290:	8c ec       	ldi	r24, 0xCC	; 204
     292:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     296:	8e e3       	ldi	r24, 0x3E	; 62
     298:	80 93 65 00 	sts	0x0065, r24
     29c:	08 95       	ret

0000029e <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     29e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2a2:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2a6:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2aa:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2ae:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2b2:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2b6:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2ba:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2be:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2c2:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2c6:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2ca:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2ce:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2d2:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2d6:	10 92 73 00 	sts	0x0073, r1
     2da:	08 95       	ret

000002dc <init>:
}

void init()
{
     2dc:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2de:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2e0:	f8 94       	cli
	{
		clearTimer();
     2e2:	dd df       	rcall	.-70     	; 0x29e <clearTimer>
		setPowerReduction();
     2e4:	d5 df       	rcall	.-86     	; 0x290 <setPowerReduction>
		myUSART_USART0_Init();
     2e6:	30 d4       	rcall	.+2144   	; 0xb48 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2e8:	4f d4       	rcall	.+2206   	; 0xb88 <myUSART_USART1_Init>
		myADC_Init();
     2ea:	1c d2       	rcall	.+1080   	; 0x724 <myADC_Init>
		MaxSonar_Init();
     2ec:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     2ee:	9b d1       	rcall	.+822    	; 0x626 <myHcSonar_Init>
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2f0:	84 b1       	in	r24, 0x04	; 4
     2f2:	80 6c       	ori	r24, 0xC0	; 192
     2f4:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2f6:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2f8:	78 94       	sei
}
     2fa:	cf 91       	pop	r28
     2fc:	08 95       	ret

000002fe <main>:
	
	// do nth
}

int main(void)
{
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
     302:	cd b7       	in	r28, 0x3d	; 61
     304:	de b7       	in	r29, 0x3e	; 62
     306:	2c 97       	sbiw	r28, 0x0c	; 12
     308:	0f b6       	in	r0, 0x3f	; 63
     30a:	f8 94       	cli
     30c:	de bf       	out	0x3e, r29	; 62
     30e:	0f be       	out	0x3f, r0	; 63
     310:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     312:	e4 df       	rcall	.-56     	; 0x2dc <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     314:	a1 2c       	mov	r10, r1
     316:	b1 2c       	mov	r11, r1
     318:	c1 2c       	mov	r12, r1
     31a:	d1 2c       	mov	r13, r1
     31c:	ce 01       	movw	r24, r28
     31e:	01 96       	adiw	r24, 0x01	; 1
     320:	7c 01       	movw	r14, r24
     322:	04 e0       	ldi	r16, 0x04	; 4
     324:	9c 01       	movw	r18, r24
     326:	49 e6       	ldi	r20, 0x69	; 105
     328:	50 e0       	ldi	r21, 0x00	; 0
     32a:	6b e5       	ldi	r22, 0x5B	; 91
     32c:	72 e0       	ldi	r23, 0x02	; 2
     32e:	85 e4       	ldi	r24, 0x45	; 69
     330:	91 e0       	ldi	r25, 0x01	; 1
     332:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     336:	ce 01       	movw	r24, r28
     338:	07 96       	adiw	r24, 0x07	; 7
     33a:	7c 01       	movw	r14, r24
     33c:	02 e0       	ldi	r16, 0x02	; 2
     33e:	20 e0       	ldi	r18, 0x00	; 0
     340:	30 e0       	ldi	r19, 0x00	; 0
     342:	4f e4       	ldi	r20, 0x4F	; 79
     344:	51 e0       	ldi	r21, 0x01	; 1
     346:	63 e6       	ldi	r22, 0x63	; 99
     348:	72 e0       	ldi	r23, 0x02	; 2
     34a:	85 eb       	ldi	r24, 0xB5	; 181
     34c:	90 e0       	ldi	r25, 0x00	; 0
     34e:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     352:	ce 01       	movw	r24, r28
     354:	0b 96       	adiw	r24, 0x0b	; 11
     356:	7c 01       	movw	r14, r24
     358:	01 e0       	ldi	r16, 0x01	; 1
     35a:	20 e0       	ldi	r18, 0x00	; 0
     35c:	30 e0       	ldi	r19, 0x00	; 0
     35e:	49 e6       	ldi	r20, 0x69	; 105
     360:	50 e0       	ldi	r21, 0x00	; 0
     362:	6c e6       	ldi	r22, 0x6C	; 108
     364:	72 e0       	ldi	r23, 0x02	; 2
     366:	83 e9       	ldi	r24, 0x93	; 147
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     36e:	ce 01       	movw	r24, r28
     370:	09 96       	adiw	r24, 0x09	; 9
     372:	7c 01       	movw	r14, r24
     374:	20 e0       	ldi	r18, 0x00	; 0
     376:	30 e0       	ldi	r19, 0x00	; 0
     378:	49 e6       	ldi	r20, 0x69	; 105
     37a:	50 e0       	ldi	r21, 0x00	; 0
     37c:	63 e7       	ldi	r22, 0x73	; 115
     37e:	72 e0       	ldi	r23, 0x02	; 2
     380:	8f e9       	ldi	r24, 0x9F	; 159
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     388:	ce 01       	movw	r24, r28
     38a:	05 96       	adiw	r24, 0x05	; 5
     38c:	7c 01       	movw	r14, r24
     38e:	03 e0       	ldi	r16, 0x03	; 3
     390:	20 e0       	ldi	r18, 0x00	; 0
     392:	30 e0       	ldi	r19, 0x00	; 0
     394:	47 e8       	ldi	r20, 0x87	; 135
     396:	50 e0       	ldi	r21, 0x00	; 0
     398:	6a e7       	ldi	r22, 0x7A	; 122
     39a:	72 e0       	ldi	r23, 0x02	; 2
     39c:	8b ea       	ldi	r24, 0xAB	; 171
     39e:	90 e0       	ldi	r25, 0x00	; 0
     3a0:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3a4:	ce 01       	movw	r24, r28
     3a6:	03 96       	adiw	r24, 0x03	; 3
     3a8:	7c 01       	movw	r14, r24
     3aa:	02 e0       	ldi	r16, 0x02	; 2
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	30 e0       	ldi	r19, 0x00	; 0
     3b0:	47 e8       	ldi	r20, 0x87	; 135
     3b2:	50 e0       	ldi	r21, 0x00	; 0
     3b4:	66 e8       	ldi	r22, 0x86	; 134
     3b6:	72 e0       	ldi	r23, 0x02	; 2
     3b8:	80 eb       	ldi	r24, 0xB0	; 176
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	0e 94 2f 0b 	call	0x165e	; 0x165e <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3c0:	0e 94 8f 0c 	call	0x191e	; 0x191e <vTaskStartScheduler>
     3c4:	a6 cf       	rjmp	.-180    	; 0x312 <main+0x14>

000003c6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3c6:	cf 93       	push	r28
     3c8:	df 93       	push	r29
     3ca:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3cc:	0e 94 b8 0c 	call	0x1970	; 0x1970 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3d0:	80 91 94 02 	lds	r24, 0x0294
     3d4:	90 91 95 02 	lds	r25, 0x0295
     3d8:	89 2b       	or	r24, r25
     3da:	31 f4       	brne	.+12     	; 0x3e8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3dc:	89 e9       	ldi	r24, 0x99	; 153
     3de:	92 e0       	ldi	r25, 0x02	; 2
     3e0:	90 93 95 02 	sts	0x0295, r25
     3e4:	80 93 94 02 	sts	0x0294, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3e8:	40 91 96 02 	lds	r20, 0x0296
     3ec:	50 91 97 02 	lds	r21, 0x0297
     3f0:	9e 01       	movw	r18, r28
     3f2:	24 0f       	add	r18, r20
     3f4:	35 1f       	adc	r19, r21
     3f6:	2b 3d       	cpi	r18, 0xDB	; 219
     3f8:	85 e0       	ldi	r24, 0x05	; 5
     3fa:	38 07       	cpc	r19, r24
     3fc:	70 f4       	brcc	.+28     	; 0x41a <pvPortMalloc+0x54>
     3fe:	42 17       	cp	r20, r18
     400:	53 07       	cpc	r21, r19
     402:	70 f4       	brcc	.+28     	; 0x420 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     404:	c0 91 94 02 	lds	r28, 0x0294
     408:	d0 91 95 02 	lds	r29, 0x0295
     40c:	c4 0f       	add	r28, r20
     40e:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     410:	30 93 97 02 	sts	0x0297, r19
     414:	20 93 96 02 	sts	0x0296, r18
     418:	05 c0       	rjmp	.+10     	; 0x424 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     41a:	c0 e0       	ldi	r28, 0x00	; 0
     41c:	d0 e0       	ldi	r29, 0x00	; 0
     41e:	02 c0       	rjmp	.+4      	; 0x424 <pvPortMalloc+0x5e>
     420:	c0 e0       	ldi	r28, 0x00	; 0
     422:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     424:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     428:	ce 01       	movw	r24, r28
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	08 95       	ret

00000430 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     430:	08 95       	ret

00000432 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     432:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     434:	03 96       	adiw	r24, 0x03	; 3
     436:	92 83       	std	Z+2, r25	; 0x02
     438:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     43a:	2f ef       	ldi	r18, 0xFF	; 255
     43c:	3f ef       	ldi	r19, 0xFF	; 255
     43e:	34 83       	std	Z+4, r19	; 0x04
     440:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     442:	96 83       	std	Z+6, r25	; 0x06
     444:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     446:	90 87       	std	Z+8, r25	; 0x08
     448:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     44a:	10 82       	st	Z, r1
     44c:	08 95       	ret

0000044e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     44e:	fc 01       	movw	r30, r24
     450:	11 86       	std	Z+9, r1	; 0x09
     452:	10 86       	std	Z+8, r1	; 0x08
     454:	08 95       	ret

00000456 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     456:	cf 93       	push	r28
     458:	df 93       	push	r29
     45a:	9c 01       	movw	r18, r24
     45c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     45e:	dc 01       	movw	r26, r24
     460:	11 96       	adiw	r26, 0x01	; 1
     462:	cd 91       	ld	r28, X+
     464:	dc 91       	ld	r29, X
     466:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     468:	d3 83       	std	Z+3, r29	; 0x03
     46a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     46c:	8c 81       	ldd	r24, Y+4	; 0x04
     46e:	9d 81       	ldd	r25, Y+5	; 0x05
     470:	95 83       	std	Z+5, r25	; 0x05
     472:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     474:	8c 81       	ldd	r24, Y+4	; 0x04
     476:	9d 81       	ldd	r25, Y+5	; 0x05
     478:	dc 01       	movw	r26, r24
     47a:	13 96       	adiw	r26, 0x03	; 3
     47c:	7c 93       	st	X, r23
     47e:	6e 93       	st	-X, r22
     480:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     482:	7d 83       	std	Y+5, r23	; 0x05
     484:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     486:	31 87       	std	Z+9, r19	; 0x09
     488:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     48a:	f9 01       	movw	r30, r18
     48c:	80 81       	ld	r24, Z
     48e:	8f 5f       	subi	r24, 0xFF	; 255
     490:	80 83       	st	Z, r24
}
     492:	df 91       	pop	r29
     494:	cf 91       	pop	r28
     496:	08 95       	ret

00000498 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     498:	cf 93       	push	r28
     49a:	df 93       	push	r29
     49c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     49e:	48 81       	ld	r20, Y
     4a0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     4a2:	4f 3f       	cpi	r20, 0xFF	; 255
     4a4:	2f ef       	ldi	r18, 0xFF	; 255
     4a6:	52 07       	cpc	r21, r18
     4a8:	21 f4       	brne	.+8      	; 0x4b2 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4aa:	fc 01       	movw	r30, r24
     4ac:	a7 81       	ldd	r26, Z+7	; 0x07
     4ae:	b0 85       	ldd	r27, Z+8	; 0x08
     4b0:	0d c0       	rjmp	.+26     	; 0x4cc <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4b2:	dc 01       	movw	r26, r24
     4b4:	13 96       	adiw	r26, 0x03	; 3
     4b6:	12 96       	adiw	r26, 0x02	; 2
     4b8:	ed 91       	ld	r30, X+
     4ba:	fc 91       	ld	r31, X
     4bc:	13 97       	sbiw	r26, 0x03	; 3
     4be:	20 81       	ld	r18, Z
     4c0:	31 81       	ldd	r19, Z+1	; 0x01
     4c2:	42 17       	cp	r20, r18
     4c4:	53 07       	cpc	r21, r19
     4c6:	10 f0       	brcs	.+4      	; 0x4cc <vListInsert+0x34>
     4c8:	df 01       	movw	r26, r30
     4ca:	f5 cf       	rjmp	.-22     	; 0x4b6 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4cc:	12 96       	adiw	r26, 0x02	; 2
     4ce:	ed 91       	ld	r30, X+
     4d0:	fc 91       	ld	r31, X
     4d2:	13 97       	sbiw	r26, 0x03	; 3
     4d4:	fb 83       	std	Y+3, r31	; 0x03
     4d6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4d8:	d5 83       	std	Z+5, r29	; 0x05
     4da:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4dc:	bd 83       	std	Y+5, r27	; 0x05
     4de:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4e0:	13 96       	adiw	r26, 0x03	; 3
     4e2:	dc 93       	st	X, r29
     4e4:	ce 93       	st	-X, r28
     4e6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4e8:	99 87       	std	Y+9, r25	; 0x09
     4ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4ec:	fc 01       	movw	r30, r24
     4ee:	20 81       	ld	r18, Z
     4f0:	2f 5f       	subi	r18, 0xFF	; 255
     4f2:	20 83       	st	Z, r18
}
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	08 95       	ret

000004fa <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4fa:	cf 93       	push	r28
     4fc:	df 93       	push	r29
     4fe:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     500:	a0 85       	ldd	r26, Z+8	; 0x08
     502:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     504:	c2 81       	ldd	r28, Z+2	; 0x02
     506:	d3 81       	ldd	r29, Z+3	; 0x03
     508:	84 81       	ldd	r24, Z+4	; 0x04
     50a:	95 81       	ldd	r25, Z+5	; 0x05
     50c:	9d 83       	std	Y+5, r25	; 0x05
     50e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     510:	c4 81       	ldd	r28, Z+4	; 0x04
     512:	d5 81       	ldd	r29, Z+5	; 0x05
     514:	82 81       	ldd	r24, Z+2	; 0x02
     516:	93 81       	ldd	r25, Z+3	; 0x03
     518:	9b 83       	std	Y+3, r25	; 0x03
     51a:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     51c:	11 96       	adiw	r26, 0x01	; 1
     51e:	cd 91       	ld	r28, X+
     520:	dc 91       	ld	r29, X
     522:	12 97       	sbiw	r26, 0x02	; 2
     524:	ce 17       	cp	r28, r30
     526:	df 07       	cpc	r29, r31
     528:	31 f4       	brne	.+12     	; 0x536 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     52a:	8c 81       	ldd	r24, Y+4	; 0x04
     52c:	9d 81       	ldd	r25, Y+5	; 0x05
     52e:	12 96       	adiw	r26, 0x02	; 2
     530:	9c 93       	st	X, r25
     532:	8e 93       	st	-X, r24
     534:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     536:	11 86       	std	Z+9, r1	; 0x09
     538:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     53a:	8c 91       	ld	r24, X
     53c:	81 50       	subi	r24, 0x01	; 1
     53e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     540:	df 91       	pop	r29
     542:	cf 91       	pop	r28
     544:	08 95       	ret

00000546 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     546:	1f 92       	push	r1
     548:	0f 92       	push	r0
     54a:	0f b6       	in	r0, 0x3f	; 63
     54c:	0f 92       	push	r0
     54e:	11 24       	eor	r1, r1
     550:	0b b6       	in	r0, 0x3b	; 59
     552:	0f 92       	push	r0
     554:	2f 93       	push	r18
     556:	3f 93       	push	r19
     558:	4f 93       	push	r20
     55a:	5f 93       	push	r21
     55c:	6f 93       	push	r22
     55e:	7f 93       	push	r23
     560:	8f 93       	push	r24
     562:	9f 93       	push	r25
     564:	af 93       	push	r26
     566:	bf 93       	push	r27
     568:	ef 93       	push	r30
     56a:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     56c:	1b 9b       	sbis	0x03, 3	; 3
     56e:	0d c0       	rjmp	.+26     	; 0x58a <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     570:	57 d1       	rcall	.+686    	; 0x820 <myTimer_Read>
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	90 93 e4 08 	sts	0x08E4, r25
     578:	80 93 e3 08 	sts	0x08E3, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     57c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskGetTickCountFromISR>
     580:	90 93 e0 08 	sts	0x08E0, r25
     584:	80 93 df 08 	sts	0x08DF, r24
     588:	3b c0       	rjmp	.+118    	; 0x600 <__vector_9+0xba>
	}	
	else if (!(HC_Echo_Read))
     58a:	1b 99       	sbic	0x03, 3	; 3
     58c:	39 c0       	rjmp	.+114    	; 0x600 <__vector_9+0xba>
	{
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     58e:	48 d1       	rcall	.+656    	; 0x820 <myTimer_Read>
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	90 93 ea 08 	sts	0x08EA, r25
     596:	80 93 e9 08 	sts	0x08E9, r24
     59a:	20 91 e3 08 	lds	r18, 0x08E3
     59e:	30 91 e4 08 	lds	r19, 0x08E4
     5a2:	82 17       	cp	r24, r18
     5a4:	93 07       	cpc	r25, r19
     5a6:	54 f4       	brge	.+20     	; 0x5bc <__vector_9+0x76>
		us_tickEnd += MAX_TICKS;
     5a8:	80 91 e9 08 	lds	r24, 0x08E9
     5ac:	90 91 ea 08 	lds	r25, 0x08EA
     5b0:	86 50       	subi	r24, 0x06	; 6
     5b2:	9f 4f       	sbci	r25, 0xFF	; 255
     5b4:	90 93 ea 08 	sts	0x08EA, r25
     5b8:	80 93 e9 08 	sts	0x08E9, r24
			
		us_tickLapsed = myTimer_Read() - us_tickStart;
     5bc:	31 d1       	rcall	.+610    	; 0x820 <myTimer_Read>
     5be:	20 91 e3 08 	lds	r18, 0x08E3
     5c2:	30 91 e4 08 	lds	r19, 0x08E4
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	82 1b       	sub	r24, r18
     5ca:	93 0b       	sbc	r25, r19
     5cc:	90 93 e6 08 	sts	0x08E6, r25
     5d0:	80 93 e5 08 	sts	0x08E5, r24
		ms_tickLapsed = xTaskGetTickCountFromISR() - ms_tickStart;
     5d4:	0e 94 c8 0c 	call	0x1990	; 0x1990 <xTaskGetTickCountFromISR>
     5d8:	20 91 df 08 	lds	r18, 0x08DF
     5dc:	30 91 e0 08 	lds	r19, 0x08E0
     5e0:	82 1b       	sub	r24, r18
     5e2:	93 0b       	sbc	r25, r19
     5e4:	90 93 e2 08 	sts	0x08E2, r25
     5e8:	80 93 e1 08 	sts	0x08E1, r24
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     5ec:	20 e0       	ldi	r18, 0x00	; 0
     5ee:	40 e0       	ldi	r20, 0x00	; 0
     5f0:	50 e0       	ldi	r21, 0x00	; 0
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	80 91 e7 08 	lds	r24, 0x08E7
     5fa:	90 91 e8 08 	lds	r25, 0x08E8
     5fe:	ae d6       	rcall	.+3420   	; 0x135c <xQueueGenericSendFromISR>
	}	
}
     600:	ff 91       	pop	r31
     602:	ef 91       	pop	r30
     604:	bf 91       	pop	r27
     606:	af 91       	pop	r26
     608:	9f 91       	pop	r25
     60a:	8f 91       	pop	r24
     60c:	7f 91       	pop	r23
     60e:	6f 91       	pop	r22
     610:	5f 91       	pop	r21
     612:	4f 91       	pop	r20
     614:	3f 91       	pop	r19
     616:	2f 91       	pop	r18
     618:	0f 90       	pop	r0
     61a:	0b be       	out	0x3b, r0	; 59
     61c:	0f 90       	pop	r0
     61e:	0f be       	out	0x3f, r0	; 63
     620:	0f 90       	pop	r0
     622:	1f 90       	pop	r1
     624:	18 95       	reti

00000626 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     626:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     628:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     62a:	e8 e6       	ldi	r30, 0x68	; 104
     62c:	f0 e0       	ldi	r31, 0x00	; 0
     62e:	80 81       	ld	r24, Z
     630:	81 60       	ori	r24, 0x01	; 1
     632:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     634:	eb e6       	ldi	r30, 0x6B	; 107
     636:	f0 e0       	ldi	r31, 0x00	; 0
     638:	80 81       	ld	r24, Z
     63a:	88 60       	ori	r24, 0x08	; 8
     63c:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     63e:	43 e0       	ldi	r20, 0x03	; 3
     640:	60 e0       	ldi	r22, 0x00	; 0
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	a6 d5       	rcall	.+2892   	; 0x1192 <xQueueGenericCreate>
     646:	90 93 e8 08 	sts	0x08E8, r25
     64a:	80 93 e7 08 	sts	0x08E7, r24
     64e:	08 95       	ret

00000650 <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     650:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     652:	8e e1       	ldi	r24, 0x1E	; 30
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	0a d1       	rcall	.+532    	; 0x86c <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     658:	2a 98       	cbi	0x05, 2	; 5
     65a:	08 95       	ret

0000065c <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     65c:	f9 df       	rcall	.-14     	; 0x650 <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     65e:	20 e0       	ldi	r18, 0x00	; 0
     660:	4f ef       	ldi	r20, 0xFF	; 255
     662:	5f ef       	ldi	r21, 0xFF	; 255
     664:	60 e0       	ldi	r22, 0x00	; 0
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	80 91 e7 08 	lds	r24, 0x08E7
     66c:	90 91 e8 08 	lds	r25, 0x08E8
     670:	af d6       	rcall	.+3422   	; 0x13d0 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     672:	80 91 e5 08 	lds	r24, 0x08E5
     676:	90 91 e6 08 	lds	r25, 0x08E6
	msLength = ms_tickLapsed * 17;
     67a:	20 91 e1 08 	lds	r18, 0x08E1
     67e:	30 91 e2 08 	lds	r19, 0x08E2
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     682:	6e e0       	ldi	r22, 0x0E	; 14
     684:	70 e0       	ldi	r23, 0x00	; 0
     686:	0e 94 b3 10 	call	0x2166	; 0x2166 <__divmodhi4>
	msLength = ms_tickLapsed * 17;
     68a:	41 e1       	ldi	r20, 0x11	; 17
     68c:	42 9f       	mul	r20, r18
     68e:	c0 01       	movw	r24, r0
     690:	43 9f       	mul	r20, r19
     692:	90 0d       	add	r25, r0
     694:	11 24       	eor	r1, r1
	return usLength + msLength;
	
     696:	86 0f       	add	r24, r22
     698:	97 1f       	adc	r25, r23
     69a:	08 95       	ret

0000069c <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     69c:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     69e:	89 e1       	ldi	r24, 0x19	; 25
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	c0 d0       	rcall	.+384    	; 0x824 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     6a4:	a1 98       	cbi	0x14, 1	; 20
     6a6:	08 95       	ret

000006a8 <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     6a8:	9a d0       	rcall	.+308    	; 0x7de <myADC_analogRead>
     6aa:	90 e0       	ldi	r25, 0x00	; 0
     6ac:	9c 01       	movw	r18, r24
     6ae:	22 0f       	add	r18, r18
     6b0:	33 1f       	adc	r19, r19
     6b2:	22 0f       	add	r18, r18
     6b4:	33 1f       	adc	r19, r19
}
     6b6:	82 0f       	add	r24, r18
     6b8:	93 1f       	adc	r25, r19
     6ba:	08 95       	ret

000006bc <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     6bc:	1f 92       	push	r1
     6be:	0f 92       	push	r0
     6c0:	0f b6       	in	r0, 0x3f	; 63
     6c2:	0f 92       	push	r0
     6c4:	11 24       	eor	r1, r1
     6c6:	0b b6       	in	r0, 0x3b	; 59
     6c8:	0f 92       	push	r0
     6ca:	2f 93       	push	r18
     6cc:	3f 93       	push	r19
     6ce:	4f 93       	push	r20
     6d0:	5f 93       	push	r21
     6d2:	6f 93       	push	r22
     6d4:	7f 93       	push	r23
     6d6:	8f 93       	push	r24
     6d8:	9f 93       	push	r25
     6da:	af 93       	push	r26
     6dc:	bf 93       	push	r27
     6de:	ef 93       	push	r30
     6e0:	ff 93       	push	r31
	adcReading = ADCH; // read value
     6e2:	80 91 79 00 	lds	r24, 0x0079
     6e6:	80 93 eb 08 	sts	0x08EB, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     6ea:	20 e0       	ldi	r18, 0x00	; 0
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	50 e0       	ldi	r21, 0x00	; 0
     6f0:	60 e0       	ldi	r22, 0x00	; 0
     6f2:	70 e0       	ldi	r23, 0x00	; 0
     6f4:	80 91 ee 08 	lds	r24, 0x08EE
     6f8:	90 91 ef 08 	lds	r25, 0x08EF
     6fc:	2f d6       	rcall	.+3166   	; 0x135c <xQueueGenericSendFromISR>
}
     6fe:	ff 91       	pop	r31
     700:	ef 91       	pop	r30
     702:	bf 91       	pop	r27
     704:	af 91       	pop	r26
     706:	9f 91       	pop	r25
     708:	8f 91       	pop	r24
     70a:	7f 91       	pop	r23
     70c:	6f 91       	pop	r22
     70e:	5f 91       	pop	r21
     710:	4f 91       	pop	r20
     712:	3f 91       	pop	r19
     714:	2f 91       	pop	r18
     716:	0f 90       	pop	r0
     718:	0b be       	out	0x3b, r0	; 59
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	0f 90       	pop	r0
     720:	1f 90       	pop	r1
     722:	18 95       	reti

00000724 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     724:	8f e8       	ldi	r24, 0x8F	; 143
     726:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     72a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     72e:	80 e6       	ldi	r24, 0x60	; 96
     730:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     734:	43 e0       	ldi	r20, 0x03	; 3
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	81 e0       	ldi	r24, 0x01	; 1
     73a:	2b d5       	rcall	.+2646   	; 0x1192 <xQueueGenericCreate>
     73c:	90 93 ef 08 	sts	0x08EF, r25
     740:	80 93 ee 08 	sts	0x08EE, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	e2 d5       	rcall	.+3012   	; 0x130c <xQueueCreateMutex>
     748:	90 93 ed 08 	sts	0x08ED, r25
     74c:	80 93 ec 08 	sts	0x08EC, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     750:	20 e0       	ldi	r18, 0x00	; 0
     752:	40 e0       	ldi	r20, 0x00	; 0
     754:	50 e0       	ldi	r21, 0x00	; 0
     756:	60 e0       	ldi	r22, 0x00	; 0
     758:	70 e0       	ldi	r23, 0x00	; 0
     75a:	45 c5       	rjmp	.+2698   	; 0x11e6 <xQueueGenericSend>
     75c:	08 95       	ret

0000075e <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     75e:	cf 93       	push	r28
     760:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     762:	20 e0       	ldi	r18, 0x00	; 0
     764:	4f ef       	ldi	r20, 0xFF	; 255
     766:	5f ef       	ldi	r21, 0xFF	; 255
     768:	60 e0       	ldi	r22, 0x00	; 0
     76a:	70 e0       	ldi	r23, 0x00	; 0
     76c:	80 91 ec 08 	lds	r24, 0x08EC
     770:	90 91 ed 08 	lds	r25, 0x08ED
     774:	2d d6       	rcall	.+3162   	; 0x13d0 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     776:	ec e7       	ldi	r30, 0x7C	; 124
     778:	f0 e0       	ldi	r31, 0x00	; 0
     77a:	80 81       	ld	r24, Z
     77c:	9c 2f       	mov	r25, r28
     77e:	9f 71       	andi	r25, 0x1F	; 31
     780:	80 76       	andi	r24, 0x60	; 96
     782:	89 2b       	or	r24, r25
     784:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     786:	eb e7       	ldi	r30, 0x7B	; 123
     788:	f0 e0       	ldi	r31, 0x00	; 0
     78a:	20 81       	ld	r18, Z
     78c:	c0 72       	andi	r28, 0x20	; 32
     78e:	8c 2f       	mov	r24, r28
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	95 95       	asr	r25
     794:	87 95       	ror	r24
     796:	95 95       	asr	r25
     798:	87 95       	ror	r24
     79a:	92 2f       	mov	r25, r18
     79c:	90 76       	andi	r25, 0x60	; 96
     79e:	89 2b       	or	r24, r25
     7a0:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     7a2:	ea e7       	ldi	r30, 0x7A	; 122
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	80 64       	ori	r24, 0x40	; 64
     7aa:	80 83       	st	Z, r24
}
     7ac:	cf 91       	pop	r28
     7ae:	08 95       	ret

000007b0 <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	4f ef       	ldi	r20, 0xFF	; 255
     7b4:	5f ef       	ldi	r21, 0xFF	; 255
     7b6:	60 e0       	ldi	r22, 0x00	; 0
     7b8:	70 e0       	ldi	r23, 0x00	; 0
     7ba:	80 91 ee 08 	lds	r24, 0x08EE
     7be:	90 91 ef 08 	lds	r25, 0x08EF
     7c2:	06 d6       	rcall	.+3084   	; 0x13d0 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     7c4:	20 e0       	ldi	r18, 0x00	; 0
     7c6:	40 e0       	ldi	r20, 0x00	; 0
     7c8:	50 e0       	ldi	r21, 0x00	; 0
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	70 e0       	ldi	r23, 0x00	; 0
     7ce:	80 91 ec 08 	lds	r24, 0x08EC
     7d2:	90 91 ed 08 	lds	r25, 0x08ED
     7d6:	07 d5       	rcall	.+2574   	; 0x11e6 <xQueueGenericSend>
	return adcReading;
     7d8:	80 91 eb 08 	lds	r24, 0x08EB
     7dc:	08 95       	ret

000007de <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     7de:	cf 93       	push	r28
     7e0:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     7e2:	bd df       	rcall	.-134    	; 0x75e <myADC_startADC>
	return myADC_readADC(channel);
     7e4:	8c 2f       	mov	r24, r28
     7e6:	e4 df       	rcall	.-56     	; 0x7b0 <myADC_readADC>
}
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret

000007ec <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     7ec:	90 93 f5 08 	sts	0x08F5, r25
     7f0:	80 93 f4 08 	sts	0x08F4, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     7f4:	fc 01       	movw	r30, r24
     7f6:	80 81       	ld	r24, Z
     7f8:	91 81       	ldd	r25, Z+1	; 0x01
     7fa:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     7fe:	43 e0       	ldi	r20, 0x03	; 3
     800:	60 e0       	ldi	r22, 0x00	; 0
     802:	81 e0       	ldi	r24, 0x01	; 1
     804:	c6 d4       	rcall	.+2444   	; 0x1192 <xQueueGenericCreate>
     806:	90 93 f1 08 	sts	0x08F1, r25
     80a:	80 93 f0 08 	sts	0x08F0, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     80e:	43 e0       	ldi	r20, 0x03	; 3
     810:	60 e0       	ldi	r22, 0x00	; 0
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	be d4       	rcall	.+2428   	; 0x1192 <xQueueGenericCreate>
     816:	90 93 f3 08 	sts	0x08F3, r25
     81a:	80 93 f2 08 	sts	0x08F2, r24
     81e:	08 95       	ret

00000820 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     820:	86 b5       	in	r24, 0x26	; 38
}
     822:	08 95       	ret

00000824 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     824:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     826:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     828:	9c 01       	movw	r18, r24
     82a:	99 23       	and	r25, r25
     82c:	14 f4       	brge	.+4      	; 0x832 <myTimer_DelayMicro+0xe>
     82e:	2d 5f       	subi	r18, 0xFD	; 253
     830:	3f 4f       	sbci	r19, 0xFF	; 255
     832:	35 95       	asr	r19
     834:	27 95       	ror	r18
     836:	35 95       	asr	r19
     838:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     83a:	24 0f       	add	r18, r20
     83c:	35 1f       	adc	r19, r21
     83e:	30 93 03 02 	sts	0x0203, r19
     842:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     846:	e0 91 f4 08 	lds	r30, 0x08F4
     84a:	f0 91 f5 08 	lds	r31, 0x08F5
     84e:	80 81       	ld	r24, Z
     850:	91 81       	ldd	r25, Z+1	; 0x01
     852:	0e 94 44 0c 	call	0x1888	; 0x1888 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     856:	20 e0       	ldi	r18, 0x00	; 0
     858:	42 e0       	ldi	r20, 0x02	; 2
     85a:	50 e0       	ldi	r21, 0x00	; 0
     85c:	60 e0       	ldi	r22, 0x00	; 0
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	80 91 f0 08 	lds	r24, 0x08F0
     864:	90 91 f1 08 	lds	r25, 0x08F1
     868:	b3 c5       	rjmp	.+2918   	; 0x13d0 <xQueueGenericReceive>
     86a:	08 95       	ret

0000086c <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     86c:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     86e:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     870:	9c 01       	movw	r18, r24
     872:	99 23       	and	r25, r25
     874:	14 f4       	brge	.+4      	; 0x87a <myTimer_DelayMicro2+0xe>
     876:	2d 5f       	subi	r18, 0xFD	; 253
     878:	3f 4f       	sbci	r19, 0xFF	; 255
     87a:	35 95       	asr	r19
     87c:	27 95       	ror	r18
     87e:	35 95       	asr	r19
     880:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     882:	24 0f       	add	r18, r20
     884:	35 1f       	adc	r19, r21
     886:	30 93 01 02 	sts	0x0201, r19
     88a:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     88e:	e0 91 f4 08 	lds	r30, 0x08F4
     892:	f0 91 f5 08 	lds	r31, 0x08F5
     896:	80 81       	ld	r24, Z
     898:	91 81       	ldd	r25, Z+1	; 0x01
     89a:	f6 d7       	rcall	.+4076   	; 0x1888 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     89c:	20 e0       	ldi	r18, 0x00	; 0
     89e:	42 e0       	ldi	r20, 0x02	; 2
     8a0:	50 e0       	ldi	r21, 0x00	; 0
     8a2:	60 e0       	ldi	r22, 0x00	; 0
     8a4:	70 e0       	ldi	r23, 0x00	; 0
     8a6:	80 91 f2 08 	lds	r24, 0x08F2
     8aa:	90 91 f3 08 	lds	r25, 0x08F3
     8ae:	90 c5       	rjmp	.+2848   	; 0x13d0 <xQueueGenericReceive>
     8b0:	08 95       	ret

000008b2 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8b6:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     8b8:	c1 11       	cpse	r28, r1
     8ba:	22 c0       	rjmp	.+68     	; 0x900 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     8bc:	80 91 02 02 	lds	r24, 0x0202
     8c0:	90 91 03 02 	lds	r25, 0x0203
     8c4:	88 38       	cpi	r24, 0x88	; 136
     8c6:	93 41       	sbci	r25, 0x13	; 19
     8c8:	51 f0       	breq	.+20     	; 0x8de <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     8ca:	80 91 02 02 	lds	r24, 0x0202
     8ce:	90 91 03 02 	lds	r25, 0x0203
     8d2:	8a 5f       	subi	r24, 0xFA	; 250
     8d4:	91 09       	sbc	r25, r1
     8d6:	90 93 03 02 	sts	0x0203, r25
     8da:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     8de:	80 91 00 02 	lds	r24, 0x0200
     8e2:	90 91 01 02 	lds	r25, 0x0201
     8e6:	88 38       	cpi	r24, 0x88	; 136
     8e8:	93 41       	sbci	r25, 0x13	; 19
     8ea:	51 f0       	breq	.+20     	; 0x900 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     8ec:	80 91 00 02 	lds	r24, 0x0200
     8f0:	90 91 01 02 	lds	r25, 0x0201
     8f4:	8a 5f       	subi	r24, 0xFA	; 250
     8f6:	91 09       	sbc	r25, r1
     8f8:	90 93 01 02 	sts	0x0201, r25
     8fc:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     900:	d0 e0       	ldi	r29, 0x00	; 0
     902:	80 91 02 02 	lds	r24, 0x0202
     906:	90 91 03 02 	lds	r25, 0x0203
     90a:	8c 17       	cp	r24, r28
     90c:	9d 07       	cpc	r25, r29
     90e:	84 f4       	brge	.+32     	; 0x930 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     910:	88 e8       	ldi	r24, 0x88	; 136
     912:	93 e1       	ldi	r25, 0x13	; 19
     914:	90 93 03 02 	sts	0x0203, r25
     918:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     91c:	20 e0       	ldi	r18, 0x00	; 0
     91e:	40 e0       	ldi	r20, 0x00	; 0
     920:	50 e0       	ldi	r21, 0x00	; 0
     922:	60 e0       	ldi	r22, 0x00	; 0
     924:	70 e0       	ldi	r23, 0x00	; 0
     926:	80 91 f0 08 	lds	r24, 0x08F0
     92a:	90 91 f1 08 	lds	r25, 0x08F1
     92e:	5b d4       	rcall	.+2230   	; 0x11e6 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     930:	80 91 00 02 	lds	r24, 0x0200
     934:	90 91 01 02 	lds	r25, 0x0201
     938:	8c 17       	cp	r24, r28
     93a:	9d 07       	cpc	r25, r29
     93c:	84 f4       	brge	.+32     	; 0x95e <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     93e:	88 e8       	ldi	r24, 0x88	; 136
     940:	93 e1       	ldi	r25, 0x13	; 19
     942:	90 93 01 02 	sts	0x0201, r25
     946:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     94a:	20 e0       	ldi	r18, 0x00	; 0
     94c:	40 e0       	ldi	r20, 0x00	; 0
     94e:	50 e0       	ldi	r21, 0x00	; 0
     950:	60 e0       	ldi	r22, 0x00	; 0
     952:	70 e0       	ldi	r23, 0x00	; 0
     954:	80 91 f2 08 	lds	r24, 0x08F2
     958:	90 91 f3 08 	lds	r25, 0x08F3
     95c:	44 d4       	rcall	.+2184   	; 0x11e6 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     95e:	80 91 02 02 	lds	r24, 0x0202
     962:	90 91 03 02 	lds	r25, 0x0203
     966:	88 38       	cpi	r24, 0x88	; 136
     968:	93 41       	sbci	r25, 0x13	; 19
     96a:	79 f4       	brne	.+30     	; 0x98a <myTimer_DelayChecker+0xd8>
     96c:	80 91 00 02 	lds	r24, 0x0200
     970:	90 91 01 02 	lds	r25, 0x0201
     974:	88 38       	cpi	r24, 0x88	; 136
     976:	93 41       	sbci	r25, 0x13	; 19
     978:	41 f4       	brne	.+16     	; 0x98a <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     97a:	e0 91 f4 08 	lds	r30, 0x08F4
     97e:	f0 91 f5 08 	lds	r31, 0x08F5
     982:	80 81       	ld	r24, Z
     984:	91 81       	ldd	r25, Z+1	; 0x01
     986:	0e 94 fd 0e 	call	0x1dfa	; 0x1dfa <vTaskSuspend>
	}
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	08 95       	ret

00000990 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     990:	1f 92       	push	r1
     992:	0f 92       	push	r0
     994:	0f b6       	in	r0, 0x3f	; 63
     996:	0f 92       	push	r0
     998:	11 24       	eor	r1, r1
     99a:	0b b6       	in	r0, 0x3b	; 59
     99c:	0f 92       	push	r0
     99e:	2f 93       	push	r18
     9a0:	3f 93       	push	r19
     9a2:	4f 93       	push	r20
     9a4:	5f 93       	push	r21
     9a6:	6f 93       	push	r22
     9a8:	7f 93       	push	r23
     9aa:	8f 93       	push	r24
     9ac:	9f 93       	push	r25
     9ae:	af 93       	push	r26
     9b0:	bf 93       	push	r27
     9b2:	ef 93       	push	r30
     9b4:	ff 93       	push	r31
     9b6:	60 91 ce 00 	lds	r22, 0x00CE
     9ba:	89 e8       	ldi	r24, 0x89	; 137
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	d4 d5       	rcall	.+2984   	; 0x1568 <ringBufferPush>
     9c0:	20 e0       	ldi	r18, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	60 e0       	ldi	r22, 0x00	; 0
     9c8:	70 e0       	ldi	r23, 0x00	; 0
     9ca:	80 91 7d 09 	lds	r24, 0x097D
     9ce:	90 91 7e 09 	lds	r25, 0x097E
     9d2:	c4 d4       	rcall	.+2440   	; 0x135c <xQueueGenericSendFromISR>
     9d4:	89 e8       	ldi	r24, 0x89	; 137
     9d6:	99 e0       	ldi	r25, 0x09	; 9
     9d8:	dd d5       	rcall	.+3002   	; 0x1594 <ringBufferFull>
     9da:	ff 91       	pop	r31
     9dc:	ef 91       	pop	r30
     9de:	bf 91       	pop	r27
     9e0:	af 91       	pop	r26
     9e2:	9f 91       	pop	r25
     9e4:	8f 91       	pop	r24
     9e6:	7f 91       	pop	r23
     9e8:	6f 91       	pop	r22
     9ea:	5f 91       	pop	r21
     9ec:	4f 91       	pop	r20
     9ee:	3f 91       	pop	r19
     9f0:	2f 91       	pop	r18
     9f2:	0f 90       	pop	r0
     9f4:	0b be       	out	0x3b, r0	; 59
     9f6:	0f 90       	pop	r0
     9f8:	0f be       	out	0x3f, r0	; 63
     9fa:	0f 90       	pop	r0
     9fc:	1f 90       	pop	r1
     9fe:	18 95       	reti

00000a00 <__vector_25>:
     a00:	1f 92       	push	r1
     a02:	0f 92       	push	r0
     a04:	0f b6       	in	r0, 0x3f	; 63
     a06:	0f 92       	push	r0
     a08:	11 24       	eor	r1, r1
     a0a:	0b b6       	in	r0, 0x3b	; 59
     a0c:	0f 92       	push	r0
     a0e:	2f 93       	push	r18
     a10:	3f 93       	push	r19
     a12:	4f 93       	push	r20
     a14:	5f 93       	push	r21
     a16:	6f 93       	push	r22
     a18:	7f 93       	push	r23
     a1a:	8f 93       	push	r24
     a1c:	9f 93       	push	r25
     a1e:	af 93       	push	r26
     a20:	bf 93       	push	r27
     a22:	ef 93       	push	r30
     a24:	ff 93       	push	r31
     a26:	60 91 c6 00 	lds	r22, 0x00C6
     a2a:	86 e1       	ldi	r24, 0x16	; 22
     a2c:	99 e0       	ldi	r25, 0x09	; 9
     a2e:	9c d5       	rcall	.+2872   	; 0x1568 <ringBufferPush>
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	40 e0       	ldi	r20, 0x00	; 0
     a34:	50 e0       	ldi	r21, 0x00	; 0
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	70 e0       	ldi	r23, 0x00	; 0
     a3a:	80 91 7d 09 	lds	r24, 0x097D
     a3e:	90 91 7e 09 	lds	r25, 0x097E
     a42:	8c d4       	rcall	.+2328   	; 0x135c <xQueueGenericSendFromISR>
     a44:	86 e1       	ldi	r24, 0x16	; 22
     a46:	99 e0       	ldi	r25, 0x09	; 9
     a48:	a5 d5       	rcall	.+2890   	; 0x1594 <ringBufferFull>
     a4a:	ff 91       	pop	r31
     a4c:	ef 91       	pop	r30
     a4e:	bf 91       	pop	r27
     a50:	af 91       	pop	r26
     a52:	9f 91       	pop	r25
     a54:	8f 91       	pop	r24
     a56:	7f 91       	pop	r23
     a58:	6f 91       	pop	r22
     a5a:	5f 91       	pop	r21
     a5c:	4f 91       	pop	r20
     a5e:	3f 91       	pop	r19
     a60:	2f 91       	pop	r18
     a62:	0f 90       	pop	r0
     a64:	0b be       	out	0x3b, r0	; 59
     a66:	0f 90       	pop	r0
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	0f 90       	pop	r0
     a6c:	1f 90       	pop	r1
     a6e:	18 95       	reti

00000a70 <__vector_37>:
     a70:	1f 92       	push	r1
     a72:	0f 92       	push	r0
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	0f 92       	push	r0
     a78:	11 24       	eor	r1, r1
     a7a:	0b b6       	in	r0, 0x3b	; 59
     a7c:	0f 92       	push	r0
     a7e:	2f 93       	push	r18
     a80:	3f 93       	push	r19
     a82:	4f 93       	push	r20
     a84:	5f 93       	push	r21
     a86:	6f 93       	push	r22
     a88:	7f 93       	push	r23
     a8a:	8f 93       	push	r24
     a8c:	9f 93       	push	r25
     a8e:	af 93       	push	r26
     a90:	bf 93       	push	r27
     a92:	ef 93       	push	r30
     a94:	ff 93       	push	r31
     a96:	8f e7       	ldi	r24, 0x7F	; 127
     a98:	99 e0       	ldi	r25, 0x09	; 9
     a9a:	83 d5       	rcall	.+2822   	; 0x15a2 <ringBufferNotEmpty>
     a9c:	88 23       	and	r24, r24
     a9e:	31 f0       	breq	.+12     	; 0xaac <__vector_37+0x3c>
     aa0:	8f e7       	ldi	r24, 0x7F	; 127
     aa2:	99 e0       	ldi	r25, 0x09	; 9
     aa4:	4f d5       	rcall	.+2718   	; 0x1544 <ringBufferPop>
     aa6:	80 93 ce 00 	sts	0x00CE, r24
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <__vector_37+0x46>
     aac:	e9 ec       	ldi	r30, 0xC9	; 201
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	80 81       	ld	r24, Z
     ab2:	8f 7d       	andi	r24, 0xDF	; 223
     ab4:	80 83       	st	Z, r24
     ab6:	ff 91       	pop	r31
     ab8:	ef 91       	pop	r30
     aba:	bf 91       	pop	r27
     abc:	af 91       	pop	r26
     abe:	9f 91       	pop	r25
     ac0:	8f 91       	pop	r24
     ac2:	7f 91       	pop	r23
     ac4:	6f 91       	pop	r22
     ac6:	5f 91       	pop	r21
     ac8:	4f 91       	pop	r20
     aca:	3f 91       	pop	r19
     acc:	2f 91       	pop	r18
     ace:	0f 90       	pop	r0
     ad0:	0b be       	out	0x3b, r0	; 59
     ad2:	0f 90       	pop	r0
     ad4:	0f be       	out	0x3f, r0	; 63
     ad6:	0f 90       	pop	r0
     ad8:	1f 90       	pop	r1
     ada:	18 95       	reti

00000adc <__vector_26>:
     adc:	1f 92       	push	r1
     ade:	0f 92       	push	r0
     ae0:	0f b6       	in	r0, 0x3f	; 63
     ae2:	0f 92       	push	r0
     ae4:	11 24       	eor	r1, r1
     ae6:	0b b6       	in	r0, 0x3b	; 59
     ae8:	0f 92       	push	r0
     aea:	2f 93       	push	r18
     aec:	3f 93       	push	r19
     aee:	4f 93       	push	r20
     af0:	5f 93       	push	r21
     af2:	6f 93       	push	r22
     af4:	7f 93       	push	r23
     af6:	8f 93       	push	r24
     af8:	9f 93       	push	r25
     afa:	af 93       	push	r26
     afc:	bf 93       	push	r27
     afe:	ef 93       	push	r30
     b00:	ff 93       	push	r31
     b02:	84 e8       	ldi	r24, 0x84	; 132
     b04:	99 e0       	ldi	r25, 0x09	; 9
     b06:	4d d5       	rcall	.+2714   	; 0x15a2 <ringBufferNotEmpty>
     b08:	88 23       	and	r24, r24
     b0a:	31 f0       	breq	.+12     	; 0xb18 <__vector_26+0x3c>
     b0c:	84 e8       	ldi	r24, 0x84	; 132
     b0e:	99 e0       	ldi	r25, 0x09	; 9
     b10:	19 d5       	rcall	.+2610   	; 0x1544 <ringBufferPop>
     b12:	80 93 c6 00 	sts	0x00C6, r24
     b16:	05 c0       	rjmp	.+10     	; 0xb22 <__vector_26+0x46>
     b18:	e1 ec       	ldi	r30, 0xC1	; 193
     b1a:	f0 e0       	ldi	r31, 0x00	; 0
     b1c:	80 81       	ld	r24, Z
     b1e:	8f 7d       	andi	r24, 0xDF	; 223
     b20:	80 83       	st	Z, r24
     b22:	ff 91       	pop	r31
     b24:	ef 91       	pop	r30
     b26:	bf 91       	pop	r27
     b28:	af 91       	pop	r26
     b2a:	9f 91       	pop	r25
     b2c:	8f 91       	pop	r24
     b2e:	7f 91       	pop	r23
     b30:	6f 91       	pop	r22
     b32:	5f 91       	pop	r21
     b34:	4f 91       	pop	r20
     b36:	3f 91       	pop	r19
     b38:	2f 91       	pop	r18
     b3a:	0f 90       	pop	r0
     b3c:	0b be       	out	0x3b, r0	; 59
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63
     b42:	0f 90       	pop	r0
     b44:	1f 90       	pop	r1
     b46:	18 95       	reti

00000b48 <myUSART_USART0_Init>:
     b48:	10 92 c5 00 	sts	0x00C5, r1
     b4c:	87 e6       	ldi	r24, 0x67	; 103
     b4e:	80 93 c4 00 	sts	0x00C4, r24
     b52:	88 eb       	ldi	r24, 0xB8	; 184
     b54:	80 93 c1 00 	sts	0x00C1, r24
     b58:	86 e0       	ldi	r24, 0x06	; 6
     b5a:	80 93 c2 00 	sts	0x00C2, r24
     b5e:	40 e2       	ldi	r20, 0x20	; 32
     b60:	6b e3       	ldi	r22, 0x3B	; 59
     b62:	79 e0       	ldi	r23, 0x09	; 9
     b64:	86 e1       	ldi	r24, 0x16	; 22
     b66:	99 e0       	ldi	r25, 0x09	; 9
     b68:	e6 d4       	rcall	.+2508   	; 0x1536 <ringBufferInit>
     b6a:	40 e2       	ldi	r20, 0x20	; 32
     b6c:	6b e1       	ldi	r22, 0x1B	; 27
     b6e:	79 e0       	ldi	r23, 0x09	; 9
     b70:	84 e8       	ldi	r24, 0x84	; 132
     b72:	99 e0       	ldi	r25, 0x09	; 9
     b74:	e0 d4       	rcall	.+2496   	; 0x1536 <ringBufferInit>
     b76:	43 e0       	ldi	r20, 0x03	; 3
     b78:	60 e0       	ldi	r22, 0x00	; 0
     b7a:	81 e0       	ldi	r24, 0x01	; 1
     b7c:	0a d3       	rcall	.+1556   	; 0x1192 <xQueueGenericCreate>
     b7e:	90 93 7c 09 	sts	0x097C, r25
     b82:	80 93 7b 09 	sts	0x097B, r24
     b86:	08 95       	ret

00000b88 <myUSART_USART1_Init>:
     b88:	10 92 cd 00 	sts	0x00CD, r1
     b8c:	87 e6       	ldi	r24, 0x67	; 103
     b8e:	80 93 cc 00 	sts	0x00CC, r24
     b92:	88 eb       	ldi	r24, 0xB8	; 184
     b94:	80 93 c9 00 	sts	0x00C9, r24
     b98:	86 e0       	ldi	r24, 0x06	; 6
     b9a:	80 93 ca 00 	sts	0x00CA, r24
     b9e:	40 e2       	ldi	r20, 0x20	; 32
     ba0:	66 ef       	ldi	r22, 0xF6	; 246
     ba2:	78 e0       	ldi	r23, 0x08	; 8
     ba4:	89 e8       	ldi	r24, 0x89	; 137
     ba6:	99 e0       	ldi	r25, 0x09	; 9
     ba8:	c6 d4       	rcall	.+2444   	; 0x1536 <ringBufferInit>
     baa:	40 e2       	ldi	r20, 0x20	; 32
     bac:	6b e5       	ldi	r22, 0x5B	; 91
     bae:	79 e0       	ldi	r23, 0x09	; 9
     bb0:	8f e7       	ldi	r24, 0x7F	; 127
     bb2:	99 e0       	ldi	r25, 0x09	; 9
     bb4:	c0 d4       	rcall	.+2432   	; 0x1536 <ringBufferInit>
     bb6:	43 e0       	ldi	r20, 0x03	; 3
     bb8:	60 e0       	ldi	r22, 0x00	; 0
     bba:	81 e0       	ldi	r24, 0x01	; 1
     bbc:	ea d2       	rcall	.+1492   	; 0x1192 <xQueueGenericCreate>
     bbe:	90 93 7e 09 	sts	0x097E, r25
     bc2:	80 93 7d 09 	sts	0x097D, r24
     bc6:	08 95       	ret

00000bc8 <myUSART_transmitUSART0_c>:
     bc8:	cf 93       	push	r28
     bca:	c8 2f       	mov	r28, r24
     bcc:	84 e8       	ldi	r24, 0x84	; 132
     bce:	99 e0       	ldi	r25, 0x09	; 9
     bd0:	e1 d4       	rcall	.+2498   	; 0x1594 <ringBufferFull>
     bd2:	81 11       	cpse	r24, r1
     bd4:	fb cf       	rjmp	.-10     	; 0xbcc <myUSART_transmitUSART0_c+0x4>
     bd6:	6c 2f       	mov	r22, r28
     bd8:	84 e8       	ldi	r24, 0x84	; 132
     bda:	99 e0       	ldi	r25, 0x09	; 9
     bdc:	c5 d4       	rcall	.+2442   	; 0x1568 <ringBufferPush>
     bde:	e1 ec       	ldi	r30, 0xC1	; 193
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	80 81       	ld	r24, Z
     be4:	80 62       	ori	r24, 0x20	; 32
     be6:	80 83       	st	Z, r24
     be8:	e0 ec       	ldi	r30, 0xC0	; 192
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	80 81       	ld	r24, Z
     bee:	80 64       	ori	r24, 0x40	; 64
     bf0:	80 83       	st	Z, r24
     bf2:	cf 91       	pop	r28
     bf4:	08 95       	ret

00000bf6 <myUSART_transmitUSART1_c>:
     bf6:	cf 93       	push	r28
     bf8:	c8 2f       	mov	r28, r24
     bfa:	8f e7       	ldi	r24, 0x7F	; 127
     bfc:	99 e0       	ldi	r25, 0x09	; 9
     bfe:	ca d4       	rcall	.+2452   	; 0x1594 <ringBufferFull>
     c00:	81 11       	cpse	r24, r1
     c02:	fb cf       	rjmp	.-10     	; 0xbfa <myUSART_transmitUSART1_c+0x4>
     c04:	6c 2f       	mov	r22, r28
     c06:	8f e7       	ldi	r24, 0x7F	; 127
     c08:	99 e0       	ldi	r25, 0x09	; 9
     c0a:	ae d4       	rcall	.+2396   	; 0x1568 <ringBufferPush>
     c0c:	e9 ec       	ldi	r30, 0xC9	; 201
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	80 81       	ld	r24, Z
     c12:	80 62       	ori	r24, 0x20	; 32
     c14:	80 83       	st	Z, r24
     c16:	e8 ec       	ldi	r30, 0xC8	; 200
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	80 81       	ld	r24, Z
     c1c:	80 64       	ori	r24, 0x40	; 64
     c1e:	80 83       	st	Z, r24
     c20:	cf 91       	pop	r28
     c22:	08 95       	ret

00000c24 <myUSART_transmitUSART0>:
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	ec 01       	movw	r28, r24
     c2a:	88 81       	ld	r24, Y
     c2c:	88 23       	and	r24, r24
     c2e:	29 f0       	breq	.+10     	; 0xc3a <myUSART_transmitUSART0+0x16>
     c30:	21 96       	adiw	r28, 0x01	; 1
     c32:	ca df       	rcall	.-108    	; 0xbc8 <myUSART_transmitUSART0_c>
     c34:	89 91       	ld	r24, Y+
     c36:	81 11       	cpse	r24, r1
     c38:	fc cf       	rjmp	.-8      	; 0xc32 <myUSART_transmitUSART0+0xe>
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	08 95       	ret

00000c40 <myUSART_receiveUSART1>:
     c40:	cf 93       	push	r28
     c42:	20 e0       	ldi	r18, 0x00	; 0
     c44:	4f ef       	ldi	r20, 0xFF	; 255
     c46:	5f ef       	ldi	r21, 0xFF	; 255
     c48:	60 e0       	ldi	r22, 0x00	; 0
     c4a:	70 e0       	ldi	r23, 0x00	; 0
     c4c:	80 91 7b 09 	lds	r24, 0x097B
     c50:	90 91 7c 09 	lds	r25, 0x097C
     c54:	bd d3       	rcall	.+1914   	; 0x13d0 <xQueueGenericReceive>
     c56:	89 e8       	ldi	r24, 0x89	; 137
     c58:	99 e0       	ldi	r25, 0x09	; 9
     c5a:	74 d4       	rcall	.+2280   	; 0x1544 <ringBufferPop>
     c5c:	c8 2f       	mov	r28, r24
     c5e:	89 e8       	ldi	r24, 0x89	; 137
     c60:	99 e0       	ldi	r25, 0x09	; 9
     c62:	9f d4       	rcall	.+2366   	; 0x15a2 <ringBufferNotEmpty>
     c64:	88 23       	and	r24, r24
     c66:	51 f0       	breq	.+20     	; 0xc7c <myUSART_receiveUSART1+0x3c>
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	40 e0       	ldi	r20, 0x00	; 0
     c6c:	50 e0       	ldi	r21, 0x00	; 0
     c6e:	60 e0       	ldi	r22, 0x00	; 0
     c70:	70 e0       	ldi	r23, 0x00	; 0
     c72:	80 91 7b 09 	lds	r24, 0x097B
     c76:	90 91 7c 09 	lds	r25, 0x097C
     c7a:	b5 d2       	rcall	.+1386   	; 0x11e6 <xQueueGenericSend>
     c7c:	8c 2f       	mov	r24, r28
     c7e:	cf 91       	pop	r28
     c80:	08 95       	ret

00000c82 <myUSART_startHandShake>:

// -1 if fail, 0 success
char myUSART_startHandShake()
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	b8 df       	rcall	.-144    	; 0xbf6 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
     c86:	dc df       	rcall	.-72     	; 0xc40 <myUSART_receiveUSART1>
     c88:	85 35       	cpi	r24, 0x55	; 85
     c8a:	21 f4       	brne	.+8      	; 0xc94 <myUSART_startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
     c8c:	8f ef       	ldi	r24, 0xFF	; 255
     c8e:	b3 df       	rcall	.-154    	; 0xbf6 <myUSART_transmitUSART1_c>
	
	return 0;
     c90:	80 e0       	ldi	r24, 0x00	; 0
     c92:	08 95       	ret
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
	{
		return -1; //error handling
     c94:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     c96:	08 95       	ret

00000c98 <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c98:	d3 df       	rcall	.-90     	; 0xc40 <myUSART_receiveUSART1>
     c9a:	81 11       	cpse	r24, r1
     c9c:	0a c0       	rjmp	.+20     	; 0xcb2 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     c9e:	85 e5       	ldi	r24, 0x55	; 85
     ca0:	aa df       	rcall	.-172    	; 0xbf6 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     ca2:	ce df       	rcall	.-100    	; 0xc40 <myUSART_receiveUSART1>
     ca4:	91 e0       	ldi	r25, 0x01	; 1
     ca6:	81 11       	cpse	r24, r1
     ca8:	01 c0       	rjmp	.+2      	; 0xcac <myUSART_waitForHandshake+0x14>
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	89 2f       	mov	r24, r25
     cae:	81 95       	neg	r24
     cb0:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     cb2:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     cb4:	08 95       	ret

00000cb6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     cb6:	31 e1       	ldi	r19, 0x11	; 17
     cb8:	fc 01       	movw	r30, r24
     cba:	30 83       	st	Z, r19
     cbc:	31 97       	sbiw	r30, 0x01	; 1
     cbe:	22 e2       	ldi	r18, 0x22	; 34
     cc0:	20 83       	st	Z, r18
     cc2:	31 97       	sbiw	r30, 0x01	; 1
     cc4:	a3 e3       	ldi	r26, 0x33	; 51
     cc6:	a0 83       	st	Z, r26
     cc8:	31 97       	sbiw	r30, 0x01	; 1
     cca:	60 83       	st	Z, r22
     ccc:	31 97       	sbiw	r30, 0x01	; 1
     cce:	70 83       	st	Z, r23
     cd0:	31 97       	sbiw	r30, 0x01	; 1
     cd2:	10 82       	st	Z, r1
     cd4:	31 97       	sbiw	r30, 0x01	; 1
     cd6:	10 82       	st	Z, r1
     cd8:	31 97       	sbiw	r30, 0x01	; 1
     cda:	60 e8       	ldi	r22, 0x80	; 128
     cdc:	60 83       	st	Z, r22
     cde:	31 97       	sbiw	r30, 0x01	; 1
     ce0:	10 82       	st	Z, r1
     ce2:	31 97       	sbiw	r30, 0x01	; 1
     ce4:	10 82       	st	Z, r1
     ce6:	31 97       	sbiw	r30, 0x01	; 1
     ce8:	10 82       	st	Z, r1
     cea:	31 97       	sbiw	r30, 0x01	; 1
     cec:	62 e0       	ldi	r22, 0x02	; 2
     cee:	60 83       	st	Z, r22
     cf0:	31 97       	sbiw	r30, 0x01	; 1
     cf2:	63 e0       	ldi	r22, 0x03	; 3
     cf4:	60 83       	st	Z, r22
     cf6:	31 97       	sbiw	r30, 0x01	; 1
     cf8:	64 e0       	ldi	r22, 0x04	; 4
     cfa:	60 83       	st	Z, r22
     cfc:	31 97       	sbiw	r30, 0x01	; 1
     cfe:	65 e0       	ldi	r22, 0x05	; 5
     d00:	60 83       	st	Z, r22
     d02:	31 97       	sbiw	r30, 0x01	; 1
     d04:	66 e0       	ldi	r22, 0x06	; 6
     d06:	60 83       	st	Z, r22
     d08:	31 97       	sbiw	r30, 0x01	; 1
     d0a:	67 e0       	ldi	r22, 0x07	; 7
     d0c:	60 83       	st	Z, r22
     d0e:	31 97       	sbiw	r30, 0x01	; 1
     d10:	68 e0       	ldi	r22, 0x08	; 8
     d12:	60 83       	st	Z, r22
     d14:	31 97       	sbiw	r30, 0x01	; 1
     d16:	69 e0       	ldi	r22, 0x09	; 9
     d18:	60 83       	st	Z, r22
     d1a:	31 97       	sbiw	r30, 0x01	; 1
     d1c:	60 e1       	ldi	r22, 0x10	; 16
     d1e:	60 83       	st	Z, r22
     d20:	31 97       	sbiw	r30, 0x01	; 1
     d22:	30 83       	st	Z, r19
     d24:	31 97       	sbiw	r30, 0x01	; 1
     d26:	32 e1       	ldi	r19, 0x12	; 18
     d28:	30 83       	st	Z, r19
     d2a:	31 97       	sbiw	r30, 0x01	; 1
     d2c:	33 e1       	ldi	r19, 0x13	; 19
     d2e:	30 83       	st	Z, r19
     d30:	31 97       	sbiw	r30, 0x01	; 1
     d32:	34 e1       	ldi	r19, 0x14	; 20
     d34:	30 83       	st	Z, r19
     d36:	31 97       	sbiw	r30, 0x01	; 1
     d38:	35 e1       	ldi	r19, 0x15	; 21
     d3a:	30 83       	st	Z, r19
     d3c:	31 97       	sbiw	r30, 0x01	; 1
     d3e:	36 e1       	ldi	r19, 0x16	; 22
     d40:	30 83       	st	Z, r19
     d42:	31 97       	sbiw	r30, 0x01	; 1
     d44:	37 e1       	ldi	r19, 0x17	; 23
     d46:	30 83       	st	Z, r19
     d48:	31 97       	sbiw	r30, 0x01	; 1
     d4a:	38 e1       	ldi	r19, 0x18	; 24
     d4c:	30 83       	st	Z, r19
     d4e:	31 97       	sbiw	r30, 0x01	; 1
     d50:	39 e1       	ldi	r19, 0x19	; 25
     d52:	30 83       	st	Z, r19
     d54:	31 97       	sbiw	r30, 0x01	; 1
     d56:	30 e2       	ldi	r19, 0x20	; 32
     d58:	30 83       	st	Z, r19
     d5a:	31 97       	sbiw	r30, 0x01	; 1
     d5c:	31 e2       	ldi	r19, 0x21	; 33
     d5e:	30 83       	st	Z, r19
     d60:	31 97       	sbiw	r30, 0x01	; 1
     d62:	20 83       	st	Z, r18
     d64:	31 97       	sbiw	r30, 0x01	; 1
     d66:	23 e2       	ldi	r18, 0x23	; 35
     d68:	20 83       	st	Z, r18
     d6a:	31 97       	sbiw	r30, 0x01	; 1
     d6c:	40 83       	st	Z, r20
     d6e:	31 97       	sbiw	r30, 0x01	; 1
     d70:	50 83       	st	Z, r21
     d72:	31 97       	sbiw	r30, 0x01	; 1
     d74:	26 e2       	ldi	r18, 0x26	; 38
     d76:	20 83       	st	Z, r18
     d78:	31 97       	sbiw	r30, 0x01	; 1
     d7a:	27 e2       	ldi	r18, 0x27	; 39
     d7c:	20 83       	st	Z, r18
     d7e:	31 97       	sbiw	r30, 0x01	; 1
     d80:	28 e2       	ldi	r18, 0x28	; 40
     d82:	20 83       	st	Z, r18
     d84:	31 97       	sbiw	r30, 0x01	; 1
     d86:	29 e2       	ldi	r18, 0x29	; 41
     d88:	20 83       	st	Z, r18
     d8a:	31 97       	sbiw	r30, 0x01	; 1
     d8c:	20 e3       	ldi	r18, 0x30	; 48
     d8e:	20 83       	st	Z, r18
     d90:	31 97       	sbiw	r30, 0x01	; 1
     d92:	21 e3       	ldi	r18, 0x31	; 49
     d94:	20 83       	st	Z, r18
     d96:	89 97       	sbiw	r24, 0x29	; 41
     d98:	08 95       	ret

00000d9a <xPortStartScheduler>:
     d9a:	82 e0       	ldi	r24, 0x02	; 2
     d9c:	84 bd       	out	0x24, r24	; 36
     d9e:	16 bc       	out	0x26, r1	; 38
     da0:	80 e3       	ldi	r24, 0x30	; 48
     da2:	87 bd       	out	0x27, r24	; 39
     da4:	ee e6       	ldi	r30, 0x6E	; 110
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	80 81       	ld	r24, Z
     daa:	82 60       	ori	r24, 0x02	; 2
     dac:	80 83       	st	Z, r24
     dae:	83 e0       	ldi	r24, 0x03	; 3
     db0:	85 bd       	out	0x25, r24	; 37
     db2:	a0 91 dd 08 	lds	r26, 0x08DD
     db6:	b0 91 de 08 	lds	r27, 0x08DE
     dba:	cd 91       	ld	r28, X+
     dbc:	cd bf       	out	0x3d, r28	; 61
     dbe:	dd 91       	ld	r29, X+
     dc0:	de bf       	out	0x3e, r29	; 62
     dc2:	ff 91       	pop	r31
     dc4:	ef 91       	pop	r30
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	bf 91       	pop	r27
     dcc:	af 91       	pop	r26
     dce:	9f 91       	pop	r25
     dd0:	8f 91       	pop	r24
     dd2:	7f 91       	pop	r23
     dd4:	6f 91       	pop	r22
     dd6:	5f 91       	pop	r21
     dd8:	4f 91       	pop	r20
     dda:	3f 91       	pop	r19
     ddc:	2f 91       	pop	r18
     dde:	1f 91       	pop	r17
     de0:	0f 91       	pop	r16
     de2:	ff 90       	pop	r15
     de4:	ef 90       	pop	r14
     de6:	df 90       	pop	r13
     de8:	cf 90       	pop	r12
     dea:	bf 90       	pop	r11
     dec:	af 90       	pop	r10
     dee:	9f 90       	pop	r9
     df0:	8f 90       	pop	r8
     df2:	7f 90       	pop	r7
     df4:	6f 90       	pop	r6
     df6:	5f 90       	pop	r5
     df8:	4f 90       	pop	r4
     dfa:	3f 90       	pop	r3
     dfc:	2f 90       	pop	r2
     dfe:	1f 90       	pop	r1
     e00:	0f 90       	pop	r0
     e02:	0c be       	out	0x3c, r0	; 60
     e04:	0f 90       	pop	r0
     e06:	0b be       	out	0x3b, r0	; 59
     e08:	0f 90       	pop	r0
     e0a:	0f be       	out	0x3f, r0	; 63
     e0c:	0f 90       	pop	r0
     e0e:	08 95       	ret
     e10:	81 e0       	ldi	r24, 0x01	; 1
     e12:	08 95       	ret

00000e14 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e14:	0f 92       	push	r0
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	0f 92       	push	r0
     e1c:	0b b6       	in	r0, 0x3b	; 59
     e1e:	0f 92       	push	r0
     e20:	0c b6       	in	r0, 0x3c	; 60
     e22:	0f 92       	push	r0
     e24:	1f 92       	push	r1
     e26:	11 24       	eor	r1, r1
     e28:	2f 92       	push	r2
     e2a:	3f 92       	push	r3
     e2c:	4f 92       	push	r4
     e2e:	5f 92       	push	r5
     e30:	6f 92       	push	r6
     e32:	7f 92       	push	r7
     e34:	8f 92       	push	r8
     e36:	9f 92       	push	r9
     e38:	af 92       	push	r10
     e3a:	bf 92       	push	r11
     e3c:	cf 92       	push	r12
     e3e:	df 92       	push	r13
     e40:	ef 92       	push	r14
     e42:	ff 92       	push	r15
     e44:	0f 93       	push	r16
     e46:	1f 93       	push	r17
     e48:	2f 93       	push	r18
     e4a:	3f 93       	push	r19
     e4c:	4f 93       	push	r20
     e4e:	5f 93       	push	r21
     e50:	6f 93       	push	r22
     e52:	7f 93       	push	r23
     e54:	8f 93       	push	r24
     e56:	9f 93       	push	r25
     e58:	af 93       	push	r26
     e5a:	bf 93       	push	r27
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	ef 93       	push	r30
     e62:	ff 93       	push	r31
     e64:	a0 91 dd 08 	lds	r26, 0x08DD
     e68:	b0 91 de 08 	lds	r27, 0x08DE
     e6c:	0d b6       	in	r0, 0x3d	; 61
     e6e:	0d 92       	st	X+, r0
     e70:	0e b6       	in	r0, 0x3e	; 62
     e72:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e74:	64 d7       	rcall	.+3784   	; 0x1d3e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e76:	a0 91 dd 08 	lds	r26, 0x08DD
     e7a:	b0 91 de 08 	lds	r27, 0x08DE
     e7e:	cd 91       	ld	r28, X+
     e80:	cd bf       	out	0x3d, r28	; 61
     e82:	dd 91       	ld	r29, X+
     e84:	de bf       	out	0x3e, r29	; 62
     e86:	ff 91       	pop	r31
     e88:	ef 91       	pop	r30
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	bf 91       	pop	r27
     e90:	af 91       	pop	r26
     e92:	9f 91       	pop	r25
     e94:	8f 91       	pop	r24
     e96:	7f 91       	pop	r23
     e98:	6f 91       	pop	r22
     e9a:	5f 91       	pop	r21
     e9c:	4f 91       	pop	r20
     e9e:	3f 91       	pop	r19
     ea0:	2f 91       	pop	r18
     ea2:	1f 91       	pop	r17
     ea4:	0f 91       	pop	r16
     ea6:	ff 90       	pop	r15
     ea8:	ef 90       	pop	r14
     eaa:	df 90       	pop	r13
     eac:	cf 90       	pop	r12
     eae:	bf 90       	pop	r11
     eb0:	af 90       	pop	r10
     eb2:	9f 90       	pop	r9
     eb4:	8f 90       	pop	r8
     eb6:	7f 90       	pop	r7
     eb8:	6f 90       	pop	r6
     eba:	5f 90       	pop	r5
     ebc:	4f 90       	pop	r4
     ebe:	3f 90       	pop	r3
     ec0:	2f 90       	pop	r2
     ec2:	1f 90       	pop	r1
     ec4:	0f 90       	pop	r0
     ec6:	0c be       	out	0x3c, r0	; 60
     ec8:	0f 90       	pop	r0
     eca:	0b be       	out	0x3b, r0	; 59
     ecc:	0f 90       	pop	r0
     ece:	0f be       	out	0x3f, r0	; 63
     ed0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ed2:	08 95       	ret

00000ed4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     ed4:	0f 92       	push	r0
     ed6:	0f b6       	in	r0, 0x3f	; 63
     ed8:	f8 94       	cli
     eda:	0f 92       	push	r0
     edc:	0b b6       	in	r0, 0x3b	; 59
     ede:	0f 92       	push	r0
     ee0:	0c b6       	in	r0, 0x3c	; 60
     ee2:	0f 92       	push	r0
     ee4:	1f 92       	push	r1
     ee6:	11 24       	eor	r1, r1
     ee8:	2f 92       	push	r2
     eea:	3f 92       	push	r3
     eec:	4f 92       	push	r4
     eee:	5f 92       	push	r5
     ef0:	6f 92       	push	r6
     ef2:	7f 92       	push	r7
     ef4:	8f 92       	push	r8
     ef6:	9f 92       	push	r9
     ef8:	af 92       	push	r10
     efa:	bf 92       	push	r11
     efc:	cf 92       	push	r12
     efe:	df 92       	push	r13
     f00:	ef 92       	push	r14
     f02:	ff 92       	push	r15
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	2f 93       	push	r18
     f0a:	3f 93       	push	r19
     f0c:	4f 93       	push	r20
     f0e:	5f 93       	push	r21
     f10:	6f 93       	push	r22
     f12:	7f 93       	push	r23
     f14:	8f 93       	push	r24
     f16:	9f 93       	push	r25
     f18:	af 93       	push	r26
     f1a:	bf 93       	push	r27
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ef 93       	push	r30
     f22:	ff 93       	push	r31
     f24:	a0 91 dd 08 	lds	r26, 0x08DD
     f28:	b0 91 de 08 	lds	r27, 0x08DE
     f2c:	0d b6       	in	r0, 0x3d	; 61
     f2e:	0d 92       	st	X+, r0
     f30:	0e b6       	in	r0, 0x3e	; 62
     f32:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f34:	32 d5       	rcall	.+2660   	; 0x199a <xTaskIncrementTick>
     f36:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     f38:	02 d7       	rcall	.+3588   	; 0x1d3e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f3a:	a0 91 dd 08 	lds	r26, 0x08DD
     f3e:	b0 91 de 08 	lds	r27, 0x08DE
     f42:	cd 91       	ld	r28, X+
     f44:	cd bf       	out	0x3d, r28	; 61
     f46:	dd 91       	ld	r29, X+
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	ff 91       	pop	r31
     f4c:	ef 91       	pop	r30
     f4e:	df 91       	pop	r29
     f50:	cf 91       	pop	r28
     f52:	bf 91       	pop	r27
     f54:	af 91       	pop	r26
     f56:	9f 91       	pop	r25
     f58:	8f 91       	pop	r24
     f5a:	7f 91       	pop	r23
     f5c:	6f 91       	pop	r22
     f5e:	5f 91       	pop	r21
     f60:	4f 91       	pop	r20
     f62:	3f 91       	pop	r19
     f64:	2f 91       	pop	r18
     f66:	1f 91       	pop	r17
     f68:	0f 91       	pop	r16
     f6a:	ff 90       	pop	r15
     f6c:	ef 90       	pop	r14
     f6e:	df 90       	pop	r13
     f70:	cf 90       	pop	r12
     f72:	bf 90       	pop	r11
     f74:	af 90       	pop	r10
     f76:	9f 90       	pop	r9
     f78:	8f 90       	pop	r8
     f7a:	7f 90       	pop	r7
     f7c:	6f 90       	pop	r6
     f7e:	5f 90       	pop	r5
     f80:	4f 90       	pop	r4
     f82:	3f 90       	pop	r3
     f84:	2f 90       	pop	r2
     f86:	1f 90       	pop	r1
     f88:	0f 90       	pop	r0
     f8a:	0c be       	out	0x3c, r0	; 60
     f8c:	0f 90       	pop	r0
     f8e:	0b be       	out	0x3b, r0	; 59
     f90:	0f 90       	pop	r0
     f92:	0f be       	out	0x3f, r0	; 63
     f94:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f96:	08 95       	ret

00000f98 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     f98:	9d df       	rcall	.-198    	; 0xed4 <vPortYieldFromTick>
		 asm volatile ("reti");
     f9a:	18 95       	reti

00000f9c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f9c:	1f 93       	push	r17
     f9e:	cf 93       	push	r28
     fa0:	df 93       	push	r29
     fa2:	ec 01       	movw	r28, r24
     fa4:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     fa6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fa8:	81 11       	cpse	r24, r1
     faa:	0c c0       	rjmp	.+24     	; 0xfc4 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fac:	88 81       	ld	r24, Y
     fae:	99 81       	ldd	r25, Y+1	; 0x01
     fb0:	89 2b       	or	r24, r25
     fb2:	09 f0       	breq	.+2      	; 0xfb6 <prvCopyDataToQueue+0x1a>
     fb4:	47 c0       	rjmp	.+142    	; 0x1044 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     fb6:	8a 81       	ldd	r24, Y+2	; 0x02
     fb8:	9b 81       	ldd	r25, Y+3	; 0x03
     fba:	0e 94 62 10 	call	0x20c4	; 0x20c4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     fbe:	1b 82       	std	Y+3, r1	; 0x03
     fc0:	1a 82       	std	Y+2, r1	; 0x02
     fc2:	47 c0       	rjmp	.+142    	; 0x1052 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     fc4:	41 11       	cpse	r20, r1
     fc6:	18 c0       	rjmp	.+48     	; 0xff8 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     fc8:	48 2f       	mov	r20, r24
     fca:	50 e0       	ldi	r21, 0x00	; 0
     fcc:	8c 81       	ldd	r24, Y+4	; 0x04
     fce:	9d 81       	ldd	r25, Y+5	; 0x05
     fd0:	0e 94 da 10 	call	0x21b4	; 0x21b4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     fd4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fd6:	8c 81       	ldd	r24, Y+4	; 0x04
     fd8:	9d 81       	ldd	r25, Y+5	; 0x05
     fda:	82 0f       	add	r24, r18
     fdc:	91 1d       	adc	r25, r1
     fde:	9d 83       	std	Y+5, r25	; 0x05
     fe0:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     fe2:	2a 81       	ldd	r18, Y+2	; 0x02
     fe4:	3b 81       	ldd	r19, Y+3	; 0x03
     fe6:	82 17       	cp	r24, r18
     fe8:	93 07       	cpc	r25, r19
     fea:	70 f1       	brcs	.+92     	; 0x1048 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     fec:	88 81       	ld	r24, Y
     fee:	99 81       	ldd	r25, Y+1	; 0x01
     ff0:	9d 83       	std	Y+5, r25	; 0x05
     ff2:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	2d c0       	rjmp	.+90     	; 0x1052 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ff8:	48 2f       	mov	r20, r24
     ffa:	50 e0       	ldi	r21, 0x00	; 0
     ffc:	8e 81       	ldd	r24, Y+6	; 0x06
     ffe:	9f 81       	ldd	r25, Y+7	; 0x07
    1000:	0e 94 da 10 	call	0x21b4	; 0x21b4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1004:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1006:	30 e0       	ldi	r19, 0x00	; 0
    1008:	31 95       	neg	r19
    100a:	21 95       	neg	r18
    100c:	31 09       	sbc	r19, r1
    100e:	8e 81       	ldd	r24, Y+6	; 0x06
    1010:	9f 81       	ldd	r25, Y+7	; 0x07
    1012:	82 0f       	add	r24, r18
    1014:	93 1f       	adc	r25, r19
    1016:	9f 83       	std	Y+7, r25	; 0x07
    1018:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    101a:	68 81       	ld	r22, Y
    101c:	79 81       	ldd	r23, Y+1	; 0x01
    101e:	86 17       	cp	r24, r22
    1020:	97 07       	cpc	r25, r23
    1022:	30 f4       	brcc	.+12     	; 0x1030 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1024:	8a 81       	ldd	r24, Y+2	; 0x02
    1026:	9b 81       	ldd	r25, Y+3	; 0x03
    1028:	28 0f       	add	r18, r24
    102a:	39 1f       	adc	r19, r25
    102c:	3f 83       	std	Y+7, r19	; 0x07
    102e:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1030:	12 30       	cpi	r17, 0x02	; 2
    1032:	61 f4       	brne	.+24     	; 0x104c <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1034:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1036:	88 23       	and	r24, r24
    1038:	59 f0       	breq	.+22     	; 0x1050 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    103a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    103c:	81 50       	subi	r24, 0x01	; 1
    103e:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1040:	80 e0       	ldi	r24, 0x00	; 0
    1042:	07 c0       	rjmp	.+14     	; 0x1052 <prvCopyDataToQueue+0xb6>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	05 c0       	rjmp	.+10     	; 0x1052 <prvCopyDataToQueue+0xb6>
    1048:	80 e0       	ldi	r24, 0x00	; 0
    104a:	03 c0       	rjmp	.+6      	; 0x1052 <prvCopyDataToQueue+0xb6>
    104c:	80 e0       	ldi	r24, 0x00	; 0
    104e:	01 c0       	rjmp	.+2      	; 0x1052 <prvCopyDataToQueue+0xb6>
    1050:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1052:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1054:	9f 5f       	subi	r25, 0xFF	; 255
    1056:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	08 95       	ret

00001060 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1060:	fc 01       	movw	r30, r24
    1062:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1064:	44 8d       	ldd	r20, Z+28	; 0x1c
    1066:	44 23       	and	r20, r20
    1068:	a1 f0       	breq	.+40     	; 0x1092 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    106a:	50 e0       	ldi	r21, 0x00	; 0
    106c:	26 81       	ldd	r18, Z+6	; 0x06
    106e:	37 81       	ldd	r19, Z+7	; 0x07
    1070:	24 0f       	add	r18, r20
    1072:	35 1f       	adc	r19, r21
    1074:	37 83       	std	Z+7, r19	; 0x07
    1076:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1078:	62 81       	ldd	r22, Z+2	; 0x02
    107a:	73 81       	ldd	r23, Z+3	; 0x03
    107c:	26 17       	cp	r18, r22
    107e:	37 07       	cpc	r19, r23
    1080:	20 f0       	brcs	.+8      	; 0x108a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1082:	20 81       	ld	r18, Z
    1084:	31 81       	ldd	r19, Z+1	; 0x01
    1086:	37 83       	std	Z+7, r19	; 0x07
    1088:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    108a:	66 81       	ldd	r22, Z+6	; 0x06
    108c:	77 81       	ldd	r23, Z+7	; 0x07
    108e:	0c 94 da 10 	jmp	0x21b4	; 0x21b4 <memcpy>
    1092:	08 95       	ret

00001094 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	f8 94       	cli
    10a2:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    10a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10a6:	18 16       	cp	r1, r24
    10a8:	a4 f4       	brge	.+40     	; 0x10d2 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10aa:	89 89       	ldd	r24, Y+17	; 0x11
    10ac:	88 23       	and	r24, r24
    10ae:	89 f0       	breq	.+34     	; 0x10d2 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10b0:	8e 01       	movw	r16, r28
    10b2:	0f 5e       	subi	r16, 0xEF	; 239
    10b4:	1f 4f       	sbci	r17, 0xFF	; 255
    10b6:	03 c0       	rjmp	.+6      	; 0x10be <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10b8:	89 89       	ldd	r24, Y+17	; 0x11
    10ba:	88 23       	and	r24, r24
    10bc:	51 f0       	breq	.+20     	; 0x10d2 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10be:	c8 01       	movw	r24, r16
    10c0:	14 d7       	rcall	.+3624   	; 0x1eea <xTaskRemoveFromEventList>
    10c2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    10c4:	9d d7       	rcall	.+3898   	; 0x2000 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    10c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10c8:	81 50       	subi	r24, 0x01	; 1
    10ca:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    10cc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10ce:	18 16       	cp	r1, r24
    10d0:	9c f3       	brlt	.-26     	; 0x10b8 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    10d2:	8f ef       	ldi	r24, 0xFF	; 255
    10d4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    10d6:	0f 90       	pop	r0
    10d8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    10da:	0f b6       	in	r0, 0x3f	; 63
    10dc:	f8 94       	cli
    10de:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    10e0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10e2:	18 16       	cp	r1, r24
    10e4:	a4 f4       	brge	.+40     	; 0x110e <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10e6:	88 85       	ldd	r24, Y+8	; 0x08
    10e8:	88 23       	and	r24, r24
    10ea:	89 f0       	breq	.+34     	; 0x110e <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10ec:	8e 01       	movw	r16, r28
    10ee:	08 5f       	subi	r16, 0xF8	; 248
    10f0:	1f 4f       	sbci	r17, 0xFF	; 255
    10f2:	03 c0       	rjmp	.+6      	; 0x10fa <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10f4:	88 85       	ldd	r24, Y+8	; 0x08
    10f6:	88 23       	and	r24, r24
    10f8:	51 f0       	breq	.+20     	; 0x110e <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10fa:	c8 01       	movw	r24, r16
    10fc:	f6 d6       	rcall	.+3564   	; 0x1eea <xTaskRemoveFromEventList>
    10fe:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1100:	7f d7       	rcall	.+3838   	; 0x2000 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1102:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1104:	81 50       	subi	r24, 0x01	; 1
    1106:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1108:	8d 8d       	ldd	r24, Y+29	; 0x1d
    110a:	18 16       	cp	r1, r24
    110c:	9c f3       	brlt	.-26     	; 0x10f4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    110e:	8f ef       	ldi	r24, 0xFF	; 255
    1110:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1112:	0f 90       	pop	r0
    1114:	0f be       	out	0x3f, r0	; 63
}
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	08 95       	ret

00001120 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1126:	0f b6       	in	r0, 0x3f	; 63
    1128:	f8 94       	cli
    112a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    112c:	88 81       	ld	r24, Y
    112e:	99 81       	ldd	r25, Y+1	; 0x01
    1130:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1136:	72 9f       	mul	r23, r18
    1138:	a0 01       	movw	r20, r0
    113a:	73 9f       	mul	r23, r19
    113c:	50 0d       	add	r21, r0
    113e:	11 24       	eor	r1, r1
    1140:	fc 01       	movw	r30, r24
    1142:	e4 0f       	add	r30, r20
    1144:	f5 1f       	adc	r31, r21
    1146:	fb 83       	std	Y+3, r31	; 0x03
    1148:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    114a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    114c:	9d 83       	std	Y+5, r25	; 0x05
    114e:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1150:	42 1b       	sub	r20, r18
    1152:	53 0b       	sbc	r21, r19
    1154:	84 0f       	add	r24, r20
    1156:	95 1f       	adc	r25, r21
    1158:	9f 83       	std	Y+7, r25	; 0x07
    115a:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    115c:	8f ef       	ldi	r24, 0xFF	; 255
    115e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1160:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1162:	61 11       	cpse	r22, r1
    1164:	0a c0       	rjmp	.+20     	; 0x117a <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1166:	88 85       	ldd	r24, Y+8	; 0x08
    1168:	88 23       	and	r24, r24
    116a:	69 f0       	breq	.+26     	; 0x1186 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    116c:	ce 01       	movw	r24, r28
    116e:	08 96       	adiw	r24, 0x08	; 8
    1170:	bc d6       	rcall	.+3448   	; 0x1eea <xTaskRemoveFromEventList>
    1172:	81 30       	cpi	r24, 0x01	; 1
    1174:	41 f4       	brne	.+16     	; 0x1186 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1176:	4e de       	rcall	.-868    	; 0xe14 <vPortYield>
    1178:	06 c0       	rjmp	.+12     	; 0x1186 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    117a:	ce 01       	movw	r24, r28
    117c:	08 96       	adiw	r24, 0x08	; 8
    117e:	59 d9       	rcall	.-3406   	; 0x432 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1180:	ce 01       	movw	r24, r28
    1182:	41 96       	adiw	r24, 0x11	; 17
    1184:	56 d9       	rcall	.-3412   	; 0x432 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1186:	0f 90       	pop	r0
    1188:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	08 95       	ret

00001192 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1192:	0f 93       	push	r16
    1194:	1f 93       	push	r17
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	18 2f       	mov	r17, r24
    119c:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    119e:	88 23       	and	r24, r24
    11a0:	d1 f0       	breq	.+52     	; 0x11d6 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    11a2:	8f e1       	ldi	r24, 0x1F	; 31
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	0f d9       	rcall	.-3554   	; 0x3c6 <pvPortMalloc>
    11a8:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    11aa:	00 97       	sbiw	r24, 0x00	; 0
    11ac:	b1 f0       	breq	.+44     	; 0x11da <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11ae:	10 9f       	mul	r17, r16
    11b0:	c0 01       	movw	r24, r0
    11b2:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    11b4:	01 96       	adiw	r24, 0x01	; 1
    11b6:	07 d9       	rcall	.-3570   	; 0x3c6 <pvPortMalloc>
    11b8:	99 83       	std	Y+1, r25	; 0x01
    11ba:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    11bc:	89 2b       	or	r24, r25
    11be:	31 f0       	breq	.+12     	; 0x11cc <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    11c0:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11c2:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    11c4:	61 e0       	ldi	r22, 0x01	; 1
    11c6:	ce 01       	movw	r24, r28
    11c8:	ab df       	rcall	.-170    	; 0x1120 <xQueueGenericReset>
    11ca:	07 c0       	rjmp	.+14     	; 0x11da <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    11cc:	ce 01       	movw	r24, r28
    11ce:	30 d9       	rcall	.-3488   	; 0x430 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    11d0:	c0 e0       	ldi	r28, 0x00	; 0
    11d2:	d0 e0       	ldi	r29, 0x00	; 0
    11d4:	02 c0       	rjmp	.+4      	; 0x11da <xQueueGenericCreate+0x48>
    11d6:	c0 e0       	ldi	r28, 0x00	; 0
    11d8:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    11da:	ce 01       	movw	r24, r28
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	1f 91       	pop	r17
    11e2:	0f 91       	pop	r16
    11e4:	08 95       	ret

000011e6 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    11e6:	9f 92       	push	r9
    11e8:	af 92       	push	r10
    11ea:	bf 92       	push	r11
    11ec:	cf 92       	push	r12
    11ee:	df 92       	push	r13
    11f0:	ef 92       	push	r14
    11f2:	ff 92       	push	r15
    11f4:	0f 93       	push	r16
    11f6:	1f 93       	push	r17
    11f8:	cf 93       	push	r28
    11fa:	df 93       	push	r29
    11fc:	00 d0       	rcall	.+0      	; 0x11fe <xQueueGenericSend+0x18>
    11fe:	1f 92       	push	r1
    1200:	1f 92       	push	r1
    1202:	cd b7       	in	r28, 0x3d	; 61
    1204:	de b7       	in	r29, 0x3e	; 62
    1206:	8c 01       	movw	r16, r24
    1208:	6b 01       	movw	r12, r22
    120a:	5d 83       	std	Y+5, r21	; 0x05
    120c:	4c 83       	std	Y+4, r20	; 0x04
    120e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1210:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1212:	99 24       	eor	r9, r9
    1214:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1216:	7c 01       	movw	r14, r24
    1218:	88 e0       	ldi	r24, 0x08	; 8
    121a:	e8 0e       	add	r14, r24
    121c:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    121e:	0f b6       	in	r0, 0x3f	; 63
    1220:	f8 94       	cli
    1222:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1224:	f8 01       	movw	r30, r16
    1226:	92 8d       	ldd	r25, Z+26	; 0x1a
    1228:	83 8d       	ldd	r24, Z+27	; 0x1b
    122a:	98 17       	cp	r25, r24
    122c:	18 f0       	brcs	.+6      	; 0x1234 <xQueueGenericSend+0x4e>
    122e:	f2 e0       	ldi	r31, 0x02	; 2
    1230:	af 12       	cpse	r10, r31
    1232:	15 c0       	rjmp	.+42     	; 0x125e <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1234:	4a 2d       	mov	r20, r10
    1236:	b6 01       	movw	r22, r12
    1238:	c8 01       	movw	r24, r16
    123a:	b0 de       	rcall	.-672    	; 0xf9c <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    123c:	f8 01       	movw	r30, r16
    123e:	91 89       	ldd	r25, Z+17	; 0x11
    1240:	99 23       	and	r25, r25
    1242:	39 f0       	breq	.+14     	; 0x1252 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1244:	c8 01       	movw	r24, r16
    1246:	41 96       	adiw	r24, 0x11	; 17
    1248:	50 d6       	rcall	.+3232   	; 0x1eea <xTaskRemoveFromEventList>
    124a:	81 30       	cpi	r24, 0x01	; 1
    124c:	21 f4       	brne	.+8      	; 0x1256 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    124e:	e2 dd       	rcall	.-1084   	; 0xe14 <vPortYield>
    1250:	02 c0       	rjmp	.+4      	; 0x1256 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1252:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1254:	df dd       	rcall	.-1090   	; 0xe14 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1256:	0f 90       	pop	r0
    1258:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	46 c0       	rjmp	.+140    	; 0x12ea <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    125e:	ec 81       	ldd	r30, Y+4	; 0x04
    1260:	fd 81       	ldd	r31, Y+5	; 0x05
    1262:	ef 2b       	or	r30, r31
    1264:	21 f4       	brne	.+8      	; 0x126e <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1266:	0f 90       	pop	r0
    1268:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	3e c0       	rjmp	.+124    	; 0x12ea <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    126e:	b1 10       	cpse	r11, r1
    1270:	04 c0       	rjmp	.+8      	; 0x127a <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1272:	ce 01       	movw	r24, r28
    1274:	01 96       	adiw	r24, 0x01	; 1
    1276:	81 d6       	rcall	.+3330   	; 0x1f7a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1278:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    127a:	0f 90       	pop	r0
    127c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    127e:	78 d3       	rcall	.+1776   	; 0x1970 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	0f 92       	push	r0
    1286:	f8 01       	movw	r30, r16
    1288:	85 8d       	ldd	r24, Z+29	; 0x1d
    128a:	8f 3f       	cpi	r24, 0xFF	; 255
    128c:	09 f4       	brne	.+2      	; 0x1290 <xQueueGenericSend+0xaa>
    128e:	15 8e       	std	Z+29, r1	; 0x1d
    1290:	f8 01       	movw	r30, r16
    1292:	86 8d       	ldd	r24, Z+30	; 0x1e
    1294:	8f 3f       	cpi	r24, 0xFF	; 255
    1296:	09 f4       	brne	.+2      	; 0x129a <xQueueGenericSend+0xb4>
    1298:	16 8e       	std	Z+30, r1	; 0x1e
    129a:	0f 90       	pop	r0
    129c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    129e:	be 01       	movw	r22, r28
    12a0:	6c 5f       	subi	r22, 0xFC	; 252
    12a2:	7f 4f       	sbci	r23, 0xFF	; 255
    12a4:	ce 01       	movw	r24, r28
    12a6:	01 96       	adiw	r24, 0x01	; 1
    12a8:	73 d6       	rcall	.+3302   	; 0x1f90 <xTaskCheckForTimeOut>
    12aa:	81 11       	cpse	r24, r1
    12ac:	1a c0       	rjmp	.+52     	; 0x12e2 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12b4:	f8 01       	movw	r30, r16
    12b6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12bc:	f8 01       	movw	r30, r16
    12be:	83 8d       	ldd	r24, Z+27	; 0x1b
    12c0:	98 13       	cpse	r25, r24
    12c2:	0b c0       	rjmp	.+22     	; 0x12da <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12c4:	6c 81       	ldd	r22, Y+4	; 0x04
    12c6:	7d 81       	ldd	r23, Y+5	; 0x05
    12c8:	c7 01       	movw	r24, r14
    12ca:	e4 d5       	rcall	.+3016   	; 0x1e94 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    12cc:	c8 01       	movw	r24, r16
    12ce:	e2 de       	rcall	.-572    	; 0x1094 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12d0:	22 d4       	rcall	.+2116   	; 0x1b16 <xTaskResumeAll>
    12d2:	81 11       	cpse	r24, r1
    12d4:	a4 cf       	rjmp	.-184    	; 0x121e <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    12d6:	9e dd       	rcall	.-1220   	; 0xe14 <vPortYield>
    12d8:	a2 cf       	rjmp	.-188    	; 0x121e <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12da:	c8 01       	movw	r24, r16
    12dc:	db de       	rcall	.-586    	; 0x1094 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12de:	1b d4       	rcall	.+2102   	; 0x1b16 <xTaskResumeAll>
    12e0:	9e cf       	rjmp	.-196    	; 0x121e <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12e2:	c8 01       	movw	r24, r16
    12e4:	d7 de       	rcall	.-594    	; 0x1094 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12e6:	17 d4       	rcall	.+2094   	; 0x1b16 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    12e8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    12ea:	0f 90       	pop	r0
    12ec:	0f 90       	pop	r0
    12ee:	0f 90       	pop	r0
    12f0:	0f 90       	pop	r0
    12f2:	0f 90       	pop	r0
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	1f 91       	pop	r17
    12fa:	0f 91       	pop	r16
    12fc:	ff 90       	pop	r15
    12fe:	ef 90       	pop	r14
    1300:	df 90       	pop	r13
    1302:	cf 90       	pop	r12
    1304:	bf 90       	pop	r11
    1306:	af 90       	pop	r10
    1308:	9f 90       	pop	r9
    130a:	08 95       	ret

0000130c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1310:	8f e1       	ldi	r24, 0x1F	; 31
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	58 d8       	rcall	.-3920   	; 0x3c6 <pvPortMalloc>
    1316:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1318:	00 97       	sbiw	r24, 0x00	; 0
    131a:	e1 f0       	breq	.+56     	; 0x1354 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    131c:	1b 82       	std	Y+3, r1	; 0x03
    131e:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1320:	19 82       	std	Y+1, r1	; 0x01
    1322:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1324:	1d 82       	std	Y+5, r1	; 0x05
    1326:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1328:	1f 82       	std	Y+7, r1	; 0x07
    132a:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    132c:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    132e:	81 e0       	ldi	r24, 0x01	; 1
    1330:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1332:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1334:	8f ef       	ldi	r24, 0xFF	; 255
    1336:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1338:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    133a:	ce 01       	movw	r24, r28
    133c:	08 96       	adiw	r24, 0x08	; 8
    133e:	79 d8       	rcall	.-3854   	; 0x432 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1340:	ce 01       	movw	r24, r28
    1342:	41 96       	adiw	r24, 0x11	; 17
    1344:	76 d8       	rcall	.-3860   	; 0x432 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	50 e0       	ldi	r21, 0x00	; 0
    134c:	60 e0       	ldi	r22, 0x00	; 0
    134e:	70 e0       	ldi	r23, 0x00	; 0
    1350:	ce 01       	movw	r24, r28
    1352:	49 df       	rcall	.-366    	; 0x11e6 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1354:	ce 01       	movw	r24, r28
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
    135a:	08 95       	ret

0000135c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    135c:	0f 93       	push	r16
    135e:	1f 93       	push	r17
    1360:	cf 93       	push	r28
    1362:	df 93       	push	r29
    1364:	ec 01       	movw	r28, r24
    1366:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1368:	9a 8d       	ldd	r25, Y+26	; 0x1a
    136a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    136c:	98 17       	cp	r25, r24
    136e:	10 f0       	brcs	.+4      	; 0x1374 <xQueueGenericSendFromISR+0x18>
    1370:	22 30       	cpi	r18, 0x02	; 2
    1372:	11 f5       	brne	.+68     	; 0x13b8 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1374:	42 2f       	mov	r20, r18
    1376:	ce 01       	movw	r24, r28
    1378:	11 de       	rcall	.-990    	; 0xf9c <prvCopyDataToQueue>
    137a:	88 23       	and	r24, r24
    137c:	31 f0       	breq	.+12     	; 0x138a <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    137e:	01 15       	cp	r16, r1
    1380:	11 05       	cpc	r17, r1
    1382:	19 f0       	breq	.+6      	; 0x138a <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	f8 01       	movw	r30, r16
    1388:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    138a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    138c:	8f 3f       	cpi	r24, 0xFF	; 255
    138e:	79 f4       	brne	.+30     	; 0x13ae <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1390:	89 89       	ldd	r24, Y+17	; 0x11
    1392:	88 23       	and	r24, r24
    1394:	99 f0       	breq	.+38     	; 0x13bc <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1396:	ce 01       	movw	r24, r28
    1398:	41 96       	adiw	r24, 0x11	; 17
    139a:	a7 d5       	rcall	.+2894   	; 0x1eea <xTaskRemoveFromEventList>
    139c:	88 23       	and	r24, r24
    139e:	81 f0       	breq	.+32     	; 0x13c0 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    13a0:	01 15       	cp	r16, r1
    13a2:	11 05       	cpc	r17, r1
    13a4:	79 f0       	breq	.+30     	; 0x13c4 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	f8 01       	movw	r30, r16
    13aa:	80 83       	st	Z, r24
    13ac:	0c c0       	rjmp	.+24     	; 0x13c6 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13ae:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13b0:	8f 5f       	subi	r24, 0xFF	; 255
    13b2:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	07 c0       	rjmp	.+14     	; 0x13c6 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	05 c0       	rjmp	.+10     	; 0x13c6 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	03 c0       	rjmp	.+6      	; 0x13c6 <xQueueGenericSendFromISR+0x6a>
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	01 c0       	rjmp	.+2      	; 0x13c6 <xQueueGenericSendFromISR+0x6a>
    13c4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	08 95       	ret

000013d0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    13d0:	9f 92       	push	r9
    13d2:	af 92       	push	r10
    13d4:	bf 92       	push	r11
    13d6:	cf 92       	push	r12
    13d8:	df 92       	push	r13
    13da:	ef 92       	push	r14
    13dc:	ff 92       	push	r15
    13de:	0f 93       	push	r16
    13e0:	1f 93       	push	r17
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	00 d0       	rcall	.+0      	; 0x13e8 <xQueueGenericReceive+0x18>
    13e8:	1f 92       	push	r1
    13ea:	1f 92       	push	r1
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	8c 01       	movw	r16, r24
    13f2:	6b 01       	movw	r12, r22
    13f4:	5d 83       	std	Y+5, r21	; 0x05
    13f6:	4c 83       	std	Y+4, r20	; 0x04
    13f8:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    13fa:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    13fc:	99 24       	eor	r9, r9
    13fe:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1400:	7c 01       	movw	r14, r24
    1402:	81 e1       	ldi	r24, 0x11	; 17
    1404:	e8 0e       	add	r14, r24
    1406:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1408:	0f b6       	in	r0, 0x3f	; 63
    140a:	f8 94       	cli
    140c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    140e:	f8 01       	movw	r30, r16
    1410:	82 8d       	ldd	r24, Z+26	; 0x1a
    1412:	88 23       	and	r24, r24
    1414:	69 f1       	breq	.+90     	; 0x1470 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1416:	e6 80       	ldd	r14, Z+6	; 0x06
    1418:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    141a:	b6 01       	movw	r22, r12
    141c:	c8 01       	movw	r24, r16
    141e:	20 de       	rcall	.-960    	; 0x1060 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1420:	b1 10       	cpse	r11, r1
    1422:	17 c0       	rjmp	.+46     	; 0x1452 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1424:	f8 01       	movw	r30, r16
    1426:	82 8d       	ldd	r24, Z+26	; 0x1a
    1428:	81 50       	subi	r24, 0x01	; 1
    142a:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    142c:	80 81       	ld	r24, Z
    142e:	91 81       	ldd	r25, Z+1	; 0x01
    1430:	89 2b       	or	r24, r25
    1432:	21 f4       	brne	.+8      	; 0x143c <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1434:	86 d6       	rcall	.+3340   	; 0x2142 <pvTaskIncrementMutexHeldCount>
    1436:	f8 01       	movw	r30, r16
    1438:	93 83       	std	Z+3, r25	; 0x03
    143a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    143c:	f8 01       	movw	r30, r16
    143e:	80 85       	ldd	r24, Z+8	; 0x08
    1440:	88 23       	and	r24, r24
    1442:	91 f0       	breq	.+36     	; 0x1468 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1444:	c8 01       	movw	r24, r16
    1446:	08 96       	adiw	r24, 0x08	; 8
    1448:	50 d5       	rcall	.+2720   	; 0x1eea <xTaskRemoveFromEventList>
    144a:	81 30       	cpi	r24, 0x01	; 1
    144c:	69 f4       	brne	.+26     	; 0x1468 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    144e:	e2 dc       	rcall	.-1596   	; 0xe14 <vPortYield>
    1450:	0b c0       	rjmp	.+22     	; 0x1468 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1452:	f8 01       	movw	r30, r16
    1454:	f7 82       	std	Z+7, r15	; 0x07
    1456:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1458:	81 89       	ldd	r24, Z+17	; 0x11
    145a:	88 23       	and	r24, r24
    145c:	29 f0       	breq	.+10     	; 0x1468 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    145e:	c8 01       	movw	r24, r16
    1460:	41 96       	adiw	r24, 0x11	; 17
    1462:	43 d5       	rcall	.+2694   	; 0x1eea <xTaskRemoveFromEventList>
    1464:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1466:	d6 dc       	rcall	.-1620   	; 0xe14 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1468:	0f 90       	pop	r0
    146a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	52 c0       	rjmp	.+164    	; 0x1514 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1470:	4c 81       	ldd	r20, Y+4	; 0x04
    1472:	5d 81       	ldd	r21, Y+5	; 0x05
    1474:	45 2b       	or	r20, r21
    1476:	21 f4       	brne	.+8      	; 0x1480 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1478:	0f 90       	pop	r0
    147a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	4a c0       	rjmp	.+148    	; 0x1514 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1480:	a1 10       	cpse	r10, r1
    1482:	04 c0       	rjmp	.+8      	; 0x148c <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1484:	ce 01       	movw	r24, r28
    1486:	01 96       	adiw	r24, 0x01	; 1
    1488:	78 d5       	rcall	.+2800   	; 0x1f7a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    148a:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    148c:	0f 90       	pop	r0
    148e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1490:	6f d2       	rcall	.+1246   	; 0x1970 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1492:	0f b6       	in	r0, 0x3f	; 63
    1494:	f8 94       	cli
    1496:	0f 92       	push	r0
    1498:	f8 01       	movw	r30, r16
    149a:	85 8d       	ldd	r24, Z+29	; 0x1d
    149c:	8f 3f       	cpi	r24, 0xFF	; 255
    149e:	09 f4       	brne	.+2      	; 0x14a2 <xQueueGenericReceive+0xd2>
    14a0:	15 8e       	std	Z+29, r1	; 0x1d
    14a2:	f8 01       	movw	r30, r16
    14a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    14a6:	8f 3f       	cpi	r24, 0xFF	; 255
    14a8:	09 f4       	brne	.+2      	; 0x14ac <xQueueGenericReceive+0xdc>
    14aa:	16 8e       	std	Z+30, r1	; 0x1e
    14ac:	0f 90       	pop	r0
    14ae:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14b0:	be 01       	movw	r22, r28
    14b2:	6c 5f       	subi	r22, 0xFC	; 252
    14b4:	7f 4f       	sbci	r23, 0xFF	; 255
    14b6:	ce 01       	movw	r24, r28
    14b8:	01 96       	adiw	r24, 0x01	; 1
    14ba:	6a d5       	rcall	.+2772   	; 0x1f90 <xTaskCheckForTimeOut>
    14bc:	81 11       	cpse	r24, r1
    14be:	26 c0       	rjmp	.+76     	; 0x150c <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14c6:	f8 01       	movw	r30, r16
    14c8:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14ca:	0f 90       	pop	r0
    14cc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14ce:	81 11       	cpse	r24, r1
    14d0:	19 c0       	rjmp	.+50     	; 0x1504 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14d2:	f8 01       	movw	r30, r16
    14d4:	80 81       	ld	r24, Z
    14d6:	91 81       	ldd	r25, Z+1	; 0x01
    14d8:	89 2b       	or	r24, r25
    14da:	49 f4       	brne	.+18     	; 0x14ee <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    14dc:	0f b6       	in	r0, 0x3f	; 63
    14de:	f8 94       	cli
    14e0:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    14e2:	f8 01       	movw	r30, r16
    14e4:	82 81       	ldd	r24, Z+2	; 0x02
    14e6:	93 81       	ldd	r25, Z+3	; 0x03
    14e8:	8f d5       	rcall	.+2846   	; 0x2008 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14ee:	6c 81       	ldd	r22, Y+4	; 0x04
    14f0:	7d 81       	ldd	r23, Y+5	; 0x05
    14f2:	c7 01       	movw	r24, r14
    14f4:	cf d4       	rcall	.+2462   	; 0x1e94 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14f6:	c8 01       	movw	r24, r16
    14f8:	cd dd       	rcall	.-1126   	; 0x1094 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14fa:	0d d3       	rcall	.+1562   	; 0x1b16 <xTaskResumeAll>
    14fc:	81 11       	cpse	r24, r1
    14fe:	84 cf       	rjmp	.-248    	; 0x1408 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1500:	89 dc       	rcall	.-1774   	; 0xe14 <vPortYield>
    1502:	82 cf       	rjmp	.-252    	; 0x1408 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1504:	c8 01       	movw	r24, r16
    1506:	c6 dd       	rcall	.-1140   	; 0x1094 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1508:	06 d3       	rcall	.+1548   	; 0x1b16 <xTaskResumeAll>
    150a:	7e cf       	rjmp	.-260    	; 0x1408 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    150c:	c8 01       	movw	r24, r16
    150e:	c2 dd       	rcall	.-1148   	; 0x1094 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1510:	02 d3       	rcall	.+1540   	; 0x1b16 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1512:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1514:	0f 90       	pop	r0
    1516:	0f 90       	pop	r0
    1518:	0f 90       	pop	r0
    151a:	0f 90       	pop	r0
    151c:	0f 90       	pop	r0
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	1f 91       	pop	r17
    1524:	0f 91       	pop	r16
    1526:	ff 90       	pop	r15
    1528:	ef 90       	pop	r14
    152a:	df 90       	pop	r13
    152c:	cf 90       	pop	r12
    152e:	bf 90       	pop	r11
    1530:	af 90       	pop	r10
    1532:	9f 90       	pop	r9
    1534:	08 95       	ret

00001536 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1536:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1538:	71 83       	std	Z+1, r23	; 0x01
    153a:	60 83       	st	Z, r22
	ring->rSize = size;
    153c:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    153e:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1540:	13 82       	std	Z+3, r1	; 0x03
    1542:	08 95       	ret

00001544 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1544:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1546:	94 81       	ldd	r25, Z+4	; 0x04
    1548:	a0 81       	ld	r26, Z
    154a:	b1 81       	ldd	r27, Z+1	; 0x01
    154c:	a9 0f       	add	r26, r25
    154e:	b1 1d       	adc	r27, r1
    1550:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1552:	9f 5f       	subi	r25, 0xFF	; 255
    1554:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1556:	22 81       	ldd	r18, Z+2	; 0x02
    1558:	92 17       	cp	r25, r18
    155a:	10 f0       	brcs	.+4      	; 0x1560 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    155c:	92 1b       	sub	r25, r18
    155e:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1560:	93 81       	ldd	r25, Z+3	; 0x03
    1562:	91 50       	subi	r25, 0x01	; 1
    1564:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1566:	08 95       	ret

00001568 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1568:	fc 01       	movw	r30, r24
    156a:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    156c:	83 81       	ldd	r24, Z+3	; 0x03
    156e:	22 81       	ldd	r18, Z+2	; 0x02
    1570:	82 17       	cp	r24, r18
    1572:	78 f4       	brcc	.+30     	; 0x1592 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1574:	34 81       	ldd	r19, Z+4	; 0x04
    1576:	90 e0       	ldi	r25, 0x00	; 0
    1578:	83 0f       	add	r24, r19
    157a:	91 1d       	adc	r25, r1
    157c:	62 2f       	mov	r22, r18
    157e:	70 e0       	ldi	r23, 0x00	; 0
    1580:	f2 d5       	rcall	.+3044   	; 0x2166 <__divmodhi4>
    1582:	a0 81       	ld	r26, Z
    1584:	b1 81       	ldd	r27, Z+1	; 0x01
    1586:	a8 0f       	add	r26, r24
    1588:	b9 1f       	adc	r27, r25
    158a:	4c 93       	st	X, r20
            ring->rLength++;
    158c:	83 81       	ldd	r24, Z+3	; 0x03
    158e:	8f 5f       	subi	r24, 0xFF	; 255
    1590:	83 83       	std	Z+3, r24	; 0x03
    1592:	08 95       	ret

00001594 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1594:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	22 81       	ldd	r18, Z+2	; 0x02
    159a:	93 81       	ldd	r25, Z+3	; 0x03
    159c:	29 13       	cpse	r18, r25
    159e:	80 e0       	ldi	r24, 0x00	; 0
}
    15a0:	08 95       	ret

000015a2 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    15a2:	21 e0       	ldi	r18, 0x01	; 1
    15a4:	fc 01       	movw	r30, r24
    15a6:	83 81       	ldd	r24, Z+3	; 0x03
    15a8:	81 11       	cpse	r24, r1
    15aa:	01 c0       	rjmp	.+2      	; 0x15ae <ringBufferNotEmpty+0xc>
    15ac:	20 e0       	ldi	r18, 0x00	; 0
}
    15ae:	82 2f       	mov	r24, r18
    15b0:	08 95       	ret

000015b2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    15b2:	e0 91 9c 08 	lds	r30, 0x089C
    15b6:	f0 91 9d 08 	lds	r31, 0x089D
    15ba:	80 81       	ld	r24, Z
    15bc:	81 11       	cpse	r24, r1
    15be:	07 c0       	rjmp	.+14     	; 0x15ce <prvResetNextTaskUnblockTime+0x1c>
    15c0:	8f ef       	ldi	r24, 0xFF	; 255
    15c2:	9f ef       	ldi	r25, 0xFF	; 255
    15c4:	90 93 05 02 	sts	0x0205, r25
    15c8:	80 93 04 02 	sts	0x0204, r24
    15cc:	08 95       	ret
    15ce:	e0 91 9c 08 	lds	r30, 0x089C
    15d2:	f0 91 9d 08 	lds	r31, 0x089D
    15d6:	05 80       	ldd	r0, Z+5	; 0x05
    15d8:	f6 81       	ldd	r31, Z+6	; 0x06
    15da:	e0 2d       	mov	r30, r0
    15dc:	06 80       	ldd	r0, Z+6	; 0x06
    15de:	f7 81       	ldd	r31, Z+7	; 0x07
    15e0:	e0 2d       	mov	r30, r0
    15e2:	82 81       	ldd	r24, Z+2	; 0x02
    15e4:	93 81       	ldd	r25, Z+3	; 0x03
    15e6:	90 93 05 02 	sts	0x0205, r25
    15ea:	80 93 04 02 	sts	0x0204, r24
    15ee:	08 95       	ret

000015f0 <prvAddCurrentTaskToDelayedList>:
    15f0:	cf 93       	push	r28
    15f2:	df 93       	push	r29
    15f4:	ec 01       	movw	r28, r24
    15f6:	e0 91 dd 08 	lds	r30, 0x08DD
    15fa:	f0 91 de 08 	lds	r31, 0x08DE
    15fe:	93 83       	std	Z+3, r25	; 0x03
    1600:	82 83       	std	Z+2, r24	; 0x02
    1602:	80 91 7b 08 	lds	r24, 0x087B
    1606:	90 91 7c 08 	lds	r25, 0x087C
    160a:	c8 17       	cp	r28, r24
    160c:	d9 07       	cpc	r29, r25
    160e:	68 f4       	brcc	.+26     	; 0x162a <prvAddCurrentTaskToDelayedList+0x3a>
    1610:	60 91 dd 08 	lds	r22, 0x08DD
    1614:	70 91 de 08 	lds	r23, 0x08DE
    1618:	80 91 9a 08 	lds	r24, 0x089A
    161c:	90 91 9b 08 	lds	r25, 0x089B
    1620:	6e 5f       	subi	r22, 0xFE	; 254
    1622:	7f 4f       	sbci	r23, 0xFF	; 255
    1624:	0e 94 4c 02 	call	0x498	; 0x498 <vListInsert>
    1628:	17 c0       	rjmp	.+46     	; 0x1658 <prvAddCurrentTaskToDelayedList+0x68>
    162a:	60 91 dd 08 	lds	r22, 0x08DD
    162e:	70 91 de 08 	lds	r23, 0x08DE
    1632:	80 91 9c 08 	lds	r24, 0x089C
    1636:	90 91 9d 08 	lds	r25, 0x089D
    163a:	6e 5f       	subi	r22, 0xFE	; 254
    163c:	7f 4f       	sbci	r23, 0xFF	; 255
    163e:	0e 94 4c 02 	call	0x498	; 0x498 <vListInsert>
    1642:	80 91 04 02 	lds	r24, 0x0204
    1646:	90 91 05 02 	lds	r25, 0x0205
    164a:	c8 17       	cp	r28, r24
    164c:	d9 07       	cpc	r29, r25
    164e:	20 f4       	brcc	.+8      	; 0x1658 <prvAddCurrentTaskToDelayedList+0x68>
    1650:	d0 93 05 02 	sts	0x0205, r29
    1654:	c0 93 04 02 	sts	0x0204, r28
    1658:	df 91       	pop	r29
    165a:	cf 91       	pop	r28
    165c:	08 95       	ret

0000165e <xTaskGenericCreate>:
    165e:	4f 92       	push	r4
    1660:	5f 92       	push	r5
    1662:	6f 92       	push	r6
    1664:	7f 92       	push	r7
    1666:	8f 92       	push	r8
    1668:	9f 92       	push	r9
    166a:	af 92       	push	r10
    166c:	bf 92       	push	r11
    166e:	cf 92       	push	r12
    1670:	df 92       	push	r13
    1672:	ef 92       	push	r14
    1674:	ff 92       	push	r15
    1676:	0f 93       	push	r16
    1678:	1f 93       	push	r17
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	4c 01       	movw	r8, r24
    1680:	5b 01       	movw	r10, r22
    1682:	2a 01       	movw	r4, r20
    1684:	39 01       	movw	r6, r18
    1686:	83 e2       	ldi	r24, 0x23	; 35
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <pvPortMalloc>
    168e:	ec 01       	movw	r28, r24
    1690:	00 97       	sbiw	r24, 0x00	; 0
    1692:	09 f4       	brne	.+2      	; 0x1696 <xTaskGenericCreate+0x38>
    1694:	e7 c0       	rjmp	.+462    	; 0x1864 <xTaskGenericCreate+0x206>
    1696:	c1 14       	cp	r12, r1
    1698:	d1 04       	cpc	r13, r1
    169a:	09 f0       	breq	.+2      	; 0x169e <xTaskGenericCreate+0x40>
    169c:	cc c0       	rjmp	.+408    	; 0x1836 <xTaskGenericCreate+0x1d8>
    169e:	c2 01       	movw	r24, r4
    16a0:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <pvPortMalloc>
    16a4:	98 8f       	std	Y+24, r25	; 0x18
    16a6:	8f 8b       	std	Y+23, r24	; 0x17
    16a8:	89 2b       	or	r24, r25
    16aa:	09 f0       	breq	.+2      	; 0x16ae <xTaskGenericCreate+0x50>
    16ac:	c6 c0       	rjmp	.+396    	; 0x183a <xTaskGenericCreate+0x1dc>
    16ae:	ce 01       	movw	r24, r28
    16b0:	0e 94 18 02 	call	0x430	; 0x430 <vPortFree>
    16b4:	d7 c0       	rjmp	.+430    	; 0x1864 <xTaskGenericCreate+0x206>
    16b6:	cf 01       	movw	r24, r30
    16b8:	31 91       	ld	r19, Z+
    16ba:	da 01       	movw	r26, r20
    16bc:	3d 93       	st	X+, r19
    16be:	ad 01       	movw	r20, r26
    16c0:	dc 01       	movw	r26, r24
    16c2:	8c 91       	ld	r24, X
    16c4:	88 23       	and	r24, r24
    16c6:	11 f0       	breq	.+4      	; 0x16cc <xTaskGenericCreate+0x6e>
    16c8:	21 50       	subi	r18, 0x01	; 1
    16ca:	a9 f7       	brne	.-22     	; 0x16b6 <xTaskGenericCreate+0x58>
    16cc:	18 a2       	std	Y+32, r1	; 0x20
    16ce:	10 2f       	mov	r17, r16
    16d0:	05 30       	cpi	r16, 0x05	; 5
    16d2:	08 f0       	brcs	.+2      	; 0x16d6 <xTaskGenericCreate+0x78>
    16d4:	14 e0       	ldi	r17, 0x04	; 4
    16d6:	1e 8b       	std	Y+22, r17	; 0x16
    16d8:	19 a3       	std	Y+33, r17	; 0x21
    16da:	1a a2       	std	Y+34, r1	; 0x22
    16dc:	5e 01       	movw	r10, r28
    16de:	b2 e0       	ldi	r27, 0x02	; 2
    16e0:	ab 0e       	add	r10, r27
    16e2:	b1 1c       	adc	r11, r1
    16e4:	c5 01       	movw	r24, r10
    16e6:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>
    16ea:	ce 01       	movw	r24, r28
    16ec:	0c 96       	adiw	r24, 0x0c	; 12
    16ee:	0e 94 27 02 	call	0x44e	; 0x44e <vListInitialiseItem>
    16f2:	d9 87       	std	Y+9, r29	; 0x09
    16f4:	c8 87       	std	Y+8, r28	; 0x08
    16f6:	85 e0       	ldi	r24, 0x05	; 5
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	81 1b       	sub	r24, r17
    16fc:	91 09       	sbc	r25, r1
    16fe:	9d 87       	std	Y+13, r25	; 0x0d
    1700:	8c 87       	std	Y+12, r24	; 0x0c
    1702:	db 8b       	std	Y+19, r29	; 0x13
    1704:	ca 8b       	std	Y+18, r28	; 0x12
    1706:	a3 01       	movw	r20, r6
    1708:	b4 01       	movw	r22, r8
    170a:	c6 01       	movw	r24, r12
    170c:	d4 da       	rcall	.-2648   	; 0xcb6 <pxPortInitialiseStack>
    170e:	99 83       	std	Y+1, r25	; 0x01
    1710:	88 83       	st	Y, r24
    1712:	e1 14       	cp	r14, r1
    1714:	f1 04       	cpc	r15, r1
    1716:	19 f0       	breq	.+6      	; 0x171e <xTaskGenericCreate+0xc0>
    1718:	f7 01       	movw	r30, r14
    171a:	d1 83       	std	Z+1, r29	; 0x01
    171c:	c0 83       	st	Z, r28
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	0f 92       	push	r0
    1724:	80 91 7d 08 	lds	r24, 0x087D
    1728:	8f 5f       	subi	r24, 0xFF	; 255
    172a:	80 93 7d 08 	sts	0x087D, r24
    172e:	80 91 dd 08 	lds	r24, 0x08DD
    1732:	90 91 de 08 	lds	r25, 0x08DE
    1736:	89 2b       	or	r24, r25
    1738:	09 f0       	breq	.+2      	; 0x173c <xTaskGenericCreate+0xde>
    173a:	3f c0       	rjmp	.+126    	; 0x17ba <xTaskGenericCreate+0x15c>
    173c:	d0 93 de 08 	sts	0x08DE, r29
    1740:	c0 93 dd 08 	sts	0x08DD, r28
    1744:	80 91 7d 08 	lds	r24, 0x087D
    1748:	81 30       	cpi	r24, 0x01	; 1
    174a:	09 f0       	breq	.+2      	; 0x174e <xTaskGenericCreate+0xf0>
    174c:	45 c0       	rjmp	.+138    	; 0x17d8 <xTaskGenericCreate+0x17a>
    174e:	0f 2e       	mov	r0, r31
    1750:	f0 eb       	ldi	r31, 0xB0	; 176
    1752:	ef 2e       	mov	r14, r31
    1754:	f8 e0       	ldi	r31, 0x08	; 8
    1756:	ff 2e       	mov	r15, r31
    1758:	f0 2d       	mov	r31, r0
    175a:	0f 2e       	mov	r0, r31
    175c:	fd ed       	ldi	r31, 0xDD	; 221
    175e:	cf 2e       	mov	r12, r31
    1760:	f8 e0       	ldi	r31, 0x08	; 8
    1762:	df 2e       	mov	r13, r31
    1764:	f0 2d       	mov	r31, r0
    1766:	c7 01       	movw	r24, r14
    1768:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    176c:	f9 e0       	ldi	r31, 0x09	; 9
    176e:	ef 0e       	add	r14, r31
    1770:	f1 1c       	adc	r15, r1
    1772:	ec 14       	cp	r14, r12
    1774:	fd 04       	cpc	r15, r13
    1776:	b9 f7       	brne	.-18     	; 0x1766 <xTaskGenericCreate+0x108>
    1778:	87 ea       	ldi	r24, 0xA7	; 167
    177a:	98 e0       	ldi	r25, 0x08	; 8
    177c:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    1780:	8e e9       	ldi	r24, 0x9E	; 158
    1782:	98 e0       	ldi	r25, 0x08	; 8
    1784:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    1788:	81 e9       	ldi	r24, 0x91	; 145
    178a:	98 e0       	ldi	r25, 0x08	; 8
    178c:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    1790:	88 e8       	ldi	r24, 0x88	; 136
    1792:	98 e0       	ldi	r25, 0x08	; 8
    1794:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    1798:	8e e7       	ldi	r24, 0x7E	; 126
    179a:	98 e0       	ldi	r25, 0x08	; 8
    179c:	0e 94 19 02 	call	0x432	; 0x432 <vListInitialise>
    17a0:	87 ea       	ldi	r24, 0xA7	; 167
    17a2:	98 e0       	ldi	r25, 0x08	; 8
    17a4:	90 93 9d 08 	sts	0x089D, r25
    17a8:	80 93 9c 08 	sts	0x089C, r24
    17ac:	8e e9       	ldi	r24, 0x9E	; 158
    17ae:	98 e0       	ldi	r25, 0x08	; 8
    17b0:	90 93 9b 08 	sts	0x089B, r25
    17b4:	80 93 9a 08 	sts	0x089A, r24
    17b8:	0f c0       	rjmp	.+30     	; 0x17d8 <xTaskGenericCreate+0x17a>
    17ba:	80 91 79 08 	lds	r24, 0x0879
    17be:	81 11       	cpse	r24, r1
    17c0:	0b c0       	rjmp	.+22     	; 0x17d8 <xTaskGenericCreate+0x17a>
    17c2:	e0 91 dd 08 	lds	r30, 0x08DD
    17c6:	f0 91 de 08 	lds	r31, 0x08DE
    17ca:	86 89       	ldd	r24, Z+22	; 0x16
    17cc:	08 17       	cp	r16, r24
    17ce:	20 f0       	brcs	.+8      	; 0x17d8 <xTaskGenericCreate+0x17a>
    17d0:	d0 93 de 08 	sts	0x08DE, r29
    17d4:	c0 93 dd 08 	sts	0x08DD, r28
    17d8:	80 91 75 08 	lds	r24, 0x0875
    17dc:	8f 5f       	subi	r24, 0xFF	; 255
    17de:	80 93 75 08 	sts	0x0875, r24
    17e2:	8e 89       	ldd	r24, Y+22	; 0x16
    17e4:	90 91 7a 08 	lds	r25, 0x087A
    17e8:	98 17       	cp	r25, r24
    17ea:	10 f4       	brcc	.+4      	; 0x17f0 <xTaskGenericCreate+0x192>
    17ec:	80 93 7a 08 	sts	0x087A, r24
    17f0:	90 e0       	ldi	r25, 0x00	; 0
    17f2:	9c 01       	movw	r18, r24
    17f4:	22 0f       	add	r18, r18
    17f6:	33 1f       	adc	r19, r19
    17f8:	22 0f       	add	r18, r18
    17fa:	33 1f       	adc	r19, r19
    17fc:	22 0f       	add	r18, r18
    17fe:	33 1f       	adc	r19, r19
    1800:	82 0f       	add	r24, r18
    1802:	93 1f       	adc	r25, r19
    1804:	b5 01       	movw	r22, r10
    1806:	80 55       	subi	r24, 0x50	; 80
    1808:	97 4f       	sbci	r25, 0xF7	; 247
    180a:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    180e:	0f 90       	pop	r0
    1810:	0f be       	out	0x3f, r0	; 63
    1812:	80 91 79 08 	lds	r24, 0x0879
    1816:	88 23       	and	r24, r24
    1818:	51 f0       	breq	.+20     	; 0x182e <xTaskGenericCreate+0x1d0>
    181a:	e0 91 dd 08 	lds	r30, 0x08DD
    181e:	f0 91 de 08 	lds	r31, 0x08DE
    1822:	86 89       	ldd	r24, Z+22	; 0x16
    1824:	80 17       	cp	r24, r16
    1826:	28 f4       	brcc	.+10     	; 0x1832 <xTaskGenericCreate+0x1d4>
    1828:	f5 da       	rcall	.-2582   	; 0xe14 <vPortYield>
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	1c c0       	rjmp	.+56     	; 0x1866 <xTaskGenericCreate+0x208>
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	1a c0       	rjmp	.+52     	; 0x1866 <xTaskGenericCreate+0x208>
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	18 c0       	rjmp	.+48     	; 0x1866 <xTaskGenericCreate+0x208>
    1836:	d8 8e       	std	Y+24, r13	; 0x18
    1838:	cf 8a       	std	Y+23, r12	; 0x17
    183a:	81 e0       	ldi	r24, 0x01	; 1
    183c:	48 1a       	sub	r4, r24
    183e:	51 08       	sbc	r5, r1
    1840:	cf 88       	ldd	r12, Y+23	; 0x17
    1842:	d8 8c       	ldd	r13, Y+24	; 0x18
    1844:	c4 0c       	add	r12, r4
    1846:	d5 1c       	adc	r13, r5
    1848:	d5 01       	movw	r26, r10
    184a:	8c 91       	ld	r24, X
    184c:	89 8f       	std	Y+25, r24	; 0x19
    184e:	8c 91       	ld	r24, X
    1850:	88 23       	and	r24, r24
    1852:	09 f4       	brne	.+2      	; 0x1856 <xTaskGenericCreate+0x1f8>
    1854:	3b cf       	rjmp	.-394    	; 0x16cc <xTaskGenericCreate+0x6e>
    1856:	ae 01       	movw	r20, r28
    1858:	46 5e       	subi	r20, 0xE6	; 230
    185a:	5f 4f       	sbci	r21, 0xFF	; 255
    185c:	f5 01       	movw	r30, r10
    185e:	31 96       	adiw	r30, 0x01	; 1
    1860:	27 e0       	ldi	r18, 0x07	; 7
    1862:	29 cf       	rjmp	.-430    	; 0x16b6 <xTaskGenericCreate+0x58>
    1864:	8f ef       	ldi	r24, 0xFF	; 255
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	1f 91       	pop	r17
    186c:	0f 91       	pop	r16
    186e:	ff 90       	pop	r15
    1870:	ef 90       	pop	r14
    1872:	df 90       	pop	r13
    1874:	cf 90       	pop	r12
    1876:	bf 90       	pop	r11
    1878:	af 90       	pop	r10
    187a:	9f 90       	pop	r9
    187c:	8f 90       	pop	r8
    187e:	7f 90       	pop	r7
    1880:	6f 90       	pop	r6
    1882:	5f 90       	pop	r5
    1884:	4f 90       	pop	r4
    1886:	08 95       	ret

00001888 <vTaskResume>:
    1888:	0f 93       	push	r16
    188a:	1f 93       	push	r17
    188c:	cf 93       	push	r28
    188e:	df 93       	push	r29
    1890:	ec 01       	movw	r28, r24
    1892:	00 97       	sbiw	r24, 0x00	; 0
    1894:	09 f4       	brne	.+2      	; 0x1898 <vTaskResume+0x10>
    1896:	3e c0       	rjmp	.+124    	; 0x1914 <vTaskResume+0x8c>
    1898:	80 91 dd 08 	lds	r24, 0x08DD
    189c:	90 91 de 08 	lds	r25, 0x08DE
    18a0:	c8 17       	cp	r28, r24
    18a2:	d9 07       	cpc	r29, r25
    18a4:	b9 f1       	breq	.+110    	; 0x1914 <vTaskResume+0x8c>
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	0f 92       	push	r0
    18ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    18ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    18b0:	8e 57       	subi	r24, 0x7E	; 126
    18b2:	98 40       	sbci	r25, 0x08	; 8
    18b4:	69 f5       	brne	.+90     	; 0x1910 <vTaskResume+0x88>
    18b6:	8c 89       	ldd	r24, Y+20	; 0x14
    18b8:	9d 89       	ldd	r25, Y+21	; 0x15
    18ba:	28 e0       	ldi	r18, 0x08	; 8
    18bc:	81 39       	cpi	r24, 0x91	; 145
    18be:	92 07       	cpc	r25, r18
    18c0:	39 f1       	breq	.+78     	; 0x1910 <vTaskResume+0x88>
    18c2:	89 2b       	or	r24, r25
    18c4:	29 f5       	brne	.+74     	; 0x1910 <vTaskResume+0x88>
    18c6:	8e 01       	movw	r16, r28
    18c8:	0e 5f       	subi	r16, 0xFE	; 254
    18ca:	1f 4f       	sbci	r17, 0xFF	; 255
    18cc:	c8 01       	movw	r24, r16
    18ce:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    18d2:	8e 89       	ldd	r24, Y+22	; 0x16
    18d4:	90 91 7a 08 	lds	r25, 0x087A
    18d8:	98 17       	cp	r25, r24
    18da:	10 f4       	brcc	.+4      	; 0x18e0 <vTaskResume+0x58>
    18dc:	80 93 7a 08 	sts	0x087A, r24
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	9c 01       	movw	r18, r24
    18e4:	22 0f       	add	r18, r18
    18e6:	33 1f       	adc	r19, r19
    18e8:	22 0f       	add	r18, r18
    18ea:	33 1f       	adc	r19, r19
    18ec:	22 0f       	add	r18, r18
    18ee:	33 1f       	adc	r19, r19
    18f0:	82 0f       	add	r24, r18
    18f2:	93 1f       	adc	r25, r19
    18f4:	b8 01       	movw	r22, r16
    18f6:	80 55       	subi	r24, 0x50	; 80
    18f8:	97 4f       	sbci	r25, 0xF7	; 247
    18fa:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    18fe:	e0 91 dd 08 	lds	r30, 0x08DD
    1902:	f0 91 de 08 	lds	r31, 0x08DE
    1906:	9e 89       	ldd	r25, Y+22	; 0x16
    1908:	86 89       	ldd	r24, Z+22	; 0x16
    190a:	98 17       	cp	r25, r24
    190c:	08 f0       	brcs	.+2      	; 0x1910 <vTaskResume+0x88>
    190e:	82 da       	rcall	.-2812   	; 0xe14 <vPortYield>
    1910:	0f 90       	pop	r0
    1912:	0f be       	out	0x3f, r0	; 63
    1914:	df 91       	pop	r29
    1916:	cf 91       	pop	r28
    1918:	1f 91       	pop	r17
    191a:	0f 91       	pop	r16
    191c:	08 95       	ret

0000191e <vTaskStartScheduler>:
    191e:	af 92       	push	r10
    1920:	bf 92       	push	r11
    1922:	cf 92       	push	r12
    1924:	df 92       	push	r13
    1926:	ef 92       	push	r14
    1928:	ff 92       	push	r15
    192a:	0f 93       	push	r16
    192c:	a1 2c       	mov	r10, r1
    192e:	b1 2c       	mov	r11, r1
    1930:	c1 2c       	mov	r12, r1
    1932:	d1 2c       	mov	r13, r1
    1934:	e1 2c       	mov	r14, r1
    1936:	f1 2c       	mov	r15, r1
    1938:	00 e0       	ldi	r16, 0x00	; 0
    193a:	20 e0       	ldi	r18, 0x00	; 0
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	45 e5       	ldi	r20, 0x55	; 85
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	6f e8       	ldi	r22, 0x8F	; 143
    1944:	72 e0       	ldi	r23, 0x02	; 2
    1946:	86 e6       	ldi	r24, 0x66	; 102
    1948:	9e e0       	ldi	r25, 0x0E	; 14
    194a:	89 de       	rcall	.-750    	; 0x165e <xTaskGenericCreate>
    194c:	81 30       	cpi	r24, 0x01	; 1
    194e:	41 f4       	brne	.+16     	; 0x1960 <vTaskStartScheduler+0x42>
    1950:	f8 94       	cli
    1952:	80 93 79 08 	sts	0x0879, r24
    1956:	10 92 7c 08 	sts	0x087C, r1
    195a:	10 92 7b 08 	sts	0x087B, r1
    195e:	1d da       	rcall	.-3014   	; 0xd9a <xPortStartScheduler>
    1960:	0f 91       	pop	r16
    1962:	ff 90       	pop	r15
    1964:	ef 90       	pop	r14
    1966:	df 90       	pop	r13
    1968:	cf 90       	pop	r12
    196a:	bf 90       	pop	r11
    196c:	af 90       	pop	r10
    196e:	08 95       	ret

00001970 <vTaskSuspendAll>:
    1970:	80 91 74 08 	lds	r24, 0x0874
    1974:	8f 5f       	subi	r24, 0xFF	; 255
    1976:	80 93 74 08 	sts	0x0874, r24
    197a:	08 95       	ret

0000197c <xTaskGetTickCount>:
    197c:	0f b6       	in	r0, 0x3f	; 63
    197e:	f8 94       	cli
    1980:	0f 92       	push	r0
    1982:	80 91 7b 08 	lds	r24, 0x087B
    1986:	90 91 7c 08 	lds	r25, 0x087C
    198a:	0f 90       	pop	r0
    198c:	0f be       	out	0x3f, r0	; 63
    198e:	08 95       	ret

00001990 <xTaskGetTickCountFromISR>:
    1990:	80 91 7b 08 	lds	r24, 0x087B
    1994:	90 91 7c 08 	lds	r25, 0x087C
    1998:	08 95       	ret

0000199a <xTaskIncrementTick>:
    199a:	cf 92       	push	r12
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	80 91 74 08 	lds	r24, 0x0874
    19ae:	81 11       	cpse	r24, r1
    19b0:	99 c0       	rjmp	.+306    	; 0x1ae4 <xTaskIncrementTick+0x14a>
    19b2:	80 91 7b 08 	lds	r24, 0x087B
    19b6:	90 91 7c 08 	lds	r25, 0x087C
    19ba:	01 96       	adiw	r24, 0x01	; 1
    19bc:	90 93 7c 08 	sts	0x087C, r25
    19c0:	80 93 7b 08 	sts	0x087B, r24
    19c4:	e0 90 7b 08 	lds	r14, 0x087B
    19c8:	f0 90 7c 08 	lds	r15, 0x087C
    19cc:	e1 14       	cp	r14, r1
    19ce:	f1 04       	cpc	r15, r1
    19d0:	b1 f4       	brne	.+44     	; 0x19fe <xTaskIncrementTick+0x64>
    19d2:	80 91 9c 08 	lds	r24, 0x089C
    19d6:	90 91 9d 08 	lds	r25, 0x089D
    19da:	20 91 9a 08 	lds	r18, 0x089A
    19de:	30 91 9b 08 	lds	r19, 0x089B
    19e2:	30 93 9d 08 	sts	0x089D, r19
    19e6:	20 93 9c 08 	sts	0x089C, r18
    19ea:	90 93 9b 08 	sts	0x089B, r25
    19ee:	80 93 9a 08 	sts	0x089A, r24
    19f2:	80 91 76 08 	lds	r24, 0x0876
    19f6:	8f 5f       	subi	r24, 0xFF	; 255
    19f8:	80 93 76 08 	sts	0x0876, r24
    19fc:	da dd       	rcall	.-1100   	; 0x15b2 <prvResetNextTaskUnblockTime>
    19fe:	80 91 04 02 	lds	r24, 0x0204
    1a02:	90 91 05 02 	lds	r25, 0x0205
    1a06:	e8 16       	cp	r14, r24
    1a08:	f9 06       	cpc	r15, r25
    1a0a:	08 f4       	brcc	.+2      	; 0x1a0e <xTaskIncrementTick+0x74>
    1a0c:	54 c0       	rjmp	.+168    	; 0x1ab6 <xTaskIncrementTick+0x11c>
    1a0e:	d1 2c       	mov	r13, r1
    1a10:	cc 24       	eor	r12, r12
    1a12:	c3 94       	inc	r12
    1a14:	01 c0       	rjmp	.+2      	; 0x1a18 <xTaskIncrementTick+0x7e>
    1a16:	dc 2c       	mov	r13, r12
    1a18:	e0 91 9c 08 	lds	r30, 0x089C
    1a1c:	f0 91 9d 08 	lds	r31, 0x089D
    1a20:	80 81       	ld	r24, Z
    1a22:	81 11       	cpse	r24, r1
    1a24:	07 c0       	rjmp	.+14     	; 0x1a34 <xTaskIncrementTick+0x9a>
    1a26:	8f ef       	ldi	r24, 0xFF	; 255
    1a28:	9f ef       	ldi	r25, 0xFF	; 255
    1a2a:	90 93 05 02 	sts	0x0205, r25
    1a2e:	80 93 04 02 	sts	0x0204, r24
    1a32:	42 c0       	rjmp	.+132    	; 0x1ab8 <xTaskIncrementTick+0x11e>
    1a34:	e0 91 9c 08 	lds	r30, 0x089C
    1a38:	f0 91 9d 08 	lds	r31, 0x089D
    1a3c:	05 80       	ldd	r0, Z+5	; 0x05
    1a3e:	f6 81       	ldd	r31, Z+6	; 0x06
    1a40:	e0 2d       	mov	r30, r0
    1a42:	c6 81       	ldd	r28, Z+6	; 0x06
    1a44:	d7 81       	ldd	r29, Z+7	; 0x07
    1a46:	2a 81       	ldd	r18, Y+2	; 0x02
    1a48:	3b 81       	ldd	r19, Y+3	; 0x03
    1a4a:	e2 16       	cp	r14, r18
    1a4c:	f3 06       	cpc	r15, r19
    1a4e:	28 f4       	brcc	.+10     	; 0x1a5a <xTaskIncrementTick+0xc0>
    1a50:	30 93 05 02 	sts	0x0205, r19
    1a54:	20 93 04 02 	sts	0x0204, r18
    1a58:	2f c0       	rjmp	.+94     	; 0x1ab8 <xTaskIncrementTick+0x11e>
    1a5a:	8e 01       	movw	r16, r28
    1a5c:	0e 5f       	subi	r16, 0xFE	; 254
    1a5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a60:	c8 01       	movw	r24, r16
    1a62:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1a66:	8c 89       	ldd	r24, Y+20	; 0x14
    1a68:	9d 89       	ldd	r25, Y+21	; 0x15
    1a6a:	89 2b       	or	r24, r25
    1a6c:	21 f0       	breq	.+8      	; 0x1a76 <xTaskIncrementTick+0xdc>
    1a6e:	ce 01       	movw	r24, r28
    1a70:	0c 96       	adiw	r24, 0x0c	; 12
    1a72:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1a76:	2e 89       	ldd	r18, Y+22	; 0x16
    1a78:	80 91 7a 08 	lds	r24, 0x087A
    1a7c:	82 17       	cp	r24, r18
    1a7e:	10 f4       	brcc	.+4      	; 0x1a84 <xTaskIncrementTick+0xea>
    1a80:	20 93 7a 08 	sts	0x087A, r18
    1a84:	30 e0       	ldi	r19, 0x00	; 0
    1a86:	c9 01       	movw	r24, r18
    1a88:	88 0f       	add	r24, r24
    1a8a:	99 1f       	adc	r25, r25
    1a8c:	88 0f       	add	r24, r24
    1a8e:	99 1f       	adc	r25, r25
    1a90:	88 0f       	add	r24, r24
    1a92:	99 1f       	adc	r25, r25
    1a94:	82 0f       	add	r24, r18
    1a96:	93 1f       	adc	r25, r19
    1a98:	b8 01       	movw	r22, r16
    1a9a:	80 55       	subi	r24, 0x50	; 80
    1a9c:	97 4f       	sbci	r25, 0xF7	; 247
    1a9e:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1aa2:	e0 91 dd 08 	lds	r30, 0x08DD
    1aa6:	f0 91 de 08 	lds	r31, 0x08DE
    1aaa:	9e 89       	ldd	r25, Y+22	; 0x16
    1aac:	86 89       	ldd	r24, Z+22	; 0x16
    1aae:	98 17       	cp	r25, r24
    1ab0:	08 f0       	brcs	.+2      	; 0x1ab4 <xTaskIncrementTick+0x11a>
    1ab2:	b1 cf       	rjmp	.-158    	; 0x1a16 <xTaskIncrementTick+0x7c>
    1ab4:	b1 cf       	rjmp	.-158    	; 0x1a18 <xTaskIncrementTick+0x7e>
    1ab6:	d1 2c       	mov	r13, r1
    1ab8:	e0 91 dd 08 	lds	r30, 0x08DD
    1abc:	f0 91 de 08 	lds	r31, 0x08DE
    1ac0:	86 89       	ldd	r24, Z+22	; 0x16
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	ee 0f       	add	r30, r30
    1ad0:	ff 1f       	adc	r31, r31
    1ad2:	8e 0f       	add	r24, r30
    1ad4:	9f 1f       	adc	r25, r31
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	e0 55       	subi	r30, 0x50	; 80
    1ada:	f7 4f       	sbci	r31, 0xF7	; 247
    1adc:	80 81       	ld	r24, Z
    1ade:	82 30       	cpi	r24, 0x02	; 2
    1ae0:	40 f4       	brcc	.+16     	; 0x1af2 <xTaskIncrementTick+0x158>
    1ae2:	09 c0       	rjmp	.+18     	; 0x1af6 <xTaskIncrementTick+0x15c>
    1ae4:	80 91 78 08 	lds	r24, 0x0878
    1ae8:	8f 5f       	subi	r24, 0xFF	; 255
    1aea:	80 93 78 08 	sts	0x0878, r24
    1aee:	d1 2c       	mov	r13, r1
    1af0:	02 c0       	rjmp	.+4      	; 0x1af6 <xTaskIncrementTick+0x15c>
    1af2:	dd 24       	eor	r13, r13
    1af4:	d3 94       	inc	r13
    1af6:	80 91 77 08 	lds	r24, 0x0877
    1afa:	88 23       	and	r24, r24
    1afc:	11 f0       	breq	.+4      	; 0x1b02 <xTaskIncrementTick+0x168>
    1afe:	dd 24       	eor	r13, r13
    1b00:	d3 94       	inc	r13
    1b02:	8d 2d       	mov	r24, r13
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	ff 90       	pop	r15
    1b0e:	ef 90       	pop	r14
    1b10:	df 90       	pop	r13
    1b12:	cf 90       	pop	r12
    1b14:	08 95       	ret

00001b16 <xTaskResumeAll>:
    1b16:	df 92       	push	r13
    1b18:	ef 92       	push	r14
    1b1a:	ff 92       	push	r15
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	0f b6       	in	r0, 0x3f	; 63
    1b26:	f8 94       	cli
    1b28:	0f 92       	push	r0
    1b2a:	80 91 74 08 	lds	r24, 0x0874
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	80 93 74 08 	sts	0x0874, r24
    1b34:	80 91 74 08 	lds	r24, 0x0874
    1b38:	81 11       	cpse	r24, r1
    1b3a:	5f c0       	rjmp	.+190    	; 0x1bfa <xTaskResumeAll+0xe4>
    1b3c:	80 91 7d 08 	lds	r24, 0x087D
    1b40:	88 23       	and	r24, r24
    1b42:	09 f4       	brne	.+2      	; 0x1b46 <xTaskResumeAll+0x30>
    1b44:	5c c0       	rjmp	.+184    	; 0x1bfe <xTaskResumeAll+0xe8>
    1b46:	0f 2e       	mov	r0, r31
    1b48:	f1 e9       	ldi	r31, 0x91	; 145
    1b4a:	ef 2e       	mov	r14, r31
    1b4c:	f8 e0       	ldi	r31, 0x08	; 8
    1b4e:	ff 2e       	mov	r15, r31
    1b50:	f0 2d       	mov	r31, r0
    1b52:	dd 24       	eor	r13, r13
    1b54:	d3 94       	inc	r13
    1b56:	30 c0       	rjmp	.+96     	; 0x1bb8 <xTaskResumeAll+0xa2>
    1b58:	e0 91 96 08 	lds	r30, 0x0896
    1b5c:	f0 91 97 08 	lds	r31, 0x0897
    1b60:	c6 81       	ldd	r28, Z+6	; 0x06
    1b62:	d7 81       	ldd	r29, Z+7	; 0x07
    1b64:	ce 01       	movw	r24, r28
    1b66:	0c 96       	adiw	r24, 0x0c	; 12
    1b68:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1b6c:	8e 01       	movw	r16, r28
    1b6e:	0e 5f       	subi	r16, 0xFE	; 254
    1b70:	1f 4f       	sbci	r17, 0xFF	; 255
    1b72:	c8 01       	movw	r24, r16
    1b74:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1b78:	8e 89       	ldd	r24, Y+22	; 0x16
    1b7a:	90 91 7a 08 	lds	r25, 0x087A
    1b7e:	98 17       	cp	r25, r24
    1b80:	10 f4       	brcc	.+4      	; 0x1b86 <xTaskResumeAll+0x70>
    1b82:	80 93 7a 08 	sts	0x087A, r24
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	9c 01       	movw	r18, r24
    1b8a:	22 0f       	add	r18, r18
    1b8c:	33 1f       	adc	r19, r19
    1b8e:	22 0f       	add	r18, r18
    1b90:	33 1f       	adc	r19, r19
    1b92:	22 0f       	add	r18, r18
    1b94:	33 1f       	adc	r19, r19
    1b96:	82 0f       	add	r24, r18
    1b98:	93 1f       	adc	r25, r19
    1b9a:	b8 01       	movw	r22, r16
    1b9c:	80 55       	subi	r24, 0x50	; 80
    1b9e:	97 4f       	sbci	r25, 0xF7	; 247
    1ba0:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1ba4:	e0 91 dd 08 	lds	r30, 0x08DD
    1ba8:	f0 91 de 08 	lds	r31, 0x08DE
    1bac:	9e 89       	ldd	r25, Y+22	; 0x16
    1bae:	86 89       	ldd	r24, Z+22	; 0x16
    1bb0:	98 17       	cp	r25, r24
    1bb2:	10 f0       	brcs	.+4      	; 0x1bb8 <xTaskResumeAll+0xa2>
    1bb4:	d0 92 77 08 	sts	0x0877, r13
    1bb8:	f7 01       	movw	r30, r14
    1bba:	80 81       	ld	r24, Z
    1bbc:	81 11       	cpse	r24, r1
    1bbe:	cc cf       	rjmp	.-104    	; 0x1b58 <xTaskResumeAll+0x42>
    1bc0:	80 91 78 08 	lds	r24, 0x0878
    1bc4:	88 23       	and	r24, r24
    1bc6:	91 f0       	breq	.+36     	; 0x1bec <xTaskResumeAll+0xd6>
    1bc8:	80 91 78 08 	lds	r24, 0x0878
    1bcc:	88 23       	and	r24, r24
    1bce:	71 f0       	breq	.+28     	; 0x1bec <xTaskResumeAll+0xd6>
    1bd0:	c1 e0       	ldi	r28, 0x01	; 1
    1bd2:	e3 de       	rcall	.-570    	; 0x199a <xTaskIncrementTick>
    1bd4:	81 11       	cpse	r24, r1
    1bd6:	c0 93 77 08 	sts	0x0877, r28
    1bda:	80 91 78 08 	lds	r24, 0x0878
    1bde:	81 50       	subi	r24, 0x01	; 1
    1be0:	80 93 78 08 	sts	0x0878, r24
    1be4:	80 91 78 08 	lds	r24, 0x0878
    1be8:	81 11       	cpse	r24, r1
    1bea:	f3 cf       	rjmp	.-26     	; 0x1bd2 <xTaskResumeAll+0xbc>
    1bec:	80 91 77 08 	lds	r24, 0x0877
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	39 f4       	brne	.+14     	; 0x1c02 <xTaskResumeAll+0xec>
    1bf4:	0f d9       	rcall	.-3554   	; 0xe14 <vPortYield>
    1bf6:	81 e0       	ldi	r24, 0x01	; 1
    1bf8:	05 c0       	rjmp	.+10     	; 0x1c04 <xTaskResumeAll+0xee>
    1bfa:	80 e0       	ldi	r24, 0x00	; 0
    1bfc:	03 c0       	rjmp	.+6      	; 0x1c04 <xTaskResumeAll+0xee>
    1bfe:	80 e0       	ldi	r24, 0x00	; 0
    1c00:	01 c0       	rjmp	.+2      	; 0x1c04 <xTaskResumeAll+0xee>
    1c02:	80 e0       	ldi	r24, 0x00	; 0
    1c04:	0f 90       	pop	r0
    1c06:	0f be       	out	0x3f, r0	; 63
    1c08:	df 91       	pop	r29
    1c0a:	cf 91       	pop	r28
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	08 95       	ret

00001c18 <vTaskDelayUntil>:
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	8c 01       	movw	r16, r24
    1c22:	eb 01       	movw	r28, r22
    1c24:	a5 de       	rcall	.-694    	; 0x1970 <vTaskSuspendAll>
    1c26:	80 91 7b 08 	lds	r24, 0x087B
    1c2a:	90 91 7c 08 	lds	r25, 0x087C
    1c2e:	f8 01       	movw	r30, r16
    1c30:	20 81       	ld	r18, Z
    1c32:	31 81       	ldd	r19, Z+1	; 0x01
    1c34:	c2 0f       	add	r28, r18
    1c36:	d3 1f       	adc	r29, r19
    1c38:	82 17       	cp	r24, r18
    1c3a:	93 07       	cpc	r25, r19
    1c3c:	48 f4       	brcc	.+18     	; 0x1c50 <vTaskDelayUntil+0x38>
    1c3e:	c2 17       	cp	r28, r18
    1c40:	d3 07       	cpc	r29, r19
    1c42:	f8 f4       	brcc	.+62     	; 0x1c82 <vTaskDelayUntil+0x6a>
    1c44:	d1 83       	std	Z+1, r29	; 0x01
    1c46:	c0 83       	st	Z, r28
    1c48:	8c 17       	cp	r24, r28
    1c4a:	9d 07       	cpc	r25, r29
    1c4c:	88 f4       	brcc	.+34     	; 0x1c70 <vTaskDelayUntil+0x58>
    1c4e:	07 c0       	rjmp	.+14     	; 0x1c5e <vTaskDelayUntil+0x46>
    1c50:	c2 17       	cp	r28, r18
    1c52:	d3 07       	cpc	r29, r19
    1c54:	90 f0       	brcs	.+36     	; 0x1c7a <vTaskDelayUntil+0x62>
    1c56:	8c 17       	cp	r24, r28
    1c58:	9d 07       	cpc	r25, r29
    1c5a:	78 f0       	brcs	.+30     	; 0x1c7a <vTaskDelayUntil+0x62>
    1c5c:	12 c0       	rjmp	.+36     	; 0x1c82 <vTaskDelayUntil+0x6a>
    1c5e:	80 91 dd 08 	lds	r24, 0x08DD
    1c62:	90 91 de 08 	lds	r25, 0x08DE
    1c66:	02 96       	adiw	r24, 0x02	; 2
    1c68:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1c6c:	ce 01       	movw	r24, r28
    1c6e:	c0 dc       	rcall	.-1664   	; 0x15f0 <prvAddCurrentTaskToDelayedList>
    1c70:	52 df       	rcall	.-348    	; 0x1b16 <xTaskResumeAll>
    1c72:	81 11       	cpse	r24, r1
    1c74:	0a c0       	rjmp	.+20     	; 0x1c8a <vTaskDelayUntil+0x72>
    1c76:	ce d8       	rcall	.-3684   	; 0xe14 <vPortYield>
    1c78:	08 c0       	rjmp	.+16     	; 0x1c8a <vTaskDelayUntil+0x72>
    1c7a:	f8 01       	movw	r30, r16
    1c7c:	d1 83       	std	Z+1, r29	; 0x01
    1c7e:	c0 83       	st	Z, r28
    1c80:	ee cf       	rjmp	.-36     	; 0x1c5e <vTaskDelayUntil+0x46>
    1c82:	f8 01       	movw	r30, r16
    1c84:	d1 83       	std	Z+1, r29	; 0x01
    1c86:	c0 83       	st	Z, r28
    1c88:	f3 cf       	rjmp	.-26     	; 0x1c70 <vTaskDelayUntil+0x58>
    1c8a:	df 91       	pop	r29
    1c8c:	cf 91       	pop	r28
    1c8e:	1f 91       	pop	r17
    1c90:	0f 91       	pop	r16
    1c92:	08 95       	ret

00001c94 <vTaskDelay>:
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	ec 01       	movw	r28, r24
    1c9a:	00 97       	sbiw	r24, 0x00	; 0
    1c9c:	99 f0       	breq	.+38     	; 0x1cc4 <vTaskDelay+0x30>
    1c9e:	68 de       	rcall	.-816    	; 0x1970 <vTaskSuspendAll>
    1ca0:	80 91 7b 08 	lds	r24, 0x087B
    1ca4:	90 91 7c 08 	lds	r25, 0x087C
    1ca8:	c8 0f       	add	r28, r24
    1caa:	d9 1f       	adc	r29, r25
    1cac:	80 91 dd 08 	lds	r24, 0x08DD
    1cb0:	90 91 de 08 	lds	r25, 0x08DE
    1cb4:	02 96       	adiw	r24, 0x02	; 2
    1cb6:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1cba:	ce 01       	movw	r24, r28
    1cbc:	99 dc       	rcall	.-1742   	; 0x15f0 <prvAddCurrentTaskToDelayedList>
    1cbe:	2b df       	rcall	.-426    	; 0x1b16 <xTaskResumeAll>
    1cc0:	81 11       	cpse	r24, r1
    1cc2:	01 c0       	rjmp	.+2      	; 0x1cc6 <vTaskDelay+0x32>
    1cc4:	a7 d8       	rcall	.-3762   	; 0xe14 <vPortYield>
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	08 95       	ret

00001ccc <prvIdleTask>:
    1ccc:	0f 2e       	mov	r0, r31
    1cce:	f0 eb       	ldi	r31, 0xB0	; 176
    1cd0:	ef 2e       	mov	r14, r31
    1cd2:	f8 e0       	ldi	r31, 0x08	; 8
    1cd4:	ff 2e       	mov	r15, r31
    1cd6:	f0 2d       	mov	r31, r0
    1cd8:	c8 e8       	ldi	r28, 0x88	; 136
    1cda:	d8 e0       	ldi	r29, 0x08	; 8
    1cdc:	26 c0       	rjmp	.+76     	; 0x1d2a <prvIdleTask+0x5e>
    1cde:	48 de       	rcall	.-880    	; 0x1970 <vTaskSuspendAll>
    1ce0:	18 81       	ld	r17, Y
    1ce2:	19 df       	rcall	.-462    	; 0x1b16 <xTaskResumeAll>
    1ce4:	11 23       	and	r17, r17
    1ce6:	09 f1       	breq	.+66     	; 0x1d2a <prvIdleTask+0x5e>
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	f8 94       	cli
    1cec:	0f 92       	push	r0
    1cee:	e0 91 8d 08 	lds	r30, 0x088D
    1cf2:	f0 91 8e 08 	lds	r31, 0x088E
    1cf6:	06 81       	ldd	r16, Z+6	; 0x06
    1cf8:	17 81       	ldd	r17, Z+7	; 0x07
    1cfa:	c8 01       	movw	r24, r16
    1cfc:	02 96       	adiw	r24, 0x02	; 2
    1cfe:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1d02:	80 91 7d 08 	lds	r24, 0x087D
    1d06:	81 50       	subi	r24, 0x01	; 1
    1d08:	80 93 7d 08 	sts	0x087D, r24
    1d0c:	80 91 87 08 	lds	r24, 0x0887
    1d10:	81 50       	subi	r24, 0x01	; 1
    1d12:	80 93 87 08 	sts	0x0887, r24
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	f8 01       	movw	r30, r16
    1d1c:	87 89       	ldd	r24, Z+23	; 0x17
    1d1e:	90 8d       	ldd	r25, Z+24	; 0x18
    1d20:	0e 94 18 02 	call	0x430	; 0x430 <vPortFree>
    1d24:	c8 01       	movw	r24, r16
    1d26:	0e 94 18 02 	call	0x430	; 0x430 <vPortFree>
    1d2a:	80 91 87 08 	lds	r24, 0x0887
    1d2e:	81 11       	cpse	r24, r1
    1d30:	d6 cf       	rjmp	.-84     	; 0x1cde <prvIdleTask+0x12>
    1d32:	f7 01       	movw	r30, r14
    1d34:	80 81       	ld	r24, Z
    1d36:	82 30       	cpi	r24, 0x02	; 2
    1d38:	c0 f3       	brcs	.-16     	; 0x1d2a <prvIdleTask+0x5e>
    1d3a:	6c d8       	rcall	.-3880   	; 0xe14 <vPortYield>
    1d3c:	f6 cf       	rjmp	.-20     	; 0x1d2a <prvIdleTask+0x5e>

00001d3e <vTaskSwitchContext>:
    1d3e:	80 91 74 08 	lds	r24, 0x0874
    1d42:	88 23       	and	r24, r24
    1d44:	21 f0       	breq	.+8      	; 0x1d4e <vTaskSwitchContext+0x10>
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	80 93 77 08 	sts	0x0877, r24
    1d4c:	08 95       	ret
    1d4e:	10 92 77 08 	sts	0x0877, r1
    1d52:	80 91 7a 08 	lds	r24, 0x087A
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	fc 01       	movw	r30, r24
    1d5a:	ee 0f       	add	r30, r30
    1d5c:	ff 1f       	adc	r31, r31
    1d5e:	ee 0f       	add	r30, r30
    1d60:	ff 1f       	adc	r31, r31
    1d62:	ee 0f       	add	r30, r30
    1d64:	ff 1f       	adc	r31, r31
    1d66:	8e 0f       	add	r24, r30
    1d68:	9f 1f       	adc	r25, r31
    1d6a:	fc 01       	movw	r30, r24
    1d6c:	e0 55       	subi	r30, 0x50	; 80
    1d6e:	f7 4f       	sbci	r31, 0xF7	; 247
    1d70:	80 81       	ld	r24, Z
    1d72:	81 11       	cpse	r24, r1
    1d74:	17 c0       	rjmp	.+46     	; 0x1da4 <vTaskSwitchContext+0x66>
    1d76:	80 91 7a 08 	lds	r24, 0x087A
    1d7a:	81 50       	subi	r24, 0x01	; 1
    1d7c:	80 93 7a 08 	sts	0x087A, r24
    1d80:	80 91 7a 08 	lds	r24, 0x087A
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	fc 01       	movw	r30, r24
    1d88:	ee 0f       	add	r30, r30
    1d8a:	ff 1f       	adc	r31, r31
    1d8c:	ee 0f       	add	r30, r30
    1d8e:	ff 1f       	adc	r31, r31
    1d90:	ee 0f       	add	r30, r30
    1d92:	ff 1f       	adc	r31, r31
    1d94:	8e 0f       	add	r24, r30
    1d96:	9f 1f       	adc	r25, r31
    1d98:	fc 01       	movw	r30, r24
    1d9a:	e0 55       	subi	r30, 0x50	; 80
    1d9c:	f7 4f       	sbci	r31, 0xF7	; 247
    1d9e:	80 81       	ld	r24, Z
    1da0:	88 23       	and	r24, r24
    1da2:	49 f3       	breq	.-46     	; 0x1d76 <vTaskSwitchContext+0x38>
    1da4:	e0 91 7a 08 	lds	r30, 0x087A
    1da8:	f0 e0       	ldi	r31, 0x00	; 0
    1daa:	cf 01       	movw	r24, r30
    1dac:	88 0f       	add	r24, r24
    1dae:	99 1f       	adc	r25, r25
    1db0:	88 0f       	add	r24, r24
    1db2:	99 1f       	adc	r25, r25
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	e8 0f       	add	r30, r24
    1dba:	f9 1f       	adc	r31, r25
    1dbc:	e0 55       	subi	r30, 0x50	; 80
    1dbe:	f7 4f       	sbci	r31, 0xF7	; 247
    1dc0:	a1 81       	ldd	r26, Z+1	; 0x01
    1dc2:	b2 81       	ldd	r27, Z+2	; 0x02
    1dc4:	12 96       	adiw	r26, 0x02	; 2
    1dc6:	0d 90       	ld	r0, X+
    1dc8:	bc 91       	ld	r27, X
    1dca:	a0 2d       	mov	r26, r0
    1dcc:	b2 83       	std	Z+2, r27	; 0x02
    1dce:	a1 83       	std	Z+1, r26	; 0x01
    1dd0:	cf 01       	movw	r24, r30
    1dd2:	03 96       	adiw	r24, 0x03	; 3
    1dd4:	a8 17       	cp	r26, r24
    1dd6:	b9 07       	cpc	r27, r25
    1dd8:	31 f4       	brne	.+12     	; 0x1de6 <vTaskSwitchContext+0xa8>
    1dda:	12 96       	adiw	r26, 0x02	; 2
    1ddc:	8d 91       	ld	r24, X+
    1dde:	9c 91       	ld	r25, X
    1de0:	13 97       	sbiw	r26, 0x03	; 3
    1de2:	92 83       	std	Z+2, r25	; 0x02
    1de4:	81 83       	std	Z+1, r24	; 0x01
    1de6:	01 80       	ldd	r0, Z+1	; 0x01
    1de8:	f2 81       	ldd	r31, Z+2	; 0x02
    1dea:	e0 2d       	mov	r30, r0
    1dec:	86 81       	ldd	r24, Z+6	; 0x06
    1dee:	97 81       	ldd	r25, Z+7	; 0x07
    1df0:	90 93 de 08 	sts	0x08DE, r25
    1df4:	80 93 dd 08 	sts	0x08DD, r24
    1df8:	08 95       	ret

00001dfa <vTaskSuspend>:
    1dfa:	0f 93       	push	r16
    1dfc:	1f 93       	push	r17
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	ec 01       	movw	r28, r24
    1e04:	0f b6       	in	r0, 0x3f	; 63
    1e06:	f8 94       	cli
    1e08:	0f 92       	push	r0
    1e0a:	00 97       	sbiw	r24, 0x00	; 0
    1e0c:	21 f4       	brne	.+8      	; 0x1e16 <vTaskSuspend+0x1c>
    1e0e:	c0 91 dd 08 	lds	r28, 0x08DD
    1e12:	d0 91 de 08 	lds	r29, 0x08DE
    1e16:	8e 01       	movw	r16, r28
    1e18:	0e 5f       	subi	r16, 0xFE	; 254
    1e1a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e1c:	c8 01       	movw	r24, r16
    1e1e:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1e22:	8c 89       	ldd	r24, Y+20	; 0x14
    1e24:	9d 89       	ldd	r25, Y+21	; 0x15
    1e26:	89 2b       	or	r24, r25
    1e28:	21 f0       	breq	.+8      	; 0x1e32 <vTaskSuspend+0x38>
    1e2a:	ce 01       	movw	r24, r28
    1e2c:	0c 96       	adiw	r24, 0x0c	; 12
    1e2e:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1e32:	b8 01       	movw	r22, r16
    1e34:	8e e7       	ldi	r24, 0x7E	; 126
    1e36:	98 e0       	ldi	r25, 0x08	; 8
    1e38:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1e3c:	0f 90       	pop	r0
    1e3e:	0f be       	out	0x3f, r0	; 63
    1e40:	80 91 dd 08 	lds	r24, 0x08DD
    1e44:	90 91 de 08 	lds	r25, 0x08DE
    1e48:	c8 17       	cp	r28, r24
    1e4a:	d9 07       	cpc	r29, r25
    1e4c:	a1 f4       	brne	.+40     	; 0x1e76 <vTaskSuspend+0x7c>
    1e4e:	80 91 79 08 	lds	r24, 0x0879
    1e52:	88 23       	and	r24, r24
    1e54:	19 f0       	breq	.+6      	; 0x1e5c <vTaskSuspend+0x62>
    1e56:	0e 94 0a 07 	call	0xe14	; 0xe14 <vPortYield>
    1e5a:	17 c0       	rjmp	.+46     	; 0x1e8a <vTaskSuspend+0x90>
    1e5c:	80 91 7d 08 	lds	r24, 0x087D
    1e60:	90 91 7e 08 	lds	r25, 0x087E
    1e64:	98 13       	cpse	r25, r24
    1e66:	05 c0       	rjmp	.+10     	; 0x1e72 <vTaskSuspend+0x78>
    1e68:	10 92 de 08 	sts	0x08DE, r1
    1e6c:	10 92 dd 08 	sts	0x08DD, r1
    1e70:	0c c0       	rjmp	.+24     	; 0x1e8a <vTaskSuspend+0x90>
    1e72:	65 df       	rcall	.-310    	; 0x1d3e <vTaskSwitchContext>
    1e74:	0a c0       	rjmp	.+20     	; 0x1e8a <vTaskSuspend+0x90>
    1e76:	80 91 79 08 	lds	r24, 0x0879
    1e7a:	88 23       	and	r24, r24
    1e7c:	31 f0       	breq	.+12     	; 0x1e8a <vTaskSuspend+0x90>
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	0f 92       	push	r0
    1e84:	96 db       	rcall	.-2260   	; 0x15b2 <prvResetNextTaskUnblockTime>
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	df 91       	pop	r29
    1e8c:	cf 91       	pop	r28
    1e8e:	1f 91       	pop	r17
    1e90:	0f 91       	pop	r16
    1e92:	08 95       	ret

00001e94 <vTaskPlaceOnEventList>:
    1e94:	cf 93       	push	r28
    1e96:	df 93       	push	r29
    1e98:	eb 01       	movw	r28, r22
    1e9a:	60 91 dd 08 	lds	r22, 0x08DD
    1e9e:	70 91 de 08 	lds	r23, 0x08DE
    1ea2:	64 5f       	subi	r22, 0xF4	; 244
    1ea4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea6:	0e 94 4c 02 	call	0x498	; 0x498 <vListInsert>
    1eaa:	80 91 dd 08 	lds	r24, 0x08DD
    1eae:	90 91 de 08 	lds	r25, 0x08DE
    1eb2:	02 96       	adiw	r24, 0x02	; 2
    1eb4:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1eb8:	cf 3f       	cpi	r28, 0xFF	; 255
    1eba:	8f ef       	ldi	r24, 0xFF	; 255
    1ebc:	d8 07       	cpc	r29, r24
    1ebe:	59 f4       	brne	.+22     	; 0x1ed6 <vTaskPlaceOnEventList+0x42>
    1ec0:	60 91 dd 08 	lds	r22, 0x08DD
    1ec4:	70 91 de 08 	lds	r23, 0x08DE
    1ec8:	6e 5f       	subi	r22, 0xFE	; 254
    1eca:	7f 4f       	sbci	r23, 0xFF	; 255
    1ecc:	8e e7       	ldi	r24, 0x7E	; 126
    1ece:	98 e0       	ldi	r25, 0x08	; 8
    1ed0:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1ed4:	07 c0       	rjmp	.+14     	; 0x1ee4 <vTaskPlaceOnEventList+0x50>
    1ed6:	80 91 7b 08 	lds	r24, 0x087B
    1eda:	90 91 7c 08 	lds	r25, 0x087C
    1ede:	8c 0f       	add	r24, r28
    1ee0:	9d 1f       	adc	r25, r29
    1ee2:	86 db       	rcall	.-2292   	; 0x15f0 <prvAddCurrentTaskToDelayedList>
    1ee4:	df 91       	pop	r29
    1ee6:	cf 91       	pop	r28
    1ee8:	08 95       	ret

00001eea <xTaskRemoveFromEventList>:
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
    1ef2:	dc 01       	movw	r26, r24
    1ef4:	15 96       	adiw	r26, 0x05	; 5
    1ef6:	ed 91       	ld	r30, X+
    1ef8:	fc 91       	ld	r31, X
    1efa:	16 97       	sbiw	r26, 0x06	; 6
    1efc:	c6 81       	ldd	r28, Z+6	; 0x06
    1efe:	d7 81       	ldd	r29, Z+7	; 0x07
    1f00:	8e 01       	movw	r16, r28
    1f02:	04 5f       	subi	r16, 0xF4	; 244
    1f04:	1f 4f       	sbci	r17, 0xFF	; 255
    1f06:	c8 01       	movw	r24, r16
    1f08:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1f0c:	80 91 74 08 	lds	r24, 0x0874
    1f10:	81 11       	cpse	r24, r1
    1f12:	1c c0       	rjmp	.+56     	; 0x1f4c <xTaskRemoveFromEventList+0x62>
    1f14:	0a 50       	subi	r16, 0x0A	; 10
    1f16:	11 09       	sbc	r17, r1
    1f18:	c8 01       	movw	r24, r16
    1f1a:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    1f1e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f20:	90 91 7a 08 	lds	r25, 0x087A
    1f24:	98 17       	cp	r25, r24
    1f26:	10 f4       	brcc	.+4      	; 0x1f2c <xTaskRemoveFromEventList+0x42>
    1f28:	80 93 7a 08 	sts	0x087A, r24
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	9c 01       	movw	r18, r24
    1f30:	22 0f       	add	r18, r18
    1f32:	33 1f       	adc	r19, r19
    1f34:	22 0f       	add	r18, r18
    1f36:	33 1f       	adc	r19, r19
    1f38:	22 0f       	add	r18, r18
    1f3a:	33 1f       	adc	r19, r19
    1f3c:	82 0f       	add	r24, r18
    1f3e:	93 1f       	adc	r25, r19
    1f40:	b8 01       	movw	r22, r16
    1f42:	80 55       	subi	r24, 0x50	; 80
    1f44:	97 4f       	sbci	r25, 0xF7	; 247
    1f46:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1f4a:	05 c0       	rjmp	.+10     	; 0x1f56 <xTaskRemoveFromEventList+0x6c>
    1f4c:	b8 01       	movw	r22, r16
    1f4e:	81 e9       	ldi	r24, 0x91	; 145
    1f50:	98 e0       	ldi	r25, 0x08	; 8
    1f52:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    1f56:	e0 91 dd 08 	lds	r30, 0x08DD
    1f5a:	f0 91 de 08 	lds	r31, 0x08DE
    1f5e:	9e 89       	ldd	r25, Y+22	; 0x16
    1f60:	86 89       	ldd	r24, Z+22	; 0x16
    1f62:	89 17       	cp	r24, r25
    1f64:	20 f4       	brcc	.+8      	; 0x1f6e <xTaskRemoveFromEventList+0x84>
    1f66:	81 e0       	ldi	r24, 0x01	; 1
    1f68:	80 93 77 08 	sts	0x0877, r24
    1f6c:	01 c0       	rjmp	.+2      	; 0x1f70 <xTaskRemoveFromEventList+0x86>
    1f6e:	80 e0       	ldi	r24, 0x00	; 0
    1f70:	df 91       	pop	r29
    1f72:	cf 91       	pop	r28
    1f74:	1f 91       	pop	r17
    1f76:	0f 91       	pop	r16
    1f78:	08 95       	ret

00001f7a <vTaskSetTimeOutState>:
    1f7a:	20 91 76 08 	lds	r18, 0x0876
    1f7e:	fc 01       	movw	r30, r24
    1f80:	20 83       	st	Z, r18
    1f82:	20 91 7b 08 	lds	r18, 0x087B
    1f86:	30 91 7c 08 	lds	r19, 0x087C
    1f8a:	32 83       	std	Z+2, r19	; 0x02
    1f8c:	21 83       	std	Z+1, r18	; 0x01
    1f8e:	08 95       	ret

00001f90 <xTaskCheckForTimeOut>:
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	0f 92       	push	r0
    1f96:	40 91 7b 08 	lds	r20, 0x087B
    1f9a:	50 91 7c 08 	lds	r21, 0x087C
    1f9e:	db 01       	movw	r26, r22
    1fa0:	2d 91       	ld	r18, X+
    1fa2:	3c 91       	ld	r19, X
    1fa4:	2f 3f       	cpi	r18, 0xFF	; 255
    1fa6:	bf ef       	ldi	r27, 0xFF	; 255
    1fa8:	3b 07       	cpc	r19, r27
    1faa:	11 f1       	breq	.+68     	; 0x1ff0 <xTaskCheckForTimeOut+0x60>
    1fac:	e0 91 76 08 	lds	r30, 0x0876
    1fb0:	dc 01       	movw	r26, r24
    1fb2:	fc 91       	ld	r31, X
    1fb4:	fe 17       	cp	r31, r30
    1fb6:	39 f0       	breq	.+14     	; 0x1fc6 <xTaskCheckForTimeOut+0x36>
    1fb8:	11 96       	adiw	r26, 0x01	; 1
    1fba:	ed 91       	ld	r30, X+
    1fbc:	fc 91       	ld	r31, X
    1fbe:	12 97       	sbiw	r26, 0x02	; 2
    1fc0:	4e 17       	cp	r20, r30
    1fc2:	5f 07       	cpc	r21, r31
    1fc4:	b8 f4       	brcc	.+46     	; 0x1ff4 <xTaskCheckForTimeOut+0x64>
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	11 96       	adiw	r26, 0x01	; 1
    1fca:	ed 91       	ld	r30, X+
    1fcc:	fc 91       	ld	r31, X
    1fce:	12 97       	sbiw	r26, 0x02	; 2
    1fd0:	da 01       	movw	r26, r20
    1fd2:	ae 1b       	sub	r26, r30
    1fd4:	bf 0b       	sbc	r27, r31
    1fd6:	a2 17       	cp	r26, r18
    1fd8:	b3 07       	cpc	r27, r19
    1fda:	70 f4       	brcc	.+28     	; 0x1ff8 <xTaskCheckForTimeOut+0x68>
    1fdc:	e4 1b       	sub	r30, r20
    1fde:	f5 0b       	sbc	r31, r21
    1fe0:	2e 0f       	add	r18, r30
    1fe2:	3f 1f       	adc	r19, r31
    1fe4:	fb 01       	movw	r30, r22
    1fe6:	31 83       	std	Z+1, r19	; 0x01
    1fe8:	20 83       	st	Z, r18
    1fea:	c7 df       	rcall	.-114    	; 0x1f7a <vTaskSetTimeOutState>
    1fec:	80 e0       	ldi	r24, 0x00	; 0
    1fee:	05 c0       	rjmp	.+10     	; 0x1ffa <xTaskCheckForTimeOut+0x6a>
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	03 c0       	rjmp	.+6      	; 0x1ffa <xTaskCheckForTimeOut+0x6a>
    1ff4:	81 e0       	ldi	r24, 0x01	; 1
    1ff6:	01 c0       	rjmp	.+2      	; 0x1ffa <xTaskCheckForTimeOut+0x6a>
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	08 95       	ret

00002000 <vTaskMissedYield>:
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	80 93 77 08 	sts	0x0877, r24
    2006:	08 95       	ret

00002008 <vTaskPriorityInherit>:
    2008:	0f 93       	push	r16
    200a:	1f 93       	push	r17
    200c:	cf 93       	push	r28
    200e:	df 93       	push	r29
    2010:	ec 01       	movw	r28, r24
    2012:	00 97       	sbiw	r24, 0x00	; 0
    2014:	09 f4       	brne	.+2      	; 0x2018 <vTaskPriorityInherit+0x10>
    2016:	51 c0       	rjmp	.+162    	; 0x20ba <vTaskPriorityInherit+0xb2>
    2018:	8e 89       	ldd	r24, Y+22	; 0x16
    201a:	e0 91 dd 08 	lds	r30, 0x08DD
    201e:	f0 91 de 08 	lds	r31, 0x08DE
    2022:	96 89       	ldd	r25, Z+22	; 0x16
    2024:	89 17       	cp	r24, r25
    2026:	08 f0       	brcs	.+2      	; 0x202a <vTaskPriorityInherit+0x22>
    2028:	48 c0       	rjmp	.+144    	; 0x20ba <vTaskPriorityInherit+0xb2>
    202a:	2c 85       	ldd	r18, Y+12	; 0x0c
    202c:	3d 85       	ldd	r19, Y+13	; 0x0d
    202e:	33 23       	and	r19, r19
    2030:	5c f0       	brlt	.+22     	; 0x2048 <vTaskPriorityInherit+0x40>
    2032:	e0 91 dd 08 	lds	r30, 0x08DD
    2036:	f0 91 de 08 	lds	r31, 0x08DE
    203a:	96 89       	ldd	r25, Z+22	; 0x16
    203c:	25 e0       	ldi	r18, 0x05	; 5
    203e:	30 e0       	ldi	r19, 0x00	; 0
    2040:	29 1b       	sub	r18, r25
    2042:	31 09       	sbc	r19, r1
    2044:	3d 87       	std	Y+13, r19	; 0x0d
    2046:	2c 87       	std	Y+12, r18	; 0x0c
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	9c 01       	movw	r18, r24
    204c:	22 0f       	add	r18, r18
    204e:	33 1f       	adc	r19, r19
    2050:	22 0f       	add	r18, r18
    2052:	33 1f       	adc	r19, r19
    2054:	22 0f       	add	r18, r18
    2056:	33 1f       	adc	r19, r19
    2058:	82 0f       	add	r24, r18
    205a:	93 1f       	adc	r25, r19
    205c:	80 55       	subi	r24, 0x50	; 80
    205e:	97 4f       	sbci	r25, 0xF7	; 247
    2060:	2a 85       	ldd	r18, Y+10	; 0x0a
    2062:	3b 85       	ldd	r19, Y+11	; 0x0b
    2064:	28 17       	cp	r18, r24
    2066:	39 07       	cpc	r19, r25
    2068:	11 f5       	brne	.+68     	; 0x20ae <vTaskPriorityInherit+0xa6>
    206a:	8e 01       	movw	r16, r28
    206c:	0e 5f       	subi	r16, 0xFE	; 254
    206e:	1f 4f       	sbci	r17, 0xFF	; 255
    2070:	c8 01       	movw	r24, r16
    2072:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    2076:	e0 91 dd 08 	lds	r30, 0x08DD
    207a:	f0 91 de 08 	lds	r31, 0x08DE
    207e:	86 89       	ldd	r24, Z+22	; 0x16
    2080:	8e 8b       	std	Y+22, r24	; 0x16
    2082:	90 91 7a 08 	lds	r25, 0x087A
    2086:	98 17       	cp	r25, r24
    2088:	10 f4       	brcc	.+4      	; 0x208e <vTaskPriorityInherit+0x86>
    208a:	80 93 7a 08 	sts	0x087A, r24
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	9c 01       	movw	r18, r24
    2092:	22 0f       	add	r18, r18
    2094:	33 1f       	adc	r19, r19
    2096:	22 0f       	add	r18, r18
    2098:	33 1f       	adc	r19, r19
    209a:	22 0f       	add	r18, r18
    209c:	33 1f       	adc	r19, r19
    209e:	82 0f       	add	r24, r18
    20a0:	93 1f       	adc	r25, r19
    20a2:	b8 01       	movw	r22, r16
    20a4:	80 55       	subi	r24, 0x50	; 80
    20a6:	97 4f       	sbci	r25, 0xF7	; 247
    20a8:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    20ac:	06 c0       	rjmp	.+12     	; 0x20ba <vTaskPriorityInherit+0xb2>
    20ae:	e0 91 dd 08 	lds	r30, 0x08DD
    20b2:	f0 91 de 08 	lds	r31, 0x08DE
    20b6:	86 89       	ldd	r24, Z+22	; 0x16
    20b8:	8e 8b       	std	Y+22, r24	; 0x16
    20ba:	df 91       	pop	r29
    20bc:	cf 91       	pop	r28
    20be:	1f 91       	pop	r17
    20c0:	0f 91       	pop	r16
    20c2:	08 95       	ret

000020c4 <xTaskPriorityDisinherit>:
    20c4:	0f 93       	push	r16
    20c6:	1f 93       	push	r17
    20c8:	cf 93       	push	r28
    20ca:	df 93       	push	r29
    20cc:	ec 01       	movw	r28, r24
    20ce:	00 97       	sbiw	r24, 0x00	; 0
    20d0:	71 f1       	breq	.+92     	; 0x212e <xTaskPriorityDisinherit+0x6a>
    20d2:	8a a1       	ldd	r24, Y+34	; 0x22
    20d4:	81 50       	subi	r24, 0x01	; 1
    20d6:	8a a3       	std	Y+34, r24	; 0x22
    20d8:	2e 89       	ldd	r18, Y+22	; 0x16
    20da:	99 a1       	ldd	r25, Y+33	; 0x21
    20dc:	29 17       	cp	r18, r25
    20de:	49 f1       	breq	.+82     	; 0x2132 <xTaskPriorityDisinherit+0x6e>
    20e0:	81 11       	cpse	r24, r1
    20e2:	29 c0       	rjmp	.+82     	; 0x2136 <xTaskPriorityDisinherit+0x72>
    20e4:	8e 01       	movw	r16, r28
    20e6:	0e 5f       	subi	r16, 0xFE	; 254
    20e8:	1f 4f       	sbci	r17, 0xFF	; 255
    20ea:	c8 01       	movw	r24, r16
    20ec:	0e 94 7d 02 	call	0x4fa	; 0x4fa <uxListRemove>
    20f0:	89 a1       	ldd	r24, Y+33	; 0x21
    20f2:	8e 8b       	std	Y+22, r24	; 0x16
    20f4:	25 e0       	ldi	r18, 0x05	; 5
    20f6:	30 e0       	ldi	r19, 0x00	; 0
    20f8:	28 1b       	sub	r18, r24
    20fa:	31 09       	sbc	r19, r1
    20fc:	3d 87       	std	Y+13, r19	; 0x0d
    20fe:	2c 87       	std	Y+12, r18	; 0x0c
    2100:	90 91 7a 08 	lds	r25, 0x087A
    2104:	98 17       	cp	r25, r24
    2106:	10 f4       	brcc	.+4      	; 0x210c <xTaskPriorityDisinherit+0x48>
    2108:	80 93 7a 08 	sts	0x087A, r24
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	9c 01       	movw	r18, r24
    2110:	22 0f       	add	r18, r18
    2112:	33 1f       	adc	r19, r19
    2114:	22 0f       	add	r18, r18
    2116:	33 1f       	adc	r19, r19
    2118:	22 0f       	add	r18, r18
    211a:	33 1f       	adc	r19, r19
    211c:	82 0f       	add	r24, r18
    211e:	93 1f       	adc	r25, r19
    2120:	b8 01       	movw	r22, r16
    2122:	80 55       	subi	r24, 0x50	; 80
    2124:	97 4f       	sbci	r25, 0xF7	; 247
    2126:	0e 94 2b 02 	call	0x456	; 0x456 <vListInsertEnd>
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	05 c0       	rjmp	.+10     	; 0x2138 <xTaskPriorityDisinherit+0x74>
    212e:	80 e0       	ldi	r24, 0x00	; 0
    2130:	03 c0       	rjmp	.+6      	; 0x2138 <xTaskPriorityDisinherit+0x74>
    2132:	80 e0       	ldi	r24, 0x00	; 0
    2134:	01 c0       	rjmp	.+2      	; 0x2138 <xTaskPriorityDisinherit+0x74>
    2136:	80 e0       	ldi	r24, 0x00	; 0
    2138:	df 91       	pop	r29
    213a:	cf 91       	pop	r28
    213c:	1f 91       	pop	r17
    213e:	0f 91       	pop	r16
    2140:	08 95       	ret

00002142 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2142:	80 91 dd 08 	lds	r24, 0x08DD
    2146:	90 91 de 08 	lds	r25, 0x08DE
    214a:	89 2b       	or	r24, r25
    214c:	39 f0       	breq	.+14     	; 0x215c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    214e:	e0 91 dd 08 	lds	r30, 0x08DD
    2152:	f0 91 de 08 	lds	r31, 0x08DE
    2156:	82 a1       	ldd	r24, Z+34	; 0x22
    2158:	8f 5f       	subi	r24, 0xFF	; 255
    215a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    215c:	80 91 dd 08 	lds	r24, 0x08DD
    2160:	90 91 de 08 	lds	r25, 0x08DE
	}
    2164:	08 95       	ret

00002166 <__divmodhi4>:
    2166:	97 fb       	bst	r25, 7
    2168:	07 2e       	mov	r0, r23
    216a:	16 f4       	brtc	.+4      	; 0x2170 <__divmodhi4+0xa>
    216c:	00 94       	com	r0
    216e:	06 d0       	rcall	.+12     	; 0x217c <__divmodhi4_neg1>
    2170:	77 fd       	sbrc	r23, 7
    2172:	08 d0       	rcall	.+16     	; 0x2184 <__divmodhi4_neg2>
    2174:	0b d0       	rcall	.+22     	; 0x218c <__udivmodhi4>
    2176:	07 fc       	sbrc	r0, 7
    2178:	05 d0       	rcall	.+10     	; 0x2184 <__divmodhi4_neg2>
    217a:	3e f4       	brtc	.+14     	; 0x218a <__divmodhi4_exit>

0000217c <__divmodhi4_neg1>:
    217c:	90 95       	com	r25
    217e:	81 95       	neg	r24
    2180:	9f 4f       	sbci	r25, 0xFF	; 255
    2182:	08 95       	ret

00002184 <__divmodhi4_neg2>:
    2184:	70 95       	com	r23
    2186:	61 95       	neg	r22
    2188:	7f 4f       	sbci	r23, 0xFF	; 255

0000218a <__divmodhi4_exit>:
    218a:	08 95       	ret

0000218c <__udivmodhi4>:
    218c:	aa 1b       	sub	r26, r26
    218e:	bb 1b       	sub	r27, r27
    2190:	51 e1       	ldi	r21, 0x11	; 17
    2192:	07 c0       	rjmp	.+14     	; 0x21a2 <__udivmodhi4_ep>

00002194 <__udivmodhi4_loop>:
    2194:	aa 1f       	adc	r26, r26
    2196:	bb 1f       	adc	r27, r27
    2198:	a6 17       	cp	r26, r22
    219a:	b7 07       	cpc	r27, r23
    219c:	10 f0       	brcs	.+4      	; 0x21a2 <__udivmodhi4_ep>
    219e:	a6 1b       	sub	r26, r22
    21a0:	b7 0b       	sbc	r27, r23

000021a2 <__udivmodhi4_ep>:
    21a2:	88 1f       	adc	r24, r24
    21a4:	99 1f       	adc	r25, r25
    21a6:	5a 95       	dec	r21
    21a8:	a9 f7       	brne	.-22     	; 0x2194 <__udivmodhi4_loop>
    21aa:	80 95       	com	r24
    21ac:	90 95       	com	r25
    21ae:	bc 01       	movw	r22, r24
    21b0:	cd 01       	movw	r24, r26
    21b2:	08 95       	ret

000021b4 <memcpy>:
    21b4:	fb 01       	movw	r30, r22
    21b6:	dc 01       	movw	r26, r24
    21b8:	02 c0       	rjmp	.+4      	; 0x21be <memcpy+0xa>
    21ba:	01 90       	ld	r0, Z+
    21bc:	0d 92       	st	X+, r0
    21be:	41 50       	subi	r20, 0x01	; 1
    21c0:	50 40       	sbci	r21, 0x00	; 0
    21c2:	d8 f7       	brcc	.-10     	; 0x21ba <memcpy+0x6>
    21c4:	08 95       	ret

000021c6 <__itoa_ncheck>:
    21c6:	bb 27       	eor	r27, r27
    21c8:	4a 30       	cpi	r20, 0x0A	; 10
    21ca:	31 f4       	brne	.+12     	; 0x21d8 <__itoa_ncheck+0x12>
    21cc:	99 23       	and	r25, r25
    21ce:	22 f4       	brpl	.+8      	; 0x21d8 <__itoa_ncheck+0x12>
    21d0:	bd e2       	ldi	r27, 0x2D	; 45
    21d2:	90 95       	com	r25
    21d4:	81 95       	neg	r24
    21d6:	9f 4f       	sbci	r25, 0xFF	; 255
    21d8:	01 c0       	rjmp	.+2      	; 0x21dc <__utoa_common>

000021da <__utoa_ncheck>:
    21da:	bb 27       	eor	r27, r27

000021dc <__utoa_common>:
    21dc:	fb 01       	movw	r30, r22
    21de:	55 27       	eor	r21, r21
    21e0:	aa 27       	eor	r26, r26
    21e2:	88 0f       	add	r24, r24
    21e4:	99 1f       	adc	r25, r25
    21e6:	aa 1f       	adc	r26, r26
    21e8:	a4 17       	cp	r26, r20
    21ea:	10 f0       	brcs	.+4      	; 0x21f0 <__utoa_common+0x14>
    21ec:	a4 1b       	sub	r26, r20
    21ee:	83 95       	inc	r24
    21f0:	50 51       	subi	r21, 0x10	; 16
    21f2:	b9 f7       	brne	.-18     	; 0x21e2 <__utoa_common+0x6>
    21f4:	a0 5d       	subi	r26, 0xD0	; 208
    21f6:	aa 33       	cpi	r26, 0x3A	; 58
    21f8:	08 f0       	brcs	.+2      	; 0x21fc <__utoa_common+0x20>
    21fa:	a9 5d       	subi	r26, 0xD9	; 217
    21fc:	a1 93       	st	Z+, r26
    21fe:	00 97       	sbiw	r24, 0x00	; 0
    2200:	79 f7       	brne	.-34     	; 0x21e0 <__utoa_common+0x4>
    2202:	b1 11       	cpse	r27, r1
    2204:	b1 93       	st	Z+, r27
    2206:	11 92       	st	Z+, r1
    2208:	cb 01       	movw	r24, r22
    220a:	00 c0       	rjmp	.+0      	; 0x220c <strrev>

0000220c <strrev>:
    220c:	dc 01       	movw	r26, r24
    220e:	fc 01       	movw	r30, r24
    2210:	67 2f       	mov	r22, r23
    2212:	71 91       	ld	r23, Z+
    2214:	77 23       	and	r23, r23
    2216:	e1 f7       	brne	.-8      	; 0x2210 <strrev+0x4>
    2218:	32 97       	sbiw	r30, 0x02	; 2
    221a:	04 c0       	rjmp	.+8      	; 0x2224 <strrev+0x18>
    221c:	7c 91       	ld	r23, X
    221e:	6d 93       	st	X+, r22
    2220:	70 83       	st	Z, r23
    2222:	62 91       	ld	r22, -Z
    2224:	ae 17       	cp	r26, r30
    2226:	bf 07       	cpc	r27, r31
    2228:	c8 f3       	brcs	.-14     	; 0x221c <strrev+0x10>
    222a:	08 95       	ret

0000222c <_exit>:
    222c:	f8 94       	cli

0000222e <__stop_program>:
    222e:	ff cf       	rjmp	.-2      	; 0x222e <__stop_program>
