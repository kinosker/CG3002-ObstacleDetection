
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002f62  00002ff6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070b  00800238  00800238  0000302e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000302e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  0000305e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005fc6  00000000  00000000  000035ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001664  00000000  00000000  00009594  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003967  00000000  00000000  0000abf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000fa4  00000000  00000000  0000e560  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017d3  00000000  00000000  0000f504  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000044ea  00000000  00000000  00010cd7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  000151c1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	e3 c3       	rjmp	.+1990   	; 0x7ec <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 57 0b 	jmp	0x16ae	; 0x16ae <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	f1 c7       	rjmp	.+4066   	; 0x1048 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 9c 08 	jmp	0x1138	; 0x1138 <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	be c4       	rjmp	.+2428   	; 0x9f2 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	a3 c7       	rjmp	.+3910   	; 0xfd8 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 5c 08 	jmp	0x10b8	; 0x10b8 <__vector_37>
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_Stabilizer+0x8>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e2 e6       	ldi	r30, 0x62	; 98
     17e:	ff e2       	ldi	r31, 0x2F	; 47
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a3 34       	cpi	r26, 0x43	; 67
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	e8 d0       	rcall	.+464    	; 0x372 <main>
     1a2:	0c 94 af 17 	jmp	0x2f5e	; 0x2f5e <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 8e 09 	call	0x131c	; 0x131c <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 ce 09 	call	0x139c	; 0x139c <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 c3 09 	call	0x1386	; 0x1386 <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 38 02 	lds	r24, 0x0238
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 51 09 	call	0x12a2	; 0x12a2 <myUSART_transmitUSART1_c>
     1e2:	d0 93 38 02 	sts	0x0238, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 da 09 	call	0x13b4	; 0x13b4 <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 38 02 	sts	0x0238, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 38 02 	sts	0x0238, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 38 02 	sts	0x0238, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	cd b7       	in	r28, 0x3d	; 61
     218:	de b7       	in	r29, 0x3e	; 62
     21a:	0e 94 af 09 	call	0x135e	; 0x135e <myUSART_startHandShake>
     21e:	18 2f       	mov	r17, r24
     220:	20 e0       	ldi	r18, 0x00	; 0
     222:	4f ef       	ldi	r20, 0xFF	; 255
     224:	5f ef       	ldi	r21, 0xFF	; 255
     226:	be 01       	movw	r22, r28
     228:	6d 5f       	subi	r22, 0xFD	; 253
     22a:	7f 4f       	sbci	r23, 0xFF	; 255
     22c:	80 91 91 08 	lds	r24, 0x0891
     230:	90 91 92 08 	lds	r25, 0x0892
     234:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <xQueueGenericReceive>
     238:	11 23       	and	r17, r17
     23a:	a1 f1       	breq	.+104    	; 0x2a4 <RPI_sendTask+0x94>
     23c:	8b 81       	ldd	r24, Y+3	; 0x03
     23e:	80 5d       	subi	r24, 0xD0	; 208
     240:	0e 94 51 09 	call	0x12a2	; 0x12a2 <myUSART_transmitUSART1_c>
     244:	8a e0       	ldi	r24, 0x0A	; 10
     246:	0e 94 51 09 	call	0x12a2	; 0x12a2 <myUSART_transmitUSART1_c>
     24a:	2c c0       	rjmp	.+88     	; 0x2a4 <RPI_sendTask+0x94>
     24c:	20 e0       	ldi	r18, 0x00	; 0
     24e:	4f ef       	ldi	r20, 0xFF	; 255
     250:	5f ef       	ldi	r21, 0xFF	; 255
     252:	be 01       	movw	r22, r28
     254:	6f 5f       	subi	r22, 0xFF	; 255
     256:	7f 4f       	sbci	r23, 0xFF	; 255
     258:	80 91 93 08 	lds	r24, 0x0893
     25c:	90 91 94 08 	lds	r25, 0x0894
     260:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <xQueueGenericReceive>
     264:	e9 81       	ldd	r30, Y+1	; 0x01
     266:	fa 81       	ldd	r31, Y+2	; 0x02
     268:	80 81       	ld	r24, Z
     26a:	fa d7       	rcall	.+4084   	; 0x1260 <myUSART_transmitUSART0_c>
     26c:	87 e0       	ldi	r24, 0x07	; 7
     26e:	92 e0       	ldi	r25, 0x02	; 2
     270:	0e 94 80 09 	call	0x1300	; 0x1300 <myUSART_transmitUSART0>
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	9a 81       	ldd	r25, Y+2	; 0x02
     278:	01 96       	adiw	r24, 0x01	; 1
     27a:	0e 94 80 09 	call	0x1300	; 0x1300 <myUSART_transmitUSART0>
     27e:	8a e0       	ldi	r24, 0x0A	; 10
     280:	92 e0       	ldi	r25, 0x02	; 2
     282:	0e 94 80 09 	call	0x1300	; 0x1300 <myUSART_transmitUSART0>
     286:	11 23       	and	r17, r17
     288:	69 f0       	breq	.+26     	; 0x2a4 <RPI_sendTask+0x94>
     28a:	e9 81       	ldd	r30, Y+1	; 0x01
     28c:	fa 81       	ldd	r31, Y+2	; 0x02
     28e:	80 81       	ld	r24, Z
     290:	0e 94 51 09 	call	0x12a2	; 0x12a2 <myUSART_transmitUSART1_c>
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	9a 81       	ldd	r25, Y+2	; 0x02
     298:	01 96       	adiw	r24, 0x01	; 1
     29a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <myUSART_transmitUSART1>
     29e:	8a e0       	ldi	r24, 0x0A	; 10
     2a0:	0e 94 51 09 	call	0x12a2	; 0x12a2 <myUSART_transmitUSART1_c>
     2a4:	9b 81       	ldd	r25, Y+3	; 0x03
     2a6:	2f ef       	ldi	r18, 0xFF	; 255
     2a8:	29 0f       	add	r18, r25
     2aa:	2b 83       	std	Y+3, r18	; 0x03
     2ac:	91 11       	cpse	r25, r1
     2ae:	ce cf       	rjmp	.-100    	; 0x24c <RPI_sendTask+0x3c>
     2b0:	8a e0       	ldi	r24, 0x0A	; 10
     2b2:	d6 d7       	rcall	.+4012   	; 0x1260 <myUSART_transmitUSART0_c>
     2b4:	b2 cf       	rjmp	.-156    	; 0x21a <RPI_sendTask+0xa>

000002b6 <myTimerTask>:
     2b6:	bd d5       	rcall	.+2938   	; 0xe32 <myTimer_Init>
     2b8:	20 d6       	rcall	.+3136   	; 0xefa <myTimer_DelayChecker>
     2ba:	fe cf       	rjmp	.-4      	; 0x2b8 <myTimerTask+0x2>

000002bc <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2bc:	8f ef       	ldi	r24, 0xFF	; 255
     2be:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2c2:	ef e7       	ldi	r30, 0x7F	; 127
     2c4:	f0 e0       	ldi	r31, 0x00	; 0
     2c6:	90 81       	ld	r25, Z
     2c8:	93 60       	ori	r25, 0x03	; 3
     2ca:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2cc:	80 93 7d 00 	sts	0x007D, r24
     2d0:	08 95       	ret

000002d2 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2d2:	8c ec       	ldi	r24, 0xCC	; 204
     2d4:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2d8:	8e e3       	ldi	r24, 0x3E	; 62
     2da:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2de:	ee cf       	rjmp	.-36     	; 0x2bc <setDigitalInputPowerReduction>
     2e0:	08 95       	ret

000002e2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2e2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2e6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2ea:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ee:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2f2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2f6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2fa:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2fe:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     302:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     306:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     30a:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     30e:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     312:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     316:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     31a:	10 92 73 00 	sts	0x0073, r1
     31e:	08 95       	ret

00000320 <init>:
}

void init()
{
     320:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     322:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     324:	f8 94       	cli
	{
		clearTimer();
     326:	dd df       	rcall	.-70     	; 0x2e2 <clearTimer>
		setPowerReduction();
     328:	d4 df       	rcall	.-88     	; 0x2d2 <setPowerReduction>
		myUSART_USART0_Init();
     32a:	46 d7       	rcall	.+3724   	; 0x11b8 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     32c:	6b d7       	rcall	.+3798   	; 0x1204 <myUSART_USART1_Init>
		myADC_Init();
     32e:	9a d3       	rcall	.+1844   	; 0xa64 <myADC_Init>
		
		MaxSonar_Init();
     330:	83 b3       	in	r24, 0x13	; 19
     332:	83 60       	ori	r24, 0x03	; 3
     334:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     336:	40 e0       	ldi	r20, 0x00	; 0
     338:	61 e0       	ldi	r22, 0x01	; 1
     33a:	83 e0       	ldi	r24, 0x03	; 3
     33c:	0e 94 56 0c 	call	0x18ac	; 0x18ac <xQueueGenericCreate>
     340:	90 93 92 08 	sts	0x0892, r25
     344:	80 93 91 08 	sts	0x0891, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     348:	40 e0       	ldi	r20, 0x00	; 0
     34a:	65 e0       	ldi	r22, 0x05	; 5
     34c:	8f e0       	ldi	r24, 0x0F	; 15
     34e:	0e 94 56 0c 	call	0x18ac	; 0x18ac <xQueueGenericCreate>
     352:	90 93 94 08 	sts	0x0894, r25
     356:	80 93 93 08 	sts	0x0893, r24
		
		MOTOR_LEFT_INIT();
     35a:	8d b1       	in	r24, 0x0d	; 13
     35c:	88 61       	ori	r24, 0x18	; 24
     35e:	8d b9       	out	0x0d, r24	; 13
		MOTOR_RIGHT_INIT();
     360:	e1 e0       	ldi	r30, 0x01	; 1
     362:	f1 e0       	ldi	r31, 0x01	; 1
     364:	80 81       	ld	r24, Z
     366:	80 61       	ori	r24, 0x10	; 16
     368:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     36a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     36c:	78 94       	sei
}
     36e:	cf 91       	pop	r28
     370:	08 95       	ret

00000372 <main>:
	
	// do nth
}

int main(void)
{
     372:	cf 93       	push	r28
     374:	df 93       	push	r29
     376:	cd b7       	in	r28, 0x3d	; 61
     378:	de b7       	in	r29, 0x3e	; 62
     37a:	28 97       	sbiw	r28, 0x08	; 8
     37c:	0f b6       	in	r0, 0x3f	; 63
     37e:	f8 94       	cli
     380:	de bf       	out	0x3e, r29	; 62
     382:	0f be       	out	0x3f, r0	; 63
     384:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     386:	cc df       	rcall	.-104    	; 0x320 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     388:	a1 2c       	mov	r10, r1
     38a:	b1 2c       	mov	r11, r1
     38c:	c1 2c       	mov	r12, r1
     38e:	d1 2c       	mov	r13, r1
     390:	ce 01       	movw	r24, r28
     392:	01 96       	adiw	r24, 0x01	; 1
     394:	7c 01       	movw	r14, r24
     396:	04 e0       	ldi	r16, 0x04	; 4
     398:	9c 01       	movw	r18, r24
     39a:	49 e6       	ldi	r20, 0x69	; 105
     39c:	50 e0       	ldi	r21, 0x00	; 0
     39e:	6d e0       	ldi	r22, 0x0D	; 13
     3a0:	72 e0       	ldi	r23, 0x02	; 2
     3a2:	8b e5       	ldi	r24, 0x5B	; 91
     3a4:	91 e0       	ldi	r25, 0x01	; 1
     3a6:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     3aa:	ce 01       	movw	r24, r28
     3ac:	07 96       	adiw	r24, 0x07	; 7
     3ae:	7c 01       	movw	r14, r24
     3b0:	03 e0       	ldi	r16, 0x03	; 3
     3b2:	20 e0       	ldi	r18, 0x00	; 0
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	4d e6       	ldi	r20, 0x6D	; 109
     3b8:	51 e0       	ldi	r21, 0x01	; 1
     3ba:	65 e1       	ldi	r22, 0x15	; 21
     3bc:	72 e0       	ldi	r23, 0x02	; 2
     3be:	87 ea       	ldi	r24, 0xA7	; 167
     3c0:	92 e0       	ldi	r25, 0x02	; 2
     3c2:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3c6:	ce 01       	movw	r24, r28
     3c8:	05 96       	adiw	r24, 0x05	; 5
     3ca:	7c 01       	movw	r14, r24
     3cc:	01 e0       	ldi	r16, 0x01	; 1
     3ce:	20 e0       	ldi	r18, 0x00	; 0
     3d0:	30 e0       	ldi	r19, 0x00	; 0
     3d2:	47 e8       	ldi	r20, 0x87	; 135
     3d4:	50 e0       	ldi	r21, 0x00	; 0
     3d6:	6e e1       	ldi	r22, 0x1E	; 30
     3d8:	72 e0       	ldi	r23, 0x02	; 2
     3da:	84 ed       	ldi	r24, 0xD4	; 212
     3dc:	90 e0       	ldi	r25, 0x00	; 0
     3de:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3e2:	ce 01       	movw	r24, r28
     3e4:	03 96       	adiw	r24, 0x03	; 3
     3e6:	7c 01       	movw	r14, r24
     3e8:	02 e0       	ldi	r16, 0x02	; 2
     3ea:	20 e0       	ldi	r18, 0x00	; 0
     3ec:	30 e0       	ldi	r19, 0x00	; 0
     3ee:	47 e8       	ldi	r20, 0x87	; 135
     3f0:	50 e0       	ldi	r21, 0x00	; 0
     3f2:	6a e2       	ldi	r22, 0x2A	; 42
     3f4:	72 e0       	ldi	r23, 0x02	; 2
     3f6:	88 e0       	ldi	r24, 0x08	; 8
     3f8:	91 e0       	ldi	r25, 0x01	; 1
     3fa:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3fe:	0e 94 23 10 	call	0x2046	; 0x2046 <vTaskStartScheduler>
     402:	c1 cf       	rjmp	.-126    	; 0x386 <main+0x14>

00000404 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     404:	9c 01       	movw	r18, r24
     406:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     408:	64 e6       	ldi	r22, 0x64	; 100
     40a:	70 e0       	ldi	r23, 0x00	; 0
     40c:	0e 94 7f 17 	call	0x2efe	; 0x2efe <__divmodhi4>
	
	if(input)
     410:	61 15       	cp	r22, r1
     412:	71 05       	cpc	r23, r1
     414:	21 f0       	breq	.+8      	; 0x41e <myItoa+0x1a>
		*buffer++ = input + '0';
     416:	80 e3       	ldi	r24, 0x30	; 48
     418:	86 0f       	add	r24, r22
     41a:	80 83       	st	Z, r24
     41c:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     41e:	4c e9       	ldi	r20, 0x9C	; 156
     420:	46 03       	mulsu	r20, r22
     422:	c0 01       	movw	r24, r0
     424:	47 9f       	mul	r20, r23
     426:	90 0d       	add	r25, r0
     428:	11 24       	eor	r1, r1
     42a:	28 0f       	add	r18, r24
     42c:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     42e:	c9 01       	movw	r24, r18
     430:	6a e0       	ldi	r22, 0x0A	; 10
     432:	70 e0       	ldi	r23, 0x00	; 0
     434:	0e 94 7f 17 	call	0x2efe	; 0x2efe <__divmodhi4>
	*buffer++ = input + '0';
     438:	80 e3       	ldi	r24, 0x30	; 48
     43a:	86 0f       	add	r24, r22
     43c:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     43e:	8a e0       	ldi	r24, 0x0A	; 10
     440:	68 9f       	mul	r22, r24
     442:	20 19       	sub	r18, r0
     444:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     446:	20 5d       	subi	r18, 0xD0	; 208
     448:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     44a:	12 82       	std	Z+2, r1	; 0x02
     44c:	08 95       	ret

0000044e <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading, obstacleStruct * obstacleInfo_ptr)
{
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	cd b7       	in	r28, 0x3d	; 61
     456:	de b7       	in	r29, 0x3e	; 62
     458:	27 97       	sbiw	r28, 0x07	; 7
     45a:	0f b6       	in	r0, 0x3f	; 63
     45c:	f8 94       	cli
     45e:	de bf       	out	0x3e, r29	; 62
     460:	0f be       	out	0x3f, r0	; 63
     462:	cd bf       	out	0x3d, r28	; 61
     464:	18 2f       	mov	r17, r24
     466:	cb 01       	movw	r24, r22
     468:	5f 83       	std	Y+7, r21	; 0x07
     46a:	4e 83       	std	Y+6, r20	; 0x06
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     46c:	11 23       	and	r17, r17
     46e:	a9 f0       	breq	.+42     	; 0x49a <obstacleSend+0x4c>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     470:	be 01       	movw	r22, r28
     472:	6e 5f       	subi	r22, 0xFE	; 254
     474:	7f 4f       	sbci	r23, 0xFF	; 255
     476:	c6 df       	rcall	.-116    	; 0x404 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     478:	19 83       	std	Y+1, r17	; 0x01
		
		obstacleInfo_ptr = &obstacleInfo;
     47a:	ce 01       	movw	r24, r28
     47c:	01 96       	adiw	r24, 0x01	; 1
     47e:	9f 83       	std	Y+7, r25	; 0x07
     480:	8e 83       	std	Y+6, r24	; 0x06
		
		xQueueSendToBack(queueObstacleData, (void*) &obstacleInfo_ptr, portMAX_DELAY); // send data to queueData
     482:	20 e0       	ldi	r18, 0x00	; 0
     484:	4f ef       	ldi	r20, 0xFF	; 255
     486:	5f ef       	ldi	r21, 0xFF	; 255
     488:	be 01       	movw	r22, r28
     48a:	6a 5f       	subi	r22, 0xFA	; 250
     48c:	7f 4f       	sbci	r23, 0xFF	; 255
     48e:	80 91 93 08 	lds	r24, 0x0893
     492:	90 91 94 08 	lds	r25, 0x0894
     496:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericSend>
	}
}
     49a:	27 96       	adiw	r28, 0x07	; 7
     49c:	0f b6       	in	r0, 0x3f	; 63
     49e:	f8 94       	cli
     4a0:	de bf       	out	0x3e, r29	; 62
     4a2:	0f be       	out	0x3f, r0	; 63
     4a4:	cd bf       	out	0x3d, r28	; 61
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	1f 91       	pop	r17
     4ac:	08 95       	ret

000004ae <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(obstacleStruct * obstacleInfo_ptr ,char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{	
     4ae:	4f 92       	push	r4
     4b0:	5f 92       	push	r5
     4b2:	6f 92       	push	r6
     4b4:	7f 92       	push	r7
     4b6:	8f 92       	push	r8
     4b8:	9f 92       	push	r9
     4ba:	af 92       	push	r10
     4bc:	bf 92       	push	r11
     4be:	cf 92       	push	r12
     4c0:	df 92       	push	r13
     4c2:	ef 92       	push	r14
     4c4:	ff 92       	push	r15
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	1f 92       	push	r1
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
     4d4:	3c 01       	movw	r6, r24
     4d6:	69 83       	std	Y+1, r22	; 0x01
     4d8:	4a 01       	movw	r8, r20
     4da:	29 01       	movw	r4, r18
	if(obstacleDetected > 0)
     4dc:	66 23       	and	r22, r22
     4de:	29 f1       	breq	.+74     	; 0x52a <sendObstacleDetected+0x7c>
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4e0:	20 e0       	ldi	r18, 0x00	; 0
     4e2:	4f ef       	ldi	r20, 0xFF	; 255
     4e4:	5f ef       	ldi	r21, 0xFF	; 255
     4e6:	be 01       	movw	r22, r28
     4e8:	6f 5f       	subi	r22, 0xFF	; 255
     4ea:	7f 4f       	sbci	r23, 0xFF	; 255
     4ec:	80 91 91 08 	lds	r24, 0x0891
     4f0:	90 91 92 08 	lds	r25, 0x0892
     4f4:	0e 94 83 0c 	call	0x1906	; 0x1906 <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar, obstacleInfo_ptr);
     4f8:	a3 01       	movw	r20, r6
     4fa:	b2 01       	movw	r22, r4
     4fc:	f4 01       	movw	r30, r8
     4fe:	80 81       	ld	r24, Z
     500:	a6 df       	rcall	.-180    	; 0x44e <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar, obstacleInfo_ptr);
     502:	a3 01       	movw	r20, r6
     504:	b8 01       	movw	r22, r16
     506:	f4 01       	movw	r30, r8
     508:	81 81       	ldd	r24, Z+1	; 0x01
     50a:	a1 df       	rcall	.-190    	; 0x44e <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar, obstacleInfo_ptr);
     50c:	a3 01       	movw	r20, r6
     50e:	b7 01       	movw	r22, r14
     510:	f4 01       	movw	r30, r8
     512:	82 81       	ldd	r24, Z+2	; 0x02
     514:	9c df       	rcall	.-200    	; 0x44e <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR, obstacleInfo_ptr);
     516:	a3 01       	movw	r20, r6
     518:	b6 01       	movw	r22, r12
     51a:	f4 01       	movw	r30, r8
     51c:	83 81       	ldd	r24, Z+3	; 0x03
     51e:	97 df       	rcall	.-210    	; 0x44e <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar, obstacleInfo_ptr);
     520:	a3 01       	movw	r20, r6
     522:	b5 01       	movw	r22, r10
     524:	f4 01       	movw	r30, r8
     526:	84 81       	ldd	r24, Z+4	; 0x04
     528:	92 df       	rcall	.-220    	; 0x44e <obstacleSend>
		
	}
}
     52a:	0f 90       	pop	r0
     52c:	df 91       	pop	r29
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	ff 90       	pop	r15
     536:	ef 90       	pop	r14
     538:	df 90       	pop	r13
     53a:	cf 90       	pop	r12
     53c:	bf 90       	pop	r11
     53e:	af 90       	pop	r10
     540:	9f 90       	pop	r9
     542:	8f 90       	pop	r8
     544:	7f 90       	pop	r7
     546:	6f 90       	pop	r6
     548:	5f 90       	pop	r5
     54a:	4f 90       	pop	r4
     54c:	08 95       	ret

0000054e <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     54e:	cf 93       	push	r28
     550:	df 93       	push	r29
     552:	cd b7       	in	r28, 0x3d	; 61
     554:	de b7       	in	r29, 0x3e	; 62
     556:	a4 97       	sbiw	r28, 0x24	; 36
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	0f be       	out	0x3f, r0	; 63
     560:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     562:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     564:	86 e0       	ldi	r24, 0x06	; 6
     566:	fe 01       	movw	r30, r28
     568:	34 96       	adiw	r30, 0x04	; 4
     56a:	df 01       	movw	r26, r30
     56c:	98 2f       	mov	r25, r24
     56e:	1d 92       	st	X+, r1
     570:	9a 95       	dec	r25
     572:	e9 f7       	brne	.-6      	; 0x56e <Sonar_Task+0x20>
     574:	36 96       	adiw	r30, 0x06	; 6
     576:	df 01       	movw	r26, r30
     578:	98 2f       	mov	r25, r24
     57a:	1d 92       	st	X+, r1
     57c:	9a 95       	dec	r25
     57e:	e9 f7       	brne	.-6      	; 0x57a <Sonar_Task+0x2c>
     580:	36 96       	adiw	r30, 0x06	; 6
     582:	df 01       	movw	r26, r30
     584:	98 2f       	mov	r25, r24
     586:	1d 92       	st	X+, r1
     588:	9a 95       	dec	r25
     58a:	e9 f7       	brne	.-6      	; 0x586 <Sonar_Task+0x38>
     58c:	36 96       	adiw	r30, 0x06	; 6
     58e:	df 01       	movw	r26, r30
     590:	1d 92       	st	X+, r1
     592:	8a 95       	dec	r24
     594:	e9 f7       	brne	.-6      	; 0x590 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     596:	36 96       	adiw	r30, 0x06	; 6
     598:	85 e0       	ldi	r24, 0x05	; 5
     59a:	df 01       	movw	r26, r30
     59c:	1d 92       	st	X+, r1
     59e:	8a 95       	dec	r24
     5a0:	e9 f7       	brne	.-6      	; 0x59c <Sonar_Task+0x4e>
	obstacleStruct *obstacleInfo_ptr = NULL;

	
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     5a2:	84 e2       	ldi	r24, 0x24	; 36
     5a4:	a8 d3       	rcall	.+1872   	; 0xcf6 <mySharpIR_Read>
     5a6:	9a a3       	std	Y+34, r25	; 0x22
     5a8:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     5aa:	0e 94 52 10 	call	0x20a4	; 0x20a4 <xTaskGetTickCount>
     5ae:	9a 83       	std	Y+2, r25	; 0x02
     5b0:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     5b2:	a7 d1       	rcall	.+846    	; 0x902 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     5b4:	87 e2       	ldi	r24, 0x27	; 39
     5b6:	0b d2       	rcall	.+1046   	; 0x9ce <myMaxSonar_Read>
     5b8:	be 01       	movw	r22, r28
     5ba:	66 5f       	subi	r22, 0xF6	; 246
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	fe d1       	rcall	.+1020   	; 0x9bc <myMaxSonar_getFilteredReading>
     5c0:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     5c2:	86 e2       	ldi	r24, 0x26	; 38
     5c4:	04 d2       	rcall	.+1032   	; 0x9ce <myMaxSonar_Read>
     5c6:	be 01       	movw	r22, r28
     5c8:	60 5f       	subi	r22, 0xF0	; 240
     5ca:	7f 4f       	sbci	r23, 0xFF	; 255
     5cc:	f7 d1       	rcall	.+1006   	; 0x9bc <myMaxSonar_getFilteredReading>
     5ce:	9c a3       	std	Y+36, r25	; 0x24
     5d0:	8b a3       	std	Y+35, r24	; 0x23
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     5d2:	85 e2       	ldi	r24, 0x25	; 37
     5d4:	fc d1       	rcall	.+1016   	; 0x9ce <myMaxSonar_Read>
     5d6:	be 01       	movw	r22, r28
     5d8:	6a 5e       	subi	r22, 0xEA	; 234
     5da:	7f 4f       	sbci	r23, 0xFF	; 255
     5dc:	ef d1       	rcall	.+990    	; 0x9bc <myMaxSonar_getFilteredReading>
     5de:	1c 01       	movw	r2, r24
		
		myMaxSonar_TopStart();
     5e0:	96 d1       	rcall	.+812    	; 0x90e <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5e2:	83 e2       	ldi	r24, 0x23	; 35
     5e4:	f4 d1       	rcall	.+1000   	; 0x9ce <myMaxSonar_Read>
     5e6:	be 01       	movw	r22, r28
     5e8:	6c 5f       	subi	r22, 0xFC	; 252
     5ea:	7f 4f       	sbci	r23, 0xFF	; 255
     5ec:	e7 d1       	rcall	.+974    	; 0x9bc <myMaxSonar_getFilteredReading>
     5ee:	2c 01       	movw	r4, r24
			
			
		btmIR	= mySharpIR_Read(AN12);
     5f0:	84 e2       	ldi	r24, 0x24	; 36
     5f2:	81 d3       	rcall	.+1794   	; 0xcf6 <mySharpIR_Read>
     5f4:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5f6:	bc 01       	movw	r22, r24
     5f8:	ce 01       	movw	r24, r28
     5fa:	81 96       	adiw	r24, 0x21	; 33
     5fc:	b5 d3       	rcall	.+1898   	; 0xd68 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5fe:	c9 a0       	ldd	r12, Y+33	; 0x21
     600:	da a0       	ldd	r13, Y+34	; 0x22
     602:	54 01       	movw	r10, r8
     604:	72 01       	movw	r14, r4
     606:	81 01       	movw	r16, r2
     608:	2b a1       	ldd	r18, Y+35	; 0x23
     60a:	3c a1       	ldd	r19, Y+36	; 0x24
     60c:	ae 01       	movw	r20, r28
     60e:	44 5e       	subi	r20, 0xE4	; 228
     610:	5f 4f       	sbci	r21, 0xFF	; 255
     612:	6b 81       	ldd	r22, Y+3	; 0x03
     614:	c3 01       	movw	r24, r6
     616:	35 d3       	rcall	.+1642   	; 0xc82 <obstacleDetection>
     618:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     61a:	ce 01       	movw	r24, r28
     61c:	4c 96       	adiw	r24, 0x1c	; 28
     61e:	7c 01       	movw	r14, r24
     620:	84 01       	movw	r16, r8
     622:	91 01       	movw	r18, r2
     624:	4b a1       	ldd	r20, Y+35	; 0x23
     626:	5c a1       	ldd	r21, Y+36	; 0x24
     628:	b2 01       	movw	r22, r4
     62a:	c3 01       	movw	r24, r6
     62c:	b8 d2       	rcall	.+1392   	; 0xb9e <obstacleAvoidance>
		
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     62e:	be 01       	movw	r22, r28
     630:	6d 5f       	subi	r22, 0xFD	; 253
     632:	7f 4f       	sbci	r23, 0xFF	; 255
     634:	c7 01       	movw	r24, r14
     636:	98 d2       	rcall	.+1328   	; 0xb68 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleInfo_ptr, obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     638:	52 01       	movw	r10, r4
     63a:	64 01       	movw	r12, r8
     63c:	71 01       	movw	r14, r2
     63e:	0b a1       	ldd	r16, Y+35	; 0x23
     640:	1c a1       	ldd	r17, Y+36	; 0x24
     642:	93 01       	movw	r18, r6
     644:	ae 01       	movw	r20, r28
     646:	44 5e       	subi	r20, 0xE4	; 228
     648:	5f 4f       	sbci	r21, 0xFF	; 255
     64a:	6b 81       	ldd	r22, Y+3	; 0x03
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	2e df       	rcall	.-420    	; 0x4ae <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     652:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     654:	18 a2       	std	Y+32, r1	; 0x20
     656:	1f 8e       	std	Y+31, r1	; 0x1f
     658:	1e 8e       	std	Y+30, r1	; 0x1e
     65a:	1d 8e       	std	Y+29, r1	; 0x1d
     65c:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     65e:	66 e9       	ldi	r22, 0x96	; 150
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	ce 01       	movw	r24, r28
     664:	01 96       	adiw	r24, 0x01	; 1
     666:	0e 94 a0 11 	call	0x2340	; 0x2340 <vTaskDelayUntil>
     66a:	a3 cf       	rjmp	.-186    	; 0x5b2 <Sonar_Task+0x64>

0000066c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
     670:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     672:	0e 94 4c 10 	call	0x2098	; 0x2098 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     676:	80 91 39 02 	lds	r24, 0x0239
     67a:	90 91 3a 02 	lds	r25, 0x023A
     67e:	89 2b       	or	r24, r25
     680:	31 f4       	brne	.+12     	; 0x68e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     682:	8e e3       	ldi	r24, 0x3E	; 62
     684:	92 e0       	ldi	r25, 0x02	; 2
     686:	90 93 3a 02 	sts	0x023A, r25
     68a:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     68e:	40 91 3b 02 	lds	r20, 0x023B
     692:	50 91 3c 02 	lds	r21, 0x023C
     696:	9e 01       	movw	r18, r28
     698:	24 0f       	add	r18, r20
     69a:	35 1f       	adc	r19, r21
     69c:	2b 3d       	cpi	r18, 0xDB	; 219
     69e:	85 e0       	ldi	r24, 0x05	; 5
     6a0:	38 07       	cpc	r19, r24
     6a2:	70 f4       	brcc	.+28     	; 0x6c0 <pvPortMalloc+0x54>
     6a4:	42 17       	cp	r20, r18
     6a6:	53 07       	cpc	r21, r19
     6a8:	70 f4       	brcc	.+28     	; 0x6c6 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     6aa:	c0 91 39 02 	lds	r28, 0x0239
     6ae:	d0 91 3a 02 	lds	r29, 0x023A
     6b2:	c4 0f       	add	r28, r20
     6b4:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     6b6:	30 93 3c 02 	sts	0x023C, r19
     6ba:	20 93 3b 02 	sts	0x023B, r18
     6be:	05 c0       	rjmp	.+10     	; 0x6ca <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6c0:	c0 e0       	ldi	r28, 0x00	; 0
     6c2:	d0 e0       	ldi	r29, 0x00	; 0
     6c4:	02 c0       	rjmp	.+4      	; 0x6ca <pvPortMalloc+0x5e>
     6c6:	c0 e0       	ldi	r28, 0x00	; 0
     6c8:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6ca:	0e 94 1f 11 	call	0x223e	; 0x223e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6ce:	ce 01       	movw	r24, r28
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	08 95       	ret

000006d6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6d6:	08 95       	ret

000006d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6d8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6da:	03 96       	adiw	r24, 0x03	; 3
     6dc:	92 83       	std	Z+2, r25	; 0x02
     6de:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6e0:	2f ef       	ldi	r18, 0xFF	; 255
     6e2:	3f ef       	ldi	r19, 0xFF	; 255
     6e4:	34 83       	std	Z+4, r19	; 0x04
     6e6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e8:	96 83       	std	Z+6, r25	; 0x06
     6ea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ec:	90 87       	std	Z+8, r25	; 0x08
     6ee:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6f0:	10 82       	st	Z, r1
     6f2:	08 95       	ret

000006f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6f4:	fc 01       	movw	r30, r24
     6f6:	11 86       	std	Z+9, r1	; 0x09
     6f8:	10 86       	std	Z+8, r1	; 0x08
     6fa:	08 95       	ret

000006fc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6fc:	cf 93       	push	r28
     6fe:	df 93       	push	r29
     700:	9c 01       	movw	r18, r24
     702:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     704:	dc 01       	movw	r26, r24
     706:	11 96       	adiw	r26, 0x01	; 1
     708:	cd 91       	ld	r28, X+
     70a:	dc 91       	ld	r29, X
     70c:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     70e:	d3 83       	std	Z+3, r29	; 0x03
     710:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     712:	8c 81       	ldd	r24, Y+4	; 0x04
     714:	9d 81       	ldd	r25, Y+5	; 0x05
     716:	95 83       	std	Z+5, r25	; 0x05
     718:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     71a:	8c 81       	ldd	r24, Y+4	; 0x04
     71c:	9d 81       	ldd	r25, Y+5	; 0x05
     71e:	dc 01       	movw	r26, r24
     720:	13 96       	adiw	r26, 0x03	; 3
     722:	7c 93       	st	X, r23
     724:	6e 93       	st	-X, r22
     726:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     728:	7d 83       	std	Y+5, r23	; 0x05
     72a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     72c:	31 87       	std	Z+9, r19	; 0x09
     72e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     730:	f9 01       	movw	r30, r18
     732:	80 81       	ld	r24, Z
     734:	8f 5f       	subi	r24, 0xFF	; 255
     736:	80 83       	st	Z, r24
}
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	08 95       	ret

0000073e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     73e:	cf 93       	push	r28
     740:	df 93       	push	r29
     742:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     744:	48 81       	ld	r20, Y
     746:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     748:	4f 3f       	cpi	r20, 0xFF	; 255
     74a:	2f ef       	ldi	r18, 0xFF	; 255
     74c:	52 07       	cpc	r21, r18
     74e:	21 f4       	brne	.+8      	; 0x758 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     750:	fc 01       	movw	r30, r24
     752:	a7 81       	ldd	r26, Z+7	; 0x07
     754:	b0 85       	ldd	r27, Z+8	; 0x08
     756:	0d c0       	rjmp	.+26     	; 0x772 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     758:	dc 01       	movw	r26, r24
     75a:	13 96       	adiw	r26, 0x03	; 3
     75c:	12 96       	adiw	r26, 0x02	; 2
     75e:	ed 91       	ld	r30, X+
     760:	fc 91       	ld	r31, X
     762:	13 97       	sbiw	r26, 0x03	; 3
     764:	20 81       	ld	r18, Z
     766:	31 81       	ldd	r19, Z+1	; 0x01
     768:	42 17       	cp	r20, r18
     76a:	53 07       	cpc	r21, r19
     76c:	10 f0       	brcs	.+4      	; 0x772 <vListInsert+0x34>
     76e:	df 01       	movw	r26, r30
     770:	f5 cf       	rjmp	.-22     	; 0x75c <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     772:	12 96       	adiw	r26, 0x02	; 2
     774:	ed 91       	ld	r30, X+
     776:	fc 91       	ld	r31, X
     778:	13 97       	sbiw	r26, 0x03	; 3
     77a:	fb 83       	std	Y+3, r31	; 0x03
     77c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     77e:	d5 83       	std	Z+5, r29	; 0x05
     780:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     782:	bd 83       	std	Y+5, r27	; 0x05
     784:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     786:	13 96       	adiw	r26, 0x03	; 3
     788:	dc 93       	st	X, r29
     78a:	ce 93       	st	-X, r28
     78c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     78e:	99 87       	std	Y+9, r25	; 0x09
     790:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     792:	fc 01       	movw	r30, r24
     794:	20 81       	ld	r18, Z
     796:	2f 5f       	subi	r18, 0xFF	; 255
     798:	20 83       	st	Z, r18
}
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	08 95       	ret

000007a0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
     7a4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     7a6:	a0 85       	ldd	r26, Z+8	; 0x08
     7a8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7aa:	c2 81       	ldd	r28, Z+2	; 0x02
     7ac:	d3 81       	ldd	r29, Z+3	; 0x03
     7ae:	84 81       	ldd	r24, Z+4	; 0x04
     7b0:	95 81       	ldd	r25, Z+5	; 0x05
     7b2:	9d 83       	std	Y+5, r25	; 0x05
     7b4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7b6:	c4 81       	ldd	r28, Z+4	; 0x04
     7b8:	d5 81       	ldd	r29, Z+5	; 0x05
     7ba:	82 81       	ldd	r24, Z+2	; 0x02
     7bc:	93 81       	ldd	r25, Z+3	; 0x03
     7be:	9b 83       	std	Y+3, r25	; 0x03
     7c0:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	cd 91       	ld	r28, X+
     7c6:	dc 91       	ld	r29, X
     7c8:	12 97       	sbiw	r26, 0x02	; 2
     7ca:	ce 17       	cp	r28, r30
     7cc:	df 07       	cpc	r29, r31
     7ce:	31 f4       	brne	.+12     	; 0x7dc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7d0:	8c 81       	ldd	r24, Y+4	; 0x04
     7d2:	9d 81       	ldd	r25, Y+5	; 0x05
     7d4:	12 96       	adiw	r26, 0x02	; 2
     7d6:	9c 93       	st	X, r25
     7d8:	8e 93       	st	-X, r24
     7da:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7dc:	11 86       	std	Z+9, r1	; 0x09
     7de:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7e0:	8c 91       	ld	r24, X
     7e2:	81 50       	subi	r24, 0x01	; 1
     7e4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret

000007ec <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7ec:	1f 92       	push	r1
     7ee:	0f 92       	push	r0
     7f0:	0f b6       	in	r0, 0x3f	; 63
     7f2:	0f 92       	push	r0
     7f4:	11 24       	eor	r1, r1
     7f6:	0b b6       	in	r0, 0x3b	; 59
     7f8:	0f 92       	push	r0
     7fa:	2f 93       	push	r18
     7fc:	3f 93       	push	r19
     7fe:	4f 93       	push	r20
     800:	5f 93       	push	r21
     802:	6f 93       	push	r22
     804:	7f 93       	push	r23
     806:	8f 93       	push	r24
     808:	9f 93       	push	r25
     80a:	af 93       	push	r26
     80c:	bf 93       	push	r27
     80e:	ef 93       	push	r30
     810:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     812:	1b 9b       	sbis	0x03, 3	; 3
     814:	0d c0       	rjmp	.+26     	; 0x830 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     816:	27 d3       	rcall	.+1614   	; 0xe66 <myTimer_Read>
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	90 93 9a 08 	sts	0x089A, r25
     81e:	80 93 99 08 	sts	0x0899, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     822:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <xTaskGetTickCountFromISR>
     826:	90 93 96 08 	sts	0x0896, r25
     82a:	80 93 95 08 	sts	0x0895, r24
     82e:	56 c0       	rjmp	.+172    	; 0x8dc <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     830:	1b 99       	sbic	0x03, 3	; 3
     832:	54 c0       	rjmp	.+168    	; 0x8dc <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     834:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <xTaskGetTickCountFromISR>
     838:	90 93 a0 08 	sts	0x08A0, r25
     83c:	80 93 9f 08 	sts	0x089F, r24
     840:	20 91 95 08 	lds	r18, 0x0895
     844:	30 91 96 08 	lds	r19, 0x0896
     848:	82 17       	cp	r24, r18
     84a:	93 07       	cpc	r25, r19
     84c:	4c f4       	brge	.+18     	; 0x860 <__vector_9+0x74>
			ms_tickEnd += 65535;
     84e:	80 91 9f 08 	lds	r24, 0x089F
     852:	90 91 a0 08 	lds	r25, 0x08A0
     856:	01 97       	sbiw	r24, 0x01	; 1
     858:	90 93 a0 08 	sts	0x08A0, r25
     85c:	80 93 9f 08 	sts	0x089F, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     860:	02 d3       	rcall	.+1540   	; 0xe66 <myTimer_Read>
     862:	90 e0       	ldi	r25, 0x00	; 0
     864:	90 93 a2 08 	sts	0x08A2, r25
     868:	80 93 a1 08 	sts	0x08A1, r24
     86c:	20 91 99 08 	lds	r18, 0x0899
     870:	30 91 9a 08 	lds	r19, 0x089A
     874:	82 17       	cp	r24, r18
     876:	93 07       	cpc	r25, r19
     878:	54 f4       	brge	.+20     	; 0x88e <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     87a:	80 91 a1 08 	lds	r24, 0x08A1
     87e:	90 91 a2 08 	lds	r25, 0x08A2
     882:	86 50       	subi	r24, 0x06	; 6
     884:	9f 4f       	sbci	r25, 0xFF	; 255
     886:	90 93 a2 08 	sts	0x08A2, r25
     88a:	80 93 a1 08 	sts	0x08A1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     88e:	80 91 a1 08 	lds	r24, 0x08A1
     892:	90 91 a2 08 	lds	r25, 0x08A2
     896:	20 91 99 08 	lds	r18, 0x0899
     89a:	30 91 9a 08 	lds	r19, 0x089A
     89e:	82 1b       	sub	r24, r18
     8a0:	93 0b       	sbc	r25, r19
     8a2:	90 93 9c 08 	sts	0x089C, r25
     8a6:	80 93 9b 08 	sts	0x089B, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     8aa:	80 91 9f 08 	lds	r24, 0x089F
     8ae:	90 91 a0 08 	lds	r25, 0x08A0
     8b2:	20 91 95 08 	lds	r18, 0x0895
     8b6:	30 91 96 08 	lds	r19, 0x0896
     8ba:	82 1b       	sub	r24, r18
     8bc:	93 0b       	sbc	r25, r19
     8be:	90 93 98 08 	sts	0x0898, r25
     8c2:	80 93 97 08 	sts	0x0897, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     8c6:	20 e0       	ldi	r18, 0x00	; 0
     8c8:	40 e0       	ldi	r20, 0x00	; 0
     8ca:	50 e0       	ldi	r21, 0x00	; 0
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	70 e0       	ldi	r23, 0x00	; 0
     8d0:	80 91 9d 08 	lds	r24, 0x089D
     8d4:	90 91 9e 08 	lds	r25, 0x089E
     8d8:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xQueueGenericSendFromISR>
	}	
}
     8dc:	ff 91       	pop	r31
     8de:	ef 91       	pop	r30
     8e0:	bf 91       	pop	r27
     8e2:	af 91       	pop	r26
     8e4:	9f 91       	pop	r25
     8e6:	8f 91       	pop	r24
     8e8:	7f 91       	pop	r23
     8ea:	6f 91       	pop	r22
     8ec:	5f 91       	pop	r21
     8ee:	4f 91       	pop	r20
     8f0:	3f 91       	pop	r19
     8f2:	2f 91       	pop	r18
     8f4:	0f 90       	pop	r0
     8f6:	0b be       	out	0x3b, r0	; 59
     8f8:	0f 90       	pop	r0
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	0f 90       	pop	r0
     8fe:	1f 90       	pop	r1
     900:	18 95       	reti

00000902 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     902:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     904:	89 e1       	ldi	r24, 0x19	; 25
     906:	90 e0       	ldi	r25, 0x00	; 0
     908:	b0 d2       	rcall	.+1376   	; 0xe6a <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     90a:	a1 98       	cbi	0x14, 1	; 20
     90c:	08 95       	ret

0000090e <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     90e:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro2(25); // delay 25 micro seconds...
     910:	89 e1       	ldi	r24, 0x19	; 25
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	ce d2       	rcall	.+1436   	; 0xeb2 <myTimer_DelayMicro2>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     916:	a0 98       	cbi	0x14, 0	; 20
     918:	08 95       	ret

0000091a <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     91a:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     91c:	80 81       	ld	r24, Z
     91e:	91 81       	ldd	r25, Z+1	; 0x01
     920:	22 81       	ldd	r18, Z+2	; 0x02
     922:	33 81       	ldd	r19, Z+3	; 0x03
     924:	28 17       	cp	r18, r24
     926:	39 07       	cpc	r19, r25
     928:	54 f4       	brge	.+20     	; 0x93e <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     92a:	44 81       	ldd	r20, Z+4	; 0x04
     92c:	55 81       	ldd	r21, Z+5	; 0x05
     92e:	42 17       	cp	r20, r18
     930:	53 07       	cpc	r21, r19
     932:	84 f0       	brlt	.+32     	; 0x954 <myMaxSonar_extractMedian+0x3a>
     934:	48 17       	cp	r20, r24
     936:	59 07       	cpc	r21, r25
     938:	74 f4       	brge	.+28     	; 0x956 <myMaxSonar_extractMedian+0x3c>
     93a:	ca 01       	movw	r24, r20
     93c:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     93e:	44 81       	ldd	r20, Z+4	; 0x04
     940:	55 81       	ldd	r21, Z+5	; 0x05
     942:	48 17       	cp	r20, r24
     944:	59 07       	cpc	r21, r25
     946:	3c f0       	brlt	.+14     	; 0x956 <myMaxSonar_extractMedian+0x3c>
     948:	ca 01       	movw	r24, r20
     94a:	24 17       	cp	r18, r20
     94c:	35 07       	cpc	r19, r21
     94e:	1c f4       	brge	.+6      	; 0x956 <myMaxSonar_extractMedian+0x3c>
     950:	c9 01       	movw	r24, r18
     952:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     954:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     956:	08 95       	ret

00000958 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     958:	9b 01       	movw	r18, r22
     95a:	28 5f       	subi	r18, 0xF8	; 248
     95c:	3f 4f       	sbci	r19, 0xFF	; 255
     95e:	28 17       	cp	r18, r24
     960:	39 07       	cpc	r19, r25
     962:	3c f0       	brlt	.+14     	; 0x972 <myMaxSonar_Stabilizer+0x1a>
     964:	20 51       	subi	r18, 0x10	; 16
     966:	31 09       	sbc	r19, r1
     968:	82 17       	cp	r24, r18
     96a:	93 07       	cpc	r25, r19
     96c:	14 f0       	brlt	.+4      	; 0x972 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     96e:	86 2f       	mov	r24, r22
     970:	97 2f       	mov	r25, r23
}
     972:	08 95       	ret

00000974 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     974:	0f 93       	push	r16
     976:	1f 93       	push	r17
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     97e:	00 91 00 02 	lds	r16, 0x0200
     982:	10 e0       	ldi	r17, 0x00	; 0
     984:	f8 01       	movw	r30, r16
     986:	ee 0f       	add	r30, r30
     988:	ff 1f       	adc	r31, r31
     98a:	e6 0f       	add	r30, r22
     98c:	f7 1f       	adc	r31, r23
     98e:	60 81       	ld	r22, Z
     990:	71 81       	ldd	r23, Z+1	; 0x01
     992:	e2 df       	rcall	.-60     	; 0x958 <myMaxSonar_Stabilizer>
     994:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     996:	c8 01       	movw	r24, r16
     998:	01 96       	adiw	r24, 0x01	; 1
     99a:	63 e0       	ldi	r22, 0x03	; 3
     99c:	70 e0       	ldi	r23, 0x00	; 0
     99e:	0e 94 7f 17 	call	0x2efe	; 0x2efe <__divmodhi4>
     9a2:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     9a6:	88 0f       	add	r24, r24
     9a8:	99 1f       	adc	r25, r25
     9aa:	c8 0f       	add	r28, r24
     9ac:	d9 1f       	adc	r29, r25
     9ae:	39 83       	std	Y+1, r19	; 0x01
     9b0:	28 83       	st	Y, r18
}
     9b2:	df 91       	pop	r29
     9b4:	cf 91       	pop	r28
     9b6:	1f 91       	pop	r17
     9b8:	0f 91       	pop	r16
     9ba:	08 95       	ret

000009bc <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     9c2:	d8 df       	rcall	.-80     	; 0x974 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     9c4:	ce 01       	movw	r24, r28
     9c6:	a9 df       	rcall	.-174    	; 0x91a <myMaxSonar_extractMedian>

}
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	08 95       	ret

000009ce <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     9ce:	b5 d0       	rcall	.+362    	; 0xb3a <myADC_analogRead>
     9d0:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     9d2:	63 e0       	ldi	r22, 0x03	; 3
     9d4:	70 e0       	ldi	r23, 0x00	; 0
     9d6:	0e 94 7f 17 	call	0x2efe	; 0x2efe <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     9da:	26 0f       	add	r18, r22
     9dc:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     9de:	29 3e       	cpi	r18, 0xE9	; 233
     9e0:	83 e0       	ldi	r24, 0x03	; 3
     9e2:	38 07       	cpc	r19, r24
     9e4:	1c f0       	brlt	.+6      	; 0x9ec <myMaxSonar_Read+0x1e>
		return 999;
     9e6:	87 ee       	ldi	r24, 0xE7	; 231
     9e8:	93 e0       	ldi	r25, 0x03	; 3
     9ea:	08 95       	ret
	
	return reading;
     9ec:	82 2f       	mov	r24, r18
     9ee:	93 2f       	mov	r25, r19
}
     9f0:	08 95       	ret

000009f2 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9f2:	1f 92       	push	r1
     9f4:	0f 92       	push	r0
     9f6:	0f b6       	in	r0, 0x3f	; 63
     9f8:	0f 92       	push	r0
     9fa:	11 24       	eor	r1, r1
     9fc:	0b b6       	in	r0, 0x3b	; 59
     9fe:	0f 92       	push	r0
     a00:	2f 93       	push	r18
     a02:	3f 93       	push	r19
     a04:	4f 93       	push	r20
     a06:	5f 93       	push	r21
     a08:	6f 93       	push	r22
     a0a:	7f 93       	push	r23
     a0c:	8f 93       	push	r24
     a0e:	9f 93       	push	r25
     a10:	af 93       	push	r26
     a12:	bf 93       	push	r27
     a14:	ef 93       	push	r30
     a16:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     a18:	80 91 78 00 	lds	r24, 0x0078
     a1c:	80 93 a3 08 	sts	0x08A3, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     a20:	80 91 79 00 	lds	r24, 0x0079
     a24:	80 93 a4 08 	sts	0x08A4, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     a28:	20 e0       	ldi	r18, 0x00	; 0
     a2a:	40 e0       	ldi	r20, 0x00	; 0
     a2c:	50 e0       	ldi	r21, 0x00	; 0
     a2e:	60 e0       	ldi	r22, 0x00	; 0
     a30:	70 e0       	ldi	r23, 0x00	; 0
     a32:	80 91 a7 08 	lds	r24, 0x08A7
     a36:	90 91 a8 08 	lds	r25, 0x08A8
     a3a:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <xQueueGenericSendFromISR>
}
     a3e:	ff 91       	pop	r31
     a40:	ef 91       	pop	r30
     a42:	bf 91       	pop	r27
     a44:	af 91       	pop	r26
     a46:	9f 91       	pop	r25
     a48:	8f 91       	pop	r24
     a4a:	7f 91       	pop	r23
     a4c:	6f 91       	pop	r22
     a4e:	5f 91       	pop	r21
     a50:	4f 91       	pop	r20
     a52:	3f 91       	pop	r19
     a54:	2f 91       	pop	r18
     a56:	0f 90       	pop	r0
     a58:	0b be       	out	0x3b, r0	; 59
     a5a:	0f 90       	pop	r0
     a5c:	0f be       	out	0x3f, r0	; 63
     a5e:	0f 90       	pop	r0
     a60:	1f 90       	pop	r1
     a62:	18 95       	reti

00000a64 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a64:	8f e8       	ldi	r24, 0x8F	; 143
     a66:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a6a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a6e:	80 e4       	ldi	r24, 0x40	; 64
     a70:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a74:	43 e0       	ldi	r20, 0x03	; 3
     a76:	60 e0       	ldi	r22, 0x00	; 0
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	18 d7       	rcall	.+3632   	; 0x18ac <xQueueGenericCreate>
     a7c:	90 93 a8 08 	sts	0x08A8, r25
     a80:	80 93 a7 08 	sts	0x08A7, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	d2 d7       	rcall	.+4004   	; 0x1a2c <xQueueCreateMutex>
     a88:	90 93 a6 08 	sts	0x08A6, r25
     a8c:	80 93 a5 08 	sts	0x08A5, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	40 e0       	ldi	r20, 0x00	; 0
     a94:	50 e0       	ldi	r21, 0x00	; 0
     a96:	60 e0       	ldi	r22, 0x00	; 0
     a98:	70 e0       	ldi	r23, 0x00	; 0
     a9a:	35 c7       	rjmp	.+3690   	; 0x1906 <xQueueGenericSend>
     a9c:	08 95       	ret

00000a9e <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a9e:	cf 93       	push	r28
     aa0:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     aa2:	20 e0       	ldi	r18, 0x00	; 0
     aa4:	4f ef       	ldi	r20, 0xFF	; 255
     aa6:	5f ef       	ldi	r21, 0xFF	; 255
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	80 91 a5 08 	lds	r24, 0x08A5
     ab0:	90 91 a6 08 	lds	r25, 0x08A6
     ab4:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     ab8:	ec e7       	ldi	r30, 0x7C	; 124
     aba:	f0 e0       	ldi	r31, 0x00	; 0
     abc:	80 81       	ld	r24, Z
     abe:	9c 2f       	mov	r25, r28
     ac0:	9f 71       	andi	r25, 0x1F	; 31
     ac2:	80 76       	andi	r24, 0x60	; 96
     ac4:	89 2b       	or	r24, r25
     ac6:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     ac8:	eb e7       	ldi	r30, 0x7B	; 123
     aca:	f0 e0       	ldi	r31, 0x00	; 0
     acc:	20 81       	ld	r18, Z
     ace:	c0 72       	andi	r28, 0x20	; 32
     ad0:	8c 2f       	mov	r24, r28
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	95 95       	asr	r25
     ad6:	87 95       	ror	r24
     ad8:	95 95       	asr	r25
     ada:	87 95       	ror	r24
     adc:	92 2f       	mov	r25, r18
     ade:	90 76       	andi	r25, 0x60	; 96
     ae0:	89 2b       	or	r24, r25
     ae2:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     ae4:	ea e7       	ldi	r30, 0x7A	; 122
     ae6:	f0 e0       	ldi	r31, 0x00	; 0
     ae8:	80 81       	ld	r24, Z
     aea:	80 64       	ori	r24, 0x40	; 64
     aec:	80 83       	st	Z, r24
}
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <myADC_readADC>:

int myADC_readADC(char channel)
{
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     af6:	20 e0       	ldi	r18, 0x00	; 0
     af8:	4f ef       	ldi	r20, 0xFF	; 255
     afa:	5f ef       	ldi	r21, 0xFF	; 255
     afc:	60 e0       	ldi	r22, 0x00	; 0
     afe:	70 e0       	ldi	r23, 0x00	; 0
     b00:	80 91 a7 08 	lds	r24, 0x08A7
     b04:	90 91 a8 08 	lds	r25, 0x08A8
     b08:	f6 d7       	rcall	.+4076   	; 0x1af6 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     b0a:	c0 91 a4 08 	lds	r28, 0x08A4
     b0e:	c3 70       	andi	r28, 0x03	; 3
     b10:	d0 e0       	ldi	r29, 0x00	; 0
     b12:	dc 2f       	mov	r29, r28
     b14:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     b16:	80 91 a3 08 	lds	r24, 0x08A3
     b1a:	c8 0f       	add	r28, r24
     b1c:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     b1e:	20 e0       	ldi	r18, 0x00	; 0
     b20:	40 e0       	ldi	r20, 0x00	; 0
     b22:	50 e0       	ldi	r21, 0x00	; 0
     b24:	60 e0       	ldi	r22, 0x00	; 0
     b26:	70 e0       	ldi	r23, 0x00	; 0
     b28:	80 91 a5 08 	lds	r24, 0x08A5
     b2c:	90 91 a6 08 	lds	r25, 0x08A6
     b30:	ea d6       	rcall	.+3540   	; 0x1906 <xQueueGenericSend>
	
	return adcReading;
     b32:	ce 01       	movw	r24, r28
     b34:	df 91       	pop	r29
     b36:	cf 91       	pop	r28
     b38:	08 95       	ret

00000b3a <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     b3a:	cf 93       	push	r28
     b3c:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b3e:	af df       	rcall	.-162    	; 0xa9e <myADC_startADC>
	return myADC_readADC(channel);
     b40:	8c 2f       	mov	r24, r28
     b42:	d7 df       	rcall	.-82     	; 0xaf2 <myADC_readADC>
}
     b44:	cf 91       	pop	r28
     b46:	08 95       	ret

00000b48 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b48:	9c 01       	movw	r18, r24
     b4a:	28 5f       	subi	r18, 0xF8	; 248
     b4c:	3f 4f       	sbci	r19, 0xFF	; 255
     b4e:	26 17       	cp	r18, r22
     b50:	37 07       	cpc	r19, r23
     b52:	44 f0       	brlt	.+16     	; 0xb64 <detectStairs+0x1c>
     b54:	20 51       	subi	r18, 0x10	; 16
     b56:	31 09       	sbc	r19, r1
     b58:	81 e0       	ldi	r24, 0x01	; 1
     b5a:	62 17       	cp	r22, r18
     b5c:	73 07       	cpc	r23, r19
     b5e:	1c f0       	brlt	.+6      	; 0xb66 <detectStairs+0x1e>
     b60:	80 e0       	ldi	r24, 0x00	; 0
     b62:	08 95       	ret
	{
		return 1; // stairs found
     b64:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b66:	08 95       	ret

00000b68 <cheatPrintAll>:
	}
}


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     b68:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     b6a:	85 e0       	ldi	r24, 0x05	; 5
     b6c:	db 01       	movw	r26, r22
     b6e:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     b70:	86 e4       	ldi	r24, 0x46	; 70
     b72:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     b74:	8c e4       	ldi	r24, 0x4C	; 76
     b76:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     b78:	82 e5       	ldi	r24, 0x52	; 82
     b7a:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     b7c:	82 e4       	ldi	r24, 0x42	; 66
     b7e:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     b80:	84 e5       	ldi	r24, 0x54	; 84
     b82:	84 83       	std	Z+4, r24	; 0x04
     b84:	08 95       	ret

00000b86 <possibleStairs>:
}

// detect possibleStairs infront 
char possibleStairs(int frontSonar, int topSonar)
{
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
     b86:	c2 97       	sbiw	r24, 0x32	; 50
     b88:	44 f4       	brge	.+16     	; 0xb9a <possibleStairs+0x14>
     b8a:	61 55       	subi	r22, 0x51	; 81
     b8c:	71 09       	sbc	r23, r1
     b8e:	81 e0       	ldi	r24, 0x01	; 1
     b90:	67 32       	cpi	r22, 0x27	; 39
     b92:	71 05       	cpc	r23, r1
     b94:	18 f0       	brcs	.+6      	; 0xb9c <possibleStairs+0x16>
     b96:	80 e0       	ldi	r24, 0x00	; 0
     b98:	08 95       	ret
		return 1;
	else 
		return 0;
     b9a:	80 e0       	ldi	r24, 0x00	; 0
	
}
     b9c:	08 95       	ret

00000b9e <obstacleAvoidance>:
}


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int topSonar, int leftSonar, int rightSonar, int btmIR,  char const * const deviceBlocked)
{
     b9e:	cf 92       	push	r12
     ba0:	df 92       	push	r13
     ba2:	ef 92       	push	r14
     ba4:	ff 92       	push	r15
     ba6:	0f 93       	push	r16
     ba8:	1f 93       	push	r17
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	8a 01       	movw	r16, r20
     bb0:	69 01       	movw	r12, r18
     bb2:	e7 01       	movw	r28, r14
	
	if(deviceBlocked[BTM_DEVICE])
     bb4:	2b 81       	ldd	r18, Y+3	; 0x03
     bb6:	22 23       	and	r18, r18
     bb8:	41 f0       	breq	.+16     	; 0xbca <obstacleAvoidance+0x2c>
	{
		// stairs detected
			MOTOR_LEFT_START();
     bba:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     bbc:	e2 e0       	ldi	r30, 0x02	; 2
     bbe:	f1 e0       	ldi	r31, 0x01	; 1
     bc0:	80 81       	ld	r24, Z
     bc2:	80 61       	ori	r24, 0x10	; 16
     bc4:	80 83       	st	Z, r24
			MOTOR_FRONT_STOP();
     bc6:	73 98       	cbi	0x0e, 3	; 14
     bc8:	53 c0       	rjmp	.+166    	; 0xc70 <obstacleAvoidance+0xd2>
	}
	else if( (deviceBlocked[FRONT_DEVICE] && (!possibleStairs(frontSonar, topSonar))) || deviceBlocked[TOP_DEVICE])
     bca:	28 81       	ld	r18, Y
     bcc:	22 23       	and	r18, r18
     bce:	19 f0       	breq	.+6      	; 0xbd6 <obstacleAvoidance+0x38>
     bd0:	da df       	rcall	.-76     	; 0xb86 <possibleStairs>
     bd2:	88 23       	and	r24, r24
     bd4:	19 f0       	breq	.+6      	; 0xbdc <obstacleAvoidance+0x3e>
     bd6:	8c 81       	ldd	r24, Y+4	; 0x04
     bd8:	88 23       	and	r24, r24
     bda:	41 f1       	breq	.+80     	; 0xc2c <obstacleAvoidance+0x8e>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     bdc:	89 81       	ldd	r24, Y+1	; 0x01
     bde:	81 11       	cpse	r24, r1
     be0:	07 c0       	rjmp	.+14     	; 0xbf0 <obstacleAvoidance+0x52>
     be2:	8a 81       	ldd	r24, Y+2	; 0x02
     be4:	81 11       	cpse	r24, r1
     be6:	15 c0       	rjmp	.+42     	; 0xc12 <obstacleAvoidance+0x74>
		{
			
			MOTOR_FRONT_START();
     be8:	73 9a       	sbi	0x0e, 3	; 14
					//MOTOR_LEFT_START();
					//MOTOR_RIGHT_STOP();
					//
				//}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     bea:	89 81       	ldd	r24, Y+1	; 0x01
     bec:	88 23       	and	r24, r24
     bee:	e9 f1       	breq	.+122    	; 0xc6a <obstacleAvoidance+0xcc>
     bf0:	8a 81       	ldd	r24, Y+2	; 0x02
     bf2:	81 11       	cpse	r24, r1
     bf4:	3d c0       	rjmp	.+122    	; 0xc70 <obstacleAvoidance+0xd2>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     bf6:	c0 1a       	sub	r12, r16
     bf8:	d1 0a       	sbc	r13, r17
     bfa:	88 e0       	ldi	r24, 0x08	; 8
     bfc:	c8 16       	cp	r12, r24
     bfe:	d1 04       	cpc	r13, r1
     c00:	bc f1       	brlt	.+110    	; 0xc70 <obstacleAvoidance+0xd2>
			{
				MOTOR_FRONT_STOP();
     c02:	73 98       	cbi	0x0e, 3	; 14
				MOTOR_LEFT_STOP();
     c04:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     c06:	e2 e0       	ldi	r30, 0x02	; 2
     c08:	f1 e0       	ldi	r31, 0x01	; 1
     c0a:	80 81       	ld	r24, Z
     c0c:	80 61       	ori	r24, 0x10	; 16
     c0e:	80 83       	st	Z, r24
     c10:	2f c0       	rjmp	.+94     	; 0xc70 <obstacleAvoidance+0xd2>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     c12:	0c 19       	sub	r16, r12
     c14:	1d 09       	sbc	r17, r13
     c16:	08 30       	cpi	r16, 0x08	; 8
     c18:	11 05       	cpc	r17, r1
     c1a:	54 f1       	brlt	.+84     	; 0xc70 <obstacleAvoidance+0xd2>
			{
				MOTOR_FRONT_STOP();
     c1c:	73 98       	cbi	0x0e, 3	; 14
				MOTOR_LEFT_START();
     c1e:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     c20:	e2 e0       	ldi	r30, 0x02	; 2
     c22:	f1 e0       	ldi	r31, 0x01	; 1
     c24:	80 81       	ld	r24, Z
     c26:	8f 7e       	andi	r24, 0xEF	; 239
     c28:	80 83       	st	Z, r24
     c2a:	22 c0       	rjmp	.+68     	; 0xc70 <obstacleAvoidance+0xd2>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     c2c:	0e 31       	cpi	r16, 0x1E	; 30
     c2e:	11 05       	cpc	r17, r1
     c30:	44 f4       	brge	.+16     	; 0xc42 <obstacleAvoidance+0xa4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_FRONT_STOP();
     c32:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_STOP();
     c34:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     c36:	e2 e0       	ldi	r30, 0x02	; 2
     c38:	f1 e0       	ldi	r31, 0x01	; 1
     c3a:	80 81       	ld	r24, Z
     c3c:	80 61       	ori	r24, 0x10	; 16
     c3e:	80 83       	st	Z, r24
     c40:	17 c0       	rjmp	.+46     	; 0xc70 <obstacleAvoidance+0xd2>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     c42:	86 e1       	ldi	r24, 0x16	; 22
     c44:	c8 16       	cp	r12, r24
     c46:	d1 04       	cpc	r13, r1
     c48:	44 f4       	brge	.+16     	; 0xc5a <obstacleAvoidance+0xbc>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_FRONT_STOP();
     c4a:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_START();
     c4c:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c4e:	e2 e0       	ldi	r30, 0x02	; 2
     c50:	f1 e0       	ldi	r31, 0x01	; 1
     c52:	80 81       	ld	r24, Z
     c54:	8f 7e       	andi	r24, 0xEF	; 239
     c56:	80 83       	st	Z, r24
     c58:	0b c0       	rjmp	.+22     	; 0xc70 <obstacleAvoidance+0xd2>
	}
	else
	{
			MOTOR_FRONT_STOP();
     c5a:	73 98       	cbi	0x0e, 3	; 14
			MOTOR_LEFT_STOP();
     c5c:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c5e:	e2 e0       	ldi	r30, 0x02	; 2
     c60:	f1 e0       	ldi	r31, 0x01	; 1
     c62:	80 81       	ld	r24, Z
     c64:	8f 7e       	andi	r24, 0xEF	; 239
     c66:	80 83       	st	Z, r24
     c68:	03 c0       	rjmp	.+6      	; 0xc70 <obstacleAvoidance+0xd2>
				MOTOR_FRONT_STOP();
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     c6a:	8a 81       	ldd	r24, Y+2	; 0x02
     c6c:	81 11       	cpse	r24, r1
     c6e:	d1 cf       	rjmp	.-94     	; 0xc12 <obstacleAvoidance+0x74>
	{
			MOTOR_FRONT_STOP();
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	ff 90       	pop	r15
     c7a:	ef 90       	pop	r14
     c7c:	df 90       	pop	r13
     c7e:	cf 90       	pop	r12
     c80:	08 95       	ret

00000c82 <obstacleDetection>:
}

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c82:	af 92       	push	r10
     c84:	bf 92       	push	r11
     c86:	cf 92       	push	r12
     c88:	df 92       	push	r13
     c8a:	ef 92       	push	r14
     c8c:	ff 92       	push	r15
     c8e:	0f 93       	push	r16
     c90:	1f 93       	push	r17
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29
     c96:	ea 01       	movw	r28, r20
     c98:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	obstacleDetected = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c9a:	c2 97       	sbiw	r24, 0x32	; 50
     c9c:	2c f4       	brge	.+10     	; 0xca8 <obstacleDetection+0x26>
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c9e:	86 e4       	ldi	r24, 0x46	; 70
     ca0:	88 83       	st	Y, r24

	obstacleDetected = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
     ca2:	bb 24       	eor	r11, r11
     ca4:	b3 94       	inc	r11
     ca6:	01 c0       	rjmp	.+2      	; 0xcaa <obstacleDetection+0x28>
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
     ca8:	b1 2c       	mov	r11, r1
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     caa:	2e 31       	cpi	r18, 0x1E	; 30
     cac:	31 05       	cpc	r19, r1
     cae:	1c f4       	brge	.+6      	; 0xcb6 <obstacleDetection+0x34>
	{
		obstacleDetected ++;
     cb0:	b3 94       	inc	r11
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     cb2:	8c e4       	ldi	r24, 0x4C	; 76
     cb4:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     cb6:	0e 31       	cpi	r16, 0x1E	; 30
     cb8:	11 05       	cpc	r17, r1
     cba:	1c f4       	brge	.+6      	; 0xcc2 <obstacleDetection+0x40>
	{
		obstacleDetected++;
     cbc:	b3 94       	inc	r11
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     cbe:	82 e5       	ldi	r24, 0x52	; 82
     cc0:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     cc2:	c6 01       	movw	r24, r12
     cc4:	41 df       	rcall	.-382    	; 0xb48 <detectStairs>
     cc6:	88 23       	and	r24, r24
     cc8:	19 f0       	breq	.+6      	; 0xcd0 <obstacleDetection+0x4e>
	{
		obstacleDetected++;
     cca:	b3 94       	inc	r11
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     ccc:	82 e4       	ldi	r24, 0x42	; 66
     cce:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     cd0:	87 e3       	ldi	r24, 0x37	; 55
     cd2:	e8 16       	cp	r14, r24
     cd4:	f1 04       	cpc	r15, r1
     cd6:	1c f4       	brge	.+6      	; 0xcde <obstacleDetection+0x5c>
	{
		obstacleDetected++;
     cd8:	b3 94       	inc	r11
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     cda:	84 e5       	ldi	r24, 0x54	; 84
     cdc:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     cde:	8b 2d       	mov	r24, r11
     ce0:	df 91       	pop	r29
     ce2:	cf 91       	pop	r28
     ce4:	1f 91       	pop	r17
     ce6:	0f 91       	pop	r16
     ce8:	ff 90       	pop	r15
     cea:	ef 90       	pop	r14
     cec:	df 90       	pop	r13
     cee:	cf 90       	pop	r12
     cf0:	bf 90       	pop	r11
     cf2:	af 90       	pop	r10
     cf4:	08 95       	ret

00000cf6 <mySharpIR_Read>:
#include <myUSART.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     cf6:	21 df       	rcall	.-446    	; 0xb3a <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cf8:	bc 01       	movw	r22, r24
     cfa:	88 27       	eor	r24, r24
     cfc:	77 fd       	sbrc	r23, 7
     cfe:	80 95       	com	r24
     d00:	98 2f       	mov	r25, r24
     d02:	0e 94 c3 14 	call	0x2986	; 0x2986 <__floatsisf>
     d06:	29 e2       	ldi	r18, 0x29	; 41
     d08:	3c e5       	ldi	r19, 0x5C	; 92
     d0a:	4f e6       	ldi	r20, 0x6F	; 111
     d0c:	5f eb       	ldi	r21, 0xBF	; 191
     d0e:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <pow>
     d12:	22 e5       	ldi	r18, 0x52	; 82
     d14:	38 e6       	ldi	r19, 0x68	; 104
     d16:	46 e2       	ldi	r20, 0x26	; 38
     d18:	56 e4       	ldi	r21, 0x46	; 70
     d1a:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <__mulsf3>
     d1e:	20 e0       	ldi	r18, 0x00	; 0
     d20:	30 e0       	ldi	r19, 0x00	; 0
     d22:	40 e2       	ldi	r20, 0x20	; 32
     d24:	51 e4       	ldi	r21, 0x41	; 65
     d26:	0e 94 2b 14 	call	0x2856	; 0x2856 <__subsf3>
     d2a:	0e 94 90 14 	call	0x2920	; 0x2920 <__fixsfsi>
     d2e:	cb 01       	movw	r24, r22
	if(adcReading > IR_MAX_VALUE || adcReading < IR_MIN_VALUE)
     d30:	68 3e       	cpi	r22, 0xE8	; 232
     d32:	23 e0       	ldi	r18, 0x03	; 3
     d34:	72 07       	cpc	r23, r18
     d36:	10 f0       	brcs	.+4      	; 0xd3c <mySharpIR_Read+0x46>
		adcReading = IR_MAX_VALUE;
     d38:	87 ee       	ldi	r24, 0xE7	; 231
     d3a:	93 e0       	ldi	r25, 0x03	; 3
	
	return adcReading;
}
     d3c:	08 95       	ret

00000d3e <checkOutOfRange>:

// return 1 if out of range..
char checkOutOfRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d3e:	fb 01       	movw	r30, r22
     d40:	20 81       	ld	r18, Z
     d42:	31 81       	ldd	r19, Z+1	; 0x01
     d44:	50 e0       	ldi	r21, 0x00	; 0
     d46:	b9 01       	movw	r22, r18
     d48:	64 0f       	add	r22, r20
     d4a:	75 1f       	adc	r23, r21
     d4c:	68 17       	cp	r22, r24
     d4e:	79 07       	cpc	r23, r25
     d50:	4c f0       	brlt	.+18     	; 0xd64 <checkOutOfRange+0x26>
     d52:	24 1b       	sub	r18, r20
     d54:	35 0b       	sbc	r19, r21
     d56:	41 e0       	ldi	r20, 0x01	; 1
     d58:	82 17       	cp	r24, r18
     d5a:	93 07       	cpc	r25, r19
     d5c:	0c f0       	brlt	.+2      	; 0xd60 <checkOutOfRange+0x22>
     d5e:	40 e0       	ldi	r20, 0x00	; 0
     d60:	84 2f       	mov	r24, r20
     d62:	08 95       	ret
     d64:	81 e0       	ldi	r24, 0x01	; 1
}
     d66:	08 95       	ret

00000d68 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     d68:	ff 92       	push	r15
     d6a:	0f 93       	push	r16
     d6c:	1f 93       	push	r17
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	8c 01       	movw	r16, r24
     d74:	eb 01       	movw	r28, r22
	static uint8_t sampleCount = 0;
	static int referenceReading = 0;
	//static int testPrint = 0;
	
	if(!checkOutOfRange(reading, calibratedReading, CALIBRATE_RANGE) && sampleCount == 0)
     d76:	45 e0       	ldi	r20, 0x05	; 5
     d78:	bc 01       	movw	r22, r24
     d7a:	ce 01       	movw	r24, r28
     d7c:	e0 df       	rcall	.-64     	; 0xd3e <checkOutOfRange>
     d7e:	81 11       	cpse	r24, r1
     d80:	05 c0       	rjmp	.+10     	; 0xd8c <mySharpIR_ReCalibrate+0x24>
     d82:	80 91 1b 08 	lds	r24, 0x081B
     d86:	88 23       	and	r24, r24
     d88:	09 f4       	brne	.+2      	; 0xd8c <mySharpIR_ReCalibrate+0x24>
     d8a:	4d c0       	rjmp	.+154    	; 0xe26 <mySharpIR_ReCalibrate+0xbe>
		// if current reading and calibratedReading is within range and no checking in progess
		// skip the calibration process... not needed
		return;
	}
	
	if(reading < CALIBRATE_LOW_THRESHOLD || reading > CALIBRATE_HIGH_THRESHOLD)
     d8c:	ce 01       	movw	r24, r28
     d8e:	49 97       	sbiw	r24, 0x19	; 25
     d90:	45 97       	sbiw	r24, 0x15	; 21
     d92:	28 f0       	brcs	.+10     	; 0xd9e <mySharpIR_ReCalibrate+0x36>
	{
		// Too low or Too high for it to be ground..
		referenceReading = 0;
     d94:	10 92 1a 08 	sts	0x081A, r1
     d98:	10 92 19 08 	sts	0x0819, r1
		return;		
     d9c:	44 c0       	rjmp	.+136    	; 0xe26 <mySharpIR_ReCalibrate+0xbe>
	}
	
	
	if (sampleCount == 0)
     d9e:	f0 90 1b 08 	lds	r15, 0x081B
     da2:	f1 10       	cpse	r15, r1
     da4:	05 c0       	rjmp	.+10     	; 0xdb0 <mySharpIR_ReCalibrate+0x48>
	{
		// Possible calibration... take reference from reading
		//testPrint = 0;
		referenceReading = reading;
     da6:	d0 93 1a 08 	sts	0x081A, r29
     daa:	c0 93 19 08 	sts	0x0819, r28
     dae:	38 c0       	rjmp	.+112    	; 0xe20 <mySharpIR_ReCalibrate+0xb8>
		//myUSART_transmitUSART0("\n-----RS----\n");

	}
	else if ((sampleCount % CALIBRATE_SAMPLE_RATE) == 0) // when count reach 
     db0:	8d ec       	ldi	r24, 0xCD	; 205
     db2:	f8 9e       	mul	r15, r24
     db4:	81 2d       	mov	r24, r1
     db6:	11 24       	eor	r1, r1
     db8:	86 95       	lsr	r24
     dba:	86 95       	lsr	r24
     dbc:	98 2f       	mov	r25, r24
     dbe:	99 0f       	add	r25, r25
     dc0:	99 0f       	add	r25, r25
     dc2:	89 0f       	add	r24, r25
     dc4:	f8 12       	cpse	r15, r24
     dc6:	13 c0       	rjmp	.+38     	; 0xdee <mySharpIR_ReCalibrate+0x86>
	{
		//testPrint++;
		//myUSART_transmitUSART0_c(testPrint + '0');
		//myUSART_transmitUSART0("\n");
		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     dc8:	45 e0       	ldi	r20, 0x05	; 5
     dca:	69 e1       	ldi	r22, 0x19	; 25
     dcc:	78 e0       	ldi	r23, 0x08	; 8
     dce:	ce 01       	movw	r24, r28
     dd0:	b6 df       	rcall	.-148    	; 0xd3e <checkOutOfRange>
     dd2:	88 23       	and	r24, r24
     dd4:	39 f0       	breq	.+14     	; 0xde4 <mySharpIR_ReCalibrate+0x7c>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     dd6:	10 92 1a 08 	sts	0x081A, r1
     dda:	10 92 19 08 	sts	0x0819, r1
			sampleCount = 0; // reset to count...
     dde:	10 92 1b 08 	sts	0x081B, r1
			return;
     de2:	21 c0       	rjmp	.+66     	; 0xe26 <mySharpIR_ReCalibrate+0xbe>
		}
		else
		{	// within range.. need more confirmation, update reference point..
			referenceReading = reading;
     de4:	d0 93 1a 08 	sts	0x081A, r29
     de8:	c0 93 19 08 	sts	0x0819, r28
     dec:	19 c0       	rjmp	.+50     	; 0xe20 <mySharpIR_ReCalibrate+0xb8>
		}
	}
	else if (sampleCount >= CALIBRATE_SAMPLE_REQUIRE)
     dee:	81 e2       	ldi	r24, 0x21	; 33
     df0:	8f 15       	cp	r24, r15
     df2:	b0 f4       	brcc	.+44     	; 0xe20 <mySharpIR_ReCalibrate+0xb8>
	{
		// Sample long enough...
		sampleCount = 0; // reset to count..
     df4:	10 92 1b 08 	sts	0x081B, r1

		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     df8:	45 e0       	ldi	r20, 0x05	; 5
     dfa:	69 e1       	ldi	r22, 0x19	; 25
     dfc:	78 e0       	ldi	r23, 0x08	; 8
     dfe:	ce 01       	movw	r24, r28
     e00:	9e df       	rcall	.-196    	; 0xd3e <checkOutOfRange>
     e02:	88 23       	and	r24, r24
     e04:	29 f0       	breq	.+10     	; 0xe10 <mySharpIR_ReCalibrate+0xa8>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     e06:	10 92 1a 08 	sts	0x081A, r1
     e0a:	10 92 19 08 	sts	0x0819, r1
			return;
     e0e:	0b c0       	rjmp	.+22     	; 0xe26 <mySharpIR_ReCalibrate+0xbe>
		}
		else
		{
			// all readings within range... can calibrate as new stable.
			*calibratedReading = referenceReading; // btmIR is calibrated..
     e10:	80 91 19 08 	lds	r24, 0x0819
     e14:	90 91 1a 08 	lds	r25, 0x081A
     e18:	f8 01       	movw	r30, r16
     e1a:	91 83       	std	Z+1, r25	; 0x01
     e1c:	80 83       	st	Z, r24
			//myUSART_transmitUSART0("\nACK\n");
			return;
     e1e:	03 c0       	rjmp	.+6      	; 0xe26 <mySharpIR_ReCalibrate+0xbe>
		}
	}
	
	sampleCount++;
     e20:	f3 94       	inc	r15
     e22:	f0 92 1b 08 	sts	0x081B, r15
}
     e26:	df 91       	pop	r29
     e28:	cf 91       	pop	r28
     e2a:	1f 91       	pop	r17
     e2c:	0f 91       	pop	r16
     e2e:	ff 90       	pop	r15
     e30:	08 95       	ret

00000e32 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     e32:	90 93 ae 08 	sts	0x08AE, r25
     e36:	80 93 ad 08 	sts	0x08AD, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     e3a:	fc 01       	movw	r30, r24
     e3c:	80 81       	ld	r24, Z
     e3e:	91 81       	ldd	r25, Z+1	; 0x01
     e40:	0e 94 75 12 	call	0x24ea	; 0x24ea <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     e44:	43 e0       	ldi	r20, 0x03	; 3
     e46:	60 e0       	ldi	r22, 0x00	; 0
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	30 d5       	rcall	.+2656   	; 0x18ac <xQueueGenericCreate>
     e4c:	90 93 aa 08 	sts	0x08AA, r25
     e50:	80 93 a9 08 	sts	0x08A9, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     e54:	43 e0       	ldi	r20, 0x03	; 3
     e56:	60 e0       	ldi	r22, 0x00	; 0
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	28 d5       	rcall	.+2640   	; 0x18ac <xQueueGenericCreate>
     e5c:	90 93 ac 08 	sts	0x08AC, r25
     e60:	80 93 ab 08 	sts	0x08AB, r24
     e64:	08 95       	ret

00000e66 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e66:	86 b5       	in	r24, 0x26	; 38
}
     e68:	08 95       	ret

00000e6a <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e6a:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     e6c:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e6e:	9c 01       	movw	r18, r24
     e70:	99 23       	and	r25, r25
     e72:	14 f4       	brge	.+4      	; 0xe78 <myTimer_DelayMicro+0xe>
     e74:	2d 5f       	subi	r18, 0xFD	; 253
     e76:	3f 4f       	sbci	r19, 0xFF	; 255
     e78:	35 95       	asr	r19
     e7a:	27 95       	ror	r18
     e7c:	35 95       	asr	r19
     e7e:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     e80:	24 0f       	add	r18, r20
     e82:	35 1f       	adc	r19, r21
     e84:	30 93 04 02 	sts	0x0204, r19
     e88:	20 93 03 02 	sts	0x0203, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e8c:	e0 91 ad 08 	lds	r30, 0x08AD
     e90:	f0 91 ae 08 	lds	r31, 0x08AE
     e94:	80 81       	ld	r24, Z
     e96:	91 81       	ldd	r25, Z+1	; 0x01
     e98:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e9c:	20 e0       	ldi	r18, 0x00	; 0
     e9e:	42 e0       	ldi	r20, 0x02	; 2
     ea0:	50 e0       	ldi	r21, 0x00	; 0
     ea2:	60 e0       	ldi	r22, 0x00	; 0
     ea4:	70 e0       	ldi	r23, 0x00	; 0
     ea6:	80 91 a9 08 	lds	r24, 0x08A9
     eaa:	90 91 aa 08 	lds	r25, 0x08AA
     eae:	23 c6       	rjmp	.+3142   	; 0x1af6 <xQueueGenericReceive>
     eb0:	08 95       	ret

00000eb2 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     eb2:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     eb4:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     eb6:	9c 01       	movw	r18, r24
     eb8:	99 23       	and	r25, r25
     eba:	14 f4       	brge	.+4      	; 0xec0 <myTimer_DelayMicro2+0xe>
     ebc:	2d 5f       	subi	r18, 0xFD	; 253
     ebe:	3f 4f       	sbci	r19, 0xFF	; 255
     ec0:	35 95       	asr	r19
     ec2:	27 95       	ror	r18
     ec4:	35 95       	asr	r19
     ec6:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     ec8:	24 0f       	add	r18, r20
     eca:	35 1f       	adc	r19, r21
     ecc:	30 93 02 02 	sts	0x0202, r19
     ed0:	20 93 01 02 	sts	0x0201, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     ed4:	e0 91 ad 08 	lds	r30, 0x08AD
     ed8:	f0 91 ae 08 	lds	r31, 0x08AE
     edc:	80 81       	ld	r24, Z
     ede:	91 81       	ldd	r25, Z+1	; 0x01
     ee0:	0e 94 d8 0f 	call	0x1fb0	; 0x1fb0 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     ee4:	20 e0       	ldi	r18, 0x00	; 0
     ee6:	42 e0       	ldi	r20, 0x02	; 2
     ee8:	50 e0       	ldi	r21, 0x00	; 0
     eea:	60 e0       	ldi	r22, 0x00	; 0
     eec:	70 e0       	ldi	r23, 0x00	; 0
     eee:	80 91 ab 08 	lds	r24, 0x08AB
     ef2:	90 91 ac 08 	lds	r25, 0x08AC
     ef6:	ff c5       	rjmp	.+3070   	; 0x1af6 <xQueueGenericReceive>
     ef8:	08 95       	ret

00000efa <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     efe:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     f00:	c1 11       	cpse	r28, r1
     f02:	22 c0       	rjmp	.+68     	; 0xf48 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     f04:	80 91 03 02 	lds	r24, 0x0203
     f08:	90 91 04 02 	lds	r25, 0x0204
     f0c:	88 38       	cpi	r24, 0x88	; 136
     f0e:	93 41       	sbci	r25, 0x13	; 19
     f10:	51 f0       	breq	.+20     	; 0xf26 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     f12:	80 91 03 02 	lds	r24, 0x0203
     f16:	90 91 04 02 	lds	r25, 0x0204
     f1a:	8a 5f       	subi	r24, 0xFA	; 250
     f1c:	91 09       	sbc	r25, r1
     f1e:	90 93 04 02 	sts	0x0204, r25
     f22:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     f26:	80 91 01 02 	lds	r24, 0x0201
     f2a:	90 91 02 02 	lds	r25, 0x0202
     f2e:	88 38       	cpi	r24, 0x88	; 136
     f30:	93 41       	sbci	r25, 0x13	; 19
     f32:	51 f0       	breq	.+20     	; 0xf48 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     f34:	80 91 01 02 	lds	r24, 0x0201
     f38:	90 91 02 02 	lds	r25, 0x0202
     f3c:	8a 5f       	subi	r24, 0xFA	; 250
     f3e:	91 09       	sbc	r25, r1
     f40:	90 93 02 02 	sts	0x0202, r25
     f44:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     f48:	d0 e0       	ldi	r29, 0x00	; 0
     f4a:	80 91 03 02 	lds	r24, 0x0203
     f4e:	90 91 04 02 	lds	r25, 0x0204
     f52:	8c 17       	cp	r24, r28
     f54:	9d 07       	cpc	r25, r29
     f56:	84 f4       	brge	.+32     	; 0xf78 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     f58:	88 e8       	ldi	r24, 0x88	; 136
     f5a:	93 e1       	ldi	r25, 0x13	; 19
     f5c:	90 93 04 02 	sts	0x0204, r25
     f60:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     f64:	20 e0       	ldi	r18, 0x00	; 0
     f66:	40 e0       	ldi	r20, 0x00	; 0
     f68:	50 e0       	ldi	r21, 0x00	; 0
     f6a:	60 e0       	ldi	r22, 0x00	; 0
     f6c:	70 e0       	ldi	r23, 0x00	; 0
     f6e:	80 91 a9 08 	lds	r24, 0x08A9
     f72:	90 91 aa 08 	lds	r25, 0x08AA
     f76:	c7 d4       	rcall	.+2446   	; 0x1906 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     f78:	80 91 01 02 	lds	r24, 0x0201
     f7c:	90 91 02 02 	lds	r25, 0x0202
     f80:	8c 17       	cp	r24, r28
     f82:	9d 07       	cpc	r25, r29
     f84:	84 f4       	brge	.+32     	; 0xfa6 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     f86:	88 e8       	ldi	r24, 0x88	; 136
     f88:	93 e1       	ldi	r25, 0x13	; 19
     f8a:	90 93 02 02 	sts	0x0202, r25
     f8e:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     f92:	20 e0       	ldi	r18, 0x00	; 0
     f94:	40 e0       	ldi	r20, 0x00	; 0
     f96:	50 e0       	ldi	r21, 0x00	; 0
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	70 e0       	ldi	r23, 0x00	; 0
     f9c:	80 91 ab 08 	lds	r24, 0x08AB
     fa0:	90 91 ac 08 	lds	r25, 0x08AC
     fa4:	b0 d4       	rcall	.+2400   	; 0x1906 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     fa6:	80 91 03 02 	lds	r24, 0x0203
     faa:	90 91 04 02 	lds	r25, 0x0204
     fae:	88 38       	cpi	r24, 0x88	; 136
     fb0:	93 41       	sbci	r25, 0x13	; 19
     fb2:	79 f4       	brne	.+30     	; 0xfd2 <myTimer_DelayChecker+0xd8>
     fb4:	80 91 01 02 	lds	r24, 0x0201
     fb8:	90 91 02 02 	lds	r25, 0x0202
     fbc:	88 38       	cpi	r24, 0x88	; 136
     fbe:	93 41       	sbci	r25, 0x13	; 19
     fc0:	41 f4       	brne	.+16     	; 0xfd2 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     fc2:	e0 91 ad 08 	lds	r30, 0x08AD
     fc6:	f0 91 ae 08 	lds	r31, 0x08AE
     fca:	80 81       	ld	r24, Z
     fcc:	91 81       	ldd	r25, Z+1	; 0x01
     fce:	0e 94 75 12 	call	0x24ea	; 0x24ea <vTaskSuspend>
	}
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	08 95       	ret

00000fd8 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     fd8:	1f 92       	push	r1
     fda:	0f 92       	push	r0
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	0f 92       	push	r0
     fe0:	11 24       	eor	r1, r1
     fe2:	0b b6       	in	r0, 0x3b	; 59
     fe4:	0f 92       	push	r0
     fe6:	2f 93       	push	r18
     fe8:	3f 93       	push	r19
     fea:	4f 93       	push	r20
     fec:	5f 93       	push	r21
     fee:	6f 93       	push	r22
     ff0:	7f 93       	push	r23
     ff2:	8f 93       	push	r24
     ff4:	9f 93       	push	r25
     ff6:	af 93       	push	r26
     ff8:	bf 93       	push	r27
     ffa:	ef 93       	push	r30
     ffc:	ff 93       	push	r31
     ffe:	60 91 ce 00 	lds	r22, 0x00CE
    1002:	8e e3       	ldi	r24, 0x3E	; 62
    1004:	99 e0       	ldi	r25, 0x09	; 9
    1006:	43 d6       	rcall	.+3206   	; 0x1c8e <ringBufferPush>
    1008:	20 e0       	ldi	r18, 0x00	; 0
    100a:	40 e0       	ldi	r20, 0x00	; 0
    100c:	50 e0       	ldi	r21, 0x00	; 0
    100e:	60 e0       	ldi	r22, 0x00	; 0
    1010:	70 e0       	ldi	r23, 0x00	; 0
    1012:	80 91 24 08 	lds	r24, 0x0824
    1016:	90 91 25 08 	lds	r25, 0x0825
    101a:	33 d5       	rcall	.+2662   	; 0x1a82 <xQueueGenericSendFromISR>
    101c:	8e e3       	ldi	r24, 0x3E	; 62
    101e:	99 e0       	ldi	r25, 0x09	; 9
    1020:	4d d6       	rcall	.+3226   	; 0x1cbc <ringBufferFull>
    1022:	ff 91       	pop	r31
    1024:	ef 91       	pop	r30
    1026:	bf 91       	pop	r27
    1028:	af 91       	pop	r26
    102a:	9f 91       	pop	r25
    102c:	8f 91       	pop	r24
    102e:	7f 91       	pop	r23
    1030:	6f 91       	pop	r22
    1032:	5f 91       	pop	r21
    1034:	4f 91       	pop	r20
    1036:	3f 91       	pop	r19
    1038:	2f 91       	pop	r18
    103a:	0f 90       	pop	r0
    103c:	0b be       	out	0x3b, r0	; 59
    103e:	0f 90       	pop	r0
    1040:	0f be       	out	0x3f, r0	; 63
    1042:	0f 90       	pop	r0
    1044:	1f 90       	pop	r1
    1046:	18 95       	reti

00001048 <__vector_25>:
    1048:	1f 92       	push	r1
    104a:	0f 92       	push	r0
    104c:	0f b6       	in	r0, 0x3f	; 63
    104e:	0f 92       	push	r0
    1050:	11 24       	eor	r1, r1
    1052:	0b b6       	in	r0, 0x3b	; 59
    1054:	0f 92       	push	r0
    1056:	2f 93       	push	r18
    1058:	3f 93       	push	r19
    105a:	4f 93       	push	r20
    105c:	5f 93       	push	r21
    105e:	6f 93       	push	r22
    1060:	7f 93       	push	r23
    1062:	8f 93       	push	r24
    1064:	9f 93       	push	r25
    1066:	af 93       	push	r26
    1068:	bf 93       	push	r27
    106a:	ef 93       	push	r30
    106c:	ff 93       	push	r31
    106e:	60 91 c6 00 	lds	r22, 0x00C6
    1072:	8f ec       	ldi	r24, 0xCF	; 207
    1074:	98 e0       	ldi	r25, 0x08	; 8
    1076:	0b d6       	rcall	.+3094   	; 0x1c8e <ringBufferPush>
    1078:	20 e0       	ldi	r18, 0x00	; 0
    107a:	40 e0       	ldi	r20, 0x00	; 0
    107c:	50 e0       	ldi	r21, 0x00	; 0
    107e:	60 e0       	ldi	r22, 0x00	; 0
    1080:	70 e0       	ldi	r23, 0x00	; 0
    1082:	80 91 24 08 	lds	r24, 0x0824
    1086:	90 91 25 08 	lds	r25, 0x0825
    108a:	fb d4       	rcall	.+2550   	; 0x1a82 <xQueueGenericSendFromISR>
    108c:	8f ec       	ldi	r24, 0xCF	; 207
    108e:	98 e0       	ldi	r25, 0x08	; 8
    1090:	15 d6       	rcall	.+3114   	; 0x1cbc <ringBufferFull>
    1092:	ff 91       	pop	r31
    1094:	ef 91       	pop	r30
    1096:	bf 91       	pop	r27
    1098:	af 91       	pop	r26
    109a:	9f 91       	pop	r25
    109c:	8f 91       	pop	r24
    109e:	7f 91       	pop	r23
    10a0:	6f 91       	pop	r22
    10a2:	5f 91       	pop	r21
    10a4:	4f 91       	pop	r20
    10a6:	3f 91       	pop	r19
    10a8:	2f 91       	pop	r18
    10aa:	0f 90       	pop	r0
    10ac:	0b be       	out	0x3b, r0	; 59
    10ae:	0f 90       	pop	r0
    10b0:	0f be       	out	0x3f, r0	; 63
    10b2:	0f 90       	pop	r0
    10b4:	1f 90       	pop	r1
    10b6:	18 95       	reti

000010b8 <__vector_37>:
    10b8:	1f 92       	push	r1
    10ba:	0f 92       	push	r0
    10bc:	0f b6       	in	r0, 0x3f	; 63
    10be:	0f 92       	push	r0
    10c0:	11 24       	eor	r1, r1
    10c2:	0b b6       	in	r0, 0x3b	; 59
    10c4:	0f 92       	push	r0
    10c6:	2f 93       	push	r18
    10c8:	3f 93       	push	r19
    10ca:	4f 93       	push	r20
    10cc:	5f 93       	push	r21
    10ce:	6f 93       	push	r22
    10d0:	7f 93       	push	r23
    10d2:	8f 93       	push	r24
    10d4:	9f 93       	push	r25
    10d6:	af 93       	push	r26
    10d8:	bf 93       	push	r27
    10da:	ef 93       	push	r30
    10dc:	ff 93       	push	r31
    10de:	84 e3       	ldi	r24, 0x34	; 52
    10e0:	99 e0       	ldi	r25, 0x09	; 9
    10e2:	f3 d5       	rcall	.+3046   	; 0x1cca <ringBufferNotEmpty>
    10e4:	88 23       	and	r24, r24
    10e6:	31 f0       	breq	.+12     	; 0x10f4 <__vector_37+0x3c>
    10e8:	84 e3       	ldi	r24, 0x34	; 52
    10ea:	99 e0       	ldi	r25, 0x09	; 9
    10ec:	be d5       	rcall	.+2940   	; 0x1c6a <ringBufferPop>
    10ee:	80 93 ce 00 	sts	0x00CE, r24
    10f2:	0f c0       	rjmp	.+30     	; 0x1112 <__vector_37+0x5a>
    10f4:	e9 ec       	ldi	r30, 0xC9	; 201
    10f6:	f0 e0       	ldi	r31, 0x00	; 0
    10f8:	80 81       	ld	r24, Z
    10fa:	8f 7d       	andi	r24, 0xDF	; 223
    10fc:	80 83       	st	Z, r24
    10fe:	20 e0       	ldi	r18, 0x00	; 0
    1100:	40 e0       	ldi	r20, 0x00	; 0
    1102:	50 e0       	ldi	r21, 0x00	; 0
    1104:	60 e0       	ldi	r22, 0x00	; 0
    1106:	70 e0       	ldi	r23, 0x00	; 0
    1108:	80 91 1c 08 	lds	r24, 0x081C
    110c:	90 91 1d 08 	lds	r25, 0x081D
    1110:	b8 d4       	rcall	.+2416   	; 0x1a82 <xQueueGenericSendFromISR>
    1112:	ff 91       	pop	r31
    1114:	ef 91       	pop	r30
    1116:	bf 91       	pop	r27
    1118:	af 91       	pop	r26
    111a:	9f 91       	pop	r25
    111c:	8f 91       	pop	r24
    111e:	7f 91       	pop	r23
    1120:	6f 91       	pop	r22
    1122:	5f 91       	pop	r21
    1124:	4f 91       	pop	r20
    1126:	3f 91       	pop	r19
    1128:	2f 91       	pop	r18
    112a:	0f 90       	pop	r0
    112c:	0b be       	out	0x3b, r0	; 59
    112e:	0f 90       	pop	r0
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	0f 90       	pop	r0
    1134:	1f 90       	pop	r1
    1136:	18 95       	reti

00001138 <__vector_26>:
    1138:	1f 92       	push	r1
    113a:	0f 92       	push	r0
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	0f 92       	push	r0
    1140:	11 24       	eor	r1, r1
    1142:	0b b6       	in	r0, 0x3b	; 59
    1144:	0f 92       	push	r0
    1146:	2f 93       	push	r18
    1148:	3f 93       	push	r19
    114a:	4f 93       	push	r20
    114c:	5f 93       	push	r21
    114e:	6f 93       	push	r22
    1150:	7f 93       	push	r23
    1152:	8f 93       	push	r24
    1154:	9f 93       	push	r25
    1156:	af 93       	push	r26
    1158:	bf 93       	push	r27
    115a:	ef 93       	push	r30
    115c:	ff 93       	push	r31
    115e:	89 e3       	ldi	r24, 0x39	; 57
    1160:	99 e0       	ldi	r25, 0x09	; 9
    1162:	b3 d5       	rcall	.+2918   	; 0x1cca <ringBufferNotEmpty>
    1164:	88 23       	and	r24, r24
    1166:	31 f0       	breq	.+12     	; 0x1174 <__vector_26+0x3c>
    1168:	89 e3       	ldi	r24, 0x39	; 57
    116a:	99 e0       	ldi	r25, 0x09	; 9
    116c:	7e d5       	rcall	.+2812   	; 0x1c6a <ringBufferPop>
    116e:	80 93 c6 00 	sts	0x00C6, r24
    1172:	0f c0       	rjmp	.+30     	; 0x1192 <__vector_26+0x5a>
    1174:	e1 ec       	ldi	r30, 0xC1	; 193
    1176:	f0 e0       	ldi	r31, 0x00	; 0
    1178:	80 81       	ld	r24, Z
    117a:	8f 7d       	andi	r24, 0xDF	; 223
    117c:	80 83       	st	Z, r24
    117e:	20 e0       	ldi	r18, 0x00	; 0
    1180:	40 e0       	ldi	r20, 0x00	; 0
    1182:	50 e0       	ldi	r21, 0x00	; 0
    1184:	60 e0       	ldi	r22, 0x00	; 0
    1186:	70 e0       	ldi	r23, 0x00	; 0
    1188:	80 91 1e 08 	lds	r24, 0x081E
    118c:	90 91 1f 08 	lds	r25, 0x081F
    1190:	78 d4       	rcall	.+2288   	; 0x1a82 <xQueueGenericSendFromISR>
    1192:	ff 91       	pop	r31
    1194:	ef 91       	pop	r30
    1196:	bf 91       	pop	r27
    1198:	af 91       	pop	r26
    119a:	9f 91       	pop	r25
    119c:	8f 91       	pop	r24
    119e:	7f 91       	pop	r23
    11a0:	6f 91       	pop	r22
    11a2:	5f 91       	pop	r21
    11a4:	4f 91       	pop	r20
    11a6:	3f 91       	pop	r19
    11a8:	2f 91       	pop	r18
    11aa:	0f 90       	pop	r0
    11ac:	0b be       	out	0x3b, r0	; 59
    11ae:	0f 90       	pop	r0
    11b0:	0f be       	out	0x3f, r0	; 63
    11b2:	0f 90       	pop	r0
    11b4:	1f 90       	pop	r1
    11b6:	18 95       	reti

000011b8 <myUSART_USART0_Init>:
    11b8:	10 92 c5 00 	sts	0x00C5, r1
    11bc:	87 e6       	ldi	r24, 0x67	; 103
    11be:	80 93 c4 00 	sts	0x00C4, r24
    11c2:	88 eb       	ldi	r24, 0xB8	; 184
    11c4:	80 93 c1 00 	sts	0x00C1, r24
    11c8:	86 e0       	ldi	r24, 0x06	; 6
    11ca:	80 93 c2 00 	sts	0x00C2, r24
    11ce:	40 e2       	ldi	r20, 0x20	; 32
    11d0:	64 ef       	ldi	r22, 0xF4	; 244
    11d2:	78 e0       	ldi	r23, 0x08	; 8
    11d4:	8f ec       	ldi	r24, 0xCF	; 207
    11d6:	98 e0       	ldi	r25, 0x08	; 8
    11d8:	41 d5       	rcall	.+2690   	; 0x1c5c <ringBufferInit>
    11da:	40 e2       	ldi	r20, 0x20	; 32
    11dc:	64 ed       	ldi	r22, 0xD4	; 212
    11de:	78 e0       	ldi	r23, 0x08	; 8
    11e0:	89 e3       	ldi	r24, 0x39	; 57
    11e2:	99 e0       	ldi	r25, 0x09	; 9
    11e4:	3b d5       	rcall	.+2678   	; 0x1c5c <ringBufferInit>
    11e6:	43 e0       	ldi	r20, 0x03	; 3
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	5f d3       	rcall	.+1726   	; 0x18ac <xQueueGenericCreate>
    11ee:	90 93 23 08 	sts	0x0823, r25
    11f2:	80 93 22 08 	sts	0x0822, r24
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	19 d4       	rcall	.+2098   	; 0x1a2c <xQueueCreateMutex>
    11fa:	90 93 1f 08 	sts	0x081F, r25
    11fe:	80 93 1e 08 	sts	0x081E, r24
    1202:	08 95       	ret

00001204 <myUSART_USART1_Init>:
    1204:	10 92 cd 00 	sts	0x00CD, r1
    1208:	87 e6       	ldi	r24, 0x67	; 103
    120a:	80 93 cc 00 	sts	0x00CC, r24
    120e:	88 eb       	ldi	r24, 0xB8	; 184
    1210:	80 93 c9 00 	sts	0x00C9, r24
    1214:	86 e0       	ldi	r24, 0x06	; 6
    1216:	80 93 ca 00 	sts	0x00CA, r24
    121a:	40 e2       	ldi	r20, 0x20	; 32
    121c:	6f ea       	ldi	r22, 0xAF	; 175
    121e:	78 e0       	ldi	r23, 0x08	; 8
    1220:	8e e3       	ldi	r24, 0x3E	; 62
    1222:	99 e0       	ldi	r25, 0x09	; 9
    1224:	1b d5       	rcall	.+2614   	; 0x1c5c <ringBufferInit>
    1226:	40 e2       	ldi	r20, 0x20	; 32
    1228:	64 e1       	ldi	r22, 0x14	; 20
    122a:	79 e0       	ldi	r23, 0x09	; 9
    122c:	84 e3       	ldi	r24, 0x34	; 52
    122e:	99 e0       	ldi	r25, 0x09	; 9
    1230:	15 d5       	rcall	.+2602   	; 0x1c5c <ringBufferInit>
    1232:	43 e0       	ldi	r20, 0x03	; 3
    1234:	60 e0       	ldi	r22, 0x00	; 0
    1236:	81 e0       	ldi	r24, 0x01	; 1
    1238:	39 d3       	rcall	.+1650   	; 0x18ac <xQueueGenericCreate>
    123a:	90 93 25 08 	sts	0x0825, r25
    123e:	80 93 24 08 	sts	0x0824, r24
    1242:	43 e0       	ldi	r20, 0x03	; 3
    1244:	60 e0       	ldi	r22, 0x00	; 0
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	31 d3       	rcall	.+1634   	; 0x18ac <xQueueGenericCreate>
    124a:	90 93 21 08 	sts	0x0821, r25
    124e:	80 93 20 08 	sts	0x0820, r24
    1252:	81 e0       	ldi	r24, 0x01	; 1
    1254:	eb d3       	rcall	.+2006   	; 0x1a2c <xQueueCreateMutex>
    1256:	90 93 1d 08 	sts	0x081D, r25
    125a:	80 93 1c 08 	sts	0x081C, r24
    125e:	08 95       	ret

00001260 <myUSART_transmitUSART0_c>:
    1260:	cf 93       	push	r28
    1262:	c8 2f       	mov	r28, r24
    1264:	20 e0       	ldi	r18, 0x00	; 0
    1266:	4f ef       	ldi	r20, 0xFF	; 255
    1268:	5f ef       	ldi	r21, 0xFF	; 255
    126a:	60 e0       	ldi	r22, 0x00	; 0
    126c:	70 e0       	ldi	r23, 0x00	; 0
    126e:	80 91 1e 08 	lds	r24, 0x081E
    1272:	90 91 1f 08 	lds	r25, 0x081F
    1276:	3f d4       	rcall	.+2174   	; 0x1af6 <xQueueGenericReceive>
    1278:	89 e3       	ldi	r24, 0x39	; 57
    127a:	99 e0       	ldi	r25, 0x09	; 9
    127c:	1f d5       	rcall	.+2622   	; 0x1cbc <ringBufferFull>
    127e:	81 11       	cpse	r24, r1
    1280:	fb cf       	rjmp	.-10     	; 0x1278 <myUSART_transmitUSART0_c+0x18>
    1282:	6c 2f       	mov	r22, r28
    1284:	89 e3       	ldi	r24, 0x39	; 57
    1286:	99 e0       	ldi	r25, 0x09	; 9
    1288:	02 d5       	rcall	.+2564   	; 0x1c8e <ringBufferPush>
    128a:	e1 ec       	ldi	r30, 0xC1	; 193
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 81       	ld	r24, Z
    1290:	80 62       	ori	r24, 0x20	; 32
    1292:	80 83       	st	Z, r24
    1294:	e0 ec       	ldi	r30, 0xC0	; 192
    1296:	f0 e0       	ldi	r31, 0x00	; 0
    1298:	80 81       	ld	r24, Z
    129a:	80 64       	ori	r24, 0x40	; 64
    129c:	80 83       	st	Z, r24
    129e:	cf 91       	pop	r28
    12a0:	08 95       	ret

000012a2 <myUSART_transmitUSART1_c>:
    12a2:	cf 93       	push	r28
    12a4:	c8 2f       	mov	r28, r24
    12a6:	20 e0       	ldi	r18, 0x00	; 0
    12a8:	4f ef       	ldi	r20, 0xFF	; 255
    12aa:	5f ef       	ldi	r21, 0xFF	; 255
    12ac:	60 e0       	ldi	r22, 0x00	; 0
    12ae:	70 e0       	ldi	r23, 0x00	; 0
    12b0:	80 91 1c 08 	lds	r24, 0x081C
    12b4:	90 91 1d 08 	lds	r25, 0x081D
    12b8:	1e d4       	rcall	.+2108   	; 0x1af6 <xQueueGenericReceive>
    12ba:	84 e3       	ldi	r24, 0x34	; 52
    12bc:	99 e0       	ldi	r25, 0x09	; 9
    12be:	fe d4       	rcall	.+2556   	; 0x1cbc <ringBufferFull>
    12c0:	81 11       	cpse	r24, r1
    12c2:	fb cf       	rjmp	.-10     	; 0x12ba <myUSART_transmitUSART1_c+0x18>
    12c4:	6c 2f       	mov	r22, r28
    12c6:	84 e3       	ldi	r24, 0x34	; 52
    12c8:	99 e0       	ldi	r25, 0x09	; 9
    12ca:	e1 d4       	rcall	.+2498   	; 0x1c8e <ringBufferPush>
    12cc:	e9 ec       	ldi	r30, 0xC9	; 201
    12ce:	f0 e0       	ldi	r31, 0x00	; 0
    12d0:	80 81       	ld	r24, Z
    12d2:	80 62       	ori	r24, 0x20	; 32
    12d4:	80 83       	st	Z, r24
    12d6:	e8 ec       	ldi	r30, 0xC8	; 200
    12d8:	f0 e0       	ldi	r31, 0x00	; 0
    12da:	80 81       	ld	r24, Z
    12dc:	80 64       	ori	r24, 0x40	; 64
    12de:	80 83       	st	Z, r24
    12e0:	cf 91       	pop	r28
    12e2:	08 95       	ret

000012e4 <myUSART_transmitUSART1>:
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	ec 01       	movw	r28, r24
    12ea:	88 81       	ld	r24, Y
    12ec:	88 23       	and	r24, r24
    12ee:	29 f0       	breq	.+10     	; 0x12fa <myUSART_transmitUSART1+0x16>
    12f0:	21 96       	adiw	r28, 0x01	; 1
    12f2:	d7 df       	rcall	.-82     	; 0x12a2 <myUSART_transmitUSART1_c>
    12f4:	89 91       	ld	r24, Y+
    12f6:	81 11       	cpse	r24, r1
    12f8:	fc cf       	rjmp	.-8      	; 0x12f2 <myUSART_transmitUSART1+0xe>
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	08 95       	ret

00001300 <myUSART_transmitUSART0>:
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
    1304:	ec 01       	movw	r28, r24
    1306:	88 81       	ld	r24, Y
    1308:	88 23       	and	r24, r24
    130a:	29 f0       	breq	.+10     	; 0x1316 <myUSART_transmitUSART0+0x16>
    130c:	21 96       	adiw	r28, 0x01	; 1
    130e:	a8 df       	rcall	.-176    	; 0x1260 <myUSART_transmitUSART0_c>
    1310:	89 91       	ld	r24, Y+
    1312:	81 11       	cpse	r24, r1
    1314:	fc cf       	rjmp	.-8      	; 0x130e <myUSART_transmitUSART0+0xe>
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	08 95       	ret

0000131c <myUSART_receiveUSART1>:
    131c:	cf 93       	push	r28
    131e:	20 e0       	ldi	r18, 0x00	; 0
    1320:	4f ef       	ldi	r20, 0xFF	; 255
    1322:	5f ef       	ldi	r21, 0xFF	; 255
    1324:	60 e0       	ldi	r22, 0x00	; 0
    1326:	70 e0       	ldi	r23, 0x00	; 0
    1328:	80 91 24 08 	lds	r24, 0x0824
    132c:	90 91 25 08 	lds	r25, 0x0825
    1330:	e2 d3       	rcall	.+1988   	; 0x1af6 <xQueueGenericReceive>
    1332:	8e e3       	ldi	r24, 0x3E	; 62
    1334:	99 e0       	ldi	r25, 0x09	; 9
    1336:	99 d4       	rcall	.+2354   	; 0x1c6a <ringBufferPop>
    1338:	c8 2f       	mov	r28, r24
    133a:	8e e3       	ldi	r24, 0x3E	; 62
    133c:	99 e0       	ldi	r25, 0x09	; 9
    133e:	c5 d4       	rcall	.+2442   	; 0x1cca <ringBufferNotEmpty>
    1340:	88 23       	and	r24, r24
    1342:	51 f0       	breq	.+20     	; 0x1358 <myUSART_receiveUSART1+0x3c>
    1344:	20 e0       	ldi	r18, 0x00	; 0
    1346:	40 e0       	ldi	r20, 0x00	; 0
    1348:	50 e0       	ldi	r21, 0x00	; 0
    134a:	60 e0       	ldi	r22, 0x00	; 0
    134c:	70 e0       	ldi	r23, 0x00	; 0
    134e:	80 91 24 08 	lds	r24, 0x0824
    1352:	90 91 25 08 	lds	r25, 0x0825
    1356:	d7 d2       	rcall	.+1454   	; 0x1906 <xQueueGenericSend>
    1358:	8c 2f       	mov	r24, r28
    135a:	cf 91       	pop	r28
    135c:	08 95       	ret

0000135e <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    135e:	86 e1       	ldi	r24, 0x16	; 22
    1360:	a0 df       	rcall	.-192    	; 0x12a2 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    1362:	20 e0       	ldi	r18, 0x00	; 0
    1364:	4a ef       	ldi	r20, 0xFA	; 250
    1366:	50 e0       	ldi	r21, 0x00	; 0
    1368:	60 e0       	ldi	r22, 0x00	; 0
    136a:	70 e0       	ldi	r23, 0x00	; 0
    136c:	80 91 20 08 	lds	r24, 0x0820
    1370:	90 91 21 08 	lds	r25, 0x0821
    1374:	c0 d3       	rcall	.+1920   	; 0x1af6 <xQueueGenericReceive>
    1376:	81 30       	cpi	r24, 0x01	; 1
    1378:	21 f4       	brne	.+8      	; 0x1382 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    137a:	82 e0       	ldi	r24, 0x02	; 2
    137c:	92 df       	rcall	.-220    	; 0x12a2 <myUSART_transmitUSART1_c>
		return 1;
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	08 95       	ret
	}
	else
	{
		return 0;
    1382:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    1384:	08 95       	ret

00001386 <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    1386:	20 e0       	ldi	r18, 0x00	; 0
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	50 e0       	ldi	r21, 0x00	; 0
    138c:	60 e0       	ldi	r22, 0x00	; 0
    138e:	70 e0       	ldi	r23, 0x00	; 0
    1390:	80 91 20 08 	lds	r24, 0x0820
    1394:	90 91 21 08 	lds	r25, 0x0821
    1398:	b6 c2       	rjmp	.+1388   	; 0x1906 <xQueueGenericSend>
    139a:	08 95       	ret

0000139c <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    139c:	91 e0       	ldi	r25, 0x01	; 1
    139e:	85 30       	cpi	r24, 0x05	; 5
    13a0:	09 f0       	breq	.+2      	; 0x13a4 <myUSART_receiveHandShakeAck+0x8>
    13a2:	90 e0       	ldi	r25, 0x00	; 0
}
    13a4:	89 2f       	mov	r24, r25
    13a6:	08 95       	ret

000013a8 <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    13a8:	91 e0       	ldi	r25, 0x01	; 1
    13aa:	86 31       	cpi	r24, 0x16	; 22
    13ac:	09 f0       	breq	.+2      	; 0x13b0 <myUSART_receiveHandShakeStart+0x8>
    13ae:	90 e0       	ldi	r25, 0x00	; 0
}
    13b0:	89 2f       	mov	r24, r25
    13b2:	08 95       	ret

000013b4 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    13b4:	91 e0       	ldi	r25, 0x01	; 1
    13b6:	82 30       	cpi	r24, 0x02	; 2
    13b8:	09 f0       	breq	.+2      	; 0x13bc <myUSART_receiveHandShakeFin+0x8>
    13ba:	90 e0       	ldi	r25, 0x00	; 0
}
    13bc:	89 2f       	mov	r24, r25
    13be:	08 95       	ret

000013c0 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    13c0:	91 e0       	ldi	r25, 0x01	; 1
    13c2:	86 30       	cpi	r24, 0x06	; 6
    13c4:	09 f0       	breq	.+2      	; 0x13c8 <myUSART_receiveMessageACK+0x8>
    13c6:	90 e0       	ldi	r25, 0x00	; 0
}
    13c8:	89 2f       	mov	r24, r25
    13ca:	08 95       	ret

000013cc <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    13cc:	31 e1       	ldi	r19, 0x11	; 17
    13ce:	fc 01       	movw	r30, r24
    13d0:	30 83       	st	Z, r19
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	22 e2       	ldi	r18, 0x22	; 34
    13d6:	20 83       	st	Z, r18
    13d8:	31 97       	sbiw	r30, 0x01	; 1
    13da:	a3 e3       	ldi	r26, 0x33	; 51
    13dc:	a0 83       	st	Z, r26
    13de:	31 97       	sbiw	r30, 0x01	; 1
    13e0:	60 83       	st	Z, r22
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	70 83       	st	Z, r23
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	10 82       	st	Z, r1
    13ea:	31 97       	sbiw	r30, 0x01	; 1
    13ec:	10 82       	st	Z, r1
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	60 e8       	ldi	r22, 0x80	; 128
    13f2:	60 83       	st	Z, r22
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	10 82       	st	Z, r1
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	10 82       	st	Z, r1
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	10 82       	st	Z, r1
    1400:	31 97       	sbiw	r30, 0x01	; 1
    1402:	62 e0       	ldi	r22, 0x02	; 2
    1404:	60 83       	st	Z, r22
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	63 e0       	ldi	r22, 0x03	; 3
    140a:	60 83       	st	Z, r22
    140c:	31 97       	sbiw	r30, 0x01	; 1
    140e:	64 e0       	ldi	r22, 0x04	; 4
    1410:	60 83       	st	Z, r22
    1412:	31 97       	sbiw	r30, 0x01	; 1
    1414:	65 e0       	ldi	r22, 0x05	; 5
    1416:	60 83       	st	Z, r22
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	66 e0       	ldi	r22, 0x06	; 6
    141c:	60 83       	st	Z, r22
    141e:	31 97       	sbiw	r30, 0x01	; 1
    1420:	67 e0       	ldi	r22, 0x07	; 7
    1422:	60 83       	st	Z, r22
    1424:	31 97       	sbiw	r30, 0x01	; 1
    1426:	68 e0       	ldi	r22, 0x08	; 8
    1428:	60 83       	st	Z, r22
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	69 e0       	ldi	r22, 0x09	; 9
    142e:	60 83       	st	Z, r22
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	60 e1       	ldi	r22, 0x10	; 16
    1434:	60 83       	st	Z, r22
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	30 83       	st	Z, r19
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	32 e1       	ldi	r19, 0x12	; 18
    143e:	30 83       	st	Z, r19
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	33 e1       	ldi	r19, 0x13	; 19
    1444:	30 83       	st	Z, r19
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	34 e1       	ldi	r19, 0x14	; 20
    144a:	30 83       	st	Z, r19
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	35 e1       	ldi	r19, 0x15	; 21
    1450:	30 83       	st	Z, r19
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	36 e1       	ldi	r19, 0x16	; 22
    1456:	30 83       	st	Z, r19
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	37 e1       	ldi	r19, 0x17	; 23
    145c:	30 83       	st	Z, r19
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	38 e1       	ldi	r19, 0x18	; 24
    1462:	30 83       	st	Z, r19
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	39 e1       	ldi	r19, 0x19	; 25
    1468:	30 83       	st	Z, r19
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	30 e2       	ldi	r19, 0x20	; 32
    146e:	30 83       	st	Z, r19
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	31 e2       	ldi	r19, 0x21	; 33
    1474:	30 83       	st	Z, r19
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	20 83       	st	Z, r18
    147a:	31 97       	sbiw	r30, 0x01	; 1
    147c:	23 e2       	ldi	r18, 0x23	; 35
    147e:	20 83       	st	Z, r18
    1480:	31 97       	sbiw	r30, 0x01	; 1
    1482:	40 83       	st	Z, r20
    1484:	31 97       	sbiw	r30, 0x01	; 1
    1486:	50 83       	st	Z, r21
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	26 e2       	ldi	r18, 0x26	; 38
    148c:	20 83       	st	Z, r18
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	27 e2       	ldi	r18, 0x27	; 39
    1492:	20 83       	st	Z, r18
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	28 e2       	ldi	r18, 0x28	; 40
    1498:	20 83       	st	Z, r18
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	29 e2       	ldi	r18, 0x29	; 41
    149e:	20 83       	st	Z, r18
    14a0:	31 97       	sbiw	r30, 0x01	; 1
    14a2:	20 e3       	ldi	r18, 0x30	; 48
    14a4:	20 83       	st	Z, r18
    14a6:	31 97       	sbiw	r30, 0x01	; 1
    14a8:	21 e3       	ldi	r18, 0x31	; 49
    14aa:	20 83       	st	Z, r18
    14ac:	89 97       	sbiw	r24, 0x29	; 41
    14ae:	08 95       	ret

000014b0 <xPortStartScheduler>:
    14b0:	82 e0       	ldi	r24, 0x02	; 2
    14b2:	84 bd       	out	0x24, r24	; 36
    14b4:	16 bc       	out	0x26, r1	; 38
    14b6:	80 e3       	ldi	r24, 0x30	; 48
    14b8:	87 bd       	out	0x27, r24	; 39
    14ba:	ee e6       	ldi	r30, 0x6E	; 110
    14bc:	f0 e0       	ldi	r31, 0x00	; 0
    14be:	80 81       	ld	r24, Z
    14c0:	82 60       	ori	r24, 0x02	; 2
    14c2:	80 83       	st	Z, r24
    14c4:	83 e0       	ldi	r24, 0x03	; 3
    14c6:	85 bd       	out	0x25, r24	; 37
    14c8:	a0 91 8f 08 	lds	r26, 0x088F
    14cc:	b0 91 90 08 	lds	r27, 0x0890
    14d0:	cd 91       	ld	r28, X+
    14d2:	cd bf       	out	0x3d, r28	; 61
    14d4:	dd 91       	ld	r29, X+
    14d6:	de bf       	out	0x3e, r29	; 62
    14d8:	ff 91       	pop	r31
    14da:	ef 91       	pop	r30
    14dc:	df 91       	pop	r29
    14de:	cf 91       	pop	r28
    14e0:	bf 91       	pop	r27
    14e2:	af 91       	pop	r26
    14e4:	9f 91       	pop	r25
    14e6:	8f 91       	pop	r24
    14e8:	7f 91       	pop	r23
    14ea:	6f 91       	pop	r22
    14ec:	5f 91       	pop	r21
    14ee:	4f 91       	pop	r20
    14f0:	3f 91       	pop	r19
    14f2:	2f 91       	pop	r18
    14f4:	1f 91       	pop	r17
    14f6:	0f 91       	pop	r16
    14f8:	ff 90       	pop	r15
    14fa:	ef 90       	pop	r14
    14fc:	df 90       	pop	r13
    14fe:	cf 90       	pop	r12
    1500:	bf 90       	pop	r11
    1502:	af 90       	pop	r10
    1504:	9f 90       	pop	r9
    1506:	8f 90       	pop	r8
    1508:	7f 90       	pop	r7
    150a:	6f 90       	pop	r6
    150c:	5f 90       	pop	r5
    150e:	4f 90       	pop	r4
    1510:	3f 90       	pop	r3
    1512:	2f 90       	pop	r2
    1514:	1f 90       	pop	r1
    1516:	0f 90       	pop	r0
    1518:	0c be       	out	0x3c, r0	; 60
    151a:	0f 90       	pop	r0
    151c:	0b be       	out	0x3b, r0	; 59
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63
    1522:	0f 90       	pop	r0
    1524:	08 95       	ret
    1526:	81 e0       	ldi	r24, 0x01	; 1
    1528:	08 95       	ret

0000152a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    152a:	0f 92       	push	r0
    152c:	0f b6       	in	r0, 0x3f	; 63
    152e:	f8 94       	cli
    1530:	0f 92       	push	r0
    1532:	0b b6       	in	r0, 0x3b	; 59
    1534:	0f 92       	push	r0
    1536:	0c b6       	in	r0, 0x3c	; 60
    1538:	0f 92       	push	r0
    153a:	1f 92       	push	r1
    153c:	11 24       	eor	r1, r1
    153e:	2f 92       	push	r2
    1540:	3f 92       	push	r3
    1542:	4f 92       	push	r4
    1544:	5f 92       	push	r5
    1546:	6f 92       	push	r6
    1548:	7f 92       	push	r7
    154a:	8f 92       	push	r8
    154c:	9f 92       	push	r9
    154e:	af 92       	push	r10
    1550:	bf 92       	push	r11
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
    155c:	1f 93       	push	r17
    155e:	2f 93       	push	r18
    1560:	3f 93       	push	r19
    1562:	4f 93       	push	r20
    1564:	5f 93       	push	r21
    1566:	6f 93       	push	r22
    1568:	7f 93       	push	r23
    156a:	8f 93       	push	r24
    156c:	9f 93       	push	r25
    156e:	af 93       	push	r26
    1570:	bf 93       	push	r27
    1572:	cf 93       	push	r28
    1574:	df 93       	push	r29
    1576:	ef 93       	push	r30
    1578:	ff 93       	push	r31
    157a:	a0 91 8f 08 	lds	r26, 0x088F
    157e:	b0 91 90 08 	lds	r27, 0x0890
    1582:	0d b6       	in	r0, 0x3d	; 61
    1584:	0d 92       	st	X+, r0
    1586:	0e b6       	in	r0, 0x3e	; 62
    1588:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    158a:	51 d7       	rcall	.+3746   	; 0x242e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    158c:	a0 91 8f 08 	lds	r26, 0x088F
    1590:	b0 91 90 08 	lds	r27, 0x0890
    1594:	cd 91       	ld	r28, X+
    1596:	cd bf       	out	0x3d, r28	; 61
    1598:	dd 91       	ld	r29, X+
    159a:	de bf       	out	0x3e, r29	; 62
    159c:	ff 91       	pop	r31
    159e:	ef 91       	pop	r30
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	bf 91       	pop	r27
    15a6:	af 91       	pop	r26
    15a8:	9f 91       	pop	r25
    15aa:	8f 91       	pop	r24
    15ac:	7f 91       	pop	r23
    15ae:	6f 91       	pop	r22
    15b0:	5f 91       	pop	r21
    15b2:	4f 91       	pop	r20
    15b4:	3f 91       	pop	r19
    15b6:	2f 91       	pop	r18
    15b8:	1f 91       	pop	r17
    15ba:	0f 91       	pop	r16
    15bc:	ff 90       	pop	r15
    15be:	ef 90       	pop	r14
    15c0:	df 90       	pop	r13
    15c2:	cf 90       	pop	r12
    15c4:	bf 90       	pop	r11
    15c6:	af 90       	pop	r10
    15c8:	9f 90       	pop	r9
    15ca:	8f 90       	pop	r8
    15cc:	7f 90       	pop	r7
    15ce:	6f 90       	pop	r6
    15d0:	5f 90       	pop	r5
    15d2:	4f 90       	pop	r4
    15d4:	3f 90       	pop	r3
    15d6:	2f 90       	pop	r2
    15d8:	1f 90       	pop	r1
    15da:	0f 90       	pop	r0
    15dc:	0c be       	out	0x3c, r0	; 60
    15de:	0f 90       	pop	r0
    15e0:	0b be       	out	0x3b, r0	; 59
    15e2:	0f 90       	pop	r0
    15e4:	0f be       	out	0x3f, r0	; 63
    15e6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15e8:	08 95       	ret

000015ea <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15ea:	0f 92       	push	r0
    15ec:	0f b6       	in	r0, 0x3f	; 63
    15ee:	f8 94       	cli
    15f0:	0f 92       	push	r0
    15f2:	0b b6       	in	r0, 0x3b	; 59
    15f4:	0f 92       	push	r0
    15f6:	0c b6       	in	r0, 0x3c	; 60
    15f8:	0f 92       	push	r0
    15fa:	1f 92       	push	r1
    15fc:	11 24       	eor	r1, r1
    15fe:	2f 92       	push	r2
    1600:	3f 92       	push	r3
    1602:	4f 92       	push	r4
    1604:	5f 92       	push	r5
    1606:	6f 92       	push	r6
    1608:	7f 92       	push	r7
    160a:	8f 92       	push	r8
    160c:	9f 92       	push	r9
    160e:	af 92       	push	r10
    1610:	bf 92       	push	r11
    1612:	cf 92       	push	r12
    1614:	df 92       	push	r13
    1616:	ef 92       	push	r14
    1618:	ff 92       	push	r15
    161a:	0f 93       	push	r16
    161c:	1f 93       	push	r17
    161e:	2f 93       	push	r18
    1620:	3f 93       	push	r19
    1622:	4f 93       	push	r20
    1624:	5f 93       	push	r21
    1626:	6f 93       	push	r22
    1628:	7f 93       	push	r23
    162a:	8f 93       	push	r24
    162c:	9f 93       	push	r25
    162e:	af 93       	push	r26
    1630:	bf 93       	push	r27
    1632:	cf 93       	push	r28
    1634:	df 93       	push	r29
    1636:	ef 93       	push	r30
    1638:	ff 93       	push	r31
    163a:	a0 91 8f 08 	lds	r26, 0x088F
    163e:	b0 91 90 08 	lds	r27, 0x0890
    1642:	0d b6       	in	r0, 0x3d	; 61
    1644:	0d 92       	st	X+, r0
    1646:	0e b6       	in	r0, 0x3e	; 62
    1648:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    164a:	3b d5       	rcall	.+2678   	; 0x20c2 <xTaskIncrementTick>
    164c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    164e:	ef d6       	rcall	.+3550   	; 0x242e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1650:	a0 91 8f 08 	lds	r26, 0x088F
    1654:	b0 91 90 08 	lds	r27, 0x0890
    1658:	cd 91       	ld	r28, X+
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	dd 91       	ld	r29, X+
    165e:	de bf       	out	0x3e, r29	; 62
    1660:	ff 91       	pop	r31
    1662:	ef 91       	pop	r30
    1664:	df 91       	pop	r29
    1666:	cf 91       	pop	r28
    1668:	bf 91       	pop	r27
    166a:	af 91       	pop	r26
    166c:	9f 91       	pop	r25
    166e:	8f 91       	pop	r24
    1670:	7f 91       	pop	r23
    1672:	6f 91       	pop	r22
    1674:	5f 91       	pop	r21
    1676:	4f 91       	pop	r20
    1678:	3f 91       	pop	r19
    167a:	2f 91       	pop	r18
    167c:	1f 91       	pop	r17
    167e:	0f 91       	pop	r16
    1680:	ff 90       	pop	r15
    1682:	ef 90       	pop	r14
    1684:	df 90       	pop	r13
    1686:	cf 90       	pop	r12
    1688:	bf 90       	pop	r11
    168a:	af 90       	pop	r10
    168c:	9f 90       	pop	r9
    168e:	8f 90       	pop	r8
    1690:	7f 90       	pop	r7
    1692:	6f 90       	pop	r6
    1694:	5f 90       	pop	r5
    1696:	4f 90       	pop	r4
    1698:	3f 90       	pop	r3
    169a:	2f 90       	pop	r2
    169c:	1f 90       	pop	r1
    169e:	0f 90       	pop	r0
    16a0:	0c be       	out	0x3c, r0	; 60
    16a2:	0f 90       	pop	r0
    16a4:	0b be       	out	0x3b, r0	; 59
    16a6:	0f 90       	pop	r0
    16a8:	0f be       	out	0x3f, r0	; 63
    16aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16ac:	08 95       	ret

000016ae <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    16ae:	9d df       	rcall	.-198    	; 0x15ea <vPortYieldFromTick>
		 asm volatile ("reti");
    16b0:	18 95       	reti

000016b2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    16b2:	1f 93       	push	r17
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	ec 01       	movw	r28, r24
    16ba:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    16bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16be:	81 11       	cpse	r24, r1
    16c0:	0c c0       	rjmp	.+24     	; 0x16da <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16c2:	88 81       	ld	r24, Y
    16c4:	99 81       	ldd	r25, Y+1	; 0x01
    16c6:	89 2b       	or	r24, r25
    16c8:	09 f0       	breq	.+2      	; 0x16cc <prvCopyDataToQueue+0x1a>
    16ca:	47 c0       	rjmp	.+142    	; 0x175a <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    16cc:	8a 81       	ldd	r24, Y+2	; 0x02
    16ce:	9b 81       	ldd	r25, Y+3	; 0x03
    16d0:	0e 94 da 13 	call	0x27b4	; 0x27b4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    16d4:	1b 82       	std	Y+3, r1	; 0x03
    16d6:	1a 82       	std	Y+2, r1	; 0x02
    16d8:	47 c0       	rjmp	.+142    	; 0x1768 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    16da:	41 11       	cpse	r20, r1
    16dc:	18 c0       	rjmp	.+48     	; 0x170e <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    16de:	48 2f       	mov	r20, r24
    16e0:	50 e0       	ldi	r21, 0x00	; 0
    16e2:	8c 81       	ldd	r24, Y+4	; 0x04
    16e4:	9d 81       	ldd	r25, Y+5	; 0x05
    16e6:	0e 94 a6 17 	call	0x2f4c	; 0x2f4c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16ea:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16ec:	8c 81       	ldd	r24, Y+4	; 0x04
    16ee:	9d 81       	ldd	r25, Y+5	; 0x05
    16f0:	82 0f       	add	r24, r18
    16f2:	91 1d       	adc	r25, r1
    16f4:	9d 83       	std	Y+5, r25	; 0x05
    16f6:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16f8:	2a 81       	ldd	r18, Y+2	; 0x02
    16fa:	3b 81       	ldd	r19, Y+3	; 0x03
    16fc:	82 17       	cp	r24, r18
    16fe:	93 07       	cpc	r25, r19
    1700:	70 f1       	brcs	.+92     	; 0x175e <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1702:	88 81       	ld	r24, Y
    1704:	99 81       	ldd	r25, Y+1	; 0x01
    1706:	9d 83       	std	Y+5, r25	; 0x05
    1708:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    170a:	80 e0       	ldi	r24, 0x00	; 0
    170c:	2d c0       	rjmp	.+90     	; 0x1768 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    170e:	48 2f       	mov	r20, r24
    1710:	50 e0       	ldi	r21, 0x00	; 0
    1712:	8e 81       	ldd	r24, Y+6	; 0x06
    1714:	9f 81       	ldd	r25, Y+7	; 0x07
    1716:	0e 94 a6 17 	call	0x2f4c	; 0x2f4c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    171a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    171c:	30 e0       	ldi	r19, 0x00	; 0
    171e:	31 95       	neg	r19
    1720:	21 95       	neg	r18
    1722:	31 09       	sbc	r19, r1
    1724:	8e 81       	ldd	r24, Y+6	; 0x06
    1726:	9f 81       	ldd	r25, Y+7	; 0x07
    1728:	82 0f       	add	r24, r18
    172a:	93 1f       	adc	r25, r19
    172c:	9f 83       	std	Y+7, r25	; 0x07
    172e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1730:	68 81       	ld	r22, Y
    1732:	79 81       	ldd	r23, Y+1	; 0x01
    1734:	86 17       	cp	r24, r22
    1736:	97 07       	cpc	r25, r23
    1738:	30 f4       	brcc	.+12     	; 0x1746 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    173a:	8a 81       	ldd	r24, Y+2	; 0x02
    173c:	9b 81       	ldd	r25, Y+3	; 0x03
    173e:	28 0f       	add	r18, r24
    1740:	39 1f       	adc	r19, r25
    1742:	3f 83       	std	Y+7, r19	; 0x07
    1744:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1746:	12 30       	cpi	r17, 0x02	; 2
    1748:	61 f4       	brne	.+24     	; 0x1762 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    174a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    174c:	88 23       	and	r24, r24
    174e:	59 f0       	breq	.+22     	; 0x1766 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1750:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1752:	81 50       	subi	r24, 0x01	; 1
    1754:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1756:	80 e0       	ldi	r24, 0x00	; 0
    1758:	07 c0       	rjmp	.+14     	; 0x1768 <prvCopyDataToQueue+0xb6>
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	05 c0       	rjmp	.+10     	; 0x1768 <prvCopyDataToQueue+0xb6>
    175e:	80 e0       	ldi	r24, 0x00	; 0
    1760:	03 c0       	rjmp	.+6      	; 0x1768 <prvCopyDataToQueue+0xb6>
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	01 c0       	rjmp	.+2      	; 0x1768 <prvCopyDataToQueue+0xb6>
    1766:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1768:	9a 8d       	ldd	r25, Y+26	; 0x1a
    176a:	9f 5f       	subi	r25, 0xFF	; 255
    176c:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    176e:	df 91       	pop	r29
    1770:	cf 91       	pop	r28
    1772:	1f 91       	pop	r17
    1774:	08 95       	ret

00001776 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1776:	fc 01       	movw	r30, r24
    1778:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    177a:	44 8d       	ldd	r20, Z+28	; 0x1c
    177c:	44 23       	and	r20, r20
    177e:	a1 f0       	breq	.+40     	; 0x17a8 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1780:	50 e0       	ldi	r21, 0x00	; 0
    1782:	26 81       	ldd	r18, Z+6	; 0x06
    1784:	37 81       	ldd	r19, Z+7	; 0x07
    1786:	24 0f       	add	r18, r20
    1788:	35 1f       	adc	r19, r21
    178a:	37 83       	std	Z+7, r19	; 0x07
    178c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    178e:	62 81       	ldd	r22, Z+2	; 0x02
    1790:	73 81       	ldd	r23, Z+3	; 0x03
    1792:	26 17       	cp	r18, r22
    1794:	37 07       	cpc	r19, r23
    1796:	20 f0       	brcs	.+8      	; 0x17a0 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1798:	20 81       	ld	r18, Z
    179a:	31 81       	ldd	r19, Z+1	; 0x01
    179c:	37 83       	std	Z+7, r19	; 0x07
    179e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    17a0:	66 81       	ldd	r22, Z+6	; 0x06
    17a2:	77 81       	ldd	r23, Z+7	; 0x07
    17a4:	0c 94 a6 17 	jmp	0x2f4c	; 0x2f4c <memcpy>
    17a8:	08 95       	ret

000017aa <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    17aa:	0f 93       	push	r16
    17ac:	1f 93       	push	r17
    17ae:	cf 93       	push	r28
    17b0:	df 93       	push	r29
    17b2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    17b4:	0f b6       	in	r0, 0x3f	; 63
    17b6:	f8 94       	cli
    17b8:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17bc:	18 16       	cp	r1, r24
    17be:	a4 f4       	brge	.+40     	; 0x17e8 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17c0:	89 89       	ldd	r24, Y+17	; 0x11
    17c2:	88 23       	and	r24, r24
    17c4:	89 f0       	breq	.+34     	; 0x17e8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17c6:	8e 01       	movw	r16, r28
    17c8:	0f 5e       	subi	r16, 0xEF	; 239
    17ca:	1f 4f       	sbci	r17, 0xFF	; 255
    17cc:	03 c0       	rjmp	.+6      	; 0x17d4 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ce:	89 89       	ldd	r24, Y+17	; 0x11
    17d0:	88 23       	and	r24, r24
    17d2:	51 f0       	breq	.+20     	; 0x17e8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17d4:	c8 01       	movw	r24, r16
    17d6:	01 d7       	rcall	.+3586   	; 0x25da <xTaskRemoveFromEventList>
    17d8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    17da:	8a d7       	rcall	.+3860   	; 0x26f0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    17dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17de:	81 50       	subi	r24, 0x01	; 1
    17e0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17e4:	18 16       	cp	r1, r24
    17e6:	9c f3       	brlt	.-26     	; 0x17ce <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17e8:	8f ef       	ldi	r24, 0xFF	; 255
    17ea:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17f0:	0f b6       	in	r0, 0x3f	; 63
    17f2:	f8 94       	cli
    17f4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17f8:	18 16       	cp	r1, r24
    17fa:	a4 f4       	brge	.+40     	; 0x1824 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17fc:	88 85       	ldd	r24, Y+8	; 0x08
    17fe:	88 23       	and	r24, r24
    1800:	89 f0       	breq	.+34     	; 0x1824 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1802:	8e 01       	movw	r16, r28
    1804:	08 5f       	subi	r16, 0xF8	; 248
    1806:	1f 4f       	sbci	r17, 0xFF	; 255
    1808:	03 c0       	rjmp	.+6      	; 0x1810 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    180a:	88 85       	ldd	r24, Y+8	; 0x08
    180c:	88 23       	and	r24, r24
    180e:	51 f0       	breq	.+20     	; 0x1824 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1810:	c8 01       	movw	r24, r16
    1812:	e3 d6       	rcall	.+3526   	; 0x25da <xTaskRemoveFromEventList>
    1814:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1816:	6c d7       	rcall	.+3800   	; 0x26f0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1818:	8d 8d       	ldd	r24, Y+29	; 0x1d
    181a:	81 50       	subi	r24, 0x01	; 1
    181c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    181e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1820:	18 16       	cp	r1, r24
    1822:	9c f3       	brlt	.-26     	; 0x180a <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1824:	8f ef       	ldi	r24, 0xFF	; 255
    1826:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1828:	0f 90       	pop	r0
    182a:	0f be       	out	0x3f, r0	; 63
}
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	1f 91       	pop	r17
    1832:	0f 91       	pop	r16
    1834:	08 95       	ret

00001836 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1836:	cf 93       	push	r28
    1838:	df 93       	push	r29
    183a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    183c:	0f b6       	in	r0, 0x3f	; 63
    183e:	f8 94       	cli
    1840:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1842:	88 81       	ld	r24, Y
    1844:	99 81       	ldd	r25, Y+1	; 0x01
    1846:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1848:	30 e0       	ldi	r19, 0x00	; 0
    184a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    184c:	72 9f       	mul	r23, r18
    184e:	a0 01       	movw	r20, r0
    1850:	73 9f       	mul	r23, r19
    1852:	50 0d       	add	r21, r0
    1854:	11 24       	eor	r1, r1
    1856:	fc 01       	movw	r30, r24
    1858:	e4 0f       	add	r30, r20
    185a:	f5 1f       	adc	r31, r21
    185c:	fb 83       	std	Y+3, r31	; 0x03
    185e:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1860:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1862:	9d 83       	std	Y+5, r25	; 0x05
    1864:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1866:	42 1b       	sub	r20, r18
    1868:	53 0b       	sbc	r21, r19
    186a:	84 0f       	add	r24, r20
    186c:	95 1f       	adc	r25, r21
    186e:	9f 83       	std	Y+7, r25	; 0x07
    1870:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1872:	8f ef       	ldi	r24, 0xFF	; 255
    1874:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1876:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1878:	61 11       	cpse	r22, r1
    187a:	0a c0       	rjmp	.+20     	; 0x1890 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    187c:	88 85       	ldd	r24, Y+8	; 0x08
    187e:	88 23       	and	r24, r24
    1880:	79 f0       	breq	.+30     	; 0x18a0 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1882:	ce 01       	movw	r24, r28
    1884:	08 96       	adiw	r24, 0x08	; 8
    1886:	a9 d6       	rcall	.+3410   	; 0x25da <xTaskRemoveFromEventList>
    1888:	81 30       	cpi	r24, 0x01	; 1
    188a:	51 f4       	brne	.+20     	; 0x18a0 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    188c:	4e de       	rcall	.-868    	; 0x152a <vPortYield>
    188e:	08 c0       	rjmp	.+16     	; 0x18a0 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1890:	ce 01       	movw	r24, r28
    1892:	08 96       	adiw	r24, 0x08	; 8
    1894:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1898:	ce 01       	movw	r24, r28
    189a:	41 96       	adiw	r24, 0x11	; 17
    189c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    18a0:	0f 90       	pop	r0
    18a2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    18a4:	81 e0       	ldi	r24, 0x01	; 1
    18a6:	df 91       	pop	r29
    18a8:	cf 91       	pop	r28
    18aa:	08 95       	ret

000018ac <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    18ac:	0f 93       	push	r16
    18ae:	1f 93       	push	r17
    18b0:	cf 93       	push	r28
    18b2:	df 93       	push	r29
    18b4:	18 2f       	mov	r17, r24
    18b6:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    18b8:	88 23       	and	r24, r24
    18ba:	e9 f0       	breq	.+58     	; 0x18f6 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    18bc:	8f e1       	ldi	r24, 0x1F	; 31
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    18c4:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	c1 f0       	breq	.+48     	; 0x18fa <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18ca:	10 9f       	mul	r17, r16
    18cc:	c0 01       	movw	r24, r0
    18ce:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    18d0:	01 96       	adiw	r24, 0x01	; 1
    18d2:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    18d6:	99 83       	std	Y+1, r25	; 0x01
    18d8:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    18da:	89 2b       	or	r24, r25
    18dc:	31 f0       	breq	.+12     	; 0x18ea <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    18de:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    18e0:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    18e2:	61 e0       	ldi	r22, 0x01	; 1
    18e4:	ce 01       	movw	r24, r28
    18e6:	a7 df       	rcall	.-178    	; 0x1836 <xQueueGenericReset>
    18e8:	08 c0       	rjmp	.+16     	; 0x18fa <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    18ea:	ce 01       	movw	r24, r28
    18ec:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    18f0:	c0 e0       	ldi	r28, 0x00	; 0
    18f2:	d0 e0       	ldi	r29, 0x00	; 0
    18f4:	02 c0       	rjmp	.+4      	; 0x18fa <xQueueGenericCreate+0x4e>
    18f6:	c0 e0       	ldi	r28, 0x00	; 0
    18f8:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    18fa:	ce 01       	movw	r24, r28
    18fc:	df 91       	pop	r29
    18fe:	cf 91       	pop	r28
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	08 95       	ret

00001906 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1906:	9f 92       	push	r9
    1908:	af 92       	push	r10
    190a:	bf 92       	push	r11
    190c:	cf 92       	push	r12
    190e:	df 92       	push	r13
    1910:	ef 92       	push	r14
    1912:	ff 92       	push	r15
    1914:	0f 93       	push	r16
    1916:	1f 93       	push	r17
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	00 d0       	rcall	.+0      	; 0x191e <xQueueGenericSend+0x18>
    191e:	1f 92       	push	r1
    1920:	1f 92       	push	r1
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	8c 01       	movw	r16, r24
    1928:	6b 01       	movw	r12, r22
    192a:	5d 83       	std	Y+5, r21	; 0x05
    192c:	4c 83       	std	Y+4, r20	; 0x04
    192e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1930:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1932:	99 24       	eor	r9, r9
    1934:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1936:	7c 01       	movw	r14, r24
    1938:	88 e0       	ldi	r24, 0x08	; 8
    193a:	e8 0e       	add	r14, r24
    193c:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    193e:	0f b6       	in	r0, 0x3f	; 63
    1940:	f8 94       	cli
    1942:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1944:	f8 01       	movw	r30, r16
    1946:	92 8d       	ldd	r25, Z+26	; 0x1a
    1948:	83 8d       	ldd	r24, Z+27	; 0x1b
    194a:	98 17       	cp	r25, r24
    194c:	18 f0       	brcs	.+6      	; 0x1954 <xQueueGenericSend+0x4e>
    194e:	f2 e0       	ldi	r31, 0x02	; 2
    1950:	af 12       	cpse	r10, r31
    1952:	15 c0       	rjmp	.+42     	; 0x197e <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1954:	4a 2d       	mov	r20, r10
    1956:	b6 01       	movw	r22, r12
    1958:	c8 01       	movw	r24, r16
    195a:	ab de       	rcall	.-682    	; 0x16b2 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    195c:	f8 01       	movw	r30, r16
    195e:	91 89       	ldd	r25, Z+17	; 0x11
    1960:	99 23       	and	r25, r25
    1962:	39 f0       	breq	.+14     	; 0x1972 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1964:	c8 01       	movw	r24, r16
    1966:	41 96       	adiw	r24, 0x11	; 17
    1968:	38 d6       	rcall	.+3184   	; 0x25da <xTaskRemoveFromEventList>
    196a:	81 30       	cpi	r24, 0x01	; 1
    196c:	21 f4       	brne	.+8      	; 0x1976 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    196e:	dd dd       	rcall	.-1094   	; 0x152a <vPortYield>
    1970:	02 c0       	rjmp	.+4      	; 0x1976 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1972:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1974:	da dd       	rcall	.-1100   	; 0x152a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	46 c0       	rjmp	.+140    	; 0x1a0a <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    197e:	ec 81       	ldd	r30, Y+4	; 0x04
    1980:	fd 81       	ldd	r31, Y+5	; 0x05
    1982:	ef 2b       	or	r30, r31
    1984:	21 f4       	brne	.+8      	; 0x198e <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	3e c0       	rjmp	.+124    	; 0x1a0a <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    198e:	b1 10       	cpse	r11, r1
    1990:	04 c0       	rjmp	.+8      	; 0x199a <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1992:	ce 01       	movw	r24, r28
    1994:	01 96       	adiw	r24, 0x01	; 1
    1996:	69 d6       	rcall	.+3282   	; 0x266a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1998:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    199a:	0f 90       	pop	r0
    199c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    199e:	7c d3       	rcall	.+1784   	; 0x2098 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	0f 92       	push	r0
    19a6:	f8 01       	movw	r30, r16
    19a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    19aa:	8f 3f       	cpi	r24, 0xFF	; 255
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <xQueueGenericSend+0xaa>
    19ae:	15 8e       	std	Z+29, r1	; 0x1d
    19b0:	f8 01       	movw	r30, r16
    19b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    19b4:	8f 3f       	cpi	r24, 0xFF	; 255
    19b6:	09 f4       	brne	.+2      	; 0x19ba <xQueueGenericSend+0xb4>
    19b8:	16 8e       	std	Z+30, r1	; 0x1e
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19be:	be 01       	movw	r22, r28
    19c0:	6c 5f       	subi	r22, 0xFC	; 252
    19c2:	7f 4f       	sbci	r23, 0xFF	; 255
    19c4:	ce 01       	movw	r24, r28
    19c6:	01 96       	adiw	r24, 0x01	; 1
    19c8:	5b d6       	rcall	.+3254   	; 0x2680 <xTaskCheckForTimeOut>
    19ca:	81 11       	cpse	r24, r1
    19cc:	1a c0       	rjmp	.+52     	; 0x1a02 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19ce:	0f b6       	in	r0, 0x3f	; 63
    19d0:	f8 94       	cli
    19d2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19d4:	f8 01       	movw	r30, r16
    19d6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19d8:	0f 90       	pop	r0
    19da:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19dc:	f8 01       	movw	r30, r16
    19de:	83 8d       	ldd	r24, Z+27	; 0x1b
    19e0:	98 13       	cpse	r25, r24
    19e2:	0b c0       	rjmp	.+22     	; 0x19fa <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19e4:	6c 81       	ldd	r22, Y+4	; 0x04
    19e6:	7d 81       	ldd	r23, Y+5	; 0x05
    19e8:	c7 01       	movw	r24, r14
    19ea:	cc d5       	rcall	.+2968   	; 0x2584 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    19ec:	c8 01       	movw	r24, r16
    19ee:	dd de       	rcall	.-582    	; 0x17aa <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    19f0:	26 d4       	rcall	.+2124   	; 0x223e <xTaskResumeAll>
    19f2:	81 11       	cpse	r24, r1
    19f4:	a4 cf       	rjmp	.-184    	; 0x193e <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    19f6:	99 dd       	rcall	.-1230   	; 0x152a <vPortYield>
    19f8:	a2 cf       	rjmp	.-188    	; 0x193e <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19fa:	c8 01       	movw	r24, r16
    19fc:	d6 de       	rcall	.-596    	; 0x17aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19fe:	1f d4       	rcall	.+2110   	; 0x223e <xTaskResumeAll>
    1a00:	9e cf       	rjmp	.-196    	; 0x193e <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1a02:	c8 01       	movw	r24, r16
    1a04:	d2 de       	rcall	.-604    	; 0x17aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a06:	1b d4       	rcall	.+2102   	; 0x223e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1a08:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1a0a:	0f 90       	pop	r0
    1a0c:	0f 90       	pop	r0
    1a0e:	0f 90       	pop	r0
    1a10:	0f 90       	pop	r0
    1a12:	0f 90       	pop	r0
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	1f 91       	pop	r17
    1a1a:	0f 91       	pop	r16
    1a1c:	ff 90       	pop	r15
    1a1e:	ef 90       	pop	r14
    1a20:	df 90       	pop	r13
    1a22:	cf 90       	pop	r12
    1a24:	bf 90       	pop	r11
    1a26:	af 90       	pop	r10
    1a28:	9f 90       	pop	r9
    1a2a:	08 95       	ret

00001a2c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1a30:	8f e1       	ldi	r24, 0x1F	; 31
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    1a38:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1a3a:	00 97       	sbiw	r24, 0x00	; 0
    1a3c:	f1 f0       	breq	.+60     	; 0x1a7a <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1a3e:	1b 82       	std	Y+3, r1	; 0x03
    1a40:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1a42:	19 82       	std	Y+1, r1	; 0x01
    1a44:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1a46:	1d 82       	std	Y+5, r1	; 0x05
    1a48:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1a4a:	1f 82       	std	Y+7, r1	; 0x07
    1a4c:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1a4e:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1a50:	81 e0       	ldi	r24, 0x01	; 1
    1a52:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1a54:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1a56:	8f ef       	ldi	r24, 0xFF	; 255
    1a58:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1a5a:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1a5c:	ce 01       	movw	r24, r28
    1a5e:	08 96       	adiw	r24, 0x08	; 8
    1a60:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1a64:	ce 01       	movw	r24, r28
    1a66:	41 96       	adiw	r24, 0x11	; 17
    1a68:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1a6c:	20 e0       	ldi	r18, 0x00	; 0
    1a6e:	40 e0       	ldi	r20, 0x00	; 0
    1a70:	50 e0       	ldi	r21, 0x00	; 0
    1a72:	60 e0       	ldi	r22, 0x00	; 0
    1a74:	70 e0       	ldi	r23, 0x00	; 0
    1a76:	ce 01       	movw	r24, r28
    1a78:	46 df       	rcall	.-372    	; 0x1906 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1a7a:	ce 01       	movw	r24, r28
    1a7c:	df 91       	pop	r29
    1a7e:	cf 91       	pop	r28
    1a80:	08 95       	ret

00001a82 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a82:	0f 93       	push	r16
    1a84:	1f 93       	push	r17
    1a86:	cf 93       	push	r28
    1a88:	df 93       	push	r29
    1a8a:	ec 01       	movw	r28, r24
    1a8c:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a8e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a90:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a92:	98 17       	cp	r25, r24
    1a94:	10 f0       	brcs	.+4      	; 0x1a9a <xQueueGenericSendFromISR+0x18>
    1a96:	22 30       	cpi	r18, 0x02	; 2
    1a98:	11 f5       	brne	.+68     	; 0x1ade <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a9a:	42 2f       	mov	r20, r18
    1a9c:	ce 01       	movw	r24, r28
    1a9e:	09 de       	rcall	.-1006   	; 0x16b2 <prvCopyDataToQueue>
    1aa0:	88 23       	and	r24, r24
    1aa2:	31 f0       	breq	.+12     	; 0x1ab0 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1aa4:	01 15       	cp	r16, r1
    1aa6:	11 05       	cpc	r17, r1
    1aa8:	19 f0       	breq	.+6      	; 0x1ab0 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1aaa:	81 e0       	ldi	r24, 0x01	; 1
    1aac:	f8 01       	movw	r30, r16
    1aae:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ab0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ab2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab4:	79 f4       	brne	.+30     	; 0x1ad4 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ab6:	89 89       	ldd	r24, Y+17	; 0x11
    1ab8:	88 23       	and	r24, r24
    1aba:	99 f0       	breq	.+38     	; 0x1ae2 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1abc:	ce 01       	movw	r24, r28
    1abe:	41 96       	adiw	r24, 0x11	; 17
    1ac0:	8c d5       	rcall	.+2840   	; 0x25da <xTaskRemoveFromEventList>
    1ac2:	88 23       	and	r24, r24
    1ac4:	81 f0       	breq	.+32     	; 0x1ae6 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1ac6:	01 15       	cp	r16, r1
    1ac8:	11 05       	cpc	r17, r1
    1aca:	79 f0       	breq	.+30     	; 0x1aea <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	f8 01       	movw	r30, r16
    1ad0:	80 83       	st	Z, r24
    1ad2:	0c c0       	rjmp	.+24     	; 0x1aec <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1ad4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ad6:	8f 5f       	subi	r24, 0xFF	; 255
    1ad8:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	07 c0       	rjmp	.+14     	; 0x1aec <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	05 c0       	rjmp	.+10     	; 0x1aec <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	03 c0       	rjmp	.+6      	; 0x1aec <xQueueGenericSendFromISR+0x6a>
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	01 c0       	rjmp	.+2      	; 0x1aec <xQueueGenericSendFromISR+0x6a>
    1aea:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1aec:	df 91       	pop	r29
    1aee:	cf 91       	pop	r28
    1af0:	1f 91       	pop	r17
    1af2:	0f 91       	pop	r16
    1af4:	08 95       	ret

00001af6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1af6:	9f 92       	push	r9
    1af8:	af 92       	push	r10
    1afa:	bf 92       	push	r11
    1afc:	cf 92       	push	r12
    1afe:	df 92       	push	r13
    1b00:	ef 92       	push	r14
    1b02:	ff 92       	push	r15
    1b04:	0f 93       	push	r16
    1b06:	1f 93       	push	r17
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
    1b0c:	00 d0       	rcall	.+0      	; 0x1b0e <xQueueGenericReceive+0x18>
    1b0e:	1f 92       	push	r1
    1b10:	1f 92       	push	r1
    1b12:	cd b7       	in	r28, 0x3d	; 61
    1b14:	de b7       	in	r29, 0x3e	; 62
    1b16:	8c 01       	movw	r16, r24
    1b18:	6b 01       	movw	r12, r22
    1b1a:	5d 83       	std	Y+5, r21	; 0x05
    1b1c:	4c 83       	std	Y+4, r20	; 0x04
    1b1e:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1b20:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1b22:	99 24       	eor	r9, r9
    1b24:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b26:	7c 01       	movw	r14, r24
    1b28:	81 e1       	ldi	r24, 0x11	; 17
    1b2a:	e8 0e       	add	r14, r24
    1b2c:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b2e:	0f b6       	in	r0, 0x3f	; 63
    1b30:	f8 94       	cli
    1b32:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b34:	f8 01       	movw	r30, r16
    1b36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b38:	88 23       	and	r24, r24
    1b3a:	69 f1       	breq	.+90     	; 0x1b96 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b3c:	e6 80       	ldd	r14, Z+6	; 0x06
    1b3e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b40:	b6 01       	movw	r22, r12
    1b42:	c8 01       	movw	r24, r16
    1b44:	18 de       	rcall	.-976    	; 0x1776 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b46:	b1 10       	cpse	r11, r1
    1b48:	17 c0       	rjmp	.+46     	; 0x1b78 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4e:	81 50       	subi	r24, 0x01	; 1
    1b50:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b52:	80 81       	ld	r24, Z
    1b54:	91 81       	ldd	r25, Z+1	; 0x01
    1b56:	89 2b       	or	r24, r25
    1b58:	21 f4       	brne	.+8      	; 0x1b62 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1b5a:	6b d6       	rcall	.+3286   	; 0x2832 <pvTaskIncrementMutexHeldCount>
    1b5c:	f8 01       	movw	r30, r16
    1b5e:	93 83       	std	Z+3, r25	; 0x03
    1b60:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b62:	f8 01       	movw	r30, r16
    1b64:	80 85       	ldd	r24, Z+8	; 0x08
    1b66:	88 23       	and	r24, r24
    1b68:	91 f0       	breq	.+36     	; 0x1b8e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b6a:	c8 01       	movw	r24, r16
    1b6c:	08 96       	adiw	r24, 0x08	; 8
    1b6e:	35 d5       	rcall	.+2666   	; 0x25da <xTaskRemoveFromEventList>
    1b70:	81 30       	cpi	r24, 0x01	; 1
    1b72:	69 f4       	brne	.+26     	; 0x1b8e <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b74:	da dc       	rcall	.-1612   	; 0x152a <vPortYield>
    1b76:	0b c0       	rjmp	.+22     	; 0x1b8e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b78:	f8 01       	movw	r30, r16
    1b7a:	f7 82       	std	Z+7, r15	; 0x07
    1b7c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b7e:	81 89       	ldd	r24, Z+17	; 0x11
    1b80:	88 23       	and	r24, r24
    1b82:	29 f0       	breq	.+10     	; 0x1b8e <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b84:	c8 01       	movw	r24, r16
    1b86:	41 96       	adiw	r24, 0x11	; 17
    1b88:	28 d5       	rcall	.+2640   	; 0x25da <xTaskRemoveFromEventList>
    1b8a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b8c:	ce dc       	rcall	.-1636   	; 0x152a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	52 c0       	rjmp	.+164    	; 0x1c3a <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b96:	4c 81       	ldd	r20, Y+4	; 0x04
    1b98:	5d 81       	ldd	r21, Y+5	; 0x05
    1b9a:	45 2b       	or	r20, r21
    1b9c:	21 f4       	brne	.+8      	; 0x1ba6 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b9e:	0f 90       	pop	r0
    1ba0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ba2:	80 e0       	ldi	r24, 0x00	; 0
    1ba4:	4a c0       	rjmp	.+148    	; 0x1c3a <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ba6:	a1 10       	cpse	r10, r1
    1ba8:	04 c0       	rjmp	.+8      	; 0x1bb2 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1baa:	ce 01       	movw	r24, r28
    1bac:	01 96       	adiw	r24, 0x01	; 1
    1bae:	5d d5       	rcall	.+2746   	; 0x266a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1bb0:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1bb2:	0f 90       	pop	r0
    1bb4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1bb6:	70 d2       	rcall	.+1248   	; 0x2098 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1bb8:	0f b6       	in	r0, 0x3f	; 63
    1bba:	f8 94       	cli
    1bbc:	0f 92       	push	r0
    1bbe:	f8 01       	movw	r30, r16
    1bc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc4:	09 f4       	brne	.+2      	; 0x1bc8 <xQueueGenericReceive+0xd2>
    1bc6:	15 8e       	std	Z+29, r1	; 0x1d
    1bc8:	f8 01       	movw	r30, r16
    1bca:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1bce:	09 f4       	brne	.+2      	; 0x1bd2 <xQueueGenericReceive+0xdc>
    1bd0:	16 8e       	std	Z+30, r1	; 0x1e
    1bd2:	0f 90       	pop	r0
    1bd4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bd6:	be 01       	movw	r22, r28
    1bd8:	6c 5f       	subi	r22, 0xFC	; 252
    1bda:	7f 4f       	sbci	r23, 0xFF	; 255
    1bdc:	ce 01       	movw	r24, r28
    1bde:	01 96       	adiw	r24, 0x01	; 1
    1be0:	4f d5       	rcall	.+2718   	; 0x2680 <xTaskCheckForTimeOut>
    1be2:	81 11       	cpse	r24, r1
    1be4:	26 c0       	rjmp	.+76     	; 0x1c32 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1bec:	f8 01       	movw	r30, r16
    1bee:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1bf0:	0f 90       	pop	r0
    1bf2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bf4:	81 11       	cpse	r24, r1
    1bf6:	19 c0       	rjmp	.+50     	; 0x1c2a <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1bf8:	f8 01       	movw	r30, r16
    1bfa:	80 81       	ld	r24, Z
    1bfc:	91 81       	ldd	r25, Z+1	; 0x01
    1bfe:	89 2b       	or	r24, r25
    1c00:	49 f4       	brne	.+18     	; 0x1c14 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1c08:	f8 01       	movw	r30, r16
    1c0a:	82 81       	ldd	r24, Z+2	; 0x02
    1c0c:	93 81       	ldd	r25, Z+3	; 0x03
    1c0e:	74 d5       	rcall	.+2792   	; 0x26f8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1c10:	0f 90       	pop	r0
    1c12:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c14:	6c 81       	ldd	r22, Y+4	; 0x04
    1c16:	7d 81       	ldd	r23, Y+5	; 0x05
    1c18:	c7 01       	movw	r24, r14
    1c1a:	b4 d4       	rcall	.+2408   	; 0x2584 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c1c:	c8 01       	movw	r24, r16
    1c1e:	c5 dd       	rcall	.-1142   	; 0x17aa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c20:	0e d3       	rcall	.+1564   	; 0x223e <xTaskResumeAll>
    1c22:	81 11       	cpse	r24, r1
    1c24:	84 cf       	rjmp	.-248    	; 0x1b2e <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1c26:	81 dc       	rcall	.-1790   	; 0x152a <vPortYield>
    1c28:	82 cf       	rjmp	.-252    	; 0x1b2e <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c2a:	c8 01       	movw	r24, r16
    1c2c:	be dd       	rcall	.-1156   	; 0x17aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c2e:	07 d3       	rcall	.+1550   	; 0x223e <xTaskResumeAll>
    1c30:	7e cf       	rjmp	.-260    	; 0x1b2e <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c32:	c8 01       	movw	r24, r16
    1c34:	ba dd       	rcall	.-1164   	; 0x17aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c36:	03 d3       	rcall	.+1542   	; 0x223e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c38:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1c3a:	0f 90       	pop	r0
    1c3c:	0f 90       	pop	r0
    1c3e:	0f 90       	pop	r0
    1c40:	0f 90       	pop	r0
    1c42:	0f 90       	pop	r0
    1c44:	df 91       	pop	r29
    1c46:	cf 91       	pop	r28
    1c48:	1f 91       	pop	r17
    1c4a:	0f 91       	pop	r16
    1c4c:	ff 90       	pop	r15
    1c4e:	ef 90       	pop	r14
    1c50:	df 90       	pop	r13
    1c52:	cf 90       	pop	r12
    1c54:	bf 90       	pop	r11
    1c56:	af 90       	pop	r10
    1c58:	9f 90       	pop	r9
    1c5a:	08 95       	ret

00001c5c <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	71 83       	std	Z+1, r23	; 0x01
    1c60:	60 83       	st	Z, r22
    1c62:	42 83       	std	Z+2, r20	; 0x02
    1c64:	14 82       	std	Z+4, r1	; 0x04
    1c66:	13 82       	std	Z+3, r1	; 0x03
    1c68:	08 95       	ret

00001c6a <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1c6a:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1c6c:	94 81       	ldd	r25, Z+4	; 0x04
    1c6e:	a0 81       	ld	r26, Z
    1c70:	b1 81       	ldd	r27, Z+1	; 0x01
    1c72:	a9 0f       	add	r26, r25
    1c74:	b1 1d       	adc	r27, r1
    1c76:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1c78:	9f 5f       	subi	r25, 0xFF	; 255
    1c7a:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1c7c:	22 81       	ldd	r18, Z+2	; 0x02
    1c7e:	92 17       	cp	r25, r18
    1c80:	10 f0       	brcs	.+4      	; 0x1c86 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1c82:	92 1b       	sub	r25, r18
    1c84:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c86:	93 81       	ldd	r25, Z+3	; 0x03
    1c88:	91 50       	subi	r25, 0x01	; 1
    1c8a:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c8c:	08 95       	ret

00001c8e <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c8e:	fc 01       	movw	r30, r24
    1c90:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c92:	83 81       	ldd	r24, Z+3	; 0x03
    1c94:	22 81       	ldd	r18, Z+2	; 0x02
    1c96:	82 17       	cp	r24, r18
    1c98:	80 f4       	brcc	.+32     	; 0x1cba <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c9a:	34 81       	ldd	r19, Z+4	; 0x04
    1c9c:	90 e0       	ldi	r25, 0x00	; 0
    1c9e:	83 0f       	add	r24, r19
    1ca0:	91 1d       	adc	r25, r1
    1ca2:	62 2f       	mov	r22, r18
    1ca4:	70 e0       	ldi	r23, 0x00	; 0
    1ca6:	0e 94 7f 17 	call	0x2efe	; 0x2efe <__divmodhi4>
    1caa:	a0 81       	ld	r26, Z
    1cac:	b1 81       	ldd	r27, Z+1	; 0x01
    1cae:	a8 0f       	add	r26, r24
    1cb0:	b9 1f       	adc	r27, r25
    1cb2:	4c 93       	st	X, r20
            ring->rLength++;
    1cb4:	83 81       	ldd	r24, Z+3	; 0x03
    1cb6:	8f 5f       	subi	r24, 0xFF	; 255
    1cb8:	83 83       	std	Z+3, r24	; 0x03
    1cba:	08 95       	ret

00001cbc <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1cbc:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	22 81       	ldd	r18, Z+2	; 0x02
    1cc2:	93 81       	ldd	r25, Z+3	; 0x03
    1cc4:	29 13       	cpse	r18, r25
    1cc6:	80 e0       	ldi	r24, 0x00	; 0
}
    1cc8:	08 95       	ret

00001cca <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1cca:	21 e0       	ldi	r18, 0x01	; 1
    1ccc:	fc 01       	movw	r30, r24
    1cce:	83 81       	ldd	r24, Z+3	; 0x03
    1cd0:	81 11       	cpse	r24, r1
    1cd2:	01 c0       	rjmp	.+2      	; 0x1cd6 <ringBufferNotEmpty+0xc>
    1cd4:	20 e0       	ldi	r18, 0x00	; 0
}
    1cd6:	82 2f       	mov	r24, r18
    1cd8:	08 95       	ret

00001cda <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1cda:	e0 91 4e 08 	lds	r30, 0x084E
    1cde:	f0 91 4f 08 	lds	r31, 0x084F
    1ce2:	80 81       	ld	r24, Z
    1ce4:	81 11       	cpse	r24, r1
    1ce6:	07 c0       	rjmp	.+14     	; 0x1cf6 <prvResetNextTaskUnblockTime+0x1c>
    1ce8:	8f ef       	ldi	r24, 0xFF	; 255
    1cea:	9f ef       	ldi	r25, 0xFF	; 255
    1cec:	90 93 06 02 	sts	0x0206, r25
    1cf0:	80 93 05 02 	sts	0x0205, r24
    1cf4:	08 95       	ret
    1cf6:	e0 91 4e 08 	lds	r30, 0x084E
    1cfa:	f0 91 4f 08 	lds	r31, 0x084F
    1cfe:	05 80       	ldd	r0, Z+5	; 0x05
    1d00:	f6 81       	ldd	r31, Z+6	; 0x06
    1d02:	e0 2d       	mov	r30, r0
    1d04:	06 80       	ldd	r0, Z+6	; 0x06
    1d06:	f7 81       	ldd	r31, Z+7	; 0x07
    1d08:	e0 2d       	mov	r30, r0
    1d0a:	82 81       	ldd	r24, Z+2	; 0x02
    1d0c:	93 81       	ldd	r25, Z+3	; 0x03
    1d0e:	90 93 06 02 	sts	0x0206, r25
    1d12:	80 93 05 02 	sts	0x0205, r24
    1d16:	08 95       	ret

00001d18 <prvAddCurrentTaskToDelayedList>:
    1d18:	cf 93       	push	r28
    1d1a:	df 93       	push	r29
    1d1c:	ec 01       	movw	r28, r24
    1d1e:	e0 91 8f 08 	lds	r30, 0x088F
    1d22:	f0 91 90 08 	lds	r31, 0x0890
    1d26:	93 83       	std	Z+3, r25	; 0x03
    1d28:	82 83       	std	Z+2, r24	; 0x02
    1d2a:	80 91 2d 08 	lds	r24, 0x082D
    1d2e:	90 91 2e 08 	lds	r25, 0x082E
    1d32:	c8 17       	cp	r28, r24
    1d34:	d9 07       	cpc	r29, r25
    1d36:	68 f4       	brcc	.+26     	; 0x1d52 <prvAddCurrentTaskToDelayedList+0x3a>
    1d38:	60 91 8f 08 	lds	r22, 0x088F
    1d3c:	70 91 90 08 	lds	r23, 0x0890
    1d40:	80 91 4c 08 	lds	r24, 0x084C
    1d44:	90 91 4d 08 	lds	r25, 0x084D
    1d48:	6e 5f       	subi	r22, 0xFE	; 254
    1d4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4c:	0e 94 9f 03 	call	0x73e	; 0x73e <vListInsert>
    1d50:	17 c0       	rjmp	.+46     	; 0x1d80 <prvAddCurrentTaskToDelayedList+0x68>
    1d52:	60 91 8f 08 	lds	r22, 0x088F
    1d56:	70 91 90 08 	lds	r23, 0x0890
    1d5a:	80 91 4e 08 	lds	r24, 0x084E
    1d5e:	90 91 4f 08 	lds	r25, 0x084F
    1d62:	6e 5f       	subi	r22, 0xFE	; 254
    1d64:	7f 4f       	sbci	r23, 0xFF	; 255
    1d66:	0e 94 9f 03 	call	0x73e	; 0x73e <vListInsert>
    1d6a:	80 91 05 02 	lds	r24, 0x0205
    1d6e:	90 91 06 02 	lds	r25, 0x0206
    1d72:	c8 17       	cp	r28, r24
    1d74:	d9 07       	cpc	r29, r25
    1d76:	20 f4       	brcc	.+8      	; 0x1d80 <prvAddCurrentTaskToDelayedList+0x68>
    1d78:	d0 93 06 02 	sts	0x0206, r29
    1d7c:	c0 93 05 02 	sts	0x0205, r28
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	08 95       	ret

00001d86 <xTaskGenericCreate>:
    1d86:	4f 92       	push	r4
    1d88:	5f 92       	push	r5
    1d8a:	6f 92       	push	r6
    1d8c:	7f 92       	push	r7
    1d8e:	8f 92       	push	r8
    1d90:	9f 92       	push	r9
    1d92:	af 92       	push	r10
    1d94:	bf 92       	push	r11
    1d96:	cf 92       	push	r12
    1d98:	df 92       	push	r13
    1d9a:	ef 92       	push	r14
    1d9c:	ff 92       	push	r15
    1d9e:	0f 93       	push	r16
    1da0:	1f 93       	push	r17
    1da2:	cf 93       	push	r28
    1da4:	df 93       	push	r29
    1da6:	4c 01       	movw	r8, r24
    1da8:	5b 01       	movw	r10, r22
    1daa:	2a 01       	movw	r4, r20
    1dac:	39 01       	movw	r6, r18
    1dae:	83 e2       	ldi	r24, 0x23	; 35
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    1db6:	ec 01       	movw	r28, r24
    1db8:	00 97       	sbiw	r24, 0x00	; 0
    1dba:	09 f4       	brne	.+2      	; 0x1dbe <xTaskGenericCreate+0x38>
    1dbc:	e7 c0       	rjmp	.+462    	; 0x1f8c <xTaskGenericCreate+0x206>
    1dbe:	c1 14       	cp	r12, r1
    1dc0:	d1 04       	cpc	r13, r1
    1dc2:	09 f0       	breq	.+2      	; 0x1dc6 <xTaskGenericCreate+0x40>
    1dc4:	cc c0       	rjmp	.+408    	; 0x1f5e <xTaskGenericCreate+0x1d8>
    1dc6:	c2 01       	movw	r24, r4
    1dc8:	0e 94 36 03 	call	0x66c	; 0x66c <pvPortMalloc>
    1dcc:	98 8f       	std	Y+24, r25	; 0x18
    1dce:	8f 8b       	std	Y+23, r24	; 0x17
    1dd0:	89 2b       	or	r24, r25
    1dd2:	09 f0       	breq	.+2      	; 0x1dd6 <xTaskGenericCreate+0x50>
    1dd4:	c6 c0       	rjmp	.+396    	; 0x1f62 <xTaskGenericCreate+0x1dc>
    1dd6:	ce 01       	movw	r24, r28
    1dd8:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vPortFree>
    1ddc:	d7 c0       	rjmp	.+430    	; 0x1f8c <xTaskGenericCreate+0x206>
    1dde:	cf 01       	movw	r24, r30
    1de0:	31 91       	ld	r19, Z+
    1de2:	da 01       	movw	r26, r20
    1de4:	3d 93       	st	X+, r19
    1de6:	ad 01       	movw	r20, r26
    1de8:	dc 01       	movw	r26, r24
    1dea:	8c 91       	ld	r24, X
    1dec:	88 23       	and	r24, r24
    1dee:	11 f0       	breq	.+4      	; 0x1df4 <xTaskGenericCreate+0x6e>
    1df0:	21 50       	subi	r18, 0x01	; 1
    1df2:	a9 f7       	brne	.-22     	; 0x1dde <xTaskGenericCreate+0x58>
    1df4:	18 a2       	std	Y+32, r1	; 0x20
    1df6:	10 2f       	mov	r17, r16
    1df8:	05 30       	cpi	r16, 0x05	; 5
    1dfa:	08 f0       	brcs	.+2      	; 0x1dfe <xTaskGenericCreate+0x78>
    1dfc:	14 e0       	ldi	r17, 0x04	; 4
    1dfe:	1e 8b       	std	Y+22, r17	; 0x16
    1e00:	19 a3       	std	Y+33, r17	; 0x21
    1e02:	1a a2       	std	Y+34, r1	; 0x22
    1e04:	5e 01       	movw	r10, r28
    1e06:	b2 e0       	ldi	r27, 0x02	; 2
    1e08:	ab 0e       	add	r10, r27
    1e0a:	b1 1c       	adc	r11, r1
    1e0c:	c5 01       	movw	r24, r10
    1e0e:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <vListInitialiseItem>
    1e12:	ce 01       	movw	r24, r28
    1e14:	0c 96       	adiw	r24, 0x0c	; 12
    1e16:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <vListInitialiseItem>
    1e1a:	d9 87       	std	Y+9, r29	; 0x09
    1e1c:	c8 87       	std	Y+8, r28	; 0x08
    1e1e:	85 e0       	ldi	r24, 0x05	; 5
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	81 1b       	sub	r24, r17
    1e24:	91 09       	sbc	r25, r1
    1e26:	9d 87       	std	Y+13, r25	; 0x0d
    1e28:	8c 87       	std	Y+12, r24	; 0x0c
    1e2a:	db 8b       	std	Y+19, r29	; 0x13
    1e2c:	ca 8b       	std	Y+18, r28	; 0x12
    1e2e:	a3 01       	movw	r20, r6
    1e30:	b4 01       	movw	r22, r8
    1e32:	c6 01       	movw	r24, r12
    1e34:	cb da       	rcall	.-2666   	; 0x13cc <pxPortInitialiseStack>
    1e36:	99 83       	std	Y+1, r25	; 0x01
    1e38:	88 83       	st	Y, r24
    1e3a:	e1 14       	cp	r14, r1
    1e3c:	f1 04       	cpc	r15, r1
    1e3e:	19 f0       	breq	.+6      	; 0x1e46 <xTaskGenericCreate+0xc0>
    1e40:	f7 01       	movw	r30, r14
    1e42:	d1 83       	std	Z+1, r29	; 0x01
    1e44:	c0 83       	st	Z, r28
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	0f 92       	push	r0
    1e4c:	80 91 2f 08 	lds	r24, 0x082F
    1e50:	8f 5f       	subi	r24, 0xFF	; 255
    1e52:	80 93 2f 08 	sts	0x082F, r24
    1e56:	80 91 8f 08 	lds	r24, 0x088F
    1e5a:	90 91 90 08 	lds	r25, 0x0890
    1e5e:	89 2b       	or	r24, r25
    1e60:	09 f0       	breq	.+2      	; 0x1e64 <xTaskGenericCreate+0xde>
    1e62:	3f c0       	rjmp	.+126    	; 0x1ee2 <xTaskGenericCreate+0x15c>
    1e64:	d0 93 90 08 	sts	0x0890, r29
    1e68:	c0 93 8f 08 	sts	0x088F, r28
    1e6c:	80 91 2f 08 	lds	r24, 0x082F
    1e70:	81 30       	cpi	r24, 0x01	; 1
    1e72:	09 f0       	breq	.+2      	; 0x1e76 <xTaskGenericCreate+0xf0>
    1e74:	45 c0       	rjmp	.+138    	; 0x1f00 <xTaskGenericCreate+0x17a>
    1e76:	0f 2e       	mov	r0, r31
    1e78:	f2 e6       	ldi	r31, 0x62	; 98
    1e7a:	ef 2e       	mov	r14, r31
    1e7c:	f8 e0       	ldi	r31, 0x08	; 8
    1e7e:	ff 2e       	mov	r15, r31
    1e80:	f0 2d       	mov	r31, r0
    1e82:	0f 2e       	mov	r0, r31
    1e84:	ff e8       	ldi	r31, 0x8F	; 143
    1e86:	cf 2e       	mov	r12, r31
    1e88:	f8 e0       	ldi	r31, 0x08	; 8
    1e8a:	df 2e       	mov	r13, r31
    1e8c:	f0 2d       	mov	r31, r0
    1e8e:	c7 01       	movw	r24, r14
    1e90:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1e94:	f9 e0       	ldi	r31, 0x09	; 9
    1e96:	ef 0e       	add	r14, r31
    1e98:	f1 1c       	adc	r15, r1
    1e9a:	ec 14       	cp	r14, r12
    1e9c:	fd 04       	cpc	r15, r13
    1e9e:	b9 f7       	brne	.-18     	; 0x1e8e <xTaskGenericCreate+0x108>
    1ea0:	89 e5       	ldi	r24, 0x59	; 89
    1ea2:	98 e0       	ldi	r25, 0x08	; 8
    1ea4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1ea8:	80 e5       	ldi	r24, 0x50	; 80
    1eaa:	98 e0       	ldi	r25, 0x08	; 8
    1eac:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1eb0:	83 e4       	ldi	r24, 0x43	; 67
    1eb2:	98 e0       	ldi	r25, 0x08	; 8
    1eb4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1eb8:	8a e3       	ldi	r24, 0x3A	; 58
    1eba:	98 e0       	ldi	r25, 0x08	; 8
    1ebc:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1ec0:	80 e3       	ldi	r24, 0x30	; 48
    1ec2:	98 e0       	ldi	r25, 0x08	; 8
    1ec4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInitialise>
    1ec8:	89 e5       	ldi	r24, 0x59	; 89
    1eca:	98 e0       	ldi	r25, 0x08	; 8
    1ecc:	90 93 4f 08 	sts	0x084F, r25
    1ed0:	80 93 4e 08 	sts	0x084E, r24
    1ed4:	80 e5       	ldi	r24, 0x50	; 80
    1ed6:	98 e0       	ldi	r25, 0x08	; 8
    1ed8:	90 93 4d 08 	sts	0x084D, r25
    1edc:	80 93 4c 08 	sts	0x084C, r24
    1ee0:	0f c0       	rjmp	.+30     	; 0x1f00 <xTaskGenericCreate+0x17a>
    1ee2:	80 91 2b 08 	lds	r24, 0x082B
    1ee6:	81 11       	cpse	r24, r1
    1ee8:	0b c0       	rjmp	.+22     	; 0x1f00 <xTaskGenericCreate+0x17a>
    1eea:	e0 91 8f 08 	lds	r30, 0x088F
    1eee:	f0 91 90 08 	lds	r31, 0x0890
    1ef2:	86 89       	ldd	r24, Z+22	; 0x16
    1ef4:	08 17       	cp	r16, r24
    1ef6:	20 f0       	brcs	.+8      	; 0x1f00 <xTaskGenericCreate+0x17a>
    1ef8:	d0 93 90 08 	sts	0x0890, r29
    1efc:	c0 93 8f 08 	sts	0x088F, r28
    1f00:	80 91 27 08 	lds	r24, 0x0827
    1f04:	8f 5f       	subi	r24, 0xFF	; 255
    1f06:	80 93 27 08 	sts	0x0827, r24
    1f0a:	8e 89       	ldd	r24, Y+22	; 0x16
    1f0c:	90 91 2c 08 	lds	r25, 0x082C
    1f10:	98 17       	cp	r25, r24
    1f12:	10 f4       	brcc	.+4      	; 0x1f18 <xTaskGenericCreate+0x192>
    1f14:	80 93 2c 08 	sts	0x082C, r24
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	9c 01       	movw	r18, r24
    1f1c:	22 0f       	add	r18, r18
    1f1e:	33 1f       	adc	r19, r19
    1f20:	22 0f       	add	r18, r18
    1f22:	33 1f       	adc	r19, r19
    1f24:	22 0f       	add	r18, r18
    1f26:	33 1f       	adc	r19, r19
    1f28:	82 0f       	add	r24, r18
    1f2a:	93 1f       	adc	r25, r19
    1f2c:	b5 01       	movw	r22, r10
    1f2e:	8e 59       	subi	r24, 0x9E	; 158
    1f30:	97 4f       	sbci	r25, 0xF7	; 247
    1f32:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    1f36:	0f 90       	pop	r0
    1f38:	0f be       	out	0x3f, r0	; 63
    1f3a:	80 91 2b 08 	lds	r24, 0x082B
    1f3e:	88 23       	and	r24, r24
    1f40:	51 f0       	breq	.+20     	; 0x1f56 <xTaskGenericCreate+0x1d0>
    1f42:	e0 91 8f 08 	lds	r30, 0x088F
    1f46:	f0 91 90 08 	lds	r31, 0x0890
    1f4a:	86 89       	ldd	r24, Z+22	; 0x16
    1f4c:	80 17       	cp	r24, r16
    1f4e:	28 f4       	brcc	.+10     	; 0x1f5a <xTaskGenericCreate+0x1d4>
    1f50:	ec da       	rcall	.-2600   	; 0x152a <vPortYield>
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	1c c0       	rjmp	.+56     	; 0x1f8e <xTaskGenericCreate+0x208>
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	1a c0       	rjmp	.+52     	; 0x1f8e <xTaskGenericCreate+0x208>
    1f5a:	81 e0       	ldi	r24, 0x01	; 1
    1f5c:	18 c0       	rjmp	.+48     	; 0x1f8e <xTaskGenericCreate+0x208>
    1f5e:	d8 8e       	std	Y+24, r13	; 0x18
    1f60:	cf 8a       	std	Y+23, r12	; 0x17
    1f62:	81 e0       	ldi	r24, 0x01	; 1
    1f64:	48 1a       	sub	r4, r24
    1f66:	51 08       	sbc	r5, r1
    1f68:	cf 88       	ldd	r12, Y+23	; 0x17
    1f6a:	d8 8c       	ldd	r13, Y+24	; 0x18
    1f6c:	c4 0c       	add	r12, r4
    1f6e:	d5 1c       	adc	r13, r5
    1f70:	d5 01       	movw	r26, r10
    1f72:	8c 91       	ld	r24, X
    1f74:	89 8f       	std	Y+25, r24	; 0x19
    1f76:	8c 91       	ld	r24, X
    1f78:	88 23       	and	r24, r24
    1f7a:	09 f4       	brne	.+2      	; 0x1f7e <xTaskGenericCreate+0x1f8>
    1f7c:	3b cf       	rjmp	.-394    	; 0x1df4 <xTaskGenericCreate+0x6e>
    1f7e:	ae 01       	movw	r20, r28
    1f80:	46 5e       	subi	r20, 0xE6	; 230
    1f82:	5f 4f       	sbci	r21, 0xFF	; 255
    1f84:	f5 01       	movw	r30, r10
    1f86:	31 96       	adiw	r30, 0x01	; 1
    1f88:	27 e0       	ldi	r18, 0x07	; 7
    1f8a:	29 cf       	rjmp	.-430    	; 0x1dde <xTaskGenericCreate+0x58>
    1f8c:	8f ef       	ldi	r24, 0xFF	; 255
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	ff 90       	pop	r15
    1f98:	ef 90       	pop	r14
    1f9a:	df 90       	pop	r13
    1f9c:	cf 90       	pop	r12
    1f9e:	bf 90       	pop	r11
    1fa0:	af 90       	pop	r10
    1fa2:	9f 90       	pop	r9
    1fa4:	8f 90       	pop	r8
    1fa6:	7f 90       	pop	r7
    1fa8:	6f 90       	pop	r6
    1faa:	5f 90       	pop	r5
    1fac:	4f 90       	pop	r4
    1fae:	08 95       	ret

00001fb0 <vTaskResume>:
    1fb0:	0f 93       	push	r16
    1fb2:	1f 93       	push	r17
    1fb4:	cf 93       	push	r28
    1fb6:	df 93       	push	r29
    1fb8:	ec 01       	movw	r28, r24
    1fba:	00 97       	sbiw	r24, 0x00	; 0
    1fbc:	09 f4       	brne	.+2      	; 0x1fc0 <vTaskResume+0x10>
    1fbe:	3e c0       	rjmp	.+124    	; 0x203c <vTaskResume+0x8c>
    1fc0:	80 91 8f 08 	lds	r24, 0x088F
    1fc4:	90 91 90 08 	lds	r25, 0x0890
    1fc8:	c8 17       	cp	r28, r24
    1fca:	d9 07       	cpc	r29, r25
    1fcc:	b9 f1       	breq	.+110    	; 0x203c <vTaskResume+0x8c>
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
    1fd4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fd6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fd8:	80 53       	subi	r24, 0x30	; 48
    1fda:	98 40       	sbci	r25, 0x08	; 8
    1fdc:	69 f5       	brne	.+90     	; 0x2038 <vTaskResume+0x88>
    1fde:	8c 89       	ldd	r24, Y+20	; 0x14
    1fe0:	9d 89       	ldd	r25, Y+21	; 0x15
    1fe2:	28 e0       	ldi	r18, 0x08	; 8
    1fe4:	83 34       	cpi	r24, 0x43	; 67
    1fe6:	92 07       	cpc	r25, r18
    1fe8:	39 f1       	breq	.+78     	; 0x2038 <vTaskResume+0x88>
    1fea:	89 2b       	or	r24, r25
    1fec:	29 f5       	brne	.+74     	; 0x2038 <vTaskResume+0x88>
    1fee:	8e 01       	movw	r16, r28
    1ff0:	0e 5f       	subi	r16, 0xFE	; 254
    1ff2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ff4:	c8 01       	movw	r24, r16
    1ff6:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    1ffa:	8e 89       	ldd	r24, Y+22	; 0x16
    1ffc:	90 91 2c 08 	lds	r25, 0x082C
    2000:	98 17       	cp	r25, r24
    2002:	10 f4       	brcc	.+4      	; 0x2008 <vTaskResume+0x58>
    2004:	80 93 2c 08 	sts	0x082C, r24
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	9c 01       	movw	r18, r24
    200c:	22 0f       	add	r18, r18
    200e:	33 1f       	adc	r19, r19
    2010:	22 0f       	add	r18, r18
    2012:	33 1f       	adc	r19, r19
    2014:	22 0f       	add	r18, r18
    2016:	33 1f       	adc	r19, r19
    2018:	82 0f       	add	r24, r18
    201a:	93 1f       	adc	r25, r19
    201c:	b8 01       	movw	r22, r16
    201e:	8e 59       	subi	r24, 0x9E	; 158
    2020:	97 4f       	sbci	r25, 0xF7	; 247
    2022:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    2026:	e0 91 8f 08 	lds	r30, 0x088F
    202a:	f0 91 90 08 	lds	r31, 0x0890
    202e:	9e 89       	ldd	r25, Y+22	; 0x16
    2030:	86 89       	ldd	r24, Z+22	; 0x16
    2032:	98 17       	cp	r25, r24
    2034:	08 f0       	brcs	.+2      	; 0x2038 <vTaskResume+0x88>
    2036:	79 da       	rcall	.-2830   	; 0x152a <vPortYield>
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63
    203c:	df 91       	pop	r29
    203e:	cf 91       	pop	r28
    2040:	1f 91       	pop	r17
    2042:	0f 91       	pop	r16
    2044:	08 95       	ret

00002046 <vTaskStartScheduler>:
    2046:	af 92       	push	r10
    2048:	bf 92       	push	r11
    204a:	cf 92       	push	r12
    204c:	df 92       	push	r13
    204e:	ef 92       	push	r14
    2050:	ff 92       	push	r15
    2052:	0f 93       	push	r16
    2054:	a1 2c       	mov	r10, r1
    2056:	b1 2c       	mov	r11, r1
    2058:	c1 2c       	mov	r12, r1
    205a:	d1 2c       	mov	r13, r1
    205c:	e1 2c       	mov	r14, r1
    205e:	f1 2c       	mov	r15, r1
    2060:	00 e0       	ldi	r16, 0x00	; 0
    2062:	20 e0       	ldi	r18, 0x00	; 0
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	45 e5       	ldi	r20, 0x55	; 85
    2068:	50 e0       	ldi	r21, 0x00	; 0
    206a:	63 e3       	ldi	r22, 0x33	; 51
    206c:	72 e0       	ldi	r23, 0x02	; 2
    206e:	8e ed       	ldi	r24, 0xDE	; 222
    2070:	91 e1       	ldi	r25, 0x11	; 17
    2072:	89 de       	rcall	.-750    	; 0x1d86 <xTaskGenericCreate>
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	41 f4       	brne	.+16     	; 0x2088 <vTaskStartScheduler+0x42>
    2078:	f8 94       	cli
    207a:	80 93 2b 08 	sts	0x082B, r24
    207e:	10 92 2e 08 	sts	0x082E, r1
    2082:	10 92 2d 08 	sts	0x082D, r1
    2086:	14 da       	rcall	.-3032   	; 0x14b0 <xPortStartScheduler>
    2088:	0f 91       	pop	r16
    208a:	ff 90       	pop	r15
    208c:	ef 90       	pop	r14
    208e:	df 90       	pop	r13
    2090:	cf 90       	pop	r12
    2092:	bf 90       	pop	r11
    2094:	af 90       	pop	r10
    2096:	08 95       	ret

00002098 <vTaskSuspendAll>:
    2098:	80 91 26 08 	lds	r24, 0x0826
    209c:	8f 5f       	subi	r24, 0xFF	; 255
    209e:	80 93 26 08 	sts	0x0826, r24
    20a2:	08 95       	ret

000020a4 <xTaskGetTickCount>:
    20a4:	0f b6       	in	r0, 0x3f	; 63
    20a6:	f8 94       	cli
    20a8:	0f 92       	push	r0
    20aa:	80 91 2d 08 	lds	r24, 0x082D
    20ae:	90 91 2e 08 	lds	r25, 0x082E
    20b2:	0f 90       	pop	r0
    20b4:	0f be       	out	0x3f, r0	; 63
    20b6:	08 95       	ret

000020b8 <xTaskGetTickCountFromISR>:
    20b8:	80 91 2d 08 	lds	r24, 0x082D
    20bc:	90 91 2e 08 	lds	r25, 0x082E
    20c0:	08 95       	ret

000020c2 <xTaskIncrementTick>:
    20c2:	cf 92       	push	r12
    20c4:	df 92       	push	r13
    20c6:	ef 92       	push	r14
    20c8:	ff 92       	push	r15
    20ca:	0f 93       	push	r16
    20cc:	1f 93       	push	r17
    20ce:	cf 93       	push	r28
    20d0:	df 93       	push	r29
    20d2:	80 91 26 08 	lds	r24, 0x0826
    20d6:	81 11       	cpse	r24, r1
    20d8:	99 c0       	rjmp	.+306    	; 0x220c <__stack+0xd>
    20da:	80 91 2d 08 	lds	r24, 0x082D
    20de:	90 91 2e 08 	lds	r25, 0x082E
    20e2:	01 96       	adiw	r24, 0x01	; 1
    20e4:	90 93 2e 08 	sts	0x082E, r25
    20e8:	80 93 2d 08 	sts	0x082D, r24
    20ec:	e0 90 2d 08 	lds	r14, 0x082D
    20f0:	f0 90 2e 08 	lds	r15, 0x082E
    20f4:	e1 14       	cp	r14, r1
    20f6:	f1 04       	cpc	r15, r1
    20f8:	b1 f4       	brne	.+44     	; 0x2126 <xTaskIncrementTick+0x64>
    20fa:	80 91 4e 08 	lds	r24, 0x084E
    20fe:	90 91 4f 08 	lds	r25, 0x084F
    2102:	20 91 4c 08 	lds	r18, 0x084C
    2106:	30 91 4d 08 	lds	r19, 0x084D
    210a:	30 93 4f 08 	sts	0x084F, r19
    210e:	20 93 4e 08 	sts	0x084E, r18
    2112:	90 93 4d 08 	sts	0x084D, r25
    2116:	80 93 4c 08 	sts	0x084C, r24
    211a:	80 91 28 08 	lds	r24, 0x0828
    211e:	8f 5f       	subi	r24, 0xFF	; 255
    2120:	80 93 28 08 	sts	0x0828, r24
    2124:	da dd       	rcall	.-1100   	; 0x1cda <prvResetNextTaskUnblockTime>
    2126:	80 91 05 02 	lds	r24, 0x0205
    212a:	90 91 06 02 	lds	r25, 0x0206
    212e:	e8 16       	cp	r14, r24
    2130:	f9 06       	cpc	r15, r25
    2132:	08 f4       	brcc	.+2      	; 0x2136 <xTaskIncrementTick+0x74>
    2134:	54 c0       	rjmp	.+168    	; 0x21de <xTaskIncrementTick+0x11c>
    2136:	d1 2c       	mov	r13, r1
    2138:	cc 24       	eor	r12, r12
    213a:	c3 94       	inc	r12
    213c:	01 c0       	rjmp	.+2      	; 0x2140 <xTaskIncrementTick+0x7e>
    213e:	dc 2c       	mov	r13, r12
    2140:	e0 91 4e 08 	lds	r30, 0x084E
    2144:	f0 91 4f 08 	lds	r31, 0x084F
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	07 c0       	rjmp	.+14     	; 0x215c <xTaskIncrementTick+0x9a>
    214e:	8f ef       	ldi	r24, 0xFF	; 255
    2150:	9f ef       	ldi	r25, 0xFF	; 255
    2152:	90 93 06 02 	sts	0x0206, r25
    2156:	80 93 05 02 	sts	0x0205, r24
    215a:	42 c0       	rjmp	.+132    	; 0x21e0 <xTaskIncrementTick+0x11e>
    215c:	e0 91 4e 08 	lds	r30, 0x084E
    2160:	f0 91 4f 08 	lds	r31, 0x084F
    2164:	05 80       	ldd	r0, Z+5	; 0x05
    2166:	f6 81       	ldd	r31, Z+6	; 0x06
    2168:	e0 2d       	mov	r30, r0
    216a:	c6 81       	ldd	r28, Z+6	; 0x06
    216c:	d7 81       	ldd	r29, Z+7	; 0x07
    216e:	2a 81       	ldd	r18, Y+2	; 0x02
    2170:	3b 81       	ldd	r19, Y+3	; 0x03
    2172:	e2 16       	cp	r14, r18
    2174:	f3 06       	cpc	r15, r19
    2176:	28 f4       	brcc	.+10     	; 0x2182 <xTaskIncrementTick+0xc0>
    2178:	30 93 06 02 	sts	0x0206, r19
    217c:	20 93 05 02 	sts	0x0205, r18
    2180:	2f c0       	rjmp	.+94     	; 0x21e0 <xTaskIncrementTick+0x11e>
    2182:	8e 01       	movw	r16, r28
    2184:	0e 5f       	subi	r16, 0xFE	; 254
    2186:	1f 4f       	sbci	r17, 0xFF	; 255
    2188:	c8 01       	movw	r24, r16
    218a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    218e:	8c 89       	ldd	r24, Y+20	; 0x14
    2190:	9d 89       	ldd	r25, Y+21	; 0x15
    2192:	89 2b       	or	r24, r25
    2194:	21 f0       	breq	.+8      	; 0x219e <xTaskIncrementTick+0xdc>
    2196:	ce 01       	movw	r24, r28
    2198:	0c 96       	adiw	r24, 0x0c	; 12
    219a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    219e:	2e 89       	ldd	r18, Y+22	; 0x16
    21a0:	80 91 2c 08 	lds	r24, 0x082C
    21a4:	82 17       	cp	r24, r18
    21a6:	10 f4       	brcc	.+4      	; 0x21ac <xTaskIncrementTick+0xea>
    21a8:	20 93 2c 08 	sts	0x082C, r18
    21ac:	30 e0       	ldi	r19, 0x00	; 0
    21ae:	c9 01       	movw	r24, r18
    21b0:	88 0f       	add	r24, r24
    21b2:	99 1f       	adc	r25, r25
    21b4:	88 0f       	add	r24, r24
    21b6:	99 1f       	adc	r25, r25
    21b8:	88 0f       	add	r24, r24
    21ba:	99 1f       	adc	r25, r25
    21bc:	82 0f       	add	r24, r18
    21be:	93 1f       	adc	r25, r19
    21c0:	b8 01       	movw	r22, r16
    21c2:	8e 59       	subi	r24, 0x9E	; 158
    21c4:	97 4f       	sbci	r25, 0xF7	; 247
    21c6:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    21ca:	e0 91 8f 08 	lds	r30, 0x088F
    21ce:	f0 91 90 08 	lds	r31, 0x0890
    21d2:	9e 89       	ldd	r25, Y+22	; 0x16
    21d4:	86 89       	ldd	r24, Z+22	; 0x16
    21d6:	98 17       	cp	r25, r24
    21d8:	08 f0       	brcs	.+2      	; 0x21dc <xTaskIncrementTick+0x11a>
    21da:	b1 cf       	rjmp	.-158    	; 0x213e <xTaskIncrementTick+0x7c>
    21dc:	b1 cf       	rjmp	.-158    	; 0x2140 <xTaskIncrementTick+0x7e>
    21de:	d1 2c       	mov	r13, r1
    21e0:	e0 91 8f 08 	lds	r30, 0x088F
    21e4:	f0 91 90 08 	lds	r31, 0x0890
    21e8:	86 89       	ldd	r24, Z+22	; 0x16
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	fc 01       	movw	r30, r24
    21ee:	ee 0f       	add	r30, r30
    21f0:	ff 1f       	adc	r31, r31
    21f2:	ee 0f       	add	r30, r30
    21f4:	ff 1f       	adc	r31, r31
    21f6:	ee 0f       	add	r30, r30
    21f8:	ff 1f       	adc	r31, r31
    21fa:	8e 0f       	add	r24, r30
    21fc:	9f 1f       	adc	r25, r31
    21fe:	fc 01       	movw	r30, r24
    2200:	ee 59       	subi	r30, 0x9E	; 158
    2202:	f7 4f       	sbci	r31, 0xF7	; 247
    2204:	80 81       	ld	r24, Z
    2206:	82 30       	cpi	r24, 0x02	; 2
    2208:	40 f4       	brcc	.+16     	; 0x221a <__stack+0x1b>
    220a:	09 c0       	rjmp	.+18     	; 0x221e <__stack+0x1f>
    220c:	80 91 2a 08 	lds	r24, 0x082A
    2210:	8f 5f       	subi	r24, 0xFF	; 255
    2212:	80 93 2a 08 	sts	0x082A, r24
    2216:	d1 2c       	mov	r13, r1
    2218:	02 c0       	rjmp	.+4      	; 0x221e <__stack+0x1f>
    221a:	dd 24       	eor	r13, r13
    221c:	d3 94       	inc	r13
    221e:	80 91 29 08 	lds	r24, 0x0829
    2222:	88 23       	and	r24, r24
    2224:	11 f0       	breq	.+4      	; 0x222a <__stack+0x2b>
    2226:	dd 24       	eor	r13, r13
    2228:	d3 94       	inc	r13
    222a:	8d 2d       	mov	r24, r13
    222c:	df 91       	pop	r29
    222e:	cf 91       	pop	r28
    2230:	1f 91       	pop	r17
    2232:	0f 91       	pop	r16
    2234:	ff 90       	pop	r15
    2236:	ef 90       	pop	r14
    2238:	df 90       	pop	r13
    223a:	cf 90       	pop	r12
    223c:	08 95       	ret

0000223e <xTaskResumeAll>:
    223e:	df 92       	push	r13
    2240:	ef 92       	push	r14
    2242:	ff 92       	push	r15
    2244:	0f 93       	push	r16
    2246:	1f 93       	push	r17
    2248:	cf 93       	push	r28
    224a:	df 93       	push	r29
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	0f 92       	push	r0
    2252:	80 91 26 08 	lds	r24, 0x0826
    2256:	81 50       	subi	r24, 0x01	; 1
    2258:	80 93 26 08 	sts	0x0826, r24
    225c:	80 91 26 08 	lds	r24, 0x0826
    2260:	81 11       	cpse	r24, r1
    2262:	5f c0       	rjmp	.+190    	; 0x2322 <xTaskResumeAll+0xe4>
    2264:	80 91 2f 08 	lds	r24, 0x082F
    2268:	88 23       	and	r24, r24
    226a:	09 f4       	brne	.+2      	; 0x226e <xTaskResumeAll+0x30>
    226c:	5c c0       	rjmp	.+184    	; 0x2326 <xTaskResumeAll+0xe8>
    226e:	0f 2e       	mov	r0, r31
    2270:	f3 e4       	ldi	r31, 0x43	; 67
    2272:	ef 2e       	mov	r14, r31
    2274:	f8 e0       	ldi	r31, 0x08	; 8
    2276:	ff 2e       	mov	r15, r31
    2278:	f0 2d       	mov	r31, r0
    227a:	dd 24       	eor	r13, r13
    227c:	d3 94       	inc	r13
    227e:	30 c0       	rjmp	.+96     	; 0x22e0 <xTaskResumeAll+0xa2>
    2280:	e0 91 48 08 	lds	r30, 0x0848
    2284:	f0 91 49 08 	lds	r31, 0x0849
    2288:	c6 81       	ldd	r28, Z+6	; 0x06
    228a:	d7 81       	ldd	r29, Z+7	; 0x07
    228c:	ce 01       	movw	r24, r28
    228e:	0c 96       	adiw	r24, 0x0c	; 12
    2290:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    2294:	8e 01       	movw	r16, r28
    2296:	0e 5f       	subi	r16, 0xFE	; 254
    2298:	1f 4f       	sbci	r17, 0xFF	; 255
    229a:	c8 01       	movw	r24, r16
    229c:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    22a0:	8e 89       	ldd	r24, Y+22	; 0x16
    22a2:	90 91 2c 08 	lds	r25, 0x082C
    22a6:	98 17       	cp	r25, r24
    22a8:	10 f4       	brcc	.+4      	; 0x22ae <xTaskResumeAll+0x70>
    22aa:	80 93 2c 08 	sts	0x082C, r24
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	9c 01       	movw	r18, r24
    22b2:	22 0f       	add	r18, r18
    22b4:	33 1f       	adc	r19, r19
    22b6:	22 0f       	add	r18, r18
    22b8:	33 1f       	adc	r19, r19
    22ba:	22 0f       	add	r18, r18
    22bc:	33 1f       	adc	r19, r19
    22be:	82 0f       	add	r24, r18
    22c0:	93 1f       	adc	r25, r19
    22c2:	b8 01       	movw	r22, r16
    22c4:	8e 59       	subi	r24, 0x9E	; 158
    22c6:	97 4f       	sbci	r25, 0xF7	; 247
    22c8:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    22cc:	e0 91 8f 08 	lds	r30, 0x088F
    22d0:	f0 91 90 08 	lds	r31, 0x0890
    22d4:	9e 89       	ldd	r25, Y+22	; 0x16
    22d6:	86 89       	ldd	r24, Z+22	; 0x16
    22d8:	98 17       	cp	r25, r24
    22da:	10 f0       	brcs	.+4      	; 0x22e0 <xTaskResumeAll+0xa2>
    22dc:	d0 92 29 08 	sts	0x0829, r13
    22e0:	f7 01       	movw	r30, r14
    22e2:	80 81       	ld	r24, Z
    22e4:	81 11       	cpse	r24, r1
    22e6:	cc cf       	rjmp	.-104    	; 0x2280 <xTaskResumeAll+0x42>
    22e8:	80 91 2a 08 	lds	r24, 0x082A
    22ec:	88 23       	and	r24, r24
    22ee:	91 f0       	breq	.+36     	; 0x2314 <xTaskResumeAll+0xd6>
    22f0:	80 91 2a 08 	lds	r24, 0x082A
    22f4:	88 23       	and	r24, r24
    22f6:	71 f0       	breq	.+28     	; 0x2314 <xTaskResumeAll+0xd6>
    22f8:	c1 e0       	ldi	r28, 0x01	; 1
    22fa:	e3 de       	rcall	.-570    	; 0x20c2 <xTaskIncrementTick>
    22fc:	81 11       	cpse	r24, r1
    22fe:	c0 93 29 08 	sts	0x0829, r28
    2302:	80 91 2a 08 	lds	r24, 0x082A
    2306:	81 50       	subi	r24, 0x01	; 1
    2308:	80 93 2a 08 	sts	0x082A, r24
    230c:	80 91 2a 08 	lds	r24, 0x082A
    2310:	81 11       	cpse	r24, r1
    2312:	f3 cf       	rjmp	.-26     	; 0x22fa <xTaskResumeAll+0xbc>
    2314:	80 91 29 08 	lds	r24, 0x0829
    2318:	81 30       	cpi	r24, 0x01	; 1
    231a:	39 f4       	brne	.+14     	; 0x232a <xTaskResumeAll+0xec>
    231c:	06 d9       	rcall	.-3572   	; 0x152a <vPortYield>
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	05 c0       	rjmp	.+10     	; 0x232c <xTaskResumeAll+0xee>
    2322:	80 e0       	ldi	r24, 0x00	; 0
    2324:	03 c0       	rjmp	.+6      	; 0x232c <xTaskResumeAll+0xee>
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	01 c0       	rjmp	.+2      	; 0x232c <xTaskResumeAll+0xee>
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	0f 90       	pop	r0
    232e:	0f be       	out	0x3f, r0	; 63
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	df 90       	pop	r13
    233e:	08 95       	ret

00002340 <vTaskDelayUntil>:
    2340:	0f 93       	push	r16
    2342:	1f 93       	push	r17
    2344:	cf 93       	push	r28
    2346:	df 93       	push	r29
    2348:	8c 01       	movw	r16, r24
    234a:	eb 01       	movw	r28, r22
    234c:	a5 de       	rcall	.-694    	; 0x2098 <vTaskSuspendAll>
    234e:	80 91 2d 08 	lds	r24, 0x082D
    2352:	90 91 2e 08 	lds	r25, 0x082E
    2356:	f8 01       	movw	r30, r16
    2358:	20 81       	ld	r18, Z
    235a:	31 81       	ldd	r19, Z+1	; 0x01
    235c:	c2 0f       	add	r28, r18
    235e:	d3 1f       	adc	r29, r19
    2360:	82 17       	cp	r24, r18
    2362:	93 07       	cpc	r25, r19
    2364:	48 f4       	brcc	.+18     	; 0x2378 <vTaskDelayUntil+0x38>
    2366:	c2 17       	cp	r28, r18
    2368:	d3 07       	cpc	r29, r19
    236a:	f8 f4       	brcc	.+62     	; 0x23aa <vTaskDelayUntil+0x6a>
    236c:	d1 83       	std	Z+1, r29	; 0x01
    236e:	c0 83       	st	Z, r28
    2370:	8c 17       	cp	r24, r28
    2372:	9d 07       	cpc	r25, r29
    2374:	88 f4       	brcc	.+34     	; 0x2398 <vTaskDelayUntil+0x58>
    2376:	07 c0       	rjmp	.+14     	; 0x2386 <vTaskDelayUntil+0x46>
    2378:	c2 17       	cp	r28, r18
    237a:	d3 07       	cpc	r29, r19
    237c:	90 f0       	brcs	.+36     	; 0x23a2 <vTaskDelayUntil+0x62>
    237e:	8c 17       	cp	r24, r28
    2380:	9d 07       	cpc	r25, r29
    2382:	78 f0       	brcs	.+30     	; 0x23a2 <vTaskDelayUntil+0x62>
    2384:	12 c0       	rjmp	.+36     	; 0x23aa <vTaskDelayUntil+0x6a>
    2386:	80 91 8f 08 	lds	r24, 0x088F
    238a:	90 91 90 08 	lds	r25, 0x0890
    238e:	02 96       	adiw	r24, 0x02	; 2
    2390:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    2394:	ce 01       	movw	r24, r28
    2396:	c0 dc       	rcall	.-1664   	; 0x1d18 <prvAddCurrentTaskToDelayedList>
    2398:	52 df       	rcall	.-348    	; 0x223e <xTaskResumeAll>
    239a:	81 11       	cpse	r24, r1
    239c:	0a c0       	rjmp	.+20     	; 0x23b2 <vTaskDelayUntil+0x72>
    239e:	c5 d8       	rcall	.-3702   	; 0x152a <vPortYield>
    23a0:	08 c0       	rjmp	.+16     	; 0x23b2 <vTaskDelayUntil+0x72>
    23a2:	f8 01       	movw	r30, r16
    23a4:	d1 83       	std	Z+1, r29	; 0x01
    23a6:	c0 83       	st	Z, r28
    23a8:	ee cf       	rjmp	.-36     	; 0x2386 <vTaskDelayUntil+0x46>
    23aa:	f8 01       	movw	r30, r16
    23ac:	d1 83       	std	Z+1, r29	; 0x01
    23ae:	c0 83       	st	Z, r28
    23b0:	f3 cf       	rjmp	.-26     	; 0x2398 <vTaskDelayUntil+0x58>
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	08 95       	ret

000023bc <prvIdleTask>:
    23bc:	0f 2e       	mov	r0, r31
    23be:	f2 e6       	ldi	r31, 0x62	; 98
    23c0:	ef 2e       	mov	r14, r31
    23c2:	f8 e0       	ldi	r31, 0x08	; 8
    23c4:	ff 2e       	mov	r15, r31
    23c6:	f0 2d       	mov	r31, r0
    23c8:	ca e3       	ldi	r28, 0x3A	; 58
    23ca:	d8 e0       	ldi	r29, 0x08	; 8
    23cc:	26 c0       	rjmp	.+76     	; 0x241a <prvIdleTask+0x5e>
    23ce:	64 de       	rcall	.-824    	; 0x2098 <vTaskSuspendAll>
    23d0:	18 81       	ld	r17, Y
    23d2:	35 df       	rcall	.-406    	; 0x223e <xTaskResumeAll>
    23d4:	11 23       	and	r17, r17
    23d6:	09 f1       	breq	.+66     	; 0x241a <prvIdleTask+0x5e>
    23d8:	0f b6       	in	r0, 0x3f	; 63
    23da:	f8 94       	cli
    23dc:	0f 92       	push	r0
    23de:	e0 91 3f 08 	lds	r30, 0x083F
    23e2:	f0 91 40 08 	lds	r31, 0x0840
    23e6:	06 81       	ldd	r16, Z+6	; 0x06
    23e8:	17 81       	ldd	r17, Z+7	; 0x07
    23ea:	c8 01       	movw	r24, r16
    23ec:	02 96       	adiw	r24, 0x02	; 2
    23ee:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    23f2:	80 91 2f 08 	lds	r24, 0x082F
    23f6:	81 50       	subi	r24, 0x01	; 1
    23f8:	80 93 2f 08 	sts	0x082F, r24
    23fc:	80 91 39 08 	lds	r24, 0x0839
    2400:	81 50       	subi	r24, 0x01	; 1
    2402:	80 93 39 08 	sts	0x0839, r24
    2406:	0f 90       	pop	r0
    2408:	0f be       	out	0x3f, r0	; 63
    240a:	f8 01       	movw	r30, r16
    240c:	87 89       	ldd	r24, Z+23	; 0x17
    240e:	90 8d       	ldd	r25, Z+24	; 0x18
    2410:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vPortFree>
    2414:	c8 01       	movw	r24, r16
    2416:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vPortFree>
    241a:	80 91 39 08 	lds	r24, 0x0839
    241e:	81 11       	cpse	r24, r1
    2420:	d6 cf       	rjmp	.-84     	; 0x23ce <prvIdleTask+0x12>
    2422:	f7 01       	movw	r30, r14
    2424:	80 81       	ld	r24, Z
    2426:	82 30       	cpi	r24, 0x02	; 2
    2428:	c0 f3       	brcs	.-16     	; 0x241a <prvIdleTask+0x5e>
    242a:	7f d8       	rcall	.-3842   	; 0x152a <vPortYield>
    242c:	f6 cf       	rjmp	.-20     	; 0x241a <prvIdleTask+0x5e>

0000242e <vTaskSwitchContext>:
    242e:	80 91 26 08 	lds	r24, 0x0826
    2432:	88 23       	and	r24, r24
    2434:	21 f0       	breq	.+8      	; 0x243e <vTaskSwitchContext+0x10>
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	80 93 29 08 	sts	0x0829, r24
    243c:	08 95       	ret
    243e:	10 92 29 08 	sts	0x0829, r1
    2442:	80 91 2c 08 	lds	r24, 0x082C
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	fc 01       	movw	r30, r24
    244a:	ee 0f       	add	r30, r30
    244c:	ff 1f       	adc	r31, r31
    244e:	ee 0f       	add	r30, r30
    2450:	ff 1f       	adc	r31, r31
    2452:	ee 0f       	add	r30, r30
    2454:	ff 1f       	adc	r31, r31
    2456:	8e 0f       	add	r24, r30
    2458:	9f 1f       	adc	r25, r31
    245a:	fc 01       	movw	r30, r24
    245c:	ee 59       	subi	r30, 0x9E	; 158
    245e:	f7 4f       	sbci	r31, 0xF7	; 247
    2460:	80 81       	ld	r24, Z
    2462:	81 11       	cpse	r24, r1
    2464:	17 c0       	rjmp	.+46     	; 0x2494 <vTaskSwitchContext+0x66>
    2466:	80 91 2c 08 	lds	r24, 0x082C
    246a:	81 50       	subi	r24, 0x01	; 1
    246c:	80 93 2c 08 	sts	0x082C, r24
    2470:	80 91 2c 08 	lds	r24, 0x082C
    2474:	90 e0       	ldi	r25, 0x00	; 0
    2476:	fc 01       	movw	r30, r24
    2478:	ee 0f       	add	r30, r30
    247a:	ff 1f       	adc	r31, r31
    247c:	ee 0f       	add	r30, r30
    247e:	ff 1f       	adc	r31, r31
    2480:	ee 0f       	add	r30, r30
    2482:	ff 1f       	adc	r31, r31
    2484:	8e 0f       	add	r24, r30
    2486:	9f 1f       	adc	r25, r31
    2488:	fc 01       	movw	r30, r24
    248a:	ee 59       	subi	r30, 0x9E	; 158
    248c:	f7 4f       	sbci	r31, 0xF7	; 247
    248e:	80 81       	ld	r24, Z
    2490:	88 23       	and	r24, r24
    2492:	49 f3       	breq	.-46     	; 0x2466 <vTaskSwitchContext+0x38>
    2494:	e0 91 2c 08 	lds	r30, 0x082C
    2498:	f0 e0       	ldi	r31, 0x00	; 0
    249a:	cf 01       	movw	r24, r30
    249c:	88 0f       	add	r24, r24
    249e:	99 1f       	adc	r25, r25
    24a0:	88 0f       	add	r24, r24
    24a2:	99 1f       	adc	r25, r25
    24a4:	88 0f       	add	r24, r24
    24a6:	99 1f       	adc	r25, r25
    24a8:	e8 0f       	add	r30, r24
    24aa:	f9 1f       	adc	r31, r25
    24ac:	ee 59       	subi	r30, 0x9E	; 158
    24ae:	f7 4f       	sbci	r31, 0xF7	; 247
    24b0:	a1 81       	ldd	r26, Z+1	; 0x01
    24b2:	b2 81       	ldd	r27, Z+2	; 0x02
    24b4:	12 96       	adiw	r26, 0x02	; 2
    24b6:	0d 90       	ld	r0, X+
    24b8:	bc 91       	ld	r27, X
    24ba:	a0 2d       	mov	r26, r0
    24bc:	b2 83       	std	Z+2, r27	; 0x02
    24be:	a1 83       	std	Z+1, r26	; 0x01
    24c0:	cf 01       	movw	r24, r30
    24c2:	03 96       	adiw	r24, 0x03	; 3
    24c4:	a8 17       	cp	r26, r24
    24c6:	b9 07       	cpc	r27, r25
    24c8:	31 f4       	brne	.+12     	; 0x24d6 <vTaskSwitchContext+0xa8>
    24ca:	12 96       	adiw	r26, 0x02	; 2
    24cc:	8d 91       	ld	r24, X+
    24ce:	9c 91       	ld	r25, X
    24d0:	13 97       	sbiw	r26, 0x03	; 3
    24d2:	92 83       	std	Z+2, r25	; 0x02
    24d4:	81 83       	std	Z+1, r24	; 0x01
    24d6:	01 80       	ldd	r0, Z+1	; 0x01
    24d8:	f2 81       	ldd	r31, Z+2	; 0x02
    24da:	e0 2d       	mov	r30, r0
    24dc:	86 81       	ldd	r24, Z+6	; 0x06
    24de:	97 81       	ldd	r25, Z+7	; 0x07
    24e0:	90 93 90 08 	sts	0x0890, r25
    24e4:	80 93 8f 08 	sts	0x088F, r24
    24e8:	08 95       	ret

000024ea <vTaskSuspend>:
    24ea:	0f 93       	push	r16
    24ec:	1f 93       	push	r17
    24ee:	cf 93       	push	r28
    24f0:	df 93       	push	r29
    24f2:	ec 01       	movw	r28, r24
    24f4:	0f b6       	in	r0, 0x3f	; 63
    24f6:	f8 94       	cli
    24f8:	0f 92       	push	r0
    24fa:	00 97       	sbiw	r24, 0x00	; 0
    24fc:	21 f4       	brne	.+8      	; 0x2506 <vTaskSuspend+0x1c>
    24fe:	c0 91 8f 08 	lds	r28, 0x088F
    2502:	d0 91 90 08 	lds	r29, 0x0890
    2506:	8e 01       	movw	r16, r28
    2508:	0e 5f       	subi	r16, 0xFE	; 254
    250a:	1f 4f       	sbci	r17, 0xFF	; 255
    250c:	c8 01       	movw	r24, r16
    250e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    2512:	8c 89       	ldd	r24, Y+20	; 0x14
    2514:	9d 89       	ldd	r25, Y+21	; 0x15
    2516:	89 2b       	or	r24, r25
    2518:	21 f0       	breq	.+8      	; 0x2522 <vTaskSuspend+0x38>
    251a:	ce 01       	movw	r24, r28
    251c:	0c 96       	adiw	r24, 0x0c	; 12
    251e:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    2522:	b8 01       	movw	r22, r16
    2524:	80 e3       	ldi	r24, 0x30	; 48
    2526:	98 e0       	ldi	r25, 0x08	; 8
    2528:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    252c:	0f 90       	pop	r0
    252e:	0f be       	out	0x3f, r0	; 63
    2530:	80 91 8f 08 	lds	r24, 0x088F
    2534:	90 91 90 08 	lds	r25, 0x0890
    2538:	c8 17       	cp	r28, r24
    253a:	d9 07       	cpc	r29, r25
    253c:	a1 f4       	brne	.+40     	; 0x2566 <vTaskSuspend+0x7c>
    253e:	80 91 2b 08 	lds	r24, 0x082B
    2542:	88 23       	and	r24, r24
    2544:	19 f0       	breq	.+6      	; 0x254c <vTaskSuspend+0x62>
    2546:	0e 94 95 0a 	call	0x152a	; 0x152a <vPortYield>
    254a:	17 c0       	rjmp	.+46     	; 0x257a <vTaskSuspend+0x90>
    254c:	80 91 2f 08 	lds	r24, 0x082F
    2550:	90 91 30 08 	lds	r25, 0x0830
    2554:	98 13       	cpse	r25, r24
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <vTaskSuspend+0x78>
    2558:	10 92 90 08 	sts	0x0890, r1
    255c:	10 92 8f 08 	sts	0x088F, r1
    2560:	0c c0       	rjmp	.+24     	; 0x257a <vTaskSuspend+0x90>
    2562:	65 df       	rcall	.-310    	; 0x242e <vTaskSwitchContext>
    2564:	0a c0       	rjmp	.+20     	; 0x257a <vTaskSuspend+0x90>
    2566:	80 91 2b 08 	lds	r24, 0x082B
    256a:	88 23       	and	r24, r24
    256c:	31 f0       	breq	.+12     	; 0x257a <vTaskSuspend+0x90>
    256e:	0f b6       	in	r0, 0x3f	; 63
    2570:	f8 94       	cli
    2572:	0f 92       	push	r0
    2574:	b2 db       	rcall	.-2204   	; 0x1cda <prvResetNextTaskUnblockTime>
    2576:	0f 90       	pop	r0
    2578:	0f be       	out	0x3f, r0	; 63
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	08 95       	ret

00002584 <vTaskPlaceOnEventList>:
    2584:	cf 93       	push	r28
    2586:	df 93       	push	r29
    2588:	eb 01       	movw	r28, r22
    258a:	60 91 8f 08 	lds	r22, 0x088F
    258e:	70 91 90 08 	lds	r23, 0x0890
    2592:	64 5f       	subi	r22, 0xF4	; 244
    2594:	7f 4f       	sbci	r23, 0xFF	; 255
    2596:	0e 94 9f 03 	call	0x73e	; 0x73e <vListInsert>
    259a:	80 91 8f 08 	lds	r24, 0x088F
    259e:	90 91 90 08 	lds	r25, 0x0890
    25a2:	02 96       	adiw	r24, 0x02	; 2
    25a4:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    25a8:	cf 3f       	cpi	r28, 0xFF	; 255
    25aa:	8f ef       	ldi	r24, 0xFF	; 255
    25ac:	d8 07       	cpc	r29, r24
    25ae:	59 f4       	brne	.+22     	; 0x25c6 <vTaskPlaceOnEventList+0x42>
    25b0:	60 91 8f 08 	lds	r22, 0x088F
    25b4:	70 91 90 08 	lds	r23, 0x0890
    25b8:	6e 5f       	subi	r22, 0xFE	; 254
    25ba:	7f 4f       	sbci	r23, 0xFF	; 255
    25bc:	80 e3       	ldi	r24, 0x30	; 48
    25be:	98 e0       	ldi	r25, 0x08	; 8
    25c0:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    25c4:	07 c0       	rjmp	.+14     	; 0x25d4 <vTaskPlaceOnEventList+0x50>
    25c6:	80 91 2d 08 	lds	r24, 0x082D
    25ca:	90 91 2e 08 	lds	r25, 0x082E
    25ce:	8c 0f       	add	r24, r28
    25d0:	9d 1f       	adc	r25, r29
    25d2:	a2 db       	rcall	.-2236   	; 0x1d18 <prvAddCurrentTaskToDelayedList>
    25d4:	df 91       	pop	r29
    25d6:	cf 91       	pop	r28
    25d8:	08 95       	ret

000025da <xTaskRemoveFromEventList>:
    25da:	0f 93       	push	r16
    25dc:	1f 93       	push	r17
    25de:	cf 93       	push	r28
    25e0:	df 93       	push	r29
    25e2:	dc 01       	movw	r26, r24
    25e4:	15 96       	adiw	r26, 0x05	; 5
    25e6:	ed 91       	ld	r30, X+
    25e8:	fc 91       	ld	r31, X
    25ea:	16 97       	sbiw	r26, 0x06	; 6
    25ec:	c6 81       	ldd	r28, Z+6	; 0x06
    25ee:	d7 81       	ldd	r29, Z+7	; 0x07
    25f0:	8e 01       	movw	r16, r28
    25f2:	04 5f       	subi	r16, 0xF4	; 244
    25f4:	1f 4f       	sbci	r17, 0xFF	; 255
    25f6:	c8 01       	movw	r24, r16
    25f8:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    25fc:	80 91 26 08 	lds	r24, 0x0826
    2600:	81 11       	cpse	r24, r1
    2602:	1c c0       	rjmp	.+56     	; 0x263c <xTaskRemoveFromEventList+0x62>
    2604:	0a 50       	subi	r16, 0x0A	; 10
    2606:	11 09       	sbc	r17, r1
    2608:	c8 01       	movw	r24, r16
    260a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    260e:	8e 89       	ldd	r24, Y+22	; 0x16
    2610:	90 91 2c 08 	lds	r25, 0x082C
    2614:	98 17       	cp	r25, r24
    2616:	10 f4       	brcc	.+4      	; 0x261c <xTaskRemoveFromEventList+0x42>
    2618:	80 93 2c 08 	sts	0x082C, r24
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	9c 01       	movw	r18, r24
    2620:	22 0f       	add	r18, r18
    2622:	33 1f       	adc	r19, r19
    2624:	22 0f       	add	r18, r18
    2626:	33 1f       	adc	r19, r19
    2628:	22 0f       	add	r18, r18
    262a:	33 1f       	adc	r19, r19
    262c:	82 0f       	add	r24, r18
    262e:	93 1f       	adc	r25, r19
    2630:	b8 01       	movw	r22, r16
    2632:	8e 59       	subi	r24, 0x9E	; 158
    2634:	97 4f       	sbci	r25, 0xF7	; 247
    2636:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    263a:	05 c0       	rjmp	.+10     	; 0x2646 <xTaskRemoveFromEventList+0x6c>
    263c:	b8 01       	movw	r22, r16
    263e:	83 e4       	ldi	r24, 0x43	; 67
    2640:	98 e0       	ldi	r25, 0x08	; 8
    2642:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    2646:	e0 91 8f 08 	lds	r30, 0x088F
    264a:	f0 91 90 08 	lds	r31, 0x0890
    264e:	9e 89       	ldd	r25, Y+22	; 0x16
    2650:	86 89       	ldd	r24, Z+22	; 0x16
    2652:	89 17       	cp	r24, r25
    2654:	20 f4       	brcc	.+8      	; 0x265e <xTaskRemoveFromEventList+0x84>
    2656:	81 e0       	ldi	r24, 0x01	; 1
    2658:	80 93 29 08 	sts	0x0829, r24
    265c:	01 c0       	rjmp	.+2      	; 0x2660 <xTaskRemoveFromEventList+0x86>
    265e:	80 e0       	ldi	r24, 0x00	; 0
    2660:	df 91       	pop	r29
    2662:	cf 91       	pop	r28
    2664:	1f 91       	pop	r17
    2666:	0f 91       	pop	r16
    2668:	08 95       	ret

0000266a <vTaskSetTimeOutState>:
    266a:	20 91 28 08 	lds	r18, 0x0828
    266e:	fc 01       	movw	r30, r24
    2670:	20 83       	st	Z, r18
    2672:	20 91 2d 08 	lds	r18, 0x082D
    2676:	30 91 2e 08 	lds	r19, 0x082E
    267a:	32 83       	std	Z+2, r19	; 0x02
    267c:	21 83       	std	Z+1, r18	; 0x01
    267e:	08 95       	ret

00002680 <xTaskCheckForTimeOut>:
    2680:	0f b6       	in	r0, 0x3f	; 63
    2682:	f8 94       	cli
    2684:	0f 92       	push	r0
    2686:	40 91 2d 08 	lds	r20, 0x082D
    268a:	50 91 2e 08 	lds	r21, 0x082E
    268e:	db 01       	movw	r26, r22
    2690:	2d 91       	ld	r18, X+
    2692:	3c 91       	ld	r19, X
    2694:	2f 3f       	cpi	r18, 0xFF	; 255
    2696:	bf ef       	ldi	r27, 0xFF	; 255
    2698:	3b 07       	cpc	r19, r27
    269a:	11 f1       	breq	.+68     	; 0x26e0 <xTaskCheckForTimeOut+0x60>
    269c:	e0 91 28 08 	lds	r30, 0x0828
    26a0:	dc 01       	movw	r26, r24
    26a2:	fc 91       	ld	r31, X
    26a4:	fe 17       	cp	r31, r30
    26a6:	39 f0       	breq	.+14     	; 0x26b6 <xTaskCheckForTimeOut+0x36>
    26a8:	11 96       	adiw	r26, 0x01	; 1
    26aa:	ed 91       	ld	r30, X+
    26ac:	fc 91       	ld	r31, X
    26ae:	12 97       	sbiw	r26, 0x02	; 2
    26b0:	4e 17       	cp	r20, r30
    26b2:	5f 07       	cpc	r21, r31
    26b4:	b8 f4       	brcc	.+46     	; 0x26e4 <xTaskCheckForTimeOut+0x64>
    26b6:	dc 01       	movw	r26, r24
    26b8:	11 96       	adiw	r26, 0x01	; 1
    26ba:	ed 91       	ld	r30, X+
    26bc:	fc 91       	ld	r31, X
    26be:	12 97       	sbiw	r26, 0x02	; 2
    26c0:	da 01       	movw	r26, r20
    26c2:	ae 1b       	sub	r26, r30
    26c4:	bf 0b       	sbc	r27, r31
    26c6:	a2 17       	cp	r26, r18
    26c8:	b3 07       	cpc	r27, r19
    26ca:	70 f4       	brcc	.+28     	; 0x26e8 <xTaskCheckForTimeOut+0x68>
    26cc:	e4 1b       	sub	r30, r20
    26ce:	f5 0b       	sbc	r31, r21
    26d0:	2e 0f       	add	r18, r30
    26d2:	3f 1f       	adc	r19, r31
    26d4:	fb 01       	movw	r30, r22
    26d6:	31 83       	std	Z+1, r19	; 0x01
    26d8:	20 83       	st	Z, r18
    26da:	c7 df       	rcall	.-114    	; 0x266a <vTaskSetTimeOutState>
    26dc:	80 e0       	ldi	r24, 0x00	; 0
    26de:	05 c0       	rjmp	.+10     	; 0x26ea <xTaskCheckForTimeOut+0x6a>
    26e0:	80 e0       	ldi	r24, 0x00	; 0
    26e2:	03 c0       	rjmp	.+6      	; 0x26ea <xTaskCheckForTimeOut+0x6a>
    26e4:	81 e0       	ldi	r24, 0x01	; 1
    26e6:	01 c0       	rjmp	.+2      	; 0x26ea <xTaskCheckForTimeOut+0x6a>
    26e8:	81 e0       	ldi	r24, 0x01	; 1
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	08 95       	ret

000026f0 <vTaskMissedYield>:
    26f0:	81 e0       	ldi	r24, 0x01	; 1
    26f2:	80 93 29 08 	sts	0x0829, r24
    26f6:	08 95       	ret

000026f8 <vTaskPriorityInherit>:
    26f8:	0f 93       	push	r16
    26fa:	1f 93       	push	r17
    26fc:	cf 93       	push	r28
    26fe:	df 93       	push	r29
    2700:	ec 01       	movw	r28, r24
    2702:	00 97       	sbiw	r24, 0x00	; 0
    2704:	09 f4       	brne	.+2      	; 0x2708 <vTaskPriorityInherit+0x10>
    2706:	51 c0       	rjmp	.+162    	; 0x27aa <vTaskPriorityInherit+0xb2>
    2708:	8e 89       	ldd	r24, Y+22	; 0x16
    270a:	e0 91 8f 08 	lds	r30, 0x088F
    270e:	f0 91 90 08 	lds	r31, 0x0890
    2712:	96 89       	ldd	r25, Z+22	; 0x16
    2714:	89 17       	cp	r24, r25
    2716:	08 f0       	brcs	.+2      	; 0x271a <vTaskPriorityInherit+0x22>
    2718:	48 c0       	rjmp	.+144    	; 0x27aa <vTaskPriorityInherit+0xb2>
    271a:	2c 85       	ldd	r18, Y+12	; 0x0c
    271c:	3d 85       	ldd	r19, Y+13	; 0x0d
    271e:	33 23       	and	r19, r19
    2720:	5c f0       	brlt	.+22     	; 0x2738 <vTaskPriorityInherit+0x40>
    2722:	e0 91 8f 08 	lds	r30, 0x088F
    2726:	f0 91 90 08 	lds	r31, 0x0890
    272a:	96 89       	ldd	r25, Z+22	; 0x16
    272c:	25 e0       	ldi	r18, 0x05	; 5
    272e:	30 e0       	ldi	r19, 0x00	; 0
    2730:	29 1b       	sub	r18, r25
    2732:	31 09       	sbc	r19, r1
    2734:	3d 87       	std	Y+13, r19	; 0x0d
    2736:	2c 87       	std	Y+12, r18	; 0x0c
    2738:	90 e0       	ldi	r25, 0x00	; 0
    273a:	9c 01       	movw	r18, r24
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	22 0f       	add	r18, r18
    2742:	33 1f       	adc	r19, r19
    2744:	22 0f       	add	r18, r18
    2746:	33 1f       	adc	r19, r19
    2748:	82 0f       	add	r24, r18
    274a:	93 1f       	adc	r25, r19
    274c:	8e 59       	subi	r24, 0x9E	; 158
    274e:	97 4f       	sbci	r25, 0xF7	; 247
    2750:	2a 85       	ldd	r18, Y+10	; 0x0a
    2752:	3b 85       	ldd	r19, Y+11	; 0x0b
    2754:	28 17       	cp	r18, r24
    2756:	39 07       	cpc	r19, r25
    2758:	11 f5       	brne	.+68     	; 0x279e <vTaskPriorityInherit+0xa6>
    275a:	8e 01       	movw	r16, r28
    275c:	0e 5f       	subi	r16, 0xFE	; 254
    275e:	1f 4f       	sbci	r17, 0xFF	; 255
    2760:	c8 01       	movw	r24, r16
    2762:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    2766:	e0 91 8f 08 	lds	r30, 0x088F
    276a:	f0 91 90 08 	lds	r31, 0x0890
    276e:	86 89       	ldd	r24, Z+22	; 0x16
    2770:	8e 8b       	std	Y+22, r24	; 0x16
    2772:	90 91 2c 08 	lds	r25, 0x082C
    2776:	98 17       	cp	r25, r24
    2778:	10 f4       	brcc	.+4      	; 0x277e <vTaskPriorityInherit+0x86>
    277a:	80 93 2c 08 	sts	0x082C, r24
    277e:	90 e0       	ldi	r25, 0x00	; 0
    2780:	9c 01       	movw	r18, r24
    2782:	22 0f       	add	r18, r18
    2784:	33 1f       	adc	r19, r19
    2786:	22 0f       	add	r18, r18
    2788:	33 1f       	adc	r19, r19
    278a:	22 0f       	add	r18, r18
    278c:	33 1f       	adc	r19, r19
    278e:	82 0f       	add	r24, r18
    2790:	93 1f       	adc	r25, r19
    2792:	b8 01       	movw	r22, r16
    2794:	8e 59       	subi	r24, 0x9E	; 158
    2796:	97 4f       	sbci	r25, 0xF7	; 247
    2798:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    279c:	06 c0       	rjmp	.+12     	; 0x27aa <vTaskPriorityInherit+0xb2>
    279e:	e0 91 8f 08 	lds	r30, 0x088F
    27a2:	f0 91 90 08 	lds	r31, 0x0890
    27a6:	86 89       	ldd	r24, Z+22	; 0x16
    27a8:	8e 8b       	std	Y+22, r24	; 0x16
    27aa:	df 91       	pop	r29
    27ac:	cf 91       	pop	r28
    27ae:	1f 91       	pop	r17
    27b0:	0f 91       	pop	r16
    27b2:	08 95       	ret

000027b4 <xTaskPriorityDisinherit>:
    27b4:	0f 93       	push	r16
    27b6:	1f 93       	push	r17
    27b8:	cf 93       	push	r28
    27ba:	df 93       	push	r29
    27bc:	ec 01       	movw	r28, r24
    27be:	00 97       	sbiw	r24, 0x00	; 0
    27c0:	71 f1       	breq	.+92     	; 0x281e <xTaskPriorityDisinherit+0x6a>
    27c2:	8a a1       	ldd	r24, Y+34	; 0x22
    27c4:	81 50       	subi	r24, 0x01	; 1
    27c6:	8a a3       	std	Y+34, r24	; 0x22
    27c8:	2e 89       	ldd	r18, Y+22	; 0x16
    27ca:	99 a1       	ldd	r25, Y+33	; 0x21
    27cc:	29 17       	cp	r18, r25
    27ce:	49 f1       	breq	.+82     	; 0x2822 <xTaskPriorityDisinherit+0x6e>
    27d0:	81 11       	cpse	r24, r1
    27d2:	29 c0       	rjmp	.+82     	; 0x2826 <xTaskPriorityDisinherit+0x72>
    27d4:	8e 01       	movw	r16, r28
    27d6:	0e 5f       	subi	r16, 0xFE	; 254
    27d8:	1f 4f       	sbci	r17, 0xFF	; 255
    27da:	c8 01       	movw	r24, r16
    27dc:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <uxListRemove>
    27e0:	89 a1       	ldd	r24, Y+33	; 0x21
    27e2:	8e 8b       	std	Y+22, r24	; 0x16
    27e4:	25 e0       	ldi	r18, 0x05	; 5
    27e6:	30 e0       	ldi	r19, 0x00	; 0
    27e8:	28 1b       	sub	r18, r24
    27ea:	31 09       	sbc	r19, r1
    27ec:	3d 87       	std	Y+13, r19	; 0x0d
    27ee:	2c 87       	std	Y+12, r18	; 0x0c
    27f0:	90 91 2c 08 	lds	r25, 0x082C
    27f4:	98 17       	cp	r25, r24
    27f6:	10 f4       	brcc	.+4      	; 0x27fc <xTaskPriorityDisinherit+0x48>
    27f8:	80 93 2c 08 	sts	0x082C, r24
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	9c 01       	movw	r18, r24
    2800:	22 0f       	add	r18, r18
    2802:	33 1f       	adc	r19, r19
    2804:	22 0f       	add	r18, r18
    2806:	33 1f       	adc	r19, r19
    2808:	22 0f       	add	r18, r18
    280a:	33 1f       	adc	r19, r19
    280c:	82 0f       	add	r24, r18
    280e:	93 1f       	adc	r25, r19
    2810:	b8 01       	movw	r22, r16
    2812:	8e 59       	subi	r24, 0x9E	; 158
    2814:	97 4f       	sbci	r25, 0xF7	; 247
    2816:	0e 94 7e 03 	call	0x6fc	; 0x6fc <vListInsertEnd>
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	05 c0       	rjmp	.+10     	; 0x2828 <xTaskPriorityDisinherit+0x74>
    281e:	80 e0       	ldi	r24, 0x00	; 0
    2820:	03 c0       	rjmp	.+6      	; 0x2828 <xTaskPriorityDisinherit+0x74>
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	01 c0       	rjmp	.+2      	; 0x2828 <xTaskPriorityDisinherit+0x74>
    2826:	80 e0       	ldi	r24, 0x00	; 0
    2828:	df 91       	pop	r29
    282a:	cf 91       	pop	r28
    282c:	1f 91       	pop	r17
    282e:	0f 91       	pop	r16
    2830:	08 95       	ret

00002832 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2832:	80 91 8f 08 	lds	r24, 0x088F
    2836:	90 91 90 08 	lds	r25, 0x0890
    283a:	89 2b       	or	r24, r25
    283c:	39 f0       	breq	.+14     	; 0x284c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    283e:	e0 91 8f 08 	lds	r30, 0x088F
    2842:	f0 91 90 08 	lds	r31, 0x0890
    2846:	82 a1       	ldd	r24, Z+34	; 0x22
    2848:	8f 5f       	subi	r24, 0xFF	; 255
    284a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    284c:	80 91 8f 08 	lds	r24, 0x088F
    2850:	90 91 90 08 	lds	r25, 0x0890
	}
    2854:	08 95       	ret

00002856 <__subsf3>:
    2856:	50 58       	subi	r21, 0x80	; 128

00002858 <__addsf3>:
    2858:	bb 27       	eor	r27, r27
    285a:	aa 27       	eor	r26, r26
    285c:	0e d0       	rcall	.+28     	; 0x287a <__addsf3x>
    285e:	e5 c0       	rjmp	.+458    	; 0x2a2a <__fp_round>
    2860:	d6 d0       	rcall	.+428    	; 0x2a0e <__fp_pscA>
    2862:	30 f0       	brcs	.+12     	; 0x2870 <__addsf3+0x18>
    2864:	db d0       	rcall	.+438    	; 0x2a1c <__fp_pscB>
    2866:	20 f0       	brcs	.+8      	; 0x2870 <__addsf3+0x18>
    2868:	31 f4       	brne	.+12     	; 0x2876 <__addsf3+0x1e>
    286a:	9f 3f       	cpi	r25, 0xFF	; 255
    286c:	11 f4       	brne	.+4      	; 0x2872 <__addsf3+0x1a>
    286e:	1e f4       	brtc	.+6      	; 0x2876 <__addsf3+0x1e>
    2870:	cb c0       	rjmp	.+406    	; 0x2a08 <__fp_nan>
    2872:	0e f4       	brtc	.+2      	; 0x2876 <__addsf3+0x1e>
    2874:	e0 95       	com	r30
    2876:	e7 fb       	bst	r30, 7
    2878:	c1 c0       	rjmp	.+386    	; 0x29fc <__fp_inf>

0000287a <__addsf3x>:
    287a:	e9 2f       	mov	r30, r25
    287c:	e7 d0       	rcall	.+462    	; 0x2a4c <__fp_split3>
    287e:	80 f3       	brcs	.-32     	; 0x2860 <__addsf3+0x8>
    2880:	ba 17       	cp	r27, r26
    2882:	62 07       	cpc	r22, r18
    2884:	73 07       	cpc	r23, r19
    2886:	84 07       	cpc	r24, r20
    2888:	95 07       	cpc	r25, r21
    288a:	18 f0       	brcs	.+6      	; 0x2892 <__addsf3x+0x18>
    288c:	71 f4       	brne	.+28     	; 0x28aa <__addsf3x+0x30>
    288e:	9e f5       	brtc	.+102    	; 0x28f6 <__addsf3x+0x7c>
    2890:	ff c0       	rjmp	.+510    	; 0x2a90 <__fp_zero>
    2892:	0e f4       	brtc	.+2      	; 0x2896 <__addsf3x+0x1c>
    2894:	e0 95       	com	r30
    2896:	0b 2e       	mov	r0, r27
    2898:	ba 2f       	mov	r27, r26
    289a:	a0 2d       	mov	r26, r0
    289c:	0b 01       	movw	r0, r22
    289e:	b9 01       	movw	r22, r18
    28a0:	90 01       	movw	r18, r0
    28a2:	0c 01       	movw	r0, r24
    28a4:	ca 01       	movw	r24, r20
    28a6:	a0 01       	movw	r20, r0
    28a8:	11 24       	eor	r1, r1
    28aa:	ff 27       	eor	r31, r31
    28ac:	59 1b       	sub	r21, r25
    28ae:	99 f0       	breq	.+38     	; 0x28d6 <__addsf3x+0x5c>
    28b0:	59 3f       	cpi	r21, 0xF9	; 249
    28b2:	50 f4       	brcc	.+20     	; 0x28c8 <__addsf3x+0x4e>
    28b4:	50 3e       	cpi	r21, 0xE0	; 224
    28b6:	68 f1       	brcs	.+90     	; 0x2912 <__addsf3x+0x98>
    28b8:	1a 16       	cp	r1, r26
    28ba:	f0 40       	sbci	r31, 0x00	; 0
    28bc:	a2 2f       	mov	r26, r18
    28be:	23 2f       	mov	r18, r19
    28c0:	34 2f       	mov	r19, r20
    28c2:	44 27       	eor	r20, r20
    28c4:	58 5f       	subi	r21, 0xF8	; 248
    28c6:	f3 cf       	rjmp	.-26     	; 0x28ae <__addsf3x+0x34>
    28c8:	46 95       	lsr	r20
    28ca:	37 95       	ror	r19
    28cc:	27 95       	ror	r18
    28ce:	a7 95       	ror	r26
    28d0:	f0 40       	sbci	r31, 0x00	; 0
    28d2:	53 95       	inc	r21
    28d4:	c9 f7       	brne	.-14     	; 0x28c8 <__addsf3x+0x4e>
    28d6:	7e f4       	brtc	.+30     	; 0x28f6 <__addsf3x+0x7c>
    28d8:	1f 16       	cp	r1, r31
    28da:	ba 0b       	sbc	r27, r26
    28dc:	62 0b       	sbc	r22, r18
    28de:	73 0b       	sbc	r23, r19
    28e0:	84 0b       	sbc	r24, r20
    28e2:	ba f0       	brmi	.+46     	; 0x2912 <__addsf3x+0x98>
    28e4:	91 50       	subi	r25, 0x01	; 1
    28e6:	a1 f0       	breq	.+40     	; 0x2910 <__addsf3x+0x96>
    28e8:	ff 0f       	add	r31, r31
    28ea:	bb 1f       	adc	r27, r27
    28ec:	66 1f       	adc	r22, r22
    28ee:	77 1f       	adc	r23, r23
    28f0:	88 1f       	adc	r24, r24
    28f2:	c2 f7       	brpl	.-16     	; 0x28e4 <__addsf3x+0x6a>
    28f4:	0e c0       	rjmp	.+28     	; 0x2912 <__addsf3x+0x98>
    28f6:	ba 0f       	add	r27, r26
    28f8:	62 1f       	adc	r22, r18
    28fa:	73 1f       	adc	r23, r19
    28fc:	84 1f       	adc	r24, r20
    28fe:	48 f4       	brcc	.+18     	; 0x2912 <__addsf3x+0x98>
    2900:	87 95       	ror	r24
    2902:	77 95       	ror	r23
    2904:	67 95       	ror	r22
    2906:	b7 95       	ror	r27
    2908:	f7 95       	ror	r31
    290a:	9e 3f       	cpi	r25, 0xFE	; 254
    290c:	08 f0       	brcs	.+2      	; 0x2910 <__addsf3x+0x96>
    290e:	b3 cf       	rjmp	.-154    	; 0x2876 <__addsf3+0x1e>
    2910:	93 95       	inc	r25
    2912:	88 0f       	add	r24, r24
    2914:	08 f0       	brcs	.+2      	; 0x2918 <__addsf3x+0x9e>
    2916:	99 27       	eor	r25, r25
    2918:	ee 0f       	add	r30, r30
    291a:	97 95       	ror	r25
    291c:	87 95       	ror	r24
    291e:	08 95       	ret

00002920 <__fixsfsi>:
    2920:	04 d0       	rcall	.+8      	; 0x292a <__fixunssfsi>
    2922:	68 94       	set
    2924:	b1 11       	cpse	r27, r1
    2926:	b5 c0       	rjmp	.+362    	; 0x2a92 <__fp_szero>
    2928:	08 95       	ret

0000292a <__fixunssfsi>:
    292a:	98 d0       	rcall	.+304    	; 0x2a5c <__fp_splitA>
    292c:	88 f0       	brcs	.+34     	; 0x2950 <__fixunssfsi+0x26>
    292e:	9f 57       	subi	r25, 0x7F	; 127
    2930:	90 f0       	brcs	.+36     	; 0x2956 <__fixunssfsi+0x2c>
    2932:	b9 2f       	mov	r27, r25
    2934:	99 27       	eor	r25, r25
    2936:	b7 51       	subi	r27, 0x17	; 23
    2938:	a0 f0       	brcs	.+40     	; 0x2962 <__fixunssfsi+0x38>
    293a:	d1 f0       	breq	.+52     	; 0x2970 <__fixunssfsi+0x46>
    293c:	66 0f       	add	r22, r22
    293e:	77 1f       	adc	r23, r23
    2940:	88 1f       	adc	r24, r24
    2942:	99 1f       	adc	r25, r25
    2944:	1a f0       	brmi	.+6      	; 0x294c <__fixunssfsi+0x22>
    2946:	ba 95       	dec	r27
    2948:	c9 f7       	brne	.-14     	; 0x293c <__fixunssfsi+0x12>
    294a:	12 c0       	rjmp	.+36     	; 0x2970 <__fixunssfsi+0x46>
    294c:	b1 30       	cpi	r27, 0x01	; 1
    294e:	81 f0       	breq	.+32     	; 0x2970 <__fixunssfsi+0x46>
    2950:	9f d0       	rcall	.+318    	; 0x2a90 <__fp_zero>
    2952:	b1 e0       	ldi	r27, 0x01	; 1
    2954:	08 95       	ret
    2956:	9c c0       	rjmp	.+312    	; 0x2a90 <__fp_zero>
    2958:	67 2f       	mov	r22, r23
    295a:	78 2f       	mov	r23, r24
    295c:	88 27       	eor	r24, r24
    295e:	b8 5f       	subi	r27, 0xF8	; 248
    2960:	39 f0       	breq	.+14     	; 0x2970 <__fixunssfsi+0x46>
    2962:	b9 3f       	cpi	r27, 0xF9	; 249
    2964:	cc f3       	brlt	.-14     	; 0x2958 <__fixunssfsi+0x2e>
    2966:	86 95       	lsr	r24
    2968:	77 95       	ror	r23
    296a:	67 95       	ror	r22
    296c:	b3 95       	inc	r27
    296e:	d9 f7       	brne	.-10     	; 0x2966 <__fixunssfsi+0x3c>
    2970:	3e f4       	brtc	.+14     	; 0x2980 <__fixunssfsi+0x56>
    2972:	90 95       	com	r25
    2974:	80 95       	com	r24
    2976:	70 95       	com	r23
    2978:	61 95       	neg	r22
    297a:	7f 4f       	sbci	r23, 0xFF	; 255
    297c:	8f 4f       	sbci	r24, 0xFF	; 255
    297e:	9f 4f       	sbci	r25, 0xFF	; 255
    2980:	08 95       	ret

00002982 <__floatunsisf>:
    2982:	e8 94       	clt
    2984:	09 c0       	rjmp	.+18     	; 0x2998 <__floatsisf+0x12>

00002986 <__floatsisf>:
    2986:	97 fb       	bst	r25, 7
    2988:	3e f4       	brtc	.+14     	; 0x2998 <__floatsisf+0x12>
    298a:	90 95       	com	r25
    298c:	80 95       	com	r24
    298e:	70 95       	com	r23
    2990:	61 95       	neg	r22
    2992:	7f 4f       	sbci	r23, 0xFF	; 255
    2994:	8f 4f       	sbci	r24, 0xFF	; 255
    2996:	9f 4f       	sbci	r25, 0xFF	; 255
    2998:	99 23       	and	r25, r25
    299a:	a9 f0       	breq	.+42     	; 0x29c6 <__floatsisf+0x40>
    299c:	f9 2f       	mov	r31, r25
    299e:	96 e9       	ldi	r25, 0x96	; 150
    29a0:	bb 27       	eor	r27, r27
    29a2:	93 95       	inc	r25
    29a4:	f6 95       	lsr	r31
    29a6:	87 95       	ror	r24
    29a8:	77 95       	ror	r23
    29aa:	67 95       	ror	r22
    29ac:	b7 95       	ror	r27
    29ae:	f1 11       	cpse	r31, r1
    29b0:	f8 cf       	rjmp	.-16     	; 0x29a2 <__floatsisf+0x1c>
    29b2:	fa f4       	brpl	.+62     	; 0x29f2 <__floatsisf+0x6c>
    29b4:	bb 0f       	add	r27, r27
    29b6:	11 f4       	brne	.+4      	; 0x29bc <__floatsisf+0x36>
    29b8:	60 ff       	sbrs	r22, 0
    29ba:	1b c0       	rjmp	.+54     	; 0x29f2 <__floatsisf+0x6c>
    29bc:	6f 5f       	subi	r22, 0xFF	; 255
    29be:	7f 4f       	sbci	r23, 0xFF	; 255
    29c0:	8f 4f       	sbci	r24, 0xFF	; 255
    29c2:	9f 4f       	sbci	r25, 0xFF	; 255
    29c4:	16 c0       	rjmp	.+44     	; 0x29f2 <__floatsisf+0x6c>
    29c6:	88 23       	and	r24, r24
    29c8:	11 f0       	breq	.+4      	; 0x29ce <__floatsisf+0x48>
    29ca:	96 e9       	ldi	r25, 0x96	; 150
    29cc:	11 c0       	rjmp	.+34     	; 0x29f0 <__floatsisf+0x6a>
    29ce:	77 23       	and	r23, r23
    29d0:	21 f0       	breq	.+8      	; 0x29da <__floatsisf+0x54>
    29d2:	9e e8       	ldi	r25, 0x8E	; 142
    29d4:	87 2f       	mov	r24, r23
    29d6:	76 2f       	mov	r23, r22
    29d8:	05 c0       	rjmp	.+10     	; 0x29e4 <__floatsisf+0x5e>
    29da:	66 23       	and	r22, r22
    29dc:	71 f0       	breq	.+28     	; 0x29fa <__floatsisf+0x74>
    29de:	96 e8       	ldi	r25, 0x86	; 134
    29e0:	86 2f       	mov	r24, r22
    29e2:	70 e0       	ldi	r23, 0x00	; 0
    29e4:	60 e0       	ldi	r22, 0x00	; 0
    29e6:	2a f0       	brmi	.+10     	; 0x29f2 <__floatsisf+0x6c>
    29e8:	9a 95       	dec	r25
    29ea:	66 0f       	add	r22, r22
    29ec:	77 1f       	adc	r23, r23
    29ee:	88 1f       	adc	r24, r24
    29f0:	da f7       	brpl	.-10     	; 0x29e8 <__floatsisf+0x62>
    29f2:	88 0f       	add	r24, r24
    29f4:	96 95       	lsr	r25
    29f6:	87 95       	ror	r24
    29f8:	97 f9       	bld	r25, 7
    29fa:	08 95       	ret

000029fc <__fp_inf>:
    29fc:	97 f9       	bld	r25, 7
    29fe:	9f 67       	ori	r25, 0x7F	; 127
    2a00:	80 e8       	ldi	r24, 0x80	; 128
    2a02:	70 e0       	ldi	r23, 0x00	; 0
    2a04:	60 e0       	ldi	r22, 0x00	; 0
    2a06:	08 95       	ret

00002a08 <__fp_nan>:
    2a08:	9f ef       	ldi	r25, 0xFF	; 255
    2a0a:	80 ec       	ldi	r24, 0xC0	; 192
    2a0c:	08 95       	ret

00002a0e <__fp_pscA>:
    2a0e:	00 24       	eor	r0, r0
    2a10:	0a 94       	dec	r0
    2a12:	16 16       	cp	r1, r22
    2a14:	17 06       	cpc	r1, r23
    2a16:	18 06       	cpc	r1, r24
    2a18:	09 06       	cpc	r0, r25
    2a1a:	08 95       	ret

00002a1c <__fp_pscB>:
    2a1c:	00 24       	eor	r0, r0
    2a1e:	0a 94       	dec	r0
    2a20:	12 16       	cp	r1, r18
    2a22:	13 06       	cpc	r1, r19
    2a24:	14 06       	cpc	r1, r20
    2a26:	05 06       	cpc	r0, r21
    2a28:	08 95       	ret

00002a2a <__fp_round>:
    2a2a:	09 2e       	mov	r0, r25
    2a2c:	03 94       	inc	r0
    2a2e:	00 0c       	add	r0, r0
    2a30:	11 f4       	brne	.+4      	; 0x2a36 <__fp_round+0xc>
    2a32:	88 23       	and	r24, r24
    2a34:	52 f0       	brmi	.+20     	; 0x2a4a <__fp_round+0x20>
    2a36:	bb 0f       	add	r27, r27
    2a38:	40 f4       	brcc	.+16     	; 0x2a4a <__fp_round+0x20>
    2a3a:	bf 2b       	or	r27, r31
    2a3c:	11 f4       	brne	.+4      	; 0x2a42 <__fp_round+0x18>
    2a3e:	60 ff       	sbrs	r22, 0
    2a40:	04 c0       	rjmp	.+8      	; 0x2a4a <__fp_round+0x20>
    2a42:	6f 5f       	subi	r22, 0xFF	; 255
    2a44:	7f 4f       	sbci	r23, 0xFF	; 255
    2a46:	8f 4f       	sbci	r24, 0xFF	; 255
    2a48:	9f 4f       	sbci	r25, 0xFF	; 255
    2a4a:	08 95       	ret

00002a4c <__fp_split3>:
    2a4c:	57 fd       	sbrc	r21, 7
    2a4e:	90 58       	subi	r25, 0x80	; 128
    2a50:	44 0f       	add	r20, r20
    2a52:	55 1f       	adc	r21, r21
    2a54:	59 f0       	breq	.+22     	; 0x2a6c <__fp_splitA+0x10>
    2a56:	5f 3f       	cpi	r21, 0xFF	; 255
    2a58:	71 f0       	breq	.+28     	; 0x2a76 <__fp_splitA+0x1a>
    2a5a:	47 95       	ror	r20

00002a5c <__fp_splitA>:
    2a5c:	88 0f       	add	r24, r24
    2a5e:	97 fb       	bst	r25, 7
    2a60:	99 1f       	adc	r25, r25
    2a62:	61 f0       	breq	.+24     	; 0x2a7c <__fp_splitA+0x20>
    2a64:	9f 3f       	cpi	r25, 0xFF	; 255
    2a66:	79 f0       	breq	.+30     	; 0x2a86 <__fp_splitA+0x2a>
    2a68:	87 95       	ror	r24
    2a6a:	08 95       	ret
    2a6c:	12 16       	cp	r1, r18
    2a6e:	13 06       	cpc	r1, r19
    2a70:	14 06       	cpc	r1, r20
    2a72:	55 1f       	adc	r21, r21
    2a74:	f2 cf       	rjmp	.-28     	; 0x2a5a <__fp_split3+0xe>
    2a76:	46 95       	lsr	r20
    2a78:	f1 df       	rcall	.-30     	; 0x2a5c <__fp_splitA>
    2a7a:	08 c0       	rjmp	.+16     	; 0x2a8c <__fp_splitA+0x30>
    2a7c:	16 16       	cp	r1, r22
    2a7e:	17 06       	cpc	r1, r23
    2a80:	18 06       	cpc	r1, r24
    2a82:	99 1f       	adc	r25, r25
    2a84:	f1 cf       	rjmp	.-30     	; 0x2a68 <__fp_splitA+0xc>
    2a86:	86 95       	lsr	r24
    2a88:	71 05       	cpc	r23, r1
    2a8a:	61 05       	cpc	r22, r1
    2a8c:	08 94       	sec
    2a8e:	08 95       	ret

00002a90 <__fp_zero>:
    2a90:	e8 94       	clt

00002a92 <__fp_szero>:
    2a92:	bb 27       	eor	r27, r27
    2a94:	66 27       	eor	r22, r22
    2a96:	77 27       	eor	r23, r23
    2a98:	cb 01       	movw	r24, r22
    2a9a:	97 f9       	bld	r25, 7
    2a9c:	08 95       	ret

00002a9e <__mulsf3>:
    2a9e:	0b d0       	rcall	.+22     	; 0x2ab6 <__mulsf3x>
    2aa0:	c4 cf       	rjmp	.-120    	; 0x2a2a <__fp_round>
    2aa2:	b5 df       	rcall	.-150    	; 0x2a0e <__fp_pscA>
    2aa4:	28 f0       	brcs	.+10     	; 0x2ab0 <__mulsf3+0x12>
    2aa6:	ba df       	rcall	.-140    	; 0x2a1c <__fp_pscB>
    2aa8:	18 f0       	brcs	.+6      	; 0x2ab0 <__mulsf3+0x12>
    2aaa:	95 23       	and	r25, r21
    2aac:	09 f0       	breq	.+2      	; 0x2ab0 <__mulsf3+0x12>
    2aae:	a6 cf       	rjmp	.-180    	; 0x29fc <__fp_inf>
    2ab0:	ab cf       	rjmp	.-170    	; 0x2a08 <__fp_nan>
    2ab2:	11 24       	eor	r1, r1
    2ab4:	ee cf       	rjmp	.-36     	; 0x2a92 <__fp_szero>

00002ab6 <__mulsf3x>:
    2ab6:	ca df       	rcall	.-108    	; 0x2a4c <__fp_split3>
    2ab8:	a0 f3       	brcs	.-24     	; 0x2aa2 <__mulsf3+0x4>

00002aba <__mulsf3_pse>:
    2aba:	95 9f       	mul	r25, r21
    2abc:	d1 f3       	breq	.-12     	; 0x2ab2 <__mulsf3+0x14>
    2abe:	95 0f       	add	r25, r21
    2ac0:	50 e0       	ldi	r21, 0x00	; 0
    2ac2:	55 1f       	adc	r21, r21
    2ac4:	62 9f       	mul	r22, r18
    2ac6:	f0 01       	movw	r30, r0
    2ac8:	72 9f       	mul	r23, r18
    2aca:	bb 27       	eor	r27, r27
    2acc:	f0 0d       	add	r31, r0
    2ace:	b1 1d       	adc	r27, r1
    2ad0:	63 9f       	mul	r22, r19
    2ad2:	aa 27       	eor	r26, r26
    2ad4:	f0 0d       	add	r31, r0
    2ad6:	b1 1d       	adc	r27, r1
    2ad8:	aa 1f       	adc	r26, r26
    2ada:	64 9f       	mul	r22, r20
    2adc:	66 27       	eor	r22, r22
    2ade:	b0 0d       	add	r27, r0
    2ae0:	a1 1d       	adc	r26, r1
    2ae2:	66 1f       	adc	r22, r22
    2ae4:	82 9f       	mul	r24, r18
    2ae6:	22 27       	eor	r18, r18
    2ae8:	b0 0d       	add	r27, r0
    2aea:	a1 1d       	adc	r26, r1
    2aec:	62 1f       	adc	r22, r18
    2aee:	73 9f       	mul	r23, r19
    2af0:	b0 0d       	add	r27, r0
    2af2:	a1 1d       	adc	r26, r1
    2af4:	62 1f       	adc	r22, r18
    2af6:	83 9f       	mul	r24, r19
    2af8:	a0 0d       	add	r26, r0
    2afa:	61 1d       	adc	r22, r1
    2afc:	22 1f       	adc	r18, r18
    2afe:	74 9f       	mul	r23, r20
    2b00:	33 27       	eor	r19, r19
    2b02:	a0 0d       	add	r26, r0
    2b04:	61 1d       	adc	r22, r1
    2b06:	23 1f       	adc	r18, r19
    2b08:	84 9f       	mul	r24, r20
    2b0a:	60 0d       	add	r22, r0
    2b0c:	21 1d       	adc	r18, r1
    2b0e:	82 2f       	mov	r24, r18
    2b10:	76 2f       	mov	r23, r22
    2b12:	6a 2f       	mov	r22, r26
    2b14:	11 24       	eor	r1, r1
    2b16:	9f 57       	subi	r25, 0x7F	; 127
    2b18:	50 40       	sbci	r21, 0x00	; 0
    2b1a:	8a f0       	brmi	.+34     	; 0x2b3e <__mulsf3_pse+0x84>
    2b1c:	e1 f0       	breq	.+56     	; 0x2b56 <__mulsf3_pse+0x9c>
    2b1e:	88 23       	and	r24, r24
    2b20:	4a f0       	brmi	.+18     	; 0x2b34 <__mulsf3_pse+0x7a>
    2b22:	ee 0f       	add	r30, r30
    2b24:	ff 1f       	adc	r31, r31
    2b26:	bb 1f       	adc	r27, r27
    2b28:	66 1f       	adc	r22, r22
    2b2a:	77 1f       	adc	r23, r23
    2b2c:	88 1f       	adc	r24, r24
    2b2e:	91 50       	subi	r25, 0x01	; 1
    2b30:	50 40       	sbci	r21, 0x00	; 0
    2b32:	a9 f7       	brne	.-22     	; 0x2b1e <__mulsf3_pse+0x64>
    2b34:	9e 3f       	cpi	r25, 0xFE	; 254
    2b36:	51 05       	cpc	r21, r1
    2b38:	70 f0       	brcs	.+28     	; 0x2b56 <__mulsf3_pse+0x9c>
    2b3a:	60 cf       	rjmp	.-320    	; 0x29fc <__fp_inf>
    2b3c:	aa cf       	rjmp	.-172    	; 0x2a92 <__fp_szero>
    2b3e:	5f 3f       	cpi	r21, 0xFF	; 255
    2b40:	ec f3       	brlt	.-6      	; 0x2b3c <__mulsf3_pse+0x82>
    2b42:	98 3e       	cpi	r25, 0xE8	; 232
    2b44:	dc f3       	brlt	.-10     	; 0x2b3c <__mulsf3_pse+0x82>
    2b46:	86 95       	lsr	r24
    2b48:	77 95       	ror	r23
    2b4a:	67 95       	ror	r22
    2b4c:	b7 95       	ror	r27
    2b4e:	f7 95       	ror	r31
    2b50:	e7 95       	ror	r30
    2b52:	9f 5f       	subi	r25, 0xFF	; 255
    2b54:	c1 f7       	brne	.-16     	; 0x2b46 <__mulsf3_pse+0x8c>
    2b56:	fe 2b       	or	r31, r30
    2b58:	88 0f       	add	r24, r24
    2b5a:	91 1d       	adc	r25, r1
    2b5c:	96 95       	lsr	r25
    2b5e:	87 95       	ror	r24
    2b60:	97 f9       	bld	r25, 7
    2b62:	08 95       	ret

00002b64 <pow>:
    2b64:	fa 01       	movw	r30, r20
    2b66:	ee 0f       	add	r30, r30
    2b68:	ff 1f       	adc	r31, r31
    2b6a:	30 96       	adiw	r30, 0x00	; 0
    2b6c:	21 05       	cpc	r18, r1
    2b6e:	31 05       	cpc	r19, r1
    2b70:	99 f1       	breq	.+102    	; 0x2bd8 <pow+0x74>
    2b72:	61 15       	cp	r22, r1
    2b74:	71 05       	cpc	r23, r1
    2b76:	61 f4       	brne	.+24     	; 0x2b90 <pow+0x2c>
    2b78:	80 38       	cpi	r24, 0x80	; 128
    2b7a:	bf e3       	ldi	r27, 0x3F	; 63
    2b7c:	9b 07       	cpc	r25, r27
    2b7e:	49 f1       	breq	.+82     	; 0x2bd2 <pow+0x6e>
    2b80:	68 94       	set
    2b82:	90 38       	cpi	r25, 0x80	; 128
    2b84:	81 05       	cpc	r24, r1
    2b86:	61 f0       	breq	.+24     	; 0x2ba0 <pow+0x3c>
    2b88:	80 38       	cpi	r24, 0x80	; 128
    2b8a:	bf ef       	ldi	r27, 0xFF	; 255
    2b8c:	9b 07       	cpc	r25, r27
    2b8e:	41 f0       	breq	.+16     	; 0x2ba0 <pow+0x3c>
    2b90:	99 23       	and	r25, r25
    2b92:	42 f5       	brpl	.+80     	; 0x2be4 <pow+0x80>
    2b94:	ff 3f       	cpi	r31, 0xFF	; 255
    2b96:	e1 05       	cpc	r30, r1
    2b98:	31 05       	cpc	r19, r1
    2b9a:	21 05       	cpc	r18, r1
    2b9c:	11 f1       	breq	.+68     	; 0x2be2 <pow+0x7e>
    2b9e:	e8 94       	clt
    2ba0:	08 94       	sec
    2ba2:	e7 95       	ror	r30
    2ba4:	d9 01       	movw	r26, r18
    2ba6:	aa 23       	and	r26, r26
    2ba8:	29 f4       	brne	.+10     	; 0x2bb4 <pow+0x50>
    2baa:	ab 2f       	mov	r26, r27
    2bac:	be 2f       	mov	r27, r30
    2bae:	f8 5f       	subi	r31, 0xF8	; 248
    2bb0:	d0 f3       	brcs	.-12     	; 0x2ba6 <pow+0x42>
    2bb2:	10 c0       	rjmp	.+32     	; 0x2bd4 <pow+0x70>
    2bb4:	ff 5f       	subi	r31, 0xFF	; 255
    2bb6:	70 f4       	brcc	.+28     	; 0x2bd4 <pow+0x70>
    2bb8:	a6 95       	lsr	r26
    2bba:	e0 f7       	brcc	.-8      	; 0x2bb4 <pow+0x50>
    2bbc:	f7 39       	cpi	r31, 0x97	; 151
    2bbe:	50 f0       	brcs	.+20     	; 0x2bd4 <pow+0x70>
    2bc0:	19 f0       	breq	.+6      	; 0x2bc8 <pow+0x64>
    2bc2:	ff 3a       	cpi	r31, 0xAF	; 175
    2bc4:	38 f4       	brcc	.+14     	; 0x2bd4 <pow+0x70>
    2bc6:	9f 77       	andi	r25, 0x7F	; 127
    2bc8:	9f 93       	push	r25
    2bca:	0c d0       	rcall	.+24     	; 0x2be4 <pow+0x80>
    2bcc:	0f 90       	pop	r0
    2bce:	07 fc       	sbrc	r0, 7
    2bd0:	90 58       	subi	r25, 0x80	; 128
    2bd2:	08 95       	ret
    2bd4:	3e f0       	brts	.+14     	; 0x2be4 <pow+0x80>
    2bd6:	18 cf       	rjmp	.-464    	; 0x2a08 <__fp_nan>
    2bd8:	60 e0       	ldi	r22, 0x00	; 0
    2bda:	70 e0       	ldi	r23, 0x00	; 0
    2bdc:	80 e8       	ldi	r24, 0x80	; 128
    2bde:	9f e3       	ldi	r25, 0x3F	; 63
    2be0:	08 95       	ret
    2be2:	4f e7       	ldi	r20, 0x7F	; 127
    2be4:	9f 77       	andi	r25, 0x7F	; 127
    2be6:	5f 93       	push	r21
    2be8:	4f 93       	push	r20
    2bea:	3f 93       	push	r19
    2bec:	2f 93       	push	r18
    2bee:	9e d0       	rcall	.+316    	; 0x2d2c <log>
    2bf0:	2f 91       	pop	r18
    2bf2:	3f 91       	pop	r19
    2bf4:	4f 91       	pop	r20
    2bf6:	5f 91       	pop	r21
    2bf8:	52 df       	rcall	.-348    	; 0x2a9e <__mulsf3>
    2bfa:	05 c0       	rjmp	.+10     	; 0x2c06 <exp>
    2bfc:	19 f4       	brne	.+6      	; 0x2c04 <pow+0xa0>
    2bfe:	0e f0       	brts	.+2      	; 0x2c02 <pow+0x9e>
    2c00:	fd ce       	rjmp	.-518    	; 0x29fc <__fp_inf>
    2c02:	46 cf       	rjmp	.-372    	; 0x2a90 <__fp_zero>
    2c04:	01 cf       	rjmp	.-510    	; 0x2a08 <__fp_nan>

00002c06 <exp>:
    2c06:	2a df       	rcall	.-428    	; 0x2a5c <__fp_splitA>
    2c08:	c8 f3       	brcs	.-14     	; 0x2bfc <pow+0x98>
    2c0a:	96 38       	cpi	r25, 0x86	; 134
    2c0c:	c0 f7       	brcc	.-16     	; 0x2bfe <pow+0x9a>
    2c0e:	07 f8       	bld	r0, 7
    2c10:	0f 92       	push	r0
    2c12:	e8 94       	clt
    2c14:	2b e3       	ldi	r18, 0x3B	; 59
    2c16:	3a ea       	ldi	r19, 0xAA	; 170
    2c18:	48 eb       	ldi	r20, 0xB8	; 184
    2c1a:	5f e7       	ldi	r21, 0x7F	; 127
    2c1c:	4e df       	rcall	.-356    	; 0x2aba <__mulsf3_pse>
    2c1e:	0f 92       	push	r0
    2c20:	0f 92       	push	r0
    2c22:	0f 92       	push	r0
    2c24:	4d b7       	in	r20, 0x3d	; 61
    2c26:	5e b7       	in	r21, 0x3e	; 62
    2c28:	0f 92       	push	r0
    2c2a:	c0 d0       	rcall	.+384    	; 0x2dac <modf>
    2c2c:	e4 ee       	ldi	r30, 0xE4	; 228
    2c2e:	f0 e0       	ldi	r31, 0x00	; 0
    2c30:	16 d0       	rcall	.+44     	; 0x2c5e <__fp_powser>
    2c32:	4f 91       	pop	r20
    2c34:	5f 91       	pop	r21
    2c36:	ef 91       	pop	r30
    2c38:	ff 91       	pop	r31
    2c3a:	e5 95       	asr	r30
    2c3c:	ee 1f       	adc	r30, r30
    2c3e:	ff 1f       	adc	r31, r31
    2c40:	49 f0       	breq	.+18     	; 0x2c54 <exp+0x4e>
    2c42:	fe 57       	subi	r31, 0x7E	; 126
    2c44:	e0 68       	ori	r30, 0x80	; 128
    2c46:	44 27       	eor	r20, r20
    2c48:	ee 0f       	add	r30, r30
    2c4a:	44 1f       	adc	r20, r20
    2c4c:	fa 95       	dec	r31
    2c4e:	e1 f7       	brne	.-8      	; 0x2c48 <exp+0x42>
    2c50:	41 95       	neg	r20
    2c52:	55 0b       	sbc	r21, r21
    2c54:	32 d0       	rcall	.+100    	; 0x2cba <ldexp>
    2c56:	0f 90       	pop	r0
    2c58:	07 fe       	sbrs	r0, 7
    2c5a:	26 c0       	rjmp	.+76     	; 0x2ca8 <inverse>
    2c5c:	08 95       	ret

00002c5e <__fp_powser>:
    2c5e:	df 93       	push	r29
    2c60:	cf 93       	push	r28
    2c62:	1f 93       	push	r17
    2c64:	0f 93       	push	r16
    2c66:	ff 92       	push	r15
    2c68:	ef 92       	push	r14
    2c6a:	df 92       	push	r13
    2c6c:	7b 01       	movw	r14, r22
    2c6e:	8c 01       	movw	r16, r24
    2c70:	68 94       	set
    2c72:	05 c0       	rjmp	.+10     	; 0x2c7e <__fp_powser+0x20>
    2c74:	da 2e       	mov	r13, r26
    2c76:	ef 01       	movw	r28, r30
    2c78:	1e df       	rcall	.-452    	; 0x2ab6 <__mulsf3x>
    2c7a:	fe 01       	movw	r30, r28
    2c7c:	e8 94       	clt
    2c7e:	a5 91       	lpm	r26, Z+
    2c80:	25 91       	lpm	r18, Z+
    2c82:	35 91       	lpm	r19, Z+
    2c84:	45 91       	lpm	r20, Z+
    2c86:	55 91       	lpm	r21, Z+
    2c88:	ae f3       	brts	.-22     	; 0x2c74 <__fp_powser+0x16>
    2c8a:	ef 01       	movw	r28, r30
    2c8c:	f6 dd       	rcall	.-1044   	; 0x287a <__addsf3x>
    2c8e:	fe 01       	movw	r30, r28
    2c90:	97 01       	movw	r18, r14
    2c92:	a8 01       	movw	r20, r16
    2c94:	da 94       	dec	r13
    2c96:	79 f7       	brne	.-34     	; 0x2c76 <__fp_powser+0x18>
    2c98:	df 90       	pop	r13
    2c9a:	ef 90       	pop	r14
    2c9c:	ff 90       	pop	r15
    2c9e:	0f 91       	pop	r16
    2ca0:	1f 91       	pop	r17
    2ca2:	cf 91       	pop	r28
    2ca4:	df 91       	pop	r29
    2ca6:	08 95       	ret

00002ca8 <inverse>:
    2ca8:	9b 01       	movw	r18, r22
    2caa:	ac 01       	movw	r20, r24
    2cac:	60 e0       	ldi	r22, 0x00	; 0
    2cae:	70 e0       	ldi	r23, 0x00	; 0
    2cb0:	80 e8       	ldi	r24, 0x80	; 128
    2cb2:	9f e3       	ldi	r25, 0x3F	; 63
    2cb4:	ae c0       	rjmp	.+348    	; 0x2e12 <__divsf3>
    2cb6:	a2 ce       	rjmp	.-700    	; 0x29fc <__fp_inf>
    2cb8:	14 c1       	rjmp	.+552    	; 0x2ee2 <__fp_mpack>

00002cba <ldexp>:
    2cba:	d0 de       	rcall	.-608    	; 0x2a5c <__fp_splitA>
    2cbc:	e8 f3       	brcs	.-6      	; 0x2cb8 <inverse+0x10>
    2cbe:	99 23       	and	r25, r25
    2cc0:	d9 f3       	breq	.-10     	; 0x2cb8 <inverse+0x10>
    2cc2:	94 0f       	add	r25, r20
    2cc4:	51 1d       	adc	r21, r1
    2cc6:	bb f3       	brvs	.-18     	; 0x2cb6 <inverse+0xe>
    2cc8:	91 50       	subi	r25, 0x01	; 1
    2cca:	50 40       	sbci	r21, 0x00	; 0
    2ccc:	94 f0       	brlt	.+36     	; 0x2cf2 <ldexp+0x38>
    2cce:	59 f0       	breq	.+22     	; 0x2ce6 <ldexp+0x2c>
    2cd0:	88 23       	and	r24, r24
    2cd2:	32 f0       	brmi	.+12     	; 0x2ce0 <ldexp+0x26>
    2cd4:	66 0f       	add	r22, r22
    2cd6:	77 1f       	adc	r23, r23
    2cd8:	88 1f       	adc	r24, r24
    2cda:	91 50       	subi	r25, 0x01	; 1
    2cdc:	50 40       	sbci	r21, 0x00	; 0
    2cde:	c1 f7       	brne	.-16     	; 0x2cd0 <ldexp+0x16>
    2ce0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ce2:	51 05       	cpc	r21, r1
    2ce4:	44 f7       	brge	.-48     	; 0x2cb6 <inverse+0xe>
    2ce6:	88 0f       	add	r24, r24
    2ce8:	91 1d       	adc	r25, r1
    2cea:	96 95       	lsr	r25
    2cec:	87 95       	ror	r24
    2cee:	97 f9       	bld	r25, 7
    2cf0:	08 95       	ret
    2cf2:	5f 3f       	cpi	r21, 0xFF	; 255
    2cf4:	ac f0       	brlt	.+42     	; 0x2d20 <ldexp+0x66>
    2cf6:	98 3e       	cpi	r25, 0xE8	; 232
    2cf8:	9c f0       	brlt	.+38     	; 0x2d20 <ldexp+0x66>
    2cfa:	bb 27       	eor	r27, r27
    2cfc:	86 95       	lsr	r24
    2cfe:	77 95       	ror	r23
    2d00:	67 95       	ror	r22
    2d02:	b7 95       	ror	r27
    2d04:	08 f4       	brcc	.+2      	; 0x2d08 <ldexp+0x4e>
    2d06:	b1 60       	ori	r27, 0x01	; 1
    2d08:	93 95       	inc	r25
    2d0a:	c1 f7       	brne	.-16     	; 0x2cfc <ldexp+0x42>
    2d0c:	bb 0f       	add	r27, r27
    2d0e:	58 f7       	brcc	.-42     	; 0x2ce6 <ldexp+0x2c>
    2d10:	11 f4       	brne	.+4      	; 0x2d16 <ldexp+0x5c>
    2d12:	60 ff       	sbrs	r22, 0
    2d14:	e8 cf       	rjmp	.-48     	; 0x2ce6 <ldexp+0x2c>
    2d16:	6f 5f       	subi	r22, 0xFF	; 255
    2d18:	7f 4f       	sbci	r23, 0xFF	; 255
    2d1a:	8f 4f       	sbci	r24, 0xFF	; 255
    2d1c:	9f 4f       	sbci	r25, 0xFF	; 255
    2d1e:	e3 cf       	rjmp	.-58     	; 0x2ce6 <ldexp+0x2c>
    2d20:	b8 ce       	rjmp	.-656    	; 0x2a92 <__fp_szero>
    2d22:	0e f0       	brts	.+2      	; 0x2d26 <ldexp+0x6c>
    2d24:	de c0       	rjmp	.+444    	; 0x2ee2 <__fp_mpack>
    2d26:	70 ce       	rjmp	.-800    	; 0x2a08 <__fp_nan>
    2d28:	68 94       	set
    2d2a:	68 ce       	rjmp	.-816    	; 0x29fc <__fp_inf>

00002d2c <log>:
    2d2c:	97 de       	rcall	.-722    	; 0x2a5c <__fp_splitA>
    2d2e:	c8 f3       	brcs	.-14     	; 0x2d22 <ldexp+0x68>
    2d30:	99 23       	and	r25, r25
    2d32:	d1 f3       	breq	.-12     	; 0x2d28 <ldexp+0x6e>
    2d34:	c6 f3       	brts	.-16     	; 0x2d26 <ldexp+0x6c>
    2d36:	df 93       	push	r29
    2d38:	cf 93       	push	r28
    2d3a:	1f 93       	push	r17
    2d3c:	0f 93       	push	r16
    2d3e:	ff 92       	push	r15
    2d40:	c9 2f       	mov	r28, r25
    2d42:	dd 27       	eor	r29, r29
    2d44:	88 23       	and	r24, r24
    2d46:	2a f0       	brmi	.+10     	; 0x2d52 <log+0x26>
    2d48:	21 97       	sbiw	r28, 0x01	; 1
    2d4a:	66 0f       	add	r22, r22
    2d4c:	77 1f       	adc	r23, r23
    2d4e:	88 1f       	adc	r24, r24
    2d50:	da f7       	brpl	.-10     	; 0x2d48 <log+0x1c>
    2d52:	20 e0       	ldi	r18, 0x00	; 0
    2d54:	30 e0       	ldi	r19, 0x00	; 0
    2d56:	40 e8       	ldi	r20, 0x80	; 128
    2d58:	5f eb       	ldi	r21, 0xBF	; 191
    2d5a:	9f e3       	ldi	r25, 0x3F	; 63
    2d5c:	88 39       	cpi	r24, 0x98	; 152
    2d5e:	20 f0       	brcs	.+8      	; 0x2d68 <log+0x3c>
    2d60:	80 3e       	cpi	r24, 0xE0	; 224
    2d62:	30 f0       	brcs	.+12     	; 0x2d70 <log+0x44>
    2d64:	21 96       	adiw	r28, 0x01	; 1
    2d66:	8f 77       	andi	r24, 0x7F	; 127
    2d68:	77 dd       	rcall	.-1298   	; 0x2858 <__addsf3>
    2d6a:	ec e0       	ldi	r30, 0x0C	; 12
    2d6c:	f1 e0       	ldi	r31, 0x01	; 1
    2d6e:	03 c0       	rjmp	.+6      	; 0x2d76 <log+0x4a>
    2d70:	73 dd       	rcall	.-1306   	; 0x2858 <__addsf3>
    2d72:	e9 e3       	ldi	r30, 0x39	; 57
    2d74:	f1 e0       	ldi	r31, 0x01	; 1
    2d76:	73 df       	rcall	.-282    	; 0x2c5e <__fp_powser>
    2d78:	8b 01       	movw	r16, r22
    2d7a:	be 01       	movw	r22, r28
    2d7c:	ec 01       	movw	r28, r24
    2d7e:	fb 2e       	mov	r15, r27
    2d80:	6f 57       	subi	r22, 0x7F	; 127
    2d82:	71 09       	sbc	r23, r1
    2d84:	75 95       	asr	r23
    2d86:	77 1f       	adc	r23, r23
    2d88:	88 0b       	sbc	r24, r24
    2d8a:	99 0b       	sbc	r25, r25
    2d8c:	fc dd       	rcall	.-1032   	; 0x2986 <__floatsisf>
    2d8e:	28 e1       	ldi	r18, 0x18	; 24
    2d90:	32 e7       	ldi	r19, 0x72	; 114
    2d92:	41 e3       	ldi	r20, 0x31	; 49
    2d94:	5f e3       	ldi	r21, 0x3F	; 63
    2d96:	8f de       	rcall	.-738    	; 0x2ab6 <__mulsf3x>
    2d98:	af 2d       	mov	r26, r15
    2d9a:	98 01       	movw	r18, r16
    2d9c:	ae 01       	movw	r20, r28
    2d9e:	ff 90       	pop	r15
    2da0:	0f 91       	pop	r16
    2da2:	1f 91       	pop	r17
    2da4:	cf 91       	pop	r28
    2da6:	df 91       	pop	r29
    2da8:	68 dd       	rcall	.-1328   	; 0x287a <__addsf3x>
    2daa:	3f ce       	rjmp	.-898    	; 0x2a2a <__fp_round>

00002dac <modf>:
    2dac:	fa 01       	movw	r30, r20
    2dae:	dc 01       	movw	r26, r24
    2db0:	aa 0f       	add	r26, r26
    2db2:	bb 1f       	adc	r27, r27
    2db4:	9b 01       	movw	r18, r22
    2db6:	ac 01       	movw	r20, r24
    2db8:	bf 57       	subi	r27, 0x7F	; 127
    2dba:	28 f4       	brcc	.+10     	; 0x2dc6 <modf+0x1a>
    2dbc:	22 27       	eor	r18, r18
    2dbe:	33 27       	eor	r19, r19
    2dc0:	44 27       	eor	r20, r20
    2dc2:	50 78       	andi	r21, 0x80	; 128
    2dc4:	1f c0       	rjmp	.+62     	; 0x2e04 <modf+0x58>
    2dc6:	b7 51       	subi	r27, 0x17	; 23
    2dc8:	88 f4       	brcc	.+34     	; 0x2dec <modf+0x40>
    2dca:	ab 2f       	mov	r26, r27
    2dcc:	00 24       	eor	r0, r0
    2dce:	46 95       	lsr	r20
    2dd0:	37 95       	ror	r19
    2dd2:	27 95       	ror	r18
    2dd4:	01 1c       	adc	r0, r1
    2dd6:	a3 95       	inc	r26
    2dd8:	d2 f3       	brmi	.-12     	; 0x2dce <modf+0x22>
    2dda:	00 20       	and	r0, r0
    2ddc:	69 f0       	breq	.+26     	; 0x2df8 <modf+0x4c>
    2dde:	22 0f       	add	r18, r18
    2de0:	33 1f       	adc	r19, r19
    2de2:	44 1f       	adc	r20, r20
    2de4:	b3 95       	inc	r27
    2de6:	da f3       	brmi	.-10     	; 0x2dde <modf+0x32>
    2de8:	0d d0       	rcall	.+26     	; 0x2e04 <modf+0x58>
    2dea:	35 cd       	rjmp	.-1430   	; 0x2856 <__subsf3>
    2dec:	61 30       	cpi	r22, 0x01	; 1
    2dee:	71 05       	cpc	r23, r1
    2df0:	a0 e8       	ldi	r26, 0x80	; 128
    2df2:	8a 07       	cpc	r24, r26
    2df4:	b9 46       	sbci	r27, 0x69	; 105
    2df6:	30 f4       	brcc	.+12     	; 0x2e04 <modf+0x58>
    2df8:	9b 01       	movw	r18, r22
    2dfa:	ac 01       	movw	r20, r24
    2dfc:	66 27       	eor	r22, r22
    2dfe:	77 27       	eor	r23, r23
    2e00:	88 27       	eor	r24, r24
    2e02:	90 78       	andi	r25, 0x80	; 128
    2e04:	30 96       	adiw	r30, 0x00	; 0
    2e06:	21 f0       	breq	.+8      	; 0x2e10 <modf+0x64>
    2e08:	20 83       	st	Z, r18
    2e0a:	31 83       	std	Z+1, r19	; 0x01
    2e0c:	42 83       	std	Z+2, r20	; 0x02
    2e0e:	53 83       	std	Z+3, r21	; 0x03
    2e10:	08 95       	ret

00002e12 <__divsf3>:
    2e12:	0c d0       	rcall	.+24     	; 0x2e2c <__divsf3x>
    2e14:	0a ce       	rjmp	.-1004   	; 0x2a2a <__fp_round>
    2e16:	02 de       	rcall	.-1020   	; 0x2a1c <__fp_pscB>
    2e18:	40 f0       	brcs	.+16     	; 0x2e2a <__divsf3+0x18>
    2e1a:	f9 dd       	rcall	.-1038   	; 0x2a0e <__fp_pscA>
    2e1c:	30 f0       	brcs	.+12     	; 0x2e2a <__divsf3+0x18>
    2e1e:	21 f4       	brne	.+8      	; 0x2e28 <__divsf3+0x16>
    2e20:	5f 3f       	cpi	r21, 0xFF	; 255
    2e22:	19 f0       	breq	.+6      	; 0x2e2a <__divsf3+0x18>
    2e24:	eb cd       	rjmp	.-1066   	; 0x29fc <__fp_inf>
    2e26:	51 11       	cpse	r21, r1
    2e28:	34 ce       	rjmp	.-920    	; 0x2a92 <__fp_szero>
    2e2a:	ee cd       	rjmp	.-1060   	; 0x2a08 <__fp_nan>

00002e2c <__divsf3x>:
    2e2c:	0f de       	rcall	.-994    	; 0x2a4c <__fp_split3>
    2e2e:	98 f3       	brcs	.-26     	; 0x2e16 <__divsf3+0x4>

00002e30 <__divsf3_pse>:
    2e30:	99 23       	and	r25, r25
    2e32:	c9 f3       	breq	.-14     	; 0x2e26 <__divsf3+0x14>
    2e34:	55 23       	and	r21, r21
    2e36:	b1 f3       	breq	.-20     	; 0x2e24 <__divsf3+0x12>
    2e38:	95 1b       	sub	r25, r21
    2e3a:	55 0b       	sbc	r21, r21
    2e3c:	bb 27       	eor	r27, r27
    2e3e:	aa 27       	eor	r26, r26
    2e40:	62 17       	cp	r22, r18
    2e42:	73 07       	cpc	r23, r19
    2e44:	84 07       	cpc	r24, r20
    2e46:	38 f0       	brcs	.+14     	; 0x2e56 <__divsf3_pse+0x26>
    2e48:	9f 5f       	subi	r25, 0xFF	; 255
    2e4a:	5f 4f       	sbci	r21, 0xFF	; 255
    2e4c:	22 0f       	add	r18, r18
    2e4e:	33 1f       	adc	r19, r19
    2e50:	44 1f       	adc	r20, r20
    2e52:	aa 1f       	adc	r26, r26
    2e54:	a9 f3       	breq	.-22     	; 0x2e40 <__divsf3_pse+0x10>
    2e56:	33 d0       	rcall	.+102    	; 0x2ebe <__divsf3_pse+0x8e>
    2e58:	0e 2e       	mov	r0, r30
    2e5a:	3a f0       	brmi	.+14     	; 0x2e6a <__divsf3_pse+0x3a>
    2e5c:	e0 e8       	ldi	r30, 0x80	; 128
    2e5e:	30 d0       	rcall	.+96     	; 0x2ec0 <__divsf3_pse+0x90>
    2e60:	91 50       	subi	r25, 0x01	; 1
    2e62:	50 40       	sbci	r21, 0x00	; 0
    2e64:	e6 95       	lsr	r30
    2e66:	00 1c       	adc	r0, r0
    2e68:	ca f7       	brpl	.-14     	; 0x2e5c <__divsf3_pse+0x2c>
    2e6a:	29 d0       	rcall	.+82     	; 0x2ebe <__divsf3_pse+0x8e>
    2e6c:	fe 2f       	mov	r31, r30
    2e6e:	27 d0       	rcall	.+78     	; 0x2ebe <__divsf3_pse+0x8e>
    2e70:	66 0f       	add	r22, r22
    2e72:	77 1f       	adc	r23, r23
    2e74:	88 1f       	adc	r24, r24
    2e76:	bb 1f       	adc	r27, r27
    2e78:	26 17       	cp	r18, r22
    2e7a:	37 07       	cpc	r19, r23
    2e7c:	48 07       	cpc	r20, r24
    2e7e:	ab 07       	cpc	r26, r27
    2e80:	b0 e8       	ldi	r27, 0x80	; 128
    2e82:	09 f0       	breq	.+2      	; 0x2e86 <__divsf3_pse+0x56>
    2e84:	bb 0b       	sbc	r27, r27
    2e86:	80 2d       	mov	r24, r0
    2e88:	bf 01       	movw	r22, r30
    2e8a:	ff 27       	eor	r31, r31
    2e8c:	93 58       	subi	r25, 0x83	; 131
    2e8e:	5f 4f       	sbci	r21, 0xFF	; 255
    2e90:	2a f0       	brmi	.+10     	; 0x2e9c <__divsf3_pse+0x6c>
    2e92:	9e 3f       	cpi	r25, 0xFE	; 254
    2e94:	51 05       	cpc	r21, r1
    2e96:	68 f0       	brcs	.+26     	; 0x2eb2 <__divsf3_pse+0x82>
    2e98:	b1 cd       	rjmp	.-1182   	; 0x29fc <__fp_inf>
    2e9a:	fb cd       	rjmp	.-1034   	; 0x2a92 <__fp_szero>
    2e9c:	5f 3f       	cpi	r21, 0xFF	; 255
    2e9e:	ec f3       	brlt	.-6      	; 0x2e9a <__divsf3_pse+0x6a>
    2ea0:	98 3e       	cpi	r25, 0xE8	; 232
    2ea2:	dc f3       	brlt	.-10     	; 0x2e9a <__divsf3_pse+0x6a>
    2ea4:	86 95       	lsr	r24
    2ea6:	77 95       	ror	r23
    2ea8:	67 95       	ror	r22
    2eaa:	b7 95       	ror	r27
    2eac:	f7 95       	ror	r31
    2eae:	9f 5f       	subi	r25, 0xFF	; 255
    2eb0:	c9 f7       	brne	.-14     	; 0x2ea4 <__divsf3_pse+0x74>
    2eb2:	88 0f       	add	r24, r24
    2eb4:	91 1d       	adc	r25, r1
    2eb6:	96 95       	lsr	r25
    2eb8:	87 95       	ror	r24
    2eba:	97 f9       	bld	r25, 7
    2ebc:	08 95       	ret
    2ebe:	e1 e0       	ldi	r30, 0x01	; 1
    2ec0:	66 0f       	add	r22, r22
    2ec2:	77 1f       	adc	r23, r23
    2ec4:	88 1f       	adc	r24, r24
    2ec6:	bb 1f       	adc	r27, r27
    2ec8:	62 17       	cp	r22, r18
    2eca:	73 07       	cpc	r23, r19
    2ecc:	84 07       	cpc	r24, r20
    2ece:	ba 07       	cpc	r27, r26
    2ed0:	20 f0       	brcs	.+8      	; 0x2eda <__divsf3_pse+0xaa>
    2ed2:	62 1b       	sub	r22, r18
    2ed4:	73 0b       	sbc	r23, r19
    2ed6:	84 0b       	sbc	r24, r20
    2ed8:	ba 0b       	sbc	r27, r26
    2eda:	ee 1f       	adc	r30, r30
    2edc:	88 f7       	brcc	.-30     	; 0x2ec0 <__divsf3_pse+0x90>
    2ede:	e0 95       	com	r30
    2ee0:	08 95       	ret

00002ee2 <__fp_mpack>:
    2ee2:	9f 3f       	cpi	r25, 0xFF	; 255
    2ee4:	31 f0       	breq	.+12     	; 0x2ef2 <__fp_mpack_finite+0xc>

00002ee6 <__fp_mpack_finite>:
    2ee6:	91 50       	subi	r25, 0x01	; 1
    2ee8:	20 f4       	brcc	.+8      	; 0x2ef2 <__fp_mpack_finite+0xc>
    2eea:	87 95       	ror	r24
    2eec:	77 95       	ror	r23
    2eee:	67 95       	ror	r22
    2ef0:	b7 95       	ror	r27
    2ef2:	88 0f       	add	r24, r24
    2ef4:	91 1d       	adc	r25, r1
    2ef6:	96 95       	lsr	r25
    2ef8:	87 95       	ror	r24
    2efa:	97 f9       	bld	r25, 7
    2efc:	08 95       	ret

00002efe <__divmodhi4>:
    2efe:	97 fb       	bst	r25, 7
    2f00:	07 2e       	mov	r0, r23
    2f02:	16 f4       	brtc	.+4      	; 0x2f08 <__divmodhi4+0xa>
    2f04:	00 94       	com	r0
    2f06:	06 d0       	rcall	.+12     	; 0x2f14 <__divmodhi4_neg1>
    2f08:	77 fd       	sbrc	r23, 7
    2f0a:	08 d0       	rcall	.+16     	; 0x2f1c <__divmodhi4_neg2>
    2f0c:	0b d0       	rcall	.+22     	; 0x2f24 <__udivmodhi4>
    2f0e:	07 fc       	sbrc	r0, 7
    2f10:	05 d0       	rcall	.+10     	; 0x2f1c <__divmodhi4_neg2>
    2f12:	3e f4       	brtc	.+14     	; 0x2f22 <__divmodhi4_exit>

00002f14 <__divmodhi4_neg1>:
    2f14:	90 95       	com	r25
    2f16:	81 95       	neg	r24
    2f18:	9f 4f       	sbci	r25, 0xFF	; 255
    2f1a:	08 95       	ret

00002f1c <__divmodhi4_neg2>:
    2f1c:	70 95       	com	r23
    2f1e:	61 95       	neg	r22
    2f20:	7f 4f       	sbci	r23, 0xFF	; 255

00002f22 <__divmodhi4_exit>:
    2f22:	08 95       	ret

00002f24 <__udivmodhi4>:
    2f24:	aa 1b       	sub	r26, r26
    2f26:	bb 1b       	sub	r27, r27
    2f28:	51 e1       	ldi	r21, 0x11	; 17
    2f2a:	07 c0       	rjmp	.+14     	; 0x2f3a <__udivmodhi4_ep>

00002f2c <__udivmodhi4_loop>:
    2f2c:	aa 1f       	adc	r26, r26
    2f2e:	bb 1f       	adc	r27, r27
    2f30:	a6 17       	cp	r26, r22
    2f32:	b7 07       	cpc	r27, r23
    2f34:	10 f0       	brcs	.+4      	; 0x2f3a <__udivmodhi4_ep>
    2f36:	a6 1b       	sub	r26, r22
    2f38:	b7 0b       	sbc	r27, r23

00002f3a <__udivmodhi4_ep>:
    2f3a:	88 1f       	adc	r24, r24
    2f3c:	99 1f       	adc	r25, r25
    2f3e:	5a 95       	dec	r21
    2f40:	a9 f7       	brne	.-22     	; 0x2f2c <__udivmodhi4_loop>
    2f42:	80 95       	com	r24
    2f44:	90 95       	com	r25
    2f46:	bc 01       	movw	r22, r24
    2f48:	cd 01       	movw	r24, r26
    2f4a:	08 95       	ret

00002f4c <memcpy>:
    2f4c:	fb 01       	movw	r30, r22
    2f4e:	dc 01       	movw	r26, r24
    2f50:	02 c0       	rjmp	.+4      	; 0x2f56 <memcpy+0xa>
    2f52:	01 90       	ld	r0, Z+
    2f54:	0d 92       	st	X+, r0
    2f56:	41 50       	subi	r20, 0x01	; 1
    2f58:	50 40       	sbci	r21, 0x00	; 0
    2f5a:	d8 f7       	brcc	.-10     	; 0x2f52 <memcpy+0x6>
    2f5c:	08 95       	ret

00002f5e <_exit>:
    2f5e:	f8 94       	cli

00002f60 <__stop_program>:
    2f60:	ff cf       	rjmp	.-2      	; 0x2f60 <__stop_program>
