
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002f0e  00002fa2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f0e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070d  00800238  00800238  00002fda  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002fda  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  0000300a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f6f  00000000  00000000  0000357a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000166f  00000000  00000000  000094e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003919  00000000  00000000  0000ab58  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f94  00000000  00000000  0000e474  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017a6  00000000  00000000  0000f408  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004438  00000000  00000000  00010bae  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014fe6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c3 c3       	rjmp	.+1926   	; 0x7ac <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 2d 0b 	jmp	0x165a	; 0x165a <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	c7 c7       	rjmp	.+3982   	; 0xff4 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 72 08 	jmp	0x10e4	; 0x10e4 <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	9e c4       	rjmp	.+2364   	; 0x9b2 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	79 c7       	rjmp	.+3826   	; 0xf84 <__vector_36>
      92:	00 00       	nop
      94:	e7 c7       	rjmp	.+4046   	; 0x1064 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x2c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ee e0       	ldi	r30, 0x0E	; 14
     17e:	ff e2       	ldi	r31, 0x2F	; 47
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a5 34       	cpi	r26, 0x45	; 69
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	df d0       	rcall	.+446    	; 0x360 <main>
     1a2:	0c 94 85 17 	jmp	0x2f0a	; 0x2f0a <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 64 09 	call	0x12c8	; 0x12c8 <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 a4 09 	call	0x1348	; 0x1348 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 99 09 	call	0x1332	; 0x1332 <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 b6 09 	call	0x136c	; 0x136c <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 38 02 	lds	r24, 0x0238
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 aa 09 	call	0x1354	; 0x1354 <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 27 09 	call	0x124e	; 0x124e <myUSART_transmitUSART1_c>
     1e2:	d0 93 38 02 	sts	0x0238, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 b0 09 	call	0x1360	; 0x1360 <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 38 02 	sts	0x0238, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 38 02 	sts	0x0238, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 38 02 	sts	0x0238, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 85 09 	call	0x130a	; 0x130a <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 93 08 	lds	r24, 0x0893
     232:	90 91 94 08 	lds	r25, 0x0894
     236:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xQueueGenericReceive>
     23a:	11 23       	and	r17, r17
     23c:	61 f1       	breq	.+88     	; 0x296 <RPI_sendTask+0x86>
     23e:	8e 81       	ldd	r24, Y+6	; 0x06
     240:	80 5d       	subi	r24, 0xD0	; 208
     242:	0e 94 27 09 	call	0x124e	; 0x124e <myUSART_transmitUSART1_c>
     246:	8a e0       	ldi	r24, 0x0A	; 10
     248:	0e 94 27 09 	call	0x124e	; 0x124e <myUSART_transmitUSART1_c>
     24c:	24 c0       	rjmp	.+72     	; 0x296 <RPI_sendTask+0x86>
     24e:	20 e0       	ldi	r18, 0x00	; 0
     250:	4f ef       	ldi	r20, 0xFF	; 255
     252:	5f ef       	ldi	r21, 0xFF	; 255
     254:	be 01       	movw	r22, r28
     256:	6f 5f       	subi	r22, 0xFF	; 255
     258:	7f 4f       	sbci	r23, 0xFF	; 255
     25a:	80 91 95 08 	lds	r24, 0x0895
     25e:	90 91 96 08 	lds	r25, 0x0896
     262:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xQueueGenericReceive>
     266:	89 81       	ldd	r24, Y+1	; 0x01
     268:	d1 d7       	rcall	.+4002   	; 0x120c <myUSART_transmitUSART0_c>
     26a:	87 e0       	ldi	r24, 0x07	; 7
     26c:	92 e0       	ldi	r25, 0x02	; 2
     26e:	0e 94 56 09 	call	0x12ac	; 0x12ac <myUSART_transmitUSART0>
     272:	ce 01       	movw	r24, r28
     274:	02 96       	adiw	r24, 0x02	; 2
     276:	0e 94 56 09 	call	0x12ac	; 0x12ac <myUSART_transmitUSART0>
     27a:	8a e0       	ldi	r24, 0x0A	; 10
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	0e 94 56 09 	call	0x12ac	; 0x12ac <myUSART_transmitUSART0>
     282:	11 23       	and	r17, r17
     284:	41 f0       	breq	.+16     	; 0x296 <RPI_sendTask+0x86>
     286:	89 81       	ldd	r24, Y+1	; 0x01
     288:	e2 d7       	rcall	.+4036   	; 0x124e <myUSART_transmitUSART1_c>
     28a:	ce 01       	movw	r24, r28
     28c:	02 96       	adiw	r24, 0x02	; 2
     28e:	0e 94 48 09 	call	0x1290	; 0x1290 <myUSART_transmitUSART1>
     292:	8a e0       	ldi	r24, 0x0A	; 10
     294:	dc d7       	rcall	.+4024   	; 0x124e <myUSART_transmitUSART1_c>
     296:	9e 81       	ldd	r25, Y+6	; 0x06
     298:	2f ef       	ldi	r18, 0xFF	; 255
     29a:	29 0f       	add	r18, r25
     29c:	2e 83       	std	Y+6, r18	; 0x06
     29e:	91 11       	cpse	r25, r1
     2a0:	d6 cf       	rjmp	.-84     	; 0x24e <RPI_sendTask+0x3e>
     2a2:	8a e0       	ldi	r24, 0x0A	; 10
     2a4:	b3 d7       	rcall	.+3942   	; 0x120c <myUSART_transmitUSART0_c>
     2a6:	ba cf       	rjmp	.-140    	; 0x21c <RPI_sendTask+0xc>

000002a8 <myTimerTask>:
     2a8:	9a d5       	rcall	.+2868   	; 0xdde <myTimer_Init>
     2aa:	fd d5       	rcall	.+3066   	; 0xea6 <myTimer_DelayChecker>
     2ac:	fe cf       	rjmp	.-4      	; 0x2aa <myTimerTask+0x2>

000002ae <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2ae:	8f ef       	ldi	r24, 0xFF	; 255
     2b0:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2b4:	ef e7       	ldi	r30, 0x7F	; 127
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	90 81       	ld	r25, Z
     2ba:	93 60       	ori	r25, 0x03	; 3
     2bc:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2be:	80 93 7d 00 	sts	0x007D, r24
     2c2:	08 95       	ret

000002c4 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2c4:	8c ec       	ldi	r24, 0xCC	; 204
     2c6:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2ca:	8e e3       	ldi	r24, 0x3E	; 62
     2cc:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2d0:	ee cf       	rjmp	.-36     	; 0x2ae <setDigitalInputPowerReduction>
     2d2:	08 95       	ret

000002d4 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2d4:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2d8:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2dc:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2e0:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2e4:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2e8:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ec:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2f0:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2f4:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2f8:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2fc:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     300:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     304:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     308:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     30c:	10 92 73 00 	sts	0x0073, r1
     310:	08 95       	ret

00000312 <init>:
}

void init()
{
     312:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     314:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     316:	f8 94       	cli
	{
		clearTimer();
     318:	dd df       	rcall	.-70     	; 0x2d4 <clearTimer>
		setPowerReduction();
     31a:	d4 df       	rcall	.-88     	; 0x2c4 <setPowerReduction>
		myUSART_USART0_Init();
     31c:	23 d7       	rcall	.+3654   	; 0x1164 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     31e:	48 d7       	rcall	.+3728   	; 0x11b0 <myUSART_USART1_Init>
		myADC_Init();
     320:	81 d3       	rcall	.+1794   	; 0xa24 <myADC_Init>
		
		MaxSonar_Init();
     322:	83 b3       	in	r24, 0x13	; 19
     324:	83 60       	ori	r24, 0x03	; 3
     326:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     328:	40 e0       	ldi	r20, 0x00	; 0
     32a:	61 e0       	ldi	r22, 0x01	; 1
     32c:	85 e0       	ldi	r24, 0x05	; 5
     32e:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xQueueGenericCreate>
     332:	90 93 94 08 	sts	0x0894, r25
     336:	80 93 93 08 	sts	0x0893, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     33a:	40 e0       	ldi	r20, 0x00	; 0
     33c:	65 e0       	ldi	r22, 0x05	; 5
     33e:	84 e1       	ldi	r24, 0x14	; 20
     340:	0e 94 2c 0c 	call	0x1858	; 0x1858 <xQueueGenericCreate>
     344:	90 93 96 08 	sts	0x0896, r25
     348:	80 93 95 08 	sts	0x0895, r24
		
		MOTOR_LEFT_INIT();
     34c:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     34e:	e1 e0       	ldi	r30, 0x01	; 1
     350:	f1 e0       	ldi	r31, 0x01	; 1
     352:	80 81       	ld	r24, Z
     354:	80 61       	ori	r24, 0x10	; 16
     356:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     358:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     35a:	78 94       	sei
}
     35c:	cf 91       	pop	r28
     35e:	08 95       	ret

00000360 <main>:
	
	// do nth
}

int main(void)
{
     360:	cf 93       	push	r28
     362:	df 93       	push	r29
     364:	cd b7       	in	r28, 0x3d	; 61
     366:	de b7       	in	r29, 0x3e	; 62
     368:	28 97       	sbiw	r28, 0x08	; 8
     36a:	0f b6       	in	r0, 0x3f	; 63
     36c:	f8 94       	cli
     36e:	de bf       	out	0x3e, r29	; 62
     370:	0f be       	out	0x3f, r0	; 63
     372:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     374:	ce df       	rcall	.-100    	; 0x312 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     376:	a1 2c       	mov	r10, r1
     378:	b1 2c       	mov	r11, r1
     37a:	c1 2c       	mov	r12, r1
     37c:	d1 2c       	mov	r13, r1
     37e:	ce 01       	movw	r24, r28
     380:	01 96       	adiw	r24, 0x01	; 1
     382:	7c 01       	movw	r14, r24
     384:	04 e0       	ldi	r16, 0x04	; 4
     386:	9c 01       	movw	r18, r24
     388:	49 e6       	ldi	r20, 0x69	; 105
     38a:	50 e0       	ldi	r21, 0x00	; 0
     38c:	6d e0       	ldi	r22, 0x0D	; 13
     38e:	72 e0       	ldi	r23, 0x02	; 2
     390:	84 e5       	ldi	r24, 0x54	; 84
     392:	91 e0       	ldi	r25, 0x01	; 1
     394:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     398:	ce 01       	movw	r24, r28
     39a:	07 96       	adiw	r24, 0x07	; 7
     39c:	7c 01       	movw	r14, r24
     39e:	02 e0       	ldi	r16, 0x02	; 2
     3a0:	20 e0       	ldi	r18, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	4d e6       	ldi	r20, 0x6D	; 109
     3a6:	51 e0       	ldi	r21, 0x01	; 1
     3a8:	65 e1       	ldi	r22, 0x15	; 21
     3aa:	72 e0       	ldi	r23, 0x02	; 2
     3ac:	89 e8       	ldi	r24, 0x89	; 137
     3ae:	92 e0       	ldi	r25, 0x02	; 2
     3b0:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3b4:	ce 01       	movw	r24, r28
     3b6:	05 96       	adiw	r24, 0x05	; 5
     3b8:	7c 01       	movw	r14, r24
     3ba:	03 e0       	ldi	r16, 0x03	; 3
     3bc:	20 e0       	ldi	r18, 0x00	; 0
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	47 e8       	ldi	r20, 0x87	; 135
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	6e e1       	ldi	r22, 0x1E	; 30
     3c6:	72 e0       	ldi	r23, 0x02	; 2
     3c8:	84 ed       	ldi	r24, 0xD4	; 212
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3d0:	ce 01       	movw	r24, r28
     3d2:	03 96       	adiw	r24, 0x03	; 3
     3d4:	7c 01       	movw	r14, r24
     3d6:	01 e0       	ldi	r16, 0x01	; 1
     3d8:	20 e0       	ldi	r18, 0x00	; 0
     3da:	30 e0       	ldi	r19, 0x00	; 0
     3dc:	47 e8       	ldi	r20, 0x87	; 135
     3de:	50 e0       	ldi	r21, 0x00	; 0
     3e0:	6a e2       	ldi	r22, 0x2A	; 42
     3e2:	72 e0       	ldi	r23, 0x02	; 2
     3e4:	88 e0       	ldi	r24, 0x08	; 8
     3e6:	91 e0       	ldi	r25, 0x01	; 1
     3e8:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ec:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <vTaskStartScheduler>
     3f0:	c1 cf       	rjmp	.-126    	; 0x374 <main+0x14>

000003f2 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3f2:	9c 01       	movw	r18, r24
     3f4:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3f6:	64 e6       	ldi	r22, 0x64	; 100
     3f8:	70 e0       	ldi	r23, 0x00	; 0
     3fa:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <__divmodhi4>
	
	if(input)
     3fe:	61 15       	cp	r22, r1
     400:	71 05       	cpc	r23, r1
     402:	21 f0       	breq	.+8      	; 0x40c <myItoa+0x1a>
		*buffer++ = input + '0';
     404:	80 e3       	ldi	r24, 0x30	; 48
     406:	86 0f       	add	r24, r22
     408:	80 83       	st	Z, r24
     40a:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     40c:	4c e9       	ldi	r20, 0x9C	; 156
     40e:	46 03       	mulsu	r20, r22
     410:	c0 01       	movw	r24, r0
     412:	47 9f       	mul	r20, r23
     414:	90 0d       	add	r25, r0
     416:	11 24       	eor	r1, r1
     418:	28 0f       	add	r18, r24
     41a:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     41c:	c9 01       	movw	r24, r18
     41e:	6a e0       	ldi	r22, 0x0A	; 10
     420:	70 e0       	ldi	r23, 0x00	; 0
     422:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <__divmodhi4>
	*buffer++ = input + '0';
     426:	80 e3       	ldi	r24, 0x30	; 48
     428:	86 0f       	add	r24, r22
     42a:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     42c:	8a e0       	ldi	r24, 0x0A	; 10
     42e:	68 9f       	mul	r22, r24
     430:	20 19       	sub	r18, r0
     432:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     434:	20 5d       	subi	r18, 0xD0	; 208
     436:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     438:	12 82       	std	Z+2, r1	; 0x02
     43a:	08 95       	ret

0000043c <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
     442:	00 d0       	rcall	.+0      	; 0x444 <obstacleSend+0x8>
     444:	1f 92       	push	r1
     446:	1f 92       	push	r1
     448:	cd b7       	in	r28, 0x3d	; 61
     44a:	de b7       	in	r29, 0x3e	; 62
     44c:	18 2f       	mov	r17, r24
     44e:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     450:	11 23       	and	r17, r17
     452:	89 f0       	breq	.+34     	; 0x476 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     454:	be 01       	movw	r22, r28
     456:	6e 5f       	subi	r22, 0xFE	; 254
     458:	7f 4f       	sbci	r23, 0xFF	; 255
     45a:	cb df       	rcall	.-106    	; 0x3f2 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     45c:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     45e:	20 e0       	ldi	r18, 0x00	; 0
     460:	4f ef       	ldi	r20, 0xFF	; 255
     462:	5f ef       	ldi	r21, 0xFF	; 255
     464:	be 01       	movw	r22, r28
     466:	6f 5f       	subi	r22, 0xFF	; 255
     468:	7f 4f       	sbci	r23, 0xFF	; 255
     46a:	80 91 95 08 	lds	r24, 0x0895
     46e:	90 91 96 08 	lds	r25, 0x0896
     472:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <xQueueGenericSend>
	}
}
     476:	0f 90       	pop	r0
     478:	0f 90       	pop	r0
     47a:	0f 90       	pop	r0
     47c:	0f 90       	pop	r0
     47e:	0f 90       	pop	r0
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	1f 91       	pop	r17
     486:	08 95       	ret

00000488 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     488:	6f 92       	push	r6
     48a:	7f 92       	push	r7
     48c:	8f 92       	push	r8
     48e:	9f 92       	push	r9
     490:	af 92       	push	r10
     492:	bf 92       	push	r11
     494:	cf 92       	push	r12
     496:	df 92       	push	r13
     498:	ef 92       	push	r14
     49a:	ff 92       	push	r15
     49c:	0f 93       	push	r16
     49e:	1f 93       	push	r17
     4a0:	cf 93       	push	r28
     4a2:	df 93       	push	r29
     4a4:	1f 92       	push	r1
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	89 83       	std	Y+1, r24	; 0x01
     4ac:	5b 01       	movw	r10, r22
     4ae:	3a 01       	movw	r6, r20
     4b0:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4b2:	20 e0       	ldi	r18, 0x00	; 0
     4b4:	4f ef       	ldi	r20, 0xFF	; 255
     4b6:	5f ef       	ldi	r21, 0xFF	; 255
     4b8:	be 01       	movw	r22, r28
     4ba:	6f 5f       	subi	r22, 0xFF	; 255
     4bc:	7f 4f       	sbci	r23, 0xFF	; 255
     4be:	80 91 93 08 	lds	r24, 0x0893
     4c2:	90 91 94 08 	lds	r25, 0x0894
     4c6:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4ca:	b3 01       	movw	r22, r6
     4cc:	f5 01       	movw	r30, r10
     4ce:	80 81       	ld	r24, Z
     4d0:	b5 df       	rcall	.-150    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4d2:	b4 01       	movw	r22, r8
     4d4:	f5 01       	movw	r30, r10
     4d6:	81 81       	ldd	r24, Z+1	; 0x01
     4d8:	b1 df       	rcall	.-158    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4da:	b8 01       	movw	r22, r16
     4dc:	f5 01       	movw	r30, r10
     4de:	82 81       	ldd	r24, Z+2	; 0x02
     4e0:	ad df       	rcall	.-166    	; 0x43c <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4e2:	b7 01       	movw	r22, r14
     4e4:	f5 01       	movw	r30, r10
     4e6:	83 81       	ldd	r24, Z+3	; 0x03
     4e8:	a9 df       	rcall	.-174    	; 0x43c <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4ea:	b6 01       	movw	r22, r12
     4ec:	f5 01       	movw	r30, r10
     4ee:	84 81       	ldd	r24, Z+4	; 0x04
     4f0:	a5 df       	rcall	.-182    	; 0x43c <obstacleSend>
		
	}
}
     4f2:	0f 90       	pop	r0
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	ff 90       	pop	r15
     4fe:	ef 90       	pop	r14
     500:	df 90       	pop	r13
     502:	cf 90       	pop	r12
     504:	bf 90       	pop	r11
     506:	af 90       	pop	r10
     508:	9f 90       	pop	r9
     50a:	8f 90       	pop	r8
     50c:	7f 90       	pop	r7
     50e:	6f 90       	pop	r6
     510:	08 95       	ret

00000512 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     512:	cf 93       	push	r28
     514:	df 93       	push	r29
     516:	cd b7       	in	r28, 0x3d	; 61
     518:	de b7       	in	r29, 0x3e	; 62
     51a:	a4 97       	sbiw	r28, 0x24	; 36
     51c:	0f b6       	in	r0, 0x3f	; 63
     51e:	f8 94       	cli
     520:	de bf       	out	0x3e, r29	; 62
     522:	0f be       	out	0x3f, r0	; 63
     524:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     526:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     528:	86 e0       	ldi	r24, 0x06	; 6
     52a:	fe 01       	movw	r30, r28
     52c:	34 96       	adiw	r30, 0x04	; 4
     52e:	df 01       	movw	r26, r30
     530:	98 2f       	mov	r25, r24
     532:	1d 92       	st	X+, r1
     534:	9a 95       	dec	r25
     536:	e9 f7       	brne	.-6      	; 0x532 <Sonar_Task+0x20>
     538:	36 96       	adiw	r30, 0x06	; 6
     53a:	df 01       	movw	r26, r30
     53c:	98 2f       	mov	r25, r24
     53e:	1d 92       	st	X+, r1
     540:	9a 95       	dec	r25
     542:	e9 f7       	brne	.-6      	; 0x53e <Sonar_Task+0x2c>
     544:	36 96       	adiw	r30, 0x06	; 6
     546:	df 01       	movw	r26, r30
     548:	98 2f       	mov	r25, r24
     54a:	1d 92       	st	X+, r1
     54c:	9a 95       	dec	r25
     54e:	e9 f7       	brne	.-6      	; 0x54a <Sonar_Task+0x38>
     550:	36 96       	adiw	r30, 0x06	; 6
     552:	df 01       	movw	r26, r30
     554:	1d 92       	st	X+, r1
     556:	8a 95       	dec	r24
     558:	e9 f7       	brne	.-6      	; 0x554 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     55a:	36 96       	adiw	r30, 0x06	; 6
     55c:	85 e0       	ldi	r24, 0x05	; 5
     55e:	df 01       	movw	r26, r30
     560:	1d 92       	st	X+, r1
     562:	8a 95       	dec	r24
     564:	e9 f7       	brne	.-6      	; 0x560 <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     566:	84 e2       	ldi	r24, 0x24	; 36
     568:	b1 d3       	rcall	.+1890   	; 0xccc <mySharpIR_Read>
     56a:	9a a3       	std	Y+34, r25	; 0x22
     56c:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     56e:	0e 94 28 10 	call	0x2050	; 0x2050 <xTaskGetTickCount>
     572:	9a 83       	std	Y+2, r25	; 0x02
     574:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     576:	a5 d1       	rcall	.+842    	; 0x8c2 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     578:	87 e2       	ldi	r24, 0x27	; 39
     57a:	09 d2       	rcall	.+1042   	; 0x98e <myMaxSonar_Read>
     57c:	be 01       	movw	r22, r28
     57e:	66 5f       	subi	r22, 0xF6	; 246
     580:	7f 4f       	sbci	r23, 0xFF	; 255
     582:	fc d1       	rcall	.+1016   	; 0x97c <myMaxSonar_getFilteredReading>
     584:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     586:	86 e2       	ldi	r24, 0x26	; 38
     588:	02 d2       	rcall	.+1028   	; 0x98e <myMaxSonar_Read>
     58a:	be 01       	movw	r22, r28
     58c:	60 5f       	subi	r22, 0xF0	; 240
     58e:	7f 4f       	sbci	r23, 0xFF	; 255
     590:	f5 d1       	rcall	.+1002   	; 0x97c <myMaxSonar_getFilteredReading>
     592:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     594:	85 e2       	ldi	r24, 0x25	; 37
     596:	fb d1       	rcall	.+1014   	; 0x98e <myMaxSonar_Read>
     598:	be 01       	movw	r22, r28
     59a:	6a 5e       	subi	r22, 0xEA	; 234
     59c:	7f 4f       	sbci	r23, 0xFF	; 255
     59e:	ee d1       	rcall	.+988    	; 0x97c <myMaxSonar_getFilteredReading>
     5a0:	2c 01       	movw	r4, r24
		
		myMaxSonar_TopStart();
     5a2:	95 d1       	rcall	.+810    	; 0x8ce <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5a4:	83 e2       	ldi	r24, 0x23	; 35
     5a6:	f3 d1       	rcall	.+998    	; 0x98e <myMaxSonar_Read>
     5a8:	be 01       	movw	r22, r28
     5aa:	6c 5f       	subi	r22, 0xFC	; 252
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	e6 d1       	rcall	.+972    	; 0x97c <myMaxSonar_getFilteredReading>
     5b0:	9c a3       	std	Y+36, r25	; 0x24
     5b2:	8b a3       	std	Y+35, r24	; 0x23
			
			
		btmIR		= mySharpIR_Read(AN12);
     5b4:	84 e2       	ldi	r24, 0x24	; 36
     5b6:	8a d3       	rcall	.+1812   	; 0xccc <mySharpIR_Read>
     5b8:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5ba:	bc 01       	movw	r22, r24
     5bc:	ce 01       	movw	r24, r28
     5be:	81 96       	adiw	r24, 0x21	; 33
     5c0:	be d3       	rcall	.+1916   	; 0xd3e <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5c2:	c9 a0       	ldd	r12, Y+33	; 0x21
     5c4:	da a0       	ldd	r13, Y+34	; 0x22
     5c6:	54 01       	movw	r10, r8
     5c8:	eb a0       	ldd	r14, Y+35	; 0x23
     5ca:	fc a0       	ldd	r15, Y+36	; 0x24
     5cc:	82 01       	movw	r16, r4
     5ce:	91 01       	movw	r18, r2
     5d0:	ae 01       	movw	r20, r28
     5d2:	44 5e       	subi	r20, 0xE4	; 228
     5d4:	5f 4f       	sbci	r21, 0xFF	; 255
     5d6:	6b 81       	ldd	r22, Y+3	; 0x03
     5d8:	c3 01       	movw	r24, r6
     5da:	3e d3       	rcall	.+1660   	; 0xc58 <obstacleDetection>
     5dc:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5de:	ce 01       	movw	r24, r28
     5e0:	4c 96       	adiw	r24, 0x1c	; 28
     5e2:	7c 01       	movw	r14, r24
     5e4:	84 01       	movw	r16, r8
     5e6:	92 01       	movw	r18, r4
     5e8:	a1 01       	movw	r20, r2
     5ea:	6b a1       	ldd	r22, Y+35	; 0x23
     5ec:	7c a1       	ldd	r23, Y+36	; 0x24
     5ee:	c3 01       	movw	r24, r6
     5f0:	b6 d2       	rcall	.+1388   	; 0xb5e <obstacleAvoidance>
		
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5f2:	be 01       	movw	r22, r28
     5f4:	6d 5f       	subi	r22, 0xFD	; 253
     5f6:	7f 4f       	sbci	r23, 0xFF	; 255
     5f8:	c7 01       	movw	r24, r14
     5fa:	96 d2       	rcall	.+1324   	; 0xb28 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5fc:	cb a0       	ldd	r12, Y+35	; 0x23
     5fe:	dc a0       	ldd	r13, Y+36	; 0x24
     600:	74 01       	movw	r14, r8
     602:	82 01       	movw	r16, r4
     604:	91 01       	movw	r18, r2
     606:	a3 01       	movw	r20, r6
     608:	be 01       	movw	r22, r28
     60a:	64 5e       	subi	r22, 0xE4	; 228
     60c:	7f 4f       	sbci	r23, 0xFF	; 255
     60e:	8b 81       	ldd	r24, Y+3	; 0x03
     610:	3b df       	rcall	.-394    	; 0x488 <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     612:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     614:	18 a2       	std	Y+32, r1	; 0x20
     616:	1f 8e       	std	Y+31, r1	; 0x1f
     618:	1e 8e       	std	Y+30, r1	; 0x1e
     61a:	1d 8e       	std	Y+29, r1	; 0x1d
     61c:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     61e:	66 e9       	ldi	r22, 0x96	; 150
     620:	70 e0       	ldi	r23, 0x00	; 0
     622:	ce 01       	movw	r24, r28
     624:	01 96       	adiw	r24, 0x01	; 1
     626:	0e 94 76 11 	call	0x22ec	; 0x22ec <vTaskDelayUntil>
     62a:	a5 cf       	rjmp	.-182    	; 0x576 <Sonar_Task+0x64>

0000062c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
     630:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     632:	0e 94 22 10 	call	0x2044	; 0x2044 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     636:	80 91 39 02 	lds	r24, 0x0239
     63a:	90 91 3a 02 	lds	r25, 0x023A
     63e:	89 2b       	or	r24, r25
     640:	31 f4       	brne	.+12     	; 0x64e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     642:	8e e3       	ldi	r24, 0x3E	; 62
     644:	92 e0       	ldi	r25, 0x02	; 2
     646:	90 93 3a 02 	sts	0x023A, r25
     64a:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     64e:	40 91 3b 02 	lds	r20, 0x023B
     652:	50 91 3c 02 	lds	r21, 0x023C
     656:	9e 01       	movw	r18, r28
     658:	24 0f       	add	r18, r20
     65a:	35 1f       	adc	r19, r21
     65c:	2b 3d       	cpi	r18, 0xDB	; 219
     65e:	85 e0       	ldi	r24, 0x05	; 5
     660:	38 07       	cpc	r19, r24
     662:	70 f4       	brcc	.+28     	; 0x680 <pvPortMalloc+0x54>
     664:	42 17       	cp	r20, r18
     666:	53 07       	cpc	r21, r19
     668:	70 f4       	brcc	.+28     	; 0x686 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     66a:	c0 91 39 02 	lds	r28, 0x0239
     66e:	d0 91 3a 02 	lds	r29, 0x023A
     672:	c4 0f       	add	r28, r20
     674:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     676:	30 93 3c 02 	sts	0x023C, r19
     67a:	20 93 3b 02 	sts	0x023B, r18
     67e:	05 c0       	rjmp	.+10     	; 0x68a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     680:	c0 e0       	ldi	r28, 0x00	; 0
     682:	d0 e0       	ldi	r29, 0x00	; 0
     684:	02 c0       	rjmp	.+4      	; 0x68a <pvPortMalloc+0x5e>
     686:	c0 e0       	ldi	r28, 0x00	; 0
     688:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     68a:	0e 94 f5 10 	call	0x21ea	; 0x21ea <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     68e:	ce 01       	movw	r24, r28
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	08 95       	ret

00000696 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     696:	08 95       	ret

00000698 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     698:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     69a:	03 96       	adiw	r24, 0x03	; 3
     69c:	92 83       	std	Z+2, r25	; 0x02
     69e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6a0:	2f ef       	ldi	r18, 0xFF	; 255
     6a2:	3f ef       	ldi	r19, 0xFF	; 255
     6a4:	34 83       	std	Z+4, r19	; 0x04
     6a6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a8:	96 83       	std	Z+6, r25	; 0x06
     6aa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ac:	90 87       	std	Z+8, r25	; 0x08
     6ae:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6b0:	10 82       	st	Z, r1
     6b2:	08 95       	ret

000006b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6b4:	fc 01       	movw	r30, r24
     6b6:	11 86       	std	Z+9, r1	; 0x09
     6b8:	10 86       	std	Z+8, r1	; 0x08
     6ba:	08 95       	ret

000006bc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	9c 01       	movw	r18, r24
     6c2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6c4:	dc 01       	movw	r26, r24
     6c6:	11 96       	adiw	r26, 0x01	; 1
     6c8:	cd 91       	ld	r28, X+
     6ca:	dc 91       	ld	r29, X
     6cc:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6ce:	d3 83       	std	Z+3, r29	; 0x03
     6d0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6d2:	8c 81       	ldd	r24, Y+4	; 0x04
     6d4:	9d 81       	ldd	r25, Y+5	; 0x05
     6d6:	95 83       	std	Z+5, r25	; 0x05
     6d8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6da:	8c 81       	ldd	r24, Y+4	; 0x04
     6dc:	9d 81       	ldd	r25, Y+5	; 0x05
     6de:	dc 01       	movw	r26, r24
     6e0:	13 96       	adiw	r26, 0x03	; 3
     6e2:	7c 93       	st	X, r23
     6e4:	6e 93       	st	-X, r22
     6e6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6e8:	7d 83       	std	Y+5, r23	; 0x05
     6ea:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ec:	31 87       	std	Z+9, r19	; 0x09
     6ee:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6f0:	f9 01       	movw	r30, r18
     6f2:	80 81       	ld	r24, Z
     6f4:	8f 5f       	subi	r24, 0xFF	; 255
     6f6:	80 83       	st	Z, r24
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6fe:	cf 93       	push	r28
     700:	df 93       	push	r29
     702:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     704:	48 81       	ld	r20, Y
     706:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     708:	4f 3f       	cpi	r20, 0xFF	; 255
     70a:	2f ef       	ldi	r18, 0xFF	; 255
     70c:	52 07       	cpc	r21, r18
     70e:	21 f4       	brne	.+8      	; 0x718 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     710:	fc 01       	movw	r30, r24
     712:	a7 81       	ldd	r26, Z+7	; 0x07
     714:	b0 85       	ldd	r27, Z+8	; 0x08
     716:	0d c0       	rjmp	.+26     	; 0x732 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     718:	dc 01       	movw	r26, r24
     71a:	13 96       	adiw	r26, 0x03	; 3
     71c:	12 96       	adiw	r26, 0x02	; 2
     71e:	ed 91       	ld	r30, X+
     720:	fc 91       	ld	r31, X
     722:	13 97       	sbiw	r26, 0x03	; 3
     724:	20 81       	ld	r18, Z
     726:	31 81       	ldd	r19, Z+1	; 0x01
     728:	42 17       	cp	r20, r18
     72a:	53 07       	cpc	r21, r19
     72c:	10 f0       	brcs	.+4      	; 0x732 <vListInsert+0x34>
     72e:	df 01       	movw	r26, r30
     730:	f5 cf       	rjmp	.-22     	; 0x71c <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     732:	12 96       	adiw	r26, 0x02	; 2
     734:	ed 91       	ld	r30, X+
     736:	fc 91       	ld	r31, X
     738:	13 97       	sbiw	r26, 0x03	; 3
     73a:	fb 83       	std	Y+3, r31	; 0x03
     73c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     73e:	d5 83       	std	Z+5, r29	; 0x05
     740:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     742:	bd 83       	std	Y+5, r27	; 0x05
     744:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     746:	13 96       	adiw	r26, 0x03	; 3
     748:	dc 93       	st	X, r29
     74a:	ce 93       	st	-X, r28
     74c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     74e:	99 87       	std	Y+9, r25	; 0x09
     750:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     752:	fc 01       	movw	r30, r24
     754:	20 81       	ld	r18, Z
     756:	2f 5f       	subi	r18, 0xFF	; 255
     758:	20 83       	st	Z, r18
}
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     760:	cf 93       	push	r28
     762:	df 93       	push	r29
     764:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     766:	a0 85       	ldd	r26, Z+8	; 0x08
     768:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     76a:	c2 81       	ldd	r28, Z+2	; 0x02
     76c:	d3 81       	ldd	r29, Z+3	; 0x03
     76e:	84 81       	ldd	r24, Z+4	; 0x04
     770:	95 81       	ldd	r25, Z+5	; 0x05
     772:	9d 83       	std	Y+5, r25	; 0x05
     774:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     776:	c4 81       	ldd	r28, Z+4	; 0x04
     778:	d5 81       	ldd	r29, Z+5	; 0x05
     77a:	82 81       	ldd	r24, Z+2	; 0x02
     77c:	93 81       	ldd	r25, Z+3	; 0x03
     77e:	9b 83       	std	Y+3, r25	; 0x03
     780:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     782:	11 96       	adiw	r26, 0x01	; 1
     784:	cd 91       	ld	r28, X+
     786:	dc 91       	ld	r29, X
     788:	12 97       	sbiw	r26, 0x02	; 2
     78a:	ce 17       	cp	r28, r30
     78c:	df 07       	cpc	r29, r31
     78e:	31 f4       	brne	.+12     	; 0x79c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     790:	8c 81       	ldd	r24, Y+4	; 0x04
     792:	9d 81       	ldd	r25, Y+5	; 0x05
     794:	12 96       	adiw	r26, 0x02	; 2
     796:	9c 93       	st	X, r25
     798:	8e 93       	st	-X, r24
     79a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     79c:	11 86       	std	Z+9, r1	; 0x09
     79e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7a0:	8c 91       	ld	r24, X
     7a2:	81 50       	subi	r24, 0x01	; 1
     7a4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7a6:	df 91       	pop	r29
     7a8:	cf 91       	pop	r28
     7aa:	08 95       	ret

000007ac <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7ac:	1f 92       	push	r1
     7ae:	0f 92       	push	r0
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	0f 92       	push	r0
     7b4:	11 24       	eor	r1, r1
     7b6:	0b b6       	in	r0, 0x3b	; 59
     7b8:	0f 92       	push	r0
     7ba:	2f 93       	push	r18
     7bc:	3f 93       	push	r19
     7be:	4f 93       	push	r20
     7c0:	5f 93       	push	r21
     7c2:	6f 93       	push	r22
     7c4:	7f 93       	push	r23
     7c6:	8f 93       	push	r24
     7c8:	9f 93       	push	r25
     7ca:	af 93       	push	r26
     7cc:	bf 93       	push	r27
     7ce:	ef 93       	push	r30
     7d0:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7d2:	1b 9b       	sbis	0x03, 3	; 3
     7d4:	0d c0       	rjmp	.+26     	; 0x7f0 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7d6:	1d d3       	rcall	.+1594   	; 0xe12 <myTimer_Read>
     7d8:	90 e0       	ldi	r25, 0x00	; 0
     7da:	90 93 9c 08 	sts	0x089C, r25
     7de:	80 93 9b 08 	sts	0x089B, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7e2:	0e 94 32 10 	call	0x2064	; 0x2064 <xTaskGetTickCountFromISR>
     7e6:	90 93 98 08 	sts	0x0898, r25
     7ea:	80 93 97 08 	sts	0x0897, r24
     7ee:	56 c0       	rjmp	.+172    	; 0x89c <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7f0:	1b 99       	sbic	0x03, 3	; 3
     7f2:	54 c0       	rjmp	.+168    	; 0x89c <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7f4:	0e 94 32 10 	call	0x2064	; 0x2064 <xTaskGetTickCountFromISR>
     7f8:	90 93 a2 08 	sts	0x08A2, r25
     7fc:	80 93 a1 08 	sts	0x08A1, r24
     800:	20 91 97 08 	lds	r18, 0x0897
     804:	30 91 98 08 	lds	r19, 0x0898
     808:	82 17       	cp	r24, r18
     80a:	93 07       	cpc	r25, r19
     80c:	4c f4       	brge	.+18     	; 0x820 <__vector_9+0x74>
			ms_tickEnd += 65535;
     80e:	80 91 a1 08 	lds	r24, 0x08A1
     812:	90 91 a2 08 	lds	r25, 0x08A2
     816:	01 97       	sbiw	r24, 0x01	; 1
     818:	90 93 a2 08 	sts	0x08A2, r25
     81c:	80 93 a1 08 	sts	0x08A1, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     820:	f8 d2       	rcall	.+1520   	; 0xe12 <myTimer_Read>
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	90 93 a4 08 	sts	0x08A4, r25
     828:	80 93 a3 08 	sts	0x08A3, r24
     82c:	20 91 9b 08 	lds	r18, 0x089B
     830:	30 91 9c 08 	lds	r19, 0x089C
     834:	82 17       	cp	r24, r18
     836:	93 07       	cpc	r25, r19
     838:	54 f4       	brge	.+20     	; 0x84e <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     83a:	80 91 a3 08 	lds	r24, 0x08A3
     83e:	90 91 a4 08 	lds	r25, 0x08A4
     842:	86 50       	subi	r24, 0x06	; 6
     844:	9f 4f       	sbci	r25, 0xFF	; 255
     846:	90 93 a4 08 	sts	0x08A4, r25
     84a:	80 93 a3 08 	sts	0x08A3, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     84e:	80 91 a3 08 	lds	r24, 0x08A3
     852:	90 91 a4 08 	lds	r25, 0x08A4
     856:	20 91 9b 08 	lds	r18, 0x089B
     85a:	30 91 9c 08 	lds	r19, 0x089C
     85e:	82 1b       	sub	r24, r18
     860:	93 0b       	sbc	r25, r19
     862:	90 93 9e 08 	sts	0x089E, r25
     866:	80 93 9d 08 	sts	0x089D, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     86a:	80 91 a1 08 	lds	r24, 0x08A1
     86e:	90 91 a2 08 	lds	r25, 0x08A2
     872:	20 91 97 08 	lds	r18, 0x0897
     876:	30 91 98 08 	lds	r19, 0x0898
     87a:	82 1b       	sub	r24, r18
     87c:	93 0b       	sbc	r25, r19
     87e:	90 93 9a 08 	sts	0x089A, r25
     882:	80 93 99 08 	sts	0x0899, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     886:	20 e0       	ldi	r18, 0x00	; 0
     888:	40 e0       	ldi	r20, 0x00	; 0
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	60 e0       	ldi	r22, 0x00	; 0
     88e:	70 e0       	ldi	r23, 0x00	; 0
     890:	80 91 9f 08 	lds	r24, 0x089F
     894:	90 91 a0 08 	lds	r25, 0x08A0
     898:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <xQueueGenericSendFromISR>
	}	
}
     89c:	ff 91       	pop	r31
     89e:	ef 91       	pop	r30
     8a0:	bf 91       	pop	r27
     8a2:	af 91       	pop	r26
     8a4:	9f 91       	pop	r25
     8a6:	8f 91       	pop	r24
     8a8:	7f 91       	pop	r23
     8aa:	6f 91       	pop	r22
     8ac:	5f 91       	pop	r21
     8ae:	4f 91       	pop	r20
     8b0:	3f 91       	pop	r19
     8b2:	2f 91       	pop	r18
     8b4:	0f 90       	pop	r0
     8b6:	0b be       	out	0x3b, r0	; 59
     8b8:	0f 90       	pop	r0
     8ba:	0f be       	out	0x3f, r0	; 63
     8bc:	0f 90       	pop	r0
     8be:	1f 90       	pop	r1
     8c0:	18 95       	reti

000008c2 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8c2:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8c4:	89 e1       	ldi	r24, 0x19	; 25
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	a6 d2       	rcall	.+1356   	; 0xe16 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8ca:	a1 98       	cbi	0x14, 1	; 20
     8cc:	08 95       	ret

000008ce <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8ce:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro2(25); // delay 25 micro seconds...
     8d0:	89 e1       	ldi	r24, 0x19	; 25
     8d2:	90 e0       	ldi	r25, 0x00	; 0
     8d4:	c4 d2       	rcall	.+1416   	; 0xe5e <myTimer_DelayMicro2>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8d6:	a0 98       	cbi	0x14, 0	; 20
     8d8:	08 95       	ret

000008da <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8da:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8dc:	80 81       	ld	r24, Z
     8de:	91 81       	ldd	r25, Z+1	; 0x01
     8e0:	22 81       	ldd	r18, Z+2	; 0x02
     8e2:	33 81       	ldd	r19, Z+3	; 0x03
     8e4:	28 17       	cp	r18, r24
     8e6:	39 07       	cpc	r19, r25
     8e8:	54 f4       	brge	.+20     	; 0x8fe <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8ea:	44 81       	ldd	r20, Z+4	; 0x04
     8ec:	55 81       	ldd	r21, Z+5	; 0x05
     8ee:	42 17       	cp	r20, r18
     8f0:	53 07       	cpc	r21, r19
     8f2:	84 f0       	brlt	.+32     	; 0x914 <myMaxSonar_extractMedian+0x3a>
     8f4:	48 17       	cp	r20, r24
     8f6:	59 07       	cpc	r21, r25
     8f8:	74 f4       	brge	.+28     	; 0x916 <myMaxSonar_extractMedian+0x3c>
     8fa:	ca 01       	movw	r24, r20
     8fc:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8fe:	44 81       	ldd	r20, Z+4	; 0x04
     900:	55 81       	ldd	r21, Z+5	; 0x05
     902:	48 17       	cp	r20, r24
     904:	59 07       	cpc	r21, r25
     906:	3c f0       	brlt	.+14     	; 0x916 <myMaxSonar_extractMedian+0x3c>
     908:	ca 01       	movw	r24, r20
     90a:	24 17       	cp	r18, r20
     90c:	35 07       	cpc	r19, r21
     90e:	1c f4       	brge	.+6      	; 0x916 <myMaxSonar_extractMedian+0x3c>
     910:	c9 01       	movw	r24, r18
     912:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     914:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     916:	08 95       	ret

00000918 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_RANGE) || currentReading < (prevReading - NOISE_RANGE))
     918:	9b 01       	movw	r18, r22
     91a:	28 5f       	subi	r18, 0xF8	; 248
     91c:	3f 4f       	sbci	r19, 0xFF	; 255
     91e:	28 17       	cp	r18, r24
     920:	39 07       	cpc	r19, r25
     922:	3c f0       	brlt	.+14     	; 0x932 <myMaxSonar_Stabilizer+0x1a>
     924:	20 51       	subi	r18, 0x10	; 16
     926:	31 09       	sbc	r19, r1
     928:	82 17       	cp	r24, r18
     92a:	93 07       	cpc	r25, r19
     92c:	14 f0       	brlt	.+4      	; 0x932 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     92e:	86 2f       	mov	r24, r22
     930:	97 2f       	mov	r25, r23
}
     932:	08 95       	ret

00000934 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     934:	0f 93       	push	r16
     936:	1f 93       	push	r17
     938:	cf 93       	push	r28
     93a:	df 93       	push	r29
     93c:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     93e:	00 91 00 02 	lds	r16, 0x0200
     942:	10 e0       	ldi	r17, 0x00	; 0
     944:	f8 01       	movw	r30, r16
     946:	ee 0f       	add	r30, r30
     948:	ff 1f       	adc	r31, r31
     94a:	e6 0f       	add	r30, r22
     94c:	f7 1f       	adc	r31, r23
     94e:	60 81       	ld	r22, Z
     950:	71 81       	ldd	r23, Z+1	; 0x01
     952:	e2 df       	rcall	.-60     	; 0x918 <myMaxSonar_Stabilizer>
     954:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     956:	c8 01       	movw	r24, r16
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	63 e0       	ldi	r22, 0x03	; 3
     95c:	70 e0       	ldi	r23, 0x00	; 0
     95e:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <__divmodhi4>
     962:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	c8 0f       	add	r28, r24
     96c:	d9 1f       	adc	r29, r25
     96e:	39 83       	std	Y+1, r19	; 0x01
     970:	28 83       	st	Y, r18
}
     972:	df 91       	pop	r29
     974:	cf 91       	pop	r28
     976:	1f 91       	pop	r17
     978:	0f 91       	pop	r16
     97a:	08 95       	ret

0000097c <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     982:	d8 df       	rcall	.-80     	; 0x934 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     984:	ce 01       	movw	r24, r28
     986:	a9 df       	rcall	.-174    	; 0x8da <myMaxSonar_extractMedian>

}
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     98e:	b5 d0       	rcall	.+362    	; 0xafa <myADC_analogRead>
     990:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     992:	63 e0       	ldi	r22, 0x03	; 3
     994:	70 e0       	ldi	r23, 0x00	; 0
     996:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     99a:	26 0f       	add	r18, r22
     99c:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     99e:	29 3e       	cpi	r18, 0xE9	; 233
     9a0:	83 e0       	ldi	r24, 0x03	; 3
     9a2:	38 07       	cpc	r19, r24
     9a4:	1c f0       	brlt	.+6      	; 0x9ac <myMaxSonar_Read+0x1e>
		return 999;
     9a6:	87 ee       	ldi	r24, 0xE7	; 231
     9a8:	93 e0       	ldi	r25, 0x03	; 3
     9aa:	08 95       	ret
	
	return reading;
     9ac:	82 2f       	mov	r24, r18
     9ae:	93 2f       	mov	r25, r19
}
     9b0:	08 95       	ret

000009b2 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9b2:	1f 92       	push	r1
     9b4:	0f 92       	push	r0
     9b6:	0f b6       	in	r0, 0x3f	; 63
     9b8:	0f 92       	push	r0
     9ba:	11 24       	eor	r1, r1
     9bc:	0b b6       	in	r0, 0x3b	; 59
     9be:	0f 92       	push	r0
     9c0:	2f 93       	push	r18
     9c2:	3f 93       	push	r19
     9c4:	4f 93       	push	r20
     9c6:	5f 93       	push	r21
     9c8:	6f 93       	push	r22
     9ca:	7f 93       	push	r23
     9cc:	8f 93       	push	r24
     9ce:	9f 93       	push	r25
     9d0:	af 93       	push	r26
     9d2:	bf 93       	push	r27
     9d4:	ef 93       	push	r30
     9d6:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9d8:	80 91 78 00 	lds	r24, 0x0078
     9dc:	80 93 a5 08 	sts	0x08A5, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9e0:	80 91 79 00 	lds	r24, 0x0079
     9e4:	80 93 a6 08 	sts	0x08A6, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9e8:	20 e0       	ldi	r18, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	60 e0       	ldi	r22, 0x00	; 0
     9f0:	70 e0       	ldi	r23, 0x00	; 0
     9f2:	80 91 a9 08 	lds	r24, 0x08A9
     9f6:	90 91 aa 08 	lds	r25, 0x08AA
     9fa:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <xQueueGenericSendFromISR>
}
     9fe:	ff 91       	pop	r31
     a00:	ef 91       	pop	r30
     a02:	bf 91       	pop	r27
     a04:	af 91       	pop	r26
     a06:	9f 91       	pop	r25
     a08:	8f 91       	pop	r24
     a0a:	7f 91       	pop	r23
     a0c:	6f 91       	pop	r22
     a0e:	5f 91       	pop	r21
     a10:	4f 91       	pop	r20
     a12:	3f 91       	pop	r19
     a14:	2f 91       	pop	r18
     a16:	0f 90       	pop	r0
     a18:	0b be       	out	0x3b, r0	; 59
     a1a:	0f 90       	pop	r0
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	0f 90       	pop	r0
     a20:	1f 90       	pop	r1
     a22:	18 95       	reti

00000a24 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a24:	8f e8       	ldi	r24, 0x8F	; 143
     a26:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a2a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a34:	43 e0       	ldi	r20, 0x03	; 3
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	0e d7       	rcall	.+3612   	; 0x1858 <xQueueGenericCreate>
     a3c:	90 93 aa 08 	sts	0x08AA, r25
     a40:	80 93 a9 08 	sts	0x08A9, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a44:	81 e0       	ldi	r24, 0x01	; 1
     a46:	c8 d7       	rcall	.+3984   	; 0x19d8 <xQueueCreateMutex>
     a48:	90 93 a8 08 	sts	0x08A8, r25
     a4c:	80 93 a7 08 	sts	0x08A7, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	40 e0       	ldi	r20, 0x00	; 0
     a54:	50 e0       	ldi	r21, 0x00	; 0
     a56:	60 e0       	ldi	r22, 0x00	; 0
     a58:	70 e0       	ldi	r23, 0x00	; 0
     a5a:	2b c7       	rjmp	.+3670   	; 0x18b2 <xQueueGenericSend>
     a5c:	08 95       	ret

00000a5e <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a5e:	cf 93       	push	r28
     a60:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a62:	20 e0       	ldi	r18, 0x00	; 0
     a64:	4f ef       	ldi	r20, 0xFF	; 255
     a66:	5f ef       	ldi	r21, 0xFF	; 255
     a68:	60 e0       	ldi	r22, 0x00	; 0
     a6a:	70 e0       	ldi	r23, 0x00	; 0
     a6c:	80 91 a7 08 	lds	r24, 0x08A7
     a70:	90 91 a8 08 	lds	r25, 0x08A8
     a74:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a78:	ec e7       	ldi	r30, 0x7C	; 124
     a7a:	f0 e0       	ldi	r31, 0x00	; 0
     a7c:	80 81       	ld	r24, Z
     a7e:	9c 2f       	mov	r25, r28
     a80:	9f 71       	andi	r25, 0x1F	; 31
     a82:	80 76       	andi	r24, 0x60	; 96
     a84:	89 2b       	or	r24, r25
     a86:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a88:	eb e7       	ldi	r30, 0x7B	; 123
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	20 81       	ld	r18, Z
     a8e:	c0 72       	andi	r28, 0x20	; 32
     a90:	8c 2f       	mov	r24, r28
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	95 95       	asr	r25
     a96:	87 95       	ror	r24
     a98:	95 95       	asr	r25
     a9a:	87 95       	ror	r24
     a9c:	92 2f       	mov	r25, r18
     a9e:	90 76       	andi	r25, 0x60	; 96
     aa0:	89 2b       	or	r24, r25
     aa2:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     aa4:	ea e7       	ldi	r30, 0x7A	; 122
     aa6:	f0 e0       	ldi	r31, 0x00	; 0
     aa8:	80 81       	ld	r24, Z
     aaa:	80 64       	ori	r24, 0x40	; 64
     aac:	80 83       	st	Z, r24
}
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ab6:	20 e0       	ldi	r18, 0x00	; 0
     ab8:	4f ef       	ldi	r20, 0xFF	; 255
     aba:	5f ef       	ldi	r21, 0xFF	; 255
     abc:	60 e0       	ldi	r22, 0x00	; 0
     abe:	70 e0       	ldi	r23, 0x00	; 0
     ac0:	80 91 a9 08 	lds	r24, 0x08A9
     ac4:	90 91 aa 08 	lds	r25, 0x08AA
     ac8:	ec d7       	rcall	.+4056   	; 0x1aa2 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     aca:	c0 91 a6 08 	lds	r28, 0x08A6
     ace:	c3 70       	andi	r28, 0x03	; 3
     ad0:	d0 e0       	ldi	r29, 0x00	; 0
     ad2:	dc 2f       	mov	r29, r28
     ad4:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ad6:	80 91 a5 08 	lds	r24, 0x08A5
     ada:	c8 0f       	add	r28, r24
     adc:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     ade:	20 e0       	ldi	r18, 0x00	; 0
     ae0:	40 e0       	ldi	r20, 0x00	; 0
     ae2:	50 e0       	ldi	r21, 0x00	; 0
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	70 e0       	ldi	r23, 0x00	; 0
     ae8:	80 91 a7 08 	lds	r24, 0x08A7
     aec:	90 91 a8 08 	lds	r25, 0x08A8
     af0:	e0 d6       	rcall	.+3520   	; 0x18b2 <xQueueGenericSend>
	
	return adcReading;
     af2:	ce 01       	movw	r24, r28
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     afa:	cf 93       	push	r28
     afc:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     afe:	af df       	rcall	.-162    	; 0xa5e <myADC_startADC>
	return myADC_readADC(channel);
     b00:	8c 2f       	mov	r24, r28
     b02:	d7 df       	rcall	.-82     	; 0xab2 <myADC_readADC>
}
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b08:	9c 01       	movw	r18, r24
     b0a:	29 5f       	subi	r18, 0xF9	; 249
     b0c:	3f 4f       	sbci	r19, 0xFF	; 255
     b0e:	26 17       	cp	r18, r22
     b10:	37 07       	cpc	r19, r23
     b12:	44 f0       	brlt	.+16     	; 0xb24 <detectStairs+0x1c>
     b14:	2e 50       	subi	r18, 0x0E	; 14
     b16:	31 09       	sbc	r19, r1
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	62 17       	cp	r22, r18
     b1c:	73 07       	cpc	r23, r19
     b1e:	1c f0       	brlt	.+6      	; 0xb26 <detectStairs+0x1e>
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	08 95       	ret
	{
		return 1; // stairs found
     b24:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b26:	08 95       	ret

00000b28 <cheatPrintAll>:
	}
}


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     b28:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     b2a:	85 e0       	ldi	r24, 0x05	; 5
     b2c:	db 01       	movw	r26, r22
     b2e:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     b30:	86 e4       	ldi	r24, 0x46	; 70
     b32:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     b34:	8c e4       	ldi	r24, 0x4C	; 76
     b36:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     b38:	82 e5       	ldi	r24, 0x52	; 82
     b3a:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     b3c:	82 e4       	ldi	r24, 0x42	; 66
     b3e:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     b40:	84 e5       	ldi	r24, 0x54	; 84
     b42:	84 83       	std	Z+4, r24	; 0x04
     b44:	08 95       	ret

00000b46 <possibleStairs>:
}

// detect possibleStairs infront 
char possibleStairs(int frontSonar, int topSonar)
{
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
     b46:	c2 97       	sbiw	r24, 0x32	; 50
     b48:	44 f4       	brge	.+16     	; 0xb5a <possibleStairs+0x14>
     b4a:	61 55       	subi	r22, 0x51	; 81
     b4c:	71 09       	sbc	r23, r1
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	6d 31       	cpi	r22, 0x1D	; 29
     b52:	71 05       	cpc	r23, r1
     b54:	18 f0       	brcs	.+6      	; 0xb5c <possibleStairs+0x16>
     b56:	80 e0       	ldi	r24, 0x00	; 0
     b58:	08 95       	ret
		return 1;
	else 
		return 0;
     b5a:	80 e0       	ldi	r24, 0x00	; 0
	
}
     b5c:	08 95       	ret

00000b5e <obstacleAvoidance>:
}


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int topSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b5e:	cf 92       	push	r12
     b60:	df 92       	push	r13
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	0f 93       	push	r16
     b68:	1f 93       	push	r17
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	8a 01       	movw	r16, r20
     b70:	69 01       	movw	r12, r18
     b72:	e7 01       	movw	r28, r14
	
	if(deviceBlocked[BTM_DEVICE])
     b74:	2b 81       	ldd	r18, Y+3	; 0x03
     b76:	22 23       	and	r18, r18
     b78:	39 f0       	breq	.+14     	; 0xb88 <obstacleAvoidance+0x2a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b7a:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b7c:	e2 e0       	ldi	r30, 0x02	; 2
     b7e:	f1 e0       	ldi	r31, 0x01	; 1
     b80:	80 81       	ld	r24, Z
     b82:	80 61       	ori	r24, 0x10	; 16
     b84:	80 83       	st	Z, r24
     b86:	5f c0       	rjmp	.+190    	; 0xc46 <obstacleAvoidance+0xe8>
	}
	else if( (deviceBlocked[FRONT_DEVICE] && (!possibleStairs(frontSonar, topSonar))) || deviceBlocked[TOP_DEVICE])
     b88:	28 81       	ld	r18, Y
     b8a:	22 23       	and	r18, r18
     b8c:	19 f0       	breq	.+6      	; 0xb94 <obstacleAvoidance+0x36>
     b8e:	db df       	rcall	.-74     	; 0xb46 <possibleStairs>
     b90:	88 23       	and	r24, r24
     b92:	19 f0       	breq	.+6      	; 0xb9a <obstacleAvoidance+0x3c>
     b94:	8c 81       	ldd	r24, Y+4	; 0x04
     b96:	88 23       	and	r24, r24
     b98:	b9 f1       	breq	.+110    	; 0xc08 <obstacleAvoidance+0xaa>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b9a:	89 81       	ldd	r24, Y+1	; 0x01
     b9c:	81 11       	cpse	r24, r1
     b9e:	18 c0       	rjmp	.+48     	; 0xbd0 <obstacleAvoidance+0x72>
     ba0:	8a 81       	ldd	r24, Y+2	; 0x02
     ba2:	81 11       	cpse	r24, r1
     ba4:	25 c0       	rjmp	.+74     	; 0xbf0 <obstacleAvoidance+0x92>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar - 20) // if right sonar greater than....
     ba6:	c8 01       	movw	r24, r16
     ba8:	44 97       	sbiw	r24, 0x14	; 20
     baa:	8c 15       	cp	r24, r12
     bac:	9d 05       	cpc	r25, r13
     bae:	3c f4       	brge	.+14     	; 0xbbe <obstacleAvoidance+0x60>
				{
					MOTOR_LEFT_STOP();
     bb0:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     bb2:	e2 e0       	ldi	r30, 0x02	; 2
     bb4:	f1 e0       	ldi	r31, 0x01	; 1
     bb6:	80 81       	ld	r24, Z
     bb8:	80 61       	ori	r24, 0x10	; 16
     bba:	80 83       	st	Z, r24
     bbc:	06 c0       	rjmp	.+12     	; 0xbca <obstacleAvoidance+0x6c>
				}
				else 
				{
					MOTOR_LEFT_START();
     bbe:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     bc0:	e2 e0       	ldi	r30, 0x02	; 2
     bc2:	f1 e0       	ldi	r31, 0x01	; 1
     bc4:	80 81       	ld	r24, Z
     bc6:	8f 7e       	andi	r24, 0xEF	; 239
     bc8:	80 83       	st	Z, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     bca:	89 81       	ldd	r24, Y+1	; 0x01
     bcc:	88 23       	and	r24, r24
     bce:	c1 f1       	breq	.+112    	; 0xc40 <obstacleAvoidance+0xe2>
     bd0:	8a 81       	ldd	r24, Y+2	; 0x02
     bd2:	81 11       	cpse	r24, r1
     bd4:	38 c0       	rjmp	.+112    	; 0xc46 <obstacleAvoidance+0xe8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     bd6:	c0 1a       	sub	r12, r16
     bd8:	d1 0a       	sbc	r13, r17
     bda:	85 e0       	ldi	r24, 0x05	; 5
     bdc:	c8 16       	cp	r12, r24
     bde:	d1 04       	cpc	r13, r1
     be0:	94 f1       	brlt	.+100    	; 0xc46 <obstacleAvoidance+0xe8>
			{
				MOTOR_LEFT_STOP();
     be2:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     be4:	e2 e0       	ldi	r30, 0x02	; 2
     be6:	f1 e0       	ldi	r31, 0x01	; 1
     be8:	80 81       	ld	r24, Z
     bea:	80 61       	ori	r24, 0x10	; 16
     bec:	80 83       	st	Z, r24
     bee:	2b c0       	rjmp	.+86     	; 0xc46 <obstacleAvoidance+0xe8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     bf0:	0c 19       	sub	r16, r12
     bf2:	1d 09       	sbc	r17, r13
     bf4:	05 30       	cpi	r16, 0x05	; 5
     bf6:	11 05       	cpc	r17, r1
     bf8:	34 f1       	brlt	.+76     	; 0xc46 <obstacleAvoidance+0xe8>
			{
				MOTOR_LEFT_START();
     bfa:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     bfc:	e2 e0       	ldi	r30, 0x02	; 2
     bfe:	f1 e0       	ldi	r31, 0x01	; 1
     c00:	80 81       	ld	r24, Z
     c02:	8f 7e       	andi	r24, 0xEF	; 239
     c04:	80 83       	st	Z, r24
     c06:	1f c0       	rjmp	.+62     	; 0xc46 <obstacleAvoidance+0xe8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     c08:	03 32       	cpi	r16, 0x23	; 35
     c0a:	11 05       	cpc	r17, r1
     c0c:	3c f4       	brge	.+14     	; 0xc1c <obstacleAvoidance+0xbe>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     c0e:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     c10:	e2 e0       	ldi	r30, 0x02	; 2
     c12:	f1 e0       	ldi	r31, 0x01	; 1
     c14:	80 81       	ld	r24, Z
     c16:	80 61       	ori	r24, 0x10	; 16
     c18:	80 83       	st	Z, r24
     c1a:	15 c0       	rjmp	.+42     	; 0xc46 <obstacleAvoidance+0xe8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     c1c:	84 e1       	ldi	r24, 0x14	; 20
     c1e:	c8 16       	cp	r12, r24
     c20:	d1 04       	cpc	r13, r1
     c22:	3c f4       	brge	.+14     	; 0xc32 <obstacleAvoidance+0xd4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     c24:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c26:	e2 e0       	ldi	r30, 0x02	; 2
     c28:	f1 e0       	ldi	r31, 0x01	; 1
     c2a:	80 81       	ld	r24, Z
     c2c:	8f 7e       	andi	r24, 0xEF	; 239
     c2e:	80 83       	st	Z, r24
     c30:	0a c0       	rjmp	.+20     	; 0xc46 <obstacleAvoidance+0xe8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     c32:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c34:	e2 e0       	ldi	r30, 0x02	; 2
     c36:	f1 e0       	ldi	r31, 0x01	; 1
     c38:	80 81       	ld	r24, Z
     c3a:	8f 7e       	andi	r24, 0xEF	; 239
     c3c:	80 83       	st	Z, r24
     c3e:	03 c0       	rjmp	.+6      	; 0xc46 <obstacleAvoidance+0xe8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     c40:	8a 81       	ldd	r24, Y+2	; 0x02
     c42:	81 11       	cpse	r24, r1
     c44:	d5 cf       	rjmp	.-86     	; 0xbf0 <obstacleAvoidance+0x92>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c46:	df 91       	pop	r29
     c48:	cf 91       	pop	r28
     c4a:	1f 91       	pop	r17
     c4c:	0f 91       	pop	r16
     c4e:	ff 90       	pop	r15
     c50:	ef 90       	pop	r14
     c52:	df 90       	pop	r13
     c54:	cf 90       	pop	r12
     c56:	08 95       	ret

00000c58 <obstacleDetection>:
}

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c58:	9f 92       	push	r9
     c5a:	af 92       	push	r10
     c5c:	bf 92       	push	r11
     c5e:	cf 92       	push	r12
     c60:	df 92       	push	r13
     c62:	ef 92       	push	r14
     c64:	ff 92       	push	r15
     c66:	0f 93       	push	r16
     c68:	1f 93       	push	r17
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	96 2e       	mov	r9, r22
     c70:	ea 01       	movw	r28, r20
     c72:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c74:	c2 97       	sbiw	r24, 0x32	; 50
     c76:	1c f4       	brge	.+6      	; 0xc7e <obstacleDetection+0x26>
	{
		obstacleDetected ++;
     c78:	93 94       	inc	r9
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c7a:	86 e4       	ldi	r24, 0x46	; 70
     c7c:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c7e:	23 32       	cpi	r18, 0x23	; 35
     c80:	31 05       	cpc	r19, r1
     c82:	1c f4       	brge	.+6      	; 0xc8a <obstacleDetection+0x32>
	{
		obstacleDetected ++;
     c84:	93 94       	inc	r9
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c86:	8c e4       	ldi	r24, 0x4C	; 76
     c88:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c8a:	0e 31       	cpi	r16, 0x1E	; 30
     c8c:	11 05       	cpc	r17, r1
     c8e:	1c f4       	brge	.+6      	; 0xc96 <obstacleDetection+0x3e>
	{
		obstacleDetected++;
     c90:	93 94       	inc	r9
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c92:	82 e5       	ldi	r24, 0x52	; 82
     c94:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c96:	c6 01       	movw	r24, r12
     c98:	37 df       	rcall	.-402    	; 0xb08 <detectStairs>
     c9a:	88 23       	and	r24, r24
     c9c:	19 f0       	breq	.+6      	; 0xca4 <obstacleDetection+0x4c>
	{
		obstacleDetected++;
     c9e:	93 94       	inc	r9
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     ca0:	82 e4       	ldi	r24, 0x42	; 66
     ca2:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     ca4:	87 e3       	ldi	r24, 0x37	; 55
     ca6:	e8 16       	cp	r14, r24
     ca8:	f1 04       	cpc	r15, r1
     caa:	1c f4       	brge	.+6      	; 0xcb2 <obstacleDetection+0x5a>
	{
		obstacleDetected++;
     cac:	93 94       	inc	r9
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     cae:	84 e5       	ldi	r24, 0x54	; 84
     cb0:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     cb2:	89 2d       	mov	r24, r9
     cb4:	df 91       	pop	r29
     cb6:	cf 91       	pop	r28
     cb8:	1f 91       	pop	r17
     cba:	0f 91       	pop	r16
     cbc:	ff 90       	pop	r15
     cbe:	ef 90       	pop	r14
     cc0:	df 90       	pop	r13
     cc2:	cf 90       	pop	r12
     cc4:	bf 90       	pop	r11
     cc6:	af 90       	pop	r10
     cc8:	9f 90       	pop	r9
     cca:	08 95       	ret

00000ccc <mySharpIR_Read>:
#include <stdint.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     ccc:	16 df       	rcall	.-468    	; 0xafa <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cce:	bc 01       	movw	r22, r24
     cd0:	88 27       	eor	r24, r24
     cd2:	77 fd       	sbrc	r23, 7
     cd4:	80 95       	com	r24
     cd6:	98 2f       	mov	r25, r24
     cd8:	0e 94 99 14 	call	0x2932	; 0x2932 <__floatsisf>
     cdc:	29 e2       	ldi	r18, 0x29	; 41
     cde:	3c e5       	ldi	r19, 0x5C	; 92
     ce0:	4f e6       	ldi	r20, 0x6F	; 111
     ce2:	5f eb       	ldi	r21, 0xBF	; 191
     ce4:	0e 94 88 15 	call	0x2b10	; 0x2b10 <pow>
     ce8:	22 e5       	ldi	r18, 0x52	; 82
     cea:	38 e6       	ldi	r19, 0x68	; 104
     cec:	46 e2       	ldi	r20, 0x26	; 38
     cee:	56 e4       	ldi	r21, 0x46	; 70
     cf0:	0e 94 25 15 	call	0x2a4a	; 0x2a4a <__mulsf3>
     cf4:	20 e0       	ldi	r18, 0x00	; 0
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	40 e2       	ldi	r20, 0x20	; 32
     cfa:	51 e4       	ldi	r21, 0x41	; 65
     cfc:	0e 94 01 14 	call	0x2802	; 0x2802 <__subsf3>
     d00:	0e 94 66 14 	call	0x28cc	; 0x28cc <__fixsfsi>
     d04:	cb 01       	movw	r24, r22
     d06:	68 3e       	cpi	r22, 0xE8	; 232
     d08:	23 e0       	ldi	r18, 0x03	; 3
     d0a:	72 07       	cpc	r23, r18
     d0c:	14 f0       	brlt	.+4      	; 0xd12 <mySharpIR_Read+0x46>
     d0e:	87 ee       	ldi	r24, 0xE7	; 231
     d10:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     d12:	08 95       	ret

00000d14 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d14:	fb 01       	movw	r30, r22
     d16:	20 81       	ld	r18, Z
     d18:	31 81       	ldd	r19, Z+1	; 0x01
     d1a:	50 e0       	ldi	r21, 0x00	; 0
     d1c:	b9 01       	movw	r22, r18
     d1e:	64 0f       	add	r22, r20
     d20:	75 1f       	adc	r23, r21
     d22:	68 17       	cp	r22, r24
     d24:	79 07       	cpc	r23, r25
     d26:	4c f0       	brlt	.+18     	; 0xd3a <checkWithinRange+0x26>
     d28:	24 1b       	sub	r18, r20
     d2a:	35 0b       	sbc	r19, r21
     d2c:	41 e0       	ldi	r20, 0x01	; 1
     d2e:	82 17       	cp	r24, r18
     d30:	93 07       	cpc	r25, r19
     d32:	0c f0       	brlt	.+2      	; 0xd36 <checkWithinRange+0x22>
     d34:	40 e0       	ldi	r20, 0x00	; 0
     d36:	84 2f       	mov	r24, r20
     d38:	08 95       	ret
     d3a:	81 e0       	ldi	r24, 0x01	; 1
}
     d3c:	08 95       	ret

00000d3e <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     d3e:	0f 93       	push	r16
     d40:	1f 93       	push	r17
     d42:	cf 93       	push	r28
     d44:	df 93       	push	r29
     d46:	8c 01       	movw	r16, r24
     d48:	eb 01       	movw	r28, r22
	static uint8_t i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     d4a:	45 e0       	ldi	r20, 0x05	; 5
     d4c:	bc 01       	movw	r22, r24
     d4e:	ce 01       	movw	r24, r28
     d50:	e1 df       	rcall	.-62     	; 0xd14 <checkWithinRange>
     d52:	88 23       	and	r24, r24
     d54:	29 f0       	breq	.+10     	; 0xd60 <mySharpIR_ReCalibrate+0x22>
     d56:	80 91 1d 08 	lds	r24, 0x081D
     d5a:	81 11       	cpse	r24, r1
     d5c:	0a c0       	rjmp	.+20     	; 0xd72 <mySharpIR_ReCalibrate+0x34>
     d5e:	3a c0       	rjmp	.+116    	; 0xdd4 <mySharpIR_ReCalibrate+0x96>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     d60:	80 91 1d 08 	lds	r24, 0x081D
     d64:	81 11       	cpse	r24, r1
     d66:	05 c0       	rjmp	.+10     	; 0xd72 <mySharpIR_ReCalibrate+0x34>
	{
		checkReading[0] = reading;
     d68:	d0 93 1a 08 	sts	0x081A, r29
     d6c:	c0 93 19 08 	sts	0x0819, r28
     d70:	2c c0       	rjmp	.+88     	; 0xdca <mySharpIR_ReCalibrate+0x8c>
	}
	else if (i == CALIBRATE_COUNT/2)
     d72:	84 36       	cpi	r24, 0x64	; 100
     d74:	99 f4       	brne	.+38     	; 0xd9c <mySharpIR_ReCalibrate+0x5e>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d76:	45 e0       	ldi	r20, 0x05	; 5
     d78:	69 e1       	ldi	r22, 0x19	; 25
     d7a:	78 e0       	ldi	r23, 0x08	; 8
     d7c:	ce 01       	movw	r24, r28
     d7e:	ca df       	rcall	.-108    	; 0xd14 <checkWithinRange>
     d80:	88 23       	and	r24, r24
     d82:	39 f0       	breq	.+14     	; 0xd92 <mySharpIR_ReCalibrate+0x54>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d84:	d0 93 1a 08 	sts	0x081A, r29
     d88:	c0 93 19 08 	sts	0x0819, r28
			i = 0; // reset to count...
     d8c:	10 92 1d 08 	sts	0x081D, r1
     d90:	1c c0       	rjmp	.+56     	; 0xdca <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d92:	d0 93 1c 08 	sts	0x081C, r29
     d96:	c0 93 1b 08 	sts	0x081B, r28
     d9a:	17 c0       	rjmp	.+46     	; 0xdca <mySharpIR_ReCalibrate+0x8c>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d9c:	88 3c       	cpi	r24, 0xC8	; 200
     d9e:	a9 f4       	brne	.+42     	; 0xdca <mySharpIR_ReCalibrate+0x8c>
	{
		i = 0; // reset to count..
     da0:	10 92 1d 08 	sts	0x081D, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     da4:	45 e0       	ldi	r20, 0x05	; 5
     da6:	69 e1       	ldi	r22, 0x19	; 25
     da8:	78 e0       	ldi	r23, 0x08	; 8
     daa:	ce 01       	movw	r24, r28
     dac:	b3 df       	rcall	.-154    	; 0xd14 <checkWithinRange>
     dae:	88 23       	and	r24, r24
     db0:	29 f0       	breq	.+10     	; 0xdbc <mySharpIR_ReCalibrate+0x7e>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     db2:	d0 93 1a 08 	sts	0x081A, r29
     db6:	c0 93 19 08 	sts	0x0819, r28
     dba:	07 c0       	rjmp	.+14     	; 0xdca <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     dbc:	80 91 19 08 	lds	r24, 0x0819
     dc0:	90 91 1a 08 	lds	r25, 0x081A
     dc4:	f8 01       	movw	r30, r16
     dc6:	91 83       	std	Z+1, r25	; 0x01
     dc8:	80 83       	st	Z, r24
		}
	}
	
	i++;
     dca:	80 91 1d 08 	lds	r24, 0x081D
     dce:	8f 5f       	subi	r24, 0xFF	; 255
     dd0:	80 93 1d 08 	sts	0x081D, r24
}
     dd4:	df 91       	pop	r29
     dd6:	cf 91       	pop	r28
     dd8:	1f 91       	pop	r17
     dda:	0f 91       	pop	r16
     ddc:	08 95       	ret

00000dde <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     dde:	90 93 b0 08 	sts	0x08B0, r25
     de2:	80 93 af 08 	sts	0x08AF, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     de6:	fc 01       	movw	r30, r24
     de8:	80 81       	ld	r24, Z
     dea:	91 81       	ldd	r25, Z+1	; 0x01
     dec:	0e 94 4b 12 	call	0x2496	; 0x2496 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     df0:	43 e0       	ldi	r20, 0x03	; 3
     df2:	60 e0       	ldi	r22, 0x00	; 0
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	30 d5       	rcall	.+2656   	; 0x1858 <xQueueGenericCreate>
     df8:	90 93 ac 08 	sts	0x08AC, r25
     dfc:	80 93 ab 08 	sts	0x08AB, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     e00:	43 e0       	ldi	r20, 0x03	; 3
     e02:	60 e0       	ldi	r22, 0x00	; 0
     e04:	81 e0       	ldi	r24, 0x01	; 1
     e06:	28 d5       	rcall	.+2640   	; 0x1858 <xQueueGenericCreate>
     e08:	90 93 ae 08 	sts	0x08AE, r25
     e0c:	80 93 ad 08 	sts	0x08AD, r24
     e10:	08 95       	ret

00000e12 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e12:	86 b5       	in	r24, 0x26	; 38
}
     e14:	08 95       	ret

00000e16 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e16:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     e18:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e1a:	9c 01       	movw	r18, r24
     e1c:	99 23       	and	r25, r25
     e1e:	14 f4       	brge	.+4      	; 0xe24 <myTimer_DelayMicro+0xe>
     e20:	2d 5f       	subi	r18, 0xFD	; 253
     e22:	3f 4f       	sbci	r19, 0xFF	; 255
     e24:	35 95       	asr	r19
     e26:	27 95       	ror	r18
     e28:	35 95       	asr	r19
     e2a:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     e2c:	24 0f       	add	r18, r20
     e2e:	35 1f       	adc	r19, r21
     e30:	30 93 04 02 	sts	0x0204, r19
     e34:	20 93 03 02 	sts	0x0203, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e38:	e0 91 af 08 	lds	r30, 0x08AF
     e3c:	f0 91 b0 08 	lds	r31, 0x08B0
     e40:	80 81       	ld	r24, Z
     e42:	91 81       	ldd	r25, Z+1	; 0x01
     e44:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e48:	20 e0       	ldi	r18, 0x00	; 0
     e4a:	42 e0       	ldi	r20, 0x02	; 2
     e4c:	50 e0       	ldi	r21, 0x00	; 0
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	80 91 ab 08 	lds	r24, 0x08AB
     e56:	90 91 ac 08 	lds	r25, 0x08AC
     e5a:	23 c6       	rjmp	.+3142   	; 0x1aa2 <xQueueGenericReceive>
     e5c:	08 95       	ret

00000e5e <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e5e:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     e60:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e62:	9c 01       	movw	r18, r24
     e64:	99 23       	and	r25, r25
     e66:	14 f4       	brge	.+4      	; 0xe6c <myTimer_DelayMicro2+0xe>
     e68:	2d 5f       	subi	r18, 0xFD	; 253
     e6a:	3f 4f       	sbci	r19, 0xFF	; 255
     e6c:	35 95       	asr	r19
     e6e:	27 95       	ror	r18
     e70:	35 95       	asr	r19
     e72:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     e74:	24 0f       	add	r18, r20
     e76:	35 1f       	adc	r19, r21
     e78:	30 93 02 02 	sts	0x0202, r19
     e7c:	20 93 01 02 	sts	0x0201, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e80:	e0 91 af 08 	lds	r30, 0x08AF
     e84:	f0 91 b0 08 	lds	r31, 0x08B0
     e88:	80 81       	ld	r24, Z
     e8a:	91 81       	ldd	r25, Z+1	; 0x01
     e8c:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e90:	20 e0       	ldi	r18, 0x00	; 0
     e92:	42 e0       	ldi	r20, 0x02	; 2
     e94:	50 e0       	ldi	r21, 0x00	; 0
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	70 e0       	ldi	r23, 0x00	; 0
     e9a:	80 91 ad 08 	lds	r24, 0x08AD
     e9e:	90 91 ae 08 	lds	r25, 0x08AE
     ea2:	ff c5       	rjmp	.+3070   	; 0x1aa2 <xQueueGenericReceive>
     ea4:	08 95       	ret

00000ea6 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     ea6:	cf 93       	push	r28
     ea8:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     eaa:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     eac:	c1 11       	cpse	r28, r1
     eae:	22 c0       	rjmp	.+68     	; 0xef4 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     eb0:	80 91 03 02 	lds	r24, 0x0203
     eb4:	90 91 04 02 	lds	r25, 0x0204
     eb8:	88 38       	cpi	r24, 0x88	; 136
     eba:	93 41       	sbci	r25, 0x13	; 19
     ebc:	51 f0       	breq	.+20     	; 0xed2 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     ebe:	80 91 03 02 	lds	r24, 0x0203
     ec2:	90 91 04 02 	lds	r25, 0x0204
     ec6:	8a 5f       	subi	r24, 0xFA	; 250
     ec8:	91 09       	sbc	r25, r1
     eca:	90 93 04 02 	sts	0x0204, r25
     ece:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     ed2:	80 91 01 02 	lds	r24, 0x0201
     ed6:	90 91 02 02 	lds	r25, 0x0202
     eda:	88 38       	cpi	r24, 0x88	; 136
     edc:	93 41       	sbci	r25, 0x13	; 19
     ede:	51 f0       	breq	.+20     	; 0xef4 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     ee0:	80 91 01 02 	lds	r24, 0x0201
     ee4:	90 91 02 02 	lds	r25, 0x0202
     ee8:	8a 5f       	subi	r24, 0xFA	; 250
     eea:	91 09       	sbc	r25, r1
     eec:	90 93 02 02 	sts	0x0202, r25
     ef0:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     ef4:	d0 e0       	ldi	r29, 0x00	; 0
     ef6:	80 91 03 02 	lds	r24, 0x0203
     efa:	90 91 04 02 	lds	r25, 0x0204
     efe:	8c 17       	cp	r24, r28
     f00:	9d 07       	cpc	r25, r29
     f02:	84 f4       	brge	.+32     	; 0xf24 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     f04:	88 e8       	ldi	r24, 0x88	; 136
     f06:	93 e1       	ldi	r25, 0x13	; 19
     f08:	90 93 04 02 	sts	0x0204, r25
     f0c:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     f10:	20 e0       	ldi	r18, 0x00	; 0
     f12:	40 e0       	ldi	r20, 0x00	; 0
     f14:	50 e0       	ldi	r21, 0x00	; 0
     f16:	60 e0       	ldi	r22, 0x00	; 0
     f18:	70 e0       	ldi	r23, 0x00	; 0
     f1a:	80 91 ab 08 	lds	r24, 0x08AB
     f1e:	90 91 ac 08 	lds	r25, 0x08AC
     f22:	c7 d4       	rcall	.+2446   	; 0x18b2 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     f24:	80 91 01 02 	lds	r24, 0x0201
     f28:	90 91 02 02 	lds	r25, 0x0202
     f2c:	8c 17       	cp	r24, r28
     f2e:	9d 07       	cpc	r25, r29
     f30:	84 f4       	brge	.+32     	; 0xf52 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     f32:	88 e8       	ldi	r24, 0x88	; 136
     f34:	93 e1       	ldi	r25, 0x13	; 19
     f36:	90 93 02 02 	sts	0x0202, r25
     f3a:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     f3e:	20 e0       	ldi	r18, 0x00	; 0
     f40:	40 e0       	ldi	r20, 0x00	; 0
     f42:	50 e0       	ldi	r21, 0x00	; 0
     f44:	60 e0       	ldi	r22, 0x00	; 0
     f46:	70 e0       	ldi	r23, 0x00	; 0
     f48:	80 91 ad 08 	lds	r24, 0x08AD
     f4c:	90 91 ae 08 	lds	r25, 0x08AE
     f50:	b0 d4       	rcall	.+2400   	; 0x18b2 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     f52:	80 91 03 02 	lds	r24, 0x0203
     f56:	90 91 04 02 	lds	r25, 0x0204
     f5a:	88 38       	cpi	r24, 0x88	; 136
     f5c:	93 41       	sbci	r25, 0x13	; 19
     f5e:	79 f4       	brne	.+30     	; 0xf7e <myTimer_DelayChecker+0xd8>
     f60:	80 91 01 02 	lds	r24, 0x0201
     f64:	90 91 02 02 	lds	r25, 0x0202
     f68:	88 38       	cpi	r24, 0x88	; 136
     f6a:	93 41       	sbci	r25, 0x13	; 19
     f6c:	41 f4       	brne	.+16     	; 0xf7e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f6e:	e0 91 af 08 	lds	r30, 0x08AF
     f72:	f0 91 b0 08 	lds	r31, 0x08B0
     f76:	80 81       	ld	r24, Z
     f78:	91 81       	ldd	r25, Z+1	; 0x01
     f7a:	0e 94 4b 12 	call	0x2496	; 0x2496 <vTaskSuspend>
	}
     f7e:	df 91       	pop	r29
     f80:	cf 91       	pop	r28
     f82:	08 95       	ret

00000f84 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     f84:	1f 92       	push	r1
     f86:	0f 92       	push	r0
     f88:	0f b6       	in	r0, 0x3f	; 63
     f8a:	0f 92       	push	r0
     f8c:	11 24       	eor	r1, r1
     f8e:	0b b6       	in	r0, 0x3b	; 59
     f90:	0f 92       	push	r0
     f92:	2f 93       	push	r18
     f94:	3f 93       	push	r19
     f96:	4f 93       	push	r20
     f98:	5f 93       	push	r21
     f9a:	6f 93       	push	r22
     f9c:	7f 93       	push	r23
     f9e:	8f 93       	push	r24
     fa0:	9f 93       	push	r25
     fa2:	af 93       	push	r26
     fa4:	bf 93       	push	r27
     fa6:	ef 93       	push	r30
     fa8:	ff 93       	push	r31
     faa:	60 91 ce 00 	lds	r22, 0x00CE
     fae:	80 e4       	ldi	r24, 0x40	; 64
     fb0:	99 e0       	ldi	r25, 0x09	; 9
     fb2:	43 d6       	rcall	.+3206   	; 0x1c3a <ringBufferPush>
     fb4:	20 e0       	ldi	r18, 0x00	; 0
     fb6:	40 e0       	ldi	r20, 0x00	; 0
     fb8:	50 e0       	ldi	r21, 0x00	; 0
     fba:	60 e0       	ldi	r22, 0x00	; 0
     fbc:	70 e0       	ldi	r23, 0x00	; 0
     fbe:	80 91 26 08 	lds	r24, 0x0826
     fc2:	90 91 27 08 	lds	r25, 0x0827
     fc6:	33 d5       	rcall	.+2662   	; 0x1a2e <xQueueGenericSendFromISR>
     fc8:	80 e4       	ldi	r24, 0x40	; 64
     fca:	99 e0       	ldi	r25, 0x09	; 9
     fcc:	4d d6       	rcall	.+3226   	; 0x1c68 <ringBufferFull>
     fce:	ff 91       	pop	r31
     fd0:	ef 91       	pop	r30
     fd2:	bf 91       	pop	r27
     fd4:	af 91       	pop	r26
     fd6:	9f 91       	pop	r25
     fd8:	8f 91       	pop	r24
     fda:	7f 91       	pop	r23
     fdc:	6f 91       	pop	r22
     fde:	5f 91       	pop	r21
     fe0:	4f 91       	pop	r20
     fe2:	3f 91       	pop	r19
     fe4:	2f 91       	pop	r18
     fe6:	0f 90       	pop	r0
     fe8:	0b be       	out	0x3b, r0	; 59
     fea:	0f 90       	pop	r0
     fec:	0f be       	out	0x3f, r0	; 63
     fee:	0f 90       	pop	r0
     ff0:	1f 90       	pop	r1
     ff2:	18 95       	reti

00000ff4 <__vector_25>:
     ff4:	1f 92       	push	r1
     ff6:	0f 92       	push	r0
     ff8:	0f b6       	in	r0, 0x3f	; 63
     ffa:	0f 92       	push	r0
     ffc:	11 24       	eor	r1, r1
     ffe:	0b b6       	in	r0, 0x3b	; 59
    1000:	0f 92       	push	r0
    1002:	2f 93       	push	r18
    1004:	3f 93       	push	r19
    1006:	4f 93       	push	r20
    1008:	5f 93       	push	r21
    100a:	6f 93       	push	r22
    100c:	7f 93       	push	r23
    100e:	8f 93       	push	r24
    1010:	9f 93       	push	r25
    1012:	af 93       	push	r26
    1014:	bf 93       	push	r27
    1016:	ef 93       	push	r30
    1018:	ff 93       	push	r31
    101a:	60 91 c6 00 	lds	r22, 0x00C6
    101e:	81 ed       	ldi	r24, 0xD1	; 209
    1020:	98 e0       	ldi	r25, 0x08	; 8
    1022:	0b d6       	rcall	.+3094   	; 0x1c3a <ringBufferPush>
    1024:	20 e0       	ldi	r18, 0x00	; 0
    1026:	40 e0       	ldi	r20, 0x00	; 0
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	60 e0       	ldi	r22, 0x00	; 0
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	80 91 26 08 	lds	r24, 0x0826
    1032:	90 91 27 08 	lds	r25, 0x0827
    1036:	fb d4       	rcall	.+2550   	; 0x1a2e <xQueueGenericSendFromISR>
    1038:	81 ed       	ldi	r24, 0xD1	; 209
    103a:	98 e0       	ldi	r25, 0x08	; 8
    103c:	15 d6       	rcall	.+3114   	; 0x1c68 <ringBufferFull>
    103e:	ff 91       	pop	r31
    1040:	ef 91       	pop	r30
    1042:	bf 91       	pop	r27
    1044:	af 91       	pop	r26
    1046:	9f 91       	pop	r25
    1048:	8f 91       	pop	r24
    104a:	7f 91       	pop	r23
    104c:	6f 91       	pop	r22
    104e:	5f 91       	pop	r21
    1050:	4f 91       	pop	r20
    1052:	3f 91       	pop	r19
    1054:	2f 91       	pop	r18
    1056:	0f 90       	pop	r0
    1058:	0b be       	out	0x3b, r0	; 59
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63
    105e:	0f 90       	pop	r0
    1060:	1f 90       	pop	r1
    1062:	18 95       	reti

00001064 <__vector_37>:
    1064:	1f 92       	push	r1
    1066:	0f 92       	push	r0
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	0f 92       	push	r0
    106c:	11 24       	eor	r1, r1
    106e:	0b b6       	in	r0, 0x3b	; 59
    1070:	0f 92       	push	r0
    1072:	2f 93       	push	r18
    1074:	3f 93       	push	r19
    1076:	4f 93       	push	r20
    1078:	5f 93       	push	r21
    107a:	6f 93       	push	r22
    107c:	7f 93       	push	r23
    107e:	8f 93       	push	r24
    1080:	9f 93       	push	r25
    1082:	af 93       	push	r26
    1084:	bf 93       	push	r27
    1086:	ef 93       	push	r30
    1088:	ff 93       	push	r31
    108a:	86 e3       	ldi	r24, 0x36	; 54
    108c:	99 e0       	ldi	r25, 0x09	; 9
    108e:	f3 d5       	rcall	.+3046   	; 0x1c76 <ringBufferNotEmpty>
    1090:	88 23       	and	r24, r24
    1092:	31 f0       	breq	.+12     	; 0x10a0 <__vector_37+0x3c>
    1094:	86 e3       	ldi	r24, 0x36	; 54
    1096:	99 e0       	ldi	r25, 0x09	; 9
    1098:	be d5       	rcall	.+2940   	; 0x1c16 <ringBufferPop>
    109a:	80 93 ce 00 	sts	0x00CE, r24
    109e:	0f c0       	rjmp	.+30     	; 0x10be <__vector_37+0x5a>
    10a0:	e9 ec       	ldi	r30, 0xC9	; 201
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	8f 7d       	andi	r24, 0xDF	; 223
    10a8:	80 83       	st	Z, r24
    10aa:	20 e0       	ldi	r18, 0x00	; 0
    10ac:	40 e0       	ldi	r20, 0x00	; 0
    10ae:	50 e0       	ldi	r21, 0x00	; 0
    10b0:	60 e0       	ldi	r22, 0x00	; 0
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	80 91 1e 08 	lds	r24, 0x081E
    10b8:	90 91 1f 08 	lds	r25, 0x081F
    10bc:	b8 d4       	rcall	.+2416   	; 0x1a2e <xQueueGenericSendFromISR>
    10be:	ff 91       	pop	r31
    10c0:	ef 91       	pop	r30
    10c2:	bf 91       	pop	r27
    10c4:	af 91       	pop	r26
    10c6:	9f 91       	pop	r25
    10c8:	8f 91       	pop	r24
    10ca:	7f 91       	pop	r23
    10cc:	6f 91       	pop	r22
    10ce:	5f 91       	pop	r21
    10d0:	4f 91       	pop	r20
    10d2:	3f 91       	pop	r19
    10d4:	2f 91       	pop	r18
    10d6:	0f 90       	pop	r0
    10d8:	0b be       	out	0x3b, r0	; 59
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0
    10e0:	1f 90       	pop	r1
    10e2:	18 95       	reti

000010e4 <__vector_26>:
    10e4:	1f 92       	push	r1
    10e6:	0f 92       	push	r0
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	0f 92       	push	r0
    10ec:	11 24       	eor	r1, r1
    10ee:	0b b6       	in	r0, 0x3b	; 59
    10f0:	0f 92       	push	r0
    10f2:	2f 93       	push	r18
    10f4:	3f 93       	push	r19
    10f6:	4f 93       	push	r20
    10f8:	5f 93       	push	r21
    10fa:	6f 93       	push	r22
    10fc:	7f 93       	push	r23
    10fe:	8f 93       	push	r24
    1100:	9f 93       	push	r25
    1102:	af 93       	push	r26
    1104:	bf 93       	push	r27
    1106:	ef 93       	push	r30
    1108:	ff 93       	push	r31
    110a:	8b e3       	ldi	r24, 0x3B	; 59
    110c:	99 e0       	ldi	r25, 0x09	; 9
    110e:	b3 d5       	rcall	.+2918   	; 0x1c76 <ringBufferNotEmpty>
    1110:	88 23       	and	r24, r24
    1112:	31 f0       	breq	.+12     	; 0x1120 <__vector_26+0x3c>
    1114:	8b e3       	ldi	r24, 0x3B	; 59
    1116:	99 e0       	ldi	r25, 0x09	; 9
    1118:	7e d5       	rcall	.+2812   	; 0x1c16 <ringBufferPop>
    111a:	80 93 c6 00 	sts	0x00C6, r24
    111e:	0f c0       	rjmp	.+30     	; 0x113e <__vector_26+0x5a>
    1120:	e1 ec       	ldi	r30, 0xC1	; 193
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	8f 7d       	andi	r24, 0xDF	; 223
    1128:	80 83       	st	Z, r24
    112a:	20 e0       	ldi	r18, 0x00	; 0
    112c:	40 e0       	ldi	r20, 0x00	; 0
    112e:	50 e0       	ldi	r21, 0x00	; 0
    1130:	60 e0       	ldi	r22, 0x00	; 0
    1132:	70 e0       	ldi	r23, 0x00	; 0
    1134:	80 91 20 08 	lds	r24, 0x0820
    1138:	90 91 21 08 	lds	r25, 0x0821
    113c:	78 d4       	rcall	.+2288   	; 0x1a2e <xQueueGenericSendFromISR>
    113e:	ff 91       	pop	r31
    1140:	ef 91       	pop	r30
    1142:	bf 91       	pop	r27
    1144:	af 91       	pop	r26
    1146:	9f 91       	pop	r25
    1148:	8f 91       	pop	r24
    114a:	7f 91       	pop	r23
    114c:	6f 91       	pop	r22
    114e:	5f 91       	pop	r21
    1150:	4f 91       	pop	r20
    1152:	3f 91       	pop	r19
    1154:	2f 91       	pop	r18
    1156:	0f 90       	pop	r0
    1158:	0b be       	out	0x3b, r0	; 59
    115a:	0f 90       	pop	r0
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	0f 90       	pop	r0
    1160:	1f 90       	pop	r1
    1162:	18 95       	reti

00001164 <myUSART_USART0_Init>:
    1164:	10 92 c5 00 	sts	0x00C5, r1
    1168:	87 e6       	ldi	r24, 0x67	; 103
    116a:	80 93 c4 00 	sts	0x00C4, r24
    116e:	88 eb       	ldi	r24, 0xB8	; 184
    1170:	80 93 c1 00 	sts	0x00C1, r24
    1174:	86 e0       	ldi	r24, 0x06	; 6
    1176:	80 93 c2 00 	sts	0x00C2, r24
    117a:	40 e2       	ldi	r20, 0x20	; 32
    117c:	66 ef       	ldi	r22, 0xF6	; 246
    117e:	78 e0       	ldi	r23, 0x08	; 8
    1180:	81 ed       	ldi	r24, 0xD1	; 209
    1182:	98 e0       	ldi	r25, 0x08	; 8
    1184:	41 d5       	rcall	.+2690   	; 0x1c08 <ringBufferInit>
    1186:	40 e2       	ldi	r20, 0x20	; 32
    1188:	66 ed       	ldi	r22, 0xD6	; 214
    118a:	78 e0       	ldi	r23, 0x08	; 8
    118c:	8b e3       	ldi	r24, 0x3B	; 59
    118e:	99 e0       	ldi	r25, 0x09	; 9
    1190:	3b d5       	rcall	.+2678   	; 0x1c08 <ringBufferInit>
    1192:	43 e0       	ldi	r20, 0x03	; 3
    1194:	60 e0       	ldi	r22, 0x00	; 0
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	5f d3       	rcall	.+1726   	; 0x1858 <xQueueGenericCreate>
    119a:	90 93 25 08 	sts	0x0825, r25
    119e:	80 93 24 08 	sts	0x0824, r24
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	19 d4       	rcall	.+2098   	; 0x19d8 <xQueueCreateMutex>
    11a6:	90 93 21 08 	sts	0x0821, r25
    11aa:	80 93 20 08 	sts	0x0820, r24
    11ae:	08 95       	ret

000011b0 <myUSART_USART1_Init>:
    11b0:	10 92 cd 00 	sts	0x00CD, r1
    11b4:	87 e6       	ldi	r24, 0x67	; 103
    11b6:	80 93 cc 00 	sts	0x00CC, r24
    11ba:	88 eb       	ldi	r24, 0xB8	; 184
    11bc:	80 93 c9 00 	sts	0x00C9, r24
    11c0:	86 e0       	ldi	r24, 0x06	; 6
    11c2:	80 93 ca 00 	sts	0x00CA, r24
    11c6:	40 e2       	ldi	r20, 0x20	; 32
    11c8:	61 eb       	ldi	r22, 0xB1	; 177
    11ca:	78 e0       	ldi	r23, 0x08	; 8
    11cc:	80 e4       	ldi	r24, 0x40	; 64
    11ce:	99 e0       	ldi	r25, 0x09	; 9
    11d0:	1b d5       	rcall	.+2614   	; 0x1c08 <ringBufferInit>
    11d2:	40 e2       	ldi	r20, 0x20	; 32
    11d4:	66 e1       	ldi	r22, 0x16	; 22
    11d6:	79 e0       	ldi	r23, 0x09	; 9
    11d8:	86 e3       	ldi	r24, 0x36	; 54
    11da:	99 e0       	ldi	r25, 0x09	; 9
    11dc:	15 d5       	rcall	.+2602   	; 0x1c08 <ringBufferInit>
    11de:	43 e0       	ldi	r20, 0x03	; 3
    11e0:	60 e0       	ldi	r22, 0x00	; 0
    11e2:	81 e0       	ldi	r24, 0x01	; 1
    11e4:	39 d3       	rcall	.+1650   	; 0x1858 <xQueueGenericCreate>
    11e6:	90 93 27 08 	sts	0x0827, r25
    11ea:	80 93 26 08 	sts	0x0826, r24
    11ee:	43 e0       	ldi	r20, 0x03	; 3
    11f0:	60 e0       	ldi	r22, 0x00	; 0
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	31 d3       	rcall	.+1634   	; 0x1858 <xQueueGenericCreate>
    11f6:	90 93 23 08 	sts	0x0823, r25
    11fa:	80 93 22 08 	sts	0x0822, r24
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	eb d3       	rcall	.+2006   	; 0x19d8 <xQueueCreateMutex>
    1202:	90 93 1f 08 	sts	0x081F, r25
    1206:	80 93 1e 08 	sts	0x081E, r24
    120a:	08 95       	ret

0000120c <myUSART_transmitUSART0_c>:
    120c:	cf 93       	push	r28
    120e:	c8 2f       	mov	r28, r24
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	4f ef       	ldi	r20, 0xFF	; 255
    1214:	5f ef       	ldi	r21, 0xFF	; 255
    1216:	60 e0       	ldi	r22, 0x00	; 0
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	80 91 20 08 	lds	r24, 0x0820
    121e:	90 91 21 08 	lds	r25, 0x0821
    1222:	3f d4       	rcall	.+2174   	; 0x1aa2 <xQueueGenericReceive>
    1224:	8b e3       	ldi	r24, 0x3B	; 59
    1226:	99 e0       	ldi	r25, 0x09	; 9
    1228:	1f d5       	rcall	.+2622   	; 0x1c68 <ringBufferFull>
    122a:	81 11       	cpse	r24, r1
    122c:	fb cf       	rjmp	.-10     	; 0x1224 <myUSART_transmitUSART0_c+0x18>
    122e:	6c 2f       	mov	r22, r28
    1230:	8b e3       	ldi	r24, 0x3B	; 59
    1232:	99 e0       	ldi	r25, 0x09	; 9
    1234:	02 d5       	rcall	.+2564   	; 0x1c3a <ringBufferPush>
    1236:	e1 ec       	ldi	r30, 0xC1	; 193
    1238:	f0 e0       	ldi	r31, 0x00	; 0
    123a:	80 81       	ld	r24, Z
    123c:	80 62       	ori	r24, 0x20	; 32
    123e:	80 83       	st	Z, r24
    1240:	e0 ec       	ldi	r30, 0xC0	; 192
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	80 64       	ori	r24, 0x40	; 64
    1248:	80 83       	st	Z, r24
    124a:	cf 91       	pop	r28
    124c:	08 95       	ret

0000124e <myUSART_transmitUSART1_c>:
    124e:	cf 93       	push	r28
    1250:	c8 2f       	mov	r28, r24
    1252:	20 e0       	ldi	r18, 0x00	; 0
    1254:	4f ef       	ldi	r20, 0xFF	; 255
    1256:	5f ef       	ldi	r21, 0xFF	; 255
    1258:	60 e0       	ldi	r22, 0x00	; 0
    125a:	70 e0       	ldi	r23, 0x00	; 0
    125c:	80 91 1e 08 	lds	r24, 0x081E
    1260:	90 91 1f 08 	lds	r25, 0x081F
    1264:	1e d4       	rcall	.+2108   	; 0x1aa2 <xQueueGenericReceive>
    1266:	86 e3       	ldi	r24, 0x36	; 54
    1268:	99 e0       	ldi	r25, 0x09	; 9
    126a:	fe d4       	rcall	.+2556   	; 0x1c68 <ringBufferFull>
    126c:	81 11       	cpse	r24, r1
    126e:	fb cf       	rjmp	.-10     	; 0x1266 <myUSART_transmitUSART1_c+0x18>
    1270:	6c 2f       	mov	r22, r28
    1272:	86 e3       	ldi	r24, 0x36	; 54
    1274:	99 e0       	ldi	r25, 0x09	; 9
    1276:	e1 d4       	rcall	.+2498   	; 0x1c3a <ringBufferPush>
    1278:	e9 ec       	ldi	r30, 0xC9	; 201
    127a:	f0 e0       	ldi	r31, 0x00	; 0
    127c:	80 81       	ld	r24, Z
    127e:	80 62       	ori	r24, 0x20	; 32
    1280:	80 83       	st	Z, r24
    1282:	e8 ec       	ldi	r30, 0xC8	; 200
    1284:	f0 e0       	ldi	r31, 0x00	; 0
    1286:	80 81       	ld	r24, Z
    1288:	80 64       	ori	r24, 0x40	; 64
    128a:	80 83       	st	Z, r24
    128c:	cf 91       	pop	r28
    128e:	08 95       	ret

00001290 <myUSART_transmitUSART1>:
    1290:	cf 93       	push	r28
    1292:	df 93       	push	r29
    1294:	ec 01       	movw	r28, r24
    1296:	88 81       	ld	r24, Y
    1298:	88 23       	and	r24, r24
    129a:	29 f0       	breq	.+10     	; 0x12a6 <myUSART_transmitUSART1+0x16>
    129c:	21 96       	adiw	r28, 0x01	; 1
    129e:	d7 df       	rcall	.-82     	; 0x124e <myUSART_transmitUSART1_c>
    12a0:	89 91       	ld	r24, Y+
    12a2:	81 11       	cpse	r24, r1
    12a4:	fc cf       	rjmp	.-8      	; 0x129e <myUSART_transmitUSART1+0xe>
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	08 95       	ret

000012ac <myUSART_transmitUSART0>:
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	ec 01       	movw	r28, r24
    12b2:	88 81       	ld	r24, Y
    12b4:	88 23       	and	r24, r24
    12b6:	29 f0       	breq	.+10     	; 0x12c2 <myUSART_transmitUSART0+0x16>
    12b8:	21 96       	adiw	r28, 0x01	; 1
    12ba:	a8 df       	rcall	.-176    	; 0x120c <myUSART_transmitUSART0_c>
    12bc:	89 91       	ld	r24, Y+
    12be:	81 11       	cpse	r24, r1
    12c0:	fc cf       	rjmp	.-8      	; 0x12ba <myUSART_transmitUSART0+0xe>
    12c2:	df 91       	pop	r29
    12c4:	cf 91       	pop	r28
    12c6:	08 95       	ret

000012c8 <myUSART_receiveUSART1>:
    12c8:	cf 93       	push	r28
    12ca:	20 e0       	ldi	r18, 0x00	; 0
    12cc:	4f ef       	ldi	r20, 0xFF	; 255
    12ce:	5f ef       	ldi	r21, 0xFF	; 255
    12d0:	60 e0       	ldi	r22, 0x00	; 0
    12d2:	70 e0       	ldi	r23, 0x00	; 0
    12d4:	80 91 26 08 	lds	r24, 0x0826
    12d8:	90 91 27 08 	lds	r25, 0x0827
    12dc:	e2 d3       	rcall	.+1988   	; 0x1aa2 <xQueueGenericReceive>
    12de:	80 e4       	ldi	r24, 0x40	; 64
    12e0:	99 e0       	ldi	r25, 0x09	; 9
    12e2:	99 d4       	rcall	.+2354   	; 0x1c16 <ringBufferPop>
    12e4:	c8 2f       	mov	r28, r24
    12e6:	80 e4       	ldi	r24, 0x40	; 64
    12e8:	99 e0       	ldi	r25, 0x09	; 9
    12ea:	c5 d4       	rcall	.+2442   	; 0x1c76 <ringBufferNotEmpty>
    12ec:	88 23       	and	r24, r24
    12ee:	51 f0       	breq	.+20     	; 0x1304 <myUSART_receiveUSART1+0x3c>
    12f0:	20 e0       	ldi	r18, 0x00	; 0
    12f2:	40 e0       	ldi	r20, 0x00	; 0
    12f4:	50 e0       	ldi	r21, 0x00	; 0
    12f6:	60 e0       	ldi	r22, 0x00	; 0
    12f8:	70 e0       	ldi	r23, 0x00	; 0
    12fa:	80 91 26 08 	lds	r24, 0x0826
    12fe:	90 91 27 08 	lds	r25, 0x0827
    1302:	d7 d2       	rcall	.+1454   	; 0x18b2 <xQueueGenericSend>
    1304:	8c 2f       	mov	r24, r28
    1306:	cf 91       	pop	r28
    1308:	08 95       	ret

0000130a <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    130a:	86 e1       	ldi	r24, 0x16	; 22
    130c:	a0 df       	rcall	.-192    	; 0x124e <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    130e:	20 e0       	ldi	r18, 0x00	; 0
    1310:	4a ef       	ldi	r20, 0xFA	; 250
    1312:	50 e0       	ldi	r21, 0x00	; 0
    1314:	60 e0       	ldi	r22, 0x00	; 0
    1316:	70 e0       	ldi	r23, 0x00	; 0
    1318:	80 91 22 08 	lds	r24, 0x0822
    131c:	90 91 23 08 	lds	r25, 0x0823
    1320:	c0 d3       	rcall	.+1920   	; 0x1aa2 <xQueueGenericReceive>
    1322:	81 30       	cpi	r24, 0x01	; 1
    1324:	21 f4       	brne	.+8      	; 0x132e <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    1326:	82 e0       	ldi	r24, 0x02	; 2
    1328:	92 df       	rcall	.-220    	; 0x124e <myUSART_transmitUSART1_c>
		return 1;
    132a:	81 e0       	ldi	r24, 0x01	; 1
    132c:	08 95       	ret
	}
	else
	{
		return 0;
    132e:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    1330:	08 95       	ret

00001332 <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    1332:	20 e0       	ldi	r18, 0x00	; 0
    1334:	40 e0       	ldi	r20, 0x00	; 0
    1336:	50 e0       	ldi	r21, 0x00	; 0
    1338:	60 e0       	ldi	r22, 0x00	; 0
    133a:	70 e0       	ldi	r23, 0x00	; 0
    133c:	80 91 22 08 	lds	r24, 0x0822
    1340:	90 91 23 08 	lds	r25, 0x0823
    1344:	b6 c2       	rjmp	.+1388   	; 0x18b2 <xQueueGenericSend>
    1346:	08 95       	ret

00001348 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    1348:	91 e0       	ldi	r25, 0x01	; 1
    134a:	85 30       	cpi	r24, 0x05	; 5
    134c:	09 f0       	breq	.+2      	; 0x1350 <myUSART_receiveHandShakeAck+0x8>
    134e:	90 e0       	ldi	r25, 0x00	; 0
}
    1350:	89 2f       	mov	r24, r25
    1352:	08 95       	ret

00001354 <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    1354:	91 e0       	ldi	r25, 0x01	; 1
    1356:	86 31       	cpi	r24, 0x16	; 22
    1358:	09 f0       	breq	.+2      	; 0x135c <myUSART_receiveHandShakeStart+0x8>
    135a:	90 e0       	ldi	r25, 0x00	; 0
}
    135c:	89 2f       	mov	r24, r25
    135e:	08 95       	ret

00001360 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    1360:	91 e0       	ldi	r25, 0x01	; 1
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	09 f0       	breq	.+2      	; 0x1368 <myUSART_receiveHandShakeFin+0x8>
    1366:	90 e0       	ldi	r25, 0x00	; 0
}
    1368:	89 2f       	mov	r24, r25
    136a:	08 95       	ret

0000136c <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    136c:	91 e0       	ldi	r25, 0x01	; 1
    136e:	86 30       	cpi	r24, 0x06	; 6
    1370:	09 f0       	breq	.+2      	; 0x1374 <myUSART_receiveMessageACK+0x8>
    1372:	90 e0       	ldi	r25, 0x00	; 0
}
    1374:	89 2f       	mov	r24, r25
    1376:	08 95       	ret

00001378 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1378:	31 e1       	ldi	r19, 0x11	; 17
    137a:	fc 01       	movw	r30, r24
    137c:	30 83       	st	Z, r19
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	22 e2       	ldi	r18, 0x22	; 34
    1382:	20 83       	st	Z, r18
    1384:	31 97       	sbiw	r30, 0x01	; 1
    1386:	a3 e3       	ldi	r26, 0x33	; 51
    1388:	a0 83       	st	Z, r26
    138a:	31 97       	sbiw	r30, 0x01	; 1
    138c:	60 83       	st	Z, r22
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	70 83       	st	Z, r23
    1392:	31 97       	sbiw	r30, 0x01	; 1
    1394:	10 82       	st	Z, r1
    1396:	31 97       	sbiw	r30, 0x01	; 1
    1398:	10 82       	st	Z, r1
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	60 e8       	ldi	r22, 0x80	; 128
    139e:	60 83       	st	Z, r22
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	10 82       	st	Z, r1
    13a4:	31 97       	sbiw	r30, 0x01	; 1
    13a6:	10 82       	st	Z, r1
    13a8:	31 97       	sbiw	r30, 0x01	; 1
    13aa:	10 82       	st	Z, r1
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	62 e0       	ldi	r22, 0x02	; 2
    13b0:	60 83       	st	Z, r22
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	63 e0       	ldi	r22, 0x03	; 3
    13b6:	60 83       	st	Z, r22
    13b8:	31 97       	sbiw	r30, 0x01	; 1
    13ba:	64 e0       	ldi	r22, 0x04	; 4
    13bc:	60 83       	st	Z, r22
    13be:	31 97       	sbiw	r30, 0x01	; 1
    13c0:	65 e0       	ldi	r22, 0x05	; 5
    13c2:	60 83       	st	Z, r22
    13c4:	31 97       	sbiw	r30, 0x01	; 1
    13c6:	66 e0       	ldi	r22, 0x06	; 6
    13c8:	60 83       	st	Z, r22
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	67 e0       	ldi	r22, 0x07	; 7
    13ce:	60 83       	st	Z, r22
    13d0:	31 97       	sbiw	r30, 0x01	; 1
    13d2:	68 e0       	ldi	r22, 0x08	; 8
    13d4:	60 83       	st	Z, r22
    13d6:	31 97       	sbiw	r30, 0x01	; 1
    13d8:	69 e0       	ldi	r22, 0x09	; 9
    13da:	60 83       	st	Z, r22
    13dc:	31 97       	sbiw	r30, 0x01	; 1
    13de:	60 e1       	ldi	r22, 0x10	; 16
    13e0:	60 83       	st	Z, r22
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	30 83       	st	Z, r19
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	32 e1       	ldi	r19, 0x12	; 18
    13ea:	30 83       	st	Z, r19
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	33 e1       	ldi	r19, 0x13	; 19
    13f0:	30 83       	st	Z, r19
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	34 e1       	ldi	r19, 0x14	; 20
    13f6:	30 83       	st	Z, r19
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	35 e1       	ldi	r19, 0x15	; 21
    13fc:	30 83       	st	Z, r19
    13fe:	31 97       	sbiw	r30, 0x01	; 1
    1400:	36 e1       	ldi	r19, 0x16	; 22
    1402:	30 83       	st	Z, r19
    1404:	31 97       	sbiw	r30, 0x01	; 1
    1406:	37 e1       	ldi	r19, 0x17	; 23
    1408:	30 83       	st	Z, r19
    140a:	31 97       	sbiw	r30, 0x01	; 1
    140c:	38 e1       	ldi	r19, 0x18	; 24
    140e:	30 83       	st	Z, r19
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	39 e1       	ldi	r19, 0x19	; 25
    1414:	30 83       	st	Z, r19
    1416:	31 97       	sbiw	r30, 0x01	; 1
    1418:	30 e2       	ldi	r19, 0x20	; 32
    141a:	30 83       	st	Z, r19
    141c:	31 97       	sbiw	r30, 0x01	; 1
    141e:	31 e2       	ldi	r19, 0x21	; 33
    1420:	30 83       	st	Z, r19
    1422:	31 97       	sbiw	r30, 0x01	; 1
    1424:	20 83       	st	Z, r18
    1426:	31 97       	sbiw	r30, 0x01	; 1
    1428:	23 e2       	ldi	r18, 0x23	; 35
    142a:	20 83       	st	Z, r18
    142c:	31 97       	sbiw	r30, 0x01	; 1
    142e:	40 83       	st	Z, r20
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	50 83       	st	Z, r21
    1434:	31 97       	sbiw	r30, 0x01	; 1
    1436:	26 e2       	ldi	r18, 0x26	; 38
    1438:	20 83       	st	Z, r18
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	27 e2       	ldi	r18, 0x27	; 39
    143e:	20 83       	st	Z, r18
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	28 e2       	ldi	r18, 0x28	; 40
    1444:	20 83       	st	Z, r18
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	29 e2       	ldi	r18, 0x29	; 41
    144a:	20 83       	st	Z, r18
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	20 e3       	ldi	r18, 0x30	; 48
    1450:	20 83       	st	Z, r18
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	21 e3       	ldi	r18, 0x31	; 49
    1456:	20 83       	st	Z, r18
    1458:	89 97       	sbiw	r24, 0x29	; 41
    145a:	08 95       	ret

0000145c <xPortStartScheduler>:
    145c:	82 e0       	ldi	r24, 0x02	; 2
    145e:	84 bd       	out	0x24, r24	; 36
    1460:	16 bc       	out	0x26, r1	; 38
    1462:	80 e3       	ldi	r24, 0x30	; 48
    1464:	87 bd       	out	0x27, r24	; 39
    1466:	ee e6       	ldi	r30, 0x6E	; 110
    1468:	f0 e0       	ldi	r31, 0x00	; 0
    146a:	80 81       	ld	r24, Z
    146c:	82 60       	ori	r24, 0x02	; 2
    146e:	80 83       	st	Z, r24
    1470:	83 e0       	ldi	r24, 0x03	; 3
    1472:	85 bd       	out	0x25, r24	; 37
    1474:	a0 91 91 08 	lds	r26, 0x0891
    1478:	b0 91 92 08 	lds	r27, 0x0892
    147c:	cd 91       	ld	r28, X+
    147e:	cd bf       	out	0x3d, r28	; 61
    1480:	dd 91       	ld	r29, X+
    1482:	de bf       	out	0x3e, r29	; 62
    1484:	ff 91       	pop	r31
    1486:	ef 91       	pop	r30
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	bf 91       	pop	r27
    148e:	af 91       	pop	r26
    1490:	9f 91       	pop	r25
    1492:	8f 91       	pop	r24
    1494:	7f 91       	pop	r23
    1496:	6f 91       	pop	r22
    1498:	5f 91       	pop	r21
    149a:	4f 91       	pop	r20
    149c:	3f 91       	pop	r19
    149e:	2f 91       	pop	r18
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	ff 90       	pop	r15
    14a6:	ef 90       	pop	r14
    14a8:	df 90       	pop	r13
    14aa:	cf 90       	pop	r12
    14ac:	bf 90       	pop	r11
    14ae:	af 90       	pop	r10
    14b0:	9f 90       	pop	r9
    14b2:	8f 90       	pop	r8
    14b4:	7f 90       	pop	r7
    14b6:	6f 90       	pop	r6
    14b8:	5f 90       	pop	r5
    14ba:	4f 90       	pop	r4
    14bc:	3f 90       	pop	r3
    14be:	2f 90       	pop	r2
    14c0:	1f 90       	pop	r1
    14c2:	0f 90       	pop	r0
    14c4:	0c be       	out	0x3c, r0	; 60
    14c6:	0f 90       	pop	r0
    14c8:	0b be       	out	0x3b, r0	; 59
    14ca:	0f 90       	pop	r0
    14cc:	0f be       	out	0x3f, r0	; 63
    14ce:	0f 90       	pop	r0
    14d0:	08 95       	ret
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	08 95       	ret

000014d6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14d6:	0f 92       	push	r0
    14d8:	0f b6       	in	r0, 0x3f	; 63
    14da:	f8 94       	cli
    14dc:	0f 92       	push	r0
    14de:	0b b6       	in	r0, 0x3b	; 59
    14e0:	0f 92       	push	r0
    14e2:	0c b6       	in	r0, 0x3c	; 60
    14e4:	0f 92       	push	r0
    14e6:	1f 92       	push	r1
    14e8:	11 24       	eor	r1, r1
    14ea:	2f 92       	push	r2
    14ec:	3f 92       	push	r3
    14ee:	4f 92       	push	r4
    14f0:	5f 92       	push	r5
    14f2:	6f 92       	push	r6
    14f4:	7f 92       	push	r7
    14f6:	8f 92       	push	r8
    14f8:	9f 92       	push	r9
    14fa:	af 92       	push	r10
    14fc:	bf 92       	push	r11
    14fe:	cf 92       	push	r12
    1500:	df 92       	push	r13
    1502:	ef 92       	push	r14
    1504:	ff 92       	push	r15
    1506:	0f 93       	push	r16
    1508:	1f 93       	push	r17
    150a:	2f 93       	push	r18
    150c:	3f 93       	push	r19
    150e:	4f 93       	push	r20
    1510:	5f 93       	push	r21
    1512:	6f 93       	push	r22
    1514:	7f 93       	push	r23
    1516:	8f 93       	push	r24
    1518:	9f 93       	push	r25
    151a:	af 93       	push	r26
    151c:	bf 93       	push	r27
    151e:	cf 93       	push	r28
    1520:	df 93       	push	r29
    1522:	ef 93       	push	r30
    1524:	ff 93       	push	r31
    1526:	a0 91 91 08 	lds	r26, 0x0891
    152a:	b0 91 92 08 	lds	r27, 0x0892
    152e:	0d b6       	in	r0, 0x3d	; 61
    1530:	0d 92       	st	X+, r0
    1532:	0e b6       	in	r0, 0x3e	; 62
    1534:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1536:	51 d7       	rcall	.+3746   	; 0x23da <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1538:	a0 91 91 08 	lds	r26, 0x0891
    153c:	b0 91 92 08 	lds	r27, 0x0892
    1540:	cd 91       	ld	r28, X+
    1542:	cd bf       	out	0x3d, r28	; 61
    1544:	dd 91       	ld	r29, X+
    1546:	de bf       	out	0x3e, r29	; 62
    1548:	ff 91       	pop	r31
    154a:	ef 91       	pop	r30
    154c:	df 91       	pop	r29
    154e:	cf 91       	pop	r28
    1550:	bf 91       	pop	r27
    1552:	af 91       	pop	r26
    1554:	9f 91       	pop	r25
    1556:	8f 91       	pop	r24
    1558:	7f 91       	pop	r23
    155a:	6f 91       	pop	r22
    155c:	5f 91       	pop	r21
    155e:	4f 91       	pop	r20
    1560:	3f 91       	pop	r19
    1562:	2f 91       	pop	r18
    1564:	1f 91       	pop	r17
    1566:	0f 91       	pop	r16
    1568:	ff 90       	pop	r15
    156a:	ef 90       	pop	r14
    156c:	df 90       	pop	r13
    156e:	cf 90       	pop	r12
    1570:	bf 90       	pop	r11
    1572:	af 90       	pop	r10
    1574:	9f 90       	pop	r9
    1576:	8f 90       	pop	r8
    1578:	7f 90       	pop	r7
    157a:	6f 90       	pop	r6
    157c:	5f 90       	pop	r5
    157e:	4f 90       	pop	r4
    1580:	3f 90       	pop	r3
    1582:	2f 90       	pop	r2
    1584:	1f 90       	pop	r1
    1586:	0f 90       	pop	r0
    1588:	0c be       	out	0x3c, r0	; 60
    158a:	0f 90       	pop	r0
    158c:	0b be       	out	0x3b, r0	; 59
    158e:	0f 90       	pop	r0
    1590:	0f be       	out	0x3f, r0	; 63
    1592:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1594:	08 95       	ret

00001596 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1596:	0f 92       	push	r0
    1598:	0f b6       	in	r0, 0x3f	; 63
    159a:	f8 94       	cli
    159c:	0f 92       	push	r0
    159e:	0b b6       	in	r0, 0x3b	; 59
    15a0:	0f 92       	push	r0
    15a2:	0c b6       	in	r0, 0x3c	; 60
    15a4:	0f 92       	push	r0
    15a6:	1f 92       	push	r1
    15a8:	11 24       	eor	r1, r1
    15aa:	2f 92       	push	r2
    15ac:	3f 92       	push	r3
    15ae:	4f 92       	push	r4
    15b0:	5f 92       	push	r5
    15b2:	6f 92       	push	r6
    15b4:	7f 92       	push	r7
    15b6:	8f 92       	push	r8
    15b8:	9f 92       	push	r9
    15ba:	af 92       	push	r10
    15bc:	bf 92       	push	r11
    15be:	cf 92       	push	r12
    15c0:	df 92       	push	r13
    15c2:	ef 92       	push	r14
    15c4:	ff 92       	push	r15
    15c6:	0f 93       	push	r16
    15c8:	1f 93       	push	r17
    15ca:	2f 93       	push	r18
    15cc:	3f 93       	push	r19
    15ce:	4f 93       	push	r20
    15d0:	5f 93       	push	r21
    15d2:	6f 93       	push	r22
    15d4:	7f 93       	push	r23
    15d6:	8f 93       	push	r24
    15d8:	9f 93       	push	r25
    15da:	af 93       	push	r26
    15dc:	bf 93       	push	r27
    15de:	cf 93       	push	r28
    15e0:	df 93       	push	r29
    15e2:	ef 93       	push	r30
    15e4:	ff 93       	push	r31
    15e6:	a0 91 91 08 	lds	r26, 0x0891
    15ea:	b0 91 92 08 	lds	r27, 0x0892
    15ee:	0d b6       	in	r0, 0x3d	; 61
    15f0:	0d 92       	st	X+, r0
    15f2:	0e b6       	in	r0, 0x3e	; 62
    15f4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    15f6:	3b d5       	rcall	.+2678   	; 0x206e <xTaskIncrementTick>
    15f8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    15fa:	ef d6       	rcall	.+3550   	; 0x23da <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    15fc:	a0 91 91 08 	lds	r26, 0x0891
    1600:	b0 91 92 08 	lds	r27, 0x0892
    1604:	cd 91       	ld	r28, X+
    1606:	cd bf       	out	0x3d, r28	; 61
    1608:	dd 91       	ld	r29, X+
    160a:	de bf       	out	0x3e, r29	; 62
    160c:	ff 91       	pop	r31
    160e:	ef 91       	pop	r30
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	bf 91       	pop	r27
    1616:	af 91       	pop	r26
    1618:	9f 91       	pop	r25
    161a:	8f 91       	pop	r24
    161c:	7f 91       	pop	r23
    161e:	6f 91       	pop	r22
    1620:	5f 91       	pop	r21
    1622:	4f 91       	pop	r20
    1624:	3f 91       	pop	r19
    1626:	2f 91       	pop	r18
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	ff 90       	pop	r15
    162e:	ef 90       	pop	r14
    1630:	df 90       	pop	r13
    1632:	cf 90       	pop	r12
    1634:	bf 90       	pop	r11
    1636:	af 90       	pop	r10
    1638:	9f 90       	pop	r9
    163a:	8f 90       	pop	r8
    163c:	7f 90       	pop	r7
    163e:	6f 90       	pop	r6
    1640:	5f 90       	pop	r5
    1642:	4f 90       	pop	r4
    1644:	3f 90       	pop	r3
    1646:	2f 90       	pop	r2
    1648:	1f 90       	pop	r1
    164a:	0f 90       	pop	r0
    164c:	0c be       	out	0x3c, r0	; 60
    164e:	0f 90       	pop	r0
    1650:	0b be       	out	0x3b, r0	; 59
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
    1656:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1658:	08 95       	ret

0000165a <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    165a:	9d df       	rcall	.-198    	; 0x1596 <vPortYieldFromTick>
		 asm volatile ("reti");
    165c:	18 95       	reti

0000165e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    165e:	1f 93       	push	r17
    1660:	cf 93       	push	r28
    1662:	df 93       	push	r29
    1664:	ec 01       	movw	r28, r24
    1666:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1668:	8c 8d       	ldd	r24, Y+28	; 0x1c
    166a:	81 11       	cpse	r24, r1
    166c:	0c c0       	rjmp	.+24     	; 0x1686 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    166e:	88 81       	ld	r24, Y
    1670:	99 81       	ldd	r25, Y+1	; 0x01
    1672:	89 2b       	or	r24, r25
    1674:	09 f0       	breq	.+2      	; 0x1678 <prvCopyDataToQueue+0x1a>
    1676:	47 c0       	rjmp	.+142    	; 0x1706 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1678:	8a 81       	ldd	r24, Y+2	; 0x02
    167a:	9b 81       	ldd	r25, Y+3	; 0x03
    167c:	0e 94 b0 13 	call	0x2760	; 0x2760 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1680:	1b 82       	std	Y+3, r1	; 0x03
    1682:	1a 82       	std	Y+2, r1	; 0x02
    1684:	47 c0       	rjmp	.+142    	; 0x1714 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1686:	41 11       	cpse	r20, r1
    1688:	18 c0       	rjmp	.+48     	; 0x16ba <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    168a:	48 2f       	mov	r20, r24
    168c:	50 e0       	ldi	r21, 0x00	; 0
    168e:	8c 81       	ldd	r24, Y+4	; 0x04
    1690:	9d 81       	ldd	r25, Y+5	; 0x05
    1692:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1696:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1698:	8c 81       	ldd	r24, Y+4	; 0x04
    169a:	9d 81       	ldd	r25, Y+5	; 0x05
    169c:	82 0f       	add	r24, r18
    169e:	91 1d       	adc	r25, r1
    16a0:	9d 83       	std	Y+5, r25	; 0x05
    16a2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16a4:	2a 81       	ldd	r18, Y+2	; 0x02
    16a6:	3b 81       	ldd	r19, Y+3	; 0x03
    16a8:	82 17       	cp	r24, r18
    16aa:	93 07       	cpc	r25, r19
    16ac:	70 f1       	brcs	.+92     	; 0x170a <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    16ae:	88 81       	ld	r24, Y
    16b0:	99 81       	ldd	r25, Y+1	; 0x01
    16b2:	9d 83       	std	Y+5, r25	; 0x05
    16b4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16b6:	80 e0       	ldi	r24, 0x00	; 0
    16b8:	2d c0       	rjmp	.+90     	; 0x1714 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16ba:	48 2f       	mov	r20, r24
    16bc:	50 e0       	ldi	r21, 0x00	; 0
    16be:	8e 81       	ldd	r24, Y+6	; 0x06
    16c0:	9f 81       	ldd	r25, Y+7	; 0x07
    16c2:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    16c6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16c8:	30 e0       	ldi	r19, 0x00	; 0
    16ca:	31 95       	neg	r19
    16cc:	21 95       	neg	r18
    16ce:	31 09       	sbc	r19, r1
    16d0:	8e 81       	ldd	r24, Y+6	; 0x06
    16d2:	9f 81       	ldd	r25, Y+7	; 0x07
    16d4:	82 0f       	add	r24, r18
    16d6:	93 1f       	adc	r25, r19
    16d8:	9f 83       	std	Y+7, r25	; 0x07
    16da:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16dc:	68 81       	ld	r22, Y
    16de:	79 81       	ldd	r23, Y+1	; 0x01
    16e0:	86 17       	cp	r24, r22
    16e2:	97 07       	cpc	r25, r23
    16e4:	30 f4       	brcc	.+12     	; 0x16f2 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16e6:	8a 81       	ldd	r24, Y+2	; 0x02
    16e8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ea:	28 0f       	add	r18, r24
    16ec:	39 1f       	adc	r19, r25
    16ee:	3f 83       	std	Y+7, r19	; 0x07
    16f0:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    16f2:	12 30       	cpi	r17, 0x02	; 2
    16f4:	61 f4       	brne	.+24     	; 0x170e <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    16f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16f8:	88 23       	and	r24, r24
    16fa:	59 f0       	breq	.+22     	; 0x1712 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    16fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16fe:	81 50       	subi	r24, 0x01	; 1
    1700:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1702:	80 e0       	ldi	r24, 0x00	; 0
    1704:	07 c0       	rjmp	.+14     	; 0x1714 <prvCopyDataToQueue+0xb6>
    1706:	80 e0       	ldi	r24, 0x00	; 0
    1708:	05 c0       	rjmp	.+10     	; 0x1714 <prvCopyDataToQueue+0xb6>
    170a:	80 e0       	ldi	r24, 0x00	; 0
    170c:	03 c0       	rjmp	.+6      	; 0x1714 <prvCopyDataToQueue+0xb6>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	01 c0       	rjmp	.+2      	; 0x1714 <prvCopyDataToQueue+0xb6>
    1712:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1714:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1716:	9f 5f       	subi	r25, 0xFF	; 255
    1718:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	1f 91       	pop	r17
    1720:	08 95       	ret

00001722 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1722:	fc 01       	movw	r30, r24
    1724:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1726:	44 8d       	ldd	r20, Z+28	; 0x1c
    1728:	44 23       	and	r20, r20
    172a:	a1 f0       	breq	.+40     	; 0x1754 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    172c:	50 e0       	ldi	r21, 0x00	; 0
    172e:	26 81       	ldd	r18, Z+6	; 0x06
    1730:	37 81       	ldd	r19, Z+7	; 0x07
    1732:	24 0f       	add	r18, r20
    1734:	35 1f       	adc	r19, r21
    1736:	37 83       	std	Z+7, r19	; 0x07
    1738:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    173a:	62 81       	ldd	r22, Z+2	; 0x02
    173c:	73 81       	ldd	r23, Z+3	; 0x03
    173e:	26 17       	cp	r18, r22
    1740:	37 07       	cpc	r19, r23
    1742:	20 f0       	brcs	.+8      	; 0x174c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1744:	20 81       	ld	r18, Z
    1746:	31 81       	ldd	r19, Z+1	; 0x01
    1748:	37 83       	std	Z+7, r19	; 0x07
    174a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    174c:	66 81       	ldd	r22, Z+6	; 0x06
    174e:	77 81       	ldd	r23, Z+7	; 0x07
    1750:	0c 94 7c 17 	jmp	0x2ef8	; 0x2ef8 <memcpy>
    1754:	08 95       	ret

00001756 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1756:	0f 93       	push	r16
    1758:	1f 93       	push	r17
    175a:	cf 93       	push	r28
    175c:	df 93       	push	r29
    175e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1766:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1768:	18 16       	cp	r1, r24
    176a:	a4 f4       	brge	.+40     	; 0x1794 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    176c:	89 89       	ldd	r24, Y+17	; 0x11
    176e:	88 23       	and	r24, r24
    1770:	89 f0       	breq	.+34     	; 0x1794 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1772:	8e 01       	movw	r16, r28
    1774:	0f 5e       	subi	r16, 0xEF	; 239
    1776:	1f 4f       	sbci	r17, 0xFF	; 255
    1778:	03 c0       	rjmp	.+6      	; 0x1780 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    177a:	89 89       	ldd	r24, Y+17	; 0x11
    177c:	88 23       	and	r24, r24
    177e:	51 f0       	breq	.+20     	; 0x1794 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1780:	c8 01       	movw	r24, r16
    1782:	01 d7       	rcall	.+3586   	; 0x2586 <xTaskRemoveFromEventList>
    1784:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1786:	8a d7       	rcall	.+3860   	; 0x269c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1788:	8e 8d       	ldd	r24, Y+30	; 0x1e
    178a:	81 50       	subi	r24, 0x01	; 1
    178c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    178e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1790:	18 16       	cp	r1, r24
    1792:	9c f3       	brlt	.-26     	; 0x177a <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1794:	8f ef       	ldi	r24, 0xFF	; 255
    1796:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1798:	0f 90       	pop	r0
    179a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17a2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17a4:	18 16       	cp	r1, r24
    17a6:	a4 f4       	brge	.+40     	; 0x17d0 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17a8:	88 85       	ldd	r24, Y+8	; 0x08
    17aa:	88 23       	and	r24, r24
    17ac:	89 f0       	breq	.+34     	; 0x17d0 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17ae:	8e 01       	movw	r16, r28
    17b0:	08 5f       	subi	r16, 0xF8	; 248
    17b2:	1f 4f       	sbci	r17, 0xFF	; 255
    17b4:	03 c0       	rjmp	.+6      	; 0x17bc <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b6:	88 85       	ldd	r24, Y+8	; 0x08
    17b8:	88 23       	and	r24, r24
    17ba:	51 f0       	breq	.+20     	; 0x17d0 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17bc:	c8 01       	movw	r24, r16
    17be:	e3 d6       	rcall	.+3526   	; 0x2586 <xTaskRemoveFromEventList>
    17c0:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    17c2:	6c d7       	rcall	.+3800   	; 0x269c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    17c4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17c6:	81 50       	subi	r24, 0x01	; 1
    17c8:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17ca:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17cc:	18 16       	cp	r1, r24
    17ce:	9c f3       	brlt	.-26     	; 0x17b6 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    17d0:	8f ef       	ldi	r24, 0xFF	; 255
    17d2:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63
}
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	08 95       	ret

000017e2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    17e2:	cf 93       	push	r28
    17e4:	df 93       	push	r29
    17e6:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17e8:	0f b6       	in	r0, 0x3f	; 63
    17ea:	f8 94       	cli
    17ec:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    17ee:	88 81       	ld	r24, Y
    17f0:	99 81       	ldd	r25, Y+1	; 0x01
    17f2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	7b 8d       	ldd	r23, Y+27	; 0x1b
    17f8:	72 9f       	mul	r23, r18
    17fa:	a0 01       	movw	r20, r0
    17fc:	73 9f       	mul	r23, r19
    17fe:	50 0d       	add	r21, r0
    1800:	11 24       	eor	r1, r1
    1802:	fc 01       	movw	r30, r24
    1804:	e4 0f       	add	r30, r20
    1806:	f5 1f       	adc	r31, r21
    1808:	fb 83       	std	Y+3, r31	; 0x03
    180a:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    180c:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    180e:	9d 83       	std	Y+5, r25	; 0x05
    1810:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1812:	42 1b       	sub	r20, r18
    1814:	53 0b       	sbc	r21, r19
    1816:	84 0f       	add	r24, r20
    1818:	95 1f       	adc	r25, r21
    181a:	9f 83       	std	Y+7, r25	; 0x07
    181c:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    181e:	8f ef       	ldi	r24, 0xFF	; 255
    1820:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1822:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1824:	61 11       	cpse	r22, r1
    1826:	0a c0       	rjmp	.+20     	; 0x183c <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1828:	88 85       	ldd	r24, Y+8	; 0x08
    182a:	88 23       	and	r24, r24
    182c:	79 f0       	breq	.+30     	; 0x184c <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    182e:	ce 01       	movw	r24, r28
    1830:	08 96       	adiw	r24, 0x08	; 8
    1832:	a9 d6       	rcall	.+3410   	; 0x2586 <xTaskRemoveFromEventList>
    1834:	81 30       	cpi	r24, 0x01	; 1
    1836:	51 f4       	brne	.+20     	; 0x184c <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1838:	4e de       	rcall	.-868    	; 0x14d6 <vPortYield>
    183a:	08 c0       	rjmp	.+16     	; 0x184c <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    183c:	ce 01       	movw	r24, r28
    183e:	08 96       	adiw	r24, 0x08	; 8
    1840:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1844:	ce 01       	movw	r24, r28
    1846:	41 96       	adiw	r24, 0x11	; 17
    1848:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    184c:	0f 90       	pop	r0
    184e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1850:	81 e0       	ldi	r24, 0x01	; 1
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	08 95       	ret

00001858 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1858:	0f 93       	push	r16
    185a:	1f 93       	push	r17
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	18 2f       	mov	r17, r24
    1862:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1864:	88 23       	and	r24, r24
    1866:	e9 f0       	breq	.+58     	; 0x18a2 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1868:	8f e1       	ldi	r24, 0x1F	; 31
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1870:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1872:	00 97       	sbiw	r24, 0x00	; 0
    1874:	c1 f0       	breq	.+48     	; 0x18a6 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1876:	10 9f       	mul	r17, r16
    1878:	c0 01       	movw	r24, r0
    187a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    187c:	01 96       	adiw	r24, 0x01	; 1
    187e:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1882:	99 83       	std	Y+1, r25	; 0x01
    1884:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1886:	89 2b       	or	r24, r25
    1888:	31 f0       	breq	.+12     	; 0x1896 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    188a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    188c:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    188e:	61 e0       	ldi	r22, 0x01	; 1
    1890:	ce 01       	movw	r24, r28
    1892:	a7 df       	rcall	.-178    	; 0x17e2 <xQueueGenericReset>
    1894:	08 c0       	rjmp	.+16     	; 0x18a6 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1896:	ce 01       	movw	r24, r28
    1898:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    189c:	c0 e0       	ldi	r28, 0x00	; 0
    189e:	d0 e0       	ldi	r29, 0x00	; 0
    18a0:	02 c0       	rjmp	.+4      	; 0x18a6 <xQueueGenericCreate+0x4e>
    18a2:	c0 e0       	ldi	r28, 0x00	; 0
    18a4:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    18a6:	ce 01       	movw	r24, r28
    18a8:	df 91       	pop	r29
    18aa:	cf 91       	pop	r28
    18ac:	1f 91       	pop	r17
    18ae:	0f 91       	pop	r16
    18b0:	08 95       	ret

000018b2 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    18b2:	9f 92       	push	r9
    18b4:	af 92       	push	r10
    18b6:	bf 92       	push	r11
    18b8:	cf 92       	push	r12
    18ba:	df 92       	push	r13
    18bc:	ef 92       	push	r14
    18be:	ff 92       	push	r15
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	00 d0       	rcall	.+0      	; 0x18ca <xQueueGenericSend+0x18>
    18ca:	1f 92       	push	r1
    18cc:	1f 92       	push	r1
    18ce:	cd b7       	in	r28, 0x3d	; 61
    18d0:	de b7       	in	r29, 0x3e	; 62
    18d2:	8c 01       	movw	r16, r24
    18d4:	6b 01       	movw	r12, r22
    18d6:	5d 83       	std	Y+5, r21	; 0x05
    18d8:	4c 83       	std	Y+4, r20	; 0x04
    18da:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    18dc:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    18de:	99 24       	eor	r9, r9
    18e0:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18e2:	7c 01       	movw	r14, r24
    18e4:	88 e0       	ldi	r24, 0x08	; 8
    18e6:	e8 0e       	add	r14, r24
    18e8:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	f8 94       	cli
    18ee:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18f0:	f8 01       	movw	r30, r16
    18f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    18f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    18f6:	98 17       	cp	r25, r24
    18f8:	18 f0       	brcs	.+6      	; 0x1900 <xQueueGenericSend+0x4e>
    18fa:	f2 e0       	ldi	r31, 0x02	; 2
    18fc:	af 12       	cpse	r10, r31
    18fe:	15 c0       	rjmp	.+42     	; 0x192a <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1900:	4a 2d       	mov	r20, r10
    1902:	b6 01       	movw	r22, r12
    1904:	c8 01       	movw	r24, r16
    1906:	ab de       	rcall	.-682    	; 0x165e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1908:	f8 01       	movw	r30, r16
    190a:	91 89       	ldd	r25, Z+17	; 0x11
    190c:	99 23       	and	r25, r25
    190e:	39 f0       	breq	.+14     	; 0x191e <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1910:	c8 01       	movw	r24, r16
    1912:	41 96       	adiw	r24, 0x11	; 17
    1914:	38 d6       	rcall	.+3184   	; 0x2586 <xTaskRemoveFromEventList>
    1916:	81 30       	cpi	r24, 0x01	; 1
    1918:	21 f4       	brne	.+8      	; 0x1922 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    191a:	dd dd       	rcall	.-1094   	; 0x14d6 <vPortYield>
    191c:	02 c0       	rjmp	.+4      	; 0x1922 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    191e:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1920:	da dd       	rcall	.-1100   	; 0x14d6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	46 c0       	rjmp	.+140    	; 0x19b6 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    192a:	ec 81       	ldd	r30, Y+4	; 0x04
    192c:	fd 81       	ldd	r31, Y+5	; 0x05
    192e:	ef 2b       	or	r30, r31
    1930:	21 f4       	brne	.+8      	; 0x193a <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1932:	0f 90       	pop	r0
    1934:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	3e c0       	rjmp	.+124    	; 0x19b6 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    193a:	b1 10       	cpse	r11, r1
    193c:	04 c0       	rjmp	.+8      	; 0x1946 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    193e:	ce 01       	movw	r24, r28
    1940:	01 96       	adiw	r24, 0x01	; 1
    1942:	69 d6       	rcall	.+3282   	; 0x2616 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1944:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    194a:	7c d3       	rcall	.+1784   	; 0x2044 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    194c:	0f b6       	in	r0, 0x3f	; 63
    194e:	f8 94       	cli
    1950:	0f 92       	push	r0
    1952:	f8 01       	movw	r30, r16
    1954:	85 8d       	ldd	r24, Z+29	; 0x1d
    1956:	8f 3f       	cpi	r24, 0xFF	; 255
    1958:	09 f4       	brne	.+2      	; 0x195c <xQueueGenericSend+0xaa>
    195a:	15 8e       	std	Z+29, r1	; 0x1d
    195c:	f8 01       	movw	r30, r16
    195e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1960:	8f 3f       	cpi	r24, 0xFF	; 255
    1962:	09 f4       	brne	.+2      	; 0x1966 <xQueueGenericSend+0xb4>
    1964:	16 8e       	std	Z+30, r1	; 0x1e
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    196a:	be 01       	movw	r22, r28
    196c:	6c 5f       	subi	r22, 0xFC	; 252
    196e:	7f 4f       	sbci	r23, 0xFF	; 255
    1970:	ce 01       	movw	r24, r28
    1972:	01 96       	adiw	r24, 0x01	; 1
    1974:	5b d6       	rcall	.+3254   	; 0x262c <xTaskCheckForTimeOut>
    1976:	81 11       	cpse	r24, r1
    1978:	1a c0       	rjmp	.+52     	; 0x19ae <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1980:	f8 01       	movw	r30, r16
    1982:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1988:	f8 01       	movw	r30, r16
    198a:	83 8d       	ldd	r24, Z+27	; 0x1b
    198c:	98 13       	cpse	r25, r24
    198e:	0b c0       	rjmp	.+22     	; 0x19a6 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1990:	6c 81       	ldd	r22, Y+4	; 0x04
    1992:	7d 81       	ldd	r23, Y+5	; 0x05
    1994:	c7 01       	movw	r24, r14
    1996:	cc d5       	rcall	.+2968   	; 0x2530 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1998:	c8 01       	movw	r24, r16
    199a:	dd de       	rcall	.-582    	; 0x1756 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    199c:	26 d4       	rcall	.+2124   	; 0x21ea <xTaskResumeAll>
    199e:	81 11       	cpse	r24, r1
    19a0:	a4 cf       	rjmp	.-184    	; 0x18ea <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    19a2:	99 dd       	rcall	.-1230   	; 0x14d6 <vPortYield>
    19a4:	a2 cf       	rjmp	.-188    	; 0x18ea <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19a6:	c8 01       	movw	r24, r16
    19a8:	d6 de       	rcall	.-596    	; 0x1756 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19aa:	1f d4       	rcall	.+2110   	; 0x21ea <xTaskResumeAll>
    19ac:	9e cf       	rjmp	.-196    	; 0x18ea <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19ae:	c8 01       	movw	r24, r16
    19b0:	d2 de       	rcall	.-604    	; 0x1756 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19b2:	1b d4       	rcall	.+2102   	; 0x21ea <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19b4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19b6:	0f 90       	pop	r0
    19b8:	0f 90       	pop	r0
    19ba:	0f 90       	pop	r0
    19bc:	0f 90       	pop	r0
    19be:	0f 90       	pop	r0
    19c0:	df 91       	pop	r29
    19c2:	cf 91       	pop	r28
    19c4:	1f 91       	pop	r17
    19c6:	0f 91       	pop	r16
    19c8:	ff 90       	pop	r15
    19ca:	ef 90       	pop	r14
    19cc:	df 90       	pop	r13
    19ce:	cf 90       	pop	r12
    19d0:	bf 90       	pop	r11
    19d2:	af 90       	pop	r10
    19d4:	9f 90       	pop	r9
    19d6:	08 95       	ret

000019d8 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    19d8:	cf 93       	push	r28
    19da:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    19dc:	8f e1       	ldi	r24, 0x1F	; 31
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    19e4:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    19e6:	00 97       	sbiw	r24, 0x00	; 0
    19e8:	f1 f0       	breq	.+60     	; 0x1a26 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    19ea:	1b 82       	std	Y+3, r1	; 0x03
    19ec:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    19ee:	19 82       	std	Y+1, r1	; 0x01
    19f0:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    19f2:	1d 82       	std	Y+5, r1	; 0x05
    19f4:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    19f6:	1f 82       	std	Y+7, r1	; 0x07
    19f8:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19fa:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    19fc:	81 e0       	ldi	r24, 0x01	; 1
    19fe:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1a00:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1a02:	8f ef       	ldi	r24, 0xFF	; 255
    1a04:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1a06:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1a08:	ce 01       	movw	r24, r28
    1a0a:	08 96       	adiw	r24, 0x08	; 8
    1a0c:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1a10:	ce 01       	movw	r24, r28
    1a12:	41 96       	adiw	r24, 0x11	; 17
    1a14:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1a18:	20 e0       	ldi	r18, 0x00	; 0
    1a1a:	40 e0       	ldi	r20, 0x00	; 0
    1a1c:	50 e0       	ldi	r21, 0x00	; 0
    1a1e:	60 e0       	ldi	r22, 0x00	; 0
    1a20:	70 e0       	ldi	r23, 0x00	; 0
    1a22:	ce 01       	movw	r24, r28
    1a24:	46 df       	rcall	.-372    	; 0x18b2 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1a26:	ce 01       	movw	r24, r28
    1a28:	df 91       	pop	r29
    1a2a:	cf 91       	pop	r28
    1a2c:	08 95       	ret

00001a2e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a2e:	0f 93       	push	r16
    1a30:	1f 93       	push	r17
    1a32:	cf 93       	push	r28
    1a34:	df 93       	push	r29
    1a36:	ec 01       	movw	r28, r24
    1a38:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a3c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a3e:	98 17       	cp	r25, r24
    1a40:	10 f0       	brcs	.+4      	; 0x1a46 <xQueueGenericSendFromISR+0x18>
    1a42:	22 30       	cpi	r18, 0x02	; 2
    1a44:	11 f5       	brne	.+68     	; 0x1a8a <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a46:	42 2f       	mov	r20, r18
    1a48:	ce 01       	movw	r24, r28
    1a4a:	09 de       	rcall	.-1006   	; 0x165e <prvCopyDataToQueue>
    1a4c:	88 23       	and	r24, r24
    1a4e:	31 f0       	breq	.+12     	; 0x1a5c <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1a50:	01 15       	cp	r16, r1
    1a52:	11 05       	cpc	r17, r1
    1a54:	19 f0       	breq	.+6      	; 0x1a5c <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	f8 01       	movw	r30, r16
    1a5a:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a5c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a60:	79 f4       	brne	.+30     	; 0x1a80 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a62:	89 89       	ldd	r24, Y+17	; 0x11
    1a64:	88 23       	and	r24, r24
    1a66:	99 f0       	breq	.+38     	; 0x1a8e <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a68:	ce 01       	movw	r24, r28
    1a6a:	41 96       	adiw	r24, 0x11	; 17
    1a6c:	8c d5       	rcall	.+2840   	; 0x2586 <xTaskRemoveFromEventList>
    1a6e:	88 23       	and	r24, r24
    1a70:	81 f0       	breq	.+32     	; 0x1a92 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a72:	01 15       	cp	r16, r1
    1a74:	11 05       	cpc	r17, r1
    1a76:	79 f0       	breq	.+30     	; 0x1a96 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	f8 01       	movw	r30, r16
    1a7c:	80 83       	st	Z, r24
    1a7e:	0c c0       	rjmp	.+24     	; 0x1a98 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a80:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a82:	8f 5f       	subi	r24, 0xFF	; 255
    1a84:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	07 c0       	rjmp	.+14     	; 0x1a98 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a8a:	80 e0       	ldi	r24, 0x00	; 0
    1a8c:	05 c0       	rjmp	.+10     	; 0x1a98 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a8e:	81 e0       	ldi	r24, 0x01	; 1
    1a90:	03 c0       	rjmp	.+6      	; 0x1a98 <xQueueGenericSendFromISR+0x6a>
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	01 c0       	rjmp	.+2      	; 0x1a98 <xQueueGenericSendFromISR+0x6a>
    1a96:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	1f 91       	pop	r17
    1a9e:	0f 91       	pop	r16
    1aa0:	08 95       	ret

00001aa2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1aa2:	9f 92       	push	r9
    1aa4:	af 92       	push	r10
    1aa6:	bf 92       	push	r11
    1aa8:	cf 92       	push	r12
    1aaa:	df 92       	push	r13
    1aac:	ef 92       	push	r14
    1aae:	ff 92       	push	r15
    1ab0:	0f 93       	push	r16
    1ab2:	1f 93       	push	r17
    1ab4:	cf 93       	push	r28
    1ab6:	df 93       	push	r29
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <xQueueGenericReceive+0x18>
    1aba:	1f 92       	push	r1
    1abc:	1f 92       	push	r1
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
    1ac2:	8c 01       	movw	r16, r24
    1ac4:	6b 01       	movw	r12, r22
    1ac6:	5d 83       	std	Y+5, r21	; 0x05
    1ac8:	4c 83       	std	Y+4, r20	; 0x04
    1aca:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1acc:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ace:	99 24       	eor	r9, r9
    1ad0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ad2:	7c 01       	movw	r14, r24
    1ad4:	81 e1       	ldi	r24, 0x11	; 17
    1ad6:	e8 0e       	add	r14, r24
    1ad8:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ada:	0f b6       	in	r0, 0x3f	; 63
    1adc:	f8 94       	cli
    1ade:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ae0:	f8 01       	movw	r30, r16
    1ae2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ae4:	88 23       	and	r24, r24
    1ae6:	69 f1       	breq	.+90     	; 0x1b42 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1ae8:	e6 80       	ldd	r14, Z+6	; 0x06
    1aea:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aec:	b6 01       	movw	r22, r12
    1aee:	c8 01       	movw	r24, r16
    1af0:	18 de       	rcall	.-976    	; 0x1722 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1af2:	b1 10       	cpse	r11, r1
    1af4:	17 c0       	rjmp	.+46     	; 0x1b24 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1af6:	f8 01       	movw	r30, r16
    1af8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1afa:	81 50       	subi	r24, 0x01	; 1
    1afc:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1afe:	80 81       	ld	r24, Z
    1b00:	91 81       	ldd	r25, Z+1	; 0x01
    1b02:	89 2b       	or	r24, r25
    1b04:	21 f4       	brne	.+8      	; 0x1b0e <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1b06:	6b d6       	rcall	.+3286   	; 0x27de <pvTaskIncrementMutexHeldCount>
    1b08:	f8 01       	movw	r30, r16
    1b0a:	93 83       	std	Z+3, r25	; 0x03
    1b0c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b0e:	f8 01       	movw	r30, r16
    1b10:	80 85       	ldd	r24, Z+8	; 0x08
    1b12:	88 23       	and	r24, r24
    1b14:	91 f0       	breq	.+36     	; 0x1b3a <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b16:	c8 01       	movw	r24, r16
    1b18:	08 96       	adiw	r24, 0x08	; 8
    1b1a:	35 d5       	rcall	.+2666   	; 0x2586 <xTaskRemoveFromEventList>
    1b1c:	81 30       	cpi	r24, 0x01	; 1
    1b1e:	69 f4       	brne	.+26     	; 0x1b3a <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b20:	da dc       	rcall	.-1612   	; 0x14d6 <vPortYield>
    1b22:	0b c0       	rjmp	.+22     	; 0x1b3a <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b24:	f8 01       	movw	r30, r16
    1b26:	f7 82       	std	Z+7, r15	; 0x07
    1b28:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b2a:	81 89       	ldd	r24, Z+17	; 0x11
    1b2c:	88 23       	and	r24, r24
    1b2e:	29 f0       	breq	.+10     	; 0x1b3a <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b30:	c8 01       	movw	r24, r16
    1b32:	41 96       	adiw	r24, 0x11	; 17
    1b34:	28 d5       	rcall	.+2640   	; 0x2586 <xTaskRemoveFromEventList>
    1b36:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b38:	ce dc       	rcall	.-1636   	; 0x14d6 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b3e:	81 e0       	ldi	r24, 0x01	; 1
    1b40:	52 c0       	rjmp	.+164    	; 0x1be6 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b42:	4c 81       	ldd	r20, Y+4	; 0x04
    1b44:	5d 81       	ldd	r21, Y+5	; 0x05
    1b46:	45 2b       	or	r20, r21
    1b48:	21 f4       	brne	.+8      	; 0x1b52 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
    1b50:	4a c0       	rjmp	.+148    	; 0x1be6 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b52:	a1 10       	cpse	r10, r1
    1b54:	04 c0       	rjmp	.+8      	; 0x1b5e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b56:	ce 01       	movw	r24, r28
    1b58:	01 96       	adiw	r24, 0x01	; 1
    1b5a:	5d d5       	rcall	.+2746   	; 0x2616 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b5c:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b5e:	0f 90       	pop	r0
    1b60:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b62:	70 d2       	rcall	.+1248   	; 0x2044 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b64:	0f b6       	in	r0, 0x3f	; 63
    1b66:	f8 94       	cli
    1b68:	0f 92       	push	r0
    1b6a:	f8 01       	movw	r30, r16
    1b6c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b70:	09 f4       	brne	.+2      	; 0x1b74 <xQueueGenericReceive+0xd2>
    1b72:	15 8e       	std	Z+29, r1	; 0x1d
    1b74:	f8 01       	movw	r30, r16
    1b76:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b78:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <xQueueGenericReceive+0xdc>
    1b7c:	16 8e       	std	Z+30, r1	; 0x1e
    1b7e:	0f 90       	pop	r0
    1b80:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b82:	be 01       	movw	r22, r28
    1b84:	6c 5f       	subi	r22, 0xFC	; 252
    1b86:	7f 4f       	sbci	r23, 0xFF	; 255
    1b88:	ce 01       	movw	r24, r28
    1b8a:	01 96       	adiw	r24, 0x01	; 1
    1b8c:	4f d5       	rcall	.+2718   	; 0x262c <xTaskCheckForTimeOut>
    1b8e:	81 11       	cpse	r24, r1
    1b90:	26 c0       	rjmp	.+76     	; 0x1bde <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b92:	0f b6       	in	r0, 0x3f	; 63
    1b94:	f8 94       	cli
    1b96:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b98:	f8 01       	movw	r30, r16
    1b9a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b9c:	0f 90       	pop	r0
    1b9e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ba0:	81 11       	cpse	r24, r1
    1ba2:	19 c0       	rjmp	.+50     	; 0x1bd6 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ba4:	f8 01       	movw	r30, r16
    1ba6:	80 81       	ld	r24, Z
    1ba8:	91 81       	ldd	r25, Z+1	; 0x01
    1baa:	89 2b       	or	r24, r25
    1bac:	49 f4       	brne	.+18     	; 0x1bc0 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1bb4:	f8 01       	movw	r30, r16
    1bb6:	82 81       	ldd	r24, Z+2	; 0x02
    1bb8:	93 81       	ldd	r25, Z+3	; 0x03
    1bba:	74 d5       	rcall	.+2792   	; 0x26a4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1bbc:	0f 90       	pop	r0
    1bbe:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bc0:	6c 81       	ldd	r22, Y+4	; 0x04
    1bc2:	7d 81       	ldd	r23, Y+5	; 0x05
    1bc4:	c7 01       	movw	r24, r14
    1bc6:	b4 d4       	rcall	.+2408   	; 0x2530 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1bc8:	c8 01       	movw	r24, r16
    1bca:	c5 dd       	rcall	.-1142   	; 0x1756 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1bcc:	0e d3       	rcall	.+1564   	; 0x21ea <xTaskResumeAll>
    1bce:	81 11       	cpse	r24, r1
    1bd0:	84 cf       	rjmp	.-248    	; 0x1ada <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1bd2:	81 dc       	rcall	.-1790   	; 0x14d6 <vPortYield>
    1bd4:	82 cf       	rjmp	.-252    	; 0x1ada <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bd6:	c8 01       	movw	r24, r16
    1bd8:	be dd       	rcall	.-1156   	; 0x1756 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bda:	07 d3       	rcall	.+1550   	; 0x21ea <xTaskResumeAll>
    1bdc:	7e cf       	rjmp	.-260    	; 0x1ada <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1bde:	c8 01       	movw	r24, r16
    1be0:	ba dd       	rcall	.-1164   	; 0x1756 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1be2:	03 d3       	rcall	.+1542   	; 0x21ea <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1be4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1be6:	0f 90       	pop	r0
    1be8:	0f 90       	pop	r0
    1bea:	0f 90       	pop	r0
    1bec:	0f 90       	pop	r0
    1bee:	0f 90       	pop	r0
    1bf0:	df 91       	pop	r29
    1bf2:	cf 91       	pop	r28
    1bf4:	1f 91       	pop	r17
    1bf6:	0f 91       	pop	r16
    1bf8:	ff 90       	pop	r15
    1bfa:	ef 90       	pop	r14
    1bfc:	df 90       	pop	r13
    1bfe:	cf 90       	pop	r12
    1c00:	bf 90       	pop	r11
    1c02:	af 90       	pop	r10
    1c04:	9f 90       	pop	r9
    1c06:	08 95       	ret

00001c08 <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1c08:	fc 01       	movw	r30, r24
    1c0a:	71 83       	std	Z+1, r23	; 0x01
    1c0c:	60 83       	st	Z, r22
    1c0e:	42 83       	std	Z+2, r20	; 0x02
    1c10:	14 82       	std	Z+4, r1	; 0x04
    1c12:	13 82       	std	Z+3, r1	; 0x03
    1c14:	08 95       	ret

00001c16 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1c16:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1c18:	94 81       	ldd	r25, Z+4	; 0x04
    1c1a:	a0 81       	ld	r26, Z
    1c1c:	b1 81       	ldd	r27, Z+1	; 0x01
    1c1e:	a9 0f       	add	r26, r25
    1c20:	b1 1d       	adc	r27, r1
    1c22:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1c24:	9f 5f       	subi	r25, 0xFF	; 255
    1c26:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1c28:	22 81       	ldd	r18, Z+2	; 0x02
    1c2a:	92 17       	cp	r25, r18
    1c2c:	10 f0       	brcs	.+4      	; 0x1c32 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1c2e:	92 1b       	sub	r25, r18
    1c30:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c32:	93 81       	ldd	r25, Z+3	; 0x03
    1c34:	91 50       	subi	r25, 0x01	; 1
    1c36:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c38:	08 95       	ret

00001c3a <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c3e:	83 81       	ldd	r24, Z+3	; 0x03
    1c40:	22 81       	ldd	r18, Z+2	; 0x02
    1c42:	82 17       	cp	r24, r18
    1c44:	80 f4       	brcc	.+32     	; 0x1c66 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c46:	34 81       	ldd	r19, Z+4	; 0x04
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	83 0f       	add	r24, r19
    1c4c:	91 1d       	adc	r25, r1
    1c4e:	62 2f       	mov	r22, r18
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <__divmodhi4>
    1c56:	a0 81       	ld	r26, Z
    1c58:	b1 81       	ldd	r27, Z+1	; 0x01
    1c5a:	a8 0f       	add	r26, r24
    1c5c:	b9 1f       	adc	r27, r25
    1c5e:	4c 93       	st	X, r20
            ring->rLength++;
    1c60:	83 81       	ldd	r24, Z+3	; 0x03
    1c62:	8f 5f       	subi	r24, 0xFF	; 255
    1c64:	83 83       	std	Z+3, r24	; 0x03
    1c66:	08 95       	ret

00001c68 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c68:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	22 81       	ldd	r18, Z+2	; 0x02
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	29 13       	cpse	r18, r25
    1c72:	80 e0       	ldi	r24, 0x00	; 0
}
    1c74:	08 95       	ret

00001c76 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c76:	21 e0       	ldi	r18, 0x01	; 1
    1c78:	fc 01       	movw	r30, r24
    1c7a:	83 81       	ldd	r24, Z+3	; 0x03
    1c7c:	81 11       	cpse	r24, r1
    1c7e:	01 c0       	rjmp	.+2      	; 0x1c82 <ringBufferNotEmpty+0xc>
    1c80:	20 e0       	ldi	r18, 0x00	; 0
}
    1c82:	82 2f       	mov	r24, r18
    1c84:	08 95       	ret

00001c86 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c86:	e0 91 50 08 	lds	r30, 0x0850
    1c8a:	f0 91 51 08 	lds	r31, 0x0851
    1c8e:	80 81       	ld	r24, Z
    1c90:	81 11       	cpse	r24, r1
    1c92:	07 c0       	rjmp	.+14     	; 0x1ca2 <prvResetNextTaskUnblockTime+0x1c>
    1c94:	8f ef       	ldi	r24, 0xFF	; 255
    1c96:	9f ef       	ldi	r25, 0xFF	; 255
    1c98:	90 93 06 02 	sts	0x0206, r25
    1c9c:	80 93 05 02 	sts	0x0205, r24
    1ca0:	08 95       	ret
    1ca2:	e0 91 50 08 	lds	r30, 0x0850
    1ca6:	f0 91 51 08 	lds	r31, 0x0851
    1caa:	05 80       	ldd	r0, Z+5	; 0x05
    1cac:	f6 81       	ldd	r31, Z+6	; 0x06
    1cae:	e0 2d       	mov	r30, r0
    1cb0:	06 80       	ldd	r0, Z+6	; 0x06
    1cb2:	f7 81       	ldd	r31, Z+7	; 0x07
    1cb4:	e0 2d       	mov	r30, r0
    1cb6:	82 81       	ldd	r24, Z+2	; 0x02
    1cb8:	93 81       	ldd	r25, Z+3	; 0x03
    1cba:	90 93 06 02 	sts	0x0206, r25
    1cbe:	80 93 05 02 	sts	0x0205, r24
    1cc2:	08 95       	ret

00001cc4 <prvAddCurrentTaskToDelayedList>:
    1cc4:	cf 93       	push	r28
    1cc6:	df 93       	push	r29
    1cc8:	ec 01       	movw	r28, r24
    1cca:	e0 91 91 08 	lds	r30, 0x0891
    1cce:	f0 91 92 08 	lds	r31, 0x0892
    1cd2:	93 83       	std	Z+3, r25	; 0x03
    1cd4:	82 83       	std	Z+2, r24	; 0x02
    1cd6:	80 91 2f 08 	lds	r24, 0x082F
    1cda:	90 91 30 08 	lds	r25, 0x0830
    1cde:	c8 17       	cp	r28, r24
    1ce0:	d9 07       	cpc	r29, r25
    1ce2:	68 f4       	brcc	.+26     	; 0x1cfe <prvAddCurrentTaskToDelayedList+0x3a>
    1ce4:	60 91 91 08 	lds	r22, 0x0891
    1ce8:	70 91 92 08 	lds	r23, 0x0892
    1cec:	80 91 4e 08 	lds	r24, 0x084E
    1cf0:	90 91 4f 08 	lds	r25, 0x084F
    1cf4:	6e 5f       	subi	r22, 0xFE	; 254
    1cf6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf8:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    1cfc:	17 c0       	rjmp	.+46     	; 0x1d2c <prvAddCurrentTaskToDelayedList+0x68>
    1cfe:	60 91 91 08 	lds	r22, 0x0891
    1d02:	70 91 92 08 	lds	r23, 0x0892
    1d06:	80 91 50 08 	lds	r24, 0x0850
    1d0a:	90 91 51 08 	lds	r25, 0x0851
    1d0e:	6e 5f       	subi	r22, 0xFE	; 254
    1d10:	7f 4f       	sbci	r23, 0xFF	; 255
    1d12:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    1d16:	80 91 05 02 	lds	r24, 0x0205
    1d1a:	90 91 06 02 	lds	r25, 0x0206
    1d1e:	c8 17       	cp	r28, r24
    1d20:	d9 07       	cpc	r29, r25
    1d22:	20 f4       	brcc	.+8      	; 0x1d2c <prvAddCurrentTaskToDelayedList+0x68>
    1d24:	d0 93 06 02 	sts	0x0206, r29
    1d28:	c0 93 05 02 	sts	0x0205, r28
    1d2c:	df 91       	pop	r29
    1d2e:	cf 91       	pop	r28
    1d30:	08 95       	ret

00001d32 <xTaskGenericCreate>:
    1d32:	4f 92       	push	r4
    1d34:	5f 92       	push	r5
    1d36:	6f 92       	push	r6
    1d38:	7f 92       	push	r7
    1d3a:	8f 92       	push	r8
    1d3c:	9f 92       	push	r9
    1d3e:	af 92       	push	r10
    1d40:	bf 92       	push	r11
    1d42:	cf 92       	push	r12
    1d44:	df 92       	push	r13
    1d46:	ef 92       	push	r14
    1d48:	ff 92       	push	r15
    1d4a:	0f 93       	push	r16
    1d4c:	1f 93       	push	r17
    1d4e:	cf 93       	push	r28
    1d50:	df 93       	push	r29
    1d52:	4c 01       	movw	r8, r24
    1d54:	5b 01       	movw	r10, r22
    1d56:	2a 01       	movw	r4, r20
    1d58:	39 01       	movw	r6, r18
    1d5a:	83 e2       	ldi	r24, 0x23	; 35
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1d62:	ec 01       	movw	r28, r24
    1d64:	00 97       	sbiw	r24, 0x00	; 0
    1d66:	09 f4       	brne	.+2      	; 0x1d6a <xTaskGenericCreate+0x38>
    1d68:	e7 c0       	rjmp	.+462    	; 0x1f38 <xTaskGenericCreate+0x206>
    1d6a:	c1 14       	cp	r12, r1
    1d6c:	d1 04       	cpc	r13, r1
    1d6e:	09 f0       	breq	.+2      	; 0x1d72 <xTaskGenericCreate+0x40>
    1d70:	cc c0       	rjmp	.+408    	; 0x1f0a <xTaskGenericCreate+0x1d8>
    1d72:	c2 01       	movw	r24, r4
    1d74:	0e 94 16 03 	call	0x62c	; 0x62c <pvPortMalloc>
    1d78:	98 8f       	std	Y+24, r25	; 0x18
    1d7a:	8f 8b       	std	Y+23, r24	; 0x17
    1d7c:	89 2b       	or	r24, r25
    1d7e:	09 f0       	breq	.+2      	; 0x1d82 <xTaskGenericCreate+0x50>
    1d80:	c6 c0       	rjmp	.+396    	; 0x1f0e <xTaskGenericCreate+0x1dc>
    1d82:	ce 01       	movw	r24, r28
    1d84:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    1d88:	d7 c0       	rjmp	.+430    	; 0x1f38 <xTaskGenericCreate+0x206>
    1d8a:	cf 01       	movw	r24, r30
    1d8c:	31 91       	ld	r19, Z+
    1d8e:	da 01       	movw	r26, r20
    1d90:	3d 93       	st	X+, r19
    1d92:	ad 01       	movw	r20, r26
    1d94:	dc 01       	movw	r26, r24
    1d96:	8c 91       	ld	r24, X
    1d98:	88 23       	and	r24, r24
    1d9a:	11 f0       	breq	.+4      	; 0x1da0 <xTaskGenericCreate+0x6e>
    1d9c:	21 50       	subi	r18, 0x01	; 1
    1d9e:	a9 f7       	brne	.-22     	; 0x1d8a <xTaskGenericCreate+0x58>
    1da0:	18 a2       	std	Y+32, r1	; 0x20
    1da2:	10 2f       	mov	r17, r16
    1da4:	05 30       	cpi	r16, 0x05	; 5
    1da6:	08 f0       	brcs	.+2      	; 0x1daa <xTaskGenericCreate+0x78>
    1da8:	14 e0       	ldi	r17, 0x04	; 4
    1daa:	1e 8b       	std	Y+22, r17	; 0x16
    1dac:	19 a3       	std	Y+33, r17	; 0x21
    1dae:	1a a2       	std	Y+34, r1	; 0x22
    1db0:	5e 01       	movw	r10, r28
    1db2:	b2 e0       	ldi	r27, 0x02	; 2
    1db4:	ab 0e       	add	r10, r27
    1db6:	b1 1c       	adc	r11, r1
    1db8:	c5 01       	movw	r24, r10
    1dba:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	0c 96       	adiw	r24, 0x0c	; 12
    1dc2:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialiseItem>
    1dc6:	d9 87       	std	Y+9, r29	; 0x09
    1dc8:	c8 87       	std	Y+8, r28	; 0x08
    1dca:	85 e0       	ldi	r24, 0x05	; 5
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	81 1b       	sub	r24, r17
    1dd0:	91 09       	sbc	r25, r1
    1dd2:	9d 87       	std	Y+13, r25	; 0x0d
    1dd4:	8c 87       	std	Y+12, r24	; 0x0c
    1dd6:	db 8b       	std	Y+19, r29	; 0x13
    1dd8:	ca 8b       	std	Y+18, r28	; 0x12
    1dda:	a3 01       	movw	r20, r6
    1ddc:	b4 01       	movw	r22, r8
    1dde:	c6 01       	movw	r24, r12
    1de0:	cb da       	rcall	.-2666   	; 0x1378 <pxPortInitialiseStack>
    1de2:	99 83       	std	Y+1, r25	; 0x01
    1de4:	88 83       	st	Y, r24
    1de6:	e1 14       	cp	r14, r1
    1de8:	f1 04       	cpc	r15, r1
    1dea:	19 f0       	breq	.+6      	; 0x1df2 <xTaskGenericCreate+0xc0>
    1dec:	f7 01       	movw	r30, r14
    1dee:	d1 83       	std	Z+1, r29	; 0x01
    1df0:	c0 83       	st	Z, r28
    1df2:	0f b6       	in	r0, 0x3f	; 63
    1df4:	f8 94       	cli
    1df6:	0f 92       	push	r0
    1df8:	80 91 31 08 	lds	r24, 0x0831
    1dfc:	8f 5f       	subi	r24, 0xFF	; 255
    1dfe:	80 93 31 08 	sts	0x0831, r24
    1e02:	80 91 91 08 	lds	r24, 0x0891
    1e06:	90 91 92 08 	lds	r25, 0x0892
    1e0a:	89 2b       	or	r24, r25
    1e0c:	09 f0       	breq	.+2      	; 0x1e10 <xTaskGenericCreate+0xde>
    1e0e:	3f c0       	rjmp	.+126    	; 0x1e8e <xTaskGenericCreate+0x15c>
    1e10:	d0 93 92 08 	sts	0x0892, r29
    1e14:	c0 93 91 08 	sts	0x0891, r28
    1e18:	80 91 31 08 	lds	r24, 0x0831
    1e1c:	81 30       	cpi	r24, 0x01	; 1
    1e1e:	09 f0       	breq	.+2      	; 0x1e22 <xTaskGenericCreate+0xf0>
    1e20:	45 c0       	rjmp	.+138    	; 0x1eac <xTaskGenericCreate+0x17a>
    1e22:	0f 2e       	mov	r0, r31
    1e24:	f4 e6       	ldi	r31, 0x64	; 100
    1e26:	ef 2e       	mov	r14, r31
    1e28:	f8 e0       	ldi	r31, 0x08	; 8
    1e2a:	ff 2e       	mov	r15, r31
    1e2c:	f0 2d       	mov	r31, r0
    1e2e:	0f 2e       	mov	r0, r31
    1e30:	f1 e9       	ldi	r31, 0x91	; 145
    1e32:	cf 2e       	mov	r12, r31
    1e34:	f8 e0       	ldi	r31, 0x08	; 8
    1e36:	df 2e       	mov	r13, r31
    1e38:	f0 2d       	mov	r31, r0
    1e3a:	c7 01       	movw	r24, r14
    1e3c:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e40:	f9 e0       	ldi	r31, 0x09	; 9
    1e42:	ef 0e       	add	r14, r31
    1e44:	f1 1c       	adc	r15, r1
    1e46:	ec 14       	cp	r14, r12
    1e48:	fd 04       	cpc	r15, r13
    1e4a:	b9 f7       	brne	.-18     	; 0x1e3a <xTaskGenericCreate+0x108>
    1e4c:	8b e5       	ldi	r24, 0x5B	; 91
    1e4e:	98 e0       	ldi	r25, 0x08	; 8
    1e50:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e54:	82 e5       	ldi	r24, 0x52	; 82
    1e56:	98 e0       	ldi	r25, 0x08	; 8
    1e58:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e5c:	85 e4       	ldi	r24, 0x45	; 69
    1e5e:	98 e0       	ldi	r25, 0x08	; 8
    1e60:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e64:	8c e3       	ldi	r24, 0x3C	; 60
    1e66:	98 e0       	ldi	r25, 0x08	; 8
    1e68:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e6c:	82 e3       	ldi	r24, 0x32	; 50
    1e6e:	98 e0       	ldi	r25, 0x08	; 8
    1e70:	0e 94 4c 03 	call	0x698	; 0x698 <vListInitialise>
    1e74:	8b e5       	ldi	r24, 0x5B	; 91
    1e76:	98 e0       	ldi	r25, 0x08	; 8
    1e78:	90 93 51 08 	sts	0x0851, r25
    1e7c:	80 93 50 08 	sts	0x0850, r24
    1e80:	82 e5       	ldi	r24, 0x52	; 82
    1e82:	98 e0       	ldi	r25, 0x08	; 8
    1e84:	90 93 4f 08 	sts	0x084F, r25
    1e88:	80 93 4e 08 	sts	0x084E, r24
    1e8c:	0f c0       	rjmp	.+30     	; 0x1eac <xTaskGenericCreate+0x17a>
    1e8e:	80 91 2d 08 	lds	r24, 0x082D
    1e92:	81 11       	cpse	r24, r1
    1e94:	0b c0       	rjmp	.+22     	; 0x1eac <xTaskGenericCreate+0x17a>
    1e96:	e0 91 91 08 	lds	r30, 0x0891
    1e9a:	f0 91 92 08 	lds	r31, 0x0892
    1e9e:	86 89       	ldd	r24, Z+22	; 0x16
    1ea0:	08 17       	cp	r16, r24
    1ea2:	20 f0       	brcs	.+8      	; 0x1eac <xTaskGenericCreate+0x17a>
    1ea4:	d0 93 92 08 	sts	0x0892, r29
    1ea8:	c0 93 91 08 	sts	0x0891, r28
    1eac:	80 91 29 08 	lds	r24, 0x0829
    1eb0:	8f 5f       	subi	r24, 0xFF	; 255
    1eb2:	80 93 29 08 	sts	0x0829, r24
    1eb6:	8e 89       	ldd	r24, Y+22	; 0x16
    1eb8:	90 91 2e 08 	lds	r25, 0x082E
    1ebc:	98 17       	cp	r25, r24
    1ebe:	10 f4       	brcc	.+4      	; 0x1ec4 <xTaskGenericCreate+0x192>
    1ec0:	80 93 2e 08 	sts	0x082E, r24
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	9c 01       	movw	r18, r24
    1ec8:	22 0f       	add	r18, r18
    1eca:	33 1f       	adc	r19, r19
    1ecc:	22 0f       	add	r18, r18
    1ece:	33 1f       	adc	r19, r19
    1ed0:	22 0f       	add	r18, r18
    1ed2:	33 1f       	adc	r19, r19
    1ed4:	82 0f       	add	r24, r18
    1ed6:	93 1f       	adc	r25, r19
    1ed8:	b5 01       	movw	r22, r10
    1eda:	8c 59       	subi	r24, 0x9C	; 156
    1edc:	97 4f       	sbci	r25, 0xF7	; 247
    1ede:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1ee2:	0f 90       	pop	r0
    1ee4:	0f be       	out	0x3f, r0	; 63
    1ee6:	80 91 2d 08 	lds	r24, 0x082D
    1eea:	88 23       	and	r24, r24
    1eec:	51 f0       	breq	.+20     	; 0x1f02 <xTaskGenericCreate+0x1d0>
    1eee:	e0 91 91 08 	lds	r30, 0x0891
    1ef2:	f0 91 92 08 	lds	r31, 0x0892
    1ef6:	86 89       	ldd	r24, Z+22	; 0x16
    1ef8:	80 17       	cp	r24, r16
    1efa:	28 f4       	brcc	.+10     	; 0x1f06 <xTaskGenericCreate+0x1d4>
    1efc:	ec da       	rcall	.-2600   	; 0x14d6 <vPortYield>
    1efe:	81 e0       	ldi	r24, 0x01	; 1
    1f00:	1c c0       	rjmp	.+56     	; 0x1f3a <xTaskGenericCreate+0x208>
    1f02:	81 e0       	ldi	r24, 0x01	; 1
    1f04:	1a c0       	rjmp	.+52     	; 0x1f3a <xTaskGenericCreate+0x208>
    1f06:	81 e0       	ldi	r24, 0x01	; 1
    1f08:	18 c0       	rjmp	.+48     	; 0x1f3a <xTaskGenericCreate+0x208>
    1f0a:	d8 8e       	std	Y+24, r13	; 0x18
    1f0c:	cf 8a       	std	Y+23, r12	; 0x17
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	48 1a       	sub	r4, r24
    1f12:	51 08       	sbc	r5, r1
    1f14:	cf 88       	ldd	r12, Y+23	; 0x17
    1f16:	d8 8c       	ldd	r13, Y+24	; 0x18
    1f18:	c4 0c       	add	r12, r4
    1f1a:	d5 1c       	adc	r13, r5
    1f1c:	d5 01       	movw	r26, r10
    1f1e:	8c 91       	ld	r24, X
    1f20:	89 8f       	std	Y+25, r24	; 0x19
    1f22:	8c 91       	ld	r24, X
    1f24:	88 23       	and	r24, r24
    1f26:	09 f4       	brne	.+2      	; 0x1f2a <xTaskGenericCreate+0x1f8>
    1f28:	3b cf       	rjmp	.-394    	; 0x1da0 <xTaskGenericCreate+0x6e>
    1f2a:	ae 01       	movw	r20, r28
    1f2c:	46 5e       	subi	r20, 0xE6	; 230
    1f2e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f30:	f5 01       	movw	r30, r10
    1f32:	31 96       	adiw	r30, 0x01	; 1
    1f34:	27 e0       	ldi	r18, 0x07	; 7
    1f36:	29 cf       	rjmp	.-430    	; 0x1d8a <xTaskGenericCreate+0x58>
    1f38:	8f ef       	ldi	r24, 0xFF	; 255
    1f3a:	df 91       	pop	r29
    1f3c:	cf 91       	pop	r28
    1f3e:	1f 91       	pop	r17
    1f40:	0f 91       	pop	r16
    1f42:	ff 90       	pop	r15
    1f44:	ef 90       	pop	r14
    1f46:	df 90       	pop	r13
    1f48:	cf 90       	pop	r12
    1f4a:	bf 90       	pop	r11
    1f4c:	af 90       	pop	r10
    1f4e:	9f 90       	pop	r9
    1f50:	8f 90       	pop	r8
    1f52:	7f 90       	pop	r7
    1f54:	6f 90       	pop	r6
    1f56:	5f 90       	pop	r5
    1f58:	4f 90       	pop	r4
    1f5a:	08 95       	ret

00001f5c <vTaskResume>:
    1f5c:	0f 93       	push	r16
    1f5e:	1f 93       	push	r17
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
    1f64:	ec 01       	movw	r28, r24
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	09 f4       	brne	.+2      	; 0x1f6c <vTaskResume+0x10>
    1f6a:	3e c0       	rjmp	.+124    	; 0x1fe8 <vTaskResume+0x8c>
    1f6c:	80 91 91 08 	lds	r24, 0x0891
    1f70:	90 91 92 08 	lds	r25, 0x0892
    1f74:	c8 17       	cp	r28, r24
    1f76:	d9 07       	cpc	r29, r25
    1f78:	b9 f1       	breq	.+110    	; 0x1fe8 <vTaskResume+0x8c>
    1f7a:	0f b6       	in	r0, 0x3f	; 63
    1f7c:	f8 94       	cli
    1f7e:	0f 92       	push	r0
    1f80:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f82:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f84:	82 53       	subi	r24, 0x32	; 50
    1f86:	98 40       	sbci	r25, 0x08	; 8
    1f88:	69 f5       	brne	.+90     	; 0x1fe4 <vTaskResume+0x88>
    1f8a:	8c 89       	ldd	r24, Y+20	; 0x14
    1f8c:	9d 89       	ldd	r25, Y+21	; 0x15
    1f8e:	28 e0       	ldi	r18, 0x08	; 8
    1f90:	85 34       	cpi	r24, 0x45	; 69
    1f92:	92 07       	cpc	r25, r18
    1f94:	39 f1       	breq	.+78     	; 0x1fe4 <vTaskResume+0x88>
    1f96:	89 2b       	or	r24, r25
    1f98:	29 f5       	brne	.+74     	; 0x1fe4 <vTaskResume+0x88>
    1f9a:	8e 01       	movw	r16, r28
    1f9c:	0e 5f       	subi	r16, 0xFE	; 254
    1f9e:	1f 4f       	sbci	r17, 0xFF	; 255
    1fa0:	c8 01       	movw	r24, r16
    1fa2:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    1fa6:	8e 89       	ldd	r24, Y+22	; 0x16
    1fa8:	90 91 2e 08 	lds	r25, 0x082E
    1fac:	98 17       	cp	r25, r24
    1fae:	10 f4       	brcc	.+4      	; 0x1fb4 <vTaskResume+0x58>
    1fb0:	80 93 2e 08 	sts	0x082E, r24
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	9c 01       	movw	r18, r24
    1fb8:	22 0f       	add	r18, r18
    1fba:	33 1f       	adc	r19, r19
    1fbc:	22 0f       	add	r18, r18
    1fbe:	33 1f       	adc	r19, r19
    1fc0:	22 0f       	add	r18, r18
    1fc2:	33 1f       	adc	r19, r19
    1fc4:	82 0f       	add	r24, r18
    1fc6:	93 1f       	adc	r25, r19
    1fc8:	b8 01       	movw	r22, r16
    1fca:	8c 59       	subi	r24, 0x9C	; 156
    1fcc:	97 4f       	sbci	r25, 0xF7	; 247
    1fce:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    1fd2:	e0 91 91 08 	lds	r30, 0x0891
    1fd6:	f0 91 92 08 	lds	r31, 0x0892
    1fda:	9e 89       	ldd	r25, Y+22	; 0x16
    1fdc:	86 89       	ldd	r24, Z+22	; 0x16
    1fde:	98 17       	cp	r25, r24
    1fe0:	08 f0       	brcs	.+2      	; 0x1fe4 <vTaskResume+0x88>
    1fe2:	79 da       	rcall	.-2830   	; 0x14d6 <vPortYield>
    1fe4:	0f 90       	pop	r0
    1fe6:	0f be       	out	0x3f, r0	; 63
    1fe8:	df 91       	pop	r29
    1fea:	cf 91       	pop	r28
    1fec:	1f 91       	pop	r17
    1fee:	0f 91       	pop	r16
    1ff0:	08 95       	ret

00001ff2 <vTaskStartScheduler>:
    1ff2:	af 92       	push	r10
    1ff4:	bf 92       	push	r11
    1ff6:	cf 92       	push	r12
    1ff8:	df 92       	push	r13
    1ffa:	ef 92       	push	r14
    1ffc:	ff 92       	push	r15
    1ffe:	0f 93       	push	r16
    2000:	a1 2c       	mov	r10, r1
    2002:	b1 2c       	mov	r11, r1
    2004:	c1 2c       	mov	r12, r1
    2006:	d1 2c       	mov	r13, r1
    2008:	e1 2c       	mov	r14, r1
    200a:	f1 2c       	mov	r15, r1
    200c:	00 e0       	ldi	r16, 0x00	; 0
    200e:	20 e0       	ldi	r18, 0x00	; 0
    2010:	30 e0       	ldi	r19, 0x00	; 0
    2012:	45 e5       	ldi	r20, 0x55	; 85
    2014:	50 e0       	ldi	r21, 0x00	; 0
    2016:	63 e3       	ldi	r22, 0x33	; 51
    2018:	72 e0       	ldi	r23, 0x02	; 2
    201a:	84 eb       	ldi	r24, 0xB4	; 180
    201c:	91 e1       	ldi	r25, 0x11	; 17
    201e:	89 de       	rcall	.-750    	; 0x1d32 <xTaskGenericCreate>
    2020:	81 30       	cpi	r24, 0x01	; 1
    2022:	41 f4       	brne	.+16     	; 0x2034 <vTaskStartScheduler+0x42>
    2024:	f8 94       	cli
    2026:	80 93 2d 08 	sts	0x082D, r24
    202a:	10 92 30 08 	sts	0x0830, r1
    202e:	10 92 2f 08 	sts	0x082F, r1
    2032:	14 da       	rcall	.-3032   	; 0x145c <xPortStartScheduler>
    2034:	0f 91       	pop	r16
    2036:	ff 90       	pop	r15
    2038:	ef 90       	pop	r14
    203a:	df 90       	pop	r13
    203c:	cf 90       	pop	r12
    203e:	bf 90       	pop	r11
    2040:	af 90       	pop	r10
    2042:	08 95       	ret

00002044 <vTaskSuspendAll>:
    2044:	80 91 28 08 	lds	r24, 0x0828
    2048:	8f 5f       	subi	r24, 0xFF	; 255
    204a:	80 93 28 08 	sts	0x0828, r24
    204e:	08 95       	ret

00002050 <xTaskGetTickCount>:
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	0f 92       	push	r0
    2056:	80 91 2f 08 	lds	r24, 0x082F
    205a:	90 91 30 08 	lds	r25, 0x0830
    205e:	0f 90       	pop	r0
    2060:	0f be       	out	0x3f, r0	; 63
    2062:	08 95       	ret

00002064 <xTaskGetTickCountFromISR>:
    2064:	80 91 2f 08 	lds	r24, 0x082F
    2068:	90 91 30 08 	lds	r25, 0x0830
    206c:	08 95       	ret

0000206e <xTaskIncrementTick>:
    206e:	cf 92       	push	r12
    2070:	df 92       	push	r13
    2072:	ef 92       	push	r14
    2074:	ff 92       	push	r15
    2076:	0f 93       	push	r16
    2078:	1f 93       	push	r17
    207a:	cf 93       	push	r28
    207c:	df 93       	push	r29
    207e:	80 91 28 08 	lds	r24, 0x0828
    2082:	81 11       	cpse	r24, r1
    2084:	99 c0       	rjmp	.+306    	; 0x21b8 <xTaskIncrementTick+0x14a>
    2086:	80 91 2f 08 	lds	r24, 0x082F
    208a:	90 91 30 08 	lds	r25, 0x0830
    208e:	01 96       	adiw	r24, 0x01	; 1
    2090:	90 93 30 08 	sts	0x0830, r25
    2094:	80 93 2f 08 	sts	0x082F, r24
    2098:	e0 90 2f 08 	lds	r14, 0x082F
    209c:	f0 90 30 08 	lds	r15, 0x0830
    20a0:	e1 14       	cp	r14, r1
    20a2:	f1 04       	cpc	r15, r1
    20a4:	b1 f4       	brne	.+44     	; 0x20d2 <xTaskIncrementTick+0x64>
    20a6:	80 91 50 08 	lds	r24, 0x0850
    20aa:	90 91 51 08 	lds	r25, 0x0851
    20ae:	20 91 4e 08 	lds	r18, 0x084E
    20b2:	30 91 4f 08 	lds	r19, 0x084F
    20b6:	30 93 51 08 	sts	0x0851, r19
    20ba:	20 93 50 08 	sts	0x0850, r18
    20be:	90 93 4f 08 	sts	0x084F, r25
    20c2:	80 93 4e 08 	sts	0x084E, r24
    20c6:	80 91 2a 08 	lds	r24, 0x082A
    20ca:	8f 5f       	subi	r24, 0xFF	; 255
    20cc:	80 93 2a 08 	sts	0x082A, r24
    20d0:	da dd       	rcall	.-1100   	; 0x1c86 <prvResetNextTaskUnblockTime>
    20d2:	80 91 05 02 	lds	r24, 0x0205
    20d6:	90 91 06 02 	lds	r25, 0x0206
    20da:	e8 16       	cp	r14, r24
    20dc:	f9 06       	cpc	r15, r25
    20de:	08 f4       	brcc	.+2      	; 0x20e2 <xTaskIncrementTick+0x74>
    20e0:	54 c0       	rjmp	.+168    	; 0x218a <xTaskIncrementTick+0x11c>
    20e2:	d1 2c       	mov	r13, r1
    20e4:	cc 24       	eor	r12, r12
    20e6:	c3 94       	inc	r12
    20e8:	01 c0       	rjmp	.+2      	; 0x20ec <xTaskIncrementTick+0x7e>
    20ea:	dc 2c       	mov	r13, r12
    20ec:	e0 91 50 08 	lds	r30, 0x0850
    20f0:	f0 91 51 08 	lds	r31, 0x0851
    20f4:	80 81       	ld	r24, Z
    20f6:	81 11       	cpse	r24, r1
    20f8:	07 c0       	rjmp	.+14     	; 0x2108 <xTaskIncrementTick+0x9a>
    20fa:	8f ef       	ldi	r24, 0xFF	; 255
    20fc:	9f ef       	ldi	r25, 0xFF	; 255
    20fe:	90 93 06 02 	sts	0x0206, r25
    2102:	80 93 05 02 	sts	0x0205, r24
    2106:	42 c0       	rjmp	.+132    	; 0x218c <xTaskIncrementTick+0x11e>
    2108:	e0 91 50 08 	lds	r30, 0x0850
    210c:	f0 91 51 08 	lds	r31, 0x0851
    2110:	05 80       	ldd	r0, Z+5	; 0x05
    2112:	f6 81       	ldd	r31, Z+6	; 0x06
    2114:	e0 2d       	mov	r30, r0
    2116:	c6 81       	ldd	r28, Z+6	; 0x06
    2118:	d7 81       	ldd	r29, Z+7	; 0x07
    211a:	2a 81       	ldd	r18, Y+2	; 0x02
    211c:	3b 81       	ldd	r19, Y+3	; 0x03
    211e:	e2 16       	cp	r14, r18
    2120:	f3 06       	cpc	r15, r19
    2122:	28 f4       	brcc	.+10     	; 0x212e <xTaskIncrementTick+0xc0>
    2124:	30 93 06 02 	sts	0x0206, r19
    2128:	20 93 05 02 	sts	0x0205, r18
    212c:	2f c0       	rjmp	.+94     	; 0x218c <xTaskIncrementTick+0x11e>
    212e:	8e 01       	movw	r16, r28
    2130:	0e 5f       	subi	r16, 0xFE	; 254
    2132:	1f 4f       	sbci	r17, 0xFF	; 255
    2134:	c8 01       	movw	r24, r16
    2136:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    213a:	8c 89       	ldd	r24, Y+20	; 0x14
    213c:	9d 89       	ldd	r25, Y+21	; 0x15
    213e:	89 2b       	or	r24, r25
    2140:	21 f0       	breq	.+8      	; 0x214a <xTaskIncrementTick+0xdc>
    2142:	ce 01       	movw	r24, r28
    2144:	0c 96       	adiw	r24, 0x0c	; 12
    2146:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    214a:	2e 89       	ldd	r18, Y+22	; 0x16
    214c:	80 91 2e 08 	lds	r24, 0x082E
    2150:	82 17       	cp	r24, r18
    2152:	10 f4       	brcc	.+4      	; 0x2158 <xTaskIncrementTick+0xea>
    2154:	20 93 2e 08 	sts	0x082E, r18
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	c9 01       	movw	r24, r18
    215c:	88 0f       	add	r24, r24
    215e:	99 1f       	adc	r25, r25
    2160:	88 0f       	add	r24, r24
    2162:	99 1f       	adc	r25, r25
    2164:	88 0f       	add	r24, r24
    2166:	99 1f       	adc	r25, r25
    2168:	82 0f       	add	r24, r18
    216a:	93 1f       	adc	r25, r19
    216c:	b8 01       	movw	r22, r16
    216e:	8c 59       	subi	r24, 0x9C	; 156
    2170:	97 4f       	sbci	r25, 0xF7	; 247
    2172:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2176:	e0 91 91 08 	lds	r30, 0x0891
    217a:	f0 91 92 08 	lds	r31, 0x0892
    217e:	9e 89       	ldd	r25, Y+22	; 0x16
    2180:	86 89       	ldd	r24, Z+22	; 0x16
    2182:	98 17       	cp	r25, r24
    2184:	08 f0       	brcs	.+2      	; 0x2188 <xTaskIncrementTick+0x11a>
    2186:	b1 cf       	rjmp	.-158    	; 0x20ea <xTaskIncrementTick+0x7c>
    2188:	b1 cf       	rjmp	.-158    	; 0x20ec <xTaskIncrementTick+0x7e>
    218a:	d1 2c       	mov	r13, r1
    218c:	e0 91 91 08 	lds	r30, 0x0891
    2190:	f0 91 92 08 	lds	r31, 0x0892
    2194:	86 89       	ldd	r24, Z+22	; 0x16
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	fc 01       	movw	r30, r24
    219a:	ee 0f       	add	r30, r30
    219c:	ff 1f       	adc	r31, r31
    219e:	ee 0f       	add	r30, r30
    21a0:	ff 1f       	adc	r31, r31
    21a2:	ee 0f       	add	r30, r30
    21a4:	ff 1f       	adc	r31, r31
    21a6:	8e 0f       	add	r24, r30
    21a8:	9f 1f       	adc	r25, r31
    21aa:	fc 01       	movw	r30, r24
    21ac:	ec 59       	subi	r30, 0x9C	; 156
    21ae:	f7 4f       	sbci	r31, 0xF7	; 247
    21b0:	80 81       	ld	r24, Z
    21b2:	82 30       	cpi	r24, 0x02	; 2
    21b4:	40 f4       	brcc	.+16     	; 0x21c6 <xTaskIncrementTick+0x158>
    21b6:	09 c0       	rjmp	.+18     	; 0x21ca <xTaskIncrementTick+0x15c>
    21b8:	80 91 2c 08 	lds	r24, 0x082C
    21bc:	8f 5f       	subi	r24, 0xFF	; 255
    21be:	80 93 2c 08 	sts	0x082C, r24
    21c2:	d1 2c       	mov	r13, r1
    21c4:	02 c0       	rjmp	.+4      	; 0x21ca <xTaskIncrementTick+0x15c>
    21c6:	dd 24       	eor	r13, r13
    21c8:	d3 94       	inc	r13
    21ca:	80 91 2b 08 	lds	r24, 0x082B
    21ce:	88 23       	and	r24, r24
    21d0:	11 f0       	breq	.+4      	; 0x21d6 <xTaskIncrementTick+0x168>
    21d2:	dd 24       	eor	r13, r13
    21d4:	d3 94       	inc	r13
    21d6:	8d 2d       	mov	r24, r13
    21d8:	df 91       	pop	r29
    21da:	cf 91       	pop	r28
    21dc:	1f 91       	pop	r17
    21de:	0f 91       	pop	r16
    21e0:	ff 90       	pop	r15
    21e2:	ef 90       	pop	r14
    21e4:	df 90       	pop	r13
    21e6:	cf 90       	pop	r12
    21e8:	08 95       	ret

000021ea <xTaskResumeAll>:
    21ea:	df 92       	push	r13
    21ec:	ef 92       	push	r14
    21ee:	ff 92       	push	r15
    21f0:	0f 93       	push	r16
    21f2:	1f 93       	push	r17
    21f4:	cf 93       	push	r28
    21f6:	df 93       	push	r29
    21f8:	0f b6       	in	r0, 0x3f	; 63
    21fa:	f8 94       	cli
    21fc:	0f 92       	push	r0
    21fe:	80 91 28 08 	lds	r24, 0x0828
    2202:	81 50       	subi	r24, 0x01	; 1
    2204:	80 93 28 08 	sts	0x0828, r24
    2208:	80 91 28 08 	lds	r24, 0x0828
    220c:	81 11       	cpse	r24, r1
    220e:	5f c0       	rjmp	.+190    	; 0x22ce <__stack+0xcf>
    2210:	80 91 31 08 	lds	r24, 0x0831
    2214:	88 23       	and	r24, r24
    2216:	09 f4       	brne	.+2      	; 0x221a <__stack+0x1b>
    2218:	5c c0       	rjmp	.+184    	; 0x22d2 <__stack+0xd3>
    221a:	0f 2e       	mov	r0, r31
    221c:	f5 e4       	ldi	r31, 0x45	; 69
    221e:	ef 2e       	mov	r14, r31
    2220:	f8 e0       	ldi	r31, 0x08	; 8
    2222:	ff 2e       	mov	r15, r31
    2224:	f0 2d       	mov	r31, r0
    2226:	dd 24       	eor	r13, r13
    2228:	d3 94       	inc	r13
    222a:	30 c0       	rjmp	.+96     	; 0x228c <__stack+0x8d>
    222c:	e0 91 4a 08 	lds	r30, 0x084A
    2230:	f0 91 4b 08 	lds	r31, 0x084B
    2234:	c6 81       	ldd	r28, Z+6	; 0x06
    2236:	d7 81       	ldd	r29, Z+7	; 0x07
    2238:	ce 01       	movw	r24, r28
    223a:	0c 96       	adiw	r24, 0x0c	; 12
    223c:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2240:	8e 01       	movw	r16, r28
    2242:	0e 5f       	subi	r16, 0xFE	; 254
    2244:	1f 4f       	sbci	r17, 0xFF	; 255
    2246:	c8 01       	movw	r24, r16
    2248:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    224c:	8e 89       	ldd	r24, Y+22	; 0x16
    224e:	90 91 2e 08 	lds	r25, 0x082E
    2252:	98 17       	cp	r25, r24
    2254:	10 f4       	brcc	.+4      	; 0x225a <__stack+0x5b>
    2256:	80 93 2e 08 	sts	0x082E, r24
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	9c 01       	movw	r18, r24
    225e:	22 0f       	add	r18, r18
    2260:	33 1f       	adc	r19, r19
    2262:	22 0f       	add	r18, r18
    2264:	33 1f       	adc	r19, r19
    2266:	22 0f       	add	r18, r18
    2268:	33 1f       	adc	r19, r19
    226a:	82 0f       	add	r24, r18
    226c:	93 1f       	adc	r25, r19
    226e:	b8 01       	movw	r22, r16
    2270:	8c 59       	subi	r24, 0x9C	; 156
    2272:	97 4f       	sbci	r25, 0xF7	; 247
    2274:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2278:	e0 91 91 08 	lds	r30, 0x0891
    227c:	f0 91 92 08 	lds	r31, 0x0892
    2280:	9e 89       	ldd	r25, Y+22	; 0x16
    2282:	86 89       	ldd	r24, Z+22	; 0x16
    2284:	98 17       	cp	r25, r24
    2286:	10 f0       	brcs	.+4      	; 0x228c <__stack+0x8d>
    2288:	d0 92 2b 08 	sts	0x082B, r13
    228c:	f7 01       	movw	r30, r14
    228e:	80 81       	ld	r24, Z
    2290:	81 11       	cpse	r24, r1
    2292:	cc cf       	rjmp	.-104    	; 0x222c <__stack+0x2d>
    2294:	80 91 2c 08 	lds	r24, 0x082C
    2298:	88 23       	and	r24, r24
    229a:	91 f0       	breq	.+36     	; 0x22c0 <__stack+0xc1>
    229c:	80 91 2c 08 	lds	r24, 0x082C
    22a0:	88 23       	and	r24, r24
    22a2:	71 f0       	breq	.+28     	; 0x22c0 <__stack+0xc1>
    22a4:	c1 e0       	ldi	r28, 0x01	; 1
    22a6:	e3 de       	rcall	.-570    	; 0x206e <xTaskIncrementTick>
    22a8:	81 11       	cpse	r24, r1
    22aa:	c0 93 2b 08 	sts	0x082B, r28
    22ae:	80 91 2c 08 	lds	r24, 0x082C
    22b2:	81 50       	subi	r24, 0x01	; 1
    22b4:	80 93 2c 08 	sts	0x082C, r24
    22b8:	80 91 2c 08 	lds	r24, 0x082C
    22bc:	81 11       	cpse	r24, r1
    22be:	f3 cf       	rjmp	.-26     	; 0x22a6 <__stack+0xa7>
    22c0:	80 91 2b 08 	lds	r24, 0x082B
    22c4:	81 30       	cpi	r24, 0x01	; 1
    22c6:	39 f4       	brne	.+14     	; 0x22d6 <__stack+0xd7>
    22c8:	06 d9       	rcall	.-3572   	; 0x14d6 <vPortYield>
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	05 c0       	rjmp	.+10     	; 0x22d8 <__stack+0xd9>
    22ce:	80 e0       	ldi	r24, 0x00	; 0
    22d0:	03 c0       	rjmp	.+6      	; 0x22d8 <__stack+0xd9>
    22d2:	80 e0       	ldi	r24, 0x00	; 0
    22d4:	01 c0       	rjmp	.+2      	; 0x22d8 <__stack+0xd9>
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63
    22dc:	df 91       	pop	r29
    22de:	cf 91       	pop	r28
    22e0:	1f 91       	pop	r17
    22e2:	0f 91       	pop	r16
    22e4:	ff 90       	pop	r15
    22e6:	ef 90       	pop	r14
    22e8:	df 90       	pop	r13
    22ea:	08 95       	ret

000022ec <vTaskDelayUntil>:
    22ec:	0f 93       	push	r16
    22ee:	1f 93       	push	r17
    22f0:	cf 93       	push	r28
    22f2:	df 93       	push	r29
    22f4:	8c 01       	movw	r16, r24
    22f6:	eb 01       	movw	r28, r22
    22f8:	a5 de       	rcall	.-694    	; 0x2044 <vTaskSuspendAll>
    22fa:	80 91 2f 08 	lds	r24, 0x082F
    22fe:	90 91 30 08 	lds	r25, 0x0830
    2302:	f8 01       	movw	r30, r16
    2304:	20 81       	ld	r18, Z
    2306:	31 81       	ldd	r19, Z+1	; 0x01
    2308:	c2 0f       	add	r28, r18
    230a:	d3 1f       	adc	r29, r19
    230c:	82 17       	cp	r24, r18
    230e:	93 07       	cpc	r25, r19
    2310:	48 f4       	brcc	.+18     	; 0x2324 <vTaskDelayUntil+0x38>
    2312:	c2 17       	cp	r28, r18
    2314:	d3 07       	cpc	r29, r19
    2316:	f8 f4       	brcc	.+62     	; 0x2356 <vTaskDelayUntil+0x6a>
    2318:	d1 83       	std	Z+1, r29	; 0x01
    231a:	c0 83       	st	Z, r28
    231c:	8c 17       	cp	r24, r28
    231e:	9d 07       	cpc	r25, r29
    2320:	88 f4       	brcc	.+34     	; 0x2344 <vTaskDelayUntil+0x58>
    2322:	07 c0       	rjmp	.+14     	; 0x2332 <vTaskDelayUntil+0x46>
    2324:	c2 17       	cp	r28, r18
    2326:	d3 07       	cpc	r29, r19
    2328:	90 f0       	brcs	.+36     	; 0x234e <vTaskDelayUntil+0x62>
    232a:	8c 17       	cp	r24, r28
    232c:	9d 07       	cpc	r25, r29
    232e:	78 f0       	brcs	.+30     	; 0x234e <vTaskDelayUntil+0x62>
    2330:	12 c0       	rjmp	.+36     	; 0x2356 <vTaskDelayUntil+0x6a>
    2332:	80 91 91 08 	lds	r24, 0x0891
    2336:	90 91 92 08 	lds	r25, 0x0892
    233a:	02 96       	adiw	r24, 0x02	; 2
    233c:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2340:	ce 01       	movw	r24, r28
    2342:	c0 dc       	rcall	.-1664   	; 0x1cc4 <prvAddCurrentTaskToDelayedList>
    2344:	52 df       	rcall	.-348    	; 0x21ea <xTaskResumeAll>
    2346:	81 11       	cpse	r24, r1
    2348:	0a c0       	rjmp	.+20     	; 0x235e <vTaskDelayUntil+0x72>
    234a:	c5 d8       	rcall	.-3702   	; 0x14d6 <vPortYield>
    234c:	08 c0       	rjmp	.+16     	; 0x235e <vTaskDelayUntil+0x72>
    234e:	f8 01       	movw	r30, r16
    2350:	d1 83       	std	Z+1, r29	; 0x01
    2352:	c0 83       	st	Z, r28
    2354:	ee cf       	rjmp	.-36     	; 0x2332 <vTaskDelayUntil+0x46>
    2356:	f8 01       	movw	r30, r16
    2358:	d1 83       	std	Z+1, r29	; 0x01
    235a:	c0 83       	st	Z, r28
    235c:	f3 cf       	rjmp	.-26     	; 0x2344 <vTaskDelayUntil+0x58>
    235e:	df 91       	pop	r29
    2360:	cf 91       	pop	r28
    2362:	1f 91       	pop	r17
    2364:	0f 91       	pop	r16
    2366:	08 95       	ret

00002368 <prvIdleTask>:
    2368:	0f 2e       	mov	r0, r31
    236a:	f4 e6       	ldi	r31, 0x64	; 100
    236c:	ef 2e       	mov	r14, r31
    236e:	f8 e0       	ldi	r31, 0x08	; 8
    2370:	ff 2e       	mov	r15, r31
    2372:	f0 2d       	mov	r31, r0
    2374:	cc e3       	ldi	r28, 0x3C	; 60
    2376:	d8 e0       	ldi	r29, 0x08	; 8
    2378:	26 c0       	rjmp	.+76     	; 0x23c6 <prvIdleTask+0x5e>
    237a:	64 de       	rcall	.-824    	; 0x2044 <vTaskSuspendAll>
    237c:	18 81       	ld	r17, Y
    237e:	35 df       	rcall	.-406    	; 0x21ea <xTaskResumeAll>
    2380:	11 23       	and	r17, r17
    2382:	09 f1       	breq	.+66     	; 0x23c6 <prvIdleTask+0x5e>
    2384:	0f b6       	in	r0, 0x3f	; 63
    2386:	f8 94       	cli
    2388:	0f 92       	push	r0
    238a:	e0 91 41 08 	lds	r30, 0x0841
    238e:	f0 91 42 08 	lds	r31, 0x0842
    2392:	06 81       	ldd	r16, Z+6	; 0x06
    2394:	17 81       	ldd	r17, Z+7	; 0x07
    2396:	c8 01       	movw	r24, r16
    2398:	02 96       	adiw	r24, 0x02	; 2
    239a:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    239e:	80 91 31 08 	lds	r24, 0x0831
    23a2:	81 50       	subi	r24, 0x01	; 1
    23a4:	80 93 31 08 	sts	0x0831, r24
    23a8:	80 91 3b 08 	lds	r24, 0x083B
    23ac:	81 50       	subi	r24, 0x01	; 1
    23ae:	80 93 3b 08 	sts	0x083B, r24
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
    23b6:	f8 01       	movw	r30, r16
    23b8:	87 89       	ldd	r24, Z+23	; 0x17
    23ba:	90 8d       	ldd	r25, Z+24	; 0x18
    23bc:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    23c0:	c8 01       	movw	r24, r16
    23c2:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
    23c6:	80 91 3b 08 	lds	r24, 0x083B
    23ca:	81 11       	cpse	r24, r1
    23cc:	d6 cf       	rjmp	.-84     	; 0x237a <prvIdleTask+0x12>
    23ce:	f7 01       	movw	r30, r14
    23d0:	80 81       	ld	r24, Z
    23d2:	82 30       	cpi	r24, 0x02	; 2
    23d4:	c0 f3       	brcs	.-16     	; 0x23c6 <prvIdleTask+0x5e>
    23d6:	7f d8       	rcall	.-3842   	; 0x14d6 <vPortYield>
    23d8:	f6 cf       	rjmp	.-20     	; 0x23c6 <prvIdleTask+0x5e>

000023da <vTaskSwitchContext>:
    23da:	80 91 28 08 	lds	r24, 0x0828
    23de:	88 23       	and	r24, r24
    23e0:	21 f0       	breq	.+8      	; 0x23ea <vTaskSwitchContext+0x10>
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	80 93 2b 08 	sts	0x082B, r24
    23e8:	08 95       	ret
    23ea:	10 92 2b 08 	sts	0x082B, r1
    23ee:	80 91 2e 08 	lds	r24, 0x082E
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	fc 01       	movw	r30, r24
    23f6:	ee 0f       	add	r30, r30
    23f8:	ff 1f       	adc	r31, r31
    23fa:	ee 0f       	add	r30, r30
    23fc:	ff 1f       	adc	r31, r31
    23fe:	ee 0f       	add	r30, r30
    2400:	ff 1f       	adc	r31, r31
    2402:	8e 0f       	add	r24, r30
    2404:	9f 1f       	adc	r25, r31
    2406:	fc 01       	movw	r30, r24
    2408:	ec 59       	subi	r30, 0x9C	; 156
    240a:	f7 4f       	sbci	r31, 0xF7	; 247
    240c:	80 81       	ld	r24, Z
    240e:	81 11       	cpse	r24, r1
    2410:	17 c0       	rjmp	.+46     	; 0x2440 <vTaskSwitchContext+0x66>
    2412:	80 91 2e 08 	lds	r24, 0x082E
    2416:	81 50       	subi	r24, 0x01	; 1
    2418:	80 93 2e 08 	sts	0x082E, r24
    241c:	80 91 2e 08 	lds	r24, 0x082E
    2420:	90 e0       	ldi	r25, 0x00	; 0
    2422:	fc 01       	movw	r30, r24
    2424:	ee 0f       	add	r30, r30
    2426:	ff 1f       	adc	r31, r31
    2428:	ee 0f       	add	r30, r30
    242a:	ff 1f       	adc	r31, r31
    242c:	ee 0f       	add	r30, r30
    242e:	ff 1f       	adc	r31, r31
    2430:	8e 0f       	add	r24, r30
    2432:	9f 1f       	adc	r25, r31
    2434:	fc 01       	movw	r30, r24
    2436:	ec 59       	subi	r30, 0x9C	; 156
    2438:	f7 4f       	sbci	r31, 0xF7	; 247
    243a:	80 81       	ld	r24, Z
    243c:	88 23       	and	r24, r24
    243e:	49 f3       	breq	.-46     	; 0x2412 <vTaskSwitchContext+0x38>
    2440:	e0 91 2e 08 	lds	r30, 0x082E
    2444:	f0 e0       	ldi	r31, 0x00	; 0
    2446:	cf 01       	movw	r24, r30
    2448:	88 0f       	add	r24, r24
    244a:	99 1f       	adc	r25, r25
    244c:	88 0f       	add	r24, r24
    244e:	99 1f       	adc	r25, r25
    2450:	88 0f       	add	r24, r24
    2452:	99 1f       	adc	r25, r25
    2454:	e8 0f       	add	r30, r24
    2456:	f9 1f       	adc	r31, r25
    2458:	ec 59       	subi	r30, 0x9C	; 156
    245a:	f7 4f       	sbci	r31, 0xF7	; 247
    245c:	a1 81       	ldd	r26, Z+1	; 0x01
    245e:	b2 81       	ldd	r27, Z+2	; 0x02
    2460:	12 96       	adiw	r26, 0x02	; 2
    2462:	0d 90       	ld	r0, X+
    2464:	bc 91       	ld	r27, X
    2466:	a0 2d       	mov	r26, r0
    2468:	b2 83       	std	Z+2, r27	; 0x02
    246a:	a1 83       	std	Z+1, r26	; 0x01
    246c:	cf 01       	movw	r24, r30
    246e:	03 96       	adiw	r24, 0x03	; 3
    2470:	a8 17       	cp	r26, r24
    2472:	b9 07       	cpc	r27, r25
    2474:	31 f4       	brne	.+12     	; 0x2482 <vTaskSwitchContext+0xa8>
    2476:	12 96       	adiw	r26, 0x02	; 2
    2478:	8d 91       	ld	r24, X+
    247a:	9c 91       	ld	r25, X
    247c:	13 97       	sbiw	r26, 0x03	; 3
    247e:	92 83       	std	Z+2, r25	; 0x02
    2480:	81 83       	std	Z+1, r24	; 0x01
    2482:	01 80       	ldd	r0, Z+1	; 0x01
    2484:	f2 81       	ldd	r31, Z+2	; 0x02
    2486:	e0 2d       	mov	r30, r0
    2488:	86 81       	ldd	r24, Z+6	; 0x06
    248a:	97 81       	ldd	r25, Z+7	; 0x07
    248c:	90 93 92 08 	sts	0x0892, r25
    2490:	80 93 91 08 	sts	0x0891, r24
    2494:	08 95       	ret

00002496 <vTaskSuspend>:
    2496:	0f 93       	push	r16
    2498:	1f 93       	push	r17
    249a:	cf 93       	push	r28
    249c:	df 93       	push	r29
    249e:	ec 01       	movw	r28, r24
    24a0:	0f b6       	in	r0, 0x3f	; 63
    24a2:	f8 94       	cli
    24a4:	0f 92       	push	r0
    24a6:	00 97       	sbiw	r24, 0x00	; 0
    24a8:	21 f4       	brne	.+8      	; 0x24b2 <vTaskSuspend+0x1c>
    24aa:	c0 91 91 08 	lds	r28, 0x0891
    24ae:	d0 91 92 08 	lds	r29, 0x0892
    24b2:	8e 01       	movw	r16, r28
    24b4:	0e 5f       	subi	r16, 0xFE	; 254
    24b6:	1f 4f       	sbci	r17, 0xFF	; 255
    24b8:	c8 01       	movw	r24, r16
    24ba:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    24be:	8c 89       	ldd	r24, Y+20	; 0x14
    24c0:	9d 89       	ldd	r25, Y+21	; 0x15
    24c2:	89 2b       	or	r24, r25
    24c4:	21 f0       	breq	.+8      	; 0x24ce <vTaskSuspend+0x38>
    24c6:	ce 01       	movw	r24, r28
    24c8:	0c 96       	adiw	r24, 0x0c	; 12
    24ca:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    24ce:	b8 01       	movw	r22, r16
    24d0:	82 e3       	ldi	r24, 0x32	; 50
    24d2:	98 e0       	ldi	r25, 0x08	; 8
    24d4:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    24d8:	0f 90       	pop	r0
    24da:	0f be       	out	0x3f, r0	; 63
    24dc:	80 91 91 08 	lds	r24, 0x0891
    24e0:	90 91 92 08 	lds	r25, 0x0892
    24e4:	c8 17       	cp	r28, r24
    24e6:	d9 07       	cpc	r29, r25
    24e8:	a1 f4       	brne	.+40     	; 0x2512 <vTaskSuspend+0x7c>
    24ea:	80 91 2d 08 	lds	r24, 0x082D
    24ee:	88 23       	and	r24, r24
    24f0:	19 f0       	breq	.+6      	; 0x24f8 <vTaskSuspend+0x62>
    24f2:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vPortYield>
    24f6:	17 c0       	rjmp	.+46     	; 0x2526 <vTaskSuspend+0x90>
    24f8:	80 91 31 08 	lds	r24, 0x0831
    24fc:	90 91 32 08 	lds	r25, 0x0832
    2500:	98 13       	cpse	r25, r24
    2502:	05 c0       	rjmp	.+10     	; 0x250e <vTaskSuspend+0x78>
    2504:	10 92 92 08 	sts	0x0892, r1
    2508:	10 92 91 08 	sts	0x0891, r1
    250c:	0c c0       	rjmp	.+24     	; 0x2526 <vTaskSuspend+0x90>
    250e:	65 df       	rcall	.-310    	; 0x23da <vTaskSwitchContext>
    2510:	0a c0       	rjmp	.+20     	; 0x2526 <vTaskSuspend+0x90>
    2512:	80 91 2d 08 	lds	r24, 0x082D
    2516:	88 23       	and	r24, r24
    2518:	31 f0       	breq	.+12     	; 0x2526 <vTaskSuspend+0x90>
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	0f 92       	push	r0
    2520:	b2 db       	rcall	.-2204   	; 0x1c86 <prvResetNextTaskUnblockTime>
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	df 91       	pop	r29
    2528:	cf 91       	pop	r28
    252a:	1f 91       	pop	r17
    252c:	0f 91       	pop	r16
    252e:	08 95       	ret

00002530 <vTaskPlaceOnEventList>:
    2530:	cf 93       	push	r28
    2532:	df 93       	push	r29
    2534:	eb 01       	movw	r28, r22
    2536:	60 91 91 08 	lds	r22, 0x0891
    253a:	70 91 92 08 	lds	r23, 0x0892
    253e:	64 5f       	subi	r22, 0xF4	; 244
    2540:	7f 4f       	sbci	r23, 0xFF	; 255
    2542:	0e 94 7f 03 	call	0x6fe	; 0x6fe <vListInsert>
    2546:	80 91 91 08 	lds	r24, 0x0891
    254a:	90 91 92 08 	lds	r25, 0x0892
    254e:	02 96       	adiw	r24, 0x02	; 2
    2550:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2554:	cf 3f       	cpi	r28, 0xFF	; 255
    2556:	8f ef       	ldi	r24, 0xFF	; 255
    2558:	d8 07       	cpc	r29, r24
    255a:	59 f4       	brne	.+22     	; 0x2572 <vTaskPlaceOnEventList+0x42>
    255c:	60 91 91 08 	lds	r22, 0x0891
    2560:	70 91 92 08 	lds	r23, 0x0892
    2564:	6e 5f       	subi	r22, 0xFE	; 254
    2566:	7f 4f       	sbci	r23, 0xFF	; 255
    2568:	82 e3       	ldi	r24, 0x32	; 50
    256a:	98 e0       	ldi	r25, 0x08	; 8
    256c:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2570:	07 c0       	rjmp	.+14     	; 0x2580 <vTaskPlaceOnEventList+0x50>
    2572:	80 91 2f 08 	lds	r24, 0x082F
    2576:	90 91 30 08 	lds	r25, 0x0830
    257a:	8c 0f       	add	r24, r28
    257c:	9d 1f       	adc	r25, r29
    257e:	a2 db       	rcall	.-2236   	; 0x1cc4 <prvAddCurrentTaskToDelayedList>
    2580:	df 91       	pop	r29
    2582:	cf 91       	pop	r28
    2584:	08 95       	ret

00002586 <xTaskRemoveFromEventList>:
    2586:	0f 93       	push	r16
    2588:	1f 93       	push	r17
    258a:	cf 93       	push	r28
    258c:	df 93       	push	r29
    258e:	dc 01       	movw	r26, r24
    2590:	15 96       	adiw	r26, 0x05	; 5
    2592:	ed 91       	ld	r30, X+
    2594:	fc 91       	ld	r31, X
    2596:	16 97       	sbiw	r26, 0x06	; 6
    2598:	c6 81       	ldd	r28, Z+6	; 0x06
    259a:	d7 81       	ldd	r29, Z+7	; 0x07
    259c:	8e 01       	movw	r16, r28
    259e:	04 5f       	subi	r16, 0xF4	; 244
    25a0:	1f 4f       	sbci	r17, 0xFF	; 255
    25a2:	c8 01       	movw	r24, r16
    25a4:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    25a8:	80 91 28 08 	lds	r24, 0x0828
    25ac:	81 11       	cpse	r24, r1
    25ae:	1c c0       	rjmp	.+56     	; 0x25e8 <xTaskRemoveFromEventList+0x62>
    25b0:	0a 50       	subi	r16, 0x0A	; 10
    25b2:	11 09       	sbc	r17, r1
    25b4:	c8 01       	movw	r24, r16
    25b6:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    25ba:	8e 89       	ldd	r24, Y+22	; 0x16
    25bc:	90 91 2e 08 	lds	r25, 0x082E
    25c0:	98 17       	cp	r25, r24
    25c2:	10 f4       	brcc	.+4      	; 0x25c8 <xTaskRemoveFromEventList+0x42>
    25c4:	80 93 2e 08 	sts	0x082E, r24
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	9c 01       	movw	r18, r24
    25cc:	22 0f       	add	r18, r18
    25ce:	33 1f       	adc	r19, r19
    25d0:	22 0f       	add	r18, r18
    25d2:	33 1f       	adc	r19, r19
    25d4:	22 0f       	add	r18, r18
    25d6:	33 1f       	adc	r19, r19
    25d8:	82 0f       	add	r24, r18
    25da:	93 1f       	adc	r25, r19
    25dc:	b8 01       	movw	r22, r16
    25de:	8c 59       	subi	r24, 0x9C	; 156
    25e0:	97 4f       	sbci	r25, 0xF7	; 247
    25e2:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    25e6:	05 c0       	rjmp	.+10     	; 0x25f2 <xTaskRemoveFromEventList+0x6c>
    25e8:	b8 01       	movw	r22, r16
    25ea:	85 e4       	ldi	r24, 0x45	; 69
    25ec:	98 e0       	ldi	r25, 0x08	; 8
    25ee:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    25f2:	e0 91 91 08 	lds	r30, 0x0891
    25f6:	f0 91 92 08 	lds	r31, 0x0892
    25fa:	9e 89       	ldd	r25, Y+22	; 0x16
    25fc:	86 89       	ldd	r24, Z+22	; 0x16
    25fe:	89 17       	cp	r24, r25
    2600:	20 f4       	brcc	.+8      	; 0x260a <xTaskRemoveFromEventList+0x84>
    2602:	81 e0       	ldi	r24, 0x01	; 1
    2604:	80 93 2b 08 	sts	0x082B, r24
    2608:	01 c0       	rjmp	.+2      	; 0x260c <xTaskRemoveFromEventList+0x86>
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	df 91       	pop	r29
    260e:	cf 91       	pop	r28
    2610:	1f 91       	pop	r17
    2612:	0f 91       	pop	r16
    2614:	08 95       	ret

00002616 <vTaskSetTimeOutState>:
    2616:	20 91 2a 08 	lds	r18, 0x082A
    261a:	fc 01       	movw	r30, r24
    261c:	20 83       	st	Z, r18
    261e:	20 91 2f 08 	lds	r18, 0x082F
    2622:	30 91 30 08 	lds	r19, 0x0830
    2626:	32 83       	std	Z+2, r19	; 0x02
    2628:	21 83       	std	Z+1, r18	; 0x01
    262a:	08 95       	ret

0000262c <xTaskCheckForTimeOut>:
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	0f 92       	push	r0
    2632:	40 91 2f 08 	lds	r20, 0x082F
    2636:	50 91 30 08 	lds	r21, 0x0830
    263a:	db 01       	movw	r26, r22
    263c:	2d 91       	ld	r18, X+
    263e:	3c 91       	ld	r19, X
    2640:	2f 3f       	cpi	r18, 0xFF	; 255
    2642:	bf ef       	ldi	r27, 0xFF	; 255
    2644:	3b 07       	cpc	r19, r27
    2646:	11 f1       	breq	.+68     	; 0x268c <xTaskCheckForTimeOut+0x60>
    2648:	e0 91 2a 08 	lds	r30, 0x082A
    264c:	dc 01       	movw	r26, r24
    264e:	fc 91       	ld	r31, X
    2650:	fe 17       	cp	r31, r30
    2652:	39 f0       	breq	.+14     	; 0x2662 <xTaskCheckForTimeOut+0x36>
    2654:	11 96       	adiw	r26, 0x01	; 1
    2656:	ed 91       	ld	r30, X+
    2658:	fc 91       	ld	r31, X
    265a:	12 97       	sbiw	r26, 0x02	; 2
    265c:	4e 17       	cp	r20, r30
    265e:	5f 07       	cpc	r21, r31
    2660:	b8 f4       	brcc	.+46     	; 0x2690 <xTaskCheckForTimeOut+0x64>
    2662:	dc 01       	movw	r26, r24
    2664:	11 96       	adiw	r26, 0x01	; 1
    2666:	ed 91       	ld	r30, X+
    2668:	fc 91       	ld	r31, X
    266a:	12 97       	sbiw	r26, 0x02	; 2
    266c:	da 01       	movw	r26, r20
    266e:	ae 1b       	sub	r26, r30
    2670:	bf 0b       	sbc	r27, r31
    2672:	a2 17       	cp	r26, r18
    2674:	b3 07       	cpc	r27, r19
    2676:	70 f4       	brcc	.+28     	; 0x2694 <xTaskCheckForTimeOut+0x68>
    2678:	e4 1b       	sub	r30, r20
    267a:	f5 0b       	sbc	r31, r21
    267c:	2e 0f       	add	r18, r30
    267e:	3f 1f       	adc	r19, r31
    2680:	fb 01       	movw	r30, r22
    2682:	31 83       	std	Z+1, r19	; 0x01
    2684:	20 83       	st	Z, r18
    2686:	c7 df       	rcall	.-114    	; 0x2616 <vTaskSetTimeOutState>
    2688:	80 e0       	ldi	r24, 0x00	; 0
    268a:	05 c0       	rjmp	.+10     	; 0x2696 <xTaskCheckForTimeOut+0x6a>
    268c:	80 e0       	ldi	r24, 0x00	; 0
    268e:	03 c0       	rjmp	.+6      	; 0x2696 <xTaskCheckForTimeOut+0x6a>
    2690:	81 e0       	ldi	r24, 0x01	; 1
    2692:	01 c0       	rjmp	.+2      	; 0x2696 <xTaskCheckForTimeOut+0x6a>
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	0f 90       	pop	r0
    2698:	0f be       	out	0x3f, r0	; 63
    269a:	08 95       	ret

0000269c <vTaskMissedYield>:
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	80 93 2b 08 	sts	0x082B, r24
    26a2:	08 95       	ret

000026a4 <vTaskPriorityInherit>:
    26a4:	0f 93       	push	r16
    26a6:	1f 93       	push	r17
    26a8:	cf 93       	push	r28
    26aa:	df 93       	push	r29
    26ac:	ec 01       	movw	r28, r24
    26ae:	00 97       	sbiw	r24, 0x00	; 0
    26b0:	09 f4       	brne	.+2      	; 0x26b4 <vTaskPriorityInherit+0x10>
    26b2:	51 c0       	rjmp	.+162    	; 0x2756 <vTaskPriorityInherit+0xb2>
    26b4:	8e 89       	ldd	r24, Y+22	; 0x16
    26b6:	e0 91 91 08 	lds	r30, 0x0891
    26ba:	f0 91 92 08 	lds	r31, 0x0892
    26be:	96 89       	ldd	r25, Z+22	; 0x16
    26c0:	89 17       	cp	r24, r25
    26c2:	08 f0       	brcs	.+2      	; 0x26c6 <vTaskPriorityInherit+0x22>
    26c4:	48 c0       	rjmp	.+144    	; 0x2756 <vTaskPriorityInherit+0xb2>
    26c6:	2c 85       	ldd	r18, Y+12	; 0x0c
    26c8:	3d 85       	ldd	r19, Y+13	; 0x0d
    26ca:	33 23       	and	r19, r19
    26cc:	5c f0       	brlt	.+22     	; 0x26e4 <vTaskPriorityInherit+0x40>
    26ce:	e0 91 91 08 	lds	r30, 0x0891
    26d2:	f0 91 92 08 	lds	r31, 0x0892
    26d6:	96 89       	ldd	r25, Z+22	; 0x16
    26d8:	25 e0       	ldi	r18, 0x05	; 5
    26da:	30 e0       	ldi	r19, 0x00	; 0
    26dc:	29 1b       	sub	r18, r25
    26de:	31 09       	sbc	r19, r1
    26e0:	3d 87       	std	Y+13, r19	; 0x0d
    26e2:	2c 87       	std	Y+12, r18	; 0x0c
    26e4:	90 e0       	ldi	r25, 0x00	; 0
    26e6:	9c 01       	movw	r18, r24
    26e8:	22 0f       	add	r18, r18
    26ea:	33 1f       	adc	r19, r19
    26ec:	22 0f       	add	r18, r18
    26ee:	33 1f       	adc	r19, r19
    26f0:	22 0f       	add	r18, r18
    26f2:	33 1f       	adc	r19, r19
    26f4:	82 0f       	add	r24, r18
    26f6:	93 1f       	adc	r25, r19
    26f8:	8c 59       	subi	r24, 0x9C	; 156
    26fa:	97 4f       	sbci	r25, 0xF7	; 247
    26fc:	2a 85       	ldd	r18, Y+10	; 0x0a
    26fe:	3b 85       	ldd	r19, Y+11	; 0x0b
    2700:	28 17       	cp	r18, r24
    2702:	39 07       	cpc	r19, r25
    2704:	11 f5       	brne	.+68     	; 0x274a <vTaskPriorityInherit+0xa6>
    2706:	8e 01       	movw	r16, r28
    2708:	0e 5f       	subi	r16, 0xFE	; 254
    270a:	1f 4f       	sbci	r17, 0xFF	; 255
    270c:	c8 01       	movw	r24, r16
    270e:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    2712:	e0 91 91 08 	lds	r30, 0x0891
    2716:	f0 91 92 08 	lds	r31, 0x0892
    271a:	86 89       	ldd	r24, Z+22	; 0x16
    271c:	8e 8b       	std	Y+22, r24	; 0x16
    271e:	90 91 2e 08 	lds	r25, 0x082E
    2722:	98 17       	cp	r25, r24
    2724:	10 f4       	brcc	.+4      	; 0x272a <vTaskPriorityInherit+0x86>
    2726:	80 93 2e 08 	sts	0x082E, r24
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	9c 01       	movw	r18, r24
    272e:	22 0f       	add	r18, r18
    2730:	33 1f       	adc	r19, r19
    2732:	22 0f       	add	r18, r18
    2734:	33 1f       	adc	r19, r19
    2736:	22 0f       	add	r18, r18
    2738:	33 1f       	adc	r19, r19
    273a:	82 0f       	add	r24, r18
    273c:	93 1f       	adc	r25, r19
    273e:	b8 01       	movw	r22, r16
    2740:	8c 59       	subi	r24, 0x9C	; 156
    2742:	97 4f       	sbci	r25, 0xF7	; 247
    2744:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    2748:	06 c0       	rjmp	.+12     	; 0x2756 <vTaskPriorityInherit+0xb2>
    274a:	e0 91 91 08 	lds	r30, 0x0891
    274e:	f0 91 92 08 	lds	r31, 0x0892
    2752:	86 89       	ldd	r24, Z+22	; 0x16
    2754:	8e 8b       	std	Y+22, r24	; 0x16
    2756:	df 91       	pop	r29
    2758:	cf 91       	pop	r28
    275a:	1f 91       	pop	r17
    275c:	0f 91       	pop	r16
    275e:	08 95       	ret

00002760 <xTaskPriorityDisinherit>:
    2760:	0f 93       	push	r16
    2762:	1f 93       	push	r17
    2764:	cf 93       	push	r28
    2766:	df 93       	push	r29
    2768:	ec 01       	movw	r28, r24
    276a:	00 97       	sbiw	r24, 0x00	; 0
    276c:	71 f1       	breq	.+92     	; 0x27ca <xTaskPriorityDisinherit+0x6a>
    276e:	8a a1       	ldd	r24, Y+34	; 0x22
    2770:	81 50       	subi	r24, 0x01	; 1
    2772:	8a a3       	std	Y+34, r24	; 0x22
    2774:	2e 89       	ldd	r18, Y+22	; 0x16
    2776:	99 a1       	ldd	r25, Y+33	; 0x21
    2778:	29 17       	cp	r18, r25
    277a:	49 f1       	breq	.+82     	; 0x27ce <xTaskPriorityDisinherit+0x6e>
    277c:	81 11       	cpse	r24, r1
    277e:	29 c0       	rjmp	.+82     	; 0x27d2 <xTaskPriorityDisinherit+0x72>
    2780:	8e 01       	movw	r16, r28
    2782:	0e 5f       	subi	r16, 0xFE	; 254
    2784:	1f 4f       	sbci	r17, 0xFF	; 255
    2786:	c8 01       	movw	r24, r16
    2788:	0e 94 b0 03 	call	0x760	; 0x760 <uxListRemove>
    278c:	89 a1       	ldd	r24, Y+33	; 0x21
    278e:	8e 8b       	std	Y+22, r24	; 0x16
    2790:	25 e0       	ldi	r18, 0x05	; 5
    2792:	30 e0       	ldi	r19, 0x00	; 0
    2794:	28 1b       	sub	r18, r24
    2796:	31 09       	sbc	r19, r1
    2798:	3d 87       	std	Y+13, r19	; 0x0d
    279a:	2c 87       	std	Y+12, r18	; 0x0c
    279c:	90 91 2e 08 	lds	r25, 0x082E
    27a0:	98 17       	cp	r25, r24
    27a2:	10 f4       	brcc	.+4      	; 0x27a8 <xTaskPriorityDisinherit+0x48>
    27a4:	80 93 2e 08 	sts	0x082E, r24
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	9c 01       	movw	r18, r24
    27ac:	22 0f       	add	r18, r18
    27ae:	33 1f       	adc	r19, r19
    27b0:	22 0f       	add	r18, r18
    27b2:	33 1f       	adc	r19, r19
    27b4:	22 0f       	add	r18, r18
    27b6:	33 1f       	adc	r19, r19
    27b8:	82 0f       	add	r24, r18
    27ba:	93 1f       	adc	r25, r19
    27bc:	b8 01       	movw	r22, r16
    27be:	8c 59       	subi	r24, 0x9C	; 156
    27c0:	97 4f       	sbci	r25, 0xF7	; 247
    27c2:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsertEnd>
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	05 c0       	rjmp	.+10     	; 0x27d4 <xTaskPriorityDisinherit+0x74>
    27ca:	80 e0       	ldi	r24, 0x00	; 0
    27cc:	03 c0       	rjmp	.+6      	; 0x27d4 <xTaskPriorityDisinherit+0x74>
    27ce:	80 e0       	ldi	r24, 0x00	; 0
    27d0:	01 c0       	rjmp	.+2      	; 0x27d4 <xTaskPriorityDisinherit+0x74>
    27d2:	80 e0       	ldi	r24, 0x00	; 0
    27d4:	df 91       	pop	r29
    27d6:	cf 91       	pop	r28
    27d8:	1f 91       	pop	r17
    27da:	0f 91       	pop	r16
    27dc:	08 95       	ret

000027de <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    27de:	80 91 91 08 	lds	r24, 0x0891
    27e2:	90 91 92 08 	lds	r25, 0x0892
    27e6:	89 2b       	or	r24, r25
    27e8:	39 f0       	breq	.+14     	; 0x27f8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    27ea:	e0 91 91 08 	lds	r30, 0x0891
    27ee:	f0 91 92 08 	lds	r31, 0x0892
    27f2:	82 a1       	ldd	r24, Z+34	; 0x22
    27f4:	8f 5f       	subi	r24, 0xFF	; 255
    27f6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    27f8:	80 91 91 08 	lds	r24, 0x0891
    27fc:	90 91 92 08 	lds	r25, 0x0892
	}
    2800:	08 95       	ret

00002802 <__subsf3>:
    2802:	50 58       	subi	r21, 0x80	; 128

00002804 <__addsf3>:
    2804:	bb 27       	eor	r27, r27
    2806:	aa 27       	eor	r26, r26
    2808:	0e d0       	rcall	.+28     	; 0x2826 <__addsf3x>
    280a:	e5 c0       	rjmp	.+458    	; 0x29d6 <__fp_round>
    280c:	d6 d0       	rcall	.+428    	; 0x29ba <__fp_pscA>
    280e:	30 f0       	brcs	.+12     	; 0x281c <__addsf3+0x18>
    2810:	db d0       	rcall	.+438    	; 0x29c8 <__fp_pscB>
    2812:	20 f0       	brcs	.+8      	; 0x281c <__addsf3+0x18>
    2814:	31 f4       	brne	.+12     	; 0x2822 <__addsf3+0x1e>
    2816:	9f 3f       	cpi	r25, 0xFF	; 255
    2818:	11 f4       	brne	.+4      	; 0x281e <__addsf3+0x1a>
    281a:	1e f4       	brtc	.+6      	; 0x2822 <__addsf3+0x1e>
    281c:	cb c0       	rjmp	.+406    	; 0x29b4 <__fp_nan>
    281e:	0e f4       	brtc	.+2      	; 0x2822 <__addsf3+0x1e>
    2820:	e0 95       	com	r30
    2822:	e7 fb       	bst	r30, 7
    2824:	c1 c0       	rjmp	.+386    	; 0x29a8 <__fp_inf>

00002826 <__addsf3x>:
    2826:	e9 2f       	mov	r30, r25
    2828:	e7 d0       	rcall	.+462    	; 0x29f8 <__fp_split3>
    282a:	80 f3       	brcs	.-32     	; 0x280c <__addsf3+0x8>
    282c:	ba 17       	cp	r27, r26
    282e:	62 07       	cpc	r22, r18
    2830:	73 07       	cpc	r23, r19
    2832:	84 07       	cpc	r24, r20
    2834:	95 07       	cpc	r25, r21
    2836:	18 f0       	brcs	.+6      	; 0x283e <__addsf3x+0x18>
    2838:	71 f4       	brne	.+28     	; 0x2856 <__addsf3x+0x30>
    283a:	9e f5       	brtc	.+102    	; 0x28a2 <__addsf3x+0x7c>
    283c:	ff c0       	rjmp	.+510    	; 0x2a3c <__fp_zero>
    283e:	0e f4       	brtc	.+2      	; 0x2842 <__addsf3x+0x1c>
    2840:	e0 95       	com	r30
    2842:	0b 2e       	mov	r0, r27
    2844:	ba 2f       	mov	r27, r26
    2846:	a0 2d       	mov	r26, r0
    2848:	0b 01       	movw	r0, r22
    284a:	b9 01       	movw	r22, r18
    284c:	90 01       	movw	r18, r0
    284e:	0c 01       	movw	r0, r24
    2850:	ca 01       	movw	r24, r20
    2852:	a0 01       	movw	r20, r0
    2854:	11 24       	eor	r1, r1
    2856:	ff 27       	eor	r31, r31
    2858:	59 1b       	sub	r21, r25
    285a:	99 f0       	breq	.+38     	; 0x2882 <__addsf3x+0x5c>
    285c:	59 3f       	cpi	r21, 0xF9	; 249
    285e:	50 f4       	brcc	.+20     	; 0x2874 <__addsf3x+0x4e>
    2860:	50 3e       	cpi	r21, 0xE0	; 224
    2862:	68 f1       	brcs	.+90     	; 0x28be <__addsf3x+0x98>
    2864:	1a 16       	cp	r1, r26
    2866:	f0 40       	sbci	r31, 0x00	; 0
    2868:	a2 2f       	mov	r26, r18
    286a:	23 2f       	mov	r18, r19
    286c:	34 2f       	mov	r19, r20
    286e:	44 27       	eor	r20, r20
    2870:	58 5f       	subi	r21, 0xF8	; 248
    2872:	f3 cf       	rjmp	.-26     	; 0x285a <__addsf3x+0x34>
    2874:	46 95       	lsr	r20
    2876:	37 95       	ror	r19
    2878:	27 95       	ror	r18
    287a:	a7 95       	ror	r26
    287c:	f0 40       	sbci	r31, 0x00	; 0
    287e:	53 95       	inc	r21
    2880:	c9 f7       	brne	.-14     	; 0x2874 <__addsf3x+0x4e>
    2882:	7e f4       	brtc	.+30     	; 0x28a2 <__addsf3x+0x7c>
    2884:	1f 16       	cp	r1, r31
    2886:	ba 0b       	sbc	r27, r26
    2888:	62 0b       	sbc	r22, r18
    288a:	73 0b       	sbc	r23, r19
    288c:	84 0b       	sbc	r24, r20
    288e:	ba f0       	brmi	.+46     	; 0x28be <__addsf3x+0x98>
    2890:	91 50       	subi	r25, 0x01	; 1
    2892:	a1 f0       	breq	.+40     	; 0x28bc <__addsf3x+0x96>
    2894:	ff 0f       	add	r31, r31
    2896:	bb 1f       	adc	r27, r27
    2898:	66 1f       	adc	r22, r22
    289a:	77 1f       	adc	r23, r23
    289c:	88 1f       	adc	r24, r24
    289e:	c2 f7       	brpl	.-16     	; 0x2890 <__addsf3x+0x6a>
    28a0:	0e c0       	rjmp	.+28     	; 0x28be <__addsf3x+0x98>
    28a2:	ba 0f       	add	r27, r26
    28a4:	62 1f       	adc	r22, r18
    28a6:	73 1f       	adc	r23, r19
    28a8:	84 1f       	adc	r24, r20
    28aa:	48 f4       	brcc	.+18     	; 0x28be <__addsf3x+0x98>
    28ac:	87 95       	ror	r24
    28ae:	77 95       	ror	r23
    28b0:	67 95       	ror	r22
    28b2:	b7 95       	ror	r27
    28b4:	f7 95       	ror	r31
    28b6:	9e 3f       	cpi	r25, 0xFE	; 254
    28b8:	08 f0       	brcs	.+2      	; 0x28bc <__addsf3x+0x96>
    28ba:	b3 cf       	rjmp	.-154    	; 0x2822 <__addsf3+0x1e>
    28bc:	93 95       	inc	r25
    28be:	88 0f       	add	r24, r24
    28c0:	08 f0       	brcs	.+2      	; 0x28c4 <__addsf3x+0x9e>
    28c2:	99 27       	eor	r25, r25
    28c4:	ee 0f       	add	r30, r30
    28c6:	97 95       	ror	r25
    28c8:	87 95       	ror	r24
    28ca:	08 95       	ret

000028cc <__fixsfsi>:
    28cc:	04 d0       	rcall	.+8      	; 0x28d6 <__fixunssfsi>
    28ce:	68 94       	set
    28d0:	b1 11       	cpse	r27, r1
    28d2:	b5 c0       	rjmp	.+362    	; 0x2a3e <__fp_szero>
    28d4:	08 95       	ret

000028d6 <__fixunssfsi>:
    28d6:	98 d0       	rcall	.+304    	; 0x2a08 <__fp_splitA>
    28d8:	88 f0       	brcs	.+34     	; 0x28fc <__fixunssfsi+0x26>
    28da:	9f 57       	subi	r25, 0x7F	; 127
    28dc:	90 f0       	brcs	.+36     	; 0x2902 <__fixunssfsi+0x2c>
    28de:	b9 2f       	mov	r27, r25
    28e0:	99 27       	eor	r25, r25
    28e2:	b7 51       	subi	r27, 0x17	; 23
    28e4:	a0 f0       	brcs	.+40     	; 0x290e <__fixunssfsi+0x38>
    28e6:	d1 f0       	breq	.+52     	; 0x291c <__fixunssfsi+0x46>
    28e8:	66 0f       	add	r22, r22
    28ea:	77 1f       	adc	r23, r23
    28ec:	88 1f       	adc	r24, r24
    28ee:	99 1f       	adc	r25, r25
    28f0:	1a f0       	brmi	.+6      	; 0x28f8 <__fixunssfsi+0x22>
    28f2:	ba 95       	dec	r27
    28f4:	c9 f7       	brne	.-14     	; 0x28e8 <__fixunssfsi+0x12>
    28f6:	12 c0       	rjmp	.+36     	; 0x291c <__fixunssfsi+0x46>
    28f8:	b1 30       	cpi	r27, 0x01	; 1
    28fa:	81 f0       	breq	.+32     	; 0x291c <__fixunssfsi+0x46>
    28fc:	9f d0       	rcall	.+318    	; 0x2a3c <__fp_zero>
    28fe:	b1 e0       	ldi	r27, 0x01	; 1
    2900:	08 95       	ret
    2902:	9c c0       	rjmp	.+312    	; 0x2a3c <__fp_zero>
    2904:	67 2f       	mov	r22, r23
    2906:	78 2f       	mov	r23, r24
    2908:	88 27       	eor	r24, r24
    290a:	b8 5f       	subi	r27, 0xF8	; 248
    290c:	39 f0       	breq	.+14     	; 0x291c <__fixunssfsi+0x46>
    290e:	b9 3f       	cpi	r27, 0xF9	; 249
    2910:	cc f3       	brlt	.-14     	; 0x2904 <__fixunssfsi+0x2e>
    2912:	86 95       	lsr	r24
    2914:	77 95       	ror	r23
    2916:	67 95       	ror	r22
    2918:	b3 95       	inc	r27
    291a:	d9 f7       	brne	.-10     	; 0x2912 <__fixunssfsi+0x3c>
    291c:	3e f4       	brtc	.+14     	; 0x292c <__fixunssfsi+0x56>
    291e:	90 95       	com	r25
    2920:	80 95       	com	r24
    2922:	70 95       	com	r23
    2924:	61 95       	neg	r22
    2926:	7f 4f       	sbci	r23, 0xFF	; 255
    2928:	8f 4f       	sbci	r24, 0xFF	; 255
    292a:	9f 4f       	sbci	r25, 0xFF	; 255
    292c:	08 95       	ret

0000292e <__floatunsisf>:
    292e:	e8 94       	clt
    2930:	09 c0       	rjmp	.+18     	; 0x2944 <__floatsisf+0x12>

00002932 <__floatsisf>:
    2932:	97 fb       	bst	r25, 7
    2934:	3e f4       	brtc	.+14     	; 0x2944 <__floatsisf+0x12>
    2936:	90 95       	com	r25
    2938:	80 95       	com	r24
    293a:	70 95       	com	r23
    293c:	61 95       	neg	r22
    293e:	7f 4f       	sbci	r23, 0xFF	; 255
    2940:	8f 4f       	sbci	r24, 0xFF	; 255
    2942:	9f 4f       	sbci	r25, 0xFF	; 255
    2944:	99 23       	and	r25, r25
    2946:	a9 f0       	breq	.+42     	; 0x2972 <__floatsisf+0x40>
    2948:	f9 2f       	mov	r31, r25
    294a:	96 e9       	ldi	r25, 0x96	; 150
    294c:	bb 27       	eor	r27, r27
    294e:	93 95       	inc	r25
    2950:	f6 95       	lsr	r31
    2952:	87 95       	ror	r24
    2954:	77 95       	ror	r23
    2956:	67 95       	ror	r22
    2958:	b7 95       	ror	r27
    295a:	f1 11       	cpse	r31, r1
    295c:	f8 cf       	rjmp	.-16     	; 0x294e <__floatsisf+0x1c>
    295e:	fa f4       	brpl	.+62     	; 0x299e <__floatsisf+0x6c>
    2960:	bb 0f       	add	r27, r27
    2962:	11 f4       	brne	.+4      	; 0x2968 <__floatsisf+0x36>
    2964:	60 ff       	sbrs	r22, 0
    2966:	1b c0       	rjmp	.+54     	; 0x299e <__floatsisf+0x6c>
    2968:	6f 5f       	subi	r22, 0xFF	; 255
    296a:	7f 4f       	sbci	r23, 0xFF	; 255
    296c:	8f 4f       	sbci	r24, 0xFF	; 255
    296e:	9f 4f       	sbci	r25, 0xFF	; 255
    2970:	16 c0       	rjmp	.+44     	; 0x299e <__floatsisf+0x6c>
    2972:	88 23       	and	r24, r24
    2974:	11 f0       	breq	.+4      	; 0x297a <__floatsisf+0x48>
    2976:	96 e9       	ldi	r25, 0x96	; 150
    2978:	11 c0       	rjmp	.+34     	; 0x299c <__floatsisf+0x6a>
    297a:	77 23       	and	r23, r23
    297c:	21 f0       	breq	.+8      	; 0x2986 <__floatsisf+0x54>
    297e:	9e e8       	ldi	r25, 0x8E	; 142
    2980:	87 2f       	mov	r24, r23
    2982:	76 2f       	mov	r23, r22
    2984:	05 c0       	rjmp	.+10     	; 0x2990 <__floatsisf+0x5e>
    2986:	66 23       	and	r22, r22
    2988:	71 f0       	breq	.+28     	; 0x29a6 <__floatsisf+0x74>
    298a:	96 e8       	ldi	r25, 0x86	; 134
    298c:	86 2f       	mov	r24, r22
    298e:	70 e0       	ldi	r23, 0x00	; 0
    2990:	60 e0       	ldi	r22, 0x00	; 0
    2992:	2a f0       	brmi	.+10     	; 0x299e <__floatsisf+0x6c>
    2994:	9a 95       	dec	r25
    2996:	66 0f       	add	r22, r22
    2998:	77 1f       	adc	r23, r23
    299a:	88 1f       	adc	r24, r24
    299c:	da f7       	brpl	.-10     	; 0x2994 <__floatsisf+0x62>
    299e:	88 0f       	add	r24, r24
    29a0:	96 95       	lsr	r25
    29a2:	87 95       	ror	r24
    29a4:	97 f9       	bld	r25, 7
    29a6:	08 95       	ret

000029a8 <__fp_inf>:
    29a8:	97 f9       	bld	r25, 7
    29aa:	9f 67       	ori	r25, 0x7F	; 127
    29ac:	80 e8       	ldi	r24, 0x80	; 128
    29ae:	70 e0       	ldi	r23, 0x00	; 0
    29b0:	60 e0       	ldi	r22, 0x00	; 0
    29b2:	08 95       	ret

000029b4 <__fp_nan>:
    29b4:	9f ef       	ldi	r25, 0xFF	; 255
    29b6:	80 ec       	ldi	r24, 0xC0	; 192
    29b8:	08 95       	ret

000029ba <__fp_pscA>:
    29ba:	00 24       	eor	r0, r0
    29bc:	0a 94       	dec	r0
    29be:	16 16       	cp	r1, r22
    29c0:	17 06       	cpc	r1, r23
    29c2:	18 06       	cpc	r1, r24
    29c4:	09 06       	cpc	r0, r25
    29c6:	08 95       	ret

000029c8 <__fp_pscB>:
    29c8:	00 24       	eor	r0, r0
    29ca:	0a 94       	dec	r0
    29cc:	12 16       	cp	r1, r18
    29ce:	13 06       	cpc	r1, r19
    29d0:	14 06       	cpc	r1, r20
    29d2:	05 06       	cpc	r0, r21
    29d4:	08 95       	ret

000029d6 <__fp_round>:
    29d6:	09 2e       	mov	r0, r25
    29d8:	03 94       	inc	r0
    29da:	00 0c       	add	r0, r0
    29dc:	11 f4       	brne	.+4      	; 0x29e2 <__fp_round+0xc>
    29de:	88 23       	and	r24, r24
    29e0:	52 f0       	brmi	.+20     	; 0x29f6 <__fp_round+0x20>
    29e2:	bb 0f       	add	r27, r27
    29e4:	40 f4       	brcc	.+16     	; 0x29f6 <__fp_round+0x20>
    29e6:	bf 2b       	or	r27, r31
    29e8:	11 f4       	brne	.+4      	; 0x29ee <__fp_round+0x18>
    29ea:	60 ff       	sbrs	r22, 0
    29ec:	04 c0       	rjmp	.+8      	; 0x29f6 <__fp_round+0x20>
    29ee:	6f 5f       	subi	r22, 0xFF	; 255
    29f0:	7f 4f       	sbci	r23, 0xFF	; 255
    29f2:	8f 4f       	sbci	r24, 0xFF	; 255
    29f4:	9f 4f       	sbci	r25, 0xFF	; 255
    29f6:	08 95       	ret

000029f8 <__fp_split3>:
    29f8:	57 fd       	sbrc	r21, 7
    29fa:	90 58       	subi	r25, 0x80	; 128
    29fc:	44 0f       	add	r20, r20
    29fe:	55 1f       	adc	r21, r21
    2a00:	59 f0       	breq	.+22     	; 0x2a18 <__fp_splitA+0x10>
    2a02:	5f 3f       	cpi	r21, 0xFF	; 255
    2a04:	71 f0       	breq	.+28     	; 0x2a22 <__fp_splitA+0x1a>
    2a06:	47 95       	ror	r20

00002a08 <__fp_splitA>:
    2a08:	88 0f       	add	r24, r24
    2a0a:	97 fb       	bst	r25, 7
    2a0c:	99 1f       	adc	r25, r25
    2a0e:	61 f0       	breq	.+24     	; 0x2a28 <__fp_splitA+0x20>
    2a10:	9f 3f       	cpi	r25, 0xFF	; 255
    2a12:	79 f0       	breq	.+30     	; 0x2a32 <__fp_splitA+0x2a>
    2a14:	87 95       	ror	r24
    2a16:	08 95       	ret
    2a18:	12 16       	cp	r1, r18
    2a1a:	13 06       	cpc	r1, r19
    2a1c:	14 06       	cpc	r1, r20
    2a1e:	55 1f       	adc	r21, r21
    2a20:	f2 cf       	rjmp	.-28     	; 0x2a06 <__fp_split3+0xe>
    2a22:	46 95       	lsr	r20
    2a24:	f1 df       	rcall	.-30     	; 0x2a08 <__fp_splitA>
    2a26:	08 c0       	rjmp	.+16     	; 0x2a38 <__fp_splitA+0x30>
    2a28:	16 16       	cp	r1, r22
    2a2a:	17 06       	cpc	r1, r23
    2a2c:	18 06       	cpc	r1, r24
    2a2e:	99 1f       	adc	r25, r25
    2a30:	f1 cf       	rjmp	.-30     	; 0x2a14 <__fp_splitA+0xc>
    2a32:	86 95       	lsr	r24
    2a34:	71 05       	cpc	r23, r1
    2a36:	61 05       	cpc	r22, r1
    2a38:	08 94       	sec
    2a3a:	08 95       	ret

00002a3c <__fp_zero>:
    2a3c:	e8 94       	clt

00002a3e <__fp_szero>:
    2a3e:	bb 27       	eor	r27, r27
    2a40:	66 27       	eor	r22, r22
    2a42:	77 27       	eor	r23, r23
    2a44:	cb 01       	movw	r24, r22
    2a46:	97 f9       	bld	r25, 7
    2a48:	08 95       	ret

00002a4a <__mulsf3>:
    2a4a:	0b d0       	rcall	.+22     	; 0x2a62 <__mulsf3x>
    2a4c:	c4 cf       	rjmp	.-120    	; 0x29d6 <__fp_round>
    2a4e:	b5 df       	rcall	.-150    	; 0x29ba <__fp_pscA>
    2a50:	28 f0       	brcs	.+10     	; 0x2a5c <__mulsf3+0x12>
    2a52:	ba df       	rcall	.-140    	; 0x29c8 <__fp_pscB>
    2a54:	18 f0       	brcs	.+6      	; 0x2a5c <__mulsf3+0x12>
    2a56:	95 23       	and	r25, r21
    2a58:	09 f0       	breq	.+2      	; 0x2a5c <__mulsf3+0x12>
    2a5a:	a6 cf       	rjmp	.-180    	; 0x29a8 <__fp_inf>
    2a5c:	ab cf       	rjmp	.-170    	; 0x29b4 <__fp_nan>
    2a5e:	11 24       	eor	r1, r1
    2a60:	ee cf       	rjmp	.-36     	; 0x2a3e <__fp_szero>

00002a62 <__mulsf3x>:
    2a62:	ca df       	rcall	.-108    	; 0x29f8 <__fp_split3>
    2a64:	a0 f3       	brcs	.-24     	; 0x2a4e <__mulsf3+0x4>

00002a66 <__mulsf3_pse>:
    2a66:	95 9f       	mul	r25, r21
    2a68:	d1 f3       	breq	.-12     	; 0x2a5e <__mulsf3+0x14>
    2a6a:	95 0f       	add	r25, r21
    2a6c:	50 e0       	ldi	r21, 0x00	; 0
    2a6e:	55 1f       	adc	r21, r21
    2a70:	62 9f       	mul	r22, r18
    2a72:	f0 01       	movw	r30, r0
    2a74:	72 9f       	mul	r23, r18
    2a76:	bb 27       	eor	r27, r27
    2a78:	f0 0d       	add	r31, r0
    2a7a:	b1 1d       	adc	r27, r1
    2a7c:	63 9f       	mul	r22, r19
    2a7e:	aa 27       	eor	r26, r26
    2a80:	f0 0d       	add	r31, r0
    2a82:	b1 1d       	adc	r27, r1
    2a84:	aa 1f       	adc	r26, r26
    2a86:	64 9f       	mul	r22, r20
    2a88:	66 27       	eor	r22, r22
    2a8a:	b0 0d       	add	r27, r0
    2a8c:	a1 1d       	adc	r26, r1
    2a8e:	66 1f       	adc	r22, r22
    2a90:	82 9f       	mul	r24, r18
    2a92:	22 27       	eor	r18, r18
    2a94:	b0 0d       	add	r27, r0
    2a96:	a1 1d       	adc	r26, r1
    2a98:	62 1f       	adc	r22, r18
    2a9a:	73 9f       	mul	r23, r19
    2a9c:	b0 0d       	add	r27, r0
    2a9e:	a1 1d       	adc	r26, r1
    2aa0:	62 1f       	adc	r22, r18
    2aa2:	83 9f       	mul	r24, r19
    2aa4:	a0 0d       	add	r26, r0
    2aa6:	61 1d       	adc	r22, r1
    2aa8:	22 1f       	adc	r18, r18
    2aaa:	74 9f       	mul	r23, r20
    2aac:	33 27       	eor	r19, r19
    2aae:	a0 0d       	add	r26, r0
    2ab0:	61 1d       	adc	r22, r1
    2ab2:	23 1f       	adc	r18, r19
    2ab4:	84 9f       	mul	r24, r20
    2ab6:	60 0d       	add	r22, r0
    2ab8:	21 1d       	adc	r18, r1
    2aba:	82 2f       	mov	r24, r18
    2abc:	76 2f       	mov	r23, r22
    2abe:	6a 2f       	mov	r22, r26
    2ac0:	11 24       	eor	r1, r1
    2ac2:	9f 57       	subi	r25, 0x7F	; 127
    2ac4:	50 40       	sbci	r21, 0x00	; 0
    2ac6:	8a f0       	brmi	.+34     	; 0x2aea <__mulsf3_pse+0x84>
    2ac8:	e1 f0       	breq	.+56     	; 0x2b02 <__mulsf3_pse+0x9c>
    2aca:	88 23       	and	r24, r24
    2acc:	4a f0       	brmi	.+18     	; 0x2ae0 <__mulsf3_pse+0x7a>
    2ace:	ee 0f       	add	r30, r30
    2ad0:	ff 1f       	adc	r31, r31
    2ad2:	bb 1f       	adc	r27, r27
    2ad4:	66 1f       	adc	r22, r22
    2ad6:	77 1f       	adc	r23, r23
    2ad8:	88 1f       	adc	r24, r24
    2ada:	91 50       	subi	r25, 0x01	; 1
    2adc:	50 40       	sbci	r21, 0x00	; 0
    2ade:	a9 f7       	brne	.-22     	; 0x2aca <__mulsf3_pse+0x64>
    2ae0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ae2:	51 05       	cpc	r21, r1
    2ae4:	70 f0       	brcs	.+28     	; 0x2b02 <__mulsf3_pse+0x9c>
    2ae6:	60 cf       	rjmp	.-320    	; 0x29a8 <__fp_inf>
    2ae8:	aa cf       	rjmp	.-172    	; 0x2a3e <__fp_szero>
    2aea:	5f 3f       	cpi	r21, 0xFF	; 255
    2aec:	ec f3       	brlt	.-6      	; 0x2ae8 <__mulsf3_pse+0x82>
    2aee:	98 3e       	cpi	r25, 0xE8	; 232
    2af0:	dc f3       	brlt	.-10     	; 0x2ae8 <__mulsf3_pse+0x82>
    2af2:	86 95       	lsr	r24
    2af4:	77 95       	ror	r23
    2af6:	67 95       	ror	r22
    2af8:	b7 95       	ror	r27
    2afa:	f7 95       	ror	r31
    2afc:	e7 95       	ror	r30
    2afe:	9f 5f       	subi	r25, 0xFF	; 255
    2b00:	c1 f7       	brne	.-16     	; 0x2af2 <__mulsf3_pse+0x8c>
    2b02:	fe 2b       	or	r31, r30
    2b04:	88 0f       	add	r24, r24
    2b06:	91 1d       	adc	r25, r1
    2b08:	96 95       	lsr	r25
    2b0a:	87 95       	ror	r24
    2b0c:	97 f9       	bld	r25, 7
    2b0e:	08 95       	ret

00002b10 <pow>:
    2b10:	fa 01       	movw	r30, r20
    2b12:	ee 0f       	add	r30, r30
    2b14:	ff 1f       	adc	r31, r31
    2b16:	30 96       	adiw	r30, 0x00	; 0
    2b18:	21 05       	cpc	r18, r1
    2b1a:	31 05       	cpc	r19, r1
    2b1c:	99 f1       	breq	.+102    	; 0x2b84 <pow+0x74>
    2b1e:	61 15       	cp	r22, r1
    2b20:	71 05       	cpc	r23, r1
    2b22:	61 f4       	brne	.+24     	; 0x2b3c <pow+0x2c>
    2b24:	80 38       	cpi	r24, 0x80	; 128
    2b26:	bf e3       	ldi	r27, 0x3F	; 63
    2b28:	9b 07       	cpc	r25, r27
    2b2a:	49 f1       	breq	.+82     	; 0x2b7e <pow+0x6e>
    2b2c:	68 94       	set
    2b2e:	90 38       	cpi	r25, 0x80	; 128
    2b30:	81 05       	cpc	r24, r1
    2b32:	61 f0       	breq	.+24     	; 0x2b4c <pow+0x3c>
    2b34:	80 38       	cpi	r24, 0x80	; 128
    2b36:	bf ef       	ldi	r27, 0xFF	; 255
    2b38:	9b 07       	cpc	r25, r27
    2b3a:	41 f0       	breq	.+16     	; 0x2b4c <pow+0x3c>
    2b3c:	99 23       	and	r25, r25
    2b3e:	42 f5       	brpl	.+80     	; 0x2b90 <pow+0x80>
    2b40:	ff 3f       	cpi	r31, 0xFF	; 255
    2b42:	e1 05       	cpc	r30, r1
    2b44:	31 05       	cpc	r19, r1
    2b46:	21 05       	cpc	r18, r1
    2b48:	11 f1       	breq	.+68     	; 0x2b8e <pow+0x7e>
    2b4a:	e8 94       	clt
    2b4c:	08 94       	sec
    2b4e:	e7 95       	ror	r30
    2b50:	d9 01       	movw	r26, r18
    2b52:	aa 23       	and	r26, r26
    2b54:	29 f4       	brne	.+10     	; 0x2b60 <pow+0x50>
    2b56:	ab 2f       	mov	r26, r27
    2b58:	be 2f       	mov	r27, r30
    2b5a:	f8 5f       	subi	r31, 0xF8	; 248
    2b5c:	d0 f3       	brcs	.-12     	; 0x2b52 <pow+0x42>
    2b5e:	10 c0       	rjmp	.+32     	; 0x2b80 <pow+0x70>
    2b60:	ff 5f       	subi	r31, 0xFF	; 255
    2b62:	70 f4       	brcc	.+28     	; 0x2b80 <pow+0x70>
    2b64:	a6 95       	lsr	r26
    2b66:	e0 f7       	brcc	.-8      	; 0x2b60 <pow+0x50>
    2b68:	f7 39       	cpi	r31, 0x97	; 151
    2b6a:	50 f0       	brcs	.+20     	; 0x2b80 <pow+0x70>
    2b6c:	19 f0       	breq	.+6      	; 0x2b74 <pow+0x64>
    2b6e:	ff 3a       	cpi	r31, 0xAF	; 175
    2b70:	38 f4       	brcc	.+14     	; 0x2b80 <pow+0x70>
    2b72:	9f 77       	andi	r25, 0x7F	; 127
    2b74:	9f 93       	push	r25
    2b76:	0c d0       	rcall	.+24     	; 0x2b90 <pow+0x80>
    2b78:	0f 90       	pop	r0
    2b7a:	07 fc       	sbrc	r0, 7
    2b7c:	90 58       	subi	r25, 0x80	; 128
    2b7e:	08 95       	ret
    2b80:	3e f0       	brts	.+14     	; 0x2b90 <pow+0x80>
    2b82:	18 cf       	rjmp	.-464    	; 0x29b4 <__fp_nan>
    2b84:	60 e0       	ldi	r22, 0x00	; 0
    2b86:	70 e0       	ldi	r23, 0x00	; 0
    2b88:	80 e8       	ldi	r24, 0x80	; 128
    2b8a:	9f e3       	ldi	r25, 0x3F	; 63
    2b8c:	08 95       	ret
    2b8e:	4f e7       	ldi	r20, 0x7F	; 127
    2b90:	9f 77       	andi	r25, 0x7F	; 127
    2b92:	5f 93       	push	r21
    2b94:	4f 93       	push	r20
    2b96:	3f 93       	push	r19
    2b98:	2f 93       	push	r18
    2b9a:	9e d0       	rcall	.+316    	; 0x2cd8 <log>
    2b9c:	2f 91       	pop	r18
    2b9e:	3f 91       	pop	r19
    2ba0:	4f 91       	pop	r20
    2ba2:	5f 91       	pop	r21
    2ba4:	52 df       	rcall	.-348    	; 0x2a4a <__mulsf3>
    2ba6:	05 c0       	rjmp	.+10     	; 0x2bb2 <exp>
    2ba8:	19 f4       	brne	.+6      	; 0x2bb0 <pow+0xa0>
    2baa:	0e f0       	brts	.+2      	; 0x2bae <pow+0x9e>
    2bac:	fd ce       	rjmp	.-518    	; 0x29a8 <__fp_inf>
    2bae:	46 cf       	rjmp	.-372    	; 0x2a3c <__fp_zero>
    2bb0:	01 cf       	rjmp	.-510    	; 0x29b4 <__fp_nan>

00002bb2 <exp>:
    2bb2:	2a df       	rcall	.-428    	; 0x2a08 <__fp_splitA>
    2bb4:	c8 f3       	brcs	.-14     	; 0x2ba8 <pow+0x98>
    2bb6:	96 38       	cpi	r25, 0x86	; 134
    2bb8:	c0 f7       	brcc	.-16     	; 0x2baa <pow+0x9a>
    2bba:	07 f8       	bld	r0, 7
    2bbc:	0f 92       	push	r0
    2bbe:	e8 94       	clt
    2bc0:	2b e3       	ldi	r18, 0x3B	; 59
    2bc2:	3a ea       	ldi	r19, 0xAA	; 170
    2bc4:	48 eb       	ldi	r20, 0xB8	; 184
    2bc6:	5f e7       	ldi	r21, 0x7F	; 127
    2bc8:	4e df       	rcall	.-356    	; 0x2a66 <__mulsf3_pse>
    2bca:	0f 92       	push	r0
    2bcc:	0f 92       	push	r0
    2bce:	0f 92       	push	r0
    2bd0:	4d b7       	in	r20, 0x3d	; 61
    2bd2:	5e b7       	in	r21, 0x3e	; 62
    2bd4:	0f 92       	push	r0
    2bd6:	c0 d0       	rcall	.+384    	; 0x2d58 <modf>
    2bd8:	e4 ee       	ldi	r30, 0xE4	; 228
    2bda:	f0 e0       	ldi	r31, 0x00	; 0
    2bdc:	16 d0       	rcall	.+44     	; 0x2c0a <__fp_powser>
    2bde:	4f 91       	pop	r20
    2be0:	5f 91       	pop	r21
    2be2:	ef 91       	pop	r30
    2be4:	ff 91       	pop	r31
    2be6:	e5 95       	asr	r30
    2be8:	ee 1f       	adc	r30, r30
    2bea:	ff 1f       	adc	r31, r31
    2bec:	49 f0       	breq	.+18     	; 0x2c00 <exp+0x4e>
    2bee:	fe 57       	subi	r31, 0x7E	; 126
    2bf0:	e0 68       	ori	r30, 0x80	; 128
    2bf2:	44 27       	eor	r20, r20
    2bf4:	ee 0f       	add	r30, r30
    2bf6:	44 1f       	adc	r20, r20
    2bf8:	fa 95       	dec	r31
    2bfa:	e1 f7       	brne	.-8      	; 0x2bf4 <exp+0x42>
    2bfc:	41 95       	neg	r20
    2bfe:	55 0b       	sbc	r21, r21
    2c00:	32 d0       	rcall	.+100    	; 0x2c66 <ldexp>
    2c02:	0f 90       	pop	r0
    2c04:	07 fe       	sbrs	r0, 7
    2c06:	26 c0       	rjmp	.+76     	; 0x2c54 <inverse>
    2c08:	08 95       	ret

00002c0a <__fp_powser>:
    2c0a:	df 93       	push	r29
    2c0c:	cf 93       	push	r28
    2c0e:	1f 93       	push	r17
    2c10:	0f 93       	push	r16
    2c12:	ff 92       	push	r15
    2c14:	ef 92       	push	r14
    2c16:	df 92       	push	r13
    2c18:	7b 01       	movw	r14, r22
    2c1a:	8c 01       	movw	r16, r24
    2c1c:	68 94       	set
    2c1e:	05 c0       	rjmp	.+10     	; 0x2c2a <__fp_powser+0x20>
    2c20:	da 2e       	mov	r13, r26
    2c22:	ef 01       	movw	r28, r30
    2c24:	1e df       	rcall	.-452    	; 0x2a62 <__mulsf3x>
    2c26:	fe 01       	movw	r30, r28
    2c28:	e8 94       	clt
    2c2a:	a5 91       	lpm	r26, Z+
    2c2c:	25 91       	lpm	r18, Z+
    2c2e:	35 91       	lpm	r19, Z+
    2c30:	45 91       	lpm	r20, Z+
    2c32:	55 91       	lpm	r21, Z+
    2c34:	ae f3       	brts	.-22     	; 0x2c20 <__fp_powser+0x16>
    2c36:	ef 01       	movw	r28, r30
    2c38:	f6 dd       	rcall	.-1044   	; 0x2826 <__addsf3x>
    2c3a:	fe 01       	movw	r30, r28
    2c3c:	97 01       	movw	r18, r14
    2c3e:	a8 01       	movw	r20, r16
    2c40:	da 94       	dec	r13
    2c42:	79 f7       	brne	.-34     	; 0x2c22 <__fp_powser+0x18>
    2c44:	df 90       	pop	r13
    2c46:	ef 90       	pop	r14
    2c48:	ff 90       	pop	r15
    2c4a:	0f 91       	pop	r16
    2c4c:	1f 91       	pop	r17
    2c4e:	cf 91       	pop	r28
    2c50:	df 91       	pop	r29
    2c52:	08 95       	ret

00002c54 <inverse>:
    2c54:	9b 01       	movw	r18, r22
    2c56:	ac 01       	movw	r20, r24
    2c58:	60 e0       	ldi	r22, 0x00	; 0
    2c5a:	70 e0       	ldi	r23, 0x00	; 0
    2c5c:	80 e8       	ldi	r24, 0x80	; 128
    2c5e:	9f e3       	ldi	r25, 0x3F	; 63
    2c60:	ae c0       	rjmp	.+348    	; 0x2dbe <__divsf3>
    2c62:	a2 ce       	rjmp	.-700    	; 0x29a8 <__fp_inf>
    2c64:	14 c1       	rjmp	.+552    	; 0x2e8e <__fp_mpack>

00002c66 <ldexp>:
    2c66:	d0 de       	rcall	.-608    	; 0x2a08 <__fp_splitA>
    2c68:	e8 f3       	brcs	.-6      	; 0x2c64 <inverse+0x10>
    2c6a:	99 23       	and	r25, r25
    2c6c:	d9 f3       	breq	.-10     	; 0x2c64 <inverse+0x10>
    2c6e:	94 0f       	add	r25, r20
    2c70:	51 1d       	adc	r21, r1
    2c72:	bb f3       	brvs	.-18     	; 0x2c62 <inverse+0xe>
    2c74:	91 50       	subi	r25, 0x01	; 1
    2c76:	50 40       	sbci	r21, 0x00	; 0
    2c78:	94 f0       	brlt	.+36     	; 0x2c9e <ldexp+0x38>
    2c7a:	59 f0       	breq	.+22     	; 0x2c92 <ldexp+0x2c>
    2c7c:	88 23       	and	r24, r24
    2c7e:	32 f0       	brmi	.+12     	; 0x2c8c <ldexp+0x26>
    2c80:	66 0f       	add	r22, r22
    2c82:	77 1f       	adc	r23, r23
    2c84:	88 1f       	adc	r24, r24
    2c86:	91 50       	subi	r25, 0x01	; 1
    2c88:	50 40       	sbci	r21, 0x00	; 0
    2c8a:	c1 f7       	brne	.-16     	; 0x2c7c <ldexp+0x16>
    2c8c:	9e 3f       	cpi	r25, 0xFE	; 254
    2c8e:	51 05       	cpc	r21, r1
    2c90:	44 f7       	brge	.-48     	; 0x2c62 <inverse+0xe>
    2c92:	88 0f       	add	r24, r24
    2c94:	91 1d       	adc	r25, r1
    2c96:	96 95       	lsr	r25
    2c98:	87 95       	ror	r24
    2c9a:	97 f9       	bld	r25, 7
    2c9c:	08 95       	ret
    2c9e:	5f 3f       	cpi	r21, 0xFF	; 255
    2ca0:	ac f0       	brlt	.+42     	; 0x2ccc <ldexp+0x66>
    2ca2:	98 3e       	cpi	r25, 0xE8	; 232
    2ca4:	9c f0       	brlt	.+38     	; 0x2ccc <ldexp+0x66>
    2ca6:	bb 27       	eor	r27, r27
    2ca8:	86 95       	lsr	r24
    2caa:	77 95       	ror	r23
    2cac:	67 95       	ror	r22
    2cae:	b7 95       	ror	r27
    2cb0:	08 f4       	brcc	.+2      	; 0x2cb4 <ldexp+0x4e>
    2cb2:	b1 60       	ori	r27, 0x01	; 1
    2cb4:	93 95       	inc	r25
    2cb6:	c1 f7       	brne	.-16     	; 0x2ca8 <ldexp+0x42>
    2cb8:	bb 0f       	add	r27, r27
    2cba:	58 f7       	brcc	.-42     	; 0x2c92 <ldexp+0x2c>
    2cbc:	11 f4       	brne	.+4      	; 0x2cc2 <ldexp+0x5c>
    2cbe:	60 ff       	sbrs	r22, 0
    2cc0:	e8 cf       	rjmp	.-48     	; 0x2c92 <ldexp+0x2c>
    2cc2:	6f 5f       	subi	r22, 0xFF	; 255
    2cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc6:	8f 4f       	sbci	r24, 0xFF	; 255
    2cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    2cca:	e3 cf       	rjmp	.-58     	; 0x2c92 <ldexp+0x2c>
    2ccc:	b8 ce       	rjmp	.-656    	; 0x2a3e <__fp_szero>
    2cce:	0e f0       	brts	.+2      	; 0x2cd2 <ldexp+0x6c>
    2cd0:	de c0       	rjmp	.+444    	; 0x2e8e <__fp_mpack>
    2cd2:	70 ce       	rjmp	.-800    	; 0x29b4 <__fp_nan>
    2cd4:	68 94       	set
    2cd6:	68 ce       	rjmp	.-816    	; 0x29a8 <__fp_inf>

00002cd8 <log>:
    2cd8:	97 de       	rcall	.-722    	; 0x2a08 <__fp_splitA>
    2cda:	c8 f3       	brcs	.-14     	; 0x2cce <ldexp+0x68>
    2cdc:	99 23       	and	r25, r25
    2cde:	d1 f3       	breq	.-12     	; 0x2cd4 <ldexp+0x6e>
    2ce0:	c6 f3       	brts	.-16     	; 0x2cd2 <ldexp+0x6c>
    2ce2:	df 93       	push	r29
    2ce4:	cf 93       	push	r28
    2ce6:	1f 93       	push	r17
    2ce8:	0f 93       	push	r16
    2cea:	ff 92       	push	r15
    2cec:	c9 2f       	mov	r28, r25
    2cee:	dd 27       	eor	r29, r29
    2cf0:	88 23       	and	r24, r24
    2cf2:	2a f0       	brmi	.+10     	; 0x2cfe <log+0x26>
    2cf4:	21 97       	sbiw	r28, 0x01	; 1
    2cf6:	66 0f       	add	r22, r22
    2cf8:	77 1f       	adc	r23, r23
    2cfa:	88 1f       	adc	r24, r24
    2cfc:	da f7       	brpl	.-10     	; 0x2cf4 <log+0x1c>
    2cfe:	20 e0       	ldi	r18, 0x00	; 0
    2d00:	30 e0       	ldi	r19, 0x00	; 0
    2d02:	40 e8       	ldi	r20, 0x80	; 128
    2d04:	5f eb       	ldi	r21, 0xBF	; 191
    2d06:	9f e3       	ldi	r25, 0x3F	; 63
    2d08:	88 39       	cpi	r24, 0x98	; 152
    2d0a:	20 f0       	brcs	.+8      	; 0x2d14 <log+0x3c>
    2d0c:	80 3e       	cpi	r24, 0xE0	; 224
    2d0e:	30 f0       	brcs	.+12     	; 0x2d1c <log+0x44>
    2d10:	21 96       	adiw	r28, 0x01	; 1
    2d12:	8f 77       	andi	r24, 0x7F	; 127
    2d14:	77 dd       	rcall	.-1298   	; 0x2804 <__addsf3>
    2d16:	ec e0       	ldi	r30, 0x0C	; 12
    2d18:	f1 e0       	ldi	r31, 0x01	; 1
    2d1a:	03 c0       	rjmp	.+6      	; 0x2d22 <log+0x4a>
    2d1c:	73 dd       	rcall	.-1306   	; 0x2804 <__addsf3>
    2d1e:	e9 e3       	ldi	r30, 0x39	; 57
    2d20:	f1 e0       	ldi	r31, 0x01	; 1
    2d22:	73 df       	rcall	.-282    	; 0x2c0a <__fp_powser>
    2d24:	8b 01       	movw	r16, r22
    2d26:	be 01       	movw	r22, r28
    2d28:	ec 01       	movw	r28, r24
    2d2a:	fb 2e       	mov	r15, r27
    2d2c:	6f 57       	subi	r22, 0x7F	; 127
    2d2e:	71 09       	sbc	r23, r1
    2d30:	75 95       	asr	r23
    2d32:	77 1f       	adc	r23, r23
    2d34:	88 0b       	sbc	r24, r24
    2d36:	99 0b       	sbc	r25, r25
    2d38:	fc dd       	rcall	.-1032   	; 0x2932 <__floatsisf>
    2d3a:	28 e1       	ldi	r18, 0x18	; 24
    2d3c:	32 e7       	ldi	r19, 0x72	; 114
    2d3e:	41 e3       	ldi	r20, 0x31	; 49
    2d40:	5f e3       	ldi	r21, 0x3F	; 63
    2d42:	8f de       	rcall	.-738    	; 0x2a62 <__mulsf3x>
    2d44:	af 2d       	mov	r26, r15
    2d46:	98 01       	movw	r18, r16
    2d48:	ae 01       	movw	r20, r28
    2d4a:	ff 90       	pop	r15
    2d4c:	0f 91       	pop	r16
    2d4e:	1f 91       	pop	r17
    2d50:	cf 91       	pop	r28
    2d52:	df 91       	pop	r29
    2d54:	68 dd       	rcall	.-1328   	; 0x2826 <__addsf3x>
    2d56:	3f ce       	rjmp	.-898    	; 0x29d6 <__fp_round>

00002d58 <modf>:
    2d58:	fa 01       	movw	r30, r20
    2d5a:	dc 01       	movw	r26, r24
    2d5c:	aa 0f       	add	r26, r26
    2d5e:	bb 1f       	adc	r27, r27
    2d60:	9b 01       	movw	r18, r22
    2d62:	ac 01       	movw	r20, r24
    2d64:	bf 57       	subi	r27, 0x7F	; 127
    2d66:	28 f4       	brcc	.+10     	; 0x2d72 <modf+0x1a>
    2d68:	22 27       	eor	r18, r18
    2d6a:	33 27       	eor	r19, r19
    2d6c:	44 27       	eor	r20, r20
    2d6e:	50 78       	andi	r21, 0x80	; 128
    2d70:	1f c0       	rjmp	.+62     	; 0x2db0 <modf+0x58>
    2d72:	b7 51       	subi	r27, 0x17	; 23
    2d74:	88 f4       	brcc	.+34     	; 0x2d98 <modf+0x40>
    2d76:	ab 2f       	mov	r26, r27
    2d78:	00 24       	eor	r0, r0
    2d7a:	46 95       	lsr	r20
    2d7c:	37 95       	ror	r19
    2d7e:	27 95       	ror	r18
    2d80:	01 1c       	adc	r0, r1
    2d82:	a3 95       	inc	r26
    2d84:	d2 f3       	brmi	.-12     	; 0x2d7a <modf+0x22>
    2d86:	00 20       	and	r0, r0
    2d88:	69 f0       	breq	.+26     	; 0x2da4 <modf+0x4c>
    2d8a:	22 0f       	add	r18, r18
    2d8c:	33 1f       	adc	r19, r19
    2d8e:	44 1f       	adc	r20, r20
    2d90:	b3 95       	inc	r27
    2d92:	da f3       	brmi	.-10     	; 0x2d8a <modf+0x32>
    2d94:	0d d0       	rcall	.+26     	; 0x2db0 <modf+0x58>
    2d96:	35 cd       	rjmp	.-1430   	; 0x2802 <__subsf3>
    2d98:	61 30       	cpi	r22, 0x01	; 1
    2d9a:	71 05       	cpc	r23, r1
    2d9c:	a0 e8       	ldi	r26, 0x80	; 128
    2d9e:	8a 07       	cpc	r24, r26
    2da0:	b9 46       	sbci	r27, 0x69	; 105
    2da2:	30 f4       	brcc	.+12     	; 0x2db0 <modf+0x58>
    2da4:	9b 01       	movw	r18, r22
    2da6:	ac 01       	movw	r20, r24
    2da8:	66 27       	eor	r22, r22
    2daa:	77 27       	eor	r23, r23
    2dac:	88 27       	eor	r24, r24
    2dae:	90 78       	andi	r25, 0x80	; 128
    2db0:	30 96       	adiw	r30, 0x00	; 0
    2db2:	21 f0       	breq	.+8      	; 0x2dbc <modf+0x64>
    2db4:	20 83       	st	Z, r18
    2db6:	31 83       	std	Z+1, r19	; 0x01
    2db8:	42 83       	std	Z+2, r20	; 0x02
    2dba:	53 83       	std	Z+3, r21	; 0x03
    2dbc:	08 95       	ret

00002dbe <__divsf3>:
    2dbe:	0c d0       	rcall	.+24     	; 0x2dd8 <__divsf3x>
    2dc0:	0a ce       	rjmp	.-1004   	; 0x29d6 <__fp_round>
    2dc2:	02 de       	rcall	.-1020   	; 0x29c8 <__fp_pscB>
    2dc4:	40 f0       	brcs	.+16     	; 0x2dd6 <__divsf3+0x18>
    2dc6:	f9 dd       	rcall	.-1038   	; 0x29ba <__fp_pscA>
    2dc8:	30 f0       	brcs	.+12     	; 0x2dd6 <__divsf3+0x18>
    2dca:	21 f4       	brne	.+8      	; 0x2dd4 <__divsf3+0x16>
    2dcc:	5f 3f       	cpi	r21, 0xFF	; 255
    2dce:	19 f0       	breq	.+6      	; 0x2dd6 <__divsf3+0x18>
    2dd0:	eb cd       	rjmp	.-1066   	; 0x29a8 <__fp_inf>
    2dd2:	51 11       	cpse	r21, r1
    2dd4:	34 ce       	rjmp	.-920    	; 0x2a3e <__fp_szero>
    2dd6:	ee cd       	rjmp	.-1060   	; 0x29b4 <__fp_nan>

00002dd8 <__divsf3x>:
    2dd8:	0f de       	rcall	.-994    	; 0x29f8 <__fp_split3>
    2dda:	98 f3       	brcs	.-26     	; 0x2dc2 <__divsf3+0x4>

00002ddc <__divsf3_pse>:
    2ddc:	99 23       	and	r25, r25
    2dde:	c9 f3       	breq	.-14     	; 0x2dd2 <__divsf3+0x14>
    2de0:	55 23       	and	r21, r21
    2de2:	b1 f3       	breq	.-20     	; 0x2dd0 <__divsf3+0x12>
    2de4:	95 1b       	sub	r25, r21
    2de6:	55 0b       	sbc	r21, r21
    2de8:	bb 27       	eor	r27, r27
    2dea:	aa 27       	eor	r26, r26
    2dec:	62 17       	cp	r22, r18
    2dee:	73 07       	cpc	r23, r19
    2df0:	84 07       	cpc	r24, r20
    2df2:	38 f0       	brcs	.+14     	; 0x2e02 <__divsf3_pse+0x26>
    2df4:	9f 5f       	subi	r25, 0xFF	; 255
    2df6:	5f 4f       	sbci	r21, 0xFF	; 255
    2df8:	22 0f       	add	r18, r18
    2dfa:	33 1f       	adc	r19, r19
    2dfc:	44 1f       	adc	r20, r20
    2dfe:	aa 1f       	adc	r26, r26
    2e00:	a9 f3       	breq	.-22     	; 0x2dec <__divsf3_pse+0x10>
    2e02:	33 d0       	rcall	.+102    	; 0x2e6a <__divsf3_pse+0x8e>
    2e04:	0e 2e       	mov	r0, r30
    2e06:	3a f0       	brmi	.+14     	; 0x2e16 <__divsf3_pse+0x3a>
    2e08:	e0 e8       	ldi	r30, 0x80	; 128
    2e0a:	30 d0       	rcall	.+96     	; 0x2e6c <__divsf3_pse+0x90>
    2e0c:	91 50       	subi	r25, 0x01	; 1
    2e0e:	50 40       	sbci	r21, 0x00	; 0
    2e10:	e6 95       	lsr	r30
    2e12:	00 1c       	adc	r0, r0
    2e14:	ca f7       	brpl	.-14     	; 0x2e08 <__divsf3_pse+0x2c>
    2e16:	29 d0       	rcall	.+82     	; 0x2e6a <__divsf3_pse+0x8e>
    2e18:	fe 2f       	mov	r31, r30
    2e1a:	27 d0       	rcall	.+78     	; 0x2e6a <__divsf3_pse+0x8e>
    2e1c:	66 0f       	add	r22, r22
    2e1e:	77 1f       	adc	r23, r23
    2e20:	88 1f       	adc	r24, r24
    2e22:	bb 1f       	adc	r27, r27
    2e24:	26 17       	cp	r18, r22
    2e26:	37 07       	cpc	r19, r23
    2e28:	48 07       	cpc	r20, r24
    2e2a:	ab 07       	cpc	r26, r27
    2e2c:	b0 e8       	ldi	r27, 0x80	; 128
    2e2e:	09 f0       	breq	.+2      	; 0x2e32 <__divsf3_pse+0x56>
    2e30:	bb 0b       	sbc	r27, r27
    2e32:	80 2d       	mov	r24, r0
    2e34:	bf 01       	movw	r22, r30
    2e36:	ff 27       	eor	r31, r31
    2e38:	93 58       	subi	r25, 0x83	; 131
    2e3a:	5f 4f       	sbci	r21, 0xFF	; 255
    2e3c:	2a f0       	brmi	.+10     	; 0x2e48 <__divsf3_pse+0x6c>
    2e3e:	9e 3f       	cpi	r25, 0xFE	; 254
    2e40:	51 05       	cpc	r21, r1
    2e42:	68 f0       	brcs	.+26     	; 0x2e5e <__divsf3_pse+0x82>
    2e44:	b1 cd       	rjmp	.-1182   	; 0x29a8 <__fp_inf>
    2e46:	fb cd       	rjmp	.-1034   	; 0x2a3e <__fp_szero>
    2e48:	5f 3f       	cpi	r21, 0xFF	; 255
    2e4a:	ec f3       	brlt	.-6      	; 0x2e46 <__divsf3_pse+0x6a>
    2e4c:	98 3e       	cpi	r25, 0xE8	; 232
    2e4e:	dc f3       	brlt	.-10     	; 0x2e46 <__divsf3_pse+0x6a>
    2e50:	86 95       	lsr	r24
    2e52:	77 95       	ror	r23
    2e54:	67 95       	ror	r22
    2e56:	b7 95       	ror	r27
    2e58:	f7 95       	ror	r31
    2e5a:	9f 5f       	subi	r25, 0xFF	; 255
    2e5c:	c9 f7       	brne	.-14     	; 0x2e50 <__divsf3_pse+0x74>
    2e5e:	88 0f       	add	r24, r24
    2e60:	91 1d       	adc	r25, r1
    2e62:	96 95       	lsr	r25
    2e64:	87 95       	ror	r24
    2e66:	97 f9       	bld	r25, 7
    2e68:	08 95       	ret
    2e6a:	e1 e0       	ldi	r30, 0x01	; 1
    2e6c:	66 0f       	add	r22, r22
    2e6e:	77 1f       	adc	r23, r23
    2e70:	88 1f       	adc	r24, r24
    2e72:	bb 1f       	adc	r27, r27
    2e74:	62 17       	cp	r22, r18
    2e76:	73 07       	cpc	r23, r19
    2e78:	84 07       	cpc	r24, r20
    2e7a:	ba 07       	cpc	r27, r26
    2e7c:	20 f0       	brcs	.+8      	; 0x2e86 <__divsf3_pse+0xaa>
    2e7e:	62 1b       	sub	r22, r18
    2e80:	73 0b       	sbc	r23, r19
    2e82:	84 0b       	sbc	r24, r20
    2e84:	ba 0b       	sbc	r27, r26
    2e86:	ee 1f       	adc	r30, r30
    2e88:	88 f7       	brcc	.-30     	; 0x2e6c <__divsf3_pse+0x90>
    2e8a:	e0 95       	com	r30
    2e8c:	08 95       	ret

00002e8e <__fp_mpack>:
    2e8e:	9f 3f       	cpi	r25, 0xFF	; 255
    2e90:	31 f0       	breq	.+12     	; 0x2e9e <__fp_mpack_finite+0xc>

00002e92 <__fp_mpack_finite>:
    2e92:	91 50       	subi	r25, 0x01	; 1
    2e94:	20 f4       	brcc	.+8      	; 0x2e9e <__fp_mpack_finite+0xc>
    2e96:	87 95       	ror	r24
    2e98:	77 95       	ror	r23
    2e9a:	67 95       	ror	r22
    2e9c:	b7 95       	ror	r27
    2e9e:	88 0f       	add	r24, r24
    2ea0:	91 1d       	adc	r25, r1
    2ea2:	96 95       	lsr	r25
    2ea4:	87 95       	ror	r24
    2ea6:	97 f9       	bld	r25, 7
    2ea8:	08 95       	ret

00002eaa <__divmodhi4>:
    2eaa:	97 fb       	bst	r25, 7
    2eac:	07 2e       	mov	r0, r23
    2eae:	16 f4       	brtc	.+4      	; 0x2eb4 <__divmodhi4+0xa>
    2eb0:	00 94       	com	r0
    2eb2:	06 d0       	rcall	.+12     	; 0x2ec0 <__divmodhi4_neg1>
    2eb4:	77 fd       	sbrc	r23, 7
    2eb6:	08 d0       	rcall	.+16     	; 0x2ec8 <__divmodhi4_neg2>
    2eb8:	0b d0       	rcall	.+22     	; 0x2ed0 <__udivmodhi4>
    2eba:	07 fc       	sbrc	r0, 7
    2ebc:	05 d0       	rcall	.+10     	; 0x2ec8 <__divmodhi4_neg2>
    2ebe:	3e f4       	brtc	.+14     	; 0x2ece <__divmodhi4_exit>

00002ec0 <__divmodhi4_neg1>:
    2ec0:	90 95       	com	r25
    2ec2:	81 95       	neg	r24
    2ec4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ec6:	08 95       	ret

00002ec8 <__divmodhi4_neg2>:
    2ec8:	70 95       	com	r23
    2eca:	61 95       	neg	r22
    2ecc:	7f 4f       	sbci	r23, 0xFF	; 255

00002ece <__divmodhi4_exit>:
    2ece:	08 95       	ret

00002ed0 <__udivmodhi4>:
    2ed0:	aa 1b       	sub	r26, r26
    2ed2:	bb 1b       	sub	r27, r27
    2ed4:	51 e1       	ldi	r21, 0x11	; 17
    2ed6:	07 c0       	rjmp	.+14     	; 0x2ee6 <__udivmodhi4_ep>

00002ed8 <__udivmodhi4_loop>:
    2ed8:	aa 1f       	adc	r26, r26
    2eda:	bb 1f       	adc	r27, r27
    2edc:	a6 17       	cp	r26, r22
    2ede:	b7 07       	cpc	r27, r23
    2ee0:	10 f0       	brcs	.+4      	; 0x2ee6 <__udivmodhi4_ep>
    2ee2:	a6 1b       	sub	r26, r22
    2ee4:	b7 0b       	sbc	r27, r23

00002ee6 <__udivmodhi4_ep>:
    2ee6:	88 1f       	adc	r24, r24
    2ee8:	99 1f       	adc	r25, r25
    2eea:	5a 95       	dec	r21
    2eec:	a9 f7       	brne	.-22     	; 0x2ed8 <__udivmodhi4_loop>
    2eee:	80 95       	com	r24
    2ef0:	90 95       	com	r25
    2ef2:	bc 01       	movw	r22, r24
    2ef4:	cd 01       	movw	r24, r26
    2ef6:	08 95       	ret

00002ef8 <memcpy>:
    2ef8:	fb 01       	movw	r30, r22
    2efa:	dc 01       	movw	r26, r24
    2efc:	02 c0       	rjmp	.+4      	; 0x2f02 <memcpy+0xa>
    2efe:	01 90       	ld	r0, Z+
    2f00:	0d 92       	st	X+, r0
    2f02:	41 50       	subi	r20, 0x01	; 1
    2f04:	50 40       	sbci	r21, 0x00	; 0
    2f06:	d8 f7       	brcc	.-10     	; 0x2efe <memcpy+0x6>
    2f08:	08 95       	ret

00002f0a <_exit>:
    2f0a:	f8 94       	cli

00002f0c <__stop_program>:
    2f0c:	ff cf       	rjmp	.-2      	; 0x2f0c <__stop_program>
