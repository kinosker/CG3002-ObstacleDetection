
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800200  00002e4e  00002ee2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e4e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000708  00800236  00800236  00002f18  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f18  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002f48  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000606c  00000000  00000000  000034b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000163b  00000000  00000000  00009524  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003a33  00000000  00000000  0000ab5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000fb4  00000000  00000000  0000e594  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017ff  00000000  00000000  0000f548  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000457d  00000000  00000000  00010d47  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  000152c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	d4 c3       	rjmp	.+1960   	; 0x7ce <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 fd 0a 	jmp	0x15fa	; 0x15fa <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	97 c7       	rjmp	.+3886   	; 0xf94 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 42 08 	jmp	0x1084	; 0x1084 <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	b1 c4       	rjmp	.+2402   	; 0x9d8 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c7       	rjmp	.+3730   	; 0xf24 <__vector_36>
      92:	00 00       	nop
      94:	b7 c7       	rjmp	.+3950   	; 0x1004 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x6>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ee e4       	ldi	r30, 0x4E	; 78
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 33       	cpi	r26, 0x36	; 54
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a6 e3       	ldi	r26, 0x36	; 54
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	ae 33       	cpi	r26, 0x3E	; 62
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	d9 d0       	rcall	.+434    	; 0x354 <main>
     1a2:	0c 94 25 17 	jmp	0x2e4a	; 0x2e4a <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 34 09 	call	0x1268	; 0x1268 <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 74 09 	call	0x12e8	; 0x12e8 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 69 09 	call	0x12d2	; 0x12d2 <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 86 09 	call	0x130c	; 0x130c <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 36 02 	lds	r24, 0x0236
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 f7 08 	call	0x11ee	; 0x11ee <myUSART_transmitUSART1_c>
     1e2:	d0 93 36 02 	sts	0x0236, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 80 09 	call	0x1300	; 0x1300 <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 36 02 	sts	0x0236, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 36 02 	sts	0x0236, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 36 02 	sts	0x0236, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 55 09 	call	0x12aa	; 0x12aa <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 8c 08 	lds	r24, 0x088C
     232:	90 91 8d 08 	lds	r25, 0x088D
     236:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xQueueGenericReceive>
     23a:	25 c0       	rjmp	.+74     	; 0x286 <RPI_sendTask+0x76>
     23c:	20 e0       	ldi	r18, 0x00	; 0
     23e:	4f ef       	ldi	r20, 0xFF	; 255
     240:	5f ef       	ldi	r21, 0xFF	; 255
     242:	be 01       	movw	r22, r28
     244:	6f 5f       	subi	r22, 0xFF	; 255
     246:	7f 4f       	sbci	r23, 0xFF	; 255
     248:	80 91 8e 08 	lds	r24, 0x088E
     24c:	90 91 8f 08 	lds	r25, 0x088F
     250:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <xQueueGenericReceive>
     254:	89 81       	ldd	r24, Y+1	; 0x01
     256:	aa d7       	rcall	.+3924   	; 0x11ac <myUSART_transmitUSART0_c>
     258:	87 e0       	ldi	r24, 0x07	; 7
     25a:	92 e0       	ldi	r25, 0x02	; 2
     25c:	f7 d7       	rcall	.+4078   	; 0x124c <myUSART_transmitUSART0>
     25e:	ce 01       	movw	r24, r28
     260:	02 96       	adiw	r24, 0x02	; 2
     262:	f4 d7       	rcall	.+4072   	; 0x124c <myUSART_transmitUSART0>
     264:	89 e0       	ldi	r24, 0x09	; 9
     266:	92 e0       	ldi	r25, 0x02	; 2
     268:	f1 d7       	rcall	.+4066   	; 0x124c <myUSART_transmitUSART0>
     26a:	11 23       	and	r17, r17
     26c:	61 f0       	breq	.+24     	; 0x286 <RPI_sendTask+0x76>
     26e:	8e 81       	ldd	r24, Y+6	; 0x06
     270:	80 5d       	subi	r24, 0xD0	; 208
     272:	bd d7       	rcall	.+3962   	; 0x11ee <myUSART_transmitUSART1_c>
     274:	8a e0       	ldi	r24, 0x0A	; 10
     276:	bb d7       	rcall	.+3958   	; 0x11ee <myUSART_transmitUSART1_c>
     278:	89 81       	ldd	r24, Y+1	; 0x01
     27a:	b9 d7       	rcall	.+3954   	; 0x11ee <myUSART_transmitUSART1_c>
     27c:	ce 01       	movw	r24, r28
     27e:	02 96       	adiw	r24, 0x02	; 2
     280:	d7 d7       	rcall	.+4014   	; 0x1230 <myUSART_transmitUSART1>
     282:	8a e0       	ldi	r24, 0x0A	; 10
     284:	b4 d7       	rcall	.+3944   	; 0x11ee <myUSART_transmitUSART1_c>
     286:	9e 81       	ldd	r25, Y+6	; 0x06
     288:	2f ef       	ldi	r18, 0xFF	; 255
     28a:	29 0f       	add	r18, r25
     28c:	2e 83       	std	Y+6, r18	; 0x06
     28e:	91 11       	cpse	r25, r1
     290:	d5 cf       	rjmp	.-86     	; 0x23c <RPI_sendTask+0x2c>
     292:	8a e0       	ldi	r24, 0x0A	; 10
     294:	8b d7       	rcall	.+3862   	; 0x11ac <myUSART_transmitUSART0_c>
     296:	c2 cf       	rjmp	.-124    	; 0x21c <RPI_sendTask+0xc>

00000298 <myTimerTask>:
     298:	ba d5       	rcall	.+2932   	; 0xe0e <myTimer_Init>
     29a:	d5 d5       	rcall	.+2986   	; 0xe46 <myTimer_DelayChecker>
     29c:	fe cf       	rjmp	.-4      	; 0x29a <myTimerTask+0x2>

0000029e <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     29e:	8f ef       	ldi	r24, 0xFF	; 255
     2a0:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2a4:	ef e7       	ldi	r30, 0x7F	; 127
     2a6:	f0 e0       	ldi	r31, 0x00	; 0
     2a8:	90 81       	ld	r25, Z
     2aa:	93 60       	ori	r25, 0x03	; 3
     2ac:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2ae:	80 93 7d 00 	sts	0x007D, r24
     2b2:	08 95       	ret

000002b4 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2b4:	8c ec       	ldi	r24, 0xCC	; 204
     2b6:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2ba:	8e e3       	ldi	r24, 0x3E	; 62
     2bc:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2c0:	ee cf       	rjmp	.-36     	; 0x29e <setDigitalInputPowerReduction>
     2c2:	08 95       	ret

000002c4 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2c4:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2c8:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2cc:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2d0:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2d4:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2d8:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2dc:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2e0:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2e4:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2e8:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2ec:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2f0:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2f4:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2f8:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2fc:	10 92 73 00 	sts	0x0073, r1
     300:	08 95       	ret

00000302 <init>:
}

void init()
{
     302:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     304:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     306:	f8 94       	cli
	{
		clearTimer();
     308:	dd df       	rcall	.-70     	; 0x2c4 <clearTimer>
		setPowerReduction();
     30a:	d4 df       	rcall	.-88     	; 0x2b4 <setPowerReduction>
		myUSART_USART0_Init();
     30c:	fb d6       	rcall	.+3574   	; 0x1104 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     30e:	20 d7       	rcall	.+3648   	; 0x1150 <myUSART_USART1_Init>
		myADC_Init();
     310:	9b d3       	rcall	.+1846   	; 0xa48 <myADC_Init>
		
		MaxSonar_Init();
     312:	83 b3       	in	r24, 0x13	; 19
     314:	83 60       	ori	r24, 0x03	; 3
     316:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     318:	40 e0       	ldi	r20, 0x00	; 0
     31a:	61 e0       	ldi	r22, 0x01	; 1
     31c:	85 e0       	ldi	r24, 0x05	; 5
     31e:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <xQueueGenericCreate>
     322:	90 93 8d 08 	sts	0x088D, r25
     326:	80 93 8c 08 	sts	0x088C, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SENSOR_NUM), sizeof (obstacleStruct)); // create queue
     32a:	40 e0       	ldi	r20, 0x00	; 0
     32c:	65 e0       	ldi	r22, 0x05	; 5
     32e:	8e e1       	ldi	r24, 0x1E	; 30
     330:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <xQueueGenericCreate>
     334:	90 93 8f 08 	sts	0x088F, r25
     338:	80 93 8e 08 	sts	0x088E, r24
		
		MOTOR_LEFT_INIT();
     33c:	8d b1       	in	r24, 0x0d	; 13
     33e:	88 61       	ori	r24, 0x18	; 24
     340:	8d b9       	out	0x0d, r24	; 13
		MOTOR_RIGHT_INIT();
     342:	e1 e0       	ldi	r30, 0x01	; 1
     344:	f1 e0       	ldi	r31, 0x01	; 1
     346:	80 81       	ld	r24, Z
     348:	80 61       	ori	r24, 0x10	; 16
     34a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     34c:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     34e:	78 94       	sei
}
     350:	cf 91       	pop	r28
     352:	08 95       	ret

00000354 <main>:
	
	// do nth
}

int main(void)
{
     354:	cf 93       	push	r28
     356:	df 93       	push	r29
     358:	cd b7       	in	r28, 0x3d	; 61
     35a:	de b7       	in	r29, 0x3e	; 62
     35c:	28 97       	sbiw	r28, 0x08	; 8
     35e:	0f b6       	in	r0, 0x3f	; 63
     360:	f8 94       	cli
     362:	de bf       	out	0x3e, r29	; 62
     364:	0f be       	out	0x3f, r0	; 63
     366:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     368:	cc df       	rcall	.-104    	; 0x302 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     36a:	a1 2c       	mov	r10, r1
     36c:	b1 2c       	mov	r11, r1
     36e:	c1 2c       	mov	r12, r1
     370:	d1 2c       	mov	r13, r1
     372:	ce 01       	movw	r24, r28
     374:	01 96       	adiw	r24, 0x01	; 1
     376:	7c 01       	movw	r14, r24
     378:	04 e0       	ldi	r16, 0x04	; 4
     37a:	9c 01       	movw	r18, r24
     37c:	49 e6       	ldi	r20, 0x69	; 105
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	6b e0       	ldi	r22, 0x0B	; 11
     382:	72 e0       	ldi	r23, 0x02	; 2
     384:	8c e4       	ldi	r24, 0x4C	; 76
     386:	91 e0       	ldi	r25, 0x01	; 1
     388:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     38c:	ce 01       	movw	r24, r28
     38e:	07 96       	adiw	r24, 0x07	; 7
     390:	7c 01       	movw	r14, r24
     392:	03 e0       	ldi	r16, 0x03	; 3
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	4d e6       	ldi	r20, 0x6D	; 109
     39a:	51 e0       	ldi	r21, 0x01	; 1
     39c:	63 e1       	ldi	r22, 0x13	; 19
     39e:	72 e0       	ldi	r23, 0x02	; 2
     3a0:	88 e8       	ldi	r24, 0x88	; 136
     3a2:	92 e0       	ldi	r25, 0x02	; 2
     3a4:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a8:	ce 01       	movw	r24, r28
     3aa:	05 96       	adiw	r24, 0x05	; 5
     3ac:	7c 01       	movw	r14, r24
     3ae:	01 e0       	ldi	r16, 0x01	; 1
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	47 e8       	ldi	r20, 0x87	; 135
     3b6:	50 e0       	ldi	r21, 0x00	; 0
     3b8:	6c e1       	ldi	r22, 0x1C	; 28
     3ba:	72 e0       	ldi	r23, 0x02	; 2
     3bc:	84 ed       	ldi	r24, 0xD4	; 212
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3c4:	ce 01       	movw	r24, r28
     3c6:	03 96       	adiw	r24, 0x03	; 3
     3c8:	7c 01       	movw	r14, r24
     3ca:	02 e0       	ldi	r16, 0x02	; 2
     3cc:	20 e0       	ldi	r18, 0x00	; 0
     3ce:	30 e0       	ldi	r19, 0x00	; 0
     3d0:	47 e8       	ldi	r20, 0x87	; 135
     3d2:	50 e0       	ldi	r21, 0x00	; 0
     3d4:	68 e2       	ldi	r22, 0x28	; 40
     3d6:	72 e0       	ldi	r23, 0x02	; 2
     3d8:	88 e0       	ldi	r24, 0x08	; 8
     3da:	91 e0       	ldi	r25, 0x01	; 1
     3dc:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3e0:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <vTaskStartScheduler>
     3e4:	c1 cf       	rjmp	.-126    	; 0x368 <main+0x14>

000003e6 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3e6:	9c 01       	movw	r18, r24
     3e8:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3ea:	64 e6       	ldi	r22, 0x64	; 100
     3ec:	70 e0       	ldi	r23, 0x00	; 0
     3ee:	0e 94 f5 16 	call	0x2dea	; 0x2dea <__divmodhi4>
	
	if(input)
     3f2:	61 15       	cp	r22, r1
     3f4:	71 05       	cpc	r23, r1
     3f6:	21 f0       	breq	.+8      	; 0x400 <myItoa+0x1a>
		*buffer++ = input + '0';
     3f8:	80 e3       	ldi	r24, 0x30	; 48
     3fa:	86 0f       	add	r24, r22
     3fc:	80 83       	st	Z, r24
     3fe:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     400:	4c e9       	ldi	r20, 0x9C	; 156
     402:	46 03       	mulsu	r20, r22
     404:	c0 01       	movw	r24, r0
     406:	47 9f       	mul	r20, r23
     408:	90 0d       	add	r25, r0
     40a:	11 24       	eor	r1, r1
     40c:	28 0f       	add	r18, r24
     40e:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     410:	c9 01       	movw	r24, r18
     412:	6a e0       	ldi	r22, 0x0A	; 10
     414:	70 e0       	ldi	r23, 0x00	; 0
     416:	0e 94 f5 16 	call	0x2dea	; 0x2dea <__divmodhi4>
	*buffer++ = input + '0';
     41a:	80 e3       	ldi	r24, 0x30	; 48
     41c:	86 0f       	add	r24, r22
     41e:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     420:	8a e0       	ldi	r24, 0x0A	; 10
     422:	68 9f       	mul	r22, r24
     424:	20 19       	sub	r18, r0
     426:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     428:	20 5d       	subi	r18, 0xD0	; 208
     42a:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     42c:	12 82       	std	Z+2, r1	; 0x02
     42e:	08 95       	ret

00000430 <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{	
     430:	1f 93       	push	r17
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	00 d0       	rcall	.+0      	; 0x438 <obstacleSend+0x8>
     438:	1f 92       	push	r1
     43a:	1f 92       	push	r1
     43c:	cd b7       	in	r28, 0x3d	; 61
     43e:	de b7       	in	r29, 0x3e	; 62
     440:	18 2f       	mov	r17, r24
     442:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
		
	if(deviceBlocked)
     444:	11 23       	and	r17, r17
     446:	89 f0       	breq	.+34     	; 0x46a <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     448:	be 01       	movw	r22, r28
     44a:	6e 5f       	subi	r22, 0xFE	; 254
     44c:	7f 4f       	sbci	r23, 0xFF	; 255
     44e:	cb df       	rcall	.-106    	; 0x3e6 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     450:	19 83       	std	Y+1, r17	; 0x01
		
		
		xQueueSendToBack(queueObstacleData, (void*) &obstacleInfo, portMAX_DELAY); // send data to queueData
     452:	20 e0       	ldi	r18, 0x00	; 0
     454:	4f ef       	ldi	r20, 0xFF	; 255
     456:	5f ef       	ldi	r21, 0xFF	; 255
     458:	be 01       	movw	r22, r28
     45a:	6f 5f       	subi	r22, 0xFF	; 255
     45c:	7f 4f       	sbci	r23, 0xFF	; 255
     45e:	80 91 8e 08 	lds	r24, 0x088E
     462:	90 91 8f 08 	lds	r25, 0x088F
     466:	0e 94 29 0c 	call	0x1852	; 0x1852 <xQueueGenericSend>
	}
}
     46a:	0f 90       	pop	r0
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	1f 91       	pop	r17
     47a:	08 95       	ret

0000047c <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar, int topIR)
{	
     47c:	6f 92       	push	r6
     47e:	7f 92       	push	r7
     480:	8f 92       	push	r8
     482:	9f 92       	push	r9
     484:	af 92       	push	r10
     486:	bf 92       	push	r11
     488:	cf 92       	push	r12
     48a:	df 92       	push	r13
     48c:	ef 92       	push	r14
     48e:	ff 92       	push	r15
     490:	0f 93       	push	r16
     492:	1f 93       	push	r17
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
     498:	1f 92       	push	r1
     49a:	cd b7       	in	r28, 0x3d	; 61
     49c:	de b7       	in	r29, 0x3e	; 62
     49e:	89 83       	std	Y+1, r24	; 0x01
     4a0:	4b 01       	movw	r8, r22
     4a2:	39 01       	movw	r6, r18
	
	if(obstacleDetected > 0)
     4a4:	88 23       	and	r24, r24
     4a6:	21 f1       	breq	.+72     	; 0x4f0 <sendObstacleDetected+0x74>
	{
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4a8:	ba 01       	movw	r22, r20
     4aa:	f4 01       	movw	r30, r8
     4ac:	80 81       	ld	r24, Z
     4ae:	c0 df       	rcall	.-128    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4b0:	b3 01       	movw	r22, r6
     4b2:	f4 01       	movw	r30, r8
     4b4:	81 81       	ldd	r24, Z+1	; 0x01
     4b6:	bc df       	rcall	.-136    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4b8:	b8 01       	movw	r22, r16
     4ba:	f4 01       	movw	r30, r8
     4bc:	82 81       	ldd	r24, Z+2	; 0x02
     4be:	b8 df       	rcall	.-144    	; 0x430 <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4c0:	b7 01       	movw	r22, r14
     4c2:	f4 01       	movw	r30, r8
     4c4:	83 81       	ldd	r24, Z+3	; 0x03
     4c6:	b4 df       	rcall	.-152    	; 0x430 <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4c8:	b6 01       	movw	r22, r12
     4ca:	f4 01       	movw	r30, r8
     4cc:	84 81       	ldd	r24, Z+4	; 0x04
     4ce:	b0 df       	rcall	.-160    	; 0x430 <obstacleSend>
		
		obstacleSend(deviceBlocked[HIGH_DEVICE], topIR);
     4d0:	b5 01       	movw	r22, r10
     4d2:	f4 01       	movw	r30, r8
     4d4:	85 81       	ldd	r24, Z+5	; 0x05
     4d6:	ac df       	rcall	.-168    	; 0x430 <obstacleSend>
				//myUSART_transmitUSART0("p\n");
				//myUSART_transmitUSART0_c(totalObs + '0');
				//myUSART_transmitUSART0("M\n");
			//}
			
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4d8:	20 e0       	ldi	r18, 0x00	; 0
     4da:	4f ef       	ldi	r20, 0xFF	; 255
     4dc:	5f ef       	ldi	r21, 0xFF	; 255
     4de:	be 01       	movw	r22, r28
     4e0:	6f 5f       	subi	r22, 0xFF	; 255
     4e2:	7f 4f       	sbci	r23, 0xFF	; 255
     4e4:	80 91 8c 08 	lds	r24, 0x088C
     4e8:	90 91 8d 08 	lds	r25, 0x088D
     4ec:	0e 94 29 0c 	call	0x1852	; 0x1852 <xQueueGenericSend>
		
	}
}
     4f0:	0f 90       	pop	r0
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	ff 90       	pop	r15
     4fc:	ef 90       	pop	r14
     4fe:	df 90       	pop	r13
     500:	cf 90       	pop	r12
     502:	bf 90       	pop	r11
     504:	af 90       	pop	r10
     506:	9f 90       	pop	r9
     508:	8f 90       	pop	r8
     50a:	7f 90       	pop	r7
     50c:	6f 90       	pop	r6
     50e:	08 95       	ret

00000510 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     510:	cf 93       	push	r28
     512:	df 93       	push	r29
     514:	cd b7       	in	r28, 0x3d	; 61
     516:	de b7       	in	r29, 0x3e	; 62
     518:	ac 97       	sbiw	r28, 0x2c	; 44
     51a:	0f b6       	in	r0, 0x3f	; 63
     51c:	f8 94       	cli
     51e:	de bf       	out	0x3e, r29	; 62
     520:	0f be       	out	0x3f, r0	; 63
     522:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
	int btmReference = 0;
     524:	1c 82       	std	Y+4, r1	; 0x04
     526:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t btmSampleCount = 0;
     528:	1d 82       	std	Y+5, r1	; 0x05
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR, topIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     52a:	86 e0       	ldi	r24, 0x06	; 6
     52c:	fe 01       	movw	r30, r28
     52e:	36 96       	adiw	r30, 0x06	; 6
     530:	df 01       	movw	r26, r30
     532:	98 2f       	mov	r25, r24
     534:	1d 92       	st	X+, r1
     536:	9a 95       	dec	r25
     538:	e9 f7       	brne	.-6      	; 0x534 <Sonar_Task+0x24>
     53a:	36 96       	adiw	r30, 0x06	; 6
     53c:	df 01       	movw	r26, r30
     53e:	98 2f       	mov	r25, r24
     540:	1d 92       	st	X+, r1
     542:	9a 95       	dec	r25
     544:	e9 f7       	brne	.-6      	; 0x540 <Sonar_Task+0x30>
     546:	36 96       	adiw	r30, 0x06	; 6
     548:	df 01       	movw	r26, r30
     54a:	98 2f       	mov	r25, r24
     54c:	1d 92       	st	X+, r1
     54e:	9a 95       	dec	r25
     550:	e9 f7       	brne	.-6      	; 0x54c <Sonar_Task+0x3c>
     552:	36 96       	adiw	r30, 0x06	; 6
     554:	df 01       	movw	r26, r30
     556:	98 2f       	mov	r25, r24
     558:	1d 92       	st	X+, r1
     55a:	9a 95       	dec	r25
     55c:	e9 f7       	brne	.-6      	; 0x558 <Sonar_Task+0x48>
	char deviceBlocked[SENSOR_NUM] = {0}; // flag to indicate if we should send the reading to RPI
     55e:	36 96       	adiw	r30, 0x06	; 6
     560:	df 01       	movw	r26, r30
     562:	1d 92       	st	X+, r1
     564:	8a 95       	dec	r24
     566:	e9 f7       	brne	.-6      	; 0x562 <Sonar_Task+0x52>
	
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     568:	84 e2       	ldi	r24, 0x24	; 36
     56a:	a9 d3       	rcall	.+1874   	; 0xcbe <mySharpIR_Read>
     56c:	9d a3       	std	Y+37, r25	; 0x25
     56e:	8c a3       	std	Y+36, r24	; 0x24
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     570:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <xTaskGetTickCount>
     574:	9a 83       	std	Y+2, r25	; 0x02
     576:	89 83       	std	Y+1, r24	; 0x01


void Sonar_Task(void *p)
{
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     578:	1c a6       	std	Y+44, r1	; 0x2c
	xLastWakeTime = xTaskGetTickCount(); // get tick count
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     57a:	b4 d1       	rcall	.+872    	; 0x8e4 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     57c:	87 e2       	ldi	r24, 0x27	; 39
     57e:	1a d2       	rcall	.+1076   	; 0x9b4 <myMaxSonar_Read>
     580:	be 01       	movw	r22, r28
     582:	64 5f       	subi	r22, 0xF4	; 244
     584:	7f 4f       	sbci	r23, 0xFF	; 255
     586:	0d d2       	rcall	.+1050   	; 0x9a2 <myMaxSonar_getFilteredReading>
     588:	2c 01       	movw	r4, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     58a:	86 e2       	ldi	r24, 0x26	; 38
     58c:	13 d2       	rcall	.+1062   	; 0x9b4 <myMaxSonar_Read>
     58e:	be 01       	movw	r22, r28
     590:	6e 5e       	subi	r22, 0xEE	; 238
     592:	7f 4f       	sbci	r23, 0xFF	; 255
     594:	06 d2       	rcall	.+1036   	; 0x9a2 <myMaxSonar_getFilteredReading>
     596:	9f a3       	std	Y+39, r25	; 0x27
     598:	8e a3       	std	Y+38, r24	; 0x26
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     59a:	85 e2       	ldi	r24, 0x25	; 37
     59c:	0b d2       	rcall	.+1046   	; 0x9b4 <myMaxSonar_Read>
     59e:	be 01       	movw	r22, r28
     5a0:	68 5e       	subi	r22, 0xE8	; 232
     5a2:	7f 4f       	sbci	r23, 0xFF	; 255
     5a4:	fe d1       	rcall	.+1020   	; 0x9a2 <myMaxSonar_getFilteredReading>
     5a6:	1c 01       	movw	r2, r24
		
		myMaxSonar_TopStart();
     5a8:	a4 d1       	rcall	.+840    	; 0x8f2 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5aa:	83 e2       	ldi	r24, 0x23	; 35
     5ac:	03 d2       	rcall	.+1030   	; 0x9b4 <myMaxSonar_Read>
     5ae:	be 01       	movw	r22, r28
     5b0:	6a 5f       	subi	r22, 0xFA	; 250
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	f6 d1       	rcall	.+1004   	; 0x9a2 <myMaxSonar_getFilteredReading>
     5b6:	99 a7       	std	Y+41, r25	; 0x29
     5b8:	88 a7       	std	Y+40, r24	; 0x28
			
			
		btmIR	= mySharpIR_Read(AN12);
     5ba:	84 e2       	ldi	r24, 0x24	; 36
     5bc:	80 d3       	rcall	.+1792   	; 0xcbe <mySharpIR_Read>
     5be:	3c 01       	movw	r6, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, &btmReference, &btmSampleCount, btmIR, CALIBRATE_BTM_HIGH_THRESHOLD, CALIBRATE_BTM_LOW_THRESHOLD); // attempt to re-calibrate btm ir sensor if stable enough..
     5c0:	0f 2e       	mov	r0, r31
     5c2:	f9 e1       	ldi	r31, 0x19	; 25
     5c4:	ef 2e       	mov	r14, r31
     5c6:	f1 2c       	mov	r15, r1
     5c8:	f0 2d       	mov	r31, r0
     5ca:	0d e2       	ldi	r16, 0x2D	; 45
     5cc:	10 e0       	ldi	r17, 0x00	; 0
     5ce:	9c 01       	movw	r18, r24
     5d0:	ae 01       	movw	r20, r28
     5d2:	4b 5f       	subi	r20, 0xFB	; 251
     5d4:	5f 4f       	sbci	r21, 0xFF	; 255
     5d6:	be 01       	movw	r22, r28
     5d8:	6d 5f       	subi	r22, 0xFD	; 253
     5da:	7f 4f       	sbci	r23, 0xFF	; 255
     5dc:	ce 01       	movw	r24, r28
     5de:	84 96       	adiw	r24, 0x24	; 36
     5e0:	a7 d3       	rcall	.+1870   	; 0xd30 <mySharpIR_ReCalibrate>
	
		topIR = mySharpIR_Read(AN7);
     5e2:	87 e0       	ldi	r24, 0x07	; 7
     5e4:	6c d3       	rcall	.+1752   	; 0xcbe <mySharpIR_Read>
     5e6:	9b a7       	std	Y+43, r25	; 0x2b
     5e8:	8a a7       	std	Y+42, r24	; 0x2a
		
		
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR, topIR);
     5ea:	cc a0       	ldd	r12, Y+36	; 0x24
     5ec:	dd a0       	ldd	r13, Y+37	; 0x25
     5ee:	4c 01       	movw	r8, r24
     5f0:	53 01       	movw	r10, r6
     5f2:	e8 a4       	ldd	r14, Y+40	; 0x28
     5f4:	f9 a4       	ldd	r15, Y+41	; 0x29
     5f6:	81 01       	movw	r16, r2
     5f8:	2e a1       	ldd	r18, Y+38	; 0x26
     5fa:	3f a1       	ldd	r19, Y+39	; 0x27
     5fc:	ae 01       	movw	r20, r28
     5fe:	42 5e       	subi	r20, 0xE2	; 226
     600:	5f 4f       	sbci	r21, 0xFF	; 255
     602:	6c a5       	ldd	r22, Y+44	; 0x2c
     604:	c2 01       	movw	r24, r4
     606:	03 d3       	rcall	.+1542   	; 0xc0e <obstacleDetection>
     608:	8c a7       	std	Y+44, r24	; 0x2c
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, topIR, deviceBlocked);
     60a:	ce 01       	movw	r24, r28
     60c:	4e 96       	adiw	r24, 0x1e	; 30
     60e:	6c 01       	movw	r12, r24
     610:	ea a4       	ldd	r14, Y+42	; 0x2a
     612:	fb a4       	ldd	r15, Y+43	; 0x2b
     614:	83 01       	movw	r16, r6
     616:	91 01       	movw	r18, r2
     618:	4e a1       	ldd	r20, Y+38	; 0x26
     61a:	5f a1       	ldd	r21, Y+39	; 0x27
     61c:	68 a5       	ldd	r22, Y+40	; 0x28
     61e:	79 a5       	ldd	r23, Y+41	; 0x29
     620:	c2 01       	movw	r24, r4
     622:	93 d2       	rcall	.+1318   	; 0xb4a <obstacleAvoidance>
		//cheatPrintAll(deviceBlocked, &obstacleDetected); 
		// remove top statement... when not debuggin..
		
		
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar, topIR);
     624:	aa a4       	ldd	r10, Y+42	; 0x2a
     626:	bb a4       	ldd	r11, Y+43	; 0x2b
     628:	c8 a4       	ldd	r12, Y+40	; 0x28
     62a:	d9 a4       	ldd	r13, Y+41	; 0x29
     62c:	73 01       	movw	r14, r6
     62e:	81 01       	movw	r16, r2
     630:	2e a1       	ldd	r18, Y+38	; 0x26
     632:	3f a1       	ldd	r19, Y+39	; 0x27
     634:	a2 01       	movw	r20, r4
     636:	be 01       	movw	r22, r28
     638:	62 5e       	subi	r22, 0xE2	; 226
     63a:	7f 4f       	sbci	r23, 0xFF	; 255
     63c:	8c a5       	ldd	r24, Y+44	; 0x2c
     63e:	1e df       	rcall	.-452    	; 0x47c <sendObstacleDetected>
	
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     640:	66 e9       	ldi	r22, 0x96	; 150
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	ce 01       	movw	r24, r28
     646:	01 96       	adiw	r24, 0x01	; 1
     648:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <vTaskDelayUntil>
     64c:	96 cf       	rjmp	.-212    	; 0x57a <Sonar_Task+0x6a>

0000064e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     654:	0e 94 a7 0f 	call	0x1f4e	; 0x1f4e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     658:	80 91 37 02 	lds	r24, 0x0237
     65c:	90 91 38 02 	lds	r25, 0x0238
     660:	89 2b       	or	r24, r25
     662:	31 f4       	brne	.+12     	; 0x670 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     664:	8c e3       	ldi	r24, 0x3C	; 60
     666:	92 e0       	ldi	r25, 0x02	; 2
     668:	90 93 38 02 	sts	0x0238, r25
     66c:	80 93 37 02 	sts	0x0237, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     670:	40 91 39 02 	lds	r20, 0x0239
     674:	50 91 3a 02 	lds	r21, 0x023A
     678:	9e 01       	movw	r18, r28
     67a:	24 0f       	add	r18, r20
     67c:	35 1f       	adc	r19, r21
     67e:	2b 3d       	cpi	r18, 0xDB	; 219
     680:	85 e0       	ldi	r24, 0x05	; 5
     682:	38 07       	cpc	r19, r24
     684:	70 f4       	brcc	.+28     	; 0x6a2 <pvPortMalloc+0x54>
     686:	42 17       	cp	r20, r18
     688:	53 07       	cpc	r21, r19
     68a:	70 f4       	brcc	.+28     	; 0x6a8 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     68c:	c0 91 37 02 	lds	r28, 0x0237
     690:	d0 91 38 02 	lds	r29, 0x0238
     694:	c4 0f       	add	r28, r20
     696:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     698:	30 93 3a 02 	sts	0x023A, r19
     69c:	20 93 39 02 	sts	0x0239, r18
     6a0:	05 c0       	rjmp	.+10     	; 0x6ac <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6a2:	c0 e0       	ldi	r28, 0x00	; 0
     6a4:	d0 e0       	ldi	r29, 0x00	; 0
     6a6:	02 c0       	rjmp	.+4      	; 0x6ac <pvPortMalloc+0x5e>
     6a8:	c0 e0       	ldi	r28, 0x00	; 0
     6aa:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6ac:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6b0:	ce 01       	movw	r24, r28
     6b2:	df 91       	pop	r29
     6b4:	cf 91       	pop	r28
     6b6:	08 95       	ret

000006b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6b8:	08 95       	ret

000006ba <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6ba:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6bc:	03 96       	adiw	r24, 0x03	; 3
     6be:	92 83       	std	Z+2, r25	; 0x02
     6c0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6c2:	2f ef       	ldi	r18, 0xFF	; 255
     6c4:	3f ef       	ldi	r19, 0xFF	; 255
     6c6:	34 83       	std	Z+4, r19	; 0x04
     6c8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ca:	96 83       	std	Z+6, r25	; 0x06
     6cc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ce:	90 87       	std	Z+8, r25	; 0x08
     6d0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6d2:	10 82       	st	Z, r1
     6d4:	08 95       	ret

000006d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6d6:	fc 01       	movw	r30, r24
     6d8:	11 86       	std	Z+9, r1	; 0x09
     6da:	10 86       	std	Z+8, r1	; 0x08
     6dc:	08 95       	ret

000006de <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	9c 01       	movw	r18, r24
     6e4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6e6:	dc 01       	movw	r26, r24
     6e8:	11 96       	adiw	r26, 0x01	; 1
     6ea:	cd 91       	ld	r28, X+
     6ec:	dc 91       	ld	r29, X
     6ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6f0:	d3 83       	std	Z+3, r29	; 0x03
     6f2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6f4:	8c 81       	ldd	r24, Y+4	; 0x04
     6f6:	9d 81       	ldd	r25, Y+5	; 0x05
     6f8:	95 83       	std	Z+5, r25	; 0x05
     6fa:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6fc:	8c 81       	ldd	r24, Y+4	; 0x04
     6fe:	9d 81       	ldd	r25, Y+5	; 0x05
     700:	dc 01       	movw	r26, r24
     702:	13 96       	adiw	r26, 0x03	; 3
     704:	7c 93       	st	X, r23
     706:	6e 93       	st	-X, r22
     708:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     70a:	7d 83       	std	Y+5, r23	; 0x05
     70c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     70e:	31 87       	std	Z+9, r19	; 0x09
     710:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     712:	f9 01       	movw	r30, r18
     714:	80 81       	ld	r24, Z
     716:	8f 5f       	subi	r24, 0xFF	; 255
     718:	80 83       	st	Z, r24
}
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	08 95       	ret

00000720 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     726:	48 81       	ld	r20, Y
     728:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     72a:	4f 3f       	cpi	r20, 0xFF	; 255
     72c:	2f ef       	ldi	r18, 0xFF	; 255
     72e:	52 07       	cpc	r21, r18
     730:	21 f4       	brne	.+8      	; 0x73a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     732:	fc 01       	movw	r30, r24
     734:	a7 81       	ldd	r26, Z+7	; 0x07
     736:	b0 85       	ldd	r27, Z+8	; 0x08
     738:	0d c0       	rjmp	.+26     	; 0x754 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     73a:	dc 01       	movw	r26, r24
     73c:	13 96       	adiw	r26, 0x03	; 3
     73e:	12 96       	adiw	r26, 0x02	; 2
     740:	ed 91       	ld	r30, X+
     742:	fc 91       	ld	r31, X
     744:	13 97       	sbiw	r26, 0x03	; 3
     746:	20 81       	ld	r18, Z
     748:	31 81       	ldd	r19, Z+1	; 0x01
     74a:	42 17       	cp	r20, r18
     74c:	53 07       	cpc	r21, r19
     74e:	10 f0       	brcs	.+4      	; 0x754 <vListInsert+0x34>
     750:	df 01       	movw	r26, r30
     752:	f5 cf       	rjmp	.-22     	; 0x73e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	ed 91       	ld	r30, X+
     758:	fc 91       	ld	r31, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	fb 83       	std	Y+3, r31	; 0x03
     75e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     760:	d5 83       	std	Z+5, r29	; 0x05
     762:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     764:	bd 83       	std	Y+5, r27	; 0x05
     766:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     768:	13 96       	adiw	r26, 0x03	; 3
     76a:	dc 93       	st	X, r29
     76c:	ce 93       	st	-X, r28
     76e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     770:	99 87       	std	Y+9, r25	; 0x09
     772:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     774:	fc 01       	movw	r30, r24
     776:	20 81       	ld	r18, Z
     778:	2f 5f       	subi	r18, 0xFF	; 255
     77a:	20 83       	st	Z, r18
}
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	08 95       	ret

00000782 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     788:	a0 85       	ldd	r26, Z+8	; 0x08
     78a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     78c:	c2 81       	ldd	r28, Z+2	; 0x02
     78e:	d3 81       	ldd	r29, Z+3	; 0x03
     790:	84 81       	ldd	r24, Z+4	; 0x04
     792:	95 81       	ldd	r25, Z+5	; 0x05
     794:	9d 83       	std	Y+5, r25	; 0x05
     796:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     798:	c4 81       	ldd	r28, Z+4	; 0x04
     79a:	d5 81       	ldd	r29, Z+5	; 0x05
     79c:	82 81       	ldd	r24, Z+2	; 0x02
     79e:	93 81       	ldd	r25, Z+3	; 0x03
     7a0:	9b 83       	std	Y+3, r25	; 0x03
     7a2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7a4:	11 96       	adiw	r26, 0x01	; 1
     7a6:	cd 91       	ld	r28, X+
     7a8:	dc 91       	ld	r29, X
     7aa:	12 97       	sbiw	r26, 0x02	; 2
     7ac:	ce 17       	cp	r28, r30
     7ae:	df 07       	cpc	r29, r31
     7b0:	31 f4       	brne	.+12     	; 0x7be <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7b2:	8c 81       	ldd	r24, Y+4	; 0x04
     7b4:	9d 81       	ldd	r25, Y+5	; 0x05
     7b6:	12 96       	adiw	r26, 0x02	; 2
     7b8:	9c 93       	st	X, r25
     7ba:	8e 93       	st	-X, r24
     7bc:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7be:	11 86       	std	Z+9, r1	; 0x09
     7c0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7c2:	8c 91       	ld	r24, X
     7c4:	81 50       	subi	r24, 0x01	; 1
     7c6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	08 95       	ret

000007ce <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7ce:	1f 92       	push	r1
     7d0:	0f 92       	push	r0
     7d2:	0f b6       	in	r0, 0x3f	; 63
     7d4:	0f 92       	push	r0
     7d6:	11 24       	eor	r1, r1
     7d8:	0b b6       	in	r0, 0x3b	; 59
     7da:	0f 92       	push	r0
     7dc:	2f 93       	push	r18
     7de:	3f 93       	push	r19
     7e0:	4f 93       	push	r20
     7e2:	5f 93       	push	r21
     7e4:	6f 93       	push	r22
     7e6:	7f 93       	push	r23
     7e8:	8f 93       	push	r24
     7ea:	9f 93       	push	r25
     7ec:	af 93       	push	r26
     7ee:	bf 93       	push	r27
     7f0:	ef 93       	push	r30
     7f2:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7f4:	1b 9b       	sbis	0x03, 3	; 3
     7f6:	0d c0       	rjmp	.+26     	; 0x812 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7f8:	24 d3       	rcall	.+1608   	; 0xe42 <myTimer_Read>
     7fa:	90 e0       	ldi	r25, 0x00	; 0
     7fc:	90 93 95 08 	sts	0x0895, r25
     800:	80 93 94 08 	sts	0x0894, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     804:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <xTaskGetTickCountFromISR>
     808:	90 93 91 08 	sts	0x0891, r25
     80c:	80 93 90 08 	sts	0x0890, r24
     810:	56 c0       	rjmp	.+172    	; 0x8be <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     812:	1b 99       	sbic	0x03, 3	; 3
     814:	54 c0       	rjmp	.+168    	; 0x8be <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     816:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <xTaskGetTickCountFromISR>
     81a:	90 93 9b 08 	sts	0x089B, r25
     81e:	80 93 9a 08 	sts	0x089A, r24
     822:	20 91 90 08 	lds	r18, 0x0890
     826:	30 91 91 08 	lds	r19, 0x0891
     82a:	82 17       	cp	r24, r18
     82c:	93 07       	cpc	r25, r19
     82e:	4c f4       	brge	.+18     	; 0x842 <__vector_9+0x74>
			ms_tickEnd += 65535;
     830:	80 91 9a 08 	lds	r24, 0x089A
     834:	90 91 9b 08 	lds	r25, 0x089B
     838:	01 97       	sbiw	r24, 0x01	; 1
     83a:	90 93 9b 08 	sts	0x089B, r25
     83e:	80 93 9a 08 	sts	0x089A, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     842:	ff d2       	rcall	.+1534   	; 0xe42 <myTimer_Read>
     844:	90 e0       	ldi	r25, 0x00	; 0
     846:	90 93 9d 08 	sts	0x089D, r25
     84a:	80 93 9c 08 	sts	0x089C, r24
     84e:	20 91 94 08 	lds	r18, 0x0894
     852:	30 91 95 08 	lds	r19, 0x0895
     856:	82 17       	cp	r24, r18
     858:	93 07       	cpc	r25, r19
     85a:	54 f4       	brge	.+20     	; 0x870 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     85c:	80 91 9c 08 	lds	r24, 0x089C
     860:	90 91 9d 08 	lds	r25, 0x089D
     864:	86 50       	subi	r24, 0x06	; 6
     866:	9f 4f       	sbci	r25, 0xFF	; 255
     868:	90 93 9d 08 	sts	0x089D, r25
     86c:	80 93 9c 08 	sts	0x089C, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     870:	80 91 9c 08 	lds	r24, 0x089C
     874:	90 91 9d 08 	lds	r25, 0x089D
     878:	20 91 94 08 	lds	r18, 0x0894
     87c:	30 91 95 08 	lds	r19, 0x0895
     880:	82 1b       	sub	r24, r18
     882:	93 0b       	sbc	r25, r19
     884:	90 93 97 08 	sts	0x0897, r25
     888:	80 93 96 08 	sts	0x0896, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     88c:	80 91 9a 08 	lds	r24, 0x089A
     890:	90 91 9b 08 	lds	r25, 0x089B
     894:	20 91 90 08 	lds	r18, 0x0890
     898:	30 91 91 08 	lds	r19, 0x0891
     89c:	82 1b       	sub	r24, r18
     89e:	93 0b       	sbc	r25, r19
     8a0:	90 93 93 08 	sts	0x0893, r25
     8a4:	80 93 92 08 	sts	0x0892, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     8a8:	20 e0       	ldi	r18, 0x00	; 0
     8aa:	40 e0       	ldi	r20, 0x00	; 0
     8ac:	50 e0       	ldi	r21, 0x00	; 0
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	70 e0       	ldi	r23, 0x00	; 0
     8b2:	80 91 98 08 	lds	r24, 0x0898
     8b6:	90 91 99 08 	lds	r25, 0x0899
     8ba:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xQueueGenericSendFromISR>
	}	
}
     8be:	ff 91       	pop	r31
     8c0:	ef 91       	pop	r30
     8c2:	bf 91       	pop	r27
     8c4:	af 91       	pop	r26
     8c6:	9f 91       	pop	r25
     8c8:	8f 91       	pop	r24
     8ca:	7f 91       	pop	r23
     8cc:	6f 91       	pop	r22
     8ce:	5f 91       	pop	r21
     8d0:	4f 91       	pop	r20
     8d2:	3f 91       	pop	r19
     8d4:	2f 91       	pop	r18
     8d6:	0f 90       	pop	r0
     8d8:	0b be       	out	0x3b, r0	; 59
     8da:	0f 90       	pop	r0
     8dc:	0f be       	out	0x3f, r0	; 63
     8de:	0f 90       	pop	r0
     8e0:	1f 90       	pop	r1
     8e2:	18 95       	reti

000008e4 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8e4:	a1 9a       	sbi	0x14, 1	; 20
	
	//myTimer_DelayMicro(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	0e 94 39 11 	call	0x2272	; 0x2272 <vTaskDelay>
	
	MaxSonar_BtmTriggerStop();
     8ee:	a1 98       	cbi	0x14, 1	; 20
     8f0:	08 95       	ret

000008f2 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8f2:	a0 9a       	sbi	0x14, 0	; 20
	
	//myTimer_DelayMicro2(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     8f4:	81 e0       	ldi	r24, 0x01	; 1
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	0e 94 39 11 	call	0x2272	; 0x2272 <vTaskDelay>
	
	MaxSonar_TopTriggerStop();
     8fc:	a0 98       	cbi	0x14, 0	; 20
     8fe:	08 95       	ret

00000900 <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     900:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     902:	80 81       	ld	r24, Z
     904:	91 81       	ldd	r25, Z+1	; 0x01
     906:	22 81       	ldd	r18, Z+2	; 0x02
     908:	33 81       	ldd	r19, Z+3	; 0x03
     90a:	28 17       	cp	r18, r24
     90c:	39 07       	cpc	r19, r25
     90e:	54 f4       	brge	.+20     	; 0x924 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     910:	44 81       	ldd	r20, Z+4	; 0x04
     912:	55 81       	ldd	r21, Z+5	; 0x05
     914:	42 17       	cp	r20, r18
     916:	53 07       	cpc	r21, r19
     918:	84 f0       	brlt	.+32     	; 0x93a <myMaxSonar_extractMedian+0x3a>
     91a:	48 17       	cp	r20, r24
     91c:	59 07       	cpc	r21, r25
     91e:	74 f4       	brge	.+28     	; 0x93c <myMaxSonar_extractMedian+0x3c>
     920:	ca 01       	movw	r24, r20
     922:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     924:	44 81       	ldd	r20, Z+4	; 0x04
     926:	55 81       	ldd	r21, Z+5	; 0x05
     928:	48 17       	cp	r20, r24
     92a:	59 07       	cpc	r21, r25
     92c:	3c f0       	brlt	.+14     	; 0x93c <myMaxSonar_extractMedian+0x3c>
     92e:	ca 01       	movw	r24, r20
     930:	24 17       	cp	r18, r20
     932:	35 07       	cpc	r19, r21
     934:	1c f4       	brge	.+6      	; 0x93c <myMaxSonar_extractMedian+0x3c>
     936:	c9 01       	movw	r24, r18
     938:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     93a:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     93c:	08 95       	ret

0000093e <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     93e:	9b 01       	movw	r18, r22
     940:	28 5f       	subi	r18, 0xF8	; 248
     942:	3f 4f       	sbci	r19, 0xFF	; 255
     944:	28 17       	cp	r18, r24
     946:	39 07       	cpc	r19, r25
     948:	3c f0       	brlt	.+14     	; 0x958 <myMaxSonar_Stabilizer+0x1a>
     94a:	20 51       	subi	r18, 0x10	; 16
     94c:	31 09       	sbc	r19, r1
     94e:	82 17       	cp	r24, r18
     950:	93 07       	cpc	r25, r19
     952:	14 f0       	brlt	.+4      	; 0x958 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     954:	86 2f       	mov	r24, r22
     956:	97 2f       	mov	r25, r23
}
     958:	08 95       	ret

0000095a <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     95a:	0f 93       	push	r16
     95c:	1f 93       	push	r17
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
     962:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     964:	00 91 00 02 	lds	r16, 0x0200
     968:	10 e0       	ldi	r17, 0x00	; 0
     96a:	f8 01       	movw	r30, r16
     96c:	ee 0f       	add	r30, r30
     96e:	ff 1f       	adc	r31, r31
     970:	e6 0f       	add	r30, r22
     972:	f7 1f       	adc	r31, r23
     974:	60 81       	ld	r22, Z
     976:	71 81       	ldd	r23, Z+1	; 0x01
     978:	e2 df       	rcall	.-60     	; 0x93e <myMaxSonar_Stabilizer>
     97a:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     97c:	c8 01       	movw	r24, r16
     97e:	01 96       	adiw	r24, 0x01	; 1
     980:	63 e0       	ldi	r22, 0x03	; 3
     982:	70 e0       	ldi	r23, 0x00	; 0
     984:	0e 94 f5 16 	call	0x2dea	; 0x2dea <__divmodhi4>
     988:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     98c:	88 0f       	add	r24, r24
     98e:	99 1f       	adc	r25, r25
     990:	c8 0f       	add	r28, r24
     992:	d9 1f       	adc	r29, r25
     994:	39 83       	std	Y+1, r19	; 0x01
     996:	28 83       	st	Y, r18
}
     998:	df 91       	pop	r29
     99a:	cf 91       	pop	r28
     99c:	1f 91       	pop	r17
     99e:	0f 91       	pop	r16
     9a0:	08 95       	ret

000009a2 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     9a2:	cf 93       	push	r28
     9a4:	df 93       	push	r29
     9a6:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     9a8:	d8 df       	rcall	.-80     	; 0x95a <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     9aa:	ce 01       	movw	r24, r28
     9ac:	a9 df       	rcall	.-174    	; 0x900 <myMaxSonar_extractMedian>

}
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	08 95       	ret

000009b4 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     9b4:	b3 d0       	rcall	.+358    	; 0xb1c <myADC_analogRead>
     9b6:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     9b8:	63 e0       	ldi	r22, 0x03	; 3
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	0e 94 f5 16 	call	0x2dea	; 0x2dea <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     9c0:	26 0f       	add	r18, r22
     9c2:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     9c4:	29 3e       	cpi	r18, 0xE9	; 233
     9c6:	83 e0       	ldi	r24, 0x03	; 3
     9c8:	38 07       	cpc	r19, r24
     9ca:	1c f0       	brlt	.+6      	; 0x9d2 <myMaxSonar_Read+0x1e>
		return 999;
     9cc:	87 ee       	ldi	r24, 0xE7	; 231
     9ce:	93 e0       	ldi	r25, 0x03	; 3
     9d0:	08 95       	ret
	
	return reading;
     9d2:	82 2f       	mov	r24, r18
     9d4:	93 2f       	mov	r25, r19
}
     9d6:	08 95       	ret

000009d8 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9d8:	1f 92       	push	r1
     9da:	0f 92       	push	r0
     9dc:	0f b6       	in	r0, 0x3f	; 63
     9de:	0f 92       	push	r0
     9e0:	11 24       	eor	r1, r1
     9e2:	0b b6       	in	r0, 0x3b	; 59
     9e4:	0f 92       	push	r0
     9e6:	2f 93       	push	r18
     9e8:	3f 93       	push	r19
     9ea:	4f 93       	push	r20
     9ec:	5f 93       	push	r21
     9ee:	6f 93       	push	r22
     9f0:	7f 93       	push	r23
     9f2:	8f 93       	push	r24
     9f4:	9f 93       	push	r25
     9f6:	af 93       	push	r26
     9f8:	bf 93       	push	r27
     9fa:	ef 93       	push	r30
     9fc:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9fe:	80 91 78 00 	lds	r24, 0x0078
     a02:	80 93 9e 08 	sts	0x089E, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     a06:	80 91 79 00 	lds	r24, 0x0079
     a0a:	80 93 9f 08 	sts	0x089F, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     a0e:	20 e0       	ldi	r18, 0x00	; 0
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	60 e0       	ldi	r22, 0x00	; 0
     a16:	70 e0       	ldi	r23, 0x00	; 0
     a18:	80 91 a2 08 	lds	r24, 0x08A2
     a1c:	90 91 a3 08 	lds	r25, 0x08A3
     a20:	d6 d7       	rcall	.+4012   	; 0x19ce <xQueueGenericSendFromISR>
}
     a22:	ff 91       	pop	r31
     a24:	ef 91       	pop	r30
     a26:	bf 91       	pop	r27
     a28:	af 91       	pop	r26
     a2a:	9f 91       	pop	r25
     a2c:	8f 91       	pop	r24
     a2e:	7f 91       	pop	r23
     a30:	6f 91       	pop	r22
     a32:	5f 91       	pop	r21
     a34:	4f 91       	pop	r20
     a36:	3f 91       	pop	r19
     a38:	2f 91       	pop	r18
     a3a:	0f 90       	pop	r0
     a3c:	0b be       	out	0x3b, r0	; 59
     a3e:	0f 90       	pop	r0
     a40:	0f be       	out	0x3f, r0	; 63
     a42:	0f 90       	pop	r0
     a44:	1f 90       	pop	r1
     a46:	18 95       	reti

00000a48 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a48:	8f e8       	ldi	r24, 0x8F	; 143
     a4a:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a4e:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a52:	80 e4       	ldi	r24, 0x40	; 64
     a54:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a58:	43 e0       	ldi	r20, 0x03	; 3
     a5a:	60 e0       	ldi	r22, 0x00	; 0
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	cc d6       	rcall	.+3480   	; 0x17f8 <xQueueGenericCreate>
     a60:	90 93 a3 08 	sts	0x08A3, r25
     a64:	80 93 a2 08 	sts	0x08A2, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a68:	81 e0       	ldi	r24, 0x01	; 1
     a6a:	86 d7       	rcall	.+3852   	; 0x1978 <xQueueCreateMutex>
     a6c:	90 93 a1 08 	sts	0x08A1, r25
     a70:	80 93 a0 08 	sts	0x08A0, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a74:	20 e0       	ldi	r18, 0x00	; 0
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	e9 c6       	rjmp	.+3538   	; 0x1852 <xQueueGenericSend>
     a80:	08 95       	ret

00000a82 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a82:	cf 93       	push	r28
     a84:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a86:	20 e0       	ldi	r18, 0x00	; 0
     a88:	4f ef       	ldi	r20, 0xFF	; 255
     a8a:	5f ef       	ldi	r21, 0xFF	; 255
     a8c:	60 e0       	ldi	r22, 0x00	; 0
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	80 91 a0 08 	lds	r24, 0x08A0
     a94:	90 91 a1 08 	lds	r25, 0x08A1
     a98:	d4 d7       	rcall	.+4008   	; 0x1a42 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a9a:	ec e7       	ldi	r30, 0x7C	; 124
     a9c:	f0 e0       	ldi	r31, 0x00	; 0
     a9e:	80 81       	ld	r24, Z
     aa0:	9c 2f       	mov	r25, r28
     aa2:	9f 71       	andi	r25, 0x1F	; 31
     aa4:	80 76       	andi	r24, 0x60	; 96
     aa6:	89 2b       	or	r24, r25
     aa8:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     aaa:	eb e7       	ldi	r30, 0x7B	; 123
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	20 81       	ld	r18, Z
     ab0:	c0 72       	andi	r28, 0x20	; 32
     ab2:	8c 2f       	mov	r24, r28
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	95 95       	asr	r25
     ab8:	87 95       	ror	r24
     aba:	95 95       	asr	r25
     abc:	87 95       	ror	r24
     abe:	92 2f       	mov	r25, r18
     ac0:	90 76       	andi	r25, 0x60	; 96
     ac2:	89 2b       	or	r24, r25
     ac4:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     ac6:	ea e7       	ldi	r30, 0x7A	; 122
     ac8:	f0 e0       	ldi	r31, 0x00	; 0
     aca:	80 81       	ld	r24, Z
     acc:	80 64       	ori	r24, 0x40	; 64
     ace:	80 83       	st	Z, r24
}
     ad0:	cf 91       	pop	r28
     ad2:	08 95       	ret

00000ad4 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ad4:	cf 93       	push	r28
     ad6:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ad8:	20 e0       	ldi	r18, 0x00	; 0
     ada:	4f ef       	ldi	r20, 0xFF	; 255
     adc:	5f ef       	ldi	r21, 0xFF	; 255
     ade:	60 e0       	ldi	r22, 0x00	; 0
     ae0:	70 e0       	ldi	r23, 0x00	; 0
     ae2:	80 91 a2 08 	lds	r24, 0x08A2
     ae6:	90 91 a3 08 	lds	r25, 0x08A3
     aea:	ab d7       	rcall	.+3926   	; 0x1a42 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     aec:	c0 91 9f 08 	lds	r28, 0x089F
     af0:	c3 70       	andi	r28, 0x03	; 3
     af2:	d0 e0       	ldi	r29, 0x00	; 0
     af4:	dc 2f       	mov	r29, r28
     af6:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     af8:	80 91 9e 08 	lds	r24, 0x089E
     afc:	c8 0f       	add	r28, r24
     afe:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     b00:	20 e0       	ldi	r18, 0x00	; 0
     b02:	40 e0       	ldi	r20, 0x00	; 0
     b04:	50 e0       	ldi	r21, 0x00	; 0
     b06:	60 e0       	ldi	r22, 0x00	; 0
     b08:	70 e0       	ldi	r23, 0x00	; 0
     b0a:	80 91 a0 08 	lds	r24, 0x08A0
     b0e:	90 91 a1 08 	lds	r25, 0x08A1
     b12:	9f d6       	rcall	.+3390   	; 0x1852 <xQueueGenericSend>
	
	return adcReading;
     b14:	ce 01       	movw	r24, r28
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	08 95       	ret

00000b1c <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     b1c:	cf 93       	push	r28
     b1e:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b20:	b0 df       	rcall	.-160    	; 0xa82 <myADC_startADC>
	return myADC_readADC(channel);
     b22:	8c 2f       	mov	r24, r28
     b24:	d7 df       	rcall	.-82     	; 0xad4 <myADC_readADC>
}
     b26:	cf 91       	pop	r28
     b28:	08 95       	ret

00000b2a <detectStairs>:
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
		return 1;
	else 
		return 0;
	
}
     b2a:	9c 01       	movw	r18, r24
     b2c:	28 5f       	subi	r18, 0xF8	; 248
     b2e:	3f 4f       	sbci	r19, 0xFF	; 255
     b30:	26 17       	cp	r18, r22
     b32:	37 07       	cpc	r19, r23
     b34:	44 f0       	brlt	.+16     	; 0xb46 <detectStairs+0x1c>
     b36:	20 51       	subi	r18, 0x10	; 16
     b38:	31 09       	sbc	r19, r1
     b3a:	81 e0       	ldi	r24, 0x01	; 1
     b3c:	62 17       	cp	r22, r18
     b3e:	73 07       	cpc	r23, r19
     b40:	1c f0       	brlt	.+6      	; 0xb48 <detectStairs+0x1e>
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	08 95       	ret
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	08 95       	ret

00000b4a <obstacleAvoidance>:
     b4a:	cf 92       	push	r12
     b4c:	df 92       	push	r13
     b4e:	f6 01       	movw	r30, r12
     b50:	83 81       	ldd	r24, Z+3	; 0x03
     b52:	88 23       	and	r24, r24
     b54:	41 f0       	breq	.+16     	; 0xb66 <obstacleAvoidance+0x1c>
     b56:	74 9a       	sbi	0x0e, 4	; 14
     b58:	e2 e0       	ldi	r30, 0x02	; 2
     b5a:	f1 e0       	ldi	r31, 0x01	; 1
     b5c:	80 81       	ld	r24, Z
     b5e:	80 61       	ori	r24, 0x10	; 16
     b60:	80 83       	st	Z, r24
     b62:	73 98       	cbi	0x0e, 3	; 14
     b64:	51 c0       	rjmp	.+162    	; 0xc08 <obstacleAvoidance+0xbe>
     b66:	80 81       	ld	r24, Z
     b68:	81 11       	cpse	r24, r1
     b6a:	06 c0       	rjmp	.+12     	; 0xb78 <obstacleAvoidance+0x2e>
     b6c:	84 81       	ldd	r24, Z+4	; 0x04
     b6e:	81 11       	cpse	r24, r1
     b70:	03 c0       	rjmp	.+6      	; 0xb78 <obstacleAvoidance+0x2e>
     b72:	85 81       	ldd	r24, Z+5	; 0x05
     b74:	88 23       	and	r24, r24
     b76:	39 f1       	breq	.+78     	; 0xbc6 <obstacleAvoidance+0x7c>
     b78:	81 81       	ldd	r24, Z+1	; 0x01
     b7a:	81 11       	cpse	r24, r1
     b7c:	07 c0       	rjmp	.+14     	; 0xb8c <obstacleAvoidance+0x42>
     b7e:	82 81       	ldd	r24, Z+2	; 0x02
     b80:	81 11       	cpse	r24, r1
     b82:	14 c0       	rjmp	.+40     	; 0xbac <obstacleAvoidance+0x62>
     b84:	73 9a       	sbi	0x0e, 3	; 14
     b86:	81 81       	ldd	r24, Z+1	; 0x01
     b88:	88 23       	and	r24, r24
     b8a:	d9 f1       	breq	.+118    	; 0xc02 <obstacleAvoidance+0xb8>
     b8c:	82 81       	ldd	r24, Z+2	; 0x02
     b8e:	81 11       	cpse	r24, r1
     b90:	3b c0       	rjmp	.+118    	; 0xc08 <obstacleAvoidance+0xbe>
     b92:	24 1b       	sub	r18, r20
     b94:	35 0b       	sbc	r19, r21
     b96:	28 30       	cpi	r18, 0x08	; 8
     b98:	31 05       	cpc	r19, r1
     b9a:	b4 f1       	brlt	.+108    	; 0xc08 <obstacleAvoidance+0xbe>
     b9c:	73 98       	cbi	0x0e, 3	; 14
     b9e:	74 98       	cbi	0x0e, 4	; 14
     ba0:	e2 e0       	ldi	r30, 0x02	; 2
     ba2:	f1 e0       	ldi	r31, 0x01	; 1
     ba4:	80 81       	ld	r24, Z
     ba6:	80 61       	ori	r24, 0x10	; 16
     ba8:	80 83       	st	Z, r24
     baa:	2e c0       	rjmp	.+92     	; 0xc08 <obstacleAvoidance+0xbe>
     bac:	42 1b       	sub	r20, r18
     bae:	53 0b       	sbc	r21, r19
     bb0:	48 30       	cpi	r20, 0x08	; 8
     bb2:	51 05       	cpc	r21, r1
     bb4:	4c f1       	brlt	.+82     	; 0xc08 <obstacleAvoidance+0xbe>
     bb6:	73 98       	cbi	0x0e, 3	; 14
     bb8:	74 9a       	sbi	0x0e, 4	; 14
     bba:	e2 e0       	ldi	r30, 0x02	; 2
     bbc:	f1 e0       	ldi	r31, 0x01	; 1
     bbe:	80 81       	ld	r24, Z
     bc0:	8f 7e       	andi	r24, 0xEF	; 239
     bc2:	80 83       	st	Z, r24
     bc4:	21 c0       	rjmp	.+66     	; 0xc08 <obstacleAvoidance+0xbe>
     bc6:	4e 31       	cpi	r20, 0x1E	; 30
     bc8:	51 05       	cpc	r21, r1
     bca:	44 f4       	brge	.+16     	; 0xbdc <obstacleAvoidance+0x92>
     bcc:	73 98       	cbi	0x0e, 3	; 14
     bce:	74 98       	cbi	0x0e, 4	; 14
     bd0:	e2 e0       	ldi	r30, 0x02	; 2
     bd2:	f1 e0       	ldi	r31, 0x01	; 1
     bd4:	80 81       	ld	r24, Z
     bd6:	80 61       	ori	r24, 0x10	; 16
     bd8:	80 83       	st	Z, r24
     bda:	16 c0       	rjmp	.+44     	; 0xc08 <obstacleAvoidance+0xbe>
     bdc:	28 31       	cpi	r18, 0x18	; 24
     bde:	31 05       	cpc	r19, r1
     be0:	44 f4       	brge	.+16     	; 0xbf2 <obstacleAvoidance+0xa8>
     be2:	73 98       	cbi	0x0e, 3	; 14
     be4:	74 9a       	sbi	0x0e, 4	; 14
     be6:	e2 e0       	ldi	r30, 0x02	; 2
     be8:	f1 e0       	ldi	r31, 0x01	; 1
     bea:	80 81       	ld	r24, Z
     bec:	8f 7e       	andi	r24, 0xEF	; 239
     bee:	80 83       	st	Z, r24
     bf0:	0b c0       	rjmp	.+22     	; 0xc08 <obstacleAvoidance+0xbe>
     bf2:	73 98       	cbi	0x0e, 3	; 14
     bf4:	74 98       	cbi	0x0e, 4	; 14
     bf6:	e2 e0       	ldi	r30, 0x02	; 2
     bf8:	f1 e0       	ldi	r31, 0x01	; 1
     bfa:	80 81       	ld	r24, Z
     bfc:	8f 7e       	andi	r24, 0xEF	; 239
     bfe:	80 83       	st	Z, r24
     c00:	03 c0       	rjmp	.+6      	; 0xc08 <obstacleAvoidance+0xbe>
     c02:	82 81       	ldd	r24, Z+2	; 0x02
     c04:	81 11       	cpse	r24, r1
     c06:	d2 cf       	rjmp	.-92     	; 0xbac <obstacleAvoidance+0x62>
     c08:	df 90       	pop	r13
     c0a:	cf 90       	pop	r12
     c0c:	08 95       	ret

00000c0e <obstacleDetection>:

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
     c0e:	6f 92       	push	r6
     c10:	7f 92       	push	r7
     c12:	8f 92       	push	r8
     c14:	9f 92       	push	r9
     c16:	af 92       	push	r10
     c18:	bf 92       	push	r11
     c1a:	cf 92       	push	r12
     c1c:	df 92       	push	r13
     c1e:	ef 92       	push	r14
     c20:	ff 92       	push	r15
     c22:	0f 93       	push	r16
     c24:	1f 93       	push	r17
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	cd b7       	in	r28, 0x3d	; 61
     c2c:	de b7       	in	r29, 0x3e	; 62
     c2e:	3a 01       	movw	r6, r20
     c30:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
     c32:	fa 01       	movw	r30, r20
     c34:	15 82       	std	Z+5, r1	; 0x05
     c36:	14 82       	std	Z+4, r1	; 0x04
     c38:	13 82       	std	Z+3, r1	; 0x03
     c3a:	12 82       	std	Z+2, r1	; 0x02
     c3c:	11 82       	std	Z+1, r1	; 0x01
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c3e:	c2 97       	sbiw	r24, 0x32	; 50
     c40:	1c f0       	brlt	.+6      	; 0xc48 <obstacleDetection+0x3a>
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
     c42:	10 82       	st	Z, r1
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
     c44:	b1 2c       	mov	r11, r1
     c46:	05 c0       	rjmp	.+10     	; 0xc52 <obstacleDetection+0x44>
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c48:	86 e4       	ldi	r24, 0x46	; 70
     c4a:	fa 01       	movw	r30, r20
     c4c:	80 83       	st	Z, r24
	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
     c4e:	bb 24       	eor	r11, r11
     c50:	b3 94       	inc	r11
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c52:	2e 31       	cpi	r18, 0x1E	; 30
     c54:	31 05       	cpc	r19, r1
     c56:	24 f4       	brge	.+8      	; 0xc60 <obstacleDetection+0x52>
	{
		obstacleDetected ++;
     c58:	b3 94       	inc	r11
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c5a:	8c e4       	ldi	r24, 0x4C	; 76
     c5c:	f3 01       	movw	r30, r6
     c5e:	81 83       	std	Z+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c60:	0e 31       	cpi	r16, 0x1E	; 30
     c62:	11 05       	cpc	r17, r1
     c64:	24 f4       	brge	.+8      	; 0xc6e <obstacleDetection+0x60>
	{
		obstacleDetected++;
     c66:	b3 94       	inc	r11
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c68:	82 e5       	ldi	r24, 0x52	; 82
     c6a:	f3 01       	movw	r30, r6
     c6c:	82 83       	std	Z+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c6e:	c6 01       	movw	r24, r12
     c70:	5c df       	rcall	.-328    	; 0xb2a <detectStairs>
     c72:	88 23       	and	r24, r24
     c74:	21 f0       	breq	.+8      	; 0xc7e <obstacleDetection+0x70>
	{
		obstacleDetected++;
     c76:	b3 94       	inc	r11
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c78:	82 e4       	ldi	r24, 0x42	; 66
     c7a:	f3 01       	movw	r30, r6
     c7c:	83 83       	std	Z+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     c7e:	f7 e3       	ldi	r31, 0x37	; 55
     c80:	ef 16       	cp	r14, r31
     c82:	f1 04       	cpc	r15, r1
     c84:	24 f4       	brge	.+8      	; 0xc8e <obstacleDetection+0x80>
	{
		obstacleDetected++;
     c86:	b3 94       	inc	r11
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     c88:	84 e5       	ldi	r24, 0x54	; 84
     c8a:	f3 01       	movw	r30, r6
     c8c:	84 83       	std	Z+4, r24	; 0x04
	}
	
	if(topIR < HIGH_OBSTACLE_DISTANCE)
     c8e:	f2 e3       	ldi	r31, 0x32	; 50
     c90:	8f 16       	cp	r8, r31
     c92:	91 04       	cpc	r9, r1
     c94:	24 f4       	brge	.+8      	; 0xc9e <obstacleDetection+0x90>
	{
		obstacleDetected++;
     c96:	b3 94       	inc	r11
		deviceBlocked[HIGH_DEVICE] = HIGH_SONAR_ID;
     c98:	88 e4       	ldi	r24, 0x48	; 72
     c9a:	f3 01       	movw	r30, r6
     c9c:	85 83       	std	Z+5, r24	; 0x05
	}
	
	return obstacleDetected;
}
     c9e:	8b 2d       	mov	r24, r11
     ca0:	df 91       	pop	r29
     ca2:	cf 91       	pop	r28
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	ff 90       	pop	r15
     caa:	ef 90       	pop	r14
     cac:	df 90       	pop	r13
     cae:	cf 90       	pop	r12
     cb0:	bf 90       	pop	r11
     cb2:	af 90       	pop	r10
     cb4:	9f 90       	pop	r9
     cb6:	8f 90       	pop	r8
     cb8:	7f 90       	pop	r7
     cba:	6f 90       	pop	r6
     cbc:	08 95       	ret

00000cbe <mySharpIR_Read>:
#include <myUSART.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     cbe:	2e df       	rcall	.-420    	; 0xb1c <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cc0:	bc 01       	movw	r22, r24
     cc2:	88 27       	eor	r24, r24
     cc4:	77 fd       	sbrc	r23, 7
     cc6:	80 95       	com	r24
     cc8:	98 2f       	mov	r25, r24
     cca:	0e 94 39 14 	call	0x2872	; 0x2872 <__floatsisf>
     cce:	29 e2       	ldi	r18, 0x29	; 41
     cd0:	3c e5       	ldi	r19, 0x5C	; 92
     cd2:	4f e6       	ldi	r20, 0x6F	; 111
     cd4:	5f eb       	ldi	r21, 0xBF	; 191
     cd6:	0e 94 28 15 	call	0x2a50	; 0x2a50 <pow>
     cda:	22 e5       	ldi	r18, 0x52	; 82
     cdc:	38 e6       	ldi	r19, 0x68	; 104
     cde:	46 e2       	ldi	r20, 0x26	; 38
     ce0:	56 e4       	ldi	r21, 0x46	; 70
     ce2:	0e 94 c5 14 	call	0x298a	; 0x298a <__mulsf3>
     ce6:	20 e0       	ldi	r18, 0x00	; 0
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	40 e2       	ldi	r20, 0x20	; 32
     cec:	51 e4       	ldi	r21, 0x41	; 65
     cee:	0e 94 a1 13 	call	0x2742	; 0x2742 <__subsf3>
     cf2:	0e 94 06 14 	call	0x280c	; 0x280c <__fixsfsi>
     cf6:	cb 01       	movw	r24, r22
	if(adcReading > IR_MAX_VALUE || adcReading < IR_MIN_VALUE)
     cf8:	68 3e       	cpi	r22, 0xE8	; 232
     cfa:	23 e0       	ldi	r18, 0x03	; 3
     cfc:	72 07       	cpc	r23, r18
     cfe:	10 f0       	brcs	.+4      	; 0xd04 <mySharpIR_Read+0x46>
		adcReading = IR_MAX_VALUE;
     d00:	87 ee       	ldi	r24, 0xE7	; 231
     d02:	93 e0       	ldi	r25, 0x03	; 3
	
	return adcReading;
}
     d04:	08 95       	ret

00000d06 <checkOutOfRange>:

// return 1 if out of range..
char checkOutOfRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d06:	fb 01       	movw	r30, r22
     d08:	20 81       	ld	r18, Z
     d0a:	31 81       	ldd	r19, Z+1	; 0x01
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	b9 01       	movw	r22, r18
     d10:	64 0f       	add	r22, r20
     d12:	75 1f       	adc	r23, r21
     d14:	68 17       	cp	r22, r24
     d16:	79 07       	cpc	r23, r25
     d18:	4c f0       	brlt	.+18     	; 0xd2c <checkOutOfRange+0x26>
     d1a:	24 1b       	sub	r18, r20
     d1c:	35 0b       	sbc	r19, r21
     d1e:	41 e0       	ldi	r20, 0x01	; 1
     d20:	82 17       	cp	r24, r18
     d22:	93 07       	cpc	r25, r19
     d24:	0c f0       	brlt	.+2      	; 0xd28 <checkOutOfRange+0x22>
     d26:	40 e0       	ldi	r20, 0x00	; 0
     d28:	84 2f       	mov	r24, r20
     d2a:	08 95       	ret
     d2c:	81 e0       	ldi	r24, 0x01	; 1
}
     d2e:	08 95       	ret

00000d30 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int * referenceReading, uint8_t * sampleCount, int reading, const int highThreshold, const int lowThreshold)
{
     d30:	8f 92       	push	r8
     d32:	9f 92       	push	r9
     d34:	af 92       	push	r10
     d36:	bf 92       	push	r11
     d38:	cf 92       	push	r12
     d3a:	df 92       	push	r13
     d3c:	ef 92       	push	r14
     d3e:	ff 92       	push	r15
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	5c 01       	movw	r10, r24
     d4a:	4b 01       	movw	r8, r22
     d4c:	6a 01       	movw	r12, r20
     d4e:	e9 01       	movw	r28, r18
	//static int testPrint = 0;
	
	if(!checkOutOfRange(reading, calibratedReading, CALIBRATE_RANGE) && *sampleCount == 0)
     d50:	45 e0       	ldi	r20, 0x05	; 5
     d52:	bc 01       	movw	r22, r24
     d54:	c9 01       	movw	r24, r18
     d56:	d7 df       	rcall	.-82     	; 0xd06 <checkOutOfRange>
     d58:	81 11       	cpse	r24, r1
     d5a:	05 c0       	rjmp	.+10     	; 0xd66 <mySharpIR_ReCalibrate+0x36>
     d5c:	f6 01       	movw	r30, r12
     d5e:	80 81       	ld	r24, Z
     d60:	88 23       	and	r24, r24
     d62:	09 f4       	brne	.+2      	; 0xd66 <mySharpIR_ReCalibrate+0x36>
     d64:	47 c0       	rjmp	.+142    	; 0xdf4 <mySharpIR_ReCalibrate+0xc4>
		// if current reading and calibratedReading is within range and no checking in progess
		// skip the calibration process... not needed
		return;
	}
	
	if(reading < lowThreshold || reading > highThreshold)
     d66:	ce 15       	cp	r28, r14
     d68:	df 05       	cpc	r29, r15
     d6a:	1c f0       	brlt	.+6      	; 0xd72 <mySharpIR_ReCalibrate+0x42>
     d6c:	0c 17       	cp	r16, r28
     d6e:	1d 07       	cpc	r17, r29
     d70:	24 f4       	brge	.+8      	; 0xd7a <mySharpIR_ReCalibrate+0x4a>
	{
		// Too low or Too high for it to be ground..
		*referenceReading = 0;
     d72:	f4 01       	movw	r30, r8
     d74:	11 82       	std	Z+1, r1	; 0x01
     d76:	10 82       	st	Z, r1
		return;		
     d78:	3d c0       	rjmp	.+122    	; 0xdf4 <mySharpIR_ReCalibrate+0xc4>
	}
	
	
	if (*sampleCount == 0)
     d7a:	f6 01       	movw	r30, r12
     d7c:	80 81       	ld	r24, Z
     d7e:	81 11       	cpse	r24, r1
     d80:	04 c0       	rjmp	.+8      	; 0xd8a <mySharpIR_ReCalibrate+0x5a>
	{
		// Possible calibration... take reference from reading
		//testPrint = 0;
		*referenceReading = reading;
     d82:	f4 01       	movw	r30, r8
     d84:	d1 83       	std	Z+1, r29	; 0x01
     d86:	c0 83       	st	Z, r28
     d88:	31 c0       	rjmp	.+98     	; 0xdec <mySharpIR_ReCalibrate+0xbc>
		//myUSART_transmitUSART0("\n-----RS----\n");

	}
	else if ((*sampleCount % CALIBRATE_SAMPLE_RATE) == 0) // when count reach 
     d8a:	9d ec       	ldi	r25, 0xCD	; 205
     d8c:	89 9f       	mul	r24, r25
     d8e:	91 2d       	mov	r25, r1
     d90:	11 24       	eor	r1, r1
     d92:	96 95       	lsr	r25
     d94:	96 95       	lsr	r25
     d96:	29 2f       	mov	r18, r25
     d98:	22 0f       	add	r18, r18
     d9a:	22 0f       	add	r18, r18
     d9c:	92 0f       	add	r25, r18
     d9e:	89 13       	cpse	r24, r25
     da0:	10 c0       	rjmp	.+32     	; 0xdc2 <mySharpIR_ReCalibrate+0x92>
	{
		//testPrint++;
		//myUSART_transmitUSART0_c(testPrint + '0');
		//myUSART_transmitUSART0("\n");
		if(checkOutOfRange(reading, referenceReading, CALIBRATE_RANGE))
     da2:	45 e0       	ldi	r20, 0x05	; 5
     da4:	b4 01       	movw	r22, r8
     da6:	ce 01       	movw	r24, r28
     da8:	ae df       	rcall	.-164    	; 0xd06 <checkOutOfRange>
     daa:	88 23       	and	r24, r24
     dac:	31 f0       	breq	.+12     	; 0xdba <mySharpIR_ReCalibrate+0x8a>
		{
			// Out of range.. restart to find new calibration point..
			*referenceReading = 0;
     dae:	f4 01       	movw	r30, r8
     db0:	11 82       	std	Z+1, r1	; 0x01
     db2:	10 82       	st	Z, r1
			*sampleCount = 0; // reset to count...
     db4:	f6 01       	movw	r30, r12
     db6:	10 82       	st	Z, r1
			return;
     db8:	1d c0       	rjmp	.+58     	; 0xdf4 <mySharpIR_ReCalibrate+0xc4>
		}
		else
		{	// within range.. need more confirmation, update reference point..
			*referenceReading = reading;
     dba:	f4 01       	movw	r30, r8
     dbc:	d1 83       	std	Z+1, r29	; 0x01
     dbe:	c0 83       	st	Z, r28
     dc0:	15 c0       	rjmp	.+42     	; 0xdec <mySharpIR_ReCalibrate+0xbc>
		}
	}
	else if (*sampleCount >= CALIBRATE_SAMPLE_REQUIRE)
     dc2:	82 32       	cpi	r24, 0x22	; 34
     dc4:	98 f0       	brcs	.+38     	; 0xdec <mySharpIR_ReCalibrate+0xbc>
	{
		// Sample long enough...
		*sampleCount = 0; // reset to count..
     dc6:	f6 01       	movw	r30, r12
     dc8:	10 82       	st	Z, r1

		if(checkOutOfRange(reading, referenceReading, CALIBRATE_RANGE))
     dca:	45 e0       	ldi	r20, 0x05	; 5
     dcc:	b4 01       	movw	r22, r8
     dce:	ce 01       	movw	r24, r28
     dd0:	9a df       	rcall	.-204    	; 0xd06 <checkOutOfRange>
     dd2:	88 23       	and	r24, r24
     dd4:	21 f0       	breq	.+8      	; 0xdde <mySharpIR_ReCalibrate+0xae>
		{
			// Out of range.. restart to find new calibration point..
			*referenceReading = 0;
     dd6:	f4 01       	movw	r30, r8
     dd8:	11 82       	std	Z+1, r1	; 0x01
     dda:	10 82       	st	Z, r1
			return;
     ddc:	0b c0       	rjmp	.+22     	; 0xdf4 <mySharpIR_ReCalibrate+0xc4>
		}
		else
		{
			// all readings within range... can calibrate as new stable.
			*calibratedReading = *referenceReading; // btmIR is calibrated..
     dde:	f4 01       	movw	r30, r8
     de0:	80 81       	ld	r24, Z
     de2:	91 81       	ldd	r25, Z+1	; 0x01
     de4:	f5 01       	movw	r30, r10
     de6:	91 83       	std	Z+1, r25	; 0x01
     de8:	80 83       	st	Z, r24
			//myUSART_transmitUSART0("\nACK\n");
			return;
     dea:	04 c0       	rjmp	.+8      	; 0xdf4 <mySharpIR_ReCalibrate+0xc4>
		}
	}
	
	(*sampleCount)++;
     dec:	f6 01       	movw	r30, r12
     dee:	80 81       	ld	r24, Z
     df0:	8f 5f       	subi	r24, 0xFF	; 255
     df2:	80 83       	st	Z, r24
}
     df4:	df 91       	pop	r29
     df6:	cf 91       	pop	r28
     df8:	1f 91       	pop	r17
     dfa:	0f 91       	pop	r16
     dfc:	ff 90       	pop	r15
     dfe:	ef 90       	pop	r14
     e00:	df 90       	pop	r13
     e02:	cf 90       	pop	r12
     e04:	bf 90       	pop	r11
     e06:	af 90       	pop	r10
     e08:	9f 90       	pop	r9
     e0a:	8f 90       	pop	r8
     e0c:	08 95       	ret

00000e0e <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e0e:	90 93 a9 08 	sts	0x08A9, r25
     e12:	80 93 a8 08 	sts	0x08A8, r24
     e16:	fc 01       	movw	r30, r24
     e18:	80 81       	ld	r24, Z
     e1a:	91 81       	ldd	r25, Z+1	; 0x01
     e1c:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vTaskSuspend>
     e20:	43 e0       	ldi	r20, 0x03	; 3
     e22:	60 e0       	ldi	r22, 0x00	; 0
     e24:	81 e0       	ldi	r24, 0x01	; 1
     e26:	e8 d4       	rcall	.+2512   	; 0x17f8 <xQueueGenericCreate>
     e28:	90 93 a5 08 	sts	0x08A5, r25
     e2c:	80 93 a4 08 	sts	0x08A4, r24
     e30:	43 e0       	ldi	r20, 0x03	; 3
     e32:	60 e0       	ldi	r22, 0x00	; 0
     e34:	81 e0       	ldi	r24, 0x01	; 1
     e36:	e0 d4       	rcall	.+2496   	; 0x17f8 <xQueueGenericCreate>
     e38:	90 93 a7 08 	sts	0x08A7, r25
     e3c:	80 93 a6 08 	sts	0x08A6, r24
     e40:	08 95       	ret

00000e42 <myTimer_Read>:
     e42:	86 b5       	in	r24, 0x26	; 38
     e44:	08 95       	ret

00000e46 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e46:	cf 93       	push	r28
     e48:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e4a:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e4c:	c1 11       	cpse	r28, r1
     e4e:	22 c0       	rjmp	.+68     	; 0xe94 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e50:	80 91 03 02 	lds	r24, 0x0203
     e54:	90 91 04 02 	lds	r25, 0x0204
     e58:	88 38       	cpi	r24, 0x88	; 136
     e5a:	93 41       	sbci	r25, 0x13	; 19
     e5c:	51 f0       	breq	.+20     	; 0xe72 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e5e:	80 91 03 02 	lds	r24, 0x0203
     e62:	90 91 04 02 	lds	r25, 0x0204
     e66:	8a 5f       	subi	r24, 0xFA	; 250
     e68:	91 09       	sbc	r25, r1
     e6a:	90 93 04 02 	sts	0x0204, r25
     e6e:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e72:	80 91 01 02 	lds	r24, 0x0201
     e76:	90 91 02 02 	lds	r25, 0x0202
     e7a:	88 38       	cpi	r24, 0x88	; 136
     e7c:	93 41       	sbci	r25, 0x13	; 19
     e7e:	51 f0       	breq	.+20     	; 0xe94 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e80:	80 91 01 02 	lds	r24, 0x0201
     e84:	90 91 02 02 	lds	r25, 0x0202
     e88:	8a 5f       	subi	r24, 0xFA	; 250
     e8a:	91 09       	sbc	r25, r1
     e8c:	90 93 02 02 	sts	0x0202, r25
     e90:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e94:	d0 e0       	ldi	r29, 0x00	; 0
     e96:	80 91 03 02 	lds	r24, 0x0203
     e9a:	90 91 04 02 	lds	r25, 0x0204
     e9e:	8c 17       	cp	r24, r28
     ea0:	9d 07       	cpc	r25, r29
     ea2:	84 f4       	brge	.+32     	; 0xec4 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     ea4:	88 e8       	ldi	r24, 0x88	; 136
     ea6:	93 e1       	ldi	r25, 0x13	; 19
     ea8:	90 93 04 02 	sts	0x0204, r25
     eac:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     eb0:	20 e0       	ldi	r18, 0x00	; 0
     eb2:	40 e0       	ldi	r20, 0x00	; 0
     eb4:	50 e0       	ldi	r21, 0x00	; 0
     eb6:	60 e0       	ldi	r22, 0x00	; 0
     eb8:	70 e0       	ldi	r23, 0x00	; 0
     eba:	80 91 a4 08 	lds	r24, 0x08A4
     ebe:	90 91 a5 08 	lds	r25, 0x08A5
     ec2:	c7 d4       	rcall	.+2446   	; 0x1852 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     ec4:	80 91 01 02 	lds	r24, 0x0201
     ec8:	90 91 02 02 	lds	r25, 0x0202
     ecc:	8c 17       	cp	r24, r28
     ece:	9d 07       	cpc	r25, r29
     ed0:	84 f4       	brge	.+32     	; 0xef2 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     ed2:	88 e8       	ldi	r24, 0x88	; 136
     ed4:	93 e1       	ldi	r25, 0x13	; 19
     ed6:	90 93 02 02 	sts	0x0202, r25
     eda:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     ede:	20 e0       	ldi	r18, 0x00	; 0
     ee0:	40 e0       	ldi	r20, 0x00	; 0
     ee2:	50 e0       	ldi	r21, 0x00	; 0
     ee4:	60 e0       	ldi	r22, 0x00	; 0
     ee6:	70 e0       	ldi	r23, 0x00	; 0
     ee8:	80 91 a6 08 	lds	r24, 0x08A6
     eec:	90 91 a7 08 	lds	r25, 0x08A7
     ef0:	b0 d4       	rcall	.+2400   	; 0x1852 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     ef2:	80 91 03 02 	lds	r24, 0x0203
     ef6:	90 91 04 02 	lds	r25, 0x0204
     efa:	88 38       	cpi	r24, 0x88	; 136
     efc:	93 41       	sbci	r25, 0x13	; 19
     efe:	79 f4       	brne	.+30     	; 0xf1e <myTimer_DelayChecker+0xd8>
     f00:	80 91 01 02 	lds	r24, 0x0201
     f04:	90 91 02 02 	lds	r25, 0x0202
     f08:	88 38       	cpi	r24, 0x88	; 136
     f0a:	93 41       	sbci	r25, 0x13	; 19
     f0c:	41 f4       	brne	.+16     	; 0xf1e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f0e:	e0 91 a8 08 	lds	r30, 0x08A8
     f12:	f0 91 a9 08 	lds	r31, 0x08A9
     f16:	80 81       	ld	r24, Z
     f18:	91 81       	ldd	r25, Z+1	; 0x01
     f1a:	0e 94 ec 11 	call	0x23d8	; 0x23d8 <vTaskSuspend>
	}
     f1e:	df 91       	pop	r29
     f20:	cf 91       	pop	r28
     f22:	08 95       	ret

00000f24 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     f24:	1f 92       	push	r1
     f26:	0f 92       	push	r0
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	0f 92       	push	r0
     f2c:	11 24       	eor	r1, r1
     f2e:	0b b6       	in	r0, 0x3b	; 59
     f30:	0f 92       	push	r0
     f32:	2f 93       	push	r18
     f34:	3f 93       	push	r19
     f36:	4f 93       	push	r20
     f38:	5f 93       	push	r21
     f3a:	6f 93       	push	r22
     f3c:	7f 93       	push	r23
     f3e:	8f 93       	push	r24
     f40:	9f 93       	push	r25
     f42:	af 93       	push	r26
     f44:	bf 93       	push	r27
     f46:	ef 93       	push	r30
     f48:	ff 93       	push	r31
     f4a:	60 91 ce 00 	lds	r22, 0x00CE
     f4e:	89 e3       	ldi	r24, 0x39	; 57
     f50:	99 e0       	ldi	r25, 0x09	; 9
     f52:	43 d6       	rcall	.+3206   	; 0x1bda <ringBufferPush>
     f54:	20 e0       	ldi	r18, 0x00	; 0
     f56:	40 e0       	ldi	r20, 0x00	; 0
     f58:	50 e0       	ldi	r21, 0x00	; 0
     f5a:	60 e0       	ldi	r22, 0x00	; 0
     f5c:	70 e0       	ldi	r23, 0x00	; 0
     f5e:	80 91 1f 08 	lds	r24, 0x081F
     f62:	90 91 20 08 	lds	r25, 0x0820
     f66:	33 d5       	rcall	.+2662   	; 0x19ce <xQueueGenericSendFromISR>
     f68:	89 e3       	ldi	r24, 0x39	; 57
     f6a:	99 e0       	ldi	r25, 0x09	; 9
     f6c:	4d d6       	rcall	.+3226   	; 0x1c08 <ringBufferFull>
     f6e:	ff 91       	pop	r31
     f70:	ef 91       	pop	r30
     f72:	bf 91       	pop	r27
     f74:	af 91       	pop	r26
     f76:	9f 91       	pop	r25
     f78:	8f 91       	pop	r24
     f7a:	7f 91       	pop	r23
     f7c:	6f 91       	pop	r22
     f7e:	5f 91       	pop	r21
     f80:	4f 91       	pop	r20
     f82:	3f 91       	pop	r19
     f84:	2f 91       	pop	r18
     f86:	0f 90       	pop	r0
     f88:	0b be       	out	0x3b, r0	; 59
     f8a:	0f 90       	pop	r0
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	0f 90       	pop	r0
     f90:	1f 90       	pop	r1
     f92:	18 95       	reti

00000f94 <__vector_25>:
     f94:	1f 92       	push	r1
     f96:	0f 92       	push	r0
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	0f 92       	push	r0
     f9c:	11 24       	eor	r1, r1
     f9e:	0b b6       	in	r0, 0x3b	; 59
     fa0:	0f 92       	push	r0
     fa2:	2f 93       	push	r18
     fa4:	3f 93       	push	r19
     fa6:	4f 93       	push	r20
     fa8:	5f 93       	push	r21
     faa:	6f 93       	push	r22
     fac:	7f 93       	push	r23
     fae:	8f 93       	push	r24
     fb0:	9f 93       	push	r25
     fb2:	af 93       	push	r26
     fb4:	bf 93       	push	r27
     fb6:	ef 93       	push	r30
     fb8:	ff 93       	push	r31
     fba:	60 91 c6 00 	lds	r22, 0x00C6
     fbe:	8a ec       	ldi	r24, 0xCA	; 202
     fc0:	98 e0       	ldi	r25, 0x08	; 8
     fc2:	0b d6       	rcall	.+3094   	; 0x1bda <ringBufferPush>
     fc4:	20 e0       	ldi	r18, 0x00	; 0
     fc6:	40 e0       	ldi	r20, 0x00	; 0
     fc8:	50 e0       	ldi	r21, 0x00	; 0
     fca:	60 e0       	ldi	r22, 0x00	; 0
     fcc:	70 e0       	ldi	r23, 0x00	; 0
     fce:	80 91 1f 08 	lds	r24, 0x081F
     fd2:	90 91 20 08 	lds	r25, 0x0820
     fd6:	fb d4       	rcall	.+2550   	; 0x19ce <xQueueGenericSendFromISR>
     fd8:	8a ec       	ldi	r24, 0xCA	; 202
     fda:	98 e0       	ldi	r25, 0x08	; 8
     fdc:	15 d6       	rcall	.+3114   	; 0x1c08 <ringBufferFull>
     fde:	ff 91       	pop	r31
     fe0:	ef 91       	pop	r30
     fe2:	bf 91       	pop	r27
     fe4:	af 91       	pop	r26
     fe6:	9f 91       	pop	r25
     fe8:	8f 91       	pop	r24
     fea:	7f 91       	pop	r23
     fec:	6f 91       	pop	r22
     fee:	5f 91       	pop	r21
     ff0:	4f 91       	pop	r20
     ff2:	3f 91       	pop	r19
     ff4:	2f 91       	pop	r18
     ff6:	0f 90       	pop	r0
     ff8:	0b be       	out	0x3b, r0	; 59
     ffa:	0f 90       	pop	r0
     ffc:	0f be       	out	0x3f, r0	; 63
     ffe:	0f 90       	pop	r0
    1000:	1f 90       	pop	r1
    1002:	18 95       	reti

00001004 <__vector_37>:
    1004:	1f 92       	push	r1
    1006:	0f 92       	push	r0
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	0f 92       	push	r0
    100c:	11 24       	eor	r1, r1
    100e:	0b b6       	in	r0, 0x3b	; 59
    1010:	0f 92       	push	r0
    1012:	2f 93       	push	r18
    1014:	3f 93       	push	r19
    1016:	4f 93       	push	r20
    1018:	5f 93       	push	r21
    101a:	6f 93       	push	r22
    101c:	7f 93       	push	r23
    101e:	8f 93       	push	r24
    1020:	9f 93       	push	r25
    1022:	af 93       	push	r26
    1024:	bf 93       	push	r27
    1026:	ef 93       	push	r30
    1028:	ff 93       	push	r31
    102a:	8f e2       	ldi	r24, 0x2F	; 47
    102c:	99 e0       	ldi	r25, 0x09	; 9
    102e:	f3 d5       	rcall	.+3046   	; 0x1c16 <ringBufferNotEmpty>
    1030:	88 23       	and	r24, r24
    1032:	31 f0       	breq	.+12     	; 0x1040 <__vector_37+0x3c>
    1034:	8f e2       	ldi	r24, 0x2F	; 47
    1036:	99 e0       	ldi	r25, 0x09	; 9
    1038:	be d5       	rcall	.+2940   	; 0x1bb6 <ringBufferPop>
    103a:	80 93 ce 00 	sts	0x00CE, r24
    103e:	0f c0       	rjmp	.+30     	; 0x105e <__vector_37+0x5a>
    1040:	e9 ec       	ldi	r30, 0xC9	; 201
    1042:	f0 e0       	ldi	r31, 0x00	; 0
    1044:	80 81       	ld	r24, Z
    1046:	8f 7d       	andi	r24, 0xDF	; 223
    1048:	80 83       	st	Z, r24
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	40 e0       	ldi	r20, 0x00	; 0
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	60 e0       	ldi	r22, 0x00	; 0
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	80 91 17 08 	lds	r24, 0x0817
    1058:	90 91 18 08 	lds	r25, 0x0818
    105c:	b8 d4       	rcall	.+2416   	; 0x19ce <xQueueGenericSendFromISR>
    105e:	ff 91       	pop	r31
    1060:	ef 91       	pop	r30
    1062:	bf 91       	pop	r27
    1064:	af 91       	pop	r26
    1066:	9f 91       	pop	r25
    1068:	8f 91       	pop	r24
    106a:	7f 91       	pop	r23
    106c:	6f 91       	pop	r22
    106e:	5f 91       	pop	r21
    1070:	4f 91       	pop	r20
    1072:	3f 91       	pop	r19
    1074:	2f 91       	pop	r18
    1076:	0f 90       	pop	r0
    1078:	0b be       	out	0x3b, r0	; 59
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63
    107e:	0f 90       	pop	r0
    1080:	1f 90       	pop	r1
    1082:	18 95       	reti

00001084 <__vector_26>:
    1084:	1f 92       	push	r1
    1086:	0f 92       	push	r0
    1088:	0f b6       	in	r0, 0x3f	; 63
    108a:	0f 92       	push	r0
    108c:	11 24       	eor	r1, r1
    108e:	0b b6       	in	r0, 0x3b	; 59
    1090:	0f 92       	push	r0
    1092:	2f 93       	push	r18
    1094:	3f 93       	push	r19
    1096:	4f 93       	push	r20
    1098:	5f 93       	push	r21
    109a:	6f 93       	push	r22
    109c:	7f 93       	push	r23
    109e:	8f 93       	push	r24
    10a0:	9f 93       	push	r25
    10a2:	af 93       	push	r26
    10a4:	bf 93       	push	r27
    10a6:	ef 93       	push	r30
    10a8:	ff 93       	push	r31
    10aa:	84 e3       	ldi	r24, 0x34	; 52
    10ac:	99 e0       	ldi	r25, 0x09	; 9
    10ae:	b3 d5       	rcall	.+2918   	; 0x1c16 <ringBufferNotEmpty>
    10b0:	88 23       	and	r24, r24
    10b2:	31 f0       	breq	.+12     	; 0x10c0 <__vector_26+0x3c>
    10b4:	84 e3       	ldi	r24, 0x34	; 52
    10b6:	99 e0       	ldi	r25, 0x09	; 9
    10b8:	7e d5       	rcall	.+2812   	; 0x1bb6 <ringBufferPop>
    10ba:	80 93 c6 00 	sts	0x00C6, r24
    10be:	0f c0       	rjmp	.+30     	; 0x10de <__vector_26+0x5a>
    10c0:	e1 ec       	ldi	r30, 0xC1	; 193
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	80 81       	ld	r24, Z
    10c6:	8f 7d       	andi	r24, 0xDF	; 223
    10c8:	80 83       	st	Z, r24
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	40 e0       	ldi	r20, 0x00	; 0
    10ce:	50 e0       	ldi	r21, 0x00	; 0
    10d0:	60 e0       	ldi	r22, 0x00	; 0
    10d2:	70 e0       	ldi	r23, 0x00	; 0
    10d4:	80 91 19 08 	lds	r24, 0x0819
    10d8:	90 91 1a 08 	lds	r25, 0x081A
    10dc:	78 d4       	rcall	.+2288   	; 0x19ce <xQueueGenericSendFromISR>
    10de:	ff 91       	pop	r31
    10e0:	ef 91       	pop	r30
    10e2:	bf 91       	pop	r27
    10e4:	af 91       	pop	r26
    10e6:	9f 91       	pop	r25
    10e8:	8f 91       	pop	r24
    10ea:	7f 91       	pop	r23
    10ec:	6f 91       	pop	r22
    10ee:	5f 91       	pop	r21
    10f0:	4f 91       	pop	r20
    10f2:	3f 91       	pop	r19
    10f4:	2f 91       	pop	r18
    10f6:	0f 90       	pop	r0
    10f8:	0b be       	out	0x3b, r0	; 59
    10fa:	0f 90       	pop	r0
    10fc:	0f be       	out	0x3f, r0	; 63
    10fe:	0f 90       	pop	r0
    1100:	1f 90       	pop	r1
    1102:	18 95       	reti

00001104 <myUSART_USART0_Init>:
    1104:	10 92 c5 00 	sts	0x00C5, r1
    1108:	87 e6       	ldi	r24, 0x67	; 103
    110a:	80 93 c4 00 	sts	0x00C4, r24
    110e:	88 eb       	ldi	r24, 0xB8	; 184
    1110:	80 93 c1 00 	sts	0x00C1, r24
    1114:	86 e0       	ldi	r24, 0x06	; 6
    1116:	80 93 c2 00 	sts	0x00C2, r24
    111a:	40 e2       	ldi	r20, 0x20	; 32
    111c:	6f ee       	ldi	r22, 0xEF	; 239
    111e:	78 e0       	ldi	r23, 0x08	; 8
    1120:	8a ec       	ldi	r24, 0xCA	; 202
    1122:	98 e0       	ldi	r25, 0x08	; 8
    1124:	41 d5       	rcall	.+2690   	; 0x1ba8 <ringBufferInit>
    1126:	40 e2       	ldi	r20, 0x20	; 32
    1128:	6f ec       	ldi	r22, 0xCF	; 207
    112a:	78 e0       	ldi	r23, 0x08	; 8
    112c:	84 e3       	ldi	r24, 0x34	; 52
    112e:	99 e0       	ldi	r25, 0x09	; 9
    1130:	3b d5       	rcall	.+2678   	; 0x1ba8 <ringBufferInit>
    1132:	43 e0       	ldi	r20, 0x03	; 3
    1134:	60 e0       	ldi	r22, 0x00	; 0
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	5f d3       	rcall	.+1726   	; 0x17f8 <xQueueGenericCreate>
    113a:	90 93 1e 08 	sts	0x081E, r25
    113e:	80 93 1d 08 	sts	0x081D, r24
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	19 d4       	rcall	.+2098   	; 0x1978 <xQueueCreateMutex>
    1146:	90 93 1a 08 	sts	0x081A, r25
    114a:	80 93 19 08 	sts	0x0819, r24
    114e:	08 95       	ret

00001150 <myUSART_USART1_Init>:
    1150:	10 92 cd 00 	sts	0x00CD, r1
    1154:	87 e6       	ldi	r24, 0x67	; 103
    1156:	80 93 cc 00 	sts	0x00CC, r24
    115a:	88 eb       	ldi	r24, 0xB8	; 184
    115c:	80 93 c9 00 	sts	0x00C9, r24
    1160:	86 e0       	ldi	r24, 0x06	; 6
    1162:	80 93 ca 00 	sts	0x00CA, r24
    1166:	40 e2       	ldi	r20, 0x20	; 32
    1168:	6a ea       	ldi	r22, 0xAA	; 170
    116a:	78 e0       	ldi	r23, 0x08	; 8
    116c:	89 e3       	ldi	r24, 0x39	; 57
    116e:	99 e0       	ldi	r25, 0x09	; 9
    1170:	1b d5       	rcall	.+2614   	; 0x1ba8 <ringBufferInit>
    1172:	40 e2       	ldi	r20, 0x20	; 32
    1174:	6f e0       	ldi	r22, 0x0F	; 15
    1176:	79 e0       	ldi	r23, 0x09	; 9
    1178:	8f e2       	ldi	r24, 0x2F	; 47
    117a:	99 e0       	ldi	r25, 0x09	; 9
    117c:	15 d5       	rcall	.+2602   	; 0x1ba8 <ringBufferInit>
    117e:	43 e0       	ldi	r20, 0x03	; 3
    1180:	60 e0       	ldi	r22, 0x00	; 0
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	39 d3       	rcall	.+1650   	; 0x17f8 <xQueueGenericCreate>
    1186:	90 93 20 08 	sts	0x0820, r25
    118a:	80 93 1f 08 	sts	0x081F, r24
    118e:	43 e0       	ldi	r20, 0x03	; 3
    1190:	60 e0       	ldi	r22, 0x00	; 0
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	31 d3       	rcall	.+1634   	; 0x17f8 <xQueueGenericCreate>
    1196:	90 93 1c 08 	sts	0x081C, r25
    119a:	80 93 1b 08 	sts	0x081B, r24
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	eb d3       	rcall	.+2006   	; 0x1978 <xQueueCreateMutex>
    11a2:	90 93 18 08 	sts	0x0818, r25
    11a6:	80 93 17 08 	sts	0x0817, r24
    11aa:	08 95       	ret

000011ac <myUSART_transmitUSART0_c>:
    11ac:	cf 93       	push	r28
    11ae:	c8 2f       	mov	r28, r24
    11b0:	20 e0       	ldi	r18, 0x00	; 0
    11b2:	4f ef       	ldi	r20, 0xFF	; 255
    11b4:	5f ef       	ldi	r21, 0xFF	; 255
    11b6:	60 e0       	ldi	r22, 0x00	; 0
    11b8:	70 e0       	ldi	r23, 0x00	; 0
    11ba:	80 91 19 08 	lds	r24, 0x0819
    11be:	90 91 1a 08 	lds	r25, 0x081A
    11c2:	3f d4       	rcall	.+2174   	; 0x1a42 <xQueueGenericReceive>
    11c4:	84 e3       	ldi	r24, 0x34	; 52
    11c6:	99 e0       	ldi	r25, 0x09	; 9
    11c8:	1f d5       	rcall	.+2622   	; 0x1c08 <ringBufferFull>
    11ca:	81 11       	cpse	r24, r1
    11cc:	fb cf       	rjmp	.-10     	; 0x11c4 <myUSART_transmitUSART0_c+0x18>
    11ce:	6c 2f       	mov	r22, r28
    11d0:	84 e3       	ldi	r24, 0x34	; 52
    11d2:	99 e0       	ldi	r25, 0x09	; 9
    11d4:	02 d5       	rcall	.+2564   	; 0x1bda <ringBufferPush>
    11d6:	e1 ec       	ldi	r30, 0xC1	; 193
    11d8:	f0 e0       	ldi	r31, 0x00	; 0
    11da:	80 81       	ld	r24, Z
    11dc:	80 62       	ori	r24, 0x20	; 32
    11de:	80 83       	st	Z, r24
    11e0:	e0 ec       	ldi	r30, 0xC0	; 192
    11e2:	f0 e0       	ldi	r31, 0x00	; 0
    11e4:	80 81       	ld	r24, Z
    11e6:	80 64       	ori	r24, 0x40	; 64
    11e8:	80 83       	st	Z, r24
    11ea:	cf 91       	pop	r28
    11ec:	08 95       	ret

000011ee <myUSART_transmitUSART1_c>:
    11ee:	cf 93       	push	r28
    11f0:	c8 2f       	mov	r28, r24
    11f2:	20 e0       	ldi	r18, 0x00	; 0
    11f4:	4f ef       	ldi	r20, 0xFF	; 255
    11f6:	5f ef       	ldi	r21, 0xFF	; 255
    11f8:	60 e0       	ldi	r22, 0x00	; 0
    11fa:	70 e0       	ldi	r23, 0x00	; 0
    11fc:	80 91 17 08 	lds	r24, 0x0817
    1200:	90 91 18 08 	lds	r25, 0x0818
    1204:	1e d4       	rcall	.+2108   	; 0x1a42 <xQueueGenericReceive>
    1206:	8f e2       	ldi	r24, 0x2F	; 47
    1208:	99 e0       	ldi	r25, 0x09	; 9
    120a:	fe d4       	rcall	.+2556   	; 0x1c08 <ringBufferFull>
    120c:	81 11       	cpse	r24, r1
    120e:	fb cf       	rjmp	.-10     	; 0x1206 <myUSART_transmitUSART1_c+0x18>
    1210:	6c 2f       	mov	r22, r28
    1212:	8f e2       	ldi	r24, 0x2F	; 47
    1214:	99 e0       	ldi	r25, 0x09	; 9
    1216:	e1 d4       	rcall	.+2498   	; 0x1bda <ringBufferPush>
    1218:	e9 ec       	ldi	r30, 0xC9	; 201
    121a:	f0 e0       	ldi	r31, 0x00	; 0
    121c:	80 81       	ld	r24, Z
    121e:	80 62       	ori	r24, 0x20	; 32
    1220:	80 83       	st	Z, r24
    1222:	e8 ec       	ldi	r30, 0xC8	; 200
    1224:	f0 e0       	ldi	r31, 0x00	; 0
    1226:	80 81       	ld	r24, Z
    1228:	80 64       	ori	r24, 0x40	; 64
    122a:	80 83       	st	Z, r24
    122c:	cf 91       	pop	r28
    122e:	08 95       	ret

00001230 <myUSART_transmitUSART1>:
    1230:	cf 93       	push	r28
    1232:	df 93       	push	r29
    1234:	ec 01       	movw	r28, r24
    1236:	88 81       	ld	r24, Y
    1238:	88 23       	and	r24, r24
    123a:	29 f0       	breq	.+10     	; 0x1246 <myUSART_transmitUSART1+0x16>
    123c:	21 96       	adiw	r28, 0x01	; 1
    123e:	d7 df       	rcall	.-82     	; 0x11ee <myUSART_transmitUSART1_c>
    1240:	89 91       	ld	r24, Y+
    1242:	81 11       	cpse	r24, r1
    1244:	fc cf       	rjmp	.-8      	; 0x123e <myUSART_transmitUSART1+0xe>
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	08 95       	ret

0000124c <myUSART_transmitUSART0>:
    124c:	cf 93       	push	r28
    124e:	df 93       	push	r29
    1250:	ec 01       	movw	r28, r24
    1252:	88 81       	ld	r24, Y
    1254:	88 23       	and	r24, r24
    1256:	29 f0       	breq	.+10     	; 0x1262 <myUSART_transmitUSART0+0x16>
    1258:	21 96       	adiw	r28, 0x01	; 1
    125a:	a8 df       	rcall	.-176    	; 0x11ac <myUSART_transmitUSART0_c>
    125c:	89 91       	ld	r24, Y+
    125e:	81 11       	cpse	r24, r1
    1260:	fc cf       	rjmp	.-8      	; 0x125a <myUSART_transmitUSART0+0xe>
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	08 95       	ret

00001268 <myUSART_receiveUSART1>:
    1268:	cf 93       	push	r28
    126a:	20 e0       	ldi	r18, 0x00	; 0
    126c:	4f ef       	ldi	r20, 0xFF	; 255
    126e:	5f ef       	ldi	r21, 0xFF	; 255
    1270:	60 e0       	ldi	r22, 0x00	; 0
    1272:	70 e0       	ldi	r23, 0x00	; 0
    1274:	80 91 1f 08 	lds	r24, 0x081F
    1278:	90 91 20 08 	lds	r25, 0x0820
    127c:	e2 d3       	rcall	.+1988   	; 0x1a42 <xQueueGenericReceive>
    127e:	89 e3       	ldi	r24, 0x39	; 57
    1280:	99 e0       	ldi	r25, 0x09	; 9
    1282:	99 d4       	rcall	.+2354   	; 0x1bb6 <ringBufferPop>
    1284:	c8 2f       	mov	r28, r24
    1286:	89 e3       	ldi	r24, 0x39	; 57
    1288:	99 e0       	ldi	r25, 0x09	; 9
    128a:	c5 d4       	rcall	.+2442   	; 0x1c16 <ringBufferNotEmpty>
    128c:	88 23       	and	r24, r24
    128e:	51 f0       	breq	.+20     	; 0x12a4 <myUSART_receiveUSART1+0x3c>
    1290:	20 e0       	ldi	r18, 0x00	; 0
    1292:	40 e0       	ldi	r20, 0x00	; 0
    1294:	50 e0       	ldi	r21, 0x00	; 0
    1296:	60 e0       	ldi	r22, 0x00	; 0
    1298:	70 e0       	ldi	r23, 0x00	; 0
    129a:	80 91 1f 08 	lds	r24, 0x081F
    129e:	90 91 20 08 	lds	r25, 0x0820
    12a2:	d7 d2       	rcall	.+1454   	; 0x1852 <xQueueGenericSend>
    12a4:	8c 2f       	mov	r24, r28
    12a6:	cf 91       	pop	r28
    12a8:	08 95       	ret

000012aa <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    12aa:	86 e1       	ldi	r24, 0x16	; 22
    12ac:	a0 df       	rcall	.-192    	; 0x11ee <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    12ae:	20 e0       	ldi	r18, 0x00	; 0
    12b0:	44 ef       	ldi	r20, 0xF4	; 244
    12b2:	51 e0       	ldi	r21, 0x01	; 1
    12b4:	60 e0       	ldi	r22, 0x00	; 0
    12b6:	70 e0       	ldi	r23, 0x00	; 0
    12b8:	80 91 1b 08 	lds	r24, 0x081B
    12bc:	90 91 1c 08 	lds	r25, 0x081C
    12c0:	c0 d3       	rcall	.+1920   	; 0x1a42 <xQueueGenericReceive>
    12c2:	81 30       	cpi	r24, 0x01	; 1
    12c4:	21 f4       	brne	.+8      	; 0x12ce <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    12c6:	82 e0       	ldi	r24, 0x02	; 2
    12c8:	92 df       	rcall	.-220    	; 0x11ee <myUSART_transmitUSART1_c>
		return 1;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	08 95       	ret
	}
	else
	{
		return 0;
    12ce:	80 e0       	ldi	r24, 0x00	; 0
	}

}
    12d0:	08 95       	ret

000012d2 <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    12d2:	20 e0       	ldi	r18, 0x00	; 0
    12d4:	40 e0       	ldi	r20, 0x00	; 0
    12d6:	50 e0       	ldi	r21, 0x00	; 0
    12d8:	60 e0       	ldi	r22, 0x00	; 0
    12da:	70 e0       	ldi	r23, 0x00	; 0
    12dc:	80 91 1b 08 	lds	r24, 0x081B
    12e0:	90 91 1c 08 	lds	r25, 0x081C
    12e4:	b6 c2       	rjmp	.+1388   	; 0x1852 <xQueueGenericSend>
    12e6:	08 95       	ret

000012e8 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    12e8:	91 e0       	ldi	r25, 0x01	; 1
    12ea:	85 30       	cpi	r24, 0x05	; 5
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <myUSART_receiveHandShakeAck+0x8>
    12ee:	90 e0       	ldi	r25, 0x00	; 0
}
    12f0:	89 2f       	mov	r24, r25
    12f2:	08 95       	ret

000012f4 <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    12f4:	91 e0       	ldi	r25, 0x01	; 1
    12f6:	86 31       	cpi	r24, 0x16	; 22
    12f8:	09 f0       	breq	.+2      	; 0x12fc <myUSART_receiveHandShakeStart+0x8>
    12fa:	90 e0       	ldi	r25, 0x00	; 0
}
    12fc:	89 2f       	mov	r24, r25
    12fe:	08 95       	ret

00001300 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	82 30       	cpi	r24, 0x02	; 2
    1304:	09 f0       	breq	.+2      	; 0x1308 <myUSART_receiveHandShakeFin+0x8>
    1306:	90 e0       	ldi	r25, 0x00	; 0
}
    1308:	89 2f       	mov	r24, r25
    130a:	08 95       	ret

0000130c <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    130c:	91 e0       	ldi	r25, 0x01	; 1
    130e:	86 30       	cpi	r24, 0x06	; 6
    1310:	09 f0       	breq	.+2      	; 0x1314 <myUSART_receiveMessageACK+0x8>
    1312:	90 e0       	ldi	r25, 0x00	; 0
}
    1314:	89 2f       	mov	r24, r25
    1316:	08 95       	ret

00001318 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1318:	31 e1       	ldi	r19, 0x11	; 17
    131a:	fc 01       	movw	r30, r24
    131c:	30 83       	st	Z, r19
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	22 e2       	ldi	r18, 0x22	; 34
    1322:	20 83       	st	Z, r18
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	a3 e3       	ldi	r26, 0x33	; 51
    1328:	a0 83       	st	Z, r26
    132a:	31 97       	sbiw	r30, 0x01	; 1
    132c:	60 83       	st	Z, r22
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	70 83       	st	Z, r23
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	10 82       	st	Z, r1
    1336:	31 97       	sbiw	r30, 0x01	; 1
    1338:	10 82       	st	Z, r1
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	60 e8       	ldi	r22, 0x80	; 128
    133e:	60 83       	st	Z, r22
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	10 82       	st	Z, r1
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	10 82       	st	Z, r1
    1348:	31 97       	sbiw	r30, 0x01	; 1
    134a:	10 82       	st	Z, r1
    134c:	31 97       	sbiw	r30, 0x01	; 1
    134e:	62 e0       	ldi	r22, 0x02	; 2
    1350:	60 83       	st	Z, r22
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	63 e0       	ldi	r22, 0x03	; 3
    1356:	60 83       	st	Z, r22
    1358:	31 97       	sbiw	r30, 0x01	; 1
    135a:	64 e0       	ldi	r22, 0x04	; 4
    135c:	60 83       	st	Z, r22
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	65 e0       	ldi	r22, 0x05	; 5
    1362:	60 83       	st	Z, r22
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	66 e0       	ldi	r22, 0x06	; 6
    1368:	60 83       	st	Z, r22
    136a:	31 97       	sbiw	r30, 0x01	; 1
    136c:	67 e0       	ldi	r22, 0x07	; 7
    136e:	60 83       	st	Z, r22
    1370:	31 97       	sbiw	r30, 0x01	; 1
    1372:	68 e0       	ldi	r22, 0x08	; 8
    1374:	60 83       	st	Z, r22
    1376:	31 97       	sbiw	r30, 0x01	; 1
    1378:	69 e0       	ldi	r22, 0x09	; 9
    137a:	60 83       	st	Z, r22
    137c:	31 97       	sbiw	r30, 0x01	; 1
    137e:	60 e1       	ldi	r22, 0x10	; 16
    1380:	60 83       	st	Z, r22
    1382:	31 97       	sbiw	r30, 0x01	; 1
    1384:	30 83       	st	Z, r19
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	32 e1       	ldi	r19, 0x12	; 18
    138a:	30 83       	st	Z, r19
    138c:	31 97       	sbiw	r30, 0x01	; 1
    138e:	33 e1       	ldi	r19, 0x13	; 19
    1390:	30 83       	st	Z, r19
    1392:	31 97       	sbiw	r30, 0x01	; 1
    1394:	34 e1       	ldi	r19, 0x14	; 20
    1396:	30 83       	st	Z, r19
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	35 e1       	ldi	r19, 0x15	; 21
    139c:	30 83       	st	Z, r19
    139e:	31 97       	sbiw	r30, 0x01	; 1
    13a0:	36 e1       	ldi	r19, 0x16	; 22
    13a2:	30 83       	st	Z, r19
    13a4:	31 97       	sbiw	r30, 0x01	; 1
    13a6:	37 e1       	ldi	r19, 0x17	; 23
    13a8:	30 83       	st	Z, r19
    13aa:	31 97       	sbiw	r30, 0x01	; 1
    13ac:	38 e1       	ldi	r19, 0x18	; 24
    13ae:	30 83       	st	Z, r19
    13b0:	31 97       	sbiw	r30, 0x01	; 1
    13b2:	39 e1       	ldi	r19, 0x19	; 25
    13b4:	30 83       	st	Z, r19
    13b6:	31 97       	sbiw	r30, 0x01	; 1
    13b8:	30 e2       	ldi	r19, 0x20	; 32
    13ba:	30 83       	st	Z, r19
    13bc:	31 97       	sbiw	r30, 0x01	; 1
    13be:	31 e2       	ldi	r19, 0x21	; 33
    13c0:	30 83       	st	Z, r19
    13c2:	31 97       	sbiw	r30, 0x01	; 1
    13c4:	20 83       	st	Z, r18
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	23 e2       	ldi	r18, 0x23	; 35
    13ca:	20 83       	st	Z, r18
    13cc:	31 97       	sbiw	r30, 0x01	; 1
    13ce:	40 83       	st	Z, r20
    13d0:	31 97       	sbiw	r30, 0x01	; 1
    13d2:	50 83       	st	Z, r21
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	26 e2       	ldi	r18, 0x26	; 38
    13d8:	20 83       	st	Z, r18
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	27 e2       	ldi	r18, 0x27	; 39
    13de:	20 83       	st	Z, r18
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	28 e2       	ldi	r18, 0x28	; 40
    13e4:	20 83       	st	Z, r18
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	29 e2       	ldi	r18, 0x29	; 41
    13ea:	20 83       	st	Z, r18
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	20 e3       	ldi	r18, 0x30	; 48
    13f0:	20 83       	st	Z, r18
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	21 e3       	ldi	r18, 0x31	; 49
    13f6:	20 83       	st	Z, r18
    13f8:	89 97       	sbiw	r24, 0x29	; 41
    13fa:	08 95       	ret

000013fc <xPortStartScheduler>:
    13fc:	82 e0       	ldi	r24, 0x02	; 2
    13fe:	84 bd       	out	0x24, r24	; 36
    1400:	16 bc       	out	0x26, r1	; 38
    1402:	80 e3       	ldi	r24, 0x30	; 48
    1404:	87 bd       	out	0x27, r24	; 39
    1406:	ee e6       	ldi	r30, 0x6E	; 110
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	80 81       	ld	r24, Z
    140c:	82 60       	ori	r24, 0x02	; 2
    140e:	80 83       	st	Z, r24
    1410:	83 e0       	ldi	r24, 0x03	; 3
    1412:	85 bd       	out	0x25, r24	; 37
    1414:	a0 91 8a 08 	lds	r26, 0x088A
    1418:	b0 91 8b 08 	lds	r27, 0x088B
    141c:	cd 91       	ld	r28, X+
    141e:	cd bf       	out	0x3d, r28	; 61
    1420:	dd 91       	ld	r29, X+
    1422:	de bf       	out	0x3e, r29	; 62
    1424:	ff 91       	pop	r31
    1426:	ef 91       	pop	r30
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	bf 91       	pop	r27
    142e:	af 91       	pop	r26
    1430:	9f 91       	pop	r25
    1432:	8f 91       	pop	r24
    1434:	7f 91       	pop	r23
    1436:	6f 91       	pop	r22
    1438:	5f 91       	pop	r21
    143a:	4f 91       	pop	r20
    143c:	3f 91       	pop	r19
    143e:	2f 91       	pop	r18
    1440:	1f 91       	pop	r17
    1442:	0f 91       	pop	r16
    1444:	ff 90       	pop	r15
    1446:	ef 90       	pop	r14
    1448:	df 90       	pop	r13
    144a:	cf 90       	pop	r12
    144c:	bf 90       	pop	r11
    144e:	af 90       	pop	r10
    1450:	9f 90       	pop	r9
    1452:	8f 90       	pop	r8
    1454:	7f 90       	pop	r7
    1456:	6f 90       	pop	r6
    1458:	5f 90       	pop	r5
    145a:	4f 90       	pop	r4
    145c:	3f 90       	pop	r3
    145e:	2f 90       	pop	r2
    1460:	1f 90       	pop	r1
    1462:	0f 90       	pop	r0
    1464:	0c be       	out	0x3c, r0	; 60
    1466:	0f 90       	pop	r0
    1468:	0b be       	out	0x3b, r0	; 59
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63
    146e:	0f 90       	pop	r0
    1470:	08 95       	ret
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	08 95       	ret

00001476 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1476:	0f 92       	push	r0
    1478:	0f b6       	in	r0, 0x3f	; 63
    147a:	f8 94       	cli
    147c:	0f 92       	push	r0
    147e:	0b b6       	in	r0, 0x3b	; 59
    1480:	0f 92       	push	r0
    1482:	0c b6       	in	r0, 0x3c	; 60
    1484:	0f 92       	push	r0
    1486:	1f 92       	push	r1
    1488:	11 24       	eor	r1, r1
    148a:	2f 92       	push	r2
    148c:	3f 92       	push	r3
    148e:	4f 92       	push	r4
    1490:	5f 92       	push	r5
    1492:	6f 92       	push	r6
    1494:	7f 92       	push	r7
    1496:	8f 92       	push	r8
    1498:	9f 92       	push	r9
    149a:	af 92       	push	r10
    149c:	bf 92       	push	r11
    149e:	cf 92       	push	r12
    14a0:	df 92       	push	r13
    14a2:	ef 92       	push	r14
    14a4:	ff 92       	push	r15
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	2f 93       	push	r18
    14ac:	3f 93       	push	r19
    14ae:	4f 93       	push	r20
    14b0:	5f 93       	push	r21
    14b2:	6f 93       	push	r22
    14b4:	7f 93       	push	r23
    14b6:	8f 93       	push	r24
    14b8:	9f 93       	push	r25
    14ba:	af 93       	push	r26
    14bc:	bf 93       	push	r27
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	ef 93       	push	r30
    14c4:	ff 93       	push	r31
    14c6:	a0 91 8a 08 	lds	r26, 0x088A
    14ca:	b0 91 8b 08 	lds	r27, 0x088B
    14ce:	0d b6       	in	r0, 0x3d	; 61
    14d0:	0d 92       	st	X+, r0
    14d2:	0e b6       	in	r0, 0x3e	; 62
    14d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14d6:	22 d7       	rcall	.+3652   	; 0x231c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14d8:	a0 91 8a 08 	lds	r26, 0x088A
    14dc:	b0 91 8b 08 	lds	r27, 0x088B
    14e0:	cd 91       	ld	r28, X+
    14e2:	cd bf       	out	0x3d, r28	; 61
    14e4:	dd 91       	ld	r29, X+
    14e6:	de bf       	out	0x3e, r29	; 62
    14e8:	ff 91       	pop	r31
    14ea:	ef 91       	pop	r30
    14ec:	df 91       	pop	r29
    14ee:	cf 91       	pop	r28
    14f0:	bf 91       	pop	r27
    14f2:	af 91       	pop	r26
    14f4:	9f 91       	pop	r25
    14f6:	8f 91       	pop	r24
    14f8:	7f 91       	pop	r23
    14fa:	6f 91       	pop	r22
    14fc:	5f 91       	pop	r21
    14fe:	4f 91       	pop	r20
    1500:	3f 91       	pop	r19
    1502:	2f 91       	pop	r18
    1504:	1f 91       	pop	r17
    1506:	0f 91       	pop	r16
    1508:	ff 90       	pop	r15
    150a:	ef 90       	pop	r14
    150c:	df 90       	pop	r13
    150e:	cf 90       	pop	r12
    1510:	bf 90       	pop	r11
    1512:	af 90       	pop	r10
    1514:	9f 90       	pop	r9
    1516:	8f 90       	pop	r8
    1518:	7f 90       	pop	r7
    151a:	6f 90       	pop	r6
    151c:	5f 90       	pop	r5
    151e:	4f 90       	pop	r4
    1520:	3f 90       	pop	r3
    1522:	2f 90       	pop	r2
    1524:	1f 90       	pop	r1
    1526:	0f 90       	pop	r0
    1528:	0c be       	out	0x3c, r0	; 60
    152a:	0f 90       	pop	r0
    152c:	0b be       	out	0x3b, r0	; 59
    152e:	0f 90       	pop	r0
    1530:	0f be       	out	0x3f, r0	; 63
    1532:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1534:	08 95       	ret

00001536 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1536:	0f 92       	push	r0
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	f8 94       	cli
    153c:	0f 92       	push	r0
    153e:	0b b6       	in	r0, 0x3b	; 59
    1540:	0f 92       	push	r0
    1542:	0c b6       	in	r0, 0x3c	; 60
    1544:	0f 92       	push	r0
    1546:	1f 92       	push	r1
    1548:	11 24       	eor	r1, r1
    154a:	2f 92       	push	r2
    154c:	3f 92       	push	r3
    154e:	4f 92       	push	r4
    1550:	5f 92       	push	r5
    1552:	6f 92       	push	r6
    1554:	7f 92       	push	r7
    1556:	8f 92       	push	r8
    1558:	9f 92       	push	r9
    155a:	af 92       	push	r10
    155c:	bf 92       	push	r11
    155e:	cf 92       	push	r12
    1560:	df 92       	push	r13
    1562:	ef 92       	push	r14
    1564:	ff 92       	push	r15
    1566:	0f 93       	push	r16
    1568:	1f 93       	push	r17
    156a:	2f 93       	push	r18
    156c:	3f 93       	push	r19
    156e:	4f 93       	push	r20
    1570:	5f 93       	push	r21
    1572:	6f 93       	push	r22
    1574:	7f 93       	push	r23
    1576:	8f 93       	push	r24
    1578:	9f 93       	push	r25
    157a:	af 93       	push	r26
    157c:	bf 93       	push	r27
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	ef 93       	push	r30
    1584:	ff 93       	push	r31
    1586:	a0 91 8a 08 	lds	r26, 0x088A
    158a:	b0 91 8b 08 	lds	r27, 0x088B
    158e:	0d b6       	in	r0, 0x3d	; 61
    1590:	0d 92       	st	X+, r0
    1592:	0e b6       	in	r0, 0x3e	; 62
    1594:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1596:	f0 d4       	rcall	.+2528   	; 0x1f78 <xTaskIncrementTick>
    1598:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    159a:	c0 d6       	rcall	.+3456   	; 0x231c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    159c:	a0 91 8a 08 	lds	r26, 0x088A
    15a0:	b0 91 8b 08 	lds	r27, 0x088B
    15a4:	cd 91       	ld	r28, X+
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	dd 91       	ld	r29, X+
    15aa:	de bf       	out	0x3e, r29	; 62
    15ac:	ff 91       	pop	r31
    15ae:	ef 91       	pop	r30
    15b0:	df 91       	pop	r29
    15b2:	cf 91       	pop	r28
    15b4:	bf 91       	pop	r27
    15b6:	af 91       	pop	r26
    15b8:	9f 91       	pop	r25
    15ba:	8f 91       	pop	r24
    15bc:	7f 91       	pop	r23
    15be:	6f 91       	pop	r22
    15c0:	5f 91       	pop	r21
    15c2:	4f 91       	pop	r20
    15c4:	3f 91       	pop	r19
    15c6:	2f 91       	pop	r18
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	3f 90       	pop	r3
    15e6:	2f 90       	pop	r2
    15e8:	1f 90       	pop	r1
    15ea:	0f 90       	pop	r0
    15ec:	0c be       	out	0x3c, r0	; 60
    15ee:	0f 90       	pop	r0
    15f0:	0b be       	out	0x3b, r0	; 59
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15f8:	08 95       	ret

000015fa <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    15fa:	9d df       	rcall	.-198    	; 0x1536 <vPortYieldFromTick>
		 asm volatile ("reti");
    15fc:	18 95       	reti

000015fe <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    15fe:	1f 93       	push	r17
    1600:	cf 93       	push	r28
    1602:	df 93       	push	r29
    1604:	ec 01       	movw	r28, r24
    1606:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1608:	8c 8d       	ldd	r24, Y+28	; 0x1c
    160a:	81 11       	cpse	r24, r1
    160c:	0c c0       	rjmp	.+24     	; 0x1626 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    160e:	88 81       	ld	r24, Y
    1610:	99 81       	ldd	r25, Y+1	; 0x01
    1612:	89 2b       	or	r24, r25
    1614:	09 f0       	breq	.+2      	; 0x1618 <prvCopyDataToQueue+0x1a>
    1616:	47 c0       	rjmp	.+142    	; 0x16a6 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1618:	8a 81       	ldd	r24, Y+2	; 0x02
    161a:	9b 81       	ldd	r25, Y+3	; 0x03
    161c:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1620:	1b 82       	std	Y+3, r1	; 0x03
    1622:	1a 82       	std	Y+2, r1	; 0x02
    1624:	47 c0       	rjmp	.+142    	; 0x16b4 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1626:	41 11       	cpse	r20, r1
    1628:	18 c0       	rjmp	.+48     	; 0x165a <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    162a:	48 2f       	mov	r20, r24
    162c:	50 e0       	ldi	r21, 0x00	; 0
    162e:	8c 81       	ldd	r24, Y+4	; 0x04
    1630:	9d 81       	ldd	r25, Y+5	; 0x05
    1632:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1636:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1638:	8c 81       	ldd	r24, Y+4	; 0x04
    163a:	9d 81       	ldd	r25, Y+5	; 0x05
    163c:	82 0f       	add	r24, r18
    163e:	91 1d       	adc	r25, r1
    1640:	9d 83       	std	Y+5, r25	; 0x05
    1642:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1644:	2a 81       	ldd	r18, Y+2	; 0x02
    1646:	3b 81       	ldd	r19, Y+3	; 0x03
    1648:	82 17       	cp	r24, r18
    164a:	93 07       	cpc	r25, r19
    164c:	70 f1       	brcs	.+92     	; 0x16aa <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    164e:	88 81       	ld	r24, Y
    1650:	99 81       	ldd	r25, Y+1	; 0x01
    1652:	9d 83       	std	Y+5, r25	; 0x05
    1654:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1656:	80 e0       	ldi	r24, 0x00	; 0
    1658:	2d c0       	rjmp	.+90     	; 0x16b4 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    165a:	48 2f       	mov	r20, r24
    165c:	50 e0       	ldi	r21, 0x00	; 0
    165e:	8e 81       	ldd	r24, Y+6	; 0x06
    1660:	9f 81       	ldd	r25, Y+7	; 0x07
    1662:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1666:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	31 95       	neg	r19
    166c:	21 95       	neg	r18
    166e:	31 09       	sbc	r19, r1
    1670:	8e 81       	ldd	r24, Y+6	; 0x06
    1672:	9f 81       	ldd	r25, Y+7	; 0x07
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	9f 83       	std	Y+7, r25	; 0x07
    167a:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    167c:	68 81       	ld	r22, Y
    167e:	79 81       	ldd	r23, Y+1	; 0x01
    1680:	86 17       	cp	r24, r22
    1682:	97 07       	cpc	r25, r23
    1684:	30 f4       	brcc	.+12     	; 0x1692 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1686:	8a 81       	ldd	r24, Y+2	; 0x02
    1688:	9b 81       	ldd	r25, Y+3	; 0x03
    168a:	28 0f       	add	r18, r24
    168c:	39 1f       	adc	r19, r25
    168e:	3f 83       	std	Y+7, r19	; 0x07
    1690:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1692:	12 30       	cpi	r17, 0x02	; 2
    1694:	61 f4       	brne	.+24     	; 0x16ae <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1696:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1698:	88 23       	and	r24, r24
    169a:	59 f0       	breq	.+22     	; 0x16b2 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    169c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    169e:	81 50       	subi	r24, 0x01	; 1
    16a0:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16a2:	80 e0       	ldi	r24, 0x00	; 0
    16a4:	07 c0       	rjmp	.+14     	; 0x16b4 <prvCopyDataToQueue+0xb6>
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	05 c0       	rjmp	.+10     	; 0x16b4 <prvCopyDataToQueue+0xb6>
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	03 c0       	rjmp	.+6      	; 0x16b4 <prvCopyDataToQueue+0xb6>
    16ae:	80 e0       	ldi	r24, 0x00	; 0
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <prvCopyDataToQueue+0xb6>
    16b2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16b4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    16b6:	9f 5f       	subi	r25, 0xFF	; 255
    16b8:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    16ba:	df 91       	pop	r29
    16bc:	cf 91       	pop	r28
    16be:	1f 91       	pop	r17
    16c0:	08 95       	ret

000016c2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    16c2:	fc 01       	movw	r30, r24
    16c4:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    16c6:	44 8d       	ldd	r20, Z+28	; 0x1c
    16c8:	44 23       	and	r20, r20
    16ca:	a1 f0       	breq	.+40     	; 0x16f4 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    16cc:	50 e0       	ldi	r21, 0x00	; 0
    16ce:	26 81       	ldd	r18, Z+6	; 0x06
    16d0:	37 81       	ldd	r19, Z+7	; 0x07
    16d2:	24 0f       	add	r18, r20
    16d4:	35 1f       	adc	r19, r21
    16d6:	37 83       	std	Z+7, r19	; 0x07
    16d8:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    16da:	62 81       	ldd	r22, Z+2	; 0x02
    16dc:	73 81       	ldd	r23, Z+3	; 0x03
    16de:	26 17       	cp	r18, r22
    16e0:	37 07       	cpc	r19, r23
    16e2:	20 f0       	brcs	.+8      	; 0x16ec <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    16e4:	20 81       	ld	r18, Z
    16e6:	31 81       	ldd	r19, Z+1	; 0x01
    16e8:	37 83       	std	Z+7, r19	; 0x07
    16ea:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    16ec:	66 81       	ldd	r22, Z+6	; 0x06
    16ee:	77 81       	ldd	r23, Z+7	; 0x07
    16f0:	0c 94 1c 17 	jmp	0x2e38	; 0x2e38 <memcpy>
    16f4:	08 95       	ret

000016f6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    16f6:	0f 93       	push	r16
    16f8:	1f 93       	push	r17
    16fa:	cf 93       	push	r28
    16fc:	df 93       	push	r29
    16fe:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1700:	0f b6       	in	r0, 0x3f	; 63
    1702:	f8 94       	cli
    1704:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1706:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1708:	18 16       	cp	r1, r24
    170a:	a4 f4       	brge	.+40     	; 0x1734 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    170c:	89 89       	ldd	r24, Y+17	; 0x11
    170e:	88 23       	and	r24, r24
    1710:	89 f0       	breq	.+34     	; 0x1734 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1712:	8e 01       	movw	r16, r28
    1714:	0f 5e       	subi	r16, 0xEF	; 239
    1716:	1f 4f       	sbci	r17, 0xFF	; 255
    1718:	03 c0       	rjmp	.+6      	; 0x1720 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    171a:	89 89       	ldd	r24, Y+17	; 0x11
    171c:	88 23       	and	r24, r24
    171e:	51 f0       	breq	.+20     	; 0x1734 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1720:	c8 01       	movw	r24, r16
    1722:	d1 d6       	rcall	.+3490   	; 0x24c6 <xTaskRemoveFromEventList>
    1724:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1726:	5a d7       	rcall	.+3764   	; 0x25dc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1728:	8e 8d       	ldd	r24, Y+30	; 0x1e
    172a:	81 50       	subi	r24, 0x01	; 1
    172c:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    172e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1730:	18 16       	cp	r1, r24
    1732:	9c f3       	brlt	.-26     	; 0x171a <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1734:	8f ef       	ldi	r24, 0xFF	; 255
    1736:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1738:	0f 90       	pop	r0
    173a:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1742:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1744:	18 16       	cp	r1, r24
    1746:	a4 f4       	brge	.+40     	; 0x1770 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1748:	88 85       	ldd	r24, Y+8	; 0x08
    174a:	88 23       	and	r24, r24
    174c:	89 f0       	breq	.+34     	; 0x1770 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    174e:	8e 01       	movw	r16, r28
    1750:	08 5f       	subi	r16, 0xF8	; 248
    1752:	1f 4f       	sbci	r17, 0xFF	; 255
    1754:	03 c0       	rjmp	.+6      	; 0x175c <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1756:	88 85       	ldd	r24, Y+8	; 0x08
    1758:	88 23       	and	r24, r24
    175a:	51 f0       	breq	.+20     	; 0x1770 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    175c:	c8 01       	movw	r24, r16
    175e:	b3 d6       	rcall	.+3430   	; 0x24c6 <xTaskRemoveFromEventList>
    1760:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1762:	3c d7       	rcall	.+3704   	; 0x25dc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1764:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1766:	81 50       	subi	r24, 0x01	; 1
    1768:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    176a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    176c:	18 16       	cp	r1, r24
    176e:	9c f3       	brlt	.-26     	; 0x1756 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1770:	8f ef       	ldi	r24, 0xFF	; 255
    1772:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1774:	0f 90       	pop	r0
    1776:	0f be       	out	0x3f, r0	; 63
}
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	08 95       	ret

00001782 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1782:	cf 93       	push	r28
    1784:	df 93       	push	r29
    1786:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1788:	0f b6       	in	r0, 0x3f	; 63
    178a:	f8 94       	cli
    178c:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    178e:	88 81       	ld	r24, Y
    1790:	99 81       	ldd	r25, Y+1	; 0x01
    1792:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1798:	72 9f       	mul	r23, r18
    179a:	a0 01       	movw	r20, r0
    179c:	73 9f       	mul	r23, r19
    179e:	50 0d       	add	r21, r0
    17a0:	11 24       	eor	r1, r1
    17a2:	fc 01       	movw	r30, r24
    17a4:	e4 0f       	add	r30, r20
    17a6:	f5 1f       	adc	r31, r21
    17a8:	fb 83       	std	Y+3, r31	; 0x03
    17aa:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17ac:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17ae:	9d 83       	std	Y+5, r25	; 0x05
    17b0:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    17b2:	42 1b       	sub	r20, r18
    17b4:	53 0b       	sbc	r21, r19
    17b6:	84 0f       	add	r24, r20
    17b8:	95 1f       	adc	r25, r21
    17ba:	9f 83       	std	Y+7, r25	; 0x07
    17bc:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17be:	8f ef       	ldi	r24, 0xFF	; 255
    17c0:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17c2:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17c4:	61 11       	cpse	r22, r1
    17c6:	0a c0       	rjmp	.+20     	; 0x17dc <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17c8:	88 85       	ldd	r24, Y+8	; 0x08
    17ca:	88 23       	and	r24, r24
    17cc:	79 f0       	breq	.+30     	; 0x17ec <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17ce:	ce 01       	movw	r24, r28
    17d0:	08 96       	adiw	r24, 0x08	; 8
    17d2:	79 d6       	rcall	.+3314   	; 0x24c6 <xTaskRemoveFromEventList>
    17d4:	81 30       	cpi	r24, 0x01	; 1
    17d6:	51 f4       	brne	.+20     	; 0x17ec <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    17d8:	4e de       	rcall	.-868    	; 0x1476 <vPortYield>
    17da:	08 c0       	rjmp	.+16     	; 0x17ec <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17dc:	ce 01       	movw	r24, r28
    17de:	08 96       	adiw	r24, 0x08	; 8
    17e0:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    17e4:	ce 01       	movw	r24, r28
    17e6:	41 96       	adiw	r24, 0x11	; 17
    17e8:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	df 91       	pop	r29
    17f4:	cf 91       	pop	r28
    17f6:	08 95       	ret

000017f8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    17f8:	0f 93       	push	r16
    17fa:	1f 93       	push	r17
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	18 2f       	mov	r17, r24
    1802:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1804:	88 23       	and	r24, r24
    1806:	e9 f0       	breq	.+58     	; 0x1842 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1808:	8f e1       	ldi	r24, 0x1F	; 31
    180a:	90 e0       	ldi	r25, 0x00	; 0
    180c:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
    1810:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1812:	00 97       	sbiw	r24, 0x00	; 0
    1814:	c1 f0       	breq	.+48     	; 0x1846 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1816:	10 9f       	mul	r17, r16
    1818:	c0 01       	movw	r24, r0
    181a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    181c:	01 96       	adiw	r24, 0x01	; 1
    181e:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
    1822:	99 83       	std	Y+1, r25	; 0x01
    1824:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1826:	89 2b       	or	r24, r25
    1828:	31 f0       	breq	.+12     	; 0x1836 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    182a:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    182c:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    182e:	61 e0       	ldi	r22, 0x01	; 1
    1830:	ce 01       	movw	r24, r28
    1832:	a7 df       	rcall	.-178    	; 0x1782 <xQueueGenericReset>
    1834:	08 c0       	rjmp	.+16     	; 0x1846 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1836:	ce 01       	movw	r24, r28
    1838:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    183c:	c0 e0       	ldi	r28, 0x00	; 0
    183e:	d0 e0       	ldi	r29, 0x00	; 0
    1840:	02 c0       	rjmp	.+4      	; 0x1846 <xQueueGenericCreate+0x4e>
    1842:	c0 e0       	ldi	r28, 0x00	; 0
    1844:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1846:	ce 01       	movw	r24, r28
    1848:	df 91       	pop	r29
    184a:	cf 91       	pop	r28
    184c:	1f 91       	pop	r17
    184e:	0f 91       	pop	r16
    1850:	08 95       	ret

00001852 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1852:	9f 92       	push	r9
    1854:	af 92       	push	r10
    1856:	bf 92       	push	r11
    1858:	cf 92       	push	r12
    185a:	df 92       	push	r13
    185c:	ef 92       	push	r14
    185e:	ff 92       	push	r15
    1860:	0f 93       	push	r16
    1862:	1f 93       	push	r17
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
    1868:	00 d0       	rcall	.+0      	; 0x186a <xQueueGenericSend+0x18>
    186a:	1f 92       	push	r1
    186c:	1f 92       	push	r1
    186e:	cd b7       	in	r28, 0x3d	; 61
    1870:	de b7       	in	r29, 0x3e	; 62
    1872:	8c 01       	movw	r16, r24
    1874:	6b 01       	movw	r12, r22
    1876:	5d 83       	std	Y+5, r21	; 0x05
    1878:	4c 83       	std	Y+4, r20	; 0x04
    187a:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    187c:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    187e:	99 24       	eor	r9, r9
    1880:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1882:	7c 01       	movw	r14, r24
    1884:	88 e0       	ldi	r24, 0x08	; 8
    1886:	e8 0e       	add	r14, r24
    1888:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    188a:	0f b6       	in	r0, 0x3f	; 63
    188c:	f8 94       	cli
    188e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1890:	f8 01       	movw	r30, r16
    1892:	92 8d       	ldd	r25, Z+26	; 0x1a
    1894:	83 8d       	ldd	r24, Z+27	; 0x1b
    1896:	98 17       	cp	r25, r24
    1898:	18 f0       	brcs	.+6      	; 0x18a0 <xQueueGenericSend+0x4e>
    189a:	f2 e0       	ldi	r31, 0x02	; 2
    189c:	af 12       	cpse	r10, r31
    189e:	15 c0       	rjmp	.+42     	; 0x18ca <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18a0:	4a 2d       	mov	r20, r10
    18a2:	b6 01       	movw	r22, r12
    18a4:	c8 01       	movw	r24, r16
    18a6:	ab de       	rcall	.-682    	; 0x15fe <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18a8:	f8 01       	movw	r30, r16
    18aa:	91 89       	ldd	r25, Z+17	; 0x11
    18ac:	99 23       	and	r25, r25
    18ae:	39 f0       	breq	.+14     	; 0x18be <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18b0:	c8 01       	movw	r24, r16
    18b2:	41 96       	adiw	r24, 0x11	; 17
    18b4:	08 d6       	rcall	.+3088   	; 0x24c6 <xTaskRemoveFromEventList>
    18b6:	81 30       	cpi	r24, 0x01	; 1
    18b8:	21 f4       	brne	.+8      	; 0x18c2 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    18ba:	dd dd       	rcall	.-1094   	; 0x1476 <vPortYield>
    18bc:	02 c0       	rjmp	.+4      	; 0x18c2 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    18be:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    18c0:	da dd       	rcall	.-1100   	; 0x1476 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	46 c0       	rjmp	.+140    	; 0x1956 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18ca:	ec 81       	ldd	r30, Y+4	; 0x04
    18cc:	fd 81       	ldd	r31, Y+5	; 0x05
    18ce:	ef 2b       	or	r30, r31
    18d0:	21 f4       	brne	.+8      	; 0x18da <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18d2:	0f 90       	pop	r0
    18d4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    18d6:	80 e0       	ldi	r24, 0x00	; 0
    18d8:	3e c0       	rjmp	.+124    	; 0x1956 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    18da:	b1 10       	cpse	r11, r1
    18dc:	04 c0       	rjmp	.+8      	; 0x18e6 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18de:	ce 01       	movw	r24, r28
    18e0:	01 96       	adiw	r24, 0x01	; 1
    18e2:	39 d6       	rcall	.+3186   	; 0x2556 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18e4:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18e6:	0f 90       	pop	r0
    18e8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18ea:	31 d3       	rcall	.+1634   	; 0x1f4e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18ec:	0f b6       	in	r0, 0x3f	; 63
    18ee:	f8 94       	cli
    18f0:	0f 92       	push	r0
    18f2:	f8 01       	movw	r30, r16
    18f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    18f6:	8f 3f       	cpi	r24, 0xFF	; 255
    18f8:	09 f4       	brne	.+2      	; 0x18fc <xQueueGenericSend+0xaa>
    18fa:	15 8e       	std	Z+29, r1	; 0x1d
    18fc:	f8 01       	movw	r30, r16
    18fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1900:	8f 3f       	cpi	r24, 0xFF	; 255
    1902:	09 f4       	brne	.+2      	; 0x1906 <xQueueGenericSend+0xb4>
    1904:	16 8e       	std	Z+30, r1	; 0x1e
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    190a:	be 01       	movw	r22, r28
    190c:	6c 5f       	subi	r22, 0xFC	; 252
    190e:	7f 4f       	sbci	r23, 0xFF	; 255
    1910:	ce 01       	movw	r24, r28
    1912:	01 96       	adiw	r24, 0x01	; 1
    1914:	2b d6       	rcall	.+3158   	; 0x256c <xTaskCheckForTimeOut>
    1916:	81 11       	cpse	r24, r1
    1918:	1a c0       	rjmp	.+52     	; 0x194e <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1920:	f8 01       	movw	r30, r16
    1922:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1924:	0f 90       	pop	r0
    1926:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1928:	f8 01       	movw	r30, r16
    192a:	83 8d       	ldd	r24, Z+27	; 0x1b
    192c:	98 13       	cpse	r25, r24
    192e:	0b c0       	rjmp	.+22     	; 0x1946 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1930:	6c 81       	ldd	r22, Y+4	; 0x04
    1932:	7d 81       	ldd	r23, Y+5	; 0x05
    1934:	c7 01       	movw	r24, r14
    1936:	9c d5       	rcall	.+2872   	; 0x2470 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1938:	c8 01       	movw	r24, r16
    193a:	dd de       	rcall	.-582    	; 0x16f6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    193c:	db d3       	rcall	.+1974   	; 0x20f4 <xTaskResumeAll>
    193e:	81 11       	cpse	r24, r1
    1940:	a4 cf       	rjmp	.-184    	; 0x188a <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1942:	99 dd       	rcall	.-1230   	; 0x1476 <vPortYield>
    1944:	a2 cf       	rjmp	.-188    	; 0x188a <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1946:	c8 01       	movw	r24, r16
    1948:	d6 de       	rcall	.-596    	; 0x16f6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    194a:	d4 d3       	rcall	.+1960   	; 0x20f4 <xTaskResumeAll>
    194c:	9e cf       	rjmp	.-196    	; 0x188a <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    194e:	c8 01       	movw	r24, r16
    1950:	d2 de       	rcall	.-604    	; 0x16f6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1952:	d0 d3       	rcall	.+1952   	; 0x20f4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1954:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1956:	0f 90       	pop	r0
    1958:	0f 90       	pop	r0
    195a:	0f 90       	pop	r0
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	df 91       	pop	r29
    1962:	cf 91       	pop	r28
    1964:	1f 91       	pop	r17
    1966:	0f 91       	pop	r16
    1968:	ff 90       	pop	r15
    196a:	ef 90       	pop	r14
    196c:	df 90       	pop	r13
    196e:	cf 90       	pop	r12
    1970:	bf 90       	pop	r11
    1972:	af 90       	pop	r10
    1974:	9f 90       	pop	r9
    1976:	08 95       	ret

00001978 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    197c:	8f e1       	ldi	r24, 0x1F	; 31
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
    1984:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1986:	00 97       	sbiw	r24, 0x00	; 0
    1988:	f1 f0       	breq	.+60     	; 0x19c6 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    198a:	1b 82       	std	Y+3, r1	; 0x03
    198c:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    198e:	19 82       	std	Y+1, r1	; 0x01
    1990:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1992:	1d 82       	std	Y+5, r1	; 0x05
    1994:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1996:	1f 82       	std	Y+7, r1	; 0x07
    1998:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    199a:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    19a0:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    19a2:	8f ef       	ldi	r24, 0xFF	; 255
    19a4:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    19a6:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19a8:	ce 01       	movw	r24, r28
    19aa:	08 96       	adiw	r24, 0x08	; 8
    19ac:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19b0:	ce 01       	movw	r24, r28
    19b2:	41 96       	adiw	r24, 0x11	; 17
    19b4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    19b8:	20 e0       	ldi	r18, 0x00	; 0
    19ba:	40 e0       	ldi	r20, 0x00	; 0
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	60 e0       	ldi	r22, 0x00	; 0
    19c0:	70 e0       	ldi	r23, 0x00	; 0
    19c2:	ce 01       	movw	r24, r28
    19c4:	46 df       	rcall	.-372    	; 0x1852 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    19c6:	ce 01       	movw	r24, r28
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	08 95       	ret

000019ce <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	ec 01       	movw	r28, r24
    19d8:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19da:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19dc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19de:	98 17       	cp	r25, r24
    19e0:	10 f0       	brcs	.+4      	; 0x19e6 <xQueueGenericSendFromISR+0x18>
    19e2:	22 30       	cpi	r18, 0x02	; 2
    19e4:	11 f5       	brne	.+68     	; 0x1a2a <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    19e6:	42 2f       	mov	r20, r18
    19e8:	ce 01       	movw	r24, r28
    19ea:	09 de       	rcall	.-1006   	; 0x15fe <prvCopyDataToQueue>
    19ec:	88 23       	and	r24, r24
    19ee:	31 f0       	breq	.+12     	; 0x19fc <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    19f0:	01 15       	cp	r16, r1
    19f2:	11 05       	cpc	r17, r1
    19f4:	19 f0       	breq	.+6      	; 0x19fc <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	f8 01       	movw	r30, r16
    19fa:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    19fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1a00:	79 f4       	brne	.+30     	; 0x1a20 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a02:	89 89       	ldd	r24, Y+17	; 0x11
    1a04:	88 23       	and	r24, r24
    1a06:	99 f0       	breq	.+38     	; 0x1a2e <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a08:	ce 01       	movw	r24, r28
    1a0a:	41 96       	adiw	r24, 0x11	; 17
    1a0c:	5c d5       	rcall	.+2744   	; 0x24c6 <xTaskRemoveFromEventList>
    1a0e:	88 23       	and	r24, r24
    1a10:	81 f0       	breq	.+32     	; 0x1a32 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a12:	01 15       	cp	r16, r1
    1a14:	11 05       	cpc	r17, r1
    1a16:	79 f0       	breq	.+30     	; 0x1a36 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	f8 01       	movw	r30, r16
    1a1c:	80 83       	st	Z, r24
    1a1e:	0c c0       	rjmp	.+24     	; 0x1a38 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a20:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a22:	8f 5f       	subi	r24, 0xFF	; 255
    1a24:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a26:	81 e0       	ldi	r24, 0x01	; 1
    1a28:	07 c0       	rjmp	.+14     	; 0x1a38 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	05 c0       	rjmp	.+10     	; 0x1a38 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	03 c0       	rjmp	.+6      	; 0x1a38 <xQueueGenericSendFromISR+0x6a>
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	01 c0       	rjmp	.+2      	; 0x1a38 <xQueueGenericSendFromISR+0x6a>
    1a36:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a38:	df 91       	pop	r29
    1a3a:	cf 91       	pop	r28
    1a3c:	1f 91       	pop	r17
    1a3e:	0f 91       	pop	r16
    1a40:	08 95       	ret

00001a42 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a42:	9f 92       	push	r9
    1a44:	af 92       	push	r10
    1a46:	bf 92       	push	r11
    1a48:	cf 92       	push	r12
    1a4a:	df 92       	push	r13
    1a4c:	ef 92       	push	r14
    1a4e:	ff 92       	push	r15
    1a50:	0f 93       	push	r16
    1a52:	1f 93       	push	r17
    1a54:	cf 93       	push	r28
    1a56:	df 93       	push	r29
    1a58:	00 d0       	rcall	.+0      	; 0x1a5a <xQueueGenericReceive+0x18>
    1a5a:	1f 92       	push	r1
    1a5c:	1f 92       	push	r1
    1a5e:	cd b7       	in	r28, 0x3d	; 61
    1a60:	de b7       	in	r29, 0x3e	; 62
    1a62:	8c 01       	movw	r16, r24
    1a64:	6b 01       	movw	r12, r22
    1a66:	5d 83       	std	Y+5, r21	; 0x05
    1a68:	4c 83       	std	Y+4, r20	; 0x04
    1a6a:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1a6c:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1a6e:	99 24       	eor	r9, r9
    1a70:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a72:	7c 01       	movw	r14, r24
    1a74:	81 e1       	ldi	r24, 0x11	; 17
    1a76:	e8 0e       	add	r14, r24
    1a78:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a7a:	0f b6       	in	r0, 0x3f	; 63
    1a7c:	f8 94       	cli
    1a7e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a80:	f8 01       	movw	r30, r16
    1a82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a84:	88 23       	and	r24, r24
    1a86:	69 f1       	breq	.+90     	; 0x1ae2 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a88:	e6 80       	ldd	r14, Z+6	; 0x06
    1a8a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a8c:	b6 01       	movw	r22, r12
    1a8e:	c8 01       	movw	r24, r16
    1a90:	18 de       	rcall	.-976    	; 0x16c2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a92:	b1 10       	cpse	r11, r1
    1a94:	17 c0       	rjmp	.+46     	; 0x1ac4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a96:	f8 01       	movw	r30, r16
    1a98:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a9a:	81 50       	subi	r24, 0x01	; 1
    1a9c:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a9e:	80 81       	ld	r24, Z
    1aa0:	91 81       	ldd	r25, Z+1	; 0x01
    1aa2:	89 2b       	or	r24, r25
    1aa4:	21 f4       	brne	.+8      	; 0x1aae <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1aa6:	3b d6       	rcall	.+3190   	; 0x271e <pvTaskIncrementMutexHeldCount>
    1aa8:	f8 01       	movw	r30, r16
    1aaa:	93 83       	std	Z+3, r25	; 0x03
    1aac:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aae:	f8 01       	movw	r30, r16
    1ab0:	80 85       	ldd	r24, Z+8	; 0x08
    1ab2:	88 23       	and	r24, r24
    1ab4:	91 f0       	breq	.+36     	; 0x1ada <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ab6:	c8 01       	movw	r24, r16
    1ab8:	08 96       	adiw	r24, 0x08	; 8
    1aba:	05 d5       	rcall	.+2570   	; 0x24c6 <xTaskRemoveFromEventList>
    1abc:	81 30       	cpi	r24, 0x01	; 1
    1abe:	69 f4       	brne	.+26     	; 0x1ada <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1ac0:	da dc       	rcall	.-1612   	; 0x1476 <vPortYield>
    1ac2:	0b c0       	rjmp	.+22     	; 0x1ada <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1ac4:	f8 01       	movw	r30, r16
    1ac6:	f7 82       	std	Z+7, r15	; 0x07
    1ac8:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aca:	81 89       	ldd	r24, Z+17	; 0x11
    1acc:	88 23       	and	r24, r24
    1ace:	29 f0       	breq	.+10     	; 0x1ada <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ad0:	c8 01       	movw	r24, r16
    1ad2:	41 96       	adiw	r24, 0x11	; 17
    1ad4:	f8 d4       	rcall	.+2544   	; 0x24c6 <xTaskRemoveFromEventList>
    1ad6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1ad8:	ce dc       	rcall	.-1636   	; 0x1476 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ade:	81 e0       	ldi	r24, 0x01	; 1
    1ae0:	52 c0       	rjmp	.+164    	; 0x1b86 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ae2:	4c 81       	ldd	r20, Y+4	; 0x04
    1ae4:	5d 81       	ldd	r21, Y+5	; 0x05
    1ae6:	45 2b       	or	r20, r21
    1ae8:	21 f4       	brne	.+8      	; 0x1af2 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1aea:	0f 90       	pop	r0
    1aec:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1aee:	80 e0       	ldi	r24, 0x00	; 0
    1af0:	4a c0       	rjmp	.+148    	; 0x1b86 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1af2:	a1 10       	cpse	r10, r1
    1af4:	04 c0       	rjmp	.+8      	; 0x1afe <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1af6:	ce 01       	movw	r24, r28
    1af8:	01 96       	adiw	r24, 0x01	; 1
    1afa:	2d d5       	rcall	.+2650   	; 0x2556 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1afc:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1afe:	0f 90       	pop	r0
    1b00:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b02:	25 d2       	rcall	.+1098   	; 0x1f4e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	0f 92       	push	r0
    1b0a:	f8 01       	movw	r30, r16
    1b0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b10:	09 f4       	brne	.+2      	; 0x1b14 <xQueueGenericReceive+0xd2>
    1b12:	15 8e       	std	Z+29, r1	; 0x1d
    1b14:	f8 01       	movw	r30, r16
    1b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b18:	8f 3f       	cpi	r24, 0xFF	; 255
    1b1a:	09 f4       	brne	.+2      	; 0x1b1e <xQueueGenericReceive+0xdc>
    1b1c:	16 8e       	std	Z+30, r1	; 0x1e
    1b1e:	0f 90       	pop	r0
    1b20:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b22:	be 01       	movw	r22, r28
    1b24:	6c 5f       	subi	r22, 0xFC	; 252
    1b26:	7f 4f       	sbci	r23, 0xFF	; 255
    1b28:	ce 01       	movw	r24, r28
    1b2a:	01 96       	adiw	r24, 0x01	; 1
    1b2c:	1f d5       	rcall	.+2622   	; 0x256c <xTaskCheckForTimeOut>
    1b2e:	81 11       	cpse	r24, r1
    1b30:	26 c0       	rjmp	.+76     	; 0x1b7e <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b32:	0f b6       	in	r0, 0x3f	; 63
    1b34:	f8 94       	cli
    1b36:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b38:	f8 01       	movw	r30, r16
    1b3a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b3c:	0f 90       	pop	r0
    1b3e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b40:	81 11       	cpse	r24, r1
    1b42:	19 c0       	rjmp	.+50     	; 0x1b76 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b44:	f8 01       	movw	r30, r16
    1b46:	80 81       	ld	r24, Z
    1b48:	91 81       	ldd	r25, Z+1	; 0x01
    1b4a:	89 2b       	or	r24, r25
    1b4c:	49 f4       	brne	.+18     	; 0x1b60 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	f8 94       	cli
    1b52:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b54:	f8 01       	movw	r30, r16
    1b56:	82 81       	ldd	r24, Z+2	; 0x02
    1b58:	93 81       	ldd	r25, Z+3	; 0x03
    1b5a:	44 d5       	rcall	.+2696   	; 0x25e4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b5c:	0f 90       	pop	r0
    1b5e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b60:	6c 81       	ldd	r22, Y+4	; 0x04
    1b62:	7d 81       	ldd	r23, Y+5	; 0x05
    1b64:	c7 01       	movw	r24, r14
    1b66:	84 d4       	rcall	.+2312   	; 0x2470 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b68:	c8 01       	movw	r24, r16
    1b6a:	c5 dd       	rcall	.-1142   	; 0x16f6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b6c:	c3 d2       	rcall	.+1414   	; 0x20f4 <xTaskResumeAll>
    1b6e:	81 11       	cpse	r24, r1
    1b70:	84 cf       	rjmp	.-248    	; 0x1a7a <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1b72:	81 dc       	rcall	.-1790   	; 0x1476 <vPortYield>
    1b74:	82 cf       	rjmp	.-252    	; 0x1a7a <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b76:	c8 01       	movw	r24, r16
    1b78:	be dd       	rcall	.-1156   	; 0x16f6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b7a:	bc d2       	rcall	.+1400   	; 0x20f4 <xTaskResumeAll>
    1b7c:	7e cf       	rjmp	.-260    	; 0x1a7a <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b7e:	c8 01       	movw	r24, r16
    1b80:	ba dd       	rcall	.-1164   	; 0x16f6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b82:	b8 d2       	rcall	.+1392   	; 0x20f4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b84:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b86:	0f 90       	pop	r0
    1b88:	0f 90       	pop	r0
    1b8a:	0f 90       	pop	r0
    1b8c:	0f 90       	pop	r0
    1b8e:	0f 90       	pop	r0
    1b90:	df 91       	pop	r29
    1b92:	cf 91       	pop	r28
    1b94:	1f 91       	pop	r17
    1b96:	0f 91       	pop	r16
    1b98:	ff 90       	pop	r15
    1b9a:	ef 90       	pop	r14
    1b9c:	df 90       	pop	r13
    1b9e:	cf 90       	pop	r12
    1ba0:	bf 90       	pop	r11
    1ba2:	af 90       	pop	r10
    1ba4:	9f 90       	pop	r9
    1ba6:	08 95       	ret

00001ba8 <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1ba8:	fc 01       	movw	r30, r24
    1baa:	71 83       	std	Z+1, r23	; 0x01
    1bac:	60 83       	st	Z, r22
    1bae:	42 83       	std	Z+2, r20	; 0x02
    1bb0:	14 82       	std	Z+4, r1	; 0x04
    1bb2:	13 82       	std	Z+3, r1	; 0x03
    1bb4:	08 95       	ret

00001bb6 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1bb6:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1bb8:	94 81       	ldd	r25, Z+4	; 0x04
    1bba:	a0 81       	ld	r26, Z
    1bbc:	b1 81       	ldd	r27, Z+1	; 0x01
    1bbe:	a9 0f       	add	r26, r25
    1bc0:	b1 1d       	adc	r27, r1
    1bc2:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1bc4:	9f 5f       	subi	r25, 0xFF	; 255
    1bc6:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1bc8:	22 81       	ldd	r18, Z+2	; 0x02
    1bca:	92 17       	cp	r25, r18
    1bcc:	10 f0       	brcs	.+4      	; 0x1bd2 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1bce:	92 1b       	sub	r25, r18
    1bd0:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1bd2:	93 81       	ldd	r25, Z+3	; 0x03
    1bd4:	91 50       	subi	r25, 0x01	; 1
    1bd6:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1bd8:	08 95       	ret

00001bda <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1bda:	fc 01       	movw	r30, r24
    1bdc:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1bde:	83 81       	ldd	r24, Z+3	; 0x03
    1be0:	22 81       	ldd	r18, Z+2	; 0x02
    1be2:	82 17       	cp	r24, r18
    1be4:	80 f4       	brcc	.+32     	; 0x1c06 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1be6:	34 81       	ldd	r19, Z+4	; 0x04
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	83 0f       	add	r24, r19
    1bec:	91 1d       	adc	r25, r1
    1bee:	62 2f       	mov	r22, r18
    1bf0:	70 e0       	ldi	r23, 0x00	; 0
    1bf2:	0e 94 f5 16 	call	0x2dea	; 0x2dea <__divmodhi4>
    1bf6:	a0 81       	ld	r26, Z
    1bf8:	b1 81       	ldd	r27, Z+1	; 0x01
    1bfa:	a8 0f       	add	r26, r24
    1bfc:	b9 1f       	adc	r27, r25
    1bfe:	4c 93       	st	X, r20
            ring->rLength++;
    1c00:	83 81       	ldd	r24, Z+3	; 0x03
    1c02:	8f 5f       	subi	r24, 0xFF	; 255
    1c04:	83 83       	std	Z+3, r24	; 0x03
    1c06:	08 95       	ret

00001c08 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c08:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c0a:	81 e0       	ldi	r24, 0x01	; 1
    1c0c:	22 81       	ldd	r18, Z+2	; 0x02
    1c0e:	93 81       	ldd	r25, Z+3	; 0x03
    1c10:	29 13       	cpse	r18, r25
    1c12:	80 e0       	ldi	r24, 0x00	; 0
}
    1c14:	08 95       	ret

00001c16 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c16:	21 e0       	ldi	r18, 0x01	; 1
    1c18:	fc 01       	movw	r30, r24
    1c1a:	83 81       	ldd	r24, Z+3	; 0x03
    1c1c:	81 11       	cpse	r24, r1
    1c1e:	01 c0       	rjmp	.+2      	; 0x1c22 <ringBufferNotEmpty+0xc>
    1c20:	20 e0       	ldi	r18, 0x00	; 0
}
    1c22:	82 2f       	mov	r24, r18
    1c24:	08 95       	ret

00001c26 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c26:	e0 91 49 08 	lds	r30, 0x0849
    1c2a:	f0 91 4a 08 	lds	r31, 0x084A
    1c2e:	80 81       	ld	r24, Z
    1c30:	81 11       	cpse	r24, r1
    1c32:	07 c0       	rjmp	.+14     	; 0x1c42 <prvResetNextTaskUnblockTime+0x1c>
    1c34:	8f ef       	ldi	r24, 0xFF	; 255
    1c36:	9f ef       	ldi	r25, 0xFF	; 255
    1c38:	90 93 06 02 	sts	0x0206, r25
    1c3c:	80 93 05 02 	sts	0x0205, r24
    1c40:	08 95       	ret
    1c42:	e0 91 49 08 	lds	r30, 0x0849
    1c46:	f0 91 4a 08 	lds	r31, 0x084A
    1c4a:	05 80       	ldd	r0, Z+5	; 0x05
    1c4c:	f6 81       	ldd	r31, Z+6	; 0x06
    1c4e:	e0 2d       	mov	r30, r0
    1c50:	06 80       	ldd	r0, Z+6	; 0x06
    1c52:	f7 81       	ldd	r31, Z+7	; 0x07
    1c54:	e0 2d       	mov	r30, r0
    1c56:	82 81       	ldd	r24, Z+2	; 0x02
    1c58:	93 81       	ldd	r25, Z+3	; 0x03
    1c5a:	90 93 06 02 	sts	0x0206, r25
    1c5e:	80 93 05 02 	sts	0x0205, r24
    1c62:	08 95       	ret

00001c64 <prvAddCurrentTaskToDelayedList>:
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	ec 01       	movw	r28, r24
    1c6a:	e0 91 8a 08 	lds	r30, 0x088A
    1c6e:	f0 91 8b 08 	lds	r31, 0x088B
    1c72:	93 83       	std	Z+3, r25	; 0x03
    1c74:	82 83       	std	Z+2, r24	; 0x02
    1c76:	80 91 28 08 	lds	r24, 0x0828
    1c7a:	90 91 29 08 	lds	r25, 0x0829
    1c7e:	c8 17       	cp	r28, r24
    1c80:	d9 07       	cpc	r29, r25
    1c82:	68 f4       	brcc	.+26     	; 0x1c9e <prvAddCurrentTaskToDelayedList+0x3a>
    1c84:	60 91 8a 08 	lds	r22, 0x088A
    1c88:	70 91 8b 08 	lds	r23, 0x088B
    1c8c:	80 91 47 08 	lds	r24, 0x0847
    1c90:	90 91 48 08 	lds	r25, 0x0848
    1c94:	6e 5f       	subi	r22, 0xFE	; 254
    1c96:	7f 4f       	sbci	r23, 0xFF	; 255
    1c98:	0e 94 90 03 	call	0x720	; 0x720 <vListInsert>
    1c9c:	17 c0       	rjmp	.+46     	; 0x1ccc <prvAddCurrentTaskToDelayedList+0x68>
    1c9e:	60 91 8a 08 	lds	r22, 0x088A
    1ca2:	70 91 8b 08 	lds	r23, 0x088B
    1ca6:	80 91 49 08 	lds	r24, 0x0849
    1caa:	90 91 4a 08 	lds	r25, 0x084A
    1cae:	6e 5f       	subi	r22, 0xFE	; 254
    1cb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb2:	0e 94 90 03 	call	0x720	; 0x720 <vListInsert>
    1cb6:	80 91 05 02 	lds	r24, 0x0205
    1cba:	90 91 06 02 	lds	r25, 0x0206
    1cbe:	c8 17       	cp	r28, r24
    1cc0:	d9 07       	cpc	r29, r25
    1cc2:	20 f4       	brcc	.+8      	; 0x1ccc <prvAddCurrentTaskToDelayedList+0x68>
    1cc4:	d0 93 06 02 	sts	0x0206, r29
    1cc8:	c0 93 05 02 	sts	0x0205, r28
    1ccc:	df 91       	pop	r29
    1cce:	cf 91       	pop	r28
    1cd0:	08 95       	ret

00001cd2 <xTaskGenericCreate>:
    1cd2:	4f 92       	push	r4
    1cd4:	5f 92       	push	r5
    1cd6:	6f 92       	push	r6
    1cd8:	7f 92       	push	r7
    1cda:	8f 92       	push	r8
    1cdc:	9f 92       	push	r9
    1cde:	af 92       	push	r10
    1ce0:	bf 92       	push	r11
    1ce2:	cf 92       	push	r12
    1ce4:	df 92       	push	r13
    1ce6:	ef 92       	push	r14
    1ce8:	ff 92       	push	r15
    1cea:	0f 93       	push	r16
    1cec:	1f 93       	push	r17
    1cee:	cf 93       	push	r28
    1cf0:	df 93       	push	r29
    1cf2:	4c 01       	movw	r8, r24
    1cf4:	5b 01       	movw	r10, r22
    1cf6:	2a 01       	movw	r4, r20
    1cf8:	39 01       	movw	r6, r18
    1cfa:	83 e2       	ldi	r24, 0x23	; 35
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
    1d02:	ec 01       	movw	r28, r24
    1d04:	00 97       	sbiw	r24, 0x00	; 0
    1d06:	09 f4       	brne	.+2      	; 0x1d0a <xTaskGenericCreate+0x38>
    1d08:	e7 c0       	rjmp	.+462    	; 0x1ed8 <xTaskGenericCreate+0x206>
    1d0a:	c1 14       	cp	r12, r1
    1d0c:	d1 04       	cpc	r13, r1
    1d0e:	09 f0       	breq	.+2      	; 0x1d12 <xTaskGenericCreate+0x40>
    1d10:	cc c0       	rjmp	.+408    	; 0x1eaa <xTaskGenericCreate+0x1d8>
    1d12:	c2 01       	movw	r24, r4
    1d14:	0e 94 27 03 	call	0x64e	; 0x64e <pvPortMalloc>
    1d18:	98 8f       	std	Y+24, r25	; 0x18
    1d1a:	8f 8b       	std	Y+23, r24	; 0x17
    1d1c:	89 2b       	or	r24, r25
    1d1e:	09 f0       	breq	.+2      	; 0x1d22 <xTaskGenericCreate+0x50>
    1d20:	c6 c0       	rjmp	.+396    	; 0x1eae <xTaskGenericCreate+0x1dc>
    1d22:	ce 01       	movw	r24, r28
    1d24:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <vPortFree>
    1d28:	d7 c0       	rjmp	.+430    	; 0x1ed8 <xTaskGenericCreate+0x206>
    1d2a:	cf 01       	movw	r24, r30
    1d2c:	31 91       	ld	r19, Z+
    1d2e:	da 01       	movw	r26, r20
    1d30:	3d 93       	st	X+, r19
    1d32:	ad 01       	movw	r20, r26
    1d34:	dc 01       	movw	r26, r24
    1d36:	8c 91       	ld	r24, X
    1d38:	88 23       	and	r24, r24
    1d3a:	11 f0       	breq	.+4      	; 0x1d40 <xTaskGenericCreate+0x6e>
    1d3c:	21 50       	subi	r18, 0x01	; 1
    1d3e:	a9 f7       	brne	.-22     	; 0x1d2a <xTaskGenericCreate+0x58>
    1d40:	18 a2       	std	Y+32, r1	; 0x20
    1d42:	10 2f       	mov	r17, r16
    1d44:	05 30       	cpi	r16, 0x05	; 5
    1d46:	08 f0       	brcs	.+2      	; 0x1d4a <xTaskGenericCreate+0x78>
    1d48:	14 e0       	ldi	r17, 0x04	; 4
    1d4a:	1e 8b       	std	Y+22, r17	; 0x16
    1d4c:	19 a3       	std	Y+33, r17	; 0x21
    1d4e:	1a a2       	std	Y+34, r1	; 0x22
    1d50:	5e 01       	movw	r10, r28
    1d52:	b2 e0       	ldi	r27, 0x02	; 2
    1d54:	ab 0e       	add	r10, r27
    1d56:	b1 1c       	adc	r11, r1
    1d58:	c5 01       	movw	r24, r10
    1d5a:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vListInitialiseItem>
    1d5e:	ce 01       	movw	r24, r28
    1d60:	0c 96       	adiw	r24, 0x0c	; 12
    1d62:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <vListInitialiseItem>
    1d66:	d9 87       	std	Y+9, r29	; 0x09
    1d68:	c8 87       	std	Y+8, r28	; 0x08
    1d6a:	85 e0       	ldi	r24, 0x05	; 5
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	81 1b       	sub	r24, r17
    1d70:	91 09       	sbc	r25, r1
    1d72:	9d 87       	std	Y+13, r25	; 0x0d
    1d74:	8c 87       	std	Y+12, r24	; 0x0c
    1d76:	db 8b       	std	Y+19, r29	; 0x13
    1d78:	ca 8b       	std	Y+18, r28	; 0x12
    1d7a:	a3 01       	movw	r20, r6
    1d7c:	b4 01       	movw	r22, r8
    1d7e:	c6 01       	movw	r24, r12
    1d80:	cb da       	rcall	.-2666   	; 0x1318 <pxPortInitialiseStack>
    1d82:	99 83       	std	Y+1, r25	; 0x01
    1d84:	88 83       	st	Y, r24
    1d86:	e1 14       	cp	r14, r1
    1d88:	f1 04       	cpc	r15, r1
    1d8a:	19 f0       	breq	.+6      	; 0x1d92 <xTaskGenericCreate+0xc0>
    1d8c:	f7 01       	movw	r30, r14
    1d8e:	d1 83       	std	Z+1, r29	; 0x01
    1d90:	c0 83       	st	Z, r28
    1d92:	0f b6       	in	r0, 0x3f	; 63
    1d94:	f8 94       	cli
    1d96:	0f 92       	push	r0
    1d98:	80 91 2a 08 	lds	r24, 0x082A
    1d9c:	8f 5f       	subi	r24, 0xFF	; 255
    1d9e:	80 93 2a 08 	sts	0x082A, r24
    1da2:	80 91 8a 08 	lds	r24, 0x088A
    1da6:	90 91 8b 08 	lds	r25, 0x088B
    1daa:	89 2b       	or	r24, r25
    1dac:	09 f0       	breq	.+2      	; 0x1db0 <xTaskGenericCreate+0xde>
    1dae:	3f c0       	rjmp	.+126    	; 0x1e2e <xTaskGenericCreate+0x15c>
    1db0:	d0 93 8b 08 	sts	0x088B, r29
    1db4:	c0 93 8a 08 	sts	0x088A, r28
    1db8:	80 91 2a 08 	lds	r24, 0x082A
    1dbc:	81 30       	cpi	r24, 0x01	; 1
    1dbe:	09 f0       	breq	.+2      	; 0x1dc2 <xTaskGenericCreate+0xf0>
    1dc0:	45 c0       	rjmp	.+138    	; 0x1e4c <xTaskGenericCreate+0x17a>
    1dc2:	0f 2e       	mov	r0, r31
    1dc4:	fd e5       	ldi	r31, 0x5D	; 93
    1dc6:	ef 2e       	mov	r14, r31
    1dc8:	f8 e0       	ldi	r31, 0x08	; 8
    1dca:	ff 2e       	mov	r15, r31
    1dcc:	f0 2d       	mov	r31, r0
    1dce:	0f 2e       	mov	r0, r31
    1dd0:	fa e8       	ldi	r31, 0x8A	; 138
    1dd2:	cf 2e       	mov	r12, r31
    1dd4:	f8 e0       	ldi	r31, 0x08	; 8
    1dd6:	df 2e       	mov	r13, r31
    1dd8:	f0 2d       	mov	r31, r0
    1dda:	c7 01       	movw	r24, r14
    1ddc:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1de0:	f9 e0       	ldi	r31, 0x09	; 9
    1de2:	ef 0e       	add	r14, r31
    1de4:	f1 1c       	adc	r15, r1
    1de6:	ec 14       	cp	r14, r12
    1de8:	fd 04       	cpc	r15, r13
    1dea:	b9 f7       	brne	.-18     	; 0x1dda <xTaskGenericCreate+0x108>
    1dec:	84 e5       	ldi	r24, 0x54	; 84
    1dee:	98 e0       	ldi	r25, 0x08	; 8
    1df0:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1df4:	8b e4       	ldi	r24, 0x4B	; 75
    1df6:	98 e0       	ldi	r25, 0x08	; 8
    1df8:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1dfc:	8e e3       	ldi	r24, 0x3E	; 62
    1dfe:	98 e0       	ldi	r25, 0x08	; 8
    1e00:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1e04:	85 e3       	ldi	r24, 0x35	; 53
    1e06:	98 e0       	ldi	r25, 0x08	; 8
    1e08:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1e0c:	8b e2       	ldi	r24, 0x2B	; 43
    1e0e:	98 e0       	ldi	r25, 0x08	; 8
    1e10:	0e 94 5d 03 	call	0x6ba	; 0x6ba <vListInitialise>
    1e14:	84 e5       	ldi	r24, 0x54	; 84
    1e16:	98 e0       	ldi	r25, 0x08	; 8
    1e18:	90 93 4a 08 	sts	0x084A, r25
    1e1c:	80 93 49 08 	sts	0x0849, r24
    1e20:	8b e4       	ldi	r24, 0x4B	; 75
    1e22:	98 e0       	ldi	r25, 0x08	; 8
    1e24:	90 93 48 08 	sts	0x0848, r25
    1e28:	80 93 47 08 	sts	0x0847, r24
    1e2c:	0f c0       	rjmp	.+30     	; 0x1e4c <xTaskGenericCreate+0x17a>
    1e2e:	80 91 26 08 	lds	r24, 0x0826
    1e32:	81 11       	cpse	r24, r1
    1e34:	0b c0       	rjmp	.+22     	; 0x1e4c <xTaskGenericCreate+0x17a>
    1e36:	e0 91 8a 08 	lds	r30, 0x088A
    1e3a:	f0 91 8b 08 	lds	r31, 0x088B
    1e3e:	86 89       	ldd	r24, Z+22	; 0x16
    1e40:	08 17       	cp	r16, r24
    1e42:	20 f0       	brcs	.+8      	; 0x1e4c <xTaskGenericCreate+0x17a>
    1e44:	d0 93 8b 08 	sts	0x088B, r29
    1e48:	c0 93 8a 08 	sts	0x088A, r28
    1e4c:	80 91 22 08 	lds	r24, 0x0822
    1e50:	8f 5f       	subi	r24, 0xFF	; 255
    1e52:	80 93 22 08 	sts	0x0822, r24
    1e56:	8e 89       	ldd	r24, Y+22	; 0x16
    1e58:	90 91 27 08 	lds	r25, 0x0827
    1e5c:	98 17       	cp	r25, r24
    1e5e:	10 f4       	brcc	.+4      	; 0x1e64 <xTaskGenericCreate+0x192>
    1e60:	80 93 27 08 	sts	0x0827, r24
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	9c 01       	movw	r18, r24
    1e68:	22 0f       	add	r18, r18
    1e6a:	33 1f       	adc	r19, r19
    1e6c:	22 0f       	add	r18, r18
    1e6e:	33 1f       	adc	r19, r19
    1e70:	22 0f       	add	r18, r18
    1e72:	33 1f       	adc	r19, r19
    1e74:	82 0f       	add	r24, r18
    1e76:	93 1f       	adc	r25, r19
    1e78:	b5 01       	movw	r22, r10
    1e7a:	83 5a       	subi	r24, 0xA3	; 163
    1e7c:	97 4f       	sbci	r25, 0xF7	; 247
    1e7e:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    1e82:	0f 90       	pop	r0
    1e84:	0f be       	out	0x3f, r0	; 63
    1e86:	80 91 26 08 	lds	r24, 0x0826
    1e8a:	88 23       	and	r24, r24
    1e8c:	51 f0       	breq	.+20     	; 0x1ea2 <xTaskGenericCreate+0x1d0>
    1e8e:	e0 91 8a 08 	lds	r30, 0x088A
    1e92:	f0 91 8b 08 	lds	r31, 0x088B
    1e96:	86 89       	ldd	r24, Z+22	; 0x16
    1e98:	80 17       	cp	r24, r16
    1e9a:	28 f4       	brcc	.+10     	; 0x1ea6 <xTaskGenericCreate+0x1d4>
    1e9c:	ec da       	rcall	.-2600   	; 0x1476 <vPortYield>
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	1c c0       	rjmp	.+56     	; 0x1eda <xTaskGenericCreate+0x208>
    1ea2:	81 e0       	ldi	r24, 0x01	; 1
    1ea4:	1a c0       	rjmp	.+52     	; 0x1eda <xTaskGenericCreate+0x208>
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	18 c0       	rjmp	.+48     	; 0x1eda <xTaskGenericCreate+0x208>
    1eaa:	d8 8e       	std	Y+24, r13	; 0x18
    1eac:	cf 8a       	std	Y+23, r12	; 0x17
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	48 1a       	sub	r4, r24
    1eb2:	51 08       	sbc	r5, r1
    1eb4:	cf 88       	ldd	r12, Y+23	; 0x17
    1eb6:	d8 8c       	ldd	r13, Y+24	; 0x18
    1eb8:	c4 0c       	add	r12, r4
    1eba:	d5 1c       	adc	r13, r5
    1ebc:	d5 01       	movw	r26, r10
    1ebe:	8c 91       	ld	r24, X
    1ec0:	89 8f       	std	Y+25, r24	; 0x19
    1ec2:	8c 91       	ld	r24, X
    1ec4:	88 23       	and	r24, r24
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <xTaskGenericCreate+0x1f8>
    1ec8:	3b cf       	rjmp	.-394    	; 0x1d40 <xTaskGenericCreate+0x6e>
    1eca:	ae 01       	movw	r20, r28
    1ecc:	46 5e       	subi	r20, 0xE6	; 230
    1ece:	5f 4f       	sbci	r21, 0xFF	; 255
    1ed0:	f5 01       	movw	r30, r10
    1ed2:	31 96       	adiw	r30, 0x01	; 1
    1ed4:	27 e0       	ldi	r18, 0x07	; 7
    1ed6:	29 cf       	rjmp	.-430    	; 0x1d2a <xTaskGenericCreate+0x58>
    1ed8:	8f ef       	ldi	r24, 0xFF	; 255
    1eda:	df 91       	pop	r29
    1edc:	cf 91       	pop	r28
    1ede:	1f 91       	pop	r17
    1ee0:	0f 91       	pop	r16
    1ee2:	ff 90       	pop	r15
    1ee4:	ef 90       	pop	r14
    1ee6:	df 90       	pop	r13
    1ee8:	cf 90       	pop	r12
    1eea:	bf 90       	pop	r11
    1eec:	af 90       	pop	r10
    1eee:	9f 90       	pop	r9
    1ef0:	8f 90       	pop	r8
    1ef2:	7f 90       	pop	r7
    1ef4:	6f 90       	pop	r6
    1ef6:	5f 90       	pop	r5
    1ef8:	4f 90       	pop	r4
    1efa:	08 95       	ret

00001efc <vTaskStartScheduler>:
    1efc:	af 92       	push	r10
    1efe:	bf 92       	push	r11
    1f00:	cf 92       	push	r12
    1f02:	df 92       	push	r13
    1f04:	ef 92       	push	r14
    1f06:	ff 92       	push	r15
    1f08:	0f 93       	push	r16
    1f0a:	a1 2c       	mov	r10, r1
    1f0c:	b1 2c       	mov	r11, r1
    1f0e:	c1 2c       	mov	r12, r1
    1f10:	d1 2c       	mov	r13, r1
    1f12:	e1 2c       	mov	r14, r1
    1f14:	f1 2c       	mov	r15, r1
    1f16:	00 e0       	ldi	r16, 0x00	; 0
    1f18:	20 e0       	ldi	r18, 0x00	; 0
    1f1a:	30 e0       	ldi	r19, 0x00	; 0
    1f1c:	45 e5       	ldi	r20, 0x55	; 85
    1f1e:	50 e0       	ldi	r21, 0x00	; 0
    1f20:	61 e3       	ldi	r22, 0x31	; 49
    1f22:	72 e0       	ldi	r23, 0x02	; 2
    1f24:	85 e5       	ldi	r24, 0x55	; 85
    1f26:	91 e1       	ldi	r25, 0x11	; 17
    1f28:	d4 de       	rcall	.-600    	; 0x1cd2 <xTaskGenericCreate>
    1f2a:	81 30       	cpi	r24, 0x01	; 1
    1f2c:	41 f4       	brne	.+16     	; 0x1f3e <vTaskStartScheduler+0x42>
    1f2e:	f8 94       	cli
    1f30:	80 93 26 08 	sts	0x0826, r24
    1f34:	10 92 29 08 	sts	0x0829, r1
    1f38:	10 92 28 08 	sts	0x0828, r1
    1f3c:	5f da       	rcall	.-2882   	; 0x13fc <xPortStartScheduler>
    1f3e:	0f 91       	pop	r16
    1f40:	ff 90       	pop	r15
    1f42:	ef 90       	pop	r14
    1f44:	df 90       	pop	r13
    1f46:	cf 90       	pop	r12
    1f48:	bf 90       	pop	r11
    1f4a:	af 90       	pop	r10
    1f4c:	08 95       	ret

00001f4e <vTaskSuspendAll>:
    1f4e:	80 91 21 08 	lds	r24, 0x0821
    1f52:	8f 5f       	subi	r24, 0xFF	; 255
    1f54:	80 93 21 08 	sts	0x0821, r24
    1f58:	08 95       	ret

00001f5a <xTaskGetTickCount>:
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	0f 92       	push	r0
    1f60:	80 91 28 08 	lds	r24, 0x0828
    1f64:	90 91 29 08 	lds	r25, 0x0829
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63
    1f6c:	08 95       	ret

00001f6e <xTaskGetTickCountFromISR>:
    1f6e:	80 91 28 08 	lds	r24, 0x0828
    1f72:	90 91 29 08 	lds	r25, 0x0829
    1f76:	08 95       	ret

00001f78 <xTaskIncrementTick>:
    1f78:	cf 92       	push	r12
    1f7a:	df 92       	push	r13
    1f7c:	ef 92       	push	r14
    1f7e:	ff 92       	push	r15
    1f80:	0f 93       	push	r16
    1f82:	1f 93       	push	r17
    1f84:	cf 93       	push	r28
    1f86:	df 93       	push	r29
    1f88:	80 91 21 08 	lds	r24, 0x0821
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	99 c0       	rjmp	.+306    	; 0x20c2 <xTaskIncrementTick+0x14a>
    1f90:	80 91 28 08 	lds	r24, 0x0828
    1f94:	90 91 29 08 	lds	r25, 0x0829
    1f98:	01 96       	adiw	r24, 0x01	; 1
    1f9a:	90 93 29 08 	sts	0x0829, r25
    1f9e:	80 93 28 08 	sts	0x0828, r24
    1fa2:	e0 90 28 08 	lds	r14, 0x0828
    1fa6:	f0 90 29 08 	lds	r15, 0x0829
    1faa:	e1 14       	cp	r14, r1
    1fac:	f1 04       	cpc	r15, r1
    1fae:	b1 f4       	brne	.+44     	; 0x1fdc <xTaskIncrementTick+0x64>
    1fb0:	80 91 49 08 	lds	r24, 0x0849
    1fb4:	90 91 4a 08 	lds	r25, 0x084A
    1fb8:	20 91 47 08 	lds	r18, 0x0847
    1fbc:	30 91 48 08 	lds	r19, 0x0848
    1fc0:	30 93 4a 08 	sts	0x084A, r19
    1fc4:	20 93 49 08 	sts	0x0849, r18
    1fc8:	90 93 48 08 	sts	0x0848, r25
    1fcc:	80 93 47 08 	sts	0x0847, r24
    1fd0:	80 91 23 08 	lds	r24, 0x0823
    1fd4:	8f 5f       	subi	r24, 0xFF	; 255
    1fd6:	80 93 23 08 	sts	0x0823, r24
    1fda:	25 de       	rcall	.-950    	; 0x1c26 <prvResetNextTaskUnblockTime>
    1fdc:	80 91 05 02 	lds	r24, 0x0205
    1fe0:	90 91 06 02 	lds	r25, 0x0206
    1fe4:	e8 16       	cp	r14, r24
    1fe6:	f9 06       	cpc	r15, r25
    1fe8:	08 f4       	brcc	.+2      	; 0x1fec <xTaskIncrementTick+0x74>
    1fea:	54 c0       	rjmp	.+168    	; 0x2094 <xTaskIncrementTick+0x11c>
    1fec:	d1 2c       	mov	r13, r1
    1fee:	cc 24       	eor	r12, r12
    1ff0:	c3 94       	inc	r12
    1ff2:	01 c0       	rjmp	.+2      	; 0x1ff6 <xTaskIncrementTick+0x7e>
    1ff4:	dc 2c       	mov	r13, r12
    1ff6:	e0 91 49 08 	lds	r30, 0x0849
    1ffa:	f0 91 4a 08 	lds	r31, 0x084A
    1ffe:	80 81       	ld	r24, Z
    2000:	81 11       	cpse	r24, r1
    2002:	07 c0       	rjmp	.+14     	; 0x2012 <xTaskIncrementTick+0x9a>
    2004:	8f ef       	ldi	r24, 0xFF	; 255
    2006:	9f ef       	ldi	r25, 0xFF	; 255
    2008:	90 93 06 02 	sts	0x0206, r25
    200c:	80 93 05 02 	sts	0x0205, r24
    2010:	42 c0       	rjmp	.+132    	; 0x2096 <xTaskIncrementTick+0x11e>
    2012:	e0 91 49 08 	lds	r30, 0x0849
    2016:	f0 91 4a 08 	lds	r31, 0x084A
    201a:	05 80       	ldd	r0, Z+5	; 0x05
    201c:	f6 81       	ldd	r31, Z+6	; 0x06
    201e:	e0 2d       	mov	r30, r0
    2020:	c6 81       	ldd	r28, Z+6	; 0x06
    2022:	d7 81       	ldd	r29, Z+7	; 0x07
    2024:	2a 81       	ldd	r18, Y+2	; 0x02
    2026:	3b 81       	ldd	r19, Y+3	; 0x03
    2028:	e2 16       	cp	r14, r18
    202a:	f3 06       	cpc	r15, r19
    202c:	28 f4       	brcc	.+10     	; 0x2038 <xTaskIncrementTick+0xc0>
    202e:	30 93 06 02 	sts	0x0206, r19
    2032:	20 93 05 02 	sts	0x0205, r18
    2036:	2f c0       	rjmp	.+94     	; 0x2096 <xTaskIncrementTick+0x11e>
    2038:	8e 01       	movw	r16, r28
    203a:	0e 5f       	subi	r16, 0xFE	; 254
    203c:	1f 4f       	sbci	r17, 0xFF	; 255
    203e:	c8 01       	movw	r24, r16
    2040:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2044:	8c 89       	ldd	r24, Y+20	; 0x14
    2046:	9d 89       	ldd	r25, Y+21	; 0x15
    2048:	89 2b       	or	r24, r25
    204a:	21 f0       	breq	.+8      	; 0x2054 <xTaskIncrementTick+0xdc>
    204c:	ce 01       	movw	r24, r28
    204e:	0c 96       	adiw	r24, 0x0c	; 12
    2050:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2054:	2e 89       	ldd	r18, Y+22	; 0x16
    2056:	80 91 27 08 	lds	r24, 0x0827
    205a:	82 17       	cp	r24, r18
    205c:	10 f4       	brcc	.+4      	; 0x2062 <xTaskIncrementTick+0xea>
    205e:	20 93 27 08 	sts	0x0827, r18
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	c9 01       	movw	r24, r18
    2066:	88 0f       	add	r24, r24
    2068:	99 1f       	adc	r25, r25
    206a:	88 0f       	add	r24, r24
    206c:	99 1f       	adc	r25, r25
    206e:	88 0f       	add	r24, r24
    2070:	99 1f       	adc	r25, r25
    2072:	82 0f       	add	r24, r18
    2074:	93 1f       	adc	r25, r19
    2076:	b8 01       	movw	r22, r16
    2078:	83 5a       	subi	r24, 0xA3	; 163
    207a:	97 4f       	sbci	r25, 0xF7	; 247
    207c:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2080:	e0 91 8a 08 	lds	r30, 0x088A
    2084:	f0 91 8b 08 	lds	r31, 0x088B
    2088:	9e 89       	ldd	r25, Y+22	; 0x16
    208a:	86 89       	ldd	r24, Z+22	; 0x16
    208c:	98 17       	cp	r25, r24
    208e:	08 f0       	brcs	.+2      	; 0x2092 <xTaskIncrementTick+0x11a>
    2090:	b1 cf       	rjmp	.-158    	; 0x1ff4 <xTaskIncrementTick+0x7c>
    2092:	b1 cf       	rjmp	.-158    	; 0x1ff6 <xTaskIncrementTick+0x7e>
    2094:	d1 2c       	mov	r13, r1
    2096:	e0 91 8a 08 	lds	r30, 0x088A
    209a:	f0 91 8b 08 	lds	r31, 0x088B
    209e:	86 89       	ldd	r24, Z+22	; 0x16
    20a0:	90 e0       	ldi	r25, 0x00	; 0
    20a2:	fc 01       	movw	r30, r24
    20a4:	ee 0f       	add	r30, r30
    20a6:	ff 1f       	adc	r31, r31
    20a8:	ee 0f       	add	r30, r30
    20aa:	ff 1f       	adc	r31, r31
    20ac:	ee 0f       	add	r30, r30
    20ae:	ff 1f       	adc	r31, r31
    20b0:	8e 0f       	add	r24, r30
    20b2:	9f 1f       	adc	r25, r31
    20b4:	fc 01       	movw	r30, r24
    20b6:	e3 5a       	subi	r30, 0xA3	; 163
    20b8:	f7 4f       	sbci	r31, 0xF7	; 247
    20ba:	80 81       	ld	r24, Z
    20bc:	82 30       	cpi	r24, 0x02	; 2
    20be:	40 f4       	brcc	.+16     	; 0x20d0 <xTaskIncrementTick+0x158>
    20c0:	09 c0       	rjmp	.+18     	; 0x20d4 <xTaskIncrementTick+0x15c>
    20c2:	80 91 25 08 	lds	r24, 0x0825
    20c6:	8f 5f       	subi	r24, 0xFF	; 255
    20c8:	80 93 25 08 	sts	0x0825, r24
    20cc:	d1 2c       	mov	r13, r1
    20ce:	02 c0       	rjmp	.+4      	; 0x20d4 <xTaskIncrementTick+0x15c>
    20d0:	dd 24       	eor	r13, r13
    20d2:	d3 94       	inc	r13
    20d4:	80 91 24 08 	lds	r24, 0x0824
    20d8:	88 23       	and	r24, r24
    20da:	11 f0       	breq	.+4      	; 0x20e0 <xTaskIncrementTick+0x168>
    20dc:	dd 24       	eor	r13, r13
    20de:	d3 94       	inc	r13
    20e0:	8d 2d       	mov	r24, r13
    20e2:	df 91       	pop	r29
    20e4:	cf 91       	pop	r28
    20e6:	1f 91       	pop	r17
    20e8:	0f 91       	pop	r16
    20ea:	ff 90       	pop	r15
    20ec:	ef 90       	pop	r14
    20ee:	df 90       	pop	r13
    20f0:	cf 90       	pop	r12
    20f2:	08 95       	ret

000020f4 <xTaskResumeAll>:
    20f4:	df 92       	push	r13
    20f6:	ef 92       	push	r14
    20f8:	ff 92       	push	r15
    20fa:	0f 93       	push	r16
    20fc:	1f 93       	push	r17
    20fe:	cf 93       	push	r28
    2100:	df 93       	push	r29
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	0f 92       	push	r0
    2108:	80 91 21 08 	lds	r24, 0x0821
    210c:	81 50       	subi	r24, 0x01	; 1
    210e:	80 93 21 08 	sts	0x0821, r24
    2112:	80 91 21 08 	lds	r24, 0x0821
    2116:	81 11       	cpse	r24, r1
    2118:	5f c0       	rjmp	.+190    	; 0x21d8 <xTaskResumeAll+0xe4>
    211a:	80 91 2a 08 	lds	r24, 0x082A
    211e:	88 23       	and	r24, r24
    2120:	09 f4       	brne	.+2      	; 0x2124 <xTaskResumeAll+0x30>
    2122:	5c c0       	rjmp	.+184    	; 0x21dc <xTaskResumeAll+0xe8>
    2124:	0f 2e       	mov	r0, r31
    2126:	fe e3       	ldi	r31, 0x3E	; 62
    2128:	ef 2e       	mov	r14, r31
    212a:	f8 e0       	ldi	r31, 0x08	; 8
    212c:	ff 2e       	mov	r15, r31
    212e:	f0 2d       	mov	r31, r0
    2130:	dd 24       	eor	r13, r13
    2132:	d3 94       	inc	r13
    2134:	30 c0       	rjmp	.+96     	; 0x2196 <xTaskResumeAll+0xa2>
    2136:	e0 91 43 08 	lds	r30, 0x0843
    213a:	f0 91 44 08 	lds	r31, 0x0844
    213e:	c6 81       	ldd	r28, Z+6	; 0x06
    2140:	d7 81       	ldd	r29, Z+7	; 0x07
    2142:	ce 01       	movw	r24, r28
    2144:	0c 96       	adiw	r24, 0x0c	; 12
    2146:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    214a:	8e 01       	movw	r16, r28
    214c:	0e 5f       	subi	r16, 0xFE	; 254
    214e:	1f 4f       	sbci	r17, 0xFF	; 255
    2150:	c8 01       	movw	r24, r16
    2152:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2156:	8e 89       	ldd	r24, Y+22	; 0x16
    2158:	90 91 27 08 	lds	r25, 0x0827
    215c:	98 17       	cp	r25, r24
    215e:	10 f4       	brcc	.+4      	; 0x2164 <xTaskResumeAll+0x70>
    2160:	80 93 27 08 	sts	0x0827, r24
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	9c 01       	movw	r18, r24
    2168:	22 0f       	add	r18, r18
    216a:	33 1f       	adc	r19, r19
    216c:	22 0f       	add	r18, r18
    216e:	33 1f       	adc	r19, r19
    2170:	22 0f       	add	r18, r18
    2172:	33 1f       	adc	r19, r19
    2174:	82 0f       	add	r24, r18
    2176:	93 1f       	adc	r25, r19
    2178:	b8 01       	movw	r22, r16
    217a:	83 5a       	subi	r24, 0xA3	; 163
    217c:	97 4f       	sbci	r25, 0xF7	; 247
    217e:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2182:	e0 91 8a 08 	lds	r30, 0x088A
    2186:	f0 91 8b 08 	lds	r31, 0x088B
    218a:	9e 89       	ldd	r25, Y+22	; 0x16
    218c:	86 89       	ldd	r24, Z+22	; 0x16
    218e:	98 17       	cp	r25, r24
    2190:	10 f0       	brcs	.+4      	; 0x2196 <xTaskResumeAll+0xa2>
    2192:	d0 92 24 08 	sts	0x0824, r13
    2196:	f7 01       	movw	r30, r14
    2198:	80 81       	ld	r24, Z
    219a:	81 11       	cpse	r24, r1
    219c:	cc cf       	rjmp	.-104    	; 0x2136 <xTaskResumeAll+0x42>
    219e:	80 91 25 08 	lds	r24, 0x0825
    21a2:	88 23       	and	r24, r24
    21a4:	91 f0       	breq	.+36     	; 0x21ca <xTaskResumeAll+0xd6>
    21a6:	80 91 25 08 	lds	r24, 0x0825
    21aa:	88 23       	and	r24, r24
    21ac:	71 f0       	breq	.+28     	; 0x21ca <xTaskResumeAll+0xd6>
    21ae:	c1 e0       	ldi	r28, 0x01	; 1
    21b0:	e3 de       	rcall	.-570    	; 0x1f78 <xTaskIncrementTick>
    21b2:	81 11       	cpse	r24, r1
    21b4:	c0 93 24 08 	sts	0x0824, r28
    21b8:	80 91 25 08 	lds	r24, 0x0825
    21bc:	81 50       	subi	r24, 0x01	; 1
    21be:	80 93 25 08 	sts	0x0825, r24
    21c2:	80 91 25 08 	lds	r24, 0x0825
    21c6:	81 11       	cpse	r24, r1
    21c8:	f3 cf       	rjmp	.-26     	; 0x21b0 <xTaskResumeAll+0xbc>
    21ca:	80 91 24 08 	lds	r24, 0x0824
    21ce:	81 30       	cpi	r24, 0x01	; 1
    21d0:	39 f4       	brne	.+14     	; 0x21e0 <xTaskResumeAll+0xec>
    21d2:	51 d9       	rcall	.-3422   	; 0x1476 <vPortYield>
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	05 c0       	rjmp	.+10     	; 0x21e2 <xTaskResumeAll+0xee>
    21d8:	80 e0       	ldi	r24, 0x00	; 0
    21da:	03 c0       	rjmp	.+6      	; 0x21e2 <xTaskResumeAll+0xee>
    21dc:	80 e0       	ldi	r24, 0x00	; 0
    21de:	01 c0       	rjmp	.+2      	; 0x21e2 <xTaskResumeAll+0xee>
    21e0:	80 e0       	ldi	r24, 0x00	; 0
    21e2:	0f 90       	pop	r0
    21e4:	0f be       	out	0x3f, r0	; 63
    21e6:	df 91       	pop	r29
    21e8:	cf 91       	pop	r28
    21ea:	1f 91       	pop	r17
    21ec:	0f 91       	pop	r16
    21ee:	ff 90       	pop	r15
    21f0:	ef 90       	pop	r14
    21f2:	df 90       	pop	r13
    21f4:	08 95       	ret

000021f6 <vTaskDelayUntil>:
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	8c 01       	movw	r16, r24
    2200:	eb 01       	movw	r28, r22
    2202:	a5 de       	rcall	.-694    	; 0x1f4e <vTaskSuspendAll>
    2204:	80 91 28 08 	lds	r24, 0x0828
    2208:	90 91 29 08 	lds	r25, 0x0829
    220c:	f8 01       	movw	r30, r16
    220e:	20 81       	ld	r18, Z
    2210:	31 81       	ldd	r19, Z+1	; 0x01
    2212:	c2 0f       	add	r28, r18
    2214:	d3 1f       	adc	r29, r19
    2216:	82 17       	cp	r24, r18
    2218:	93 07       	cpc	r25, r19
    221a:	48 f4       	brcc	.+18     	; 0x222e <__stack+0x2f>
    221c:	c2 17       	cp	r28, r18
    221e:	d3 07       	cpc	r29, r19
    2220:	f8 f4       	brcc	.+62     	; 0x2260 <__stack+0x61>
    2222:	d1 83       	std	Z+1, r29	; 0x01
    2224:	c0 83       	st	Z, r28
    2226:	8c 17       	cp	r24, r28
    2228:	9d 07       	cpc	r25, r29
    222a:	88 f4       	brcc	.+34     	; 0x224e <__stack+0x4f>
    222c:	07 c0       	rjmp	.+14     	; 0x223c <__stack+0x3d>
    222e:	c2 17       	cp	r28, r18
    2230:	d3 07       	cpc	r29, r19
    2232:	90 f0       	brcs	.+36     	; 0x2258 <__stack+0x59>
    2234:	8c 17       	cp	r24, r28
    2236:	9d 07       	cpc	r25, r29
    2238:	78 f0       	brcs	.+30     	; 0x2258 <__stack+0x59>
    223a:	12 c0       	rjmp	.+36     	; 0x2260 <__stack+0x61>
    223c:	80 91 8a 08 	lds	r24, 0x088A
    2240:	90 91 8b 08 	lds	r25, 0x088B
    2244:	02 96       	adiw	r24, 0x02	; 2
    2246:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    224a:	ce 01       	movw	r24, r28
    224c:	0b dd       	rcall	.-1514   	; 0x1c64 <prvAddCurrentTaskToDelayedList>
    224e:	52 df       	rcall	.-348    	; 0x20f4 <xTaskResumeAll>
    2250:	81 11       	cpse	r24, r1
    2252:	0a c0       	rjmp	.+20     	; 0x2268 <__stack+0x69>
    2254:	10 d9       	rcall	.-3552   	; 0x1476 <vPortYield>
    2256:	08 c0       	rjmp	.+16     	; 0x2268 <__stack+0x69>
    2258:	f8 01       	movw	r30, r16
    225a:	d1 83       	std	Z+1, r29	; 0x01
    225c:	c0 83       	st	Z, r28
    225e:	ee cf       	rjmp	.-36     	; 0x223c <__stack+0x3d>
    2260:	f8 01       	movw	r30, r16
    2262:	d1 83       	std	Z+1, r29	; 0x01
    2264:	c0 83       	st	Z, r28
    2266:	f3 cf       	rjmp	.-26     	; 0x224e <__stack+0x4f>
    2268:	df 91       	pop	r29
    226a:	cf 91       	pop	r28
    226c:	1f 91       	pop	r17
    226e:	0f 91       	pop	r16
    2270:	08 95       	ret

00002272 <vTaskDelay>:
    2272:	cf 93       	push	r28
    2274:	df 93       	push	r29
    2276:	ec 01       	movw	r28, r24
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	99 f0       	breq	.+38     	; 0x22a2 <vTaskDelay+0x30>
    227c:	68 de       	rcall	.-816    	; 0x1f4e <vTaskSuspendAll>
    227e:	80 91 28 08 	lds	r24, 0x0828
    2282:	90 91 29 08 	lds	r25, 0x0829
    2286:	c8 0f       	add	r28, r24
    2288:	d9 1f       	adc	r29, r25
    228a:	80 91 8a 08 	lds	r24, 0x088A
    228e:	90 91 8b 08 	lds	r25, 0x088B
    2292:	02 96       	adiw	r24, 0x02	; 2
    2294:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2298:	ce 01       	movw	r24, r28
    229a:	e4 dc       	rcall	.-1592   	; 0x1c64 <prvAddCurrentTaskToDelayedList>
    229c:	2b df       	rcall	.-426    	; 0x20f4 <xTaskResumeAll>
    229e:	81 11       	cpse	r24, r1
    22a0:	01 c0       	rjmp	.+2      	; 0x22a4 <vTaskDelay+0x32>
    22a2:	e9 d8       	rcall	.-3630   	; 0x1476 <vPortYield>
    22a4:	df 91       	pop	r29
    22a6:	cf 91       	pop	r28
    22a8:	08 95       	ret

000022aa <prvIdleTask>:
    22aa:	0f 2e       	mov	r0, r31
    22ac:	fd e5       	ldi	r31, 0x5D	; 93
    22ae:	ef 2e       	mov	r14, r31
    22b0:	f8 e0       	ldi	r31, 0x08	; 8
    22b2:	ff 2e       	mov	r15, r31
    22b4:	f0 2d       	mov	r31, r0
    22b6:	c5 e3       	ldi	r28, 0x35	; 53
    22b8:	d8 e0       	ldi	r29, 0x08	; 8
    22ba:	26 c0       	rjmp	.+76     	; 0x2308 <prvIdleTask+0x5e>
    22bc:	48 de       	rcall	.-880    	; 0x1f4e <vTaskSuspendAll>
    22be:	18 81       	ld	r17, Y
    22c0:	19 df       	rcall	.-462    	; 0x20f4 <xTaskResumeAll>
    22c2:	11 23       	and	r17, r17
    22c4:	09 f1       	breq	.+66     	; 0x2308 <prvIdleTask+0x5e>
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	0f 92       	push	r0
    22cc:	e0 91 3a 08 	lds	r30, 0x083A
    22d0:	f0 91 3b 08 	lds	r31, 0x083B
    22d4:	06 81       	ldd	r16, Z+6	; 0x06
    22d6:	17 81       	ldd	r17, Z+7	; 0x07
    22d8:	c8 01       	movw	r24, r16
    22da:	02 96       	adiw	r24, 0x02	; 2
    22dc:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    22e0:	80 91 2a 08 	lds	r24, 0x082A
    22e4:	81 50       	subi	r24, 0x01	; 1
    22e6:	80 93 2a 08 	sts	0x082A, r24
    22ea:	80 91 34 08 	lds	r24, 0x0834
    22ee:	81 50       	subi	r24, 0x01	; 1
    22f0:	80 93 34 08 	sts	0x0834, r24
    22f4:	0f 90       	pop	r0
    22f6:	0f be       	out	0x3f, r0	; 63
    22f8:	f8 01       	movw	r30, r16
    22fa:	87 89       	ldd	r24, Z+23	; 0x17
    22fc:	90 8d       	ldd	r25, Z+24	; 0x18
    22fe:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <vPortFree>
    2302:	c8 01       	movw	r24, r16
    2304:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <vPortFree>
    2308:	80 91 34 08 	lds	r24, 0x0834
    230c:	81 11       	cpse	r24, r1
    230e:	d6 cf       	rjmp	.-84     	; 0x22bc <prvIdleTask+0x12>
    2310:	f7 01       	movw	r30, r14
    2312:	80 81       	ld	r24, Z
    2314:	82 30       	cpi	r24, 0x02	; 2
    2316:	c0 f3       	brcs	.-16     	; 0x2308 <prvIdleTask+0x5e>
    2318:	ae d8       	rcall	.-3748   	; 0x1476 <vPortYield>
    231a:	f6 cf       	rjmp	.-20     	; 0x2308 <prvIdleTask+0x5e>

0000231c <vTaskSwitchContext>:
    231c:	80 91 21 08 	lds	r24, 0x0821
    2320:	88 23       	and	r24, r24
    2322:	21 f0       	breq	.+8      	; 0x232c <vTaskSwitchContext+0x10>
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	80 93 24 08 	sts	0x0824, r24
    232a:	08 95       	ret
    232c:	10 92 24 08 	sts	0x0824, r1
    2330:	80 91 27 08 	lds	r24, 0x0827
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	fc 01       	movw	r30, r24
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	ee 0f       	add	r30, r30
    233e:	ff 1f       	adc	r31, r31
    2340:	ee 0f       	add	r30, r30
    2342:	ff 1f       	adc	r31, r31
    2344:	8e 0f       	add	r24, r30
    2346:	9f 1f       	adc	r25, r31
    2348:	fc 01       	movw	r30, r24
    234a:	e3 5a       	subi	r30, 0xA3	; 163
    234c:	f7 4f       	sbci	r31, 0xF7	; 247
    234e:	80 81       	ld	r24, Z
    2350:	81 11       	cpse	r24, r1
    2352:	17 c0       	rjmp	.+46     	; 0x2382 <vTaskSwitchContext+0x66>
    2354:	80 91 27 08 	lds	r24, 0x0827
    2358:	81 50       	subi	r24, 0x01	; 1
    235a:	80 93 27 08 	sts	0x0827, r24
    235e:	80 91 27 08 	lds	r24, 0x0827
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	fc 01       	movw	r30, r24
    2366:	ee 0f       	add	r30, r30
    2368:	ff 1f       	adc	r31, r31
    236a:	ee 0f       	add	r30, r30
    236c:	ff 1f       	adc	r31, r31
    236e:	ee 0f       	add	r30, r30
    2370:	ff 1f       	adc	r31, r31
    2372:	8e 0f       	add	r24, r30
    2374:	9f 1f       	adc	r25, r31
    2376:	fc 01       	movw	r30, r24
    2378:	e3 5a       	subi	r30, 0xA3	; 163
    237a:	f7 4f       	sbci	r31, 0xF7	; 247
    237c:	80 81       	ld	r24, Z
    237e:	88 23       	and	r24, r24
    2380:	49 f3       	breq	.-46     	; 0x2354 <vTaskSwitchContext+0x38>
    2382:	e0 91 27 08 	lds	r30, 0x0827
    2386:	f0 e0       	ldi	r31, 0x00	; 0
    2388:	cf 01       	movw	r24, r30
    238a:	88 0f       	add	r24, r24
    238c:	99 1f       	adc	r25, r25
    238e:	88 0f       	add	r24, r24
    2390:	99 1f       	adc	r25, r25
    2392:	88 0f       	add	r24, r24
    2394:	99 1f       	adc	r25, r25
    2396:	e8 0f       	add	r30, r24
    2398:	f9 1f       	adc	r31, r25
    239a:	e3 5a       	subi	r30, 0xA3	; 163
    239c:	f7 4f       	sbci	r31, 0xF7	; 247
    239e:	a1 81       	ldd	r26, Z+1	; 0x01
    23a0:	b2 81       	ldd	r27, Z+2	; 0x02
    23a2:	12 96       	adiw	r26, 0x02	; 2
    23a4:	0d 90       	ld	r0, X+
    23a6:	bc 91       	ld	r27, X
    23a8:	a0 2d       	mov	r26, r0
    23aa:	b2 83       	std	Z+2, r27	; 0x02
    23ac:	a1 83       	std	Z+1, r26	; 0x01
    23ae:	cf 01       	movw	r24, r30
    23b0:	03 96       	adiw	r24, 0x03	; 3
    23b2:	a8 17       	cp	r26, r24
    23b4:	b9 07       	cpc	r27, r25
    23b6:	31 f4       	brne	.+12     	; 0x23c4 <vTaskSwitchContext+0xa8>
    23b8:	12 96       	adiw	r26, 0x02	; 2
    23ba:	8d 91       	ld	r24, X+
    23bc:	9c 91       	ld	r25, X
    23be:	13 97       	sbiw	r26, 0x03	; 3
    23c0:	92 83       	std	Z+2, r25	; 0x02
    23c2:	81 83       	std	Z+1, r24	; 0x01
    23c4:	01 80       	ldd	r0, Z+1	; 0x01
    23c6:	f2 81       	ldd	r31, Z+2	; 0x02
    23c8:	e0 2d       	mov	r30, r0
    23ca:	86 81       	ldd	r24, Z+6	; 0x06
    23cc:	97 81       	ldd	r25, Z+7	; 0x07
    23ce:	90 93 8b 08 	sts	0x088B, r25
    23d2:	80 93 8a 08 	sts	0x088A, r24
    23d6:	08 95       	ret

000023d8 <vTaskSuspend>:
    23d8:	0f 93       	push	r16
    23da:	1f 93       	push	r17
    23dc:	cf 93       	push	r28
    23de:	df 93       	push	r29
    23e0:	ec 01       	movw	r28, r24
    23e2:	0f b6       	in	r0, 0x3f	; 63
    23e4:	f8 94       	cli
    23e6:	0f 92       	push	r0
    23e8:	00 97       	sbiw	r24, 0x00	; 0
    23ea:	21 f4       	brne	.+8      	; 0x23f4 <vTaskSuspend+0x1c>
    23ec:	c0 91 8a 08 	lds	r28, 0x088A
    23f0:	d0 91 8b 08 	lds	r29, 0x088B
    23f4:	8e 01       	movw	r16, r28
    23f6:	0e 5f       	subi	r16, 0xFE	; 254
    23f8:	1f 4f       	sbci	r17, 0xFF	; 255
    23fa:	c8 01       	movw	r24, r16
    23fc:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2400:	8c 89       	ldd	r24, Y+20	; 0x14
    2402:	9d 89       	ldd	r25, Y+21	; 0x15
    2404:	89 2b       	or	r24, r25
    2406:	21 f0       	breq	.+8      	; 0x2410 <vTaskSuspend+0x38>
    2408:	ce 01       	movw	r24, r28
    240a:	0c 96       	adiw	r24, 0x0c	; 12
    240c:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2410:	b8 01       	movw	r22, r16
    2412:	8b e2       	ldi	r24, 0x2B	; 43
    2414:	98 e0       	ldi	r25, 0x08	; 8
    2416:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	80 91 8a 08 	lds	r24, 0x088A
    2422:	90 91 8b 08 	lds	r25, 0x088B
    2426:	c8 17       	cp	r28, r24
    2428:	d9 07       	cpc	r29, r25
    242a:	99 f4       	brne	.+38     	; 0x2452 <vTaskSuspend+0x7a>
    242c:	80 91 26 08 	lds	r24, 0x0826
    2430:	88 23       	and	r24, r24
    2432:	11 f0       	breq	.+4      	; 0x2438 <vTaskSuspend+0x60>
    2434:	20 d8       	rcall	.-4032   	; 0x1476 <vPortYield>
    2436:	17 c0       	rjmp	.+46     	; 0x2466 <vTaskSuspend+0x8e>
    2438:	80 91 2a 08 	lds	r24, 0x082A
    243c:	90 91 2b 08 	lds	r25, 0x082B
    2440:	98 13       	cpse	r25, r24
    2442:	05 c0       	rjmp	.+10     	; 0x244e <vTaskSuspend+0x76>
    2444:	10 92 8b 08 	sts	0x088B, r1
    2448:	10 92 8a 08 	sts	0x088A, r1
    244c:	0c c0       	rjmp	.+24     	; 0x2466 <vTaskSuspend+0x8e>
    244e:	66 df       	rcall	.-308    	; 0x231c <vTaskSwitchContext>
    2450:	0a c0       	rjmp	.+20     	; 0x2466 <vTaskSuspend+0x8e>
    2452:	80 91 26 08 	lds	r24, 0x0826
    2456:	88 23       	and	r24, r24
    2458:	31 f0       	breq	.+12     	; 0x2466 <vTaskSuspend+0x8e>
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	f8 94       	cli
    245e:	0f 92       	push	r0
    2460:	e2 db       	rcall	.-2108   	; 0x1c26 <prvResetNextTaskUnblockTime>
    2462:	0f 90       	pop	r0
    2464:	0f be       	out	0x3f, r0	; 63
    2466:	df 91       	pop	r29
    2468:	cf 91       	pop	r28
    246a:	1f 91       	pop	r17
    246c:	0f 91       	pop	r16
    246e:	08 95       	ret

00002470 <vTaskPlaceOnEventList>:
    2470:	cf 93       	push	r28
    2472:	df 93       	push	r29
    2474:	eb 01       	movw	r28, r22
    2476:	60 91 8a 08 	lds	r22, 0x088A
    247a:	70 91 8b 08 	lds	r23, 0x088B
    247e:	64 5f       	subi	r22, 0xF4	; 244
    2480:	7f 4f       	sbci	r23, 0xFF	; 255
    2482:	0e 94 90 03 	call	0x720	; 0x720 <vListInsert>
    2486:	80 91 8a 08 	lds	r24, 0x088A
    248a:	90 91 8b 08 	lds	r25, 0x088B
    248e:	02 96       	adiw	r24, 0x02	; 2
    2490:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2494:	cf 3f       	cpi	r28, 0xFF	; 255
    2496:	8f ef       	ldi	r24, 0xFF	; 255
    2498:	d8 07       	cpc	r29, r24
    249a:	59 f4       	brne	.+22     	; 0x24b2 <vTaskPlaceOnEventList+0x42>
    249c:	60 91 8a 08 	lds	r22, 0x088A
    24a0:	70 91 8b 08 	lds	r23, 0x088B
    24a4:	6e 5f       	subi	r22, 0xFE	; 254
    24a6:	7f 4f       	sbci	r23, 0xFF	; 255
    24a8:	8b e2       	ldi	r24, 0x2B	; 43
    24aa:	98 e0       	ldi	r25, 0x08	; 8
    24ac:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    24b0:	07 c0       	rjmp	.+14     	; 0x24c0 <vTaskPlaceOnEventList+0x50>
    24b2:	80 91 28 08 	lds	r24, 0x0828
    24b6:	90 91 29 08 	lds	r25, 0x0829
    24ba:	8c 0f       	add	r24, r28
    24bc:	9d 1f       	adc	r25, r29
    24be:	d2 db       	rcall	.-2140   	; 0x1c64 <prvAddCurrentTaskToDelayedList>
    24c0:	df 91       	pop	r29
    24c2:	cf 91       	pop	r28
    24c4:	08 95       	ret

000024c6 <xTaskRemoveFromEventList>:
    24c6:	0f 93       	push	r16
    24c8:	1f 93       	push	r17
    24ca:	cf 93       	push	r28
    24cc:	df 93       	push	r29
    24ce:	dc 01       	movw	r26, r24
    24d0:	15 96       	adiw	r26, 0x05	; 5
    24d2:	ed 91       	ld	r30, X+
    24d4:	fc 91       	ld	r31, X
    24d6:	16 97       	sbiw	r26, 0x06	; 6
    24d8:	c6 81       	ldd	r28, Z+6	; 0x06
    24da:	d7 81       	ldd	r29, Z+7	; 0x07
    24dc:	8e 01       	movw	r16, r28
    24de:	04 5f       	subi	r16, 0xF4	; 244
    24e0:	1f 4f       	sbci	r17, 0xFF	; 255
    24e2:	c8 01       	movw	r24, r16
    24e4:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    24e8:	80 91 21 08 	lds	r24, 0x0821
    24ec:	81 11       	cpse	r24, r1
    24ee:	1c c0       	rjmp	.+56     	; 0x2528 <xTaskRemoveFromEventList+0x62>
    24f0:	0a 50       	subi	r16, 0x0A	; 10
    24f2:	11 09       	sbc	r17, r1
    24f4:	c8 01       	movw	r24, r16
    24f6:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    24fa:	8e 89       	ldd	r24, Y+22	; 0x16
    24fc:	90 91 27 08 	lds	r25, 0x0827
    2500:	98 17       	cp	r25, r24
    2502:	10 f4       	brcc	.+4      	; 0x2508 <xTaskRemoveFromEventList+0x42>
    2504:	80 93 27 08 	sts	0x0827, r24
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	9c 01       	movw	r18, r24
    250c:	22 0f       	add	r18, r18
    250e:	33 1f       	adc	r19, r19
    2510:	22 0f       	add	r18, r18
    2512:	33 1f       	adc	r19, r19
    2514:	22 0f       	add	r18, r18
    2516:	33 1f       	adc	r19, r19
    2518:	82 0f       	add	r24, r18
    251a:	93 1f       	adc	r25, r19
    251c:	b8 01       	movw	r22, r16
    251e:	83 5a       	subi	r24, 0xA3	; 163
    2520:	97 4f       	sbci	r25, 0xF7	; 247
    2522:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2526:	05 c0       	rjmp	.+10     	; 0x2532 <xTaskRemoveFromEventList+0x6c>
    2528:	b8 01       	movw	r22, r16
    252a:	8e e3       	ldi	r24, 0x3E	; 62
    252c:	98 e0       	ldi	r25, 0x08	; 8
    252e:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2532:	e0 91 8a 08 	lds	r30, 0x088A
    2536:	f0 91 8b 08 	lds	r31, 0x088B
    253a:	9e 89       	ldd	r25, Y+22	; 0x16
    253c:	86 89       	ldd	r24, Z+22	; 0x16
    253e:	89 17       	cp	r24, r25
    2540:	20 f4       	brcc	.+8      	; 0x254a <xTaskRemoveFromEventList+0x84>
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	80 93 24 08 	sts	0x0824, r24
    2548:	01 c0       	rjmp	.+2      	; 0x254c <xTaskRemoveFromEventList+0x86>
    254a:	80 e0       	ldi	r24, 0x00	; 0
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	08 95       	ret

00002556 <vTaskSetTimeOutState>:
    2556:	20 91 23 08 	lds	r18, 0x0823
    255a:	fc 01       	movw	r30, r24
    255c:	20 83       	st	Z, r18
    255e:	20 91 28 08 	lds	r18, 0x0828
    2562:	30 91 29 08 	lds	r19, 0x0829
    2566:	32 83       	std	Z+2, r19	; 0x02
    2568:	21 83       	std	Z+1, r18	; 0x01
    256a:	08 95       	ret

0000256c <xTaskCheckForTimeOut>:
    256c:	0f b6       	in	r0, 0x3f	; 63
    256e:	f8 94       	cli
    2570:	0f 92       	push	r0
    2572:	40 91 28 08 	lds	r20, 0x0828
    2576:	50 91 29 08 	lds	r21, 0x0829
    257a:	db 01       	movw	r26, r22
    257c:	2d 91       	ld	r18, X+
    257e:	3c 91       	ld	r19, X
    2580:	2f 3f       	cpi	r18, 0xFF	; 255
    2582:	bf ef       	ldi	r27, 0xFF	; 255
    2584:	3b 07       	cpc	r19, r27
    2586:	11 f1       	breq	.+68     	; 0x25cc <xTaskCheckForTimeOut+0x60>
    2588:	e0 91 23 08 	lds	r30, 0x0823
    258c:	dc 01       	movw	r26, r24
    258e:	fc 91       	ld	r31, X
    2590:	fe 17       	cp	r31, r30
    2592:	39 f0       	breq	.+14     	; 0x25a2 <xTaskCheckForTimeOut+0x36>
    2594:	11 96       	adiw	r26, 0x01	; 1
    2596:	ed 91       	ld	r30, X+
    2598:	fc 91       	ld	r31, X
    259a:	12 97       	sbiw	r26, 0x02	; 2
    259c:	4e 17       	cp	r20, r30
    259e:	5f 07       	cpc	r21, r31
    25a0:	b8 f4       	brcc	.+46     	; 0x25d0 <xTaskCheckForTimeOut+0x64>
    25a2:	dc 01       	movw	r26, r24
    25a4:	11 96       	adiw	r26, 0x01	; 1
    25a6:	ed 91       	ld	r30, X+
    25a8:	fc 91       	ld	r31, X
    25aa:	12 97       	sbiw	r26, 0x02	; 2
    25ac:	da 01       	movw	r26, r20
    25ae:	ae 1b       	sub	r26, r30
    25b0:	bf 0b       	sbc	r27, r31
    25b2:	a2 17       	cp	r26, r18
    25b4:	b3 07       	cpc	r27, r19
    25b6:	70 f4       	brcc	.+28     	; 0x25d4 <xTaskCheckForTimeOut+0x68>
    25b8:	e4 1b       	sub	r30, r20
    25ba:	f5 0b       	sbc	r31, r21
    25bc:	2e 0f       	add	r18, r30
    25be:	3f 1f       	adc	r19, r31
    25c0:	fb 01       	movw	r30, r22
    25c2:	31 83       	std	Z+1, r19	; 0x01
    25c4:	20 83       	st	Z, r18
    25c6:	c7 df       	rcall	.-114    	; 0x2556 <vTaskSetTimeOutState>
    25c8:	80 e0       	ldi	r24, 0x00	; 0
    25ca:	05 c0       	rjmp	.+10     	; 0x25d6 <xTaskCheckForTimeOut+0x6a>
    25cc:	80 e0       	ldi	r24, 0x00	; 0
    25ce:	03 c0       	rjmp	.+6      	; 0x25d6 <xTaskCheckForTimeOut+0x6a>
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	01 c0       	rjmp	.+2      	; 0x25d6 <xTaskCheckForTimeOut+0x6a>
    25d4:	81 e0       	ldi	r24, 0x01	; 1
    25d6:	0f 90       	pop	r0
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	08 95       	ret

000025dc <vTaskMissedYield>:
    25dc:	81 e0       	ldi	r24, 0x01	; 1
    25de:	80 93 24 08 	sts	0x0824, r24
    25e2:	08 95       	ret

000025e4 <vTaskPriorityInherit>:
    25e4:	0f 93       	push	r16
    25e6:	1f 93       	push	r17
    25e8:	cf 93       	push	r28
    25ea:	df 93       	push	r29
    25ec:	ec 01       	movw	r28, r24
    25ee:	00 97       	sbiw	r24, 0x00	; 0
    25f0:	09 f4       	brne	.+2      	; 0x25f4 <vTaskPriorityInherit+0x10>
    25f2:	51 c0       	rjmp	.+162    	; 0x2696 <vTaskPriorityInherit+0xb2>
    25f4:	8e 89       	ldd	r24, Y+22	; 0x16
    25f6:	e0 91 8a 08 	lds	r30, 0x088A
    25fa:	f0 91 8b 08 	lds	r31, 0x088B
    25fe:	96 89       	ldd	r25, Z+22	; 0x16
    2600:	89 17       	cp	r24, r25
    2602:	08 f0       	brcs	.+2      	; 0x2606 <vTaskPriorityInherit+0x22>
    2604:	48 c0       	rjmp	.+144    	; 0x2696 <vTaskPriorityInherit+0xb2>
    2606:	2c 85       	ldd	r18, Y+12	; 0x0c
    2608:	3d 85       	ldd	r19, Y+13	; 0x0d
    260a:	33 23       	and	r19, r19
    260c:	5c f0       	brlt	.+22     	; 0x2624 <vTaskPriorityInherit+0x40>
    260e:	e0 91 8a 08 	lds	r30, 0x088A
    2612:	f0 91 8b 08 	lds	r31, 0x088B
    2616:	96 89       	ldd	r25, Z+22	; 0x16
    2618:	25 e0       	ldi	r18, 0x05	; 5
    261a:	30 e0       	ldi	r19, 0x00	; 0
    261c:	29 1b       	sub	r18, r25
    261e:	31 09       	sbc	r19, r1
    2620:	3d 87       	std	Y+13, r19	; 0x0d
    2622:	2c 87       	std	Y+12, r18	; 0x0c
    2624:	90 e0       	ldi	r25, 0x00	; 0
    2626:	9c 01       	movw	r18, r24
    2628:	22 0f       	add	r18, r18
    262a:	33 1f       	adc	r19, r19
    262c:	22 0f       	add	r18, r18
    262e:	33 1f       	adc	r19, r19
    2630:	22 0f       	add	r18, r18
    2632:	33 1f       	adc	r19, r19
    2634:	82 0f       	add	r24, r18
    2636:	93 1f       	adc	r25, r19
    2638:	83 5a       	subi	r24, 0xA3	; 163
    263a:	97 4f       	sbci	r25, 0xF7	; 247
    263c:	2a 85       	ldd	r18, Y+10	; 0x0a
    263e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2640:	28 17       	cp	r18, r24
    2642:	39 07       	cpc	r19, r25
    2644:	11 f5       	brne	.+68     	; 0x268a <vTaskPriorityInherit+0xa6>
    2646:	8e 01       	movw	r16, r28
    2648:	0e 5f       	subi	r16, 0xFE	; 254
    264a:	1f 4f       	sbci	r17, 0xFF	; 255
    264c:	c8 01       	movw	r24, r16
    264e:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    2652:	e0 91 8a 08 	lds	r30, 0x088A
    2656:	f0 91 8b 08 	lds	r31, 0x088B
    265a:	86 89       	ldd	r24, Z+22	; 0x16
    265c:	8e 8b       	std	Y+22, r24	; 0x16
    265e:	90 91 27 08 	lds	r25, 0x0827
    2662:	98 17       	cp	r25, r24
    2664:	10 f4       	brcc	.+4      	; 0x266a <vTaskPriorityInherit+0x86>
    2666:	80 93 27 08 	sts	0x0827, r24
    266a:	90 e0       	ldi	r25, 0x00	; 0
    266c:	9c 01       	movw	r18, r24
    266e:	22 0f       	add	r18, r18
    2670:	33 1f       	adc	r19, r19
    2672:	22 0f       	add	r18, r18
    2674:	33 1f       	adc	r19, r19
    2676:	22 0f       	add	r18, r18
    2678:	33 1f       	adc	r19, r19
    267a:	82 0f       	add	r24, r18
    267c:	93 1f       	adc	r25, r19
    267e:	b8 01       	movw	r22, r16
    2680:	83 5a       	subi	r24, 0xA3	; 163
    2682:	97 4f       	sbci	r25, 0xF7	; 247
    2684:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2688:	06 c0       	rjmp	.+12     	; 0x2696 <vTaskPriorityInherit+0xb2>
    268a:	e0 91 8a 08 	lds	r30, 0x088A
    268e:	f0 91 8b 08 	lds	r31, 0x088B
    2692:	86 89       	ldd	r24, Z+22	; 0x16
    2694:	8e 8b       	std	Y+22, r24	; 0x16
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	1f 91       	pop	r17
    269c:	0f 91       	pop	r16
    269e:	08 95       	ret

000026a0 <xTaskPriorityDisinherit>:
    26a0:	0f 93       	push	r16
    26a2:	1f 93       	push	r17
    26a4:	cf 93       	push	r28
    26a6:	df 93       	push	r29
    26a8:	ec 01       	movw	r28, r24
    26aa:	00 97       	sbiw	r24, 0x00	; 0
    26ac:	71 f1       	breq	.+92     	; 0x270a <xTaskPriorityDisinherit+0x6a>
    26ae:	8a a1       	ldd	r24, Y+34	; 0x22
    26b0:	81 50       	subi	r24, 0x01	; 1
    26b2:	8a a3       	std	Y+34, r24	; 0x22
    26b4:	2e 89       	ldd	r18, Y+22	; 0x16
    26b6:	99 a1       	ldd	r25, Y+33	; 0x21
    26b8:	29 17       	cp	r18, r25
    26ba:	49 f1       	breq	.+82     	; 0x270e <xTaskPriorityDisinherit+0x6e>
    26bc:	81 11       	cpse	r24, r1
    26be:	29 c0       	rjmp	.+82     	; 0x2712 <xTaskPriorityDisinherit+0x72>
    26c0:	8e 01       	movw	r16, r28
    26c2:	0e 5f       	subi	r16, 0xFE	; 254
    26c4:	1f 4f       	sbci	r17, 0xFF	; 255
    26c6:	c8 01       	movw	r24, r16
    26c8:	0e 94 c1 03 	call	0x782	; 0x782 <uxListRemove>
    26cc:	89 a1       	ldd	r24, Y+33	; 0x21
    26ce:	8e 8b       	std	Y+22, r24	; 0x16
    26d0:	25 e0       	ldi	r18, 0x05	; 5
    26d2:	30 e0       	ldi	r19, 0x00	; 0
    26d4:	28 1b       	sub	r18, r24
    26d6:	31 09       	sbc	r19, r1
    26d8:	3d 87       	std	Y+13, r19	; 0x0d
    26da:	2c 87       	std	Y+12, r18	; 0x0c
    26dc:	90 91 27 08 	lds	r25, 0x0827
    26e0:	98 17       	cp	r25, r24
    26e2:	10 f4       	brcc	.+4      	; 0x26e8 <xTaskPriorityDisinherit+0x48>
    26e4:	80 93 27 08 	sts	0x0827, r24
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	9c 01       	movw	r18, r24
    26ec:	22 0f       	add	r18, r18
    26ee:	33 1f       	adc	r19, r19
    26f0:	22 0f       	add	r18, r18
    26f2:	33 1f       	adc	r19, r19
    26f4:	22 0f       	add	r18, r18
    26f6:	33 1f       	adc	r19, r19
    26f8:	82 0f       	add	r24, r18
    26fa:	93 1f       	adc	r25, r19
    26fc:	b8 01       	movw	r22, r16
    26fe:	83 5a       	subi	r24, 0xA3	; 163
    2700:	97 4f       	sbci	r25, 0xF7	; 247
    2702:	0e 94 6f 03 	call	0x6de	; 0x6de <vListInsertEnd>
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	05 c0       	rjmp	.+10     	; 0x2714 <xTaskPriorityDisinherit+0x74>
    270a:	80 e0       	ldi	r24, 0x00	; 0
    270c:	03 c0       	rjmp	.+6      	; 0x2714 <xTaskPriorityDisinherit+0x74>
    270e:	80 e0       	ldi	r24, 0x00	; 0
    2710:	01 c0       	rjmp	.+2      	; 0x2714 <xTaskPriorityDisinherit+0x74>
    2712:	80 e0       	ldi	r24, 0x00	; 0
    2714:	df 91       	pop	r29
    2716:	cf 91       	pop	r28
    2718:	1f 91       	pop	r17
    271a:	0f 91       	pop	r16
    271c:	08 95       	ret

0000271e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    271e:	80 91 8a 08 	lds	r24, 0x088A
    2722:	90 91 8b 08 	lds	r25, 0x088B
    2726:	89 2b       	or	r24, r25
    2728:	39 f0       	breq	.+14     	; 0x2738 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    272a:	e0 91 8a 08 	lds	r30, 0x088A
    272e:	f0 91 8b 08 	lds	r31, 0x088B
    2732:	82 a1       	ldd	r24, Z+34	; 0x22
    2734:	8f 5f       	subi	r24, 0xFF	; 255
    2736:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2738:	80 91 8a 08 	lds	r24, 0x088A
    273c:	90 91 8b 08 	lds	r25, 0x088B
	}
    2740:	08 95       	ret

00002742 <__subsf3>:
    2742:	50 58       	subi	r21, 0x80	; 128

00002744 <__addsf3>:
    2744:	bb 27       	eor	r27, r27
    2746:	aa 27       	eor	r26, r26
    2748:	0e d0       	rcall	.+28     	; 0x2766 <__addsf3x>
    274a:	e5 c0       	rjmp	.+458    	; 0x2916 <__fp_round>
    274c:	d6 d0       	rcall	.+428    	; 0x28fa <__fp_pscA>
    274e:	30 f0       	brcs	.+12     	; 0x275c <__addsf3+0x18>
    2750:	db d0       	rcall	.+438    	; 0x2908 <__fp_pscB>
    2752:	20 f0       	brcs	.+8      	; 0x275c <__addsf3+0x18>
    2754:	31 f4       	brne	.+12     	; 0x2762 <__addsf3+0x1e>
    2756:	9f 3f       	cpi	r25, 0xFF	; 255
    2758:	11 f4       	brne	.+4      	; 0x275e <__addsf3+0x1a>
    275a:	1e f4       	brtc	.+6      	; 0x2762 <__addsf3+0x1e>
    275c:	cb c0       	rjmp	.+406    	; 0x28f4 <__fp_nan>
    275e:	0e f4       	brtc	.+2      	; 0x2762 <__addsf3+0x1e>
    2760:	e0 95       	com	r30
    2762:	e7 fb       	bst	r30, 7
    2764:	c1 c0       	rjmp	.+386    	; 0x28e8 <__fp_inf>

00002766 <__addsf3x>:
    2766:	e9 2f       	mov	r30, r25
    2768:	e7 d0       	rcall	.+462    	; 0x2938 <__fp_split3>
    276a:	80 f3       	brcs	.-32     	; 0x274c <__addsf3+0x8>
    276c:	ba 17       	cp	r27, r26
    276e:	62 07       	cpc	r22, r18
    2770:	73 07       	cpc	r23, r19
    2772:	84 07       	cpc	r24, r20
    2774:	95 07       	cpc	r25, r21
    2776:	18 f0       	brcs	.+6      	; 0x277e <__addsf3x+0x18>
    2778:	71 f4       	brne	.+28     	; 0x2796 <__addsf3x+0x30>
    277a:	9e f5       	brtc	.+102    	; 0x27e2 <__addsf3x+0x7c>
    277c:	ff c0       	rjmp	.+510    	; 0x297c <__fp_zero>
    277e:	0e f4       	brtc	.+2      	; 0x2782 <__addsf3x+0x1c>
    2780:	e0 95       	com	r30
    2782:	0b 2e       	mov	r0, r27
    2784:	ba 2f       	mov	r27, r26
    2786:	a0 2d       	mov	r26, r0
    2788:	0b 01       	movw	r0, r22
    278a:	b9 01       	movw	r22, r18
    278c:	90 01       	movw	r18, r0
    278e:	0c 01       	movw	r0, r24
    2790:	ca 01       	movw	r24, r20
    2792:	a0 01       	movw	r20, r0
    2794:	11 24       	eor	r1, r1
    2796:	ff 27       	eor	r31, r31
    2798:	59 1b       	sub	r21, r25
    279a:	99 f0       	breq	.+38     	; 0x27c2 <__addsf3x+0x5c>
    279c:	59 3f       	cpi	r21, 0xF9	; 249
    279e:	50 f4       	brcc	.+20     	; 0x27b4 <__addsf3x+0x4e>
    27a0:	50 3e       	cpi	r21, 0xE0	; 224
    27a2:	68 f1       	brcs	.+90     	; 0x27fe <__addsf3x+0x98>
    27a4:	1a 16       	cp	r1, r26
    27a6:	f0 40       	sbci	r31, 0x00	; 0
    27a8:	a2 2f       	mov	r26, r18
    27aa:	23 2f       	mov	r18, r19
    27ac:	34 2f       	mov	r19, r20
    27ae:	44 27       	eor	r20, r20
    27b0:	58 5f       	subi	r21, 0xF8	; 248
    27b2:	f3 cf       	rjmp	.-26     	; 0x279a <__addsf3x+0x34>
    27b4:	46 95       	lsr	r20
    27b6:	37 95       	ror	r19
    27b8:	27 95       	ror	r18
    27ba:	a7 95       	ror	r26
    27bc:	f0 40       	sbci	r31, 0x00	; 0
    27be:	53 95       	inc	r21
    27c0:	c9 f7       	brne	.-14     	; 0x27b4 <__addsf3x+0x4e>
    27c2:	7e f4       	brtc	.+30     	; 0x27e2 <__addsf3x+0x7c>
    27c4:	1f 16       	cp	r1, r31
    27c6:	ba 0b       	sbc	r27, r26
    27c8:	62 0b       	sbc	r22, r18
    27ca:	73 0b       	sbc	r23, r19
    27cc:	84 0b       	sbc	r24, r20
    27ce:	ba f0       	brmi	.+46     	; 0x27fe <__addsf3x+0x98>
    27d0:	91 50       	subi	r25, 0x01	; 1
    27d2:	a1 f0       	breq	.+40     	; 0x27fc <__addsf3x+0x96>
    27d4:	ff 0f       	add	r31, r31
    27d6:	bb 1f       	adc	r27, r27
    27d8:	66 1f       	adc	r22, r22
    27da:	77 1f       	adc	r23, r23
    27dc:	88 1f       	adc	r24, r24
    27de:	c2 f7       	brpl	.-16     	; 0x27d0 <__addsf3x+0x6a>
    27e0:	0e c0       	rjmp	.+28     	; 0x27fe <__addsf3x+0x98>
    27e2:	ba 0f       	add	r27, r26
    27e4:	62 1f       	adc	r22, r18
    27e6:	73 1f       	adc	r23, r19
    27e8:	84 1f       	adc	r24, r20
    27ea:	48 f4       	brcc	.+18     	; 0x27fe <__addsf3x+0x98>
    27ec:	87 95       	ror	r24
    27ee:	77 95       	ror	r23
    27f0:	67 95       	ror	r22
    27f2:	b7 95       	ror	r27
    27f4:	f7 95       	ror	r31
    27f6:	9e 3f       	cpi	r25, 0xFE	; 254
    27f8:	08 f0       	brcs	.+2      	; 0x27fc <__addsf3x+0x96>
    27fa:	b3 cf       	rjmp	.-154    	; 0x2762 <__addsf3+0x1e>
    27fc:	93 95       	inc	r25
    27fe:	88 0f       	add	r24, r24
    2800:	08 f0       	brcs	.+2      	; 0x2804 <__addsf3x+0x9e>
    2802:	99 27       	eor	r25, r25
    2804:	ee 0f       	add	r30, r30
    2806:	97 95       	ror	r25
    2808:	87 95       	ror	r24
    280a:	08 95       	ret

0000280c <__fixsfsi>:
    280c:	04 d0       	rcall	.+8      	; 0x2816 <__fixunssfsi>
    280e:	68 94       	set
    2810:	b1 11       	cpse	r27, r1
    2812:	b5 c0       	rjmp	.+362    	; 0x297e <__fp_szero>
    2814:	08 95       	ret

00002816 <__fixunssfsi>:
    2816:	98 d0       	rcall	.+304    	; 0x2948 <__fp_splitA>
    2818:	88 f0       	brcs	.+34     	; 0x283c <__fixunssfsi+0x26>
    281a:	9f 57       	subi	r25, 0x7F	; 127
    281c:	90 f0       	brcs	.+36     	; 0x2842 <__fixunssfsi+0x2c>
    281e:	b9 2f       	mov	r27, r25
    2820:	99 27       	eor	r25, r25
    2822:	b7 51       	subi	r27, 0x17	; 23
    2824:	a0 f0       	brcs	.+40     	; 0x284e <__fixunssfsi+0x38>
    2826:	d1 f0       	breq	.+52     	; 0x285c <__fixunssfsi+0x46>
    2828:	66 0f       	add	r22, r22
    282a:	77 1f       	adc	r23, r23
    282c:	88 1f       	adc	r24, r24
    282e:	99 1f       	adc	r25, r25
    2830:	1a f0       	brmi	.+6      	; 0x2838 <__fixunssfsi+0x22>
    2832:	ba 95       	dec	r27
    2834:	c9 f7       	brne	.-14     	; 0x2828 <__fixunssfsi+0x12>
    2836:	12 c0       	rjmp	.+36     	; 0x285c <__fixunssfsi+0x46>
    2838:	b1 30       	cpi	r27, 0x01	; 1
    283a:	81 f0       	breq	.+32     	; 0x285c <__fixunssfsi+0x46>
    283c:	9f d0       	rcall	.+318    	; 0x297c <__fp_zero>
    283e:	b1 e0       	ldi	r27, 0x01	; 1
    2840:	08 95       	ret
    2842:	9c c0       	rjmp	.+312    	; 0x297c <__fp_zero>
    2844:	67 2f       	mov	r22, r23
    2846:	78 2f       	mov	r23, r24
    2848:	88 27       	eor	r24, r24
    284a:	b8 5f       	subi	r27, 0xF8	; 248
    284c:	39 f0       	breq	.+14     	; 0x285c <__fixunssfsi+0x46>
    284e:	b9 3f       	cpi	r27, 0xF9	; 249
    2850:	cc f3       	brlt	.-14     	; 0x2844 <__fixunssfsi+0x2e>
    2852:	86 95       	lsr	r24
    2854:	77 95       	ror	r23
    2856:	67 95       	ror	r22
    2858:	b3 95       	inc	r27
    285a:	d9 f7       	brne	.-10     	; 0x2852 <__fixunssfsi+0x3c>
    285c:	3e f4       	brtc	.+14     	; 0x286c <__fixunssfsi+0x56>
    285e:	90 95       	com	r25
    2860:	80 95       	com	r24
    2862:	70 95       	com	r23
    2864:	61 95       	neg	r22
    2866:	7f 4f       	sbci	r23, 0xFF	; 255
    2868:	8f 4f       	sbci	r24, 0xFF	; 255
    286a:	9f 4f       	sbci	r25, 0xFF	; 255
    286c:	08 95       	ret

0000286e <__floatunsisf>:
    286e:	e8 94       	clt
    2870:	09 c0       	rjmp	.+18     	; 0x2884 <__floatsisf+0x12>

00002872 <__floatsisf>:
    2872:	97 fb       	bst	r25, 7
    2874:	3e f4       	brtc	.+14     	; 0x2884 <__floatsisf+0x12>
    2876:	90 95       	com	r25
    2878:	80 95       	com	r24
    287a:	70 95       	com	r23
    287c:	61 95       	neg	r22
    287e:	7f 4f       	sbci	r23, 0xFF	; 255
    2880:	8f 4f       	sbci	r24, 0xFF	; 255
    2882:	9f 4f       	sbci	r25, 0xFF	; 255
    2884:	99 23       	and	r25, r25
    2886:	a9 f0       	breq	.+42     	; 0x28b2 <__floatsisf+0x40>
    2888:	f9 2f       	mov	r31, r25
    288a:	96 e9       	ldi	r25, 0x96	; 150
    288c:	bb 27       	eor	r27, r27
    288e:	93 95       	inc	r25
    2890:	f6 95       	lsr	r31
    2892:	87 95       	ror	r24
    2894:	77 95       	ror	r23
    2896:	67 95       	ror	r22
    2898:	b7 95       	ror	r27
    289a:	f1 11       	cpse	r31, r1
    289c:	f8 cf       	rjmp	.-16     	; 0x288e <__floatsisf+0x1c>
    289e:	fa f4       	brpl	.+62     	; 0x28de <__floatsisf+0x6c>
    28a0:	bb 0f       	add	r27, r27
    28a2:	11 f4       	brne	.+4      	; 0x28a8 <__floatsisf+0x36>
    28a4:	60 ff       	sbrs	r22, 0
    28a6:	1b c0       	rjmp	.+54     	; 0x28de <__floatsisf+0x6c>
    28a8:	6f 5f       	subi	r22, 0xFF	; 255
    28aa:	7f 4f       	sbci	r23, 0xFF	; 255
    28ac:	8f 4f       	sbci	r24, 0xFF	; 255
    28ae:	9f 4f       	sbci	r25, 0xFF	; 255
    28b0:	16 c0       	rjmp	.+44     	; 0x28de <__floatsisf+0x6c>
    28b2:	88 23       	and	r24, r24
    28b4:	11 f0       	breq	.+4      	; 0x28ba <__floatsisf+0x48>
    28b6:	96 e9       	ldi	r25, 0x96	; 150
    28b8:	11 c0       	rjmp	.+34     	; 0x28dc <__floatsisf+0x6a>
    28ba:	77 23       	and	r23, r23
    28bc:	21 f0       	breq	.+8      	; 0x28c6 <__floatsisf+0x54>
    28be:	9e e8       	ldi	r25, 0x8E	; 142
    28c0:	87 2f       	mov	r24, r23
    28c2:	76 2f       	mov	r23, r22
    28c4:	05 c0       	rjmp	.+10     	; 0x28d0 <__floatsisf+0x5e>
    28c6:	66 23       	and	r22, r22
    28c8:	71 f0       	breq	.+28     	; 0x28e6 <__floatsisf+0x74>
    28ca:	96 e8       	ldi	r25, 0x86	; 134
    28cc:	86 2f       	mov	r24, r22
    28ce:	70 e0       	ldi	r23, 0x00	; 0
    28d0:	60 e0       	ldi	r22, 0x00	; 0
    28d2:	2a f0       	brmi	.+10     	; 0x28de <__floatsisf+0x6c>
    28d4:	9a 95       	dec	r25
    28d6:	66 0f       	add	r22, r22
    28d8:	77 1f       	adc	r23, r23
    28da:	88 1f       	adc	r24, r24
    28dc:	da f7       	brpl	.-10     	; 0x28d4 <__floatsisf+0x62>
    28de:	88 0f       	add	r24, r24
    28e0:	96 95       	lsr	r25
    28e2:	87 95       	ror	r24
    28e4:	97 f9       	bld	r25, 7
    28e6:	08 95       	ret

000028e8 <__fp_inf>:
    28e8:	97 f9       	bld	r25, 7
    28ea:	9f 67       	ori	r25, 0x7F	; 127
    28ec:	80 e8       	ldi	r24, 0x80	; 128
    28ee:	70 e0       	ldi	r23, 0x00	; 0
    28f0:	60 e0       	ldi	r22, 0x00	; 0
    28f2:	08 95       	ret

000028f4 <__fp_nan>:
    28f4:	9f ef       	ldi	r25, 0xFF	; 255
    28f6:	80 ec       	ldi	r24, 0xC0	; 192
    28f8:	08 95       	ret

000028fa <__fp_pscA>:
    28fa:	00 24       	eor	r0, r0
    28fc:	0a 94       	dec	r0
    28fe:	16 16       	cp	r1, r22
    2900:	17 06       	cpc	r1, r23
    2902:	18 06       	cpc	r1, r24
    2904:	09 06       	cpc	r0, r25
    2906:	08 95       	ret

00002908 <__fp_pscB>:
    2908:	00 24       	eor	r0, r0
    290a:	0a 94       	dec	r0
    290c:	12 16       	cp	r1, r18
    290e:	13 06       	cpc	r1, r19
    2910:	14 06       	cpc	r1, r20
    2912:	05 06       	cpc	r0, r21
    2914:	08 95       	ret

00002916 <__fp_round>:
    2916:	09 2e       	mov	r0, r25
    2918:	03 94       	inc	r0
    291a:	00 0c       	add	r0, r0
    291c:	11 f4       	brne	.+4      	; 0x2922 <__fp_round+0xc>
    291e:	88 23       	and	r24, r24
    2920:	52 f0       	brmi	.+20     	; 0x2936 <__fp_round+0x20>
    2922:	bb 0f       	add	r27, r27
    2924:	40 f4       	brcc	.+16     	; 0x2936 <__fp_round+0x20>
    2926:	bf 2b       	or	r27, r31
    2928:	11 f4       	brne	.+4      	; 0x292e <__fp_round+0x18>
    292a:	60 ff       	sbrs	r22, 0
    292c:	04 c0       	rjmp	.+8      	; 0x2936 <__fp_round+0x20>
    292e:	6f 5f       	subi	r22, 0xFF	; 255
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	8f 4f       	sbci	r24, 0xFF	; 255
    2934:	9f 4f       	sbci	r25, 0xFF	; 255
    2936:	08 95       	ret

00002938 <__fp_split3>:
    2938:	57 fd       	sbrc	r21, 7
    293a:	90 58       	subi	r25, 0x80	; 128
    293c:	44 0f       	add	r20, r20
    293e:	55 1f       	adc	r21, r21
    2940:	59 f0       	breq	.+22     	; 0x2958 <__fp_splitA+0x10>
    2942:	5f 3f       	cpi	r21, 0xFF	; 255
    2944:	71 f0       	breq	.+28     	; 0x2962 <__fp_splitA+0x1a>
    2946:	47 95       	ror	r20

00002948 <__fp_splitA>:
    2948:	88 0f       	add	r24, r24
    294a:	97 fb       	bst	r25, 7
    294c:	99 1f       	adc	r25, r25
    294e:	61 f0       	breq	.+24     	; 0x2968 <__fp_splitA+0x20>
    2950:	9f 3f       	cpi	r25, 0xFF	; 255
    2952:	79 f0       	breq	.+30     	; 0x2972 <__fp_splitA+0x2a>
    2954:	87 95       	ror	r24
    2956:	08 95       	ret
    2958:	12 16       	cp	r1, r18
    295a:	13 06       	cpc	r1, r19
    295c:	14 06       	cpc	r1, r20
    295e:	55 1f       	adc	r21, r21
    2960:	f2 cf       	rjmp	.-28     	; 0x2946 <__fp_split3+0xe>
    2962:	46 95       	lsr	r20
    2964:	f1 df       	rcall	.-30     	; 0x2948 <__fp_splitA>
    2966:	08 c0       	rjmp	.+16     	; 0x2978 <__fp_splitA+0x30>
    2968:	16 16       	cp	r1, r22
    296a:	17 06       	cpc	r1, r23
    296c:	18 06       	cpc	r1, r24
    296e:	99 1f       	adc	r25, r25
    2970:	f1 cf       	rjmp	.-30     	; 0x2954 <__fp_splitA+0xc>
    2972:	86 95       	lsr	r24
    2974:	71 05       	cpc	r23, r1
    2976:	61 05       	cpc	r22, r1
    2978:	08 94       	sec
    297a:	08 95       	ret

0000297c <__fp_zero>:
    297c:	e8 94       	clt

0000297e <__fp_szero>:
    297e:	bb 27       	eor	r27, r27
    2980:	66 27       	eor	r22, r22
    2982:	77 27       	eor	r23, r23
    2984:	cb 01       	movw	r24, r22
    2986:	97 f9       	bld	r25, 7
    2988:	08 95       	ret

0000298a <__mulsf3>:
    298a:	0b d0       	rcall	.+22     	; 0x29a2 <__mulsf3x>
    298c:	c4 cf       	rjmp	.-120    	; 0x2916 <__fp_round>
    298e:	b5 df       	rcall	.-150    	; 0x28fa <__fp_pscA>
    2990:	28 f0       	brcs	.+10     	; 0x299c <__mulsf3+0x12>
    2992:	ba df       	rcall	.-140    	; 0x2908 <__fp_pscB>
    2994:	18 f0       	brcs	.+6      	; 0x299c <__mulsf3+0x12>
    2996:	95 23       	and	r25, r21
    2998:	09 f0       	breq	.+2      	; 0x299c <__mulsf3+0x12>
    299a:	a6 cf       	rjmp	.-180    	; 0x28e8 <__fp_inf>
    299c:	ab cf       	rjmp	.-170    	; 0x28f4 <__fp_nan>
    299e:	11 24       	eor	r1, r1
    29a0:	ee cf       	rjmp	.-36     	; 0x297e <__fp_szero>

000029a2 <__mulsf3x>:
    29a2:	ca df       	rcall	.-108    	; 0x2938 <__fp_split3>
    29a4:	a0 f3       	brcs	.-24     	; 0x298e <__mulsf3+0x4>

000029a6 <__mulsf3_pse>:
    29a6:	95 9f       	mul	r25, r21
    29a8:	d1 f3       	breq	.-12     	; 0x299e <__mulsf3+0x14>
    29aa:	95 0f       	add	r25, r21
    29ac:	50 e0       	ldi	r21, 0x00	; 0
    29ae:	55 1f       	adc	r21, r21
    29b0:	62 9f       	mul	r22, r18
    29b2:	f0 01       	movw	r30, r0
    29b4:	72 9f       	mul	r23, r18
    29b6:	bb 27       	eor	r27, r27
    29b8:	f0 0d       	add	r31, r0
    29ba:	b1 1d       	adc	r27, r1
    29bc:	63 9f       	mul	r22, r19
    29be:	aa 27       	eor	r26, r26
    29c0:	f0 0d       	add	r31, r0
    29c2:	b1 1d       	adc	r27, r1
    29c4:	aa 1f       	adc	r26, r26
    29c6:	64 9f       	mul	r22, r20
    29c8:	66 27       	eor	r22, r22
    29ca:	b0 0d       	add	r27, r0
    29cc:	a1 1d       	adc	r26, r1
    29ce:	66 1f       	adc	r22, r22
    29d0:	82 9f       	mul	r24, r18
    29d2:	22 27       	eor	r18, r18
    29d4:	b0 0d       	add	r27, r0
    29d6:	a1 1d       	adc	r26, r1
    29d8:	62 1f       	adc	r22, r18
    29da:	73 9f       	mul	r23, r19
    29dc:	b0 0d       	add	r27, r0
    29de:	a1 1d       	adc	r26, r1
    29e0:	62 1f       	adc	r22, r18
    29e2:	83 9f       	mul	r24, r19
    29e4:	a0 0d       	add	r26, r0
    29e6:	61 1d       	adc	r22, r1
    29e8:	22 1f       	adc	r18, r18
    29ea:	74 9f       	mul	r23, r20
    29ec:	33 27       	eor	r19, r19
    29ee:	a0 0d       	add	r26, r0
    29f0:	61 1d       	adc	r22, r1
    29f2:	23 1f       	adc	r18, r19
    29f4:	84 9f       	mul	r24, r20
    29f6:	60 0d       	add	r22, r0
    29f8:	21 1d       	adc	r18, r1
    29fa:	82 2f       	mov	r24, r18
    29fc:	76 2f       	mov	r23, r22
    29fe:	6a 2f       	mov	r22, r26
    2a00:	11 24       	eor	r1, r1
    2a02:	9f 57       	subi	r25, 0x7F	; 127
    2a04:	50 40       	sbci	r21, 0x00	; 0
    2a06:	8a f0       	brmi	.+34     	; 0x2a2a <__mulsf3_pse+0x84>
    2a08:	e1 f0       	breq	.+56     	; 0x2a42 <__mulsf3_pse+0x9c>
    2a0a:	88 23       	and	r24, r24
    2a0c:	4a f0       	brmi	.+18     	; 0x2a20 <__mulsf3_pse+0x7a>
    2a0e:	ee 0f       	add	r30, r30
    2a10:	ff 1f       	adc	r31, r31
    2a12:	bb 1f       	adc	r27, r27
    2a14:	66 1f       	adc	r22, r22
    2a16:	77 1f       	adc	r23, r23
    2a18:	88 1f       	adc	r24, r24
    2a1a:	91 50       	subi	r25, 0x01	; 1
    2a1c:	50 40       	sbci	r21, 0x00	; 0
    2a1e:	a9 f7       	brne	.-22     	; 0x2a0a <__mulsf3_pse+0x64>
    2a20:	9e 3f       	cpi	r25, 0xFE	; 254
    2a22:	51 05       	cpc	r21, r1
    2a24:	70 f0       	brcs	.+28     	; 0x2a42 <__mulsf3_pse+0x9c>
    2a26:	60 cf       	rjmp	.-320    	; 0x28e8 <__fp_inf>
    2a28:	aa cf       	rjmp	.-172    	; 0x297e <__fp_szero>
    2a2a:	5f 3f       	cpi	r21, 0xFF	; 255
    2a2c:	ec f3       	brlt	.-6      	; 0x2a28 <__mulsf3_pse+0x82>
    2a2e:	98 3e       	cpi	r25, 0xE8	; 232
    2a30:	dc f3       	brlt	.-10     	; 0x2a28 <__mulsf3_pse+0x82>
    2a32:	86 95       	lsr	r24
    2a34:	77 95       	ror	r23
    2a36:	67 95       	ror	r22
    2a38:	b7 95       	ror	r27
    2a3a:	f7 95       	ror	r31
    2a3c:	e7 95       	ror	r30
    2a3e:	9f 5f       	subi	r25, 0xFF	; 255
    2a40:	c1 f7       	brne	.-16     	; 0x2a32 <__mulsf3_pse+0x8c>
    2a42:	fe 2b       	or	r31, r30
    2a44:	88 0f       	add	r24, r24
    2a46:	91 1d       	adc	r25, r1
    2a48:	96 95       	lsr	r25
    2a4a:	87 95       	ror	r24
    2a4c:	97 f9       	bld	r25, 7
    2a4e:	08 95       	ret

00002a50 <pow>:
    2a50:	fa 01       	movw	r30, r20
    2a52:	ee 0f       	add	r30, r30
    2a54:	ff 1f       	adc	r31, r31
    2a56:	30 96       	adiw	r30, 0x00	; 0
    2a58:	21 05       	cpc	r18, r1
    2a5a:	31 05       	cpc	r19, r1
    2a5c:	99 f1       	breq	.+102    	; 0x2ac4 <pow+0x74>
    2a5e:	61 15       	cp	r22, r1
    2a60:	71 05       	cpc	r23, r1
    2a62:	61 f4       	brne	.+24     	; 0x2a7c <pow+0x2c>
    2a64:	80 38       	cpi	r24, 0x80	; 128
    2a66:	bf e3       	ldi	r27, 0x3F	; 63
    2a68:	9b 07       	cpc	r25, r27
    2a6a:	49 f1       	breq	.+82     	; 0x2abe <pow+0x6e>
    2a6c:	68 94       	set
    2a6e:	90 38       	cpi	r25, 0x80	; 128
    2a70:	81 05       	cpc	r24, r1
    2a72:	61 f0       	breq	.+24     	; 0x2a8c <pow+0x3c>
    2a74:	80 38       	cpi	r24, 0x80	; 128
    2a76:	bf ef       	ldi	r27, 0xFF	; 255
    2a78:	9b 07       	cpc	r25, r27
    2a7a:	41 f0       	breq	.+16     	; 0x2a8c <pow+0x3c>
    2a7c:	99 23       	and	r25, r25
    2a7e:	42 f5       	brpl	.+80     	; 0x2ad0 <pow+0x80>
    2a80:	ff 3f       	cpi	r31, 0xFF	; 255
    2a82:	e1 05       	cpc	r30, r1
    2a84:	31 05       	cpc	r19, r1
    2a86:	21 05       	cpc	r18, r1
    2a88:	11 f1       	breq	.+68     	; 0x2ace <pow+0x7e>
    2a8a:	e8 94       	clt
    2a8c:	08 94       	sec
    2a8e:	e7 95       	ror	r30
    2a90:	d9 01       	movw	r26, r18
    2a92:	aa 23       	and	r26, r26
    2a94:	29 f4       	brne	.+10     	; 0x2aa0 <pow+0x50>
    2a96:	ab 2f       	mov	r26, r27
    2a98:	be 2f       	mov	r27, r30
    2a9a:	f8 5f       	subi	r31, 0xF8	; 248
    2a9c:	d0 f3       	brcs	.-12     	; 0x2a92 <pow+0x42>
    2a9e:	10 c0       	rjmp	.+32     	; 0x2ac0 <pow+0x70>
    2aa0:	ff 5f       	subi	r31, 0xFF	; 255
    2aa2:	70 f4       	brcc	.+28     	; 0x2ac0 <pow+0x70>
    2aa4:	a6 95       	lsr	r26
    2aa6:	e0 f7       	brcc	.-8      	; 0x2aa0 <pow+0x50>
    2aa8:	f7 39       	cpi	r31, 0x97	; 151
    2aaa:	50 f0       	brcs	.+20     	; 0x2ac0 <pow+0x70>
    2aac:	19 f0       	breq	.+6      	; 0x2ab4 <pow+0x64>
    2aae:	ff 3a       	cpi	r31, 0xAF	; 175
    2ab0:	38 f4       	brcc	.+14     	; 0x2ac0 <pow+0x70>
    2ab2:	9f 77       	andi	r25, 0x7F	; 127
    2ab4:	9f 93       	push	r25
    2ab6:	0c d0       	rcall	.+24     	; 0x2ad0 <pow+0x80>
    2ab8:	0f 90       	pop	r0
    2aba:	07 fc       	sbrc	r0, 7
    2abc:	90 58       	subi	r25, 0x80	; 128
    2abe:	08 95       	ret
    2ac0:	3e f0       	brts	.+14     	; 0x2ad0 <pow+0x80>
    2ac2:	18 cf       	rjmp	.-464    	; 0x28f4 <__fp_nan>
    2ac4:	60 e0       	ldi	r22, 0x00	; 0
    2ac6:	70 e0       	ldi	r23, 0x00	; 0
    2ac8:	80 e8       	ldi	r24, 0x80	; 128
    2aca:	9f e3       	ldi	r25, 0x3F	; 63
    2acc:	08 95       	ret
    2ace:	4f e7       	ldi	r20, 0x7F	; 127
    2ad0:	9f 77       	andi	r25, 0x7F	; 127
    2ad2:	5f 93       	push	r21
    2ad4:	4f 93       	push	r20
    2ad6:	3f 93       	push	r19
    2ad8:	2f 93       	push	r18
    2ada:	9e d0       	rcall	.+316    	; 0x2c18 <log>
    2adc:	2f 91       	pop	r18
    2ade:	3f 91       	pop	r19
    2ae0:	4f 91       	pop	r20
    2ae2:	5f 91       	pop	r21
    2ae4:	52 df       	rcall	.-348    	; 0x298a <__mulsf3>
    2ae6:	05 c0       	rjmp	.+10     	; 0x2af2 <exp>
    2ae8:	19 f4       	brne	.+6      	; 0x2af0 <pow+0xa0>
    2aea:	0e f0       	brts	.+2      	; 0x2aee <pow+0x9e>
    2aec:	fd ce       	rjmp	.-518    	; 0x28e8 <__fp_inf>
    2aee:	46 cf       	rjmp	.-372    	; 0x297c <__fp_zero>
    2af0:	01 cf       	rjmp	.-510    	; 0x28f4 <__fp_nan>

00002af2 <exp>:
    2af2:	2a df       	rcall	.-428    	; 0x2948 <__fp_splitA>
    2af4:	c8 f3       	brcs	.-14     	; 0x2ae8 <pow+0x98>
    2af6:	96 38       	cpi	r25, 0x86	; 134
    2af8:	c0 f7       	brcc	.-16     	; 0x2aea <pow+0x9a>
    2afa:	07 f8       	bld	r0, 7
    2afc:	0f 92       	push	r0
    2afe:	e8 94       	clt
    2b00:	2b e3       	ldi	r18, 0x3B	; 59
    2b02:	3a ea       	ldi	r19, 0xAA	; 170
    2b04:	48 eb       	ldi	r20, 0xB8	; 184
    2b06:	5f e7       	ldi	r21, 0x7F	; 127
    2b08:	4e df       	rcall	.-356    	; 0x29a6 <__mulsf3_pse>
    2b0a:	0f 92       	push	r0
    2b0c:	0f 92       	push	r0
    2b0e:	0f 92       	push	r0
    2b10:	4d b7       	in	r20, 0x3d	; 61
    2b12:	5e b7       	in	r21, 0x3e	; 62
    2b14:	0f 92       	push	r0
    2b16:	c0 d0       	rcall	.+384    	; 0x2c98 <modf>
    2b18:	e4 ee       	ldi	r30, 0xE4	; 228
    2b1a:	f0 e0       	ldi	r31, 0x00	; 0
    2b1c:	16 d0       	rcall	.+44     	; 0x2b4a <__fp_powser>
    2b1e:	4f 91       	pop	r20
    2b20:	5f 91       	pop	r21
    2b22:	ef 91       	pop	r30
    2b24:	ff 91       	pop	r31
    2b26:	e5 95       	asr	r30
    2b28:	ee 1f       	adc	r30, r30
    2b2a:	ff 1f       	adc	r31, r31
    2b2c:	49 f0       	breq	.+18     	; 0x2b40 <exp+0x4e>
    2b2e:	fe 57       	subi	r31, 0x7E	; 126
    2b30:	e0 68       	ori	r30, 0x80	; 128
    2b32:	44 27       	eor	r20, r20
    2b34:	ee 0f       	add	r30, r30
    2b36:	44 1f       	adc	r20, r20
    2b38:	fa 95       	dec	r31
    2b3a:	e1 f7       	brne	.-8      	; 0x2b34 <exp+0x42>
    2b3c:	41 95       	neg	r20
    2b3e:	55 0b       	sbc	r21, r21
    2b40:	32 d0       	rcall	.+100    	; 0x2ba6 <ldexp>
    2b42:	0f 90       	pop	r0
    2b44:	07 fe       	sbrs	r0, 7
    2b46:	26 c0       	rjmp	.+76     	; 0x2b94 <inverse>
    2b48:	08 95       	ret

00002b4a <__fp_powser>:
    2b4a:	df 93       	push	r29
    2b4c:	cf 93       	push	r28
    2b4e:	1f 93       	push	r17
    2b50:	0f 93       	push	r16
    2b52:	ff 92       	push	r15
    2b54:	ef 92       	push	r14
    2b56:	df 92       	push	r13
    2b58:	7b 01       	movw	r14, r22
    2b5a:	8c 01       	movw	r16, r24
    2b5c:	68 94       	set
    2b5e:	05 c0       	rjmp	.+10     	; 0x2b6a <__fp_powser+0x20>
    2b60:	da 2e       	mov	r13, r26
    2b62:	ef 01       	movw	r28, r30
    2b64:	1e df       	rcall	.-452    	; 0x29a2 <__mulsf3x>
    2b66:	fe 01       	movw	r30, r28
    2b68:	e8 94       	clt
    2b6a:	a5 91       	lpm	r26, Z+
    2b6c:	25 91       	lpm	r18, Z+
    2b6e:	35 91       	lpm	r19, Z+
    2b70:	45 91       	lpm	r20, Z+
    2b72:	55 91       	lpm	r21, Z+
    2b74:	ae f3       	brts	.-22     	; 0x2b60 <__fp_powser+0x16>
    2b76:	ef 01       	movw	r28, r30
    2b78:	f6 dd       	rcall	.-1044   	; 0x2766 <__addsf3x>
    2b7a:	fe 01       	movw	r30, r28
    2b7c:	97 01       	movw	r18, r14
    2b7e:	a8 01       	movw	r20, r16
    2b80:	da 94       	dec	r13
    2b82:	79 f7       	brne	.-34     	; 0x2b62 <__fp_powser+0x18>
    2b84:	df 90       	pop	r13
    2b86:	ef 90       	pop	r14
    2b88:	ff 90       	pop	r15
    2b8a:	0f 91       	pop	r16
    2b8c:	1f 91       	pop	r17
    2b8e:	cf 91       	pop	r28
    2b90:	df 91       	pop	r29
    2b92:	08 95       	ret

00002b94 <inverse>:
    2b94:	9b 01       	movw	r18, r22
    2b96:	ac 01       	movw	r20, r24
    2b98:	60 e0       	ldi	r22, 0x00	; 0
    2b9a:	70 e0       	ldi	r23, 0x00	; 0
    2b9c:	80 e8       	ldi	r24, 0x80	; 128
    2b9e:	9f e3       	ldi	r25, 0x3F	; 63
    2ba0:	ae c0       	rjmp	.+348    	; 0x2cfe <__divsf3>
    2ba2:	a2 ce       	rjmp	.-700    	; 0x28e8 <__fp_inf>
    2ba4:	14 c1       	rjmp	.+552    	; 0x2dce <__fp_mpack>

00002ba6 <ldexp>:
    2ba6:	d0 de       	rcall	.-608    	; 0x2948 <__fp_splitA>
    2ba8:	e8 f3       	brcs	.-6      	; 0x2ba4 <inverse+0x10>
    2baa:	99 23       	and	r25, r25
    2bac:	d9 f3       	breq	.-10     	; 0x2ba4 <inverse+0x10>
    2bae:	94 0f       	add	r25, r20
    2bb0:	51 1d       	adc	r21, r1
    2bb2:	bb f3       	brvs	.-18     	; 0x2ba2 <inverse+0xe>
    2bb4:	91 50       	subi	r25, 0x01	; 1
    2bb6:	50 40       	sbci	r21, 0x00	; 0
    2bb8:	94 f0       	brlt	.+36     	; 0x2bde <ldexp+0x38>
    2bba:	59 f0       	breq	.+22     	; 0x2bd2 <ldexp+0x2c>
    2bbc:	88 23       	and	r24, r24
    2bbe:	32 f0       	brmi	.+12     	; 0x2bcc <ldexp+0x26>
    2bc0:	66 0f       	add	r22, r22
    2bc2:	77 1f       	adc	r23, r23
    2bc4:	88 1f       	adc	r24, r24
    2bc6:	91 50       	subi	r25, 0x01	; 1
    2bc8:	50 40       	sbci	r21, 0x00	; 0
    2bca:	c1 f7       	brne	.-16     	; 0x2bbc <ldexp+0x16>
    2bcc:	9e 3f       	cpi	r25, 0xFE	; 254
    2bce:	51 05       	cpc	r21, r1
    2bd0:	44 f7       	brge	.-48     	; 0x2ba2 <inverse+0xe>
    2bd2:	88 0f       	add	r24, r24
    2bd4:	91 1d       	adc	r25, r1
    2bd6:	96 95       	lsr	r25
    2bd8:	87 95       	ror	r24
    2bda:	97 f9       	bld	r25, 7
    2bdc:	08 95       	ret
    2bde:	5f 3f       	cpi	r21, 0xFF	; 255
    2be0:	ac f0       	brlt	.+42     	; 0x2c0c <ldexp+0x66>
    2be2:	98 3e       	cpi	r25, 0xE8	; 232
    2be4:	9c f0       	brlt	.+38     	; 0x2c0c <ldexp+0x66>
    2be6:	bb 27       	eor	r27, r27
    2be8:	86 95       	lsr	r24
    2bea:	77 95       	ror	r23
    2bec:	67 95       	ror	r22
    2bee:	b7 95       	ror	r27
    2bf0:	08 f4       	brcc	.+2      	; 0x2bf4 <ldexp+0x4e>
    2bf2:	b1 60       	ori	r27, 0x01	; 1
    2bf4:	93 95       	inc	r25
    2bf6:	c1 f7       	brne	.-16     	; 0x2be8 <ldexp+0x42>
    2bf8:	bb 0f       	add	r27, r27
    2bfa:	58 f7       	brcc	.-42     	; 0x2bd2 <ldexp+0x2c>
    2bfc:	11 f4       	brne	.+4      	; 0x2c02 <ldexp+0x5c>
    2bfe:	60 ff       	sbrs	r22, 0
    2c00:	e8 cf       	rjmp	.-48     	; 0x2bd2 <ldexp+0x2c>
    2c02:	6f 5f       	subi	r22, 0xFF	; 255
    2c04:	7f 4f       	sbci	r23, 0xFF	; 255
    2c06:	8f 4f       	sbci	r24, 0xFF	; 255
    2c08:	9f 4f       	sbci	r25, 0xFF	; 255
    2c0a:	e3 cf       	rjmp	.-58     	; 0x2bd2 <ldexp+0x2c>
    2c0c:	b8 ce       	rjmp	.-656    	; 0x297e <__fp_szero>
    2c0e:	0e f0       	brts	.+2      	; 0x2c12 <ldexp+0x6c>
    2c10:	de c0       	rjmp	.+444    	; 0x2dce <__fp_mpack>
    2c12:	70 ce       	rjmp	.-800    	; 0x28f4 <__fp_nan>
    2c14:	68 94       	set
    2c16:	68 ce       	rjmp	.-816    	; 0x28e8 <__fp_inf>

00002c18 <log>:
    2c18:	97 de       	rcall	.-722    	; 0x2948 <__fp_splitA>
    2c1a:	c8 f3       	brcs	.-14     	; 0x2c0e <ldexp+0x68>
    2c1c:	99 23       	and	r25, r25
    2c1e:	d1 f3       	breq	.-12     	; 0x2c14 <ldexp+0x6e>
    2c20:	c6 f3       	brts	.-16     	; 0x2c12 <ldexp+0x6c>
    2c22:	df 93       	push	r29
    2c24:	cf 93       	push	r28
    2c26:	1f 93       	push	r17
    2c28:	0f 93       	push	r16
    2c2a:	ff 92       	push	r15
    2c2c:	c9 2f       	mov	r28, r25
    2c2e:	dd 27       	eor	r29, r29
    2c30:	88 23       	and	r24, r24
    2c32:	2a f0       	brmi	.+10     	; 0x2c3e <log+0x26>
    2c34:	21 97       	sbiw	r28, 0x01	; 1
    2c36:	66 0f       	add	r22, r22
    2c38:	77 1f       	adc	r23, r23
    2c3a:	88 1f       	adc	r24, r24
    2c3c:	da f7       	brpl	.-10     	; 0x2c34 <log+0x1c>
    2c3e:	20 e0       	ldi	r18, 0x00	; 0
    2c40:	30 e0       	ldi	r19, 0x00	; 0
    2c42:	40 e8       	ldi	r20, 0x80	; 128
    2c44:	5f eb       	ldi	r21, 0xBF	; 191
    2c46:	9f e3       	ldi	r25, 0x3F	; 63
    2c48:	88 39       	cpi	r24, 0x98	; 152
    2c4a:	20 f0       	brcs	.+8      	; 0x2c54 <log+0x3c>
    2c4c:	80 3e       	cpi	r24, 0xE0	; 224
    2c4e:	30 f0       	brcs	.+12     	; 0x2c5c <log+0x44>
    2c50:	21 96       	adiw	r28, 0x01	; 1
    2c52:	8f 77       	andi	r24, 0x7F	; 127
    2c54:	77 dd       	rcall	.-1298   	; 0x2744 <__addsf3>
    2c56:	ec e0       	ldi	r30, 0x0C	; 12
    2c58:	f1 e0       	ldi	r31, 0x01	; 1
    2c5a:	03 c0       	rjmp	.+6      	; 0x2c62 <log+0x4a>
    2c5c:	73 dd       	rcall	.-1306   	; 0x2744 <__addsf3>
    2c5e:	e9 e3       	ldi	r30, 0x39	; 57
    2c60:	f1 e0       	ldi	r31, 0x01	; 1
    2c62:	73 df       	rcall	.-282    	; 0x2b4a <__fp_powser>
    2c64:	8b 01       	movw	r16, r22
    2c66:	be 01       	movw	r22, r28
    2c68:	ec 01       	movw	r28, r24
    2c6a:	fb 2e       	mov	r15, r27
    2c6c:	6f 57       	subi	r22, 0x7F	; 127
    2c6e:	71 09       	sbc	r23, r1
    2c70:	75 95       	asr	r23
    2c72:	77 1f       	adc	r23, r23
    2c74:	88 0b       	sbc	r24, r24
    2c76:	99 0b       	sbc	r25, r25
    2c78:	fc dd       	rcall	.-1032   	; 0x2872 <__floatsisf>
    2c7a:	28 e1       	ldi	r18, 0x18	; 24
    2c7c:	32 e7       	ldi	r19, 0x72	; 114
    2c7e:	41 e3       	ldi	r20, 0x31	; 49
    2c80:	5f e3       	ldi	r21, 0x3F	; 63
    2c82:	8f de       	rcall	.-738    	; 0x29a2 <__mulsf3x>
    2c84:	af 2d       	mov	r26, r15
    2c86:	98 01       	movw	r18, r16
    2c88:	ae 01       	movw	r20, r28
    2c8a:	ff 90       	pop	r15
    2c8c:	0f 91       	pop	r16
    2c8e:	1f 91       	pop	r17
    2c90:	cf 91       	pop	r28
    2c92:	df 91       	pop	r29
    2c94:	68 dd       	rcall	.-1328   	; 0x2766 <__addsf3x>
    2c96:	3f ce       	rjmp	.-898    	; 0x2916 <__fp_round>

00002c98 <modf>:
    2c98:	fa 01       	movw	r30, r20
    2c9a:	dc 01       	movw	r26, r24
    2c9c:	aa 0f       	add	r26, r26
    2c9e:	bb 1f       	adc	r27, r27
    2ca0:	9b 01       	movw	r18, r22
    2ca2:	ac 01       	movw	r20, r24
    2ca4:	bf 57       	subi	r27, 0x7F	; 127
    2ca6:	28 f4       	brcc	.+10     	; 0x2cb2 <modf+0x1a>
    2ca8:	22 27       	eor	r18, r18
    2caa:	33 27       	eor	r19, r19
    2cac:	44 27       	eor	r20, r20
    2cae:	50 78       	andi	r21, 0x80	; 128
    2cb0:	1f c0       	rjmp	.+62     	; 0x2cf0 <modf+0x58>
    2cb2:	b7 51       	subi	r27, 0x17	; 23
    2cb4:	88 f4       	brcc	.+34     	; 0x2cd8 <modf+0x40>
    2cb6:	ab 2f       	mov	r26, r27
    2cb8:	00 24       	eor	r0, r0
    2cba:	46 95       	lsr	r20
    2cbc:	37 95       	ror	r19
    2cbe:	27 95       	ror	r18
    2cc0:	01 1c       	adc	r0, r1
    2cc2:	a3 95       	inc	r26
    2cc4:	d2 f3       	brmi	.-12     	; 0x2cba <modf+0x22>
    2cc6:	00 20       	and	r0, r0
    2cc8:	69 f0       	breq	.+26     	; 0x2ce4 <modf+0x4c>
    2cca:	22 0f       	add	r18, r18
    2ccc:	33 1f       	adc	r19, r19
    2cce:	44 1f       	adc	r20, r20
    2cd0:	b3 95       	inc	r27
    2cd2:	da f3       	brmi	.-10     	; 0x2cca <modf+0x32>
    2cd4:	0d d0       	rcall	.+26     	; 0x2cf0 <modf+0x58>
    2cd6:	35 cd       	rjmp	.-1430   	; 0x2742 <__subsf3>
    2cd8:	61 30       	cpi	r22, 0x01	; 1
    2cda:	71 05       	cpc	r23, r1
    2cdc:	a0 e8       	ldi	r26, 0x80	; 128
    2cde:	8a 07       	cpc	r24, r26
    2ce0:	b9 46       	sbci	r27, 0x69	; 105
    2ce2:	30 f4       	brcc	.+12     	; 0x2cf0 <modf+0x58>
    2ce4:	9b 01       	movw	r18, r22
    2ce6:	ac 01       	movw	r20, r24
    2ce8:	66 27       	eor	r22, r22
    2cea:	77 27       	eor	r23, r23
    2cec:	88 27       	eor	r24, r24
    2cee:	90 78       	andi	r25, 0x80	; 128
    2cf0:	30 96       	adiw	r30, 0x00	; 0
    2cf2:	21 f0       	breq	.+8      	; 0x2cfc <modf+0x64>
    2cf4:	20 83       	st	Z, r18
    2cf6:	31 83       	std	Z+1, r19	; 0x01
    2cf8:	42 83       	std	Z+2, r20	; 0x02
    2cfa:	53 83       	std	Z+3, r21	; 0x03
    2cfc:	08 95       	ret

00002cfe <__divsf3>:
    2cfe:	0c d0       	rcall	.+24     	; 0x2d18 <__divsf3x>
    2d00:	0a ce       	rjmp	.-1004   	; 0x2916 <__fp_round>
    2d02:	02 de       	rcall	.-1020   	; 0x2908 <__fp_pscB>
    2d04:	40 f0       	brcs	.+16     	; 0x2d16 <__divsf3+0x18>
    2d06:	f9 dd       	rcall	.-1038   	; 0x28fa <__fp_pscA>
    2d08:	30 f0       	brcs	.+12     	; 0x2d16 <__divsf3+0x18>
    2d0a:	21 f4       	brne	.+8      	; 0x2d14 <__divsf3+0x16>
    2d0c:	5f 3f       	cpi	r21, 0xFF	; 255
    2d0e:	19 f0       	breq	.+6      	; 0x2d16 <__divsf3+0x18>
    2d10:	eb cd       	rjmp	.-1066   	; 0x28e8 <__fp_inf>
    2d12:	51 11       	cpse	r21, r1
    2d14:	34 ce       	rjmp	.-920    	; 0x297e <__fp_szero>
    2d16:	ee cd       	rjmp	.-1060   	; 0x28f4 <__fp_nan>

00002d18 <__divsf3x>:
    2d18:	0f de       	rcall	.-994    	; 0x2938 <__fp_split3>
    2d1a:	98 f3       	brcs	.-26     	; 0x2d02 <__divsf3+0x4>

00002d1c <__divsf3_pse>:
    2d1c:	99 23       	and	r25, r25
    2d1e:	c9 f3       	breq	.-14     	; 0x2d12 <__divsf3+0x14>
    2d20:	55 23       	and	r21, r21
    2d22:	b1 f3       	breq	.-20     	; 0x2d10 <__divsf3+0x12>
    2d24:	95 1b       	sub	r25, r21
    2d26:	55 0b       	sbc	r21, r21
    2d28:	bb 27       	eor	r27, r27
    2d2a:	aa 27       	eor	r26, r26
    2d2c:	62 17       	cp	r22, r18
    2d2e:	73 07       	cpc	r23, r19
    2d30:	84 07       	cpc	r24, r20
    2d32:	38 f0       	brcs	.+14     	; 0x2d42 <__divsf3_pse+0x26>
    2d34:	9f 5f       	subi	r25, 0xFF	; 255
    2d36:	5f 4f       	sbci	r21, 0xFF	; 255
    2d38:	22 0f       	add	r18, r18
    2d3a:	33 1f       	adc	r19, r19
    2d3c:	44 1f       	adc	r20, r20
    2d3e:	aa 1f       	adc	r26, r26
    2d40:	a9 f3       	breq	.-22     	; 0x2d2c <__divsf3_pse+0x10>
    2d42:	33 d0       	rcall	.+102    	; 0x2daa <__divsf3_pse+0x8e>
    2d44:	0e 2e       	mov	r0, r30
    2d46:	3a f0       	brmi	.+14     	; 0x2d56 <__divsf3_pse+0x3a>
    2d48:	e0 e8       	ldi	r30, 0x80	; 128
    2d4a:	30 d0       	rcall	.+96     	; 0x2dac <__divsf3_pse+0x90>
    2d4c:	91 50       	subi	r25, 0x01	; 1
    2d4e:	50 40       	sbci	r21, 0x00	; 0
    2d50:	e6 95       	lsr	r30
    2d52:	00 1c       	adc	r0, r0
    2d54:	ca f7       	brpl	.-14     	; 0x2d48 <__divsf3_pse+0x2c>
    2d56:	29 d0       	rcall	.+82     	; 0x2daa <__divsf3_pse+0x8e>
    2d58:	fe 2f       	mov	r31, r30
    2d5a:	27 d0       	rcall	.+78     	; 0x2daa <__divsf3_pse+0x8e>
    2d5c:	66 0f       	add	r22, r22
    2d5e:	77 1f       	adc	r23, r23
    2d60:	88 1f       	adc	r24, r24
    2d62:	bb 1f       	adc	r27, r27
    2d64:	26 17       	cp	r18, r22
    2d66:	37 07       	cpc	r19, r23
    2d68:	48 07       	cpc	r20, r24
    2d6a:	ab 07       	cpc	r26, r27
    2d6c:	b0 e8       	ldi	r27, 0x80	; 128
    2d6e:	09 f0       	breq	.+2      	; 0x2d72 <__divsf3_pse+0x56>
    2d70:	bb 0b       	sbc	r27, r27
    2d72:	80 2d       	mov	r24, r0
    2d74:	bf 01       	movw	r22, r30
    2d76:	ff 27       	eor	r31, r31
    2d78:	93 58       	subi	r25, 0x83	; 131
    2d7a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d7c:	2a f0       	brmi	.+10     	; 0x2d88 <__divsf3_pse+0x6c>
    2d7e:	9e 3f       	cpi	r25, 0xFE	; 254
    2d80:	51 05       	cpc	r21, r1
    2d82:	68 f0       	brcs	.+26     	; 0x2d9e <__divsf3_pse+0x82>
    2d84:	b1 cd       	rjmp	.-1182   	; 0x28e8 <__fp_inf>
    2d86:	fb cd       	rjmp	.-1034   	; 0x297e <__fp_szero>
    2d88:	5f 3f       	cpi	r21, 0xFF	; 255
    2d8a:	ec f3       	brlt	.-6      	; 0x2d86 <__divsf3_pse+0x6a>
    2d8c:	98 3e       	cpi	r25, 0xE8	; 232
    2d8e:	dc f3       	brlt	.-10     	; 0x2d86 <__divsf3_pse+0x6a>
    2d90:	86 95       	lsr	r24
    2d92:	77 95       	ror	r23
    2d94:	67 95       	ror	r22
    2d96:	b7 95       	ror	r27
    2d98:	f7 95       	ror	r31
    2d9a:	9f 5f       	subi	r25, 0xFF	; 255
    2d9c:	c9 f7       	brne	.-14     	; 0x2d90 <__divsf3_pse+0x74>
    2d9e:	88 0f       	add	r24, r24
    2da0:	91 1d       	adc	r25, r1
    2da2:	96 95       	lsr	r25
    2da4:	87 95       	ror	r24
    2da6:	97 f9       	bld	r25, 7
    2da8:	08 95       	ret
    2daa:	e1 e0       	ldi	r30, 0x01	; 1
    2dac:	66 0f       	add	r22, r22
    2dae:	77 1f       	adc	r23, r23
    2db0:	88 1f       	adc	r24, r24
    2db2:	bb 1f       	adc	r27, r27
    2db4:	62 17       	cp	r22, r18
    2db6:	73 07       	cpc	r23, r19
    2db8:	84 07       	cpc	r24, r20
    2dba:	ba 07       	cpc	r27, r26
    2dbc:	20 f0       	brcs	.+8      	; 0x2dc6 <__divsf3_pse+0xaa>
    2dbe:	62 1b       	sub	r22, r18
    2dc0:	73 0b       	sbc	r23, r19
    2dc2:	84 0b       	sbc	r24, r20
    2dc4:	ba 0b       	sbc	r27, r26
    2dc6:	ee 1f       	adc	r30, r30
    2dc8:	88 f7       	brcc	.-30     	; 0x2dac <__divsf3_pse+0x90>
    2dca:	e0 95       	com	r30
    2dcc:	08 95       	ret

00002dce <__fp_mpack>:
    2dce:	9f 3f       	cpi	r25, 0xFF	; 255
    2dd0:	31 f0       	breq	.+12     	; 0x2dde <__fp_mpack_finite+0xc>

00002dd2 <__fp_mpack_finite>:
    2dd2:	91 50       	subi	r25, 0x01	; 1
    2dd4:	20 f4       	brcc	.+8      	; 0x2dde <__fp_mpack_finite+0xc>
    2dd6:	87 95       	ror	r24
    2dd8:	77 95       	ror	r23
    2dda:	67 95       	ror	r22
    2ddc:	b7 95       	ror	r27
    2dde:	88 0f       	add	r24, r24
    2de0:	91 1d       	adc	r25, r1
    2de2:	96 95       	lsr	r25
    2de4:	87 95       	ror	r24
    2de6:	97 f9       	bld	r25, 7
    2de8:	08 95       	ret

00002dea <__divmodhi4>:
    2dea:	97 fb       	bst	r25, 7
    2dec:	07 2e       	mov	r0, r23
    2dee:	16 f4       	brtc	.+4      	; 0x2df4 <__divmodhi4+0xa>
    2df0:	00 94       	com	r0
    2df2:	06 d0       	rcall	.+12     	; 0x2e00 <__divmodhi4_neg1>
    2df4:	77 fd       	sbrc	r23, 7
    2df6:	08 d0       	rcall	.+16     	; 0x2e08 <__divmodhi4_neg2>
    2df8:	0b d0       	rcall	.+22     	; 0x2e10 <__udivmodhi4>
    2dfa:	07 fc       	sbrc	r0, 7
    2dfc:	05 d0       	rcall	.+10     	; 0x2e08 <__divmodhi4_neg2>
    2dfe:	3e f4       	brtc	.+14     	; 0x2e0e <__divmodhi4_exit>

00002e00 <__divmodhi4_neg1>:
    2e00:	90 95       	com	r25
    2e02:	81 95       	neg	r24
    2e04:	9f 4f       	sbci	r25, 0xFF	; 255
    2e06:	08 95       	ret

00002e08 <__divmodhi4_neg2>:
    2e08:	70 95       	com	r23
    2e0a:	61 95       	neg	r22
    2e0c:	7f 4f       	sbci	r23, 0xFF	; 255

00002e0e <__divmodhi4_exit>:
    2e0e:	08 95       	ret

00002e10 <__udivmodhi4>:
    2e10:	aa 1b       	sub	r26, r26
    2e12:	bb 1b       	sub	r27, r27
    2e14:	51 e1       	ldi	r21, 0x11	; 17
    2e16:	07 c0       	rjmp	.+14     	; 0x2e26 <__udivmodhi4_ep>

00002e18 <__udivmodhi4_loop>:
    2e18:	aa 1f       	adc	r26, r26
    2e1a:	bb 1f       	adc	r27, r27
    2e1c:	a6 17       	cp	r26, r22
    2e1e:	b7 07       	cpc	r27, r23
    2e20:	10 f0       	brcs	.+4      	; 0x2e26 <__udivmodhi4_ep>
    2e22:	a6 1b       	sub	r26, r22
    2e24:	b7 0b       	sbc	r27, r23

00002e26 <__udivmodhi4_ep>:
    2e26:	88 1f       	adc	r24, r24
    2e28:	99 1f       	adc	r25, r25
    2e2a:	5a 95       	dec	r21
    2e2c:	a9 f7       	brne	.-22     	; 0x2e18 <__udivmodhi4_loop>
    2e2e:	80 95       	com	r24
    2e30:	90 95       	com	r25
    2e32:	bc 01       	movw	r22, r24
    2e34:	cd 01       	movw	r24, r26
    2e36:	08 95       	ret

00002e38 <memcpy>:
    2e38:	fb 01       	movw	r30, r22
    2e3a:	dc 01       	movw	r26, r24
    2e3c:	02 c0       	rjmp	.+4      	; 0x2e42 <memcpy+0xa>
    2e3e:	01 90       	ld	r0, Z+
    2e40:	0d 92       	st	X+, r0
    2e42:	41 50       	subi	r20, 0x01	; 1
    2e44:	50 40       	sbci	r21, 0x00	; 0
    2e46:	d8 f7       	brcc	.-10     	; 0x2e3e <memcpy+0x6>
    2e48:	08 95       	ret

00002e4a <_exit>:
    2e4a:	f8 94       	cli

00002e4c <__stop_program>:
    2e4c:	ff cf       	rjmp	.-2      	; 0x2e4c <__stop_program>
