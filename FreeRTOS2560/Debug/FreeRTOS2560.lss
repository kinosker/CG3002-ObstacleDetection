
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800200  00002268  000022fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002268  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000700  00800256  00800256  00002352  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002352  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  00002382  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000052df  00000000  00000000  0000283a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001419  00000000  00000000  00007b19  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003246  00000000  00000000  00008f32  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d68  00000000  00000000  0000c178  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000151a  00000000  00000000  0000cee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000037fa  00000000  00000000  0000e3fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011bf4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	9d c2       	rjmp	.+1338   	; 0x560 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	bd c7       	rjmp	.+3962   	; 0xfd0 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	f4 c4       	rjmp	.+2536   	; 0xa4e <__vector_25>
      66:	00 00       	nop
      68:	60 c5       	rjmp	.+2752   	; 0xb2a <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	4a c3       	rjmp	.+1684   	; 0x70a <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	a6 c4       	rjmp	.+2380   	; 0x9de <__vector_36>
      92:	00 00       	nop
      94:	14 c5       	rjmp	.+2600   	; 0xabe <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 e6       	ldi	r30, 0x68	; 104
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a6 35       	cpi	r26, 0x56	; 86
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a6 e5       	ldi	r26, 0x56	; 86
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a6 35       	cpi	r26, 0x56	; 86
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	09 d1       	rcall	.+530    	; 0x332 <main>
     120:	0c 94 32 11 	jmp	0x2264	; 0x2264 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	d4 d5       	rcall	.+2984   	; 0xcd0 <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	a2 d5       	rcall	.+2884   	; 0xc72 <myUSART_transmitUSART0>
     12e:	fb cf       	rjmp	.-10     	; 0x126 <RPI_receiveTask>

00000130 <RPI_sendTask>:
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	00 d0       	rcall	.+0      	; 0x136 <RPI_sendTask+0x6>
     136:	00 d0       	rcall	.+0      	; 0x138 <RPI_sendTask+0x8>
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	4f ef       	ldi	r20, 0xFF	; 255
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	be 01       	movw	r22, r28
     144:	6a 5f       	subi	r22, 0xFA	; 250
     146:	7f 4f       	sbci	r23, 0xFF	; 255
     148:	80 91 a1 08 	lds	r24, 0x08A1
     14c:	90 91 a2 08 	lds	r25, 0x08A2
     150:	0e 94 04 0a 	call	0x1408	; 0x1408 <xQueueGenericReceive>
     154:	8e 81       	ldd	r24, Y+6	; 0x06
     156:	9f ef       	ldi	r25, 0xFF	; 255
     158:	98 0f       	add	r25, r24
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	88 23       	and	r24, r24
     15e:	e9 f0       	breq	.+58     	; 0x19a <RPI_sendTask+0x6a>
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	be 01       	movw	r22, r28
     168:	6f 5f       	subi	r22, 0xFF	; 255
     16a:	7f 4f       	sbci	r23, 0xFF	; 255
     16c:	80 91 a3 08 	lds	r24, 0x08A3
     170:	90 91 a4 08 	lds	r25, 0x08A4
     174:	0e 94 04 0a 	call	0x1408	; 0x1408 <xQueueGenericReceive>
     178:	89 81       	ldd	r24, Y+1	; 0x01
     17a:	4d d5       	rcall	.+2714   	; 0xc16 <myUSART_transmitUSART0_c>
     17c:	8d e1       	ldi	r24, 0x1D	; 29
     17e:	92 e0       	ldi	r25, 0x02	; 2
     180:	78 d5       	rcall	.+2800   	; 0xc72 <myUSART_transmitUSART0>
     182:	ce 01       	movw	r24, r28
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	75 d5       	rcall	.+2794   	; 0xc72 <myUSART_transmitUSART0>
     188:	80 e2       	ldi	r24, 0x20	; 32
     18a:	92 e0       	ldi	r25, 0x02	; 2
     18c:	72 d5       	rcall	.+2788   	; 0xc72 <myUSART_transmitUSART0>
     18e:	8e 81       	ldd	r24, Y+6	; 0x06
     190:	9f ef       	ldi	r25, 0xFF	; 255
     192:	98 0f       	add	r25, r24
     194:	9e 83       	std	Y+6, r25	; 0x06
     196:	81 11       	cpse	r24, r1
     198:	e3 cf       	rjmp	.-58     	; 0x160 <RPI_sendTask+0x30>
     19a:	8a e0       	ldi	r24, 0x0A	; 10
     19c:	3c d5       	rcall	.+2680   	; 0xc16 <myUSART_transmitUSART0_c>
     19e:	84 ef       	ldi	r24, 0xF4	; 244
     1a0:	91 e0       	ldi	r25, 0x01	; 1
     1a2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vTaskDelay>
     1a6:	ca cf       	rjmp	.-108    	; 0x13c <RPI_sendTask+0xc>

000001a8 <task1>:
     1a8:	2e 9a       	sbi	0x05, 6	; 5
     1aa:	88 ee       	ldi	r24, 0xE8	; 232
     1ac:	93 e0       	ldi	r25, 0x03	; 3
     1ae:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vTaskDelay>
     1b2:	85 b1       	in	r24, 0x05	; 5
     1b4:	15 b8       	out	0x05, r1	; 5
     1b6:	88 ee       	ldi	r24, 0xE8	; 232
     1b8:	93 e0       	ldi	r25, 0x03	; 3
     1ba:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <vTaskDelay>
     1be:	f4 cf       	rjmp	.-24     	; 0x1a8 <task1>

000001c0 <myTimerTask>:
     1c0:	3c d3       	rcall	.+1656   	; 0x83a <myTimer_Init>
     1c2:	9e d3       	rcall	.+1852   	; 0x900 <myTimer_DelayChecker>
     1c4:	fe cf       	rjmp	.-4      	; 0x1c2 <myTimerTask+0x2>

000001c6 <obstacleSend>:
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	00 d0       	rcall	.+0      	; 0x1ce <obstacleSend+0x8>
     1ce:	1f 92       	push	r1
     1d0:	1f 92       	push	r1
     1d2:	cd b7       	in	r28, 0x3d	; 61
     1d4:	de b7       	in	r29, 0x3e	; 62
     1d6:	18 2f       	mov	r17, r24
     1d8:	cb 01       	movw	r24, r22
     1da:	11 23       	and	r17, r17
     1dc:	99 f0       	breq	.+38     	; 0x204 <obstacleSend+0x3e>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6e 5f       	subi	r22, 0xFE	; 254
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 ff 10 	call	0x21fe	; 0x21fe <__itoa_ncheck>
     1ea:	19 83       	std	Y+1, r17	; 0x01
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	4f ef       	ldi	r20, 0xFF	; 255
     1f0:	5f ef       	ldi	r21, 0xFF	; 255
     1f2:	be 01       	movw	r22, r28
     1f4:	6f 5f       	subi	r22, 0xFF	; 255
     1f6:	7f 4f       	sbci	r23, 0xFF	; 255
     1f8:	80 91 a3 08 	lds	r24, 0x08A3
     1fc:	90 91 a4 08 	lds	r25, 0x08A4
     200:	0e 94 0f 09 	call	0x121e	; 0x121e <xQueueGenericSend>
     204:	0f 90       	pop	r0
     206:	0f 90       	pop	r0
     208:	0f 90       	pop	r0
     20a:	0f 90       	pop	r0
     20c:	0f 90       	pop	r0
     20e:	df 91       	pop	r29
     210:	cf 91       	pop	r28
     212:	1f 91       	pop	r17
     214:	08 95       	ret

00000216 <Sonar_Task>:
     216:	cf 93       	push	r28
     218:	df 93       	push	r29
     21a:	00 d0       	rcall	.+0      	; 0x21c <Sonar_Task+0x6>
     21c:	cd b7       	in	r28, 0x3d	; 61
     21e:	de b7       	in	r29, 0x3e	; 62
     220:	1b 82       	std	Y+3, r1	; 0x03
     222:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <xTaskGetTickCount>
     226:	9a 83       	std	Y+2, r25	; 0x02
     228:	89 83       	std	Y+1, r24	; 0x01
     22a:	0f 2e       	mov	r0, r31
     22c:	f8 e7       	ldi	r31, 0x78	; 120
     22e:	8f 2e       	mov	r8, r31
     230:	f0 2d       	mov	r31, r0
     232:	0f 2e       	mov	r0, r31
     234:	f3 e0       	ldi	r31, 0x03	; 3
     236:	9f 2e       	mov	r9, r31
     238:	f0 2d       	mov	r31, r0
     23a:	57 d2       	rcall	.+1198   	; 0x6ea <myMaxSonar_Start>
     23c:	87 e2       	ldi	r24, 0x27	; 39
     23e:	5b d2       	rcall	.+1206   	; 0x6f6 <myMaxSonar_Read>
     240:	5c 01       	movw	r10, r24
     242:	86 e2       	ldi	r24, 0x26	; 38
     244:	58 d2       	rcall	.+1200   	; 0x6f6 <myMaxSonar_Read>
     246:	6c 01       	movw	r12, r24
     248:	85 e2       	ldi	r24, 0x25	; 37
     24a:	55 d2       	rcall	.+1194   	; 0x6f6 <myMaxSonar_Read>
     24c:	0a 97       	sbiw	r24, 0x0a	; 10
     24e:	7c 01       	movw	r14, r24
     250:	2c d2       	rcall	.+1112   	; 0x6aa <myHcSonar_Read>
     252:	8c 01       	movw	r16, r24
     254:	08 3e       	cpi	r16, 0xE8	; 232
     256:	83 e0       	ldi	r24, 0x03	; 3
     258:	18 07       	cpc	r17, r24
     25a:	14 f0       	brlt	.+4      	; 0x260 <Sonar_Task+0x4a>
     25c:	08 2d       	mov	r16, r8
     25e:	19 2d       	mov	r17, r9
     260:	8b 81       	ldd	r24, Y+3	; 0x03
     262:	8c 5f       	subi	r24, 0xFC	; 252
     264:	8b 83       	std	Y+3, r24	; 0x03
     266:	20 e0       	ldi	r18, 0x00	; 0
     268:	4f ef       	ldi	r20, 0xFF	; 255
     26a:	5f ef       	ldi	r21, 0xFF	; 255
     26c:	be 01       	movw	r22, r28
     26e:	6d 5f       	subi	r22, 0xFD	; 253
     270:	7f 4f       	sbci	r23, 0xFF	; 255
     272:	80 91 a1 08 	lds	r24, 0x08A1
     276:	90 91 a2 08 	lds	r25, 0x08A2
     27a:	d1 d7       	rcall	.+4002   	; 0x121e <xQueueGenericSend>
     27c:	b5 01       	movw	r22, r10
     27e:	86 e4       	ldi	r24, 0x46	; 70
     280:	a2 df       	rcall	.-188    	; 0x1c6 <obstacleSend>
     282:	b6 01       	movw	r22, r12
     284:	8c e4       	ldi	r24, 0x4C	; 76
     286:	9f df       	rcall	.-194    	; 0x1c6 <obstacleSend>
     288:	b7 01       	movw	r22, r14
     28a:	82 e5       	ldi	r24, 0x52	; 82
     28c:	9c df       	rcall	.-200    	; 0x1c6 <obstacleSend>
     28e:	b8 01       	movw	r22, r16
     290:	82 e4       	ldi	r24, 0x42	; 66
     292:	99 df       	rcall	.-206    	; 0x1c6 <obstacleSend>
     294:	1b 82       	std	Y+3, r1	; 0x03
     296:	66 e9       	ldi	r22, 0x96	; 150
     298:	70 e0       	ldi	r23, 0x00	; 0
     29a:	ce 01       	movw	r24, r28
     29c:	01 96       	adiw	r24, 0x01	; 1
     29e:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vTaskDelayUntil>
     2a2:	cb cf       	rjmp	.-106    	; 0x23a <Sonar_Task+0x24>

000002a4 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2a4:	8c ec       	ldi	r24, 0xCC	; 204
     2a6:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2aa:	8e e3       	ldi	r24, 0x3E	; 62
     2ac:	80 93 65 00 	sts	0x0065, r24
     2b0:	08 95       	ret

000002b2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2b2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2b6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2ba:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2be:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2c2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2c6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ca:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2ce:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2d2:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2d6:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2da:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2de:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2e2:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2e6:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2ea:	10 92 73 00 	sts	0x0073, r1
     2ee:	08 95       	ret

000002f0 <init>:
}

void init()
{
     2f0:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2f2:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2f4:	f8 94       	cli
	{
		clearTimer();
     2f6:	dd df       	rcall	.-70     	; 0x2b2 <clearTimer>
		setPowerReduction();
     2f8:	d5 df       	rcall	.-86     	; 0x2a4 <setPowerReduction>
		myUSART_USART0_Init();
     2fa:	4d d4       	rcall	.+2202   	; 0xb96 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2fc:	6c d4       	rcall	.+2264   	; 0xbd6 <myUSART_USART1_Init>
		myADC_Init();
     2fe:	39 d2       	rcall	.+1138   	; 0x772 <myADC_Init>
		MaxSonar_Init();
     300:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     302:	b8 d1       	rcall	.+880    	; 0x674 <myHcSonar_Init>
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     304:	40 e0       	ldi	r20, 0x00	; 0
     306:	61 e0       	ldi	r22, 0x01	; 1
     308:	85 e0       	ldi	r24, 0x05	; 5
     30a:	5f d7       	rcall	.+3774   	; 0x11ca <xQueueGenericCreate>
     30c:	90 93 a2 08 	sts	0x08A2, r25
     310:	80 93 a1 08 	sts	0x08A1, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     314:	40 e0       	ldi	r20, 0x00	; 0
     316:	65 e0       	ldi	r22, 0x05	; 5
     318:	84 e1       	ldi	r24, 0x14	; 20
     31a:	57 d7       	rcall	.+3758   	; 0x11ca <xQueueGenericCreate>
     31c:	90 93 a4 08 	sts	0x08A4, r25
     320:	80 93 a3 08 	sts	0x08A3, r24
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction for led
     324:	84 b1       	in	r24, 0x04	; 4
     326:	80 6c       	ori	r24, 0xC0	; 192
     328:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     32a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     32c:	78 94       	sei
}
     32e:	cf 91       	pop	r28
     330:	08 95       	ret

00000332 <main>:
	
	// do nth
}

int main(void)
{
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	cd b7       	in	r28, 0x3d	; 61
     338:	de b7       	in	r29, 0x3e	; 62
     33a:	2a 97       	sbiw	r28, 0x0a	; 10
     33c:	0f b6       	in	r0, 0x3f	; 63
     33e:	f8 94       	cli
     340:	de bf       	out	0x3e, r29	; 62
     342:	0f be       	out	0x3f, r0	; 63
     344:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
		
		init();
     346:	d4 df       	rcall	.-88     	; 0x2f0 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     348:	a1 2c       	mov	r10, r1
     34a:	b1 2c       	mov	r11, r1
     34c:	c1 2c       	mov	r12, r1
     34e:	d1 2c       	mov	r13, r1
     350:	ce 01       	movw	r24, r28
     352:	01 96       	adiw	r24, 0x01	; 1
     354:	7c 01       	movw	r14, r24
     356:	01 e0       	ldi	r16, 0x01	; 1
     358:	20 e0       	ldi	r18, 0x00	; 0
     35a:	30 e0       	ldi	r19, 0x00	; 0
     35c:	49 e6       	ldi	r20, 0x69	; 105
     35e:	50 e0       	ldi	r21, 0x00	; 0
     360:	63 e2       	ldi	r22, 0x23	; 35
     362:	72 e0       	ldi	r23, 0x02	; 2
     364:	84 ed       	ldi	r24, 0xD4	; 212
     366:	90 e0       	ldi	r25, 0x00	; 0
     368:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     36c:	ce 01       	movw	r24, r28
     36e:	03 96       	adiw	r24, 0x03	; 3
     370:	7c 01       	movw	r14, r24
     372:	04 e0       	ldi	r16, 0x04	; 4
     374:	9c 01       	movw	r18, r24
     376:	49 e6       	ldi	r20, 0x69	; 105
     378:	50 e0       	ldi	r21, 0x00	; 0
     37a:	6a e2       	ldi	r22, 0x2A	; 42
     37c:	72 e0       	ldi	r23, 0x02	; 2
     37e:	80 ee       	ldi	r24, 0xE0	; 224
     380:	90 e0       	ldi	r25, 0x00	; 0
     382:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     386:	ce 01       	movw	r24, r28
     388:	09 96       	adiw	r24, 0x09	; 9
     38a:	7c 01       	movw	r14, r24
     38c:	02 e0       	ldi	r16, 0x02	; 2
     38e:	20 e0       	ldi	r18, 0x00	; 0
     390:	30 e0       	ldi	r19, 0x00	; 0
     392:	4f e4       	ldi	r20, 0x4F	; 79
     394:	51 e0       	ldi	r21, 0x01	; 1
     396:	62 e3       	ldi	r22, 0x32	; 50
     398:	72 e0       	ldi	r23, 0x02	; 2
     39a:	8b e0       	ldi	r24, 0x0B	; 11
     39c:	91 e0       	ldi	r25, 0x01	; 1
     39e:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a2:	ce 01       	movw	r24, r28
     3a4:	07 96       	adiw	r24, 0x07	; 7
     3a6:	7c 01       	movw	r14, r24
     3a8:	03 e0       	ldi	r16, 0x03	; 3
     3aa:	20 e0       	ldi	r18, 0x00	; 0
     3ac:	30 e0       	ldi	r19, 0x00	; 0
     3ae:	47 e8       	ldi	r20, 0x87	; 135
     3b0:	50 e0       	ldi	r21, 0x00	; 0
     3b2:	6b e3       	ldi	r22, 0x3B	; 59
     3b4:	72 e0       	ldi	r23, 0x02	; 2
     3b6:	83 e9       	ldi	r24, 0x93	; 147
     3b8:	90 e0       	ldi	r25, 0x00	; 0
     3ba:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3be:	ce 01       	movw	r24, r28
     3c0:	05 96       	adiw	r24, 0x05	; 5
     3c2:	7c 01       	movw	r14, r24
     3c4:	01 e0       	ldi	r16, 0x01	; 1
     3c6:	20 e0       	ldi	r18, 0x00	; 0
     3c8:	30 e0       	ldi	r19, 0x00	; 0
     3ca:	47 e8       	ldi	r20, 0x87	; 135
     3cc:	50 e0       	ldi	r21, 0x00	; 0
     3ce:	67 e4       	ldi	r22, 0x47	; 71
     3d0:	72 e0       	ldi	r23, 0x02	; 2
     3d2:	88 e9       	ldi	r24, 0x98	; 152
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	0e 94 4b 0b 	call	0x1696	; 0x1696 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3da:	0e 94 ab 0c 	call	0x1956	; 0x1956 <vTaskStartScheduler>
     3de:	b3 cf       	rjmp	.-154    	; 0x346 <main+0x14>

000003e0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3e6:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3ea:	80 91 56 02 	lds	r24, 0x0256
     3ee:	90 91 57 02 	lds	r25, 0x0257
     3f2:	89 2b       	or	r24, r25
     3f4:	31 f4       	brne	.+12     	; 0x402 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3f6:	8b e5       	ldi	r24, 0x5B	; 91
     3f8:	92 e0       	ldi	r25, 0x02	; 2
     3fa:	90 93 57 02 	sts	0x0257, r25
     3fe:	80 93 56 02 	sts	0x0256, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     402:	40 91 58 02 	lds	r20, 0x0258
     406:	50 91 59 02 	lds	r21, 0x0259
     40a:	9e 01       	movw	r18, r28
     40c:	24 0f       	add	r18, r20
     40e:	35 1f       	adc	r19, r21
     410:	2b 3d       	cpi	r18, 0xDB	; 219
     412:	85 e0       	ldi	r24, 0x05	; 5
     414:	38 07       	cpc	r19, r24
     416:	70 f4       	brcc	.+28     	; 0x434 <pvPortMalloc+0x54>
     418:	42 17       	cp	r20, r18
     41a:	53 07       	cpc	r21, r19
     41c:	70 f4       	brcc	.+28     	; 0x43a <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     41e:	c0 91 56 02 	lds	r28, 0x0256
     422:	d0 91 57 02 	lds	r29, 0x0257
     426:	c4 0f       	add	r28, r20
     428:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     42a:	30 93 59 02 	sts	0x0259, r19
     42e:	20 93 58 02 	sts	0x0258, r18
     432:	05 c0       	rjmp	.+10     	; 0x43e <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     434:	c0 e0       	ldi	r28, 0x00	; 0
     436:	d0 e0       	ldi	r29, 0x00	; 0
     438:	02 c0       	rjmp	.+4      	; 0x43e <pvPortMalloc+0x5e>
     43a:	c0 e0       	ldi	r28, 0x00	; 0
     43c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     43e:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     442:	ce 01       	movw	r24, r28
     444:	df 91       	pop	r29
     446:	cf 91       	pop	r28
     448:	08 95       	ret

0000044a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     44a:	08 95       	ret

0000044c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     44c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     44e:	03 96       	adiw	r24, 0x03	; 3
     450:	92 83       	std	Z+2, r25	; 0x02
     452:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     454:	2f ef       	ldi	r18, 0xFF	; 255
     456:	3f ef       	ldi	r19, 0xFF	; 255
     458:	34 83       	std	Z+4, r19	; 0x04
     45a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     45c:	96 83       	std	Z+6, r25	; 0x06
     45e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     460:	90 87       	std	Z+8, r25	; 0x08
     462:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     464:	10 82       	st	Z, r1
     466:	08 95       	ret

00000468 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     468:	fc 01       	movw	r30, r24
     46a:	11 86       	std	Z+9, r1	; 0x09
     46c:	10 86       	std	Z+8, r1	; 0x08
     46e:	08 95       	ret

00000470 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     470:	cf 93       	push	r28
     472:	df 93       	push	r29
     474:	9c 01       	movw	r18, r24
     476:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     478:	dc 01       	movw	r26, r24
     47a:	11 96       	adiw	r26, 0x01	; 1
     47c:	cd 91       	ld	r28, X+
     47e:	dc 91       	ld	r29, X
     480:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     482:	d3 83       	std	Z+3, r29	; 0x03
     484:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     486:	8c 81       	ldd	r24, Y+4	; 0x04
     488:	9d 81       	ldd	r25, Y+5	; 0x05
     48a:	95 83       	std	Z+5, r25	; 0x05
     48c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     48e:	8c 81       	ldd	r24, Y+4	; 0x04
     490:	9d 81       	ldd	r25, Y+5	; 0x05
     492:	dc 01       	movw	r26, r24
     494:	13 96       	adiw	r26, 0x03	; 3
     496:	7c 93       	st	X, r23
     498:	6e 93       	st	-X, r22
     49a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     49c:	7d 83       	std	Y+5, r23	; 0x05
     49e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4a0:	31 87       	std	Z+9, r19	; 0x09
     4a2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     4a4:	f9 01       	movw	r30, r18
     4a6:	80 81       	ld	r24, Z
     4a8:	8f 5f       	subi	r24, 0xFF	; 255
     4aa:	80 83       	st	Z, r24
}
     4ac:	df 91       	pop	r29
     4ae:	cf 91       	pop	r28
     4b0:	08 95       	ret

000004b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4b2:	cf 93       	push	r28
     4b4:	df 93       	push	r29
     4b6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     4b8:	48 81       	ld	r20, Y
     4ba:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     4bc:	4f 3f       	cpi	r20, 0xFF	; 255
     4be:	2f ef       	ldi	r18, 0xFF	; 255
     4c0:	52 07       	cpc	r21, r18
     4c2:	21 f4       	brne	.+8      	; 0x4cc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4c4:	fc 01       	movw	r30, r24
     4c6:	a7 81       	ldd	r26, Z+7	; 0x07
     4c8:	b0 85       	ldd	r27, Z+8	; 0x08
     4ca:	0d c0       	rjmp	.+26     	; 0x4e6 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4cc:	dc 01       	movw	r26, r24
     4ce:	13 96       	adiw	r26, 0x03	; 3
     4d0:	12 96       	adiw	r26, 0x02	; 2
     4d2:	ed 91       	ld	r30, X+
     4d4:	fc 91       	ld	r31, X
     4d6:	13 97       	sbiw	r26, 0x03	; 3
     4d8:	20 81       	ld	r18, Z
     4da:	31 81       	ldd	r19, Z+1	; 0x01
     4dc:	42 17       	cp	r20, r18
     4de:	53 07       	cpc	r21, r19
     4e0:	10 f0       	brcs	.+4      	; 0x4e6 <vListInsert+0x34>
     4e2:	df 01       	movw	r26, r30
     4e4:	f5 cf       	rjmp	.-22     	; 0x4d0 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4e6:	12 96       	adiw	r26, 0x02	; 2
     4e8:	ed 91       	ld	r30, X+
     4ea:	fc 91       	ld	r31, X
     4ec:	13 97       	sbiw	r26, 0x03	; 3
     4ee:	fb 83       	std	Y+3, r31	; 0x03
     4f0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4f2:	d5 83       	std	Z+5, r29	; 0x05
     4f4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4f6:	bd 83       	std	Y+5, r27	; 0x05
     4f8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4fa:	13 96       	adiw	r26, 0x03	; 3
     4fc:	dc 93       	st	X, r29
     4fe:	ce 93       	st	-X, r28
     500:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     502:	99 87       	std	Y+9, r25	; 0x09
     504:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     506:	fc 01       	movw	r30, r24
     508:	20 81       	ld	r18, Z
     50a:	2f 5f       	subi	r18, 0xFF	; 255
     50c:	20 83       	st	Z, r18
}
     50e:	df 91       	pop	r29
     510:	cf 91       	pop	r28
     512:	08 95       	ret

00000514 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     514:	cf 93       	push	r28
     516:	df 93       	push	r29
     518:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     51a:	a0 85       	ldd	r26, Z+8	; 0x08
     51c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     51e:	c2 81       	ldd	r28, Z+2	; 0x02
     520:	d3 81       	ldd	r29, Z+3	; 0x03
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	95 81       	ldd	r25, Z+5	; 0x05
     526:	9d 83       	std	Y+5, r25	; 0x05
     528:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     52a:	c4 81       	ldd	r28, Z+4	; 0x04
     52c:	d5 81       	ldd	r29, Z+5	; 0x05
     52e:	82 81       	ldd	r24, Z+2	; 0x02
     530:	93 81       	ldd	r25, Z+3	; 0x03
     532:	9b 83       	std	Y+3, r25	; 0x03
     534:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     536:	11 96       	adiw	r26, 0x01	; 1
     538:	cd 91       	ld	r28, X+
     53a:	dc 91       	ld	r29, X
     53c:	12 97       	sbiw	r26, 0x02	; 2
     53e:	ce 17       	cp	r28, r30
     540:	df 07       	cpc	r29, r31
     542:	31 f4       	brne	.+12     	; 0x550 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     544:	8c 81       	ldd	r24, Y+4	; 0x04
     546:	9d 81       	ldd	r25, Y+5	; 0x05
     548:	12 96       	adiw	r26, 0x02	; 2
     54a:	9c 93       	st	X, r25
     54c:	8e 93       	st	-X, r24
     54e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     550:	11 86       	std	Z+9, r1	; 0x09
     552:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     554:	8c 91       	ld	r24, X
     556:	81 50       	subi	r24, 0x01	; 1
     558:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     55a:	df 91       	pop	r29
     55c:	cf 91       	pop	r28
     55e:	08 95       	ret

00000560 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     560:	1f 92       	push	r1
     562:	0f 92       	push	r0
     564:	0f b6       	in	r0, 0x3f	; 63
     566:	0f 92       	push	r0
     568:	11 24       	eor	r1, r1
     56a:	0b b6       	in	r0, 0x3b	; 59
     56c:	0f 92       	push	r0
     56e:	2f 93       	push	r18
     570:	3f 93       	push	r19
     572:	4f 93       	push	r20
     574:	5f 93       	push	r21
     576:	6f 93       	push	r22
     578:	7f 93       	push	r23
     57a:	8f 93       	push	r24
     57c:	9f 93       	push	r25
     57e:	af 93       	push	r26
     580:	bf 93       	push	r27
     582:	ef 93       	push	r30
     584:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     586:	1b 9b       	sbis	0x03, 3	; 3
     588:	0d c0       	rjmp	.+26     	; 0x5a4 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     58a:	71 d1       	rcall	.+738    	; 0x86e <myTimer_Read>
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	90 93 aa 08 	sts	0x08AA, r25
     592:	80 93 a9 08 	sts	0x08A9, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     596:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <xTaskGetTickCountFromISR>
     59a:	90 93 a6 08 	sts	0x08A6, r25
     59e:	80 93 a5 08 	sts	0x08A5, r24
     5a2:	55 c0       	rjmp	.+170    	; 0x64e <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     5a4:	1b 99       	sbic	0x03, 3	; 3
     5a6:	53 c0       	rjmp	.+166    	; 0x64e <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     5a8:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <xTaskGetTickCountFromISR>
     5ac:	90 93 b0 08 	sts	0x08B0, r25
     5b0:	80 93 af 08 	sts	0x08AF, r24
     5b4:	20 91 a5 08 	lds	r18, 0x08A5
     5b8:	30 91 a6 08 	lds	r19, 0x08A6
     5bc:	82 17       	cp	r24, r18
     5be:	93 07       	cpc	r25, r19
     5c0:	4c f4       	brge	.+18     	; 0x5d4 <__vector_9+0x74>
			ms_tickEnd += 65535;
     5c2:	80 91 af 08 	lds	r24, 0x08AF
     5c6:	90 91 b0 08 	lds	r25, 0x08B0
     5ca:	01 97       	sbiw	r24, 0x01	; 1
     5cc:	90 93 b0 08 	sts	0x08B0, r25
     5d0:	80 93 af 08 	sts	0x08AF, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     5d4:	4c d1       	rcall	.+664    	; 0x86e <myTimer_Read>
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	90 93 b2 08 	sts	0x08B2, r25
     5dc:	80 93 b1 08 	sts	0x08B1, r24
     5e0:	20 91 a9 08 	lds	r18, 0x08A9
     5e4:	30 91 aa 08 	lds	r19, 0x08AA
     5e8:	82 17       	cp	r24, r18
     5ea:	93 07       	cpc	r25, r19
     5ec:	54 f4       	brge	.+20     	; 0x602 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     5ee:	80 91 b1 08 	lds	r24, 0x08B1
     5f2:	90 91 b2 08 	lds	r25, 0x08B2
     5f6:	86 50       	subi	r24, 0x06	; 6
     5f8:	9f 4f       	sbci	r25, 0xFF	; 255
     5fa:	90 93 b2 08 	sts	0x08B2, r25
     5fe:	80 93 b1 08 	sts	0x08B1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     602:	80 91 b1 08 	lds	r24, 0x08B1
     606:	90 91 b2 08 	lds	r25, 0x08B2
     60a:	20 91 a9 08 	lds	r18, 0x08A9
     60e:	30 91 aa 08 	lds	r19, 0x08AA
     612:	82 1b       	sub	r24, r18
     614:	93 0b       	sbc	r25, r19
     616:	90 93 ac 08 	sts	0x08AC, r25
     61a:	80 93 ab 08 	sts	0x08AB, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     61e:	80 91 af 08 	lds	r24, 0x08AF
     622:	90 91 b0 08 	lds	r25, 0x08B0
     626:	20 91 a5 08 	lds	r18, 0x08A5
     62a:	30 91 a6 08 	lds	r19, 0x08A6
     62e:	82 1b       	sub	r24, r18
     630:	93 0b       	sbc	r25, r19
     632:	90 93 a8 08 	sts	0x08A8, r25
     636:	80 93 a7 08 	sts	0x08A7, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     63a:	20 e0       	ldi	r18, 0x00	; 0
     63c:	40 e0       	ldi	r20, 0x00	; 0
     63e:	50 e0       	ldi	r21, 0x00	; 0
     640:	60 e0       	ldi	r22, 0x00	; 0
     642:	70 e0       	ldi	r23, 0x00	; 0
     644:	80 91 ad 08 	lds	r24, 0x08AD
     648:	90 91 ae 08 	lds	r25, 0x08AE
     64c:	a3 d6       	rcall	.+3398   	; 0x1394 <xQueueGenericSendFromISR>
	}	
}
     64e:	ff 91       	pop	r31
     650:	ef 91       	pop	r30
     652:	bf 91       	pop	r27
     654:	af 91       	pop	r26
     656:	9f 91       	pop	r25
     658:	8f 91       	pop	r24
     65a:	7f 91       	pop	r23
     65c:	6f 91       	pop	r22
     65e:	5f 91       	pop	r21
     660:	4f 91       	pop	r20
     662:	3f 91       	pop	r19
     664:	2f 91       	pop	r18
     666:	0f 90       	pop	r0
     668:	0b be       	out	0x3b, r0	; 59
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63
     66e:	0f 90       	pop	r0
     670:	1f 90       	pop	r1
     672:	18 95       	reti

00000674 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     674:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     676:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     678:	e8 e6       	ldi	r30, 0x68	; 104
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	80 81       	ld	r24, Z
     67e:	81 60       	ori	r24, 0x01	; 1
     680:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     682:	eb e6       	ldi	r30, 0x6B	; 107
     684:	f0 e0       	ldi	r31, 0x00	; 0
     686:	80 81       	ld	r24, Z
     688:	88 60       	ori	r24, 0x08	; 8
     68a:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     68c:	43 e0       	ldi	r20, 0x03	; 3
     68e:	60 e0       	ldi	r22, 0x00	; 0
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	9b d5       	rcall	.+2870   	; 0x11ca <xQueueGenericCreate>
     694:	90 93 ae 08 	sts	0x08AE, r25
     698:	80 93 ad 08 	sts	0x08AD, r24
     69c:	08 95       	ret

0000069e <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     69e:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     6a0:	8e e1       	ldi	r24, 0x1E	; 30
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	0a d1       	rcall	.+532    	; 0x8ba <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     6a6:	2a 98       	cbi	0x05, 2	; 5
     6a8:	08 95       	ret

000006aa <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     6aa:	f9 df       	rcall	.-14     	; 0x69e <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	4f ef       	ldi	r20, 0xFF	; 255
     6b0:	5f ef       	ldi	r21, 0xFF	; 255
     6b2:	60 e0       	ldi	r22, 0x00	; 0
     6b4:	70 e0       	ldi	r23, 0x00	; 0
     6b6:	80 91 ad 08 	lds	r24, 0x08AD
     6ba:	90 91 ae 08 	lds	r25, 0x08AE
     6be:	a4 d6       	rcall	.+3400   	; 0x1408 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     6c0:	80 91 ab 08 	lds	r24, 0x08AB
     6c4:	90 91 ac 08 	lds	r25, 0x08AC
	msLength = ms_tickLapsed * 17;
     6c8:	20 91 a7 08 	lds	r18, 0x08A7
     6cc:	30 91 a8 08 	lds	r19, 0x08A8
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     6d0:	6e e0       	ldi	r22, 0x0E	; 14
     6d2:	70 e0       	ldi	r23, 0x00	; 0
     6d4:	0e 94 cf 10 	call	0x219e	; 0x219e <__divmodhi4>
	msLength = ms_tickLapsed * 17;
     6d8:	41 e1       	ldi	r20, 0x11	; 17
     6da:	42 9f       	mul	r20, r18
     6dc:	c0 01       	movw	r24, r0
     6de:	43 9f       	mul	r20, r19
     6e0:	90 0d       	add	r25, r0
     6e2:	11 24       	eor	r1, r1
	return usLength + msLength;
	
     6e4:	86 0f       	add	r24, r22
     6e6:	97 1f       	adc	r25, r23
     6e8:	08 95       	ret

000006ea <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     6ea:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     6ec:	89 e1       	ldi	r24, 0x19	; 25
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	c0 d0       	rcall	.+384    	; 0x872 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     6f2:	a1 98       	cbi	0x14, 1	; 20
     6f4:	08 95       	ret

000006f6 <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     6f6:	9a d0       	rcall	.+308    	; 0x82c <myADC_analogRead>
     6f8:	90 e0       	ldi	r25, 0x00	; 0
     6fa:	9c 01       	movw	r18, r24
     6fc:	22 0f       	add	r18, r18
     6fe:	33 1f       	adc	r19, r19
     700:	22 0f       	add	r18, r18
     702:	33 1f       	adc	r19, r19
}
     704:	82 0f       	add	r24, r18
     706:	93 1f       	adc	r25, r19
     708:	08 95       	ret

0000070a <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     70a:	1f 92       	push	r1
     70c:	0f 92       	push	r0
     70e:	0f b6       	in	r0, 0x3f	; 63
     710:	0f 92       	push	r0
     712:	11 24       	eor	r1, r1
     714:	0b b6       	in	r0, 0x3b	; 59
     716:	0f 92       	push	r0
     718:	2f 93       	push	r18
     71a:	3f 93       	push	r19
     71c:	4f 93       	push	r20
     71e:	5f 93       	push	r21
     720:	6f 93       	push	r22
     722:	7f 93       	push	r23
     724:	8f 93       	push	r24
     726:	9f 93       	push	r25
     728:	af 93       	push	r26
     72a:	bf 93       	push	r27
     72c:	ef 93       	push	r30
     72e:	ff 93       	push	r31
	adcReading = ADCH; // read value
     730:	80 91 79 00 	lds	r24, 0x0079
     734:	80 93 b3 08 	sts	0x08B3, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     738:	20 e0       	ldi	r18, 0x00	; 0
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	60 e0       	ldi	r22, 0x00	; 0
     740:	70 e0       	ldi	r23, 0x00	; 0
     742:	80 91 b6 08 	lds	r24, 0x08B6
     746:	90 91 b7 08 	lds	r25, 0x08B7
     74a:	24 d6       	rcall	.+3144   	; 0x1394 <xQueueGenericSendFromISR>
}
     74c:	ff 91       	pop	r31
     74e:	ef 91       	pop	r30
     750:	bf 91       	pop	r27
     752:	af 91       	pop	r26
     754:	9f 91       	pop	r25
     756:	8f 91       	pop	r24
     758:	7f 91       	pop	r23
     75a:	6f 91       	pop	r22
     75c:	5f 91       	pop	r21
     75e:	4f 91       	pop	r20
     760:	3f 91       	pop	r19
     762:	2f 91       	pop	r18
     764:	0f 90       	pop	r0
     766:	0b be       	out	0x3b, r0	; 59
     768:	0f 90       	pop	r0
     76a:	0f be       	out	0x3f, r0	; 63
     76c:	0f 90       	pop	r0
     76e:	1f 90       	pop	r1
     770:	18 95       	reti

00000772 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     772:	8f e8       	ldi	r24, 0x8F	; 143
     774:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     778:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     77c:	80 e6       	ldi	r24, 0x60	; 96
     77e:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     782:	43 e0       	ldi	r20, 0x03	; 3
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	81 e0       	ldi	r24, 0x01	; 1
     788:	20 d5       	rcall	.+2624   	; 0x11ca <xQueueGenericCreate>
     78a:	90 93 b7 08 	sts	0x08B7, r25
     78e:	80 93 b6 08 	sts	0x08B6, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     792:	81 e0       	ldi	r24, 0x01	; 1
     794:	d7 d5       	rcall	.+2990   	; 0x1344 <xQueueCreateMutex>
     796:	90 93 b5 08 	sts	0x08B5, r25
     79a:	80 93 b4 08 	sts	0x08B4, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     79e:	20 e0       	ldi	r18, 0x00	; 0
     7a0:	40 e0       	ldi	r20, 0x00	; 0
     7a2:	50 e0       	ldi	r21, 0x00	; 0
     7a4:	60 e0       	ldi	r22, 0x00	; 0
     7a6:	70 e0       	ldi	r23, 0x00	; 0
     7a8:	3a c5       	rjmp	.+2676   	; 0x121e <xQueueGenericSend>
     7aa:	08 95       	ret

000007ac <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     7ac:	cf 93       	push	r28
     7ae:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	4f ef       	ldi	r20, 0xFF	; 255
     7b4:	5f ef       	ldi	r21, 0xFF	; 255
     7b6:	60 e0       	ldi	r22, 0x00	; 0
     7b8:	70 e0       	ldi	r23, 0x00	; 0
     7ba:	80 91 b4 08 	lds	r24, 0x08B4
     7be:	90 91 b5 08 	lds	r25, 0x08B5
     7c2:	22 d6       	rcall	.+3140   	; 0x1408 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     7c4:	ec e7       	ldi	r30, 0x7C	; 124
     7c6:	f0 e0       	ldi	r31, 0x00	; 0
     7c8:	80 81       	ld	r24, Z
     7ca:	9c 2f       	mov	r25, r28
     7cc:	9f 71       	andi	r25, 0x1F	; 31
     7ce:	80 76       	andi	r24, 0x60	; 96
     7d0:	89 2b       	or	r24, r25
     7d2:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     7d4:	eb e7       	ldi	r30, 0x7B	; 123
     7d6:	f0 e0       	ldi	r31, 0x00	; 0
     7d8:	20 81       	ld	r18, Z
     7da:	c0 72       	andi	r28, 0x20	; 32
     7dc:	8c 2f       	mov	r24, r28
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	95 95       	asr	r25
     7e2:	87 95       	ror	r24
     7e4:	95 95       	asr	r25
     7e6:	87 95       	ror	r24
     7e8:	92 2f       	mov	r25, r18
     7ea:	90 76       	andi	r25, 0x60	; 96
     7ec:	89 2b       	or	r24, r25
     7ee:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     7f0:	ea e7       	ldi	r30, 0x7A	; 122
     7f2:	f0 e0       	ldi	r31, 0x00	; 0
     7f4:	80 81       	ld	r24, Z
     7f6:	80 64       	ori	r24, 0x40	; 64
     7f8:	80 83       	st	Z, r24
}
     7fa:	cf 91       	pop	r28
     7fc:	08 95       	ret

000007fe <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	4f ef       	ldi	r20, 0xFF	; 255
     802:	5f ef       	ldi	r21, 0xFF	; 255
     804:	60 e0       	ldi	r22, 0x00	; 0
     806:	70 e0       	ldi	r23, 0x00	; 0
     808:	80 91 b6 08 	lds	r24, 0x08B6
     80c:	90 91 b7 08 	lds	r25, 0x08B7
     810:	fb d5       	rcall	.+3062   	; 0x1408 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     812:	20 e0       	ldi	r18, 0x00	; 0
     814:	40 e0       	ldi	r20, 0x00	; 0
     816:	50 e0       	ldi	r21, 0x00	; 0
     818:	60 e0       	ldi	r22, 0x00	; 0
     81a:	70 e0       	ldi	r23, 0x00	; 0
     81c:	80 91 b4 08 	lds	r24, 0x08B4
     820:	90 91 b5 08 	lds	r25, 0x08B5
     824:	fc d4       	rcall	.+2552   	; 0x121e <xQueueGenericSend>
	return adcReading;
     826:	80 91 b3 08 	lds	r24, 0x08B3
     82a:	08 95       	ret

0000082c <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     82c:	cf 93       	push	r28
     82e:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     830:	bd df       	rcall	.-134    	; 0x7ac <myADC_startADC>
	return myADC_readADC(channel);
     832:	8c 2f       	mov	r24, r28
     834:	e4 df       	rcall	.-56     	; 0x7fe <myADC_readADC>
}
     836:	cf 91       	pop	r28
     838:	08 95       	ret

0000083a <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     83a:	90 93 bd 08 	sts	0x08BD, r25
     83e:	80 93 bc 08 	sts	0x08BC, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     842:	fc 01       	movw	r30, r24
     844:	80 81       	ld	r24, Z
     846:	91 81       	ldd	r25, Z+1	; 0x01
     848:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     84c:	43 e0       	ldi	r20, 0x03	; 3
     84e:	60 e0       	ldi	r22, 0x00	; 0
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	bb d4       	rcall	.+2422   	; 0x11ca <xQueueGenericCreate>
     854:	90 93 b9 08 	sts	0x08B9, r25
     858:	80 93 b8 08 	sts	0x08B8, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     85c:	43 e0       	ldi	r20, 0x03	; 3
     85e:	60 e0       	ldi	r22, 0x00	; 0
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	b3 d4       	rcall	.+2406   	; 0x11ca <xQueueGenericCreate>
     864:	90 93 bb 08 	sts	0x08BB, r25
     868:	80 93 ba 08 	sts	0x08BA, r24
     86c:	08 95       	ret

0000086e <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     86e:	86 b5       	in	r24, 0x26	; 38
}
     870:	08 95       	ret

00000872 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     872:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     874:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     876:	9c 01       	movw	r18, r24
     878:	99 23       	and	r25, r25
     87a:	14 f4       	brge	.+4      	; 0x880 <myTimer_DelayMicro+0xe>
     87c:	2d 5f       	subi	r18, 0xFD	; 253
     87e:	3f 4f       	sbci	r19, 0xFF	; 255
     880:	35 95       	asr	r19
     882:	27 95       	ror	r18
     884:	35 95       	asr	r19
     886:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     888:	24 0f       	add	r18, r20
     88a:	35 1f       	adc	r19, r21
     88c:	30 93 03 02 	sts	0x0203, r19
     890:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     894:	e0 91 bc 08 	lds	r30, 0x08BC
     898:	f0 91 bd 08 	lds	r31, 0x08BD
     89c:	80 81       	ld	r24, Z
     89e:	91 81       	ldd	r25, Z+1	; 0x01
     8a0:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     8a4:	20 e0       	ldi	r18, 0x00	; 0
     8a6:	42 e0       	ldi	r20, 0x02	; 2
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	60 e0       	ldi	r22, 0x00	; 0
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	80 91 b8 08 	lds	r24, 0x08B8
     8b2:	90 91 b9 08 	lds	r25, 0x08B9
     8b6:	a8 c5       	rjmp	.+2896   	; 0x1408 <xQueueGenericReceive>
     8b8:	08 95       	ret

000008ba <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8ba:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     8bc:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     8be:	9c 01       	movw	r18, r24
     8c0:	99 23       	and	r25, r25
     8c2:	14 f4       	brge	.+4      	; 0x8c8 <myTimer_DelayMicro2+0xe>
     8c4:	2d 5f       	subi	r18, 0xFD	; 253
     8c6:	3f 4f       	sbci	r19, 0xFF	; 255
     8c8:	35 95       	asr	r19
     8ca:	27 95       	ror	r18
     8cc:	35 95       	asr	r19
     8ce:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     8d0:	24 0f       	add	r18, r20
     8d2:	35 1f       	adc	r19, r21
     8d4:	30 93 01 02 	sts	0x0201, r19
     8d8:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     8dc:	e0 91 bc 08 	lds	r30, 0x08BC
     8e0:	f0 91 bd 08 	lds	r31, 0x08BD
     8e4:	80 81       	ld	r24, Z
     8e6:	91 81       	ldd	r25, Z+1	; 0x01
     8e8:	eb d7       	rcall	.+4054   	; 0x18c0 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     8ea:	20 e0       	ldi	r18, 0x00	; 0
     8ec:	42 e0       	ldi	r20, 0x02	; 2
     8ee:	50 e0       	ldi	r21, 0x00	; 0
     8f0:	60 e0       	ldi	r22, 0x00	; 0
     8f2:	70 e0       	ldi	r23, 0x00	; 0
     8f4:	80 91 ba 08 	lds	r24, 0x08BA
     8f8:	90 91 bb 08 	lds	r25, 0x08BB
     8fc:	85 c5       	rjmp	.+2826   	; 0x1408 <xQueueGenericReceive>
     8fe:	08 95       	ret

00000900 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     904:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     906:	c1 11       	cpse	r28, r1
     908:	22 c0       	rjmp	.+68     	; 0x94e <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     90a:	80 91 02 02 	lds	r24, 0x0202
     90e:	90 91 03 02 	lds	r25, 0x0203
     912:	88 38       	cpi	r24, 0x88	; 136
     914:	93 41       	sbci	r25, 0x13	; 19
     916:	51 f0       	breq	.+20     	; 0x92c <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     918:	80 91 02 02 	lds	r24, 0x0202
     91c:	90 91 03 02 	lds	r25, 0x0203
     920:	8a 5f       	subi	r24, 0xFA	; 250
     922:	91 09       	sbc	r25, r1
     924:	90 93 03 02 	sts	0x0203, r25
     928:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     92c:	80 91 00 02 	lds	r24, 0x0200
     930:	90 91 01 02 	lds	r25, 0x0201
     934:	88 38       	cpi	r24, 0x88	; 136
     936:	93 41       	sbci	r25, 0x13	; 19
     938:	51 f0       	breq	.+20     	; 0x94e <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     93a:	80 91 00 02 	lds	r24, 0x0200
     93e:	90 91 01 02 	lds	r25, 0x0201
     942:	8a 5f       	subi	r24, 0xFA	; 250
     944:	91 09       	sbc	r25, r1
     946:	90 93 01 02 	sts	0x0201, r25
     94a:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     94e:	d0 e0       	ldi	r29, 0x00	; 0
     950:	80 91 02 02 	lds	r24, 0x0202
     954:	90 91 03 02 	lds	r25, 0x0203
     958:	8c 17       	cp	r24, r28
     95a:	9d 07       	cpc	r25, r29
     95c:	84 f4       	brge	.+32     	; 0x97e <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     95e:	88 e8       	ldi	r24, 0x88	; 136
     960:	93 e1       	ldi	r25, 0x13	; 19
     962:	90 93 03 02 	sts	0x0203, r25
     966:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     96a:	20 e0       	ldi	r18, 0x00	; 0
     96c:	40 e0       	ldi	r20, 0x00	; 0
     96e:	50 e0       	ldi	r21, 0x00	; 0
     970:	60 e0       	ldi	r22, 0x00	; 0
     972:	70 e0       	ldi	r23, 0x00	; 0
     974:	80 91 b8 08 	lds	r24, 0x08B8
     978:	90 91 b9 08 	lds	r25, 0x08B9
     97c:	50 d4       	rcall	.+2208   	; 0x121e <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     97e:	80 91 00 02 	lds	r24, 0x0200
     982:	90 91 01 02 	lds	r25, 0x0201
     986:	8c 17       	cp	r24, r28
     988:	9d 07       	cpc	r25, r29
     98a:	84 f4       	brge	.+32     	; 0x9ac <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     98c:	88 e8       	ldi	r24, 0x88	; 136
     98e:	93 e1       	ldi	r25, 0x13	; 19
     990:	90 93 01 02 	sts	0x0201, r25
     994:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     998:	20 e0       	ldi	r18, 0x00	; 0
     99a:	40 e0       	ldi	r20, 0x00	; 0
     99c:	50 e0       	ldi	r21, 0x00	; 0
     99e:	60 e0       	ldi	r22, 0x00	; 0
     9a0:	70 e0       	ldi	r23, 0x00	; 0
     9a2:	80 91 ba 08 	lds	r24, 0x08BA
     9a6:	90 91 bb 08 	lds	r25, 0x08BB
     9aa:	39 d4       	rcall	.+2162   	; 0x121e <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     9ac:	80 91 02 02 	lds	r24, 0x0202
     9b0:	90 91 03 02 	lds	r25, 0x0203
     9b4:	88 38       	cpi	r24, 0x88	; 136
     9b6:	93 41       	sbci	r25, 0x13	; 19
     9b8:	79 f4       	brne	.+30     	; 0x9d8 <myTimer_DelayChecker+0xd8>
     9ba:	80 91 00 02 	lds	r24, 0x0200
     9be:	90 91 01 02 	lds	r25, 0x0201
     9c2:	88 38       	cpi	r24, 0x88	; 136
     9c4:	93 41       	sbci	r25, 0x13	; 19
     9c6:	41 f4       	brne	.+16     	; 0x9d8 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     9c8:	e0 91 bc 08 	lds	r30, 0x08BC
     9cc:	f0 91 bd 08 	lds	r31, 0x08BD
     9d0:	80 81       	ld	r24, Z
     9d2:	91 81       	ldd	r25, Z+1	; 0x01
     9d4:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <vTaskSuspend>
	}
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	08 95       	ret

000009de <__vector_36>:
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     9de:	1f 92       	push	r1
     9e0:	0f 92       	push	r0
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	0f 92       	push	r0
     9e6:	11 24       	eor	r1, r1
     9e8:	0b b6       	in	r0, 0x3b	; 59
     9ea:	0f 92       	push	r0
     9ec:	2f 93       	push	r18
     9ee:	3f 93       	push	r19
     9f0:	4f 93       	push	r20
     9f2:	5f 93       	push	r21
     9f4:	6f 93       	push	r22
     9f6:	7f 93       	push	r23
     9f8:	8f 93       	push	r24
     9fa:	9f 93       	push	r25
     9fc:	af 93       	push	r26
     9fe:	bf 93       	push	r27
     a00:	ef 93       	push	r30
     a02:	ff 93       	push	r31
     a04:	60 91 ce 00 	lds	r22, 0x00CE
     a08:	81 e5       	ldi	r24, 0x51	; 81
     a0a:	99 e0       	ldi	r25, 0x09	; 9
     a0c:	c9 d5       	rcall	.+2962   	; 0x15a0 <ringBufferPush>
     a0e:	20 e0       	ldi	r18, 0x00	; 0
     a10:	40 e0       	ldi	r20, 0x00	; 0
     a12:	50 e0       	ldi	r21, 0x00	; 0
     a14:	60 e0       	ldi	r22, 0x00	; 0
     a16:	70 e0       	ldi	r23, 0x00	; 0
     a18:	80 91 45 09 	lds	r24, 0x0945
     a1c:	90 91 46 09 	lds	r25, 0x0946
     a20:	b9 d4       	rcall	.+2418   	; 0x1394 <xQueueGenericSendFromISR>
     a22:	81 e5       	ldi	r24, 0x51	; 81
     a24:	99 e0       	ldi	r25, 0x09	; 9
     a26:	d2 d5       	rcall	.+2980   	; 0x15cc <ringBufferFull>
     a28:	ff 91       	pop	r31
     a2a:	ef 91       	pop	r30
     a2c:	bf 91       	pop	r27
     a2e:	af 91       	pop	r26
     a30:	9f 91       	pop	r25
     a32:	8f 91       	pop	r24
     a34:	7f 91       	pop	r23
     a36:	6f 91       	pop	r22
     a38:	5f 91       	pop	r21
     a3a:	4f 91       	pop	r20
     a3c:	3f 91       	pop	r19
     a3e:	2f 91       	pop	r18
     a40:	0f 90       	pop	r0
     a42:	0b be       	out	0x3b, r0	; 59
     a44:	0f 90       	pop	r0
     a46:	0f be       	out	0x3f, r0	; 63
     a48:	0f 90       	pop	r0
     a4a:	1f 90       	pop	r1
     a4c:	18 95       	reti

00000a4e <__vector_25>:
     a4e:	1f 92       	push	r1
     a50:	0f 92       	push	r0
     a52:	0f b6       	in	r0, 0x3f	; 63
     a54:	0f 92       	push	r0
     a56:	11 24       	eor	r1, r1
     a58:	0b b6       	in	r0, 0x3b	; 59
     a5a:	0f 92       	push	r0
     a5c:	2f 93       	push	r18
     a5e:	3f 93       	push	r19
     a60:	4f 93       	push	r20
     a62:	5f 93       	push	r21
     a64:	6f 93       	push	r22
     a66:	7f 93       	push	r23
     a68:	8f 93       	push	r24
     a6a:	9f 93       	push	r25
     a6c:	af 93       	push	r26
     a6e:	bf 93       	push	r27
     a70:	ef 93       	push	r30
     a72:	ff 93       	push	r31
     a74:	60 91 c6 00 	lds	r22, 0x00C6
     a78:	8e ed       	ldi	r24, 0xDE	; 222
     a7a:	98 e0       	ldi	r25, 0x08	; 8
     a7c:	91 d5       	rcall	.+2850   	; 0x15a0 <ringBufferPush>
     a7e:	20 e0       	ldi	r18, 0x00	; 0
     a80:	40 e0       	ldi	r20, 0x00	; 0
     a82:	50 e0       	ldi	r21, 0x00	; 0
     a84:	60 e0       	ldi	r22, 0x00	; 0
     a86:	70 e0       	ldi	r23, 0x00	; 0
     a88:	80 91 45 09 	lds	r24, 0x0945
     a8c:	90 91 46 09 	lds	r25, 0x0946
     a90:	81 d4       	rcall	.+2306   	; 0x1394 <xQueueGenericSendFromISR>
     a92:	8e ed       	ldi	r24, 0xDE	; 222
     a94:	98 e0       	ldi	r25, 0x08	; 8
     a96:	9a d5       	rcall	.+2868   	; 0x15cc <ringBufferFull>
     a98:	ff 91       	pop	r31
     a9a:	ef 91       	pop	r30
     a9c:	bf 91       	pop	r27
     a9e:	af 91       	pop	r26
     aa0:	9f 91       	pop	r25
     aa2:	8f 91       	pop	r24
     aa4:	7f 91       	pop	r23
     aa6:	6f 91       	pop	r22
     aa8:	5f 91       	pop	r21
     aaa:	4f 91       	pop	r20
     aac:	3f 91       	pop	r19
     aae:	2f 91       	pop	r18
     ab0:	0f 90       	pop	r0
     ab2:	0b be       	out	0x3b, r0	; 59
     ab4:	0f 90       	pop	r0
     ab6:	0f be       	out	0x3f, r0	; 63
     ab8:	0f 90       	pop	r0
     aba:	1f 90       	pop	r1
     abc:	18 95       	reti

00000abe <__vector_37>:
     abe:	1f 92       	push	r1
     ac0:	0f 92       	push	r0
     ac2:	0f b6       	in	r0, 0x3f	; 63
     ac4:	0f 92       	push	r0
     ac6:	11 24       	eor	r1, r1
     ac8:	0b b6       	in	r0, 0x3b	; 59
     aca:	0f 92       	push	r0
     acc:	2f 93       	push	r18
     ace:	3f 93       	push	r19
     ad0:	4f 93       	push	r20
     ad2:	5f 93       	push	r21
     ad4:	6f 93       	push	r22
     ad6:	7f 93       	push	r23
     ad8:	8f 93       	push	r24
     ada:	9f 93       	push	r25
     adc:	af 93       	push	r26
     ade:	bf 93       	push	r27
     ae0:	ef 93       	push	r30
     ae2:	ff 93       	push	r31
     ae4:	87 e4       	ldi	r24, 0x47	; 71
     ae6:	99 e0       	ldi	r25, 0x09	; 9
     ae8:	78 d5       	rcall	.+2800   	; 0x15da <ringBufferNotEmpty>
     aea:	88 23       	and	r24, r24
     aec:	31 f0       	breq	.+12     	; 0xafa <__vector_37+0x3c>
     aee:	87 e4       	ldi	r24, 0x47	; 71
     af0:	99 e0       	ldi	r25, 0x09	; 9
     af2:	44 d5       	rcall	.+2696   	; 0x157c <ringBufferPop>
     af4:	80 93 ce 00 	sts	0x00CE, r24
     af8:	05 c0       	rjmp	.+10     	; 0xb04 <__vector_37+0x46>
     afa:	e9 ec       	ldi	r30, 0xC9	; 201
     afc:	f0 e0       	ldi	r31, 0x00	; 0
     afe:	80 81       	ld	r24, Z
     b00:	8f 7d       	andi	r24, 0xDF	; 223
     b02:	80 83       	st	Z, r24
     b04:	ff 91       	pop	r31
     b06:	ef 91       	pop	r30
     b08:	bf 91       	pop	r27
     b0a:	af 91       	pop	r26
     b0c:	9f 91       	pop	r25
     b0e:	8f 91       	pop	r24
     b10:	7f 91       	pop	r23
     b12:	6f 91       	pop	r22
     b14:	5f 91       	pop	r21
     b16:	4f 91       	pop	r20
     b18:	3f 91       	pop	r19
     b1a:	2f 91       	pop	r18
     b1c:	0f 90       	pop	r0
     b1e:	0b be       	out	0x3b, r0	; 59
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63
     b24:	0f 90       	pop	r0
     b26:	1f 90       	pop	r1
     b28:	18 95       	reti

00000b2a <__vector_26>:
     b2a:	1f 92       	push	r1
     b2c:	0f 92       	push	r0
     b2e:	0f b6       	in	r0, 0x3f	; 63
     b30:	0f 92       	push	r0
     b32:	11 24       	eor	r1, r1
     b34:	0b b6       	in	r0, 0x3b	; 59
     b36:	0f 92       	push	r0
     b38:	2f 93       	push	r18
     b3a:	3f 93       	push	r19
     b3c:	4f 93       	push	r20
     b3e:	5f 93       	push	r21
     b40:	6f 93       	push	r22
     b42:	7f 93       	push	r23
     b44:	8f 93       	push	r24
     b46:	9f 93       	push	r25
     b48:	af 93       	push	r26
     b4a:	bf 93       	push	r27
     b4c:	ef 93       	push	r30
     b4e:	ff 93       	push	r31
     b50:	8c e4       	ldi	r24, 0x4C	; 76
     b52:	99 e0       	ldi	r25, 0x09	; 9
     b54:	42 d5       	rcall	.+2692   	; 0x15da <ringBufferNotEmpty>
     b56:	88 23       	and	r24, r24
     b58:	31 f0       	breq	.+12     	; 0xb66 <__vector_26+0x3c>
     b5a:	8c e4       	ldi	r24, 0x4C	; 76
     b5c:	99 e0       	ldi	r25, 0x09	; 9
     b5e:	0e d5       	rcall	.+2588   	; 0x157c <ringBufferPop>
     b60:	80 93 c6 00 	sts	0x00C6, r24
     b64:	05 c0       	rjmp	.+10     	; 0xb70 <__vector_26+0x46>
     b66:	e1 ec       	ldi	r30, 0xC1	; 193
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	8f 7d       	andi	r24, 0xDF	; 223
     b6e:	80 83       	st	Z, r24
     b70:	ff 91       	pop	r31
     b72:	ef 91       	pop	r30
     b74:	bf 91       	pop	r27
     b76:	af 91       	pop	r26
     b78:	9f 91       	pop	r25
     b7a:	8f 91       	pop	r24
     b7c:	7f 91       	pop	r23
     b7e:	6f 91       	pop	r22
     b80:	5f 91       	pop	r21
     b82:	4f 91       	pop	r20
     b84:	3f 91       	pop	r19
     b86:	2f 91       	pop	r18
     b88:	0f 90       	pop	r0
     b8a:	0b be       	out	0x3b, r0	; 59
     b8c:	0f 90       	pop	r0
     b8e:	0f be       	out	0x3f, r0	; 63
     b90:	0f 90       	pop	r0
     b92:	1f 90       	pop	r1
     b94:	18 95       	reti

00000b96 <myUSART_USART0_Init>:
     b96:	10 92 c5 00 	sts	0x00C5, r1
     b9a:	87 e6       	ldi	r24, 0x67	; 103
     b9c:	80 93 c4 00 	sts	0x00C4, r24
     ba0:	88 eb       	ldi	r24, 0xB8	; 184
     ba2:	80 93 c1 00 	sts	0x00C1, r24
     ba6:	86 e0       	ldi	r24, 0x06	; 6
     ba8:	80 93 c2 00 	sts	0x00C2, r24
     bac:	40 e2       	ldi	r20, 0x20	; 32
     bae:	63 e0       	ldi	r22, 0x03	; 3
     bb0:	79 e0       	ldi	r23, 0x09	; 9
     bb2:	8e ed       	ldi	r24, 0xDE	; 222
     bb4:	98 e0       	ldi	r25, 0x08	; 8
     bb6:	db d4       	rcall	.+2486   	; 0x156e <ringBufferInit>
     bb8:	40 e2       	ldi	r20, 0x20	; 32
     bba:	63 ee       	ldi	r22, 0xE3	; 227
     bbc:	78 e0       	ldi	r23, 0x08	; 8
     bbe:	8c e4       	ldi	r24, 0x4C	; 76
     bc0:	99 e0       	ldi	r25, 0x09	; 9
     bc2:	d5 d4       	rcall	.+2474   	; 0x156e <ringBufferInit>
     bc4:	43 e0       	ldi	r20, 0x03	; 3
     bc6:	60 e0       	ldi	r22, 0x00	; 0
     bc8:	81 e0       	ldi	r24, 0x01	; 1
     bca:	ff d2       	rcall	.+1534   	; 0x11ca <xQueueGenericCreate>
     bcc:	90 93 44 09 	sts	0x0944, r25
     bd0:	80 93 43 09 	sts	0x0943, r24
     bd4:	08 95       	ret

00000bd6 <myUSART_USART1_Init>:
     bd6:	10 92 cd 00 	sts	0x00CD, r1
     bda:	87 e6       	ldi	r24, 0x67	; 103
     bdc:	80 93 cc 00 	sts	0x00CC, r24
     be0:	88 eb       	ldi	r24, 0xB8	; 184
     be2:	80 93 c9 00 	sts	0x00C9, r24
     be6:	86 e0       	ldi	r24, 0x06	; 6
     be8:	80 93 ca 00 	sts	0x00CA, r24
     bec:	40 e2       	ldi	r20, 0x20	; 32
     bee:	6e eb       	ldi	r22, 0xBE	; 190
     bf0:	78 e0       	ldi	r23, 0x08	; 8
     bf2:	81 e5       	ldi	r24, 0x51	; 81
     bf4:	99 e0       	ldi	r25, 0x09	; 9
     bf6:	bb d4       	rcall	.+2422   	; 0x156e <ringBufferInit>
     bf8:	40 e2       	ldi	r20, 0x20	; 32
     bfa:	63 e2       	ldi	r22, 0x23	; 35
     bfc:	79 e0       	ldi	r23, 0x09	; 9
     bfe:	87 e4       	ldi	r24, 0x47	; 71
     c00:	99 e0       	ldi	r25, 0x09	; 9
     c02:	b5 d4       	rcall	.+2410   	; 0x156e <ringBufferInit>
     c04:	43 e0       	ldi	r20, 0x03	; 3
     c06:	60 e0       	ldi	r22, 0x00	; 0
     c08:	81 e0       	ldi	r24, 0x01	; 1
     c0a:	df d2       	rcall	.+1470   	; 0x11ca <xQueueGenericCreate>
     c0c:	90 93 46 09 	sts	0x0946, r25
     c10:	80 93 45 09 	sts	0x0945, r24
     c14:	08 95       	ret

00000c16 <myUSART_transmitUSART0_c>:
     c16:	cf 93       	push	r28
     c18:	c8 2f       	mov	r28, r24
     c1a:	8c e4       	ldi	r24, 0x4C	; 76
     c1c:	99 e0       	ldi	r25, 0x09	; 9
     c1e:	d6 d4       	rcall	.+2476   	; 0x15cc <ringBufferFull>
     c20:	81 11       	cpse	r24, r1
     c22:	fb cf       	rjmp	.-10     	; 0xc1a <myUSART_transmitUSART0_c+0x4>
     c24:	6c 2f       	mov	r22, r28
     c26:	8c e4       	ldi	r24, 0x4C	; 76
     c28:	99 e0       	ldi	r25, 0x09	; 9
     c2a:	ba d4       	rcall	.+2420   	; 0x15a0 <ringBufferPush>
     c2c:	e1 ec       	ldi	r30, 0xC1	; 193
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	80 81       	ld	r24, Z
     c32:	80 62       	ori	r24, 0x20	; 32
     c34:	80 83       	st	Z, r24
     c36:	e0 ec       	ldi	r30, 0xC0	; 192
     c38:	f0 e0       	ldi	r31, 0x00	; 0
     c3a:	80 81       	ld	r24, Z
     c3c:	80 64       	ori	r24, 0x40	; 64
     c3e:	80 83       	st	Z, r24
     c40:	cf 91       	pop	r28
     c42:	08 95       	ret

00000c44 <myUSART_transmitUSART1_c>:
     c44:	cf 93       	push	r28
     c46:	c8 2f       	mov	r28, r24
     c48:	87 e4       	ldi	r24, 0x47	; 71
     c4a:	99 e0       	ldi	r25, 0x09	; 9
     c4c:	bf d4       	rcall	.+2430   	; 0x15cc <ringBufferFull>
     c4e:	81 11       	cpse	r24, r1
     c50:	fb cf       	rjmp	.-10     	; 0xc48 <myUSART_transmitUSART1_c+0x4>
     c52:	6c 2f       	mov	r22, r28
     c54:	87 e4       	ldi	r24, 0x47	; 71
     c56:	99 e0       	ldi	r25, 0x09	; 9
     c58:	a3 d4       	rcall	.+2374   	; 0x15a0 <ringBufferPush>
     c5a:	e9 ec       	ldi	r30, 0xC9	; 201
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	80 81       	ld	r24, Z
     c60:	80 62       	ori	r24, 0x20	; 32
     c62:	80 83       	st	Z, r24
     c64:	e8 ec       	ldi	r30, 0xC8	; 200
     c66:	f0 e0       	ldi	r31, 0x00	; 0
     c68:	80 81       	ld	r24, Z
     c6a:	80 64       	ori	r24, 0x40	; 64
     c6c:	80 83       	st	Z, r24
     c6e:	cf 91       	pop	r28
     c70:	08 95       	ret

00000c72 <myUSART_transmitUSART0>:
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	ec 01       	movw	r28, r24
     c78:	88 81       	ld	r24, Y
     c7a:	88 23       	and	r24, r24
     c7c:	29 f0       	breq	.+10     	; 0xc88 <myUSART_transmitUSART0+0x16>
     c7e:	21 96       	adiw	r28, 0x01	; 1
     c80:	ca df       	rcall	.-108    	; 0xc16 <myUSART_transmitUSART0_c>
     c82:	89 91       	ld	r24, Y+
     c84:	81 11       	cpse	r24, r1
     c86:	fc cf       	rjmp	.-8      	; 0xc80 <myUSART_transmitUSART0+0xe>
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	08 95       	ret

00000c8e <myUSART_receiveUSART1>:
     c8e:	cf 93       	push	r28
     c90:	20 e0       	ldi	r18, 0x00	; 0
     c92:	4f ef       	ldi	r20, 0xFF	; 255
     c94:	5f ef       	ldi	r21, 0xFF	; 255
     c96:	60 e0       	ldi	r22, 0x00	; 0
     c98:	70 e0       	ldi	r23, 0x00	; 0
     c9a:	80 91 43 09 	lds	r24, 0x0943
     c9e:	90 91 44 09 	lds	r25, 0x0944
     ca2:	b2 d3       	rcall	.+1892   	; 0x1408 <xQueueGenericReceive>
     ca4:	81 e5       	ldi	r24, 0x51	; 81
     ca6:	99 e0       	ldi	r25, 0x09	; 9
     ca8:	69 d4       	rcall	.+2258   	; 0x157c <ringBufferPop>
     caa:	c8 2f       	mov	r28, r24
     cac:	81 e5       	ldi	r24, 0x51	; 81
     cae:	99 e0       	ldi	r25, 0x09	; 9
     cb0:	94 d4       	rcall	.+2344   	; 0x15da <ringBufferNotEmpty>
     cb2:	88 23       	and	r24, r24
     cb4:	51 f0       	breq	.+20     	; 0xcca <myUSART_receiveUSART1+0x3c>
     cb6:	20 e0       	ldi	r18, 0x00	; 0
     cb8:	40 e0       	ldi	r20, 0x00	; 0
     cba:	50 e0       	ldi	r21, 0x00	; 0
     cbc:	60 e0       	ldi	r22, 0x00	; 0
     cbe:	70 e0       	ldi	r23, 0x00	; 0
     cc0:	80 91 43 09 	lds	r24, 0x0943
     cc4:	90 91 44 09 	lds	r25, 0x0944
     cc8:	aa d2       	rcall	.+1364   	; 0x121e <xQueueGenericSend>
     cca:	8c 2f       	mov	r24, r28
     ccc:	cf 91       	pop	r28
     cce:	08 95       	ret

00000cd0 <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     cd0:	de df       	rcall	.-68     	; 0xc8e <myUSART_receiveUSART1>
     cd2:	81 11       	cpse	r24, r1
     cd4:	0a c0       	rjmp	.+20     	; 0xcea <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     cd6:	85 e5       	ldi	r24, 0x55	; 85
     cd8:	b5 df       	rcall	.-150    	; 0xc44 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     cda:	d9 df       	rcall	.-78     	; 0xc8e <myUSART_receiveUSART1>
     cdc:	91 e0       	ldi	r25, 0x01	; 1
     cde:	81 11       	cpse	r24, r1
     ce0:	01 c0       	rjmp	.+2      	; 0xce4 <myUSART_waitForHandshake+0x14>
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	89 2f       	mov	r24, r25
     ce6:	81 95       	neg	r24
     ce8:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     cea:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     cec:	08 95       	ret

00000cee <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     cee:	31 e1       	ldi	r19, 0x11	; 17
     cf0:	fc 01       	movw	r30, r24
     cf2:	30 83       	st	Z, r19
     cf4:	31 97       	sbiw	r30, 0x01	; 1
     cf6:	22 e2       	ldi	r18, 0x22	; 34
     cf8:	20 83       	st	Z, r18
     cfa:	31 97       	sbiw	r30, 0x01	; 1
     cfc:	a3 e3       	ldi	r26, 0x33	; 51
     cfe:	a0 83       	st	Z, r26
     d00:	31 97       	sbiw	r30, 0x01	; 1
     d02:	60 83       	st	Z, r22
     d04:	31 97       	sbiw	r30, 0x01	; 1
     d06:	70 83       	st	Z, r23
     d08:	31 97       	sbiw	r30, 0x01	; 1
     d0a:	10 82       	st	Z, r1
     d0c:	31 97       	sbiw	r30, 0x01	; 1
     d0e:	10 82       	st	Z, r1
     d10:	31 97       	sbiw	r30, 0x01	; 1
     d12:	60 e8       	ldi	r22, 0x80	; 128
     d14:	60 83       	st	Z, r22
     d16:	31 97       	sbiw	r30, 0x01	; 1
     d18:	10 82       	st	Z, r1
     d1a:	31 97       	sbiw	r30, 0x01	; 1
     d1c:	10 82       	st	Z, r1
     d1e:	31 97       	sbiw	r30, 0x01	; 1
     d20:	10 82       	st	Z, r1
     d22:	31 97       	sbiw	r30, 0x01	; 1
     d24:	62 e0       	ldi	r22, 0x02	; 2
     d26:	60 83       	st	Z, r22
     d28:	31 97       	sbiw	r30, 0x01	; 1
     d2a:	63 e0       	ldi	r22, 0x03	; 3
     d2c:	60 83       	st	Z, r22
     d2e:	31 97       	sbiw	r30, 0x01	; 1
     d30:	64 e0       	ldi	r22, 0x04	; 4
     d32:	60 83       	st	Z, r22
     d34:	31 97       	sbiw	r30, 0x01	; 1
     d36:	65 e0       	ldi	r22, 0x05	; 5
     d38:	60 83       	st	Z, r22
     d3a:	31 97       	sbiw	r30, 0x01	; 1
     d3c:	66 e0       	ldi	r22, 0x06	; 6
     d3e:	60 83       	st	Z, r22
     d40:	31 97       	sbiw	r30, 0x01	; 1
     d42:	67 e0       	ldi	r22, 0x07	; 7
     d44:	60 83       	st	Z, r22
     d46:	31 97       	sbiw	r30, 0x01	; 1
     d48:	68 e0       	ldi	r22, 0x08	; 8
     d4a:	60 83       	st	Z, r22
     d4c:	31 97       	sbiw	r30, 0x01	; 1
     d4e:	69 e0       	ldi	r22, 0x09	; 9
     d50:	60 83       	st	Z, r22
     d52:	31 97       	sbiw	r30, 0x01	; 1
     d54:	60 e1       	ldi	r22, 0x10	; 16
     d56:	60 83       	st	Z, r22
     d58:	31 97       	sbiw	r30, 0x01	; 1
     d5a:	30 83       	st	Z, r19
     d5c:	31 97       	sbiw	r30, 0x01	; 1
     d5e:	32 e1       	ldi	r19, 0x12	; 18
     d60:	30 83       	st	Z, r19
     d62:	31 97       	sbiw	r30, 0x01	; 1
     d64:	33 e1       	ldi	r19, 0x13	; 19
     d66:	30 83       	st	Z, r19
     d68:	31 97       	sbiw	r30, 0x01	; 1
     d6a:	34 e1       	ldi	r19, 0x14	; 20
     d6c:	30 83       	st	Z, r19
     d6e:	31 97       	sbiw	r30, 0x01	; 1
     d70:	35 e1       	ldi	r19, 0x15	; 21
     d72:	30 83       	st	Z, r19
     d74:	31 97       	sbiw	r30, 0x01	; 1
     d76:	36 e1       	ldi	r19, 0x16	; 22
     d78:	30 83       	st	Z, r19
     d7a:	31 97       	sbiw	r30, 0x01	; 1
     d7c:	37 e1       	ldi	r19, 0x17	; 23
     d7e:	30 83       	st	Z, r19
     d80:	31 97       	sbiw	r30, 0x01	; 1
     d82:	38 e1       	ldi	r19, 0x18	; 24
     d84:	30 83       	st	Z, r19
     d86:	31 97       	sbiw	r30, 0x01	; 1
     d88:	39 e1       	ldi	r19, 0x19	; 25
     d8a:	30 83       	st	Z, r19
     d8c:	31 97       	sbiw	r30, 0x01	; 1
     d8e:	30 e2       	ldi	r19, 0x20	; 32
     d90:	30 83       	st	Z, r19
     d92:	31 97       	sbiw	r30, 0x01	; 1
     d94:	31 e2       	ldi	r19, 0x21	; 33
     d96:	30 83       	st	Z, r19
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	20 83       	st	Z, r18
     d9c:	31 97       	sbiw	r30, 0x01	; 1
     d9e:	23 e2       	ldi	r18, 0x23	; 35
     da0:	20 83       	st	Z, r18
     da2:	31 97       	sbiw	r30, 0x01	; 1
     da4:	40 83       	st	Z, r20
     da6:	31 97       	sbiw	r30, 0x01	; 1
     da8:	50 83       	st	Z, r21
     daa:	31 97       	sbiw	r30, 0x01	; 1
     dac:	26 e2       	ldi	r18, 0x26	; 38
     dae:	20 83       	st	Z, r18
     db0:	31 97       	sbiw	r30, 0x01	; 1
     db2:	27 e2       	ldi	r18, 0x27	; 39
     db4:	20 83       	st	Z, r18
     db6:	31 97       	sbiw	r30, 0x01	; 1
     db8:	28 e2       	ldi	r18, 0x28	; 40
     dba:	20 83       	st	Z, r18
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	29 e2       	ldi	r18, 0x29	; 41
     dc0:	20 83       	st	Z, r18
     dc2:	31 97       	sbiw	r30, 0x01	; 1
     dc4:	20 e3       	ldi	r18, 0x30	; 48
     dc6:	20 83       	st	Z, r18
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	21 e3       	ldi	r18, 0x31	; 49
     dcc:	20 83       	st	Z, r18
     dce:	89 97       	sbiw	r24, 0x29	; 41
     dd0:	08 95       	ret

00000dd2 <xPortStartScheduler>:
     dd2:	82 e0       	ldi	r24, 0x02	; 2
     dd4:	84 bd       	out	0x24, r24	; 36
     dd6:	16 bc       	out	0x26, r1	; 38
     dd8:	80 e3       	ldi	r24, 0x30	; 48
     dda:	87 bd       	out	0x27, r24	; 39
     ddc:	ee e6       	ldi	r30, 0x6E	; 110
     dde:	f0 e0       	ldi	r31, 0x00	; 0
     de0:	80 81       	ld	r24, Z
     de2:	82 60       	ori	r24, 0x02	; 2
     de4:	80 83       	st	Z, r24
     de6:	83 e0       	ldi	r24, 0x03	; 3
     de8:	85 bd       	out	0x25, r24	; 37
     dea:	a0 91 9f 08 	lds	r26, 0x089F
     dee:	b0 91 a0 08 	lds	r27, 0x08A0
     df2:	cd 91       	ld	r28, X+
     df4:	cd bf       	out	0x3d, r28	; 61
     df6:	dd 91       	ld	r29, X+
     df8:	de bf       	out	0x3e, r29	; 62
     dfa:	ff 91       	pop	r31
     dfc:	ef 91       	pop	r30
     dfe:	df 91       	pop	r29
     e00:	cf 91       	pop	r28
     e02:	bf 91       	pop	r27
     e04:	af 91       	pop	r26
     e06:	9f 91       	pop	r25
     e08:	8f 91       	pop	r24
     e0a:	7f 91       	pop	r23
     e0c:	6f 91       	pop	r22
     e0e:	5f 91       	pop	r21
     e10:	4f 91       	pop	r20
     e12:	3f 91       	pop	r19
     e14:	2f 91       	pop	r18
     e16:	1f 91       	pop	r17
     e18:	0f 91       	pop	r16
     e1a:	ff 90       	pop	r15
     e1c:	ef 90       	pop	r14
     e1e:	df 90       	pop	r13
     e20:	cf 90       	pop	r12
     e22:	bf 90       	pop	r11
     e24:	af 90       	pop	r10
     e26:	9f 90       	pop	r9
     e28:	8f 90       	pop	r8
     e2a:	7f 90       	pop	r7
     e2c:	6f 90       	pop	r6
     e2e:	5f 90       	pop	r5
     e30:	4f 90       	pop	r4
     e32:	3f 90       	pop	r3
     e34:	2f 90       	pop	r2
     e36:	1f 90       	pop	r1
     e38:	0f 90       	pop	r0
     e3a:	0c be       	out	0x3c, r0	; 60
     e3c:	0f 90       	pop	r0
     e3e:	0b be       	out	0x3b, r0	; 59
     e40:	0f 90       	pop	r0
     e42:	0f be       	out	0x3f, r0	; 63
     e44:	0f 90       	pop	r0
     e46:	08 95       	ret
     e48:	81 e0       	ldi	r24, 0x01	; 1
     e4a:	08 95       	ret

00000e4c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e4c:	0f 92       	push	r0
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
     e54:	0b b6       	in	r0, 0x3b	; 59
     e56:	0f 92       	push	r0
     e58:	0c b6       	in	r0, 0x3c	; 60
     e5a:	0f 92       	push	r0
     e5c:	1f 92       	push	r1
     e5e:	11 24       	eor	r1, r1
     e60:	2f 92       	push	r2
     e62:	3f 92       	push	r3
     e64:	4f 92       	push	r4
     e66:	5f 92       	push	r5
     e68:	6f 92       	push	r6
     e6a:	7f 92       	push	r7
     e6c:	8f 92       	push	r8
     e6e:	9f 92       	push	r9
     e70:	af 92       	push	r10
     e72:	bf 92       	push	r11
     e74:	cf 92       	push	r12
     e76:	df 92       	push	r13
     e78:	ef 92       	push	r14
     e7a:	ff 92       	push	r15
     e7c:	0f 93       	push	r16
     e7e:	1f 93       	push	r17
     e80:	2f 93       	push	r18
     e82:	3f 93       	push	r19
     e84:	4f 93       	push	r20
     e86:	5f 93       	push	r21
     e88:	6f 93       	push	r22
     e8a:	7f 93       	push	r23
     e8c:	8f 93       	push	r24
     e8e:	9f 93       	push	r25
     e90:	af 93       	push	r26
     e92:	bf 93       	push	r27
     e94:	cf 93       	push	r28
     e96:	df 93       	push	r29
     e98:	ef 93       	push	r30
     e9a:	ff 93       	push	r31
     e9c:	a0 91 9f 08 	lds	r26, 0x089F
     ea0:	b0 91 a0 08 	lds	r27, 0x08A0
     ea4:	0d b6       	in	r0, 0x3d	; 61
     ea6:	0d 92       	st	X+, r0
     ea8:	0e b6       	in	r0, 0x3e	; 62
     eaa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     eac:	64 d7       	rcall	.+3784   	; 0x1d76 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     eae:	a0 91 9f 08 	lds	r26, 0x089F
     eb2:	b0 91 a0 08 	lds	r27, 0x08A0
     eb6:	cd 91       	ld	r28, X+
     eb8:	cd bf       	out	0x3d, r28	; 61
     eba:	dd 91       	ld	r29, X+
     ebc:	de bf       	out	0x3e, r29	; 62
     ebe:	ff 91       	pop	r31
     ec0:	ef 91       	pop	r30
     ec2:	df 91       	pop	r29
     ec4:	cf 91       	pop	r28
     ec6:	bf 91       	pop	r27
     ec8:	af 91       	pop	r26
     eca:	9f 91       	pop	r25
     ecc:	8f 91       	pop	r24
     ece:	7f 91       	pop	r23
     ed0:	6f 91       	pop	r22
     ed2:	5f 91       	pop	r21
     ed4:	4f 91       	pop	r20
     ed6:	3f 91       	pop	r19
     ed8:	2f 91       	pop	r18
     eda:	1f 91       	pop	r17
     edc:	0f 91       	pop	r16
     ede:	ff 90       	pop	r15
     ee0:	ef 90       	pop	r14
     ee2:	df 90       	pop	r13
     ee4:	cf 90       	pop	r12
     ee6:	bf 90       	pop	r11
     ee8:	af 90       	pop	r10
     eea:	9f 90       	pop	r9
     eec:	8f 90       	pop	r8
     eee:	7f 90       	pop	r7
     ef0:	6f 90       	pop	r6
     ef2:	5f 90       	pop	r5
     ef4:	4f 90       	pop	r4
     ef6:	3f 90       	pop	r3
     ef8:	2f 90       	pop	r2
     efa:	1f 90       	pop	r1
     efc:	0f 90       	pop	r0
     efe:	0c be       	out	0x3c, r0	; 60
     f00:	0f 90       	pop	r0
     f02:	0b be       	out	0x3b, r0	; 59
     f04:	0f 90       	pop	r0
     f06:	0f be       	out	0x3f, r0	; 63
     f08:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f0a:	08 95       	ret

00000f0c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f0c:	0f 92       	push	r0
     f0e:	0f b6       	in	r0, 0x3f	; 63
     f10:	f8 94       	cli
     f12:	0f 92       	push	r0
     f14:	0b b6       	in	r0, 0x3b	; 59
     f16:	0f 92       	push	r0
     f18:	0c b6       	in	r0, 0x3c	; 60
     f1a:	0f 92       	push	r0
     f1c:	1f 92       	push	r1
     f1e:	11 24       	eor	r1, r1
     f20:	2f 92       	push	r2
     f22:	3f 92       	push	r3
     f24:	4f 92       	push	r4
     f26:	5f 92       	push	r5
     f28:	6f 92       	push	r6
     f2a:	7f 92       	push	r7
     f2c:	8f 92       	push	r8
     f2e:	9f 92       	push	r9
     f30:	af 92       	push	r10
     f32:	bf 92       	push	r11
     f34:	cf 92       	push	r12
     f36:	df 92       	push	r13
     f38:	ef 92       	push	r14
     f3a:	ff 92       	push	r15
     f3c:	0f 93       	push	r16
     f3e:	1f 93       	push	r17
     f40:	2f 93       	push	r18
     f42:	3f 93       	push	r19
     f44:	4f 93       	push	r20
     f46:	5f 93       	push	r21
     f48:	6f 93       	push	r22
     f4a:	7f 93       	push	r23
     f4c:	8f 93       	push	r24
     f4e:	9f 93       	push	r25
     f50:	af 93       	push	r26
     f52:	bf 93       	push	r27
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	ef 93       	push	r30
     f5a:	ff 93       	push	r31
     f5c:	a0 91 9f 08 	lds	r26, 0x089F
     f60:	b0 91 a0 08 	lds	r27, 0x08A0
     f64:	0d b6       	in	r0, 0x3d	; 61
     f66:	0d 92       	st	X+, r0
     f68:	0e b6       	in	r0, 0x3e	; 62
     f6a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f6c:	32 d5       	rcall	.+2660   	; 0x19d2 <xTaskIncrementTick>
     f6e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     f70:	02 d7       	rcall	.+3588   	; 0x1d76 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f72:	a0 91 9f 08 	lds	r26, 0x089F
     f76:	b0 91 a0 08 	lds	r27, 0x08A0
     f7a:	cd 91       	ld	r28, X+
     f7c:	cd bf       	out	0x3d, r28	; 61
     f7e:	dd 91       	ld	r29, X+
     f80:	de bf       	out	0x3e, r29	; 62
     f82:	ff 91       	pop	r31
     f84:	ef 91       	pop	r30
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	bf 91       	pop	r27
     f8c:	af 91       	pop	r26
     f8e:	9f 91       	pop	r25
     f90:	8f 91       	pop	r24
     f92:	7f 91       	pop	r23
     f94:	6f 91       	pop	r22
     f96:	5f 91       	pop	r21
     f98:	4f 91       	pop	r20
     f9a:	3f 91       	pop	r19
     f9c:	2f 91       	pop	r18
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	df 90       	pop	r13
     fa8:	cf 90       	pop	r12
     faa:	bf 90       	pop	r11
     fac:	af 90       	pop	r10
     fae:	9f 90       	pop	r9
     fb0:	8f 90       	pop	r8
     fb2:	7f 90       	pop	r7
     fb4:	6f 90       	pop	r6
     fb6:	5f 90       	pop	r5
     fb8:	4f 90       	pop	r4
     fba:	3f 90       	pop	r3
     fbc:	2f 90       	pop	r2
     fbe:	1f 90       	pop	r1
     fc0:	0f 90       	pop	r0
     fc2:	0c be       	out	0x3c, r0	; 60
     fc4:	0f 90       	pop	r0
     fc6:	0b be       	out	0x3b, r0	; 59
     fc8:	0f 90       	pop	r0
     fca:	0f be       	out	0x3f, r0	; 63
     fcc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     fce:	08 95       	ret

00000fd0 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     fd0:	9d df       	rcall	.-198    	; 0xf0c <vPortYieldFromTick>
		 asm volatile ("reti");
     fd2:	18 95       	reti

00000fd4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     fd4:	1f 93       	push	r17
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	ec 01       	movw	r28, r24
     fdc:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     fde:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fe0:	81 11       	cpse	r24, r1
     fe2:	0c c0       	rjmp	.+24     	; 0xffc <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fe4:	88 81       	ld	r24, Y
     fe6:	99 81       	ldd	r25, Y+1	; 0x01
     fe8:	89 2b       	or	r24, r25
     fea:	09 f0       	breq	.+2      	; 0xfee <prvCopyDataToQueue+0x1a>
     fec:	47 c0       	rjmp	.+142    	; 0x107c <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     fee:	8a 81       	ldd	r24, Y+2	; 0x02
     ff0:	9b 81       	ldd	r25, Y+3	; 0x03
     ff2:	0e 94 7e 10 	call	0x20fc	; 0x20fc <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     ff6:	1b 82       	std	Y+3, r1	; 0x03
     ff8:	1a 82       	std	Y+2, r1	; 0x02
     ffa:	47 c0       	rjmp	.+142    	; 0x108a <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     ffc:	41 11       	cpse	r20, r1
     ffe:	18 c0       	rjmp	.+48     	; 0x1030 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1000:	48 2f       	mov	r20, r24
    1002:	50 e0       	ldi	r21, 0x00	; 0
    1004:	8c 81       	ldd	r24, Y+4	; 0x04
    1006:	9d 81       	ldd	r25, Y+5	; 0x05
    1008:	0e 94 f6 10 	call	0x21ec	; 0x21ec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    100c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    100e:	8c 81       	ldd	r24, Y+4	; 0x04
    1010:	9d 81       	ldd	r25, Y+5	; 0x05
    1012:	82 0f       	add	r24, r18
    1014:	91 1d       	adc	r25, r1
    1016:	9d 83       	std	Y+5, r25	; 0x05
    1018:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    101a:	2a 81       	ldd	r18, Y+2	; 0x02
    101c:	3b 81       	ldd	r19, Y+3	; 0x03
    101e:	82 17       	cp	r24, r18
    1020:	93 07       	cpc	r25, r19
    1022:	70 f1       	brcs	.+92     	; 0x1080 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1024:	88 81       	ld	r24, Y
    1026:	99 81       	ldd	r25, Y+1	; 0x01
    1028:	9d 83       	std	Y+5, r25	; 0x05
    102a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	2d c0       	rjmp	.+90     	; 0x108a <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1030:	48 2f       	mov	r20, r24
    1032:	50 e0       	ldi	r21, 0x00	; 0
    1034:	8e 81       	ldd	r24, Y+6	; 0x06
    1036:	9f 81       	ldd	r25, Y+7	; 0x07
    1038:	0e 94 f6 10 	call	0x21ec	; 0x21ec <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    103c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	31 95       	neg	r19
    1042:	21 95       	neg	r18
    1044:	31 09       	sbc	r19, r1
    1046:	8e 81       	ldd	r24, Y+6	; 0x06
    1048:	9f 81       	ldd	r25, Y+7	; 0x07
    104a:	82 0f       	add	r24, r18
    104c:	93 1f       	adc	r25, r19
    104e:	9f 83       	std	Y+7, r25	; 0x07
    1050:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1052:	68 81       	ld	r22, Y
    1054:	79 81       	ldd	r23, Y+1	; 0x01
    1056:	86 17       	cp	r24, r22
    1058:	97 07       	cpc	r25, r23
    105a:	30 f4       	brcc	.+12     	; 0x1068 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    105c:	8a 81       	ldd	r24, Y+2	; 0x02
    105e:	9b 81       	ldd	r25, Y+3	; 0x03
    1060:	28 0f       	add	r18, r24
    1062:	39 1f       	adc	r19, r25
    1064:	3f 83       	std	Y+7, r19	; 0x07
    1066:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1068:	12 30       	cpi	r17, 0x02	; 2
    106a:	61 f4       	brne	.+24     	; 0x1084 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    106c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    106e:	88 23       	and	r24, r24
    1070:	59 f0       	breq	.+22     	; 0x1088 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1072:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1074:	81 50       	subi	r24, 0x01	; 1
    1076:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	07 c0       	rjmp	.+14     	; 0x108a <prvCopyDataToQueue+0xb6>
    107c:	80 e0       	ldi	r24, 0x00	; 0
    107e:	05 c0       	rjmp	.+10     	; 0x108a <prvCopyDataToQueue+0xb6>
    1080:	80 e0       	ldi	r24, 0x00	; 0
    1082:	03 c0       	rjmp	.+6      	; 0x108a <prvCopyDataToQueue+0xb6>
    1084:	80 e0       	ldi	r24, 0x00	; 0
    1086:	01 c0       	rjmp	.+2      	; 0x108a <prvCopyDataToQueue+0xb6>
    1088:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    108a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    108c:	9f 5f       	subi	r25, 0xFF	; 255
    108e:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	1f 91       	pop	r17
    1096:	08 95       	ret

00001098 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1098:	fc 01       	movw	r30, r24
    109a:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    109c:	44 8d       	ldd	r20, Z+28	; 0x1c
    109e:	44 23       	and	r20, r20
    10a0:	a1 f0       	breq	.+40     	; 0x10ca <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    10a2:	50 e0       	ldi	r21, 0x00	; 0
    10a4:	26 81       	ldd	r18, Z+6	; 0x06
    10a6:	37 81       	ldd	r19, Z+7	; 0x07
    10a8:	24 0f       	add	r18, r20
    10aa:	35 1f       	adc	r19, r21
    10ac:	37 83       	std	Z+7, r19	; 0x07
    10ae:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    10b0:	62 81       	ldd	r22, Z+2	; 0x02
    10b2:	73 81       	ldd	r23, Z+3	; 0x03
    10b4:	26 17       	cp	r18, r22
    10b6:	37 07       	cpc	r19, r23
    10b8:	20 f0       	brcs	.+8      	; 0x10c2 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    10ba:	20 81       	ld	r18, Z
    10bc:	31 81       	ldd	r19, Z+1	; 0x01
    10be:	37 83       	std	Z+7, r19	; 0x07
    10c0:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    10c2:	66 81       	ldd	r22, Z+6	; 0x06
    10c4:	77 81       	ldd	r23, Z+7	; 0x07
    10c6:	0c 94 f6 10 	jmp	0x21ec	; 0x21ec <memcpy>
    10ca:	08 95       	ret

000010cc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    10cc:	0f 93       	push	r16
    10ce:	1f 93       	push	r17
    10d0:	cf 93       	push	r28
    10d2:	df 93       	push	r29
    10d4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    10d6:	0f b6       	in	r0, 0x3f	; 63
    10d8:	f8 94       	cli
    10da:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    10dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10de:	18 16       	cp	r1, r24
    10e0:	a4 f4       	brge	.+40     	; 0x110a <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10e2:	89 89       	ldd	r24, Y+17	; 0x11
    10e4:	88 23       	and	r24, r24
    10e6:	89 f0       	breq	.+34     	; 0x110a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10e8:	8e 01       	movw	r16, r28
    10ea:	0f 5e       	subi	r16, 0xEF	; 239
    10ec:	1f 4f       	sbci	r17, 0xFF	; 255
    10ee:	03 c0       	rjmp	.+6      	; 0x10f6 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10f0:	89 89       	ldd	r24, Y+17	; 0x11
    10f2:	88 23       	and	r24, r24
    10f4:	51 f0       	breq	.+20     	; 0x110a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10f6:	c8 01       	movw	r24, r16
    10f8:	14 d7       	rcall	.+3624   	; 0x1f22 <xTaskRemoveFromEventList>
    10fa:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    10fc:	9d d7       	rcall	.+3898   	; 0x2038 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    10fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1100:	81 50       	subi	r24, 0x01	; 1
    1102:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1104:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1106:	18 16       	cp	r1, r24
    1108:	9c f3       	brlt	.-26     	; 0x10f0 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    110a:	8f ef       	ldi	r24, 0xFF	; 255
    110c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    110e:	0f 90       	pop	r0
    1110:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1112:	0f b6       	in	r0, 0x3f	; 63
    1114:	f8 94       	cli
    1116:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1118:	8d 8d       	ldd	r24, Y+29	; 0x1d
    111a:	18 16       	cp	r1, r24
    111c:	a4 f4       	brge	.+40     	; 0x1146 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    111e:	88 85       	ldd	r24, Y+8	; 0x08
    1120:	88 23       	and	r24, r24
    1122:	89 f0       	breq	.+34     	; 0x1146 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1124:	8e 01       	movw	r16, r28
    1126:	08 5f       	subi	r16, 0xF8	; 248
    1128:	1f 4f       	sbci	r17, 0xFF	; 255
    112a:	03 c0       	rjmp	.+6      	; 0x1132 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    112c:	88 85       	ldd	r24, Y+8	; 0x08
    112e:	88 23       	and	r24, r24
    1130:	51 f0       	breq	.+20     	; 0x1146 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1132:	c8 01       	movw	r24, r16
    1134:	f6 d6       	rcall	.+3564   	; 0x1f22 <xTaskRemoveFromEventList>
    1136:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1138:	7f d7       	rcall	.+3838   	; 0x2038 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    113a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    113c:	81 50       	subi	r24, 0x01	; 1
    113e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1140:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1142:	18 16       	cp	r1, r24
    1144:	9c f3       	brlt	.-26     	; 0x112c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1146:	8f ef       	ldi	r24, 0xFF	; 255
    1148:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    114a:	0f 90       	pop	r0
    114c:	0f be       	out	0x3f, r0	; 63
}
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	1f 91       	pop	r17
    1154:	0f 91       	pop	r16
    1156:	08 95       	ret

00001158 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    115e:	0f b6       	in	r0, 0x3f	; 63
    1160:	f8 94       	cli
    1162:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1164:	88 81       	ld	r24, Y
    1166:	99 81       	ldd	r25, Y+1	; 0x01
    1168:	2c 8d       	ldd	r18, Y+28	; 0x1c
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    116e:	72 9f       	mul	r23, r18
    1170:	a0 01       	movw	r20, r0
    1172:	73 9f       	mul	r23, r19
    1174:	50 0d       	add	r21, r0
    1176:	11 24       	eor	r1, r1
    1178:	fc 01       	movw	r30, r24
    117a:	e4 0f       	add	r30, r20
    117c:	f5 1f       	adc	r31, r21
    117e:	fb 83       	std	Y+3, r31	; 0x03
    1180:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1182:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1184:	9d 83       	std	Y+5, r25	; 0x05
    1186:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1188:	42 1b       	sub	r20, r18
    118a:	53 0b       	sbc	r21, r19
    118c:	84 0f       	add	r24, r20
    118e:	95 1f       	adc	r25, r21
    1190:	9f 83       	std	Y+7, r25	; 0x07
    1192:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1194:	8f ef       	ldi	r24, 0xFF	; 255
    1196:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1198:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    119a:	61 11       	cpse	r22, r1
    119c:	0a c0       	rjmp	.+20     	; 0x11b2 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    119e:	88 85       	ldd	r24, Y+8	; 0x08
    11a0:	88 23       	and	r24, r24
    11a2:	69 f0       	breq	.+26     	; 0x11be <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    11a4:	ce 01       	movw	r24, r28
    11a6:	08 96       	adiw	r24, 0x08	; 8
    11a8:	bc d6       	rcall	.+3448   	; 0x1f22 <xTaskRemoveFromEventList>
    11aa:	81 30       	cpi	r24, 0x01	; 1
    11ac:	41 f4       	brne	.+16     	; 0x11be <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    11ae:	4e de       	rcall	.-868    	; 0xe4c <vPortYield>
    11b0:	06 c0       	rjmp	.+12     	; 0x11be <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    11b2:	ce 01       	movw	r24, r28
    11b4:	08 96       	adiw	r24, 0x08	; 8
    11b6:	4a d9       	rcall	.-3436   	; 0x44c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    11b8:	ce 01       	movw	r24, r28
    11ba:	41 96       	adiw	r24, 0x11	; 17
    11bc:	47 d9       	rcall	.-3442   	; 0x44c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    11be:	0f 90       	pop	r0
    11c0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	08 95       	ret

000011ca <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    11ca:	0f 93       	push	r16
    11cc:	1f 93       	push	r17
    11ce:	cf 93       	push	r28
    11d0:	df 93       	push	r29
    11d2:	18 2f       	mov	r17, r24
    11d4:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    11d6:	88 23       	and	r24, r24
    11d8:	d1 f0       	breq	.+52     	; 0x120e <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    11da:	8f e1       	ldi	r24, 0x1F	; 31
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	00 d9       	rcall	.-3584   	; 0x3e0 <pvPortMalloc>
    11e0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    11e2:	00 97       	sbiw	r24, 0x00	; 0
    11e4:	b1 f0       	breq	.+44     	; 0x1212 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11e6:	10 9f       	mul	r17, r16
    11e8:	c0 01       	movw	r24, r0
    11ea:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    11ec:	01 96       	adiw	r24, 0x01	; 1
    11ee:	f8 d8       	rcall	.-3600   	; 0x3e0 <pvPortMalloc>
    11f0:	99 83       	std	Y+1, r25	; 0x01
    11f2:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    11f4:	89 2b       	or	r24, r25
    11f6:	31 f0       	breq	.+12     	; 0x1204 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    11f8:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11fa:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    11fc:	61 e0       	ldi	r22, 0x01	; 1
    11fe:	ce 01       	movw	r24, r28
    1200:	ab df       	rcall	.-170    	; 0x1158 <xQueueGenericReset>
    1202:	07 c0       	rjmp	.+14     	; 0x1212 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1204:	ce 01       	movw	r24, r28
    1206:	21 d9       	rcall	.-3518   	; 0x44a <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1208:	c0 e0       	ldi	r28, 0x00	; 0
    120a:	d0 e0       	ldi	r29, 0x00	; 0
    120c:	02 c0       	rjmp	.+4      	; 0x1212 <xQueueGenericCreate+0x48>
    120e:	c0 e0       	ldi	r28, 0x00	; 0
    1210:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1212:	ce 01       	movw	r24, r28
    1214:	df 91       	pop	r29
    1216:	cf 91       	pop	r28
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	08 95       	ret

0000121e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    121e:	9f 92       	push	r9
    1220:	af 92       	push	r10
    1222:	bf 92       	push	r11
    1224:	cf 92       	push	r12
    1226:	df 92       	push	r13
    1228:	ef 92       	push	r14
    122a:	ff 92       	push	r15
    122c:	0f 93       	push	r16
    122e:	1f 93       	push	r17
    1230:	cf 93       	push	r28
    1232:	df 93       	push	r29
    1234:	00 d0       	rcall	.+0      	; 0x1236 <xQueueGenericSend+0x18>
    1236:	1f 92       	push	r1
    1238:	1f 92       	push	r1
    123a:	cd b7       	in	r28, 0x3d	; 61
    123c:	de b7       	in	r29, 0x3e	; 62
    123e:	8c 01       	movw	r16, r24
    1240:	6b 01       	movw	r12, r22
    1242:	5d 83       	std	Y+5, r21	; 0x05
    1244:	4c 83       	std	Y+4, r20	; 0x04
    1246:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1248:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    124a:	99 24       	eor	r9, r9
    124c:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    124e:	7c 01       	movw	r14, r24
    1250:	88 e0       	ldi	r24, 0x08	; 8
    1252:	e8 0e       	add	r14, r24
    1254:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    125c:	f8 01       	movw	r30, r16
    125e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1260:	83 8d       	ldd	r24, Z+27	; 0x1b
    1262:	98 17       	cp	r25, r24
    1264:	18 f0       	brcs	.+6      	; 0x126c <xQueueGenericSend+0x4e>
    1266:	f2 e0       	ldi	r31, 0x02	; 2
    1268:	af 12       	cpse	r10, r31
    126a:	15 c0       	rjmp	.+42     	; 0x1296 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    126c:	4a 2d       	mov	r20, r10
    126e:	b6 01       	movw	r22, r12
    1270:	c8 01       	movw	r24, r16
    1272:	b0 de       	rcall	.-672    	; 0xfd4 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1274:	f8 01       	movw	r30, r16
    1276:	91 89       	ldd	r25, Z+17	; 0x11
    1278:	99 23       	and	r25, r25
    127a:	39 f0       	breq	.+14     	; 0x128a <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    127c:	c8 01       	movw	r24, r16
    127e:	41 96       	adiw	r24, 0x11	; 17
    1280:	50 d6       	rcall	.+3232   	; 0x1f22 <xTaskRemoveFromEventList>
    1282:	81 30       	cpi	r24, 0x01	; 1
    1284:	21 f4       	brne	.+8      	; 0x128e <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1286:	e2 dd       	rcall	.-1084   	; 0xe4c <vPortYield>
    1288:	02 c0       	rjmp	.+4      	; 0x128e <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    128a:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    128c:	df dd       	rcall	.-1090   	; 0xe4c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	46 c0       	rjmp	.+140    	; 0x1322 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1296:	ec 81       	ldd	r30, Y+4	; 0x04
    1298:	fd 81       	ldd	r31, Y+5	; 0x05
    129a:	ef 2b       	or	r30, r31
    129c:	21 f4       	brne	.+8      	; 0x12a6 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    129e:	0f 90       	pop	r0
    12a0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    12a2:	80 e0       	ldi	r24, 0x00	; 0
    12a4:	3e c0       	rjmp	.+124    	; 0x1322 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    12a6:	b1 10       	cpse	r11, r1
    12a8:	04 c0       	rjmp	.+8      	; 0x12b2 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    12aa:	ce 01       	movw	r24, r28
    12ac:	01 96       	adiw	r24, 0x01	; 1
    12ae:	81 d6       	rcall	.+3330   	; 0x1fb2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    12b0:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12b6:	78 d3       	rcall	.+1776   	; 0x19a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
    12be:	f8 01       	movw	r30, r16
    12c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    12c2:	8f 3f       	cpi	r24, 0xFF	; 255
    12c4:	09 f4       	brne	.+2      	; 0x12c8 <xQueueGenericSend+0xaa>
    12c6:	15 8e       	std	Z+29, r1	; 0x1d
    12c8:	f8 01       	movw	r30, r16
    12ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    12cc:	8f 3f       	cpi	r24, 0xFF	; 255
    12ce:	09 f4       	brne	.+2      	; 0x12d2 <xQueueGenericSend+0xb4>
    12d0:	16 8e       	std	Z+30, r1	; 0x1e
    12d2:	0f 90       	pop	r0
    12d4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12d6:	be 01       	movw	r22, r28
    12d8:	6c 5f       	subi	r22, 0xFC	; 252
    12da:	7f 4f       	sbci	r23, 0xFF	; 255
    12dc:	ce 01       	movw	r24, r28
    12de:	01 96       	adiw	r24, 0x01	; 1
    12e0:	73 d6       	rcall	.+3302   	; 0x1fc8 <xTaskCheckForTimeOut>
    12e2:	81 11       	cpse	r24, r1
    12e4:	1a c0       	rjmp	.+52     	; 0x131a <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12e6:	0f b6       	in	r0, 0x3f	; 63
    12e8:	f8 94       	cli
    12ea:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12ec:	f8 01       	movw	r30, r16
    12ee:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12f0:	0f 90       	pop	r0
    12f2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12f4:	f8 01       	movw	r30, r16
    12f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    12f8:	98 13       	cpse	r25, r24
    12fa:	0b c0       	rjmp	.+22     	; 0x1312 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12fc:	6c 81       	ldd	r22, Y+4	; 0x04
    12fe:	7d 81       	ldd	r23, Y+5	; 0x05
    1300:	c7 01       	movw	r24, r14
    1302:	e4 d5       	rcall	.+3016   	; 0x1ecc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1304:	c8 01       	movw	r24, r16
    1306:	e2 de       	rcall	.-572    	; 0x10cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1308:	22 d4       	rcall	.+2116   	; 0x1b4e <xTaskResumeAll>
    130a:	81 11       	cpse	r24, r1
    130c:	a4 cf       	rjmp	.-184    	; 0x1256 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    130e:	9e dd       	rcall	.-1220   	; 0xe4c <vPortYield>
    1310:	a2 cf       	rjmp	.-188    	; 0x1256 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1312:	c8 01       	movw	r24, r16
    1314:	db de       	rcall	.-586    	; 0x10cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1316:	1b d4       	rcall	.+2102   	; 0x1b4e <xTaskResumeAll>
    1318:	9e cf       	rjmp	.-196    	; 0x1256 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    131a:	c8 01       	movw	r24, r16
    131c:	d7 de       	rcall	.-594    	; 0x10cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    131e:	17 d4       	rcall	.+2094   	; 0x1b4e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1320:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1322:	0f 90       	pop	r0
    1324:	0f 90       	pop	r0
    1326:	0f 90       	pop	r0
    1328:	0f 90       	pop	r0
    132a:	0f 90       	pop	r0
    132c:	df 91       	pop	r29
    132e:	cf 91       	pop	r28
    1330:	1f 91       	pop	r17
    1332:	0f 91       	pop	r16
    1334:	ff 90       	pop	r15
    1336:	ef 90       	pop	r14
    1338:	df 90       	pop	r13
    133a:	cf 90       	pop	r12
    133c:	bf 90       	pop	r11
    133e:	af 90       	pop	r10
    1340:	9f 90       	pop	r9
    1342:	08 95       	ret

00001344 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1344:	cf 93       	push	r28
    1346:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1348:	8f e1       	ldi	r24, 0x1F	; 31
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	49 d8       	rcall	.-3950   	; 0x3e0 <pvPortMalloc>
    134e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1350:	00 97       	sbiw	r24, 0x00	; 0
    1352:	e1 f0       	breq	.+56     	; 0x138c <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1354:	1b 82       	std	Y+3, r1	; 0x03
    1356:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1358:	19 82       	std	Y+1, r1	; 0x01
    135a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    135c:	1d 82       	std	Y+5, r1	; 0x05
    135e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1360:	1f 82       	std	Y+7, r1	; 0x07
    1362:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1364:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    136a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    136c:	8f ef       	ldi	r24, 0xFF	; 255
    136e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1370:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1372:	ce 01       	movw	r24, r28
    1374:	08 96       	adiw	r24, 0x08	; 8
    1376:	6a d8       	rcall	.-3884   	; 0x44c <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1378:	ce 01       	movw	r24, r28
    137a:	41 96       	adiw	r24, 0x11	; 17
    137c:	67 d8       	rcall	.-3890   	; 0x44c <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	40 e0       	ldi	r20, 0x00	; 0
    1382:	50 e0       	ldi	r21, 0x00	; 0
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	70 e0       	ldi	r23, 0x00	; 0
    1388:	ce 01       	movw	r24, r28
    138a:	49 df       	rcall	.-366    	; 0x121e <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    138c:	ce 01       	movw	r24, r28
    138e:	df 91       	pop	r29
    1390:	cf 91       	pop	r28
    1392:	08 95       	ret

00001394 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1394:	0f 93       	push	r16
    1396:	1f 93       	push	r17
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	ec 01       	movw	r28, r24
    139e:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    13a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13a2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13a4:	98 17       	cp	r25, r24
    13a6:	10 f0       	brcs	.+4      	; 0x13ac <xQueueGenericSendFromISR+0x18>
    13a8:	22 30       	cpi	r18, 0x02	; 2
    13aa:	11 f5       	brne	.+68     	; 0x13f0 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    13ac:	42 2f       	mov	r20, r18
    13ae:	ce 01       	movw	r24, r28
    13b0:	11 de       	rcall	.-990    	; 0xfd4 <prvCopyDataToQueue>
    13b2:	88 23       	and	r24, r24
    13b4:	31 f0       	breq	.+12     	; 0x13c2 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    13b6:	01 15       	cp	r16, r1
    13b8:	11 05       	cpc	r17, r1
    13ba:	19 f0       	breq	.+6      	; 0x13c2 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	f8 01       	movw	r30, r16
    13c0:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    13c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13c4:	8f 3f       	cpi	r24, 0xFF	; 255
    13c6:	79 f4       	brne	.+30     	; 0x13e6 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13c8:	89 89       	ldd	r24, Y+17	; 0x11
    13ca:	88 23       	and	r24, r24
    13cc:	99 f0       	breq	.+38     	; 0x13f4 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13ce:	ce 01       	movw	r24, r28
    13d0:	41 96       	adiw	r24, 0x11	; 17
    13d2:	a7 d5       	rcall	.+2894   	; 0x1f22 <xTaskRemoveFromEventList>
    13d4:	88 23       	and	r24, r24
    13d6:	81 f0       	breq	.+32     	; 0x13f8 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    13d8:	01 15       	cp	r16, r1
    13da:	11 05       	cpc	r17, r1
    13dc:	79 f0       	breq	.+30     	; 0x13fc <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	f8 01       	movw	r30, r16
    13e2:	80 83       	st	Z, r24
    13e4:	0c c0       	rjmp	.+24     	; 0x13fe <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13e8:	8f 5f       	subi	r24, 0xFF	; 255
    13ea:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	07 c0       	rjmp	.+14     	; 0x13fe <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	05 c0       	rjmp	.+10     	; 0x13fe <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	03 c0       	rjmp	.+6      	; 0x13fe <xQueueGenericSendFromISR+0x6a>
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	01 c0       	rjmp	.+2      	; 0x13fe <xQueueGenericSendFromISR+0x6a>
    13fc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	1f 91       	pop	r17
    1404:	0f 91       	pop	r16
    1406:	08 95       	ret

00001408 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1408:	9f 92       	push	r9
    140a:	af 92       	push	r10
    140c:	bf 92       	push	r11
    140e:	cf 92       	push	r12
    1410:	df 92       	push	r13
    1412:	ef 92       	push	r14
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	1f 93       	push	r17
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	00 d0       	rcall	.+0      	; 0x1420 <xQueueGenericReceive+0x18>
    1420:	1f 92       	push	r1
    1422:	1f 92       	push	r1
    1424:	cd b7       	in	r28, 0x3d	; 61
    1426:	de b7       	in	r29, 0x3e	; 62
    1428:	8c 01       	movw	r16, r24
    142a:	6b 01       	movw	r12, r22
    142c:	5d 83       	std	Y+5, r21	; 0x05
    142e:	4c 83       	std	Y+4, r20	; 0x04
    1430:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1432:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1434:	99 24       	eor	r9, r9
    1436:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1438:	7c 01       	movw	r14, r24
    143a:	81 e1       	ldi	r24, 0x11	; 17
    143c:	e8 0e       	add	r14, r24
    143e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1440:	0f b6       	in	r0, 0x3f	; 63
    1442:	f8 94       	cli
    1444:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1446:	f8 01       	movw	r30, r16
    1448:	82 8d       	ldd	r24, Z+26	; 0x1a
    144a:	88 23       	and	r24, r24
    144c:	69 f1       	breq	.+90     	; 0x14a8 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    144e:	e6 80       	ldd	r14, Z+6	; 0x06
    1450:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1452:	b6 01       	movw	r22, r12
    1454:	c8 01       	movw	r24, r16
    1456:	20 de       	rcall	.-960    	; 0x1098 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1458:	b1 10       	cpse	r11, r1
    145a:	17 c0       	rjmp	.+46     	; 0x148a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    145c:	f8 01       	movw	r30, r16
    145e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1460:	81 50       	subi	r24, 0x01	; 1
    1462:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1464:	80 81       	ld	r24, Z
    1466:	91 81       	ldd	r25, Z+1	; 0x01
    1468:	89 2b       	or	r24, r25
    146a:	21 f4       	brne	.+8      	; 0x1474 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    146c:	86 d6       	rcall	.+3340   	; 0x217a <pvTaskIncrementMutexHeldCount>
    146e:	f8 01       	movw	r30, r16
    1470:	93 83       	std	Z+3, r25	; 0x03
    1472:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1474:	f8 01       	movw	r30, r16
    1476:	80 85       	ldd	r24, Z+8	; 0x08
    1478:	88 23       	and	r24, r24
    147a:	91 f0       	breq	.+36     	; 0x14a0 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    147c:	c8 01       	movw	r24, r16
    147e:	08 96       	adiw	r24, 0x08	; 8
    1480:	50 d5       	rcall	.+2720   	; 0x1f22 <xTaskRemoveFromEventList>
    1482:	81 30       	cpi	r24, 0x01	; 1
    1484:	69 f4       	brne	.+26     	; 0x14a0 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1486:	e2 dc       	rcall	.-1596   	; 0xe4c <vPortYield>
    1488:	0b c0       	rjmp	.+22     	; 0x14a0 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    148a:	f8 01       	movw	r30, r16
    148c:	f7 82       	std	Z+7, r15	; 0x07
    148e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1490:	81 89       	ldd	r24, Z+17	; 0x11
    1492:	88 23       	and	r24, r24
    1494:	29 f0       	breq	.+10     	; 0x14a0 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1496:	c8 01       	movw	r24, r16
    1498:	41 96       	adiw	r24, 0x11	; 17
    149a:	43 d5       	rcall	.+2694   	; 0x1f22 <xTaskRemoveFromEventList>
    149c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    149e:	d6 dc       	rcall	.-1620   	; 0xe4c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    14a0:	0f 90       	pop	r0
    14a2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	52 c0       	rjmp	.+164    	; 0x154c <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    14a8:	4c 81       	ldd	r20, Y+4	; 0x04
    14aa:	5d 81       	ldd	r21, Y+5	; 0x05
    14ac:	45 2b       	or	r20, r21
    14ae:	21 f4       	brne	.+8      	; 0x14b8 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	4a c0       	rjmp	.+148    	; 0x154c <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    14b8:	a1 10       	cpse	r10, r1
    14ba:	04 c0       	rjmp	.+8      	; 0x14c4 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14bc:	ce 01       	movw	r24, r28
    14be:	01 96       	adiw	r24, 0x01	; 1
    14c0:	78 d5       	rcall	.+2800   	; 0x1fb2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14c2:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    14c4:	0f 90       	pop	r0
    14c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14c8:	6f d2       	rcall	.+1246   	; 0x19a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	0f 92       	push	r0
    14d0:	f8 01       	movw	r30, r16
    14d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    14d4:	8f 3f       	cpi	r24, 0xFF	; 255
    14d6:	09 f4       	brne	.+2      	; 0x14da <xQueueGenericReceive+0xd2>
    14d8:	15 8e       	std	Z+29, r1	; 0x1d
    14da:	f8 01       	movw	r30, r16
    14dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    14de:	8f 3f       	cpi	r24, 0xFF	; 255
    14e0:	09 f4       	brne	.+2      	; 0x14e4 <xQueueGenericReceive+0xdc>
    14e2:	16 8e       	std	Z+30, r1	; 0x1e
    14e4:	0f 90       	pop	r0
    14e6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14e8:	be 01       	movw	r22, r28
    14ea:	6c 5f       	subi	r22, 0xFC	; 252
    14ec:	7f 4f       	sbci	r23, 0xFF	; 255
    14ee:	ce 01       	movw	r24, r28
    14f0:	01 96       	adiw	r24, 0x01	; 1
    14f2:	6a d5       	rcall	.+2772   	; 0x1fc8 <xTaskCheckForTimeOut>
    14f4:	81 11       	cpse	r24, r1
    14f6:	26 c0       	rjmp	.+76     	; 0x1544 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14fe:	f8 01       	movw	r30, r16
    1500:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1506:	81 11       	cpse	r24, r1
    1508:	19 c0       	rjmp	.+50     	; 0x153c <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    150a:	f8 01       	movw	r30, r16
    150c:	80 81       	ld	r24, Z
    150e:	91 81       	ldd	r25, Z+1	; 0x01
    1510:	89 2b       	or	r24, r25
    1512:	49 f4       	brne	.+18     	; 0x1526 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    151a:	f8 01       	movw	r30, r16
    151c:	82 81       	ldd	r24, Z+2	; 0x02
    151e:	93 81       	ldd	r25, Z+3	; 0x03
    1520:	8f d5       	rcall	.+2846   	; 0x2040 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1522:	0f 90       	pop	r0
    1524:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1526:	6c 81       	ldd	r22, Y+4	; 0x04
    1528:	7d 81       	ldd	r23, Y+5	; 0x05
    152a:	c7 01       	movw	r24, r14
    152c:	cf d4       	rcall	.+2462   	; 0x1ecc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    152e:	c8 01       	movw	r24, r16
    1530:	cd dd       	rcall	.-1126   	; 0x10cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1532:	0d d3       	rcall	.+1562   	; 0x1b4e <xTaskResumeAll>
    1534:	81 11       	cpse	r24, r1
    1536:	84 cf       	rjmp	.-248    	; 0x1440 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1538:	89 dc       	rcall	.-1774   	; 0xe4c <vPortYield>
    153a:	82 cf       	rjmp	.-252    	; 0x1440 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    153c:	c8 01       	movw	r24, r16
    153e:	c6 dd       	rcall	.-1140   	; 0x10cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1540:	06 d3       	rcall	.+1548   	; 0x1b4e <xTaskResumeAll>
    1542:	7e cf       	rjmp	.-260    	; 0x1440 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1544:	c8 01       	movw	r24, r16
    1546:	c2 dd       	rcall	.-1148   	; 0x10cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1548:	02 d3       	rcall	.+1540   	; 0x1b4e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    154a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	0f 90       	pop	r0
    1552:	0f 90       	pop	r0
    1554:	0f 90       	pop	r0
    1556:	df 91       	pop	r29
    1558:	cf 91       	pop	r28
    155a:	1f 91       	pop	r17
    155c:	0f 91       	pop	r16
    155e:	ff 90       	pop	r15
    1560:	ef 90       	pop	r14
    1562:	df 90       	pop	r13
    1564:	cf 90       	pop	r12
    1566:	bf 90       	pop	r11
    1568:	af 90       	pop	r10
    156a:	9f 90       	pop	r9
    156c:	08 95       	ret

0000156e <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    156e:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1570:	71 83       	std	Z+1, r23	; 0x01
    1572:	60 83       	st	Z, r22
	ring->rSize = size;
    1574:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1576:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1578:	13 82       	std	Z+3, r1	; 0x03
    157a:	08 95       	ret

0000157c <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    157c:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    157e:	94 81       	ldd	r25, Z+4	; 0x04
    1580:	a0 81       	ld	r26, Z
    1582:	b1 81       	ldd	r27, Z+1	; 0x01
    1584:	a9 0f       	add	r26, r25
    1586:	b1 1d       	adc	r27, r1
    1588:	8c 91       	ld	r24, X
            ring->rIndex ++;
    158a:	9f 5f       	subi	r25, 0xFF	; 255
    158c:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    158e:	22 81       	ldd	r18, Z+2	; 0x02
    1590:	92 17       	cp	r25, r18
    1592:	10 f0       	brcs	.+4      	; 0x1598 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1594:	92 1b       	sub	r25, r18
    1596:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1598:	93 81       	ldd	r25, Z+3	; 0x03
    159a:	91 50       	subi	r25, 0x01	; 1
    159c:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    159e:	08 95       	ret

000015a0 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    15a0:	fc 01       	movw	r30, r24
    15a2:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    15a4:	83 81       	ldd	r24, Z+3	; 0x03
    15a6:	22 81       	ldd	r18, Z+2	; 0x02
    15a8:	82 17       	cp	r24, r18
    15aa:	78 f4       	brcc	.+30     	; 0x15ca <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    15ac:	34 81       	ldd	r19, Z+4	; 0x04
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	83 0f       	add	r24, r19
    15b2:	91 1d       	adc	r25, r1
    15b4:	62 2f       	mov	r22, r18
    15b6:	70 e0       	ldi	r23, 0x00	; 0
    15b8:	f2 d5       	rcall	.+3044   	; 0x219e <__divmodhi4>
    15ba:	a0 81       	ld	r26, Z
    15bc:	b1 81       	ldd	r27, Z+1	; 0x01
    15be:	a8 0f       	add	r26, r24
    15c0:	b9 1f       	adc	r27, r25
    15c2:	4c 93       	st	X, r20
            ring->rLength++;
    15c4:	83 81       	ldd	r24, Z+3	; 0x03
    15c6:	8f 5f       	subi	r24, 0xFF	; 255
    15c8:	83 83       	std	Z+3, r24	; 0x03
    15ca:	08 95       	ret

000015cc <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    15cc:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	22 81       	ldd	r18, Z+2	; 0x02
    15d2:	93 81       	ldd	r25, Z+3	; 0x03
    15d4:	29 13       	cpse	r18, r25
    15d6:	80 e0       	ldi	r24, 0x00	; 0
}
    15d8:	08 95       	ret

000015da <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    15da:	21 e0       	ldi	r18, 0x01	; 1
    15dc:	fc 01       	movw	r30, r24
    15de:	83 81       	ldd	r24, Z+3	; 0x03
    15e0:	81 11       	cpse	r24, r1
    15e2:	01 c0       	rjmp	.+2      	; 0x15e6 <ringBufferNotEmpty+0xc>
    15e4:	20 e0       	ldi	r18, 0x00	; 0
}
    15e6:	82 2f       	mov	r24, r18
    15e8:	08 95       	ret

000015ea <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    15ea:	e0 91 5e 08 	lds	r30, 0x085E
    15ee:	f0 91 5f 08 	lds	r31, 0x085F
    15f2:	80 81       	ld	r24, Z
    15f4:	81 11       	cpse	r24, r1
    15f6:	07 c0       	rjmp	.+14     	; 0x1606 <prvResetNextTaskUnblockTime+0x1c>
    15f8:	8f ef       	ldi	r24, 0xFF	; 255
    15fa:	9f ef       	ldi	r25, 0xFF	; 255
    15fc:	90 93 05 02 	sts	0x0205, r25
    1600:	80 93 04 02 	sts	0x0204, r24
    1604:	08 95       	ret
    1606:	e0 91 5e 08 	lds	r30, 0x085E
    160a:	f0 91 5f 08 	lds	r31, 0x085F
    160e:	05 80       	ldd	r0, Z+5	; 0x05
    1610:	f6 81       	ldd	r31, Z+6	; 0x06
    1612:	e0 2d       	mov	r30, r0
    1614:	06 80       	ldd	r0, Z+6	; 0x06
    1616:	f7 81       	ldd	r31, Z+7	; 0x07
    1618:	e0 2d       	mov	r30, r0
    161a:	82 81       	ldd	r24, Z+2	; 0x02
    161c:	93 81       	ldd	r25, Z+3	; 0x03
    161e:	90 93 05 02 	sts	0x0205, r25
    1622:	80 93 04 02 	sts	0x0204, r24
    1626:	08 95       	ret

00001628 <prvAddCurrentTaskToDelayedList>:
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
    162c:	ec 01       	movw	r28, r24
    162e:	e0 91 9f 08 	lds	r30, 0x089F
    1632:	f0 91 a0 08 	lds	r31, 0x08A0
    1636:	93 83       	std	Z+3, r25	; 0x03
    1638:	82 83       	std	Z+2, r24	; 0x02
    163a:	80 91 3d 08 	lds	r24, 0x083D
    163e:	90 91 3e 08 	lds	r25, 0x083E
    1642:	c8 17       	cp	r28, r24
    1644:	d9 07       	cpc	r29, r25
    1646:	68 f4       	brcc	.+26     	; 0x1662 <prvAddCurrentTaskToDelayedList+0x3a>
    1648:	60 91 9f 08 	lds	r22, 0x089F
    164c:	70 91 a0 08 	lds	r23, 0x08A0
    1650:	80 91 5c 08 	lds	r24, 0x085C
    1654:	90 91 5d 08 	lds	r25, 0x085D
    1658:	6e 5f       	subi	r22, 0xFE	; 254
    165a:	7f 4f       	sbci	r23, 0xFF	; 255
    165c:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vListInsert>
    1660:	17 c0       	rjmp	.+46     	; 0x1690 <prvAddCurrentTaskToDelayedList+0x68>
    1662:	60 91 9f 08 	lds	r22, 0x089F
    1666:	70 91 a0 08 	lds	r23, 0x08A0
    166a:	80 91 5e 08 	lds	r24, 0x085E
    166e:	90 91 5f 08 	lds	r25, 0x085F
    1672:	6e 5f       	subi	r22, 0xFE	; 254
    1674:	7f 4f       	sbci	r23, 0xFF	; 255
    1676:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vListInsert>
    167a:	80 91 04 02 	lds	r24, 0x0204
    167e:	90 91 05 02 	lds	r25, 0x0205
    1682:	c8 17       	cp	r28, r24
    1684:	d9 07       	cpc	r29, r25
    1686:	20 f4       	brcc	.+8      	; 0x1690 <prvAddCurrentTaskToDelayedList+0x68>
    1688:	d0 93 05 02 	sts	0x0205, r29
    168c:	c0 93 04 02 	sts	0x0204, r28
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	08 95       	ret

00001696 <xTaskGenericCreate>:
    1696:	4f 92       	push	r4
    1698:	5f 92       	push	r5
    169a:	6f 92       	push	r6
    169c:	7f 92       	push	r7
    169e:	8f 92       	push	r8
    16a0:	9f 92       	push	r9
    16a2:	af 92       	push	r10
    16a4:	bf 92       	push	r11
    16a6:	cf 92       	push	r12
    16a8:	df 92       	push	r13
    16aa:	ef 92       	push	r14
    16ac:	ff 92       	push	r15
    16ae:	0f 93       	push	r16
    16b0:	1f 93       	push	r17
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	4c 01       	movw	r8, r24
    16b8:	5b 01       	movw	r10, r22
    16ba:	2a 01       	movw	r4, r20
    16bc:	39 01       	movw	r6, r18
    16be:	83 e2       	ldi	r24, 0x23	; 35
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <pvPortMalloc>
    16c6:	ec 01       	movw	r28, r24
    16c8:	00 97       	sbiw	r24, 0x00	; 0
    16ca:	09 f4       	brne	.+2      	; 0x16ce <xTaskGenericCreate+0x38>
    16cc:	e7 c0       	rjmp	.+462    	; 0x189c <xTaskGenericCreate+0x206>
    16ce:	c1 14       	cp	r12, r1
    16d0:	d1 04       	cpc	r13, r1
    16d2:	09 f0       	breq	.+2      	; 0x16d6 <xTaskGenericCreate+0x40>
    16d4:	cc c0       	rjmp	.+408    	; 0x186e <xTaskGenericCreate+0x1d8>
    16d6:	c2 01       	movw	r24, r4
    16d8:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <pvPortMalloc>
    16dc:	98 8f       	std	Y+24, r25	; 0x18
    16de:	8f 8b       	std	Y+23, r24	; 0x17
    16e0:	89 2b       	or	r24, r25
    16e2:	09 f0       	breq	.+2      	; 0x16e6 <xTaskGenericCreate+0x50>
    16e4:	c6 c0       	rjmp	.+396    	; 0x1872 <xTaskGenericCreate+0x1dc>
    16e6:	ce 01       	movw	r24, r28
    16e8:	0e 94 25 02 	call	0x44a	; 0x44a <vPortFree>
    16ec:	d7 c0       	rjmp	.+430    	; 0x189c <xTaskGenericCreate+0x206>
    16ee:	cf 01       	movw	r24, r30
    16f0:	31 91       	ld	r19, Z+
    16f2:	da 01       	movw	r26, r20
    16f4:	3d 93       	st	X+, r19
    16f6:	ad 01       	movw	r20, r26
    16f8:	dc 01       	movw	r26, r24
    16fa:	8c 91       	ld	r24, X
    16fc:	88 23       	and	r24, r24
    16fe:	11 f0       	breq	.+4      	; 0x1704 <xTaskGenericCreate+0x6e>
    1700:	21 50       	subi	r18, 0x01	; 1
    1702:	a9 f7       	brne	.-22     	; 0x16ee <xTaskGenericCreate+0x58>
    1704:	18 a2       	std	Y+32, r1	; 0x20
    1706:	10 2f       	mov	r17, r16
    1708:	05 30       	cpi	r16, 0x05	; 5
    170a:	08 f0       	brcs	.+2      	; 0x170e <xTaskGenericCreate+0x78>
    170c:	14 e0       	ldi	r17, 0x04	; 4
    170e:	1e 8b       	std	Y+22, r17	; 0x16
    1710:	19 a3       	std	Y+33, r17	; 0x21
    1712:	1a a2       	std	Y+34, r1	; 0x22
    1714:	5e 01       	movw	r10, r28
    1716:	b2 e0       	ldi	r27, 0x02	; 2
    1718:	ab 0e       	add	r10, r27
    171a:	b1 1c       	adc	r11, r1
    171c:	c5 01       	movw	r24, r10
    171e:	0e 94 34 02 	call	0x468	; 0x468 <vListInitialiseItem>
    1722:	ce 01       	movw	r24, r28
    1724:	0c 96       	adiw	r24, 0x0c	; 12
    1726:	0e 94 34 02 	call	0x468	; 0x468 <vListInitialiseItem>
    172a:	d9 87       	std	Y+9, r29	; 0x09
    172c:	c8 87       	std	Y+8, r28	; 0x08
    172e:	85 e0       	ldi	r24, 0x05	; 5
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	81 1b       	sub	r24, r17
    1734:	91 09       	sbc	r25, r1
    1736:	9d 87       	std	Y+13, r25	; 0x0d
    1738:	8c 87       	std	Y+12, r24	; 0x0c
    173a:	db 8b       	std	Y+19, r29	; 0x13
    173c:	ca 8b       	std	Y+18, r28	; 0x12
    173e:	a3 01       	movw	r20, r6
    1740:	b4 01       	movw	r22, r8
    1742:	c6 01       	movw	r24, r12
    1744:	d4 da       	rcall	.-2648   	; 0xcee <pxPortInitialiseStack>
    1746:	99 83       	std	Y+1, r25	; 0x01
    1748:	88 83       	st	Y, r24
    174a:	e1 14       	cp	r14, r1
    174c:	f1 04       	cpc	r15, r1
    174e:	19 f0       	breq	.+6      	; 0x1756 <xTaskGenericCreate+0xc0>
    1750:	f7 01       	movw	r30, r14
    1752:	d1 83       	std	Z+1, r29	; 0x01
    1754:	c0 83       	st	Z, r28
    1756:	0f b6       	in	r0, 0x3f	; 63
    1758:	f8 94       	cli
    175a:	0f 92       	push	r0
    175c:	80 91 3f 08 	lds	r24, 0x083F
    1760:	8f 5f       	subi	r24, 0xFF	; 255
    1762:	80 93 3f 08 	sts	0x083F, r24
    1766:	80 91 9f 08 	lds	r24, 0x089F
    176a:	90 91 a0 08 	lds	r25, 0x08A0
    176e:	89 2b       	or	r24, r25
    1770:	09 f0       	breq	.+2      	; 0x1774 <xTaskGenericCreate+0xde>
    1772:	3f c0       	rjmp	.+126    	; 0x17f2 <xTaskGenericCreate+0x15c>
    1774:	d0 93 a0 08 	sts	0x08A0, r29
    1778:	c0 93 9f 08 	sts	0x089F, r28
    177c:	80 91 3f 08 	lds	r24, 0x083F
    1780:	81 30       	cpi	r24, 0x01	; 1
    1782:	09 f0       	breq	.+2      	; 0x1786 <xTaskGenericCreate+0xf0>
    1784:	45 c0       	rjmp	.+138    	; 0x1810 <xTaskGenericCreate+0x17a>
    1786:	0f 2e       	mov	r0, r31
    1788:	f2 e7       	ldi	r31, 0x72	; 114
    178a:	ef 2e       	mov	r14, r31
    178c:	f8 e0       	ldi	r31, 0x08	; 8
    178e:	ff 2e       	mov	r15, r31
    1790:	f0 2d       	mov	r31, r0
    1792:	0f 2e       	mov	r0, r31
    1794:	ff e9       	ldi	r31, 0x9F	; 159
    1796:	cf 2e       	mov	r12, r31
    1798:	f8 e0       	ldi	r31, 0x08	; 8
    179a:	df 2e       	mov	r13, r31
    179c:	f0 2d       	mov	r31, r0
    179e:	c7 01       	movw	r24, r14
    17a0:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17a4:	f9 e0       	ldi	r31, 0x09	; 9
    17a6:	ef 0e       	add	r14, r31
    17a8:	f1 1c       	adc	r15, r1
    17aa:	ec 14       	cp	r14, r12
    17ac:	fd 04       	cpc	r15, r13
    17ae:	b9 f7       	brne	.-18     	; 0x179e <xTaskGenericCreate+0x108>
    17b0:	89 e6       	ldi	r24, 0x69	; 105
    17b2:	98 e0       	ldi	r25, 0x08	; 8
    17b4:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17b8:	80 e6       	ldi	r24, 0x60	; 96
    17ba:	98 e0       	ldi	r25, 0x08	; 8
    17bc:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17c0:	83 e5       	ldi	r24, 0x53	; 83
    17c2:	98 e0       	ldi	r25, 0x08	; 8
    17c4:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17c8:	8a e4       	ldi	r24, 0x4A	; 74
    17ca:	98 e0       	ldi	r25, 0x08	; 8
    17cc:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17d0:	80 e4       	ldi	r24, 0x40	; 64
    17d2:	98 e0       	ldi	r25, 0x08	; 8
    17d4:	0e 94 26 02 	call	0x44c	; 0x44c <vListInitialise>
    17d8:	89 e6       	ldi	r24, 0x69	; 105
    17da:	98 e0       	ldi	r25, 0x08	; 8
    17dc:	90 93 5f 08 	sts	0x085F, r25
    17e0:	80 93 5e 08 	sts	0x085E, r24
    17e4:	80 e6       	ldi	r24, 0x60	; 96
    17e6:	98 e0       	ldi	r25, 0x08	; 8
    17e8:	90 93 5d 08 	sts	0x085D, r25
    17ec:	80 93 5c 08 	sts	0x085C, r24
    17f0:	0f c0       	rjmp	.+30     	; 0x1810 <xTaskGenericCreate+0x17a>
    17f2:	80 91 3b 08 	lds	r24, 0x083B
    17f6:	81 11       	cpse	r24, r1
    17f8:	0b c0       	rjmp	.+22     	; 0x1810 <xTaskGenericCreate+0x17a>
    17fa:	e0 91 9f 08 	lds	r30, 0x089F
    17fe:	f0 91 a0 08 	lds	r31, 0x08A0
    1802:	86 89       	ldd	r24, Z+22	; 0x16
    1804:	08 17       	cp	r16, r24
    1806:	20 f0       	brcs	.+8      	; 0x1810 <xTaskGenericCreate+0x17a>
    1808:	d0 93 a0 08 	sts	0x08A0, r29
    180c:	c0 93 9f 08 	sts	0x089F, r28
    1810:	80 91 37 08 	lds	r24, 0x0837
    1814:	8f 5f       	subi	r24, 0xFF	; 255
    1816:	80 93 37 08 	sts	0x0837, r24
    181a:	8e 89       	ldd	r24, Y+22	; 0x16
    181c:	90 91 3c 08 	lds	r25, 0x083C
    1820:	98 17       	cp	r25, r24
    1822:	10 f4       	brcc	.+4      	; 0x1828 <xTaskGenericCreate+0x192>
    1824:	80 93 3c 08 	sts	0x083C, r24
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	9c 01       	movw	r18, r24
    182c:	22 0f       	add	r18, r18
    182e:	33 1f       	adc	r19, r19
    1830:	22 0f       	add	r18, r18
    1832:	33 1f       	adc	r19, r19
    1834:	22 0f       	add	r18, r18
    1836:	33 1f       	adc	r19, r19
    1838:	82 0f       	add	r24, r18
    183a:	93 1f       	adc	r25, r19
    183c:	b5 01       	movw	r22, r10
    183e:	8e 58       	subi	r24, 0x8E	; 142
    1840:	97 4f       	sbci	r25, 0xF7	; 247
    1842:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63
    184a:	80 91 3b 08 	lds	r24, 0x083B
    184e:	88 23       	and	r24, r24
    1850:	51 f0       	breq	.+20     	; 0x1866 <xTaskGenericCreate+0x1d0>
    1852:	e0 91 9f 08 	lds	r30, 0x089F
    1856:	f0 91 a0 08 	lds	r31, 0x08A0
    185a:	86 89       	ldd	r24, Z+22	; 0x16
    185c:	80 17       	cp	r24, r16
    185e:	28 f4       	brcc	.+10     	; 0x186a <xTaskGenericCreate+0x1d4>
    1860:	f5 da       	rcall	.-2582   	; 0xe4c <vPortYield>
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	1c c0       	rjmp	.+56     	; 0x189e <xTaskGenericCreate+0x208>
    1866:	81 e0       	ldi	r24, 0x01	; 1
    1868:	1a c0       	rjmp	.+52     	; 0x189e <xTaskGenericCreate+0x208>
    186a:	81 e0       	ldi	r24, 0x01	; 1
    186c:	18 c0       	rjmp	.+48     	; 0x189e <xTaskGenericCreate+0x208>
    186e:	d8 8e       	std	Y+24, r13	; 0x18
    1870:	cf 8a       	std	Y+23, r12	; 0x17
    1872:	81 e0       	ldi	r24, 0x01	; 1
    1874:	48 1a       	sub	r4, r24
    1876:	51 08       	sbc	r5, r1
    1878:	cf 88       	ldd	r12, Y+23	; 0x17
    187a:	d8 8c       	ldd	r13, Y+24	; 0x18
    187c:	c4 0c       	add	r12, r4
    187e:	d5 1c       	adc	r13, r5
    1880:	d5 01       	movw	r26, r10
    1882:	8c 91       	ld	r24, X
    1884:	89 8f       	std	Y+25, r24	; 0x19
    1886:	8c 91       	ld	r24, X
    1888:	88 23       	and	r24, r24
    188a:	09 f4       	brne	.+2      	; 0x188e <xTaskGenericCreate+0x1f8>
    188c:	3b cf       	rjmp	.-394    	; 0x1704 <xTaskGenericCreate+0x6e>
    188e:	ae 01       	movw	r20, r28
    1890:	46 5e       	subi	r20, 0xE6	; 230
    1892:	5f 4f       	sbci	r21, 0xFF	; 255
    1894:	f5 01       	movw	r30, r10
    1896:	31 96       	adiw	r30, 0x01	; 1
    1898:	27 e0       	ldi	r18, 0x07	; 7
    189a:	29 cf       	rjmp	.-430    	; 0x16ee <xTaskGenericCreate+0x58>
    189c:	8f ef       	ldi	r24, 0xFF	; 255
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	1f 91       	pop	r17
    18a4:	0f 91       	pop	r16
    18a6:	ff 90       	pop	r15
    18a8:	ef 90       	pop	r14
    18aa:	df 90       	pop	r13
    18ac:	cf 90       	pop	r12
    18ae:	bf 90       	pop	r11
    18b0:	af 90       	pop	r10
    18b2:	9f 90       	pop	r9
    18b4:	8f 90       	pop	r8
    18b6:	7f 90       	pop	r7
    18b8:	6f 90       	pop	r6
    18ba:	5f 90       	pop	r5
    18bc:	4f 90       	pop	r4
    18be:	08 95       	ret

000018c0 <vTaskResume>:
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	ec 01       	movw	r28, r24
    18ca:	00 97       	sbiw	r24, 0x00	; 0
    18cc:	09 f4       	brne	.+2      	; 0x18d0 <vTaskResume+0x10>
    18ce:	3e c0       	rjmp	.+124    	; 0x194c <vTaskResume+0x8c>
    18d0:	80 91 9f 08 	lds	r24, 0x089F
    18d4:	90 91 a0 08 	lds	r25, 0x08A0
    18d8:	c8 17       	cp	r28, r24
    18da:	d9 07       	cpc	r29, r25
    18dc:	b9 f1       	breq	.+110    	; 0x194c <vTaskResume+0x8c>
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	f8 94       	cli
    18e2:	0f 92       	push	r0
    18e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    18e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    18e8:	80 54       	subi	r24, 0x40	; 64
    18ea:	98 40       	sbci	r25, 0x08	; 8
    18ec:	69 f5       	brne	.+90     	; 0x1948 <vTaskResume+0x88>
    18ee:	8c 89       	ldd	r24, Y+20	; 0x14
    18f0:	9d 89       	ldd	r25, Y+21	; 0x15
    18f2:	28 e0       	ldi	r18, 0x08	; 8
    18f4:	83 35       	cpi	r24, 0x53	; 83
    18f6:	92 07       	cpc	r25, r18
    18f8:	39 f1       	breq	.+78     	; 0x1948 <vTaskResume+0x88>
    18fa:	89 2b       	or	r24, r25
    18fc:	29 f5       	brne	.+74     	; 0x1948 <vTaskResume+0x88>
    18fe:	8e 01       	movw	r16, r28
    1900:	0e 5f       	subi	r16, 0xFE	; 254
    1902:	1f 4f       	sbci	r17, 0xFF	; 255
    1904:	c8 01       	movw	r24, r16
    1906:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    190a:	8e 89       	ldd	r24, Y+22	; 0x16
    190c:	90 91 3c 08 	lds	r25, 0x083C
    1910:	98 17       	cp	r25, r24
    1912:	10 f4       	brcc	.+4      	; 0x1918 <vTaskResume+0x58>
    1914:	80 93 3c 08 	sts	0x083C, r24
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	9c 01       	movw	r18, r24
    191c:	22 0f       	add	r18, r18
    191e:	33 1f       	adc	r19, r19
    1920:	22 0f       	add	r18, r18
    1922:	33 1f       	adc	r19, r19
    1924:	22 0f       	add	r18, r18
    1926:	33 1f       	adc	r19, r19
    1928:	82 0f       	add	r24, r18
    192a:	93 1f       	adc	r25, r19
    192c:	b8 01       	movw	r22, r16
    192e:	8e 58       	subi	r24, 0x8E	; 142
    1930:	97 4f       	sbci	r25, 0xF7	; 247
    1932:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1936:	e0 91 9f 08 	lds	r30, 0x089F
    193a:	f0 91 a0 08 	lds	r31, 0x08A0
    193e:	9e 89       	ldd	r25, Y+22	; 0x16
    1940:	86 89       	ldd	r24, Z+22	; 0x16
    1942:	98 17       	cp	r25, r24
    1944:	08 f0       	brcs	.+2      	; 0x1948 <vTaskResume+0x88>
    1946:	82 da       	rcall	.-2812   	; 0xe4c <vPortYield>
    1948:	0f 90       	pop	r0
    194a:	0f be       	out	0x3f, r0	; 63
    194c:	df 91       	pop	r29
    194e:	cf 91       	pop	r28
    1950:	1f 91       	pop	r17
    1952:	0f 91       	pop	r16
    1954:	08 95       	ret

00001956 <vTaskStartScheduler>:
    1956:	af 92       	push	r10
    1958:	bf 92       	push	r11
    195a:	cf 92       	push	r12
    195c:	df 92       	push	r13
    195e:	ef 92       	push	r14
    1960:	ff 92       	push	r15
    1962:	0f 93       	push	r16
    1964:	a1 2c       	mov	r10, r1
    1966:	b1 2c       	mov	r11, r1
    1968:	c1 2c       	mov	r12, r1
    196a:	d1 2c       	mov	r13, r1
    196c:	e1 2c       	mov	r14, r1
    196e:	f1 2c       	mov	r15, r1
    1970:	00 e0       	ldi	r16, 0x00	; 0
    1972:	20 e0       	ldi	r18, 0x00	; 0
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	45 e5       	ldi	r20, 0x55	; 85
    1978:	50 e0       	ldi	r21, 0x00	; 0
    197a:	60 e5       	ldi	r22, 0x50	; 80
    197c:	72 e0       	ldi	r23, 0x02	; 2
    197e:	82 e8       	ldi	r24, 0x82	; 130
    1980:	9e e0       	ldi	r25, 0x0E	; 14
    1982:	89 de       	rcall	.-750    	; 0x1696 <xTaskGenericCreate>
    1984:	81 30       	cpi	r24, 0x01	; 1
    1986:	41 f4       	brne	.+16     	; 0x1998 <vTaskStartScheduler+0x42>
    1988:	f8 94       	cli
    198a:	80 93 3b 08 	sts	0x083B, r24
    198e:	10 92 3e 08 	sts	0x083E, r1
    1992:	10 92 3d 08 	sts	0x083D, r1
    1996:	1d da       	rcall	.-3014   	; 0xdd2 <xPortStartScheduler>
    1998:	0f 91       	pop	r16
    199a:	ff 90       	pop	r15
    199c:	ef 90       	pop	r14
    199e:	df 90       	pop	r13
    19a0:	cf 90       	pop	r12
    19a2:	bf 90       	pop	r11
    19a4:	af 90       	pop	r10
    19a6:	08 95       	ret

000019a8 <vTaskSuspendAll>:
    19a8:	80 91 36 08 	lds	r24, 0x0836
    19ac:	8f 5f       	subi	r24, 0xFF	; 255
    19ae:	80 93 36 08 	sts	0x0836, r24
    19b2:	08 95       	ret

000019b4 <xTaskGetTickCount>:
    19b4:	0f b6       	in	r0, 0x3f	; 63
    19b6:	f8 94       	cli
    19b8:	0f 92       	push	r0
    19ba:	80 91 3d 08 	lds	r24, 0x083D
    19be:	90 91 3e 08 	lds	r25, 0x083E
    19c2:	0f 90       	pop	r0
    19c4:	0f be       	out	0x3f, r0	; 63
    19c6:	08 95       	ret

000019c8 <xTaskGetTickCountFromISR>:
    19c8:	80 91 3d 08 	lds	r24, 0x083D
    19cc:	90 91 3e 08 	lds	r25, 0x083E
    19d0:	08 95       	ret

000019d2 <xTaskIncrementTick>:
    19d2:	cf 92       	push	r12
    19d4:	df 92       	push	r13
    19d6:	ef 92       	push	r14
    19d8:	ff 92       	push	r15
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	80 91 36 08 	lds	r24, 0x0836
    19e6:	81 11       	cpse	r24, r1
    19e8:	99 c0       	rjmp	.+306    	; 0x1b1c <xTaskIncrementTick+0x14a>
    19ea:	80 91 3d 08 	lds	r24, 0x083D
    19ee:	90 91 3e 08 	lds	r25, 0x083E
    19f2:	01 96       	adiw	r24, 0x01	; 1
    19f4:	90 93 3e 08 	sts	0x083E, r25
    19f8:	80 93 3d 08 	sts	0x083D, r24
    19fc:	e0 90 3d 08 	lds	r14, 0x083D
    1a00:	f0 90 3e 08 	lds	r15, 0x083E
    1a04:	e1 14       	cp	r14, r1
    1a06:	f1 04       	cpc	r15, r1
    1a08:	b1 f4       	brne	.+44     	; 0x1a36 <xTaskIncrementTick+0x64>
    1a0a:	80 91 5e 08 	lds	r24, 0x085E
    1a0e:	90 91 5f 08 	lds	r25, 0x085F
    1a12:	20 91 5c 08 	lds	r18, 0x085C
    1a16:	30 91 5d 08 	lds	r19, 0x085D
    1a1a:	30 93 5f 08 	sts	0x085F, r19
    1a1e:	20 93 5e 08 	sts	0x085E, r18
    1a22:	90 93 5d 08 	sts	0x085D, r25
    1a26:	80 93 5c 08 	sts	0x085C, r24
    1a2a:	80 91 38 08 	lds	r24, 0x0838
    1a2e:	8f 5f       	subi	r24, 0xFF	; 255
    1a30:	80 93 38 08 	sts	0x0838, r24
    1a34:	da dd       	rcall	.-1100   	; 0x15ea <prvResetNextTaskUnblockTime>
    1a36:	80 91 04 02 	lds	r24, 0x0204
    1a3a:	90 91 05 02 	lds	r25, 0x0205
    1a3e:	e8 16       	cp	r14, r24
    1a40:	f9 06       	cpc	r15, r25
    1a42:	08 f4       	brcc	.+2      	; 0x1a46 <xTaskIncrementTick+0x74>
    1a44:	54 c0       	rjmp	.+168    	; 0x1aee <xTaskIncrementTick+0x11c>
    1a46:	d1 2c       	mov	r13, r1
    1a48:	cc 24       	eor	r12, r12
    1a4a:	c3 94       	inc	r12
    1a4c:	01 c0       	rjmp	.+2      	; 0x1a50 <xTaskIncrementTick+0x7e>
    1a4e:	dc 2c       	mov	r13, r12
    1a50:	e0 91 5e 08 	lds	r30, 0x085E
    1a54:	f0 91 5f 08 	lds	r31, 0x085F
    1a58:	80 81       	ld	r24, Z
    1a5a:	81 11       	cpse	r24, r1
    1a5c:	07 c0       	rjmp	.+14     	; 0x1a6c <xTaskIncrementTick+0x9a>
    1a5e:	8f ef       	ldi	r24, 0xFF	; 255
    1a60:	9f ef       	ldi	r25, 0xFF	; 255
    1a62:	90 93 05 02 	sts	0x0205, r25
    1a66:	80 93 04 02 	sts	0x0204, r24
    1a6a:	42 c0       	rjmp	.+132    	; 0x1af0 <xTaskIncrementTick+0x11e>
    1a6c:	e0 91 5e 08 	lds	r30, 0x085E
    1a70:	f0 91 5f 08 	lds	r31, 0x085F
    1a74:	05 80       	ldd	r0, Z+5	; 0x05
    1a76:	f6 81       	ldd	r31, Z+6	; 0x06
    1a78:	e0 2d       	mov	r30, r0
    1a7a:	c6 81       	ldd	r28, Z+6	; 0x06
    1a7c:	d7 81       	ldd	r29, Z+7	; 0x07
    1a7e:	2a 81       	ldd	r18, Y+2	; 0x02
    1a80:	3b 81       	ldd	r19, Y+3	; 0x03
    1a82:	e2 16       	cp	r14, r18
    1a84:	f3 06       	cpc	r15, r19
    1a86:	28 f4       	brcc	.+10     	; 0x1a92 <xTaskIncrementTick+0xc0>
    1a88:	30 93 05 02 	sts	0x0205, r19
    1a8c:	20 93 04 02 	sts	0x0204, r18
    1a90:	2f c0       	rjmp	.+94     	; 0x1af0 <xTaskIncrementTick+0x11e>
    1a92:	8e 01       	movw	r16, r28
    1a94:	0e 5f       	subi	r16, 0xFE	; 254
    1a96:	1f 4f       	sbci	r17, 0xFF	; 255
    1a98:	c8 01       	movw	r24, r16
    1a9a:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1a9e:	8c 89       	ldd	r24, Y+20	; 0x14
    1aa0:	9d 89       	ldd	r25, Y+21	; 0x15
    1aa2:	89 2b       	or	r24, r25
    1aa4:	21 f0       	breq	.+8      	; 0x1aae <xTaskIncrementTick+0xdc>
    1aa6:	ce 01       	movw	r24, r28
    1aa8:	0c 96       	adiw	r24, 0x0c	; 12
    1aaa:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1aae:	2e 89       	ldd	r18, Y+22	; 0x16
    1ab0:	80 91 3c 08 	lds	r24, 0x083C
    1ab4:	82 17       	cp	r24, r18
    1ab6:	10 f4       	brcc	.+4      	; 0x1abc <xTaskIncrementTick+0xea>
    1ab8:	20 93 3c 08 	sts	0x083C, r18
    1abc:	30 e0       	ldi	r19, 0x00	; 0
    1abe:	c9 01       	movw	r24, r18
    1ac0:	88 0f       	add	r24, r24
    1ac2:	99 1f       	adc	r25, r25
    1ac4:	88 0f       	add	r24, r24
    1ac6:	99 1f       	adc	r25, r25
    1ac8:	88 0f       	add	r24, r24
    1aca:	99 1f       	adc	r25, r25
    1acc:	82 0f       	add	r24, r18
    1ace:	93 1f       	adc	r25, r19
    1ad0:	b8 01       	movw	r22, r16
    1ad2:	8e 58       	subi	r24, 0x8E	; 142
    1ad4:	97 4f       	sbci	r25, 0xF7	; 247
    1ad6:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1ada:	e0 91 9f 08 	lds	r30, 0x089F
    1ade:	f0 91 a0 08 	lds	r31, 0x08A0
    1ae2:	9e 89       	ldd	r25, Y+22	; 0x16
    1ae4:	86 89       	ldd	r24, Z+22	; 0x16
    1ae6:	98 17       	cp	r25, r24
    1ae8:	08 f0       	brcs	.+2      	; 0x1aec <xTaskIncrementTick+0x11a>
    1aea:	b1 cf       	rjmp	.-158    	; 0x1a4e <xTaskIncrementTick+0x7c>
    1aec:	b1 cf       	rjmp	.-158    	; 0x1a50 <xTaskIncrementTick+0x7e>
    1aee:	d1 2c       	mov	r13, r1
    1af0:	e0 91 9f 08 	lds	r30, 0x089F
    1af4:	f0 91 a0 08 	lds	r31, 0x08A0
    1af8:	86 89       	ldd	r24, Z+22	; 0x16
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	fc 01       	movw	r30, r24
    1afe:	ee 0f       	add	r30, r30
    1b00:	ff 1f       	adc	r31, r31
    1b02:	ee 0f       	add	r30, r30
    1b04:	ff 1f       	adc	r31, r31
    1b06:	ee 0f       	add	r30, r30
    1b08:	ff 1f       	adc	r31, r31
    1b0a:	8e 0f       	add	r24, r30
    1b0c:	9f 1f       	adc	r25, r31
    1b0e:	fc 01       	movw	r30, r24
    1b10:	ee 58       	subi	r30, 0x8E	; 142
    1b12:	f7 4f       	sbci	r31, 0xF7	; 247
    1b14:	80 81       	ld	r24, Z
    1b16:	82 30       	cpi	r24, 0x02	; 2
    1b18:	40 f4       	brcc	.+16     	; 0x1b2a <xTaskIncrementTick+0x158>
    1b1a:	09 c0       	rjmp	.+18     	; 0x1b2e <xTaskIncrementTick+0x15c>
    1b1c:	80 91 3a 08 	lds	r24, 0x083A
    1b20:	8f 5f       	subi	r24, 0xFF	; 255
    1b22:	80 93 3a 08 	sts	0x083A, r24
    1b26:	d1 2c       	mov	r13, r1
    1b28:	02 c0       	rjmp	.+4      	; 0x1b2e <xTaskIncrementTick+0x15c>
    1b2a:	dd 24       	eor	r13, r13
    1b2c:	d3 94       	inc	r13
    1b2e:	80 91 39 08 	lds	r24, 0x0839
    1b32:	88 23       	and	r24, r24
    1b34:	11 f0       	breq	.+4      	; 0x1b3a <xTaskIncrementTick+0x168>
    1b36:	dd 24       	eor	r13, r13
    1b38:	d3 94       	inc	r13
    1b3a:	8d 2d       	mov	r24, r13
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	1f 91       	pop	r17
    1b42:	0f 91       	pop	r16
    1b44:	ff 90       	pop	r15
    1b46:	ef 90       	pop	r14
    1b48:	df 90       	pop	r13
    1b4a:	cf 90       	pop	r12
    1b4c:	08 95       	ret

00001b4e <xTaskResumeAll>:
    1b4e:	df 92       	push	r13
    1b50:	ef 92       	push	r14
    1b52:	ff 92       	push	r15
    1b54:	0f 93       	push	r16
    1b56:	1f 93       	push	r17
    1b58:	cf 93       	push	r28
    1b5a:	df 93       	push	r29
    1b5c:	0f b6       	in	r0, 0x3f	; 63
    1b5e:	f8 94       	cli
    1b60:	0f 92       	push	r0
    1b62:	80 91 36 08 	lds	r24, 0x0836
    1b66:	81 50       	subi	r24, 0x01	; 1
    1b68:	80 93 36 08 	sts	0x0836, r24
    1b6c:	80 91 36 08 	lds	r24, 0x0836
    1b70:	81 11       	cpse	r24, r1
    1b72:	5f c0       	rjmp	.+190    	; 0x1c32 <xTaskResumeAll+0xe4>
    1b74:	80 91 3f 08 	lds	r24, 0x083F
    1b78:	88 23       	and	r24, r24
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <xTaskResumeAll+0x30>
    1b7c:	5c c0       	rjmp	.+184    	; 0x1c36 <xTaskResumeAll+0xe8>
    1b7e:	0f 2e       	mov	r0, r31
    1b80:	f3 e5       	ldi	r31, 0x53	; 83
    1b82:	ef 2e       	mov	r14, r31
    1b84:	f8 e0       	ldi	r31, 0x08	; 8
    1b86:	ff 2e       	mov	r15, r31
    1b88:	f0 2d       	mov	r31, r0
    1b8a:	dd 24       	eor	r13, r13
    1b8c:	d3 94       	inc	r13
    1b8e:	30 c0       	rjmp	.+96     	; 0x1bf0 <xTaskResumeAll+0xa2>
    1b90:	e0 91 58 08 	lds	r30, 0x0858
    1b94:	f0 91 59 08 	lds	r31, 0x0859
    1b98:	c6 81       	ldd	r28, Z+6	; 0x06
    1b9a:	d7 81       	ldd	r29, Z+7	; 0x07
    1b9c:	ce 01       	movw	r24, r28
    1b9e:	0c 96       	adiw	r24, 0x0c	; 12
    1ba0:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1ba4:	8e 01       	movw	r16, r28
    1ba6:	0e 5f       	subi	r16, 0xFE	; 254
    1ba8:	1f 4f       	sbci	r17, 0xFF	; 255
    1baa:	c8 01       	movw	r24, r16
    1bac:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1bb0:	8e 89       	ldd	r24, Y+22	; 0x16
    1bb2:	90 91 3c 08 	lds	r25, 0x083C
    1bb6:	98 17       	cp	r25, r24
    1bb8:	10 f4       	brcc	.+4      	; 0x1bbe <xTaskResumeAll+0x70>
    1bba:	80 93 3c 08 	sts	0x083C, r24
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	9c 01       	movw	r18, r24
    1bc2:	22 0f       	add	r18, r18
    1bc4:	33 1f       	adc	r19, r19
    1bc6:	22 0f       	add	r18, r18
    1bc8:	33 1f       	adc	r19, r19
    1bca:	22 0f       	add	r18, r18
    1bcc:	33 1f       	adc	r19, r19
    1bce:	82 0f       	add	r24, r18
    1bd0:	93 1f       	adc	r25, r19
    1bd2:	b8 01       	movw	r22, r16
    1bd4:	8e 58       	subi	r24, 0x8E	; 142
    1bd6:	97 4f       	sbci	r25, 0xF7	; 247
    1bd8:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1bdc:	e0 91 9f 08 	lds	r30, 0x089F
    1be0:	f0 91 a0 08 	lds	r31, 0x08A0
    1be4:	9e 89       	ldd	r25, Y+22	; 0x16
    1be6:	86 89       	ldd	r24, Z+22	; 0x16
    1be8:	98 17       	cp	r25, r24
    1bea:	10 f0       	brcs	.+4      	; 0x1bf0 <xTaskResumeAll+0xa2>
    1bec:	d0 92 39 08 	sts	0x0839, r13
    1bf0:	f7 01       	movw	r30, r14
    1bf2:	80 81       	ld	r24, Z
    1bf4:	81 11       	cpse	r24, r1
    1bf6:	cc cf       	rjmp	.-104    	; 0x1b90 <xTaskResumeAll+0x42>
    1bf8:	80 91 3a 08 	lds	r24, 0x083A
    1bfc:	88 23       	and	r24, r24
    1bfe:	91 f0       	breq	.+36     	; 0x1c24 <xTaskResumeAll+0xd6>
    1c00:	80 91 3a 08 	lds	r24, 0x083A
    1c04:	88 23       	and	r24, r24
    1c06:	71 f0       	breq	.+28     	; 0x1c24 <xTaskResumeAll+0xd6>
    1c08:	c1 e0       	ldi	r28, 0x01	; 1
    1c0a:	e3 de       	rcall	.-570    	; 0x19d2 <xTaskIncrementTick>
    1c0c:	81 11       	cpse	r24, r1
    1c0e:	c0 93 39 08 	sts	0x0839, r28
    1c12:	80 91 3a 08 	lds	r24, 0x083A
    1c16:	81 50       	subi	r24, 0x01	; 1
    1c18:	80 93 3a 08 	sts	0x083A, r24
    1c1c:	80 91 3a 08 	lds	r24, 0x083A
    1c20:	81 11       	cpse	r24, r1
    1c22:	f3 cf       	rjmp	.-26     	; 0x1c0a <xTaskResumeAll+0xbc>
    1c24:	80 91 39 08 	lds	r24, 0x0839
    1c28:	81 30       	cpi	r24, 0x01	; 1
    1c2a:	39 f4       	brne	.+14     	; 0x1c3a <xTaskResumeAll+0xec>
    1c2c:	0f d9       	rcall	.-3554   	; 0xe4c <vPortYield>
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	05 c0       	rjmp	.+10     	; 0x1c3c <xTaskResumeAll+0xee>
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	03 c0       	rjmp	.+6      	; 0x1c3c <xTaskResumeAll+0xee>
    1c36:	80 e0       	ldi	r24, 0x00	; 0
    1c38:	01 c0       	rjmp	.+2      	; 0x1c3c <xTaskResumeAll+0xee>
    1c3a:	80 e0       	ldi	r24, 0x00	; 0
    1c3c:	0f 90       	pop	r0
    1c3e:	0f be       	out	0x3f, r0	; 63
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	1f 91       	pop	r17
    1c46:	0f 91       	pop	r16
    1c48:	ff 90       	pop	r15
    1c4a:	ef 90       	pop	r14
    1c4c:	df 90       	pop	r13
    1c4e:	08 95       	ret

00001c50 <vTaskDelayUntil>:
    1c50:	0f 93       	push	r16
    1c52:	1f 93       	push	r17
    1c54:	cf 93       	push	r28
    1c56:	df 93       	push	r29
    1c58:	8c 01       	movw	r16, r24
    1c5a:	eb 01       	movw	r28, r22
    1c5c:	a5 de       	rcall	.-694    	; 0x19a8 <vTaskSuspendAll>
    1c5e:	80 91 3d 08 	lds	r24, 0x083D
    1c62:	90 91 3e 08 	lds	r25, 0x083E
    1c66:	f8 01       	movw	r30, r16
    1c68:	20 81       	ld	r18, Z
    1c6a:	31 81       	ldd	r19, Z+1	; 0x01
    1c6c:	c2 0f       	add	r28, r18
    1c6e:	d3 1f       	adc	r29, r19
    1c70:	82 17       	cp	r24, r18
    1c72:	93 07       	cpc	r25, r19
    1c74:	48 f4       	brcc	.+18     	; 0x1c88 <vTaskDelayUntil+0x38>
    1c76:	c2 17       	cp	r28, r18
    1c78:	d3 07       	cpc	r29, r19
    1c7a:	f8 f4       	brcc	.+62     	; 0x1cba <vTaskDelayUntil+0x6a>
    1c7c:	d1 83       	std	Z+1, r29	; 0x01
    1c7e:	c0 83       	st	Z, r28
    1c80:	8c 17       	cp	r24, r28
    1c82:	9d 07       	cpc	r25, r29
    1c84:	88 f4       	brcc	.+34     	; 0x1ca8 <vTaskDelayUntil+0x58>
    1c86:	07 c0       	rjmp	.+14     	; 0x1c96 <vTaskDelayUntil+0x46>
    1c88:	c2 17       	cp	r28, r18
    1c8a:	d3 07       	cpc	r29, r19
    1c8c:	90 f0       	brcs	.+36     	; 0x1cb2 <vTaskDelayUntil+0x62>
    1c8e:	8c 17       	cp	r24, r28
    1c90:	9d 07       	cpc	r25, r29
    1c92:	78 f0       	brcs	.+30     	; 0x1cb2 <vTaskDelayUntil+0x62>
    1c94:	12 c0       	rjmp	.+36     	; 0x1cba <vTaskDelayUntil+0x6a>
    1c96:	80 91 9f 08 	lds	r24, 0x089F
    1c9a:	90 91 a0 08 	lds	r25, 0x08A0
    1c9e:	02 96       	adiw	r24, 0x02	; 2
    1ca0:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1ca4:	ce 01       	movw	r24, r28
    1ca6:	c0 dc       	rcall	.-1664   	; 0x1628 <prvAddCurrentTaskToDelayedList>
    1ca8:	52 df       	rcall	.-348    	; 0x1b4e <xTaskResumeAll>
    1caa:	81 11       	cpse	r24, r1
    1cac:	0a c0       	rjmp	.+20     	; 0x1cc2 <vTaskDelayUntil+0x72>
    1cae:	ce d8       	rcall	.-3684   	; 0xe4c <vPortYield>
    1cb0:	08 c0       	rjmp	.+16     	; 0x1cc2 <vTaskDelayUntil+0x72>
    1cb2:	f8 01       	movw	r30, r16
    1cb4:	d1 83       	std	Z+1, r29	; 0x01
    1cb6:	c0 83       	st	Z, r28
    1cb8:	ee cf       	rjmp	.-36     	; 0x1c96 <vTaskDelayUntil+0x46>
    1cba:	f8 01       	movw	r30, r16
    1cbc:	d1 83       	std	Z+1, r29	; 0x01
    1cbe:	c0 83       	st	Z, r28
    1cc0:	f3 cf       	rjmp	.-26     	; 0x1ca8 <vTaskDelayUntil+0x58>
    1cc2:	df 91       	pop	r29
    1cc4:	cf 91       	pop	r28
    1cc6:	1f 91       	pop	r17
    1cc8:	0f 91       	pop	r16
    1cca:	08 95       	ret

00001ccc <vTaskDelay>:
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	ec 01       	movw	r28, r24
    1cd2:	00 97       	sbiw	r24, 0x00	; 0
    1cd4:	99 f0       	breq	.+38     	; 0x1cfc <vTaskDelay+0x30>
    1cd6:	68 de       	rcall	.-816    	; 0x19a8 <vTaskSuspendAll>
    1cd8:	80 91 3d 08 	lds	r24, 0x083D
    1cdc:	90 91 3e 08 	lds	r25, 0x083E
    1ce0:	c8 0f       	add	r28, r24
    1ce2:	d9 1f       	adc	r29, r25
    1ce4:	80 91 9f 08 	lds	r24, 0x089F
    1ce8:	90 91 a0 08 	lds	r25, 0x08A0
    1cec:	02 96       	adiw	r24, 0x02	; 2
    1cee:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1cf2:	ce 01       	movw	r24, r28
    1cf4:	99 dc       	rcall	.-1742   	; 0x1628 <prvAddCurrentTaskToDelayedList>
    1cf6:	2b df       	rcall	.-426    	; 0x1b4e <xTaskResumeAll>
    1cf8:	81 11       	cpse	r24, r1
    1cfa:	01 c0       	rjmp	.+2      	; 0x1cfe <vTaskDelay+0x32>
    1cfc:	a7 d8       	rcall	.-3762   	; 0xe4c <vPortYield>
    1cfe:	df 91       	pop	r29
    1d00:	cf 91       	pop	r28
    1d02:	08 95       	ret

00001d04 <prvIdleTask>:
    1d04:	0f 2e       	mov	r0, r31
    1d06:	f2 e7       	ldi	r31, 0x72	; 114
    1d08:	ef 2e       	mov	r14, r31
    1d0a:	f8 e0       	ldi	r31, 0x08	; 8
    1d0c:	ff 2e       	mov	r15, r31
    1d0e:	f0 2d       	mov	r31, r0
    1d10:	ca e4       	ldi	r28, 0x4A	; 74
    1d12:	d8 e0       	ldi	r29, 0x08	; 8
    1d14:	26 c0       	rjmp	.+76     	; 0x1d62 <prvIdleTask+0x5e>
    1d16:	48 de       	rcall	.-880    	; 0x19a8 <vTaskSuspendAll>
    1d18:	18 81       	ld	r17, Y
    1d1a:	19 df       	rcall	.-462    	; 0x1b4e <xTaskResumeAll>
    1d1c:	11 23       	and	r17, r17
    1d1e:	09 f1       	breq	.+66     	; 0x1d62 <prvIdleTask+0x5e>
    1d20:	0f b6       	in	r0, 0x3f	; 63
    1d22:	f8 94       	cli
    1d24:	0f 92       	push	r0
    1d26:	e0 91 4f 08 	lds	r30, 0x084F
    1d2a:	f0 91 50 08 	lds	r31, 0x0850
    1d2e:	06 81       	ldd	r16, Z+6	; 0x06
    1d30:	17 81       	ldd	r17, Z+7	; 0x07
    1d32:	c8 01       	movw	r24, r16
    1d34:	02 96       	adiw	r24, 0x02	; 2
    1d36:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1d3a:	80 91 3f 08 	lds	r24, 0x083F
    1d3e:	81 50       	subi	r24, 0x01	; 1
    1d40:	80 93 3f 08 	sts	0x083F, r24
    1d44:	80 91 49 08 	lds	r24, 0x0849
    1d48:	81 50       	subi	r24, 0x01	; 1
    1d4a:	80 93 49 08 	sts	0x0849, r24
    1d4e:	0f 90       	pop	r0
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	f8 01       	movw	r30, r16
    1d54:	87 89       	ldd	r24, Z+23	; 0x17
    1d56:	90 8d       	ldd	r25, Z+24	; 0x18
    1d58:	0e 94 25 02 	call	0x44a	; 0x44a <vPortFree>
    1d5c:	c8 01       	movw	r24, r16
    1d5e:	0e 94 25 02 	call	0x44a	; 0x44a <vPortFree>
    1d62:	80 91 49 08 	lds	r24, 0x0849
    1d66:	81 11       	cpse	r24, r1
    1d68:	d6 cf       	rjmp	.-84     	; 0x1d16 <prvIdleTask+0x12>
    1d6a:	f7 01       	movw	r30, r14
    1d6c:	80 81       	ld	r24, Z
    1d6e:	82 30       	cpi	r24, 0x02	; 2
    1d70:	c0 f3       	brcs	.-16     	; 0x1d62 <prvIdleTask+0x5e>
    1d72:	6c d8       	rcall	.-3880   	; 0xe4c <vPortYield>
    1d74:	f6 cf       	rjmp	.-20     	; 0x1d62 <prvIdleTask+0x5e>

00001d76 <vTaskSwitchContext>:
    1d76:	80 91 36 08 	lds	r24, 0x0836
    1d7a:	88 23       	and	r24, r24
    1d7c:	21 f0       	breq	.+8      	; 0x1d86 <vTaskSwitchContext+0x10>
    1d7e:	81 e0       	ldi	r24, 0x01	; 1
    1d80:	80 93 39 08 	sts	0x0839, r24
    1d84:	08 95       	ret
    1d86:	10 92 39 08 	sts	0x0839, r1
    1d8a:	80 91 3c 08 	lds	r24, 0x083C
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	fc 01       	movw	r30, r24
    1d92:	ee 0f       	add	r30, r30
    1d94:	ff 1f       	adc	r31, r31
    1d96:	ee 0f       	add	r30, r30
    1d98:	ff 1f       	adc	r31, r31
    1d9a:	ee 0f       	add	r30, r30
    1d9c:	ff 1f       	adc	r31, r31
    1d9e:	8e 0f       	add	r24, r30
    1da0:	9f 1f       	adc	r25, r31
    1da2:	fc 01       	movw	r30, r24
    1da4:	ee 58       	subi	r30, 0x8E	; 142
    1da6:	f7 4f       	sbci	r31, 0xF7	; 247
    1da8:	80 81       	ld	r24, Z
    1daa:	81 11       	cpse	r24, r1
    1dac:	17 c0       	rjmp	.+46     	; 0x1ddc <vTaskSwitchContext+0x66>
    1dae:	80 91 3c 08 	lds	r24, 0x083C
    1db2:	81 50       	subi	r24, 0x01	; 1
    1db4:	80 93 3c 08 	sts	0x083C, r24
    1db8:	80 91 3c 08 	lds	r24, 0x083C
    1dbc:	90 e0       	ldi	r25, 0x00	; 0
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	ee 0f       	add	r30, r30
    1dc2:	ff 1f       	adc	r31, r31
    1dc4:	ee 0f       	add	r30, r30
    1dc6:	ff 1f       	adc	r31, r31
    1dc8:	ee 0f       	add	r30, r30
    1dca:	ff 1f       	adc	r31, r31
    1dcc:	8e 0f       	add	r24, r30
    1dce:	9f 1f       	adc	r25, r31
    1dd0:	fc 01       	movw	r30, r24
    1dd2:	ee 58       	subi	r30, 0x8E	; 142
    1dd4:	f7 4f       	sbci	r31, 0xF7	; 247
    1dd6:	80 81       	ld	r24, Z
    1dd8:	88 23       	and	r24, r24
    1dda:	49 f3       	breq	.-46     	; 0x1dae <vTaskSwitchContext+0x38>
    1ddc:	e0 91 3c 08 	lds	r30, 0x083C
    1de0:	f0 e0       	ldi	r31, 0x00	; 0
    1de2:	cf 01       	movw	r24, r30
    1de4:	88 0f       	add	r24, r24
    1de6:	99 1f       	adc	r25, r25
    1de8:	88 0f       	add	r24, r24
    1dea:	99 1f       	adc	r25, r25
    1dec:	88 0f       	add	r24, r24
    1dee:	99 1f       	adc	r25, r25
    1df0:	e8 0f       	add	r30, r24
    1df2:	f9 1f       	adc	r31, r25
    1df4:	ee 58       	subi	r30, 0x8E	; 142
    1df6:	f7 4f       	sbci	r31, 0xF7	; 247
    1df8:	a1 81       	ldd	r26, Z+1	; 0x01
    1dfa:	b2 81       	ldd	r27, Z+2	; 0x02
    1dfc:	12 96       	adiw	r26, 0x02	; 2
    1dfe:	0d 90       	ld	r0, X+
    1e00:	bc 91       	ld	r27, X
    1e02:	a0 2d       	mov	r26, r0
    1e04:	b2 83       	std	Z+2, r27	; 0x02
    1e06:	a1 83       	std	Z+1, r26	; 0x01
    1e08:	cf 01       	movw	r24, r30
    1e0a:	03 96       	adiw	r24, 0x03	; 3
    1e0c:	a8 17       	cp	r26, r24
    1e0e:	b9 07       	cpc	r27, r25
    1e10:	31 f4       	brne	.+12     	; 0x1e1e <vTaskSwitchContext+0xa8>
    1e12:	12 96       	adiw	r26, 0x02	; 2
    1e14:	8d 91       	ld	r24, X+
    1e16:	9c 91       	ld	r25, X
    1e18:	13 97       	sbiw	r26, 0x03	; 3
    1e1a:	92 83       	std	Z+2, r25	; 0x02
    1e1c:	81 83       	std	Z+1, r24	; 0x01
    1e1e:	01 80       	ldd	r0, Z+1	; 0x01
    1e20:	f2 81       	ldd	r31, Z+2	; 0x02
    1e22:	e0 2d       	mov	r30, r0
    1e24:	86 81       	ldd	r24, Z+6	; 0x06
    1e26:	97 81       	ldd	r25, Z+7	; 0x07
    1e28:	90 93 a0 08 	sts	0x08A0, r25
    1e2c:	80 93 9f 08 	sts	0x089F, r24
    1e30:	08 95       	ret

00001e32 <vTaskSuspend>:
    1e32:	0f 93       	push	r16
    1e34:	1f 93       	push	r17
    1e36:	cf 93       	push	r28
    1e38:	df 93       	push	r29
    1e3a:	ec 01       	movw	r28, r24
    1e3c:	0f b6       	in	r0, 0x3f	; 63
    1e3e:	f8 94       	cli
    1e40:	0f 92       	push	r0
    1e42:	00 97       	sbiw	r24, 0x00	; 0
    1e44:	21 f4       	brne	.+8      	; 0x1e4e <vTaskSuspend+0x1c>
    1e46:	c0 91 9f 08 	lds	r28, 0x089F
    1e4a:	d0 91 a0 08 	lds	r29, 0x08A0
    1e4e:	8e 01       	movw	r16, r28
    1e50:	0e 5f       	subi	r16, 0xFE	; 254
    1e52:	1f 4f       	sbci	r17, 0xFF	; 255
    1e54:	c8 01       	movw	r24, r16
    1e56:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1e5a:	8c 89       	ldd	r24, Y+20	; 0x14
    1e5c:	9d 89       	ldd	r25, Y+21	; 0x15
    1e5e:	89 2b       	or	r24, r25
    1e60:	21 f0       	breq	.+8      	; 0x1e6a <vTaskSuspend+0x38>
    1e62:	ce 01       	movw	r24, r28
    1e64:	0c 96       	adiw	r24, 0x0c	; 12
    1e66:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1e6a:	b8 01       	movw	r22, r16
    1e6c:	80 e4       	ldi	r24, 0x40	; 64
    1e6e:	98 e0       	ldi	r25, 0x08	; 8
    1e70:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	80 91 9f 08 	lds	r24, 0x089F
    1e7c:	90 91 a0 08 	lds	r25, 0x08A0
    1e80:	c8 17       	cp	r28, r24
    1e82:	d9 07       	cpc	r29, r25
    1e84:	a1 f4       	brne	.+40     	; 0x1eae <vTaskSuspend+0x7c>
    1e86:	80 91 3b 08 	lds	r24, 0x083B
    1e8a:	88 23       	and	r24, r24
    1e8c:	19 f0       	breq	.+6      	; 0x1e94 <vTaskSuspend+0x62>
    1e8e:	0e 94 26 07 	call	0xe4c	; 0xe4c <vPortYield>
    1e92:	17 c0       	rjmp	.+46     	; 0x1ec2 <vTaskSuspend+0x90>
    1e94:	80 91 3f 08 	lds	r24, 0x083F
    1e98:	90 91 40 08 	lds	r25, 0x0840
    1e9c:	98 13       	cpse	r25, r24
    1e9e:	05 c0       	rjmp	.+10     	; 0x1eaa <vTaskSuspend+0x78>
    1ea0:	10 92 a0 08 	sts	0x08A0, r1
    1ea4:	10 92 9f 08 	sts	0x089F, r1
    1ea8:	0c c0       	rjmp	.+24     	; 0x1ec2 <vTaskSuspend+0x90>
    1eaa:	65 df       	rcall	.-310    	; 0x1d76 <vTaskSwitchContext>
    1eac:	0a c0       	rjmp	.+20     	; 0x1ec2 <vTaskSuspend+0x90>
    1eae:	80 91 3b 08 	lds	r24, 0x083B
    1eb2:	88 23       	and	r24, r24
    1eb4:	31 f0       	breq	.+12     	; 0x1ec2 <vTaskSuspend+0x90>
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	f8 94       	cli
    1eba:	0f 92       	push	r0
    1ebc:	96 db       	rcall	.-2260   	; 0x15ea <prvResetNextTaskUnblockTime>
    1ebe:	0f 90       	pop	r0
    1ec0:	0f be       	out	0x3f, r0	; 63
    1ec2:	df 91       	pop	r29
    1ec4:	cf 91       	pop	r28
    1ec6:	1f 91       	pop	r17
    1ec8:	0f 91       	pop	r16
    1eca:	08 95       	ret

00001ecc <vTaskPlaceOnEventList>:
    1ecc:	cf 93       	push	r28
    1ece:	df 93       	push	r29
    1ed0:	eb 01       	movw	r28, r22
    1ed2:	60 91 9f 08 	lds	r22, 0x089F
    1ed6:	70 91 a0 08 	lds	r23, 0x08A0
    1eda:	64 5f       	subi	r22, 0xF4	; 244
    1edc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ede:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vListInsert>
    1ee2:	80 91 9f 08 	lds	r24, 0x089F
    1ee6:	90 91 a0 08 	lds	r25, 0x08A0
    1eea:	02 96       	adiw	r24, 0x02	; 2
    1eec:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1ef0:	cf 3f       	cpi	r28, 0xFF	; 255
    1ef2:	8f ef       	ldi	r24, 0xFF	; 255
    1ef4:	d8 07       	cpc	r29, r24
    1ef6:	59 f4       	brne	.+22     	; 0x1f0e <vTaskPlaceOnEventList+0x42>
    1ef8:	60 91 9f 08 	lds	r22, 0x089F
    1efc:	70 91 a0 08 	lds	r23, 0x08A0
    1f00:	6e 5f       	subi	r22, 0xFE	; 254
    1f02:	7f 4f       	sbci	r23, 0xFF	; 255
    1f04:	80 e4       	ldi	r24, 0x40	; 64
    1f06:	98 e0       	ldi	r25, 0x08	; 8
    1f08:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1f0c:	07 c0       	rjmp	.+14     	; 0x1f1c <vTaskPlaceOnEventList+0x50>
    1f0e:	80 91 3d 08 	lds	r24, 0x083D
    1f12:	90 91 3e 08 	lds	r25, 0x083E
    1f16:	8c 0f       	add	r24, r28
    1f18:	9d 1f       	adc	r25, r29
    1f1a:	86 db       	rcall	.-2292   	; 0x1628 <prvAddCurrentTaskToDelayedList>
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	08 95       	ret

00001f22 <xTaskRemoveFromEventList>:
    1f22:	0f 93       	push	r16
    1f24:	1f 93       	push	r17
    1f26:	cf 93       	push	r28
    1f28:	df 93       	push	r29
    1f2a:	dc 01       	movw	r26, r24
    1f2c:	15 96       	adiw	r26, 0x05	; 5
    1f2e:	ed 91       	ld	r30, X+
    1f30:	fc 91       	ld	r31, X
    1f32:	16 97       	sbiw	r26, 0x06	; 6
    1f34:	c6 81       	ldd	r28, Z+6	; 0x06
    1f36:	d7 81       	ldd	r29, Z+7	; 0x07
    1f38:	8e 01       	movw	r16, r28
    1f3a:	04 5f       	subi	r16, 0xF4	; 244
    1f3c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f3e:	c8 01       	movw	r24, r16
    1f40:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1f44:	80 91 36 08 	lds	r24, 0x0836
    1f48:	81 11       	cpse	r24, r1
    1f4a:	1c c0       	rjmp	.+56     	; 0x1f84 <xTaskRemoveFromEventList+0x62>
    1f4c:	0a 50       	subi	r16, 0x0A	; 10
    1f4e:	11 09       	sbc	r17, r1
    1f50:	c8 01       	movw	r24, r16
    1f52:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    1f56:	8e 89       	ldd	r24, Y+22	; 0x16
    1f58:	90 91 3c 08 	lds	r25, 0x083C
    1f5c:	98 17       	cp	r25, r24
    1f5e:	10 f4       	brcc	.+4      	; 0x1f64 <xTaskRemoveFromEventList+0x42>
    1f60:	80 93 3c 08 	sts	0x083C, r24
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	9c 01       	movw	r18, r24
    1f68:	22 0f       	add	r18, r18
    1f6a:	33 1f       	adc	r19, r19
    1f6c:	22 0f       	add	r18, r18
    1f6e:	33 1f       	adc	r19, r19
    1f70:	22 0f       	add	r18, r18
    1f72:	33 1f       	adc	r19, r19
    1f74:	82 0f       	add	r24, r18
    1f76:	93 1f       	adc	r25, r19
    1f78:	b8 01       	movw	r22, r16
    1f7a:	8e 58       	subi	r24, 0x8E	; 142
    1f7c:	97 4f       	sbci	r25, 0xF7	; 247
    1f7e:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1f82:	05 c0       	rjmp	.+10     	; 0x1f8e <xTaskRemoveFromEventList+0x6c>
    1f84:	b8 01       	movw	r22, r16
    1f86:	83 e5       	ldi	r24, 0x53	; 83
    1f88:	98 e0       	ldi	r25, 0x08	; 8
    1f8a:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    1f8e:	e0 91 9f 08 	lds	r30, 0x089F
    1f92:	f0 91 a0 08 	lds	r31, 0x08A0
    1f96:	9e 89       	ldd	r25, Y+22	; 0x16
    1f98:	86 89       	ldd	r24, Z+22	; 0x16
    1f9a:	89 17       	cp	r24, r25
    1f9c:	20 f4       	brcc	.+8      	; 0x1fa6 <xTaskRemoveFromEventList+0x84>
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
    1fa0:	80 93 39 08 	sts	0x0839, r24
    1fa4:	01 c0       	rjmp	.+2      	; 0x1fa8 <xTaskRemoveFromEventList+0x86>
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	df 91       	pop	r29
    1faa:	cf 91       	pop	r28
    1fac:	1f 91       	pop	r17
    1fae:	0f 91       	pop	r16
    1fb0:	08 95       	ret

00001fb2 <vTaskSetTimeOutState>:
    1fb2:	20 91 38 08 	lds	r18, 0x0838
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	20 83       	st	Z, r18
    1fba:	20 91 3d 08 	lds	r18, 0x083D
    1fbe:	30 91 3e 08 	lds	r19, 0x083E
    1fc2:	32 83       	std	Z+2, r19	; 0x02
    1fc4:	21 83       	std	Z+1, r18	; 0x01
    1fc6:	08 95       	ret

00001fc8 <xTaskCheckForTimeOut>:
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	0f 92       	push	r0
    1fce:	40 91 3d 08 	lds	r20, 0x083D
    1fd2:	50 91 3e 08 	lds	r21, 0x083E
    1fd6:	db 01       	movw	r26, r22
    1fd8:	2d 91       	ld	r18, X+
    1fda:	3c 91       	ld	r19, X
    1fdc:	2f 3f       	cpi	r18, 0xFF	; 255
    1fde:	bf ef       	ldi	r27, 0xFF	; 255
    1fe0:	3b 07       	cpc	r19, r27
    1fe2:	11 f1       	breq	.+68     	; 0x2028 <xTaskCheckForTimeOut+0x60>
    1fe4:	e0 91 38 08 	lds	r30, 0x0838
    1fe8:	dc 01       	movw	r26, r24
    1fea:	fc 91       	ld	r31, X
    1fec:	fe 17       	cp	r31, r30
    1fee:	39 f0       	breq	.+14     	; 0x1ffe <xTaskCheckForTimeOut+0x36>
    1ff0:	11 96       	adiw	r26, 0x01	; 1
    1ff2:	ed 91       	ld	r30, X+
    1ff4:	fc 91       	ld	r31, X
    1ff6:	12 97       	sbiw	r26, 0x02	; 2
    1ff8:	4e 17       	cp	r20, r30
    1ffa:	5f 07       	cpc	r21, r31
    1ffc:	b8 f4       	brcc	.+46     	; 0x202c <xTaskCheckForTimeOut+0x64>
    1ffe:	dc 01       	movw	r26, r24
    2000:	11 96       	adiw	r26, 0x01	; 1
    2002:	ed 91       	ld	r30, X+
    2004:	fc 91       	ld	r31, X
    2006:	12 97       	sbiw	r26, 0x02	; 2
    2008:	da 01       	movw	r26, r20
    200a:	ae 1b       	sub	r26, r30
    200c:	bf 0b       	sbc	r27, r31
    200e:	a2 17       	cp	r26, r18
    2010:	b3 07       	cpc	r27, r19
    2012:	70 f4       	brcc	.+28     	; 0x2030 <xTaskCheckForTimeOut+0x68>
    2014:	e4 1b       	sub	r30, r20
    2016:	f5 0b       	sbc	r31, r21
    2018:	2e 0f       	add	r18, r30
    201a:	3f 1f       	adc	r19, r31
    201c:	fb 01       	movw	r30, r22
    201e:	31 83       	std	Z+1, r19	; 0x01
    2020:	20 83       	st	Z, r18
    2022:	c7 df       	rcall	.-114    	; 0x1fb2 <vTaskSetTimeOutState>
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	05 c0       	rjmp	.+10     	; 0x2032 <xTaskCheckForTimeOut+0x6a>
    2028:	80 e0       	ldi	r24, 0x00	; 0
    202a:	03 c0       	rjmp	.+6      	; 0x2032 <xTaskCheckForTimeOut+0x6a>
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xTaskCheckForTimeOut+0x6a>
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	0f 90       	pop	r0
    2034:	0f be       	out	0x3f, r0	; 63
    2036:	08 95       	ret

00002038 <vTaskMissedYield>:
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	80 93 39 08 	sts	0x0839, r24
    203e:	08 95       	ret

00002040 <vTaskPriorityInherit>:
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
    204a:	00 97       	sbiw	r24, 0x00	; 0
    204c:	09 f4       	brne	.+2      	; 0x2050 <vTaskPriorityInherit+0x10>
    204e:	51 c0       	rjmp	.+162    	; 0x20f2 <vTaskPriorityInherit+0xb2>
    2050:	8e 89       	ldd	r24, Y+22	; 0x16
    2052:	e0 91 9f 08 	lds	r30, 0x089F
    2056:	f0 91 a0 08 	lds	r31, 0x08A0
    205a:	96 89       	ldd	r25, Z+22	; 0x16
    205c:	89 17       	cp	r24, r25
    205e:	08 f0       	brcs	.+2      	; 0x2062 <vTaskPriorityInherit+0x22>
    2060:	48 c0       	rjmp	.+144    	; 0x20f2 <vTaskPriorityInherit+0xb2>
    2062:	2c 85       	ldd	r18, Y+12	; 0x0c
    2064:	3d 85       	ldd	r19, Y+13	; 0x0d
    2066:	33 23       	and	r19, r19
    2068:	5c f0       	brlt	.+22     	; 0x2080 <vTaskPriorityInherit+0x40>
    206a:	e0 91 9f 08 	lds	r30, 0x089F
    206e:	f0 91 a0 08 	lds	r31, 0x08A0
    2072:	96 89       	ldd	r25, Z+22	; 0x16
    2074:	25 e0       	ldi	r18, 0x05	; 5
    2076:	30 e0       	ldi	r19, 0x00	; 0
    2078:	29 1b       	sub	r18, r25
    207a:	31 09       	sbc	r19, r1
    207c:	3d 87       	std	Y+13, r19	; 0x0d
    207e:	2c 87       	std	Y+12, r18	; 0x0c
    2080:	90 e0       	ldi	r25, 0x00	; 0
    2082:	9c 01       	movw	r18, r24
    2084:	22 0f       	add	r18, r18
    2086:	33 1f       	adc	r19, r19
    2088:	22 0f       	add	r18, r18
    208a:	33 1f       	adc	r19, r19
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	82 0f       	add	r24, r18
    2092:	93 1f       	adc	r25, r19
    2094:	8e 58       	subi	r24, 0x8E	; 142
    2096:	97 4f       	sbci	r25, 0xF7	; 247
    2098:	2a 85       	ldd	r18, Y+10	; 0x0a
    209a:	3b 85       	ldd	r19, Y+11	; 0x0b
    209c:	28 17       	cp	r18, r24
    209e:	39 07       	cpc	r19, r25
    20a0:	11 f5       	brne	.+68     	; 0x20e6 <vTaskPriorityInherit+0xa6>
    20a2:	8e 01       	movw	r16, r28
    20a4:	0e 5f       	subi	r16, 0xFE	; 254
    20a6:	1f 4f       	sbci	r17, 0xFF	; 255
    20a8:	c8 01       	movw	r24, r16
    20aa:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    20ae:	e0 91 9f 08 	lds	r30, 0x089F
    20b2:	f0 91 a0 08 	lds	r31, 0x08A0
    20b6:	86 89       	ldd	r24, Z+22	; 0x16
    20b8:	8e 8b       	std	Y+22, r24	; 0x16
    20ba:	90 91 3c 08 	lds	r25, 0x083C
    20be:	98 17       	cp	r25, r24
    20c0:	10 f4       	brcc	.+4      	; 0x20c6 <vTaskPriorityInherit+0x86>
    20c2:	80 93 3c 08 	sts	0x083C, r24
    20c6:	90 e0       	ldi	r25, 0x00	; 0
    20c8:	9c 01       	movw	r18, r24
    20ca:	22 0f       	add	r18, r18
    20cc:	33 1f       	adc	r19, r19
    20ce:	22 0f       	add	r18, r18
    20d0:	33 1f       	adc	r19, r19
    20d2:	22 0f       	add	r18, r18
    20d4:	33 1f       	adc	r19, r19
    20d6:	82 0f       	add	r24, r18
    20d8:	93 1f       	adc	r25, r19
    20da:	b8 01       	movw	r22, r16
    20dc:	8e 58       	subi	r24, 0x8E	; 142
    20de:	97 4f       	sbci	r25, 0xF7	; 247
    20e0:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    20e4:	06 c0       	rjmp	.+12     	; 0x20f2 <vTaskPriorityInherit+0xb2>
    20e6:	e0 91 9f 08 	lds	r30, 0x089F
    20ea:	f0 91 a0 08 	lds	r31, 0x08A0
    20ee:	86 89       	ldd	r24, Z+22	; 0x16
    20f0:	8e 8b       	std	Y+22, r24	; 0x16
    20f2:	df 91       	pop	r29
    20f4:	cf 91       	pop	r28
    20f6:	1f 91       	pop	r17
    20f8:	0f 91       	pop	r16
    20fa:	08 95       	ret

000020fc <xTaskPriorityDisinherit>:
    20fc:	0f 93       	push	r16
    20fe:	1f 93       	push	r17
    2100:	cf 93       	push	r28
    2102:	df 93       	push	r29
    2104:	ec 01       	movw	r28, r24
    2106:	00 97       	sbiw	r24, 0x00	; 0
    2108:	71 f1       	breq	.+92     	; 0x2166 <xTaskPriorityDisinherit+0x6a>
    210a:	8a a1       	ldd	r24, Y+34	; 0x22
    210c:	81 50       	subi	r24, 0x01	; 1
    210e:	8a a3       	std	Y+34, r24	; 0x22
    2110:	2e 89       	ldd	r18, Y+22	; 0x16
    2112:	99 a1       	ldd	r25, Y+33	; 0x21
    2114:	29 17       	cp	r18, r25
    2116:	49 f1       	breq	.+82     	; 0x216a <xTaskPriorityDisinherit+0x6e>
    2118:	81 11       	cpse	r24, r1
    211a:	29 c0       	rjmp	.+82     	; 0x216e <xTaskPriorityDisinherit+0x72>
    211c:	8e 01       	movw	r16, r28
    211e:	0e 5f       	subi	r16, 0xFE	; 254
    2120:	1f 4f       	sbci	r17, 0xFF	; 255
    2122:	c8 01       	movw	r24, r16
    2124:	0e 94 8a 02 	call	0x514	; 0x514 <uxListRemove>
    2128:	89 a1       	ldd	r24, Y+33	; 0x21
    212a:	8e 8b       	std	Y+22, r24	; 0x16
    212c:	25 e0       	ldi	r18, 0x05	; 5
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	28 1b       	sub	r18, r24
    2132:	31 09       	sbc	r19, r1
    2134:	3d 87       	std	Y+13, r19	; 0x0d
    2136:	2c 87       	std	Y+12, r18	; 0x0c
    2138:	90 91 3c 08 	lds	r25, 0x083C
    213c:	98 17       	cp	r25, r24
    213e:	10 f4       	brcc	.+4      	; 0x2144 <xTaskPriorityDisinherit+0x48>
    2140:	80 93 3c 08 	sts	0x083C, r24
    2144:	90 e0       	ldi	r25, 0x00	; 0
    2146:	9c 01       	movw	r18, r24
    2148:	22 0f       	add	r18, r18
    214a:	33 1f       	adc	r19, r19
    214c:	22 0f       	add	r18, r18
    214e:	33 1f       	adc	r19, r19
    2150:	22 0f       	add	r18, r18
    2152:	33 1f       	adc	r19, r19
    2154:	82 0f       	add	r24, r18
    2156:	93 1f       	adc	r25, r19
    2158:	b8 01       	movw	r22, r16
    215a:	8e 58       	subi	r24, 0x8E	; 142
    215c:	97 4f       	sbci	r25, 0xF7	; 247
    215e:	0e 94 38 02 	call	0x470	; 0x470 <vListInsertEnd>
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	05 c0       	rjmp	.+10     	; 0x2170 <xTaskPriorityDisinherit+0x74>
    2166:	80 e0       	ldi	r24, 0x00	; 0
    2168:	03 c0       	rjmp	.+6      	; 0x2170 <xTaskPriorityDisinherit+0x74>
    216a:	80 e0       	ldi	r24, 0x00	; 0
    216c:	01 c0       	rjmp	.+2      	; 0x2170 <xTaskPriorityDisinherit+0x74>
    216e:	80 e0       	ldi	r24, 0x00	; 0
    2170:	df 91       	pop	r29
    2172:	cf 91       	pop	r28
    2174:	1f 91       	pop	r17
    2176:	0f 91       	pop	r16
    2178:	08 95       	ret

0000217a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    217a:	80 91 9f 08 	lds	r24, 0x089F
    217e:	90 91 a0 08 	lds	r25, 0x08A0
    2182:	89 2b       	or	r24, r25
    2184:	39 f0       	breq	.+14     	; 0x2194 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2186:	e0 91 9f 08 	lds	r30, 0x089F
    218a:	f0 91 a0 08 	lds	r31, 0x08A0
    218e:	82 a1       	ldd	r24, Z+34	; 0x22
    2190:	8f 5f       	subi	r24, 0xFF	; 255
    2192:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2194:	80 91 9f 08 	lds	r24, 0x089F
    2198:	90 91 a0 08 	lds	r25, 0x08A0
	}
    219c:	08 95       	ret

0000219e <__divmodhi4>:
    219e:	97 fb       	bst	r25, 7
    21a0:	07 2e       	mov	r0, r23
    21a2:	16 f4       	brtc	.+4      	; 0x21a8 <__divmodhi4+0xa>
    21a4:	00 94       	com	r0
    21a6:	06 d0       	rcall	.+12     	; 0x21b4 <__divmodhi4_neg1>
    21a8:	77 fd       	sbrc	r23, 7
    21aa:	08 d0       	rcall	.+16     	; 0x21bc <__divmodhi4_neg2>
    21ac:	0b d0       	rcall	.+22     	; 0x21c4 <__udivmodhi4>
    21ae:	07 fc       	sbrc	r0, 7
    21b0:	05 d0       	rcall	.+10     	; 0x21bc <__divmodhi4_neg2>
    21b2:	3e f4       	brtc	.+14     	; 0x21c2 <__divmodhi4_exit>

000021b4 <__divmodhi4_neg1>:
    21b4:	90 95       	com	r25
    21b6:	81 95       	neg	r24
    21b8:	9f 4f       	sbci	r25, 0xFF	; 255
    21ba:	08 95       	ret

000021bc <__divmodhi4_neg2>:
    21bc:	70 95       	com	r23
    21be:	61 95       	neg	r22
    21c0:	7f 4f       	sbci	r23, 0xFF	; 255

000021c2 <__divmodhi4_exit>:
    21c2:	08 95       	ret

000021c4 <__udivmodhi4>:
    21c4:	aa 1b       	sub	r26, r26
    21c6:	bb 1b       	sub	r27, r27
    21c8:	51 e1       	ldi	r21, 0x11	; 17
    21ca:	07 c0       	rjmp	.+14     	; 0x21da <__udivmodhi4_ep>

000021cc <__udivmodhi4_loop>:
    21cc:	aa 1f       	adc	r26, r26
    21ce:	bb 1f       	adc	r27, r27
    21d0:	a6 17       	cp	r26, r22
    21d2:	b7 07       	cpc	r27, r23
    21d4:	10 f0       	brcs	.+4      	; 0x21da <__udivmodhi4_ep>
    21d6:	a6 1b       	sub	r26, r22
    21d8:	b7 0b       	sbc	r27, r23

000021da <__udivmodhi4_ep>:
    21da:	88 1f       	adc	r24, r24
    21dc:	99 1f       	adc	r25, r25
    21de:	5a 95       	dec	r21
    21e0:	a9 f7       	brne	.-22     	; 0x21cc <__udivmodhi4_loop>
    21e2:	80 95       	com	r24
    21e4:	90 95       	com	r25
    21e6:	bc 01       	movw	r22, r24
    21e8:	cd 01       	movw	r24, r26
    21ea:	08 95       	ret

000021ec <memcpy>:
    21ec:	fb 01       	movw	r30, r22
    21ee:	dc 01       	movw	r26, r24
    21f0:	02 c0       	rjmp	.+4      	; 0x21f6 <memcpy+0xa>
    21f2:	01 90       	ld	r0, Z+
    21f4:	0d 92       	st	X+, r0
    21f6:	41 50       	subi	r20, 0x01	; 1
    21f8:	50 40       	sbci	r21, 0x00	; 0
    21fa:	d8 f7       	brcc	.-10     	; 0x21f2 <memcpy+0x6>
    21fc:	08 95       	ret

000021fe <__itoa_ncheck>:
    21fe:	bb 27       	eor	r27, r27
    2200:	4a 30       	cpi	r20, 0x0A	; 10
    2202:	31 f4       	brne	.+12     	; 0x2210 <__stack+0x11>
    2204:	99 23       	and	r25, r25
    2206:	22 f4       	brpl	.+8      	; 0x2210 <__stack+0x11>
    2208:	bd e2       	ldi	r27, 0x2D	; 45
    220a:	90 95       	com	r25
    220c:	81 95       	neg	r24
    220e:	9f 4f       	sbci	r25, 0xFF	; 255
    2210:	01 c0       	rjmp	.+2      	; 0x2214 <__utoa_common>

00002212 <__utoa_ncheck>:
    2212:	bb 27       	eor	r27, r27

00002214 <__utoa_common>:
    2214:	fb 01       	movw	r30, r22
    2216:	55 27       	eor	r21, r21
    2218:	aa 27       	eor	r26, r26
    221a:	88 0f       	add	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	aa 1f       	adc	r26, r26
    2220:	a4 17       	cp	r26, r20
    2222:	10 f0       	brcs	.+4      	; 0x2228 <__utoa_common+0x14>
    2224:	a4 1b       	sub	r26, r20
    2226:	83 95       	inc	r24
    2228:	50 51       	subi	r21, 0x10	; 16
    222a:	b9 f7       	brne	.-18     	; 0x221a <__utoa_common+0x6>
    222c:	a0 5d       	subi	r26, 0xD0	; 208
    222e:	aa 33       	cpi	r26, 0x3A	; 58
    2230:	08 f0       	brcs	.+2      	; 0x2234 <__utoa_common+0x20>
    2232:	a9 5d       	subi	r26, 0xD9	; 217
    2234:	a1 93       	st	Z+, r26
    2236:	00 97       	sbiw	r24, 0x00	; 0
    2238:	79 f7       	brne	.-34     	; 0x2218 <__utoa_common+0x4>
    223a:	b1 11       	cpse	r27, r1
    223c:	b1 93       	st	Z+, r27
    223e:	11 92       	st	Z+, r1
    2240:	cb 01       	movw	r24, r22
    2242:	00 c0       	rjmp	.+0      	; 0x2244 <strrev>

00002244 <strrev>:
    2244:	dc 01       	movw	r26, r24
    2246:	fc 01       	movw	r30, r24
    2248:	67 2f       	mov	r22, r23
    224a:	71 91       	ld	r23, Z+
    224c:	77 23       	and	r23, r23
    224e:	e1 f7       	brne	.-8      	; 0x2248 <strrev+0x4>
    2250:	32 97       	sbiw	r30, 0x02	; 2
    2252:	04 c0       	rjmp	.+8      	; 0x225c <strrev+0x18>
    2254:	7c 91       	ld	r23, X
    2256:	6d 93       	st	X+, r22
    2258:	70 83       	st	Z, r23
    225a:	62 91       	ld	r22, -Z
    225c:	ae 17       	cp	r26, r30
    225e:	bf 07       	cpc	r27, r31
    2260:	c8 f3       	brcs	.-14     	; 0x2254 <strrev+0x10>
    2262:	08 95       	ret

00002264 <_exit>:
    2264:	f8 94       	cli

00002266 <__stop_program>:
    2266:	ff cf       	rjmp	.-2      	; 0x2266 <__stop_program>
