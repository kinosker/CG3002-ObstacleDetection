
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002e24  00002eb8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e24  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000708  00800238  00800238  00002ef0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002ef0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002f20  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005e6f  00000000  00000000  00003490  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016aa  00000000  00000000  000092ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003883  00000000  00000000  0000a9a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f70  00000000  00000000  0000e22c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000176c  00000000  00000000  0000f19c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000425a  00000000  00000000  00010908  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014b62  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	a2 c3       	rjmp	.+1860   	; 0x76a <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 ae 0a 	jmp	0x155c	; 0x155c <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	66 c7       	rjmp	.+3788   	; 0xf32 <__vector_25>
      66:	00 00       	nop
      68:	d2 c7       	rjmp	.+4004   	; 0x100e <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	8a c4       	rjmp	.+2324   	; 0x98a <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	18 c7       	rjmp	.+3632   	; 0xec2 <__vector_36>
      92:	00 00       	nop
      94:	86 c7       	rjmp	.+3852   	; 0xfa2 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x44>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 e2       	ldi	r30, 0x24	; 36
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a0 34       	cpi	r26, 0x40	; 64
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c0 d0       	rcall	.+384    	; 0x322 <main>
     1a2:	0c 94 10 17 	jmp	0x2e20	; 0x2e20 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	0e 94 1c 09 	call	0x1238	; 0x1238 <myUSART_peekReceiveUSART1>
     1ac:	c8 2f       	mov	r28, r24
     1ae:	0e 94 0a 09 	call	0x1214	; 0x1214 <myUSART_receiveHandShakeAck>
     1b2:	88 23       	and	r24, r24
     1b4:	21 f0       	breq	.+8      	; 0x1be <RPI_receiveTask+0x16>
     1b6:	f3 d7       	rcall	.+4070   	; 0x119e <myUSART_receiveUSART1>
     1b8:	0e 94 ff 08 	call	0x11fe	; 0x11fe <myUSART_completeHandShake>
     1bc:	f5 cf       	rjmp	.-22     	; 0x1a8 <RPI_receiveTask>
     1be:	8c 2f       	mov	r24, r28
     1c0:	0e 94 16 09 	call	0x122c	; 0x122c <myUSART_receiveMessageACK>
     1c4:	88 23       	and	r24, r24
     1c6:	11 f0       	breq	.+4      	; 0x1cc <RPI_receiveTask+0x24>
     1c8:	ea d7       	rcall	.+4052   	; 0x119e <myUSART_receiveUSART1>
     1ca:	ee cf       	rjmp	.-36     	; 0x1a8 <RPI_receiveTask>
     1cc:	8c 2f       	mov	r24, r28
     1ce:	0e 94 10 09 	call	0x1220	; 0x1220 <myUSART_receiveHandShakeStart>
     1d2:	88 23       	and	r24, r24
     1d4:	19 f0       	breq	.+6      	; 0x1dc <RPI_receiveTask+0x34>
     1d6:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <myUSART_waitForHandshake>
     1da:	e6 cf       	rjmp	.-52     	; 0x1a8 <RPI_receiveTask>
     1dc:	e0 d7       	rcall	.+4032   	; 0x119e <myUSART_receiveUSART1>
     1de:	e4 cf       	rjmp	.-56     	; 0x1a8 <RPI_receiveTask>

000001e0 <RPI_sendTask>:
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	00 d0       	rcall	.+0      	; 0x1e6 <RPI_sendTask+0x6>
     1e6:	00 d0       	rcall	.+0      	; 0x1e8 <RPI_sendTask+0x8>
     1e8:	cd b7       	in	r28, 0x3d	; 61
     1ea:	de b7       	in	r29, 0x3e	; 62
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	4f ef       	ldi	r20, 0xFF	; 255
     1f0:	5f ef       	ldi	r21, 0xFF	; 255
     1f2:	be 01       	movw	r22, r28
     1f4:	6a 5f       	subi	r22, 0xFA	; 250
     1f6:	7f 4f       	sbci	r23, 0xFF	; 255
     1f8:	80 91 88 08 	lds	r24, 0x0888
     1fc:	90 91 89 08 	lds	r25, 0x0889
     200:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericReceive>
     204:	8e 81       	ldd	r24, Y+6	; 0x06
     206:	80 5d       	subi	r24, 0xD0	; 208
     208:	97 d7       	rcall	.+3886   	; 0x1138 <myUSART_transmitUSART1_c>
     20a:	8a e0       	ldi	r24, 0x0A	; 10
     20c:	95 d7       	rcall	.+3882   	; 0x1138 <myUSART_transmitUSART1_c>
     20e:	8e 81       	ldd	r24, Y+6	; 0x06
     210:	9f ef       	ldi	r25, 0xFF	; 255
     212:	98 0f       	add	r25, r24
     214:	9e 83       	std	Y+6, r25	; 0x06
     216:	88 23       	and	r24, r24
     218:	21 f1       	breq	.+72     	; 0x262 <RPI_sendTask+0x82>
     21a:	20 e0       	ldi	r18, 0x00	; 0
     21c:	4f ef       	ldi	r20, 0xFF	; 255
     21e:	5f ef       	ldi	r21, 0xFF	; 255
     220:	be 01       	movw	r22, r28
     222:	6f 5f       	subi	r22, 0xFF	; 255
     224:	7f 4f       	sbci	r23, 0xFF	; 255
     226:	80 91 8a 08 	lds	r24, 0x088A
     22a:	90 91 8b 08 	lds	r25, 0x088B
     22e:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <xQueueGenericReceive>
     232:	89 81       	ldd	r24, Y+1	; 0x01
     234:	6a d7       	rcall	.+3796   	; 0x110a <myUSART_transmitUSART0_c>
     236:	89 81       	ldd	r24, Y+1	; 0x01
     238:	7f d7       	rcall	.+3838   	; 0x1138 <myUSART_transmitUSART1_c>
     23a:	87 e0       	ldi	r24, 0x07	; 7
     23c:	92 e0       	ldi	r25, 0x02	; 2
     23e:	a1 d7       	rcall	.+3906   	; 0x1182 <myUSART_transmitUSART0>
     240:	ce 01       	movw	r24, r28
     242:	02 96       	adiw	r24, 0x02	; 2
     244:	9e d7       	rcall	.+3900   	; 0x1182 <myUSART_transmitUSART0>
     246:	ce 01       	movw	r24, r28
     248:	02 96       	adiw	r24, 0x02	; 2
     24a:	8d d7       	rcall	.+3866   	; 0x1166 <myUSART_transmitUSART1>
     24c:	8a e0       	ldi	r24, 0x0A	; 10
     24e:	74 d7       	rcall	.+3816   	; 0x1138 <myUSART_transmitUSART1_c>
     250:	8a e0       	ldi	r24, 0x0A	; 10
     252:	92 e0       	ldi	r25, 0x02	; 2
     254:	96 d7       	rcall	.+3884   	; 0x1182 <myUSART_transmitUSART0>
     256:	8e 81       	ldd	r24, Y+6	; 0x06
     258:	9f ef       	ldi	r25, 0xFF	; 255
     25a:	98 0f       	add	r25, r24
     25c:	9e 83       	std	Y+6, r25	; 0x06
     25e:	81 11       	cpse	r24, r1
     260:	dc cf       	rjmp	.-72     	; 0x21a <RPI_sendTask+0x3a>
     262:	8a e0       	ldi	r24, 0x0A	; 10
     264:	52 d7       	rcall	.+3748   	; 0x110a <myUSART_transmitUSART0_c>
     266:	c2 cf       	rjmp	.-124    	; 0x1ec <RPI_sendTask+0xc>

00000268 <myTimerTask>:
     268:	7d d5       	rcall	.+2810   	; 0xd64 <myTimer_Init>
     26a:	bc d5       	rcall	.+2936   	; 0xde4 <myTimer_DelayChecker>
     26c:	fe cf       	rjmp	.-4      	; 0x26a <myTimerTask+0x2>

0000026e <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     26e:	8f ef       	ldi	r24, 0xFF	; 255
     270:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     274:	ef e7       	ldi	r30, 0x7F	; 127
     276:	f0 e0       	ldi	r31, 0x00	; 0
     278:	90 81       	ld	r25, Z
     27a:	93 60       	ori	r25, 0x03	; 3
     27c:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     27e:	80 93 7d 00 	sts	0x007D, r24
     282:	08 95       	ret

00000284 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     284:	8c ec       	ldi	r24, 0xCC	; 204
     286:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     28a:	8e e3       	ldi	r24, 0x3E	; 62
     28c:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     290:	ee cf       	rjmp	.-36     	; 0x26e <setDigitalInputPowerReduction>
     292:	08 95       	ret

00000294 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     294:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     298:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     29c:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2a0:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2a4:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2a8:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ac:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2b0:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2b4:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2b8:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2bc:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2c0:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2c4:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2c8:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2cc:	10 92 73 00 	sts	0x0073, r1
     2d0:	08 95       	ret

000002d2 <init>:
}

void init()
{
     2d2:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2d4:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2d6:	f8 94       	cli
	{
		clearTimer();
     2d8:	dd df       	rcall	.-70     	; 0x294 <clearTimer>
		setPowerReduction();
     2da:	d4 df       	rcall	.-88     	; 0x284 <setPowerReduction>
		myUSART_USART0_Init();
     2dc:	ce d6       	rcall	.+3484   	; 0x107a <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2de:	ed d6       	rcall	.+3546   	; 0x10ba <myUSART_USART1_Init>
		myADC_Init();
     2e0:	8c d3       	rcall	.+1816   	; 0x9fa <myADC_Init>
		
		MaxSonar_Init();
     2e2:	83 b3       	in	r24, 0x13	; 19
     2e4:	83 60       	ori	r24, 0x03	; 3
     2e6:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     2e8:	cb d2       	rcall	.+1430   	; 0x880 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2ea:	40 e0       	ldi	r20, 0x00	; 0
     2ec:	61 e0       	ldi	r22, 0x01	; 1
     2ee:	85 e0       	ldi	r24, 0x05	; 5
     2f0:	0e 94 ad 0b 	call	0x175a	; 0x175a <xQueueGenericCreate>
     2f4:	90 93 89 08 	sts	0x0889, r25
     2f8:	80 93 88 08 	sts	0x0888, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     2fc:	40 e0       	ldi	r20, 0x00	; 0
     2fe:	65 e0       	ldi	r22, 0x05	; 5
     300:	84 e1       	ldi	r24, 0x14	; 20
     302:	0e 94 ad 0b 	call	0x175a	; 0x175a <xQueueGenericCreate>
     306:	90 93 8b 08 	sts	0x088B, r25
     30a:	80 93 8a 08 	sts	0x088A, r24
		
		MOTOR_LEFT_INIT();
     30e:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     310:	e1 e0       	ldi	r30, 0x01	; 1
     312:	f1 e0       	ldi	r31, 0x01	; 1
     314:	80 81       	ld	r24, Z
     316:	80 61       	ori	r24, 0x10	; 16
     318:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     31a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     31c:	78 94       	sei
}
     31e:	cf 91       	pop	r28
     320:	08 95       	ret

00000322 <main>:
	
	// do nth
}

int main(void)
{
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	cd b7       	in	r28, 0x3d	; 61
     328:	de b7       	in	r29, 0x3e	; 62
     32a:	28 97       	sbiw	r28, 0x08	; 8
     32c:	0f b6       	in	r0, 0x3f	; 63
     32e:	f8 94       	cli
     330:	de bf       	out	0x3e, r29	; 62
     332:	0f be       	out	0x3f, r0	; 63
     334:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     336:	cd df       	rcall	.-102    	; 0x2d2 <init>

		//xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     338:	a1 2c       	mov	r10, r1
     33a:	b1 2c       	mov	r11, r1
     33c:	c1 2c       	mov	r12, r1
     33e:	d1 2c       	mov	r13, r1
     340:	ce 01       	movw	r24, r28
     342:	01 96       	adiw	r24, 0x01	; 1
     344:	7c 01       	movw	r14, r24
     346:	04 e0       	ldi	r16, 0x04	; 4
     348:	9c 01       	movw	r18, r24
     34a:	49 e6       	ldi	r20, 0x69	; 105
     34c:	50 e0       	ldi	r21, 0x00	; 0
     34e:	6d e0       	ldi	r22, 0x0D	; 13
     350:	72 e0       	ldi	r23, 0x02	; 2
     352:	84 e3       	ldi	r24, 0x34	; 52
     354:	91 e0       	ldi	r25, 0x01	; 1
     356:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     35a:	ce 01       	movw	r24, r28
     35c:	07 96       	adiw	r24, 0x07	; 7
     35e:	7c 01       	movw	r14, r24
     360:	02 e0       	ldi	r16, 0x02	; 2
     362:	20 e0       	ldi	r18, 0x00	; 0
     364:	30 e0       	ldi	r19, 0x00	; 0
     366:	4d e6       	ldi	r20, 0x6D	; 109
     368:	51 e0       	ldi	r21, 0x01	; 1
     36a:	65 e1       	ldi	r22, 0x15	; 21
     36c:	72 e0       	ldi	r23, 0x02	; 2
     36e:	8a e6       	ldi	r24, 0x6A	; 106
     370:	92 e0       	ldi	r25, 0x02	; 2
     372:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     376:	ce 01       	movw	r24, r28
     378:	05 96       	adiw	r24, 0x05	; 5
     37a:	7c 01       	movw	r14, r24
     37c:	03 e0       	ldi	r16, 0x03	; 3
     37e:	20 e0       	ldi	r18, 0x00	; 0
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	47 e8       	ldi	r20, 0x87	; 135
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	6e e1       	ldi	r22, 0x1E	; 30
     388:	72 e0       	ldi	r23, 0x02	; 2
     38a:	84 ed       	ldi	r24, 0xD4	; 212
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     392:	ce 01       	movw	r24, r28
     394:	03 96       	adiw	r24, 0x03	; 3
     396:	7c 01       	movw	r14, r24
     398:	01 e0       	ldi	r16, 0x01	; 1
     39a:	20 e0       	ldi	r18, 0x00	; 0
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	47 e8       	ldi	r20, 0x87	; 135
     3a0:	50 e0       	ldi	r21, 0x00	; 0
     3a2:	6a e2       	ldi	r22, 0x2A	; 42
     3a4:	72 e0       	ldi	r23, 0x02	; 2
     3a6:	80 ef       	ldi	r24, 0xF0	; 240
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ae:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <vTaskStartScheduler>
     3b2:	c1 cf       	rjmp	.-126    	; 0x336 <main+0x14>

000003b4 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3b4:	9c 01       	movw	r18, r24
     3b6:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3b8:	64 e6       	ldi	r22, 0x64	; 100
     3ba:	70 e0       	ldi	r23, 0x00	; 0
     3bc:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
	
	if(input)
     3c0:	61 15       	cp	r22, r1
     3c2:	71 05       	cpc	r23, r1
     3c4:	21 f0       	breq	.+8      	; 0x3ce <myItoa+0x1a>
		*buffer++ = input + '0';
     3c6:	80 e3       	ldi	r24, 0x30	; 48
     3c8:	86 0f       	add	r24, r22
     3ca:	80 83       	st	Z, r24
     3cc:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     3ce:	4c e9       	ldi	r20, 0x9C	; 156
     3d0:	46 03       	mulsu	r20, r22
     3d2:	c0 01       	movw	r24, r0
     3d4:	47 9f       	mul	r20, r23
     3d6:	90 0d       	add	r25, r0
     3d8:	11 24       	eor	r1, r1
     3da:	28 0f       	add	r18, r24
     3dc:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     3de:	c9 01       	movw	r24, r18
     3e0:	6a e0       	ldi	r22, 0x0A	; 10
     3e2:	70 e0       	ldi	r23, 0x00	; 0
     3e4:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
	*buffer++ = input + '0';
     3e8:	80 e3       	ldi	r24, 0x30	; 48
     3ea:	86 0f       	add	r24, r22
     3ec:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     3ee:	8a e0       	ldi	r24, 0x0A	; 10
     3f0:	68 9f       	mul	r22, r24
     3f2:	20 19       	sub	r18, r0
     3f4:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     3f6:	20 5d       	subi	r18, 0xD0	; 208
     3f8:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     3fa:	12 82       	std	Z+2, r1	; 0x02
     3fc:	08 95       	ret

000003fe <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     3fe:	1f 93       	push	r17
     400:	cf 93       	push	r28
     402:	df 93       	push	r29
     404:	00 d0       	rcall	.+0      	; 0x406 <obstacleSend+0x8>
     406:	1f 92       	push	r1
     408:	1f 92       	push	r1
     40a:	cd b7       	in	r28, 0x3d	; 61
     40c:	de b7       	in	r29, 0x3e	; 62
     40e:	18 2f       	mov	r17, r24
     410:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     412:	11 23       	and	r17, r17
     414:	89 f0       	breq	.+34     	; 0x438 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     416:	be 01       	movw	r22, r28
     418:	6e 5f       	subi	r22, 0xFE	; 254
     41a:	7f 4f       	sbci	r23, 0xFF	; 255
     41c:	cb df       	rcall	.-106    	; 0x3b4 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     41e:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     420:	20 e0       	ldi	r18, 0x00	; 0
     422:	4f ef       	ldi	r20, 0xFF	; 255
     424:	5f ef       	ldi	r21, 0xFF	; 255
     426:	be 01       	movw	r22, r28
     428:	6f 5f       	subi	r22, 0xFF	; 255
     42a:	7f 4f       	sbci	r23, 0xFF	; 255
     42c:	80 91 8a 08 	lds	r24, 0x088A
     430:	90 91 8b 08 	lds	r25, 0x088B
     434:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
	}
}
     438:	0f 90       	pop	r0
     43a:	0f 90       	pop	r0
     43c:	0f 90       	pop	r0
     43e:	0f 90       	pop	r0
     440:	0f 90       	pop	r0
     442:	df 91       	pop	r29
     444:	cf 91       	pop	r28
     446:	1f 91       	pop	r17
     448:	08 95       	ret

0000044a <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     44a:	6f 92       	push	r6
     44c:	7f 92       	push	r7
     44e:	8f 92       	push	r8
     450:	9f 92       	push	r9
     452:	af 92       	push	r10
     454:	bf 92       	push	r11
     456:	cf 92       	push	r12
     458:	df 92       	push	r13
     45a:	ef 92       	push	r14
     45c:	ff 92       	push	r15
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	1f 92       	push	r1
     468:	cd b7       	in	r28, 0x3d	; 61
     46a:	de b7       	in	r29, 0x3e	; 62
     46c:	89 83       	std	Y+1, r24	; 0x01
     46e:	5b 01       	movw	r10, r22
     470:	3a 01       	movw	r6, r20
     472:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     474:	20 e0       	ldi	r18, 0x00	; 0
     476:	4f ef       	ldi	r20, 0xFF	; 255
     478:	5f ef       	ldi	r21, 0xFF	; 255
     47a:	be 01       	movw	r22, r28
     47c:	6f 5f       	subi	r22, 0xFF	; 255
     47e:	7f 4f       	sbci	r23, 0xFF	; 255
     480:	80 91 88 08 	lds	r24, 0x0888
     484:	90 91 89 08 	lds	r25, 0x0889
     488:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     48c:	b3 01       	movw	r22, r6
     48e:	f5 01       	movw	r30, r10
     490:	80 81       	ld	r24, Z
     492:	b5 df       	rcall	.-150    	; 0x3fe <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     494:	b4 01       	movw	r22, r8
     496:	f5 01       	movw	r30, r10
     498:	81 81       	ldd	r24, Z+1	; 0x01
     49a:	b1 df       	rcall	.-158    	; 0x3fe <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     49c:	b8 01       	movw	r22, r16
     49e:	f5 01       	movw	r30, r10
     4a0:	82 81       	ldd	r24, Z+2	; 0x02
     4a2:	ad df       	rcall	.-166    	; 0x3fe <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4a4:	b7 01       	movw	r22, r14
     4a6:	f5 01       	movw	r30, r10
     4a8:	83 81       	ldd	r24, Z+3	; 0x03
     4aa:	a9 df       	rcall	.-174    	; 0x3fe <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4ac:	b6 01       	movw	r22, r12
     4ae:	f5 01       	movw	r30, r10
     4b0:	84 81       	ldd	r24, Z+4	; 0x04
     4b2:	a5 df       	rcall	.-182    	; 0x3fe <obstacleSend>
		
	}
}
     4b4:	0f 90       	pop	r0
     4b6:	df 91       	pop	r29
     4b8:	cf 91       	pop	r28
     4ba:	1f 91       	pop	r17
     4bc:	0f 91       	pop	r16
     4be:	ff 90       	pop	r15
     4c0:	ef 90       	pop	r14
     4c2:	df 90       	pop	r13
     4c4:	cf 90       	pop	r12
     4c6:	bf 90       	pop	r11
     4c8:	af 90       	pop	r10
     4ca:	9f 90       	pop	r9
     4cc:	8f 90       	pop	r8
     4ce:	7f 90       	pop	r7
     4d0:	6f 90       	pop	r6
     4d2:	08 95       	ret

000004d4 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4d4:	cf 93       	push	r28
     4d6:	df 93       	push	r29
     4d8:	cd b7       	in	r28, 0x3d	; 61
     4da:	de b7       	in	r29, 0x3e	; 62
     4dc:	a4 97       	sbiw	r28, 0x24	; 36
     4de:	0f b6       	in	r0, 0x3f	; 63
     4e0:	f8 94       	cli
     4e2:	de bf       	out	0x3e, r29	; 62
     4e4:	0f be       	out	0x3f, r0	; 63
     4e6:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     4e8:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     4ea:	86 e0       	ldi	r24, 0x06	; 6
     4ec:	fe 01       	movw	r30, r28
     4ee:	34 96       	adiw	r30, 0x04	; 4
     4f0:	df 01       	movw	r26, r30
     4f2:	98 2f       	mov	r25, r24
     4f4:	1d 92       	st	X+, r1
     4f6:	9a 95       	dec	r25
     4f8:	e9 f7       	brne	.-6      	; 0x4f4 <Sonar_Task+0x20>
     4fa:	36 96       	adiw	r30, 0x06	; 6
     4fc:	df 01       	movw	r26, r30
     4fe:	98 2f       	mov	r25, r24
     500:	1d 92       	st	X+, r1
     502:	9a 95       	dec	r25
     504:	e9 f7       	brne	.-6      	; 0x500 <Sonar_Task+0x2c>
     506:	36 96       	adiw	r30, 0x06	; 6
     508:	df 01       	movw	r26, r30
     50a:	98 2f       	mov	r25, r24
     50c:	1d 92       	st	X+, r1
     50e:	9a 95       	dec	r25
     510:	e9 f7       	brne	.-6      	; 0x50c <Sonar_Task+0x38>
     512:	36 96       	adiw	r30, 0x06	; 6
     514:	df 01       	movw	r26, r30
     516:	1d 92       	st	X+, r1
     518:	8a 95       	dec	r24
     51a:	e9 f7       	brne	.-6      	; 0x516 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     51c:	36 96       	adiw	r30, 0x06	; 6
     51e:	85 e0       	ldi	r24, 0x05	; 5
     520:	df 01       	movw	r26, r30
     522:	1d 92       	st	X+, r1
     524:	8a 95       	dec	r24
     526:	e9 f7       	brne	.-6      	; 0x522 <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     528:	84 e2       	ldi	r24, 0x24	; 36
     52a:	8e d3       	rcall	.+1820   	; 0xc48 <mySharpIR_Read>
     52c:	9a a3       	std	Y+34, r25	; 0x22
     52e:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     530:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xTaskGetTickCount>
     534:	9a 83       	std	Y+2, r25	; 0x02
     536:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     538:	be d1       	rcall	.+892    	; 0x8b6 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     53a:	83 e2       	ldi	r24, 0x23	; 35
     53c:	1c d2       	rcall	.+1080   	; 0x976 <myMaxSonar_Read>
     53e:	be 01       	movw	r22, r28
     540:	6c 5f       	subi	r22, 0xFC	; 252
     542:	7f 4f       	sbci	r23, 0xFF	; 255
     544:	0f d2       	rcall	.+1054   	; 0x964 <myMaxSonar_getFilteredReading>
     546:	9c a3       	std	Y+36, r25	; 0x24
     548:	8b a3       	std	Y+35, r24	; 0x23
		
		myMaxSonar_BtmStart();
     54a:	af d1       	rcall	.+862    	; 0x8aa <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     54c:	87 e2       	ldi	r24, 0x27	; 39
     54e:	13 d2       	rcall	.+1062   	; 0x976 <myMaxSonar_Read>
     550:	be 01       	movw	r22, r28
     552:	66 5f       	subi	r22, 0xF6	; 246
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	06 d2       	rcall	.+1036   	; 0x964 <myMaxSonar_getFilteredReading>
     558:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     55a:	86 e2       	ldi	r24, 0x26	; 38
     55c:	0c d2       	rcall	.+1048   	; 0x976 <myMaxSonar_Read>
     55e:	be 01       	movw	r22, r28
     560:	60 5f       	subi	r22, 0xF0	; 240
     562:	7f 4f       	sbci	r23, 0xFF	; 255
     564:	ff d1       	rcall	.+1022   	; 0x964 <myMaxSonar_getFilteredReading>
     566:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 
     568:	85 e2       	ldi	r24, 0x25	; 37
     56a:	05 d2       	rcall	.+1034   	; 0x976 <myMaxSonar_Read>
     56c:	be 01       	movw	r22, r28
     56e:	6a 5e       	subi	r22, 0xEA	; 234
     570:	7f 4f       	sbci	r23, 0xFF	; 255
     572:	f8 d1       	rcall	.+1008   	; 0x964 <myMaxSonar_getFilteredReading>
     574:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     576:	84 e2       	ldi	r24, 0x24	; 36
     578:	67 d3       	rcall	.+1742   	; 0xc48 <mySharpIR_Read>
     57a:	4c 01       	movw	r8, r24
		//frontSonar = myMaxSonar_Stabilizer(frontSonar, &prevFrontSonar);
		//leftSonar = myMaxSonar_Stabilizer(leftSonar, &prevLeftSonar);
		//rightSonar = myMaxSonar_Stabilizer(rightSonar, &prevRightSonar);
		
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     57c:	bc 01       	movw	r22, r24
     57e:	ce 01       	movw	r24, r28
     580:	81 96       	adiw	r24, 0x21	; 33
     582:	9b d3       	rcall	.+1846   	; 0xcba <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     584:	c9 a0       	ldd	r12, Y+33	; 0x21
     586:	da a0       	ldd	r13, Y+34	; 0x22
     588:	54 01       	movw	r10, r8
     58a:	eb a0       	ldd	r14, Y+35	; 0x23
     58c:	fc a0       	ldd	r15, Y+36	; 0x24
     58e:	82 01       	movw	r16, r4
     590:	91 01       	movw	r18, r2
     592:	ae 01       	movw	r20, r28
     594:	44 5e       	subi	r20, 0xE4	; 228
     596:	5f 4f       	sbci	r21, 0xFF	; 255
     598:	6b 81       	ldd	r22, Y+3	; 0x03
     59a:	c3 01       	movw	r24, r6
     59c:	25 d3       	rcall	.+1610   	; 0xbe8 <obstacleDetection>
     59e:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5a0:	8e 01       	movw	r16, r28
     5a2:	04 5e       	subi	r16, 0xE4	; 228
     5a4:	1f 4f       	sbci	r17, 0xFF	; 255
     5a6:	94 01       	movw	r18, r8
     5a8:	a2 01       	movw	r20, r4
     5aa:	b1 01       	movw	r22, r2
     5ac:	c3 01       	movw	r24, r6
     5ae:	a6 d2       	rcall	.+1356   	; 0xafc <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5b0:	be 01       	movw	r22, r28
     5b2:	6d 5f       	subi	r22, 0xFD	; 253
     5b4:	7f 4f       	sbci	r23, 0xFF	; 255
     5b6:	c8 01       	movw	r24, r16
     5b8:	08 d3       	rcall	.+1552   	; 0xbca <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5ba:	cb a0       	ldd	r12, Y+35	; 0x23
     5bc:	dc a0       	ldd	r13, Y+36	; 0x24
     5be:	74 01       	movw	r14, r8
     5c0:	82 01       	movw	r16, r4
     5c2:	91 01       	movw	r18, r2
     5c4:	a3 01       	movw	r20, r6
     5c6:	be 01       	movw	r22, r28
     5c8:	64 5e       	subi	r22, 0xE4	; 228
     5ca:	7f 4f       	sbci	r23, 0xFF	; 255
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	3d df       	rcall	.-390    	; 0x44a <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     5d0:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     5d2:	18 a2       	std	Y+32, r1	; 0x20
     5d4:	1f 8e       	std	Y+31, r1	; 0x1f
     5d6:	1e 8e       	std	Y+30, r1	; 0x1e
     5d8:	1d 8e       	std	Y+29, r1	; 0x1d
     5da:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     5dc:	66 e9       	ldi	r22, 0x96	; 150
     5de:	70 e0       	ldi	r23, 0x00	; 0
     5e0:	ce 01       	movw	r24, r28
     5e2:	01 96       	adiw	r24, 0x01	; 1
     5e4:	0e 94 01 11 	call	0x2202	; 0x2202 <vTaskDelayUntil>
     5e8:	a7 cf       	rjmp	.-178    	; 0x538 <Sonar_Task+0x64>

000005ea <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     5f0:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     5f4:	80 91 38 02 	lds	r24, 0x0238
     5f8:	90 91 39 02 	lds	r25, 0x0239
     5fc:	89 2b       	or	r24, r25
     5fe:	31 f4       	brne	.+12     	; 0x60c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     600:	8d e3       	ldi	r24, 0x3D	; 61
     602:	92 e0       	ldi	r25, 0x02	; 2
     604:	90 93 39 02 	sts	0x0239, r25
     608:	80 93 38 02 	sts	0x0238, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     60c:	40 91 3a 02 	lds	r20, 0x023A
     610:	50 91 3b 02 	lds	r21, 0x023B
     614:	9e 01       	movw	r18, r28
     616:	24 0f       	add	r18, r20
     618:	35 1f       	adc	r19, r21
     61a:	2b 3d       	cpi	r18, 0xDB	; 219
     61c:	85 e0       	ldi	r24, 0x05	; 5
     61e:	38 07       	cpc	r19, r24
     620:	70 f4       	brcc	.+28     	; 0x63e <pvPortMalloc+0x54>
     622:	42 17       	cp	r20, r18
     624:	53 07       	cpc	r21, r19
     626:	70 f4       	brcc	.+28     	; 0x644 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     628:	c0 91 38 02 	lds	r28, 0x0238
     62c:	d0 91 39 02 	lds	r29, 0x0239
     630:	c4 0f       	add	r28, r20
     632:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     634:	30 93 3b 02 	sts	0x023B, r19
     638:	20 93 3a 02 	sts	0x023A, r18
     63c:	05 c0       	rjmp	.+10     	; 0x648 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     63e:	c0 e0       	ldi	r28, 0x00	; 0
     640:	d0 e0       	ldi	r29, 0x00	; 0
     642:	02 c0       	rjmp	.+4      	; 0x648 <pvPortMalloc+0x5e>
     644:	c0 e0       	ldi	r28, 0x00	; 0
     646:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     648:	0e 94 80 10 	call	0x2100	; 0x2100 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     64c:	ce 01       	movw	r24, r28
     64e:	df 91       	pop	r29
     650:	cf 91       	pop	r28
     652:	08 95       	ret

00000654 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     654:	08 95       	ret

00000656 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     656:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     658:	03 96       	adiw	r24, 0x03	; 3
     65a:	92 83       	std	Z+2, r25	; 0x02
     65c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     65e:	2f ef       	ldi	r18, 0xFF	; 255
     660:	3f ef       	ldi	r19, 0xFF	; 255
     662:	34 83       	std	Z+4, r19	; 0x04
     664:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     666:	96 83       	std	Z+6, r25	; 0x06
     668:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     66a:	90 87       	std	Z+8, r25	; 0x08
     66c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     66e:	10 82       	st	Z, r1
     670:	08 95       	ret

00000672 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     672:	fc 01       	movw	r30, r24
     674:	11 86       	std	Z+9, r1	; 0x09
     676:	10 86       	std	Z+8, r1	; 0x08
     678:	08 95       	ret

0000067a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     67a:	cf 93       	push	r28
     67c:	df 93       	push	r29
     67e:	9c 01       	movw	r18, r24
     680:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     682:	dc 01       	movw	r26, r24
     684:	11 96       	adiw	r26, 0x01	; 1
     686:	cd 91       	ld	r28, X+
     688:	dc 91       	ld	r29, X
     68a:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     68c:	d3 83       	std	Z+3, r29	; 0x03
     68e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	9d 81       	ldd	r25, Y+5	; 0x05
     694:	95 83       	std	Z+5, r25	; 0x05
     696:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     698:	8c 81       	ldd	r24, Y+4	; 0x04
     69a:	9d 81       	ldd	r25, Y+5	; 0x05
     69c:	dc 01       	movw	r26, r24
     69e:	13 96       	adiw	r26, 0x03	; 3
     6a0:	7c 93       	st	X, r23
     6a2:	6e 93       	st	-X, r22
     6a4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6a6:	7d 83       	std	Y+5, r23	; 0x05
     6a8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6aa:	31 87       	std	Z+9, r19	; 0x09
     6ac:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6ae:	f9 01       	movw	r30, r18
     6b0:	80 81       	ld	r24, Z
     6b2:	8f 5f       	subi	r24, 0xFF	; 255
     6b4:	80 83       	st	Z, r24
}
     6b6:	df 91       	pop	r29
     6b8:	cf 91       	pop	r28
     6ba:	08 95       	ret

000006bc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6c2:	48 81       	ld	r20, Y
     6c4:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6c6:	4f 3f       	cpi	r20, 0xFF	; 255
     6c8:	2f ef       	ldi	r18, 0xFF	; 255
     6ca:	52 07       	cpc	r21, r18
     6cc:	21 f4       	brne	.+8      	; 0x6d6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6ce:	fc 01       	movw	r30, r24
     6d0:	a7 81       	ldd	r26, Z+7	; 0x07
     6d2:	b0 85       	ldd	r27, Z+8	; 0x08
     6d4:	0d c0       	rjmp	.+26     	; 0x6f0 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6d6:	dc 01       	movw	r26, r24
     6d8:	13 96       	adiw	r26, 0x03	; 3
     6da:	12 96       	adiw	r26, 0x02	; 2
     6dc:	ed 91       	ld	r30, X+
     6de:	fc 91       	ld	r31, X
     6e0:	13 97       	sbiw	r26, 0x03	; 3
     6e2:	20 81       	ld	r18, Z
     6e4:	31 81       	ldd	r19, Z+1	; 0x01
     6e6:	42 17       	cp	r20, r18
     6e8:	53 07       	cpc	r21, r19
     6ea:	10 f0       	brcs	.+4      	; 0x6f0 <vListInsert+0x34>
     6ec:	df 01       	movw	r26, r30
     6ee:	f5 cf       	rjmp	.-22     	; 0x6da <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     6f0:	12 96       	adiw	r26, 0x02	; 2
     6f2:	ed 91       	ld	r30, X+
     6f4:	fc 91       	ld	r31, X
     6f6:	13 97       	sbiw	r26, 0x03	; 3
     6f8:	fb 83       	std	Y+3, r31	; 0x03
     6fa:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     6fc:	d5 83       	std	Z+5, r29	; 0x05
     6fe:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     700:	bd 83       	std	Y+5, r27	; 0x05
     702:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     704:	13 96       	adiw	r26, 0x03	; 3
     706:	dc 93       	st	X, r29
     708:	ce 93       	st	-X, r28
     70a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     70c:	99 87       	std	Y+9, r25	; 0x09
     70e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     710:	fc 01       	movw	r30, r24
     712:	20 81       	ld	r18, Z
     714:	2f 5f       	subi	r18, 0xFF	; 255
     716:	20 83       	st	Z, r18
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	08 95       	ret

0000071e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     724:	a0 85       	ldd	r26, Z+8	; 0x08
     726:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     728:	c2 81       	ldd	r28, Z+2	; 0x02
     72a:	d3 81       	ldd	r29, Z+3	; 0x03
     72c:	84 81       	ldd	r24, Z+4	; 0x04
     72e:	95 81       	ldd	r25, Z+5	; 0x05
     730:	9d 83       	std	Y+5, r25	; 0x05
     732:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     734:	c4 81       	ldd	r28, Z+4	; 0x04
     736:	d5 81       	ldd	r29, Z+5	; 0x05
     738:	82 81       	ldd	r24, Z+2	; 0x02
     73a:	93 81       	ldd	r25, Z+3	; 0x03
     73c:	9b 83       	std	Y+3, r25	; 0x03
     73e:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     740:	11 96       	adiw	r26, 0x01	; 1
     742:	cd 91       	ld	r28, X+
     744:	dc 91       	ld	r29, X
     746:	12 97       	sbiw	r26, 0x02	; 2
     748:	ce 17       	cp	r28, r30
     74a:	df 07       	cpc	r29, r31
     74c:	31 f4       	brne	.+12     	; 0x75a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     74e:	8c 81       	ldd	r24, Y+4	; 0x04
     750:	9d 81       	ldd	r25, Y+5	; 0x05
     752:	12 96       	adiw	r26, 0x02	; 2
     754:	9c 93       	st	X, r25
     756:	8e 93       	st	-X, r24
     758:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     75a:	11 86       	std	Z+9, r1	; 0x09
     75c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     75e:	8c 91       	ld	r24, X
     760:	81 50       	subi	r24, 0x01	; 1
     762:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     764:	df 91       	pop	r29
     766:	cf 91       	pop	r28
     768:	08 95       	ret

0000076a <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     76a:	1f 92       	push	r1
     76c:	0f 92       	push	r0
     76e:	0f b6       	in	r0, 0x3f	; 63
     770:	0f 92       	push	r0
     772:	11 24       	eor	r1, r1
     774:	0b b6       	in	r0, 0x3b	; 59
     776:	0f 92       	push	r0
     778:	2f 93       	push	r18
     77a:	3f 93       	push	r19
     77c:	4f 93       	push	r20
     77e:	5f 93       	push	r21
     780:	6f 93       	push	r22
     782:	7f 93       	push	r23
     784:	8f 93       	push	r24
     786:	9f 93       	push	r25
     788:	af 93       	push	r26
     78a:	bf 93       	push	r27
     78c:	ef 93       	push	r30
     78e:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     790:	1b 9b       	sbis	0x03, 3	; 3
     792:	0d c0       	rjmp	.+26     	; 0x7ae <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     794:	01 d3       	rcall	.+1538   	; 0xd98 <myTimer_Read>
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	90 93 91 08 	sts	0x0891, r25
     79c:	80 93 90 08 	sts	0x0890, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7a0:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGetTickCountFromISR>
     7a4:	90 93 8d 08 	sts	0x088D, r25
     7a8:	80 93 8c 08 	sts	0x088C, r24
     7ac:	56 c0       	rjmp	.+172    	; 0x85a <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7ae:	1b 99       	sbic	0x03, 3	; 3
     7b0:	54 c0       	rjmp	.+168    	; 0x85a <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7b2:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <xTaskGetTickCountFromISR>
     7b6:	90 93 97 08 	sts	0x0897, r25
     7ba:	80 93 96 08 	sts	0x0896, r24
     7be:	20 91 8c 08 	lds	r18, 0x088C
     7c2:	30 91 8d 08 	lds	r19, 0x088D
     7c6:	82 17       	cp	r24, r18
     7c8:	93 07       	cpc	r25, r19
     7ca:	4c f4       	brge	.+18     	; 0x7de <__vector_9+0x74>
			ms_tickEnd += 65535;
     7cc:	80 91 96 08 	lds	r24, 0x0896
     7d0:	90 91 97 08 	lds	r25, 0x0897
     7d4:	01 97       	sbiw	r24, 0x01	; 1
     7d6:	90 93 97 08 	sts	0x0897, r25
     7da:	80 93 96 08 	sts	0x0896, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     7de:	dc d2       	rcall	.+1464   	; 0xd98 <myTimer_Read>
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	90 93 99 08 	sts	0x0899, r25
     7e6:	80 93 98 08 	sts	0x0898, r24
     7ea:	20 91 90 08 	lds	r18, 0x0890
     7ee:	30 91 91 08 	lds	r19, 0x0891
     7f2:	82 17       	cp	r24, r18
     7f4:	93 07       	cpc	r25, r19
     7f6:	54 f4       	brge	.+20     	; 0x80c <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     7f8:	80 91 98 08 	lds	r24, 0x0898
     7fc:	90 91 99 08 	lds	r25, 0x0899
     800:	86 50       	subi	r24, 0x06	; 6
     802:	9f 4f       	sbci	r25, 0xFF	; 255
     804:	90 93 99 08 	sts	0x0899, r25
     808:	80 93 98 08 	sts	0x0898, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     80c:	80 91 98 08 	lds	r24, 0x0898
     810:	90 91 99 08 	lds	r25, 0x0899
     814:	20 91 90 08 	lds	r18, 0x0890
     818:	30 91 91 08 	lds	r19, 0x0891
     81c:	82 1b       	sub	r24, r18
     81e:	93 0b       	sbc	r25, r19
     820:	90 93 93 08 	sts	0x0893, r25
     824:	80 93 92 08 	sts	0x0892, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     828:	80 91 96 08 	lds	r24, 0x0896
     82c:	90 91 97 08 	lds	r25, 0x0897
     830:	20 91 8c 08 	lds	r18, 0x088C
     834:	30 91 8d 08 	lds	r19, 0x088D
     838:	82 1b       	sub	r24, r18
     83a:	93 0b       	sbc	r25, r19
     83c:	90 93 8f 08 	sts	0x088F, r25
     840:	80 93 8e 08 	sts	0x088E, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     844:	20 e0       	ldi	r18, 0x00	; 0
     846:	40 e0       	ldi	r20, 0x00	; 0
     848:	50 e0       	ldi	r21, 0x00	; 0
     84a:	60 e0       	ldi	r22, 0x00	; 0
     84c:	70 e0       	ldi	r23, 0x00	; 0
     84e:	80 91 94 08 	lds	r24, 0x0894
     852:	90 91 95 08 	lds	r25, 0x0895
     856:	0e 94 98 0c 	call	0x1930	; 0x1930 <xQueueGenericSendFromISR>
	}	
}
     85a:	ff 91       	pop	r31
     85c:	ef 91       	pop	r30
     85e:	bf 91       	pop	r27
     860:	af 91       	pop	r26
     862:	9f 91       	pop	r25
     864:	8f 91       	pop	r24
     866:	7f 91       	pop	r23
     868:	6f 91       	pop	r22
     86a:	5f 91       	pop	r21
     86c:	4f 91       	pop	r20
     86e:	3f 91       	pop	r19
     870:	2f 91       	pop	r18
     872:	0f 90       	pop	r0
     874:	0b be       	out	0x3b, r0	; 59
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	0f 90       	pop	r0
     87c:	1f 90       	pop	r1
     87e:	18 95       	reti

00000880 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     880:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     882:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     884:	e8 e6       	ldi	r30, 0x68	; 104
     886:	f0 e0       	ldi	r31, 0x00	; 0
     888:	80 81       	ld	r24, Z
     88a:	81 60       	ori	r24, 0x01	; 1
     88c:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     88e:	eb e6       	ldi	r30, 0x6B	; 107
     890:	f0 e0       	ldi	r31, 0x00	; 0
     892:	80 81       	ld	r24, Z
     894:	88 60       	ori	r24, 0x08	; 8
     896:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     898:	43 e0       	ldi	r20, 0x03	; 3
     89a:	60 e0       	ldi	r22, 0x00	; 0
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	5d d7       	rcall	.+3770   	; 0x175a <xQueueGenericCreate>
     8a0:	90 93 95 08 	sts	0x0895, r25
     8a4:	80 93 94 08 	sts	0x0894, r24
     8a8:	08 95       	ret

000008aa <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8aa:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8ac:	89 e1       	ldi	r24, 0x19	; 25
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	75 d2       	rcall	.+1258   	; 0xd9c <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8b2:	a1 98       	cbi	0x14, 1	; 20
     8b4:	08 95       	ret

000008b6 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8b6:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8b8:	89 e1       	ldi	r24, 0x19	; 25
     8ba:	90 e0       	ldi	r25, 0x00	; 0
     8bc:	6f d2       	rcall	.+1246   	; 0xd9c <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8be:	a0 98       	cbi	0x14, 0	; 20
     8c0:	08 95       	ret

000008c2 <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8c2:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8c4:	80 81       	ld	r24, Z
     8c6:	91 81       	ldd	r25, Z+1	; 0x01
     8c8:	22 81       	ldd	r18, Z+2	; 0x02
     8ca:	33 81       	ldd	r19, Z+3	; 0x03
     8cc:	28 17       	cp	r18, r24
     8ce:	39 07       	cpc	r19, r25
     8d0:	54 f4       	brge	.+20     	; 0x8e6 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8d2:	44 81       	ldd	r20, Z+4	; 0x04
     8d4:	55 81       	ldd	r21, Z+5	; 0x05
     8d6:	42 17       	cp	r20, r18
     8d8:	53 07       	cpc	r21, r19
     8da:	84 f0       	brlt	.+32     	; 0x8fc <myMaxSonar_extractMedian+0x3a>
     8dc:	48 17       	cp	r20, r24
     8de:	59 07       	cpc	r21, r25
     8e0:	74 f4       	brge	.+28     	; 0x8fe <myMaxSonar_extractMedian+0x3c>
     8e2:	ca 01       	movw	r24, r20
     8e4:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     8e6:	44 81       	ldd	r20, Z+4	; 0x04
     8e8:	55 81       	ldd	r21, Z+5	; 0x05
     8ea:	48 17       	cp	r20, r24
     8ec:	59 07       	cpc	r21, r25
     8ee:	3c f0       	brlt	.+14     	; 0x8fe <myMaxSonar_extractMedian+0x3c>
     8f0:	ca 01       	movw	r24, r20
     8f2:	24 17       	cp	r18, r20
     8f4:	35 07       	cpc	r19, r21
     8f6:	1c f4       	brge	.+6      	; 0x8fe <myMaxSonar_extractMedian+0x3c>
     8f8:	c9 01       	movw	r24, r18
     8fa:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     8fc:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     8fe:	08 95       	ret

00000900 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_RANGE) || currentReading < (prevReading - NOISE_RANGE))
     900:	9b 01       	movw	r18, r22
     902:	28 5f       	subi	r18, 0xF8	; 248
     904:	3f 4f       	sbci	r19, 0xFF	; 255
     906:	28 17       	cp	r18, r24
     908:	39 07       	cpc	r19, r25
     90a:	3c f0       	brlt	.+14     	; 0x91a <myMaxSonar_Stabilizer+0x1a>
     90c:	20 51       	subi	r18, 0x10	; 16
     90e:	31 09       	sbc	r19, r1
     910:	82 17       	cp	r24, r18
     912:	93 07       	cpc	r25, r19
     914:	14 f0       	brlt	.+4      	; 0x91a <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     916:	86 2f       	mov	r24, r22
     918:	97 2f       	mov	r25, r23
}
     91a:	08 95       	ret

0000091c <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     91c:	0f 93       	push	r16
     91e:	1f 93       	push	r17
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     926:	00 91 00 02 	lds	r16, 0x0200
     92a:	10 e0       	ldi	r17, 0x00	; 0
     92c:	f8 01       	movw	r30, r16
     92e:	ee 0f       	add	r30, r30
     930:	ff 1f       	adc	r31, r31
     932:	e6 0f       	add	r30, r22
     934:	f7 1f       	adc	r31, r23
     936:	60 81       	ld	r22, Z
     938:	71 81       	ldd	r23, Z+1	; 0x01
     93a:	e2 df       	rcall	.-60     	; 0x900 <myMaxSonar_Stabilizer>
     93c:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     93e:	c8 01       	movw	r24, r16
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	63 e0       	ldi	r22, 0x03	; 3
     944:	70 e0       	ldi	r23, 0x00	; 0
     946:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
     94a:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     94e:	88 0f       	add	r24, r24
     950:	99 1f       	adc	r25, r25
     952:	c8 0f       	add	r28, r24
     954:	d9 1f       	adc	r29, r25
     956:	39 83       	std	Y+1, r19	; 0x01
     958:	28 83       	st	Y, r18
}
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	1f 91       	pop	r17
     960:	0f 91       	pop	r16
     962:	08 95       	ret

00000964 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     96a:	d8 df       	rcall	.-80     	; 0x91c <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     96c:	ce 01       	movw	r24, r28
     96e:	a9 df       	rcall	.-174    	; 0x8c2 <myMaxSonar_extractMedian>

}
     970:	df 91       	pop	r29
     972:	cf 91       	pop	r28
     974:	08 95       	ret

00000976 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     976:	ab d0       	rcall	.+342    	; 0xace <myADC_analogRead>
     978:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     97a:	63 e0       	ldi	r22, 0x03	; 3
     97c:	70 e0       	ldi	r23, 0x00	; 0
     97e:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     982:	cb 01       	movw	r24, r22
     984:	82 0f       	add	r24, r18
     986:	93 1f       	adc	r25, r19
     988:	08 95       	ret

0000098a <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     98a:	1f 92       	push	r1
     98c:	0f 92       	push	r0
     98e:	0f b6       	in	r0, 0x3f	; 63
     990:	0f 92       	push	r0
     992:	11 24       	eor	r1, r1
     994:	0b b6       	in	r0, 0x3b	; 59
     996:	0f 92       	push	r0
     998:	2f 93       	push	r18
     99a:	3f 93       	push	r19
     99c:	4f 93       	push	r20
     99e:	5f 93       	push	r21
     9a0:	6f 93       	push	r22
     9a2:	7f 93       	push	r23
     9a4:	8f 93       	push	r24
     9a6:	9f 93       	push	r25
     9a8:	af 93       	push	r26
     9aa:	bf 93       	push	r27
     9ac:	ef 93       	push	r30
     9ae:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9b0:	80 91 78 00 	lds	r24, 0x0078
     9b4:	80 93 9a 08 	sts	0x089A, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9b8:	80 91 79 00 	lds	r24, 0x0079
     9bc:	80 93 9b 08 	sts	0x089B, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9c0:	20 e0       	ldi	r18, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	60 e0       	ldi	r22, 0x00	; 0
     9c8:	70 e0       	ldi	r23, 0x00	; 0
     9ca:	80 91 9e 08 	lds	r24, 0x089E
     9ce:	90 91 9f 08 	lds	r25, 0x089F
     9d2:	ae d7       	rcall	.+3932   	; 0x1930 <xQueueGenericSendFromISR>
}
     9d4:	ff 91       	pop	r31
     9d6:	ef 91       	pop	r30
     9d8:	bf 91       	pop	r27
     9da:	af 91       	pop	r26
     9dc:	9f 91       	pop	r25
     9de:	8f 91       	pop	r24
     9e0:	7f 91       	pop	r23
     9e2:	6f 91       	pop	r22
     9e4:	5f 91       	pop	r21
     9e6:	4f 91       	pop	r20
     9e8:	3f 91       	pop	r19
     9ea:	2f 91       	pop	r18
     9ec:	0f 90       	pop	r0
     9ee:	0b be       	out	0x3b, r0	; 59
     9f0:	0f 90       	pop	r0
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	0f 90       	pop	r0
     9f6:	1f 90       	pop	r1
     9f8:	18 95       	reti

000009fa <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     9fa:	8f e8       	ldi	r24, 0x8F	; 143
     9fc:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a00:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a0a:	43 e0       	ldi	r20, 0x03	; 3
     a0c:	60 e0       	ldi	r22, 0x00	; 0
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	a4 d6       	rcall	.+3400   	; 0x175a <xQueueGenericCreate>
     a12:	90 93 9f 08 	sts	0x089F, r25
     a16:	80 93 9e 08 	sts	0x089E, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	5e d7       	rcall	.+3772   	; 0x18da <xQueueCreateMutex>
     a1e:	90 93 9d 08 	sts	0x089D, r25
     a22:	80 93 9c 08 	sts	0x089C, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a26:	20 e0       	ldi	r18, 0x00	; 0
     a28:	40 e0       	ldi	r20, 0x00	; 0
     a2a:	50 e0       	ldi	r21, 0x00	; 0
     a2c:	60 e0       	ldi	r22, 0x00	; 0
     a2e:	70 e0       	ldi	r23, 0x00	; 0
     a30:	c1 c6       	rjmp	.+3458   	; 0x17b4 <xQueueGenericSend>
     a32:	08 95       	ret

00000a34 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a34:	cf 93       	push	r28
     a36:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a38:	20 e0       	ldi	r18, 0x00	; 0
     a3a:	4f ef       	ldi	r20, 0xFF	; 255
     a3c:	5f ef       	ldi	r21, 0xFF	; 255
     a3e:	60 e0       	ldi	r22, 0x00	; 0
     a40:	70 e0       	ldi	r23, 0x00	; 0
     a42:	80 91 9c 08 	lds	r24, 0x089C
     a46:	90 91 9d 08 	lds	r25, 0x089D
     a4a:	ac d7       	rcall	.+3928   	; 0x19a4 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a4c:	ec e7       	ldi	r30, 0x7C	; 124
     a4e:	f0 e0       	ldi	r31, 0x00	; 0
     a50:	80 81       	ld	r24, Z
     a52:	9c 2f       	mov	r25, r28
     a54:	9f 71       	andi	r25, 0x1F	; 31
     a56:	80 76       	andi	r24, 0x60	; 96
     a58:	89 2b       	or	r24, r25
     a5a:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a5c:	eb e7       	ldi	r30, 0x7B	; 123
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	20 81       	ld	r18, Z
     a62:	c0 72       	andi	r28, 0x20	; 32
     a64:	8c 2f       	mov	r24, r28
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	95 95       	asr	r25
     a6a:	87 95       	ror	r24
     a6c:	95 95       	asr	r25
     a6e:	87 95       	ror	r24
     a70:	92 2f       	mov	r25, r18
     a72:	90 76       	andi	r25, 0x60	; 96
     a74:	89 2b       	or	r24, r25
     a76:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a78:	ea e7       	ldi	r30, 0x7A	; 122
     a7a:	f0 e0       	ldi	r31, 0x00	; 0
     a7c:	80 81       	ld	r24, Z
     a7e:	80 64       	ori	r24, 0x40	; 64
     a80:	80 83       	st	Z, r24
}
     a82:	cf 91       	pop	r28
     a84:	08 95       	ret

00000a86 <myADC_readADC>:

int myADC_readADC(char channel)
{
     a86:	cf 93       	push	r28
     a88:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a8a:	20 e0       	ldi	r18, 0x00	; 0
     a8c:	4f ef       	ldi	r20, 0xFF	; 255
     a8e:	5f ef       	ldi	r21, 0xFF	; 255
     a90:	60 e0       	ldi	r22, 0x00	; 0
     a92:	70 e0       	ldi	r23, 0x00	; 0
     a94:	80 91 9e 08 	lds	r24, 0x089E
     a98:	90 91 9f 08 	lds	r25, 0x089F
     a9c:	83 d7       	rcall	.+3846   	; 0x19a4 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     a9e:	c0 91 9b 08 	lds	r28, 0x089B
     aa2:	c3 70       	andi	r28, 0x03	; 3
     aa4:	d0 e0       	ldi	r29, 0x00	; 0
     aa6:	dc 2f       	mov	r29, r28
     aa8:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     aaa:	80 91 9a 08 	lds	r24, 0x089A
     aae:	c8 0f       	add	r28, r24
     ab0:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     ab2:	20 e0       	ldi	r18, 0x00	; 0
     ab4:	40 e0       	ldi	r20, 0x00	; 0
     ab6:	50 e0       	ldi	r21, 0x00	; 0
     ab8:	60 e0       	ldi	r22, 0x00	; 0
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	80 91 9c 08 	lds	r24, 0x089C
     ac0:	90 91 9d 08 	lds	r25, 0x089D
     ac4:	77 d6       	rcall	.+3310   	; 0x17b4 <xQueueGenericSend>
	
	return adcReading;
     ac6:	ce 01       	movw	r24, r28
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	08 95       	ret

00000ace <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     ace:	cf 93       	push	r28
     ad0:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     ad2:	b0 df       	rcall	.-160    	; 0xa34 <myADC_startADC>
	return myADC_readADC(channel);
     ad4:	8c 2f       	mov	r24, r28
     ad6:	d7 df       	rcall	.-82     	; 0xa86 <myADC_readADC>
}
     ad8:	cf 91       	pop	r28
     ada:	08 95       	ret

00000adc <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     adc:	9c 01       	movw	r18, r24
     ade:	24 5f       	subi	r18, 0xF4	; 244
     ae0:	3f 4f       	sbci	r19, 0xFF	; 255
     ae2:	26 17       	cp	r18, r22
     ae4:	37 07       	cpc	r19, r23
     ae6:	44 f0       	brlt	.+16     	; 0xaf8 <detectStairs+0x1c>
     ae8:	28 51       	subi	r18, 0x18	; 24
     aea:	31 09       	sbc	r19, r1
     aec:	81 e0       	ldi	r24, 0x01	; 1
     aee:	62 17       	cp	r22, r18
     af0:	73 07       	cpc	r23, r19
     af2:	1c f0       	brlt	.+6      	; 0xafa <detectStairs+0x1e>
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	08 95       	ret
	{
		return 1; // stairs found
     af8:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     afa:	08 95       	ret

00000afc <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     afc:	0f 93       	push	r16
     afe:	1f 93       	push	r17
     b00:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     b02:	83 81       	ldd	r24, Z+3	; 0x03
     b04:	88 23       	and	r24, r24
     b06:	39 f0       	breq	.+14     	; 0xb16 <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b08:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b0a:	e2 e0       	ldi	r30, 0x02	; 2
     b0c:	f1 e0       	ldi	r31, 0x01	; 1
     b0e:	80 81       	ld	r24, Z
     b10:	80 61       	ori	r24, 0x10	; 16
     b12:	80 83       	st	Z, r24
     b14:	57 c0       	rjmp	.+174    	; 0xbc4 <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b16:	80 81       	ld	r24, Z
     b18:	88 23       	and	r24, r24
     b1a:	b1 f1       	breq	.+108    	; 0xb88 <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b1c:	81 81       	ldd	r24, Z+1	; 0x01
     b1e:	81 11       	cpse	r24, r1
     b20:	18 c0       	rjmp	.+48     	; 0xb52 <obstacleAvoidance+0x56>
     b22:	82 81       	ldd	r24, Z+2	; 0x02
     b24:	81 11       	cpse	r24, r1
     b26:	24 c0       	rjmp	.+72     	; 0xb70 <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar + 14) // if right sonar greater than....
     b28:	cb 01       	movw	r24, r22
     b2a:	0e 96       	adiw	r24, 0x0e	; 14
     b2c:	84 17       	cp	r24, r20
     b2e:	95 07       	cpc	r25, r21
     b30:	3c f4       	brge	.+14     	; 0xb40 <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b32:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b34:	a2 e0       	ldi	r26, 0x02	; 2
     b36:	b1 e0       	ldi	r27, 0x01	; 1
     b38:	8c 91       	ld	r24, X
     b3a:	80 61       	ori	r24, 0x10	; 16
     b3c:	8c 93       	st	X, r24
     b3e:	06 c0       	rjmp	.+12     	; 0xb4c <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b40:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b42:	a2 e0       	ldi	r26, 0x02	; 2
     b44:	b1 e0       	ldi	r27, 0x01	; 1
     b46:	8c 91       	ld	r24, X
     b48:	8f 7e       	andi	r24, 0xEF	; 239
     b4a:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b4c:	81 81       	ldd	r24, Z+1	; 0x01
     b4e:	88 23       	and	r24, r24
     b50:	b1 f1       	breq	.+108    	; 0xbbe <obstacleAvoidance+0xc2>
     b52:	82 81       	ldd	r24, Z+2	; 0x02
     b54:	81 11       	cpse	r24, r1
     b56:	36 c0       	rjmp	.+108    	; 0xbc4 <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b58:	46 1b       	sub	r20, r22
     b5a:	57 0b       	sbc	r21, r23
     b5c:	49 30       	cpi	r20, 0x09	; 9
     b5e:	51 05       	cpc	r21, r1
     b60:	8c f1       	brlt	.+98     	; 0xbc4 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     b62:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     b64:	e2 e0       	ldi	r30, 0x02	; 2
     b66:	f1 e0       	ldi	r31, 0x01	; 1
     b68:	80 81       	ld	r24, Z
     b6a:	80 61       	ori	r24, 0x10	; 16
     b6c:	80 83       	st	Z, r24
     b6e:	2a c0       	rjmp	.+84     	; 0xbc4 <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     b70:	64 1b       	sub	r22, r20
     b72:	75 0b       	sbc	r23, r21
     b74:	69 30       	cpi	r22, 0x09	; 9
     b76:	71 05       	cpc	r23, r1
     b78:	2c f1       	brlt	.+74     	; 0xbc4 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     b7a:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     b7c:	e2 e0       	ldi	r30, 0x02	; 2
     b7e:	f1 e0       	ldi	r31, 0x01	; 1
     b80:	80 81       	ld	r24, Z
     b82:	8f 7e       	andi	r24, 0xEF	; 239
     b84:	80 83       	st	Z, r24
     b86:	1e c0       	rjmp	.+60     	; 0xbc4 <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     b88:	66 32       	cpi	r22, 0x26	; 38
     b8a:	71 05       	cpc	r23, r1
     b8c:	3c f4       	brge	.+14     	; 0xb9c <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     b8e:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     b90:	e2 e0       	ldi	r30, 0x02	; 2
     b92:	f1 e0       	ldi	r31, 0x01	; 1
     b94:	80 81       	ld	r24, Z
     b96:	80 61       	ori	r24, 0x10	; 16
     b98:	80 83       	st	Z, r24
     b9a:	14 c0       	rjmp	.+40     	; 0xbc4 <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     b9c:	44 31       	cpi	r20, 0x14	; 20
     b9e:	51 05       	cpc	r21, r1
     ba0:	3c f4       	brge	.+14     	; 0xbb0 <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     ba2:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     ba4:	e2 e0       	ldi	r30, 0x02	; 2
     ba6:	f1 e0       	ldi	r31, 0x01	; 1
     ba8:	80 81       	ld	r24, Z
     baa:	8f 7e       	andi	r24, 0xEF	; 239
     bac:	80 83       	st	Z, r24
     bae:	0a c0       	rjmp	.+20     	; 0xbc4 <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     bb0:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bb2:	e2 e0       	ldi	r30, 0x02	; 2
     bb4:	f1 e0       	ldi	r31, 0x01	; 1
     bb6:	80 81       	ld	r24, Z
     bb8:	8f 7e       	andi	r24, 0xEF	; 239
     bba:	80 83       	st	Z, r24
     bbc:	03 c0       	rjmp	.+6      	; 0xbc4 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     bbe:	82 81       	ldd	r24, Z+2	; 0x02
     bc0:	81 11       	cpse	r24, r1
     bc2:	d6 cf       	rjmp	.-84     	; 0xb70 <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     bc4:	1f 91       	pop	r17
     bc6:	0f 91       	pop	r16
     bc8:	08 95       	ret

00000bca <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     bca:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     bcc:	85 e0       	ldi	r24, 0x05	; 5
     bce:	db 01       	movw	r26, r22
     bd0:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     bd2:	86 e4       	ldi	r24, 0x46	; 70
     bd4:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     bd6:	8c e4       	ldi	r24, 0x4C	; 76
     bd8:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     bda:	82 e5       	ldi	r24, 0x52	; 82
     bdc:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     bde:	82 e4       	ldi	r24, 0x42	; 66
     be0:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     be2:	84 e5       	ldi	r24, 0x54	; 84
     be4:	84 83       	std	Z+4, r24	; 0x04
     be6:	08 95       	ret

00000be8 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     be8:	af 92       	push	r10
     bea:	bf 92       	push	r11
     bec:	cf 92       	push	r12
     bee:	df 92       	push	r13
     bf0:	ff 92       	push	r15
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	f6 2e       	mov	r15, r22
     bfc:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     bfe:	86 34       	cpi	r24, 0x46	; 70
     c00:	91 05       	cpc	r25, r1
     c02:	1c f4       	brge	.+6      	; 0xc0a <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     c04:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c06:	86 e4       	ldi	r24, 0x46	; 70
     c08:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c0a:	2e 31       	cpi	r18, 0x1E	; 30
     c0c:	31 05       	cpc	r19, r1
     c0e:	1c f4       	brge	.+6      	; 0xc16 <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     c10:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c12:	8c e4       	ldi	r24, 0x4C	; 76
     c14:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c16:	0e 31       	cpi	r16, 0x1E	; 30
     c18:	11 05       	cpc	r17, r1
     c1a:	1c f4       	brge	.+6      	; 0xc22 <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     c1c:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c1e:	82 e5       	ldi	r24, 0x52	; 82
     c20:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c22:	b5 01       	movw	r22, r10
     c24:	c6 01       	movw	r24, r12
     c26:	5a df       	rcall	.-332    	; 0xadc <detectStairs>
     c28:	88 23       	and	r24, r24
     c2a:	19 f0       	breq	.+6      	; 0xc32 <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c2c:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c2e:	82 e4       	ldi	r24, 0x42	; 66
     c30:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     c32:	8f 2d       	mov	r24, r15
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	1f 91       	pop	r17
     c3a:	0f 91       	pop	r16
     c3c:	ff 90       	pop	r15
     c3e:	df 90       	pop	r13
     c40:	cf 90       	pop	r12
     c42:	bf 90       	pop	r11
     c44:	af 90       	pop	r10
     c46:	08 95       	ret

00000c48 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c48:	42 df       	rcall	.-380    	; 0xace <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c4a:	bc 01       	movw	r22, r24
     c4c:	88 27       	eor	r24, r24
     c4e:	77 fd       	sbrc	r23, 7
     c50:	80 95       	com	r24
     c52:	98 2f       	mov	r25, r24
     c54:	0e 94 24 14 	call	0x2848	; 0x2848 <__floatsisf>
     c58:	29 e2       	ldi	r18, 0x29	; 41
     c5a:	3c e5       	ldi	r19, 0x5C	; 92
     c5c:	4f e6       	ldi	r20, 0x6F	; 111
     c5e:	5f eb       	ldi	r21, 0xBF	; 191
     c60:	0e 94 13 15 	call	0x2a26	; 0x2a26 <pow>
     c64:	22 e5       	ldi	r18, 0x52	; 82
     c66:	38 e6       	ldi	r19, 0x68	; 104
     c68:	46 e2       	ldi	r20, 0x26	; 38
     c6a:	56 e4       	ldi	r21, 0x46	; 70
     c6c:	0e 94 b0 14 	call	0x2960	; 0x2960 <__mulsf3>
     c70:	20 e0       	ldi	r18, 0x00	; 0
     c72:	30 e0       	ldi	r19, 0x00	; 0
     c74:	40 e2       	ldi	r20, 0x20	; 32
     c76:	51 e4       	ldi	r21, 0x41	; 65
     c78:	0e 94 8c 13 	call	0x2718	; 0x2718 <__subsf3>
     c7c:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <__fixsfsi>
     c80:	cb 01       	movw	r24, r22
     c82:	68 3e       	cpi	r22, 0xE8	; 232
     c84:	23 e0       	ldi	r18, 0x03	; 3
     c86:	72 07       	cpc	r23, r18
     c88:	14 f0       	brlt	.+4      	; 0xc8e <mySharpIR_Read+0x46>
     c8a:	87 ee       	ldi	r24, 0xE7	; 231
     c8c:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     c8e:	08 95       	ret

00000c90 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     c90:	fb 01       	movw	r30, r22
     c92:	20 81       	ld	r18, Z
     c94:	31 81       	ldd	r19, Z+1	; 0x01
     c96:	50 e0       	ldi	r21, 0x00	; 0
     c98:	b9 01       	movw	r22, r18
     c9a:	64 0f       	add	r22, r20
     c9c:	75 1f       	adc	r23, r21
     c9e:	68 17       	cp	r22, r24
     ca0:	79 07       	cpc	r23, r25
     ca2:	4c f0       	brlt	.+18     	; 0xcb6 <checkWithinRange+0x26>
     ca4:	24 1b       	sub	r18, r20
     ca6:	35 0b       	sbc	r19, r21
     ca8:	41 e0       	ldi	r20, 0x01	; 1
     caa:	82 17       	cp	r24, r18
     cac:	93 07       	cpc	r25, r19
     cae:	0c f0       	brlt	.+2      	; 0xcb2 <checkWithinRange+0x22>
     cb0:	40 e0       	ldi	r20, 0x00	; 0
     cb2:	84 2f       	mov	r24, r20
     cb4:	08 95       	ret
     cb6:	81 e0       	ldi	r24, 0x01	; 1
}
     cb8:	08 95       	ret

00000cba <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     cba:	0f 93       	push	r16
     cbc:	1f 93       	push	r17
     cbe:	cf 93       	push	r28
     cc0:	df 93       	push	r29
     cc2:	8c 01       	movw	r16, r24
     cc4:	eb 01       	movw	r28, r22
	static uint8_t i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     cc6:	45 e0       	ldi	r20, 0x05	; 5
     cc8:	bc 01       	movw	r22, r24
     cca:	ce 01       	movw	r24, r28
     ccc:	e1 df       	rcall	.-62     	; 0xc90 <checkWithinRange>
     cce:	88 23       	and	r24, r24
     cd0:	29 f0       	breq	.+10     	; 0xcdc <mySharpIR_ReCalibrate+0x22>
     cd2:	80 91 1c 08 	lds	r24, 0x081C
     cd6:	81 11       	cpse	r24, r1
     cd8:	0a c0       	rjmp	.+20     	; 0xcee <mySharpIR_ReCalibrate+0x34>
     cda:	3f c0       	rjmp	.+126    	; 0xd5a <mySharpIR_ReCalibrate+0xa0>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     cdc:	80 91 1c 08 	lds	r24, 0x081C
     ce0:	81 11       	cpse	r24, r1
     ce2:	05 c0       	rjmp	.+10     	; 0xcee <mySharpIR_ReCalibrate+0x34>
	{
		checkReading[0] = reading;
     ce4:	d0 93 19 08 	sts	0x0819, r29
     ce8:	c0 93 18 08 	sts	0x0818, r28
     cec:	2c c0       	rjmp	.+88     	; 0xd46 <mySharpIR_ReCalibrate+0x8c>
	}
	else if (i == CALIBRATE_COUNT/2)
     cee:	8a 30       	cpi	r24, 0x0A	; 10
     cf0:	99 f4       	brne	.+38     	; 0xd18 <mySharpIR_ReCalibrate+0x5e>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     cf2:	45 e0       	ldi	r20, 0x05	; 5
     cf4:	68 e1       	ldi	r22, 0x18	; 24
     cf6:	78 e0       	ldi	r23, 0x08	; 8
     cf8:	ce 01       	movw	r24, r28
     cfa:	ca df       	rcall	.-108    	; 0xc90 <checkWithinRange>
     cfc:	88 23       	and	r24, r24
     cfe:	39 f0       	breq	.+14     	; 0xd0e <mySharpIR_ReCalibrate+0x54>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d00:	d0 93 19 08 	sts	0x0819, r29
     d04:	c0 93 18 08 	sts	0x0818, r28
			i = 0; // reset to count...
     d08:	10 92 1c 08 	sts	0x081C, r1
     d0c:	1c c0       	rjmp	.+56     	; 0xd46 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d0e:	d0 93 1b 08 	sts	0x081B, r29
     d12:	c0 93 1a 08 	sts	0x081A, r28
     d16:	17 c0       	rjmp	.+46     	; 0xd46 <mySharpIR_ReCalibrate+0x8c>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d18:	84 31       	cpi	r24, 0x14	; 20
     d1a:	a9 f4       	brne	.+42     	; 0xd46 <mySharpIR_ReCalibrate+0x8c>
	{
		i = 0; // reset to count..
     d1c:	10 92 1c 08 	sts	0x081C, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d20:	45 e0       	ldi	r20, 0x05	; 5
     d22:	68 e1       	ldi	r22, 0x18	; 24
     d24:	78 e0       	ldi	r23, 0x08	; 8
     d26:	ce 01       	movw	r24, r28
     d28:	b3 df       	rcall	.-154    	; 0xc90 <checkWithinRange>
     d2a:	88 23       	and	r24, r24
     d2c:	29 f0       	breq	.+10     	; 0xd38 <mySharpIR_ReCalibrate+0x7e>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d2e:	d0 93 19 08 	sts	0x0819, r29
     d32:	c0 93 18 08 	sts	0x0818, r28
     d36:	07 c0       	rjmp	.+14     	; 0xd46 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     d38:	80 91 18 08 	lds	r24, 0x0818
     d3c:	90 91 19 08 	lds	r25, 0x0819
     d40:	f8 01       	movw	r30, r16
     d42:	91 83       	std	Z+1, r25	; 0x01
     d44:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     d46:	80 91 1c 08 	lds	r24, 0x081C
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	01 96       	adiw	r24, 0x01	; 1
     d4e:	64 e1       	ldi	r22, 0x14	; 20
     d50:	70 e0       	ldi	r23, 0x00	; 0
     d52:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
     d56:	80 93 1c 08 	sts	0x081C, r24
}
     d5a:	df 91       	pop	r29
     d5c:	cf 91       	pop	r28
     d5e:	1f 91       	pop	r17
     d60:	0f 91       	pop	r16
     d62:	08 95       	ret

00000d64 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     d64:	90 93 a5 08 	sts	0x08A5, r25
     d68:	80 93 a4 08 	sts	0x08A4, r24
     d6c:	fc 01       	movw	r30, r24
     d6e:	80 81       	ld	r24, Z
     d70:	91 81       	ldd	r25, Z+1	; 0x01
     d72:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vTaskSuspend>
     d76:	43 e0       	ldi	r20, 0x03	; 3
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	ee d4       	rcall	.+2524   	; 0x175a <xQueueGenericCreate>
     d7e:	90 93 a1 08 	sts	0x08A1, r25
     d82:	80 93 a0 08 	sts	0x08A0, r24
     d86:	43 e0       	ldi	r20, 0x03	; 3
     d88:	60 e0       	ldi	r22, 0x00	; 0
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	e6 d4       	rcall	.+2508   	; 0x175a <xQueueGenericCreate>
     d8e:	90 93 a3 08 	sts	0x08A3, r25
     d92:	80 93 a2 08 	sts	0x08A2, r24
     d96:	08 95       	ret

00000d98 <myTimer_Read>:
     d98:	86 b5       	in	r24, 0x26	; 38
     d9a:	08 95       	ret

00000d9c <myTimer_DelayMicro>:
     d9c:	46 b5       	in	r20, 0x26	; 38
     d9e:	50 e0       	ldi	r21, 0x00	; 0
     da0:	9c 01       	movw	r18, r24
     da2:	99 23       	and	r25, r25
     da4:	14 f4       	brge	.+4      	; 0xdaa <myTimer_DelayMicro+0xe>
     da6:	2d 5f       	subi	r18, 0xFD	; 253
     da8:	3f 4f       	sbci	r19, 0xFF	; 255
     daa:	35 95       	asr	r19
     dac:	27 95       	ror	r18
     dae:	35 95       	asr	r19
     db0:	27 95       	ror	r18
     db2:	24 0f       	add	r18, r20
     db4:	35 1f       	adc	r19, r21
     db6:	30 93 04 02 	sts	0x0204, r19
     dba:	20 93 03 02 	sts	0x0203, r18
     dbe:	e0 91 a4 08 	lds	r30, 0x08A4
     dc2:	f0 91 a5 08 	lds	r31, 0x08A5
     dc6:	80 81       	ld	r24, Z
     dc8:	91 81       	ldd	r25, Z+1	; 0x01
     dca:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <vTaskResume>
     dce:	20 e0       	ldi	r18, 0x00	; 0
     dd0:	42 e0       	ldi	r20, 0x02	; 2
     dd2:	50 e0       	ldi	r21, 0x00	; 0
     dd4:	60 e0       	ldi	r22, 0x00	; 0
     dd6:	70 e0       	ldi	r23, 0x00	; 0
     dd8:	80 91 a0 08 	lds	r24, 0x08A0
     ddc:	90 91 a1 08 	lds	r25, 0x08A1
     de0:	e1 c5       	rjmp	.+3010   	; 0x19a4 <xQueueGenericReceive>
     de2:	08 95       	ret

00000de4 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     de4:	cf 93       	push	r28
     de6:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     de8:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     dea:	c1 11       	cpse	r28, r1
     dec:	22 c0       	rjmp	.+68     	; 0xe32 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     dee:	80 91 03 02 	lds	r24, 0x0203
     df2:	90 91 04 02 	lds	r25, 0x0204
     df6:	88 38       	cpi	r24, 0x88	; 136
     df8:	93 41       	sbci	r25, 0x13	; 19
     dfa:	51 f0       	breq	.+20     	; 0xe10 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     dfc:	80 91 03 02 	lds	r24, 0x0203
     e00:	90 91 04 02 	lds	r25, 0x0204
     e04:	8a 5f       	subi	r24, 0xFA	; 250
     e06:	91 09       	sbc	r25, r1
     e08:	90 93 04 02 	sts	0x0204, r25
     e0c:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e10:	80 91 01 02 	lds	r24, 0x0201
     e14:	90 91 02 02 	lds	r25, 0x0202
     e18:	88 38       	cpi	r24, 0x88	; 136
     e1a:	93 41       	sbci	r25, 0x13	; 19
     e1c:	51 f0       	breq	.+20     	; 0xe32 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e1e:	80 91 01 02 	lds	r24, 0x0201
     e22:	90 91 02 02 	lds	r25, 0x0202
     e26:	8a 5f       	subi	r24, 0xFA	; 250
     e28:	91 09       	sbc	r25, r1
     e2a:	90 93 02 02 	sts	0x0202, r25
     e2e:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e32:	d0 e0       	ldi	r29, 0x00	; 0
     e34:	80 91 03 02 	lds	r24, 0x0203
     e38:	90 91 04 02 	lds	r25, 0x0204
     e3c:	8c 17       	cp	r24, r28
     e3e:	9d 07       	cpc	r25, r29
     e40:	84 f4       	brge	.+32     	; 0xe62 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     e42:	88 e8       	ldi	r24, 0x88	; 136
     e44:	93 e1       	ldi	r25, 0x13	; 19
     e46:	90 93 04 02 	sts	0x0204, r25
     e4a:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     e4e:	20 e0       	ldi	r18, 0x00	; 0
     e50:	40 e0       	ldi	r20, 0x00	; 0
     e52:	50 e0       	ldi	r21, 0x00	; 0
     e54:	60 e0       	ldi	r22, 0x00	; 0
     e56:	70 e0       	ldi	r23, 0x00	; 0
     e58:	80 91 a0 08 	lds	r24, 0x08A0
     e5c:	90 91 a1 08 	lds	r25, 0x08A1
     e60:	a9 d4       	rcall	.+2386   	; 0x17b4 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     e62:	80 91 01 02 	lds	r24, 0x0201
     e66:	90 91 02 02 	lds	r25, 0x0202
     e6a:	8c 17       	cp	r24, r28
     e6c:	9d 07       	cpc	r25, r29
     e6e:	84 f4       	brge	.+32     	; 0xe90 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     e70:	88 e8       	ldi	r24, 0x88	; 136
     e72:	93 e1       	ldi	r25, 0x13	; 19
     e74:	90 93 02 02 	sts	0x0202, r25
     e78:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     e7c:	20 e0       	ldi	r18, 0x00	; 0
     e7e:	40 e0       	ldi	r20, 0x00	; 0
     e80:	50 e0       	ldi	r21, 0x00	; 0
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	70 e0       	ldi	r23, 0x00	; 0
     e86:	80 91 a2 08 	lds	r24, 0x08A2
     e8a:	90 91 a3 08 	lds	r25, 0x08A3
     e8e:	92 d4       	rcall	.+2340   	; 0x17b4 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     e90:	80 91 03 02 	lds	r24, 0x0203
     e94:	90 91 04 02 	lds	r25, 0x0204
     e98:	88 38       	cpi	r24, 0x88	; 136
     e9a:	93 41       	sbci	r25, 0x13	; 19
     e9c:	79 f4       	brne	.+30     	; 0xebc <myTimer_DelayChecker+0xd8>
     e9e:	80 91 01 02 	lds	r24, 0x0201
     ea2:	90 91 02 02 	lds	r25, 0x0202
     ea6:	88 38       	cpi	r24, 0x88	; 136
     ea8:	93 41       	sbci	r25, 0x13	; 19
     eaa:	41 f4       	brne	.+16     	; 0xebc <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     eac:	e0 91 a4 08 	lds	r30, 0x08A4
     eb0:	f0 91 a5 08 	lds	r31, 0x08A5
     eb4:	80 81       	ld	r24, Z
     eb6:	91 81       	ldd	r25, Z+1	; 0x01
     eb8:	0e 94 d6 11 	call	0x23ac	; 0x23ac <vTaskSuspend>
	}
     ebc:	df 91       	pop	r29
     ebe:	cf 91       	pop	r28
     ec0:	08 95       	ret

00000ec2 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     ec2:	1f 92       	push	r1
     ec4:	0f 92       	push	r0
     ec6:	0f b6       	in	r0, 0x3f	; 63
     ec8:	0f 92       	push	r0
     eca:	11 24       	eor	r1, r1
     ecc:	0b b6       	in	r0, 0x3b	; 59
     ece:	0f 92       	push	r0
     ed0:	2f 93       	push	r18
     ed2:	3f 93       	push	r19
     ed4:	4f 93       	push	r20
     ed6:	5f 93       	push	r21
     ed8:	6f 93       	push	r22
     eda:	7f 93       	push	r23
     edc:	8f 93       	push	r24
     ede:	9f 93       	push	r25
     ee0:	af 93       	push	r26
     ee2:	bf 93       	push	r27
     ee4:	ef 93       	push	r30
     ee6:	ff 93       	push	r31
     ee8:	60 91 ce 00 	lds	r22, 0x00CE
     eec:	8b e3       	ldi	r24, 0x3B	; 59
     eee:	99 e0       	ldi	r25, 0x09	; 9
     ef0:	2f d6       	rcall	.+3166   	; 0x1b50 <ringBufferPush>
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	40 e0       	ldi	r20, 0x00	; 0
     ef6:	50 e0       	ldi	r21, 0x00	; 0
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	70 e0       	ldi	r23, 0x00	; 0
     efc:	80 91 2f 09 	lds	r24, 0x092F
     f00:	90 91 30 09 	lds	r25, 0x0930
     f04:	15 d5       	rcall	.+2602   	; 0x1930 <xQueueGenericSendFromISR>
     f06:	8b e3       	ldi	r24, 0x3B	; 59
     f08:	99 e0       	ldi	r25, 0x09	; 9
     f0a:	39 d6       	rcall	.+3186   	; 0x1b7e <ringBufferFull>
     f0c:	ff 91       	pop	r31
     f0e:	ef 91       	pop	r30
     f10:	bf 91       	pop	r27
     f12:	af 91       	pop	r26
     f14:	9f 91       	pop	r25
     f16:	8f 91       	pop	r24
     f18:	7f 91       	pop	r23
     f1a:	6f 91       	pop	r22
     f1c:	5f 91       	pop	r21
     f1e:	4f 91       	pop	r20
     f20:	3f 91       	pop	r19
     f22:	2f 91       	pop	r18
     f24:	0f 90       	pop	r0
     f26:	0b be       	out	0x3b, r0	; 59
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	0f 90       	pop	r0
     f2e:	1f 90       	pop	r1
     f30:	18 95       	reti

00000f32 <__vector_25>:
     f32:	1f 92       	push	r1
     f34:	0f 92       	push	r0
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	0f 92       	push	r0
     f3a:	11 24       	eor	r1, r1
     f3c:	0b b6       	in	r0, 0x3b	; 59
     f3e:	0f 92       	push	r0
     f40:	2f 93       	push	r18
     f42:	3f 93       	push	r19
     f44:	4f 93       	push	r20
     f46:	5f 93       	push	r21
     f48:	6f 93       	push	r22
     f4a:	7f 93       	push	r23
     f4c:	8f 93       	push	r24
     f4e:	9f 93       	push	r25
     f50:	af 93       	push	r26
     f52:	bf 93       	push	r27
     f54:	ef 93       	push	r30
     f56:	ff 93       	push	r31
     f58:	60 91 c6 00 	lds	r22, 0x00C6
     f5c:	86 ec       	ldi	r24, 0xC6	; 198
     f5e:	98 e0       	ldi	r25, 0x08	; 8
     f60:	f7 d5       	rcall	.+3054   	; 0x1b50 <ringBufferPush>
     f62:	20 e0       	ldi	r18, 0x00	; 0
     f64:	40 e0       	ldi	r20, 0x00	; 0
     f66:	50 e0       	ldi	r21, 0x00	; 0
     f68:	60 e0       	ldi	r22, 0x00	; 0
     f6a:	70 e0       	ldi	r23, 0x00	; 0
     f6c:	80 91 2f 09 	lds	r24, 0x092F
     f70:	90 91 30 09 	lds	r25, 0x0930
     f74:	dd d4       	rcall	.+2490   	; 0x1930 <xQueueGenericSendFromISR>
     f76:	86 ec       	ldi	r24, 0xC6	; 198
     f78:	98 e0       	ldi	r25, 0x08	; 8
     f7a:	01 d6       	rcall	.+3074   	; 0x1b7e <ringBufferFull>
     f7c:	ff 91       	pop	r31
     f7e:	ef 91       	pop	r30
     f80:	bf 91       	pop	r27
     f82:	af 91       	pop	r26
     f84:	9f 91       	pop	r25
     f86:	8f 91       	pop	r24
     f88:	7f 91       	pop	r23
     f8a:	6f 91       	pop	r22
     f8c:	5f 91       	pop	r21
     f8e:	4f 91       	pop	r20
     f90:	3f 91       	pop	r19
     f92:	2f 91       	pop	r18
     f94:	0f 90       	pop	r0
     f96:	0b be       	out	0x3b, r0	; 59
     f98:	0f 90       	pop	r0
     f9a:	0f be       	out	0x3f, r0	; 63
     f9c:	0f 90       	pop	r0
     f9e:	1f 90       	pop	r1
     fa0:	18 95       	reti

00000fa2 <__vector_37>:
     fa2:	1f 92       	push	r1
     fa4:	0f 92       	push	r0
     fa6:	0f b6       	in	r0, 0x3f	; 63
     fa8:	0f 92       	push	r0
     faa:	11 24       	eor	r1, r1
     fac:	0b b6       	in	r0, 0x3b	; 59
     fae:	0f 92       	push	r0
     fb0:	2f 93       	push	r18
     fb2:	3f 93       	push	r19
     fb4:	4f 93       	push	r20
     fb6:	5f 93       	push	r21
     fb8:	6f 93       	push	r22
     fba:	7f 93       	push	r23
     fbc:	8f 93       	push	r24
     fbe:	9f 93       	push	r25
     fc0:	af 93       	push	r26
     fc2:	bf 93       	push	r27
     fc4:	ef 93       	push	r30
     fc6:	ff 93       	push	r31
     fc8:	81 e3       	ldi	r24, 0x31	; 49
     fca:	99 e0       	ldi	r25, 0x09	; 9
     fcc:	df d5       	rcall	.+3006   	; 0x1b8c <ringBufferNotEmpty>
     fce:	88 23       	and	r24, r24
     fd0:	31 f0       	breq	.+12     	; 0xfde <__vector_37+0x3c>
     fd2:	81 e3       	ldi	r24, 0x31	; 49
     fd4:	99 e0       	ldi	r25, 0x09	; 9
     fd6:	aa d5       	rcall	.+2900   	; 0x1b2c <ringBufferPop>
     fd8:	80 93 ce 00 	sts	0x00CE, r24
     fdc:	05 c0       	rjmp	.+10     	; 0xfe8 <__vector_37+0x46>
     fde:	e9 ec       	ldi	r30, 0xC9	; 201
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	8f 7d       	andi	r24, 0xDF	; 223
     fe6:	80 83       	st	Z, r24
     fe8:	ff 91       	pop	r31
     fea:	ef 91       	pop	r30
     fec:	bf 91       	pop	r27
     fee:	af 91       	pop	r26
     ff0:	9f 91       	pop	r25
     ff2:	8f 91       	pop	r24
     ff4:	7f 91       	pop	r23
     ff6:	6f 91       	pop	r22
     ff8:	5f 91       	pop	r21
     ffa:	4f 91       	pop	r20
     ffc:	3f 91       	pop	r19
     ffe:	2f 91       	pop	r18
    1000:	0f 90       	pop	r0
    1002:	0b be       	out	0x3b, r0	; 59
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	0f 90       	pop	r0
    100a:	1f 90       	pop	r1
    100c:	18 95       	reti

0000100e <__vector_26>:
    100e:	1f 92       	push	r1
    1010:	0f 92       	push	r0
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	0f 92       	push	r0
    1016:	11 24       	eor	r1, r1
    1018:	0b b6       	in	r0, 0x3b	; 59
    101a:	0f 92       	push	r0
    101c:	2f 93       	push	r18
    101e:	3f 93       	push	r19
    1020:	4f 93       	push	r20
    1022:	5f 93       	push	r21
    1024:	6f 93       	push	r22
    1026:	7f 93       	push	r23
    1028:	8f 93       	push	r24
    102a:	9f 93       	push	r25
    102c:	af 93       	push	r26
    102e:	bf 93       	push	r27
    1030:	ef 93       	push	r30
    1032:	ff 93       	push	r31
    1034:	86 e3       	ldi	r24, 0x36	; 54
    1036:	99 e0       	ldi	r25, 0x09	; 9
    1038:	a9 d5       	rcall	.+2898   	; 0x1b8c <ringBufferNotEmpty>
    103a:	88 23       	and	r24, r24
    103c:	31 f0       	breq	.+12     	; 0x104a <__vector_26+0x3c>
    103e:	86 e3       	ldi	r24, 0x36	; 54
    1040:	99 e0       	ldi	r25, 0x09	; 9
    1042:	74 d5       	rcall	.+2792   	; 0x1b2c <ringBufferPop>
    1044:	80 93 c6 00 	sts	0x00C6, r24
    1048:	05 c0       	rjmp	.+10     	; 0x1054 <__vector_26+0x46>
    104a:	e1 ec       	ldi	r30, 0xC1	; 193
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	80 81       	ld	r24, Z
    1050:	8f 7d       	andi	r24, 0xDF	; 223
    1052:	80 83       	st	Z, r24
    1054:	ff 91       	pop	r31
    1056:	ef 91       	pop	r30
    1058:	bf 91       	pop	r27
    105a:	af 91       	pop	r26
    105c:	9f 91       	pop	r25
    105e:	8f 91       	pop	r24
    1060:	7f 91       	pop	r23
    1062:	6f 91       	pop	r22
    1064:	5f 91       	pop	r21
    1066:	4f 91       	pop	r20
    1068:	3f 91       	pop	r19
    106a:	2f 91       	pop	r18
    106c:	0f 90       	pop	r0
    106e:	0b be       	out	0x3b, r0	; 59
    1070:	0f 90       	pop	r0
    1072:	0f be       	out	0x3f, r0	; 63
    1074:	0f 90       	pop	r0
    1076:	1f 90       	pop	r1
    1078:	18 95       	reti

0000107a <myUSART_USART0_Init>:
    107a:	10 92 c5 00 	sts	0x00C5, r1
    107e:	87 e6       	ldi	r24, 0x67	; 103
    1080:	80 93 c4 00 	sts	0x00C4, r24
    1084:	88 eb       	ldi	r24, 0xB8	; 184
    1086:	80 93 c1 00 	sts	0x00C1, r24
    108a:	86 e0       	ldi	r24, 0x06	; 6
    108c:	80 93 c2 00 	sts	0x00C2, r24
    1090:	40 e2       	ldi	r20, 0x20	; 32
    1092:	6d ee       	ldi	r22, 0xED	; 237
    1094:	78 e0       	ldi	r23, 0x08	; 8
    1096:	86 ec       	ldi	r24, 0xC6	; 198
    1098:	98 e0       	ldi	r25, 0x08	; 8
    109a:	37 d5       	rcall	.+2670   	; 0x1b0a <ringBufferInit>
    109c:	40 e2       	ldi	r20, 0x20	; 32
    109e:	6b ec       	ldi	r22, 0xCB	; 203
    10a0:	78 e0       	ldi	r23, 0x08	; 8
    10a2:	86 e3       	ldi	r24, 0x36	; 54
    10a4:	99 e0       	ldi	r25, 0x09	; 9
    10a6:	31 d5       	rcall	.+2658   	; 0x1b0a <ringBufferInit>
    10a8:	43 e0       	ldi	r20, 0x03	; 3
    10aa:	60 e0       	ldi	r22, 0x00	; 0
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	55 d3       	rcall	.+1706   	; 0x175a <xQueueGenericCreate>
    10b0:	90 93 2e 09 	sts	0x092E, r25
    10b4:	80 93 2d 09 	sts	0x092D, r24
    10b8:	08 95       	ret

000010ba <myUSART_USART1_Init>:
    10ba:	10 92 cd 00 	sts	0x00CD, r1
    10be:	87 e6       	ldi	r24, 0x67	; 103
    10c0:	80 93 cc 00 	sts	0x00CC, r24
    10c4:	88 eb       	ldi	r24, 0xB8	; 184
    10c6:	80 93 c9 00 	sts	0x00C9, r24
    10ca:	86 e0       	ldi	r24, 0x06	; 6
    10cc:	80 93 ca 00 	sts	0x00CA, r24
    10d0:	40 e2       	ldi	r20, 0x20	; 32
    10d2:	66 ea       	ldi	r22, 0xA6	; 166
    10d4:	78 e0       	ldi	r23, 0x08	; 8
    10d6:	8b e3       	ldi	r24, 0x3B	; 59
    10d8:	99 e0       	ldi	r25, 0x09	; 9
    10da:	17 d5       	rcall	.+2606   	; 0x1b0a <ringBufferInit>
    10dc:	40 e2       	ldi	r20, 0x20	; 32
    10de:	6d e0       	ldi	r22, 0x0D	; 13
    10e0:	79 e0       	ldi	r23, 0x09	; 9
    10e2:	81 e3       	ldi	r24, 0x31	; 49
    10e4:	99 e0       	ldi	r25, 0x09	; 9
    10e6:	11 d5       	rcall	.+2594   	; 0x1b0a <ringBufferInit>
    10e8:	43 e0       	ldi	r20, 0x03	; 3
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	35 d3       	rcall	.+1642   	; 0x175a <xQueueGenericCreate>
    10f0:	90 93 30 09 	sts	0x0930, r25
    10f4:	80 93 2f 09 	sts	0x092F, r24
    10f8:	43 e0       	ldi	r20, 0x03	; 3
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	2d d3       	rcall	.+1626   	; 0x175a <xQueueGenericCreate>
    1100:	90 93 ec 08 	sts	0x08EC, r25
    1104:	80 93 eb 08 	sts	0x08EB, r24
    1108:	08 95       	ret

0000110a <myUSART_transmitUSART0_c>:
    110a:	cf 93       	push	r28
    110c:	c8 2f       	mov	r28, r24
    110e:	86 e3       	ldi	r24, 0x36	; 54
    1110:	99 e0       	ldi	r25, 0x09	; 9
    1112:	35 d5       	rcall	.+2666   	; 0x1b7e <ringBufferFull>
    1114:	81 11       	cpse	r24, r1
    1116:	fb cf       	rjmp	.-10     	; 0x110e <myUSART_transmitUSART0_c+0x4>
    1118:	6c 2f       	mov	r22, r28
    111a:	86 e3       	ldi	r24, 0x36	; 54
    111c:	99 e0       	ldi	r25, 0x09	; 9
    111e:	18 d5       	rcall	.+2608   	; 0x1b50 <ringBufferPush>
    1120:	e1 ec       	ldi	r30, 0xC1	; 193
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	80 62       	ori	r24, 0x20	; 32
    1128:	80 83       	st	Z, r24
    112a:	e0 ec       	ldi	r30, 0xC0	; 192
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	80 64       	ori	r24, 0x40	; 64
    1132:	80 83       	st	Z, r24
    1134:	cf 91       	pop	r28
    1136:	08 95       	ret

00001138 <myUSART_transmitUSART1_c>:
    1138:	cf 93       	push	r28
    113a:	c8 2f       	mov	r28, r24
    113c:	81 e3       	ldi	r24, 0x31	; 49
    113e:	99 e0       	ldi	r25, 0x09	; 9
    1140:	1e d5       	rcall	.+2620   	; 0x1b7e <ringBufferFull>
    1142:	81 11       	cpse	r24, r1
    1144:	fb cf       	rjmp	.-10     	; 0x113c <myUSART_transmitUSART1_c+0x4>
    1146:	6c 2f       	mov	r22, r28
    1148:	81 e3       	ldi	r24, 0x31	; 49
    114a:	99 e0       	ldi	r25, 0x09	; 9
    114c:	01 d5       	rcall	.+2562   	; 0x1b50 <ringBufferPush>
    114e:	e9 ec       	ldi	r30, 0xC9	; 201
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	80 81       	ld	r24, Z
    1154:	80 62       	ori	r24, 0x20	; 32
    1156:	80 83       	st	Z, r24
    1158:	e8 ec       	ldi	r30, 0xC8	; 200
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	80 81       	ld	r24, Z
    115e:	80 64       	ori	r24, 0x40	; 64
    1160:	80 83       	st	Z, r24
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <myUSART_transmitUSART1>:
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	ec 01       	movw	r28, r24
    116c:	88 81       	ld	r24, Y
    116e:	88 23       	and	r24, r24
    1170:	29 f0       	breq	.+10     	; 0x117c <myUSART_transmitUSART1+0x16>
    1172:	21 96       	adiw	r28, 0x01	; 1
    1174:	e1 df       	rcall	.-62     	; 0x1138 <myUSART_transmitUSART1_c>
    1176:	89 91       	ld	r24, Y+
    1178:	81 11       	cpse	r24, r1
    117a:	fc cf       	rjmp	.-8      	; 0x1174 <myUSART_transmitUSART1+0xe>
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	08 95       	ret

00001182 <myUSART_transmitUSART0>:
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
    1186:	ec 01       	movw	r28, r24
    1188:	88 81       	ld	r24, Y
    118a:	88 23       	and	r24, r24
    118c:	29 f0       	breq	.+10     	; 0x1198 <myUSART_transmitUSART0+0x16>
    118e:	21 96       	adiw	r28, 0x01	; 1
    1190:	bc df       	rcall	.-136    	; 0x110a <myUSART_transmitUSART0_c>
    1192:	89 91       	ld	r24, Y+
    1194:	81 11       	cpse	r24, r1
    1196:	fc cf       	rjmp	.-8      	; 0x1190 <myUSART_transmitUSART0+0xe>
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <myUSART_receiveUSART1>:
    119e:	cf 93       	push	r28
    11a0:	20 e0       	ldi	r18, 0x00	; 0
    11a2:	4f ef       	ldi	r20, 0xFF	; 255
    11a4:	5f ef       	ldi	r21, 0xFF	; 255
    11a6:	60 e0       	ldi	r22, 0x00	; 0
    11a8:	70 e0       	ldi	r23, 0x00	; 0
    11aa:	80 91 2f 09 	lds	r24, 0x092F
    11ae:	90 91 30 09 	lds	r25, 0x0930
    11b2:	f8 d3       	rcall	.+2032   	; 0x19a4 <xQueueGenericReceive>
    11b4:	8b e3       	ldi	r24, 0x3B	; 59
    11b6:	99 e0       	ldi	r25, 0x09	; 9
    11b8:	b9 d4       	rcall	.+2418   	; 0x1b2c <ringBufferPop>
    11ba:	c8 2f       	mov	r28, r24
    11bc:	8b e3       	ldi	r24, 0x3B	; 59
    11be:	99 e0       	ldi	r25, 0x09	; 9
    11c0:	e5 d4       	rcall	.+2506   	; 0x1b8c <ringBufferNotEmpty>
    11c2:	88 23       	and	r24, r24
    11c4:	51 f0       	breq	.+20     	; 0x11da <myUSART_receiveUSART1+0x3c>
    11c6:	20 e0       	ldi	r18, 0x00	; 0
    11c8:	40 e0       	ldi	r20, 0x00	; 0
    11ca:	50 e0       	ldi	r21, 0x00	; 0
    11cc:	60 e0       	ldi	r22, 0x00	; 0
    11ce:	70 e0       	ldi	r23, 0x00	; 0
    11d0:	80 91 2f 09 	lds	r24, 0x092F
    11d4:	90 91 30 09 	lds	r25, 0x0930
    11d8:	ed d2       	rcall	.+1498   	; 0x17b4 <xQueueGenericSend>
    11da:	8c 2f       	mov	r24, r28
    11dc:	cf 91       	pop	r28
    11de:	08 95       	ret

000011e0 <myUSART_waitForHandshake>:
    11e0:	de df       	rcall	.-68     	; 0x119e <myUSART_receiveUSART1>
    11e2:	86 31       	cpi	r24, 0x16	; 22
    11e4:	51 f4       	brne	.+20     	; 0x11fa <myUSART_waitForHandshake+0x1a>
    11e6:	85 e0       	ldi	r24, 0x05	; 5
    11e8:	a7 df       	rcall	.-178    	; 0x1138 <myUSART_transmitUSART1_c>
    11ea:	d9 df       	rcall	.-78     	; 0x119e <myUSART_receiveUSART1>
    11ec:	91 e0       	ldi	r25, 0x01	; 1
    11ee:	86 31       	cpi	r24, 0x16	; 22
    11f0:	09 f4       	brne	.+2      	; 0x11f4 <myUSART_waitForHandshake+0x14>
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	89 2f       	mov	r24, r25
    11f6:	81 95       	neg	r24
    11f8:	08 95       	ret
    11fa:	8f ef       	ldi	r24, 0xFF	; 255
    11fc:	08 95       	ret

000011fe <myUSART_completeHandShake>:
    11fe:	20 e0       	ldi	r18, 0x00	; 0
    1200:	40 e0       	ldi	r20, 0x00	; 0
    1202:	50 e0       	ldi	r21, 0x00	; 0
    1204:	60 e0       	ldi	r22, 0x00	; 0
    1206:	70 e0       	ldi	r23, 0x00	; 0
    1208:	80 91 eb 08 	lds	r24, 0x08EB
    120c:	90 91 ec 08 	lds	r25, 0x08EC
    1210:	d1 c2       	rjmp	.+1442   	; 0x17b4 <xQueueGenericSend>
    1212:	08 95       	ret

00001214 <myUSART_receiveHandShakeAck>:
    1214:	91 e0       	ldi	r25, 0x01	; 1
    1216:	85 30       	cpi	r24, 0x05	; 5
    1218:	09 f0       	breq	.+2      	; 0x121c <myUSART_receiveHandShakeAck+0x8>
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	89 2f       	mov	r24, r25
    121e:	08 95       	ret

00001220 <myUSART_receiveHandShakeStart>:
    1220:	91 e0       	ldi	r25, 0x01	; 1
    1222:	86 31       	cpi	r24, 0x16	; 22
    1224:	09 f0       	breq	.+2      	; 0x1228 <myUSART_receiveHandShakeStart+0x8>
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	89 2f       	mov	r24, r25
    122a:	08 95       	ret

0000122c <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    122c:	91 e0       	ldi	r25, 0x01	; 1
    122e:	86 30       	cpi	r24, 0x06	; 6
    1230:	09 f0       	breq	.+2      	; 0x1234 <myUSART_receiveMessageACK+0x8>
    1232:	90 e0       	ldi	r25, 0x00	; 0
}
    1234:	89 2f       	mov	r24, r25
    1236:	08 95       	ret

00001238 <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    1238:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	4f ef       	ldi	r20, 0xFF	; 255
    123e:	5f ef       	ldi	r21, 0xFF	; 255
    1240:	60 e0       	ldi	r22, 0x00	; 0
    1242:	70 e0       	ldi	r23, 0x00	; 0
    1244:	80 91 2f 09 	lds	r24, 0x092F
    1248:	90 91 30 09 	lds	r25, 0x0930
    124c:	ab d3       	rcall	.+1878   	; 0x19a4 <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    124e:	8b e3       	ldi	r24, 0x3B	; 59
    1250:	99 e0       	ldi	r25, 0x09	; 9
    1252:	62 d4       	rcall	.+2244   	; 0x1b18 <ringBufferPeek>
    1254:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    1256:	8b e3       	ldi	r24, 0x3B	; 59
    1258:	99 e0       	ldi	r25, 0x09	; 9
    125a:	98 d4       	rcall	.+2352   	; 0x1b8c <ringBufferNotEmpty>
    125c:	88 23       	and	r24, r24
    125e:	51 f0       	breq	.+20     	; 0x1274 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    1260:	20 e0       	ldi	r18, 0x00	; 0
    1262:	40 e0       	ldi	r20, 0x00	; 0
    1264:	50 e0       	ldi	r21, 0x00	; 0
    1266:	60 e0       	ldi	r22, 0x00	; 0
    1268:	70 e0       	ldi	r23, 0x00	; 0
    126a:	80 91 2f 09 	lds	r24, 0x092F
    126e:	90 91 30 09 	lds	r25, 0x0930
    1272:	a0 d2       	rcall	.+1344   	; 0x17b4 <xQueueGenericSend>
	}
	
	return data;
    1274:	8c 2f       	mov	r24, r28
    1276:	cf 91       	pop	r28
    1278:	08 95       	ret

0000127a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    127a:	31 e1       	ldi	r19, 0x11	; 17
    127c:	fc 01       	movw	r30, r24
    127e:	30 83       	st	Z, r19
    1280:	31 97       	sbiw	r30, 0x01	; 1
    1282:	22 e2       	ldi	r18, 0x22	; 34
    1284:	20 83       	st	Z, r18
    1286:	31 97       	sbiw	r30, 0x01	; 1
    1288:	a3 e3       	ldi	r26, 0x33	; 51
    128a:	a0 83       	st	Z, r26
    128c:	31 97       	sbiw	r30, 0x01	; 1
    128e:	60 83       	st	Z, r22
    1290:	31 97       	sbiw	r30, 0x01	; 1
    1292:	70 83       	st	Z, r23
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	10 82       	st	Z, r1
    1298:	31 97       	sbiw	r30, 0x01	; 1
    129a:	10 82       	st	Z, r1
    129c:	31 97       	sbiw	r30, 0x01	; 1
    129e:	60 e8       	ldi	r22, 0x80	; 128
    12a0:	60 83       	st	Z, r22
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	10 82       	st	Z, r1
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	10 82       	st	Z, r1
    12aa:	31 97       	sbiw	r30, 0x01	; 1
    12ac:	10 82       	st	Z, r1
    12ae:	31 97       	sbiw	r30, 0x01	; 1
    12b0:	62 e0       	ldi	r22, 0x02	; 2
    12b2:	60 83       	st	Z, r22
    12b4:	31 97       	sbiw	r30, 0x01	; 1
    12b6:	63 e0       	ldi	r22, 0x03	; 3
    12b8:	60 83       	st	Z, r22
    12ba:	31 97       	sbiw	r30, 0x01	; 1
    12bc:	64 e0       	ldi	r22, 0x04	; 4
    12be:	60 83       	st	Z, r22
    12c0:	31 97       	sbiw	r30, 0x01	; 1
    12c2:	65 e0       	ldi	r22, 0x05	; 5
    12c4:	60 83       	st	Z, r22
    12c6:	31 97       	sbiw	r30, 0x01	; 1
    12c8:	66 e0       	ldi	r22, 0x06	; 6
    12ca:	60 83       	st	Z, r22
    12cc:	31 97       	sbiw	r30, 0x01	; 1
    12ce:	67 e0       	ldi	r22, 0x07	; 7
    12d0:	60 83       	st	Z, r22
    12d2:	31 97       	sbiw	r30, 0x01	; 1
    12d4:	68 e0       	ldi	r22, 0x08	; 8
    12d6:	60 83       	st	Z, r22
    12d8:	31 97       	sbiw	r30, 0x01	; 1
    12da:	69 e0       	ldi	r22, 0x09	; 9
    12dc:	60 83       	st	Z, r22
    12de:	31 97       	sbiw	r30, 0x01	; 1
    12e0:	60 e1       	ldi	r22, 0x10	; 16
    12e2:	60 83       	st	Z, r22
    12e4:	31 97       	sbiw	r30, 0x01	; 1
    12e6:	30 83       	st	Z, r19
    12e8:	31 97       	sbiw	r30, 0x01	; 1
    12ea:	32 e1       	ldi	r19, 0x12	; 18
    12ec:	30 83       	st	Z, r19
    12ee:	31 97       	sbiw	r30, 0x01	; 1
    12f0:	33 e1       	ldi	r19, 0x13	; 19
    12f2:	30 83       	st	Z, r19
    12f4:	31 97       	sbiw	r30, 0x01	; 1
    12f6:	34 e1       	ldi	r19, 0x14	; 20
    12f8:	30 83       	st	Z, r19
    12fa:	31 97       	sbiw	r30, 0x01	; 1
    12fc:	35 e1       	ldi	r19, 0x15	; 21
    12fe:	30 83       	st	Z, r19
    1300:	31 97       	sbiw	r30, 0x01	; 1
    1302:	36 e1       	ldi	r19, 0x16	; 22
    1304:	30 83       	st	Z, r19
    1306:	31 97       	sbiw	r30, 0x01	; 1
    1308:	37 e1       	ldi	r19, 0x17	; 23
    130a:	30 83       	st	Z, r19
    130c:	31 97       	sbiw	r30, 0x01	; 1
    130e:	38 e1       	ldi	r19, 0x18	; 24
    1310:	30 83       	st	Z, r19
    1312:	31 97       	sbiw	r30, 0x01	; 1
    1314:	39 e1       	ldi	r19, 0x19	; 25
    1316:	30 83       	st	Z, r19
    1318:	31 97       	sbiw	r30, 0x01	; 1
    131a:	30 e2       	ldi	r19, 0x20	; 32
    131c:	30 83       	st	Z, r19
    131e:	31 97       	sbiw	r30, 0x01	; 1
    1320:	31 e2       	ldi	r19, 0x21	; 33
    1322:	30 83       	st	Z, r19
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	20 83       	st	Z, r18
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	23 e2       	ldi	r18, 0x23	; 35
    132c:	20 83       	st	Z, r18
    132e:	31 97       	sbiw	r30, 0x01	; 1
    1330:	40 83       	st	Z, r20
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	50 83       	st	Z, r21
    1336:	31 97       	sbiw	r30, 0x01	; 1
    1338:	26 e2       	ldi	r18, 0x26	; 38
    133a:	20 83       	st	Z, r18
    133c:	31 97       	sbiw	r30, 0x01	; 1
    133e:	27 e2       	ldi	r18, 0x27	; 39
    1340:	20 83       	st	Z, r18
    1342:	31 97       	sbiw	r30, 0x01	; 1
    1344:	28 e2       	ldi	r18, 0x28	; 40
    1346:	20 83       	st	Z, r18
    1348:	31 97       	sbiw	r30, 0x01	; 1
    134a:	29 e2       	ldi	r18, 0x29	; 41
    134c:	20 83       	st	Z, r18
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	20 e3       	ldi	r18, 0x30	; 48
    1352:	20 83       	st	Z, r18
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	21 e3       	ldi	r18, 0x31	; 49
    1358:	20 83       	st	Z, r18
    135a:	89 97       	sbiw	r24, 0x29	; 41
    135c:	08 95       	ret

0000135e <xPortStartScheduler>:
    135e:	82 e0       	ldi	r24, 0x02	; 2
    1360:	84 bd       	out	0x24, r24	; 36
    1362:	16 bc       	out	0x26, r1	; 38
    1364:	80 e3       	ldi	r24, 0x30	; 48
    1366:	87 bd       	out	0x27, r24	; 39
    1368:	ee e6       	ldi	r30, 0x6E	; 110
    136a:	f0 e0       	ldi	r31, 0x00	; 0
    136c:	80 81       	ld	r24, Z
    136e:	82 60       	ori	r24, 0x02	; 2
    1370:	80 83       	st	Z, r24
    1372:	83 e0       	ldi	r24, 0x03	; 3
    1374:	85 bd       	out	0x25, r24	; 37
    1376:	a0 91 86 08 	lds	r26, 0x0886
    137a:	b0 91 87 08 	lds	r27, 0x0887
    137e:	cd 91       	ld	r28, X+
    1380:	cd bf       	out	0x3d, r28	; 61
    1382:	dd 91       	ld	r29, X+
    1384:	de bf       	out	0x3e, r29	; 62
    1386:	ff 91       	pop	r31
    1388:	ef 91       	pop	r30
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	bf 91       	pop	r27
    1390:	af 91       	pop	r26
    1392:	9f 91       	pop	r25
    1394:	8f 91       	pop	r24
    1396:	7f 91       	pop	r23
    1398:	6f 91       	pop	r22
    139a:	5f 91       	pop	r21
    139c:	4f 91       	pop	r20
    139e:	3f 91       	pop	r19
    13a0:	2f 91       	pop	r18
    13a2:	1f 91       	pop	r17
    13a4:	0f 91       	pop	r16
    13a6:	ff 90       	pop	r15
    13a8:	ef 90       	pop	r14
    13aa:	df 90       	pop	r13
    13ac:	cf 90       	pop	r12
    13ae:	bf 90       	pop	r11
    13b0:	af 90       	pop	r10
    13b2:	9f 90       	pop	r9
    13b4:	8f 90       	pop	r8
    13b6:	7f 90       	pop	r7
    13b8:	6f 90       	pop	r6
    13ba:	5f 90       	pop	r5
    13bc:	4f 90       	pop	r4
    13be:	3f 90       	pop	r3
    13c0:	2f 90       	pop	r2
    13c2:	1f 90       	pop	r1
    13c4:	0f 90       	pop	r0
    13c6:	0c be       	out	0x3c, r0	; 60
    13c8:	0f 90       	pop	r0
    13ca:	0b be       	out	0x3b, r0	; 59
    13cc:	0f 90       	pop	r0
    13ce:	0f be       	out	0x3f, r0	; 63
    13d0:	0f 90       	pop	r0
    13d2:	08 95       	ret
    13d4:	81 e0       	ldi	r24, 0x01	; 1
    13d6:	08 95       	ret

000013d8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    13d8:	0f 92       	push	r0
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
    13e0:	0b b6       	in	r0, 0x3b	; 59
    13e2:	0f 92       	push	r0
    13e4:	0c b6       	in	r0, 0x3c	; 60
    13e6:	0f 92       	push	r0
    13e8:	1f 92       	push	r1
    13ea:	11 24       	eor	r1, r1
    13ec:	2f 92       	push	r2
    13ee:	3f 92       	push	r3
    13f0:	4f 92       	push	r4
    13f2:	5f 92       	push	r5
    13f4:	6f 92       	push	r6
    13f6:	7f 92       	push	r7
    13f8:	8f 92       	push	r8
    13fa:	9f 92       	push	r9
    13fc:	af 92       	push	r10
    13fe:	bf 92       	push	r11
    1400:	cf 92       	push	r12
    1402:	df 92       	push	r13
    1404:	ef 92       	push	r14
    1406:	ff 92       	push	r15
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	2f 93       	push	r18
    140e:	3f 93       	push	r19
    1410:	4f 93       	push	r20
    1412:	5f 93       	push	r21
    1414:	6f 93       	push	r22
    1416:	7f 93       	push	r23
    1418:	8f 93       	push	r24
    141a:	9f 93       	push	r25
    141c:	af 93       	push	r26
    141e:	bf 93       	push	r27
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	ef 93       	push	r30
    1426:	ff 93       	push	r31
    1428:	a0 91 86 08 	lds	r26, 0x0886
    142c:	b0 91 87 08 	lds	r27, 0x0887
    1430:	0d b6       	in	r0, 0x3d	; 61
    1432:	0d 92       	st	X+, r0
    1434:	0e b6       	in	r0, 0x3e	; 62
    1436:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1438:	5b d7       	rcall	.+3766   	; 0x22f0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    143a:	a0 91 86 08 	lds	r26, 0x0886
    143e:	b0 91 87 08 	lds	r27, 0x0887
    1442:	cd 91       	ld	r28, X+
    1444:	cd bf       	out	0x3d, r28	; 61
    1446:	dd 91       	ld	r29, X+
    1448:	de bf       	out	0x3e, r29	; 62
    144a:	ff 91       	pop	r31
    144c:	ef 91       	pop	r30
    144e:	df 91       	pop	r29
    1450:	cf 91       	pop	r28
    1452:	bf 91       	pop	r27
    1454:	af 91       	pop	r26
    1456:	9f 91       	pop	r25
    1458:	8f 91       	pop	r24
    145a:	7f 91       	pop	r23
    145c:	6f 91       	pop	r22
    145e:	5f 91       	pop	r21
    1460:	4f 91       	pop	r20
    1462:	3f 91       	pop	r19
    1464:	2f 91       	pop	r18
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	df 90       	pop	r13
    1470:	cf 90       	pop	r12
    1472:	bf 90       	pop	r11
    1474:	af 90       	pop	r10
    1476:	9f 90       	pop	r9
    1478:	8f 90       	pop	r8
    147a:	7f 90       	pop	r7
    147c:	6f 90       	pop	r6
    147e:	5f 90       	pop	r5
    1480:	4f 90       	pop	r4
    1482:	3f 90       	pop	r3
    1484:	2f 90       	pop	r2
    1486:	1f 90       	pop	r1
    1488:	0f 90       	pop	r0
    148a:	0c be       	out	0x3c, r0	; 60
    148c:	0f 90       	pop	r0
    148e:	0b be       	out	0x3b, r0	; 59
    1490:	0f 90       	pop	r0
    1492:	0f be       	out	0x3f, r0	; 63
    1494:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1496:	08 95       	ret

00001498 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1498:	0f 92       	push	r0
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	0f 92       	push	r0
    14a0:	0b b6       	in	r0, 0x3b	; 59
    14a2:	0f 92       	push	r0
    14a4:	0c b6       	in	r0, 0x3c	; 60
    14a6:	0f 92       	push	r0
    14a8:	1f 92       	push	r1
    14aa:	11 24       	eor	r1, r1
    14ac:	2f 92       	push	r2
    14ae:	3f 92       	push	r3
    14b0:	4f 92       	push	r4
    14b2:	5f 92       	push	r5
    14b4:	6f 92       	push	r6
    14b6:	7f 92       	push	r7
    14b8:	8f 92       	push	r8
    14ba:	9f 92       	push	r9
    14bc:	af 92       	push	r10
    14be:	bf 92       	push	r11
    14c0:	cf 92       	push	r12
    14c2:	df 92       	push	r13
    14c4:	ef 92       	push	r14
    14c6:	ff 92       	push	r15
    14c8:	0f 93       	push	r16
    14ca:	1f 93       	push	r17
    14cc:	2f 93       	push	r18
    14ce:	3f 93       	push	r19
    14d0:	4f 93       	push	r20
    14d2:	5f 93       	push	r21
    14d4:	6f 93       	push	r22
    14d6:	7f 93       	push	r23
    14d8:	8f 93       	push	r24
    14da:	9f 93       	push	r25
    14dc:	af 93       	push	r26
    14de:	bf 93       	push	r27
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	ef 93       	push	r30
    14e6:	ff 93       	push	r31
    14e8:	a0 91 86 08 	lds	r26, 0x0886
    14ec:	b0 91 87 08 	lds	r27, 0x0887
    14f0:	0d b6       	in	r0, 0x3d	; 61
    14f2:	0d 92       	st	X+, r0
    14f4:	0e b6       	in	r0, 0x3e	; 62
    14f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    14f8:	45 d5       	rcall	.+2698   	; 0x1f84 <xTaskIncrementTick>
    14fa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    14fc:	f9 d6       	rcall	.+3570   	; 0x22f0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    14fe:	a0 91 86 08 	lds	r26, 0x0886
    1502:	b0 91 87 08 	lds	r27, 0x0887
    1506:	cd 91       	ld	r28, X+
    1508:	cd bf       	out	0x3d, r28	; 61
    150a:	dd 91       	ld	r29, X+
    150c:	de bf       	out	0x3e, r29	; 62
    150e:	ff 91       	pop	r31
    1510:	ef 91       	pop	r30
    1512:	df 91       	pop	r29
    1514:	cf 91       	pop	r28
    1516:	bf 91       	pop	r27
    1518:	af 91       	pop	r26
    151a:	9f 91       	pop	r25
    151c:	8f 91       	pop	r24
    151e:	7f 91       	pop	r23
    1520:	6f 91       	pop	r22
    1522:	5f 91       	pop	r21
    1524:	4f 91       	pop	r20
    1526:	3f 91       	pop	r19
    1528:	2f 91       	pop	r18
    152a:	1f 91       	pop	r17
    152c:	0f 91       	pop	r16
    152e:	ff 90       	pop	r15
    1530:	ef 90       	pop	r14
    1532:	df 90       	pop	r13
    1534:	cf 90       	pop	r12
    1536:	bf 90       	pop	r11
    1538:	af 90       	pop	r10
    153a:	9f 90       	pop	r9
    153c:	8f 90       	pop	r8
    153e:	7f 90       	pop	r7
    1540:	6f 90       	pop	r6
    1542:	5f 90       	pop	r5
    1544:	4f 90       	pop	r4
    1546:	3f 90       	pop	r3
    1548:	2f 90       	pop	r2
    154a:	1f 90       	pop	r1
    154c:	0f 90       	pop	r0
    154e:	0c be       	out	0x3c, r0	; 60
    1550:	0f 90       	pop	r0
    1552:	0b be       	out	0x3b, r0	; 59
    1554:	0f 90       	pop	r0
    1556:	0f be       	out	0x3f, r0	; 63
    1558:	0f 90       	pop	r0

	asm volatile ( "ret" );
    155a:	08 95       	ret

0000155c <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    155c:	9d df       	rcall	.-198    	; 0x1498 <vPortYieldFromTick>
		 asm volatile ("reti");
    155e:	18 95       	reti

00001560 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1560:	1f 93       	push	r17
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
    1566:	ec 01       	movw	r28, r24
    1568:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    156a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    156c:	81 11       	cpse	r24, r1
    156e:	0c c0       	rjmp	.+24     	; 0x1588 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1570:	88 81       	ld	r24, Y
    1572:	99 81       	ldd	r25, Y+1	; 0x01
    1574:	89 2b       	or	r24, r25
    1576:	09 f0       	breq	.+2      	; 0x157a <prvCopyDataToQueue+0x1a>
    1578:	47 c0       	rjmp	.+142    	; 0x1608 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    157a:	8a 81       	ldd	r24, Y+2	; 0x02
    157c:	9b 81       	ldd	r25, Y+3	; 0x03
    157e:	0e 94 3b 13 	call	0x2676	; 0x2676 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1582:	1b 82       	std	Y+3, r1	; 0x03
    1584:	1a 82       	std	Y+2, r1	; 0x02
    1586:	47 c0       	rjmp	.+142    	; 0x1616 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1588:	41 11       	cpse	r20, r1
    158a:	18 c0       	rjmp	.+48     	; 0x15bc <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    158c:	48 2f       	mov	r20, r24
    158e:	50 e0       	ldi	r21, 0x00	; 0
    1590:	8c 81       	ldd	r24, Y+4	; 0x04
    1592:	9d 81       	ldd	r25, Y+5	; 0x05
    1594:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1598:	2c 8d       	ldd	r18, Y+28	; 0x1c
    159a:	8c 81       	ldd	r24, Y+4	; 0x04
    159c:	9d 81       	ldd	r25, Y+5	; 0x05
    159e:	82 0f       	add	r24, r18
    15a0:	91 1d       	adc	r25, r1
    15a2:	9d 83       	std	Y+5, r25	; 0x05
    15a4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15a6:	2a 81       	ldd	r18, Y+2	; 0x02
    15a8:	3b 81       	ldd	r19, Y+3	; 0x03
    15aa:	82 17       	cp	r24, r18
    15ac:	93 07       	cpc	r25, r19
    15ae:	70 f1       	brcs	.+92     	; 0x160c <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15b0:	88 81       	ld	r24, Y
    15b2:	99 81       	ldd	r25, Y+1	; 0x01
    15b4:	9d 83       	std	Y+5, r25	; 0x05
    15b6:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    15b8:	80 e0       	ldi	r24, 0x00	; 0
    15ba:	2d c0       	rjmp	.+90     	; 0x1616 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    15bc:	48 2f       	mov	r20, r24
    15be:	50 e0       	ldi	r21, 0x00	; 0
    15c0:	8e 81       	ldd	r24, Y+6	; 0x06
    15c2:	9f 81       	ldd	r25, Y+7	; 0x07
    15c4:	0e 94 07 17 	call	0x2e0e	; 0x2e0e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    15c8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	31 95       	neg	r19
    15ce:	21 95       	neg	r18
    15d0:	31 09       	sbc	r19, r1
    15d2:	8e 81       	ldd	r24, Y+6	; 0x06
    15d4:	9f 81       	ldd	r25, Y+7	; 0x07
    15d6:	82 0f       	add	r24, r18
    15d8:	93 1f       	adc	r25, r19
    15da:	9f 83       	std	Y+7, r25	; 0x07
    15dc:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    15de:	68 81       	ld	r22, Y
    15e0:	79 81       	ldd	r23, Y+1	; 0x01
    15e2:	86 17       	cp	r24, r22
    15e4:	97 07       	cpc	r25, r23
    15e6:	30 f4       	brcc	.+12     	; 0x15f4 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    15e8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ea:	9b 81       	ldd	r25, Y+3	; 0x03
    15ec:	28 0f       	add	r18, r24
    15ee:	39 1f       	adc	r19, r25
    15f0:	3f 83       	std	Y+7, r19	; 0x07
    15f2:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    15f4:	12 30       	cpi	r17, 0x02	; 2
    15f6:	61 f4       	brne	.+24     	; 0x1610 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    15f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    15fa:	88 23       	and	r24, r24
    15fc:	59 f0       	breq	.+22     	; 0x1614 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    15fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1600:	81 50       	subi	r24, 0x01	; 1
    1602:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	07 c0       	rjmp	.+14     	; 0x1616 <prvCopyDataToQueue+0xb6>
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	05 c0       	rjmp	.+10     	; 0x1616 <prvCopyDataToQueue+0xb6>
    160c:	80 e0       	ldi	r24, 0x00	; 0
    160e:	03 c0       	rjmp	.+6      	; 0x1616 <prvCopyDataToQueue+0xb6>
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	01 c0       	rjmp	.+2      	; 0x1616 <prvCopyDataToQueue+0xb6>
    1614:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1616:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1618:	9f 5f       	subi	r25, 0xFF	; 255
    161a:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    161c:	df 91       	pop	r29
    161e:	cf 91       	pop	r28
    1620:	1f 91       	pop	r17
    1622:	08 95       	ret

00001624 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1624:	fc 01       	movw	r30, r24
    1626:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1628:	44 8d       	ldd	r20, Z+28	; 0x1c
    162a:	44 23       	and	r20, r20
    162c:	a1 f0       	breq	.+40     	; 0x1656 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    162e:	50 e0       	ldi	r21, 0x00	; 0
    1630:	26 81       	ldd	r18, Z+6	; 0x06
    1632:	37 81       	ldd	r19, Z+7	; 0x07
    1634:	24 0f       	add	r18, r20
    1636:	35 1f       	adc	r19, r21
    1638:	37 83       	std	Z+7, r19	; 0x07
    163a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    163c:	62 81       	ldd	r22, Z+2	; 0x02
    163e:	73 81       	ldd	r23, Z+3	; 0x03
    1640:	26 17       	cp	r18, r22
    1642:	37 07       	cpc	r19, r23
    1644:	20 f0       	brcs	.+8      	; 0x164e <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1646:	20 81       	ld	r18, Z
    1648:	31 81       	ldd	r19, Z+1	; 0x01
    164a:	37 83       	std	Z+7, r19	; 0x07
    164c:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    164e:	66 81       	ldd	r22, Z+6	; 0x06
    1650:	77 81       	ldd	r23, Z+7	; 0x07
    1652:	0c 94 07 17 	jmp	0x2e0e	; 0x2e0e <memcpy>
    1656:	08 95       	ret

00001658 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1658:	0f 93       	push	r16
    165a:	1f 93       	push	r17
    165c:	cf 93       	push	r28
    165e:	df 93       	push	r29
    1660:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1662:	0f b6       	in	r0, 0x3f	; 63
    1664:	f8 94       	cli
    1666:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1668:	8e 8d       	ldd	r24, Y+30	; 0x1e
    166a:	18 16       	cp	r1, r24
    166c:	a4 f4       	brge	.+40     	; 0x1696 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    166e:	89 89       	ldd	r24, Y+17	; 0x11
    1670:	88 23       	and	r24, r24
    1672:	89 f0       	breq	.+34     	; 0x1696 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1674:	8e 01       	movw	r16, r28
    1676:	0f 5e       	subi	r16, 0xEF	; 239
    1678:	1f 4f       	sbci	r17, 0xFF	; 255
    167a:	03 c0       	rjmp	.+6      	; 0x1682 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    167c:	89 89       	ldd	r24, Y+17	; 0x11
    167e:	88 23       	and	r24, r24
    1680:	51 f0       	breq	.+20     	; 0x1696 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1682:	c8 01       	movw	r24, r16
    1684:	0b d7       	rcall	.+3606   	; 0x249c <xTaskRemoveFromEventList>
    1686:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1688:	94 d7       	rcall	.+3880   	; 0x25b2 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    168a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    168c:	81 50       	subi	r24, 0x01	; 1
    168e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1690:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1692:	18 16       	cp	r1, r24
    1694:	9c f3       	brlt	.-26     	; 0x167c <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1696:	8f ef       	ldi	r24, 0xFF	; 255
    1698:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    169a:	0f 90       	pop	r0
    169c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    169e:	0f b6       	in	r0, 0x3f	; 63
    16a0:	f8 94       	cli
    16a2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16a4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16a6:	18 16       	cp	r1, r24
    16a8:	a4 f4       	brge	.+40     	; 0x16d2 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16aa:	88 85       	ldd	r24, Y+8	; 0x08
    16ac:	88 23       	and	r24, r24
    16ae:	89 f0       	breq	.+34     	; 0x16d2 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16b0:	8e 01       	movw	r16, r28
    16b2:	08 5f       	subi	r16, 0xF8	; 248
    16b4:	1f 4f       	sbci	r17, 0xFF	; 255
    16b6:	03 c0       	rjmp	.+6      	; 0x16be <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16b8:	88 85       	ldd	r24, Y+8	; 0x08
    16ba:	88 23       	and	r24, r24
    16bc:	51 f0       	breq	.+20     	; 0x16d2 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    16be:	c8 01       	movw	r24, r16
    16c0:	ed d6       	rcall	.+3546   	; 0x249c <xTaskRemoveFromEventList>
    16c2:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    16c4:	76 d7       	rcall	.+3820   	; 0x25b2 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    16c6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16c8:	81 50       	subi	r24, 0x01	; 1
    16ca:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    16cc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    16ce:	18 16       	cp	r1, r24
    16d0:	9c f3       	brlt	.-26     	; 0x16b8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    16d2:	8f ef       	ldi	r24, 0xFF	; 255
    16d4:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    16d6:	0f 90       	pop	r0
    16d8:	0f be       	out	0x3f, r0	; 63
}
    16da:	df 91       	pop	r29
    16dc:	cf 91       	pop	r28
    16de:	1f 91       	pop	r17
    16e0:	0f 91       	pop	r16
    16e2:	08 95       	ret

000016e4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    16e4:	cf 93       	push	r28
    16e6:	df 93       	push	r29
    16e8:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    16f0:	88 81       	ld	r24, Y
    16f2:	99 81       	ldd	r25, Y+1	; 0x01
    16f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16f6:	30 e0       	ldi	r19, 0x00	; 0
    16f8:	7b 8d       	ldd	r23, Y+27	; 0x1b
    16fa:	72 9f       	mul	r23, r18
    16fc:	a0 01       	movw	r20, r0
    16fe:	73 9f       	mul	r23, r19
    1700:	50 0d       	add	r21, r0
    1702:	11 24       	eor	r1, r1
    1704:	fc 01       	movw	r30, r24
    1706:	e4 0f       	add	r30, r20
    1708:	f5 1f       	adc	r31, r21
    170a:	fb 83       	std	Y+3, r31	; 0x03
    170c:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    170e:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1710:	9d 83       	std	Y+5, r25	; 0x05
    1712:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1714:	42 1b       	sub	r20, r18
    1716:	53 0b       	sbc	r21, r19
    1718:	84 0f       	add	r24, r20
    171a:	95 1f       	adc	r25, r21
    171c:	9f 83       	std	Y+7, r25	; 0x07
    171e:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1720:	8f ef       	ldi	r24, 0xFF	; 255
    1722:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1724:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1726:	61 11       	cpse	r22, r1
    1728:	0a c0       	rjmp	.+20     	; 0x173e <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    172a:	88 85       	ldd	r24, Y+8	; 0x08
    172c:	88 23       	and	r24, r24
    172e:	79 f0       	breq	.+30     	; 0x174e <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1730:	ce 01       	movw	r24, r28
    1732:	08 96       	adiw	r24, 0x08	; 8
    1734:	b3 d6       	rcall	.+3430   	; 0x249c <xTaskRemoveFromEventList>
    1736:	81 30       	cpi	r24, 0x01	; 1
    1738:	51 f4       	brne	.+20     	; 0x174e <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    173a:	4e de       	rcall	.-868    	; 0x13d8 <vPortYield>
    173c:	08 c0       	rjmp	.+16     	; 0x174e <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    173e:	ce 01       	movw	r24, r28
    1740:	08 96       	adiw	r24, 0x08	; 8
    1742:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1746:	ce 01       	movw	r24, r28
    1748:	41 96       	adiw	r24, 0x11	; 17
    174a:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    174e:	0f 90       	pop	r0
    1750:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	df 91       	pop	r29
    1756:	cf 91       	pop	r28
    1758:	08 95       	ret

0000175a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	18 2f       	mov	r17, r24
    1764:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1766:	88 23       	and	r24, r24
    1768:	e9 f0       	breq	.+58     	; 0x17a4 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    176a:	8f e1       	ldi	r24, 0x1F	; 31
    176c:	90 e0       	ldi	r25, 0x00	; 0
    176e:	0e 94 f5 02 	call	0x5ea	; 0x5ea <pvPortMalloc>
    1772:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1774:	00 97       	sbiw	r24, 0x00	; 0
    1776:	c1 f0       	breq	.+48     	; 0x17a8 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1778:	10 9f       	mul	r17, r16
    177a:	c0 01       	movw	r24, r0
    177c:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    177e:	01 96       	adiw	r24, 0x01	; 1
    1780:	0e 94 f5 02 	call	0x5ea	; 0x5ea <pvPortMalloc>
    1784:	99 83       	std	Y+1, r25	; 0x01
    1786:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1788:	89 2b       	or	r24, r25
    178a:	31 f0       	breq	.+12     	; 0x1798 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    178c:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    178e:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1790:	61 e0       	ldi	r22, 0x01	; 1
    1792:	ce 01       	movw	r24, r28
    1794:	a7 df       	rcall	.-178    	; 0x16e4 <xQueueGenericReset>
    1796:	08 c0       	rjmp	.+16     	; 0x17a8 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1798:	ce 01       	movw	r24, r28
    179a:	0e 94 2a 03 	call	0x654	; 0x654 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    179e:	c0 e0       	ldi	r28, 0x00	; 0
    17a0:	d0 e0       	ldi	r29, 0x00	; 0
    17a2:	02 c0       	rjmp	.+4      	; 0x17a8 <xQueueGenericCreate+0x4e>
    17a4:	c0 e0       	ldi	r28, 0x00	; 0
    17a6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    17a8:	ce 01       	movw	r24, r28
    17aa:	df 91       	pop	r29
    17ac:	cf 91       	pop	r28
    17ae:	1f 91       	pop	r17
    17b0:	0f 91       	pop	r16
    17b2:	08 95       	ret

000017b4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    17b4:	9f 92       	push	r9
    17b6:	af 92       	push	r10
    17b8:	bf 92       	push	r11
    17ba:	cf 92       	push	r12
    17bc:	df 92       	push	r13
    17be:	ef 92       	push	r14
    17c0:	ff 92       	push	r15
    17c2:	0f 93       	push	r16
    17c4:	1f 93       	push	r17
    17c6:	cf 93       	push	r28
    17c8:	df 93       	push	r29
    17ca:	00 d0       	rcall	.+0      	; 0x17cc <xQueueGenericSend+0x18>
    17cc:	1f 92       	push	r1
    17ce:	1f 92       	push	r1
    17d0:	cd b7       	in	r28, 0x3d	; 61
    17d2:	de b7       	in	r29, 0x3e	; 62
    17d4:	8c 01       	movw	r16, r24
    17d6:	6b 01       	movw	r12, r22
    17d8:	5d 83       	std	Y+5, r21	; 0x05
    17da:	4c 83       	std	Y+4, r20	; 0x04
    17dc:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    17de:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    17e0:	99 24       	eor	r9, r9
    17e2:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    17e4:	7c 01       	movw	r14, r24
    17e6:	88 e0       	ldi	r24, 0x08	; 8
    17e8:	e8 0e       	add	r14, r24
    17ea:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	f8 94       	cli
    17f0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    17f2:	f8 01       	movw	r30, r16
    17f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    17f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    17f8:	98 17       	cp	r25, r24
    17fa:	18 f0       	brcs	.+6      	; 0x1802 <xQueueGenericSend+0x4e>
    17fc:	f2 e0       	ldi	r31, 0x02	; 2
    17fe:	af 12       	cpse	r10, r31
    1800:	15 c0       	rjmp	.+42     	; 0x182c <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1802:	4a 2d       	mov	r20, r10
    1804:	b6 01       	movw	r22, r12
    1806:	c8 01       	movw	r24, r16
    1808:	ab de       	rcall	.-682    	; 0x1560 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    180a:	f8 01       	movw	r30, r16
    180c:	91 89       	ldd	r25, Z+17	; 0x11
    180e:	99 23       	and	r25, r25
    1810:	39 f0       	breq	.+14     	; 0x1820 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1812:	c8 01       	movw	r24, r16
    1814:	41 96       	adiw	r24, 0x11	; 17
    1816:	42 d6       	rcall	.+3204   	; 0x249c <xTaskRemoveFromEventList>
    1818:	81 30       	cpi	r24, 0x01	; 1
    181a:	21 f4       	brne	.+8      	; 0x1824 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    181c:	dd dd       	rcall	.-1094   	; 0x13d8 <vPortYield>
    181e:	02 c0       	rjmp	.+4      	; 0x1824 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1820:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1822:	da dd       	rcall	.-1100   	; 0x13d8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1824:	0f 90       	pop	r0
    1826:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	46 c0       	rjmp	.+140    	; 0x18b8 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    182c:	ec 81       	ldd	r30, Y+4	; 0x04
    182e:	fd 81       	ldd	r31, Y+5	; 0x05
    1830:	ef 2b       	or	r30, r31
    1832:	21 f4       	brne	.+8      	; 0x183c <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1834:	0f 90       	pop	r0
    1836:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1838:	80 e0       	ldi	r24, 0x00	; 0
    183a:	3e c0       	rjmp	.+124    	; 0x18b8 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    183c:	b1 10       	cpse	r11, r1
    183e:	04 c0       	rjmp	.+8      	; 0x1848 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1840:	ce 01       	movw	r24, r28
    1842:	01 96       	adiw	r24, 0x01	; 1
    1844:	73 d6       	rcall	.+3302   	; 0x252c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1846:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1848:	0f 90       	pop	r0
    184a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    184c:	86 d3       	rcall	.+1804   	; 0x1f5a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	f8 01       	movw	r30, r16
    1856:	85 8d       	ldd	r24, Z+29	; 0x1d
    1858:	8f 3f       	cpi	r24, 0xFF	; 255
    185a:	09 f4       	brne	.+2      	; 0x185e <xQueueGenericSend+0xaa>
    185c:	15 8e       	std	Z+29, r1	; 0x1d
    185e:	f8 01       	movw	r30, r16
    1860:	86 8d       	ldd	r24, Z+30	; 0x1e
    1862:	8f 3f       	cpi	r24, 0xFF	; 255
    1864:	09 f4       	brne	.+2      	; 0x1868 <xQueueGenericSend+0xb4>
    1866:	16 8e       	std	Z+30, r1	; 0x1e
    1868:	0f 90       	pop	r0
    186a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    186c:	be 01       	movw	r22, r28
    186e:	6c 5f       	subi	r22, 0xFC	; 252
    1870:	7f 4f       	sbci	r23, 0xFF	; 255
    1872:	ce 01       	movw	r24, r28
    1874:	01 96       	adiw	r24, 0x01	; 1
    1876:	65 d6       	rcall	.+3274   	; 0x2542 <xTaskCheckForTimeOut>
    1878:	81 11       	cpse	r24, r1
    187a:	1a c0       	rjmp	.+52     	; 0x18b0 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    187c:	0f b6       	in	r0, 0x3f	; 63
    187e:	f8 94       	cli
    1880:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1882:	f8 01       	movw	r30, r16
    1884:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1886:	0f 90       	pop	r0
    1888:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    188a:	f8 01       	movw	r30, r16
    188c:	83 8d       	ldd	r24, Z+27	; 0x1b
    188e:	98 13       	cpse	r25, r24
    1890:	0b c0       	rjmp	.+22     	; 0x18a8 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1892:	6c 81       	ldd	r22, Y+4	; 0x04
    1894:	7d 81       	ldd	r23, Y+5	; 0x05
    1896:	c7 01       	movw	r24, r14
    1898:	d6 d5       	rcall	.+2988   	; 0x2446 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    189a:	c8 01       	movw	r24, r16
    189c:	dd de       	rcall	.-582    	; 0x1658 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    189e:	30 d4       	rcall	.+2144   	; 0x2100 <xTaskResumeAll>
    18a0:	81 11       	cpse	r24, r1
    18a2:	a4 cf       	rjmp	.-184    	; 0x17ec <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    18a4:	99 dd       	rcall	.-1230   	; 0x13d8 <vPortYield>
    18a6:	a2 cf       	rjmp	.-188    	; 0x17ec <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    18a8:	c8 01       	movw	r24, r16
    18aa:	d6 de       	rcall	.-596    	; 0x1658 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18ac:	29 d4       	rcall	.+2130   	; 0x2100 <xTaskResumeAll>
    18ae:	9e cf       	rjmp	.-196    	; 0x17ec <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    18b0:	c8 01       	movw	r24, r16
    18b2:	d2 de       	rcall	.-604    	; 0x1658 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18b4:	25 d4       	rcall	.+2122   	; 0x2100 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    18b6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    18b8:	0f 90       	pop	r0
    18ba:	0f 90       	pop	r0
    18bc:	0f 90       	pop	r0
    18be:	0f 90       	pop	r0
    18c0:	0f 90       	pop	r0
    18c2:	df 91       	pop	r29
    18c4:	cf 91       	pop	r28
    18c6:	1f 91       	pop	r17
    18c8:	0f 91       	pop	r16
    18ca:	ff 90       	pop	r15
    18cc:	ef 90       	pop	r14
    18ce:	df 90       	pop	r13
    18d0:	cf 90       	pop	r12
    18d2:	bf 90       	pop	r11
    18d4:	af 90       	pop	r10
    18d6:	9f 90       	pop	r9
    18d8:	08 95       	ret

000018da <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    18da:	cf 93       	push	r28
    18dc:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    18de:	8f e1       	ldi	r24, 0x1F	; 31
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	0e 94 f5 02 	call	0x5ea	; 0x5ea <pvPortMalloc>
    18e6:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18e8:	00 97       	sbiw	r24, 0x00	; 0
    18ea:	f1 f0       	breq	.+60     	; 0x1928 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    18ec:	1b 82       	std	Y+3, r1	; 0x03
    18ee:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    18f0:	19 82       	std	Y+1, r1	; 0x01
    18f2:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    18f4:	1d 82       	std	Y+5, r1	; 0x05
    18f6:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    18f8:	1f 82       	std	Y+7, r1	; 0x07
    18fa:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18fc:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    18fe:	81 e0       	ldi	r24, 0x01	; 1
    1900:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1902:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1904:	8f ef       	ldi	r24, 0xFF	; 255
    1906:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1908:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    190a:	ce 01       	movw	r24, r28
    190c:	08 96       	adiw	r24, 0x08	; 8
    190e:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1912:	ce 01       	movw	r24, r28
    1914:	41 96       	adiw	r24, 0x11	; 17
    1916:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    191a:	20 e0       	ldi	r18, 0x00	; 0
    191c:	40 e0       	ldi	r20, 0x00	; 0
    191e:	50 e0       	ldi	r21, 0x00	; 0
    1920:	60 e0       	ldi	r22, 0x00	; 0
    1922:	70 e0       	ldi	r23, 0x00	; 0
    1924:	ce 01       	movw	r24, r28
    1926:	46 df       	rcall	.-372    	; 0x17b4 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1928:	ce 01       	movw	r24, r28
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	08 95       	ret

00001930 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	ec 01       	movw	r28, r24
    193a:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    193c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    193e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1940:	98 17       	cp	r25, r24
    1942:	10 f0       	brcs	.+4      	; 0x1948 <xQueueGenericSendFromISR+0x18>
    1944:	22 30       	cpi	r18, 0x02	; 2
    1946:	11 f5       	brne	.+68     	; 0x198c <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1948:	42 2f       	mov	r20, r18
    194a:	ce 01       	movw	r24, r28
    194c:	09 de       	rcall	.-1006   	; 0x1560 <prvCopyDataToQueue>
    194e:	88 23       	and	r24, r24
    1950:	31 f0       	breq	.+12     	; 0x195e <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1952:	01 15       	cp	r16, r1
    1954:	11 05       	cpc	r17, r1
    1956:	19 f0       	breq	.+6      	; 0x195e <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	f8 01       	movw	r30, r16
    195c:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    195e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1960:	8f 3f       	cpi	r24, 0xFF	; 255
    1962:	79 f4       	brne	.+30     	; 0x1982 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1964:	89 89       	ldd	r24, Y+17	; 0x11
    1966:	88 23       	and	r24, r24
    1968:	99 f0       	breq	.+38     	; 0x1990 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    196a:	ce 01       	movw	r24, r28
    196c:	41 96       	adiw	r24, 0x11	; 17
    196e:	96 d5       	rcall	.+2860   	; 0x249c <xTaskRemoveFromEventList>
    1970:	88 23       	and	r24, r24
    1972:	81 f0       	breq	.+32     	; 0x1994 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1974:	01 15       	cp	r16, r1
    1976:	11 05       	cpc	r17, r1
    1978:	79 f0       	breq	.+30     	; 0x1998 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	f8 01       	movw	r30, r16
    197e:	80 83       	st	Z, r24
    1980:	0c c0       	rjmp	.+24     	; 0x199a <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1982:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1984:	8f 5f       	subi	r24, 0xFF	; 255
    1986:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1988:	81 e0       	ldi	r24, 0x01	; 1
    198a:	07 c0       	rjmp	.+14     	; 0x199a <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	05 c0       	rjmp	.+10     	; 0x199a <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	03 c0       	rjmp	.+6      	; 0x199a <xQueueGenericSendFromISR+0x6a>
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	01 c0       	rjmp	.+2      	; 0x199a <xQueueGenericSendFromISR+0x6a>
    1998:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	1f 91       	pop	r17
    19a0:	0f 91       	pop	r16
    19a2:	08 95       	ret

000019a4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    19a4:	9f 92       	push	r9
    19a6:	af 92       	push	r10
    19a8:	bf 92       	push	r11
    19aa:	cf 92       	push	r12
    19ac:	df 92       	push	r13
    19ae:	ef 92       	push	r14
    19b0:	ff 92       	push	r15
    19b2:	0f 93       	push	r16
    19b4:	1f 93       	push	r17
    19b6:	cf 93       	push	r28
    19b8:	df 93       	push	r29
    19ba:	00 d0       	rcall	.+0      	; 0x19bc <xQueueGenericReceive+0x18>
    19bc:	1f 92       	push	r1
    19be:	1f 92       	push	r1
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
    19c4:	8c 01       	movw	r16, r24
    19c6:	6b 01       	movw	r12, r22
    19c8:	5d 83       	std	Y+5, r21	; 0x05
    19ca:	4c 83       	std	Y+4, r20	; 0x04
    19cc:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    19ce:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    19d0:	99 24       	eor	r9, r9
    19d2:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19d4:	7c 01       	movw	r14, r24
    19d6:	81 e1       	ldi	r24, 0x11	; 17
    19d8:	e8 0e       	add	r14, r24
    19da:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    19e2:	f8 01       	movw	r30, r16
    19e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    19e6:	88 23       	and	r24, r24
    19e8:	69 f1       	breq	.+90     	; 0x1a44 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    19ea:	e6 80       	ldd	r14, Z+6	; 0x06
    19ec:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    19ee:	b6 01       	movw	r22, r12
    19f0:	c8 01       	movw	r24, r16
    19f2:	18 de       	rcall	.-976    	; 0x1624 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    19f4:	b1 10       	cpse	r11, r1
    19f6:	17 c0       	rjmp	.+46     	; 0x1a26 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    19f8:	f8 01       	movw	r30, r16
    19fa:	82 8d       	ldd	r24, Z+26	; 0x1a
    19fc:	81 50       	subi	r24, 0x01	; 1
    19fe:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a00:	80 81       	ld	r24, Z
    1a02:	91 81       	ldd	r25, Z+1	; 0x01
    1a04:	89 2b       	or	r24, r25
    1a06:	21 f4       	brne	.+8      	; 0x1a10 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1a08:	75 d6       	rcall	.+3306   	; 0x26f4 <pvTaskIncrementMutexHeldCount>
    1a0a:	f8 01       	movw	r30, r16
    1a0c:	93 83       	std	Z+3, r25	; 0x03
    1a0e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a10:	f8 01       	movw	r30, r16
    1a12:	80 85       	ldd	r24, Z+8	; 0x08
    1a14:	88 23       	and	r24, r24
    1a16:	91 f0       	breq	.+36     	; 0x1a3c <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a18:	c8 01       	movw	r24, r16
    1a1a:	08 96       	adiw	r24, 0x08	; 8
    1a1c:	3f d5       	rcall	.+2686   	; 0x249c <xTaskRemoveFromEventList>
    1a1e:	81 30       	cpi	r24, 0x01	; 1
    1a20:	69 f4       	brne	.+26     	; 0x1a3c <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1a22:	da dc       	rcall	.-1612   	; 0x13d8 <vPortYield>
    1a24:	0b c0       	rjmp	.+22     	; 0x1a3c <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a26:	f8 01       	movw	r30, r16
    1a28:	f7 82       	std	Z+7, r15	; 0x07
    1a2a:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a2c:	81 89       	ldd	r24, Z+17	; 0x11
    1a2e:	88 23       	and	r24, r24
    1a30:	29 f0       	breq	.+10     	; 0x1a3c <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a32:	c8 01       	movw	r24, r16
    1a34:	41 96       	adiw	r24, 0x11	; 17
    1a36:	32 d5       	rcall	.+2660   	; 0x249c <xTaskRemoveFromEventList>
    1a38:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1a3a:	ce dc       	rcall	.-1636   	; 0x13d8 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	52 c0       	rjmp	.+164    	; 0x1ae8 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1a44:	4c 81       	ldd	r20, Y+4	; 0x04
    1a46:	5d 81       	ldd	r21, Y+5	; 0x05
    1a48:	45 2b       	or	r20, r21
    1a4a:	21 f4       	brne	.+8      	; 0x1a54 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a4c:	0f 90       	pop	r0
    1a4e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a50:	80 e0       	ldi	r24, 0x00	; 0
    1a52:	4a c0       	rjmp	.+148    	; 0x1ae8 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a54:	a1 10       	cpse	r10, r1
    1a56:	04 c0       	rjmp	.+8      	; 0x1a60 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a58:	ce 01       	movw	r24, r28
    1a5a:	01 96       	adiw	r24, 0x01	; 1
    1a5c:	67 d5       	rcall	.+2766   	; 0x252c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a5e:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1a60:	0f 90       	pop	r0
    1a62:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a64:	7a d2       	rcall	.+1268   	; 0x1f5a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a66:	0f b6       	in	r0, 0x3f	; 63
    1a68:	f8 94       	cli
    1a6a:	0f 92       	push	r0
    1a6c:	f8 01       	movw	r30, r16
    1a6e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a70:	8f 3f       	cpi	r24, 0xFF	; 255
    1a72:	09 f4       	brne	.+2      	; 0x1a76 <xQueueGenericReceive+0xd2>
    1a74:	15 8e       	std	Z+29, r1	; 0x1d
    1a76:	f8 01       	movw	r30, r16
    1a78:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a7c:	09 f4       	brne	.+2      	; 0x1a80 <xQueueGenericReceive+0xdc>
    1a7e:	16 8e       	std	Z+30, r1	; 0x1e
    1a80:	0f 90       	pop	r0
    1a82:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a84:	be 01       	movw	r22, r28
    1a86:	6c 5f       	subi	r22, 0xFC	; 252
    1a88:	7f 4f       	sbci	r23, 0xFF	; 255
    1a8a:	ce 01       	movw	r24, r28
    1a8c:	01 96       	adiw	r24, 0x01	; 1
    1a8e:	59 d5       	rcall	.+2738   	; 0x2542 <xTaskCheckForTimeOut>
    1a90:	81 11       	cpse	r24, r1
    1a92:	26 c0       	rjmp	.+76     	; 0x1ae0 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1a94:	0f b6       	in	r0, 0x3f	; 63
    1a96:	f8 94       	cli
    1a98:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1a9a:	f8 01       	movw	r30, r16
    1a9c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a9e:	0f 90       	pop	r0
    1aa0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1aa2:	81 11       	cpse	r24, r1
    1aa4:	19 c0       	rjmp	.+50     	; 0x1ad8 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1aa6:	f8 01       	movw	r30, r16
    1aa8:	80 81       	ld	r24, Z
    1aaa:	91 81       	ldd	r25, Z+1	; 0x01
    1aac:	89 2b       	or	r24, r25
    1aae:	49 f4       	brne	.+18     	; 0x1ac2 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	82 81       	ldd	r24, Z+2	; 0x02
    1aba:	93 81       	ldd	r25, Z+3	; 0x03
    1abc:	7e d5       	rcall	.+2812   	; 0x25ba <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1abe:	0f 90       	pop	r0
    1ac0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ac2:	6c 81       	ldd	r22, Y+4	; 0x04
    1ac4:	7d 81       	ldd	r23, Y+5	; 0x05
    1ac6:	c7 01       	movw	r24, r14
    1ac8:	be d4       	rcall	.+2428   	; 0x2446 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1aca:	c8 01       	movw	r24, r16
    1acc:	c5 dd       	rcall	.-1142   	; 0x1658 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ace:	18 d3       	rcall	.+1584   	; 0x2100 <xTaskResumeAll>
    1ad0:	81 11       	cpse	r24, r1
    1ad2:	84 cf       	rjmp	.-248    	; 0x19dc <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1ad4:	81 dc       	rcall	.-1790   	; 0x13d8 <vPortYield>
    1ad6:	82 cf       	rjmp	.-252    	; 0x19dc <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ad8:	c8 01       	movw	r24, r16
    1ada:	be dd       	rcall	.-1156   	; 0x1658 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1adc:	11 d3       	rcall	.+1570   	; 0x2100 <xTaskResumeAll>
    1ade:	7e cf       	rjmp	.-260    	; 0x19dc <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ae0:	c8 01       	movw	r24, r16
    1ae2:	ba dd       	rcall	.-1164   	; 0x1658 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ae4:	0d d3       	rcall	.+1562   	; 0x2100 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1ae8:	0f 90       	pop	r0
    1aea:	0f 90       	pop	r0
    1aec:	0f 90       	pop	r0
    1aee:	0f 90       	pop	r0
    1af0:	0f 90       	pop	r0
    1af2:	df 91       	pop	r29
    1af4:	cf 91       	pop	r28
    1af6:	1f 91       	pop	r17
    1af8:	0f 91       	pop	r16
    1afa:	ff 90       	pop	r15
    1afc:	ef 90       	pop	r14
    1afe:	df 90       	pop	r13
    1b00:	cf 90       	pop	r12
    1b02:	bf 90       	pop	r11
    1b04:	af 90       	pop	r10
    1b06:	9f 90       	pop	r9
    1b08:	08 95       	ret

00001b0a <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1b0a:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1b0c:	71 83       	std	Z+1, r23	; 0x01
    1b0e:	60 83       	st	Z, r22
	ring->rSize = size;
    1b10:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1b12:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1b14:	13 82       	std	Z+3, r1	; 0x03
    1b16:	08 95       	ret

00001b18 <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1b18:	dc 01       	movw	r26, r24
    1b1a:	14 96       	adiw	r26, 0x04	; 4
    1b1c:	2c 91       	ld	r18, X
    1b1e:	14 97       	sbiw	r26, 0x04	; 4
    1b20:	ed 91       	ld	r30, X+
    1b22:	fc 91       	ld	r31, X
    1b24:	e2 0f       	add	r30, r18
    1b26:	f1 1d       	adc	r31, r1
}
    1b28:	80 81       	ld	r24, Z
    1b2a:	08 95       	ret

00001b2c <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1b2c:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1b2e:	94 81       	ldd	r25, Z+4	; 0x04
    1b30:	a0 81       	ld	r26, Z
    1b32:	b1 81       	ldd	r27, Z+1	; 0x01
    1b34:	a9 0f       	add	r26, r25
    1b36:	b1 1d       	adc	r27, r1
    1b38:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1b3a:	9f 5f       	subi	r25, 0xFF	; 255
    1b3c:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1b3e:	22 81       	ldd	r18, Z+2	; 0x02
    1b40:	92 17       	cp	r25, r18
    1b42:	10 f0       	brcs	.+4      	; 0x1b48 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1b44:	92 1b       	sub	r25, r18
    1b46:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1b48:	93 81       	ldd	r25, Z+3	; 0x03
    1b4a:	91 50       	subi	r25, 0x01	; 1
    1b4c:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1b4e:	08 95       	ret

00001b50 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1b50:	fc 01       	movw	r30, r24
    1b52:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1b54:	83 81       	ldd	r24, Z+3	; 0x03
    1b56:	22 81       	ldd	r18, Z+2	; 0x02
    1b58:	82 17       	cp	r24, r18
    1b5a:	80 f4       	brcc	.+32     	; 0x1b7c <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1b5c:	34 81       	ldd	r19, Z+4	; 0x04
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	83 0f       	add	r24, r19
    1b62:	91 1d       	adc	r25, r1
    1b64:	62 2f       	mov	r22, r18
    1b66:	70 e0       	ldi	r23, 0x00	; 0
    1b68:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <__divmodhi4>
    1b6c:	a0 81       	ld	r26, Z
    1b6e:	b1 81       	ldd	r27, Z+1	; 0x01
    1b70:	a8 0f       	add	r26, r24
    1b72:	b9 1f       	adc	r27, r25
    1b74:	4c 93       	st	X, r20
            ring->rLength++;
    1b76:	83 81       	ldd	r24, Z+3	; 0x03
    1b78:	8f 5f       	subi	r24, 0xFF	; 255
    1b7a:	83 83       	std	Z+3, r24	; 0x03
    1b7c:	08 95       	ret

00001b7e <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1b7e:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	22 81       	ldd	r18, Z+2	; 0x02
    1b84:	93 81       	ldd	r25, Z+3	; 0x03
    1b86:	29 13       	cpse	r18, r25
    1b88:	80 e0       	ldi	r24, 0x00	; 0
}
    1b8a:	08 95       	ret

00001b8c <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1b8c:	21 e0       	ldi	r18, 0x01	; 1
    1b8e:	fc 01       	movw	r30, r24
    1b90:	83 81       	ldd	r24, Z+3	; 0x03
    1b92:	81 11       	cpse	r24, r1
    1b94:	01 c0       	rjmp	.+2      	; 0x1b98 <ringBufferNotEmpty+0xc>
    1b96:	20 e0       	ldi	r18, 0x00	; 0
}
    1b98:	82 2f       	mov	r24, r18
    1b9a:	08 95       	ret

00001b9c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1b9c:	e0 91 45 08 	lds	r30, 0x0845
    1ba0:	f0 91 46 08 	lds	r31, 0x0846
    1ba4:	80 81       	ld	r24, Z
    1ba6:	81 11       	cpse	r24, r1
    1ba8:	07 c0       	rjmp	.+14     	; 0x1bb8 <prvResetNextTaskUnblockTime+0x1c>
    1baa:	8f ef       	ldi	r24, 0xFF	; 255
    1bac:	9f ef       	ldi	r25, 0xFF	; 255
    1bae:	90 93 06 02 	sts	0x0206, r25
    1bb2:	80 93 05 02 	sts	0x0205, r24
    1bb6:	08 95       	ret
    1bb8:	e0 91 45 08 	lds	r30, 0x0845
    1bbc:	f0 91 46 08 	lds	r31, 0x0846
    1bc0:	05 80       	ldd	r0, Z+5	; 0x05
    1bc2:	f6 81       	ldd	r31, Z+6	; 0x06
    1bc4:	e0 2d       	mov	r30, r0
    1bc6:	06 80       	ldd	r0, Z+6	; 0x06
    1bc8:	f7 81       	ldd	r31, Z+7	; 0x07
    1bca:	e0 2d       	mov	r30, r0
    1bcc:	82 81       	ldd	r24, Z+2	; 0x02
    1bce:	93 81       	ldd	r25, Z+3	; 0x03
    1bd0:	90 93 06 02 	sts	0x0206, r25
    1bd4:	80 93 05 02 	sts	0x0205, r24
    1bd8:	08 95       	ret

00001bda <prvAddCurrentTaskToDelayedList>:
    1bda:	cf 93       	push	r28
    1bdc:	df 93       	push	r29
    1bde:	ec 01       	movw	r28, r24
    1be0:	e0 91 86 08 	lds	r30, 0x0886
    1be4:	f0 91 87 08 	lds	r31, 0x0887
    1be8:	93 83       	std	Z+3, r25	; 0x03
    1bea:	82 83       	std	Z+2, r24	; 0x02
    1bec:	80 91 24 08 	lds	r24, 0x0824
    1bf0:	90 91 25 08 	lds	r25, 0x0825
    1bf4:	c8 17       	cp	r28, r24
    1bf6:	d9 07       	cpc	r29, r25
    1bf8:	68 f4       	brcc	.+26     	; 0x1c14 <prvAddCurrentTaskToDelayedList+0x3a>
    1bfa:	60 91 86 08 	lds	r22, 0x0886
    1bfe:	70 91 87 08 	lds	r23, 0x0887
    1c02:	80 91 43 08 	lds	r24, 0x0843
    1c06:	90 91 44 08 	lds	r25, 0x0844
    1c0a:	6e 5f       	subi	r22, 0xFE	; 254
    1c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c0e:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsert>
    1c12:	17 c0       	rjmp	.+46     	; 0x1c42 <prvAddCurrentTaskToDelayedList+0x68>
    1c14:	60 91 86 08 	lds	r22, 0x0886
    1c18:	70 91 87 08 	lds	r23, 0x0887
    1c1c:	80 91 45 08 	lds	r24, 0x0845
    1c20:	90 91 46 08 	lds	r25, 0x0846
    1c24:	6e 5f       	subi	r22, 0xFE	; 254
    1c26:	7f 4f       	sbci	r23, 0xFF	; 255
    1c28:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsert>
    1c2c:	80 91 05 02 	lds	r24, 0x0205
    1c30:	90 91 06 02 	lds	r25, 0x0206
    1c34:	c8 17       	cp	r28, r24
    1c36:	d9 07       	cpc	r29, r25
    1c38:	20 f4       	brcc	.+8      	; 0x1c42 <prvAddCurrentTaskToDelayedList+0x68>
    1c3a:	d0 93 06 02 	sts	0x0206, r29
    1c3e:	c0 93 05 02 	sts	0x0205, r28
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	08 95       	ret

00001c48 <xTaskGenericCreate>:
    1c48:	4f 92       	push	r4
    1c4a:	5f 92       	push	r5
    1c4c:	6f 92       	push	r6
    1c4e:	7f 92       	push	r7
    1c50:	8f 92       	push	r8
    1c52:	9f 92       	push	r9
    1c54:	af 92       	push	r10
    1c56:	bf 92       	push	r11
    1c58:	cf 92       	push	r12
    1c5a:	df 92       	push	r13
    1c5c:	ef 92       	push	r14
    1c5e:	ff 92       	push	r15
    1c60:	0f 93       	push	r16
    1c62:	1f 93       	push	r17
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	4c 01       	movw	r8, r24
    1c6a:	5b 01       	movw	r10, r22
    1c6c:	2a 01       	movw	r4, r20
    1c6e:	39 01       	movw	r6, r18
    1c70:	83 e2       	ldi	r24, 0x23	; 35
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	0e 94 f5 02 	call	0x5ea	; 0x5ea <pvPortMalloc>
    1c78:	ec 01       	movw	r28, r24
    1c7a:	00 97       	sbiw	r24, 0x00	; 0
    1c7c:	09 f4       	brne	.+2      	; 0x1c80 <xTaskGenericCreate+0x38>
    1c7e:	e7 c0       	rjmp	.+462    	; 0x1e4e <xTaskGenericCreate+0x206>
    1c80:	c1 14       	cp	r12, r1
    1c82:	d1 04       	cpc	r13, r1
    1c84:	09 f0       	breq	.+2      	; 0x1c88 <xTaskGenericCreate+0x40>
    1c86:	cc c0       	rjmp	.+408    	; 0x1e20 <xTaskGenericCreate+0x1d8>
    1c88:	c2 01       	movw	r24, r4
    1c8a:	0e 94 f5 02 	call	0x5ea	; 0x5ea <pvPortMalloc>
    1c8e:	98 8f       	std	Y+24, r25	; 0x18
    1c90:	8f 8b       	std	Y+23, r24	; 0x17
    1c92:	89 2b       	or	r24, r25
    1c94:	09 f0       	breq	.+2      	; 0x1c98 <xTaskGenericCreate+0x50>
    1c96:	c6 c0       	rjmp	.+396    	; 0x1e24 <xTaskGenericCreate+0x1dc>
    1c98:	ce 01       	movw	r24, r28
    1c9a:	0e 94 2a 03 	call	0x654	; 0x654 <vPortFree>
    1c9e:	d7 c0       	rjmp	.+430    	; 0x1e4e <xTaskGenericCreate+0x206>
    1ca0:	cf 01       	movw	r24, r30
    1ca2:	31 91       	ld	r19, Z+
    1ca4:	da 01       	movw	r26, r20
    1ca6:	3d 93       	st	X+, r19
    1ca8:	ad 01       	movw	r20, r26
    1caa:	dc 01       	movw	r26, r24
    1cac:	8c 91       	ld	r24, X
    1cae:	88 23       	and	r24, r24
    1cb0:	11 f0       	breq	.+4      	; 0x1cb6 <xTaskGenericCreate+0x6e>
    1cb2:	21 50       	subi	r18, 0x01	; 1
    1cb4:	a9 f7       	brne	.-22     	; 0x1ca0 <xTaskGenericCreate+0x58>
    1cb6:	18 a2       	std	Y+32, r1	; 0x20
    1cb8:	10 2f       	mov	r17, r16
    1cba:	05 30       	cpi	r16, 0x05	; 5
    1cbc:	08 f0       	brcs	.+2      	; 0x1cc0 <xTaskGenericCreate+0x78>
    1cbe:	14 e0       	ldi	r17, 0x04	; 4
    1cc0:	1e 8b       	std	Y+22, r17	; 0x16
    1cc2:	19 a3       	std	Y+33, r17	; 0x21
    1cc4:	1a a2       	std	Y+34, r1	; 0x22
    1cc6:	5e 01       	movw	r10, r28
    1cc8:	b2 e0       	ldi	r27, 0x02	; 2
    1cca:	ab 0e       	add	r10, r27
    1ccc:	b1 1c       	adc	r11, r1
    1cce:	c5 01       	movw	r24, r10
    1cd0:	0e 94 39 03 	call	0x672	; 0x672 <vListInitialiseItem>
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	0c 96       	adiw	r24, 0x0c	; 12
    1cd8:	0e 94 39 03 	call	0x672	; 0x672 <vListInitialiseItem>
    1cdc:	d9 87       	std	Y+9, r29	; 0x09
    1cde:	c8 87       	std	Y+8, r28	; 0x08
    1ce0:	85 e0       	ldi	r24, 0x05	; 5
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	81 1b       	sub	r24, r17
    1ce6:	91 09       	sbc	r25, r1
    1ce8:	9d 87       	std	Y+13, r25	; 0x0d
    1cea:	8c 87       	std	Y+12, r24	; 0x0c
    1cec:	db 8b       	std	Y+19, r29	; 0x13
    1cee:	ca 8b       	std	Y+18, r28	; 0x12
    1cf0:	a3 01       	movw	r20, r6
    1cf2:	b4 01       	movw	r22, r8
    1cf4:	c6 01       	movw	r24, r12
    1cf6:	c1 da       	rcall	.-2686   	; 0x127a <pxPortInitialiseStack>
    1cf8:	99 83       	std	Y+1, r25	; 0x01
    1cfa:	88 83       	st	Y, r24
    1cfc:	e1 14       	cp	r14, r1
    1cfe:	f1 04       	cpc	r15, r1
    1d00:	19 f0       	breq	.+6      	; 0x1d08 <xTaskGenericCreate+0xc0>
    1d02:	f7 01       	movw	r30, r14
    1d04:	d1 83       	std	Z+1, r29	; 0x01
    1d06:	c0 83       	st	Z, r28
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	0f 92       	push	r0
    1d0e:	80 91 26 08 	lds	r24, 0x0826
    1d12:	8f 5f       	subi	r24, 0xFF	; 255
    1d14:	80 93 26 08 	sts	0x0826, r24
    1d18:	80 91 86 08 	lds	r24, 0x0886
    1d1c:	90 91 87 08 	lds	r25, 0x0887
    1d20:	89 2b       	or	r24, r25
    1d22:	09 f0       	breq	.+2      	; 0x1d26 <xTaskGenericCreate+0xde>
    1d24:	3f c0       	rjmp	.+126    	; 0x1da4 <xTaskGenericCreate+0x15c>
    1d26:	d0 93 87 08 	sts	0x0887, r29
    1d2a:	c0 93 86 08 	sts	0x0886, r28
    1d2e:	80 91 26 08 	lds	r24, 0x0826
    1d32:	81 30       	cpi	r24, 0x01	; 1
    1d34:	09 f0       	breq	.+2      	; 0x1d38 <xTaskGenericCreate+0xf0>
    1d36:	45 c0       	rjmp	.+138    	; 0x1dc2 <xTaskGenericCreate+0x17a>
    1d38:	0f 2e       	mov	r0, r31
    1d3a:	f9 e5       	ldi	r31, 0x59	; 89
    1d3c:	ef 2e       	mov	r14, r31
    1d3e:	f8 e0       	ldi	r31, 0x08	; 8
    1d40:	ff 2e       	mov	r15, r31
    1d42:	f0 2d       	mov	r31, r0
    1d44:	0f 2e       	mov	r0, r31
    1d46:	f6 e8       	ldi	r31, 0x86	; 134
    1d48:	cf 2e       	mov	r12, r31
    1d4a:	f8 e0       	ldi	r31, 0x08	; 8
    1d4c:	df 2e       	mov	r13, r31
    1d4e:	f0 2d       	mov	r31, r0
    1d50:	c7 01       	movw	r24, r14
    1d52:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d56:	f9 e0       	ldi	r31, 0x09	; 9
    1d58:	ef 0e       	add	r14, r31
    1d5a:	f1 1c       	adc	r15, r1
    1d5c:	ec 14       	cp	r14, r12
    1d5e:	fd 04       	cpc	r15, r13
    1d60:	b9 f7       	brne	.-18     	; 0x1d50 <xTaskGenericCreate+0x108>
    1d62:	80 e5       	ldi	r24, 0x50	; 80
    1d64:	98 e0       	ldi	r25, 0x08	; 8
    1d66:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d6a:	87 e4       	ldi	r24, 0x47	; 71
    1d6c:	98 e0       	ldi	r25, 0x08	; 8
    1d6e:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d72:	8a e3       	ldi	r24, 0x3A	; 58
    1d74:	98 e0       	ldi	r25, 0x08	; 8
    1d76:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d7a:	81 e3       	ldi	r24, 0x31	; 49
    1d7c:	98 e0       	ldi	r25, 0x08	; 8
    1d7e:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d82:	87 e2       	ldi	r24, 0x27	; 39
    1d84:	98 e0       	ldi	r25, 0x08	; 8
    1d86:	0e 94 2b 03 	call	0x656	; 0x656 <vListInitialise>
    1d8a:	80 e5       	ldi	r24, 0x50	; 80
    1d8c:	98 e0       	ldi	r25, 0x08	; 8
    1d8e:	90 93 46 08 	sts	0x0846, r25
    1d92:	80 93 45 08 	sts	0x0845, r24
    1d96:	87 e4       	ldi	r24, 0x47	; 71
    1d98:	98 e0       	ldi	r25, 0x08	; 8
    1d9a:	90 93 44 08 	sts	0x0844, r25
    1d9e:	80 93 43 08 	sts	0x0843, r24
    1da2:	0f c0       	rjmp	.+30     	; 0x1dc2 <xTaskGenericCreate+0x17a>
    1da4:	80 91 22 08 	lds	r24, 0x0822
    1da8:	81 11       	cpse	r24, r1
    1daa:	0b c0       	rjmp	.+22     	; 0x1dc2 <xTaskGenericCreate+0x17a>
    1dac:	e0 91 86 08 	lds	r30, 0x0886
    1db0:	f0 91 87 08 	lds	r31, 0x0887
    1db4:	86 89       	ldd	r24, Z+22	; 0x16
    1db6:	08 17       	cp	r16, r24
    1db8:	20 f0       	brcs	.+8      	; 0x1dc2 <xTaskGenericCreate+0x17a>
    1dba:	d0 93 87 08 	sts	0x0887, r29
    1dbe:	c0 93 86 08 	sts	0x0886, r28
    1dc2:	80 91 1e 08 	lds	r24, 0x081E
    1dc6:	8f 5f       	subi	r24, 0xFF	; 255
    1dc8:	80 93 1e 08 	sts	0x081E, r24
    1dcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1dce:	90 91 23 08 	lds	r25, 0x0823
    1dd2:	98 17       	cp	r25, r24
    1dd4:	10 f4       	brcc	.+4      	; 0x1dda <xTaskGenericCreate+0x192>
    1dd6:	80 93 23 08 	sts	0x0823, r24
    1dda:	90 e0       	ldi	r25, 0x00	; 0
    1ddc:	9c 01       	movw	r18, r24
    1dde:	22 0f       	add	r18, r18
    1de0:	33 1f       	adc	r19, r19
    1de2:	22 0f       	add	r18, r18
    1de4:	33 1f       	adc	r19, r19
    1de6:	22 0f       	add	r18, r18
    1de8:	33 1f       	adc	r19, r19
    1dea:	82 0f       	add	r24, r18
    1dec:	93 1f       	adc	r25, r19
    1dee:	b5 01       	movw	r22, r10
    1df0:	87 5a       	subi	r24, 0xA7	; 167
    1df2:	97 4f       	sbci	r25, 0xF7	; 247
    1df4:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    1df8:	0f 90       	pop	r0
    1dfa:	0f be       	out	0x3f, r0	; 63
    1dfc:	80 91 22 08 	lds	r24, 0x0822
    1e00:	88 23       	and	r24, r24
    1e02:	51 f0       	breq	.+20     	; 0x1e18 <xTaskGenericCreate+0x1d0>
    1e04:	e0 91 86 08 	lds	r30, 0x0886
    1e08:	f0 91 87 08 	lds	r31, 0x0887
    1e0c:	86 89       	ldd	r24, Z+22	; 0x16
    1e0e:	80 17       	cp	r24, r16
    1e10:	28 f4       	brcc	.+10     	; 0x1e1c <xTaskGenericCreate+0x1d4>
    1e12:	e2 da       	rcall	.-2620   	; 0x13d8 <vPortYield>
    1e14:	81 e0       	ldi	r24, 0x01	; 1
    1e16:	1c c0       	rjmp	.+56     	; 0x1e50 <xTaskGenericCreate+0x208>
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	1a c0       	rjmp	.+52     	; 0x1e50 <xTaskGenericCreate+0x208>
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	18 c0       	rjmp	.+48     	; 0x1e50 <xTaskGenericCreate+0x208>
    1e20:	d8 8e       	std	Y+24, r13	; 0x18
    1e22:	cf 8a       	std	Y+23, r12	; 0x17
    1e24:	81 e0       	ldi	r24, 0x01	; 1
    1e26:	48 1a       	sub	r4, r24
    1e28:	51 08       	sbc	r5, r1
    1e2a:	cf 88       	ldd	r12, Y+23	; 0x17
    1e2c:	d8 8c       	ldd	r13, Y+24	; 0x18
    1e2e:	c4 0c       	add	r12, r4
    1e30:	d5 1c       	adc	r13, r5
    1e32:	d5 01       	movw	r26, r10
    1e34:	8c 91       	ld	r24, X
    1e36:	89 8f       	std	Y+25, r24	; 0x19
    1e38:	8c 91       	ld	r24, X
    1e3a:	88 23       	and	r24, r24
    1e3c:	09 f4       	brne	.+2      	; 0x1e40 <xTaskGenericCreate+0x1f8>
    1e3e:	3b cf       	rjmp	.-394    	; 0x1cb6 <xTaskGenericCreate+0x6e>
    1e40:	ae 01       	movw	r20, r28
    1e42:	46 5e       	subi	r20, 0xE6	; 230
    1e44:	5f 4f       	sbci	r21, 0xFF	; 255
    1e46:	f5 01       	movw	r30, r10
    1e48:	31 96       	adiw	r30, 0x01	; 1
    1e4a:	27 e0       	ldi	r18, 0x07	; 7
    1e4c:	29 cf       	rjmp	.-430    	; 0x1ca0 <xTaskGenericCreate+0x58>
    1e4e:	8f ef       	ldi	r24, 0xFF	; 255
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	1f 91       	pop	r17
    1e56:	0f 91       	pop	r16
    1e58:	ff 90       	pop	r15
    1e5a:	ef 90       	pop	r14
    1e5c:	df 90       	pop	r13
    1e5e:	cf 90       	pop	r12
    1e60:	bf 90       	pop	r11
    1e62:	af 90       	pop	r10
    1e64:	9f 90       	pop	r9
    1e66:	8f 90       	pop	r8
    1e68:	7f 90       	pop	r7
    1e6a:	6f 90       	pop	r6
    1e6c:	5f 90       	pop	r5
    1e6e:	4f 90       	pop	r4
    1e70:	08 95       	ret

00001e72 <vTaskResume>:
    1e72:	0f 93       	push	r16
    1e74:	1f 93       	push	r17
    1e76:	cf 93       	push	r28
    1e78:	df 93       	push	r29
    1e7a:	ec 01       	movw	r28, r24
    1e7c:	00 97       	sbiw	r24, 0x00	; 0
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <vTaskResume+0x10>
    1e80:	3e c0       	rjmp	.+124    	; 0x1efe <vTaskResume+0x8c>
    1e82:	80 91 86 08 	lds	r24, 0x0886
    1e86:	90 91 87 08 	lds	r25, 0x0887
    1e8a:	c8 17       	cp	r28, r24
    1e8c:	d9 07       	cpc	r29, r25
    1e8e:	b9 f1       	breq	.+110    	; 0x1efe <vTaskResume+0x8c>
    1e90:	0f b6       	in	r0, 0x3f	; 63
    1e92:	f8 94       	cli
    1e94:	0f 92       	push	r0
    1e96:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e98:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e9a:	87 52       	subi	r24, 0x27	; 39
    1e9c:	98 40       	sbci	r25, 0x08	; 8
    1e9e:	69 f5       	brne	.+90     	; 0x1efa <vTaskResume+0x88>
    1ea0:	8c 89       	ldd	r24, Y+20	; 0x14
    1ea2:	9d 89       	ldd	r25, Y+21	; 0x15
    1ea4:	28 e0       	ldi	r18, 0x08	; 8
    1ea6:	8a 33       	cpi	r24, 0x3A	; 58
    1ea8:	92 07       	cpc	r25, r18
    1eaa:	39 f1       	breq	.+78     	; 0x1efa <vTaskResume+0x88>
    1eac:	89 2b       	or	r24, r25
    1eae:	29 f5       	brne	.+74     	; 0x1efa <vTaskResume+0x88>
    1eb0:	8e 01       	movw	r16, r28
    1eb2:	0e 5f       	subi	r16, 0xFE	; 254
    1eb4:	1f 4f       	sbci	r17, 0xFF	; 255
    1eb6:	c8 01       	movw	r24, r16
    1eb8:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    1ebc:	8e 89       	ldd	r24, Y+22	; 0x16
    1ebe:	90 91 23 08 	lds	r25, 0x0823
    1ec2:	98 17       	cp	r25, r24
    1ec4:	10 f4       	brcc	.+4      	; 0x1eca <vTaskResume+0x58>
    1ec6:	80 93 23 08 	sts	0x0823, r24
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	9c 01       	movw	r18, r24
    1ece:	22 0f       	add	r18, r18
    1ed0:	33 1f       	adc	r19, r19
    1ed2:	22 0f       	add	r18, r18
    1ed4:	33 1f       	adc	r19, r19
    1ed6:	22 0f       	add	r18, r18
    1ed8:	33 1f       	adc	r19, r19
    1eda:	82 0f       	add	r24, r18
    1edc:	93 1f       	adc	r25, r19
    1ede:	b8 01       	movw	r22, r16
    1ee0:	87 5a       	subi	r24, 0xA7	; 167
    1ee2:	97 4f       	sbci	r25, 0xF7	; 247
    1ee4:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    1ee8:	e0 91 86 08 	lds	r30, 0x0886
    1eec:	f0 91 87 08 	lds	r31, 0x0887
    1ef0:	9e 89       	ldd	r25, Y+22	; 0x16
    1ef2:	86 89       	ldd	r24, Z+22	; 0x16
    1ef4:	98 17       	cp	r25, r24
    1ef6:	08 f0       	brcs	.+2      	; 0x1efa <vTaskResume+0x88>
    1ef8:	6f da       	rcall	.-2850   	; 0x13d8 <vPortYield>
    1efa:	0f 90       	pop	r0
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	df 91       	pop	r29
    1f00:	cf 91       	pop	r28
    1f02:	1f 91       	pop	r17
    1f04:	0f 91       	pop	r16
    1f06:	08 95       	ret

00001f08 <vTaskStartScheduler>:
    1f08:	af 92       	push	r10
    1f0a:	bf 92       	push	r11
    1f0c:	cf 92       	push	r12
    1f0e:	df 92       	push	r13
    1f10:	ef 92       	push	r14
    1f12:	ff 92       	push	r15
    1f14:	0f 93       	push	r16
    1f16:	a1 2c       	mov	r10, r1
    1f18:	b1 2c       	mov	r11, r1
    1f1a:	c1 2c       	mov	r12, r1
    1f1c:	d1 2c       	mov	r13, r1
    1f1e:	e1 2c       	mov	r14, r1
    1f20:	f1 2c       	mov	r15, r1
    1f22:	00 e0       	ldi	r16, 0x00	; 0
    1f24:	20 e0       	ldi	r18, 0x00	; 0
    1f26:	30 e0       	ldi	r19, 0x00	; 0
    1f28:	45 e5       	ldi	r20, 0x55	; 85
    1f2a:	50 e0       	ldi	r21, 0x00	; 0
    1f2c:	63 e3       	ldi	r22, 0x33	; 51
    1f2e:	72 e0       	ldi	r23, 0x02	; 2
    1f30:	8f e3       	ldi	r24, 0x3F	; 63
    1f32:	91 e1       	ldi	r25, 0x11	; 17
    1f34:	89 de       	rcall	.-750    	; 0x1c48 <xTaskGenericCreate>
    1f36:	81 30       	cpi	r24, 0x01	; 1
    1f38:	41 f4       	brne	.+16     	; 0x1f4a <vTaskStartScheduler+0x42>
    1f3a:	f8 94       	cli
    1f3c:	80 93 22 08 	sts	0x0822, r24
    1f40:	10 92 25 08 	sts	0x0825, r1
    1f44:	10 92 24 08 	sts	0x0824, r1
    1f48:	0a da       	rcall	.-3052   	; 0x135e <xPortStartScheduler>
    1f4a:	0f 91       	pop	r16
    1f4c:	ff 90       	pop	r15
    1f4e:	ef 90       	pop	r14
    1f50:	df 90       	pop	r13
    1f52:	cf 90       	pop	r12
    1f54:	bf 90       	pop	r11
    1f56:	af 90       	pop	r10
    1f58:	08 95       	ret

00001f5a <vTaskSuspendAll>:
    1f5a:	80 91 1d 08 	lds	r24, 0x081D
    1f5e:	8f 5f       	subi	r24, 0xFF	; 255
    1f60:	80 93 1d 08 	sts	0x081D, r24
    1f64:	08 95       	ret

00001f66 <xTaskGetTickCount>:
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	0f 92       	push	r0
    1f6c:	80 91 24 08 	lds	r24, 0x0824
    1f70:	90 91 25 08 	lds	r25, 0x0825
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63
    1f78:	08 95       	ret

00001f7a <xTaskGetTickCountFromISR>:
    1f7a:	80 91 24 08 	lds	r24, 0x0824
    1f7e:	90 91 25 08 	lds	r25, 0x0825
    1f82:	08 95       	ret

00001f84 <xTaskIncrementTick>:
    1f84:	cf 92       	push	r12
    1f86:	df 92       	push	r13
    1f88:	ef 92       	push	r14
    1f8a:	ff 92       	push	r15
    1f8c:	0f 93       	push	r16
    1f8e:	1f 93       	push	r17
    1f90:	cf 93       	push	r28
    1f92:	df 93       	push	r29
    1f94:	80 91 1d 08 	lds	r24, 0x081D
    1f98:	81 11       	cpse	r24, r1
    1f9a:	99 c0       	rjmp	.+306    	; 0x20ce <xTaskIncrementTick+0x14a>
    1f9c:	80 91 24 08 	lds	r24, 0x0824
    1fa0:	90 91 25 08 	lds	r25, 0x0825
    1fa4:	01 96       	adiw	r24, 0x01	; 1
    1fa6:	90 93 25 08 	sts	0x0825, r25
    1faa:	80 93 24 08 	sts	0x0824, r24
    1fae:	e0 90 24 08 	lds	r14, 0x0824
    1fb2:	f0 90 25 08 	lds	r15, 0x0825
    1fb6:	e1 14       	cp	r14, r1
    1fb8:	f1 04       	cpc	r15, r1
    1fba:	b1 f4       	brne	.+44     	; 0x1fe8 <xTaskIncrementTick+0x64>
    1fbc:	80 91 45 08 	lds	r24, 0x0845
    1fc0:	90 91 46 08 	lds	r25, 0x0846
    1fc4:	20 91 43 08 	lds	r18, 0x0843
    1fc8:	30 91 44 08 	lds	r19, 0x0844
    1fcc:	30 93 46 08 	sts	0x0846, r19
    1fd0:	20 93 45 08 	sts	0x0845, r18
    1fd4:	90 93 44 08 	sts	0x0844, r25
    1fd8:	80 93 43 08 	sts	0x0843, r24
    1fdc:	80 91 1f 08 	lds	r24, 0x081F
    1fe0:	8f 5f       	subi	r24, 0xFF	; 255
    1fe2:	80 93 1f 08 	sts	0x081F, r24
    1fe6:	da dd       	rcall	.-1100   	; 0x1b9c <prvResetNextTaskUnblockTime>
    1fe8:	80 91 05 02 	lds	r24, 0x0205
    1fec:	90 91 06 02 	lds	r25, 0x0206
    1ff0:	e8 16       	cp	r14, r24
    1ff2:	f9 06       	cpc	r15, r25
    1ff4:	08 f4       	brcc	.+2      	; 0x1ff8 <xTaskIncrementTick+0x74>
    1ff6:	54 c0       	rjmp	.+168    	; 0x20a0 <xTaskIncrementTick+0x11c>
    1ff8:	d1 2c       	mov	r13, r1
    1ffa:	cc 24       	eor	r12, r12
    1ffc:	c3 94       	inc	r12
    1ffe:	01 c0       	rjmp	.+2      	; 0x2002 <xTaskIncrementTick+0x7e>
    2000:	dc 2c       	mov	r13, r12
    2002:	e0 91 45 08 	lds	r30, 0x0845
    2006:	f0 91 46 08 	lds	r31, 0x0846
    200a:	80 81       	ld	r24, Z
    200c:	81 11       	cpse	r24, r1
    200e:	07 c0       	rjmp	.+14     	; 0x201e <xTaskIncrementTick+0x9a>
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	9f ef       	ldi	r25, 0xFF	; 255
    2014:	90 93 06 02 	sts	0x0206, r25
    2018:	80 93 05 02 	sts	0x0205, r24
    201c:	42 c0       	rjmp	.+132    	; 0x20a2 <xTaskIncrementTick+0x11e>
    201e:	e0 91 45 08 	lds	r30, 0x0845
    2022:	f0 91 46 08 	lds	r31, 0x0846
    2026:	05 80       	ldd	r0, Z+5	; 0x05
    2028:	f6 81       	ldd	r31, Z+6	; 0x06
    202a:	e0 2d       	mov	r30, r0
    202c:	c6 81       	ldd	r28, Z+6	; 0x06
    202e:	d7 81       	ldd	r29, Z+7	; 0x07
    2030:	2a 81       	ldd	r18, Y+2	; 0x02
    2032:	3b 81       	ldd	r19, Y+3	; 0x03
    2034:	e2 16       	cp	r14, r18
    2036:	f3 06       	cpc	r15, r19
    2038:	28 f4       	brcc	.+10     	; 0x2044 <xTaskIncrementTick+0xc0>
    203a:	30 93 06 02 	sts	0x0206, r19
    203e:	20 93 05 02 	sts	0x0205, r18
    2042:	2f c0       	rjmp	.+94     	; 0x20a2 <xTaskIncrementTick+0x11e>
    2044:	8e 01       	movw	r16, r28
    2046:	0e 5f       	subi	r16, 0xFE	; 254
    2048:	1f 4f       	sbci	r17, 0xFF	; 255
    204a:	c8 01       	movw	r24, r16
    204c:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2050:	8c 89       	ldd	r24, Y+20	; 0x14
    2052:	9d 89       	ldd	r25, Y+21	; 0x15
    2054:	89 2b       	or	r24, r25
    2056:	21 f0       	breq	.+8      	; 0x2060 <xTaskIncrementTick+0xdc>
    2058:	ce 01       	movw	r24, r28
    205a:	0c 96       	adiw	r24, 0x0c	; 12
    205c:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2060:	2e 89       	ldd	r18, Y+22	; 0x16
    2062:	80 91 23 08 	lds	r24, 0x0823
    2066:	82 17       	cp	r24, r18
    2068:	10 f4       	brcc	.+4      	; 0x206e <xTaskIncrementTick+0xea>
    206a:	20 93 23 08 	sts	0x0823, r18
    206e:	30 e0       	ldi	r19, 0x00	; 0
    2070:	c9 01       	movw	r24, r18
    2072:	88 0f       	add	r24, r24
    2074:	99 1f       	adc	r25, r25
    2076:	88 0f       	add	r24, r24
    2078:	99 1f       	adc	r25, r25
    207a:	88 0f       	add	r24, r24
    207c:	99 1f       	adc	r25, r25
    207e:	82 0f       	add	r24, r18
    2080:	93 1f       	adc	r25, r19
    2082:	b8 01       	movw	r22, r16
    2084:	87 5a       	subi	r24, 0xA7	; 167
    2086:	97 4f       	sbci	r25, 0xF7	; 247
    2088:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    208c:	e0 91 86 08 	lds	r30, 0x0886
    2090:	f0 91 87 08 	lds	r31, 0x0887
    2094:	9e 89       	ldd	r25, Y+22	; 0x16
    2096:	86 89       	ldd	r24, Z+22	; 0x16
    2098:	98 17       	cp	r25, r24
    209a:	08 f0       	brcs	.+2      	; 0x209e <xTaskIncrementTick+0x11a>
    209c:	b1 cf       	rjmp	.-158    	; 0x2000 <xTaskIncrementTick+0x7c>
    209e:	b1 cf       	rjmp	.-158    	; 0x2002 <xTaskIncrementTick+0x7e>
    20a0:	d1 2c       	mov	r13, r1
    20a2:	e0 91 86 08 	lds	r30, 0x0886
    20a6:	f0 91 87 08 	lds	r31, 0x0887
    20aa:	86 89       	ldd	r24, Z+22	; 0x16
    20ac:	90 e0       	ldi	r25, 0x00	; 0
    20ae:	fc 01       	movw	r30, r24
    20b0:	ee 0f       	add	r30, r30
    20b2:	ff 1f       	adc	r31, r31
    20b4:	ee 0f       	add	r30, r30
    20b6:	ff 1f       	adc	r31, r31
    20b8:	ee 0f       	add	r30, r30
    20ba:	ff 1f       	adc	r31, r31
    20bc:	8e 0f       	add	r24, r30
    20be:	9f 1f       	adc	r25, r31
    20c0:	fc 01       	movw	r30, r24
    20c2:	e7 5a       	subi	r30, 0xA7	; 167
    20c4:	f7 4f       	sbci	r31, 0xF7	; 247
    20c6:	80 81       	ld	r24, Z
    20c8:	82 30       	cpi	r24, 0x02	; 2
    20ca:	40 f4       	brcc	.+16     	; 0x20dc <xTaskIncrementTick+0x158>
    20cc:	09 c0       	rjmp	.+18     	; 0x20e0 <xTaskIncrementTick+0x15c>
    20ce:	80 91 21 08 	lds	r24, 0x0821
    20d2:	8f 5f       	subi	r24, 0xFF	; 255
    20d4:	80 93 21 08 	sts	0x0821, r24
    20d8:	d1 2c       	mov	r13, r1
    20da:	02 c0       	rjmp	.+4      	; 0x20e0 <xTaskIncrementTick+0x15c>
    20dc:	dd 24       	eor	r13, r13
    20de:	d3 94       	inc	r13
    20e0:	80 91 20 08 	lds	r24, 0x0820
    20e4:	88 23       	and	r24, r24
    20e6:	11 f0       	breq	.+4      	; 0x20ec <xTaskIncrementTick+0x168>
    20e8:	dd 24       	eor	r13, r13
    20ea:	d3 94       	inc	r13
    20ec:	8d 2d       	mov	r24, r13
    20ee:	df 91       	pop	r29
    20f0:	cf 91       	pop	r28
    20f2:	1f 91       	pop	r17
    20f4:	0f 91       	pop	r16
    20f6:	ff 90       	pop	r15
    20f8:	ef 90       	pop	r14
    20fa:	df 90       	pop	r13
    20fc:	cf 90       	pop	r12
    20fe:	08 95       	ret

00002100 <xTaskResumeAll>:
    2100:	df 92       	push	r13
    2102:	ef 92       	push	r14
    2104:	ff 92       	push	r15
    2106:	0f 93       	push	r16
    2108:	1f 93       	push	r17
    210a:	cf 93       	push	r28
    210c:	df 93       	push	r29
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	0f 92       	push	r0
    2114:	80 91 1d 08 	lds	r24, 0x081D
    2118:	81 50       	subi	r24, 0x01	; 1
    211a:	80 93 1d 08 	sts	0x081D, r24
    211e:	80 91 1d 08 	lds	r24, 0x081D
    2122:	81 11       	cpse	r24, r1
    2124:	5f c0       	rjmp	.+190    	; 0x21e4 <xTaskResumeAll+0xe4>
    2126:	80 91 26 08 	lds	r24, 0x0826
    212a:	88 23       	and	r24, r24
    212c:	09 f4       	brne	.+2      	; 0x2130 <xTaskResumeAll+0x30>
    212e:	5c c0       	rjmp	.+184    	; 0x21e8 <xTaskResumeAll+0xe8>
    2130:	0f 2e       	mov	r0, r31
    2132:	fa e3       	ldi	r31, 0x3A	; 58
    2134:	ef 2e       	mov	r14, r31
    2136:	f8 e0       	ldi	r31, 0x08	; 8
    2138:	ff 2e       	mov	r15, r31
    213a:	f0 2d       	mov	r31, r0
    213c:	dd 24       	eor	r13, r13
    213e:	d3 94       	inc	r13
    2140:	30 c0       	rjmp	.+96     	; 0x21a2 <xTaskResumeAll+0xa2>
    2142:	e0 91 3f 08 	lds	r30, 0x083F
    2146:	f0 91 40 08 	lds	r31, 0x0840
    214a:	c6 81       	ldd	r28, Z+6	; 0x06
    214c:	d7 81       	ldd	r29, Z+7	; 0x07
    214e:	ce 01       	movw	r24, r28
    2150:	0c 96       	adiw	r24, 0x0c	; 12
    2152:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2156:	8e 01       	movw	r16, r28
    2158:	0e 5f       	subi	r16, 0xFE	; 254
    215a:	1f 4f       	sbci	r17, 0xFF	; 255
    215c:	c8 01       	movw	r24, r16
    215e:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2162:	8e 89       	ldd	r24, Y+22	; 0x16
    2164:	90 91 23 08 	lds	r25, 0x0823
    2168:	98 17       	cp	r25, r24
    216a:	10 f4       	brcc	.+4      	; 0x2170 <xTaskResumeAll+0x70>
    216c:	80 93 23 08 	sts	0x0823, r24
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	9c 01       	movw	r18, r24
    2174:	22 0f       	add	r18, r18
    2176:	33 1f       	adc	r19, r19
    2178:	22 0f       	add	r18, r18
    217a:	33 1f       	adc	r19, r19
    217c:	22 0f       	add	r18, r18
    217e:	33 1f       	adc	r19, r19
    2180:	82 0f       	add	r24, r18
    2182:	93 1f       	adc	r25, r19
    2184:	b8 01       	movw	r22, r16
    2186:	87 5a       	subi	r24, 0xA7	; 167
    2188:	97 4f       	sbci	r25, 0xF7	; 247
    218a:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    218e:	e0 91 86 08 	lds	r30, 0x0886
    2192:	f0 91 87 08 	lds	r31, 0x0887
    2196:	9e 89       	ldd	r25, Y+22	; 0x16
    2198:	86 89       	ldd	r24, Z+22	; 0x16
    219a:	98 17       	cp	r25, r24
    219c:	10 f0       	brcs	.+4      	; 0x21a2 <xTaskResumeAll+0xa2>
    219e:	d0 92 20 08 	sts	0x0820, r13
    21a2:	f7 01       	movw	r30, r14
    21a4:	80 81       	ld	r24, Z
    21a6:	81 11       	cpse	r24, r1
    21a8:	cc cf       	rjmp	.-104    	; 0x2142 <xTaskResumeAll+0x42>
    21aa:	80 91 21 08 	lds	r24, 0x0821
    21ae:	88 23       	and	r24, r24
    21b0:	91 f0       	breq	.+36     	; 0x21d6 <xTaskResumeAll+0xd6>
    21b2:	80 91 21 08 	lds	r24, 0x0821
    21b6:	88 23       	and	r24, r24
    21b8:	71 f0       	breq	.+28     	; 0x21d6 <xTaskResumeAll+0xd6>
    21ba:	c1 e0       	ldi	r28, 0x01	; 1
    21bc:	e3 de       	rcall	.-570    	; 0x1f84 <xTaskIncrementTick>
    21be:	81 11       	cpse	r24, r1
    21c0:	c0 93 20 08 	sts	0x0820, r28
    21c4:	80 91 21 08 	lds	r24, 0x0821
    21c8:	81 50       	subi	r24, 0x01	; 1
    21ca:	80 93 21 08 	sts	0x0821, r24
    21ce:	80 91 21 08 	lds	r24, 0x0821
    21d2:	81 11       	cpse	r24, r1
    21d4:	f3 cf       	rjmp	.-26     	; 0x21bc <xTaskResumeAll+0xbc>
    21d6:	80 91 20 08 	lds	r24, 0x0820
    21da:	81 30       	cpi	r24, 0x01	; 1
    21dc:	39 f4       	brne	.+14     	; 0x21ec <xTaskResumeAll+0xec>
    21de:	fc d8       	rcall	.-3592   	; 0x13d8 <vPortYield>
    21e0:	81 e0       	ldi	r24, 0x01	; 1
    21e2:	05 c0       	rjmp	.+10     	; 0x21ee <xTaskResumeAll+0xee>
    21e4:	80 e0       	ldi	r24, 0x00	; 0
    21e6:	03 c0       	rjmp	.+6      	; 0x21ee <xTaskResumeAll+0xee>
    21e8:	80 e0       	ldi	r24, 0x00	; 0
    21ea:	01 c0       	rjmp	.+2      	; 0x21ee <xTaskResumeAll+0xee>
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	0f 90       	pop	r0
    21f0:	0f be       	out	0x3f, r0	; 63
    21f2:	df 91       	pop	r29
    21f4:	cf 91       	pop	r28
    21f6:	1f 91       	pop	r17
    21f8:	0f 91       	pop	r16
    21fa:	ff 90       	pop	r15
    21fc:	ef 90       	pop	r14
    21fe:	df 90       	pop	r13
    2200:	08 95       	ret

00002202 <vTaskDelayUntil>:
    2202:	0f 93       	push	r16
    2204:	1f 93       	push	r17
    2206:	cf 93       	push	r28
    2208:	df 93       	push	r29
    220a:	8c 01       	movw	r16, r24
    220c:	eb 01       	movw	r28, r22
    220e:	a5 de       	rcall	.-694    	; 0x1f5a <vTaskSuspendAll>
    2210:	80 91 24 08 	lds	r24, 0x0824
    2214:	90 91 25 08 	lds	r25, 0x0825
    2218:	f8 01       	movw	r30, r16
    221a:	20 81       	ld	r18, Z
    221c:	31 81       	ldd	r19, Z+1	; 0x01
    221e:	c2 0f       	add	r28, r18
    2220:	d3 1f       	adc	r29, r19
    2222:	82 17       	cp	r24, r18
    2224:	93 07       	cpc	r25, r19
    2226:	48 f4       	brcc	.+18     	; 0x223a <vTaskDelayUntil+0x38>
    2228:	c2 17       	cp	r28, r18
    222a:	d3 07       	cpc	r29, r19
    222c:	f8 f4       	brcc	.+62     	; 0x226c <vTaskDelayUntil+0x6a>
    222e:	d1 83       	std	Z+1, r29	; 0x01
    2230:	c0 83       	st	Z, r28
    2232:	8c 17       	cp	r24, r28
    2234:	9d 07       	cpc	r25, r29
    2236:	88 f4       	brcc	.+34     	; 0x225a <vTaskDelayUntil+0x58>
    2238:	07 c0       	rjmp	.+14     	; 0x2248 <vTaskDelayUntil+0x46>
    223a:	c2 17       	cp	r28, r18
    223c:	d3 07       	cpc	r29, r19
    223e:	90 f0       	brcs	.+36     	; 0x2264 <vTaskDelayUntil+0x62>
    2240:	8c 17       	cp	r24, r28
    2242:	9d 07       	cpc	r25, r29
    2244:	78 f0       	brcs	.+30     	; 0x2264 <vTaskDelayUntil+0x62>
    2246:	12 c0       	rjmp	.+36     	; 0x226c <vTaskDelayUntil+0x6a>
    2248:	80 91 86 08 	lds	r24, 0x0886
    224c:	90 91 87 08 	lds	r25, 0x0887
    2250:	02 96       	adiw	r24, 0x02	; 2
    2252:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2256:	ce 01       	movw	r24, r28
    2258:	c0 dc       	rcall	.-1664   	; 0x1bda <prvAddCurrentTaskToDelayedList>
    225a:	52 df       	rcall	.-348    	; 0x2100 <xTaskResumeAll>
    225c:	81 11       	cpse	r24, r1
    225e:	0a c0       	rjmp	.+20     	; 0x2274 <vTaskDelayUntil+0x72>
    2260:	bb d8       	rcall	.-3722   	; 0x13d8 <vPortYield>
    2262:	08 c0       	rjmp	.+16     	; 0x2274 <vTaskDelayUntil+0x72>
    2264:	f8 01       	movw	r30, r16
    2266:	d1 83       	std	Z+1, r29	; 0x01
    2268:	c0 83       	st	Z, r28
    226a:	ee cf       	rjmp	.-36     	; 0x2248 <vTaskDelayUntil+0x46>
    226c:	f8 01       	movw	r30, r16
    226e:	d1 83       	std	Z+1, r29	; 0x01
    2270:	c0 83       	st	Z, r28
    2272:	f3 cf       	rjmp	.-26     	; 0x225a <vTaskDelayUntil+0x58>
    2274:	df 91       	pop	r29
    2276:	cf 91       	pop	r28
    2278:	1f 91       	pop	r17
    227a:	0f 91       	pop	r16
    227c:	08 95       	ret

0000227e <prvIdleTask>:
    227e:	0f 2e       	mov	r0, r31
    2280:	f9 e5       	ldi	r31, 0x59	; 89
    2282:	ef 2e       	mov	r14, r31
    2284:	f8 e0       	ldi	r31, 0x08	; 8
    2286:	ff 2e       	mov	r15, r31
    2288:	f0 2d       	mov	r31, r0
    228a:	c1 e3       	ldi	r28, 0x31	; 49
    228c:	d8 e0       	ldi	r29, 0x08	; 8
    228e:	26 c0       	rjmp	.+76     	; 0x22dc <prvIdleTask+0x5e>
    2290:	64 de       	rcall	.-824    	; 0x1f5a <vTaskSuspendAll>
    2292:	18 81       	ld	r17, Y
    2294:	35 df       	rcall	.-406    	; 0x2100 <xTaskResumeAll>
    2296:	11 23       	and	r17, r17
    2298:	09 f1       	breq	.+66     	; 0x22dc <prvIdleTask+0x5e>
    229a:	0f b6       	in	r0, 0x3f	; 63
    229c:	f8 94       	cli
    229e:	0f 92       	push	r0
    22a0:	e0 91 36 08 	lds	r30, 0x0836
    22a4:	f0 91 37 08 	lds	r31, 0x0837
    22a8:	06 81       	ldd	r16, Z+6	; 0x06
    22aa:	17 81       	ldd	r17, Z+7	; 0x07
    22ac:	c8 01       	movw	r24, r16
    22ae:	02 96       	adiw	r24, 0x02	; 2
    22b0:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    22b4:	80 91 26 08 	lds	r24, 0x0826
    22b8:	81 50       	subi	r24, 0x01	; 1
    22ba:	80 93 26 08 	sts	0x0826, r24
    22be:	80 91 30 08 	lds	r24, 0x0830
    22c2:	81 50       	subi	r24, 0x01	; 1
    22c4:	80 93 30 08 	sts	0x0830, r24
    22c8:	0f 90       	pop	r0
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	f8 01       	movw	r30, r16
    22ce:	87 89       	ldd	r24, Z+23	; 0x17
    22d0:	90 8d       	ldd	r25, Z+24	; 0x18
    22d2:	0e 94 2a 03 	call	0x654	; 0x654 <vPortFree>
    22d6:	c8 01       	movw	r24, r16
    22d8:	0e 94 2a 03 	call	0x654	; 0x654 <vPortFree>
    22dc:	80 91 30 08 	lds	r24, 0x0830
    22e0:	81 11       	cpse	r24, r1
    22e2:	d6 cf       	rjmp	.-84     	; 0x2290 <prvIdleTask+0x12>
    22e4:	f7 01       	movw	r30, r14
    22e6:	80 81       	ld	r24, Z
    22e8:	82 30       	cpi	r24, 0x02	; 2
    22ea:	c0 f3       	brcs	.-16     	; 0x22dc <prvIdleTask+0x5e>
    22ec:	75 d8       	rcall	.-3862   	; 0x13d8 <vPortYield>
    22ee:	f6 cf       	rjmp	.-20     	; 0x22dc <prvIdleTask+0x5e>

000022f0 <vTaskSwitchContext>:
    22f0:	80 91 1d 08 	lds	r24, 0x081D
    22f4:	88 23       	and	r24, r24
    22f6:	21 f0       	breq	.+8      	; 0x2300 <vTaskSwitchContext+0x10>
    22f8:	81 e0       	ldi	r24, 0x01	; 1
    22fa:	80 93 20 08 	sts	0x0820, r24
    22fe:	08 95       	ret
    2300:	10 92 20 08 	sts	0x0820, r1
    2304:	80 91 23 08 	lds	r24, 0x0823
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	fc 01       	movw	r30, r24
    230c:	ee 0f       	add	r30, r30
    230e:	ff 1f       	adc	r31, r31
    2310:	ee 0f       	add	r30, r30
    2312:	ff 1f       	adc	r31, r31
    2314:	ee 0f       	add	r30, r30
    2316:	ff 1f       	adc	r31, r31
    2318:	8e 0f       	add	r24, r30
    231a:	9f 1f       	adc	r25, r31
    231c:	fc 01       	movw	r30, r24
    231e:	e7 5a       	subi	r30, 0xA7	; 167
    2320:	f7 4f       	sbci	r31, 0xF7	; 247
    2322:	80 81       	ld	r24, Z
    2324:	81 11       	cpse	r24, r1
    2326:	17 c0       	rjmp	.+46     	; 0x2356 <vTaskSwitchContext+0x66>
    2328:	80 91 23 08 	lds	r24, 0x0823
    232c:	81 50       	subi	r24, 0x01	; 1
    232e:	80 93 23 08 	sts	0x0823, r24
    2332:	80 91 23 08 	lds	r24, 0x0823
    2336:	90 e0       	ldi	r25, 0x00	; 0
    2338:	fc 01       	movw	r30, r24
    233a:	ee 0f       	add	r30, r30
    233c:	ff 1f       	adc	r31, r31
    233e:	ee 0f       	add	r30, r30
    2340:	ff 1f       	adc	r31, r31
    2342:	ee 0f       	add	r30, r30
    2344:	ff 1f       	adc	r31, r31
    2346:	8e 0f       	add	r24, r30
    2348:	9f 1f       	adc	r25, r31
    234a:	fc 01       	movw	r30, r24
    234c:	e7 5a       	subi	r30, 0xA7	; 167
    234e:	f7 4f       	sbci	r31, 0xF7	; 247
    2350:	80 81       	ld	r24, Z
    2352:	88 23       	and	r24, r24
    2354:	49 f3       	breq	.-46     	; 0x2328 <vTaskSwitchContext+0x38>
    2356:	e0 91 23 08 	lds	r30, 0x0823
    235a:	f0 e0       	ldi	r31, 0x00	; 0
    235c:	cf 01       	movw	r24, r30
    235e:	88 0f       	add	r24, r24
    2360:	99 1f       	adc	r25, r25
    2362:	88 0f       	add	r24, r24
    2364:	99 1f       	adc	r25, r25
    2366:	88 0f       	add	r24, r24
    2368:	99 1f       	adc	r25, r25
    236a:	e8 0f       	add	r30, r24
    236c:	f9 1f       	adc	r31, r25
    236e:	e7 5a       	subi	r30, 0xA7	; 167
    2370:	f7 4f       	sbci	r31, 0xF7	; 247
    2372:	a1 81       	ldd	r26, Z+1	; 0x01
    2374:	b2 81       	ldd	r27, Z+2	; 0x02
    2376:	12 96       	adiw	r26, 0x02	; 2
    2378:	0d 90       	ld	r0, X+
    237a:	bc 91       	ld	r27, X
    237c:	a0 2d       	mov	r26, r0
    237e:	b2 83       	std	Z+2, r27	; 0x02
    2380:	a1 83       	std	Z+1, r26	; 0x01
    2382:	cf 01       	movw	r24, r30
    2384:	03 96       	adiw	r24, 0x03	; 3
    2386:	a8 17       	cp	r26, r24
    2388:	b9 07       	cpc	r27, r25
    238a:	31 f4       	brne	.+12     	; 0x2398 <vTaskSwitchContext+0xa8>
    238c:	12 96       	adiw	r26, 0x02	; 2
    238e:	8d 91       	ld	r24, X+
    2390:	9c 91       	ld	r25, X
    2392:	13 97       	sbiw	r26, 0x03	; 3
    2394:	92 83       	std	Z+2, r25	; 0x02
    2396:	81 83       	std	Z+1, r24	; 0x01
    2398:	01 80       	ldd	r0, Z+1	; 0x01
    239a:	f2 81       	ldd	r31, Z+2	; 0x02
    239c:	e0 2d       	mov	r30, r0
    239e:	86 81       	ldd	r24, Z+6	; 0x06
    23a0:	97 81       	ldd	r25, Z+7	; 0x07
    23a2:	90 93 87 08 	sts	0x0887, r25
    23a6:	80 93 86 08 	sts	0x0886, r24
    23aa:	08 95       	ret

000023ac <vTaskSuspend>:
    23ac:	0f 93       	push	r16
    23ae:	1f 93       	push	r17
    23b0:	cf 93       	push	r28
    23b2:	df 93       	push	r29
    23b4:	ec 01       	movw	r28, r24
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	0f 92       	push	r0
    23bc:	00 97       	sbiw	r24, 0x00	; 0
    23be:	21 f4       	brne	.+8      	; 0x23c8 <vTaskSuspend+0x1c>
    23c0:	c0 91 86 08 	lds	r28, 0x0886
    23c4:	d0 91 87 08 	lds	r29, 0x0887
    23c8:	8e 01       	movw	r16, r28
    23ca:	0e 5f       	subi	r16, 0xFE	; 254
    23cc:	1f 4f       	sbci	r17, 0xFF	; 255
    23ce:	c8 01       	movw	r24, r16
    23d0:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    23d4:	8c 89       	ldd	r24, Y+20	; 0x14
    23d6:	9d 89       	ldd	r25, Y+21	; 0x15
    23d8:	89 2b       	or	r24, r25
    23da:	21 f0       	breq	.+8      	; 0x23e4 <vTaskSuspend+0x38>
    23dc:	ce 01       	movw	r24, r28
    23de:	0c 96       	adiw	r24, 0x0c	; 12
    23e0:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    23e4:	b8 01       	movw	r22, r16
    23e6:	87 e2       	ldi	r24, 0x27	; 39
    23e8:	98 e0       	ldi	r25, 0x08	; 8
    23ea:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    23ee:	0f 90       	pop	r0
    23f0:	0f be       	out	0x3f, r0	; 63
    23f2:	80 91 86 08 	lds	r24, 0x0886
    23f6:	90 91 87 08 	lds	r25, 0x0887
    23fa:	c8 17       	cp	r28, r24
    23fc:	d9 07       	cpc	r29, r25
    23fe:	a1 f4       	brne	.+40     	; 0x2428 <vTaskSuspend+0x7c>
    2400:	80 91 22 08 	lds	r24, 0x0822
    2404:	88 23       	and	r24, r24
    2406:	19 f0       	breq	.+6      	; 0x240e <vTaskSuspend+0x62>
    2408:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <vPortYield>
    240c:	17 c0       	rjmp	.+46     	; 0x243c <vTaskSuspend+0x90>
    240e:	80 91 26 08 	lds	r24, 0x0826
    2412:	90 91 27 08 	lds	r25, 0x0827
    2416:	98 13       	cpse	r25, r24
    2418:	05 c0       	rjmp	.+10     	; 0x2424 <vTaskSuspend+0x78>
    241a:	10 92 87 08 	sts	0x0887, r1
    241e:	10 92 86 08 	sts	0x0886, r1
    2422:	0c c0       	rjmp	.+24     	; 0x243c <vTaskSuspend+0x90>
    2424:	65 df       	rcall	.-310    	; 0x22f0 <vTaskSwitchContext>
    2426:	0a c0       	rjmp	.+20     	; 0x243c <vTaskSuspend+0x90>
    2428:	80 91 22 08 	lds	r24, 0x0822
    242c:	88 23       	and	r24, r24
    242e:	31 f0       	breq	.+12     	; 0x243c <vTaskSuspend+0x90>
    2430:	0f b6       	in	r0, 0x3f	; 63
    2432:	f8 94       	cli
    2434:	0f 92       	push	r0
    2436:	b2 db       	rcall	.-2204   	; 0x1b9c <prvResetNextTaskUnblockTime>
    2438:	0f 90       	pop	r0
    243a:	0f be       	out	0x3f, r0	; 63
    243c:	df 91       	pop	r29
    243e:	cf 91       	pop	r28
    2440:	1f 91       	pop	r17
    2442:	0f 91       	pop	r16
    2444:	08 95       	ret

00002446 <vTaskPlaceOnEventList>:
    2446:	cf 93       	push	r28
    2448:	df 93       	push	r29
    244a:	eb 01       	movw	r28, r22
    244c:	60 91 86 08 	lds	r22, 0x0886
    2450:	70 91 87 08 	lds	r23, 0x0887
    2454:	64 5f       	subi	r22, 0xF4	; 244
    2456:	7f 4f       	sbci	r23, 0xFF	; 255
    2458:	0e 94 5e 03 	call	0x6bc	; 0x6bc <vListInsert>
    245c:	80 91 86 08 	lds	r24, 0x0886
    2460:	90 91 87 08 	lds	r25, 0x0887
    2464:	02 96       	adiw	r24, 0x02	; 2
    2466:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    246a:	cf 3f       	cpi	r28, 0xFF	; 255
    246c:	8f ef       	ldi	r24, 0xFF	; 255
    246e:	d8 07       	cpc	r29, r24
    2470:	59 f4       	brne	.+22     	; 0x2488 <vTaskPlaceOnEventList+0x42>
    2472:	60 91 86 08 	lds	r22, 0x0886
    2476:	70 91 87 08 	lds	r23, 0x0887
    247a:	6e 5f       	subi	r22, 0xFE	; 254
    247c:	7f 4f       	sbci	r23, 0xFF	; 255
    247e:	87 e2       	ldi	r24, 0x27	; 39
    2480:	98 e0       	ldi	r25, 0x08	; 8
    2482:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    2486:	07 c0       	rjmp	.+14     	; 0x2496 <vTaskPlaceOnEventList+0x50>
    2488:	80 91 24 08 	lds	r24, 0x0824
    248c:	90 91 25 08 	lds	r25, 0x0825
    2490:	8c 0f       	add	r24, r28
    2492:	9d 1f       	adc	r25, r29
    2494:	a2 db       	rcall	.-2236   	; 0x1bda <prvAddCurrentTaskToDelayedList>
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	08 95       	ret

0000249c <xTaskRemoveFromEventList>:
    249c:	0f 93       	push	r16
    249e:	1f 93       	push	r17
    24a0:	cf 93       	push	r28
    24a2:	df 93       	push	r29
    24a4:	dc 01       	movw	r26, r24
    24a6:	15 96       	adiw	r26, 0x05	; 5
    24a8:	ed 91       	ld	r30, X+
    24aa:	fc 91       	ld	r31, X
    24ac:	16 97       	sbiw	r26, 0x06	; 6
    24ae:	c6 81       	ldd	r28, Z+6	; 0x06
    24b0:	d7 81       	ldd	r29, Z+7	; 0x07
    24b2:	8e 01       	movw	r16, r28
    24b4:	04 5f       	subi	r16, 0xF4	; 244
    24b6:	1f 4f       	sbci	r17, 0xFF	; 255
    24b8:	c8 01       	movw	r24, r16
    24ba:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    24be:	80 91 1d 08 	lds	r24, 0x081D
    24c2:	81 11       	cpse	r24, r1
    24c4:	1c c0       	rjmp	.+56     	; 0x24fe <xTaskRemoveFromEventList+0x62>
    24c6:	0a 50       	subi	r16, 0x0A	; 10
    24c8:	11 09       	sbc	r17, r1
    24ca:	c8 01       	movw	r24, r16
    24cc:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    24d0:	8e 89       	ldd	r24, Y+22	; 0x16
    24d2:	90 91 23 08 	lds	r25, 0x0823
    24d6:	98 17       	cp	r25, r24
    24d8:	10 f4       	brcc	.+4      	; 0x24de <xTaskRemoveFromEventList+0x42>
    24da:	80 93 23 08 	sts	0x0823, r24
    24de:	90 e0       	ldi	r25, 0x00	; 0
    24e0:	9c 01       	movw	r18, r24
    24e2:	22 0f       	add	r18, r18
    24e4:	33 1f       	adc	r19, r19
    24e6:	22 0f       	add	r18, r18
    24e8:	33 1f       	adc	r19, r19
    24ea:	22 0f       	add	r18, r18
    24ec:	33 1f       	adc	r19, r19
    24ee:	82 0f       	add	r24, r18
    24f0:	93 1f       	adc	r25, r19
    24f2:	b8 01       	movw	r22, r16
    24f4:	87 5a       	subi	r24, 0xA7	; 167
    24f6:	97 4f       	sbci	r25, 0xF7	; 247
    24f8:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    24fc:	05 c0       	rjmp	.+10     	; 0x2508 <xTaskRemoveFromEventList+0x6c>
    24fe:	b8 01       	movw	r22, r16
    2500:	8a e3       	ldi	r24, 0x3A	; 58
    2502:	98 e0       	ldi	r25, 0x08	; 8
    2504:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    2508:	e0 91 86 08 	lds	r30, 0x0886
    250c:	f0 91 87 08 	lds	r31, 0x0887
    2510:	9e 89       	ldd	r25, Y+22	; 0x16
    2512:	86 89       	ldd	r24, Z+22	; 0x16
    2514:	89 17       	cp	r24, r25
    2516:	20 f4       	brcc	.+8      	; 0x2520 <xTaskRemoveFromEventList+0x84>
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	80 93 20 08 	sts	0x0820, r24
    251e:	01 c0       	rjmp	.+2      	; 0x2522 <xTaskRemoveFromEventList+0x86>
    2520:	80 e0       	ldi	r24, 0x00	; 0
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	08 95       	ret

0000252c <vTaskSetTimeOutState>:
    252c:	20 91 1f 08 	lds	r18, 0x081F
    2530:	fc 01       	movw	r30, r24
    2532:	20 83       	st	Z, r18
    2534:	20 91 24 08 	lds	r18, 0x0824
    2538:	30 91 25 08 	lds	r19, 0x0825
    253c:	32 83       	std	Z+2, r19	; 0x02
    253e:	21 83       	std	Z+1, r18	; 0x01
    2540:	08 95       	ret

00002542 <xTaskCheckForTimeOut>:
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	0f 92       	push	r0
    2548:	40 91 24 08 	lds	r20, 0x0824
    254c:	50 91 25 08 	lds	r21, 0x0825
    2550:	db 01       	movw	r26, r22
    2552:	2d 91       	ld	r18, X+
    2554:	3c 91       	ld	r19, X
    2556:	2f 3f       	cpi	r18, 0xFF	; 255
    2558:	bf ef       	ldi	r27, 0xFF	; 255
    255a:	3b 07       	cpc	r19, r27
    255c:	11 f1       	breq	.+68     	; 0x25a2 <xTaskCheckForTimeOut+0x60>
    255e:	e0 91 1f 08 	lds	r30, 0x081F
    2562:	dc 01       	movw	r26, r24
    2564:	fc 91       	ld	r31, X
    2566:	fe 17       	cp	r31, r30
    2568:	39 f0       	breq	.+14     	; 0x2578 <xTaskCheckForTimeOut+0x36>
    256a:	11 96       	adiw	r26, 0x01	; 1
    256c:	ed 91       	ld	r30, X+
    256e:	fc 91       	ld	r31, X
    2570:	12 97       	sbiw	r26, 0x02	; 2
    2572:	4e 17       	cp	r20, r30
    2574:	5f 07       	cpc	r21, r31
    2576:	b8 f4       	brcc	.+46     	; 0x25a6 <xTaskCheckForTimeOut+0x64>
    2578:	dc 01       	movw	r26, r24
    257a:	11 96       	adiw	r26, 0x01	; 1
    257c:	ed 91       	ld	r30, X+
    257e:	fc 91       	ld	r31, X
    2580:	12 97       	sbiw	r26, 0x02	; 2
    2582:	da 01       	movw	r26, r20
    2584:	ae 1b       	sub	r26, r30
    2586:	bf 0b       	sbc	r27, r31
    2588:	a2 17       	cp	r26, r18
    258a:	b3 07       	cpc	r27, r19
    258c:	70 f4       	brcc	.+28     	; 0x25aa <xTaskCheckForTimeOut+0x68>
    258e:	e4 1b       	sub	r30, r20
    2590:	f5 0b       	sbc	r31, r21
    2592:	2e 0f       	add	r18, r30
    2594:	3f 1f       	adc	r19, r31
    2596:	fb 01       	movw	r30, r22
    2598:	31 83       	std	Z+1, r19	; 0x01
    259a:	20 83       	st	Z, r18
    259c:	c7 df       	rcall	.-114    	; 0x252c <vTaskSetTimeOutState>
    259e:	80 e0       	ldi	r24, 0x00	; 0
    25a0:	05 c0       	rjmp	.+10     	; 0x25ac <xTaskCheckForTimeOut+0x6a>
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	03 c0       	rjmp	.+6      	; 0x25ac <xTaskCheckForTimeOut+0x6a>
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	01 c0       	rjmp	.+2      	; 0x25ac <xTaskCheckForTimeOut+0x6a>
    25aa:	81 e0       	ldi	r24, 0x01	; 1
    25ac:	0f 90       	pop	r0
    25ae:	0f be       	out	0x3f, r0	; 63
    25b0:	08 95       	ret

000025b2 <vTaskMissedYield>:
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	80 93 20 08 	sts	0x0820, r24
    25b8:	08 95       	ret

000025ba <vTaskPriorityInherit>:
    25ba:	0f 93       	push	r16
    25bc:	1f 93       	push	r17
    25be:	cf 93       	push	r28
    25c0:	df 93       	push	r29
    25c2:	ec 01       	movw	r28, r24
    25c4:	00 97       	sbiw	r24, 0x00	; 0
    25c6:	09 f4       	brne	.+2      	; 0x25ca <vTaskPriorityInherit+0x10>
    25c8:	51 c0       	rjmp	.+162    	; 0x266c <vTaskPriorityInherit+0xb2>
    25ca:	8e 89       	ldd	r24, Y+22	; 0x16
    25cc:	e0 91 86 08 	lds	r30, 0x0886
    25d0:	f0 91 87 08 	lds	r31, 0x0887
    25d4:	96 89       	ldd	r25, Z+22	; 0x16
    25d6:	89 17       	cp	r24, r25
    25d8:	08 f0       	brcs	.+2      	; 0x25dc <vTaskPriorityInherit+0x22>
    25da:	48 c0       	rjmp	.+144    	; 0x266c <vTaskPriorityInherit+0xb2>
    25dc:	2c 85       	ldd	r18, Y+12	; 0x0c
    25de:	3d 85       	ldd	r19, Y+13	; 0x0d
    25e0:	33 23       	and	r19, r19
    25e2:	5c f0       	brlt	.+22     	; 0x25fa <vTaskPriorityInherit+0x40>
    25e4:	e0 91 86 08 	lds	r30, 0x0886
    25e8:	f0 91 87 08 	lds	r31, 0x0887
    25ec:	96 89       	ldd	r25, Z+22	; 0x16
    25ee:	25 e0       	ldi	r18, 0x05	; 5
    25f0:	30 e0       	ldi	r19, 0x00	; 0
    25f2:	29 1b       	sub	r18, r25
    25f4:	31 09       	sbc	r19, r1
    25f6:	3d 87       	std	Y+13, r19	; 0x0d
    25f8:	2c 87       	std	Y+12, r18	; 0x0c
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	9c 01       	movw	r18, r24
    25fe:	22 0f       	add	r18, r18
    2600:	33 1f       	adc	r19, r19
    2602:	22 0f       	add	r18, r18
    2604:	33 1f       	adc	r19, r19
    2606:	22 0f       	add	r18, r18
    2608:	33 1f       	adc	r19, r19
    260a:	82 0f       	add	r24, r18
    260c:	93 1f       	adc	r25, r19
    260e:	87 5a       	subi	r24, 0xA7	; 167
    2610:	97 4f       	sbci	r25, 0xF7	; 247
    2612:	2a 85       	ldd	r18, Y+10	; 0x0a
    2614:	3b 85       	ldd	r19, Y+11	; 0x0b
    2616:	28 17       	cp	r18, r24
    2618:	39 07       	cpc	r19, r25
    261a:	11 f5       	brne	.+68     	; 0x2660 <vTaskPriorityInherit+0xa6>
    261c:	8e 01       	movw	r16, r28
    261e:	0e 5f       	subi	r16, 0xFE	; 254
    2620:	1f 4f       	sbci	r17, 0xFF	; 255
    2622:	c8 01       	movw	r24, r16
    2624:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    2628:	e0 91 86 08 	lds	r30, 0x0886
    262c:	f0 91 87 08 	lds	r31, 0x0887
    2630:	86 89       	ldd	r24, Z+22	; 0x16
    2632:	8e 8b       	std	Y+22, r24	; 0x16
    2634:	90 91 23 08 	lds	r25, 0x0823
    2638:	98 17       	cp	r25, r24
    263a:	10 f4       	brcc	.+4      	; 0x2640 <vTaskPriorityInherit+0x86>
    263c:	80 93 23 08 	sts	0x0823, r24
    2640:	90 e0       	ldi	r25, 0x00	; 0
    2642:	9c 01       	movw	r18, r24
    2644:	22 0f       	add	r18, r18
    2646:	33 1f       	adc	r19, r19
    2648:	22 0f       	add	r18, r18
    264a:	33 1f       	adc	r19, r19
    264c:	22 0f       	add	r18, r18
    264e:	33 1f       	adc	r19, r19
    2650:	82 0f       	add	r24, r18
    2652:	93 1f       	adc	r25, r19
    2654:	b8 01       	movw	r22, r16
    2656:	87 5a       	subi	r24, 0xA7	; 167
    2658:	97 4f       	sbci	r25, 0xF7	; 247
    265a:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    265e:	06 c0       	rjmp	.+12     	; 0x266c <vTaskPriorityInherit+0xb2>
    2660:	e0 91 86 08 	lds	r30, 0x0886
    2664:	f0 91 87 08 	lds	r31, 0x0887
    2668:	86 89       	ldd	r24, Z+22	; 0x16
    266a:	8e 8b       	std	Y+22, r24	; 0x16
    266c:	df 91       	pop	r29
    266e:	cf 91       	pop	r28
    2670:	1f 91       	pop	r17
    2672:	0f 91       	pop	r16
    2674:	08 95       	ret

00002676 <xTaskPriorityDisinherit>:
    2676:	0f 93       	push	r16
    2678:	1f 93       	push	r17
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	ec 01       	movw	r28, r24
    2680:	00 97       	sbiw	r24, 0x00	; 0
    2682:	71 f1       	breq	.+92     	; 0x26e0 <xTaskPriorityDisinherit+0x6a>
    2684:	8a a1       	ldd	r24, Y+34	; 0x22
    2686:	81 50       	subi	r24, 0x01	; 1
    2688:	8a a3       	std	Y+34, r24	; 0x22
    268a:	2e 89       	ldd	r18, Y+22	; 0x16
    268c:	99 a1       	ldd	r25, Y+33	; 0x21
    268e:	29 17       	cp	r18, r25
    2690:	49 f1       	breq	.+82     	; 0x26e4 <xTaskPriorityDisinherit+0x6e>
    2692:	81 11       	cpse	r24, r1
    2694:	29 c0       	rjmp	.+82     	; 0x26e8 <xTaskPriorityDisinherit+0x72>
    2696:	8e 01       	movw	r16, r28
    2698:	0e 5f       	subi	r16, 0xFE	; 254
    269a:	1f 4f       	sbci	r17, 0xFF	; 255
    269c:	c8 01       	movw	r24, r16
    269e:	0e 94 8f 03 	call	0x71e	; 0x71e <uxListRemove>
    26a2:	89 a1       	ldd	r24, Y+33	; 0x21
    26a4:	8e 8b       	std	Y+22, r24	; 0x16
    26a6:	25 e0       	ldi	r18, 0x05	; 5
    26a8:	30 e0       	ldi	r19, 0x00	; 0
    26aa:	28 1b       	sub	r18, r24
    26ac:	31 09       	sbc	r19, r1
    26ae:	3d 87       	std	Y+13, r19	; 0x0d
    26b0:	2c 87       	std	Y+12, r18	; 0x0c
    26b2:	90 91 23 08 	lds	r25, 0x0823
    26b6:	98 17       	cp	r25, r24
    26b8:	10 f4       	brcc	.+4      	; 0x26be <xTaskPriorityDisinherit+0x48>
    26ba:	80 93 23 08 	sts	0x0823, r24
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	9c 01       	movw	r18, r24
    26c2:	22 0f       	add	r18, r18
    26c4:	33 1f       	adc	r19, r19
    26c6:	22 0f       	add	r18, r18
    26c8:	33 1f       	adc	r19, r19
    26ca:	22 0f       	add	r18, r18
    26cc:	33 1f       	adc	r19, r19
    26ce:	82 0f       	add	r24, r18
    26d0:	93 1f       	adc	r25, r19
    26d2:	b8 01       	movw	r22, r16
    26d4:	87 5a       	subi	r24, 0xA7	; 167
    26d6:	97 4f       	sbci	r25, 0xF7	; 247
    26d8:	0e 94 3d 03 	call	0x67a	; 0x67a <vListInsertEnd>
    26dc:	81 e0       	ldi	r24, 0x01	; 1
    26de:	05 c0       	rjmp	.+10     	; 0x26ea <xTaskPriorityDisinherit+0x74>
    26e0:	80 e0       	ldi	r24, 0x00	; 0
    26e2:	03 c0       	rjmp	.+6      	; 0x26ea <xTaskPriorityDisinherit+0x74>
    26e4:	80 e0       	ldi	r24, 0x00	; 0
    26e6:	01 c0       	rjmp	.+2      	; 0x26ea <xTaskPriorityDisinherit+0x74>
    26e8:	80 e0       	ldi	r24, 0x00	; 0
    26ea:	df 91       	pop	r29
    26ec:	cf 91       	pop	r28
    26ee:	1f 91       	pop	r17
    26f0:	0f 91       	pop	r16
    26f2:	08 95       	ret

000026f4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    26f4:	80 91 86 08 	lds	r24, 0x0886
    26f8:	90 91 87 08 	lds	r25, 0x0887
    26fc:	89 2b       	or	r24, r25
    26fe:	39 f0       	breq	.+14     	; 0x270e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2700:	e0 91 86 08 	lds	r30, 0x0886
    2704:	f0 91 87 08 	lds	r31, 0x0887
    2708:	82 a1       	ldd	r24, Z+34	; 0x22
    270a:	8f 5f       	subi	r24, 0xFF	; 255
    270c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    270e:	80 91 86 08 	lds	r24, 0x0886
    2712:	90 91 87 08 	lds	r25, 0x0887
	}
    2716:	08 95       	ret

00002718 <__subsf3>:
    2718:	50 58       	subi	r21, 0x80	; 128

0000271a <__addsf3>:
    271a:	bb 27       	eor	r27, r27
    271c:	aa 27       	eor	r26, r26
    271e:	0e d0       	rcall	.+28     	; 0x273c <__addsf3x>
    2720:	e5 c0       	rjmp	.+458    	; 0x28ec <__fp_round>
    2722:	d6 d0       	rcall	.+428    	; 0x28d0 <__fp_pscA>
    2724:	30 f0       	brcs	.+12     	; 0x2732 <__addsf3+0x18>
    2726:	db d0       	rcall	.+438    	; 0x28de <__fp_pscB>
    2728:	20 f0       	brcs	.+8      	; 0x2732 <__addsf3+0x18>
    272a:	31 f4       	brne	.+12     	; 0x2738 <__addsf3+0x1e>
    272c:	9f 3f       	cpi	r25, 0xFF	; 255
    272e:	11 f4       	brne	.+4      	; 0x2734 <__addsf3+0x1a>
    2730:	1e f4       	brtc	.+6      	; 0x2738 <__addsf3+0x1e>
    2732:	cb c0       	rjmp	.+406    	; 0x28ca <__fp_nan>
    2734:	0e f4       	brtc	.+2      	; 0x2738 <__addsf3+0x1e>
    2736:	e0 95       	com	r30
    2738:	e7 fb       	bst	r30, 7
    273a:	c1 c0       	rjmp	.+386    	; 0x28be <__fp_inf>

0000273c <__addsf3x>:
    273c:	e9 2f       	mov	r30, r25
    273e:	e7 d0       	rcall	.+462    	; 0x290e <__fp_split3>
    2740:	80 f3       	brcs	.-32     	; 0x2722 <__addsf3+0x8>
    2742:	ba 17       	cp	r27, r26
    2744:	62 07       	cpc	r22, r18
    2746:	73 07       	cpc	r23, r19
    2748:	84 07       	cpc	r24, r20
    274a:	95 07       	cpc	r25, r21
    274c:	18 f0       	brcs	.+6      	; 0x2754 <__addsf3x+0x18>
    274e:	71 f4       	brne	.+28     	; 0x276c <__addsf3x+0x30>
    2750:	9e f5       	brtc	.+102    	; 0x27b8 <__addsf3x+0x7c>
    2752:	ff c0       	rjmp	.+510    	; 0x2952 <__fp_zero>
    2754:	0e f4       	brtc	.+2      	; 0x2758 <__addsf3x+0x1c>
    2756:	e0 95       	com	r30
    2758:	0b 2e       	mov	r0, r27
    275a:	ba 2f       	mov	r27, r26
    275c:	a0 2d       	mov	r26, r0
    275e:	0b 01       	movw	r0, r22
    2760:	b9 01       	movw	r22, r18
    2762:	90 01       	movw	r18, r0
    2764:	0c 01       	movw	r0, r24
    2766:	ca 01       	movw	r24, r20
    2768:	a0 01       	movw	r20, r0
    276a:	11 24       	eor	r1, r1
    276c:	ff 27       	eor	r31, r31
    276e:	59 1b       	sub	r21, r25
    2770:	99 f0       	breq	.+38     	; 0x2798 <__addsf3x+0x5c>
    2772:	59 3f       	cpi	r21, 0xF9	; 249
    2774:	50 f4       	brcc	.+20     	; 0x278a <__addsf3x+0x4e>
    2776:	50 3e       	cpi	r21, 0xE0	; 224
    2778:	68 f1       	brcs	.+90     	; 0x27d4 <__addsf3x+0x98>
    277a:	1a 16       	cp	r1, r26
    277c:	f0 40       	sbci	r31, 0x00	; 0
    277e:	a2 2f       	mov	r26, r18
    2780:	23 2f       	mov	r18, r19
    2782:	34 2f       	mov	r19, r20
    2784:	44 27       	eor	r20, r20
    2786:	58 5f       	subi	r21, 0xF8	; 248
    2788:	f3 cf       	rjmp	.-26     	; 0x2770 <__addsf3x+0x34>
    278a:	46 95       	lsr	r20
    278c:	37 95       	ror	r19
    278e:	27 95       	ror	r18
    2790:	a7 95       	ror	r26
    2792:	f0 40       	sbci	r31, 0x00	; 0
    2794:	53 95       	inc	r21
    2796:	c9 f7       	brne	.-14     	; 0x278a <__addsf3x+0x4e>
    2798:	7e f4       	brtc	.+30     	; 0x27b8 <__addsf3x+0x7c>
    279a:	1f 16       	cp	r1, r31
    279c:	ba 0b       	sbc	r27, r26
    279e:	62 0b       	sbc	r22, r18
    27a0:	73 0b       	sbc	r23, r19
    27a2:	84 0b       	sbc	r24, r20
    27a4:	ba f0       	brmi	.+46     	; 0x27d4 <__addsf3x+0x98>
    27a6:	91 50       	subi	r25, 0x01	; 1
    27a8:	a1 f0       	breq	.+40     	; 0x27d2 <__addsf3x+0x96>
    27aa:	ff 0f       	add	r31, r31
    27ac:	bb 1f       	adc	r27, r27
    27ae:	66 1f       	adc	r22, r22
    27b0:	77 1f       	adc	r23, r23
    27b2:	88 1f       	adc	r24, r24
    27b4:	c2 f7       	brpl	.-16     	; 0x27a6 <__addsf3x+0x6a>
    27b6:	0e c0       	rjmp	.+28     	; 0x27d4 <__addsf3x+0x98>
    27b8:	ba 0f       	add	r27, r26
    27ba:	62 1f       	adc	r22, r18
    27bc:	73 1f       	adc	r23, r19
    27be:	84 1f       	adc	r24, r20
    27c0:	48 f4       	brcc	.+18     	; 0x27d4 <__addsf3x+0x98>
    27c2:	87 95       	ror	r24
    27c4:	77 95       	ror	r23
    27c6:	67 95       	ror	r22
    27c8:	b7 95       	ror	r27
    27ca:	f7 95       	ror	r31
    27cc:	9e 3f       	cpi	r25, 0xFE	; 254
    27ce:	08 f0       	brcs	.+2      	; 0x27d2 <__addsf3x+0x96>
    27d0:	b3 cf       	rjmp	.-154    	; 0x2738 <__addsf3+0x1e>
    27d2:	93 95       	inc	r25
    27d4:	88 0f       	add	r24, r24
    27d6:	08 f0       	brcs	.+2      	; 0x27da <__addsf3x+0x9e>
    27d8:	99 27       	eor	r25, r25
    27da:	ee 0f       	add	r30, r30
    27dc:	97 95       	ror	r25
    27de:	87 95       	ror	r24
    27e0:	08 95       	ret

000027e2 <__fixsfsi>:
    27e2:	04 d0       	rcall	.+8      	; 0x27ec <__fixunssfsi>
    27e4:	68 94       	set
    27e6:	b1 11       	cpse	r27, r1
    27e8:	b5 c0       	rjmp	.+362    	; 0x2954 <__fp_szero>
    27ea:	08 95       	ret

000027ec <__fixunssfsi>:
    27ec:	98 d0       	rcall	.+304    	; 0x291e <__fp_splitA>
    27ee:	88 f0       	brcs	.+34     	; 0x2812 <__fixunssfsi+0x26>
    27f0:	9f 57       	subi	r25, 0x7F	; 127
    27f2:	90 f0       	brcs	.+36     	; 0x2818 <__fixunssfsi+0x2c>
    27f4:	b9 2f       	mov	r27, r25
    27f6:	99 27       	eor	r25, r25
    27f8:	b7 51       	subi	r27, 0x17	; 23
    27fa:	a0 f0       	brcs	.+40     	; 0x2824 <__fixunssfsi+0x38>
    27fc:	d1 f0       	breq	.+52     	; 0x2832 <__fixunssfsi+0x46>
    27fe:	66 0f       	add	r22, r22
    2800:	77 1f       	adc	r23, r23
    2802:	88 1f       	adc	r24, r24
    2804:	99 1f       	adc	r25, r25
    2806:	1a f0       	brmi	.+6      	; 0x280e <__fixunssfsi+0x22>
    2808:	ba 95       	dec	r27
    280a:	c9 f7       	brne	.-14     	; 0x27fe <__fixunssfsi+0x12>
    280c:	12 c0       	rjmp	.+36     	; 0x2832 <__fixunssfsi+0x46>
    280e:	b1 30       	cpi	r27, 0x01	; 1
    2810:	81 f0       	breq	.+32     	; 0x2832 <__fixunssfsi+0x46>
    2812:	9f d0       	rcall	.+318    	; 0x2952 <__fp_zero>
    2814:	b1 e0       	ldi	r27, 0x01	; 1
    2816:	08 95       	ret
    2818:	9c c0       	rjmp	.+312    	; 0x2952 <__fp_zero>
    281a:	67 2f       	mov	r22, r23
    281c:	78 2f       	mov	r23, r24
    281e:	88 27       	eor	r24, r24
    2820:	b8 5f       	subi	r27, 0xF8	; 248
    2822:	39 f0       	breq	.+14     	; 0x2832 <__fixunssfsi+0x46>
    2824:	b9 3f       	cpi	r27, 0xF9	; 249
    2826:	cc f3       	brlt	.-14     	; 0x281a <__fixunssfsi+0x2e>
    2828:	86 95       	lsr	r24
    282a:	77 95       	ror	r23
    282c:	67 95       	ror	r22
    282e:	b3 95       	inc	r27
    2830:	d9 f7       	brne	.-10     	; 0x2828 <__fixunssfsi+0x3c>
    2832:	3e f4       	brtc	.+14     	; 0x2842 <__fixunssfsi+0x56>
    2834:	90 95       	com	r25
    2836:	80 95       	com	r24
    2838:	70 95       	com	r23
    283a:	61 95       	neg	r22
    283c:	7f 4f       	sbci	r23, 0xFF	; 255
    283e:	8f 4f       	sbci	r24, 0xFF	; 255
    2840:	9f 4f       	sbci	r25, 0xFF	; 255
    2842:	08 95       	ret

00002844 <__floatunsisf>:
    2844:	e8 94       	clt
    2846:	09 c0       	rjmp	.+18     	; 0x285a <__floatsisf+0x12>

00002848 <__floatsisf>:
    2848:	97 fb       	bst	r25, 7
    284a:	3e f4       	brtc	.+14     	; 0x285a <__floatsisf+0x12>
    284c:	90 95       	com	r25
    284e:	80 95       	com	r24
    2850:	70 95       	com	r23
    2852:	61 95       	neg	r22
    2854:	7f 4f       	sbci	r23, 0xFF	; 255
    2856:	8f 4f       	sbci	r24, 0xFF	; 255
    2858:	9f 4f       	sbci	r25, 0xFF	; 255
    285a:	99 23       	and	r25, r25
    285c:	a9 f0       	breq	.+42     	; 0x2888 <__floatsisf+0x40>
    285e:	f9 2f       	mov	r31, r25
    2860:	96 e9       	ldi	r25, 0x96	; 150
    2862:	bb 27       	eor	r27, r27
    2864:	93 95       	inc	r25
    2866:	f6 95       	lsr	r31
    2868:	87 95       	ror	r24
    286a:	77 95       	ror	r23
    286c:	67 95       	ror	r22
    286e:	b7 95       	ror	r27
    2870:	f1 11       	cpse	r31, r1
    2872:	f8 cf       	rjmp	.-16     	; 0x2864 <__floatsisf+0x1c>
    2874:	fa f4       	brpl	.+62     	; 0x28b4 <__floatsisf+0x6c>
    2876:	bb 0f       	add	r27, r27
    2878:	11 f4       	brne	.+4      	; 0x287e <__floatsisf+0x36>
    287a:	60 ff       	sbrs	r22, 0
    287c:	1b c0       	rjmp	.+54     	; 0x28b4 <__floatsisf+0x6c>
    287e:	6f 5f       	subi	r22, 0xFF	; 255
    2880:	7f 4f       	sbci	r23, 0xFF	; 255
    2882:	8f 4f       	sbci	r24, 0xFF	; 255
    2884:	9f 4f       	sbci	r25, 0xFF	; 255
    2886:	16 c0       	rjmp	.+44     	; 0x28b4 <__floatsisf+0x6c>
    2888:	88 23       	and	r24, r24
    288a:	11 f0       	breq	.+4      	; 0x2890 <__floatsisf+0x48>
    288c:	96 e9       	ldi	r25, 0x96	; 150
    288e:	11 c0       	rjmp	.+34     	; 0x28b2 <__floatsisf+0x6a>
    2890:	77 23       	and	r23, r23
    2892:	21 f0       	breq	.+8      	; 0x289c <__floatsisf+0x54>
    2894:	9e e8       	ldi	r25, 0x8E	; 142
    2896:	87 2f       	mov	r24, r23
    2898:	76 2f       	mov	r23, r22
    289a:	05 c0       	rjmp	.+10     	; 0x28a6 <__floatsisf+0x5e>
    289c:	66 23       	and	r22, r22
    289e:	71 f0       	breq	.+28     	; 0x28bc <__floatsisf+0x74>
    28a0:	96 e8       	ldi	r25, 0x86	; 134
    28a2:	86 2f       	mov	r24, r22
    28a4:	70 e0       	ldi	r23, 0x00	; 0
    28a6:	60 e0       	ldi	r22, 0x00	; 0
    28a8:	2a f0       	brmi	.+10     	; 0x28b4 <__floatsisf+0x6c>
    28aa:	9a 95       	dec	r25
    28ac:	66 0f       	add	r22, r22
    28ae:	77 1f       	adc	r23, r23
    28b0:	88 1f       	adc	r24, r24
    28b2:	da f7       	brpl	.-10     	; 0x28aa <__floatsisf+0x62>
    28b4:	88 0f       	add	r24, r24
    28b6:	96 95       	lsr	r25
    28b8:	87 95       	ror	r24
    28ba:	97 f9       	bld	r25, 7
    28bc:	08 95       	ret

000028be <__fp_inf>:
    28be:	97 f9       	bld	r25, 7
    28c0:	9f 67       	ori	r25, 0x7F	; 127
    28c2:	80 e8       	ldi	r24, 0x80	; 128
    28c4:	70 e0       	ldi	r23, 0x00	; 0
    28c6:	60 e0       	ldi	r22, 0x00	; 0
    28c8:	08 95       	ret

000028ca <__fp_nan>:
    28ca:	9f ef       	ldi	r25, 0xFF	; 255
    28cc:	80 ec       	ldi	r24, 0xC0	; 192
    28ce:	08 95       	ret

000028d0 <__fp_pscA>:
    28d0:	00 24       	eor	r0, r0
    28d2:	0a 94       	dec	r0
    28d4:	16 16       	cp	r1, r22
    28d6:	17 06       	cpc	r1, r23
    28d8:	18 06       	cpc	r1, r24
    28da:	09 06       	cpc	r0, r25
    28dc:	08 95       	ret

000028de <__fp_pscB>:
    28de:	00 24       	eor	r0, r0
    28e0:	0a 94       	dec	r0
    28e2:	12 16       	cp	r1, r18
    28e4:	13 06       	cpc	r1, r19
    28e6:	14 06       	cpc	r1, r20
    28e8:	05 06       	cpc	r0, r21
    28ea:	08 95       	ret

000028ec <__fp_round>:
    28ec:	09 2e       	mov	r0, r25
    28ee:	03 94       	inc	r0
    28f0:	00 0c       	add	r0, r0
    28f2:	11 f4       	brne	.+4      	; 0x28f8 <__fp_round+0xc>
    28f4:	88 23       	and	r24, r24
    28f6:	52 f0       	brmi	.+20     	; 0x290c <__fp_round+0x20>
    28f8:	bb 0f       	add	r27, r27
    28fa:	40 f4       	brcc	.+16     	; 0x290c <__fp_round+0x20>
    28fc:	bf 2b       	or	r27, r31
    28fe:	11 f4       	brne	.+4      	; 0x2904 <__fp_round+0x18>
    2900:	60 ff       	sbrs	r22, 0
    2902:	04 c0       	rjmp	.+8      	; 0x290c <__fp_round+0x20>
    2904:	6f 5f       	subi	r22, 0xFF	; 255
    2906:	7f 4f       	sbci	r23, 0xFF	; 255
    2908:	8f 4f       	sbci	r24, 0xFF	; 255
    290a:	9f 4f       	sbci	r25, 0xFF	; 255
    290c:	08 95       	ret

0000290e <__fp_split3>:
    290e:	57 fd       	sbrc	r21, 7
    2910:	90 58       	subi	r25, 0x80	; 128
    2912:	44 0f       	add	r20, r20
    2914:	55 1f       	adc	r21, r21
    2916:	59 f0       	breq	.+22     	; 0x292e <__fp_splitA+0x10>
    2918:	5f 3f       	cpi	r21, 0xFF	; 255
    291a:	71 f0       	breq	.+28     	; 0x2938 <__fp_splitA+0x1a>
    291c:	47 95       	ror	r20

0000291e <__fp_splitA>:
    291e:	88 0f       	add	r24, r24
    2920:	97 fb       	bst	r25, 7
    2922:	99 1f       	adc	r25, r25
    2924:	61 f0       	breq	.+24     	; 0x293e <__fp_splitA+0x20>
    2926:	9f 3f       	cpi	r25, 0xFF	; 255
    2928:	79 f0       	breq	.+30     	; 0x2948 <__fp_splitA+0x2a>
    292a:	87 95       	ror	r24
    292c:	08 95       	ret
    292e:	12 16       	cp	r1, r18
    2930:	13 06       	cpc	r1, r19
    2932:	14 06       	cpc	r1, r20
    2934:	55 1f       	adc	r21, r21
    2936:	f2 cf       	rjmp	.-28     	; 0x291c <__fp_split3+0xe>
    2938:	46 95       	lsr	r20
    293a:	f1 df       	rcall	.-30     	; 0x291e <__fp_splitA>
    293c:	08 c0       	rjmp	.+16     	; 0x294e <__fp_splitA+0x30>
    293e:	16 16       	cp	r1, r22
    2940:	17 06       	cpc	r1, r23
    2942:	18 06       	cpc	r1, r24
    2944:	99 1f       	adc	r25, r25
    2946:	f1 cf       	rjmp	.-30     	; 0x292a <__fp_splitA+0xc>
    2948:	86 95       	lsr	r24
    294a:	71 05       	cpc	r23, r1
    294c:	61 05       	cpc	r22, r1
    294e:	08 94       	sec
    2950:	08 95       	ret

00002952 <__fp_zero>:
    2952:	e8 94       	clt

00002954 <__fp_szero>:
    2954:	bb 27       	eor	r27, r27
    2956:	66 27       	eor	r22, r22
    2958:	77 27       	eor	r23, r23
    295a:	cb 01       	movw	r24, r22
    295c:	97 f9       	bld	r25, 7
    295e:	08 95       	ret

00002960 <__mulsf3>:
    2960:	0b d0       	rcall	.+22     	; 0x2978 <__mulsf3x>
    2962:	c4 cf       	rjmp	.-120    	; 0x28ec <__fp_round>
    2964:	b5 df       	rcall	.-150    	; 0x28d0 <__fp_pscA>
    2966:	28 f0       	brcs	.+10     	; 0x2972 <__mulsf3+0x12>
    2968:	ba df       	rcall	.-140    	; 0x28de <__fp_pscB>
    296a:	18 f0       	brcs	.+6      	; 0x2972 <__mulsf3+0x12>
    296c:	95 23       	and	r25, r21
    296e:	09 f0       	breq	.+2      	; 0x2972 <__mulsf3+0x12>
    2970:	a6 cf       	rjmp	.-180    	; 0x28be <__fp_inf>
    2972:	ab cf       	rjmp	.-170    	; 0x28ca <__fp_nan>
    2974:	11 24       	eor	r1, r1
    2976:	ee cf       	rjmp	.-36     	; 0x2954 <__fp_szero>

00002978 <__mulsf3x>:
    2978:	ca df       	rcall	.-108    	; 0x290e <__fp_split3>
    297a:	a0 f3       	brcs	.-24     	; 0x2964 <__mulsf3+0x4>

0000297c <__mulsf3_pse>:
    297c:	95 9f       	mul	r25, r21
    297e:	d1 f3       	breq	.-12     	; 0x2974 <__mulsf3+0x14>
    2980:	95 0f       	add	r25, r21
    2982:	50 e0       	ldi	r21, 0x00	; 0
    2984:	55 1f       	adc	r21, r21
    2986:	62 9f       	mul	r22, r18
    2988:	f0 01       	movw	r30, r0
    298a:	72 9f       	mul	r23, r18
    298c:	bb 27       	eor	r27, r27
    298e:	f0 0d       	add	r31, r0
    2990:	b1 1d       	adc	r27, r1
    2992:	63 9f       	mul	r22, r19
    2994:	aa 27       	eor	r26, r26
    2996:	f0 0d       	add	r31, r0
    2998:	b1 1d       	adc	r27, r1
    299a:	aa 1f       	adc	r26, r26
    299c:	64 9f       	mul	r22, r20
    299e:	66 27       	eor	r22, r22
    29a0:	b0 0d       	add	r27, r0
    29a2:	a1 1d       	adc	r26, r1
    29a4:	66 1f       	adc	r22, r22
    29a6:	82 9f       	mul	r24, r18
    29a8:	22 27       	eor	r18, r18
    29aa:	b0 0d       	add	r27, r0
    29ac:	a1 1d       	adc	r26, r1
    29ae:	62 1f       	adc	r22, r18
    29b0:	73 9f       	mul	r23, r19
    29b2:	b0 0d       	add	r27, r0
    29b4:	a1 1d       	adc	r26, r1
    29b6:	62 1f       	adc	r22, r18
    29b8:	83 9f       	mul	r24, r19
    29ba:	a0 0d       	add	r26, r0
    29bc:	61 1d       	adc	r22, r1
    29be:	22 1f       	adc	r18, r18
    29c0:	74 9f       	mul	r23, r20
    29c2:	33 27       	eor	r19, r19
    29c4:	a0 0d       	add	r26, r0
    29c6:	61 1d       	adc	r22, r1
    29c8:	23 1f       	adc	r18, r19
    29ca:	84 9f       	mul	r24, r20
    29cc:	60 0d       	add	r22, r0
    29ce:	21 1d       	adc	r18, r1
    29d0:	82 2f       	mov	r24, r18
    29d2:	76 2f       	mov	r23, r22
    29d4:	6a 2f       	mov	r22, r26
    29d6:	11 24       	eor	r1, r1
    29d8:	9f 57       	subi	r25, 0x7F	; 127
    29da:	50 40       	sbci	r21, 0x00	; 0
    29dc:	8a f0       	brmi	.+34     	; 0x2a00 <__mulsf3_pse+0x84>
    29de:	e1 f0       	breq	.+56     	; 0x2a18 <__mulsf3_pse+0x9c>
    29e0:	88 23       	and	r24, r24
    29e2:	4a f0       	brmi	.+18     	; 0x29f6 <__mulsf3_pse+0x7a>
    29e4:	ee 0f       	add	r30, r30
    29e6:	ff 1f       	adc	r31, r31
    29e8:	bb 1f       	adc	r27, r27
    29ea:	66 1f       	adc	r22, r22
    29ec:	77 1f       	adc	r23, r23
    29ee:	88 1f       	adc	r24, r24
    29f0:	91 50       	subi	r25, 0x01	; 1
    29f2:	50 40       	sbci	r21, 0x00	; 0
    29f4:	a9 f7       	brne	.-22     	; 0x29e0 <__mulsf3_pse+0x64>
    29f6:	9e 3f       	cpi	r25, 0xFE	; 254
    29f8:	51 05       	cpc	r21, r1
    29fa:	70 f0       	brcs	.+28     	; 0x2a18 <__mulsf3_pse+0x9c>
    29fc:	60 cf       	rjmp	.-320    	; 0x28be <__fp_inf>
    29fe:	aa cf       	rjmp	.-172    	; 0x2954 <__fp_szero>
    2a00:	5f 3f       	cpi	r21, 0xFF	; 255
    2a02:	ec f3       	brlt	.-6      	; 0x29fe <__mulsf3_pse+0x82>
    2a04:	98 3e       	cpi	r25, 0xE8	; 232
    2a06:	dc f3       	brlt	.-10     	; 0x29fe <__mulsf3_pse+0x82>
    2a08:	86 95       	lsr	r24
    2a0a:	77 95       	ror	r23
    2a0c:	67 95       	ror	r22
    2a0e:	b7 95       	ror	r27
    2a10:	f7 95       	ror	r31
    2a12:	e7 95       	ror	r30
    2a14:	9f 5f       	subi	r25, 0xFF	; 255
    2a16:	c1 f7       	brne	.-16     	; 0x2a08 <__mulsf3_pse+0x8c>
    2a18:	fe 2b       	or	r31, r30
    2a1a:	88 0f       	add	r24, r24
    2a1c:	91 1d       	adc	r25, r1
    2a1e:	96 95       	lsr	r25
    2a20:	87 95       	ror	r24
    2a22:	97 f9       	bld	r25, 7
    2a24:	08 95       	ret

00002a26 <pow>:
    2a26:	fa 01       	movw	r30, r20
    2a28:	ee 0f       	add	r30, r30
    2a2a:	ff 1f       	adc	r31, r31
    2a2c:	30 96       	adiw	r30, 0x00	; 0
    2a2e:	21 05       	cpc	r18, r1
    2a30:	31 05       	cpc	r19, r1
    2a32:	99 f1       	breq	.+102    	; 0x2a9a <pow+0x74>
    2a34:	61 15       	cp	r22, r1
    2a36:	71 05       	cpc	r23, r1
    2a38:	61 f4       	brne	.+24     	; 0x2a52 <pow+0x2c>
    2a3a:	80 38       	cpi	r24, 0x80	; 128
    2a3c:	bf e3       	ldi	r27, 0x3F	; 63
    2a3e:	9b 07       	cpc	r25, r27
    2a40:	49 f1       	breq	.+82     	; 0x2a94 <pow+0x6e>
    2a42:	68 94       	set
    2a44:	90 38       	cpi	r25, 0x80	; 128
    2a46:	81 05       	cpc	r24, r1
    2a48:	61 f0       	breq	.+24     	; 0x2a62 <pow+0x3c>
    2a4a:	80 38       	cpi	r24, 0x80	; 128
    2a4c:	bf ef       	ldi	r27, 0xFF	; 255
    2a4e:	9b 07       	cpc	r25, r27
    2a50:	41 f0       	breq	.+16     	; 0x2a62 <pow+0x3c>
    2a52:	99 23       	and	r25, r25
    2a54:	42 f5       	brpl	.+80     	; 0x2aa6 <pow+0x80>
    2a56:	ff 3f       	cpi	r31, 0xFF	; 255
    2a58:	e1 05       	cpc	r30, r1
    2a5a:	31 05       	cpc	r19, r1
    2a5c:	21 05       	cpc	r18, r1
    2a5e:	11 f1       	breq	.+68     	; 0x2aa4 <pow+0x7e>
    2a60:	e8 94       	clt
    2a62:	08 94       	sec
    2a64:	e7 95       	ror	r30
    2a66:	d9 01       	movw	r26, r18
    2a68:	aa 23       	and	r26, r26
    2a6a:	29 f4       	brne	.+10     	; 0x2a76 <pow+0x50>
    2a6c:	ab 2f       	mov	r26, r27
    2a6e:	be 2f       	mov	r27, r30
    2a70:	f8 5f       	subi	r31, 0xF8	; 248
    2a72:	d0 f3       	brcs	.-12     	; 0x2a68 <pow+0x42>
    2a74:	10 c0       	rjmp	.+32     	; 0x2a96 <pow+0x70>
    2a76:	ff 5f       	subi	r31, 0xFF	; 255
    2a78:	70 f4       	brcc	.+28     	; 0x2a96 <pow+0x70>
    2a7a:	a6 95       	lsr	r26
    2a7c:	e0 f7       	brcc	.-8      	; 0x2a76 <pow+0x50>
    2a7e:	f7 39       	cpi	r31, 0x97	; 151
    2a80:	50 f0       	brcs	.+20     	; 0x2a96 <pow+0x70>
    2a82:	19 f0       	breq	.+6      	; 0x2a8a <pow+0x64>
    2a84:	ff 3a       	cpi	r31, 0xAF	; 175
    2a86:	38 f4       	brcc	.+14     	; 0x2a96 <pow+0x70>
    2a88:	9f 77       	andi	r25, 0x7F	; 127
    2a8a:	9f 93       	push	r25
    2a8c:	0c d0       	rcall	.+24     	; 0x2aa6 <pow+0x80>
    2a8e:	0f 90       	pop	r0
    2a90:	07 fc       	sbrc	r0, 7
    2a92:	90 58       	subi	r25, 0x80	; 128
    2a94:	08 95       	ret
    2a96:	3e f0       	brts	.+14     	; 0x2aa6 <pow+0x80>
    2a98:	18 cf       	rjmp	.-464    	; 0x28ca <__fp_nan>
    2a9a:	60 e0       	ldi	r22, 0x00	; 0
    2a9c:	70 e0       	ldi	r23, 0x00	; 0
    2a9e:	80 e8       	ldi	r24, 0x80	; 128
    2aa0:	9f e3       	ldi	r25, 0x3F	; 63
    2aa2:	08 95       	ret
    2aa4:	4f e7       	ldi	r20, 0x7F	; 127
    2aa6:	9f 77       	andi	r25, 0x7F	; 127
    2aa8:	5f 93       	push	r21
    2aaa:	4f 93       	push	r20
    2aac:	3f 93       	push	r19
    2aae:	2f 93       	push	r18
    2ab0:	9e d0       	rcall	.+316    	; 0x2bee <log>
    2ab2:	2f 91       	pop	r18
    2ab4:	3f 91       	pop	r19
    2ab6:	4f 91       	pop	r20
    2ab8:	5f 91       	pop	r21
    2aba:	52 df       	rcall	.-348    	; 0x2960 <__mulsf3>
    2abc:	05 c0       	rjmp	.+10     	; 0x2ac8 <exp>
    2abe:	19 f4       	brne	.+6      	; 0x2ac6 <pow+0xa0>
    2ac0:	0e f0       	brts	.+2      	; 0x2ac4 <pow+0x9e>
    2ac2:	fd ce       	rjmp	.-518    	; 0x28be <__fp_inf>
    2ac4:	46 cf       	rjmp	.-372    	; 0x2952 <__fp_zero>
    2ac6:	01 cf       	rjmp	.-510    	; 0x28ca <__fp_nan>

00002ac8 <exp>:
    2ac8:	2a df       	rcall	.-428    	; 0x291e <__fp_splitA>
    2aca:	c8 f3       	brcs	.-14     	; 0x2abe <pow+0x98>
    2acc:	96 38       	cpi	r25, 0x86	; 134
    2ace:	c0 f7       	brcc	.-16     	; 0x2ac0 <pow+0x9a>
    2ad0:	07 f8       	bld	r0, 7
    2ad2:	0f 92       	push	r0
    2ad4:	e8 94       	clt
    2ad6:	2b e3       	ldi	r18, 0x3B	; 59
    2ad8:	3a ea       	ldi	r19, 0xAA	; 170
    2ada:	48 eb       	ldi	r20, 0xB8	; 184
    2adc:	5f e7       	ldi	r21, 0x7F	; 127
    2ade:	4e df       	rcall	.-356    	; 0x297c <__mulsf3_pse>
    2ae0:	0f 92       	push	r0
    2ae2:	0f 92       	push	r0
    2ae4:	0f 92       	push	r0
    2ae6:	4d b7       	in	r20, 0x3d	; 61
    2ae8:	5e b7       	in	r21, 0x3e	; 62
    2aea:	0f 92       	push	r0
    2aec:	c0 d0       	rcall	.+384    	; 0x2c6e <modf>
    2aee:	e4 ee       	ldi	r30, 0xE4	; 228
    2af0:	f0 e0       	ldi	r31, 0x00	; 0
    2af2:	16 d0       	rcall	.+44     	; 0x2b20 <__fp_powser>
    2af4:	4f 91       	pop	r20
    2af6:	5f 91       	pop	r21
    2af8:	ef 91       	pop	r30
    2afa:	ff 91       	pop	r31
    2afc:	e5 95       	asr	r30
    2afe:	ee 1f       	adc	r30, r30
    2b00:	ff 1f       	adc	r31, r31
    2b02:	49 f0       	breq	.+18     	; 0x2b16 <exp+0x4e>
    2b04:	fe 57       	subi	r31, 0x7E	; 126
    2b06:	e0 68       	ori	r30, 0x80	; 128
    2b08:	44 27       	eor	r20, r20
    2b0a:	ee 0f       	add	r30, r30
    2b0c:	44 1f       	adc	r20, r20
    2b0e:	fa 95       	dec	r31
    2b10:	e1 f7       	brne	.-8      	; 0x2b0a <exp+0x42>
    2b12:	41 95       	neg	r20
    2b14:	55 0b       	sbc	r21, r21
    2b16:	32 d0       	rcall	.+100    	; 0x2b7c <ldexp>
    2b18:	0f 90       	pop	r0
    2b1a:	07 fe       	sbrs	r0, 7
    2b1c:	26 c0       	rjmp	.+76     	; 0x2b6a <inverse>
    2b1e:	08 95       	ret

00002b20 <__fp_powser>:
    2b20:	df 93       	push	r29
    2b22:	cf 93       	push	r28
    2b24:	1f 93       	push	r17
    2b26:	0f 93       	push	r16
    2b28:	ff 92       	push	r15
    2b2a:	ef 92       	push	r14
    2b2c:	df 92       	push	r13
    2b2e:	7b 01       	movw	r14, r22
    2b30:	8c 01       	movw	r16, r24
    2b32:	68 94       	set
    2b34:	05 c0       	rjmp	.+10     	; 0x2b40 <__fp_powser+0x20>
    2b36:	da 2e       	mov	r13, r26
    2b38:	ef 01       	movw	r28, r30
    2b3a:	1e df       	rcall	.-452    	; 0x2978 <__mulsf3x>
    2b3c:	fe 01       	movw	r30, r28
    2b3e:	e8 94       	clt
    2b40:	a5 91       	lpm	r26, Z+
    2b42:	25 91       	lpm	r18, Z+
    2b44:	35 91       	lpm	r19, Z+
    2b46:	45 91       	lpm	r20, Z+
    2b48:	55 91       	lpm	r21, Z+
    2b4a:	ae f3       	brts	.-22     	; 0x2b36 <__fp_powser+0x16>
    2b4c:	ef 01       	movw	r28, r30
    2b4e:	f6 dd       	rcall	.-1044   	; 0x273c <__addsf3x>
    2b50:	fe 01       	movw	r30, r28
    2b52:	97 01       	movw	r18, r14
    2b54:	a8 01       	movw	r20, r16
    2b56:	da 94       	dec	r13
    2b58:	79 f7       	brne	.-34     	; 0x2b38 <__fp_powser+0x18>
    2b5a:	df 90       	pop	r13
    2b5c:	ef 90       	pop	r14
    2b5e:	ff 90       	pop	r15
    2b60:	0f 91       	pop	r16
    2b62:	1f 91       	pop	r17
    2b64:	cf 91       	pop	r28
    2b66:	df 91       	pop	r29
    2b68:	08 95       	ret

00002b6a <inverse>:
    2b6a:	9b 01       	movw	r18, r22
    2b6c:	ac 01       	movw	r20, r24
    2b6e:	60 e0       	ldi	r22, 0x00	; 0
    2b70:	70 e0       	ldi	r23, 0x00	; 0
    2b72:	80 e8       	ldi	r24, 0x80	; 128
    2b74:	9f e3       	ldi	r25, 0x3F	; 63
    2b76:	ae c0       	rjmp	.+348    	; 0x2cd4 <__divsf3>
    2b78:	a2 ce       	rjmp	.-700    	; 0x28be <__fp_inf>
    2b7a:	14 c1       	rjmp	.+552    	; 0x2da4 <__fp_mpack>

00002b7c <ldexp>:
    2b7c:	d0 de       	rcall	.-608    	; 0x291e <__fp_splitA>
    2b7e:	e8 f3       	brcs	.-6      	; 0x2b7a <inverse+0x10>
    2b80:	99 23       	and	r25, r25
    2b82:	d9 f3       	breq	.-10     	; 0x2b7a <inverse+0x10>
    2b84:	94 0f       	add	r25, r20
    2b86:	51 1d       	adc	r21, r1
    2b88:	bb f3       	brvs	.-18     	; 0x2b78 <inverse+0xe>
    2b8a:	91 50       	subi	r25, 0x01	; 1
    2b8c:	50 40       	sbci	r21, 0x00	; 0
    2b8e:	94 f0       	brlt	.+36     	; 0x2bb4 <ldexp+0x38>
    2b90:	59 f0       	breq	.+22     	; 0x2ba8 <ldexp+0x2c>
    2b92:	88 23       	and	r24, r24
    2b94:	32 f0       	brmi	.+12     	; 0x2ba2 <ldexp+0x26>
    2b96:	66 0f       	add	r22, r22
    2b98:	77 1f       	adc	r23, r23
    2b9a:	88 1f       	adc	r24, r24
    2b9c:	91 50       	subi	r25, 0x01	; 1
    2b9e:	50 40       	sbci	r21, 0x00	; 0
    2ba0:	c1 f7       	brne	.-16     	; 0x2b92 <ldexp+0x16>
    2ba2:	9e 3f       	cpi	r25, 0xFE	; 254
    2ba4:	51 05       	cpc	r21, r1
    2ba6:	44 f7       	brge	.-48     	; 0x2b78 <inverse+0xe>
    2ba8:	88 0f       	add	r24, r24
    2baa:	91 1d       	adc	r25, r1
    2bac:	96 95       	lsr	r25
    2bae:	87 95       	ror	r24
    2bb0:	97 f9       	bld	r25, 7
    2bb2:	08 95       	ret
    2bb4:	5f 3f       	cpi	r21, 0xFF	; 255
    2bb6:	ac f0       	brlt	.+42     	; 0x2be2 <ldexp+0x66>
    2bb8:	98 3e       	cpi	r25, 0xE8	; 232
    2bba:	9c f0       	brlt	.+38     	; 0x2be2 <ldexp+0x66>
    2bbc:	bb 27       	eor	r27, r27
    2bbe:	86 95       	lsr	r24
    2bc0:	77 95       	ror	r23
    2bc2:	67 95       	ror	r22
    2bc4:	b7 95       	ror	r27
    2bc6:	08 f4       	brcc	.+2      	; 0x2bca <ldexp+0x4e>
    2bc8:	b1 60       	ori	r27, 0x01	; 1
    2bca:	93 95       	inc	r25
    2bcc:	c1 f7       	brne	.-16     	; 0x2bbe <ldexp+0x42>
    2bce:	bb 0f       	add	r27, r27
    2bd0:	58 f7       	brcc	.-42     	; 0x2ba8 <ldexp+0x2c>
    2bd2:	11 f4       	brne	.+4      	; 0x2bd8 <ldexp+0x5c>
    2bd4:	60 ff       	sbrs	r22, 0
    2bd6:	e8 cf       	rjmp	.-48     	; 0x2ba8 <ldexp+0x2c>
    2bd8:	6f 5f       	subi	r22, 0xFF	; 255
    2bda:	7f 4f       	sbci	r23, 0xFF	; 255
    2bdc:	8f 4f       	sbci	r24, 0xFF	; 255
    2bde:	9f 4f       	sbci	r25, 0xFF	; 255
    2be0:	e3 cf       	rjmp	.-58     	; 0x2ba8 <ldexp+0x2c>
    2be2:	b8 ce       	rjmp	.-656    	; 0x2954 <__fp_szero>
    2be4:	0e f0       	brts	.+2      	; 0x2be8 <ldexp+0x6c>
    2be6:	de c0       	rjmp	.+444    	; 0x2da4 <__fp_mpack>
    2be8:	70 ce       	rjmp	.-800    	; 0x28ca <__fp_nan>
    2bea:	68 94       	set
    2bec:	68 ce       	rjmp	.-816    	; 0x28be <__fp_inf>

00002bee <log>:
    2bee:	97 de       	rcall	.-722    	; 0x291e <__fp_splitA>
    2bf0:	c8 f3       	brcs	.-14     	; 0x2be4 <ldexp+0x68>
    2bf2:	99 23       	and	r25, r25
    2bf4:	d1 f3       	breq	.-12     	; 0x2bea <ldexp+0x6e>
    2bf6:	c6 f3       	brts	.-16     	; 0x2be8 <ldexp+0x6c>
    2bf8:	df 93       	push	r29
    2bfa:	cf 93       	push	r28
    2bfc:	1f 93       	push	r17
    2bfe:	0f 93       	push	r16
    2c00:	ff 92       	push	r15
    2c02:	c9 2f       	mov	r28, r25
    2c04:	dd 27       	eor	r29, r29
    2c06:	88 23       	and	r24, r24
    2c08:	2a f0       	brmi	.+10     	; 0x2c14 <log+0x26>
    2c0a:	21 97       	sbiw	r28, 0x01	; 1
    2c0c:	66 0f       	add	r22, r22
    2c0e:	77 1f       	adc	r23, r23
    2c10:	88 1f       	adc	r24, r24
    2c12:	da f7       	brpl	.-10     	; 0x2c0a <log+0x1c>
    2c14:	20 e0       	ldi	r18, 0x00	; 0
    2c16:	30 e0       	ldi	r19, 0x00	; 0
    2c18:	40 e8       	ldi	r20, 0x80	; 128
    2c1a:	5f eb       	ldi	r21, 0xBF	; 191
    2c1c:	9f e3       	ldi	r25, 0x3F	; 63
    2c1e:	88 39       	cpi	r24, 0x98	; 152
    2c20:	20 f0       	brcs	.+8      	; 0x2c2a <log+0x3c>
    2c22:	80 3e       	cpi	r24, 0xE0	; 224
    2c24:	30 f0       	brcs	.+12     	; 0x2c32 <log+0x44>
    2c26:	21 96       	adiw	r28, 0x01	; 1
    2c28:	8f 77       	andi	r24, 0x7F	; 127
    2c2a:	77 dd       	rcall	.-1298   	; 0x271a <__addsf3>
    2c2c:	ec e0       	ldi	r30, 0x0C	; 12
    2c2e:	f1 e0       	ldi	r31, 0x01	; 1
    2c30:	03 c0       	rjmp	.+6      	; 0x2c38 <log+0x4a>
    2c32:	73 dd       	rcall	.-1306   	; 0x271a <__addsf3>
    2c34:	e9 e3       	ldi	r30, 0x39	; 57
    2c36:	f1 e0       	ldi	r31, 0x01	; 1
    2c38:	73 df       	rcall	.-282    	; 0x2b20 <__fp_powser>
    2c3a:	8b 01       	movw	r16, r22
    2c3c:	be 01       	movw	r22, r28
    2c3e:	ec 01       	movw	r28, r24
    2c40:	fb 2e       	mov	r15, r27
    2c42:	6f 57       	subi	r22, 0x7F	; 127
    2c44:	71 09       	sbc	r23, r1
    2c46:	75 95       	asr	r23
    2c48:	77 1f       	adc	r23, r23
    2c4a:	88 0b       	sbc	r24, r24
    2c4c:	99 0b       	sbc	r25, r25
    2c4e:	fc dd       	rcall	.-1032   	; 0x2848 <__floatsisf>
    2c50:	28 e1       	ldi	r18, 0x18	; 24
    2c52:	32 e7       	ldi	r19, 0x72	; 114
    2c54:	41 e3       	ldi	r20, 0x31	; 49
    2c56:	5f e3       	ldi	r21, 0x3F	; 63
    2c58:	8f de       	rcall	.-738    	; 0x2978 <__mulsf3x>
    2c5a:	af 2d       	mov	r26, r15
    2c5c:	98 01       	movw	r18, r16
    2c5e:	ae 01       	movw	r20, r28
    2c60:	ff 90       	pop	r15
    2c62:	0f 91       	pop	r16
    2c64:	1f 91       	pop	r17
    2c66:	cf 91       	pop	r28
    2c68:	df 91       	pop	r29
    2c6a:	68 dd       	rcall	.-1328   	; 0x273c <__addsf3x>
    2c6c:	3f ce       	rjmp	.-898    	; 0x28ec <__fp_round>

00002c6e <modf>:
    2c6e:	fa 01       	movw	r30, r20
    2c70:	dc 01       	movw	r26, r24
    2c72:	aa 0f       	add	r26, r26
    2c74:	bb 1f       	adc	r27, r27
    2c76:	9b 01       	movw	r18, r22
    2c78:	ac 01       	movw	r20, r24
    2c7a:	bf 57       	subi	r27, 0x7F	; 127
    2c7c:	28 f4       	brcc	.+10     	; 0x2c88 <modf+0x1a>
    2c7e:	22 27       	eor	r18, r18
    2c80:	33 27       	eor	r19, r19
    2c82:	44 27       	eor	r20, r20
    2c84:	50 78       	andi	r21, 0x80	; 128
    2c86:	1f c0       	rjmp	.+62     	; 0x2cc6 <modf+0x58>
    2c88:	b7 51       	subi	r27, 0x17	; 23
    2c8a:	88 f4       	brcc	.+34     	; 0x2cae <modf+0x40>
    2c8c:	ab 2f       	mov	r26, r27
    2c8e:	00 24       	eor	r0, r0
    2c90:	46 95       	lsr	r20
    2c92:	37 95       	ror	r19
    2c94:	27 95       	ror	r18
    2c96:	01 1c       	adc	r0, r1
    2c98:	a3 95       	inc	r26
    2c9a:	d2 f3       	brmi	.-12     	; 0x2c90 <modf+0x22>
    2c9c:	00 20       	and	r0, r0
    2c9e:	69 f0       	breq	.+26     	; 0x2cba <modf+0x4c>
    2ca0:	22 0f       	add	r18, r18
    2ca2:	33 1f       	adc	r19, r19
    2ca4:	44 1f       	adc	r20, r20
    2ca6:	b3 95       	inc	r27
    2ca8:	da f3       	brmi	.-10     	; 0x2ca0 <modf+0x32>
    2caa:	0d d0       	rcall	.+26     	; 0x2cc6 <modf+0x58>
    2cac:	35 cd       	rjmp	.-1430   	; 0x2718 <__subsf3>
    2cae:	61 30       	cpi	r22, 0x01	; 1
    2cb0:	71 05       	cpc	r23, r1
    2cb2:	a0 e8       	ldi	r26, 0x80	; 128
    2cb4:	8a 07       	cpc	r24, r26
    2cb6:	b9 46       	sbci	r27, 0x69	; 105
    2cb8:	30 f4       	brcc	.+12     	; 0x2cc6 <modf+0x58>
    2cba:	9b 01       	movw	r18, r22
    2cbc:	ac 01       	movw	r20, r24
    2cbe:	66 27       	eor	r22, r22
    2cc0:	77 27       	eor	r23, r23
    2cc2:	88 27       	eor	r24, r24
    2cc4:	90 78       	andi	r25, 0x80	; 128
    2cc6:	30 96       	adiw	r30, 0x00	; 0
    2cc8:	21 f0       	breq	.+8      	; 0x2cd2 <modf+0x64>
    2cca:	20 83       	st	Z, r18
    2ccc:	31 83       	std	Z+1, r19	; 0x01
    2cce:	42 83       	std	Z+2, r20	; 0x02
    2cd0:	53 83       	std	Z+3, r21	; 0x03
    2cd2:	08 95       	ret

00002cd4 <__divsf3>:
    2cd4:	0c d0       	rcall	.+24     	; 0x2cee <__divsf3x>
    2cd6:	0a ce       	rjmp	.-1004   	; 0x28ec <__fp_round>
    2cd8:	02 de       	rcall	.-1020   	; 0x28de <__fp_pscB>
    2cda:	40 f0       	brcs	.+16     	; 0x2cec <__divsf3+0x18>
    2cdc:	f9 dd       	rcall	.-1038   	; 0x28d0 <__fp_pscA>
    2cde:	30 f0       	brcs	.+12     	; 0x2cec <__divsf3+0x18>
    2ce0:	21 f4       	brne	.+8      	; 0x2cea <__divsf3+0x16>
    2ce2:	5f 3f       	cpi	r21, 0xFF	; 255
    2ce4:	19 f0       	breq	.+6      	; 0x2cec <__divsf3+0x18>
    2ce6:	eb cd       	rjmp	.-1066   	; 0x28be <__fp_inf>
    2ce8:	51 11       	cpse	r21, r1
    2cea:	34 ce       	rjmp	.-920    	; 0x2954 <__fp_szero>
    2cec:	ee cd       	rjmp	.-1060   	; 0x28ca <__fp_nan>

00002cee <__divsf3x>:
    2cee:	0f de       	rcall	.-994    	; 0x290e <__fp_split3>
    2cf0:	98 f3       	brcs	.-26     	; 0x2cd8 <__divsf3+0x4>

00002cf2 <__divsf3_pse>:
    2cf2:	99 23       	and	r25, r25
    2cf4:	c9 f3       	breq	.-14     	; 0x2ce8 <__divsf3+0x14>
    2cf6:	55 23       	and	r21, r21
    2cf8:	b1 f3       	breq	.-20     	; 0x2ce6 <__divsf3+0x12>
    2cfa:	95 1b       	sub	r25, r21
    2cfc:	55 0b       	sbc	r21, r21
    2cfe:	bb 27       	eor	r27, r27
    2d00:	aa 27       	eor	r26, r26
    2d02:	62 17       	cp	r22, r18
    2d04:	73 07       	cpc	r23, r19
    2d06:	84 07       	cpc	r24, r20
    2d08:	38 f0       	brcs	.+14     	; 0x2d18 <__divsf3_pse+0x26>
    2d0a:	9f 5f       	subi	r25, 0xFF	; 255
    2d0c:	5f 4f       	sbci	r21, 0xFF	; 255
    2d0e:	22 0f       	add	r18, r18
    2d10:	33 1f       	adc	r19, r19
    2d12:	44 1f       	adc	r20, r20
    2d14:	aa 1f       	adc	r26, r26
    2d16:	a9 f3       	breq	.-22     	; 0x2d02 <__divsf3_pse+0x10>
    2d18:	33 d0       	rcall	.+102    	; 0x2d80 <__divsf3_pse+0x8e>
    2d1a:	0e 2e       	mov	r0, r30
    2d1c:	3a f0       	brmi	.+14     	; 0x2d2c <__divsf3_pse+0x3a>
    2d1e:	e0 e8       	ldi	r30, 0x80	; 128
    2d20:	30 d0       	rcall	.+96     	; 0x2d82 <__divsf3_pse+0x90>
    2d22:	91 50       	subi	r25, 0x01	; 1
    2d24:	50 40       	sbci	r21, 0x00	; 0
    2d26:	e6 95       	lsr	r30
    2d28:	00 1c       	adc	r0, r0
    2d2a:	ca f7       	brpl	.-14     	; 0x2d1e <__divsf3_pse+0x2c>
    2d2c:	29 d0       	rcall	.+82     	; 0x2d80 <__divsf3_pse+0x8e>
    2d2e:	fe 2f       	mov	r31, r30
    2d30:	27 d0       	rcall	.+78     	; 0x2d80 <__divsf3_pse+0x8e>
    2d32:	66 0f       	add	r22, r22
    2d34:	77 1f       	adc	r23, r23
    2d36:	88 1f       	adc	r24, r24
    2d38:	bb 1f       	adc	r27, r27
    2d3a:	26 17       	cp	r18, r22
    2d3c:	37 07       	cpc	r19, r23
    2d3e:	48 07       	cpc	r20, r24
    2d40:	ab 07       	cpc	r26, r27
    2d42:	b0 e8       	ldi	r27, 0x80	; 128
    2d44:	09 f0       	breq	.+2      	; 0x2d48 <__divsf3_pse+0x56>
    2d46:	bb 0b       	sbc	r27, r27
    2d48:	80 2d       	mov	r24, r0
    2d4a:	bf 01       	movw	r22, r30
    2d4c:	ff 27       	eor	r31, r31
    2d4e:	93 58       	subi	r25, 0x83	; 131
    2d50:	5f 4f       	sbci	r21, 0xFF	; 255
    2d52:	2a f0       	brmi	.+10     	; 0x2d5e <__divsf3_pse+0x6c>
    2d54:	9e 3f       	cpi	r25, 0xFE	; 254
    2d56:	51 05       	cpc	r21, r1
    2d58:	68 f0       	brcs	.+26     	; 0x2d74 <__divsf3_pse+0x82>
    2d5a:	b1 cd       	rjmp	.-1182   	; 0x28be <__fp_inf>
    2d5c:	fb cd       	rjmp	.-1034   	; 0x2954 <__fp_szero>
    2d5e:	5f 3f       	cpi	r21, 0xFF	; 255
    2d60:	ec f3       	brlt	.-6      	; 0x2d5c <__divsf3_pse+0x6a>
    2d62:	98 3e       	cpi	r25, 0xE8	; 232
    2d64:	dc f3       	brlt	.-10     	; 0x2d5c <__divsf3_pse+0x6a>
    2d66:	86 95       	lsr	r24
    2d68:	77 95       	ror	r23
    2d6a:	67 95       	ror	r22
    2d6c:	b7 95       	ror	r27
    2d6e:	f7 95       	ror	r31
    2d70:	9f 5f       	subi	r25, 0xFF	; 255
    2d72:	c9 f7       	brne	.-14     	; 0x2d66 <__divsf3_pse+0x74>
    2d74:	88 0f       	add	r24, r24
    2d76:	91 1d       	adc	r25, r1
    2d78:	96 95       	lsr	r25
    2d7a:	87 95       	ror	r24
    2d7c:	97 f9       	bld	r25, 7
    2d7e:	08 95       	ret
    2d80:	e1 e0       	ldi	r30, 0x01	; 1
    2d82:	66 0f       	add	r22, r22
    2d84:	77 1f       	adc	r23, r23
    2d86:	88 1f       	adc	r24, r24
    2d88:	bb 1f       	adc	r27, r27
    2d8a:	62 17       	cp	r22, r18
    2d8c:	73 07       	cpc	r23, r19
    2d8e:	84 07       	cpc	r24, r20
    2d90:	ba 07       	cpc	r27, r26
    2d92:	20 f0       	brcs	.+8      	; 0x2d9c <__divsf3_pse+0xaa>
    2d94:	62 1b       	sub	r22, r18
    2d96:	73 0b       	sbc	r23, r19
    2d98:	84 0b       	sbc	r24, r20
    2d9a:	ba 0b       	sbc	r27, r26
    2d9c:	ee 1f       	adc	r30, r30
    2d9e:	88 f7       	brcc	.-30     	; 0x2d82 <__divsf3_pse+0x90>
    2da0:	e0 95       	com	r30
    2da2:	08 95       	ret

00002da4 <__fp_mpack>:
    2da4:	9f 3f       	cpi	r25, 0xFF	; 255
    2da6:	31 f0       	breq	.+12     	; 0x2db4 <__fp_mpack_finite+0xc>

00002da8 <__fp_mpack_finite>:
    2da8:	91 50       	subi	r25, 0x01	; 1
    2daa:	20 f4       	brcc	.+8      	; 0x2db4 <__fp_mpack_finite+0xc>
    2dac:	87 95       	ror	r24
    2dae:	77 95       	ror	r23
    2db0:	67 95       	ror	r22
    2db2:	b7 95       	ror	r27
    2db4:	88 0f       	add	r24, r24
    2db6:	91 1d       	adc	r25, r1
    2db8:	96 95       	lsr	r25
    2dba:	87 95       	ror	r24
    2dbc:	97 f9       	bld	r25, 7
    2dbe:	08 95       	ret

00002dc0 <__divmodhi4>:
    2dc0:	97 fb       	bst	r25, 7
    2dc2:	07 2e       	mov	r0, r23
    2dc4:	16 f4       	brtc	.+4      	; 0x2dca <__divmodhi4+0xa>
    2dc6:	00 94       	com	r0
    2dc8:	06 d0       	rcall	.+12     	; 0x2dd6 <__divmodhi4_neg1>
    2dca:	77 fd       	sbrc	r23, 7
    2dcc:	08 d0       	rcall	.+16     	; 0x2dde <__divmodhi4_neg2>
    2dce:	0b d0       	rcall	.+22     	; 0x2de6 <__udivmodhi4>
    2dd0:	07 fc       	sbrc	r0, 7
    2dd2:	05 d0       	rcall	.+10     	; 0x2dde <__divmodhi4_neg2>
    2dd4:	3e f4       	brtc	.+14     	; 0x2de4 <__divmodhi4_exit>

00002dd6 <__divmodhi4_neg1>:
    2dd6:	90 95       	com	r25
    2dd8:	81 95       	neg	r24
    2dda:	9f 4f       	sbci	r25, 0xFF	; 255
    2ddc:	08 95       	ret

00002dde <__divmodhi4_neg2>:
    2dde:	70 95       	com	r23
    2de0:	61 95       	neg	r22
    2de2:	7f 4f       	sbci	r23, 0xFF	; 255

00002de4 <__divmodhi4_exit>:
    2de4:	08 95       	ret

00002de6 <__udivmodhi4>:
    2de6:	aa 1b       	sub	r26, r26
    2de8:	bb 1b       	sub	r27, r27
    2dea:	51 e1       	ldi	r21, 0x11	; 17
    2dec:	07 c0       	rjmp	.+14     	; 0x2dfc <__udivmodhi4_ep>

00002dee <__udivmodhi4_loop>:
    2dee:	aa 1f       	adc	r26, r26
    2df0:	bb 1f       	adc	r27, r27
    2df2:	a6 17       	cp	r26, r22
    2df4:	b7 07       	cpc	r27, r23
    2df6:	10 f0       	brcs	.+4      	; 0x2dfc <__udivmodhi4_ep>
    2df8:	a6 1b       	sub	r26, r22
    2dfa:	b7 0b       	sbc	r27, r23

00002dfc <__udivmodhi4_ep>:
    2dfc:	88 1f       	adc	r24, r24
    2dfe:	99 1f       	adc	r25, r25
    2e00:	5a 95       	dec	r21
    2e02:	a9 f7       	brne	.-22     	; 0x2dee <__udivmodhi4_loop>
    2e04:	80 95       	com	r24
    2e06:	90 95       	com	r25
    2e08:	bc 01       	movw	r22, r24
    2e0a:	cd 01       	movw	r24, r26
    2e0c:	08 95       	ret

00002e0e <memcpy>:
    2e0e:	fb 01       	movw	r30, r22
    2e10:	dc 01       	movw	r26, r24
    2e12:	02 c0       	rjmp	.+4      	; 0x2e18 <memcpy+0xa>
    2e14:	01 90       	ld	r0, Z+
    2e16:	0d 92       	st	X+, r0
    2e18:	41 50       	subi	r20, 0x01	; 1
    2e1a:	50 40       	sbci	r21, 0x00	; 0
    2e1c:	d8 f7       	brcc	.-10     	; 0x2e14 <memcpy+0x6>
    2e1e:	08 95       	ret

00002e20 <_exit>:
    2e20:	f8 94       	cli

00002e22 <__stop_program>:
    2e22:	ff cf       	rjmp	.-2      	; 0x2e22 <__stop_program>
