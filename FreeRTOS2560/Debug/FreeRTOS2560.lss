
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002ede  00002f72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ede  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070d  00800238  00800238  00002faa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002faa  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000568  00000000  00000000  00002fda  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f5a  00000000  00000000  00003542  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001673  00000000  00000000  0000949c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000038ca  00000000  00000000  0000ab0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f60  00000000  00000000  0000e3dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001797  00000000  00000000  0000f33c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004280  00000000  00000000  00010ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f8  00000000  00000000  00014d53  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c0 c3       	rjmp	.+1920   	; 0x7a6 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	84 c7       	rjmp	.+3848   	; 0xf6e <__vector_25>
      66:	00 00       	nop
      68:	fa c7       	rjmp	.+4084   	; 0x105e <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	a8 c4       	rjmp	.+2384   	; 0x9c6 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	36 c7       	rjmp	.+3692   	; 0xefe <__vector_36>
      92:	00 00       	nop
      94:	a4 c7       	rjmp	.+3912   	; 0xfde <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x8>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ee ed       	ldi	r30, 0xDE	; 222
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a5 34       	cpi	r26, 0x45	; 69
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	de d0       	rcall	.+444    	; 0x35e <main>
     1a2:	0c 94 6d 17 	jmp	0x2eda	; 0x2eda <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 79 09 	call	0x12f2	; 0x12f2 <myUSART_peekReceiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 61 09 	call	0x12c2	; 0x12c2 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	29 f0       	breq	.+10     	; 0x1c4 <RPI_receiveTask+0x1c>
     1ba:	0e 94 21 09 	call	0x1242	; 0x1242 <myUSART_receiveUSART1>
     1be:	0e 94 56 09 	call	0x12ac	; 0x12ac <myUSART_completeHandShake>
     1c2:	f4 cf       	rjmp	.-24     	; 0x1ac <RPI_receiveTask+0x4>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	0e 94 73 09 	call	0x12e6	; 0x12e6 <myUSART_receiveMessageACK>
     1ca:	88 23       	and	r24, r24
     1cc:	19 f0       	breq	.+6      	; 0x1d4 <RPI_receiveTask+0x2c>
     1ce:	0e 94 21 09 	call	0x1242	; 0x1242 <myUSART_receiveUSART1>
     1d2:	ec cf       	rjmp	.-40     	; 0x1ac <RPI_receiveTask+0x4>
     1d4:	80 91 38 02 	lds	r24, 0x0238
     1d8:	81 11       	cpse	r24, r1
     1da:	0c c0       	rjmp	.+24     	; 0x1f4 <RPI_receiveTask+0x4c>
     1dc:	8c 2f       	mov	r24, r28
     1de:	0e 94 67 09 	call	0x12ce	; 0x12ce <myUSART_receiveHandShakeStart>
     1e2:	88 23       	and	r24, r24
     1e4:	19 f3       	breq	.-58     	; 0x1ac <RPI_receiveTask+0x4>
     1e6:	0e 94 21 09 	call	0x1242	; 0x1242 <myUSART_receiveUSART1>
     1ea:	85 e0       	ldi	r24, 0x05	; 5
     1ec:	ed d7       	rcall	.+4058   	; 0x11c8 <myUSART_transmitUSART1_c>
     1ee:	d0 93 38 02 	sts	0x0238, r29
     1f2:	dc cf       	rjmp	.-72     	; 0x1ac <RPI_receiveTask+0x4>
     1f4:	81 30       	cpi	r24, 0x01	; 1
     1f6:	59 f4       	brne	.+22     	; 0x20e <RPI_receiveTask+0x66>
     1f8:	8c 2f       	mov	r24, r28
     1fa:	0e 94 6d 09 	call	0x12da	; 0x12da <myUSART_receiveHandShakeFin>
     1fe:	88 23       	and	r24, r24
     200:	19 f0       	breq	.+6      	; 0x208 <RPI_receiveTask+0x60>
     202:	10 93 38 02 	sts	0x0238, r17
     206:	d2 cf       	rjmp	.-92     	; 0x1ac <RPI_receiveTask+0x4>
     208:	10 92 38 02 	sts	0x0238, r1
     20c:	cf cf       	rjmp	.-98     	; 0x1ac <RPI_receiveTask+0x4>
     20e:	82 30       	cpi	r24, 0x02	; 2
     210:	69 f6       	brne	.-102    	; 0x1ac <RPI_receiveTask+0x4>
     212:	0e 94 21 09 	call	0x1242	; 0x1242 <myUSART_receiveUSART1>
     216:	ca cf       	rjmp	.-108    	; 0x1ac <RPI_receiveTask+0x4>

00000218 <RPI_sendTask>:
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	00 d0       	rcall	.+0      	; 0x21e <RPI_sendTask+0x6>
     21e:	00 d0       	rcall	.+0      	; 0x220 <RPI_sendTask+0x8>
     220:	cd b7       	in	r28, 0x3d	; 61
     222:	de b7       	in	r29, 0x3e	; 62
     224:	0e 94 42 09 	call	0x1284	; 0x1284 <myUSART_startHandShake>
     228:	18 2f       	mov	r17, r24
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	4f ef       	ldi	r20, 0xFF	; 255
     22e:	5f ef       	ldi	r21, 0xFF	; 255
     230:	be 01       	movw	r22, r28
     232:	6a 5f       	subi	r22, 0xFA	; 250
     234:	7f 4f       	sbci	r23, 0xFF	; 255
     236:	80 91 93 08 	lds	r24, 0x0893
     23a:	90 91 94 08 	lds	r25, 0x0894
     23e:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xQueueGenericReceive>
     242:	11 23       	and	r17, r17
     244:	31 f1       	breq	.+76     	; 0x292 <RPI_sendTask+0x7a>
     246:	8e 81       	ldd	r24, Y+6	; 0x06
     248:	80 5d       	subi	r24, 0xD0	; 208
     24a:	be d7       	rcall	.+3964   	; 0x11c8 <myUSART_transmitUSART1_c>
     24c:	8a e0       	ldi	r24, 0x0A	; 10
     24e:	bc d7       	rcall	.+3960   	; 0x11c8 <myUSART_transmitUSART1_c>
     250:	20 c0       	rjmp	.+64     	; 0x292 <RPI_sendTask+0x7a>
     252:	20 e0       	ldi	r18, 0x00	; 0
     254:	4f ef       	ldi	r20, 0xFF	; 255
     256:	5f ef       	ldi	r21, 0xFF	; 255
     258:	be 01       	movw	r22, r28
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	7f 4f       	sbci	r23, 0xFF	; 255
     25e:	80 91 95 08 	lds	r24, 0x0895
     262:	90 91 96 08 	lds	r25, 0x0896
     266:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xQueueGenericReceive>
     26a:	89 81       	ldd	r24, Y+1	; 0x01
     26c:	8c d7       	rcall	.+3864   	; 0x1186 <myUSART_transmitUSART0_c>
     26e:	87 e0       	ldi	r24, 0x07	; 7
     270:	92 e0       	ldi	r25, 0x02	; 2
     272:	d9 d7       	rcall	.+4018   	; 0x1226 <myUSART_transmitUSART0>
     274:	ce 01       	movw	r24, r28
     276:	02 96       	adiw	r24, 0x02	; 2
     278:	d6 d7       	rcall	.+4012   	; 0x1226 <myUSART_transmitUSART0>
     27a:	8a e0       	ldi	r24, 0x0A	; 10
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	d3 d7       	rcall	.+4006   	; 0x1226 <myUSART_transmitUSART0>
     280:	11 23       	and	r17, r17
     282:	39 f0       	breq	.+14     	; 0x292 <RPI_sendTask+0x7a>
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	a0 d7       	rcall	.+3904   	; 0x11c8 <myUSART_transmitUSART1_c>
     288:	ce 01       	movw	r24, r28
     28a:	02 96       	adiw	r24, 0x02	; 2
     28c:	be d7       	rcall	.+3964   	; 0x120a <myUSART_transmitUSART1>
     28e:	8a e0       	ldi	r24, 0x0A	; 10
     290:	9b d7       	rcall	.+3894   	; 0x11c8 <myUSART_transmitUSART1_c>
     292:	9e 81       	ldd	r25, Y+6	; 0x06
     294:	2f ef       	ldi	r18, 0xFF	; 255
     296:	29 0f       	add	r18, r25
     298:	2e 83       	std	Y+6, r18	; 0x06
     29a:	91 11       	cpse	r25, r1
     29c:	da cf       	rjmp	.-76     	; 0x252 <RPI_sendTask+0x3a>
     29e:	8a e0       	ldi	r24, 0x0A	; 10
     2a0:	72 d7       	rcall	.+3812   	; 0x1186 <myUSART_transmitUSART0_c>
     2a2:	c0 cf       	rjmp	.-128    	; 0x224 <RPI_sendTask+0xc>

000002a4 <myTimerTask>:
     2a4:	7d d5       	rcall	.+2810   	; 0xda0 <myTimer_Init>
     2a6:	bc d5       	rcall	.+2936   	; 0xe20 <myTimer_DelayChecker>
     2a8:	fe cf       	rjmp	.-4      	; 0x2a6 <myTimerTask+0x2>

000002aa <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2aa:	8f ef       	ldi	r24, 0xFF	; 255
     2ac:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2b0:	ef e7       	ldi	r30, 0x7F	; 127
     2b2:	f0 e0       	ldi	r31, 0x00	; 0
     2b4:	90 81       	ld	r25, Z
     2b6:	93 60       	ori	r25, 0x03	; 3
     2b8:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2ba:	80 93 7d 00 	sts	0x007D, r24
     2be:	08 95       	ret

000002c0 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2c0:	8c ec       	ldi	r24, 0xCC	; 204
     2c2:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2c6:	8e e3       	ldi	r24, 0x3E	; 62
     2c8:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2cc:	ee cf       	rjmp	.-36     	; 0x2aa <setDigitalInputPowerReduction>
     2ce:	08 95       	ret

000002d0 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2d0:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2d4:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2d8:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2dc:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2e0:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2e4:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2e8:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2ec:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2f0:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2f4:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2f8:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2fc:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     300:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     304:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     308:	10 92 73 00 	sts	0x0073, r1
     30c:	08 95       	ret

0000030e <init>:
}

void init()
{
     30e:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     310:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     312:	f8 94       	cli
	{
		clearTimer();
     314:	dd df       	rcall	.-70     	; 0x2d0 <clearTimer>
		setPowerReduction();
     316:	d4 df       	rcall	.-88     	; 0x2c0 <setPowerReduction>
		myUSART_USART0_Init();
     318:	e2 d6       	rcall	.+3524   	; 0x10de <myUSART_USART0_Init>
		myUSART_USART1_Init();
     31a:	07 d7       	rcall	.+3598   	; 0x112a <myUSART_USART1_Init>
		myADC_Init();
     31c:	8c d3       	rcall	.+1816   	; 0xa36 <myADC_Init>
		
		MaxSonar_Init();
     31e:	83 b3       	in	r24, 0x13	; 19
     320:	83 60       	ori	r24, 0x03	; 3
     322:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     324:	cb d2       	rcall	.+1430   	; 0x8bc <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     326:	40 e0       	ldi	r20, 0x00	; 0
     328:	61 e0       	ldi	r22, 0x01	; 1
     32a:	85 e0       	ldi	r24, 0x05	; 5
     32c:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericCreate>
     330:	90 93 94 08 	sts	0x0894, r25
     334:	80 93 93 08 	sts	0x0893, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     338:	40 e0       	ldi	r20, 0x00	; 0
     33a:	65 e0       	ldi	r22, 0x05	; 5
     33c:	84 e1       	ldi	r24, 0x14	; 20
     33e:	0e 94 0a 0c 	call	0x1814	; 0x1814 <xQueueGenericCreate>
     342:	90 93 96 08 	sts	0x0896, r25
     346:	80 93 95 08 	sts	0x0895, r24
		
		MOTOR_LEFT_INIT();
     34a:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     34c:	e1 e0       	ldi	r30, 0x01	; 1
     34e:	f1 e0       	ldi	r31, 0x01	; 1
     350:	80 81       	ld	r24, Z
     352:	80 61       	ori	r24, 0x10	; 16
     354:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     356:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     358:	78 94       	sei
}
     35a:	cf 91       	pop	r28
     35c:	08 95       	ret

0000035e <main>:
	
	// do nth
}

int main(void)
{
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	cd b7       	in	r28, 0x3d	; 61
     364:	de b7       	in	r29, 0x3e	; 62
     366:	28 97       	sbiw	r28, 0x08	; 8
     368:	0f b6       	in	r0, 0x3f	; 63
     36a:	f8 94       	cli
     36c:	de bf       	out	0x3e, r29	; 62
     36e:	0f be       	out	0x3f, r0	; 63
     370:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     372:	cd df       	rcall	.-102    	; 0x30e <init>

		//xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     374:	a1 2c       	mov	r10, r1
     376:	b1 2c       	mov	r11, r1
     378:	c1 2c       	mov	r12, r1
     37a:	d1 2c       	mov	r13, r1
     37c:	ce 01       	movw	r24, r28
     37e:	01 96       	adiw	r24, 0x01	; 1
     380:	7c 01       	movw	r14, r24
     382:	04 e0       	ldi	r16, 0x04	; 4
     384:	9c 01       	movw	r18, r24
     386:	49 e6       	ldi	r20, 0x69	; 105
     388:	50 e0       	ldi	r21, 0x00	; 0
     38a:	6d e0       	ldi	r22, 0x0D	; 13
     38c:	72 e0       	ldi	r23, 0x02	; 2
     38e:	82 e5       	ldi	r24, 0x52	; 82
     390:	91 e0       	ldi	r25, 0x01	; 1
     392:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     396:	ce 01       	movw	r24, r28
     398:	07 96       	adiw	r24, 0x07	; 7
     39a:	7c 01       	movw	r14, r24
     39c:	02 e0       	ldi	r16, 0x02	; 2
     39e:	20 e0       	ldi	r18, 0x00	; 0
     3a0:	30 e0       	ldi	r19, 0x00	; 0
     3a2:	4d e6       	ldi	r20, 0x6D	; 109
     3a4:	51 e0       	ldi	r21, 0x01	; 1
     3a6:	65 e1       	ldi	r22, 0x15	; 21
     3a8:	72 e0       	ldi	r23, 0x02	; 2
     3aa:	88 e8       	ldi	r24, 0x88	; 136
     3ac:	92 e0       	ldi	r25, 0x02	; 2
     3ae:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3b2:	ce 01       	movw	r24, r28
     3b4:	05 96       	adiw	r24, 0x05	; 5
     3b6:	7c 01       	movw	r14, r24
     3b8:	03 e0       	ldi	r16, 0x03	; 3
     3ba:	20 e0       	ldi	r18, 0x00	; 0
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	47 e8       	ldi	r20, 0x87	; 135
     3c0:	50 e0       	ldi	r21, 0x00	; 0
     3c2:	6e e1       	ldi	r22, 0x1E	; 30
     3c4:	72 e0       	ldi	r23, 0x02	; 2
     3c6:	84 ed       	ldi	r24, 0xD4	; 212
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3ce:	ce 01       	movw	r24, r28
     3d0:	03 96       	adiw	r24, 0x03	; 3
     3d2:	7c 01       	movw	r14, r24
     3d4:	01 e0       	ldi	r16, 0x01	; 1
     3d6:	20 e0       	ldi	r18, 0x00	; 0
     3d8:	30 e0       	ldi	r19, 0x00	; 0
     3da:	47 e8       	ldi	r20, 0x87	; 135
     3dc:	50 e0       	ldi	r21, 0x00	; 0
     3de:	6a e2       	ldi	r22, 0x2A	; 42
     3e0:	72 e0       	ldi	r23, 0x02	; 2
     3e2:	8c e0       	ldi	r24, 0x0C	; 12
     3e4:	91 e0       	ldi	r25, 0x01	; 1
     3e6:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ea:	0e 94 e1 0f 	call	0x1fc2	; 0x1fc2 <vTaskStartScheduler>
     3ee:	c1 cf       	rjmp	.-126    	; 0x372 <main+0x14>

000003f0 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3f0:	9c 01       	movw	r18, r24
     3f2:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3f4:	64 e6       	ldi	r22, 0x64	; 100
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
	
	if(input)
     3fc:	61 15       	cp	r22, r1
     3fe:	71 05       	cpc	r23, r1
     400:	21 f0       	breq	.+8      	; 0x40a <myItoa+0x1a>
		*buffer++ = input + '0';
     402:	80 e3       	ldi	r24, 0x30	; 48
     404:	86 0f       	add	r24, r22
     406:	80 83       	st	Z, r24
     408:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     40a:	4c e9       	ldi	r20, 0x9C	; 156
     40c:	46 03       	mulsu	r20, r22
     40e:	c0 01       	movw	r24, r0
     410:	47 9f       	mul	r20, r23
     412:	90 0d       	add	r25, r0
     414:	11 24       	eor	r1, r1
     416:	28 0f       	add	r18, r24
     418:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     41a:	c9 01       	movw	r24, r18
     41c:	6a e0       	ldi	r22, 0x0A	; 10
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
	*buffer++ = input + '0';
     424:	80 e3       	ldi	r24, 0x30	; 48
     426:	86 0f       	add	r24, r22
     428:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     42a:	8a e0       	ldi	r24, 0x0A	; 10
     42c:	68 9f       	mul	r22, r24
     42e:	20 19       	sub	r18, r0
     430:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     432:	20 5d       	subi	r18, 0xD0	; 208
     434:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     436:	12 82       	std	Z+2, r1	; 0x02
     438:	08 95       	ret

0000043a <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     43a:	1f 93       	push	r17
     43c:	cf 93       	push	r28
     43e:	df 93       	push	r29
     440:	00 d0       	rcall	.+0      	; 0x442 <obstacleSend+0x8>
     442:	1f 92       	push	r1
     444:	1f 92       	push	r1
     446:	cd b7       	in	r28, 0x3d	; 61
     448:	de b7       	in	r29, 0x3e	; 62
     44a:	18 2f       	mov	r17, r24
     44c:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     44e:	11 23       	and	r17, r17
     450:	89 f0       	breq	.+34     	; 0x474 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     452:	be 01       	movw	r22, r28
     454:	6e 5f       	subi	r22, 0xFE	; 254
     456:	7f 4f       	sbci	r23, 0xFF	; 255
     458:	cb df       	rcall	.-106    	; 0x3f0 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     45a:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     45c:	20 e0       	ldi	r18, 0x00	; 0
     45e:	4f ef       	ldi	r20, 0xFF	; 255
     460:	5f ef       	ldi	r21, 0xFF	; 255
     462:	be 01       	movw	r22, r28
     464:	6f 5f       	subi	r22, 0xFF	; 255
     466:	7f 4f       	sbci	r23, 0xFF	; 255
     468:	80 91 95 08 	lds	r24, 0x0895
     46c:	90 91 96 08 	lds	r25, 0x0896
     470:	0e 94 37 0c 	call	0x186e	; 0x186e <xQueueGenericSend>
	}
}
     474:	0f 90       	pop	r0
     476:	0f 90       	pop	r0
     478:	0f 90       	pop	r0
     47a:	0f 90       	pop	r0
     47c:	0f 90       	pop	r0
     47e:	df 91       	pop	r29
     480:	cf 91       	pop	r28
     482:	1f 91       	pop	r17
     484:	08 95       	ret

00000486 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     486:	6f 92       	push	r6
     488:	7f 92       	push	r7
     48a:	8f 92       	push	r8
     48c:	9f 92       	push	r9
     48e:	af 92       	push	r10
     490:	bf 92       	push	r11
     492:	cf 92       	push	r12
     494:	df 92       	push	r13
     496:	ef 92       	push	r14
     498:	ff 92       	push	r15
     49a:	0f 93       	push	r16
     49c:	1f 93       	push	r17
     49e:	cf 93       	push	r28
     4a0:	df 93       	push	r29
     4a2:	1f 92       	push	r1
     4a4:	cd b7       	in	r28, 0x3d	; 61
     4a6:	de b7       	in	r29, 0x3e	; 62
     4a8:	89 83       	std	Y+1, r24	; 0x01
     4aa:	5b 01       	movw	r10, r22
     4ac:	3a 01       	movw	r6, r20
     4ae:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4b0:	20 e0       	ldi	r18, 0x00	; 0
     4b2:	4f ef       	ldi	r20, 0xFF	; 255
     4b4:	5f ef       	ldi	r21, 0xFF	; 255
     4b6:	be 01       	movw	r22, r28
     4b8:	6f 5f       	subi	r22, 0xFF	; 255
     4ba:	7f 4f       	sbci	r23, 0xFF	; 255
     4bc:	80 91 93 08 	lds	r24, 0x0893
     4c0:	90 91 94 08 	lds	r25, 0x0894
     4c4:	0e 94 37 0c 	call	0x186e	; 0x186e <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4c8:	b3 01       	movw	r22, r6
     4ca:	f5 01       	movw	r30, r10
     4cc:	80 81       	ld	r24, Z
     4ce:	b5 df       	rcall	.-150    	; 0x43a <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4d0:	b4 01       	movw	r22, r8
     4d2:	f5 01       	movw	r30, r10
     4d4:	81 81       	ldd	r24, Z+1	; 0x01
     4d6:	b1 df       	rcall	.-158    	; 0x43a <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4d8:	b8 01       	movw	r22, r16
     4da:	f5 01       	movw	r30, r10
     4dc:	82 81       	ldd	r24, Z+2	; 0x02
     4de:	ad df       	rcall	.-166    	; 0x43a <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4e0:	b7 01       	movw	r22, r14
     4e2:	f5 01       	movw	r30, r10
     4e4:	83 81       	ldd	r24, Z+3	; 0x03
     4e6:	a9 df       	rcall	.-174    	; 0x43a <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4e8:	b6 01       	movw	r22, r12
     4ea:	f5 01       	movw	r30, r10
     4ec:	84 81       	ldd	r24, Z+4	; 0x04
     4ee:	a5 df       	rcall	.-182    	; 0x43a <obstacleSend>
		
	}
}
     4f0:	0f 90       	pop	r0
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	ff 90       	pop	r15
     4fc:	ef 90       	pop	r14
     4fe:	df 90       	pop	r13
     500:	cf 90       	pop	r12
     502:	bf 90       	pop	r11
     504:	af 90       	pop	r10
     506:	9f 90       	pop	r9
     508:	8f 90       	pop	r8
     50a:	7f 90       	pop	r7
     50c:	6f 90       	pop	r6
     50e:	08 95       	ret

00000510 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     510:	cf 93       	push	r28
     512:	df 93       	push	r29
     514:	cd b7       	in	r28, 0x3d	; 61
     516:	de b7       	in	r29, 0x3e	; 62
     518:	a4 97       	sbiw	r28, 0x24	; 36
     51a:	0f b6       	in	r0, 0x3f	; 63
     51c:	f8 94       	cli
     51e:	de bf       	out	0x3e, r29	; 62
     520:	0f be       	out	0x3f, r0	; 63
     522:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     524:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     526:	86 e0       	ldi	r24, 0x06	; 6
     528:	fe 01       	movw	r30, r28
     52a:	34 96       	adiw	r30, 0x04	; 4
     52c:	df 01       	movw	r26, r30
     52e:	98 2f       	mov	r25, r24
     530:	1d 92       	st	X+, r1
     532:	9a 95       	dec	r25
     534:	e9 f7       	brne	.-6      	; 0x530 <Sonar_Task+0x20>
     536:	36 96       	adiw	r30, 0x06	; 6
     538:	df 01       	movw	r26, r30
     53a:	98 2f       	mov	r25, r24
     53c:	1d 92       	st	X+, r1
     53e:	9a 95       	dec	r25
     540:	e9 f7       	brne	.-6      	; 0x53c <Sonar_Task+0x2c>
     542:	36 96       	adiw	r30, 0x06	; 6
     544:	df 01       	movw	r26, r30
     546:	98 2f       	mov	r25, r24
     548:	1d 92       	st	X+, r1
     54a:	9a 95       	dec	r25
     54c:	e9 f7       	brne	.-6      	; 0x548 <Sonar_Task+0x38>
     54e:	36 96       	adiw	r30, 0x06	; 6
     550:	df 01       	movw	r26, r30
     552:	1d 92       	st	X+, r1
     554:	8a 95       	dec	r24
     556:	e9 f7       	brne	.-6      	; 0x552 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     558:	36 96       	adiw	r30, 0x06	; 6
     55a:	85 e0       	ldi	r24, 0x05	; 5
     55c:	df 01       	movw	r26, r30
     55e:	1d 92       	st	X+, r1
     560:	8a 95       	dec	r24
     562:	e9 f7       	brne	.-6      	; 0x55e <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     564:	84 e2       	ldi	r24, 0x24	; 36
     566:	8e d3       	rcall	.+1820   	; 0xc84 <mySharpIR_Read>
     568:	9a a3       	std	Y+34, r25	; 0x22
     56a:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     56c:	0e 94 10 10 	call	0x2020	; 0x2020 <xTaskGetTickCount>
     570:	9a 83       	std	Y+2, r25	; 0x02
     572:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     574:	be d1       	rcall	.+892    	; 0x8f2 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     576:	83 e2       	ldi	r24, 0x23	; 35
     578:	1c d2       	rcall	.+1080   	; 0x9b2 <myMaxSonar_Read>
     57a:	be 01       	movw	r22, r28
     57c:	6c 5f       	subi	r22, 0xFC	; 252
     57e:	7f 4f       	sbci	r23, 0xFF	; 255
     580:	0f d2       	rcall	.+1054   	; 0x9a0 <myMaxSonar_getFilteredReading>
     582:	9c a3       	std	Y+36, r25	; 0x24
     584:	8b a3       	std	Y+35, r24	; 0x23
		
		myMaxSonar_BtmStart();
     586:	af d1       	rcall	.+862    	; 0x8e6 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     588:	87 e2       	ldi	r24, 0x27	; 39
     58a:	13 d2       	rcall	.+1062   	; 0x9b2 <myMaxSonar_Read>
     58c:	be 01       	movw	r22, r28
     58e:	66 5f       	subi	r22, 0xF6	; 246
     590:	7f 4f       	sbci	r23, 0xFF	; 255
     592:	06 d2       	rcall	.+1036   	; 0x9a0 <myMaxSonar_getFilteredReading>
     594:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     596:	86 e2       	ldi	r24, 0x26	; 38
     598:	0c d2       	rcall	.+1048   	; 0x9b2 <myMaxSonar_Read>
     59a:	be 01       	movw	r22, r28
     59c:	60 5f       	subi	r22, 0xF0	; 240
     59e:	7f 4f       	sbci	r23, 0xFF	; 255
     5a0:	ff d1       	rcall	.+1022   	; 0x9a0 <myMaxSonar_getFilteredReading>
     5a2:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 
     5a4:	85 e2       	ldi	r24, 0x25	; 37
     5a6:	05 d2       	rcall	.+1034   	; 0x9b2 <myMaxSonar_Read>
     5a8:	be 01       	movw	r22, r28
     5aa:	6a 5e       	subi	r22, 0xEA	; 234
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	f8 d1       	rcall	.+1008   	; 0x9a0 <myMaxSonar_getFilteredReading>
     5b0:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     5b2:	84 e2       	ldi	r24, 0x24	; 36
     5b4:	67 d3       	rcall	.+1742   	; 0xc84 <mySharpIR_Read>
     5b6:	4c 01       	movw	r8, r24
		//frontSonar = myMaxSonar_Stabilizer(frontSonar, &prevFrontSonar);
		//leftSonar = myMaxSonar_Stabilizer(leftSonar, &prevLeftSonar);
		//rightSonar = myMaxSonar_Stabilizer(rightSonar, &prevRightSonar);
		
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5b8:	bc 01       	movw	r22, r24
     5ba:	ce 01       	movw	r24, r28
     5bc:	81 96       	adiw	r24, 0x21	; 33
     5be:	9b d3       	rcall	.+1846   	; 0xcf6 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5c0:	c9 a0       	ldd	r12, Y+33	; 0x21
     5c2:	da a0       	ldd	r13, Y+34	; 0x22
     5c4:	54 01       	movw	r10, r8
     5c6:	eb a0       	ldd	r14, Y+35	; 0x23
     5c8:	fc a0       	ldd	r15, Y+36	; 0x24
     5ca:	82 01       	movw	r16, r4
     5cc:	91 01       	movw	r18, r2
     5ce:	ae 01       	movw	r20, r28
     5d0:	44 5e       	subi	r20, 0xE4	; 228
     5d2:	5f 4f       	sbci	r21, 0xFF	; 255
     5d4:	6b 81       	ldd	r22, Y+3	; 0x03
     5d6:	c3 01       	movw	r24, r6
     5d8:	25 d3       	rcall	.+1610   	; 0xc24 <obstacleDetection>
     5da:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5dc:	8e 01       	movw	r16, r28
     5de:	04 5e       	subi	r16, 0xE4	; 228
     5e0:	1f 4f       	sbci	r17, 0xFF	; 255
     5e2:	94 01       	movw	r18, r8
     5e4:	a2 01       	movw	r20, r4
     5e6:	b1 01       	movw	r22, r2
     5e8:	c3 01       	movw	r24, r6
     5ea:	a6 d2       	rcall	.+1356   	; 0xb38 <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5ec:	be 01       	movw	r22, r28
     5ee:	6d 5f       	subi	r22, 0xFD	; 253
     5f0:	7f 4f       	sbci	r23, 0xFF	; 255
     5f2:	c8 01       	movw	r24, r16
     5f4:	08 d3       	rcall	.+1552   	; 0xc06 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5f6:	cb a0       	ldd	r12, Y+35	; 0x23
     5f8:	dc a0       	ldd	r13, Y+36	; 0x24
     5fa:	74 01       	movw	r14, r8
     5fc:	82 01       	movw	r16, r4
     5fe:	91 01       	movw	r18, r2
     600:	a3 01       	movw	r20, r6
     602:	be 01       	movw	r22, r28
     604:	64 5e       	subi	r22, 0xE4	; 228
     606:	7f 4f       	sbci	r23, 0xFF	; 255
     608:	8b 81       	ldd	r24, Y+3	; 0x03
     60a:	3d df       	rcall	.-390    	; 0x486 <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     60c:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     60e:	18 a2       	std	Y+32, r1	; 0x20
     610:	1f 8e       	std	Y+31, r1	; 0x1f
     612:	1e 8e       	std	Y+30, r1	; 0x1e
     614:	1d 8e       	std	Y+29, r1	; 0x1d
     616:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     618:	66 e9       	ldi	r22, 0x96	; 150
     61a:	70 e0       	ldi	r23, 0x00	; 0
     61c:	ce 01       	movw	r24, r28
     61e:	01 96       	adiw	r24, 0x01	; 1
     620:	0e 94 5e 11 	call	0x22bc	; 0x22bc <vTaskDelayUntil>
     624:	a7 cf       	rjmp	.-178    	; 0x574 <Sonar_Task+0x64>

00000626 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     62c:	0e 94 0a 10 	call	0x2014	; 0x2014 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     630:	80 91 39 02 	lds	r24, 0x0239
     634:	90 91 3a 02 	lds	r25, 0x023A
     638:	89 2b       	or	r24, r25
     63a:	31 f4       	brne	.+12     	; 0x648 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     63c:	8e e3       	ldi	r24, 0x3E	; 62
     63e:	92 e0       	ldi	r25, 0x02	; 2
     640:	90 93 3a 02 	sts	0x023A, r25
     644:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     648:	40 91 3b 02 	lds	r20, 0x023B
     64c:	50 91 3c 02 	lds	r21, 0x023C
     650:	9e 01       	movw	r18, r28
     652:	24 0f       	add	r18, r20
     654:	35 1f       	adc	r19, r21
     656:	2b 3d       	cpi	r18, 0xDB	; 219
     658:	85 e0       	ldi	r24, 0x05	; 5
     65a:	38 07       	cpc	r19, r24
     65c:	70 f4       	brcc	.+28     	; 0x67a <pvPortMalloc+0x54>
     65e:	42 17       	cp	r20, r18
     660:	53 07       	cpc	r21, r19
     662:	70 f4       	brcc	.+28     	; 0x680 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     664:	c0 91 39 02 	lds	r28, 0x0239
     668:	d0 91 3a 02 	lds	r29, 0x023A
     66c:	c4 0f       	add	r28, r20
     66e:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     670:	30 93 3c 02 	sts	0x023C, r19
     674:	20 93 3b 02 	sts	0x023B, r18
     678:	05 c0       	rjmp	.+10     	; 0x684 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     67a:	c0 e0       	ldi	r28, 0x00	; 0
     67c:	d0 e0       	ldi	r29, 0x00	; 0
     67e:	02 c0       	rjmp	.+4      	; 0x684 <pvPortMalloc+0x5e>
     680:	c0 e0       	ldi	r28, 0x00	; 0
     682:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     684:	0e 94 dd 10 	call	0x21ba	; 0x21ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     688:	ce 01       	movw	r24, r28
     68a:	df 91       	pop	r29
     68c:	cf 91       	pop	r28
     68e:	08 95       	ret

00000690 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     690:	08 95       	ret

00000692 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     692:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     694:	03 96       	adiw	r24, 0x03	; 3
     696:	92 83       	std	Z+2, r25	; 0x02
     698:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     69a:	2f ef       	ldi	r18, 0xFF	; 255
     69c:	3f ef       	ldi	r19, 0xFF	; 255
     69e:	34 83       	std	Z+4, r19	; 0x04
     6a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a2:	96 83       	std	Z+6, r25	; 0x06
     6a4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6a6:	90 87       	std	Z+8, r25	; 0x08
     6a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6aa:	10 82       	st	Z, r1
     6ac:	08 95       	ret

000006ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6ae:	fc 01       	movw	r30, r24
     6b0:	11 86       	std	Z+9, r1	; 0x09
     6b2:	10 86       	std	Z+8, r1	; 0x08
     6b4:	08 95       	ret

000006b6 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
     6ba:	9c 01       	movw	r18, r24
     6bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6be:	dc 01       	movw	r26, r24
     6c0:	11 96       	adiw	r26, 0x01	; 1
     6c2:	cd 91       	ld	r28, X+
     6c4:	dc 91       	ld	r29, X
     6c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6c8:	d3 83       	std	Z+3, r29	; 0x03
     6ca:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6cc:	8c 81       	ldd	r24, Y+4	; 0x04
     6ce:	9d 81       	ldd	r25, Y+5	; 0x05
     6d0:	95 83       	std	Z+5, r25	; 0x05
     6d2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6d4:	8c 81       	ldd	r24, Y+4	; 0x04
     6d6:	9d 81       	ldd	r25, Y+5	; 0x05
     6d8:	dc 01       	movw	r26, r24
     6da:	13 96       	adiw	r26, 0x03	; 3
     6dc:	7c 93       	st	X, r23
     6de:	6e 93       	st	-X, r22
     6e0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6e2:	7d 83       	std	Y+5, r23	; 0x05
     6e4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6e6:	31 87       	std	Z+9, r19	; 0x09
     6e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6ea:	f9 01       	movw	r30, r18
     6ec:	80 81       	ld	r24, Z
     6ee:	8f 5f       	subi	r24, 0xFF	; 255
     6f0:	80 83       	st	Z, r24
}
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	08 95       	ret

000006f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6fe:	48 81       	ld	r20, Y
     700:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     702:	4f 3f       	cpi	r20, 0xFF	; 255
     704:	2f ef       	ldi	r18, 0xFF	; 255
     706:	52 07       	cpc	r21, r18
     708:	21 f4       	brne	.+8      	; 0x712 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     70a:	fc 01       	movw	r30, r24
     70c:	a7 81       	ldd	r26, Z+7	; 0x07
     70e:	b0 85       	ldd	r27, Z+8	; 0x08
     710:	0d c0       	rjmp	.+26     	; 0x72c <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     712:	dc 01       	movw	r26, r24
     714:	13 96       	adiw	r26, 0x03	; 3
     716:	12 96       	adiw	r26, 0x02	; 2
     718:	ed 91       	ld	r30, X+
     71a:	fc 91       	ld	r31, X
     71c:	13 97       	sbiw	r26, 0x03	; 3
     71e:	20 81       	ld	r18, Z
     720:	31 81       	ldd	r19, Z+1	; 0x01
     722:	42 17       	cp	r20, r18
     724:	53 07       	cpc	r21, r19
     726:	10 f0       	brcs	.+4      	; 0x72c <vListInsert+0x34>
     728:	df 01       	movw	r26, r30
     72a:	f5 cf       	rjmp	.-22     	; 0x716 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     72c:	12 96       	adiw	r26, 0x02	; 2
     72e:	ed 91       	ld	r30, X+
     730:	fc 91       	ld	r31, X
     732:	13 97       	sbiw	r26, 0x03	; 3
     734:	fb 83       	std	Y+3, r31	; 0x03
     736:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     738:	d5 83       	std	Z+5, r29	; 0x05
     73a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     73c:	bd 83       	std	Y+5, r27	; 0x05
     73e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     740:	13 96       	adiw	r26, 0x03	; 3
     742:	dc 93       	st	X, r29
     744:	ce 93       	st	-X, r28
     746:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     748:	99 87       	std	Y+9, r25	; 0x09
     74a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     74c:	fc 01       	movw	r30, r24
     74e:	20 81       	ld	r18, Z
     750:	2f 5f       	subi	r18, 0xFF	; 255
     752:	20 83       	st	Z, r18
}
     754:	df 91       	pop	r29
     756:	cf 91       	pop	r28
     758:	08 95       	ret

0000075a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     760:	a0 85       	ldd	r26, Z+8	; 0x08
     762:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     764:	c2 81       	ldd	r28, Z+2	; 0x02
     766:	d3 81       	ldd	r29, Z+3	; 0x03
     768:	84 81       	ldd	r24, Z+4	; 0x04
     76a:	95 81       	ldd	r25, Z+5	; 0x05
     76c:	9d 83       	std	Y+5, r25	; 0x05
     76e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     770:	c4 81       	ldd	r28, Z+4	; 0x04
     772:	d5 81       	ldd	r29, Z+5	; 0x05
     774:	82 81       	ldd	r24, Z+2	; 0x02
     776:	93 81       	ldd	r25, Z+3	; 0x03
     778:	9b 83       	std	Y+3, r25	; 0x03
     77a:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     77c:	11 96       	adiw	r26, 0x01	; 1
     77e:	cd 91       	ld	r28, X+
     780:	dc 91       	ld	r29, X
     782:	12 97       	sbiw	r26, 0x02	; 2
     784:	ce 17       	cp	r28, r30
     786:	df 07       	cpc	r29, r31
     788:	31 f4       	brne	.+12     	; 0x796 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     78a:	8c 81       	ldd	r24, Y+4	; 0x04
     78c:	9d 81       	ldd	r25, Y+5	; 0x05
     78e:	12 96       	adiw	r26, 0x02	; 2
     790:	9c 93       	st	X, r25
     792:	8e 93       	st	-X, r24
     794:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     796:	11 86       	std	Z+9, r1	; 0x09
     798:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     79a:	8c 91       	ld	r24, X
     79c:	81 50       	subi	r24, 0x01	; 1
     79e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7a0:	df 91       	pop	r29
     7a2:	cf 91       	pop	r28
     7a4:	08 95       	ret

000007a6 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7a6:	1f 92       	push	r1
     7a8:	0f 92       	push	r0
     7aa:	0f b6       	in	r0, 0x3f	; 63
     7ac:	0f 92       	push	r0
     7ae:	11 24       	eor	r1, r1
     7b0:	0b b6       	in	r0, 0x3b	; 59
     7b2:	0f 92       	push	r0
     7b4:	2f 93       	push	r18
     7b6:	3f 93       	push	r19
     7b8:	4f 93       	push	r20
     7ba:	5f 93       	push	r21
     7bc:	6f 93       	push	r22
     7be:	7f 93       	push	r23
     7c0:	8f 93       	push	r24
     7c2:	9f 93       	push	r25
     7c4:	af 93       	push	r26
     7c6:	bf 93       	push	r27
     7c8:	ef 93       	push	r30
     7ca:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7cc:	1b 9b       	sbis	0x03, 3	; 3
     7ce:	0d c0       	rjmp	.+26     	; 0x7ea <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7d0:	01 d3       	rcall	.+1538   	; 0xdd4 <myTimer_Read>
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	90 93 9c 08 	sts	0x089C, r25
     7d8:	80 93 9b 08 	sts	0x089B, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7dc:	0e 94 1a 10 	call	0x2034	; 0x2034 <xTaskGetTickCountFromISR>
     7e0:	90 93 98 08 	sts	0x0898, r25
     7e4:	80 93 97 08 	sts	0x0897, r24
     7e8:	56 c0       	rjmp	.+172    	; 0x896 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7ea:	1b 99       	sbic	0x03, 3	; 3
     7ec:	54 c0       	rjmp	.+168    	; 0x896 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7ee:	0e 94 1a 10 	call	0x2034	; 0x2034 <xTaskGetTickCountFromISR>
     7f2:	90 93 a2 08 	sts	0x08A2, r25
     7f6:	80 93 a1 08 	sts	0x08A1, r24
     7fa:	20 91 97 08 	lds	r18, 0x0897
     7fe:	30 91 98 08 	lds	r19, 0x0898
     802:	82 17       	cp	r24, r18
     804:	93 07       	cpc	r25, r19
     806:	4c f4       	brge	.+18     	; 0x81a <__vector_9+0x74>
			ms_tickEnd += 65535;
     808:	80 91 a1 08 	lds	r24, 0x08A1
     80c:	90 91 a2 08 	lds	r25, 0x08A2
     810:	01 97       	sbiw	r24, 0x01	; 1
     812:	90 93 a2 08 	sts	0x08A2, r25
     816:	80 93 a1 08 	sts	0x08A1, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     81a:	dc d2       	rcall	.+1464   	; 0xdd4 <myTimer_Read>
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	90 93 a4 08 	sts	0x08A4, r25
     822:	80 93 a3 08 	sts	0x08A3, r24
     826:	20 91 9b 08 	lds	r18, 0x089B
     82a:	30 91 9c 08 	lds	r19, 0x089C
     82e:	82 17       	cp	r24, r18
     830:	93 07       	cpc	r25, r19
     832:	54 f4       	brge	.+20     	; 0x848 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     834:	80 91 a3 08 	lds	r24, 0x08A3
     838:	90 91 a4 08 	lds	r25, 0x08A4
     83c:	86 50       	subi	r24, 0x06	; 6
     83e:	9f 4f       	sbci	r25, 0xFF	; 255
     840:	90 93 a4 08 	sts	0x08A4, r25
     844:	80 93 a3 08 	sts	0x08A3, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     848:	80 91 a3 08 	lds	r24, 0x08A3
     84c:	90 91 a4 08 	lds	r25, 0x08A4
     850:	20 91 9b 08 	lds	r18, 0x089B
     854:	30 91 9c 08 	lds	r19, 0x089C
     858:	82 1b       	sub	r24, r18
     85a:	93 0b       	sbc	r25, r19
     85c:	90 93 9e 08 	sts	0x089E, r25
     860:	80 93 9d 08 	sts	0x089D, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     864:	80 91 a1 08 	lds	r24, 0x08A1
     868:	90 91 a2 08 	lds	r25, 0x08A2
     86c:	20 91 97 08 	lds	r18, 0x0897
     870:	30 91 98 08 	lds	r19, 0x0898
     874:	82 1b       	sub	r24, r18
     876:	93 0b       	sbc	r25, r19
     878:	90 93 9a 08 	sts	0x089A, r25
     87c:	80 93 99 08 	sts	0x0899, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     880:	20 e0       	ldi	r18, 0x00	; 0
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	80 91 9f 08 	lds	r24, 0x089F
     88e:	90 91 a0 08 	lds	r25, 0x08A0
     892:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <xQueueGenericSendFromISR>
	}	
}
     896:	ff 91       	pop	r31
     898:	ef 91       	pop	r30
     89a:	bf 91       	pop	r27
     89c:	af 91       	pop	r26
     89e:	9f 91       	pop	r25
     8a0:	8f 91       	pop	r24
     8a2:	7f 91       	pop	r23
     8a4:	6f 91       	pop	r22
     8a6:	5f 91       	pop	r21
     8a8:	4f 91       	pop	r20
     8aa:	3f 91       	pop	r19
     8ac:	2f 91       	pop	r18
     8ae:	0f 90       	pop	r0
     8b0:	0b be       	out	0x3b, r0	; 59
     8b2:	0f 90       	pop	r0
     8b4:	0f be       	out	0x3f, r0	; 63
     8b6:	0f 90       	pop	r0
     8b8:	1f 90       	pop	r1
     8ba:	18 95       	reti

000008bc <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     8bc:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     8be:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     8c0:	e8 e6       	ldi	r30, 0x68	; 104
     8c2:	f0 e0       	ldi	r31, 0x00	; 0
     8c4:	80 81       	ld	r24, Z
     8c6:	81 60       	ori	r24, 0x01	; 1
     8c8:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     8ca:	eb e6       	ldi	r30, 0x6B	; 107
     8cc:	f0 e0       	ldi	r31, 0x00	; 0
     8ce:	80 81       	ld	r24, Z
     8d0:	88 60       	ori	r24, 0x08	; 8
     8d2:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     8d4:	43 e0       	ldi	r20, 0x03	; 3
     8d6:	60 e0       	ldi	r22, 0x00	; 0
     8d8:	81 e0       	ldi	r24, 0x01	; 1
     8da:	9c d7       	rcall	.+3896   	; 0x1814 <xQueueGenericCreate>
     8dc:	90 93 a0 08 	sts	0x08A0, r25
     8e0:	80 93 9f 08 	sts	0x089F, r24
     8e4:	08 95       	ret

000008e6 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8e6:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8e8:	89 e1       	ldi	r24, 0x19	; 25
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	75 d2       	rcall	.+1258   	; 0xdd8 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8ee:	a1 98       	cbi	0x14, 1	; 20
     8f0:	08 95       	ret

000008f2 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8f2:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8f4:	89 e1       	ldi	r24, 0x19	; 25
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	6f d2       	rcall	.+1246   	; 0xdd8 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8fa:	a0 98       	cbi	0x14, 0	; 20
     8fc:	08 95       	ret

000008fe <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8fe:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     900:	80 81       	ld	r24, Z
     902:	91 81       	ldd	r25, Z+1	; 0x01
     904:	22 81       	ldd	r18, Z+2	; 0x02
     906:	33 81       	ldd	r19, Z+3	; 0x03
     908:	28 17       	cp	r18, r24
     90a:	39 07       	cpc	r19, r25
     90c:	54 f4       	brge	.+20     	; 0x922 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     90e:	44 81       	ldd	r20, Z+4	; 0x04
     910:	55 81       	ldd	r21, Z+5	; 0x05
     912:	42 17       	cp	r20, r18
     914:	53 07       	cpc	r21, r19
     916:	84 f0       	brlt	.+32     	; 0x938 <myMaxSonar_extractMedian+0x3a>
     918:	48 17       	cp	r20, r24
     91a:	59 07       	cpc	r21, r25
     91c:	74 f4       	brge	.+28     	; 0x93a <myMaxSonar_extractMedian+0x3c>
     91e:	ca 01       	movw	r24, r20
     920:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     922:	44 81       	ldd	r20, Z+4	; 0x04
     924:	55 81       	ldd	r21, Z+5	; 0x05
     926:	48 17       	cp	r20, r24
     928:	59 07       	cpc	r21, r25
     92a:	3c f0       	brlt	.+14     	; 0x93a <myMaxSonar_extractMedian+0x3c>
     92c:	ca 01       	movw	r24, r20
     92e:	24 17       	cp	r18, r20
     930:	35 07       	cpc	r19, r21
     932:	1c f4       	brge	.+6      	; 0x93a <myMaxSonar_extractMedian+0x3c>
     934:	c9 01       	movw	r24, r18
     936:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     938:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     93a:	08 95       	ret

0000093c <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_RANGE) || currentReading < (prevReading - NOISE_RANGE))
     93c:	9b 01       	movw	r18, r22
     93e:	28 5f       	subi	r18, 0xF8	; 248
     940:	3f 4f       	sbci	r19, 0xFF	; 255
     942:	28 17       	cp	r18, r24
     944:	39 07       	cpc	r19, r25
     946:	3c f0       	brlt	.+14     	; 0x956 <myMaxSonar_Stabilizer+0x1a>
     948:	20 51       	subi	r18, 0x10	; 16
     94a:	31 09       	sbc	r19, r1
     94c:	82 17       	cp	r24, r18
     94e:	93 07       	cpc	r25, r19
     950:	14 f0       	brlt	.+4      	; 0x956 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     952:	86 2f       	mov	r24, r22
     954:	97 2f       	mov	r25, r23
}
     956:	08 95       	ret

00000958 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	cf 93       	push	r28
     95e:	df 93       	push	r29
     960:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     962:	00 91 00 02 	lds	r16, 0x0200
     966:	10 e0       	ldi	r17, 0x00	; 0
     968:	f8 01       	movw	r30, r16
     96a:	ee 0f       	add	r30, r30
     96c:	ff 1f       	adc	r31, r31
     96e:	e6 0f       	add	r30, r22
     970:	f7 1f       	adc	r31, r23
     972:	60 81       	ld	r22, Z
     974:	71 81       	ldd	r23, Z+1	; 0x01
     976:	e2 df       	rcall	.-60     	; 0x93c <myMaxSonar_Stabilizer>
     978:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     97a:	c8 01       	movw	r24, r16
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	63 e0       	ldi	r22, 0x03	; 3
     980:	70 e0       	ldi	r23, 0x00	; 0
     982:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
     986:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     98a:	88 0f       	add	r24, r24
     98c:	99 1f       	adc	r25, r25
     98e:	c8 0f       	add	r28, r24
     990:	d9 1f       	adc	r29, r25
     992:	39 83       	std	Y+1, r19	; 0x01
     994:	28 83       	st	Y, r18
}
     996:	df 91       	pop	r29
     998:	cf 91       	pop	r28
     99a:	1f 91       	pop	r17
     99c:	0f 91       	pop	r16
     99e:	08 95       	ret

000009a0 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     9a6:	d8 df       	rcall	.-80     	; 0x958 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     9a8:	ce 01       	movw	r24, r28
     9aa:	a9 df       	rcall	.-174    	; 0x8fe <myMaxSonar_extractMedian>

}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     9b2:	ab d0       	rcall	.+342    	; 0xb0a <myADC_analogRead>
     9b4:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     9b6:	63 e0       	ldi	r22, 0x03	; 3
     9b8:	70 e0       	ldi	r23, 0x00	; 0
     9ba:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     9be:	cb 01       	movw	r24, r22
     9c0:	82 0f       	add	r24, r18
     9c2:	93 1f       	adc	r25, r19
     9c4:	08 95       	ret

000009c6 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9c6:	1f 92       	push	r1
     9c8:	0f 92       	push	r0
     9ca:	0f b6       	in	r0, 0x3f	; 63
     9cc:	0f 92       	push	r0
     9ce:	11 24       	eor	r1, r1
     9d0:	0b b6       	in	r0, 0x3b	; 59
     9d2:	0f 92       	push	r0
     9d4:	2f 93       	push	r18
     9d6:	3f 93       	push	r19
     9d8:	4f 93       	push	r20
     9da:	5f 93       	push	r21
     9dc:	6f 93       	push	r22
     9de:	7f 93       	push	r23
     9e0:	8f 93       	push	r24
     9e2:	9f 93       	push	r25
     9e4:	af 93       	push	r26
     9e6:	bf 93       	push	r27
     9e8:	ef 93       	push	r30
     9ea:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9ec:	80 91 78 00 	lds	r24, 0x0078
     9f0:	80 93 a5 08 	sts	0x08A5, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9f4:	80 91 79 00 	lds	r24, 0x0079
     9f8:	80 93 a6 08 	sts	0x08A6, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9fc:	20 e0       	ldi	r18, 0x00	; 0
     9fe:	40 e0       	ldi	r20, 0x00	; 0
     a00:	50 e0       	ldi	r21, 0x00	; 0
     a02:	60 e0       	ldi	r22, 0x00	; 0
     a04:	70 e0       	ldi	r23, 0x00	; 0
     a06:	80 91 a9 08 	lds	r24, 0x08A9
     a0a:	90 91 aa 08 	lds	r25, 0x08AA
     a0e:	ed d7       	rcall	.+4058   	; 0x19ea <xQueueGenericSendFromISR>
}
     a10:	ff 91       	pop	r31
     a12:	ef 91       	pop	r30
     a14:	bf 91       	pop	r27
     a16:	af 91       	pop	r26
     a18:	9f 91       	pop	r25
     a1a:	8f 91       	pop	r24
     a1c:	7f 91       	pop	r23
     a1e:	6f 91       	pop	r22
     a20:	5f 91       	pop	r21
     a22:	4f 91       	pop	r20
     a24:	3f 91       	pop	r19
     a26:	2f 91       	pop	r18
     a28:	0f 90       	pop	r0
     a2a:	0b be       	out	0x3b, r0	; 59
     a2c:	0f 90       	pop	r0
     a2e:	0f be       	out	0x3f, r0	; 63
     a30:	0f 90       	pop	r0
     a32:	1f 90       	pop	r1
     a34:	18 95       	reti

00000a36 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a36:	8f e8       	ldi	r24, 0x8F	; 143
     a38:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a3c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a40:	80 e4       	ldi	r24, 0x40	; 64
     a42:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a46:	43 e0       	ldi	r20, 0x03	; 3
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	81 e0       	ldi	r24, 0x01	; 1
     a4c:	e3 d6       	rcall	.+3526   	; 0x1814 <xQueueGenericCreate>
     a4e:	90 93 aa 08 	sts	0x08AA, r25
     a52:	80 93 a9 08 	sts	0x08A9, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	9d d7       	rcall	.+3898   	; 0x1994 <xQueueCreateMutex>
     a5a:	90 93 a8 08 	sts	0x08A8, r25
     a5e:	80 93 a7 08 	sts	0x08A7, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a62:	20 e0       	ldi	r18, 0x00	; 0
     a64:	40 e0       	ldi	r20, 0x00	; 0
     a66:	50 e0       	ldi	r21, 0x00	; 0
     a68:	60 e0       	ldi	r22, 0x00	; 0
     a6a:	70 e0       	ldi	r23, 0x00	; 0
     a6c:	00 c7       	rjmp	.+3584   	; 0x186e <xQueueGenericSend>
     a6e:	08 95       	ret

00000a70 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a70:	cf 93       	push	r28
     a72:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a74:	20 e0       	ldi	r18, 0x00	; 0
     a76:	4f ef       	ldi	r20, 0xFF	; 255
     a78:	5f ef       	ldi	r21, 0xFF	; 255
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	80 91 a7 08 	lds	r24, 0x08A7
     a82:	90 91 a8 08 	lds	r25, 0x08A8
     a86:	eb d7       	rcall	.+4054   	; 0x1a5e <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a88:	ec e7       	ldi	r30, 0x7C	; 124
     a8a:	f0 e0       	ldi	r31, 0x00	; 0
     a8c:	80 81       	ld	r24, Z
     a8e:	9c 2f       	mov	r25, r28
     a90:	9f 71       	andi	r25, 0x1F	; 31
     a92:	80 76       	andi	r24, 0x60	; 96
     a94:	89 2b       	or	r24, r25
     a96:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a98:	eb e7       	ldi	r30, 0x7B	; 123
     a9a:	f0 e0       	ldi	r31, 0x00	; 0
     a9c:	20 81       	ld	r18, Z
     a9e:	c0 72       	andi	r28, 0x20	; 32
     aa0:	8c 2f       	mov	r24, r28
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	95 95       	asr	r25
     aa6:	87 95       	ror	r24
     aa8:	95 95       	asr	r25
     aaa:	87 95       	ror	r24
     aac:	92 2f       	mov	r25, r18
     aae:	90 76       	andi	r25, 0x60	; 96
     ab0:	89 2b       	or	r24, r25
     ab2:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     ab4:	ea e7       	ldi	r30, 0x7A	; 122
     ab6:	f0 e0       	ldi	r31, 0x00	; 0
     ab8:	80 81       	ld	r24, Z
     aba:	80 64       	ori	r24, 0x40	; 64
     abc:	80 83       	st	Z, r24
}
     abe:	cf 91       	pop	r28
     ac0:	08 95       	ret

00000ac2 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ac6:	20 e0       	ldi	r18, 0x00	; 0
     ac8:	4f ef       	ldi	r20, 0xFF	; 255
     aca:	5f ef       	ldi	r21, 0xFF	; 255
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	70 e0       	ldi	r23, 0x00	; 0
     ad0:	80 91 a9 08 	lds	r24, 0x08A9
     ad4:	90 91 aa 08 	lds	r25, 0x08AA
     ad8:	c2 d7       	rcall	.+3972   	; 0x1a5e <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     ada:	c0 91 a6 08 	lds	r28, 0x08A6
     ade:	c3 70       	andi	r28, 0x03	; 3
     ae0:	d0 e0       	ldi	r29, 0x00	; 0
     ae2:	dc 2f       	mov	r29, r28
     ae4:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ae6:	80 91 a5 08 	lds	r24, 0x08A5
     aea:	c8 0f       	add	r28, r24
     aec:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     aee:	20 e0       	ldi	r18, 0x00	; 0
     af0:	40 e0       	ldi	r20, 0x00	; 0
     af2:	50 e0       	ldi	r21, 0x00	; 0
     af4:	60 e0       	ldi	r22, 0x00	; 0
     af6:	70 e0       	ldi	r23, 0x00	; 0
     af8:	80 91 a7 08 	lds	r24, 0x08A7
     afc:	90 91 a8 08 	lds	r25, 0x08A8
     b00:	b6 d6       	rcall	.+3436   	; 0x186e <xQueueGenericSend>
	
	return adcReading;
     b02:	ce 01       	movw	r24, r28
     b04:	df 91       	pop	r29
     b06:	cf 91       	pop	r28
     b08:	08 95       	ret

00000b0a <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     b0a:	cf 93       	push	r28
     b0c:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b0e:	b0 df       	rcall	.-160    	; 0xa70 <myADC_startADC>
	return myADC_readADC(channel);
     b10:	8c 2f       	mov	r24, r28
     b12:	d7 df       	rcall	.-82     	; 0xac2 <myADC_readADC>
}
     b14:	cf 91       	pop	r28
     b16:	08 95       	ret

00000b18 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b18:	9c 01       	movw	r18, r24
     b1a:	24 5f       	subi	r18, 0xF4	; 244
     b1c:	3f 4f       	sbci	r19, 0xFF	; 255
     b1e:	26 17       	cp	r18, r22
     b20:	37 07       	cpc	r19, r23
     b22:	44 f0       	brlt	.+16     	; 0xb34 <detectStairs+0x1c>
     b24:	28 51       	subi	r18, 0x18	; 24
     b26:	31 09       	sbc	r19, r1
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	62 17       	cp	r22, r18
     b2c:	73 07       	cpc	r23, r19
     b2e:	1c f0       	brlt	.+6      	; 0xb36 <detectStairs+0x1e>
     b30:	80 e0       	ldi	r24, 0x00	; 0
     b32:	08 95       	ret
	{
		return 1; // stairs found
     b34:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b36:	08 95       	ret

00000b38 <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b38:	0f 93       	push	r16
     b3a:	1f 93       	push	r17
     b3c:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     b3e:	83 81       	ldd	r24, Z+3	; 0x03
     b40:	88 23       	and	r24, r24
     b42:	39 f0       	breq	.+14     	; 0xb52 <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b44:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b46:	e2 e0       	ldi	r30, 0x02	; 2
     b48:	f1 e0       	ldi	r31, 0x01	; 1
     b4a:	80 81       	ld	r24, Z
     b4c:	80 61       	ori	r24, 0x10	; 16
     b4e:	80 83       	st	Z, r24
     b50:	57 c0       	rjmp	.+174    	; 0xc00 <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b52:	80 81       	ld	r24, Z
     b54:	88 23       	and	r24, r24
     b56:	b1 f1       	breq	.+108    	; 0xbc4 <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b58:	81 81       	ldd	r24, Z+1	; 0x01
     b5a:	81 11       	cpse	r24, r1
     b5c:	18 c0       	rjmp	.+48     	; 0xb8e <obstacleAvoidance+0x56>
     b5e:	82 81       	ldd	r24, Z+2	; 0x02
     b60:	81 11       	cpse	r24, r1
     b62:	24 c0       	rjmp	.+72     	; 0xbac <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar + 14) // if right sonar greater than....
     b64:	cb 01       	movw	r24, r22
     b66:	0e 96       	adiw	r24, 0x0e	; 14
     b68:	84 17       	cp	r24, r20
     b6a:	95 07       	cpc	r25, r21
     b6c:	3c f4       	brge	.+14     	; 0xb7c <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b6e:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b70:	a2 e0       	ldi	r26, 0x02	; 2
     b72:	b1 e0       	ldi	r27, 0x01	; 1
     b74:	8c 91       	ld	r24, X
     b76:	80 61       	ori	r24, 0x10	; 16
     b78:	8c 93       	st	X, r24
     b7a:	06 c0       	rjmp	.+12     	; 0xb88 <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b7c:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b7e:	a2 e0       	ldi	r26, 0x02	; 2
     b80:	b1 e0       	ldi	r27, 0x01	; 1
     b82:	8c 91       	ld	r24, X
     b84:	8f 7e       	andi	r24, 0xEF	; 239
     b86:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     b88:	81 81       	ldd	r24, Z+1	; 0x01
     b8a:	88 23       	and	r24, r24
     b8c:	b1 f1       	breq	.+108    	; 0xbfa <obstacleAvoidance+0xc2>
     b8e:	82 81       	ldd	r24, Z+2	; 0x02
     b90:	81 11       	cpse	r24, r1
     b92:	36 c0       	rjmp	.+108    	; 0xc00 <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     b94:	46 1b       	sub	r20, r22
     b96:	57 0b       	sbc	r21, r23
     b98:	49 30       	cpi	r20, 0x09	; 9
     b9a:	51 05       	cpc	r21, r1
     b9c:	8c f1       	brlt	.+98     	; 0xc00 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     b9e:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     ba0:	e2 e0       	ldi	r30, 0x02	; 2
     ba2:	f1 e0       	ldi	r31, 0x01	; 1
     ba4:	80 81       	ld	r24, Z
     ba6:	80 61       	ori	r24, 0x10	; 16
     ba8:	80 83       	st	Z, r24
     baa:	2a c0       	rjmp	.+84     	; 0xc00 <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     bac:	64 1b       	sub	r22, r20
     bae:	75 0b       	sbc	r23, r21
     bb0:	69 30       	cpi	r22, 0x09	; 9
     bb2:	71 05       	cpc	r23, r1
     bb4:	2c f1       	brlt	.+74     	; 0xc00 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     bb6:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     bb8:	e2 e0       	ldi	r30, 0x02	; 2
     bba:	f1 e0       	ldi	r31, 0x01	; 1
     bbc:	80 81       	ld	r24, Z
     bbe:	8f 7e       	andi	r24, 0xEF	; 239
     bc0:	80 83       	st	Z, r24
     bc2:	1e c0       	rjmp	.+60     	; 0xc00 <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     bc4:	66 32       	cpi	r22, 0x26	; 38
     bc6:	71 05       	cpc	r23, r1
     bc8:	3c f4       	brge	.+14     	; 0xbd8 <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     bca:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     bcc:	e2 e0       	ldi	r30, 0x02	; 2
     bce:	f1 e0       	ldi	r31, 0x01	; 1
     bd0:	80 81       	ld	r24, Z
     bd2:	80 61       	ori	r24, 0x10	; 16
     bd4:	80 83       	st	Z, r24
     bd6:	14 c0       	rjmp	.+40     	; 0xc00 <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     bd8:	44 31       	cpi	r20, 0x14	; 20
     bda:	51 05       	cpc	r21, r1
     bdc:	3c f4       	brge	.+14     	; 0xbec <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     bde:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     be0:	e2 e0       	ldi	r30, 0x02	; 2
     be2:	f1 e0       	ldi	r31, 0x01	; 1
     be4:	80 81       	ld	r24, Z
     be6:	8f 7e       	andi	r24, 0xEF	; 239
     be8:	80 83       	st	Z, r24
     bea:	0a c0       	rjmp	.+20     	; 0xc00 <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     bec:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bee:	e2 e0       	ldi	r30, 0x02	; 2
     bf0:	f1 e0       	ldi	r31, 0x01	; 1
     bf2:	80 81       	ld	r24, Z
     bf4:	8f 7e       	andi	r24, 0xEF	; 239
     bf6:	80 83       	st	Z, r24
     bf8:	03 c0       	rjmp	.+6      	; 0xc00 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     bfa:	82 81       	ldd	r24, Z+2	; 0x02
     bfc:	81 11       	cpse	r24, r1
     bfe:	d6 cf       	rjmp	.-84     	; 0xbac <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c00:	1f 91       	pop	r17
     c02:	0f 91       	pop	r16
     c04:	08 95       	ret

00000c06 <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     c06:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     c08:	85 e0       	ldi	r24, 0x05	; 5
     c0a:	db 01       	movw	r26, r22
     c0c:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c0e:	86 e4       	ldi	r24, 0x46	; 70
     c10:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c12:	8c e4       	ldi	r24, 0x4C	; 76
     c14:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c16:	82 e5       	ldi	r24, 0x52	; 82
     c18:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c1a:	82 e4       	ldi	r24, 0x42	; 66
     c1c:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     c1e:	84 e5       	ldi	r24, 0x54	; 84
     c20:	84 83       	std	Z+4, r24	; 0x04
     c22:	08 95       	ret

00000c24 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c24:	af 92       	push	r10
     c26:	bf 92       	push	r11
     c28:	cf 92       	push	r12
     c2a:	df 92       	push	r13
     c2c:	ff 92       	push	r15
     c2e:	0f 93       	push	r16
     c30:	1f 93       	push	r17
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	f6 2e       	mov	r15, r22
     c38:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c3a:	86 34       	cpi	r24, 0x46	; 70
     c3c:	91 05       	cpc	r25, r1
     c3e:	1c f4       	brge	.+6      	; 0xc46 <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     c40:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c42:	86 e4       	ldi	r24, 0x46	; 70
     c44:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c46:	2e 31       	cpi	r18, 0x1E	; 30
     c48:	31 05       	cpc	r19, r1
     c4a:	1c f4       	brge	.+6      	; 0xc52 <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     c4c:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c4e:	8c e4       	ldi	r24, 0x4C	; 76
     c50:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c52:	0e 31       	cpi	r16, 0x1E	; 30
     c54:	11 05       	cpc	r17, r1
     c56:	1c f4       	brge	.+6      	; 0xc5e <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     c58:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c5a:	82 e5       	ldi	r24, 0x52	; 82
     c5c:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c5e:	b5 01       	movw	r22, r10
     c60:	c6 01       	movw	r24, r12
     c62:	5a df       	rcall	.-332    	; 0xb18 <detectStairs>
     c64:	88 23       	and	r24, r24
     c66:	19 f0       	breq	.+6      	; 0xc6e <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c68:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c6a:	82 e4       	ldi	r24, 0x42	; 66
     c6c:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     c6e:	8f 2d       	mov	r24, r15
     c70:	df 91       	pop	r29
     c72:	cf 91       	pop	r28
     c74:	1f 91       	pop	r17
     c76:	0f 91       	pop	r16
     c78:	ff 90       	pop	r15
     c7a:	df 90       	pop	r13
     c7c:	cf 90       	pop	r12
     c7e:	bf 90       	pop	r11
     c80:	af 90       	pop	r10
     c82:	08 95       	ret

00000c84 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c84:	42 df       	rcall	.-380    	; 0xb0a <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c86:	bc 01       	movw	r22, r24
     c88:	88 27       	eor	r24, r24
     c8a:	77 fd       	sbrc	r23, 7
     c8c:	80 95       	com	r24
     c8e:	98 2f       	mov	r25, r24
     c90:	0e 94 81 14 	call	0x2902	; 0x2902 <__floatsisf>
     c94:	29 e2       	ldi	r18, 0x29	; 41
     c96:	3c e5       	ldi	r19, 0x5C	; 92
     c98:	4f e6       	ldi	r20, 0x6F	; 111
     c9a:	5f eb       	ldi	r21, 0xBF	; 191
     c9c:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <pow>
     ca0:	22 e5       	ldi	r18, 0x52	; 82
     ca2:	38 e6       	ldi	r19, 0x68	; 104
     ca4:	46 e2       	ldi	r20, 0x26	; 38
     ca6:	56 e4       	ldi	r21, 0x46	; 70
     ca8:	0e 94 0d 15 	call	0x2a1a	; 0x2a1a <__mulsf3>
     cac:	20 e0       	ldi	r18, 0x00	; 0
     cae:	30 e0       	ldi	r19, 0x00	; 0
     cb0:	40 e2       	ldi	r20, 0x20	; 32
     cb2:	51 e4       	ldi	r21, 0x41	; 65
     cb4:	0e 94 e9 13 	call	0x27d2	; 0x27d2 <__subsf3>
     cb8:	0e 94 4e 14 	call	0x289c	; 0x289c <__fixsfsi>
     cbc:	cb 01       	movw	r24, r22
     cbe:	68 3e       	cpi	r22, 0xE8	; 232
     cc0:	23 e0       	ldi	r18, 0x03	; 3
     cc2:	72 07       	cpc	r23, r18
     cc4:	14 f0       	brlt	.+4      	; 0xcca <mySharpIR_Read+0x46>
     cc6:	87 ee       	ldi	r24, 0xE7	; 231
     cc8:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     cca:	08 95       	ret

00000ccc <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     ccc:	fb 01       	movw	r30, r22
     cce:	20 81       	ld	r18, Z
     cd0:	31 81       	ldd	r19, Z+1	; 0x01
     cd2:	50 e0       	ldi	r21, 0x00	; 0
     cd4:	b9 01       	movw	r22, r18
     cd6:	64 0f       	add	r22, r20
     cd8:	75 1f       	adc	r23, r21
     cda:	68 17       	cp	r22, r24
     cdc:	79 07       	cpc	r23, r25
     cde:	4c f0       	brlt	.+18     	; 0xcf2 <checkWithinRange+0x26>
     ce0:	24 1b       	sub	r18, r20
     ce2:	35 0b       	sbc	r19, r21
     ce4:	41 e0       	ldi	r20, 0x01	; 1
     ce6:	82 17       	cp	r24, r18
     ce8:	93 07       	cpc	r25, r19
     cea:	0c f0       	brlt	.+2      	; 0xcee <checkWithinRange+0x22>
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	84 2f       	mov	r24, r20
     cf0:	08 95       	ret
     cf2:	81 e0       	ldi	r24, 0x01	; 1
}
     cf4:	08 95       	ret

00000cf6 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     cf6:	0f 93       	push	r16
     cf8:	1f 93       	push	r17
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	8c 01       	movw	r16, r24
     d00:	eb 01       	movw	r28, r22
	static uint8_t i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     d02:	45 e0       	ldi	r20, 0x05	; 5
     d04:	bc 01       	movw	r22, r24
     d06:	ce 01       	movw	r24, r28
     d08:	e1 df       	rcall	.-62     	; 0xccc <checkWithinRange>
     d0a:	88 23       	and	r24, r24
     d0c:	29 f0       	breq	.+10     	; 0xd18 <mySharpIR_ReCalibrate+0x22>
     d0e:	80 91 1d 08 	lds	r24, 0x081D
     d12:	81 11       	cpse	r24, r1
     d14:	0a c0       	rjmp	.+20     	; 0xd2a <mySharpIR_ReCalibrate+0x34>
     d16:	3f c0       	rjmp	.+126    	; 0xd96 <mySharpIR_ReCalibrate+0xa0>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     d18:	80 91 1d 08 	lds	r24, 0x081D
     d1c:	81 11       	cpse	r24, r1
     d1e:	05 c0       	rjmp	.+10     	; 0xd2a <mySharpIR_ReCalibrate+0x34>
	{
		checkReading[0] = reading;
     d20:	d0 93 1a 08 	sts	0x081A, r29
     d24:	c0 93 19 08 	sts	0x0819, r28
     d28:	2c c0       	rjmp	.+88     	; 0xd82 <mySharpIR_ReCalibrate+0x8c>
	}
	else if (i == CALIBRATE_COUNT/2)
     d2a:	8a 30       	cpi	r24, 0x0A	; 10
     d2c:	99 f4       	brne	.+38     	; 0xd54 <mySharpIR_ReCalibrate+0x5e>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d2e:	45 e0       	ldi	r20, 0x05	; 5
     d30:	69 e1       	ldi	r22, 0x19	; 25
     d32:	78 e0       	ldi	r23, 0x08	; 8
     d34:	ce 01       	movw	r24, r28
     d36:	ca df       	rcall	.-108    	; 0xccc <checkWithinRange>
     d38:	88 23       	and	r24, r24
     d3a:	39 f0       	breq	.+14     	; 0xd4a <mySharpIR_ReCalibrate+0x54>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d3c:	d0 93 1a 08 	sts	0x081A, r29
     d40:	c0 93 19 08 	sts	0x0819, r28
			i = 0; // reset to count...
     d44:	10 92 1d 08 	sts	0x081D, r1
     d48:	1c c0       	rjmp	.+56     	; 0xd82 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d4a:	d0 93 1c 08 	sts	0x081C, r29
     d4e:	c0 93 1b 08 	sts	0x081B, r28
     d52:	17 c0       	rjmp	.+46     	; 0xd82 <mySharpIR_ReCalibrate+0x8c>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d54:	84 31       	cpi	r24, 0x14	; 20
     d56:	a9 f4       	brne	.+42     	; 0xd82 <mySharpIR_ReCalibrate+0x8c>
	{
		i = 0; // reset to count..
     d58:	10 92 1d 08 	sts	0x081D, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d5c:	45 e0       	ldi	r20, 0x05	; 5
     d5e:	69 e1       	ldi	r22, 0x19	; 25
     d60:	78 e0       	ldi	r23, 0x08	; 8
     d62:	ce 01       	movw	r24, r28
     d64:	b3 df       	rcall	.-154    	; 0xccc <checkWithinRange>
     d66:	88 23       	and	r24, r24
     d68:	29 f0       	breq	.+10     	; 0xd74 <mySharpIR_ReCalibrate+0x7e>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d6a:	d0 93 1a 08 	sts	0x081A, r29
     d6e:	c0 93 19 08 	sts	0x0819, r28
     d72:	07 c0       	rjmp	.+14     	; 0xd82 <mySharpIR_ReCalibrate+0x8c>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     d74:	80 91 19 08 	lds	r24, 0x0819
     d78:	90 91 1a 08 	lds	r25, 0x081A
     d7c:	f8 01       	movw	r30, r16
     d7e:	91 83       	std	Z+1, r25	; 0x01
     d80:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     d82:	80 91 1d 08 	lds	r24, 0x081D
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	01 96       	adiw	r24, 0x01	; 1
     d8a:	64 e1       	ldi	r22, 0x14	; 20
     d8c:	70 e0       	ldi	r23, 0x00	; 0
     d8e:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
     d92:	80 93 1d 08 	sts	0x081D, r24
}
     d96:	df 91       	pop	r29
     d98:	cf 91       	pop	r28
     d9a:	1f 91       	pop	r17
     d9c:	0f 91       	pop	r16
     d9e:	08 95       	ret

00000da0 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     da0:	90 93 b0 08 	sts	0x08B0, r25
     da4:	80 93 af 08 	sts	0x08AF, r24
     da8:	fc 01       	movw	r30, r24
     daa:	80 81       	ld	r24, Z
     dac:	91 81       	ldd	r25, Z+1	; 0x01
     dae:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskSuspend>
     db2:	43 e0       	ldi	r20, 0x03	; 3
     db4:	60 e0       	ldi	r22, 0x00	; 0
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	2d d5       	rcall	.+2650   	; 0x1814 <xQueueGenericCreate>
     dba:	90 93 ac 08 	sts	0x08AC, r25
     dbe:	80 93 ab 08 	sts	0x08AB, r24
     dc2:	43 e0       	ldi	r20, 0x03	; 3
     dc4:	60 e0       	ldi	r22, 0x00	; 0
     dc6:	81 e0       	ldi	r24, 0x01	; 1
     dc8:	25 d5       	rcall	.+2634   	; 0x1814 <xQueueGenericCreate>
     dca:	90 93 ae 08 	sts	0x08AE, r25
     dce:	80 93 ad 08 	sts	0x08AD, r24
     dd2:	08 95       	ret

00000dd4 <myTimer_Read>:
     dd4:	86 b5       	in	r24, 0x26	; 38
     dd6:	08 95       	ret

00000dd8 <myTimer_DelayMicro>:
     dd8:	46 b5       	in	r20, 0x26	; 38
     dda:	50 e0       	ldi	r21, 0x00	; 0
     ddc:	9c 01       	movw	r18, r24
     dde:	99 23       	and	r25, r25
     de0:	14 f4       	brge	.+4      	; 0xde6 <myTimer_DelayMicro+0xe>
     de2:	2d 5f       	subi	r18, 0xFD	; 253
     de4:	3f 4f       	sbci	r19, 0xFF	; 255
     de6:	35 95       	asr	r19
     de8:	27 95       	ror	r18
     dea:	35 95       	asr	r19
     dec:	27 95       	ror	r18
     dee:	24 0f       	add	r18, r20
     df0:	35 1f       	adc	r19, r21
     df2:	30 93 04 02 	sts	0x0204, r19
     df6:	20 93 03 02 	sts	0x0203, r18
     dfa:	e0 91 af 08 	lds	r30, 0x08AF
     dfe:	f0 91 b0 08 	lds	r31, 0x08B0
     e02:	80 81       	ld	r24, Z
     e04:	91 81       	ldd	r25, Z+1	; 0x01
     e06:	0e 94 96 0f 	call	0x1f2c	; 0x1f2c <vTaskResume>
     e0a:	20 e0       	ldi	r18, 0x00	; 0
     e0c:	42 e0       	ldi	r20, 0x02	; 2
     e0e:	50 e0       	ldi	r21, 0x00	; 0
     e10:	60 e0       	ldi	r22, 0x00	; 0
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	80 91 ab 08 	lds	r24, 0x08AB
     e18:	90 91 ac 08 	lds	r25, 0x08AC
     e1c:	20 c6       	rjmp	.+3136   	; 0x1a5e <xQueueGenericReceive>
     e1e:	08 95       	ret

00000e20 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e24:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e26:	c1 11       	cpse	r28, r1
     e28:	22 c0       	rjmp	.+68     	; 0xe6e <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e2a:	80 91 03 02 	lds	r24, 0x0203
     e2e:	90 91 04 02 	lds	r25, 0x0204
     e32:	88 38       	cpi	r24, 0x88	; 136
     e34:	93 41       	sbci	r25, 0x13	; 19
     e36:	51 f0       	breq	.+20     	; 0xe4c <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e38:	80 91 03 02 	lds	r24, 0x0203
     e3c:	90 91 04 02 	lds	r25, 0x0204
     e40:	8a 5f       	subi	r24, 0xFA	; 250
     e42:	91 09       	sbc	r25, r1
     e44:	90 93 04 02 	sts	0x0204, r25
     e48:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e4c:	80 91 01 02 	lds	r24, 0x0201
     e50:	90 91 02 02 	lds	r25, 0x0202
     e54:	88 38       	cpi	r24, 0x88	; 136
     e56:	93 41       	sbci	r25, 0x13	; 19
     e58:	51 f0       	breq	.+20     	; 0xe6e <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e5a:	80 91 01 02 	lds	r24, 0x0201
     e5e:	90 91 02 02 	lds	r25, 0x0202
     e62:	8a 5f       	subi	r24, 0xFA	; 250
     e64:	91 09       	sbc	r25, r1
     e66:	90 93 02 02 	sts	0x0202, r25
     e6a:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     e6e:	d0 e0       	ldi	r29, 0x00	; 0
     e70:	80 91 03 02 	lds	r24, 0x0203
     e74:	90 91 04 02 	lds	r25, 0x0204
     e78:	8c 17       	cp	r24, r28
     e7a:	9d 07       	cpc	r25, r29
     e7c:	84 f4       	brge	.+32     	; 0xe9e <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     e7e:	88 e8       	ldi	r24, 0x88	; 136
     e80:	93 e1       	ldi	r25, 0x13	; 19
     e82:	90 93 04 02 	sts	0x0204, r25
     e86:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     e8a:	20 e0       	ldi	r18, 0x00	; 0
     e8c:	40 e0       	ldi	r20, 0x00	; 0
     e8e:	50 e0       	ldi	r21, 0x00	; 0
     e90:	60 e0       	ldi	r22, 0x00	; 0
     e92:	70 e0       	ldi	r23, 0x00	; 0
     e94:	80 91 ab 08 	lds	r24, 0x08AB
     e98:	90 91 ac 08 	lds	r25, 0x08AC
     e9c:	e8 d4       	rcall	.+2512   	; 0x186e <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     e9e:	80 91 01 02 	lds	r24, 0x0201
     ea2:	90 91 02 02 	lds	r25, 0x0202
     ea6:	8c 17       	cp	r24, r28
     ea8:	9d 07       	cpc	r25, r29
     eaa:	84 f4       	brge	.+32     	; 0xecc <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     eac:	88 e8       	ldi	r24, 0x88	; 136
     eae:	93 e1       	ldi	r25, 0x13	; 19
     eb0:	90 93 02 02 	sts	0x0202, r25
     eb4:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	40 e0       	ldi	r20, 0x00	; 0
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	60 e0       	ldi	r22, 0x00	; 0
     ec0:	70 e0       	ldi	r23, 0x00	; 0
     ec2:	80 91 ad 08 	lds	r24, 0x08AD
     ec6:	90 91 ae 08 	lds	r25, 0x08AE
     eca:	d1 d4       	rcall	.+2466   	; 0x186e <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     ecc:	80 91 03 02 	lds	r24, 0x0203
     ed0:	90 91 04 02 	lds	r25, 0x0204
     ed4:	88 38       	cpi	r24, 0x88	; 136
     ed6:	93 41       	sbci	r25, 0x13	; 19
     ed8:	79 f4       	brne	.+30     	; 0xef8 <myTimer_DelayChecker+0xd8>
     eda:	80 91 01 02 	lds	r24, 0x0201
     ede:	90 91 02 02 	lds	r25, 0x0202
     ee2:	88 38       	cpi	r24, 0x88	; 136
     ee4:	93 41       	sbci	r25, 0x13	; 19
     ee6:	41 f4       	brne	.+16     	; 0xef8 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     ee8:	e0 91 af 08 	lds	r30, 0x08AF
     eec:	f0 91 b0 08 	lds	r31, 0x08B0
     ef0:	80 81       	ld	r24, Z
     ef2:	91 81       	ldd	r25, Z+1	; 0x01
     ef4:	0e 94 33 12 	call	0x2466	; 0x2466 <vTaskSuspend>
	}
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	08 95       	ret

00000efe <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     efe:	1f 92       	push	r1
     f00:	0f 92       	push	r0
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	0f 92       	push	r0
     f06:	11 24       	eor	r1, r1
     f08:	0b b6       	in	r0, 0x3b	; 59
     f0a:	0f 92       	push	r0
     f0c:	2f 93       	push	r18
     f0e:	3f 93       	push	r19
     f10:	4f 93       	push	r20
     f12:	5f 93       	push	r21
     f14:	6f 93       	push	r22
     f16:	7f 93       	push	r23
     f18:	8f 93       	push	r24
     f1a:	9f 93       	push	r25
     f1c:	af 93       	push	r26
     f1e:	bf 93       	push	r27
     f20:	ef 93       	push	r30
     f22:	ff 93       	push	r31
     f24:	60 91 ce 00 	lds	r22, 0x00CE
     f28:	80 e4       	ldi	r24, 0x40	; 64
     f2a:	99 e0       	ldi	r25, 0x09	; 9
     f2c:	6e d6       	rcall	.+3292   	; 0x1c0a <ringBufferPush>
     f2e:	20 e0       	ldi	r18, 0x00	; 0
     f30:	40 e0       	ldi	r20, 0x00	; 0
     f32:	50 e0       	ldi	r21, 0x00	; 0
     f34:	60 e0       	ldi	r22, 0x00	; 0
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	80 91 26 08 	lds	r24, 0x0826
     f3c:	90 91 27 08 	lds	r25, 0x0827
     f40:	54 d5       	rcall	.+2728   	; 0x19ea <xQueueGenericSendFromISR>
     f42:	80 e4       	ldi	r24, 0x40	; 64
     f44:	99 e0       	ldi	r25, 0x09	; 9
     f46:	78 d6       	rcall	.+3312   	; 0x1c38 <ringBufferFull>
     f48:	ff 91       	pop	r31
     f4a:	ef 91       	pop	r30
     f4c:	bf 91       	pop	r27
     f4e:	af 91       	pop	r26
     f50:	9f 91       	pop	r25
     f52:	8f 91       	pop	r24
     f54:	7f 91       	pop	r23
     f56:	6f 91       	pop	r22
     f58:	5f 91       	pop	r21
     f5a:	4f 91       	pop	r20
     f5c:	3f 91       	pop	r19
     f5e:	2f 91       	pop	r18
     f60:	0f 90       	pop	r0
     f62:	0b be       	out	0x3b, r0	; 59
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	0f 90       	pop	r0
     f6a:	1f 90       	pop	r1
     f6c:	18 95       	reti

00000f6e <__vector_25>:
     f6e:	1f 92       	push	r1
     f70:	0f 92       	push	r0
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	0f 92       	push	r0
     f76:	11 24       	eor	r1, r1
     f78:	0b b6       	in	r0, 0x3b	; 59
     f7a:	0f 92       	push	r0
     f7c:	2f 93       	push	r18
     f7e:	3f 93       	push	r19
     f80:	4f 93       	push	r20
     f82:	5f 93       	push	r21
     f84:	6f 93       	push	r22
     f86:	7f 93       	push	r23
     f88:	8f 93       	push	r24
     f8a:	9f 93       	push	r25
     f8c:	af 93       	push	r26
     f8e:	bf 93       	push	r27
     f90:	ef 93       	push	r30
     f92:	ff 93       	push	r31
     f94:	60 91 c6 00 	lds	r22, 0x00C6
     f98:	81 ed       	ldi	r24, 0xD1	; 209
     f9a:	98 e0       	ldi	r25, 0x08	; 8
     f9c:	36 d6       	rcall	.+3180   	; 0x1c0a <ringBufferPush>
     f9e:	20 e0       	ldi	r18, 0x00	; 0
     fa0:	40 e0       	ldi	r20, 0x00	; 0
     fa2:	50 e0       	ldi	r21, 0x00	; 0
     fa4:	60 e0       	ldi	r22, 0x00	; 0
     fa6:	70 e0       	ldi	r23, 0x00	; 0
     fa8:	80 91 26 08 	lds	r24, 0x0826
     fac:	90 91 27 08 	lds	r25, 0x0827
     fb0:	1c d5       	rcall	.+2616   	; 0x19ea <xQueueGenericSendFromISR>
     fb2:	81 ed       	ldi	r24, 0xD1	; 209
     fb4:	98 e0       	ldi	r25, 0x08	; 8
     fb6:	40 d6       	rcall	.+3200   	; 0x1c38 <ringBufferFull>
     fb8:	ff 91       	pop	r31
     fba:	ef 91       	pop	r30
     fbc:	bf 91       	pop	r27
     fbe:	af 91       	pop	r26
     fc0:	9f 91       	pop	r25
     fc2:	8f 91       	pop	r24
     fc4:	7f 91       	pop	r23
     fc6:	6f 91       	pop	r22
     fc8:	5f 91       	pop	r21
     fca:	4f 91       	pop	r20
     fcc:	3f 91       	pop	r19
     fce:	2f 91       	pop	r18
     fd0:	0f 90       	pop	r0
     fd2:	0b be       	out	0x3b, r0	; 59
     fd4:	0f 90       	pop	r0
     fd6:	0f be       	out	0x3f, r0	; 63
     fd8:	0f 90       	pop	r0
     fda:	1f 90       	pop	r1
     fdc:	18 95       	reti

00000fde <__vector_37>:
     fde:	1f 92       	push	r1
     fe0:	0f 92       	push	r0
     fe2:	0f b6       	in	r0, 0x3f	; 63
     fe4:	0f 92       	push	r0
     fe6:	11 24       	eor	r1, r1
     fe8:	0b b6       	in	r0, 0x3b	; 59
     fea:	0f 92       	push	r0
     fec:	2f 93       	push	r18
     fee:	3f 93       	push	r19
     ff0:	4f 93       	push	r20
     ff2:	5f 93       	push	r21
     ff4:	6f 93       	push	r22
     ff6:	7f 93       	push	r23
     ff8:	8f 93       	push	r24
     ffa:	9f 93       	push	r25
     ffc:	af 93       	push	r26
     ffe:	bf 93       	push	r27
    1000:	ef 93       	push	r30
    1002:	ff 93       	push	r31
    1004:	86 e3       	ldi	r24, 0x36	; 54
    1006:	99 e0       	ldi	r25, 0x09	; 9
    1008:	1e d6       	rcall	.+3132   	; 0x1c46 <ringBufferNotEmpty>
    100a:	88 23       	and	r24, r24
    100c:	31 f0       	breq	.+12     	; 0x101a <__vector_37+0x3c>
    100e:	86 e3       	ldi	r24, 0x36	; 54
    1010:	99 e0       	ldi	r25, 0x09	; 9
    1012:	e9 d5       	rcall	.+3026   	; 0x1be6 <ringBufferPop>
    1014:	80 93 ce 00 	sts	0x00CE, r24
    1018:	0f c0       	rjmp	.+30     	; 0x1038 <__vector_37+0x5a>
    101a:	e9 ec       	ldi	r30, 0xC9	; 201
    101c:	f0 e0       	ldi	r31, 0x00	; 0
    101e:	80 81       	ld	r24, Z
    1020:	8f 7d       	andi	r24, 0xDF	; 223
    1022:	80 83       	st	Z, r24
    1024:	20 e0       	ldi	r18, 0x00	; 0
    1026:	40 e0       	ldi	r20, 0x00	; 0
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	60 e0       	ldi	r22, 0x00	; 0
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	80 91 1e 08 	lds	r24, 0x081E
    1032:	90 91 1f 08 	lds	r25, 0x081F
    1036:	d9 d4       	rcall	.+2482   	; 0x19ea <xQueueGenericSendFromISR>
    1038:	ff 91       	pop	r31
    103a:	ef 91       	pop	r30
    103c:	bf 91       	pop	r27
    103e:	af 91       	pop	r26
    1040:	9f 91       	pop	r25
    1042:	8f 91       	pop	r24
    1044:	7f 91       	pop	r23
    1046:	6f 91       	pop	r22
    1048:	5f 91       	pop	r21
    104a:	4f 91       	pop	r20
    104c:	3f 91       	pop	r19
    104e:	2f 91       	pop	r18
    1050:	0f 90       	pop	r0
    1052:	0b be       	out	0x3b, r0	; 59
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63
    1058:	0f 90       	pop	r0
    105a:	1f 90       	pop	r1
    105c:	18 95       	reti

0000105e <__vector_26>:
    105e:	1f 92       	push	r1
    1060:	0f 92       	push	r0
    1062:	0f b6       	in	r0, 0x3f	; 63
    1064:	0f 92       	push	r0
    1066:	11 24       	eor	r1, r1
    1068:	0b b6       	in	r0, 0x3b	; 59
    106a:	0f 92       	push	r0
    106c:	2f 93       	push	r18
    106e:	3f 93       	push	r19
    1070:	4f 93       	push	r20
    1072:	5f 93       	push	r21
    1074:	6f 93       	push	r22
    1076:	7f 93       	push	r23
    1078:	8f 93       	push	r24
    107a:	9f 93       	push	r25
    107c:	af 93       	push	r26
    107e:	bf 93       	push	r27
    1080:	ef 93       	push	r30
    1082:	ff 93       	push	r31
    1084:	8b e3       	ldi	r24, 0x3B	; 59
    1086:	99 e0       	ldi	r25, 0x09	; 9
    1088:	de d5       	rcall	.+3004   	; 0x1c46 <ringBufferNotEmpty>
    108a:	88 23       	and	r24, r24
    108c:	31 f0       	breq	.+12     	; 0x109a <__vector_26+0x3c>
    108e:	8b e3       	ldi	r24, 0x3B	; 59
    1090:	99 e0       	ldi	r25, 0x09	; 9
    1092:	a9 d5       	rcall	.+2898   	; 0x1be6 <ringBufferPop>
    1094:	80 93 c6 00 	sts	0x00C6, r24
    1098:	0f c0       	rjmp	.+30     	; 0x10b8 <__vector_26+0x5a>
    109a:	e1 ec       	ldi	r30, 0xC1	; 193
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	80 81       	ld	r24, Z
    10a0:	8f 7d       	andi	r24, 0xDF	; 223
    10a2:	80 83       	st	Z, r24
    10a4:	20 e0       	ldi	r18, 0x00	; 0
    10a6:	40 e0       	ldi	r20, 0x00	; 0
    10a8:	50 e0       	ldi	r21, 0x00	; 0
    10aa:	60 e0       	ldi	r22, 0x00	; 0
    10ac:	70 e0       	ldi	r23, 0x00	; 0
    10ae:	80 91 20 08 	lds	r24, 0x0820
    10b2:	90 91 21 08 	lds	r25, 0x0821
    10b6:	99 d4       	rcall	.+2354   	; 0x19ea <xQueueGenericSendFromISR>
    10b8:	ff 91       	pop	r31
    10ba:	ef 91       	pop	r30
    10bc:	bf 91       	pop	r27
    10be:	af 91       	pop	r26
    10c0:	9f 91       	pop	r25
    10c2:	8f 91       	pop	r24
    10c4:	7f 91       	pop	r23
    10c6:	6f 91       	pop	r22
    10c8:	5f 91       	pop	r21
    10ca:	4f 91       	pop	r20
    10cc:	3f 91       	pop	r19
    10ce:	2f 91       	pop	r18
    10d0:	0f 90       	pop	r0
    10d2:	0b be       	out	0x3b, r0	; 59
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	0f 90       	pop	r0
    10da:	1f 90       	pop	r1
    10dc:	18 95       	reti

000010de <myUSART_USART0_Init>:
    10de:	10 92 c5 00 	sts	0x00C5, r1
    10e2:	87 e6       	ldi	r24, 0x67	; 103
    10e4:	80 93 c4 00 	sts	0x00C4, r24
    10e8:	88 eb       	ldi	r24, 0xB8	; 184
    10ea:	80 93 c1 00 	sts	0x00C1, r24
    10ee:	86 e0       	ldi	r24, 0x06	; 6
    10f0:	80 93 c2 00 	sts	0x00C2, r24
    10f4:	40 e2       	ldi	r20, 0x20	; 32
    10f6:	66 ef       	ldi	r22, 0xF6	; 246
    10f8:	78 e0       	ldi	r23, 0x08	; 8
    10fa:	81 ed       	ldi	r24, 0xD1	; 209
    10fc:	98 e0       	ldi	r25, 0x08	; 8
    10fe:	62 d5       	rcall	.+2756   	; 0x1bc4 <ringBufferInit>
    1100:	40 e2       	ldi	r20, 0x20	; 32
    1102:	66 ed       	ldi	r22, 0xD6	; 214
    1104:	78 e0       	ldi	r23, 0x08	; 8
    1106:	8b e3       	ldi	r24, 0x3B	; 59
    1108:	99 e0       	ldi	r25, 0x09	; 9
    110a:	5c d5       	rcall	.+2744   	; 0x1bc4 <ringBufferInit>
    110c:	43 e0       	ldi	r20, 0x03	; 3
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	80 d3       	rcall	.+1792   	; 0x1814 <xQueueGenericCreate>
    1114:	90 93 25 08 	sts	0x0825, r25
    1118:	80 93 24 08 	sts	0x0824, r24
    111c:	81 e0       	ldi	r24, 0x01	; 1
    111e:	3a d4       	rcall	.+2164   	; 0x1994 <xQueueCreateMutex>
    1120:	90 93 21 08 	sts	0x0821, r25
    1124:	80 93 20 08 	sts	0x0820, r24
    1128:	08 95       	ret

0000112a <myUSART_USART1_Init>:
    112a:	10 92 cd 00 	sts	0x00CD, r1
    112e:	87 e6       	ldi	r24, 0x67	; 103
    1130:	80 93 cc 00 	sts	0x00CC, r24
    1134:	88 eb       	ldi	r24, 0xB8	; 184
    1136:	80 93 c9 00 	sts	0x00C9, r24
    113a:	86 e0       	ldi	r24, 0x06	; 6
    113c:	80 93 ca 00 	sts	0x00CA, r24
    1140:	40 e2       	ldi	r20, 0x20	; 32
    1142:	61 eb       	ldi	r22, 0xB1	; 177
    1144:	78 e0       	ldi	r23, 0x08	; 8
    1146:	80 e4       	ldi	r24, 0x40	; 64
    1148:	99 e0       	ldi	r25, 0x09	; 9
    114a:	3c d5       	rcall	.+2680   	; 0x1bc4 <ringBufferInit>
    114c:	40 e2       	ldi	r20, 0x20	; 32
    114e:	66 e1       	ldi	r22, 0x16	; 22
    1150:	79 e0       	ldi	r23, 0x09	; 9
    1152:	86 e3       	ldi	r24, 0x36	; 54
    1154:	99 e0       	ldi	r25, 0x09	; 9
    1156:	36 d5       	rcall	.+2668   	; 0x1bc4 <ringBufferInit>
    1158:	43 e0       	ldi	r20, 0x03	; 3
    115a:	60 e0       	ldi	r22, 0x00	; 0
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	5a d3       	rcall	.+1716   	; 0x1814 <xQueueGenericCreate>
    1160:	90 93 27 08 	sts	0x0827, r25
    1164:	80 93 26 08 	sts	0x0826, r24
    1168:	43 e0       	ldi	r20, 0x03	; 3
    116a:	60 e0       	ldi	r22, 0x00	; 0
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	52 d3       	rcall	.+1700   	; 0x1814 <xQueueGenericCreate>
    1170:	90 93 23 08 	sts	0x0823, r25
    1174:	80 93 22 08 	sts	0x0822, r24
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	0c d4       	rcall	.+2072   	; 0x1994 <xQueueCreateMutex>
    117c:	90 93 1f 08 	sts	0x081F, r25
    1180:	80 93 1e 08 	sts	0x081E, r24
    1184:	08 95       	ret

00001186 <myUSART_transmitUSART0_c>:
    1186:	cf 93       	push	r28
    1188:	c8 2f       	mov	r28, r24
    118a:	20 e0       	ldi	r18, 0x00	; 0
    118c:	4f ef       	ldi	r20, 0xFF	; 255
    118e:	5f ef       	ldi	r21, 0xFF	; 255
    1190:	60 e0       	ldi	r22, 0x00	; 0
    1192:	70 e0       	ldi	r23, 0x00	; 0
    1194:	80 91 20 08 	lds	r24, 0x0820
    1198:	90 91 21 08 	lds	r25, 0x0821
    119c:	60 d4       	rcall	.+2240   	; 0x1a5e <xQueueGenericReceive>
    119e:	8b e3       	ldi	r24, 0x3B	; 59
    11a0:	99 e0       	ldi	r25, 0x09	; 9
    11a2:	4a d5       	rcall	.+2708   	; 0x1c38 <ringBufferFull>
    11a4:	81 11       	cpse	r24, r1
    11a6:	fb cf       	rjmp	.-10     	; 0x119e <myUSART_transmitUSART0_c+0x18>
    11a8:	6c 2f       	mov	r22, r28
    11aa:	8b e3       	ldi	r24, 0x3B	; 59
    11ac:	99 e0       	ldi	r25, 0x09	; 9
    11ae:	2d d5       	rcall	.+2650   	; 0x1c0a <ringBufferPush>
    11b0:	e1 ec       	ldi	r30, 0xC1	; 193
    11b2:	f0 e0       	ldi	r31, 0x00	; 0
    11b4:	80 81       	ld	r24, Z
    11b6:	80 62       	ori	r24, 0x20	; 32
    11b8:	80 83       	st	Z, r24
    11ba:	e0 ec       	ldi	r30, 0xC0	; 192
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	80 64       	ori	r24, 0x40	; 64
    11c2:	80 83       	st	Z, r24
    11c4:	cf 91       	pop	r28
    11c6:	08 95       	ret

000011c8 <myUSART_transmitUSART1_c>:
    11c8:	cf 93       	push	r28
    11ca:	c8 2f       	mov	r28, r24
    11cc:	20 e0       	ldi	r18, 0x00	; 0
    11ce:	4f ef       	ldi	r20, 0xFF	; 255
    11d0:	5f ef       	ldi	r21, 0xFF	; 255
    11d2:	60 e0       	ldi	r22, 0x00	; 0
    11d4:	70 e0       	ldi	r23, 0x00	; 0
    11d6:	80 91 1e 08 	lds	r24, 0x081E
    11da:	90 91 1f 08 	lds	r25, 0x081F
    11de:	3f d4       	rcall	.+2174   	; 0x1a5e <xQueueGenericReceive>
    11e0:	86 e3       	ldi	r24, 0x36	; 54
    11e2:	99 e0       	ldi	r25, 0x09	; 9
    11e4:	29 d5       	rcall	.+2642   	; 0x1c38 <ringBufferFull>
    11e6:	81 11       	cpse	r24, r1
    11e8:	fb cf       	rjmp	.-10     	; 0x11e0 <myUSART_transmitUSART1_c+0x18>
    11ea:	6c 2f       	mov	r22, r28
    11ec:	86 e3       	ldi	r24, 0x36	; 54
    11ee:	99 e0       	ldi	r25, 0x09	; 9
    11f0:	0c d5       	rcall	.+2584   	; 0x1c0a <ringBufferPush>
    11f2:	e9 ec       	ldi	r30, 0xC9	; 201
    11f4:	f0 e0       	ldi	r31, 0x00	; 0
    11f6:	80 81       	ld	r24, Z
    11f8:	80 62       	ori	r24, 0x20	; 32
    11fa:	80 83       	st	Z, r24
    11fc:	e8 ec       	ldi	r30, 0xC8	; 200
    11fe:	f0 e0       	ldi	r31, 0x00	; 0
    1200:	80 81       	ld	r24, Z
    1202:	80 64       	ori	r24, 0x40	; 64
    1204:	80 83       	st	Z, r24
    1206:	cf 91       	pop	r28
    1208:	08 95       	ret

0000120a <myUSART_transmitUSART1>:
    120a:	cf 93       	push	r28
    120c:	df 93       	push	r29
    120e:	ec 01       	movw	r28, r24
    1210:	88 81       	ld	r24, Y
    1212:	88 23       	and	r24, r24
    1214:	29 f0       	breq	.+10     	; 0x1220 <myUSART_transmitUSART1+0x16>
    1216:	21 96       	adiw	r28, 0x01	; 1
    1218:	d7 df       	rcall	.-82     	; 0x11c8 <myUSART_transmitUSART1_c>
    121a:	89 91       	ld	r24, Y+
    121c:	81 11       	cpse	r24, r1
    121e:	fc cf       	rjmp	.-8      	; 0x1218 <myUSART_transmitUSART1+0xe>
    1220:	df 91       	pop	r29
    1222:	cf 91       	pop	r28
    1224:	08 95       	ret

00001226 <myUSART_transmitUSART0>:
    1226:	cf 93       	push	r28
    1228:	df 93       	push	r29
    122a:	ec 01       	movw	r28, r24
    122c:	88 81       	ld	r24, Y
    122e:	88 23       	and	r24, r24
    1230:	29 f0       	breq	.+10     	; 0x123c <myUSART_transmitUSART0+0x16>
    1232:	21 96       	adiw	r28, 0x01	; 1
    1234:	a8 df       	rcall	.-176    	; 0x1186 <myUSART_transmitUSART0_c>
    1236:	89 91       	ld	r24, Y+
    1238:	81 11       	cpse	r24, r1
    123a:	fc cf       	rjmp	.-8      	; 0x1234 <myUSART_transmitUSART0+0xe>
    123c:	df 91       	pop	r29
    123e:	cf 91       	pop	r28
    1240:	08 95       	ret

00001242 <myUSART_receiveUSART1>:
    1242:	cf 93       	push	r28
    1244:	20 e0       	ldi	r18, 0x00	; 0
    1246:	4f ef       	ldi	r20, 0xFF	; 255
    1248:	5f ef       	ldi	r21, 0xFF	; 255
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	70 e0       	ldi	r23, 0x00	; 0
    124e:	80 91 26 08 	lds	r24, 0x0826
    1252:	90 91 27 08 	lds	r25, 0x0827
    1256:	03 d4       	rcall	.+2054   	; 0x1a5e <xQueueGenericReceive>
    1258:	80 e4       	ldi	r24, 0x40	; 64
    125a:	99 e0       	ldi	r25, 0x09	; 9
    125c:	c4 d4       	rcall	.+2440   	; 0x1be6 <ringBufferPop>
    125e:	c8 2f       	mov	r28, r24
    1260:	80 e4       	ldi	r24, 0x40	; 64
    1262:	99 e0       	ldi	r25, 0x09	; 9
    1264:	f0 d4       	rcall	.+2528   	; 0x1c46 <ringBufferNotEmpty>
    1266:	88 23       	and	r24, r24
    1268:	51 f0       	breq	.+20     	; 0x127e <myUSART_receiveUSART1+0x3c>
    126a:	20 e0       	ldi	r18, 0x00	; 0
    126c:	40 e0       	ldi	r20, 0x00	; 0
    126e:	50 e0       	ldi	r21, 0x00	; 0
    1270:	60 e0       	ldi	r22, 0x00	; 0
    1272:	70 e0       	ldi	r23, 0x00	; 0
    1274:	80 91 26 08 	lds	r24, 0x0826
    1278:	90 91 27 08 	lds	r25, 0x0827
    127c:	f8 d2       	rcall	.+1520   	; 0x186e <xQueueGenericSend>
    127e:	8c 2f       	mov	r24, r28
    1280:	cf 91       	pop	r28
    1282:	08 95       	ret

00001284 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    1284:	86 e1       	ldi	r24, 0x16	; 22
    1286:	a0 df       	rcall	.-192    	; 0x11c8 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	4a ef       	ldi	r20, 0xFA	; 250
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	60 e0       	ldi	r22, 0x00	; 0
    1290:	70 e0       	ldi	r23, 0x00	; 0
    1292:	80 91 22 08 	lds	r24, 0x0822
    1296:	90 91 23 08 	lds	r25, 0x0823
    129a:	e1 d3       	rcall	.+1986   	; 0x1a5e <xQueueGenericReceive>
    129c:	81 30       	cpi	r24, 0x01	; 1
    129e:	21 f4       	brne	.+8      	; 0x12a8 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    12a0:	82 e0       	ldi	r24, 0x02	; 2
    12a2:	92 df       	rcall	.-220    	; 0x11c8 <myUSART_transmitUSART1_c>
		return 1;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	08 95       	ret
	}
	else
	{
		return 0;
    12a8:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    12aa:	08 95       	ret

000012ac <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    12ac:	20 e0       	ldi	r18, 0x00	; 0
    12ae:	40 e0       	ldi	r20, 0x00	; 0
    12b0:	50 e0       	ldi	r21, 0x00	; 0
    12b2:	60 e0       	ldi	r22, 0x00	; 0
    12b4:	70 e0       	ldi	r23, 0x00	; 0
    12b6:	80 91 22 08 	lds	r24, 0x0822
    12ba:	90 91 23 08 	lds	r25, 0x0823
    12be:	d7 c2       	rjmp	.+1454   	; 0x186e <xQueueGenericSend>
    12c0:	08 95       	ret

000012c2 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    12c2:	91 e0       	ldi	r25, 0x01	; 1
    12c4:	85 30       	cpi	r24, 0x05	; 5
    12c6:	09 f0       	breq	.+2      	; 0x12ca <myUSART_receiveHandShakeAck+0x8>
    12c8:	90 e0       	ldi	r25, 0x00	; 0
}
    12ca:	89 2f       	mov	r24, r25
    12cc:	08 95       	ret

000012ce <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    12ce:	91 e0       	ldi	r25, 0x01	; 1
    12d0:	86 31       	cpi	r24, 0x16	; 22
    12d2:	09 f0       	breq	.+2      	; 0x12d6 <myUSART_receiveHandShakeStart+0x8>
    12d4:	90 e0       	ldi	r25, 0x00	; 0
}
    12d6:	89 2f       	mov	r24, r25
    12d8:	08 95       	ret

000012da <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    12da:	91 e0       	ldi	r25, 0x01	; 1
    12dc:	82 30       	cpi	r24, 0x02	; 2
    12de:	09 f0       	breq	.+2      	; 0x12e2 <myUSART_receiveHandShakeFin+0x8>
    12e0:	90 e0       	ldi	r25, 0x00	; 0
}
    12e2:	89 2f       	mov	r24, r25
    12e4:	08 95       	ret

000012e6 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    12e6:	91 e0       	ldi	r25, 0x01	; 1
    12e8:	86 30       	cpi	r24, 0x06	; 6
    12ea:	09 f0       	breq	.+2      	; 0x12ee <myUSART_receiveMessageACK+0x8>
    12ec:	90 e0       	ldi	r25, 0x00	; 0
}
    12ee:	89 2f       	mov	r24, r25
    12f0:	08 95       	ret

000012f2 <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    12f2:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    12f4:	20 e0       	ldi	r18, 0x00	; 0
    12f6:	4f ef       	ldi	r20, 0xFF	; 255
    12f8:	5f ef       	ldi	r21, 0xFF	; 255
    12fa:	60 e0       	ldi	r22, 0x00	; 0
    12fc:	70 e0       	ldi	r23, 0x00	; 0
    12fe:	80 91 26 08 	lds	r24, 0x0826
    1302:	90 91 27 08 	lds	r25, 0x0827
    1306:	ab d3       	rcall	.+1878   	; 0x1a5e <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    1308:	80 e4       	ldi	r24, 0x40	; 64
    130a:	99 e0       	ldi	r25, 0x09	; 9
    130c:	62 d4       	rcall	.+2244   	; 0x1bd2 <ringBufferPeek>
    130e:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    1310:	80 e4       	ldi	r24, 0x40	; 64
    1312:	99 e0       	ldi	r25, 0x09	; 9
    1314:	98 d4       	rcall	.+2352   	; 0x1c46 <ringBufferNotEmpty>
    1316:	88 23       	and	r24, r24
    1318:	51 f0       	breq	.+20     	; 0x132e <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    131a:	20 e0       	ldi	r18, 0x00	; 0
    131c:	40 e0       	ldi	r20, 0x00	; 0
    131e:	50 e0       	ldi	r21, 0x00	; 0
    1320:	60 e0       	ldi	r22, 0x00	; 0
    1322:	70 e0       	ldi	r23, 0x00	; 0
    1324:	80 91 26 08 	lds	r24, 0x0826
    1328:	90 91 27 08 	lds	r25, 0x0827
    132c:	a0 d2       	rcall	.+1344   	; 0x186e <xQueueGenericSend>
	}
	
	return data;
    132e:	8c 2f       	mov	r24, r28
    1330:	cf 91       	pop	r28
    1332:	08 95       	ret

00001334 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1334:	31 e1       	ldi	r19, 0x11	; 17
    1336:	fc 01       	movw	r30, r24
    1338:	30 83       	st	Z, r19
    133a:	31 97       	sbiw	r30, 0x01	; 1
    133c:	22 e2       	ldi	r18, 0x22	; 34
    133e:	20 83       	st	Z, r18
    1340:	31 97       	sbiw	r30, 0x01	; 1
    1342:	a3 e3       	ldi	r26, 0x33	; 51
    1344:	a0 83       	st	Z, r26
    1346:	31 97       	sbiw	r30, 0x01	; 1
    1348:	60 83       	st	Z, r22
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	70 83       	st	Z, r23
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	10 82       	st	Z, r1
    1352:	31 97       	sbiw	r30, 0x01	; 1
    1354:	10 82       	st	Z, r1
    1356:	31 97       	sbiw	r30, 0x01	; 1
    1358:	60 e8       	ldi	r22, 0x80	; 128
    135a:	60 83       	st	Z, r22
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	10 82       	st	Z, r1
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	10 82       	st	Z, r1
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	10 82       	st	Z, r1
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	62 e0       	ldi	r22, 0x02	; 2
    136c:	60 83       	st	Z, r22
    136e:	31 97       	sbiw	r30, 0x01	; 1
    1370:	63 e0       	ldi	r22, 0x03	; 3
    1372:	60 83       	st	Z, r22
    1374:	31 97       	sbiw	r30, 0x01	; 1
    1376:	64 e0       	ldi	r22, 0x04	; 4
    1378:	60 83       	st	Z, r22
    137a:	31 97       	sbiw	r30, 0x01	; 1
    137c:	65 e0       	ldi	r22, 0x05	; 5
    137e:	60 83       	st	Z, r22
    1380:	31 97       	sbiw	r30, 0x01	; 1
    1382:	66 e0       	ldi	r22, 0x06	; 6
    1384:	60 83       	st	Z, r22
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	67 e0       	ldi	r22, 0x07	; 7
    138a:	60 83       	st	Z, r22
    138c:	31 97       	sbiw	r30, 0x01	; 1
    138e:	68 e0       	ldi	r22, 0x08	; 8
    1390:	60 83       	st	Z, r22
    1392:	31 97       	sbiw	r30, 0x01	; 1
    1394:	69 e0       	ldi	r22, 0x09	; 9
    1396:	60 83       	st	Z, r22
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	60 e1       	ldi	r22, 0x10	; 16
    139c:	60 83       	st	Z, r22
    139e:	31 97       	sbiw	r30, 0x01	; 1
    13a0:	30 83       	st	Z, r19
    13a2:	31 97       	sbiw	r30, 0x01	; 1
    13a4:	32 e1       	ldi	r19, 0x12	; 18
    13a6:	30 83       	st	Z, r19
    13a8:	31 97       	sbiw	r30, 0x01	; 1
    13aa:	33 e1       	ldi	r19, 0x13	; 19
    13ac:	30 83       	st	Z, r19
    13ae:	31 97       	sbiw	r30, 0x01	; 1
    13b0:	34 e1       	ldi	r19, 0x14	; 20
    13b2:	30 83       	st	Z, r19
    13b4:	31 97       	sbiw	r30, 0x01	; 1
    13b6:	35 e1       	ldi	r19, 0x15	; 21
    13b8:	30 83       	st	Z, r19
    13ba:	31 97       	sbiw	r30, 0x01	; 1
    13bc:	36 e1       	ldi	r19, 0x16	; 22
    13be:	30 83       	st	Z, r19
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	37 e1       	ldi	r19, 0x17	; 23
    13c4:	30 83       	st	Z, r19
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	38 e1       	ldi	r19, 0x18	; 24
    13ca:	30 83       	st	Z, r19
    13cc:	31 97       	sbiw	r30, 0x01	; 1
    13ce:	39 e1       	ldi	r19, 0x19	; 25
    13d0:	30 83       	st	Z, r19
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	30 e2       	ldi	r19, 0x20	; 32
    13d6:	30 83       	st	Z, r19
    13d8:	31 97       	sbiw	r30, 0x01	; 1
    13da:	31 e2       	ldi	r19, 0x21	; 33
    13dc:	30 83       	st	Z, r19
    13de:	31 97       	sbiw	r30, 0x01	; 1
    13e0:	20 83       	st	Z, r18
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	23 e2       	ldi	r18, 0x23	; 35
    13e6:	20 83       	st	Z, r18
    13e8:	31 97       	sbiw	r30, 0x01	; 1
    13ea:	40 83       	st	Z, r20
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	50 83       	st	Z, r21
    13f0:	31 97       	sbiw	r30, 0x01	; 1
    13f2:	26 e2       	ldi	r18, 0x26	; 38
    13f4:	20 83       	st	Z, r18
    13f6:	31 97       	sbiw	r30, 0x01	; 1
    13f8:	27 e2       	ldi	r18, 0x27	; 39
    13fa:	20 83       	st	Z, r18
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	28 e2       	ldi	r18, 0x28	; 40
    1400:	20 83       	st	Z, r18
    1402:	31 97       	sbiw	r30, 0x01	; 1
    1404:	29 e2       	ldi	r18, 0x29	; 41
    1406:	20 83       	st	Z, r18
    1408:	31 97       	sbiw	r30, 0x01	; 1
    140a:	20 e3       	ldi	r18, 0x30	; 48
    140c:	20 83       	st	Z, r18
    140e:	31 97       	sbiw	r30, 0x01	; 1
    1410:	21 e3       	ldi	r18, 0x31	; 49
    1412:	20 83       	st	Z, r18
    1414:	89 97       	sbiw	r24, 0x29	; 41
    1416:	08 95       	ret

00001418 <xPortStartScheduler>:
    1418:	82 e0       	ldi	r24, 0x02	; 2
    141a:	84 bd       	out	0x24, r24	; 36
    141c:	16 bc       	out	0x26, r1	; 38
    141e:	80 e3       	ldi	r24, 0x30	; 48
    1420:	87 bd       	out	0x27, r24	; 39
    1422:	ee e6       	ldi	r30, 0x6E	; 110
    1424:	f0 e0       	ldi	r31, 0x00	; 0
    1426:	80 81       	ld	r24, Z
    1428:	82 60       	ori	r24, 0x02	; 2
    142a:	80 83       	st	Z, r24
    142c:	83 e0       	ldi	r24, 0x03	; 3
    142e:	85 bd       	out	0x25, r24	; 37
    1430:	a0 91 91 08 	lds	r26, 0x0891
    1434:	b0 91 92 08 	lds	r27, 0x0892
    1438:	cd 91       	ld	r28, X+
    143a:	cd bf       	out	0x3d, r28	; 61
    143c:	dd 91       	ld	r29, X+
    143e:	de bf       	out	0x3e, r29	; 62
    1440:	ff 91       	pop	r31
    1442:	ef 91       	pop	r30
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	bf 91       	pop	r27
    144a:	af 91       	pop	r26
    144c:	9f 91       	pop	r25
    144e:	8f 91       	pop	r24
    1450:	7f 91       	pop	r23
    1452:	6f 91       	pop	r22
    1454:	5f 91       	pop	r21
    1456:	4f 91       	pop	r20
    1458:	3f 91       	pop	r19
    145a:	2f 91       	pop	r18
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	df 90       	pop	r13
    1466:	cf 90       	pop	r12
    1468:	bf 90       	pop	r11
    146a:	af 90       	pop	r10
    146c:	9f 90       	pop	r9
    146e:	8f 90       	pop	r8
    1470:	7f 90       	pop	r7
    1472:	6f 90       	pop	r6
    1474:	5f 90       	pop	r5
    1476:	4f 90       	pop	r4
    1478:	3f 90       	pop	r3
    147a:	2f 90       	pop	r2
    147c:	1f 90       	pop	r1
    147e:	0f 90       	pop	r0
    1480:	0c be       	out	0x3c, r0	; 60
    1482:	0f 90       	pop	r0
    1484:	0b be       	out	0x3b, r0	; 59
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63
    148a:	0f 90       	pop	r0
    148c:	08 95       	ret
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	08 95       	ret

00001492 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1492:	0f 92       	push	r0
    1494:	0f b6       	in	r0, 0x3f	; 63
    1496:	f8 94       	cli
    1498:	0f 92       	push	r0
    149a:	0b b6       	in	r0, 0x3b	; 59
    149c:	0f 92       	push	r0
    149e:	0c b6       	in	r0, 0x3c	; 60
    14a0:	0f 92       	push	r0
    14a2:	1f 92       	push	r1
    14a4:	11 24       	eor	r1, r1
    14a6:	2f 92       	push	r2
    14a8:	3f 92       	push	r3
    14aa:	4f 92       	push	r4
    14ac:	5f 92       	push	r5
    14ae:	6f 92       	push	r6
    14b0:	7f 92       	push	r7
    14b2:	8f 92       	push	r8
    14b4:	9f 92       	push	r9
    14b6:	af 92       	push	r10
    14b8:	bf 92       	push	r11
    14ba:	cf 92       	push	r12
    14bc:	df 92       	push	r13
    14be:	ef 92       	push	r14
    14c0:	ff 92       	push	r15
    14c2:	0f 93       	push	r16
    14c4:	1f 93       	push	r17
    14c6:	2f 93       	push	r18
    14c8:	3f 93       	push	r19
    14ca:	4f 93       	push	r20
    14cc:	5f 93       	push	r21
    14ce:	6f 93       	push	r22
    14d0:	7f 93       	push	r23
    14d2:	8f 93       	push	r24
    14d4:	9f 93       	push	r25
    14d6:	af 93       	push	r26
    14d8:	bf 93       	push	r27
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	ef 93       	push	r30
    14e0:	ff 93       	push	r31
    14e2:	a0 91 91 08 	lds	r26, 0x0891
    14e6:	b0 91 92 08 	lds	r27, 0x0892
    14ea:	0d b6       	in	r0, 0x3d	; 61
    14ec:	0d 92       	st	X+, r0
    14ee:	0e b6       	in	r0, 0x3e	; 62
    14f0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14f2:	5b d7       	rcall	.+3766   	; 0x23aa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14f4:	a0 91 91 08 	lds	r26, 0x0891
    14f8:	b0 91 92 08 	lds	r27, 0x0892
    14fc:	cd 91       	ld	r28, X+
    14fe:	cd bf       	out	0x3d, r28	; 61
    1500:	dd 91       	ld	r29, X+
    1502:	de bf       	out	0x3e, r29	; 62
    1504:	ff 91       	pop	r31
    1506:	ef 91       	pop	r30
    1508:	df 91       	pop	r29
    150a:	cf 91       	pop	r28
    150c:	bf 91       	pop	r27
    150e:	af 91       	pop	r26
    1510:	9f 91       	pop	r25
    1512:	8f 91       	pop	r24
    1514:	7f 91       	pop	r23
    1516:	6f 91       	pop	r22
    1518:	5f 91       	pop	r21
    151a:	4f 91       	pop	r20
    151c:	3f 91       	pop	r19
    151e:	2f 91       	pop	r18
    1520:	1f 91       	pop	r17
    1522:	0f 91       	pop	r16
    1524:	ff 90       	pop	r15
    1526:	ef 90       	pop	r14
    1528:	df 90       	pop	r13
    152a:	cf 90       	pop	r12
    152c:	bf 90       	pop	r11
    152e:	af 90       	pop	r10
    1530:	9f 90       	pop	r9
    1532:	8f 90       	pop	r8
    1534:	7f 90       	pop	r7
    1536:	6f 90       	pop	r6
    1538:	5f 90       	pop	r5
    153a:	4f 90       	pop	r4
    153c:	3f 90       	pop	r3
    153e:	2f 90       	pop	r2
    1540:	1f 90       	pop	r1
    1542:	0f 90       	pop	r0
    1544:	0c be       	out	0x3c, r0	; 60
    1546:	0f 90       	pop	r0
    1548:	0b be       	out	0x3b, r0	; 59
    154a:	0f 90       	pop	r0
    154c:	0f be       	out	0x3f, r0	; 63
    154e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1550:	08 95       	ret

00001552 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1552:	0f 92       	push	r0
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	f8 94       	cli
    1558:	0f 92       	push	r0
    155a:	0b b6       	in	r0, 0x3b	; 59
    155c:	0f 92       	push	r0
    155e:	0c b6       	in	r0, 0x3c	; 60
    1560:	0f 92       	push	r0
    1562:	1f 92       	push	r1
    1564:	11 24       	eor	r1, r1
    1566:	2f 92       	push	r2
    1568:	3f 92       	push	r3
    156a:	4f 92       	push	r4
    156c:	5f 92       	push	r5
    156e:	6f 92       	push	r6
    1570:	7f 92       	push	r7
    1572:	8f 92       	push	r8
    1574:	9f 92       	push	r9
    1576:	af 92       	push	r10
    1578:	bf 92       	push	r11
    157a:	cf 92       	push	r12
    157c:	df 92       	push	r13
    157e:	ef 92       	push	r14
    1580:	ff 92       	push	r15
    1582:	0f 93       	push	r16
    1584:	1f 93       	push	r17
    1586:	2f 93       	push	r18
    1588:	3f 93       	push	r19
    158a:	4f 93       	push	r20
    158c:	5f 93       	push	r21
    158e:	6f 93       	push	r22
    1590:	7f 93       	push	r23
    1592:	8f 93       	push	r24
    1594:	9f 93       	push	r25
    1596:	af 93       	push	r26
    1598:	bf 93       	push	r27
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	ef 93       	push	r30
    15a0:	ff 93       	push	r31
    15a2:	a0 91 91 08 	lds	r26, 0x0891
    15a6:	b0 91 92 08 	lds	r27, 0x0892
    15aa:	0d b6       	in	r0, 0x3d	; 61
    15ac:	0d 92       	st	X+, r0
    15ae:	0e b6       	in	r0, 0x3e	; 62
    15b0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    15b2:	45 d5       	rcall	.+2698   	; 0x203e <xTaskIncrementTick>
    15b4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    15b6:	f9 d6       	rcall	.+3570   	; 0x23aa <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    15b8:	a0 91 91 08 	lds	r26, 0x0891
    15bc:	b0 91 92 08 	lds	r27, 0x0892
    15c0:	cd 91       	ld	r28, X+
    15c2:	cd bf       	out	0x3d, r28	; 61
    15c4:	dd 91       	ld	r29, X+
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	ff 91       	pop	r31
    15ca:	ef 91       	pop	r30
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	bf 91       	pop	r27
    15d2:	af 91       	pop	r26
    15d4:	9f 91       	pop	r25
    15d6:	8f 91       	pop	r24
    15d8:	7f 91       	pop	r23
    15da:	6f 91       	pop	r22
    15dc:	5f 91       	pop	r21
    15de:	4f 91       	pop	r20
    15e0:	3f 91       	pop	r19
    15e2:	2f 91       	pop	r18
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	ff 90       	pop	r15
    15ea:	ef 90       	pop	r14
    15ec:	df 90       	pop	r13
    15ee:	cf 90       	pop	r12
    15f0:	bf 90       	pop	r11
    15f2:	af 90       	pop	r10
    15f4:	9f 90       	pop	r9
    15f6:	8f 90       	pop	r8
    15f8:	7f 90       	pop	r7
    15fa:	6f 90       	pop	r6
    15fc:	5f 90       	pop	r5
    15fe:	4f 90       	pop	r4
    1600:	3f 90       	pop	r3
    1602:	2f 90       	pop	r2
    1604:	1f 90       	pop	r1
    1606:	0f 90       	pop	r0
    1608:	0c be       	out	0x3c, r0	; 60
    160a:	0f 90       	pop	r0
    160c:	0b be       	out	0x3b, r0	; 59
    160e:	0f 90       	pop	r0
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1614:	08 95       	ret

00001616 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1616:	9d df       	rcall	.-198    	; 0x1552 <vPortYieldFromTick>
		 asm volatile ("reti");
    1618:	18 95       	reti

0000161a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    161a:	1f 93       	push	r17
    161c:	cf 93       	push	r28
    161e:	df 93       	push	r29
    1620:	ec 01       	movw	r28, r24
    1622:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1624:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1626:	81 11       	cpse	r24, r1
    1628:	0c c0       	rjmp	.+24     	; 0x1642 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    162a:	88 81       	ld	r24, Y
    162c:	99 81       	ldd	r25, Y+1	; 0x01
    162e:	89 2b       	or	r24, r25
    1630:	09 f0       	breq	.+2      	; 0x1634 <prvCopyDataToQueue+0x1a>
    1632:	47 c0       	rjmp	.+142    	; 0x16c2 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1634:	8a 81       	ldd	r24, Y+2	; 0x02
    1636:	9b 81       	ldd	r25, Y+3	; 0x03
    1638:	0e 94 98 13 	call	0x2730	; 0x2730 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    163c:	1b 82       	std	Y+3, r1	; 0x03
    163e:	1a 82       	std	Y+2, r1	; 0x02
    1640:	47 c0       	rjmp	.+142    	; 0x16d0 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1642:	41 11       	cpse	r20, r1
    1644:	18 c0       	rjmp	.+48     	; 0x1676 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1646:	48 2f       	mov	r20, r24
    1648:	50 e0       	ldi	r21, 0x00	; 0
    164a:	8c 81       	ldd	r24, Y+4	; 0x04
    164c:	9d 81       	ldd	r25, Y+5	; 0x05
    164e:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1652:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1654:	8c 81       	ldd	r24, Y+4	; 0x04
    1656:	9d 81       	ldd	r25, Y+5	; 0x05
    1658:	82 0f       	add	r24, r18
    165a:	91 1d       	adc	r25, r1
    165c:	9d 83       	std	Y+5, r25	; 0x05
    165e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1660:	2a 81       	ldd	r18, Y+2	; 0x02
    1662:	3b 81       	ldd	r19, Y+3	; 0x03
    1664:	82 17       	cp	r24, r18
    1666:	93 07       	cpc	r25, r19
    1668:	70 f1       	brcs	.+92     	; 0x16c6 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    166a:	88 81       	ld	r24, Y
    166c:	99 81       	ldd	r25, Y+1	; 0x01
    166e:	9d 83       	std	Y+5, r25	; 0x05
    1670:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	2d c0       	rjmp	.+90     	; 0x16d0 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1676:	48 2f       	mov	r20, r24
    1678:	50 e0       	ldi	r21, 0x00	; 0
    167a:	8e 81       	ldd	r24, Y+6	; 0x06
    167c:	9f 81       	ldd	r25, Y+7	; 0x07
    167e:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1682:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1684:	30 e0       	ldi	r19, 0x00	; 0
    1686:	31 95       	neg	r19
    1688:	21 95       	neg	r18
    168a:	31 09       	sbc	r19, r1
    168c:	8e 81       	ldd	r24, Y+6	; 0x06
    168e:	9f 81       	ldd	r25, Y+7	; 0x07
    1690:	82 0f       	add	r24, r18
    1692:	93 1f       	adc	r25, r19
    1694:	9f 83       	std	Y+7, r25	; 0x07
    1696:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1698:	68 81       	ld	r22, Y
    169a:	79 81       	ldd	r23, Y+1	; 0x01
    169c:	86 17       	cp	r24, r22
    169e:	97 07       	cpc	r25, r23
    16a0:	30 f4       	brcc	.+12     	; 0x16ae <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16a2:	8a 81       	ldd	r24, Y+2	; 0x02
    16a4:	9b 81       	ldd	r25, Y+3	; 0x03
    16a6:	28 0f       	add	r18, r24
    16a8:	39 1f       	adc	r19, r25
    16aa:	3f 83       	std	Y+7, r19	; 0x07
    16ac:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    16ae:	12 30       	cpi	r17, 0x02	; 2
    16b0:	61 f4       	brne	.+24     	; 0x16ca <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    16b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16b4:	88 23       	and	r24, r24
    16b6:	59 f0       	breq	.+22     	; 0x16ce <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    16b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16ba:	81 50       	subi	r24, 0x01	; 1
    16bc:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16be:	80 e0       	ldi	r24, 0x00	; 0
    16c0:	07 c0       	rjmp	.+14     	; 0x16d0 <prvCopyDataToQueue+0xb6>
    16c2:	80 e0       	ldi	r24, 0x00	; 0
    16c4:	05 c0       	rjmp	.+10     	; 0x16d0 <prvCopyDataToQueue+0xb6>
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	03 c0       	rjmp	.+6      	; 0x16d0 <prvCopyDataToQueue+0xb6>
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	01 c0       	rjmp	.+2      	; 0x16d0 <prvCopyDataToQueue+0xb6>
    16ce:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16d0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    16d2:	9f 5f       	subi	r25, 0xFF	; 255
    16d4:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	08 95       	ret

000016de <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    16de:	fc 01       	movw	r30, r24
    16e0:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    16e2:	44 8d       	ldd	r20, Z+28	; 0x1c
    16e4:	44 23       	and	r20, r20
    16e6:	a1 f0       	breq	.+40     	; 0x1710 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    16e8:	50 e0       	ldi	r21, 0x00	; 0
    16ea:	26 81       	ldd	r18, Z+6	; 0x06
    16ec:	37 81       	ldd	r19, Z+7	; 0x07
    16ee:	24 0f       	add	r18, r20
    16f0:	35 1f       	adc	r19, r21
    16f2:	37 83       	std	Z+7, r19	; 0x07
    16f4:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    16f6:	62 81       	ldd	r22, Z+2	; 0x02
    16f8:	73 81       	ldd	r23, Z+3	; 0x03
    16fa:	26 17       	cp	r18, r22
    16fc:	37 07       	cpc	r19, r23
    16fe:	20 f0       	brcs	.+8      	; 0x1708 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1700:	20 81       	ld	r18, Z
    1702:	31 81       	ldd	r19, Z+1	; 0x01
    1704:	37 83       	std	Z+7, r19	; 0x07
    1706:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1708:	66 81       	ldd	r22, Z+6	; 0x06
    170a:	77 81       	ldd	r23, Z+7	; 0x07
    170c:	0c 94 64 17 	jmp	0x2ec8	; 0x2ec8 <memcpy>
    1710:	08 95       	ret

00001712 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1712:	0f 93       	push	r16
    1714:	1f 93       	push	r17
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1722:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1724:	18 16       	cp	r1, r24
    1726:	a4 f4       	brge	.+40     	; 0x1750 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1728:	89 89       	ldd	r24, Y+17	; 0x11
    172a:	88 23       	and	r24, r24
    172c:	89 f0       	breq	.+34     	; 0x1750 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    172e:	8e 01       	movw	r16, r28
    1730:	0f 5e       	subi	r16, 0xEF	; 239
    1732:	1f 4f       	sbci	r17, 0xFF	; 255
    1734:	03 c0       	rjmp	.+6      	; 0x173c <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1736:	89 89       	ldd	r24, Y+17	; 0x11
    1738:	88 23       	and	r24, r24
    173a:	51 f0       	breq	.+20     	; 0x1750 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    173c:	c8 01       	movw	r24, r16
    173e:	0b d7       	rcall	.+3606   	; 0x2556 <xTaskRemoveFromEventList>
    1740:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1742:	94 d7       	rcall	.+3880   	; 0x266c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1744:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1746:	81 50       	subi	r24, 0x01	; 1
    1748:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    174a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    174c:	18 16       	cp	r1, r24
    174e:	9c f3       	brlt	.-26     	; 0x1736 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1750:	8f ef       	ldi	r24, 0xFF	; 255
    1752:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1758:	0f b6       	in	r0, 0x3f	; 63
    175a:	f8 94       	cli
    175c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    175e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1760:	18 16       	cp	r1, r24
    1762:	a4 f4       	brge	.+40     	; 0x178c <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1764:	88 85       	ldd	r24, Y+8	; 0x08
    1766:	88 23       	and	r24, r24
    1768:	89 f0       	breq	.+34     	; 0x178c <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    176a:	8e 01       	movw	r16, r28
    176c:	08 5f       	subi	r16, 0xF8	; 248
    176e:	1f 4f       	sbci	r17, 0xFF	; 255
    1770:	03 c0       	rjmp	.+6      	; 0x1778 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1772:	88 85       	ldd	r24, Y+8	; 0x08
    1774:	88 23       	and	r24, r24
    1776:	51 f0       	breq	.+20     	; 0x178c <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1778:	c8 01       	movw	r24, r16
    177a:	ed d6       	rcall	.+3546   	; 0x2556 <xTaskRemoveFromEventList>
    177c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    177e:	76 d7       	rcall	.+3820   	; 0x266c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1780:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1782:	81 50       	subi	r24, 0x01	; 1
    1784:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1786:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1788:	18 16       	cp	r1, r24
    178a:	9c f3       	brlt	.-26     	; 0x1772 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    178c:	8f ef       	ldi	r24, 0xFF	; 255
    178e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1790:	0f 90       	pop	r0
    1792:	0f be       	out	0x3f, r0	; 63
}
    1794:	df 91       	pop	r29
    1796:	cf 91       	pop	r28
    1798:	1f 91       	pop	r17
    179a:	0f 91       	pop	r16
    179c:	08 95       	ret

0000179e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    17aa:	88 81       	ld	r24, Y
    17ac:	99 81       	ldd	r25, Y+1	; 0x01
    17ae:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    17b4:	72 9f       	mul	r23, r18
    17b6:	a0 01       	movw	r20, r0
    17b8:	73 9f       	mul	r23, r19
    17ba:	50 0d       	add	r21, r0
    17bc:	11 24       	eor	r1, r1
    17be:	fc 01       	movw	r30, r24
    17c0:	e4 0f       	add	r30, r20
    17c2:	f5 1f       	adc	r31, r21
    17c4:	fb 83       	std	Y+3, r31	; 0x03
    17c6:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17c8:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17ca:	9d 83       	std	Y+5, r25	; 0x05
    17cc:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    17ce:	42 1b       	sub	r20, r18
    17d0:	53 0b       	sbc	r21, r19
    17d2:	84 0f       	add	r24, r20
    17d4:	95 1f       	adc	r25, r21
    17d6:	9f 83       	std	Y+7, r25	; 0x07
    17d8:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17da:	8f ef       	ldi	r24, 0xFF	; 255
    17dc:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17de:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17e0:	61 11       	cpse	r22, r1
    17e2:	0a c0       	rjmp	.+20     	; 0x17f8 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17e4:	88 85       	ldd	r24, Y+8	; 0x08
    17e6:	88 23       	and	r24, r24
    17e8:	79 f0       	breq	.+30     	; 0x1808 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17ea:	ce 01       	movw	r24, r28
    17ec:	08 96       	adiw	r24, 0x08	; 8
    17ee:	b3 d6       	rcall	.+3430   	; 0x2556 <xTaskRemoveFromEventList>
    17f0:	81 30       	cpi	r24, 0x01	; 1
    17f2:	51 f4       	brne	.+20     	; 0x1808 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    17f4:	4e de       	rcall	.-868    	; 0x1492 <vPortYield>
    17f6:	08 c0       	rjmp	.+16     	; 0x1808 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17f8:	ce 01       	movw	r24, r28
    17fa:	08 96       	adiw	r24, 0x08	; 8
    17fc:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1800:	ce 01       	movw	r24, r28
    1802:	41 96       	adiw	r24, 0x11	; 17
    1804:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1808:	0f 90       	pop	r0
    180a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	08 95       	ret

00001814 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	18 2f       	mov	r17, r24
    181e:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1820:	88 23       	and	r24, r24
    1822:	e9 f0       	breq	.+58     	; 0x185e <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1824:	8f e1       	ldi	r24, 0x1F	; 31
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	0e 94 13 03 	call	0x626	; 0x626 <pvPortMalloc>
    182c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    182e:	00 97       	sbiw	r24, 0x00	; 0
    1830:	c1 f0       	breq	.+48     	; 0x1862 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1832:	10 9f       	mul	r17, r16
    1834:	c0 01       	movw	r24, r0
    1836:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1838:	01 96       	adiw	r24, 0x01	; 1
    183a:	0e 94 13 03 	call	0x626	; 0x626 <pvPortMalloc>
    183e:	99 83       	std	Y+1, r25	; 0x01
    1840:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1842:	89 2b       	or	r24, r25
    1844:	31 f0       	breq	.+12     	; 0x1852 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1846:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1848:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    184a:	61 e0       	ldi	r22, 0x01	; 1
    184c:	ce 01       	movw	r24, r28
    184e:	a7 df       	rcall	.-178    	; 0x179e <xQueueGenericReset>
    1850:	08 c0       	rjmp	.+16     	; 0x1862 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1852:	ce 01       	movw	r24, r28
    1854:	0e 94 48 03 	call	0x690	; 0x690 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1858:	c0 e0       	ldi	r28, 0x00	; 0
    185a:	d0 e0       	ldi	r29, 0x00	; 0
    185c:	02 c0       	rjmp	.+4      	; 0x1862 <xQueueGenericCreate+0x4e>
    185e:	c0 e0       	ldi	r28, 0x00	; 0
    1860:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1862:	ce 01       	movw	r24, r28
    1864:	df 91       	pop	r29
    1866:	cf 91       	pop	r28
    1868:	1f 91       	pop	r17
    186a:	0f 91       	pop	r16
    186c:	08 95       	ret

0000186e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    186e:	9f 92       	push	r9
    1870:	af 92       	push	r10
    1872:	bf 92       	push	r11
    1874:	cf 92       	push	r12
    1876:	df 92       	push	r13
    1878:	ef 92       	push	r14
    187a:	ff 92       	push	r15
    187c:	0f 93       	push	r16
    187e:	1f 93       	push	r17
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	00 d0       	rcall	.+0      	; 0x1886 <xQueueGenericSend+0x18>
    1886:	1f 92       	push	r1
    1888:	1f 92       	push	r1
    188a:	cd b7       	in	r28, 0x3d	; 61
    188c:	de b7       	in	r29, 0x3e	; 62
    188e:	8c 01       	movw	r16, r24
    1890:	6b 01       	movw	r12, r22
    1892:	5d 83       	std	Y+5, r21	; 0x05
    1894:	4c 83       	std	Y+4, r20	; 0x04
    1896:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1898:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    189a:	99 24       	eor	r9, r9
    189c:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    189e:	7c 01       	movw	r14, r24
    18a0:	88 e0       	ldi	r24, 0x08	; 8
    18a2:	e8 0e       	add	r14, r24
    18a4:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18a6:	0f b6       	in	r0, 0x3f	; 63
    18a8:	f8 94       	cli
    18aa:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18ac:	f8 01       	movw	r30, r16
    18ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    18b0:	83 8d       	ldd	r24, Z+27	; 0x1b
    18b2:	98 17       	cp	r25, r24
    18b4:	18 f0       	brcs	.+6      	; 0x18bc <xQueueGenericSend+0x4e>
    18b6:	f2 e0       	ldi	r31, 0x02	; 2
    18b8:	af 12       	cpse	r10, r31
    18ba:	15 c0       	rjmp	.+42     	; 0x18e6 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18bc:	4a 2d       	mov	r20, r10
    18be:	b6 01       	movw	r22, r12
    18c0:	c8 01       	movw	r24, r16
    18c2:	ab de       	rcall	.-682    	; 0x161a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18c4:	f8 01       	movw	r30, r16
    18c6:	91 89       	ldd	r25, Z+17	; 0x11
    18c8:	99 23       	and	r25, r25
    18ca:	39 f0       	breq	.+14     	; 0x18da <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18cc:	c8 01       	movw	r24, r16
    18ce:	41 96       	adiw	r24, 0x11	; 17
    18d0:	42 d6       	rcall	.+3204   	; 0x2556 <xTaskRemoveFromEventList>
    18d2:	81 30       	cpi	r24, 0x01	; 1
    18d4:	21 f4       	brne	.+8      	; 0x18de <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    18d6:	dd dd       	rcall	.-1094   	; 0x1492 <vPortYield>
    18d8:	02 c0       	rjmp	.+4      	; 0x18de <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    18da:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    18dc:	da dd       	rcall	.-1100   	; 0x1492 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18e2:	81 e0       	ldi	r24, 0x01	; 1
    18e4:	46 c0       	rjmp	.+140    	; 0x1972 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    18e6:	ec 81       	ldd	r30, Y+4	; 0x04
    18e8:	fd 81       	ldd	r31, Y+5	; 0x05
    18ea:	ef 2b       	or	r30, r31
    18ec:	21 f4       	brne	.+8      	; 0x18f6 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18ee:	0f 90       	pop	r0
    18f0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    18f2:	80 e0       	ldi	r24, 0x00	; 0
    18f4:	3e c0       	rjmp	.+124    	; 0x1972 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    18f6:	b1 10       	cpse	r11, r1
    18f8:	04 c0       	rjmp	.+8      	; 0x1902 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18fa:	ce 01       	movw	r24, r28
    18fc:	01 96       	adiw	r24, 0x01	; 1
    18fe:	73 d6       	rcall	.+3302   	; 0x25e6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1900:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1902:	0f 90       	pop	r0
    1904:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1906:	86 d3       	rcall	.+1804   	; 0x2014 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1908:	0f b6       	in	r0, 0x3f	; 63
    190a:	f8 94       	cli
    190c:	0f 92       	push	r0
    190e:	f8 01       	movw	r30, r16
    1910:	85 8d       	ldd	r24, Z+29	; 0x1d
    1912:	8f 3f       	cpi	r24, 0xFF	; 255
    1914:	09 f4       	brne	.+2      	; 0x1918 <xQueueGenericSend+0xaa>
    1916:	15 8e       	std	Z+29, r1	; 0x1d
    1918:	f8 01       	movw	r30, r16
    191a:	86 8d       	ldd	r24, Z+30	; 0x1e
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	09 f4       	brne	.+2      	; 0x1922 <xQueueGenericSend+0xb4>
    1920:	16 8e       	std	Z+30, r1	; 0x1e
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1926:	be 01       	movw	r22, r28
    1928:	6c 5f       	subi	r22, 0xFC	; 252
    192a:	7f 4f       	sbci	r23, 0xFF	; 255
    192c:	ce 01       	movw	r24, r28
    192e:	01 96       	adiw	r24, 0x01	; 1
    1930:	65 d6       	rcall	.+3274   	; 0x25fc <xTaskCheckForTimeOut>
    1932:	81 11       	cpse	r24, r1
    1934:	1a c0       	rjmp	.+52     	; 0x196a <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1936:	0f b6       	in	r0, 0x3f	; 63
    1938:	f8 94       	cli
    193a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    193c:	f8 01       	movw	r30, r16
    193e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1944:	f8 01       	movw	r30, r16
    1946:	83 8d       	ldd	r24, Z+27	; 0x1b
    1948:	98 13       	cpse	r25, r24
    194a:	0b c0       	rjmp	.+22     	; 0x1962 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    194c:	6c 81       	ldd	r22, Y+4	; 0x04
    194e:	7d 81       	ldd	r23, Y+5	; 0x05
    1950:	c7 01       	movw	r24, r14
    1952:	d6 d5       	rcall	.+2988   	; 0x2500 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1954:	c8 01       	movw	r24, r16
    1956:	dd de       	rcall	.-582    	; 0x1712 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1958:	30 d4       	rcall	.+2144   	; 0x21ba <xTaskResumeAll>
    195a:	81 11       	cpse	r24, r1
    195c:	a4 cf       	rjmp	.-184    	; 0x18a6 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    195e:	99 dd       	rcall	.-1230   	; 0x1492 <vPortYield>
    1960:	a2 cf       	rjmp	.-188    	; 0x18a6 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1962:	c8 01       	movw	r24, r16
    1964:	d6 de       	rcall	.-596    	; 0x1712 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1966:	29 d4       	rcall	.+2130   	; 0x21ba <xTaskResumeAll>
    1968:	9e cf       	rjmp	.-196    	; 0x18a6 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    196a:	c8 01       	movw	r24, r16
    196c:	d2 de       	rcall	.-604    	; 0x1712 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    196e:	25 d4       	rcall	.+2122   	; 0x21ba <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1970:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1972:	0f 90       	pop	r0
    1974:	0f 90       	pop	r0
    1976:	0f 90       	pop	r0
    1978:	0f 90       	pop	r0
    197a:	0f 90       	pop	r0
    197c:	df 91       	pop	r29
    197e:	cf 91       	pop	r28
    1980:	1f 91       	pop	r17
    1982:	0f 91       	pop	r16
    1984:	ff 90       	pop	r15
    1986:	ef 90       	pop	r14
    1988:	df 90       	pop	r13
    198a:	cf 90       	pop	r12
    198c:	bf 90       	pop	r11
    198e:	af 90       	pop	r10
    1990:	9f 90       	pop	r9
    1992:	08 95       	ret

00001994 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1998:	8f e1       	ldi	r24, 0x1F	; 31
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	0e 94 13 03 	call	0x626	; 0x626 <pvPortMalloc>
    19a0:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    19a2:	00 97       	sbiw	r24, 0x00	; 0
    19a4:	f1 f0       	breq	.+60     	; 0x19e2 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    19a6:	1b 82       	std	Y+3, r1	; 0x03
    19a8:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    19aa:	19 82       	std	Y+1, r1	; 0x01
    19ac:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    19ae:	1d 82       	std	Y+5, r1	; 0x05
    19b0:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    19b2:	1f 82       	std	Y+7, r1	; 0x07
    19b4:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19b6:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    19bc:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    19be:	8f ef       	ldi	r24, 0xFF	; 255
    19c0:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    19c2:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19c4:	ce 01       	movw	r24, r28
    19c6:	08 96       	adiw	r24, 0x08	; 8
    19c8:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19cc:	ce 01       	movw	r24, r28
    19ce:	41 96       	adiw	r24, 0x11	; 17
    19d0:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    19d4:	20 e0       	ldi	r18, 0x00	; 0
    19d6:	40 e0       	ldi	r20, 0x00	; 0
    19d8:	50 e0       	ldi	r21, 0x00	; 0
    19da:	60 e0       	ldi	r22, 0x00	; 0
    19dc:	70 e0       	ldi	r23, 0x00	; 0
    19de:	ce 01       	movw	r24, r28
    19e0:	46 df       	rcall	.-372    	; 0x186e <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    19e2:	ce 01       	movw	r24, r28
    19e4:	df 91       	pop	r29
    19e6:	cf 91       	pop	r28
    19e8:	08 95       	ret

000019ea <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19ea:	0f 93       	push	r16
    19ec:	1f 93       	push	r17
    19ee:	cf 93       	push	r28
    19f0:	df 93       	push	r29
    19f2:	ec 01       	movw	r28, r24
    19f4:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19f6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19f8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19fa:	98 17       	cp	r25, r24
    19fc:	10 f0       	brcs	.+4      	; 0x1a02 <xQueueGenericSendFromISR+0x18>
    19fe:	22 30       	cpi	r18, 0x02	; 2
    1a00:	11 f5       	brne	.+68     	; 0x1a46 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a02:	42 2f       	mov	r20, r18
    1a04:	ce 01       	movw	r24, r28
    1a06:	09 de       	rcall	.-1006   	; 0x161a <prvCopyDataToQueue>
    1a08:	88 23       	and	r24, r24
    1a0a:	31 f0       	breq	.+12     	; 0x1a18 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1a0c:	01 15       	cp	r16, r1
    1a0e:	11 05       	cpc	r17, r1
    1a10:	19 f0       	breq	.+6      	; 0x1a18 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	f8 01       	movw	r30, r16
    1a16:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a18:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a1a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a1c:	79 f4       	brne	.+30     	; 0x1a3c <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a1e:	89 89       	ldd	r24, Y+17	; 0x11
    1a20:	88 23       	and	r24, r24
    1a22:	99 f0       	breq	.+38     	; 0x1a4a <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a24:	ce 01       	movw	r24, r28
    1a26:	41 96       	adiw	r24, 0x11	; 17
    1a28:	96 d5       	rcall	.+2860   	; 0x2556 <xTaskRemoveFromEventList>
    1a2a:	88 23       	and	r24, r24
    1a2c:	81 f0       	breq	.+32     	; 0x1a4e <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a2e:	01 15       	cp	r16, r1
    1a30:	11 05       	cpc	r17, r1
    1a32:	79 f0       	breq	.+30     	; 0x1a52 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a34:	81 e0       	ldi	r24, 0x01	; 1
    1a36:	f8 01       	movw	r30, r16
    1a38:	80 83       	st	Z, r24
    1a3a:	0c c0       	rjmp	.+24     	; 0x1a54 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a3c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a3e:	8f 5f       	subi	r24, 0xFF	; 255
    1a40:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	07 c0       	rjmp	.+14     	; 0x1a54 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a46:	80 e0       	ldi	r24, 0x00	; 0
    1a48:	05 c0       	rjmp	.+10     	; 0x1a54 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	03 c0       	rjmp	.+6      	; 0x1a54 <xQueueGenericSendFromISR+0x6a>
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	01 c0       	rjmp	.+2      	; 0x1a54 <xQueueGenericSendFromISR+0x6a>
    1a52:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret

00001a5e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a5e:	9f 92       	push	r9
    1a60:	af 92       	push	r10
    1a62:	bf 92       	push	r11
    1a64:	cf 92       	push	r12
    1a66:	df 92       	push	r13
    1a68:	ef 92       	push	r14
    1a6a:	ff 92       	push	r15
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	cf 93       	push	r28
    1a72:	df 93       	push	r29
    1a74:	00 d0       	rcall	.+0      	; 0x1a76 <xQueueGenericReceive+0x18>
    1a76:	1f 92       	push	r1
    1a78:	1f 92       	push	r1
    1a7a:	cd b7       	in	r28, 0x3d	; 61
    1a7c:	de b7       	in	r29, 0x3e	; 62
    1a7e:	8c 01       	movw	r16, r24
    1a80:	6b 01       	movw	r12, r22
    1a82:	5d 83       	std	Y+5, r21	; 0x05
    1a84:	4c 83       	std	Y+4, r20	; 0x04
    1a86:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1a88:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1a8a:	99 24       	eor	r9, r9
    1a8c:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a8e:	7c 01       	movw	r14, r24
    1a90:	81 e1       	ldi	r24, 0x11	; 17
    1a92:	e8 0e       	add	r14, r24
    1a94:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a96:	0f b6       	in	r0, 0x3f	; 63
    1a98:	f8 94       	cli
    1a9a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a9c:	f8 01       	movw	r30, r16
    1a9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aa0:	88 23       	and	r24, r24
    1aa2:	69 f1       	breq	.+90     	; 0x1afe <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1aa4:	e6 80       	ldd	r14, Z+6	; 0x06
    1aa6:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aa8:	b6 01       	movw	r22, r12
    1aaa:	c8 01       	movw	r24, r16
    1aac:	18 de       	rcall	.-976    	; 0x16de <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1aae:	b1 10       	cpse	r11, r1
    1ab0:	17 c0       	rjmp	.+46     	; 0x1ae0 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1ab2:	f8 01       	movw	r30, r16
    1ab4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ab6:	81 50       	subi	r24, 0x01	; 1
    1ab8:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1aba:	80 81       	ld	r24, Z
    1abc:	91 81       	ldd	r25, Z+1	; 0x01
    1abe:	89 2b       	or	r24, r25
    1ac0:	21 f4       	brne	.+8      	; 0x1aca <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1ac2:	75 d6       	rcall	.+3306   	; 0x27ae <pvTaskIncrementMutexHeldCount>
    1ac4:	f8 01       	movw	r30, r16
    1ac6:	93 83       	std	Z+3, r25	; 0x03
    1ac8:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1aca:	f8 01       	movw	r30, r16
    1acc:	80 85       	ldd	r24, Z+8	; 0x08
    1ace:	88 23       	and	r24, r24
    1ad0:	91 f0       	breq	.+36     	; 0x1af6 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1ad2:	c8 01       	movw	r24, r16
    1ad4:	08 96       	adiw	r24, 0x08	; 8
    1ad6:	3f d5       	rcall	.+2686   	; 0x2556 <xTaskRemoveFromEventList>
    1ad8:	81 30       	cpi	r24, 0x01	; 1
    1ada:	69 f4       	brne	.+26     	; 0x1af6 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1adc:	da dc       	rcall	.-1612   	; 0x1492 <vPortYield>
    1ade:	0b c0       	rjmp	.+22     	; 0x1af6 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1ae0:	f8 01       	movw	r30, r16
    1ae2:	f7 82       	std	Z+7, r15	; 0x07
    1ae4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ae6:	81 89       	ldd	r24, Z+17	; 0x11
    1ae8:	88 23       	and	r24, r24
    1aea:	29 f0       	breq	.+10     	; 0x1af6 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aec:	c8 01       	movw	r24, r16
    1aee:	41 96       	adiw	r24, 0x11	; 17
    1af0:	32 d5       	rcall	.+2660   	; 0x2556 <xTaskRemoveFromEventList>
    1af2:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1af4:	ce dc       	rcall	.-1636   	; 0x1492 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1af6:	0f 90       	pop	r0
    1af8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1afa:	81 e0       	ldi	r24, 0x01	; 1
    1afc:	52 c0       	rjmp	.+164    	; 0x1ba2 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1afe:	4c 81       	ldd	r20, Y+4	; 0x04
    1b00:	5d 81       	ldd	r21, Y+5	; 0x05
    1b02:	45 2b       	or	r20, r21
    1b04:	21 f4       	brne	.+8      	; 0x1b0e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b06:	0f 90       	pop	r0
    1b08:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	4a c0       	rjmp	.+148    	; 0x1ba2 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b0e:	a1 10       	cpse	r10, r1
    1b10:	04 c0       	rjmp	.+8      	; 0x1b1a <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b12:	ce 01       	movw	r24, r28
    1b14:	01 96       	adiw	r24, 0x01	; 1
    1b16:	67 d5       	rcall	.+2766   	; 0x25e6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b18:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b1e:	7a d2       	rcall	.+1268   	; 0x2014 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	0f 92       	push	r0
    1b26:	f8 01       	movw	r30, r16
    1b28:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b2c:	09 f4       	brne	.+2      	; 0x1b30 <xQueueGenericReceive+0xd2>
    1b2e:	15 8e       	std	Z+29, r1	; 0x1d
    1b30:	f8 01       	movw	r30, r16
    1b32:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b34:	8f 3f       	cpi	r24, 0xFF	; 255
    1b36:	09 f4       	brne	.+2      	; 0x1b3a <xQueueGenericReceive+0xdc>
    1b38:	16 8e       	std	Z+30, r1	; 0x1e
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b3e:	be 01       	movw	r22, r28
    1b40:	6c 5f       	subi	r22, 0xFC	; 252
    1b42:	7f 4f       	sbci	r23, 0xFF	; 255
    1b44:	ce 01       	movw	r24, r28
    1b46:	01 96       	adiw	r24, 0x01	; 1
    1b48:	59 d5       	rcall	.+2738   	; 0x25fc <xTaskCheckForTimeOut>
    1b4a:	81 11       	cpse	r24, r1
    1b4c:	26 c0       	rjmp	.+76     	; 0x1b9a <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b4e:	0f b6       	in	r0, 0x3f	; 63
    1b50:	f8 94       	cli
    1b52:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b54:	f8 01       	movw	r30, r16
    1b56:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b58:	0f 90       	pop	r0
    1b5a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	19 c0       	rjmp	.+50     	; 0x1b92 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b60:	f8 01       	movw	r30, r16
    1b62:	80 81       	ld	r24, Z
    1b64:	91 81       	ldd	r25, Z+1	; 0x01
    1b66:	89 2b       	or	r24, r25
    1b68:	49 f4       	brne	.+18     	; 0x1b7c <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1b6a:	0f b6       	in	r0, 0x3f	; 63
    1b6c:	f8 94       	cli
    1b6e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b70:	f8 01       	movw	r30, r16
    1b72:	82 81       	ldd	r24, Z+2	; 0x02
    1b74:	93 81       	ldd	r25, Z+3	; 0x03
    1b76:	7e d5       	rcall	.+2812   	; 0x2674 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b78:	0f 90       	pop	r0
    1b7a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b7c:	6c 81       	ldd	r22, Y+4	; 0x04
    1b7e:	7d 81       	ldd	r23, Y+5	; 0x05
    1b80:	c7 01       	movw	r24, r14
    1b82:	be d4       	rcall	.+2428   	; 0x2500 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b84:	c8 01       	movw	r24, r16
    1b86:	c5 dd       	rcall	.-1142   	; 0x1712 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b88:	18 d3       	rcall	.+1584   	; 0x21ba <xTaskResumeAll>
    1b8a:	81 11       	cpse	r24, r1
    1b8c:	84 cf       	rjmp	.-248    	; 0x1a96 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1b8e:	81 dc       	rcall	.-1790   	; 0x1492 <vPortYield>
    1b90:	82 cf       	rjmp	.-252    	; 0x1a96 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b92:	c8 01       	movw	r24, r16
    1b94:	be dd       	rcall	.-1156   	; 0x1712 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b96:	11 d3       	rcall	.+1570   	; 0x21ba <xTaskResumeAll>
    1b98:	7e cf       	rjmp	.-260    	; 0x1a96 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b9a:	c8 01       	movw	r24, r16
    1b9c:	ba dd       	rcall	.-1164   	; 0x1712 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b9e:	0d d3       	rcall	.+1562   	; 0x21ba <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ba0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1ba2:	0f 90       	pop	r0
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	df 91       	pop	r29
    1bae:	cf 91       	pop	r28
    1bb0:	1f 91       	pop	r17
    1bb2:	0f 91       	pop	r16
    1bb4:	ff 90       	pop	r15
    1bb6:	ef 90       	pop	r14
    1bb8:	df 90       	pop	r13
    1bba:	cf 90       	pop	r12
    1bbc:	bf 90       	pop	r11
    1bbe:	af 90       	pop	r10
    1bc0:	9f 90       	pop	r9
    1bc2:	08 95       	ret

00001bc4 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1bc4:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1bc6:	71 83       	std	Z+1, r23	; 0x01
    1bc8:	60 83       	st	Z, r22
	ring->rSize = size;
    1bca:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1bcc:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1bce:	13 82       	std	Z+3, r1	; 0x03
    1bd0:	08 95       	ret

00001bd2 <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1bd2:	dc 01       	movw	r26, r24
    1bd4:	14 96       	adiw	r26, 0x04	; 4
    1bd6:	2c 91       	ld	r18, X
    1bd8:	14 97       	sbiw	r26, 0x04	; 4
    1bda:	ed 91       	ld	r30, X+
    1bdc:	fc 91       	ld	r31, X
    1bde:	e2 0f       	add	r30, r18
    1be0:	f1 1d       	adc	r31, r1
}
    1be2:	80 81       	ld	r24, Z
    1be4:	08 95       	ret

00001be6 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1be6:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1be8:	94 81       	ldd	r25, Z+4	; 0x04
    1bea:	a0 81       	ld	r26, Z
    1bec:	b1 81       	ldd	r27, Z+1	; 0x01
    1bee:	a9 0f       	add	r26, r25
    1bf0:	b1 1d       	adc	r27, r1
    1bf2:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1bf4:	9f 5f       	subi	r25, 0xFF	; 255
    1bf6:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1bf8:	22 81       	ldd	r18, Z+2	; 0x02
    1bfa:	92 17       	cp	r25, r18
    1bfc:	10 f0       	brcs	.+4      	; 0x1c02 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1bfe:	92 1b       	sub	r25, r18
    1c00:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c02:	93 81       	ldd	r25, Z+3	; 0x03
    1c04:	91 50       	subi	r25, 0x01	; 1
    1c06:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c08:	08 95       	ret

00001c0a <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c0a:	fc 01       	movw	r30, r24
    1c0c:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c0e:	83 81       	ldd	r24, Z+3	; 0x03
    1c10:	22 81       	ldd	r18, Z+2	; 0x02
    1c12:	82 17       	cp	r24, r18
    1c14:	80 f4       	brcc	.+32     	; 0x1c36 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c16:	34 81       	ldd	r19, Z+4	; 0x04
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	83 0f       	add	r24, r19
    1c1c:	91 1d       	adc	r25, r1
    1c1e:	62 2f       	mov	r22, r18
    1c20:	70 e0       	ldi	r23, 0x00	; 0
    1c22:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <__divmodhi4>
    1c26:	a0 81       	ld	r26, Z
    1c28:	b1 81       	ldd	r27, Z+1	; 0x01
    1c2a:	a8 0f       	add	r26, r24
    1c2c:	b9 1f       	adc	r27, r25
    1c2e:	4c 93       	st	X, r20
            ring->rLength++;
    1c30:	83 81       	ldd	r24, Z+3	; 0x03
    1c32:	8f 5f       	subi	r24, 0xFF	; 255
    1c34:	83 83       	std	Z+3, r24	; 0x03
    1c36:	08 95       	ret

00001c38 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c38:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	22 81       	ldd	r18, Z+2	; 0x02
    1c3e:	93 81       	ldd	r25, Z+3	; 0x03
    1c40:	29 13       	cpse	r18, r25
    1c42:	80 e0       	ldi	r24, 0x00	; 0
}
    1c44:	08 95       	ret

00001c46 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c46:	21 e0       	ldi	r18, 0x01	; 1
    1c48:	fc 01       	movw	r30, r24
    1c4a:	83 81       	ldd	r24, Z+3	; 0x03
    1c4c:	81 11       	cpse	r24, r1
    1c4e:	01 c0       	rjmp	.+2      	; 0x1c52 <ringBufferNotEmpty+0xc>
    1c50:	20 e0       	ldi	r18, 0x00	; 0
}
    1c52:	82 2f       	mov	r24, r18
    1c54:	08 95       	ret

00001c56 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c56:	e0 91 50 08 	lds	r30, 0x0850
    1c5a:	f0 91 51 08 	lds	r31, 0x0851
    1c5e:	80 81       	ld	r24, Z
    1c60:	81 11       	cpse	r24, r1
    1c62:	07 c0       	rjmp	.+14     	; 0x1c72 <prvResetNextTaskUnblockTime+0x1c>
    1c64:	8f ef       	ldi	r24, 0xFF	; 255
    1c66:	9f ef       	ldi	r25, 0xFF	; 255
    1c68:	90 93 06 02 	sts	0x0206, r25
    1c6c:	80 93 05 02 	sts	0x0205, r24
    1c70:	08 95       	ret
    1c72:	e0 91 50 08 	lds	r30, 0x0850
    1c76:	f0 91 51 08 	lds	r31, 0x0851
    1c7a:	05 80       	ldd	r0, Z+5	; 0x05
    1c7c:	f6 81       	ldd	r31, Z+6	; 0x06
    1c7e:	e0 2d       	mov	r30, r0
    1c80:	06 80       	ldd	r0, Z+6	; 0x06
    1c82:	f7 81       	ldd	r31, Z+7	; 0x07
    1c84:	e0 2d       	mov	r30, r0
    1c86:	82 81       	ldd	r24, Z+2	; 0x02
    1c88:	93 81       	ldd	r25, Z+3	; 0x03
    1c8a:	90 93 06 02 	sts	0x0206, r25
    1c8e:	80 93 05 02 	sts	0x0205, r24
    1c92:	08 95       	ret

00001c94 <prvAddCurrentTaskToDelayedList>:
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	ec 01       	movw	r28, r24
    1c9a:	e0 91 91 08 	lds	r30, 0x0891
    1c9e:	f0 91 92 08 	lds	r31, 0x0892
    1ca2:	93 83       	std	Z+3, r25	; 0x03
    1ca4:	82 83       	std	Z+2, r24	; 0x02
    1ca6:	80 91 2f 08 	lds	r24, 0x082F
    1caa:	90 91 30 08 	lds	r25, 0x0830
    1cae:	c8 17       	cp	r28, r24
    1cb0:	d9 07       	cpc	r29, r25
    1cb2:	68 f4       	brcc	.+26     	; 0x1cce <prvAddCurrentTaskToDelayedList+0x3a>
    1cb4:	60 91 91 08 	lds	r22, 0x0891
    1cb8:	70 91 92 08 	lds	r23, 0x0892
    1cbc:	80 91 4e 08 	lds	r24, 0x084E
    1cc0:	90 91 4f 08 	lds	r25, 0x084F
    1cc4:	6e 5f       	subi	r22, 0xFE	; 254
    1cc6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cc8:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vListInsert>
    1ccc:	17 c0       	rjmp	.+46     	; 0x1cfc <prvAddCurrentTaskToDelayedList+0x68>
    1cce:	60 91 91 08 	lds	r22, 0x0891
    1cd2:	70 91 92 08 	lds	r23, 0x0892
    1cd6:	80 91 50 08 	lds	r24, 0x0850
    1cda:	90 91 51 08 	lds	r25, 0x0851
    1cde:	6e 5f       	subi	r22, 0xFE	; 254
    1ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce2:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vListInsert>
    1ce6:	80 91 05 02 	lds	r24, 0x0205
    1cea:	90 91 06 02 	lds	r25, 0x0206
    1cee:	c8 17       	cp	r28, r24
    1cf0:	d9 07       	cpc	r29, r25
    1cf2:	20 f4       	brcc	.+8      	; 0x1cfc <prvAddCurrentTaskToDelayedList+0x68>
    1cf4:	d0 93 06 02 	sts	0x0206, r29
    1cf8:	c0 93 05 02 	sts	0x0205, r28
    1cfc:	df 91       	pop	r29
    1cfe:	cf 91       	pop	r28
    1d00:	08 95       	ret

00001d02 <xTaskGenericCreate>:
    1d02:	4f 92       	push	r4
    1d04:	5f 92       	push	r5
    1d06:	6f 92       	push	r6
    1d08:	7f 92       	push	r7
    1d0a:	8f 92       	push	r8
    1d0c:	9f 92       	push	r9
    1d0e:	af 92       	push	r10
    1d10:	bf 92       	push	r11
    1d12:	cf 92       	push	r12
    1d14:	df 92       	push	r13
    1d16:	ef 92       	push	r14
    1d18:	ff 92       	push	r15
    1d1a:	0f 93       	push	r16
    1d1c:	1f 93       	push	r17
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
    1d22:	4c 01       	movw	r8, r24
    1d24:	5b 01       	movw	r10, r22
    1d26:	2a 01       	movw	r4, r20
    1d28:	39 01       	movw	r6, r18
    1d2a:	83 e2       	ldi	r24, 0x23	; 35
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	0e 94 13 03 	call	0x626	; 0x626 <pvPortMalloc>
    1d32:	ec 01       	movw	r28, r24
    1d34:	00 97       	sbiw	r24, 0x00	; 0
    1d36:	09 f4       	brne	.+2      	; 0x1d3a <xTaskGenericCreate+0x38>
    1d38:	e7 c0       	rjmp	.+462    	; 0x1f08 <xTaskGenericCreate+0x206>
    1d3a:	c1 14       	cp	r12, r1
    1d3c:	d1 04       	cpc	r13, r1
    1d3e:	09 f0       	breq	.+2      	; 0x1d42 <xTaskGenericCreate+0x40>
    1d40:	cc c0       	rjmp	.+408    	; 0x1eda <xTaskGenericCreate+0x1d8>
    1d42:	c2 01       	movw	r24, r4
    1d44:	0e 94 13 03 	call	0x626	; 0x626 <pvPortMalloc>
    1d48:	98 8f       	std	Y+24, r25	; 0x18
    1d4a:	8f 8b       	std	Y+23, r24	; 0x17
    1d4c:	89 2b       	or	r24, r25
    1d4e:	09 f0       	breq	.+2      	; 0x1d52 <xTaskGenericCreate+0x50>
    1d50:	c6 c0       	rjmp	.+396    	; 0x1ede <xTaskGenericCreate+0x1dc>
    1d52:	ce 01       	movw	r24, r28
    1d54:	0e 94 48 03 	call	0x690	; 0x690 <vPortFree>
    1d58:	d7 c0       	rjmp	.+430    	; 0x1f08 <xTaskGenericCreate+0x206>
    1d5a:	cf 01       	movw	r24, r30
    1d5c:	31 91       	ld	r19, Z+
    1d5e:	da 01       	movw	r26, r20
    1d60:	3d 93       	st	X+, r19
    1d62:	ad 01       	movw	r20, r26
    1d64:	dc 01       	movw	r26, r24
    1d66:	8c 91       	ld	r24, X
    1d68:	88 23       	and	r24, r24
    1d6a:	11 f0       	breq	.+4      	; 0x1d70 <xTaskGenericCreate+0x6e>
    1d6c:	21 50       	subi	r18, 0x01	; 1
    1d6e:	a9 f7       	brne	.-22     	; 0x1d5a <xTaskGenericCreate+0x58>
    1d70:	18 a2       	std	Y+32, r1	; 0x20
    1d72:	10 2f       	mov	r17, r16
    1d74:	05 30       	cpi	r16, 0x05	; 5
    1d76:	08 f0       	brcs	.+2      	; 0x1d7a <xTaskGenericCreate+0x78>
    1d78:	14 e0       	ldi	r17, 0x04	; 4
    1d7a:	1e 8b       	std	Y+22, r17	; 0x16
    1d7c:	19 a3       	std	Y+33, r17	; 0x21
    1d7e:	1a a2       	std	Y+34, r1	; 0x22
    1d80:	5e 01       	movw	r10, r28
    1d82:	b2 e0       	ldi	r27, 0x02	; 2
    1d84:	ab 0e       	add	r10, r27
    1d86:	b1 1c       	adc	r11, r1
    1d88:	c5 01       	movw	r24, r10
    1d8a:	0e 94 57 03 	call	0x6ae	; 0x6ae <vListInitialiseItem>
    1d8e:	ce 01       	movw	r24, r28
    1d90:	0c 96       	adiw	r24, 0x0c	; 12
    1d92:	0e 94 57 03 	call	0x6ae	; 0x6ae <vListInitialiseItem>
    1d96:	d9 87       	std	Y+9, r29	; 0x09
    1d98:	c8 87       	std	Y+8, r28	; 0x08
    1d9a:	85 e0       	ldi	r24, 0x05	; 5
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	81 1b       	sub	r24, r17
    1da0:	91 09       	sbc	r25, r1
    1da2:	9d 87       	std	Y+13, r25	; 0x0d
    1da4:	8c 87       	std	Y+12, r24	; 0x0c
    1da6:	db 8b       	std	Y+19, r29	; 0x13
    1da8:	ca 8b       	std	Y+18, r28	; 0x12
    1daa:	a3 01       	movw	r20, r6
    1dac:	b4 01       	movw	r22, r8
    1dae:	c6 01       	movw	r24, r12
    1db0:	c1 da       	rcall	.-2686   	; 0x1334 <pxPortInitialiseStack>
    1db2:	99 83       	std	Y+1, r25	; 0x01
    1db4:	88 83       	st	Y, r24
    1db6:	e1 14       	cp	r14, r1
    1db8:	f1 04       	cpc	r15, r1
    1dba:	19 f0       	breq	.+6      	; 0x1dc2 <xTaskGenericCreate+0xc0>
    1dbc:	f7 01       	movw	r30, r14
    1dbe:	d1 83       	std	Z+1, r29	; 0x01
    1dc0:	c0 83       	st	Z, r28
    1dc2:	0f b6       	in	r0, 0x3f	; 63
    1dc4:	f8 94       	cli
    1dc6:	0f 92       	push	r0
    1dc8:	80 91 31 08 	lds	r24, 0x0831
    1dcc:	8f 5f       	subi	r24, 0xFF	; 255
    1dce:	80 93 31 08 	sts	0x0831, r24
    1dd2:	80 91 91 08 	lds	r24, 0x0891
    1dd6:	90 91 92 08 	lds	r25, 0x0892
    1dda:	89 2b       	or	r24, r25
    1ddc:	09 f0       	breq	.+2      	; 0x1de0 <xTaskGenericCreate+0xde>
    1dde:	3f c0       	rjmp	.+126    	; 0x1e5e <xTaskGenericCreate+0x15c>
    1de0:	d0 93 92 08 	sts	0x0892, r29
    1de4:	c0 93 91 08 	sts	0x0891, r28
    1de8:	80 91 31 08 	lds	r24, 0x0831
    1dec:	81 30       	cpi	r24, 0x01	; 1
    1dee:	09 f0       	breq	.+2      	; 0x1df2 <xTaskGenericCreate+0xf0>
    1df0:	45 c0       	rjmp	.+138    	; 0x1e7c <xTaskGenericCreate+0x17a>
    1df2:	0f 2e       	mov	r0, r31
    1df4:	f4 e6       	ldi	r31, 0x64	; 100
    1df6:	ef 2e       	mov	r14, r31
    1df8:	f8 e0       	ldi	r31, 0x08	; 8
    1dfa:	ff 2e       	mov	r15, r31
    1dfc:	f0 2d       	mov	r31, r0
    1dfe:	0f 2e       	mov	r0, r31
    1e00:	f1 e9       	ldi	r31, 0x91	; 145
    1e02:	cf 2e       	mov	r12, r31
    1e04:	f8 e0       	ldi	r31, 0x08	; 8
    1e06:	df 2e       	mov	r13, r31
    1e08:	f0 2d       	mov	r31, r0
    1e0a:	c7 01       	movw	r24, r14
    1e0c:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e10:	f9 e0       	ldi	r31, 0x09	; 9
    1e12:	ef 0e       	add	r14, r31
    1e14:	f1 1c       	adc	r15, r1
    1e16:	ec 14       	cp	r14, r12
    1e18:	fd 04       	cpc	r15, r13
    1e1a:	b9 f7       	brne	.-18     	; 0x1e0a <xTaskGenericCreate+0x108>
    1e1c:	8b e5       	ldi	r24, 0x5B	; 91
    1e1e:	98 e0       	ldi	r25, 0x08	; 8
    1e20:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e24:	82 e5       	ldi	r24, 0x52	; 82
    1e26:	98 e0       	ldi	r25, 0x08	; 8
    1e28:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e2c:	85 e4       	ldi	r24, 0x45	; 69
    1e2e:	98 e0       	ldi	r25, 0x08	; 8
    1e30:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e34:	8c e3       	ldi	r24, 0x3C	; 60
    1e36:	98 e0       	ldi	r25, 0x08	; 8
    1e38:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e3c:	82 e3       	ldi	r24, 0x32	; 50
    1e3e:	98 e0       	ldi	r25, 0x08	; 8
    1e40:	0e 94 49 03 	call	0x692	; 0x692 <vListInitialise>
    1e44:	8b e5       	ldi	r24, 0x5B	; 91
    1e46:	98 e0       	ldi	r25, 0x08	; 8
    1e48:	90 93 51 08 	sts	0x0851, r25
    1e4c:	80 93 50 08 	sts	0x0850, r24
    1e50:	82 e5       	ldi	r24, 0x52	; 82
    1e52:	98 e0       	ldi	r25, 0x08	; 8
    1e54:	90 93 4f 08 	sts	0x084F, r25
    1e58:	80 93 4e 08 	sts	0x084E, r24
    1e5c:	0f c0       	rjmp	.+30     	; 0x1e7c <xTaskGenericCreate+0x17a>
    1e5e:	80 91 2d 08 	lds	r24, 0x082D
    1e62:	81 11       	cpse	r24, r1
    1e64:	0b c0       	rjmp	.+22     	; 0x1e7c <xTaskGenericCreate+0x17a>
    1e66:	e0 91 91 08 	lds	r30, 0x0891
    1e6a:	f0 91 92 08 	lds	r31, 0x0892
    1e6e:	86 89       	ldd	r24, Z+22	; 0x16
    1e70:	08 17       	cp	r16, r24
    1e72:	20 f0       	brcs	.+8      	; 0x1e7c <xTaskGenericCreate+0x17a>
    1e74:	d0 93 92 08 	sts	0x0892, r29
    1e78:	c0 93 91 08 	sts	0x0891, r28
    1e7c:	80 91 29 08 	lds	r24, 0x0829
    1e80:	8f 5f       	subi	r24, 0xFF	; 255
    1e82:	80 93 29 08 	sts	0x0829, r24
    1e86:	8e 89       	ldd	r24, Y+22	; 0x16
    1e88:	90 91 2e 08 	lds	r25, 0x082E
    1e8c:	98 17       	cp	r25, r24
    1e8e:	10 f4       	brcc	.+4      	; 0x1e94 <xTaskGenericCreate+0x192>
    1e90:	80 93 2e 08 	sts	0x082E, r24
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	9c 01       	movw	r18, r24
    1e98:	22 0f       	add	r18, r18
    1e9a:	33 1f       	adc	r19, r19
    1e9c:	22 0f       	add	r18, r18
    1e9e:	33 1f       	adc	r19, r19
    1ea0:	22 0f       	add	r18, r18
    1ea2:	33 1f       	adc	r19, r19
    1ea4:	82 0f       	add	r24, r18
    1ea6:	93 1f       	adc	r25, r19
    1ea8:	b5 01       	movw	r22, r10
    1eaa:	8c 59       	subi	r24, 0x9C	; 156
    1eac:	97 4f       	sbci	r25, 0xF7	; 247
    1eae:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
    1eb6:	80 91 2d 08 	lds	r24, 0x082D
    1eba:	88 23       	and	r24, r24
    1ebc:	51 f0       	breq	.+20     	; 0x1ed2 <xTaskGenericCreate+0x1d0>
    1ebe:	e0 91 91 08 	lds	r30, 0x0891
    1ec2:	f0 91 92 08 	lds	r31, 0x0892
    1ec6:	86 89       	ldd	r24, Z+22	; 0x16
    1ec8:	80 17       	cp	r24, r16
    1eca:	28 f4       	brcc	.+10     	; 0x1ed6 <xTaskGenericCreate+0x1d4>
    1ecc:	e2 da       	rcall	.-2620   	; 0x1492 <vPortYield>
    1ece:	81 e0       	ldi	r24, 0x01	; 1
    1ed0:	1c c0       	rjmp	.+56     	; 0x1f0a <xTaskGenericCreate+0x208>
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	1a c0       	rjmp	.+52     	; 0x1f0a <xTaskGenericCreate+0x208>
    1ed6:	81 e0       	ldi	r24, 0x01	; 1
    1ed8:	18 c0       	rjmp	.+48     	; 0x1f0a <xTaskGenericCreate+0x208>
    1eda:	d8 8e       	std	Y+24, r13	; 0x18
    1edc:	cf 8a       	std	Y+23, r12	; 0x17
    1ede:	81 e0       	ldi	r24, 0x01	; 1
    1ee0:	48 1a       	sub	r4, r24
    1ee2:	51 08       	sbc	r5, r1
    1ee4:	cf 88       	ldd	r12, Y+23	; 0x17
    1ee6:	d8 8c       	ldd	r13, Y+24	; 0x18
    1ee8:	c4 0c       	add	r12, r4
    1eea:	d5 1c       	adc	r13, r5
    1eec:	d5 01       	movw	r26, r10
    1eee:	8c 91       	ld	r24, X
    1ef0:	89 8f       	std	Y+25, r24	; 0x19
    1ef2:	8c 91       	ld	r24, X
    1ef4:	88 23       	and	r24, r24
    1ef6:	09 f4       	brne	.+2      	; 0x1efa <xTaskGenericCreate+0x1f8>
    1ef8:	3b cf       	rjmp	.-394    	; 0x1d70 <xTaskGenericCreate+0x6e>
    1efa:	ae 01       	movw	r20, r28
    1efc:	46 5e       	subi	r20, 0xE6	; 230
    1efe:	5f 4f       	sbci	r21, 0xFF	; 255
    1f00:	f5 01       	movw	r30, r10
    1f02:	31 96       	adiw	r30, 0x01	; 1
    1f04:	27 e0       	ldi	r18, 0x07	; 7
    1f06:	29 cf       	rjmp	.-430    	; 0x1d5a <xTaskGenericCreate+0x58>
    1f08:	8f ef       	ldi	r24, 0xFF	; 255
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	1f 91       	pop	r17
    1f10:	0f 91       	pop	r16
    1f12:	ff 90       	pop	r15
    1f14:	ef 90       	pop	r14
    1f16:	df 90       	pop	r13
    1f18:	cf 90       	pop	r12
    1f1a:	bf 90       	pop	r11
    1f1c:	af 90       	pop	r10
    1f1e:	9f 90       	pop	r9
    1f20:	8f 90       	pop	r8
    1f22:	7f 90       	pop	r7
    1f24:	6f 90       	pop	r6
    1f26:	5f 90       	pop	r5
    1f28:	4f 90       	pop	r4
    1f2a:	08 95       	ret

00001f2c <vTaskResume>:
    1f2c:	0f 93       	push	r16
    1f2e:	1f 93       	push	r17
    1f30:	cf 93       	push	r28
    1f32:	df 93       	push	r29
    1f34:	ec 01       	movw	r28, r24
    1f36:	00 97       	sbiw	r24, 0x00	; 0
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <vTaskResume+0x10>
    1f3a:	3e c0       	rjmp	.+124    	; 0x1fb8 <vTaskResume+0x8c>
    1f3c:	80 91 91 08 	lds	r24, 0x0891
    1f40:	90 91 92 08 	lds	r25, 0x0892
    1f44:	c8 17       	cp	r28, r24
    1f46:	d9 07       	cpc	r29, r25
    1f48:	b9 f1       	breq	.+110    	; 0x1fb8 <vTaskResume+0x8c>
    1f4a:	0f b6       	in	r0, 0x3f	; 63
    1f4c:	f8 94       	cli
    1f4e:	0f 92       	push	r0
    1f50:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f52:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f54:	82 53       	subi	r24, 0x32	; 50
    1f56:	98 40       	sbci	r25, 0x08	; 8
    1f58:	69 f5       	brne	.+90     	; 0x1fb4 <vTaskResume+0x88>
    1f5a:	8c 89       	ldd	r24, Y+20	; 0x14
    1f5c:	9d 89       	ldd	r25, Y+21	; 0x15
    1f5e:	28 e0       	ldi	r18, 0x08	; 8
    1f60:	85 34       	cpi	r24, 0x45	; 69
    1f62:	92 07       	cpc	r25, r18
    1f64:	39 f1       	breq	.+78     	; 0x1fb4 <vTaskResume+0x88>
    1f66:	89 2b       	or	r24, r25
    1f68:	29 f5       	brne	.+74     	; 0x1fb4 <vTaskResume+0x88>
    1f6a:	8e 01       	movw	r16, r28
    1f6c:	0e 5f       	subi	r16, 0xFE	; 254
    1f6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f70:	c8 01       	movw	r24, r16
    1f72:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    1f76:	8e 89       	ldd	r24, Y+22	; 0x16
    1f78:	90 91 2e 08 	lds	r25, 0x082E
    1f7c:	98 17       	cp	r25, r24
    1f7e:	10 f4       	brcc	.+4      	; 0x1f84 <vTaskResume+0x58>
    1f80:	80 93 2e 08 	sts	0x082E, r24
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	9c 01       	movw	r18, r24
    1f88:	22 0f       	add	r18, r18
    1f8a:	33 1f       	adc	r19, r19
    1f8c:	22 0f       	add	r18, r18
    1f8e:	33 1f       	adc	r19, r19
    1f90:	22 0f       	add	r18, r18
    1f92:	33 1f       	adc	r19, r19
    1f94:	82 0f       	add	r24, r18
    1f96:	93 1f       	adc	r25, r19
    1f98:	b8 01       	movw	r22, r16
    1f9a:	8c 59       	subi	r24, 0x9C	; 156
    1f9c:	97 4f       	sbci	r25, 0xF7	; 247
    1f9e:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    1fa2:	e0 91 91 08 	lds	r30, 0x0891
    1fa6:	f0 91 92 08 	lds	r31, 0x0892
    1faa:	9e 89       	ldd	r25, Y+22	; 0x16
    1fac:	86 89       	ldd	r24, Z+22	; 0x16
    1fae:	98 17       	cp	r25, r24
    1fb0:	08 f0       	brcs	.+2      	; 0x1fb4 <vTaskResume+0x88>
    1fb2:	6f da       	rcall	.-2850   	; 0x1492 <vPortYield>
    1fb4:	0f 90       	pop	r0
    1fb6:	0f be       	out	0x3f, r0	; 63
    1fb8:	df 91       	pop	r29
    1fba:	cf 91       	pop	r28
    1fbc:	1f 91       	pop	r17
    1fbe:	0f 91       	pop	r16
    1fc0:	08 95       	ret

00001fc2 <vTaskStartScheduler>:
    1fc2:	af 92       	push	r10
    1fc4:	bf 92       	push	r11
    1fc6:	cf 92       	push	r12
    1fc8:	df 92       	push	r13
    1fca:	ef 92       	push	r14
    1fcc:	ff 92       	push	r15
    1fce:	0f 93       	push	r16
    1fd0:	a1 2c       	mov	r10, r1
    1fd2:	b1 2c       	mov	r11, r1
    1fd4:	c1 2c       	mov	r12, r1
    1fd6:	d1 2c       	mov	r13, r1
    1fd8:	e1 2c       	mov	r14, r1
    1fda:	f1 2c       	mov	r15, r1
    1fdc:	00 e0       	ldi	r16, 0x00	; 0
    1fde:	20 e0       	ldi	r18, 0x00	; 0
    1fe0:	30 e0       	ldi	r19, 0x00	; 0
    1fe2:	45 e5       	ldi	r20, 0x55	; 85
    1fe4:	50 e0       	ldi	r21, 0x00	; 0
    1fe6:	63 e3       	ldi	r22, 0x33	; 51
    1fe8:	72 e0       	ldi	r23, 0x02	; 2
    1fea:	8c e9       	ldi	r24, 0x9C	; 156
    1fec:	91 e1       	ldi	r25, 0x11	; 17
    1fee:	89 de       	rcall	.-750    	; 0x1d02 <xTaskGenericCreate>
    1ff0:	81 30       	cpi	r24, 0x01	; 1
    1ff2:	41 f4       	brne	.+16     	; 0x2004 <vTaskStartScheduler+0x42>
    1ff4:	f8 94       	cli
    1ff6:	80 93 2d 08 	sts	0x082D, r24
    1ffa:	10 92 30 08 	sts	0x0830, r1
    1ffe:	10 92 2f 08 	sts	0x082F, r1
    2002:	0a da       	rcall	.-3052   	; 0x1418 <xPortStartScheduler>
    2004:	0f 91       	pop	r16
    2006:	ff 90       	pop	r15
    2008:	ef 90       	pop	r14
    200a:	df 90       	pop	r13
    200c:	cf 90       	pop	r12
    200e:	bf 90       	pop	r11
    2010:	af 90       	pop	r10
    2012:	08 95       	ret

00002014 <vTaskSuspendAll>:
    2014:	80 91 28 08 	lds	r24, 0x0828
    2018:	8f 5f       	subi	r24, 0xFF	; 255
    201a:	80 93 28 08 	sts	0x0828, r24
    201e:	08 95       	ret

00002020 <xTaskGetTickCount>:
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	f8 94       	cli
    2024:	0f 92       	push	r0
    2026:	80 91 2f 08 	lds	r24, 0x082F
    202a:	90 91 30 08 	lds	r25, 0x0830
    202e:	0f 90       	pop	r0
    2030:	0f be       	out	0x3f, r0	; 63
    2032:	08 95       	ret

00002034 <xTaskGetTickCountFromISR>:
    2034:	80 91 2f 08 	lds	r24, 0x082F
    2038:	90 91 30 08 	lds	r25, 0x0830
    203c:	08 95       	ret

0000203e <xTaskIncrementTick>:
    203e:	cf 92       	push	r12
    2040:	df 92       	push	r13
    2042:	ef 92       	push	r14
    2044:	ff 92       	push	r15
    2046:	0f 93       	push	r16
    2048:	1f 93       	push	r17
    204a:	cf 93       	push	r28
    204c:	df 93       	push	r29
    204e:	80 91 28 08 	lds	r24, 0x0828
    2052:	81 11       	cpse	r24, r1
    2054:	99 c0       	rjmp	.+306    	; 0x2188 <xTaskIncrementTick+0x14a>
    2056:	80 91 2f 08 	lds	r24, 0x082F
    205a:	90 91 30 08 	lds	r25, 0x0830
    205e:	01 96       	adiw	r24, 0x01	; 1
    2060:	90 93 30 08 	sts	0x0830, r25
    2064:	80 93 2f 08 	sts	0x082F, r24
    2068:	e0 90 2f 08 	lds	r14, 0x082F
    206c:	f0 90 30 08 	lds	r15, 0x0830
    2070:	e1 14       	cp	r14, r1
    2072:	f1 04       	cpc	r15, r1
    2074:	b1 f4       	brne	.+44     	; 0x20a2 <xTaskIncrementTick+0x64>
    2076:	80 91 50 08 	lds	r24, 0x0850
    207a:	90 91 51 08 	lds	r25, 0x0851
    207e:	20 91 4e 08 	lds	r18, 0x084E
    2082:	30 91 4f 08 	lds	r19, 0x084F
    2086:	30 93 51 08 	sts	0x0851, r19
    208a:	20 93 50 08 	sts	0x0850, r18
    208e:	90 93 4f 08 	sts	0x084F, r25
    2092:	80 93 4e 08 	sts	0x084E, r24
    2096:	80 91 2a 08 	lds	r24, 0x082A
    209a:	8f 5f       	subi	r24, 0xFF	; 255
    209c:	80 93 2a 08 	sts	0x082A, r24
    20a0:	da dd       	rcall	.-1100   	; 0x1c56 <prvResetNextTaskUnblockTime>
    20a2:	80 91 05 02 	lds	r24, 0x0205
    20a6:	90 91 06 02 	lds	r25, 0x0206
    20aa:	e8 16       	cp	r14, r24
    20ac:	f9 06       	cpc	r15, r25
    20ae:	08 f4       	brcc	.+2      	; 0x20b2 <xTaskIncrementTick+0x74>
    20b0:	54 c0       	rjmp	.+168    	; 0x215a <xTaskIncrementTick+0x11c>
    20b2:	d1 2c       	mov	r13, r1
    20b4:	cc 24       	eor	r12, r12
    20b6:	c3 94       	inc	r12
    20b8:	01 c0       	rjmp	.+2      	; 0x20bc <xTaskIncrementTick+0x7e>
    20ba:	dc 2c       	mov	r13, r12
    20bc:	e0 91 50 08 	lds	r30, 0x0850
    20c0:	f0 91 51 08 	lds	r31, 0x0851
    20c4:	80 81       	ld	r24, Z
    20c6:	81 11       	cpse	r24, r1
    20c8:	07 c0       	rjmp	.+14     	; 0x20d8 <xTaskIncrementTick+0x9a>
    20ca:	8f ef       	ldi	r24, 0xFF	; 255
    20cc:	9f ef       	ldi	r25, 0xFF	; 255
    20ce:	90 93 06 02 	sts	0x0206, r25
    20d2:	80 93 05 02 	sts	0x0205, r24
    20d6:	42 c0       	rjmp	.+132    	; 0x215c <xTaskIncrementTick+0x11e>
    20d8:	e0 91 50 08 	lds	r30, 0x0850
    20dc:	f0 91 51 08 	lds	r31, 0x0851
    20e0:	05 80       	ldd	r0, Z+5	; 0x05
    20e2:	f6 81       	ldd	r31, Z+6	; 0x06
    20e4:	e0 2d       	mov	r30, r0
    20e6:	c6 81       	ldd	r28, Z+6	; 0x06
    20e8:	d7 81       	ldd	r29, Z+7	; 0x07
    20ea:	2a 81       	ldd	r18, Y+2	; 0x02
    20ec:	3b 81       	ldd	r19, Y+3	; 0x03
    20ee:	e2 16       	cp	r14, r18
    20f0:	f3 06       	cpc	r15, r19
    20f2:	28 f4       	brcc	.+10     	; 0x20fe <xTaskIncrementTick+0xc0>
    20f4:	30 93 06 02 	sts	0x0206, r19
    20f8:	20 93 05 02 	sts	0x0205, r18
    20fc:	2f c0       	rjmp	.+94     	; 0x215c <xTaskIncrementTick+0x11e>
    20fe:	8e 01       	movw	r16, r28
    2100:	0e 5f       	subi	r16, 0xFE	; 254
    2102:	1f 4f       	sbci	r17, 0xFF	; 255
    2104:	c8 01       	movw	r24, r16
    2106:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    210a:	8c 89       	ldd	r24, Y+20	; 0x14
    210c:	9d 89       	ldd	r25, Y+21	; 0x15
    210e:	89 2b       	or	r24, r25
    2110:	21 f0       	breq	.+8      	; 0x211a <xTaskIncrementTick+0xdc>
    2112:	ce 01       	movw	r24, r28
    2114:	0c 96       	adiw	r24, 0x0c	; 12
    2116:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    211a:	2e 89       	ldd	r18, Y+22	; 0x16
    211c:	80 91 2e 08 	lds	r24, 0x082E
    2120:	82 17       	cp	r24, r18
    2122:	10 f4       	brcc	.+4      	; 0x2128 <xTaskIncrementTick+0xea>
    2124:	20 93 2e 08 	sts	0x082E, r18
    2128:	30 e0       	ldi	r19, 0x00	; 0
    212a:	c9 01       	movw	r24, r18
    212c:	88 0f       	add	r24, r24
    212e:	99 1f       	adc	r25, r25
    2130:	88 0f       	add	r24, r24
    2132:	99 1f       	adc	r25, r25
    2134:	88 0f       	add	r24, r24
    2136:	99 1f       	adc	r25, r25
    2138:	82 0f       	add	r24, r18
    213a:	93 1f       	adc	r25, r19
    213c:	b8 01       	movw	r22, r16
    213e:	8c 59       	subi	r24, 0x9C	; 156
    2140:	97 4f       	sbci	r25, 0xF7	; 247
    2142:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    2146:	e0 91 91 08 	lds	r30, 0x0891
    214a:	f0 91 92 08 	lds	r31, 0x0892
    214e:	9e 89       	ldd	r25, Y+22	; 0x16
    2150:	86 89       	ldd	r24, Z+22	; 0x16
    2152:	98 17       	cp	r25, r24
    2154:	08 f0       	brcs	.+2      	; 0x2158 <xTaskIncrementTick+0x11a>
    2156:	b1 cf       	rjmp	.-158    	; 0x20ba <xTaskIncrementTick+0x7c>
    2158:	b1 cf       	rjmp	.-158    	; 0x20bc <xTaskIncrementTick+0x7e>
    215a:	d1 2c       	mov	r13, r1
    215c:	e0 91 91 08 	lds	r30, 0x0891
    2160:	f0 91 92 08 	lds	r31, 0x0892
    2164:	86 89       	ldd	r24, Z+22	; 0x16
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	fc 01       	movw	r30, r24
    216a:	ee 0f       	add	r30, r30
    216c:	ff 1f       	adc	r31, r31
    216e:	ee 0f       	add	r30, r30
    2170:	ff 1f       	adc	r31, r31
    2172:	ee 0f       	add	r30, r30
    2174:	ff 1f       	adc	r31, r31
    2176:	8e 0f       	add	r24, r30
    2178:	9f 1f       	adc	r25, r31
    217a:	fc 01       	movw	r30, r24
    217c:	ec 59       	subi	r30, 0x9C	; 156
    217e:	f7 4f       	sbci	r31, 0xF7	; 247
    2180:	80 81       	ld	r24, Z
    2182:	82 30       	cpi	r24, 0x02	; 2
    2184:	40 f4       	brcc	.+16     	; 0x2196 <xTaskIncrementTick+0x158>
    2186:	09 c0       	rjmp	.+18     	; 0x219a <xTaskIncrementTick+0x15c>
    2188:	80 91 2c 08 	lds	r24, 0x082C
    218c:	8f 5f       	subi	r24, 0xFF	; 255
    218e:	80 93 2c 08 	sts	0x082C, r24
    2192:	d1 2c       	mov	r13, r1
    2194:	02 c0       	rjmp	.+4      	; 0x219a <xTaskIncrementTick+0x15c>
    2196:	dd 24       	eor	r13, r13
    2198:	d3 94       	inc	r13
    219a:	80 91 2b 08 	lds	r24, 0x082B
    219e:	88 23       	and	r24, r24
    21a0:	11 f0       	breq	.+4      	; 0x21a6 <xTaskIncrementTick+0x168>
    21a2:	dd 24       	eor	r13, r13
    21a4:	d3 94       	inc	r13
    21a6:	8d 2d       	mov	r24, r13
    21a8:	df 91       	pop	r29
    21aa:	cf 91       	pop	r28
    21ac:	1f 91       	pop	r17
    21ae:	0f 91       	pop	r16
    21b0:	ff 90       	pop	r15
    21b2:	ef 90       	pop	r14
    21b4:	df 90       	pop	r13
    21b6:	cf 90       	pop	r12
    21b8:	08 95       	ret

000021ba <xTaskResumeAll>:
    21ba:	df 92       	push	r13
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	0f 92       	push	r0
    21ce:	80 91 28 08 	lds	r24, 0x0828
    21d2:	81 50       	subi	r24, 0x01	; 1
    21d4:	80 93 28 08 	sts	0x0828, r24
    21d8:	80 91 28 08 	lds	r24, 0x0828
    21dc:	81 11       	cpse	r24, r1
    21de:	5f c0       	rjmp	.+190    	; 0x229e <__stack+0x9f>
    21e0:	80 91 31 08 	lds	r24, 0x0831
    21e4:	88 23       	and	r24, r24
    21e6:	09 f4       	brne	.+2      	; 0x21ea <xTaskResumeAll+0x30>
    21e8:	5c c0       	rjmp	.+184    	; 0x22a2 <__stack+0xa3>
    21ea:	0f 2e       	mov	r0, r31
    21ec:	f5 e4       	ldi	r31, 0x45	; 69
    21ee:	ef 2e       	mov	r14, r31
    21f0:	f8 e0       	ldi	r31, 0x08	; 8
    21f2:	ff 2e       	mov	r15, r31
    21f4:	f0 2d       	mov	r31, r0
    21f6:	dd 24       	eor	r13, r13
    21f8:	d3 94       	inc	r13
    21fa:	30 c0       	rjmp	.+96     	; 0x225c <__stack+0x5d>
    21fc:	e0 91 4a 08 	lds	r30, 0x084A
    2200:	f0 91 4b 08 	lds	r31, 0x084B
    2204:	c6 81       	ldd	r28, Z+6	; 0x06
    2206:	d7 81       	ldd	r29, Z+7	; 0x07
    2208:	ce 01       	movw	r24, r28
    220a:	0c 96       	adiw	r24, 0x0c	; 12
    220c:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    2210:	8e 01       	movw	r16, r28
    2212:	0e 5f       	subi	r16, 0xFE	; 254
    2214:	1f 4f       	sbci	r17, 0xFF	; 255
    2216:	c8 01       	movw	r24, r16
    2218:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    221c:	8e 89       	ldd	r24, Y+22	; 0x16
    221e:	90 91 2e 08 	lds	r25, 0x082E
    2222:	98 17       	cp	r25, r24
    2224:	10 f4       	brcc	.+4      	; 0x222a <__stack+0x2b>
    2226:	80 93 2e 08 	sts	0x082E, r24
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	9c 01       	movw	r18, r24
    222e:	22 0f       	add	r18, r18
    2230:	33 1f       	adc	r19, r19
    2232:	22 0f       	add	r18, r18
    2234:	33 1f       	adc	r19, r19
    2236:	22 0f       	add	r18, r18
    2238:	33 1f       	adc	r19, r19
    223a:	82 0f       	add	r24, r18
    223c:	93 1f       	adc	r25, r19
    223e:	b8 01       	movw	r22, r16
    2240:	8c 59       	subi	r24, 0x9C	; 156
    2242:	97 4f       	sbci	r25, 0xF7	; 247
    2244:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    2248:	e0 91 91 08 	lds	r30, 0x0891
    224c:	f0 91 92 08 	lds	r31, 0x0892
    2250:	9e 89       	ldd	r25, Y+22	; 0x16
    2252:	86 89       	ldd	r24, Z+22	; 0x16
    2254:	98 17       	cp	r25, r24
    2256:	10 f0       	brcs	.+4      	; 0x225c <__stack+0x5d>
    2258:	d0 92 2b 08 	sts	0x082B, r13
    225c:	f7 01       	movw	r30, r14
    225e:	80 81       	ld	r24, Z
    2260:	81 11       	cpse	r24, r1
    2262:	cc cf       	rjmp	.-104    	; 0x21fc <xTaskResumeAll+0x42>
    2264:	80 91 2c 08 	lds	r24, 0x082C
    2268:	88 23       	and	r24, r24
    226a:	91 f0       	breq	.+36     	; 0x2290 <__stack+0x91>
    226c:	80 91 2c 08 	lds	r24, 0x082C
    2270:	88 23       	and	r24, r24
    2272:	71 f0       	breq	.+28     	; 0x2290 <__stack+0x91>
    2274:	c1 e0       	ldi	r28, 0x01	; 1
    2276:	e3 de       	rcall	.-570    	; 0x203e <xTaskIncrementTick>
    2278:	81 11       	cpse	r24, r1
    227a:	c0 93 2b 08 	sts	0x082B, r28
    227e:	80 91 2c 08 	lds	r24, 0x082C
    2282:	81 50       	subi	r24, 0x01	; 1
    2284:	80 93 2c 08 	sts	0x082C, r24
    2288:	80 91 2c 08 	lds	r24, 0x082C
    228c:	81 11       	cpse	r24, r1
    228e:	f3 cf       	rjmp	.-26     	; 0x2276 <__stack+0x77>
    2290:	80 91 2b 08 	lds	r24, 0x082B
    2294:	81 30       	cpi	r24, 0x01	; 1
    2296:	39 f4       	brne	.+14     	; 0x22a6 <__stack+0xa7>
    2298:	fc d8       	rcall	.-3592   	; 0x1492 <vPortYield>
    229a:	81 e0       	ldi	r24, 0x01	; 1
    229c:	05 c0       	rjmp	.+10     	; 0x22a8 <__stack+0xa9>
    229e:	80 e0       	ldi	r24, 0x00	; 0
    22a0:	03 c0       	rjmp	.+6      	; 0x22a8 <__stack+0xa9>
    22a2:	80 e0       	ldi	r24, 0x00	; 0
    22a4:	01 c0       	rjmp	.+2      	; 0x22a8 <__stack+0xa9>
    22a6:	80 e0       	ldi	r24, 0x00	; 0
    22a8:	0f 90       	pop	r0
    22aa:	0f be       	out	0x3f, r0	; 63
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	ff 90       	pop	r15
    22b6:	ef 90       	pop	r14
    22b8:	df 90       	pop	r13
    22ba:	08 95       	ret

000022bc <vTaskDelayUntil>:
    22bc:	0f 93       	push	r16
    22be:	1f 93       	push	r17
    22c0:	cf 93       	push	r28
    22c2:	df 93       	push	r29
    22c4:	8c 01       	movw	r16, r24
    22c6:	eb 01       	movw	r28, r22
    22c8:	a5 de       	rcall	.-694    	; 0x2014 <vTaskSuspendAll>
    22ca:	80 91 2f 08 	lds	r24, 0x082F
    22ce:	90 91 30 08 	lds	r25, 0x0830
    22d2:	f8 01       	movw	r30, r16
    22d4:	20 81       	ld	r18, Z
    22d6:	31 81       	ldd	r19, Z+1	; 0x01
    22d8:	c2 0f       	add	r28, r18
    22da:	d3 1f       	adc	r29, r19
    22dc:	82 17       	cp	r24, r18
    22de:	93 07       	cpc	r25, r19
    22e0:	48 f4       	brcc	.+18     	; 0x22f4 <vTaskDelayUntil+0x38>
    22e2:	c2 17       	cp	r28, r18
    22e4:	d3 07       	cpc	r29, r19
    22e6:	f8 f4       	brcc	.+62     	; 0x2326 <vTaskDelayUntil+0x6a>
    22e8:	d1 83       	std	Z+1, r29	; 0x01
    22ea:	c0 83       	st	Z, r28
    22ec:	8c 17       	cp	r24, r28
    22ee:	9d 07       	cpc	r25, r29
    22f0:	88 f4       	brcc	.+34     	; 0x2314 <vTaskDelayUntil+0x58>
    22f2:	07 c0       	rjmp	.+14     	; 0x2302 <vTaskDelayUntil+0x46>
    22f4:	c2 17       	cp	r28, r18
    22f6:	d3 07       	cpc	r29, r19
    22f8:	90 f0       	brcs	.+36     	; 0x231e <vTaskDelayUntil+0x62>
    22fa:	8c 17       	cp	r24, r28
    22fc:	9d 07       	cpc	r25, r29
    22fe:	78 f0       	brcs	.+30     	; 0x231e <vTaskDelayUntil+0x62>
    2300:	12 c0       	rjmp	.+36     	; 0x2326 <vTaskDelayUntil+0x6a>
    2302:	80 91 91 08 	lds	r24, 0x0891
    2306:	90 91 92 08 	lds	r25, 0x0892
    230a:	02 96       	adiw	r24, 0x02	; 2
    230c:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    2310:	ce 01       	movw	r24, r28
    2312:	c0 dc       	rcall	.-1664   	; 0x1c94 <prvAddCurrentTaskToDelayedList>
    2314:	52 df       	rcall	.-348    	; 0x21ba <xTaskResumeAll>
    2316:	81 11       	cpse	r24, r1
    2318:	0a c0       	rjmp	.+20     	; 0x232e <vTaskDelayUntil+0x72>
    231a:	bb d8       	rcall	.-3722   	; 0x1492 <vPortYield>
    231c:	08 c0       	rjmp	.+16     	; 0x232e <vTaskDelayUntil+0x72>
    231e:	f8 01       	movw	r30, r16
    2320:	d1 83       	std	Z+1, r29	; 0x01
    2322:	c0 83       	st	Z, r28
    2324:	ee cf       	rjmp	.-36     	; 0x2302 <vTaskDelayUntil+0x46>
    2326:	f8 01       	movw	r30, r16
    2328:	d1 83       	std	Z+1, r29	; 0x01
    232a:	c0 83       	st	Z, r28
    232c:	f3 cf       	rjmp	.-26     	; 0x2314 <vTaskDelayUntil+0x58>
    232e:	df 91       	pop	r29
    2330:	cf 91       	pop	r28
    2332:	1f 91       	pop	r17
    2334:	0f 91       	pop	r16
    2336:	08 95       	ret

00002338 <prvIdleTask>:
    2338:	0f 2e       	mov	r0, r31
    233a:	f4 e6       	ldi	r31, 0x64	; 100
    233c:	ef 2e       	mov	r14, r31
    233e:	f8 e0       	ldi	r31, 0x08	; 8
    2340:	ff 2e       	mov	r15, r31
    2342:	f0 2d       	mov	r31, r0
    2344:	cc e3       	ldi	r28, 0x3C	; 60
    2346:	d8 e0       	ldi	r29, 0x08	; 8
    2348:	26 c0       	rjmp	.+76     	; 0x2396 <prvIdleTask+0x5e>
    234a:	64 de       	rcall	.-824    	; 0x2014 <vTaskSuspendAll>
    234c:	18 81       	ld	r17, Y
    234e:	35 df       	rcall	.-406    	; 0x21ba <xTaskResumeAll>
    2350:	11 23       	and	r17, r17
    2352:	09 f1       	breq	.+66     	; 0x2396 <prvIdleTask+0x5e>
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	0f 92       	push	r0
    235a:	e0 91 41 08 	lds	r30, 0x0841
    235e:	f0 91 42 08 	lds	r31, 0x0842
    2362:	06 81       	ldd	r16, Z+6	; 0x06
    2364:	17 81       	ldd	r17, Z+7	; 0x07
    2366:	c8 01       	movw	r24, r16
    2368:	02 96       	adiw	r24, 0x02	; 2
    236a:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    236e:	80 91 31 08 	lds	r24, 0x0831
    2372:	81 50       	subi	r24, 0x01	; 1
    2374:	80 93 31 08 	sts	0x0831, r24
    2378:	80 91 3b 08 	lds	r24, 0x083B
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	80 93 3b 08 	sts	0x083B, r24
    2382:	0f 90       	pop	r0
    2384:	0f be       	out	0x3f, r0	; 63
    2386:	f8 01       	movw	r30, r16
    2388:	87 89       	ldd	r24, Z+23	; 0x17
    238a:	90 8d       	ldd	r25, Z+24	; 0x18
    238c:	0e 94 48 03 	call	0x690	; 0x690 <vPortFree>
    2390:	c8 01       	movw	r24, r16
    2392:	0e 94 48 03 	call	0x690	; 0x690 <vPortFree>
    2396:	80 91 3b 08 	lds	r24, 0x083B
    239a:	81 11       	cpse	r24, r1
    239c:	d6 cf       	rjmp	.-84     	; 0x234a <prvIdleTask+0x12>
    239e:	f7 01       	movw	r30, r14
    23a0:	80 81       	ld	r24, Z
    23a2:	82 30       	cpi	r24, 0x02	; 2
    23a4:	c0 f3       	brcs	.-16     	; 0x2396 <prvIdleTask+0x5e>
    23a6:	75 d8       	rcall	.-3862   	; 0x1492 <vPortYield>
    23a8:	f6 cf       	rjmp	.-20     	; 0x2396 <prvIdleTask+0x5e>

000023aa <vTaskSwitchContext>:
    23aa:	80 91 28 08 	lds	r24, 0x0828
    23ae:	88 23       	and	r24, r24
    23b0:	21 f0       	breq	.+8      	; 0x23ba <vTaskSwitchContext+0x10>
    23b2:	81 e0       	ldi	r24, 0x01	; 1
    23b4:	80 93 2b 08 	sts	0x082B, r24
    23b8:	08 95       	ret
    23ba:	10 92 2b 08 	sts	0x082B, r1
    23be:	80 91 2e 08 	lds	r24, 0x082E
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	fc 01       	movw	r30, r24
    23c6:	ee 0f       	add	r30, r30
    23c8:	ff 1f       	adc	r31, r31
    23ca:	ee 0f       	add	r30, r30
    23cc:	ff 1f       	adc	r31, r31
    23ce:	ee 0f       	add	r30, r30
    23d0:	ff 1f       	adc	r31, r31
    23d2:	8e 0f       	add	r24, r30
    23d4:	9f 1f       	adc	r25, r31
    23d6:	fc 01       	movw	r30, r24
    23d8:	ec 59       	subi	r30, 0x9C	; 156
    23da:	f7 4f       	sbci	r31, 0xF7	; 247
    23dc:	80 81       	ld	r24, Z
    23de:	81 11       	cpse	r24, r1
    23e0:	17 c0       	rjmp	.+46     	; 0x2410 <vTaskSwitchContext+0x66>
    23e2:	80 91 2e 08 	lds	r24, 0x082E
    23e6:	81 50       	subi	r24, 0x01	; 1
    23e8:	80 93 2e 08 	sts	0x082E, r24
    23ec:	80 91 2e 08 	lds	r24, 0x082E
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	fc 01       	movw	r30, r24
    23f4:	ee 0f       	add	r30, r30
    23f6:	ff 1f       	adc	r31, r31
    23f8:	ee 0f       	add	r30, r30
    23fa:	ff 1f       	adc	r31, r31
    23fc:	ee 0f       	add	r30, r30
    23fe:	ff 1f       	adc	r31, r31
    2400:	8e 0f       	add	r24, r30
    2402:	9f 1f       	adc	r25, r31
    2404:	fc 01       	movw	r30, r24
    2406:	ec 59       	subi	r30, 0x9C	; 156
    2408:	f7 4f       	sbci	r31, 0xF7	; 247
    240a:	80 81       	ld	r24, Z
    240c:	88 23       	and	r24, r24
    240e:	49 f3       	breq	.-46     	; 0x23e2 <vTaskSwitchContext+0x38>
    2410:	e0 91 2e 08 	lds	r30, 0x082E
    2414:	f0 e0       	ldi	r31, 0x00	; 0
    2416:	cf 01       	movw	r24, r30
    2418:	88 0f       	add	r24, r24
    241a:	99 1f       	adc	r25, r25
    241c:	88 0f       	add	r24, r24
    241e:	99 1f       	adc	r25, r25
    2420:	88 0f       	add	r24, r24
    2422:	99 1f       	adc	r25, r25
    2424:	e8 0f       	add	r30, r24
    2426:	f9 1f       	adc	r31, r25
    2428:	ec 59       	subi	r30, 0x9C	; 156
    242a:	f7 4f       	sbci	r31, 0xF7	; 247
    242c:	a1 81       	ldd	r26, Z+1	; 0x01
    242e:	b2 81       	ldd	r27, Z+2	; 0x02
    2430:	12 96       	adiw	r26, 0x02	; 2
    2432:	0d 90       	ld	r0, X+
    2434:	bc 91       	ld	r27, X
    2436:	a0 2d       	mov	r26, r0
    2438:	b2 83       	std	Z+2, r27	; 0x02
    243a:	a1 83       	std	Z+1, r26	; 0x01
    243c:	cf 01       	movw	r24, r30
    243e:	03 96       	adiw	r24, 0x03	; 3
    2440:	a8 17       	cp	r26, r24
    2442:	b9 07       	cpc	r27, r25
    2444:	31 f4       	brne	.+12     	; 0x2452 <vTaskSwitchContext+0xa8>
    2446:	12 96       	adiw	r26, 0x02	; 2
    2448:	8d 91       	ld	r24, X+
    244a:	9c 91       	ld	r25, X
    244c:	13 97       	sbiw	r26, 0x03	; 3
    244e:	92 83       	std	Z+2, r25	; 0x02
    2450:	81 83       	std	Z+1, r24	; 0x01
    2452:	01 80       	ldd	r0, Z+1	; 0x01
    2454:	f2 81       	ldd	r31, Z+2	; 0x02
    2456:	e0 2d       	mov	r30, r0
    2458:	86 81       	ldd	r24, Z+6	; 0x06
    245a:	97 81       	ldd	r25, Z+7	; 0x07
    245c:	90 93 92 08 	sts	0x0892, r25
    2460:	80 93 91 08 	sts	0x0891, r24
    2464:	08 95       	ret

00002466 <vTaskSuspend>:
    2466:	0f 93       	push	r16
    2468:	1f 93       	push	r17
    246a:	cf 93       	push	r28
    246c:	df 93       	push	r29
    246e:	ec 01       	movw	r28, r24
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	0f 92       	push	r0
    2476:	00 97       	sbiw	r24, 0x00	; 0
    2478:	21 f4       	brne	.+8      	; 0x2482 <vTaskSuspend+0x1c>
    247a:	c0 91 91 08 	lds	r28, 0x0891
    247e:	d0 91 92 08 	lds	r29, 0x0892
    2482:	8e 01       	movw	r16, r28
    2484:	0e 5f       	subi	r16, 0xFE	; 254
    2486:	1f 4f       	sbci	r17, 0xFF	; 255
    2488:	c8 01       	movw	r24, r16
    248a:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    248e:	8c 89       	ldd	r24, Y+20	; 0x14
    2490:	9d 89       	ldd	r25, Y+21	; 0x15
    2492:	89 2b       	or	r24, r25
    2494:	21 f0       	breq	.+8      	; 0x249e <vTaskSuspend+0x38>
    2496:	ce 01       	movw	r24, r28
    2498:	0c 96       	adiw	r24, 0x0c	; 12
    249a:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    249e:	b8 01       	movw	r22, r16
    24a0:	82 e3       	ldi	r24, 0x32	; 50
    24a2:	98 e0       	ldi	r25, 0x08	; 8
    24a4:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    24a8:	0f 90       	pop	r0
    24aa:	0f be       	out	0x3f, r0	; 63
    24ac:	80 91 91 08 	lds	r24, 0x0891
    24b0:	90 91 92 08 	lds	r25, 0x0892
    24b4:	c8 17       	cp	r28, r24
    24b6:	d9 07       	cpc	r29, r25
    24b8:	a1 f4       	brne	.+40     	; 0x24e2 <vTaskSuspend+0x7c>
    24ba:	80 91 2d 08 	lds	r24, 0x082D
    24be:	88 23       	and	r24, r24
    24c0:	19 f0       	breq	.+6      	; 0x24c8 <vTaskSuspend+0x62>
    24c2:	0e 94 49 0a 	call	0x1492	; 0x1492 <vPortYield>
    24c6:	17 c0       	rjmp	.+46     	; 0x24f6 <vTaskSuspend+0x90>
    24c8:	80 91 31 08 	lds	r24, 0x0831
    24cc:	90 91 32 08 	lds	r25, 0x0832
    24d0:	98 13       	cpse	r25, r24
    24d2:	05 c0       	rjmp	.+10     	; 0x24de <vTaskSuspend+0x78>
    24d4:	10 92 92 08 	sts	0x0892, r1
    24d8:	10 92 91 08 	sts	0x0891, r1
    24dc:	0c c0       	rjmp	.+24     	; 0x24f6 <vTaskSuspend+0x90>
    24de:	65 df       	rcall	.-310    	; 0x23aa <vTaskSwitchContext>
    24e0:	0a c0       	rjmp	.+20     	; 0x24f6 <vTaskSuspend+0x90>
    24e2:	80 91 2d 08 	lds	r24, 0x082D
    24e6:	88 23       	and	r24, r24
    24e8:	31 f0       	breq	.+12     	; 0x24f6 <vTaskSuspend+0x90>
    24ea:	0f b6       	in	r0, 0x3f	; 63
    24ec:	f8 94       	cli
    24ee:	0f 92       	push	r0
    24f0:	b2 db       	rcall	.-2204   	; 0x1c56 <prvResetNextTaskUnblockTime>
    24f2:	0f 90       	pop	r0
    24f4:	0f be       	out	0x3f, r0	; 63
    24f6:	df 91       	pop	r29
    24f8:	cf 91       	pop	r28
    24fa:	1f 91       	pop	r17
    24fc:	0f 91       	pop	r16
    24fe:	08 95       	ret

00002500 <vTaskPlaceOnEventList>:
    2500:	cf 93       	push	r28
    2502:	df 93       	push	r29
    2504:	eb 01       	movw	r28, r22
    2506:	60 91 91 08 	lds	r22, 0x0891
    250a:	70 91 92 08 	lds	r23, 0x0892
    250e:	64 5f       	subi	r22, 0xF4	; 244
    2510:	7f 4f       	sbci	r23, 0xFF	; 255
    2512:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vListInsert>
    2516:	80 91 91 08 	lds	r24, 0x0891
    251a:	90 91 92 08 	lds	r25, 0x0892
    251e:	02 96       	adiw	r24, 0x02	; 2
    2520:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    2524:	cf 3f       	cpi	r28, 0xFF	; 255
    2526:	8f ef       	ldi	r24, 0xFF	; 255
    2528:	d8 07       	cpc	r29, r24
    252a:	59 f4       	brne	.+22     	; 0x2542 <vTaskPlaceOnEventList+0x42>
    252c:	60 91 91 08 	lds	r22, 0x0891
    2530:	70 91 92 08 	lds	r23, 0x0892
    2534:	6e 5f       	subi	r22, 0xFE	; 254
    2536:	7f 4f       	sbci	r23, 0xFF	; 255
    2538:	82 e3       	ldi	r24, 0x32	; 50
    253a:	98 e0       	ldi	r25, 0x08	; 8
    253c:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    2540:	07 c0       	rjmp	.+14     	; 0x2550 <vTaskPlaceOnEventList+0x50>
    2542:	80 91 2f 08 	lds	r24, 0x082F
    2546:	90 91 30 08 	lds	r25, 0x0830
    254a:	8c 0f       	add	r24, r28
    254c:	9d 1f       	adc	r25, r29
    254e:	a2 db       	rcall	.-2236   	; 0x1c94 <prvAddCurrentTaskToDelayedList>
    2550:	df 91       	pop	r29
    2552:	cf 91       	pop	r28
    2554:	08 95       	ret

00002556 <xTaskRemoveFromEventList>:
    2556:	0f 93       	push	r16
    2558:	1f 93       	push	r17
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	dc 01       	movw	r26, r24
    2560:	15 96       	adiw	r26, 0x05	; 5
    2562:	ed 91       	ld	r30, X+
    2564:	fc 91       	ld	r31, X
    2566:	16 97       	sbiw	r26, 0x06	; 6
    2568:	c6 81       	ldd	r28, Z+6	; 0x06
    256a:	d7 81       	ldd	r29, Z+7	; 0x07
    256c:	8e 01       	movw	r16, r28
    256e:	04 5f       	subi	r16, 0xF4	; 244
    2570:	1f 4f       	sbci	r17, 0xFF	; 255
    2572:	c8 01       	movw	r24, r16
    2574:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    2578:	80 91 28 08 	lds	r24, 0x0828
    257c:	81 11       	cpse	r24, r1
    257e:	1c c0       	rjmp	.+56     	; 0x25b8 <xTaskRemoveFromEventList+0x62>
    2580:	0a 50       	subi	r16, 0x0A	; 10
    2582:	11 09       	sbc	r17, r1
    2584:	c8 01       	movw	r24, r16
    2586:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    258a:	8e 89       	ldd	r24, Y+22	; 0x16
    258c:	90 91 2e 08 	lds	r25, 0x082E
    2590:	98 17       	cp	r25, r24
    2592:	10 f4       	brcc	.+4      	; 0x2598 <xTaskRemoveFromEventList+0x42>
    2594:	80 93 2e 08 	sts	0x082E, r24
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	9c 01       	movw	r18, r24
    259c:	22 0f       	add	r18, r18
    259e:	33 1f       	adc	r19, r19
    25a0:	22 0f       	add	r18, r18
    25a2:	33 1f       	adc	r19, r19
    25a4:	22 0f       	add	r18, r18
    25a6:	33 1f       	adc	r19, r19
    25a8:	82 0f       	add	r24, r18
    25aa:	93 1f       	adc	r25, r19
    25ac:	b8 01       	movw	r22, r16
    25ae:	8c 59       	subi	r24, 0x9C	; 156
    25b0:	97 4f       	sbci	r25, 0xF7	; 247
    25b2:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    25b6:	05 c0       	rjmp	.+10     	; 0x25c2 <xTaskRemoveFromEventList+0x6c>
    25b8:	b8 01       	movw	r22, r16
    25ba:	85 e4       	ldi	r24, 0x45	; 69
    25bc:	98 e0       	ldi	r25, 0x08	; 8
    25be:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    25c2:	e0 91 91 08 	lds	r30, 0x0891
    25c6:	f0 91 92 08 	lds	r31, 0x0892
    25ca:	9e 89       	ldd	r25, Y+22	; 0x16
    25cc:	86 89       	ldd	r24, Z+22	; 0x16
    25ce:	89 17       	cp	r24, r25
    25d0:	20 f4       	brcc	.+8      	; 0x25da <xTaskRemoveFromEventList+0x84>
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	80 93 2b 08 	sts	0x082B, r24
    25d8:	01 c0       	rjmp	.+2      	; 0x25dc <xTaskRemoveFromEventList+0x86>
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	df 91       	pop	r29
    25de:	cf 91       	pop	r28
    25e0:	1f 91       	pop	r17
    25e2:	0f 91       	pop	r16
    25e4:	08 95       	ret

000025e6 <vTaskSetTimeOutState>:
    25e6:	20 91 2a 08 	lds	r18, 0x082A
    25ea:	fc 01       	movw	r30, r24
    25ec:	20 83       	st	Z, r18
    25ee:	20 91 2f 08 	lds	r18, 0x082F
    25f2:	30 91 30 08 	lds	r19, 0x0830
    25f6:	32 83       	std	Z+2, r19	; 0x02
    25f8:	21 83       	std	Z+1, r18	; 0x01
    25fa:	08 95       	ret

000025fc <xTaskCheckForTimeOut>:
    25fc:	0f b6       	in	r0, 0x3f	; 63
    25fe:	f8 94       	cli
    2600:	0f 92       	push	r0
    2602:	40 91 2f 08 	lds	r20, 0x082F
    2606:	50 91 30 08 	lds	r21, 0x0830
    260a:	db 01       	movw	r26, r22
    260c:	2d 91       	ld	r18, X+
    260e:	3c 91       	ld	r19, X
    2610:	2f 3f       	cpi	r18, 0xFF	; 255
    2612:	bf ef       	ldi	r27, 0xFF	; 255
    2614:	3b 07       	cpc	r19, r27
    2616:	11 f1       	breq	.+68     	; 0x265c <xTaskCheckForTimeOut+0x60>
    2618:	e0 91 2a 08 	lds	r30, 0x082A
    261c:	dc 01       	movw	r26, r24
    261e:	fc 91       	ld	r31, X
    2620:	fe 17       	cp	r31, r30
    2622:	39 f0       	breq	.+14     	; 0x2632 <xTaskCheckForTimeOut+0x36>
    2624:	11 96       	adiw	r26, 0x01	; 1
    2626:	ed 91       	ld	r30, X+
    2628:	fc 91       	ld	r31, X
    262a:	12 97       	sbiw	r26, 0x02	; 2
    262c:	4e 17       	cp	r20, r30
    262e:	5f 07       	cpc	r21, r31
    2630:	b8 f4       	brcc	.+46     	; 0x2660 <xTaskCheckForTimeOut+0x64>
    2632:	dc 01       	movw	r26, r24
    2634:	11 96       	adiw	r26, 0x01	; 1
    2636:	ed 91       	ld	r30, X+
    2638:	fc 91       	ld	r31, X
    263a:	12 97       	sbiw	r26, 0x02	; 2
    263c:	da 01       	movw	r26, r20
    263e:	ae 1b       	sub	r26, r30
    2640:	bf 0b       	sbc	r27, r31
    2642:	a2 17       	cp	r26, r18
    2644:	b3 07       	cpc	r27, r19
    2646:	70 f4       	brcc	.+28     	; 0x2664 <xTaskCheckForTimeOut+0x68>
    2648:	e4 1b       	sub	r30, r20
    264a:	f5 0b       	sbc	r31, r21
    264c:	2e 0f       	add	r18, r30
    264e:	3f 1f       	adc	r19, r31
    2650:	fb 01       	movw	r30, r22
    2652:	31 83       	std	Z+1, r19	; 0x01
    2654:	20 83       	st	Z, r18
    2656:	c7 df       	rcall	.-114    	; 0x25e6 <vTaskSetTimeOutState>
    2658:	80 e0       	ldi	r24, 0x00	; 0
    265a:	05 c0       	rjmp	.+10     	; 0x2666 <xTaskCheckForTimeOut+0x6a>
    265c:	80 e0       	ldi	r24, 0x00	; 0
    265e:	03 c0       	rjmp	.+6      	; 0x2666 <xTaskCheckForTimeOut+0x6a>
    2660:	81 e0       	ldi	r24, 0x01	; 1
    2662:	01 c0       	rjmp	.+2      	; 0x2666 <xTaskCheckForTimeOut+0x6a>
    2664:	81 e0       	ldi	r24, 0x01	; 1
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	08 95       	ret

0000266c <vTaskMissedYield>:
    266c:	81 e0       	ldi	r24, 0x01	; 1
    266e:	80 93 2b 08 	sts	0x082B, r24
    2672:	08 95       	ret

00002674 <vTaskPriorityInherit>:
    2674:	0f 93       	push	r16
    2676:	1f 93       	push	r17
    2678:	cf 93       	push	r28
    267a:	df 93       	push	r29
    267c:	ec 01       	movw	r28, r24
    267e:	00 97       	sbiw	r24, 0x00	; 0
    2680:	09 f4       	brne	.+2      	; 0x2684 <vTaskPriorityInherit+0x10>
    2682:	51 c0       	rjmp	.+162    	; 0x2726 <vTaskPriorityInherit+0xb2>
    2684:	8e 89       	ldd	r24, Y+22	; 0x16
    2686:	e0 91 91 08 	lds	r30, 0x0891
    268a:	f0 91 92 08 	lds	r31, 0x0892
    268e:	96 89       	ldd	r25, Z+22	; 0x16
    2690:	89 17       	cp	r24, r25
    2692:	08 f0       	brcs	.+2      	; 0x2696 <vTaskPriorityInherit+0x22>
    2694:	48 c0       	rjmp	.+144    	; 0x2726 <vTaskPriorityInherit+0xb2>
    2696:	2c 85       	ldd	r18, Y+12	; 0x0c
    2698:	3d 85       	ldd	r19, Y+13	; 0x0d
    269a:	33 23       	and	r19, r19
    269c:	5c f0       	brlt	.+22     	; 0x26b4 <vTaskPriorityInherit+0x40>
    269e:	e0 91 91 08 	lds	r30, 0x0891
    26a2:	f0 91 92 08 	lds	r31, 0x0892
    26a6:	96 89       	ldd	r25, Z+22	; 0x16
    26a8:	25 e0       	ldi	r18, 0x05	; 5
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	29 1b       	sub	r18, r25
    26ae:	31 09       	sbc	r19, r1
    26b0:	3d 87       	std	Y+13, r19	; 0x0d
    26b2:	2c 87       	std	Y+12, r18	; 0x0c
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	9c 01       	movw	r18, r24
    26b8:	22 0f       	add	r18, r18
    26ba:	33 1f       	adc	r19, r19
    26bc:	22 0f       	add	r18, r18
    26be:	33 1f       	adc	r19, r19
    26c0:	22 0f       	add	r18, r18
    26c2:	33 1f       	adc	r19, r19
    26c4:	82 0f       	add	r24, r18
    26c6:	93 1f       	adc	r25, r19
    26c8:	8c 59       	subi	r24, 0x9C	; 156
    26ca:	97 4f       	sbci	r25, 0xF7	; 247
    26cc:	2a 85       	ldd	r18, Y+10	; 0x0a
    26ce:	3b 85       	ldd	r19, Y+11	; 0x0b
    26d0:	28 17       	cp	r18, r24
    26d2:	39 07       	cpc	r19, r25
    26d4:	11 f5       	brne	.+68     	; 0x271a <vTaskPriorityInherit+0xa6>
    26d6:	8e 01       	movw	r16, r28
    26d8:	0e 5f       	subi	r16, 0xFE	; 254
    26da:	1f 4f       	sbci	r17, 0xFF	; 255
    26dc:	c8 01       	movw	r24, r16
    26de:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    26e2:	e0 91 91 08 	lds	r30, 0x0891
    26e6:	f0 91 92 08 	lds	r31, 0x0892
    26ea:	86 89       	ldd	r24, Z+22	; 0x16
    26ec:	8e 8b       	std	Y+22, r24	; 0x16
    26ee:	90 91 2e 08 	lds	r25, 0x082E
    26f2:	98 17       	cp	r25, r24
    26f4:	10 f4       	brcc	.+4      	; 0x26fa <vTaskPriorityInherit+0x86>
    26f6:	80 93 2e 08 	sts	0x082E, r24
    26fa:	90 e0       	ldi	r25, 0x00	; 0
    26fc:	9c 01       	movw	r18, r24
    26fe:	22 0f       	add	r18, r18
    2700:	33 1f       	adc	r19, r19
    2702:	22 0f       	add	r18, r18
    2704:	33 1f       	adc	r19, r19
    2706:	22 0f       	add	r18, r18
    2708:	33 1f       	adc	r19, r19
    270a:	82 0f       	add	r24, r18
    270c:	93 1f       	adc	r25, r19
    270e:	b8 01       	movw	r22, r16
    2710:	8c 59       	subi	r24, 0x9C	; 156
    2712:	97 4f       	sbci	r25, 0xF7	; 247
    2714:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    2718:	06 c0       	rjmp	.+12     	; 0x2726 <vTaskPriorityInherit+0xb2>
    271a:	e0 91 91 08 	lds	r30, 0x0891
    271e:	f0 91 92 08 	lds	r31, 0x0892
    2722:	86 89       	ldd	r24, Z+22	; 0x16
    2724:	8e 8b       	std	Y+22, r24	; 0x16
    2726:	df 91       	pop	r29
    2728:	cf 91       	pop	r28
    272a:	1f 91       	pop	r17
    272c:	0f 91       	pop	r16
    272e:	08 95       	ret

00002730 <xTaskPriorityDisinherit>:
    2730:	0f 93       	push	r16
    2732:	1f 93       	push	r17
    2734:	cf 93       	push	r28
    2736:	df 93       	push	r29
    2738:	ec 01       	movw	r28, r24
    273a:	00 97       	sbiw	r24, 0x00	; 0
    273c:	71 f1       	breq	.+92     	; 0x279a <xTaskPriorityDisinherit+0x6a>
    273e:	8a a1       	ldd	r24, Y+34	; 0x22
    2740:	81 50       	subi	r24, 0x01	; 1
    2742:	8a a3       	std	Y+34, r24	; 0x22
    2744:	2e 89       	ldd	r18, Y+22	; 0x16
    2746:	99 a1       	ldd	r25, Y+33	; 0x21
    2748:	29 17       	cp	r18, r25
    274a:	49 f1       	breq	.+82     	; 0x279e <xTaskPriorityDisinherit+0x6e>
    274c:	81 11       	cpse	r24, r1
    274e:	29 c0       	rjmp	.+82     	; 0x27a2 <xTaskPriorityDisinherit+0x72>
    2750:	8e 01       	movw	r16, r28
    2752:	0e 5f       	subi	r16, 0xFE	; 254
    2754:	1f 4f       	sbci	r17, 0xFF	; 255
    2756:	c8 01       	movw	r24, r16
    2758:	0e 94 ad 03 	call	0x75a	; 0x75a <uxListRemove>
    275c:	89 a1       	ldd	r24, Y+33	; 0x21
    275e:	8e 8b       	std	Y+22, r24	; 0x16
    2760:	25 e0       	ldi	r18, 0x05	; 5
    2762:	30 e0       	ldi	r19, 0x00	; 0
    2764:	28 1b       	sub	r18, r24
    2766:	31 09       	sbc	r19, r1
    2768:	3d 87       	std	Y+13, r19	; 0x0d
    276a:	2c 87       	std	Y+12, r18	; 0x0c
    276c:	90 91 2e 08 	lds	r25, 0x082E
    2770:	98 17       	cp	r25, r24
    2772:	10 f4       	brcc	.+4      	; 0x2778 <xTaskPriorityDisinherit+0x48>
    2774:	80 93 2e 08 	sts	0x082E, r24
    2778:	90 e0       	ldi	r25, 0x00	; 0
    277a:	9c 01       	movw	r18, r24
    277c:	22 0f       	add	r18, r18
    277e:	33 1f       	adc	r19, r19
    2780:	22 0f       	add	r18, r18
    2782:	33 1f       	adc	r19, r19
    2784:	22 0f       	add	r18, r18
    2786:	33 1f       	adc	r19, r19
    2788:	82 0f       	add	r24, r18
    278a:	93 1f       	adc	r25, r19
    278c:	b8 01       	movw	r22, r16
    278e:	8c 59       	subi	r24, 0x9C	; 156
    2790:	97 4f       	sbci	r25, 0xF7	; 247
    2792:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInsertEnd>
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	05 c0       	rjmp	.+10     	; 0x27a4 <xTaskPriorityDisinherit+0x74>
    279a:	80 e0       	ldi	r24, 0x00	; 0
    279c:	03 c0       	rjmp	.+6      	; 0x27a4 <xTaskPriorityDisinherit+0x74>
    279e:	80 e0       	ldi	r24, 0x00	; 0
    27a0:	01 c0       	rjmp	.+2      	; 0x27a4 <xTaskPriorityDisinherit+0x74>
    27a2:	80 e0       	ldi	r24, 0x00	; 0
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	1f 91       	pop	r17
    27aa:	0f 91       	pop	r16
    27ac:	08 95       	ret

000027ae <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    27ae:	80 91 91 08 	lds	r24, 0x0891
    27b2:	90 91 92 08 	lds	r25, 0x0892
    27b6:	89 2b       	or	r24, r25
    27b8:	39 f0       	breq	.+14     	; 0x27c8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    27ba:	e0 91 91 08 	lds	r30, 0x0891
    27be:	f0 91 92 08 	lds	r31, 0x0892
    27c2:	82 a1       	ldd	r24, Z+34	; 0x22
    27c4:	8f 5f       	subi	r24, 0xFF	; 255
    27c6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    27c8:	80 91 91 08 	lds	r24, 0x0891
    27cc:	90 91 92 08 	lds	r25, 0x0892
	}
    27d0:	08 95       	ret

000027d2 <__subsf3>:
    27d2:	50 58       	subi	r21, 0x80	; 128

000027d4 <__addsf3>:
    27d4:	bb 27       	eor	r27, r27
    27d6:	aa 27       	eor	r26, r26
    27d8:	0e d0       	rcall	.+28     	; 0x27f6 <__addsf3x>
    27da:	e5 c0       	rjmp	.+458    	; 0x29a6 <__fp_round>
    27dc:	d6 d0       	rcall	.+428    	; 0x298a <__fp_pscA>
    27de:	30 f0       	brcs	.+12     	; 0x27ec <__addsf3+0x18>
    27e0:	db d0       	rcall	.+438    	; 0x2998 <__fp_pscB>
    27e2:	20 f0       	brcs	.+8      	; 0x27ec <__addsf3+0x18>
    27e4:	31 f4       	brne	.+12     	; 0x27f2 <__addsf3+0x1e>
    27e6:	9f 3f       	cpi	r25, 0xFF	; 255
    27e8:	11 f4       	brne	.+4      	; 0x27ee <__addsf3+0x1a>
    27ea:	1e f4       	brtc	.+6      	; 0x27f2 <__addsf3+0x1e>
    27ec:	cb c0       	rjmp	.+406    	; 0x2984 <__fp_nan>
    27ee:	0e f4       	brtc	.+2      	; 0x27f2 <__addsf3+0x1e>
    27f0:	e0 95       	com	r30
    27f2:	e7 fb       	bst	r30, 7
    27f4:	c1 c0       	rjmp	.+386    	; 0x2978 <__fp_inf>

000027f6 <__addsf3x>:
    27f6:	e9 2f       	mov	r30, r25
    27f8:	e7 d0       	rcall	.+462    	; 0x29c8 <__fp_split3>
    27fa:	80 f3       	brcs	.-32     	; 0x27dc <__addsf3+0x8>
    27fc:	ba 17       	cp	r27, r26
    27fe:	62 07       	cpc	r22, r18
    2800:	73 07       	cpc	r23, r19
    2802:	84 07       	cpc	r24, r20
    2804:	95 07       	cpc	r25, r21
    2806:	18 f0       	brcs	.+6      	; 0x280e <__addsf3x+0x18>
    2808:	71 f4       	brne	.+28     	; 0x2826 <__addsf3x+0x30>
    280a:	9e f5       	brtc	.+102    	; 0x2872 <__addsf3x+0x7c>
    280c:	ff c0       	rjmp	.+510    	; 0x2a0c <__fp_zero>
    280e:	0e f4       	brtc	.+2      	; 0x2812 <__addsf3x+0x1c>
    2810:	e0 95       	com	r30
    2812:	0b 2e       	mov	r0, r27
    2814:	ba 2f       	mov	r27, r26
    2816:	a0 2d       	mov	r26, r0
    2818:	0b 01       	movw	r0, r22
    281a:	b9 01       	movw	r22, r18
    281c:	90 01       	movw	r18, r0
    281e:	0c 01       	movw	r0, r24
    2820:	ca 01       	movw	r24, r20
    2822:	a0 01       	movw	r20, r0
    2824:	11 24       	eor	r1, r1
    2826:	ff 27       	eor	r31, r31
    2828:	59 1b       	sub	r21, r25
    282a:	99 f0       	breq	.+38     	; 0x2852 <__addsf3x+0x5c>
    282c:	59 3f       	cpi	r21, 0xF9	; 249
    282e:	50 f4       	brcc	.+20     	; 0x2844 <__addsf3x+0x4e>
    2830:	50 3e       	cpi	r21, 0xE0	; 224
    2832:	68 f1       	brcs	.+90     	; 0x288e <__addsf3x+0x98>
    2834:	1a 16       	cp	r1, r26
    2836:	f0 40       	sbci	r31, 0x00	; 0
    2838:	a2 2f       	mov	r26, r18
    283a:	23 2f       	mov	r18, r19
    283c:	34 2f       	mov	r19, r20
    283e:	44 27       	eor	r20, r20
    2840:	58 5f       	subi	r21, 0xF8	; 248
    2842:	f3 cf       	rjmp	.-26     	; 0x282a <__addsf3x+0x34>
    2844:	46 95       	lsr	r20
    2846:	37 95       	ror	r19
    2848:	27 95       	ror	r18
    284a:	a7 95       	ror	r26
    284c:	f0 40       	sbci	r31, 0x00	; 0
    284e:	53 95       	inc	r21
    2850:	c9 f7       	brne	.-14     	; 0x2844 <__addsf3x+0x4e>
    2852:	7e f4       	brtc	.+30     	; 0x2872 <__addsf3x+0x7c>
    2854:	1f 16       	cp	r1, r31
    2856:	ba 0b       	sbc	r27, r26
    2858:	62 0b       	sbc	r22, r18
    285a:	73 0b       	sbc	r23, r19
    285c:	84 0b       	sbc	r24, r20
    285e:	ba f0       	brmi	.+46     	; 0x288e <__addsf3x+0x98>
    2860:	91 50       	subi	r25, 0x01	; 1
    2862:	a1 f0       	breq	.+40     	; 0x288c <__addsf3x+0x96>
    2864:	ff 0f       	add	r31, r31
    2866:	bb 1f       	adc	r27, r27
    2868:	66 1f       	adc	r22, r22
    286a:	77 1f       	adc	r23, r23
    286c:	88 1f       	adc	r24, r24
    286e:	c2 f7       	brpl	.-16     	; 0x2860 <__addsf3x+0x6a>
    2870:	0e c0       	rjmp	.+28     	; 0x288e <__addsf3x+0x98>
    2872:	ba 0f       	add	r27, r26
    2874:	62 1f       	adc	r22, r18
    2876:	73 1f       	adc	r23, r19
    2878:	84 1f       	adc	r24, r20
    287a:	48 f4       	brcc	.+18     	; 0x288e <__addsf3x+0x98>
    287c:	87 95       	ror	r24
    287e:	77 95       	ror	r23
    2880:	67 95       	ror	r22
    2882:	b7 95       	ror	r27
    2884:	f7 95       	ror	r31
    2886:	9e 3f       	cpi	r25, 0xFE	; 254
    2888:	08 f0       	brcs	.+2      	; 0x288c <__addsf3x+0x96>
    288a:	b3 cf       	rjmp	.-154    	; 0x27f2 <__addsf3+0x1e>
    288c:	93 95       	inc	r25
    288e:	88 0f       	add	r24, r24
    2890:	08 f0       	brcs	.+2      	; 0x2894 <__addsf3x+0x9e>
    2892:	99 27       	eor	r25, r25
    2894:	ee 0f       	add	r30, r30
    2896:	97 95       	ror	r25
    2898:	87 95       	ror	r24
    289a:	08 95       	ret

0000289c <__fixsfsi>:
    289c:	04 d0       	rcall	.+8      	; 0x28a6 <__fixunssfsi>
    289e:	68 94       	set
    28a0:	b1 11       	cpse	r27, r1
    28a2:	b5 c0       	rjmp	.+362    	; 0x2a0e <__fp_szero>
    28a4:	08 95       	ret

000028a6 <__fixunssfsi>:
    28a6:	98 d0       	rcall	.+304    	; 0x29d8 <__fp_splitA>
    28a8:	88 f0       	brcs	.+34     	; 0x28cc <__fixunssfsi+0x26>
    28aa:	9f 57       	subi	r25, 0x7F	; 127
    28ac:	90 f0       	brcs	.+36     	; 0x28d2 <__fixunssfsi+0x2c>
    28ae:	b9 2f       	mov	r27, r25
    28b0:	99 27       	eor	r25, r25
    28b2:	b7 51       	subi	r27, 0x17	; 23
    28b4:	a0 f0       	brcs	.+40     	; 0x28de <__fixunssfsi+0x38>
    28b6:	d1 f0       	breq	.+52     	; 0x28ec <__fixunssfsi+0x46>
    28b8:	66 0f       	add	r22, r22
    28ba:	77 1f       	adc	r23, r23
    28bc:	88 1f       	adc	r24, r24
    28be:	99 1f       	adc	r25, r25
    28c0:	1a f0       	brmi	.+6      	; 0x28c8 <__fixunssfsi+0x22>
    28c2:	ba 95       	dec	r27
    28c4:	c9 f7       	brne	.-14     	; 0x28b8 <__fixunssfsi+0x12>
    28c6:	12 c0       	rjmp	.+36     	; 0x28ec <__fixunssfsi+0x46>
    28c8:	b1 30       	cpi	r27, 0x01	; 1
    28ca:	81 f0       	breq	.+32     	; 0x28ec <__fixunssfsi+0x46>
    28cc:	9f d0       	rcall	.+318    	; 0x2a0c <__fp_zero>
    28ce:	b1 e0       	ldi	r27, 0x01	; 1
    28d0:	08 95       	ret
    28d2:	9c c0       	rjmp	.+312    	; 0x2a0c <__fp_zero>
    28d4:	67 2f       	mov	r22, r23
    28d6:	78 2f       	mov	r23, r24
    28d8:	88 27       	eor	r24, r24
    28da:	b8 5f       	subi	r27, 0xF8	; 248
    28dc:	39 f0       	breq	.+14     	; 0x28ec <__fixunssfsi+0x46>
    28de:	b9 3f       	cpi	r27, 0xF9	; 249
    28e0:	cc f3       	brlt	.-14     	; 0x28d4 <__fixunssfsi+0x2e>
    28e2:	86 95       	lsr	r24
    28e4:	77 95       	ror	r23
    28e6:	67 95       	ror	r22
    28e8:	b3 95       	inc	r27
    28ea:	d9 f7       	brne	.-10     	; 0x28e2 <__fixunssfsi+0x3c>
    28ec:	3e f4       	brtc	.+14     	; 0x28fc <__fixunssfsi+0x56>
    28ee:	90 95       	com	r25
    28f0:	80 95       	com	r24
    28f2:	70 95       	com	r23
    28f4:	61 95       	neg	r22
    28f6:	7f 4f       	sbci	r23, 0xFF	; 255
    28f8:	8f 4f       	sbci	r24, 0xFF	; 255
    28fa:	9f 4f       	sbci	r25, 0xFF	; 255
    28fc:	08 95       	ret

000028fe <__floatunsisf>:
    28fe:	e8 94       	clt
    2900:	09 c0       	rjmp	.+18     	; 0x2914 <__floatsisf+0x12>

00002902 <__floatsisf>:
    2902:	97 fb       	bst	r25, 7
    2904:	3e f4       	brtc	.+14     	; 0x2914 <__floatsisf+0x12>
    2906:	90 95       	com	r25
    2908:	80 95       	com	r24
    290a:	70 95       	com	r23
    290c:	61 95       	neg	r22
    290e:	7f 4f       	sbci	r23, 0xFF	; 255
    2910:	8f 4f       	sbci	r24, 0xFF	; 255
    2912:	9f 4f       	sbci	r25, 0xFF	; 255
    2914:	99 23       	and	r25, r25
    2916:	a9 f0       	breq	.+42     	; 0x2942 <__floatsisf+0x40>
    2918:	f9 2f       	mov	r31, r25
    291a:	96 e9       	ldi	r25, 0x96	; 150
    291c:	bb 27       	eor	r27, r27
    291e:	93 95       	inc	r25
    2920:	f6 95       	lsr	r31
    2922:	87 95       	ror	r24
    2924:	77 95       	ror	r23
    2926:	67 95       	ror	r22
    2928:	b7 95       	ror	r27
    292a:	f1 11       	cpse	r31, r1
    292c:	f8 cf       	rjmp	.-16     	; 0x291e <__floatsisf+0x1c>
    292e:	fa f4       	brpl	.+62     	; 0x296e <__floatsisf+0x6c>
    2930:	bb 0f       	add	r27, r27
    2932:	11 f4       	brne	.+4      	; 0x2938 <__floatsisf+0x36>
    2934:	60 ff       	sbrs	r22, 0
    2936:	1b c0       	rjmp	.+54     	; 0x296e <__floatsisf+0x6c>
    2938:	6f 5f       	subi	r22, 0xFF	; 255
    293a:	7f 4f       	sbci	r23, 0xFF	; 255
    293c:	8f 4f       	sbci	r24, 0xFF	; 255
    293e:	9f 4f       	sbci	r25, 0xFF	; 255
    2940:	16 c0       	rjmp	.+44     	; 0x296e <__floatsisf+0x6c>
    2942:	88 23       	and	r24, r24
    2944:	11 f0       	breq	.+4      	; 0x294a <__floatsisf+0x48>
    2946:	96 e9       	ldi	r25, 0x96	; 150
    2948:	11 c0       	rjmp	.+34     	; 0x296c <__floatsisf+0x6a>
    294a:	77 23       	and	r23, r23
    294c:	21 f0       	breq	.+8      	; 0x2956 <__floatsisf+0x54>
    294e:	9e e8       	ldi	r25, 0x8E	; 142
    2950:	87 2f       	mov	r24, r23
    2952:	76 2f       	mov	r23, r22
    2954:	05 c0       	rjmp	.+10     	; 0x2960 <__floatsisf+0x5e>
    2956:	66 23       	and	r22, r22
    2958:	71 f0       	breq	.+28     	; 0x2976 <__floatsisf+0x74>
    295a:	96 e8       	ldi	r25, 0x86	; 134
    295c:	86 2f       	mov	r24, r22
    295e:	70 e0       	ldi	r23, 0x00	; 0
    2960:	60 e0       	ldi	r22, 0x00	; 0
    2962:	2a f0       	brmi	.+10     	; 0x296e <__floatsisf+0x6c>
    2964:	9a 95       	dec	r25
    2966:	66 0f       	add	r22, r22
    2968:	77 1f       	adc	r23, r23
    296a:	88 1f       	adc	r24, r24
    296c:	da f7       	brpl	.-10     	; 0x2964 <__floatsisf+0x62>
    296e:	88 0f       	add	r24, r24
    2970:	96 95       	lsr	r25
    2972:	87 95       	ror	r24
    2974:	97 f9       	bld	r25, 7
    2976:	08 95       	ret

00002978 <__fp_inf>:
    2978:	97 f9       	bld	r25, 7
    297a:	9f 67       	ori	r25, 0x7F	; 127
    297c:	80 e8       	ldi	r24, 0x80	; 128
    297e:	70 e0       	ldi	r23, 0x00	; 0
    2980:	60 e0       	ldi	r22, 0x00	; 0
    2982:	08 95       	ret

00002984 <__fp_nan>:
    2984:	9f ef       	ldi	r25, 0xFF	; 255
    2986:	80 ec       	ldi	r24, 0xC0	; 192
    2988:	08 95       	ret

0000298a <__fp_pscA>:
    298a:	00 24       	eor	r0, r0
    298c:	0a 94       	dec	r0
    298e:	16 16       	cp	r1, r22
    2990:	17 06       	cpc	r1, r23
    2992:	18 06       	cpc	r1, r24
    2994:	09 06       	cpc	r0, r25
    2996:	08 95       	ret

00002998 <__fp_pscB>:
    2998:	00 24       	eor	r0, r0
    299a:	0a 94       	dec	r0
    299c:	12 16       	cp	r1, r18
    299e:	13 06       	cpc	r1, r19
    29a0:	14 06       	cpc	r1, r20
    29a2:	05 06       	cpc	r0, r21
    29a4:	08 95       	ret

000029a6 <__fp_round>:
    29a6:	09 2e       	mov	r0, r25
    29a8:	03 94       	inc	r0
    29aa:	00 0c       	add	r0, r0
    29ac:	11 f4       	brne	.+4      	; 0x29b2 <__fp_round+0xc>
    29ae:	88 23       	and	r24, r24
    29b0:	52 f0       	brmi	.+20     	; 0x29c6 <__fp_round+0x20>
    29b2:	bb 0f       	add	r27, r27
    29b4:	40 f4       	brcc	.+16     	; 0x29c6 <__fp_round+0x20>
    29b6:	bf 2b       	or	r27, r31
    29b8:	11 f4       	brne	.+4      	; 0x29be <__fp_round+0x18>
    29ba:	60 ff       	sbrs	r22, 0
    29bc:	04 c0       	rjmp	.+8      	; 0x29c6 <__fp_round+0x20>
    29be:	6f 5f       	subi	r22, 0xFF	; 255
    29c0:	7f 4f       	sbci	r23, 0xFF	; 255
    29c2:	8f 4f       	sbci	r24, 0xFF	; 255
    29c4:	9f 4f       	sbci	r25, 0xFF	; 255
    29c6:	08 95       	ret

000029c8 <__fp_split3>:
    29c8:	57 fd       	sbrc	r21, 7
    29ca:	90 58       	subi	r25, 0x80	; 128
    29cc:	44 0f       	add	r20, r20
    29ce:	55 1f       	adc	r21, r21
    29d0:	59 f0       	breq	.+22     	; 0x29e8 <__fp_splitA+0x10>
    29d2:	5f 3f       	cpi	r21, 0xFF	; 255
    29d4:	71 f0       	breq	.+28     	; 0x29f2 <__fp_splitA+0x1a>
    29d6:	47 95       	ror	r20

000029d8 <__fp_splitA>:
    29d8:	88 0f       	add	r24, r24
    29da:	97 fb       	bst	r25, 7
    29dc:	99 1f       	adc	r25, r25
    29de:	61 f0       	breq	.+24     	; 0x29f8 <__fp_splitA+0x20>
    29e0:	9f 3f       	cpi	r25, 0xFF	; 255
    29e2:	79 f0       	breq	.+30     	; 0x2a02 <__fp_splitA+0x2a>
    29e4:	87 95       	ror	r24
    29e6:	08 95       	ret
    29e8:	12 16       	cp	r1, r18
    29ea:	13 06       	cpc	r1, r19
    29ec:	14 06       	cpc	r1, r20
    29ee:	55 1f       	adc	r21, r21
    29f0:	f2 cf       	rjmp	.-28     	; 0x29d6 <__fp_split3+0xe>
    29f2:	46 95       	lsr	r20
    29f4:	f1 df       	rcall	.-30     	; 0x29d8 <__fp_splitA>
    29f6:	08 c0       	rjmp	.+16     	; 0x2a08 <__fp_splitA+0x30>
    29f8:	16 16       	cp	r1, r22
    29fa:	17 06       	cpc	r1, r23
    29fc:	18 06       	cpc	r1, r24
    29fe:	99 1f       	adc	r25, r25
    2a00:	f1 cf       	rjmp	.-30     	; 0x29e4 <__fp_splitA+0xc>
    2a02:	86 95       	lsr	r24
    2a04:	71 05       	cpc	r23, r1
    2a06:	61 05       	cpc	r22, r1
    2a08:	08 94       	sec
    2a0a:	08 95       	ret

00002a0c <__fp_zero>:
    2a0c:	e8 94       	clt

00002a0e <__fp_szero>:
    2a0e:	bb 27       	eor	r27, r27
    2a10:	66 27       	eor	r22, r22
    2a12:	77 27       	eor	r23, r23
    2a14:	cb 01       	movw	r24, r22
    2a16:	97 f9       	bld	r25, 7
    2a18:	08 95       	ret

00002a1a <__mulsf3>:
    2a1a:	0b d0       	rcall	.+22     	; 0x2a32 <__mulsf3x>
    2a1c:	c4 cf       	rjmp	.-120    	; 0x29a6 <__fp_round>
    2a1e:	b5 df       	rcall	.-150    	; 0x298a <__fp_pscA>
    2a20:	28 f0       	brcs	.+10     	; 0x2a2c <__mulsf3+0x12>
    2a22:	ba df       	rcall	.-140    	; 0x2998 <__fp_pscB>
    2a24:	18 f0       	brcs	.+6      	; 0x2a2c <__mulsf3+0x12>
    2a26:	95 23       	and	r25, r21
    2a28:	09 f0       	breq	.+2      	; 0x2a2c <__mulsf3+0x12>
    2a2a:	a6 cf       	rjmp	.-180    	; 0x2978 <__fp_inf>
    2a2c:	ab cf       	rjmp	.-170    	; 0x2984 <__fp_nan>
    2a2e:	11 24       	eor	r1, r1
    2a30:	ee cf       	rjmp	.-36     	; 0x2a0e <__fp_szero>

00002a32 <__mulsf3x>:
    2a32:	ca df       	rcall	.-108    	; 0x29c8 <__fp_split3>
    2a34:	a0 f3       	brcs	.-24     	; 0x2a1e <__mulsf3+0x4>

00002a36 <__mulsf3_pse>:
    2a36:	95 9f       	mul	r25, r21
    2a38:	d1 f3       	breq	.-12     	; 0x2a2e <__mulsf3+0x14>
    2a3a:	95 0f       	add	r25, r21
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	55 1f       	adc	r21, r21
    2a40:	62 9f       	mul	r22, r18
    2a42:	f0 01       	movw	r30, r0
    2a44:	72 9f       	mul	r23, r18
    2a46:	bb 27       	eor	r27, r27
    2a48:	f0 0d       	add	r31, r0
    2a4a:	b1 1d       	adc	r27, r1
    2a4c:	63 9f       	mul	r22, r19
    2a4e:	aa 27       	eor	r26, r26
    2a50:	f0 0d       	add	r31, r0
    2a52:	b1 1d       	adc	r27, r1
    2a54:	aa 1f       	adc	r26, r26
    2a56:	64 9f       	mul	r22, r20
    2a58:	66 27       	eor	r22, r22
    2a5a:	b0 0d       	add	r27, r0
    2a5c:	a1 1d       	adc	r26, r1
    2a5e:	66 1f       	adc	r22, r22
    2a60:	82 9f       	mul	r24, r18
    2a62:	22 27       	eor	r18, r18
    2a64:	b0 0d       	add	r27, r0
    2a66:	a1 1d       	adc	r26, r1
    2a68:	62 1f       	adc	r22, r18
    2a6a:	73 9f       	mul	r23, r19
    2a6c:	b0 0d       	add	r27, r0
    2a6e:	a1 1d       	adc	r26, r1
    2a70:	62 1f       	adc	r22, r18
    2a72:	83 9f       	mul	r24, r19
    2a74:	a0 0d       	add	r26, r0
    2a76:	61 1d       	adc	r22, r1
    2a78:	22 1f       	adc	r18, r18
    2a7a:	74 9f       	mul	r23, r20
    2a7c:	33 27       	eor	r19, r19
    2a7e:	a0 0d       	add	r26, r0
    2a80:	61 1d       	adc	r22, r1
    2a82:	23 1f       	adc	r18, r19
    2a84:	84 9f       	mul	r24, r20
    2a86:	60 0d       	add	r22, r0
    2a88:	21 1d       	adc	r18, r1
    2a8a:	82 2f       	mov	r24, r18
    2a8c:	76 2f       	mov	r23, r22
    2a8e:	6a 2f       	mov	r22, r26
    2a90:	11 24       	eor	r1, r1
    2a92:	9f 57       	subi	r25, 0x7F	; 127
    2a94:	50 40       	sbci	r21, 0x00	; 0
    2a96:	8a f0       	brmi	.+34     	; 0x2aba <__mulsf3_pse+0x84>
    2a98:	e1 f0       	breq	.+56     	; 0x2ad2 <__mulsf3_pse+0x9c>
    2a9a:	88 23       	and	r24, r24
    2a9c:	4a f0       	brmi	.+18     	; 0x2ab0 <__mulsf3_pse+0x7a>
    2a9e:	ee 0f       	add	r30, r30
    2aa0:	ff 1f       	adc	r31, r31
    2aa2:	bb 1f       	adc	r27, r27
    2aa4:	66 1f       	adc	r22, r22
    2aa6:	77 1f       	adc	r23, r23
    2aa8:	88 1f       	adc	r24, r24
    2aaa:	91 50       	subi	r25, 0x01	; 1
    2aac:	50 40       	sbci	r21, 0x00	; 0
    2aae:	a9 f7       	brne	.-22     	; 0x2a9a <__mulsf3_pse+0x64>
    2ab0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ab2:	51 05       	cpc	r21, r1
    2ab4:	70 f0       	brcs	.+28     	; 0x2ad2 <__mulsf3_pse+0x9c>
    2ab6:	60 cf       	rjmp	.-320    	; 0x2978 <__fp_inf>
    2ab8:	aa cf       	rjmp	.-172    	; 0x2a0e <__fp_szero>
    2aba:	5f 3f       	cpi	r21, 0xFF	; 255
    2abc:	ec f3       	brlt	.-6      	; 0x2ab8 <__mulsf3_pse+0x82>
    2abe:	98 3e       	cpi	r25, 0xE8	; 232
    2ac0:	dc f3       	brlt	.-10     	; 0x2ab8 <__mulsf3_pse+0x82>
    2ac2:	86 95       	lsr	r24
    2ac4:	77 95       	ror	r23
    2ac6:	67 95       	ror	r22
    2ac8:	b7 95       	ror	r27
    2aca:	f7 95       	ror	r31
    2acc:	e7 95       	ror	r30
    2ace:	9f 5f       	subi	r25, 0xFF	; 255
    2ad0:	c1 f7       	brne	.-16     	; 0x2ac2 <__mulsf3_pse+0x8c>
    2ad2:	fe 2b       	or	r31, r30
    2ad4:	88 0f       	add	r24, r24
    2ad6:	91 1d       	adc	r25, r1
    2ad8:	96 95       	lsr	r25
    2ada:	87 95       	ror	r24
    2adc:	97 f9       	bld	r25, 7
    2ade:	08 95       	ret

00002ae0 <pow>:
    2ae0:	fa 01       	movw	r30, r20
    2ae2:	ee 0f       	add	r30, r30
    2ae4:	ff 1f       	adc	r31, r31
    2ae6:	30 96       	adiw	r30, 0x00	; 0
    2ae8:	21 05       	cpc	r18, r1
    2aea:	31 05       	cpc	r19, r1
    2aec:	99 f1       	breq	.+102    	; 0x2b54 <pow+0x74>
    2aee:	61 15       	cp	r22, r1
    2af0:	71 05       	cpc	r23, r1
    2af2:	61 f4       	brne	.+24     	; 0x2b0c <pow+0x2c>
    2af4:	80 38       	cpi	r24, 0x80	; 128
    2af6:	bf e3       	ldi	r27, 0x3F	; 63
    2af8:	9b 07       	cpc	r25, r27
    2afa:	49 f1       	breq	.+82     	; 0x2b4e <pow+0x6e>
    2afc:	68 94       	set
    2afe:	90 38       	cpi	r25, 0x80	; 128
    2b00:	81 05       	cpc	r24, r1
    2b02:	61 f0       	breq	.+24     	; 0x2b1c <pow+0x3c>
    2b04:	80 38       	cpi	r24, 0x80	; 128
    2b06:	bf ef       	ldi	r27, 0xFF	; 255
    2b08:	9b 07       	cpc	r25, r27
    2b0a:	41 f0       	breq	.+16     	; 0x2b1c <pow+0x3c>
    2b0c:	99 23       	and	r25, r25
    2b0e:	42 f5       	brpl	.+80     	; 0x2b60 <pow+0x80>
    2b10:	ff 3f       	cpi	r31, 0xFF	; 255
    2b12:	e1 05       	cpc	r30, r1
    2b14:	31 05       	cpc	r19, r1
    2b16:	21 05       	cpc	r18, r1
    2b18:	11 f1       	breq	.+68     	; 0x2b5e <pow+0x7e>
    2b1a:	e8 94       	clt
    2b1c:	08 94       	sec
    2b1e:	e7 95       	ror	r30
    2b20:	d9 01       	movw	r26, r18
    2b22:	aa 23       	and	r26, r26
    2b24:	29 f4       	brne	.+10     	; 0x2b30 <pow+0x50>
    2b26:	ab 2f       	mov	r26, r27
    2b28:	be 2f       	mov	r27, r30
    2b2a:	f8 5f       	subi	r31, 0xF8	; 248
    2b2c:	d0 f3       	brcs	.-12     	; 0x2b22 <pow+0x42>
    2b2e:	10 c0       	rjmp	.+32     	; 0x2b50 <pow+0x70>
    2b30:	ff 5f       	subi	r31, 0xFF	; 255
    2b32:	70 f4       	brcc	.+28     	; 0x2b50 <pow+0x70>
    2b34:	a6 95       	lsr	r26
    2b36:	e0 f7       	brcc	.-8      	; 0x2b30 <pow+0x50>
    2b38:	f7 39       	cpi	r31, 0x97	; 151
    2b3a:	50 f0       	brcs	.+20     	; 0x2b50 <pow+0x70>
    2b3c:	19 f0       	breq	.+6      	; 0x2b44 <pow+0x64>
    2b3e:	ff 3a       	cpi	r31, 0xAF	; 175
    2b40:	38 f4       	brcc	.+14     	; 0x2b50 <pow+0x70>
    2b42:	9f 77       	andi	r25, 0x7F	; 127
    2b44:	9f 93       	push	r25
    2b46:	0c d0       	rcall	.+24     	; 0x2b60 <pow+0x80>
    2b48:	0f 90       	pop	r0
    2b4a:	07 fc       	sbrc	r0, 7
    2b4c:	90 58       	subi	r25, 0x80	; 128
    2b4e:	08 95       	ret
    2b50:	3e f0       	brts	.+14     	; 0x2b60 <pow+0x80>
    2b52:	18 cf       	rjmp	.-464    	; 0x2984 <__fp_nan>
    2b54:	60 e0       	ldi	r22, 0x00	; 0
    2b56:	70 e0       	ldi	r23, 0x00	; 0
    2b58:	80 e8       	ldi	r24, 0x80	; 128
    2b5a:	9f e3       	ldi	r25, 0x3F	; 63
    2b5c:	08 95       	ret
    2b5e:	4f e7       	ldi	r20, 0x7F	; 127
    2b60:	9f 77       	andi	r25, 0x7F	; 127
    2b62:	5f 93       	push	r21
    2b64:	4f 93       	push	r20
    2b66:	3f 93       	push	r19
    2b68:	2f 93       	push	r18
    2b6a:	9e d0       	rcall	.+316    	; 0x2ca8 <log>
    2b6c:	2f 91       	pop	r18
    2b6e:	3f 91       	pop	r19
    2b70:	4f 91       	pop	r20
    2b72:	5f 91       	pop	r21
    2b74:	52 df       	rcall	.-348    	; 0x2a1a <__mulsf3>
    2b76:	05 c0       	rjmp	.+10     	; 0x2b82 <exp>
    2b78:	19 f4       	brne	.+6      	; 0x2b80 <pow+0xa0>
    2b7a:	0e f0       	brts	.+2      	; 0x2b7e <pow+0x9e>
    2b7c:	fd ce       	rjmp	.-518    	; 0x2978 <__fp_inf>
    2b7e:	46 cf       	rjmp	.-372    	; 0x2a0c <__fp_zero>
    2b80:	01 cf       	rjmp	.-510    	; 0x2984 <__fp_nan>

00002b82 <exp>:
    2b82:	2a df       	rcall	.-428    	; 0x29d8 <__fp_splitA>
    2b84:	c8 f3       	brcs	.-14     	; 0x2b78 <pow+0x98>
    2b86:	96 38       	cpi	r25, 0x86	; 134
    2b88:	c0 f7       	brcc	.-16     	; 0x2b7a <pow+0x9a>
    2b8a:	07 f8       	bld	r0, 7
    2b8c:	0f 92       	push	r0
    2b8e:	e8 94       	clt
    2b90:	2b e3       	ldi	r18, 0x3B	; 59
    2b92:	3a ea       	ldi	r19, 0xAA	; 170
    2b94:	48 eb       	ldi	r20, 0xB8	; 184
    2b96:	5f e7       	ldi	r21, 0x7F	; 127
    2b98:	4e df       	rcall	.-356    	; 0x2a36 <__mulsf3_pse>
    2b9a:	0f 92       	push	r0
    2b9c:	0f 92       	push	r0
    2b9e:	0f 92       	push	r0
    2ba0:	4d b7       	in	r20, 0x3d	; 61
    2ba2:	5e b7       	in	r21, 0x3e	; 62
    2ba4:	0f 92       	push	r0
    2ba6:	c0 d0       	rcall	.+384    	; 0x2d28 <modf>
    2ba8:	e4 ee       	ldi	r30, 0xE4	; 228
    2baa:	f0 e0       	ldi	r31, 0x00	; 0
    2bac:	16 d0       	rcall	.+44     	; 0x2bda <__fp_powser>
    2bae:	4f 91       	pop	r20
    2bb0:	5f 91       	pop	r21
    2bb2:	ef 91       	pop	r30
    2bb4:	ff 91       	pop	r31
    2bb6:	e5 95       	asr	r30
    2bb8:	ee 1f       	adc	r30, r30
    2bba:	ff 1f       	adc	r31, r31
    2bbc:	49 f0       	breq	.+18     	; 0x2bd0 <exp+0x4e>
    2bbe:	fe 57       	subi	r31, 0x7E	; 126
    2bc0:	e0 68       	ori	r30, 0x80	; 128
    2bc2:	44 27       	eor	r20, r20
    2bc4:	ee 0f       	add	r30, r30
    2bc6:	44 1f       	adc	r20, r20
    2bc8:	fa 95       	dec	r31
    2bca:	e1 f7       	brne	.-8      	; 0x2bc4 <exp+0x42>
    2bcc:	41 95       	neg	r20
    2bce:	55 0b       	sbc	r21, r21
    2bd0:	32 d0       	rcall	.+100    	; 0x2c36 <ldexp>
    2bd2:	0f 90       	pop	r0
    2bd4:	07 fe       	sbrs	r0, 7
    2bd6:	26 c0       	rjmp	.+76     	; 0x2c24 <inverse>
    2bd8:	08 95       	ret

00002bda <__fp_powser>:
    2bda:	df 93       	push	r29
    2bdc:	cf 93       	push	r28
    2bde:	1f 93       	push	r17
    2be0:	0f 93       	push	r16
    2be2:	ff 92       	push	r15
    2be4:	ef 92       	push	r14
    2be6:	df 92       	push	r13
    2be8:	7b 01       	movw	r14, r22
    2bea:	8c 01       	movw	r16, r24
    2bec:	68 94       	set
    2bee:	05 c0       	rjmp	.+10     	; 0x2bfa <__fp_powser+0x20>
    2bf0:	da 2e       	mov	r13, r26
    2bf2:	ef 01       	movw	r28, r30
    2bf4:	1e df       	rcall	.-452    	; 0x2a32 <__mulsf3x>
    2bf6:	fe 01       	movw	r30, r28
    2bf8:	e8 94       	clt
    2bfa:	a5 91       	lpm	r26, Z+
    2bfc:	25 91       	lpm	r18, Z+
    2bfe:	35 91       	lpm	r19, Z+
    2c00:	45 91       	lpm	r20, Z+
    2c02:	55 91       	lpm	r21, Z+
    2c04:	ae f3       	brts	.-22     	; 0x2bf0 <__fp_powser+0x16>
    2c06:	ef 01       	movw	r28, r30
    2c08:	f6 dd       	rcall	.-1044   	; 0x27f6 <__addsf3x>
    2c0a:	fe 01       	movw	r30, r28
    2c0c:	97 01       	movw	r18, r14
    2c0e:	a8 01       	movw	r20, r16
    2c10:	da 94       	dec	r13
    2c12:	79 f7       	brne	.-34     	; 0x2bf2 <__fp_powser+0x18>
    2c14:	df 90       	pop	r13
    2c16:	ef 90       	pop	r14
    2c18:	ff 90       	pop	r15
    2c1a:	0f 91       	pop	r16
    2c1c:	1f 91       	pop	r17
    2c1e:	cf 91       	pop	r28
    2c20:	df 91       	pop	r29
    2c22:	08 95       	ret

00002c24 <inverse>:
    2c24:	9b 01       	movw	r18, r22
    2c26:	ac 01       	movw	r20, r24
    2c28:	60 e0       	ldi	r22, 0x00	; 0
    2c2a:	70 e0       	ldi	r23, 0x00	; 0
    2c2c:	80 e8       	ldi	r24, 0x80	; 128
    2c2e:	9f e3       	ldi	r25, 0x3F	; 63
    2c30:	ae c0       	rjmp	.+348    	; 0x2d8e <__divsf3>
    2c32:	a2 ce       	rjmp	.-700    	; 0x2978 <__fp_inf>
    2c34:	14 c1       	rjmp	.+552    	; 0x2e5e <__fp_mpack>

00002c36 <ldexp>:
    2c36:	d0 de       	rcall	.-608    	; 0x29d8 <__fp_splitA>
    2c38:	e8 f3       	brcs	.-6      	; 0x2c34 <inverse+0x10>
    2c3a:	99 23       	and	r25, r25
    2c3c:	d9 f3       	breq	.-10     	; 0x2c34 <inverse+0x10>
    2c3e:	94 0f       	add	r25, r20
    2c40:	51 1d       	adc	r21, r1
    2c42:	bb f3       	brvs	.-18     	; 0x2c32 <inverse+0xe>
    2c44:	91 50       	subi	r25, 0x01	; 1
    2c46:	50 40       	sbci	r21, 0x00	; 0
    2c48:	94 f0       	brlt	.+36     	; 0x2c6e <ldexp+0x38>
    2c4a:	59 f0       	breq	.+22     	; 0x2c62 <ldexp+0x2c>
    2c4c:	88 23       	and	r24, r24
    2c4e:	32 f0       	brmi	.+12     	; 0x2c5c <ldexp+0x26>
    2c50:	66 0f       	add	r22, r22
    2c52:	77 1f       	adc	r23, r23
    2c54:	88 1f       	adc	r24, r24
    2c56:	91 50       	subi	r25, 0x01	; 1
    2c58:	50 40       	sbci	r21, 0x00	; 0
    2c5a:	c1 f7       	brne	.-16     	; 0x2c4c <ldexp+0x16>
    2c5c:	9e 3f       	cpi	r25, 0xFE	; 254
    2c5e:	51 05       	cpc	r21, r1
    2c60:	44 f7       	brge	.-48     	; 0x2c32 <inverse+0xe>
    2c62:	88 0f       	add	r24, r24
    2c64:	91 1d       	adc	r25, r1
    2c66:	96 95       	lsr	r25
    2c68:	87 95       	ror	r24
    2c6a:	97 f9       	bld	r25, 7
    2c6c:	08 95       	ret
    2c6e:	5f 3f       	cpi	r21, 0xFF	; 255
    2c70:	ac f0       	brlt	.+42     	; 0x2c9c <ldexp+0x66>
    2c72:	98 3e       	cpi	r25, 0xE8	; 232
    2c74:	9c f0       	brlt	.+38     	; 0x2c9c <ldexp+0x66>
    2c76:	bb 27       	eor	r27, r27
    2c78:	86 95       	lsr	r24
    2c7a:	77 95       	ror	r23
    2c7c:	67 95       	ror	r22
    2c7e:	b7 95       	ror	r27
    2c80:	08 f4       	brcc	.+2      	; 0x2c84 <ldexp+0x4e>
    2c82:	b1 60       	ori	r27, 0x01	; 1
    2c84:	93 95       	inc	r25
    2c86:	c1 f7       	brne	.-16     	; 0x2c78 <ldexp+0x42>
    2c88:	bb 0f       	add	r27, r27
    2c8a:	58 f7       	brcc	.-42     	; 0x2c62 <ldexp+0x2c>
    2c8c:	11 f4       	brne	.+4      	; 0x2c92 <ldexp+0x5c>
    2c8e:	60 ff       	sbrs	r22, 0
    2c90:	e8 cf       	rjmp	.-48     	; 0x2c62 <ldexp+0x2c>
    2c92:	6f 5f       	subi	r22, 0xFF	; 255
    2c94:	7f 4f       	sbci	r23, 0xFF	; 255
    2c96:	8f 4f       	sbci	r24, 0xFF	; 255
    2c98:	9f 4f       	sbci	r25, 0xFF	; 255
    2c9a:	e3 cf       	rjmp	.-58     	; 0x2c62 <ldexp+0x2c>
    2c9c:	b8 ce       	rjmp	.-656    	; 0x2a0e <__fp_szero>
    2c9e:	0e f0       	brts	.+2      	; 0x2ca2 <ldexp+0x6c>
    2ca0:	de c0       	rjmp	.+444    	; 0x2e5e <__fp_mpack>
    2ca2:	70 ce       	rjmp	.-800    	; 0x2984 <__fp_nan>
    2ca4:	68 94       	set
    2ca6:	68 ce       	rjmp	.-816    	; 0x2978 <__fp_inf>

00002ca8 <log>:
    2ca8:	97 de       	rcall	.-722    	; 0x29d8 <__fp_splitA>
    2caa:	c8 f3       	brcs	.-14     	; 0x2c9e <ldexp+0x68>
    2cac:	99 23       	and	r25, r25
    2cae:	d1 f3       	breq	.-12     	; 0x2ca4 <ldexp+0x6e>
    2cb0:	c6 f3       	brts	.-16     	; 0x2ca2 <ldexp+0x6c>
    2cb2:	df 93       	push	r29
    2cb4:	cf 93       	push	r28
    2cb6:	1f 93       	push	r17
    2cb8:	0f 93       	push	r16
    2cba:	ff 92       	push	r15
    2cbc:	c9 2f       	mov	r28, r25
    2cbe:	dd 27       	eor	r29, r29
    2cc0:	88 23       	and	r24, r24
    2cc2:	2a f0       	brmi	.+10     	; 0x2cce <log+0x26>
    2cc4:	21 97       	sbiw	r28, 0x01	; 1
    2cc6:	66 0f       	add	r22, r22
    2cc8:	77 1f       	adc	r23, r23
    2cca:	88 1f       	adc	r24, r24
    2ccc:	da f7       	brpl	.-10     	; 0x2cc4 <log+0x1c>
    2cce:	20 e0       	ldi	r18, 0x00	; 0
    2cd0:	30 e0       	ldi	r19, 0x00	; 0
    2cd2:	40 e8       	ldi	r20, 0x80	; 128
    2cd4:	5f eb       	ldi	r21, 0xBF	; 191
    2cd6:	9f e3       	ldi	r25, 0x3F	; 63
    2cd8:	88 39       	cpi	r24, 0x98	; 152
    2cda:	20 f0       	brcs	.+8      	; 0x2ce4 <log+0x3c>
    2cdc:	80 3e       	cpi	r24, 0xE0	; 224
    2cde:	30 f0       	brcs	.+12     	; 0x2cec <log+0x44>
    2ce0:	21 96       	adiw	r28, 0x01	; 1
    2ce2:	8f 77       	andi	r24, 0x7F	; 127
    2ce4:	77 dd       	rcall	.-1298   	; 0x27d4 <__addsf3>
    2ce6:	ec e0       	ldi	r30, 0x0C	; 12
    2ce8:	f1 e0       	ldi	r31, 0x01	; 1
    2cea:	03 c0       	rjmp	.+6      	; 0x2cf2 <log+0x4a>
    2cec:	73 dd       	rcall	.-1306   	; 0x27d4 <__addsf3>
    2cee:	e9 e3       	ldi	r30, 0x39	; 57
    2cf0:	f1 e0       	ldi	r31, 0x01	; 1
    2cf2:	73 df       	rcall	.-282    	; 0x2bda <__fp_powser>
    2cf4:	8b 01       	movw	r16, r22
    2cf6:	be 01       	movw	r22, r28
    2cf8:	ec 01       	movw	r28, r24
    2cfa:	fb 2e       	mov	r15, r27
    2cfc:	6f 57       	subi	r22, 0x7F	; 127
    2cfe:	71 09       	sbc	r23, r1
    2d00:	75 95       	asr	r23
    2d02:	77 1f       	adc	r23, r23
    2d04:	88 0b       	sbc	r24, r24
    2d06:	99 0b       	sbc	r25, r25
    2d08:	fc dd       	rcall	.-1032   	; 0x2902 <__floatsisf>
    2d0a:	28 e1       	ldi	r18, 0x18	; 24
    2d0c:	32 e7       	ldi	r19, 0x72	; 114
    2d0e:	41 e3       	ldi	r20, 0x31	; 49
    2d10:	5f e3       	ldi	r21, 0x3F	; 63
    2d12:	8f de       	rcall	.-738    	; 0x2a32 <__mulsf3x>
    2d14:	af 2d       	mov	r26, r15
    2d16:	98 01       	movw	r18, r16
    2d18:	ae 01       	movw	r20, r28
    2d1a:	ff 90       	pop	r15
    2d1c:	0f 91       	pop	r16
    2d1e:	1f 91       	pop	r17
    2d20:	cf 91       	pop	r28
    2d22:	df 91       	pop	r29
    2d24:	68 dd       	rcall	.-1328   	; 0x27f6 <__addsf3x>
    2d26:	3f ce       	rjmp	.-898    	; 0x29a6 <__fp_round>

00002d28 <modf>:
    2d28:	fa 01       	movw	r30, r20
    2d2a:	dc 01       	movw	r26, r24
    2d2c:	aa 0f       	add	r26, r26
    2d2e:	bb 1f       	adc	r27, r27
    2d30:	9b 01       	movw	r18, r22
    2d32:	ac 01       	movw	r20, r24
    2d34:	bf 57       	subi	r27, 0x7F	; 127
    2d36:	28 f4       	brcc	.+10     	; 0x2d42 <modf+0x1a>
    2d38:	22 27       	eor	r18, r18
    2d3a:	33 27       	eor	r19, r19
    2d3c:	44 27       	eor	r20, r20
    2d3e:	50 78       	andi	r21, 0x80	; 128
    2d40:	1f c0       	rjmp	.+62     	; 0x2d80 <modf+0x58>
    2d42:	b7 51       	subi	r27, 0x17	; 23
    2d44:	88 f4       	brcc	.+34     	; 0x2d68 <modf+0x40>
    2d46:	ab 2f       	mov	r26, r27
    2d48:	00 24       	eor	r0, r0
    2d4a:	46 95       	lsr	r20
    2d4c:	37 95       	ror	r19
    2d4e:	27 95       	ror	r18
    2d50:	01 1c       	adc	r0, r1
    2d52:	a3 95       	inc	r26
    2d54:	d2 f3       	brmi	.-12     	; 0x2d4a <modf+0x22>
    2d56:	00 20       	and	r0, r0
    2d58:	69 f0       	breq	.+26     	; 0x2d74 <modf+0x4c>
    2d5a:	22 0f       	add	r18, r18
    2d5c:	33 1f       	adc	r19, r19
    2d5e:	44 1f       	adc	r20, r20
    2d60:	b3 95       	inc	r27
    2d62:	da f3       	brmi	.-10     	; 0x2d5a <modf+0x32>
    2d64:	0d d0       	rcall	.+26     	; 0x2d80 <modf+0x58>
    2d66:	35 cd       	rjmp	.-1430   	; 0x27d2 <__subsf3>
    2d68:	61 30       	cpi	r22, 0x01	; 1
    2d6a:	71 05       	cpc	r23, r1
    2d6c:	a0 e8       	ldi	r26, 0x80	; 128
    2d6e:	8a 07       	cpc	r24, r26
    2d70:	b9 46       	sbci	r27, 0x69	; 105
    2d72:	30 f4       	brcc	.+12     	; 0x2d80 <modf+0x58>
    2d74:	9b 01       	movw	r18, r22
    2d76:	ac 01       	movw	r20, r24
    2d78:	66 27       	eor	r22, r22
    2d7a:	77 27       	eor	r23, r23
    2d7c:	88 27       	eor	r24, r24
    2d7e:	90 78       	andi	r25, 0x80	; 128
    2d80:	30 96       	adiw	r30, 0x00	; 0
    2d82:	21 f0       	breq	.+8      	; 0x2d8c <modf+0x64>
    2d84:	20 83       	st	Z, r18
    2d86:	31 83       	std	Z+1, r19	; 0x01
    2d88:	42 83       	std	Z+2, r20	; 0x02
    2d8a:	53 83       	std	Z+3, r21	; 0x03
    2d8c:	08 95       	ret

00002d8e <__divsf3>:
    2d8e:	0c d0       	rcall	.+24     	; 0x2da8 <__divsf3x>
    2d90:	0a ce       	rjmp	.-1004   	; 0x29a6 <__fp_round>
    2d92:	02 de       	rcall	.-1020   	; 0x2998 <__fp_pscB>
    2d94:	40 f0       	brcs	.+16     	; 0x2da6 <__divsf3+0x18>
    2d96:	f9 dd       	rcall	.-1038   	; 0x298a <__fp_pscA>
    2d98:	30 f0       	brcs	.+12     	; 0x2da6 <__divsf3+0x18>
    2d9a:	21 f4       	brne	.+8      	; 0x2da4 <__divsf3+0x16>
    2d9c:	5f 3f       	cpi	r21, 0xFF	; 255
    2d9e:	19 f0       	breq	.+6      	; 0x2da6 <__divsf3+0x18>
    2da0:	eb cd       	rjmp	.-1066   	; 0x2978 <__fp_inf>
    2da2:	51 11       	cpse	r21, r1
    2da4:	34 ce       	rjmp	.-920    	; 0x2a0e <__fp_szero>
    2da6:	ee cd       	rjmp	.-1060   	; 0x2984 <__fp_nan>

00002da8 <__divsf3x>:
    2da8:	0f de       	rcall	.-994    	; 0x29c8 <__fp_split3>
    2daa:	98 f3       	brcs	.-26     	; 0x2d92 <__divsf3+0x4>

00002dac <__divsf3_pse>:
    2dac:	99 23       	and	r25, r25
    2dae:	c9 f3       	breq	.-14     	; 0x2da2 <__divsf3+0x14>
    2db0:	55 23       	and	r21, r21
    2db2:	b1 f3       	breq	.-20     	; 0x2da0 <__divsf3+0x12>
    2db4:	95 1b       	sub	r25, r21
    2db6:	55 0b       	sbc	r21, r21
    2db8:	bb 27       	eor	r27, r27
    2dba:	aa 27       	eor	r26, r26
    2dbc:	62 17       	cp	r22, r18
    2dbe:	73 07       	cpc	r23, r19
    2dc0:	84 07       	cpc	r24, r20
    2dc2:	38 f0       	brcs	.+14     	; 0x2dd2 <__divsf3_pse+0x26>
    2dc4:	9f 5f       	subi	r25, 0xFF	; 255
    2dc6:	5f 4f       	sbci	r21, 0xFF	; 255
    2dc8:	22 0f       	add	r18, r18
    2dca:	33 1f       	adc	r19, r19
    2dcc:	44 1f       	adc	r20, r20
    2dce:	aa 1f       	adc	r26, r26
    2dd0:	a9 f3       	breq	.-22     	; 0x2dbc <__divsf3_pse+0x10>
    2dd2:	33 d0       	rcall	.+102    	; 0x2e3a <__divsf3_pse+0x8e>
    2dd4:	0e 2e       	mov	r0, r30
    2dd6:	3a f0       	brmi	.+14     	; 0x2de6 <__divsf3_pse+0x3a>
    2dd8:	e0 e8       	ldi	r30, 0x80	; 128
    2dda:	30 d0       	rcall	.+96     	; 0x2e3c <__divsf3_pse+0x90>
    2ddc:	91 50       	subi	r25, 0x01	; 1
    2dde:	50 40       	sbci	r21, 0x00	; 0
    2de0:	e6 95       	lsr	r30
    2de2:	00 1c       	adc	r0, r0
    2de4:	ca f7       	brpl	.-14     	; 0x2dd8 <__divsf3_pse+0x2c>
    2de6:	29 d0       	rcall	.+82     	; 0x2e3a <__divsf3_pse+0x8e>
    2de8:	fe 2f       	mov	r31, r30
    2dea:	27 d0       	rcall	.+78     	; 0x2e3a <__divsf3_pse+0x8e>
    2dec:	66 0f       	add	r22, r22
    2dee:	77 1f       	adc	r23, r23
    2df0:	88 1f       	adc	r24, r24
    2df2:	bb 1f       	adc	r27, r27
    2df4:	26 17       	cp	r18, r22
    2df6:	37 07       	cpc	r19, r23
    2df8:	48 07       	cpc	r20, r24
    2dfa:	ab 07       	cpc	r26, r27
    2dfc:	b0 e8       	ldi	r27, 0x80	; 128
    2dfe:	09 f0       	breq	.+2      	; 0x2e02 <__divsf3_pse+0x56>
    2e00:	bb 0b       	sbc	r27, r27
    2e02:	80 2d       	mov	r24, r0
    2e04:	bf 01       	movw	r22, r30
    2e06:	ff 27       	eor	r31, r31
    2e08:	93 58       	subi	r25, 0x83	; 131
    2e0a:	5f 4f       	sbci	r21, 0xFF	; 255
    2e0c:	2a f0       	brmi	.+10     	; 0x2e18 <__divsf3_pse+0x6c>
    2e0e:	9e 3f       	cpi	r25, 0xFE	; 254
    2e10:	51 05       	cpc	r21, r1
    2e12:	68 f0       	brcs	.+26     	; 0x2e2e <__divsf3_pse+0x82>
    2e14:	b1 cd       	rjmp	.-1182   	; 0x2978 <__fp_inf>
    2e16:	fb cd       	rjmp	.-1034   	; 0x2a0e <__fp_szero>
    2e18:	5f 3f       	cpi	r21, 0xFF	; 255
    2e1a:	ec f3       	brlt	.-6      	; 0x2e16 <__divsf3_pse+0x6a>
    2e1c:	98 3e       	cpi	r25, 0xE8	; 232
    2e1e:	dc f3       	brlt	.-10     	; 0x2e16 <__divsf3_pse+0x6a>
    2e20:	86 95       	lsr	r24
    2e22:	77 95       	ror	r23
    2e24:	67 95       	ror	r22
    2e26:	b7 95       	ror	r27
    2e28:	f7 95       	ror	r31
    2e2a:	9f 5f       	subi	r25, 0xFF	; 255
    2e2c:	c9 f7       	brne	.-14     	; 0x2e20 <__divsf3_pse+0x74>
    2e2e:	88 0f       	add	r24, r24
    2e30:	91 1d       	adc	r25, r1
    2e32:	96 95       	lsr	r25
    2e34:	87 95       	ror	r24
    2e36:	97 f9       	bld	r25, 7
    2e38:	08 95       	ret
    2e3a:	e1 e0       	ldi	r30, 0x01	; 1
    2e3c:	66 0f       	add	r22, r22
    2e3e:	77 1f       	adc	r23, r23
    2e40:	88 1f       	adc	r24, r24
    2e42:	bb 1f       	adc	r27, r27
    2e44:	62 17       	cp	r22, r18
    2e46:	73 07       	cpc	r23, r19
    2e48:	84 07       	cpc	r24, r20
    2e4a:	ba 07       	cpc	r27, r26
    2e4c:	20 f0       	brcs	.+8      	; 0x2e56 <__divsf3_pse+0xaa>
    2e4e:	62 1b       	sub	r22, r18
    2e50:	73 0b       	sbc	r23, r19
    2e52:	84 0b       	sbc	r24, r20
    2e54:	ba 0b       	sbc	r27, r26
    2e56:	ee 1f       	adc	r30, r30
    2e58:	88 f7       	brcc	.-30     	; 0x2e3c <__divsf3_pse+0x90>
    2e5a:	e0 95       	com	r30
    2e5c:	08 95       	ret

00002e5e <__fp_mpack>:
    2e5e:	9f 3f       	cpi	r25, 0xFF	; 255
    2e60:	31 f0       	breq	.+12     	; 0x2e6e <__fp_mpack_finite+0xc>

00002e62 <__fp_mpack_finite>:
    2e62:	91 50       	subi	r25, 0x01	; 1
    2e64:	20 f4       	brcc	.+8      	; 0x2e6e <__fp_mpack_finite+0xc>
    2e66:	87 95       	ror	r24
    2e68:	77 95       	ror	r23
    2e6a:	67 95       	ror	r22
    2e6c:	b7 95       	ror	r27
    2e6e:	88 0f       	add	r24, r24
    2e70:	91 1d       	adc	r25, r1
    2e72:	96 95       	lsr	r25
    2e74:	87 95       	ror	r24
    2e76:	97 f9       	bld	r25, 7
    2e78:	08 95       	ret

00002e7a <__divmodhi4>:
    2e7a:	97 fb       	bst	r25, 7
    2e7c:	07 2e       	mov	r0, r23
    2e7e:	16 f4       	brtc	.+4      	; 0x2e84 <__divmodhi4+0xa>
    2e80:	00 94       	com	r0
    2e82:	06 d0       	rcall	.+12     	; 0x2e90 <__divmodhi4_neg1>
    2e84:	77 fd       	sbrc	r23, 7
    2e86:	08 d0       	rcall	.+16     	; 0x2e98 <__divmodhi4_neg2>
    2e88:	0b d0       	rcall	.+22     	; 0x2ea0 <__udivmodhi4>
    2e8a:	07 fc       	sbrc	r0, 7
    2e8c:	05 d0       	rcall	.+10     	; 0x2e98 <__divmodhi4_neg2>
    2e8e:	3e f4       	brtc	.+14     	; 0x2e9e <__divmodhi4_exit>

00002e90 <__divmodhi4_neg1>:
    2e90:	90 95       	com	r25
    2e92:	81 95       	neg	r24
    2e94:	9f 4f       	sbci	r25, 0xFF	; 255
    2e96:	08 95       	ret

00002e98 <__divmodhi4_neg2>:
    2e98:	70 95       	com	r23
    2e9a:	61 95       	neg	r22
    2e9c:	7f 4f       	sbci	r23, 0xFF	; 255

00002e9e <__divmodhi4_exit>:
    2e9e:	08 95       	ret

00002ea0 <__udivmodhi4>:
    2ea0:	aa 1b       	sub	r26, r26
    2ea2:	bb 1b       	sub	r27, r27
    2ea4:	51 e1       	ldi	r21, 0x11	; 17
    2ea6:	07 c0       	rjmp	.+14     	; 0x2eb6 <__udivmodhi4_ep>

00002ea8 <__udivmodhi4_loop>:
    2ea8:	aa 1f       	adc	r26, r26
    2eaa:	bb 1f       	adc	r27, r27
    2eac:	a6 17       	cp	r26, r22
    2eae:	b7 07       	cpc	r27, r23
    2eb0:	10 f0       	brcs	.+4      	; 0x2eb6 <__udivmodhi4_ep>
    2eb2:	a6 1b       	sub	r26, r22
    2eb4:	b7 0b       	sbc	r27, r23

00002eb6 <__udivmodhi4_ep>:
    2eb6:	88 1f       	adc	r24, r24
    2eb8:	99 1f       	adc	r25, r25
    2eba:	5a 95       	dec	r21
    2ebc:	a9 f7       	brne	.-22     	; 0x2ea8 <__udivmodhi4_loop>
    2ebe:	80 95       	com	r24
    2ec0:	90 95       	com	r25
    2ec2:	bc 01       	movw	r22, r24
    2ec4:	cd 01       	movw	r24, r26
    2ec6:	08 95       	ret

00002ec8 <memcpy>:
    2ec8:	fb 01       	movw	r30, r22
    2eca:	dc 01       	movw	r26, r24
    2ecc:	02 c0       	rjmp	.+4      	; 0x2ed2 <memcpy+0xa>
    2ece:	01 90       	ld	r0, Z+
    2ed0:	0d 92       	st	X+, r0
    2ed2:	41 50       	subi	r20, 0x01	; 1
    2ed4:	50 40       	sbci	r21, 0x00	; 0
    2ed6:	d8 f7       	brcc	.-10     	; 0x2ece <memcpy+0x6>
    2ed8:	08 95       	ret

00002eda <_exit>:
    2eda:	f8 94       	cli

00002edc <__stop_program>:
    2edc:	ff cf       	rjmp	.-2      	; 0x2edc <__stop_program>
