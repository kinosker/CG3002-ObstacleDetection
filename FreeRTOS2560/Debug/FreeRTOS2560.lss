
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800200  00001eec  00001f80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001eec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006ec  0080028c  0080028c  0000200c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000200c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000478  00000000  00000000  0000203c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004dc2  00000000  00000000  000024b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001232  00000000  00000000  00007276  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002f25  00000000  00000000  000084a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c88  00000000  00000000  0000b3d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001335  00000000  00000000  0000c058  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003533  00000000  00000000  0000d38d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000438  00000000  00000000  000108c0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	4f c6       	rjmp	.+3230   	; 0xcf4 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	7b c3       	rjmp	.+1782   	; 0x75c <__vector_25>
      66:	00 00       	nop
      68:	e7 c3       	rjmp	.+1998   	; 0x838 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	59 c2       	rjmp	.+1202   	; 0x528 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2d c3       	rjmp	.+1626   	; 0x6ec <__vector_36>
      92:	00 00       	nop
      94:	9b c3       	rjmp	.+1846   	; 0x7cc <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ec ee       	ldi	r30, 0xEC	; 236
      fc:	fe e1       	ldi	r31, 0x1E	; 30
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 38       	cpi	r26, 0x8C	; 140
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ac e8       	ldi	r26, 0x8C	; 140
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a8 37       	cpi	r26, 0x78	; 120
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	cf d0       	rcall	.+414    	; 0x2be <main>
     120:	0c 94 74 0f 	jmp	0x1ee8	; 0x1ee8 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 a9 0c 	call	0x1952	; 0x1952 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 a9 0c 	call	0x1952	; 0x1952 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 a9 0c 	call	0x1952	; 0x1952 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 a9 0c 	call	0x1952	; 0x1952 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	4e d4       	rcall	.+2204   	; 0x9f4 <waitForHandshake>
     158:	83 e0       	ldi	r24, 0x03	; 3
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	11 c4       	rjmp	.+2082   	; 0x980 <transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	3e d4       	rcall	.+2172   	; 0x9de <startHandShake>
     162:	8a e1       	ldi	r24, 0x1A	; 26
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	0c c4       	rjmp	.+2072   	; 0x980 <transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a6 97       	sbiw	r28, 0x26	; 38
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e0 e3       	ldi	r30, 0x30	; 48
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	15 96       	adiw	r26, 0x05	; 5
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	e8 e3       	ldi	r30, 0x38	; 56
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1d 96       	adiw	r26, 0x0d	; 13
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	ef e3       	ldi	r30, 0x3F	; 63
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	54 96       	adiw	r26, 0x14	; 20
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	e7 e4       	ldi	r30, 0x47	; 71
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5c 96       	adiw	r26, 0x1c	; 28
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	ed e4       	ldi	r30, 0x4D	; 77
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	92 96       	adiw	r26, 0x22	; 34
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	96 d1       	rcall	.+812    	; 0x506 <MaxSonar_Start>
     1da:	87 e2       	ldi	r24, 0x27	; 39
     1dc:	9b d1       	rcall	.+822    	; 0x514 <MaxSonar_Read>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6f 5f       	subi	r22, 0xFF	; 255
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__itoa_ncheck>
     1ea:	ce 01       	movw	r24, r28
     1ec:	05 96       	adiw	r24, 0x05	; 5
     1ee:	c8 d3       	rcall	.+1936   	; 0x980 <transmitUSART0>
     1f0:	ce 01       	movw	r24, r28
     1f2:	01 96       	adiw	r24, 0x01	; 1
     1f4:	c5 d3       	rcall	.+1930   	; 0x980 <transmitUSART0>
     1f6:	ce 01       	movw	r24, r28
     1f8:	4c 96       	adiw	r24, 0x1c	; 28
     1fa:	c2 d3       	rcall	.+1924   	; 0x980 <transmitUSART0>
     1fc:	86 e2       	ldi	r24, 0x26	; 38
     1fe:	8a d1       	rcall	.+788    	; 0x514 <MaxSonar_Read>
     200:	4a e0       	ldi	r20, 0x0A	; 10
     202:	be 01       	movw	r22, r28
     204:	6f 5f       	subi	r22, 0xFF	; 255
     206:	7f 4f       	sbci	r23, 0xFF	; 255
     208:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__itoa_ncheck>
     20c:	ce 01       	movw	r24, r28
     20e:	0d 96       	adiw	r24, 0x0d	; 13
     210:	b7 d3       	rcall	.+1902   	; 0x980 <transmitUSART0>
     212:	ce 01       	movw	r24, r28
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	b4 d3       	rcall	.+1896   	; 0x980 <transmitUSART0>
     218:	ce 01       	movw	r24, r28
     21a:	4c 96       	adiw	r24, 0x1c	; 28
     21c:	b1 d3       	rcall	.+1890   	; 0x980 <transmitUSART0>
     21e:	85 e2       	ldi	r24, 0x25	; 37
     220:	79 d1       	rcall	.+754    	; 0x514 <MaxSonar_Read>
     222:	4a e0       	ldi	r20, 0x0A	; 10
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	0a 97       	sbiw	r24, 0x0a	; 10
     22c:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__itoa_ncheck>
     230:	ce 01       	movw	r24, r28
     232:	44 96       	adiw	r24, 0x14	; 20
     234:	a5 d3       	rcall	.+1866   	; 0x980 <transmitUSART0>
     236:	ce 01       	movw	r24, r28
     238:	01 96       	adiw	r24, 0x01	; 1
     23a:	a2 d3       	rcall	.+1860   	; 0x980 <transmitUSART0>
     23c:	ce 01       	movw	r24, r28
     23e:	82 96       	adiw	r24, 0x22	; 34
     240:	9f d3       	rcall	.+1854   	; 0x980 <transmitUSART0>
     242:	86 e9       	ldi	r24, 0x96	; 150
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 a9 0c 	call	0x1952	; 0x1952 <vTaskDelay>
     24a:	c6 cf       	rjmp	.-116    	; 0x1d8 <maxSonarTask+0x6e>

0000024c <myTimerTask>:
     24c:	05 d2       	rcall	.+1034   	; 0x658 <MyTimer_Init>
     24e:	36 d2       	rcall	.+1132   	; 0x6bc <delayMicroCheck>
     250:	fe cf       	rjmp	.-4      	; 0x24e <myTimerTask+0x2>

00000252 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     252:	8c ec       	ldi	r24, 0xCC	; 204
     254:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     258:	8e e3       	ldi	r24, 0x3E	; 62
     25a:	80 93 65 00 	sts	0x0065, r24
     25e:	08 95       	ret

00000260 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     260:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     264:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     268:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     26c:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     270:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     274:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     278:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     27c:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     280:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     284:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     288:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     28c:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     290:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     294:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     298:	10 92 73 00 	sts	0x0073, r1
     29c:	08 95       	ret

0000029e <init>:
}

void init()
{
     29e:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2a0:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2a2:	f8 94       	cli
	{
		clearTimer();
     2a4:	dd df       	rcall	.-70     	; 0x260 <clearTimer>
		setPowerReduction();
     2a6:	d5 df       	rcall	.-86     	; 0x252 <setPowerReduction>
		USART0_Init();
     2a8:	fd d2       	rcall	.+1530   	; 0x8a4 <USART0_Init>
		USART1_Init();
     2aa:	1c d3       	rcall	.+1592   	; 0x8e4 <USART1_Init>
		ADC_Init();
     2ac:	71 d1       	rcall	.+738    	; 0x590 <ADC_Init>
		MaxSonar_Init();
     2ae:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2b0:	84 b1       	in	r24, 0x04	; 4
     2b2:	80 6c       	ori	r24, 0xC0	; 192
     2b4:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2b6:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2b8:	78 94       	sei
}
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <main>:
	
	// do nth
}

int main(void)
{
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	cd b7       	in	r28, 0x3d	; 61
     2c4:	de b7       	in	r29, 0x3e	; 62
     2c6:	2c 97       	sbiw	r28, 0x0c	; 12
     2c8:	0f b6       	in	r0, 0x3f	; 63
     2ca:	f8 94       	cli
     2cc:	de bf       	out	0x3e, r29	; 62
     2ce:	0f be       	out	0x3f, r0	; 63
     2d0:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2d2:	e5 df       	rcall	.-54     	; 0x29e <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     2d4:	a1 2c       	mov	r10, r1
     2d6:	b1 2c       	mov	r11, r1
     2d8:	c1 2c       	mov	r12, r1
     2da:	d1 2c       	mov	r13, r1
     2dc:	ce 01       	movw	r24, r28
     2de:	01 96       	adiw	r24, 0x01	; 1
     2e0:	7c 01       	movw	r14, r24
     2e2:	04 e0       	ldi	r16, 0x04	; 4
     2e4:	9c 01       	movw	r18, r24
     2e6:	49 e6       	ldi	r20, 0x69	; 105
     2e8:	50 e0       	ldi	r21, 0x00	; 0
     2ea:	62 e5       	ldi	r22, 0x52	; 82
     2ec:	72 e0       	ldi	r23, 0x02	; 2
     2ee:	86 e2       	ldi	r24, 0x26	; 38
     2f0:	91 e0       	ldi	r25, 0x01	; 1
     2f2:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     2f6:	ce 01       	movw	r24, r28
     2f8:	07 96       	adiw	r24, 0x07	; 7
     2fa:	7c 01       	movw	r14, r24
     2fc:	02 e0       	ldi	r16, 0x02	; 2
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	30 e0       	ldi	r19, 0x00	; 0
     302:	4d e1       	ldi	r20, 0x1D	; 29
     304:	51 e0       	ldi	r21, 0x01	; 1
     306:	6a e5       	ldi	r22, 0x5A	; 90
     308:	72 e0       	ldi	r23, 0x02	; 2
     30a:	85 eb       	ldi	r24, 0xB5	; 181
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     312:	ce 01       	movw	r24, r28
     314:	0b 96       	adiw	r24, 0x0b	; 11
     316:	7c 01       	movw	r14, r24
     318:	01 e0       	ldi	r16, 0x01	; 1
     31a:	20 e0       	ldi	r18, 0x00	; 0
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	49 e6       	ldi	r20, 0x69	; 105
     320:	50 e0       	ldi	r21, 0x00	; 0
     322:	63 e6       	ldi	r22, 0x63	; 99
     324:	72 e0       	ldi	r23, 0x02	; 2
     326:	83 e9       	ldi	r24, 0x93	; 147
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     32e:	ce 01       	movw	r24, r28
     330:	09 96       	adiw	r24, 0x09	; 9
     332:	7c 01       	movw	r14, r24
     334:	20 e0       	ldi	r18, 0x00	; 0
     336:	30 e0       	ldi	r19, 0x00	; 0
     338:	49 e6       	ldi	r20, 0x69	; 105
     33a:	50 e0       	ldi	r21, 0x00	; 0
     33c:	6a e6       	ldi	r22, 0x6A	; 106
     33e:	72 e0       	ldi	r23, 0x02	; 2
     340:	8f e9       	ldi	r24, 0x9F	; 159
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     348:	ce 01       	movw	r24, r28
     34a:	05 96       	adiw	r24, 0x05	; 5
     34c:	7c 01       	movw	r14, r24
     34e:	03 e0       	ldi	r16, 0x03	; 3
     350:	20 e0       	ldi	r18, 0x00	; 0
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	47 e8       	ldi	r20, 0x87	; 135
     356:	50 e0       	ldi	r21, 0x00	; 0
     358:	61 e7       	ldi	r22, 0x71	; 113
     35a:	72 e0       	ldi	r23, 0x02	; 2
     35c:	8b ea       	ldi	r24, 0xAB	; 171
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     364:	ce 01       	movw	r24, r28
     366:	03 96       	adiw	r24, 0x03	; 3
     368:	7c 01       	movw	r14, r24
     36a:	02 e0       	ldi	r16, 0x02	; 2
     36c:	20 e0       	ldi	r18, 0x00	; 0
     36e:	30 e0       	ldi	r19, 0x00	; 0
     370:	47 e8       	ldi	r20, 0x87	; 135
     372:	50 e0       	ldi	r21, 0x00	; 0
     374:	6d e7       	ldi	r22, 0x7D	; 125
     376:	72 e0       	ldi	r23, 0x02	; 2
     378:	80 eb       	ldi	r24, 0xB0	; 176
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	0e 94 db 09 	call	0x13b6	; 0x13b6 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     380:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vTaskStartScheduler>
     384:	a6 cf       	rjmp	.-180    	; 0x2d2 <main+0x14>

00000386 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     386:	cf 93       	push	r28
     388:	df 93       	push	r29
     38a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     38c:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     390:	80 91 8c 02 	lds	r24, 0x028C
     394:	90 91 8d 02 	lds	r25, 0x028D
     398:	89 2b       	or	r24, r25
     39a:	31 f4       	brne	.+12     	; 0x3a8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     39c:	81 e9       	ldi	r24, 0x91	; 145
     39e:	92 e0       	ldi	r25, 0x02	; 2
     3a0:	90 93 8d 02 	sts	0x028D, r25
     3a4:	80 93 8c 02 	sts	0x028C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3a8:	40 91 8e 02 	lds	r20, 0x028E
     3ac:	50 91 8f 02 	lds	r21, 0x028F
     3b0:	9e 01       	movw	r18, r28
     3b2:	24 0f       	add	r18, r20
     3b4:	35 1f       	adc	r19, r21
     3b6:	2b 3d       	cpi	r18, 0xDB	; 219
     3b8:	85 e0       	ldi	r24, 0x05	; 5
     3ba:	38 07       	cpc	r19, r24
     3bc:	70 f4       	brcc	.+28     	; 0x3da <pvPortMalloc+0x54>
     3be:	42 17       	cp	r20, r18
     3c0:	53 07       	cpc	r21, r19
     3c2:	70 f4       	brcc	.+28     	; 0x3e0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3c4:	c0 91 8c 02 	lds	r28, 0x028C
     3c8:	d0 91 8d 02 	lds	r29, 0x028D
     3cc:	c4 0f       	add	r28, r20
     3ce:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3d0:	30 93 8f 02 	sts	0x028F, r19
     3d4:	20 93 8e 02 	sts	0x028E, r18
     3d8:	05 c0       	rjmp	.+10     	; 0x3e4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3da:	c0 e0       	ldi	r28, 0x00	; 0
     3dc:	d0 e0       	ldi	r29, 0x00	; 0
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <pvPortMalloc+0x5e>
     3e0:	c0 e0       	ldi	r28, 0x00	; 0
     3e2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3e4:	0e 94 28 0c 	call	0x1850	; 0x1850 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3e8:	ce 01       	movw	r24, r28
     3ea:	df 91       	pop	r29
     3ec:	cf 91       	pop	r28
     3ee:	08 95       	ret

000003f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3f0:	08 95       	ret

000003f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3f2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3f4:	03 96       	adiw	r24, 0x03	; 3
     3f6:	92 83       	std	Z+2, r25	; 0x02
     3f8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3fa:	2f ef       	ldi	r18, 0xFF	; 255
     3fc:	3f ef       	ldi	r19, 0xFF	; 255
     3fe:	34 83       	std	Z+4, r19	; 0x04
     400:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     402:	96 83       	std	Z+6, r25	; 0x06
     404:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     406:	90 87       	std	Z+8, r25	; 0x08
     408:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     40a:	10 82       	st	Z, r1
     40c:	08 95       	ret

0000040e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     40e:	fc 01       	movw	r30, r24
     410:	11 86       	std	Z+9, r1	; 0x09
     412:	10 86       	std	Z+8, r1	; 0x08
     414:	08 95       	ret

00000416 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     416:	cf 93       	push	r28
     418:	df 93       	push	r29
     41a:	9c 01       	movw	r18, r24
     41c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     41e:	dc 01       	movw	r26, r24
     420:	11 96       	adiw	r26, 0x01	; 1
     422:	cd 91       	ld	r28, X+
     424:	dc 91       	ld	r29, X
     426:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     428:	d3 83       	std	Z+3, r29	; 0x03
     42a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     42c:	8c 81       	ldd	r24, Y+4	; 0x04
     42e:	9d 81       	ldd	r25, Y+5	; 0x05
     430:	95 83       	std	Z+5, r25	; 0x05
     432:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     434:	8c 81       	ldd	r24, Y+4	; 0x04
     436:	9d 81       	ldd	r25, Y+5	; 0x05
     438:	dc 01       	movw	r26, r24
     43a:	13 96       	adiw	r26, 0x03	; 3
     43c:	7c 93       	st	X, r23
     43e:	6e 93       	st	-X, r22
     440:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     442:	7d 83       	std	Y+5, r23	; 0x05
     444:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     446:	31 87       	std	Z+9, r19	; 0x09
     448:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     44a:	f9 01       	movw	r30, r18
     44c:	80 81       	ld	r24, Z
     44e:	8f 5f       	subi	r24, 0xFF	; 255
     450:	80 83       	st	Z, r24
}
     452:	df 91       	pop	r29
     454:	cf 91       	pop	r28
     456:	08 95       	ret

00000458 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     458:	cf 93       	push	r28
     45a:	df 93       	push	r29
     45c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     45e:	48 81       	ld	r20, Y
     460:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     462:	4f 3f       	cpi	r20, 0xFF	; 255
     464:	2f ef       	ldi	r18, 0xFF	; 255
     466:	52 07       	cpc	r21, r18
     468:	21 f4       	brne	.+8      	; 0x472 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     46a:	fc 01       	movw	r30, r24
     46c:	a7 81       	ldd	r26, Z+7	; 0x07
     46e:	b0 85       	ldd	r27, Z+8	; 0x08
     470:	0d c0       	rjmp	.+26     	; 0x48c <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     472:	dc 01       	movw	r26, r24
     474:	13 96       	adiw	r26, 0x03	; 3
     476:	12 96       	adiw	r26, 0x02	; 2
     478:	ed 91       	ld	r30, X+
     47a:	fc 91       	ld	r31, X
     47c:	13 97       	sbiw	r26, 0x03	; 3
     47e:	20 81       	ld	r18, Z
     480:	31 81       	ldd	r19, Z+1	; 0x01
     482:	42 17       	cp	r20, r18
     484:	53 07       	cpc	r21, r19
     486:	10 f0       	brcs	.+4      	; 0x48c <vListInsert+0x34>
     488:	df 01       	movw	r26, r30
     48a:	f5 cf       	rjmp	.-22     	; 0x476 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     48c:	12 96       	adiw	r26, 0x02	; 2
     48e:	ed 91       	ld	r30, X+
     490:	fc 91       	ld	r31, X
     492:	13 97       	sbiw	r26, 0x03	; 3
     494:	fb 83       	std	Y+3, r31	; 0x03
     496:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     498:	d5 83       	std	Z+5, r29	; 0x05
     49a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     49c:	bd 83       	std	Y+5, r27	; 0x05
     49e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4a0:	13 96       	adiw	r26, 0x03	; 3
     4a2:	dc 93       	st	X, r29
     4a4:	ce 93       	st	-X, r28
     4a6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4a8:	99 87       	std	Y+9, r25	; 0x09
     4aa:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4ac:	fc 01       	movw	r30, r24
     4ae:	20 81       	ld	r18, Z
     4b0:	2f 5f       	subi	r18, 0xFF	; 255
     4b2:	20 83       	st	Z, r18
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	08 95       	ret

000004ba <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4ba:	cf 93       	push	r28
     4bc:	df 93       	push	r29
     4be:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4c0:	a0 85       	ldd	r26, Z+8	; 0x08
     4c2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4c4:	c2 81       	ldd	r28, Z+2	; 0x02
     4c6:	d3 81       	ldd	r29, Z+3	; 0x03
     4c8:	84 81       	ldd	r24, Z+4	; 0x04
     4ca:	95 81       	ldd	r25, Z+5	; 0x05
     4cc:	9d 83       	std	Y+5, r25	; 0x05
     4ce:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4d0:	c4 81       	ldd	r28, Z+4	; 0x04
     4d2:	d5 81       	ldd	r29, Z+5	; 0x05
     4d4:	82 81       	ldd	r24, Z+2	; 0x02
     4d6:	93 81       	ldd	r25, Z+3	; 0x03
     4d8:	9b 83       	std	Y+3, r25	; 0x03
     4da:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4dc:	11 96       	adiw	r26, 0x01	; 1
     4de:	cd 91       	ld	r28, X+
     4e0:	dc 91       	ld	r29, X
     4e2:	12 97       	sbiw	r26, 0x02	; 2
     4e4:	ce 17       	cp	r28, r30
     4e6:	df 07       	cpc	r29, r31
     4e8:	31 f4       	brne	.+12     	; 0x4f6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4ea:	8c 81       	ldd	r24, Y+4	; 0x04
     4ec:	9d 81       	ldd	r25, Y+5	; 0x05
     4ee:	12 96       	adiw	r26, 0x02	; 2
     4f0:	9c 93       	st	X, r25
     4f2:	8e 93       	st	-X, r24
     4f4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     4f6:	11 86       	std	Z+9, r1	; 0x09
     4f8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4fa:	8c 91       	ld	r24, X
     4fc:	81 50       	subi	r24, 0x01	; 1
     4fe:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     500:	df 91       	pop	r29
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <MaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void MaxSonar_Start()
{
	MaxSonar_TriggerStart();
     506:	a1 9a       	sbi	0x14, 1	; 20
	
	delayMicro(25); // delay 25 micro seconds...
     508:	89 e1       	ldi	r24, 0x19	; 25
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	b7 d0       	rcall	.+366    	; 0x67c <delayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     50e:	84 b3       	in	r24, 0x14	; 20
     510:	14 ba       	out	0x14, r1	; 20
     512:	08 95       	ret

00000514 <MaxSonar_Read>:
}

// Return distance in cm
int MaxSonar_Read(char analogChannel)
{
	return analogRead(analogChannel) * valueToCM;
     514:	9a d0       	rcall	.+308    	; 0x64a <analogRead>
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	9c 01       	movw	r18, r24
     51a:	22 0f       	add	r18, r18
     51c:	33 1f       	adc	r19, r19
     51e:	22 0f       	add	r18, r18
     520:	33 1f       	adc	r19, r19
}
     522:	82 0f       	add	r24, r18
     524:	93 1f       	adc	r25, r19
     526:	08 95       	ret

00000528 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     528:	1f 92       	push	r1
     52a:	0f 92       	push	r0
     52c:	0f b6       	in	r0, 0x3f	; 63
     52e:	0f 92       	push	r0
     530:	11 24       	eor	r1, r1
     532:	0b b6       	in	r0, 0x3b	; 59
     534:	0f 92       	push	r0
     536:	2f 93       	push	r18
     538:	3f 93       	push	r19
     53a:	4f 93       	push	r20
     53c:	5f 93       	push	r21
     53e:	6f 93       	push	r22
     540:	7f 93       	push	r23
     542:	8f 93       	push	r24
     544:	9f 93       	push	r25
     546:	af 93       	push	r26
     548:	bf 93       	push	r27
     54a:	ef 93       	push	r30
     54c:	ff 93       	push	r31
	adcReading = ADCH; // read value
     54e:	80 91 79 00 	lds	r24, 0x0079
     552:	80 93 d7 08 	sts	0x08D7, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     556:	20 e0       	ldi	r18, 0x00	; 0
     558:	40 e0       	ldi	r20, 0x00	; 0
     55a:	50 e0       	ldi	r21, 0x00	; 0
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	70 e0       	ldi	r23, 0x00	; 0
     560:	80 91 da 08 	lds	r24, 0x08DA
     564:	90 91 db 08 	lds	r25, 0x08DB
     568:	a7 d5       	rcall	.+2894   	; 0x10b8 <xQueueGenericSendFromISR>
}
     56a:	ff 91       	pop	r31
     56c:	ef 91       	pop	r30
     56e:	bf 91       	pop	r27
     570:	af 91       	pop	r26
     572:	9f 91       	pop	r25
     574:	8f 91       	pop	r24
     576:	7f 91       	pop	r23
     578:	6f 91       	pop	r22
     57a:	5f 91       	pop	r21
     57c:	4f 91       	pop	r20
     57e:	3f 91       	pop	r19
     580:	2f 91       	pop	r18
     582:	0f 90       	pop	r0
     584:	0b be       	out	0x3b, r0	; 59
     586:	0f 90       	pop	r0
     588:	0f be       	out	0x3f, r0	; 63
     58a:	0f 90       	pop	r0
     58c:	1f 90       	pop	r1
     58e:	18 95       	reti

00000590 <ADC_Init>:

void ADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     590:	8f e8       	ldi	r24, 0x8F	; 143
     592:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     596:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     59a:	80 e6       	ldi	r24, 0x60	; 96
     59c:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     5a0:	43 e0       	ldi	r20, 0x03	; 3
     5a2:	60 e0       	ldi	r22, 0x00	; 0
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	a3 d4       	rcall	.+2374   	; 0xeee <xQueueGenericCreate>
     5a8:	90 93 db 08 	sts	0x08DB, r25
     5ac:	80 93 da 08 	sts	0x08DA, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     5b0:	81 e0       	ldi	r24, 0x01	; 1
     5b2:	5a d5       	rcall	.+2740   	; 0x1068 <xQueueCreateMutex>
     5b4:	90 93 d9 08 	sts	0x08D9, r25
     5b8:	80 93 d8 08 	sts	0x08D8, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	60 e0       	ldi	r22, 0x00	; 0
     5c4:	70 e0       	ldi	r23, 0x00	; 0
     5c6:	bd c4       	rjmp	.+2426   	; 0xf42 <xQueueGenericSend>
     5c8:	08 95       	ret

000005ca <startADC>:
	return readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void startADC(char channel)
{
     5ca:	cf 93       	push	r28
     5cc:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     5ce:	20 e0       	ldi	r18, 0x00	; 0
     5d0:	4f ef       	ldi	r20, 0xFF	; 255
     5d2:	5f ef       	ldi	r21, 0xFF	; 255
     5d4:	60 e0       	ldi	r22, 0x00	; 0
     5d6:	70 e0       	ldi	r23, 0x00	; 0
     5d8:	80 91 d8 08 	lds	r24, 0x08D8
     5dc:	90 91 d9 08 	lds	r25, 0x08D9
     5e0:	a5 d5       	rcall	.+2890   	; 0x112c <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     5e2:	ec e7       	ldi	r30, 0x7C	; 124
     5e4:	f0 e0       	ldi	r31, 0x00	; 0
     5e6:	80 81       	ld	r24, Z
     5e8:	9c 2f       	mov	r25, r28
     5ea:	9f 71       	andi	r25, 0x1F	; 31
     5ec:	80 76       	andi	r24, 0x60	; 96
     5ee:	89 2b       	or	r24, r25
     5f0:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     5f2:	eb e7       	ldi	r30, 0x7B	; 123
     5f4:	f0 e0       	ldi	r31, 0x00	; 0
     5f6:	20 81       	ld	r18, Z
     5f8:	c0 72       	andi	r28, 0x20	; 32
     5fa:	8c 2f       	mov	r24, r28
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	95 95       	asr	r25
     600:	87 95       	ror	r24
     602:	95 95       	asr	r25
     604:	87 95       	ror	r24
     606:	92 2f       	mov	r25, r18
     608:	90 76       	andi	r25, 0x60	; 96
     60a:	89 2b       	or	r24, r25
     60c:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     60e:	ea e7       	ldi	r30, 0x7A	; 122
     610:	f0 e0       	ldi	r31, 0x00	; 0
     612:	80 81       	ld	r24, Z
     614:	80 64       	ori	r24, 0x40	; 64
     616:	80 83       	st	Z, r24
}
     618:	cf 91       	pop	r28
     61a:	08 95       	ret

0000061c <readADC>:

unsigned char readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     61c:	20 e0       	ldi	r18, 0x00	; 0
     61e:	4f ef       	ldi	r20, 0xFF	; 255
     620:	5f ef       	ldi	r21, 0xFF	; 255
     622:	60 e0       	ldi	r22, 0x00	; 0
     624:	70 e0       	ldi	r23, 0x00	; 0
     626:	80 91 da 08 	lds	r24, 0x08DA
     62a:	90 91 db 08 	lds	r25, 0x08DB
     62e:	7e d5       	rcall	.+2812   	; 0x112c <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	40 e0       	ldi	r20, 0x00	; 0
     634:	50 e0       	ldi	r21, 0x00	; 0
     636:	60 e0       	ldi	r22, 0x00	; 0
     638:	70 e0       	ldi	r23, 0x00	; 0
     63a:	80 91 d8 08 	lds	r24, 0x08D8
     63e:	90 91 d9 08 	lds	r25, 0x08D9
     642:	7f d4       	rcall	.+2302   	; 0xf42 <xQueueGenericSend>
	return adcReading;
     644:	80 91 d7 08 	lds	r24, 0x08D7
     648:	08 95       	ret

0000064a <analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char analogRead(char channel)
{
     64a:	cf 93       	push	r28
     64c:	c8 2f       	mov	r28, r24
	startADC(channel);
     64e:	bd df       	rcall	.-134    	; 0x5ca <startADC>
	return readADC(channel);
     650:	8c 2f       	mov	r24, r28
     652:	e4 df       	rcall	.-56     	; 0x61c <readADC>
}
     654:	cf 91       	pop	r28
     656:	08 95       	ret

00000658 <MyTimer_Init>:

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
}
     658:	90 93 df 08 	sts	0x08DF, r25
     65c:	80 93 de 08 	sts	0x08DE, r24
     660:	fc 01       	movw	r30, r24
     662:	80 81       	ld	r24, Z
     664:	91 81       	ldd	r25, Z+1	; 0x01
     666:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vTaskSuspend>
     66a:	43 e0       	ldi	r20, 0x03	; 3
     66c:	60 e0       	ldi	r22, 0x00	; 0
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	3e d4       	rcall	.+2172   	; 0xeee <xQueueGenericCreate>
     672:	90 93 dd 08 	sts	0x08DD, r25
     676:	80 93 dc 08 	sts	0x08DC, r24
     67a:	08 95       	ret

0000067c <delayMicro>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     67c:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     67e:	4f 5f       	subi	r20, 0xFF	; 255
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     680:	9c 01       	movw	r18, r24
     682:	99 23       	and	r25, r25
     684:	14 f4       	brge	.+4      	; 0x68a <delayMicro+0xe>
     686:	2d 5f       	subi	r18, 0xFD	; 253
     688:	3f 4f       	sbci	r19, 0xFF	; 255
     68a:	35 95       	asr	r19
     68c:	27 95       	ror	r18
     68e:	35 95       	asr	r19
     690:	27 95       	ror	r18
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     692:	24 0f       	add	r18, r20
     694:	20 93 00 02 	sts	0x0200, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     698:	e0 91 de 08 	lds	r30, 0x08DE
     69c:	f0 91 df 08 	lds	r31, 0x08DF
     6a0:	80 81       	ld	r24, Z
     6a2:	91 81       	ldd	r25, Z+1	; 0x01
     6a4:	9d d7       	rcall	.+3898   	; 0x15e0 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     6a6:	20 e0       	ldi	r18, 0x00	; 0
     6a8:	42 e0       	ldi	r20, 0x02	; 2
     6aa:	50 e0       	ldi	r21, 0x00	; 0
     6ac:	60 e0       	ldi	r22, 0x00	; 0
     6ae:	70 e0       	ldi	r23, 0x00	; 0
     6b0:	80 91 dc 08 	lds	r24, 0x08DC
     6b4:	90 91 dd 08 	lds	r25, 0x08DD
     6b8:	39 c5       	rjmp	.+2674   	; 0x112c <xQueueGenericReceive>
     6ba:	08 95       	ret

000006bc <delayMicroCheck>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     6bc:	86 b5       	in	r24, 0x26	; 38
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
}

void delayMicroCheck()
{
	if( expectedTick <= readTimer())
     6be:	90 91 00 02 	lds	r25, 0x0200
     6c2:	89 17       	cp	r24, r25
     6c4:	90 f0       	brcs	.+36     	; 0x6ea <delayMicroCheck+0x2e>
	{
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     6c6:	20 e0       	ldi	r18, 0x00	; 0
     6c8:	40 e0       	ldi	r20, 0x00	; 0
     6ca:	50 e0       	ldi	r21, 0x00	; 0
     6cc:	60 e0       	ldi	r22, 0x00	; 0
     6ce:	70 e0       	ldi	r23, 0x00	; 0
     6d0:	80 91 dc 08 	lds	r24, 0x08DC
     6d4:	90 91 dd 08 	lds	r25, 0x08DD
     6d8:	34 d4       	rcall	.+2152   	; 0xf42 <xQueueGenericSend>
		vTaskSuspend(*timerTask); // suspend again...
     6da:	e0 91 de 08 	lds	r30, 0x08DE
     6de:	f0 91 df 08 	lds	r31, 0x08DF
     6e2:	80 81       	ld	r24, Z
     6e4:	91 81       	ldd	r25, Z+1	; 0x01
     6e6:	0c 94 5c 0d 	jmp	0x1ab8	; 0x1ab8 <vTaskSuspend>
     6ea:	08 95       	ret

000006ec <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     6ec:	1f 92       	push	r1
     6ee:	0f 92       	push	r0
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	0f 92       	push	r0
     6f4:	11 24       	eor	r1, r1
     6f6:	0b b6       	in	r0, 0x3b	; 59
     6f8:	0f 92       	push	r0
     6fa:	2f 93       	push	r18
     6fc:	3f 93       	push	r19
     6fe:	4f 93       	push	r20
     700:	5f 93       	push	r21
     702:	6f 93       	push	r22
     704:	7f 93       	push	r23
     706:	8f 93       	push	r24
     708:	9f 93       	push	r25
     70a:	af 93       	push	r26
     70c:	bf 93       	push	r27
     70e:	ef 93       	push	r30
     710:	ff 93       	push	r31
     712:	60 91 ce 00 	lds	r22, 0x00CE
     716:	83 e7       	ldi	r24, 0x73	; 115
     718:	99 e0       	ldi	r25, 0x09	; 9
     71a:	d4 d5       	rcall	.+2984   	; 0x12c4 <ringBufferPush>
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	80 91 67 09 	lds	r24, 0x0967
     72a:	90 91 68 09 	lds	r25, 0x0968
     72e:	c4 d4       	rcall	.+2440   	; 0x10b8 <xQueueGenericSendFromISR>
     730:	83 e7       	ldi	r24, 0x73	; 115
     732:	99 e0       	ldi	r25, 0x09	; 9
     734:	dd d5       	rcall	.+3002   	; 0x12f0 <ringBufferFull>
     736:	ff 91       	pop	r31
     738:	ef 91       	pop	r30
     73a:	bf 91       	pop	r27
     73c:	af 91       	pop	r26
     73e:	9f 91       	pop	r25
     740:	8f 91       	pop	r24
     742:	7f 91       	pop	r23
     744:	6f 91       	pop	r22
     746:	5f 91       	pop	r21
     748:	4f 91       	pop	r20
     74a:	3f 91       	pop	r19
     74c:	2f 91       	pop	r18
     74e:	0f 90       	pop	r0
     750:	0b be       	out	0x3b, r0	; 59
     752:	0f 90       	pop	r0
     754:	0f be       	out	0x3f, r0	; 63
     756:	0f 90       	pop	r0
     758:	1f 90       	pop	r1
     75a:	18 95       	reti

0000075c <__vector_25>:
     75c:	1f 92       	push	r1
     75e:	0f 92       	push	r0
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	0f 92       	push	r0
     764:	11 24       	eor	r1, r1
     766:	0b b6       	in	r0, 0x3b	; 59
     768:	0f 92       	push	r0
     76a:	2f 93       	push	r18
     76c:	3f 93       	push	r19
     76e:	4f 93       	push	r20
     770:	5f 93       	push	r21
     772:	6f 93       	push	r22
     774:	7f 93       	push	r23
     776:	8f 93       	push	r24
     778:	9f 93       	push	r25
     77a:	af 93       	push	r26
     77c:	bf 93       	push	r27
     77e:	ef 93       	push	r30
     780:	ff 93       	push	r31
     782:	60 91 c6 00 	lds	r22, 0x00C6
     786:	80 e0       	ldi	r24, 0x00	; 0
     788:	99 e0       	ldi	r25, 0x09	; 9
     78a:	9c d5       	rcall	.+2872   	; 0x12c4 <ringBufferPush>
     78c:	20 e0       	ldi	r18, 0x00	; 0
     78e:	40 e0       	ldi	r20, 0x00	; 0
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	60 e0       	ldi	r22, 0x00	; 0
     794:	70 e0       	ldi	r23, 0x00	; 0
     796:	80 91 67 09 	lds	r24, 0x0967
     79a:	90 91 68 09 	lds	r25, 0x0968
     79e:	8c d4       	rcall	.+2328   	; 0x10b8 <xQueueGenericSendFromISR>
     7a0:	80 e0       	ldi	r24, 0x00	; 0
     7a2:	99 e0       	ldi	r25, 0x09	; 9
     7a4:	a5 d5       	rcall	.+2890   	; 0x12f0 <ringBufferFull>
     7a6:	ff 91       	pop	r31
     7a8:	ef 91       	pop	r30
     7aa:	bf 91       	pop	r27
     7ac:	af 91       	pop	r26
     7ae:	9f 91       	pop	r25
     7b0:	8f 91       	pop	r24
     7b2:	7f 91       	pop	r23
     7b4:	6f 91       	pop	r22
     7b6:	5f 91       	pop	r21
     7b8:	4f 91       	pop	r20
     7ba:	3f 91       	pop	r19
     7bc:	2f 91       	pop	r18
     7be:	0f 90       	pop	r0
     7c0:	0b be       	out	0x3b, r0	; 59
     7c2:	0f 90       	pop	r0
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	0f 90       	pop	r0
     7c8:	1f 90       	pop	r1
     7ca:	18 95       	reti

000007cc <__vector_37>:
     7cc:	1f 92       	push	r1
     7ce:	0f 92       	push	r0
     7d0:	0f b6       	in	r0, 0x3f	; 63
     7d2:	0f 92       	push	r0
     7d4:	11 24       	eor	r1, r1
     7d6:	0b b6       	in	r0, 0x3b	; 59
     7d8:	0f 92       	push	r0
     7da:	2f 93       	push	r18
     7dc:	3f 93       	push	r19
     7de:	4f 93       	push	r20
     7e0:	5f 93       	push	r21
     7e2:	6f 93       	push	r22
     7e4:	7f 93       	push	r23
     7e6:	8f 93       	push	r24
     7e8:	9f 93       	push	r25
     7ea:	af 93       	push	r26
     7ec:	bf 93       	push	r27
     7ee:	ef 93       	push	r30
     7f0:	ff 93       	push	r31
     7f2:	89 e6       	ldi	r24, 0x69	; 105
     7f4:	99 e0       	ldi	r25, 0x09	; 9
     7f6:	83 d5       	rcall	.+2822   	; 0x12fe <ringBufferNotEmpty>
     7f8:	88 23       	and	r24, r24
     7fa:	31 f0       	breq	.+12     	; 0x808 <__vector_37+0x3c>
     7fc:	89 e6       	ldi	r24, 0x69	; 105
     7fe:	99 e0       	ldi	r25, 0x09	; 9
     800:	4f d5       	rcall	.+2718   	; 0x12a0 <ringBufferPop>
     802:	80 93 ce 00 	sts	0x00CE, r24
     806:	05 c0       	rjmp	.+10     	; 0x812 <__vector_37+0x46>
     808:	e9 ec       	ldi	r30, 0xC9	; 201
     80a:	f0 e0       	ldi	r31, 0x00	; 0
     80c:	80 81       	ld	r24, Z
     80e:	8f 7d       	andi	r24, 0xDF	; 223
     810:	80 83       	st	Z, r24
     812:	ff 91       	pop	r31
     814:	ef 91       	pop	r30
     816:	bf 91       	pop	r27
     818:	af 91       	pop	r26
     81a:	9f 91       	pop	r25
     81c:	8f 91       	pop	r24
     81e:	7f 91       	pop	r23
     820:	6f 91       	pop	r22
     822:	5f 91       	pop	r21
     824:	4f 91       	pop	r20
     826:	3f 91       	pop	r19
     828:	2f 91       	pop	r18
     82a:	0f 90       	pop	r0
     82c:	0b be       	out	0x3b, r0	; 59
     82e:	0f 90       	pop	r0
     830:	0f be       	out	0x3f, r0	; 63
     832:	0f 90       	pop	r0
     834:	1f 90       	pop	r1
     836:	18 95       	reti

00000838 <__vector_26>:
     838:	1f 92       	push	r1
     83a:	0f 92       	push	r0
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	0f 92       	push	r0
     840:	11 24       	eor	r1, r1
     842:	0b b6       	in	r0, 0x3b	; 59
     844:	0f 92       	push	r0
     846:	2f 93       	push	r18
     848:	3f 93       	push	r19
     84a:	4f 93       	push	r20
     84c:	5f 93       	push	r21
     84e:	6f 93       	push	r22
     850:	7f 93       	push	r23
     852:	8f 93       	push	r24
     854:	9f 93       	push	r25
     856:	af 93       	push	r26
     858:	bf 93       	push	r27
     85a:	ef 93       	push	r30
     85c:	ff 93       	push	r31
     85e:	8e e6       	ldi	r24, 0x6E	; 110
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	4d d5       	rcall	.+2714   	; 0x12fe <ringBufferNotEmpty>
     864:	88 23       	and	r24, r24
     866:	31 f0       	breq	.+12     	; 0x874 <__vector_26+0x3c>
     868:	8e e6       	ldi	r24, 0x6E	; 110
     86a:	99 e0       	ldi	r25, 0x09	; 9
     86c:	19 d5       	rcall	.+2610   	; 0x12a0 <ringBufferPop>
     86e:	80 93 c6 00 	sts	0x00C6, r24
     872:	05 c0       	rjmp	.+10     	; 0x87e <__vector_26+0x46>
     874:	e1 ec       	ldi	r30, 0xC1	; 193
     876:	f0 e0       	ldi	r31, 0x00	; 0
     878:	80 81       	ld	r24, Z
     87a:	8f 7d       	andi	r24, 0xDF	; 223
     87c:	80 83       	st	Z, r24
     87e:	ff 91       	pop	r31
     880:	ef 91       	pop	r30
     882:	bf 91       	pop	r27
     884:	af 91       	pop	r26
     886:	9f 91       	pop	r25
     888:	8f 91       	pop	r24
     88a:	7f 91       	pop	r23
     88c:	6f 91       	pop	r22
     88e:	5f 91       	pop	r21
     890:	4f 91       	pop	r20
     892:	3f 91       	pop	r19
     894:	2f 91       	pop	r18
     896:	0f 90       	pop	r0
     898:	0b be       	out	0x3b, r0	; 59
     89a:	0f 90       	pop	r0
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	0f 90       	pop	r0
     8a0:	1f 90       	pop	r1
     8a2:	18 95       	reti

000008a4 <USART0_Init>:
     8a4:	10 92 c5 00 	sts	0x00C5, r1
     8a8:	87 e6       	ldi	r24, 0x67	; 103
     8aa:	80 93 c4 00 	sts	0x00C4, r24
     8ae:	88 eb       	ldi	r24, 0xB8	; 184
     8b0:	80 93 c1 00 	sts	0x00C1, r24
     8b4:	86 e0       	ldi	r24, 0x06	; 6
     8b6:	80 93 c2 00 	sts	0x00C2, r24
     8ba:	40 e2       	ldi	r20, 0x20	; 32
     8bc:	65 e2       	ldi	r22, 0x25	; 37
     8be:	79 e0       	ldi	r23, 0x09	; 9
     8c0:	80 e0       	ldi	r24, 0x00	; 0
     8c2:	99 e0       	ldi	r25, 0x09	; 9
     8c4:	e6 d4       	rcall	.+2508   	; 0x1292 <ringBufferInit>
     8c6:	40 e2       	ldi	r20, 0x20	; 32
     8c8:	65 e0       	ldi	r22, 0x05	; 5
     8ca:	79 e0       	ldi	r23, 0x09	; 9
     8cc:	8e e6       	ldi	r24, 0x6E	; 110
     8ce:	99 e0       	ldi	r25, 0x09	; 9
     8d0:	e0 d4       	rcall	.+2496   	; 0x1292 <ringBufferInit>
     8d2:	43 e0       	ldi	r20, 0x03	; 3
     8d4:	60 e0       	ldi	r22, 0x00	; 0
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	0a d3       	rcall	.+1556   	; 0xeee <xQueueGenericCreate>
     8da:	90 93 66 09 	sts	0x0966, r25
     8de:	80 93 65 09 	sts	0x0965, r24
     8e2:	08 95       	ret

000008e4 <USART1_Init>:
     8e4:	10 92 cd 00 	sts	0x00CD, r1
     8e8:	87 e6       	ldi	r24, 0x67	; 103
     8ea:	80 93 cc 00 	sts	0x00CC, r24
     8ee:	88 eb       	ldi	r24, 0xB8	; 184
     8f0:	80 93 c9 00 	sts	0x00C9, r24
     8f4:	86 e0       	ldi	r24, 0x06	; 6
     8f6:	80 93 ca 00 	sts	0x00CA, r24
     8fa:	40 e2       	ldi	r20, 0x20	; 32
     8fc:	60 ee       	ldi	r22, 0xE0	; 224
     8fe:	78 e0       	ldi	r23, 0x08	; 8
     900:	83 e7       	ldi	r24, 0x73	; 115
     902:	99 e0       	ldi	r25, 0x09	; 9
     904:	c6 d4       	rcall	.+2444   	; 0x1292 <ringBufferInit>
     906:	40 e2       	ldi	r20, 0x20	; 32
     908:	65 e4       	ldi	r22, 0x45	; 69
     90a:	79 e0       	ldi	r23, 0x09	; 9
     90c:	89 e6       	ldi	r24, 0x69	; 105
     90e:	99 e0       	ldi	r25, 0x09	; 9
     910:	c0 d4       	rcall	.+2432   	; 0x1292 <ringBufferInit>
     912:	43 e0       	ldi	r20, 0x03	; 3
     914:	60 e0       	ldi	r22, 0x00	; 0
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	ea d2       	rcall	.+1492   	; 0xeee <xQueueGenericCreate>
     91a:	90 93 68 09 	sts	0x0968, r25
     91e:	80 93 67 09 	sts	0x0967, r24
     922:	08 95       	ret

00000924 <transmitUSART0_c>:
     924:	cf 93       	push	r28
     926:	c8 2f       	mov	r28, r24
     928:	8e e6       	ldi	r24, 0x6E	; 110
     92a:	99 e0       	ldi	r25, 0x09	; 9
     92c:	e1 d4       	rcall	.+2498   	; 0x12f0 <ringBufferFull>
     92e:	81 11       	cpse	r24, r1
     930:	fb cf       	rjmp	.-10     	; 0x928 <transmitUSART0_c+0x4>
     932:	6c 2f       	mov	r22, r28
     934:	8e e6       	ldi	r24, 0x6E	; 110
     936:	99 e0       	ldi	r25, 0x09	; 9
     938:	c5 d4       	rcall	.+2442   	; 0x12c4 <ringBufferPush>
     93a:	e1 ec       	ldi	r30, 0xC1	; 193
     93c:	f0 e0       	ldi	r31, 0x00	; 0
     93e:	80 81       	ld	r24, Z
     940:	80 62       	ori	r24, 0x20	; 32
     942:	80 83       	st	Z, r24
     944:	e0 ec       	ldi	r30, 0xC0	; 192
     946:	f0 e0       	ldi	r31, 0x00	; 0
     948:	80 81       	ld	r24, Z
     94a:	80 64       	ori	r24, 0x40	; 64
     94c:	80 83       	st	Z, r24
     94e:	cf 91       	pop	r28
     950:	08 95       	ret

00000952 <transmitUSART1_c>:
     952:	cf 93       	push	r28
     954:	c8 2f       	mov	r28, r24
     956:	89 e6       	ldi	r24, 0x69	; 105
     958:	99 e0       	ldi	r25, 0x09	; 9
     95a:	ca d4       	rcall	.+2452   	; 0x12f0 <ringBufferFull>
     95c:	81 11       	cpse	r24, r1
     95e:	fb cf       	rjmp	.-10     	; 0x956 <transmitUSART1_c+0x4>
     960:	6c 2f       	mov	r22, r28
     962:	89 e6       	ldi	r24, 0x69	; 105
     964:	99 e0       	ldi	r25, 0x09	; 9
     966:	ae d4       	rcall	.+2396   	; 0x12c4 <ringBufferPush>
     968:	e9 ec       	ldi	r30, 0xC9	; 201
     96a:	f0 e0       	ldi	r31, 0x00	; 0
     96c:	80 81       	ld	r24, Z
     96e:	80 62       	ori	r24, 0x20	; 32
     970:	80 83       	st	Z, r24
     972:	e8 ec       	ldi	r30, 0xC8	; 200
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	80 81       	ld	r24, Z
     978:	80 64       	ori	r24, 0x40	; 64
     97a:	80 83       	st	Z, r24
     97c:	cf 91       	pop	r28
     97e:	08 95       	ret

00000980 <transmitUSART0>:
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	ec 01       	movw	r28, r24
     986:	88 81       	ld	r24, Y
     988:	88 23       	and	r24, r24
     98a:	29 f0       	breq	.+10     	; 0x996 <transmitUSART0+0x16>
     98c:	21 96       	adiw	r28, 0x01	; 1
     98e:	ca df       	rcall	.-108    	; 0x924 <transmitUSART0_c>
     990:	89 91       	ld	r24, Y+
     992:	81 11       	cpse	r24, r1
     994:	fc cf       	rjmp	.-8      	; 0x98e <transmitUSART0+0xe>
     996:	df 91       	pop	r29
     998:	cf 91       	pop	r28
     99a:	08 95       	ret

0000099c <receiveUSART1>:
     99c:	cf 93       	push	r28
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	4f ef       	ldi	r20, 0xFF	; 255
     9a2:	5f ef       	ldi	r21, 0xFF	; 255
     9a4:	60 e0       	ldi	r22, 0x00	; 0
     9a6:	70 e0       	ldi	r23, 0x00	; 0
     9a8:	80 91 65 09 	lds	r24, 0x0965
     9ac:	90 91 66 09 	lds	r25, 0x0966
     9b0:	bd d3       	rcall	.+1914   	; 0x112c <xQueueGenericReceive>
     9b2:	83 e7       	ldi	r24, 0x73	; 115
     9b4:	99 e0       	ldi	r25, 0x09	; 9
     9b6:	74 d4       	rcall	.+2280   	; 0x12a0 <ringBufferPop>
     9b8:	c8 2f       	mov	r28, r24
     9ba:	83 e7       	ldi	r24, 0x73	; 115
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	9f d4       	rcall	.+2366   	; 0x12fe <ringBufferNotEmpty>
     9c0:	88 23       	and	r24, r24
     9c2:	51 f0       	breq	.+20     	; 0x9d8 <receiveUSART1+0x3c>
     9c4:	20 e0       	ldi	r18, 0x00	; 0
     9c6:	40 e0       	ldi	r20, 0x00	; 0
     9c8:	50 e0       	ldi	r21, 0x00	; 0
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	70 e0       	ldi	r23, 0x00	; 0
     9ce:	80 91 65 09 	lds	r24, 0x0965
     9d2:	90 91 66 09 	lds	r25, 0x0966
     9d6:	b5 d2       	rcall	.+1386   	; 0xf42 <xQueueGenericSend>
     9d8:	8c 2f       	mov	r24, r28
     9da:	cf 91       	pop	r28
     9dc:	08 95       	ret

000009de <startHandShake>:

// -1 if fail, 0 success
char startHandShake()
{
	transmitUSART1_c(HANDSHAKE_START);
     9de:	80 e0       	ldi	r24, 0x00	; 0
     9e0:	b8 df       	rcall	.-144    	; 0x952 <transmitUSART1_c>
	
	if (! receiveHandShakeAck(receiveUSART1()))
     9e2:	dc df       	rcall	.-72     	; 0x99c <receiveUSART1>
     9e4:	85 35       	cpi	r24, 0x55	; 85
     9e6:	21 f4       	brne	.+8      	; 0x9f0 <startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
     9e8:	8f ef       	ldi	r24, 0xFF	; 255
     9ea:	b3 df       	rcall	.-154    	; 0x952 <transmitUSART1_c>
	
	return 0;
     9ec:	80 e0       	ldi	r24, 0x00	; 0
     9ee:	08 95       	ret
{
	transmitUSART1_c(HANDSHAKE_START);
	
	if (! receiveHandShakeAck(receiveUSART1()))
	{
		return -1; //error handling
     9f0:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     9f2:	08 95       	ret

000009f4 <waitForHandshake>:


// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
     9f4:	d3 df       	rcall	.-90     	; 0x99c <receiveUSART1>
     9f6:	81 11       	cpse	r24, r1
     9f8:	0a c0       	rjmp	.+20     	; 0xa0e <waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	transmitUSART1_c(HANDSHAKE_ACK);
     9fa:	85 e5       	ldi	r24, 0x55	; 85
     9fc:	aa df       	rcall	.-172    	; 0x952 <transmitUSART1_c>
	
	if (! receiveHandShakeStart(receiveUSART1()))
     9fe:	ce df       	rcall	.-100    	; 0x99c <receiveUSART1>
     a00:	91 e0       	ldi	r25, 0x01	; 1
     a02:	81 11       	cpse	r24, r1
     a04:	01 c0       	rjmp	.+2      	; 0xa08 <waitForHandshake+0x14>
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	89 2f       	mov	r24, r25
     a0a:	81 95       	neg	r24
     a0c:	08 95       	ret
// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
	{
		return -1; // error handling
     a0e:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     a10:	08 95       	ret

00000a12 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a12:	31 e1       	ldi	r19, 0x11	; 17
     a14:	fc 01       	movw	r30, r24
     a16:	30 83       	st	Z, r19
     a18:	31 97       	sbiw	r30, 0x01	; 1
     a1a:	22 e2       	ldi	r18, 0x22	; 34
     a1c:	20 83       	st	Z, r18
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	a3 e3       	ldi	r26, 0x33	; 51
     a22:	a0 83       	st	Z, r26
     a24:	31 97       	sbiw	r30, 0x01	; 1
     a26:	60 83       	st	Z, r22
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	70 83       	st	Z, r23
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	10 82       	st	Z, r1
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	10 82       	st	Z, r1
     a34:	31 97       	sbiw	r30, 0x01	; 1
     a36:	60 e8       	ldi	r22, 0x80	; 128
     a38:	60 83       	st	Z, r22
     a3a:	31 97       	sbiw	r30, 0x01	; 1
     a3c:	10 82       	st	Z, r1
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	10 82       	st	Z, r1
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	10 82       	st	Z, r1
     a46:	31 97       	sbiw	r30, 0x01	; 1
     a48:	62 e0       	ldi	r22, 0x02	; 2
     a4a:	60 83       	st	Z, r22
     a4c:	31 97       	sbiw	r30, 0x01	; 1
     a4e:	63 e0       	ldi	r22, 0x03	; 3
     a50:	60 83       	st	Z, r22
     a52:	31 97       	sbiw	r30, 0x01	; 1
     a54:	64 e0       	ldi	r22, 0x04	; 4
     a56:	60 83       	st	Z, r22
     a58:	31 97       	sbiw	r30, 0x01	; 1
     a5a:	65 e0       	ldi	r22, 0x05	; 5
     a5c:	60 83       	st	Z, r22
     a5e:	31 97       	sbiw	r30, 0x01	; 1
     a60:	66 e0       	ldi	r22, 0x06	; 6
     a62:	60 83       	st	Z, r22
     a64:	31 97       	sbiw	r30, 0x01	; 1
     a66:	67 e0       	ldi	r22, 0x07	; 7
     a68:	60 83       	st	Z, r22
     a6a:	31 97       	sbiw	r30, 0x01	; 1
     a6c:	68 e0       	ldi	r22, 0x08	; 8
     a6e:	60 83       	st	Z, r22
     a70:	31 97       	sbiw	r30, 0x01	; 1
     a72:	69 e0       	ldi	r22, 0x09	; 9
     a74:	60 83       	st	Z, r22
     a76:	31 97       	sbiw	r30, 0x01	; 1
     a78:	60 e1       	ldi	r22, 0x10	; 16
     a7a:	60 83       	st	Z, r22
     a7c:	31 97       	sbiw	r30, 0x01	; 1
     a7e:	30 83       	st	Z, r19
     a80:	31 97       	sbiw	r30, 0x01	; 1
     a82:	32 e1       	ldi	r19, 0x12	; 18
     a84:	30 83       	st	Z, r19
     a86:	31 97       	sbiw	r30, 0x01	; 1
     a88:	33 e1       	ldi	r19, 0x13	; 19
     a8a:	30 83       	st	Z, r19
     a8c:	31 97       	sbiw	r30, 0x01	; 1
     a8e:	34 e1       	ldi	r19, 0x14	; 20
     a90:	30 83       	st	Z, r19
     a92:	31 97       	sbiw	r30, 0x01	; 1
     a94:	35 e1       	ldi	r19, 0x15	; 21
     a96:	30 83       	st	Z, r19
     a98:	31 97       	sbiw	r30, 0x01	; 1
     a9a:	36 e1       	ldi	r19, 0x16	; 22
     a9c:	30 83       	st	Z, r19
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	37 e1       	ldi	r19, 0x17	; 23
     aa2:	30 83       	st	Z, r19
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	38 e1       	ldi	r19, 0x18	; 24
     aa8:	30 83       	st	Z, r19
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	39 e1       	ldi	r19, 0x19	; 25
     aae:	30 83       	st	Z, r19
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	30 e2       	ldi	r19, 0x20	; 32
     ab4:	30 83       	st	Z, r19
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	31 e2       	ldi	r19, 0x21	; 33
     aba:	30 83       	st	Z, r19
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	20 83       	st	Z, r18
     ac0:	31 97       	sbiw	r30, 0x01	; 1
     ac2:	23 e2       	ldi	r18, 0x23	; 35
     ac4:	20 83       	st	Z, r18
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	40 83       	st	Z, r20
     aca:	31 97       	sbiw	r30, 0x01	; 1
     acc:	50 83       	st	Z, r21
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	26 e2       	ldi	r18, 0x26	; 38
     ad2:	20 83       	st	Z, r18
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	27 e2       	ldi	r18, 0x27	; 39
     ad8:	20 83       	st	Z, r18
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	28 e2       	ldi	r18, 0x28	; 40
     ade:	20 83       	st	Z, r18
     ae0:	31 97       	sbiw	r30, 0x01	; 1
     ae2:	29 e2       	ldi	r18, 0x29	; 41
     ae4:	20 83       	st	Z, r18
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	20 e3       	ldi	r18, 0x30	; 48
     aea:	20 83       	st	Z, r18
     aec:	31 97       	sbiw	r30, 0x01	; 1
     aee:	21 e3       	ldi	r18, 0x31	; 49
     af0:	20 83       	st	Z, r18
     af2:	89 97       	sbiw	r24, 0x29	; 41
     af4:	08 95       	ret

00000af6 <xPortStartScheduler>:
     af6:	82 e0       	ldi	r24, 0x02	; 2
     af8:	84 bd       	out	0x24, r24	; 36
     afa:	16 bc       	out	0x26, r1	; 38
     afc:	80 e3       	ldi	r24, 0x30	; 48
     afe:	87 bd       	out	0x27, r24	; 39
     b00:	ee e6       	ldi	r30, 0x6E	; 110
     b02:	f0 e0       	ldi	r31, 0x00	; 0
     b04:	80 81       	ld	r24, Z
     b06:	82 60       	ori	r24, 0x02	; 2
     b08:	80 83       	st	Z, r24
     b0a:	83 e0       	ldi	r24, 0x03	; 3
     b0c:	85 bd       	out	0x25, r24	; 37
     b0e:	a0 91 d5 08 	lds	r26, 0x08D5
     b12:	b0 91 d6 08 	lds	r27, 0x08D6
     b16:	cd 91       	ld	r28, X+
     b18:	cd bf       	out	0x3d, r28	; 61
     b1a:	dd 91       	ld	r29, X+
     b1c:	de bf       	out	0x3e, r29	; 62
     b1e:	ff 91       	pop	r31
     b20:	ef 91       	pop	r30
     b22:	df 91       	pop	r29
     b24:	cf 91       	pop	r28
     b26:	bf 91       	pop	r27
     b28:	af 91       	pop	r26
     b2a:	9f 91       	pop	r25
     b2c:	8f 91       	pop	r24
     b2e:	7f 91       	pop	r23
     b30:	6f 91       	pop	r22
     b32:	5f 91       	pop	r21
     b34:	4f 91       	pop	r20
     b36:	3f 91       	pop	r19
     b38:	2f 91       	pop	r18
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	df 90       	pop	r13
     b44:	cf 90       	pop	r12
     b46:	bf 90       	pop	r11
     b48:	af 90       	pop	r10
     b4a:	9f 90       	pop	r9
     b4c:	8f 90       	pop	r8
     b4e:	7f 90       	pop	r7
     b50:	6f 90       	pop	r6
     b52:	5f 90       	pop	r5
     b54:	4f 90       	pop	r4
     b56:	3f 90       	pop	r3
     b58:	2f 90       	pop	r2
     b5a:	1f 90       	pop	r1
     b5c:	0f 90       	pop	r0
     b5e:	0c be       	out	0x3c, r0	; 60
     b60:	0f 90       	pop	r0
     b62:	0b be       	out	0x3b, r0	; 59
     b64:	0f 90       	pop	r0
     b66:	0f be       	out	0x3f, r0	; 63
     b68:	0f 90       	pop	r0
     b6a:	08 95       	ret
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	08 95       	ret

00000b70 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     b70:	0f 92       	push	r0
     b72:	0f b6       	in	r0, 0x3f	; 63
     b74:	f8 94       	cli
     b76:	0f 92       	push	r0
     b78:	0b b6       	in	r0, 0x3b	; 59
     b7a:	0f 92       	push	r0
     b7c:	0c b6       	in	r0, 0x3c	; 60
     b7e:	0f 92       	push	r0
     b80:	1f 92       	push	r1
     b82:	11 24       	eor	r1, r1
     b84:	2f 92       	push	r2
     b86:	3f 92       	push	r3
     b88:	4f 92       	push	r4
     b8a:	5f 92       	push	r5
     b8c:	6f 92       	push	r6
     b8e:	7f 92       	push	r7
     b90:	8f 92       	push	r8
     b92:	9f 92       	push	r9
     b94:	af 92       	push	r10
     b96:	bf 92       	push	r11
     b98:	cf 92       	push	r12
     b9a:	df 92       	push	r13
     b9c:	ef 92       	push	r14
     b9e:	ff 92       	push	r15
     ba0:	0f 93       	push	r16
     ba2:	1f 93       	push	r17
     ba4:	2f 93       	push	r18
     ba6:	3f 93       	push	r19
     ba8:	4f 93       	push	r20
     baa:	5f 93       	push	r21
     bac:	6f 93       	push	r22
     bae:	7f 93       	push	r23
     bb0:	8f 93       	push	r24
     bb2:	9f 93       	push	r25
     bb4:	af 93       	push	r26
     bb6:	bf 93       	push	r27
     bb8:	cf 93       	push	r28
     bba:	df 93       	push	r29
     bbc:	ef 93       	push	r30
     bbe:	ff 93       	push	r31
     bc0:	a0 91 d5 08 	lds	r26, 0x08D5
     bc4:	b0 91 d6 08 	lds	r27, 0x08D6
     bc8:	0d b6       	in	r0, 0x3d	; 61
     bca:	0d 92       	st	X+, r0
     bcc:	0e b6       	in	r0, 0x3e	; 62
     bce:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     bd0:	15 d7       	rcall	.+3626   	; 0x19fc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bd2:	a0 91 d5 08 	lds	r26, 0x08D5
     bd6:	b0 91 d6 08 	lds	r27, 0x08D6
     bda:	cd 91       	ld	r28, X+
     bdc:	cd bf       	out	0x3d, r28	; 61
     bde:	dd 91       	ld	r29, X+
     be0:	de bf       	out	0x3e, r29	; 62
     be2:	ff 91       	pop	r31
     be4:	ef 91       	pop	r30
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	bf 91       	pop	r27
     bec:	af 91       	pop	r26
     bee:	9f 91       	pop	r25
     bf0:	8f 91       	pop	r24
     bf2:	7f 91       	pop	r23
     bf4:	6f 91       	pop	r22
     bf6:	5f 91       	pop	r21
     bf8:	4f 91       	pop	r20
     bfa:	3f 91       	pop	r19
     bfc:	2f 91       	pop	r18
     bfe:	1f 91       	pop	r17
     c00:	0f 91       	pop	r16
     c02:	ff 90       	pop	r15
     c04:	ef 90       	pop	r14
     c06:	df 90       	pop	r13
     c08:	cf 90       	pop	r12
     c0a:	bf 90       	pop	r11
     c0c:	af 90       	pop	r10
     c0e:	9f 90       	pop	r9
     c10:	8f 90       	pop	r8
     c12:	7f 90       	pop	r7
     c14:	6f 90       	pop	r6
     c16:	5f 90       	pop	r5
     c18:	4f 90       	pop	r4
     c1a:	3f 90       	pop	r3
     c1c:	2f 90       	pop	r2
     c1e:	1f 90       	pop	r1
     c20:	0f 90       	pop	r0
     c22:	0c be       	out	0x3c, r0	; 60
     c24:	0f 90       	pop	r0
     c26:	0b be       	out	0x3b, r0	; 59
     c28:	0f 90       	pop	r0
     c2a:	0f be       	out	0x3f, r0	; 63
     c2c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c2e:	08 95       	ret

00000c30 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c30:	0f 92       	push	r0
     c32:	0f b6       	in	r0, 0x3f	; 63
     c34:	f8 94       	cli
     c36:	0f 92       	push	r0
     c38:	0b b6       	in	r0, 0x3b	; 59
     c3a:	0f 92       	push	r0
     c3c:	0c b6       	in	r0, 0x3c	; 60
     c3e:	0f 92       	push	r0
     c40:	1f 92       	push	r1
     c42:	11 24       	eor	r1, r1
     c44:	2f 92       	push	r2
     c46:	3f 92       	push	r3
     c48:	4f 92       	push	r4
     c4a:	5f 92       	push	r5
     c4c:	6f 92       	push	r6
     c4e:	7f 92       	push	r7
     c50:	8f 92       	push	r8
     c52:	9f 92       	push	r9
     c54:	af 92       	push	r10
     c56:	bf 92       	push	r11
     c58:	cf 92       	push	r12
     c5a:	df 92       	push	r13
     c5c:	ef 92       	push	r14
     c5e:	ff 92       	push	r15
     c60:	0f 93       	push	r16
     c62:	1f 93       	push	r17
     c64:	2f 93       	push	r18
     c66:	3f 93       	push	r19
     c68:	4f 93       	push	r20
     c6a:	5f 93       	push	r21
     c6c:	6f 93       	push	r22
     c6e:	7f 93       	push	r23
     c70:	8f 93       	push	r24
     c72:	9f 93       	push	r25
     c74:	af 93       	push	r26
     c76:	bf 93       	push	r27
     c78:	cf 93       	push	r28
     c7a:	df 93       	push	r29
     c7c:	ef 93       	push	r30
     c7e:	ff 93       	push	r31
     c80:	a0 91 d5 08 	lds	r26, 0x08D5
     c84:	b0 91 d6 08 	lds	r27, 0x08D6
     c88:	0d b6       	in	r0, 0x3d	; 61
     c8a:	0d 92       	st	X+, r0
     c8c:	0e b6       	in	r0, 0x3e	; 62
     c8e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     c90:	21 d5       	rcall	.+2626   	; 0x16d4 <xTaskIncrementTick>
     c92:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     c94:	b3 d6       	rcall	.+3430   	; 0x19fc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     c96:	a0 91 d5 08 	lds	r26, 0x08D5
     c9a:	b0 91 d6 08 	lds	r27, 0x08D6
     c9e:	cd 91       	ld	r28, X+
     ca0:	cd bf       	out	0x3d, r28	; 61
     ca2:	dd 91       	ld	r29, X+
     ca4:	de bf       	out	0x3e, r29	; 62
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	df 91       	pop	r29
     cac:	cf 91       	pop	r28
     cae:	bf 91       	pop	r27
     cb0:	af 91       	pop	r26
     cb2:	9f 91       	pop	r25
     cb4:	8f 91       	pop	r24
     cb6:	7f 91       	pop	r23
     cb8:	6f 91       	pop	r22
     cba:	5f 91       	pop	r21
     cbc:	4f 91       	pop	r20
     cbe:	3f 91       	pop	r19
     cc0:	2f 91       	pop	r18
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	ff 90       	pop	r15
     cc8:	ef 90       	pop	r14
     cca:	df 90       	pop	r13
     ccc:	cf 90       	pop	r12
     cce:	bf 90       	pop	r11
     cd0:	af 90       	pop	r10
     cd2:	9f 90       	pop	r9
     cd4:	8f 90       	pop	r8
     cd6:	7f 90       	pop	r7
     cd8:	6f 90       	pop	r6
     cda:	5f 90       	pop	r5
     cdc:	4f 90       	pop	r4
     cde:	3f 90       	pop	r3
     ce0:	2f 90       	pop	r2
     ce2:	1f 90       	pop	r1
     ce4:	0f 90       	pop	r0
     ce6:	0c be       	out	0x3c, r0	; 60
     ce8:	0f 90       	pop	r0
     cea:	0b be       	out	0x3b, r0	; 59
     cec:	0f 90       	pop	r0
     cee:	0f be       	out	0x3f, r0	; 63
     cf0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cf2:	08 95       	ret

00000cf4 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     cf4:	9d df       	rcall	.-198    	; 0xc30 <vPortYieldFromTick>
		 asm volatile ("reti");
     cf6:	18 95       	reti

00000cf8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     cf8:	1f 93       	push	r17
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	ec 01       	movw	r28, r24
     d00:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     d02:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d04:	81 11       	cpse	r24, r1
     d06:	0c c0       	rjmp	.+24     	; 0xd20 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d08:	88 81       	ld	r24, Y
     d0a:	99 81       	ldd	r25, Y+1	; 0x01
     d0c:	89 2b       	or	r24, r25
     d0e:	09 f0       	breq	.+2      	; 0xd12 <prvCopyDataToQueue+0x1a>
     d10:	47 c0       	rjmp	.+142    	; 0xda0 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     d12:	8a 81       	ldd	r24, Y+2	; 0x02
     d14:	9b 81       	ldd	r25, Y+3	; 0x03
     d16:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     d1a:	1b 82       	std	Y+3, r1	; 0x03
     d1c:	1a 82       	std	Y+2, r1	; 0x02
     d1e:	47 c0       	rjmp	.+142    	; 0xdae <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     d20:	41 11       	cpse	r20, r1
     d22:	18 c0       	rjmp	.+48     	; 0xd54 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     d24:	48 2f       	mov	r20, r24
     d26:	50 e0       	ldi	r21, 0x00	; 0
     d28:	8c 81       	ldd	r24, Y+4	; 0x04
     d2a:	9d 81       	ldd	r25, Y+5	; 0x05
     d2c:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     d30:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d32:	8c 81       	ldd	r24, Y+4	; 0x04
     d34:	9d 81       	ldd	r25, Y+5	; 0x05
     d36:	82 0f       	add	r24, r18
     d38:	91 1d       	adc	r25, r1
     d3a:	9d 83       	std	Y+5, r25	; 0x05
     d3c:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d3e:	2a 81       	ldd	r18, Y+2	; 0x02
     d40:	3b 81       	ldd	r19, Y+3	; 0x03
     d42:	82 17       	cp	r24, r18
     d44:	93 07       	cpc	r25, r19
     d46:	70 f1       	brcs	.+92     	; 0xda4 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     d48:	88 81       	ld	r24, Y
     d4a:	99 81       	ldd	r25, Y+1	; 0x01
     d4c:	9d 83       	std	Y+5, r25	; 0x05
     d4e:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d50:	80 e0       	ldi	r24, 0x00	; 0
     d52:	2d c0       	rjmp	.+90     	; 0xdae <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d54:	48 2f       	mov	r20, r24
     d56:	50 e0       	ldi	r21, 0x00	; 0
     d58:	8e 81       	ldd	r24, Y+6	; 0x06
     d5a:	9f 81       	ldd	r25, Y+7	; 0x07
     d5c:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     d60:	2c 8d       	ldd	r18, Y+28	; 0x1c
     d62:	30 e0       	ldi	r19, 0x00	; 0
     d64:	31 95       	neg	r19
     d66:	21 95       	neg	r18
     d68:	31 09       	sbc	r19, r1
     d6a:	8e 81       	ldd	r24, Y+6	; 0x06
     d6c:	9f 81       	ldd	r25, Y+7	; 0x07
     d6e:	82 0f       	add	r24, r18
     d70:	93 1f       	adc	r25, r19
     d72:	9f 83       	std	Y+7, r25	; 0x07
     d74:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     d76:	68 81       	ld	r22, Y
     d78:	79 81       	ldd	r23, Y+1	; 0x01
     d7a:	86 17       	cp	r24, r22
     d7c:	97 07       	cpc	r25, r23
     d7e:	30 f4       	brcc	.+12     	; 0xd8c <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     d80:	8a 81       	ldd	r24, Y+2	; 0x02
     d82:	9b 81       	ldd	r25, Y+3	; 0x03
     d84:	28 0f       	add	r18, r24
     d86:	39 1f       	adc	r19, r25
     d88:	3f 83       	std	Y+7, r19	; 0x07
     d8a:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     d8c:	12 30       	cpi	r17, 0x02	; 2
     d8e:	61 f4       	brne	.+24     	; 0xda8 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     d90:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d92:	88 23       	and	r24, r24
     d94:	59 f0       	breq	.+22     	; 0xdac <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     d96:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d98:	81 50       	subi	r24, 0x01	; 1
     d9a:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	07 c0       	rjmp	.+14     	; 0xdae <prvCopyDataToQueue+0xb6>
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	05 c0       	rjmp	.+10     	; 0xdae <prvCopyDataToQueue+0xb6>
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	03 c0       	rjmp	.+6      	; 0xdae <prvCopyDataToQueue+0xb6>
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	01 c0       	rjmp	.+2      	; 0xdae <prvCopyDataToQueue+0xb6>
     dac:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     dae:	9a 8d       	ldd	r25, Y+26	; 0x1a
     db0:	9f 5f       	subi	r25, 0xFF	; 255
     db2:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	1f 91       	pop	r17
     dba:	08 95       	ret

00000dbc <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     dbc:	fc 01       	movw	r30, r24
     dbe:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     dc0:	44 8d       	ldd	r20, Z+28	; 0x1c
     dc2:	44 23       	and	r20, r20
     dc4:	a1 f0       	breq	.+40     	; 0xdee <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	26 81       	ldd	r18, Z+6	; 0x06
     dca:	37 81       	ldd	r19, Z+7	; 0x07
     dcc:	24 0f       	add	r18, r20
     dce:	35 1f       	adc	r19, r21
     dd0:	37 83       	std	Z+7, r19	; 0x07
     dd2:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     dd4:	62 81       	ldd	r22, Z+2	; 0x02
     dd6:	73 81       	ldd	r23, Z+3	; 0x03
     dd8:	26 17       	cp	r18, r22
     dda:	37 07       	cpc	r19, r23
     ddc:	20 f0       	brcs	.+8      	; 0xde6 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     dde:	20 81       	ld	r18, Z
     de0:	31 81       	ldd	r19, Z+1	; 0x01
     de2:	37 83       	std	Z+7, r19	; 0x07
     de4:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     de6:	66 81       	ldd	r22, Z+6	; 0x06
     de8:	77 81       	ldd	r23, Z+7	; 0x07
     dea:	0c 94 38 0f 	jmp	0x1e70	; 0x1e70 <memcpy>
     dee:	08 95       	ret

00000df0 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     df0:	0f 93       	push	r16
     df2:	1f 93       	push	r17
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     dfa:	0f b6       	in	r0, 0x3f	; 63
     dfc:	f8 94       	cli
     dfe:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     e00:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e02:	18 16       	cp	r1, r24
     e04:	a4 f4       	brge	.+40     	; 0xe2e <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e06:	89 89       	ldd	r24, Y+17	; 0x11
     e08:	88 23       	and	r24, r24
     e0a:	89 f0       	breq	.+34     	; 0xe2e <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e0c:	8e 01       	movw	r16, r28
     e0e:	0f 5e       	subi	r16, 0xEF	; 239
     e10:	1f 4f       	sbci	r17, 0xFF	; 255
     e12:	03 c0       	rjmp	.+6      	; 0xe1a <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e14:	89 89       	ldd	r24, Y+17	; 0x11
     e16:	88 23       	and	r24, r24
     e18:	51 f0       	breq	.+20     	; 0xe2e <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e1a:	c8 01       	movw	r24, r16
     e1c:	c4 d6       	rcall	.+3464   	; 0x1ba6 <xTaskRemoveFromEventList>
     e1e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     e20:	4d d7       	rcall	.+3738   	; 0x1cbc <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     e22:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e24:	81 50       	subi	r24, 0x01	; 1
     e26:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     e28:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e2a:	18 16       	cp	r1, r24
     e2c:	9c f3       	brlt	.-26     	; 0xe14 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     e2e:	8f ef       	ldi	r24, 0xFF	; 255
     e30:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     e32:	0f 90       	pop	r0
     e34:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e3c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e3e:	18 16       	cp	r1, r24
     e40:	a4 f4       	brge	.+40     	; 0xe6a <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e42:	88 85       	ldd	r24, Y+8	; 0x08
     e44:	88 23       	and	r24, r24
     e46:	89 f0       	breq	.+34     	; 0xe6a <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e48:	8e 01       	movw	r16, r28
     e4a:	08 5f       	subi	r16, 0xF8	; 248
     e4c:	1f 4f       	sbci	r17, 0xFF	; 255
     e4e:	03 c0       	rjmp	.+6      	; 0xe56 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     e50:	88 85       	ldd	r24, Y+8	; 0x08
     e52:	88 23       	and	r24, r24
     e54:	51 f0       	breq	.+20     	; 0xe6a <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     e56:	c8 01       	movw	r24, r16
     e58:	a6 d6       	rcall	.+3404   	; 0x1ba6 <xTaskRemoveFromEventList>
     e5a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     e5c:	2f d7       	rcall	.+3678   	; 0x1cbc <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     e5e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e60:	81 50       	subi	r24, 0x01	; 1
     e62:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     e64:	8d 8d       	ldd	r24, Y+29	; 0x1d
     e66:	18 16       	cp	r1, r24
     e68:	9c f3       	brlt	.-26     	; 0xe50 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     e6a:	8f ef       	ldi	r24, 0xFF	; 255
     e6c:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     e6e:	0f 90       	pop	r0
     e70:	0f be       	out	0x3f, r0	; 63
}
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	1f 91       	pop	r17
     e78:	0f 91       	pop	r16
     e7a:	08 95       	ret

00000e7c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     e82:	0f b6       	in	r0, 0x3f	; 63
     e84:	f8 94       	cli
     e86:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     e88:	88 81       	ld	r24, Y
     e8a:	99 81       	ldd	r25, Y+1	; 0x01
     e8c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e8e:	30 e0       	ldi	r19, 0x00	; 0
     e90:	7b 8d       	ldd	r23, Y+27	; 0x1b
     e92:	72 9f       	mul	r23, r18
     e94:	a0 01       	movw	r20, r0
     e96:	73 9f       	mul	r23, r19
     e98:	50 0d       	add	r21, r0
     e9a:	11 24       	eor	r1, r1
     e9c:	fc 01       	movw	r30, r24
     e9e:	e4 0f       	add	r30, r20
     ea0:	f5 1f       	adc	r31, r21
     ea2:	fb 83       	std	Y+3, r31	; 0x03
     ea4:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     ea6:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     ea8:	9d 83       	std	Y+5, r25	; 0x05
     eaa:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     eac:	42 1b       	sub	r20, r18
     eae:	53 0b       	sbc	r21, r19
     eb0:	84 0f       	add	r24, r20
     eb2:	95 1f       	adc	r25, r21
     eb4:	9f 83       	std	Y+7, r25	; 0x07
     eb6:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     eb8:	8f ef       	ldi	r24, 0xFF	; 255
     eba:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     ebc:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     ebe:	61 11       	cpse	r22, r1
     ec0:	0a c0       	rjmp	.+20     	; 0xed6 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ec2:	88 85       	ldd	r24, Y+8	; 0x08
     ec4:	88 23       	and	r24, r24
     ec6:	69 f0       	breq	.+26     	; 0xee2 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ec8:	ce 01       	movw	r24, r28
     eca:	08 96       	adiw	r24, 0x08	; 8
     ecc:	6c d6       	rcall	.+3288   	; 0x1ba6 <xTaskRemoveFromEventList>
     ece:	81 30       	cpi	r24, 0x01	; 1
     ed0:	41 f4       	brne	.+16     	; 0xee2 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
     ed2:	4e de       	rcall	.-868    	; 0xb70 <vPortYield>
     ed4:	06 c0       	rjmp	.+12     	; 0xee2 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     ed6:	ce 01       	movw	r24, r28
     ed8:	08 96       	adiw	r24, 0x08	; 8
     eda:	8b da       	rcall	.-2794   	; 0x3f2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     edc:	ce 01       	movw	r24, r28
     ede:	41 96       	adiw	r24, 0x11	; 17
     ee0:	88 da       	rcall	.-2800   	; 0x3f2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     ee2:	0f 90       	pop	r0
     ee4:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     ee6:	81 e0       	ldi	r24, 0x01	; 1
     ee8:	df 91       	pop	r29
     eea:	cf 91       	pop	r28
     eec:	08 95       	ret

00000eee <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     eee:	0f 93       	push	r16
     ef0:	1f 93       	push	r17
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	18 2f       	mov	r17, r24
     ef8:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
     efa:	88 23       	and	r24, r24
     efc:	d1 f0       	breq	.+52     	; 0xf32 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
     efe:	8f e1       	ldi	r24, 0x1F	; 31
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	41 da       	rcall	.-2942   	; 0x386 <pvPortMalloc>
     f04:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f06:	00 97       	sbiw	r24, 0x00	; 0
     f08:	b1 f0       	breq	.+44     	; 0xf36 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f0a:	10 9f       	mul	r17, r16
     f0c:	c0 01       	movw	r24, r0
     f0e:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
     f10:	01 96       	adiw	r24, 0x01	; 1
     f12:	39 da       	rcall	.-2958   	; 0x386 <pvPortMalloc>
     f14:	99 83       	std	Y+1, r25	; 0x01
     f16:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     f18:	89 2b       	or	r24, r25
     f1a:	31 f0       	breq	.+12     	; 0xf28 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     f1c:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     f1e:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     f20:	61 e0       	ldi	r22, 0x01	; 1
     f22:	ce 01       	movw	r24, r28
     f24:	ab df       	rcall	.-170    	; 0xe7c <xQueueGenericReset>
     f26:	07 c0       	rjmp	.+14     	; 0xf36 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     f28:	ce 01       	movw	r24, r28
     f2a:	62 da       	rcall	.-2876   	; 0x3f0 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
     f2c:	c0 e0       	ldi	r28, 0x00	; 0
     f2e:	d0 e0       	ldi	r29, 0x00	; 0
     f30:	02 c0       	rjmp	.+4      	; 0xf36 <xQueueGenericCreate+0x48>
     f32:	c0 e0       	ldi	r28, 0x00	; 0
     f34:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     f36:	ce 01       	movw	r24, r28
     f38:	df 91       	pop	r29
     f3a:	cf 91       	pop	r28
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	08 95       	ret

00000f42 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     f42:	9f 92       	push	r9
     f44:	af 92       	push	r10
     f46:	bf 92       	push	r11
     f48:	cf 92       	push	r12
     f4a:	df 92       	push	r13
     f4c:	ef 92       	push	r14
     f4e:	ff 92       	push	r15
     f50:	0f 93       	push	r16
     f52:	1f 93       	push	r17
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	00 d0       	rcall	.+0      	; 0xf5a <xQueueGenericSend+0x18>
     f5a:	1f 92       	push	r1
     f5c:	1f 92       	push	r1
     f5e:	cd b7       	in	r28, 0x3d	; 61
     f60:	de b7       	in	r29, 0x3e	; 62
     f62:	8c 01       	movw	r16, r24
     f64:	6b 01       	movw	r12, r22
     f66:	5d 83       	std	Y+5, r21	; 0x05
     f68:	4c 83       	std	Y+4, r20	; 0x04
     f6a:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     f6c:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     f6e:	99 24       	eor	r9, r9
     f70:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     f72:	7c 01       	movw	r14, r24
     f74:	88 e0       	ldi	r24, 0x08	; 8
     f76:	e8 0e       	add	r14, r24
     f78:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     f7a:	0f b6       	in	r0, 0x3f	; 63
     f7c:	f8 94       	cli
     f7e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f80:	f8 01       	movw	r30, r16
     f82:	92 8d       	ldd	r25, Z+26	; 0x1a
     f84:	83 8d       	ldd	r24, Z+27	; 0x1b
     f86:	98 17       	cp	r25, r24
     f88:	18 f0       	brcs	.+6      	; 0xf90 <xQueueGenericSend+0x4e>
     f8a:	f2 e0       	ldi	r31, 0x02	; 2
     f8c:	af 12       	cpse	r10, r31
     f8e:	15 c0       	rjmp	.+42     	; 0xfba <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f90:	4a 2d       	mov	r20, r10
     f92:	b6 01       	movw	r22, r12
     f94:	c8 01       	movw	r24, r16
     f96:	b0 de       	rcall	.-672    	; 0xcf8 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f98:	f8 01       	movw	r30, r16
     f9a:	91 89       	ldd	r25, Z+17	; 0x11
     f9c:	99 23       	and	r25, r25
     f9e:	39 f0       	breq	.+14     	; 0xfae <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     fa0:	c8 01       	movw	r24, r16
     fa2:	41 96       	adiw	r24, 0x11	; 17
     fa4:	00 d6       	rcall	.+3072   	; 0x1ba6 <xTaskRemoveFromEventList>
     fa6:	81 30       	cpi	r24, 0x01	; 1
     fa8:	21 f4       	brne	.+8      	; 0xfb2 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     faa:	e2 dd       	rcall	.-1084   	; 0xb70 <vPortYield>
     fac:	02 c0       	rjmp	.+4      	; 0xfb2 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     fae:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     fb0:	df dd       	rcall	.-1090   	; 0xb70 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     fb2:	0f 90       	pop	r0
     fb4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     fb6:	81 e0       	ldi	r24, 0x01	; 1
     fb8:	46 c0       	rjmp	.+140    	; 0x1046 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     fba:	ec 81       	ldd	r30, Y+4	; 0x04
     fbc:	fd 81       	ldd	r31, Y+5	; 0x05
     fbe:	ef 2b       	or	r30, r31
     fc0:	21 f4       	brne	.+8      	; 0xfca <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     fc2:	0f 90       	pop	r0
     fc4:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     fc6:	80 e0       	ldi	r24, 0x00	; 0
     fc8:	3e c0       	rjmp	.+124    	; 0x1046 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
     fca:	b1 10       	cpse	r11, r1
     fcc:	04 c0       	rjmp	.+8      	; 0xfd6 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     fce:	ce 01       	movw	r24, r28
     fd0:	01 96       	adiw	r24, 0x01	; 1
     fd2:	31 d6       	rcall	.+3170   	; 0x1c36 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     fd4:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     fd6:	0f 90       	pop	r0
     fd8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     fda:	76 d3       	rcall	.+1772   	; 0x16c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     fdc:	0f b6       	in	r0, 0x3f	; 63
     fde:	f8 94       	cli
     fe0:	0f 92       	push	r0
     fe2:	f8 01       	movw	r30, r16
     fe4:	85 8d       	ldd	r24, Z+29	; 0x1d
     fe6:	8f 3f       	cpi	r24, 0xFF	; 255
     fe8:	09 f4       	brne	.+2      	; 0xfec <xQueueGenericSend+0xaa>
     fea:	15 8e       	std	Z+29, r1	; 0x1d
     fec:	f8 01       	movw	r30, r16
     fee:	86 8d       	ldd	r24, Z+30	; 0x1e
     ff0:	8f 3f       	cpi	r24, 0xFF	; 255
     ff2:	09 f4       	brne	.+2      	; 0xff6 <xQueueGenericSend+0xb4>
     ff4:	16 8e       	std	Z+30, r1	; 0x1e
     ff6:	0f 90       	pop	r0
     ff8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ffa:	be 01       	movw	r22, r28
     ffc:	6c 5f       	subi	r22, 0xFC	; 252
     ffe:	7f 4f       	sbci	r23, 0xFF	; 255
    1000:	ce 01       	movw	r24, r28
    1002:	01 96       	adiw	r24, 0x01	; 1
    1004:	23 d6       	rcall	.+3142   	; 0x1c4c <xTaskCheckForTimeOut>
    1006:	81 11       	cpse	r24, r1
    1008:	1a c0       	rjmp	.+52     	; 0x103e <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    100a:	0f b6       	in	r0, 0x3f	; 63
    100c:	f8 94       	cli
    100e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1010:	f8 01       	movw	r30, r16
    1012:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1014:	0f 90       	pop	r0
    1016:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1018:	f8 01       	movw	r30, r16
    101a:	83 8d       	ldd	r24, Z+27	; 0x1b
    101c:	98 13       	cpse	r25, r24
    101e:	0b c0       	rjmp	.+22     	; 0x1036 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1020:	6c 81       	ldd	r22, Y+4	; 0x04
    1022:	7d 81       	ldd	r23, Y+5	; 0x05
    1024:	c7 01       	movw	r24, r14
    1026:	94 d5       	rcall	.+2856   	; 0x1b50 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1028:	c8 01       	movw	r24, r16
    102a:	e2 de       	rcall	.-572    	; 0xdf0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    102c:	11 d4       	rcall	.+2082   	; 0x1850 <xTaskResumeAll>
    102e:	81 11       	cpse	r24, r1
    1030:	a4 cf       	rjmp	.-184    	; 0xf7a <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1032:	9e dd       	rcall	.-1220   	; 0xb70 <vPortYield>
    1034:	a2 cf       	rjmp	.-188    	; 0xf7a <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1036:	c8 01       	movw	r24, r16
    1038:	db de       	rcall	.-586    	; 0xdf0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    103a:	0a d4       	rcall	.+2068   	; 0x1850 <xTaskResumeAll>
    103c:	9e cf       	rjmp	.-196    	; 0xf7a <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    103e:	c8 01       	movw	r24, r16
    1040:	d7 de       	rcall	.-594    	; 0xdf0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1042:	06 d4       	rcall	.+2060   	; 0x1850 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1044:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	0f 90       	pop	r0
    104c:	0f 90       	pop	r0
    104e:	0f 90       	pop	r0
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	1f 91       	pop	r17
    1056:	0f 91       	pop	r16
    1058:	ff 90       	pop	r15
    105a:	ef 90       	pop	r14
    105c:	df 90       	pop	r13
    105e:	cf 90       	pop	r12
    1060:	bf 90       	pop	r11
    1062:	af 90       	pop	r10
    1064:	9f 90       	pop	r9
    1066:	08 95       	ret

00001068 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1068:	cf 93       	push	r28
    106a:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    106c:	8f e1       	ldi	r24, 0x1F	; 31
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	8a d9       	rcall	.-3308   	; 0x386 <pvPortMalloc>
    1072:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1074:	00 97       	sbiw	r24, 0x00	; 0
    1076:	e1 f0       	breq	.+56     	; 0x10b0 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1078:	1b 82       	std	Y+3, r1	; 0x03
    107a:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    107c:	19 82       	std	Y+1, r1	; 0x01
    107e:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1080:	1d 82       	std	Y+5, r1	; 0x05
    1082:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1084:	1f 82       	std	Y+7, r1	; 0x07
    1086:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1088:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    108e:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1090:	8f ef       	ldi	r24, 0xFF	; 255
    1092:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1094:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1096:	ce 01       	movw	r24, r28
    1098:	08 96       	adiw	r24, 0x08	; 8
    109a:	ab d9       	rcall	.-3242   	; 0x3f2 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    109c:	ce 01       	movw	r24, r28
    109e:	41 96       	adiw	r24, 0x11	; 17
    10a0:	a8 d9       	rcall	.-3248   	; 0x3f2 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    10a2:	20 e0       	ldi	r18, 0x00	; 0
    10a4:	40 e0       	ldi	r20, 0x00	; 0
    10a6:	50 e0       	ldi	r21, 0x00	; 0
    10a8:	60 e0       	ldi	r22, 0x00	; 0
    10aa:	70 e0       	ldi	r23, 0x00	; 0
    10ac:	ce 01       	movw	r24, r28
    10ae:	49 df       	rcall	.-366    	; 0xf42 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    10b0:	ce 01       	movw	r24, r28
    10b2:	df 91       	pop	r29
    10b4:	cf 91       	pop	r28
    10b6:	08 95       	ret

000010b8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    10b8:	0f 93       	push	r16
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	ec 01       	movw	r28, r24
    10c2:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    10c4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    10c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    10c8:	98 17       	cp	r25, r24
    10ca:	10 f0       	brcs	.+4      	; 0x10d0 <xQueueGenericSendFromISR+0x18>
    10cc:	22 30       	cpi	r18, 0x02	; 2
    10ce:	11 f5       	brne	.+68     	; 0x1114 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    10d0:	42 2f       	mov	r20, r18
    10d2:	ce 01       	movw	r24, r28
    10d4:	11 de       	rcall	.-990    	; 0xcf8 <prvCopyDataToQueue>
    10d6:	88 23       	and	r24, r24
    10d8:	31 f0       	breq	.+12     	; 0x10e6 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    10da:	01 15       	cp	r16, r1
    10dc:	11 05       	cpc	r17, r1
    10de:	19 f0       	breq	.+6      	; 0x10e6 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    10e0:	81 e0       	ldi	r24, 0x01	; 1
    10e2:	f8 01       	movw	r30, r16
    10e4:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    10e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10e8:	8f 3f       	cpi	r24, 0xFF	; 255
    10ea:	79 f4       	brne	.+30     	; 0x110a <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10ec:	89 89       	ldd	r24, Y+17	; 0x11
    10ee:	88 23       	and	r24, r24
    10f0:	99 f0       	breq	.+38     	; 0x1118 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10f2:	ce 01       	movw	r24, r28
    10f4:	41 96       	adiw	r24, 0x11	; 17
    10f6:	57 d5       	rcall	.+2734   	; 0x1ba6 <xTaskRemoveFromEventList>
    10f8:	88 23       	and	r24, r24
    10fa:	81 f0       	breq	.+32     	; 0x111c <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    10fc:	01 15       	cp	r16, r1
    10fe:	11 05       	cpc	r17, r1
    1100:	79 f0       	breq	.+30     	; 0x1120 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	f8 01       	movw	r30, r16
    1106:	80 83       	st	Z, r24
    1108:	0c c0       	rjmp	.+24     	; 0x1122 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    110a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    110c:	8f 5f       	subi	r24, 0xFF	; 255
    110e:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1110:	81 e0       	ldi	r24, 0x01	; 1
    1112:	07 c0       	rjmp	.+14     	; 0x1122 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1114:	80 e0       	ldi	r24, 0x00	; 0
    1116:	05 c0       	rjmp	.+10     	; 0x1122 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	03 c0       	rjmp	.+6      	; 0x1122 <xQueueGenericSendFromISR+0x6a>
    111c:	81 e0       	ldi	r24, 0x01	; 1
    111e:	01 c0       	rjmp	.+2      	; 0x1122 <xQueueGenericSendFromISR+0x6a>
    1120:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1122:	df 91       	pop	r29
    1124:	cf 91       	pop	r28
    1126:	1f 91       	pop	r17
    1128:	0f 91       	pop	r16
    112a:	08 95       	ret

0000112c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    112c:	9f 92       	push	r9
    112e:	af 92       	push	r10
    1130:	bf 92       	push	r11
    1132:	cf 92       	push	r12
    1134:	df 92       	push	r13
    1136:	ef 92       	push	r14
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	00 d0       	rcall	.+0      	; 0x1144 <xQueueGenericReceive+0x18>
    1144:	1f 92       	push	r1
    1146:	1f 92       	push	r1
    1148:	cd b7       	in	r28, 0x3d	; 61
    114a:	de b7       	in	r29, 0x3e	; 62
    114c:	8c 01       	movw	r16, r24
    114e:	6b 01       	movw	r12, r22
    1150:	5d 83       	std	Y+5, r21	; 0x05
    1152:	4c 83       	std	Y+4, r20	; 0x04
    1154:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1156:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1158:	99 24       	eor	r9, r9
    115a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    115c:	7c 01       	movw	r14, r24
    115e:	81 e1       	ldi	r24, 0x11	; 17
    1160:	e8 0e       	add	r14, r24
    1162:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    116a:	f8 01       	movw	r30, r16
    116c:	82 8d       	ldd	r24, Z+26	; 0x1a
    116e:	88 23       	and	r24, r24
    1170:	69 f1       	breq	.+90     	; 0x11cc <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1172:	e6 80       	ldd	r14, Z+6	; 0x06
    1174:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1176:	b6 01       	movw	r22, r12
    1178:	c8 01       	movw	r24, r16
    117a:	20 de       	rcall	.-960    	; 0xdbc <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    117c:	b1 10       	cpse	r11, r1
    117e:	17 c0       	rjmp	.+46     	; 0x11ae <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1180:	f8 01       	movw	r30, r16
    1182:	82 8d       	ldd	r24, Z+26	; 0x1a
    1184:	81 50       	subi	r24, 0x01	; 1
    1186:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1188:	80 81       	ld	r24, Z
    118a:	91 81       	ldd	r25, Z+1	; 0x01
    118c:	89 2b       	or	r24, r25
    118e:	21 f4       	brne	.+8      	; 0x1198 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1190:	36 d6       	rcall	.+3180   	; 0x1dfe <pvTaskIncrementMutexHeldCount>
    1192:	f8 01       	movw	r30, r16
    1194:	93 83       	std	Z+3, r25	; 0x03
    1196:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1198:	f8 01       	movw	r30, r16
    119a:	80 85       	ldd	r24, Z+8	; 0x08
    119c:	88 23       	and	r24, r24
    119e:	91 f0       	breq	.+36     	; 0x11c4 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    11a0:	c8 01       	movw	r24, r16
    11a2:	08 96       	adiw	r24, 0x08	; 8
    11a4:	00 d5       	rcall	.+2560   	; 0x1ba6 <xTaskRemoveFromEventList>
    11a6:	81 30       	cpi	r24, 0x01	; 1
    11a8:	69 f4       	brne	.+26     	; 0x11c4 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    11aa:	e2 dc       	rcall	.-1596   	; 0xb70 <vPortYield>
    11ac:	0b c0       	rjmp	.+22     	; 0x11c4 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    11ae:	f8 01       	movw	r30, r16
    11b0:	f7 82       	std	Z+7, r15	; 0x07
    11b2:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11b4:	81 89       	ldd	r24, Z+17	; 0x11
    11b6:	88 23       	and	r24, r24
    11b8:	29 f0       	breq	.+10     	; 0x11c4 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    11ba:	c8 01       	movw	r24, r16
    11bc:	41 96       	adiw	r24, 0x11	; 17
    11be:	f3 d4       	rcall	.+2534   	; 0x1ba6 <xTaskRemoveFromEventList>
    11c0:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    11c2:	d6 dc       	rcall	.-1620   	; 0xb70 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    11c4:	0f 90       	pop	r0
    11c6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	52 c0       	rjmp	.+164    	; 0x1270 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    11cc:	4c 81       	ldd	r20, Y+4	; 0x04
    11ce:	5d 81       	ldd	r21, Y+5	; 0x05
    11d0:	45 2b       	or	r20, r21
    11d2:	21 f4       	brne	.+8      	; 0x11dc <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11d4:	0f 90       	pop	r0
    11d6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	4a c0       	rjmp	.+148    	; 0x1270 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    11dc:	a1 10       	cpse	r10, r1
    11de:	04 c0       	rjmp	.+8      	; 0x11e8 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11e0:	ce 01       	movw	r24, r28
    11e2:	01 96       	adiw	r24, 0x01	; 1
    11e4:	28 d5       	rcall	.+2640   	; 0x1c36 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11e6:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11e8:	0f 90       	pop	r0
    11ea:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11ec:	6d d2       	rcall	.+1242   	; 0x16c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	f8 94       	cli
    11f2:	0f 92       	push	r0
    11f4:	f8 01       	movw	r30, r16
    11f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    11f8:	8f 3f       	cpi	r24, 0xFF	; 255
    11fa:	09 f4       	brne	.+2      	; 0x11fe <xQueueGenericReceive+0xd2>
    11fc:	15 8e       	std	Z+29, r1	; 0x1d
    11fe:	f8 01       	movw	r30, r16
    1200:	86 8d       	ldd	r24, Z+30	; 0x1e
    1202:	8f 3f       	cpi	r24, 0xFF	; 255
    1204:	09 f4       	brne	.+2      	; 0x1208 <xQueueGenericReceive+0xdc>
    1206:	16 8e       	std	Z+30, r1	; 0x1e
    1208:	0f 90       	pop	r0
    120a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    120c:	be 01       	movw	r22, r28
    120e:	6c 5f       	subi	r22, 0xFC	; 252
    1210:	7f 4f       	sbci	r23, 0xFF	; 255
    1212:	ce 01       	movw	r24, r28
    1214:	01 96       	adiw	r24, 0x01	; 1
    1216:	1a d5       	rcall	.+2612   	; 0x1c4c <xTaskCheckForTimeOut>
    1218:	81 11       	cpse	r24, r1
    121a:	26 c0       	rjmp	.+76     	; 0x1268 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	f8 94       	cli
    1220:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1222:	f8 01       	movw	r30, r16
    1224:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1226:	0f 90       	pop	r0
    1228:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    122a:	81 11       	cpse	r24, r1
    122c:	19 c0       	rjmp	.+50     	; 0x1260 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    122e:	f8 01       	movw	r30, r16
    1230:	80 81       	ld	r24, Z
    1232:	91 81       	ldd	r25, Z+1	; 0x01
    1234:	89 2b       	or	r24, r25
    1236:	49 f4       	brne	.+18     	; 0x124a <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    123e:	f8 01       	movw	r30, r16
    1240:	82 81       	ldd	r24, Z+2	; 0x02
    1242:	93 81       	ldd	r25, Z+3	; 0x03
    1244:	3f d5       	rcall	.+2686   	; 0x1cc4 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1246:	0f 90       	pop	r0
    1248:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    124a:	6c 81       	ldd	r22, Y+4	; 0x04
    124c:	7d 81       	ldd	r23, Y+5	; 0x05
    124e:	c7 01       	movw	r24, r14
    1250:	7f d4       	rcall	.+2302   	; 0x1b50 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1252:	c8 01       	movw	r24, r16
    1254:	cd dd       	rcall	.-1126   	; 0xdf0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1256:	fc d2       	rcall	.+1528   	; 0x1850 <xTaskResumeAll>
    1258:	81 11       	cpse	r24, r1
    125a:	84 cf       	rjmp	.-248    	; 0x1164 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    125c:	89 dc       	rcall	.-1774   	; 0xb70 <vPortYield>
    125e:	82 cf       	rjmp	.-252    	; 0x1164 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1260:	c8 01       	movw	r24, r16
    1262:	c6 dd       	rcall	.-1140   	; 0xdf0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1264:	f5 d2       	rcall	.+1514   	; 0x1850 <xTaskResumeAll>
    1266:	7e cf       	rjmp	.-260    	; 0x1164 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1268:	c8 01       	movw	r24, r16
    126a:	c2 dd       	rcall	.-1148   	; 0xdf0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    126c:	f1 d2       	rcall	.+1506   	; 0x1850 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    126e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	0f 90       	pop	r0
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	1f 91       	pop	r17
    1280:	0f 91       	pop	r16
    1282:	ff 90       	pop	r15
    1284:	ef 90       	pop	r14
    1286:	df 90       	pop	r13
    1288:	cf 90       	pop	r12
    128a:	bf 90       	pop	r11
    128c:	af 90       	pop	r10
    128e:	9f 90       	pop	r9
    1290:	08 95       	ret

00001292 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1292:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1294:	71 83       	std	Z+1, r23	; 0x01
    1296:	60 83       	st	Z, r22
	ring->rSize = size;
    1298:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    129a:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    129c:	13 82       	std	Z+3, r1	; 0x03
    129e:	08 95       	ret

000012a0 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    12a0:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    12a2:	94 81       	ldd	r25, Z+4	; 0x04
    12a4:	a0 81       	ld	r26, Z
    12a6:	b1 81       	ldd	r27, Z+1	; 0x01
    12a8:	a9 0f       	add	r26, r25
    12aa:	b1 1d       	adc	r27, r1
    12ac:	8c 91       	ld	r24, X
            ring->rIndex ++;
    12ae:	9f 5f       	subi	r25, 0xFF	; 255
    12b0:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    12b2:	22 81       	ldd	r18, Z+2	; 0x02
    12b4:	92 17       	cp	r25, r18
    12b6:	10 f0       	brcs	.+4      	; 0x12bc <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    12b8:	92 1b       	sub	r25, r18
    12ba:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    12bc:	93 81       	ldd	r25, Z+3	; 0x03
    12be:	91 50       	subi	r25, 0x01	; 1
    12c0:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    12c2:	08 95       	ret

000012c4 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    12c4:	fc 01       	movw	r30, r24
    12c6:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    12c8:	83 81       	ldd	r24, Z+3	; 0x03
    12ca:	22 81       	ldd	r18, Z+2	; 0x02
    12cc:	82 17       	cp	r24, r18
    12ce:	78 f4       	brcc	.+30     	; 0x12ee <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    12d0:	34 81       	ldd	r19, Z+4	; 0x04
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	83 0f       	add	r24, r19
    12d6:	91 1d       	adc	r25, r1
    12d8:	62 2f       	mov	r22, r18
    12da:	70 e0       	ldi	r23, 0x00	; 0
    12dc:	a2 d5       	rcall	.+2884   	; 0x1e22 <__divmodhi4>
    12de:	a0 81       	ld	r26, Z
    12e0:	b1 81       	ldd	r27, Z+1	; 0x01
    12e2:	a8 0f       	add	r26, r24
    12e4:	b9 1f       	adc	r27, r25
    12e6:	4c 93       	st	X, r20
            ring->rLength++;
    12e8:	83 81       	ldd	r24, Z+3	; 0x03
    12ea:	8f 5f       	subi	r24, 0xFF	; 255
    12ec:	83 83       	std	Z+3, r24	; 0x03
    12ee:	08 95       	ret

000012f0 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    12f0:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	22 81       	ldd	r18, Z+2	; 0x02
    12f6:	93 81       	ldd	r25, Z+3	; 0x03
    12f8:	29 13       	cpse	r18, r25
    12fa:	80 e0       	ldi	r24, 0x00	; 0
}
    12fc:	08 95       	ret

000012fe <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    12fe:	21 e0       	ldi	r18, 0x01	; 1
    1300:	fc 01       	movw	r30, r24
    1302:	83 81       	ldd	r24, Z+3	; 0x03
    1304:	81 11       	cpse	r24, r1
    1306:	01 c0       	rjmp	.+2      	; 0x130a <ringBufferNotEmpty+0xc>
    1308:	20 e0       	ldi	r18, 0x00	; 0
}
    130a:	82 2f       	mov	r24, r18
    130c:	08 95       	ret

0000130e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    130e:	e0 91 94 08 	lds	r30, 0x0894
    1312:	f0 91 95 08 	lds	r31, 0x0895
    1316:	80 81       	ld	r24, Z
    1318:	81 11       	cpse	r24, r1
    131a:	07 c0       	rjmp	.+14     	; 0x132a <prvResetNextTaskUnblockTime+0x1c>
    131c:	8f ef       	ldi	r24, 0xFF	; 255
    131e:	9f ef       	ldi	r25, 0xFF	; 255
    1320:	90 93 02 02 	sts	0x0202, r25
    1324:	80 93 01 02 	sts	0x0201, r24
    1328:	08 95       	ret
    132a:	e0 91 94 08 	lds	r30, 0x0894
    132e:	f0 91 95 08 	lds	r31, 0x0895
    1332:	05 80       	ldd	r0, Z+5	; 0x05
    1334:	f6 81       	ldd	r31, Z+6	; 0x06
    1336:	e0 2d       	mov	r30, r0
    1338:	06 80       	ldd	r0, Z+6	; 0x06
    133a:	f7 81       	ldd	r31, Z+7	; 0x07
    133c:	e0 2d       	mov	r30, r0
    133e:	82 81       	ldd	r24, Z+2	; 0x02
    1340:	93 81       	ldd	r25, Z+3	; 0x03
    1342:	90 93 02 02 	sts	0x0202, r25
    1346:	80 93 01 02 	sts	0x0201, r24
    134a:	08 95       	ret

0000134c <prvAddCurrentTaskToDelayedList>:
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	ec 01       	movw	r28, r24
    1352:	e0 91 d5 08 	lds	r30, 0x08D5
    1356:	f0 91 d6 08 	lds	r31, 0x08D6
    135a:	93 83       	std	Z+3, r25	; 0x03
    135c:	82 83       	std	Z+2, r24	; 0x02
    135e:	80 91 73 08 	lds	r24, 0x0873
    1362:	90 91 74 08 	lds	r25, 0x0874
    1366:	c8 17       	cp	r28, r24
    1368:	d9 07       	cpc	r29, r25
    136a:	60 f4       	brcc	.+24     	; 0x1384 <prvAddCurrentTaskToDelayedList+0x38>
    136c:	60 91 d5 08 	lds	r22, 0x08D5
    1370:	70 91 d6 08 	lds	r23, 0x08D6
    1374:	80 91 92 08 	lds	r24, 0x0892
    1378:	90 91 93 08 	lds	r25, 0x0893
    137c:	6e 5f       	subi	r22, 0xFE	; 254
    137e:	7f 4f       	sbci	r23, 0xFF	; 255
    1380:	6b d8       	rcall	.-3882   	; 0x458 <vListInsert>
    1382:	16 c0       	rjmp	.+44     	; 0x13b0 <prvAddCurrentTaskToDelayedList+0x64>
    1384:	60 91 d5 08 	lds	r22, 0x08D5
    1388:	70 91 d6 08 	lds	r23, 0x08D6
    138c:	80 91 94 08 	lds	r24, 0x0894
    1390:	90 91 95 08 	lds	r25, 0x0895
    1394:	6e 5f       	subi	r22, 0xFE	; 254
    1396:	7f 4f       	sbci	r23, 0xFF	; 255
    1398:	5f d8       	rcall	.-3906   	; 0x458 <vListInsert>
    139a:	80 91 01 02 	lds	r24, 0x0201
    139e:	90 91 02 02 	lds	r25, 0x0202
    13a2:	c8 17       	cp	r28, r24
    13a4:	d9 07       	cpc	r29, r25
    13a6:	20 f4       	brcc	.+8      	; 0x13b0 <prvAddCurrentTaskToDelayedList+0x64>
    13a8:	d0 93 02 02 	sts	0x0202, r29
    13ac:	c0 93 01 02 	sts	0x0201, r28
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	08 95       	ret

000013b6 <xTaskGenericCreate>:
    13b6:	4f 92       	push	r4
    13b8:	5f 92       	push	r5
    13ba:	6f 92       	push	r6
    13bc:	7f 92       	push	r7
    13be:	8f 92       	push	r8
    13c0:	9f 92       	push	r9
    13c2:	af 92       	push	r10
    13c4:	bf 92       	push	r11
    13c6:	cf 92       	push	r12
    13c8:	df 92       	push	r13
    13ca:	ef 92       	push	r14
    13cc:	ff 92       	push	r15
    13ce:	0f 93       	push	r16
    13d0:	1f 93       	push	r17
    13d2:	cf 93       	push	r28
    13d4:	df 93       	push	r29
    13d6:	4c 01       	movw	r8, r24
    13d8:	5b 01       	movw	r10, r22
    13da:	2a 01       	movw	r4, r20
    13dc:	39 01       	movw	r6, r18
    13de:	83 e2       	ldi	r24, 0x23	; 35
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	0e 94 c3 01 	call	0x386	; 0x386 <pvPortMalloc>
    13e6:	ec 01       	movw	r28, r24
    13e8:	00 97       	sbiw	r24, 0x00	; 0
    13ea:	09 f4       	brne	.+2      	; 0x13ee <xTaskGenericCreate+0x38>
    13ec:	e7 c0       	rjmp	.+462    	; 0x15bc <xTaskGenericCreate+0x206>
    13ee:	c1 14       	cp	r12, r1
    13f0:	d1 04       	cpc	r13, r1
    13f2:	09 f0       	breq	.+2      	; 0x13f6 <xTaskGenericCreate+0x40>
    13f4:	cc c0       	rjmp	.+408    	; 0x158e <xTaskGenericCreate+0x1d8>
    13f6:	c2 01       	movw	r24, r4
    13f8:	0e 94 c3 01 	call	0x386	; 0x386 <pvPortMalloc>
    13fc:	98 8f       	std	Y+24, r25	; 0x18
    13fe:	8f 8b       	std	Y+23, r24	; 0x17
    1400:	89 2b       	or	r24, r25
    1402:	09 f0       	breq	.+2      	; 0x1406 <xTaskGenericCreate+0x50>
    1404:	c6 c0       	rjmp	.+396    	; 0x1592 <xTaskGenericCreate+0x1dc>
    1406:	ce 01       	movw	r24, r28
    1408:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    140c:	d7 c0       	rjmp	.+430    	; 0x15bc <xTaskGenericCreate+0x206>
    140e:	cf 01       	movw	r24, r30
    1410:	31 91       	ld	r19, Z+
    1412:	da 01       	movw	r26, r20
    1414:	3d 93       	st	X+, r19
    1416:	ad 01       	movw	r20, r26
    1418:	dc 01       	movw	r26, r24
    141a:	8c 91       	ld	r24, X
    141c:	88 23       	and	r24, r24
    141e:	11 f0       	breq	.+4      	; 0x1424 <xTaskGenericCreate+0x6e>
    1420:	21 50       	subi	r18, 0x01	; 1
    1422:	a9 f7       	brne	.-22     	; 0x140e <xTaskGenericCreate+0x58>
    1424:	18 a2       	std	Y+32, r1	; 0x20
    1426:	10 2f       	mov	r17, r16
    1428:	05 30       	cpi	r16, 0x05	; 5
    142a:	08 f0       	brcs	.+2      	; 0x142e <xTaskGenericCreate+0x78>
    142c:	14 e0       	ldi	r17, 0x04	; 4
    142e:	1e 8b       	std	Y+22, r17	; 0x16
    1430:	19 a3       	std	Y+33, r17	; 0x21
    1432:	1a a2       	std	Y+34, r1	; 0x22
    1434:	5e 01       	movw	r10, r28
    1436:	b2 e0       	ldi	r27, 0x02	; 2
    1438:	ab 0e       	add	r10, r27
    143a:	b1 1c       	adc	r11, r1
    143c:	c5 01       	movw	r24, r10
    143e:	0e 94 07 02 	call	0x40e	; 0x40e <vListInitialiseItem>
    1442:	ce 01       	movw	r24, r28
    1444:	0c 96       	adiw	r24, 0x0c	; 12
    1446:	0e 94 07 02 	call	0x40e	; 0x40e <vListInitialiseItem>
    144a:	d9 87       	std	Y+9, r29	; 0x09
    144c:	c8 87       	std	Y+8, r28	; 0x08
    144e:	85 e0       	ldi	r24, 0x05	; 5
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	81 1b       	sub	r24, r17
    1454:	91 09       	sbc	r25, r1
    1456:	9d 87       	std	Y+13, r25	; 0x0d
    1458:	8c 87       	std	Y+12, r24	; 0x0c
    145a:	db 8b       	std	Y+19, r29	; 0x13
    145c:	ca 8b       	std	Y+18, r28	; 0x12
    145e:	a3 01       	movw	r20, r6
    1460:	b4 01       	movw	r22, r8
    1462:	c6 01       	movw	r24, r12
    1464:	d6 da       	rcall	.-2644   	; 0xa12 <pxPortInitialiseStack>
    1466:	99 83       	std	Y+1, r25	; 0x01
    1468:	88 83       	st	Y, r24
    146a:	e1 14       	cp	r14, r1
    146c:	f1 04       	cpc	r15, r1
    146e:	19 f0       	breq	.+6      	; 0x1476 <xTaskGenericCreate+0xc0>
    1470:	f7 01       	movw	r30, r14
    1472:	d1 83       	std	Z+1, r29	; 0x01
    1474:	c0 83       	st	Z, r28
    1476:	0f b6       	in	r0, 0x3f	; 63
    1478:	f8 94       	cli
    147a:	0f 92       	push	r0
    147c:	80 91 75 08 	lds	r24, 0x0875
    1480:	8f 5f       	subi	r24, 0xFF	; 255
    1482:	80 93 75 08 	sts	0x0875, r24
    1486:	80 91 d5 08 	lds	r24, 0x08D5
    148a:	90 91 d6 08 	lds	r25, 0x08D6
    148e:	89 2b       	or	r24, r25
    1490:	09 f0       	breq	.+2      	; 0x1494 <xTaskGenericCreate+0xde>
    1492:	3f c0       	rjmp	.+126    	; 0x1512 <xTaskGenericCreate+0x15c>
    1494:	d0 93 d6 08 	sts	0x08D6, r29
    1498:	c0 93 d5 08 	sts	0x08D5, r28
    149c:	80 91 75 08 	lds	r24, 0x0875
    14a0:	81 30       	cpi	r24, 0x01	; 1
    14a2:	09 f0       	breq	.+2      	; 0x14a6 <xTaskGenericCreate+0xf0>
    14a4:	45 c0       	rjmp	.+138    	; 0x1530 <xTaskGenericCreate+0x17a>
    14a6:	0f 2e       	mov	r0, r31
    14a8:	f8 ea       	ldi	r31, 0xA8	; 168
    14aa:	ef 2e       	mov	r14, r31
    14ac:	f8 e0       	ldi	r31, 0x08	; 8
    14ae:	ff 2e       	mov	r15, r31
    14b0:	f0 2d       	mov	r31, r0
    14b2:	0f 2e       	mov	r0, r31
    14b4:	f5 ed       	ldi	r31, 0xD5	; 213
    14b6:	cf 2e       	mov	r12, r31
    14b8:	f8 e0       	ldi	r31, 0x08	; 8
    14ba:	df 2e       	mov	r13, r31
    14bc:	f0 2d       	mov	r31, r0
    14be:	c7 01       	movw	r24, r14
    14c0:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14c4:	f9 e0       	ldi	r31, 0x09	; 9
    14c6:	ef 0e       	add	r14, r31
    14c8:	f1 1c       	adc	r15, r1
    14ca:	ec 14       	cp	r14, r12
    14cc:	fd 04       	cpc	r15, r13
    14ce:	b9 f7       	brne	.-18     	; 0x14be <xTaskGenericCreate+0x108>
    14d0:	8f e9       	ldi	r24, 0x9F	; 159
    14d2:	98 e0       	ldi	r25, 0x08	; 8
    14d4:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14d8:	86 e9       	ldi	r24, 0x96	; 150
    14da:	98 e0       	ldi	r25, 0x08	; 8
    14dc:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14e0:	89 e8       	ldi	r24, 0x89	; 137
    14e2:	98 e0       	ldi	r25, 0x08	; 8
    14e4:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14e8:	80 e8       	ldi	r24, 0x80	; 128
    14ea:	98 e0       	ldi	r25, 0x08	; 8
    14ec:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14f0:	86 e7       	ldi	r24, 0x76	; 118
    14f2:	98 e0       	ldi	r25, 0x08	; 8
    14f4:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    14f8:	8f e9       	ldi	r24, 0x9F	; 159
    14fa:	98 e0       	ldi	r25, 0x08	; 8
    14fc:	90 93 95 08 	sts	0x0895, r25
    1500:	80 93 94 08 	sts	0x0894, r24
    1504:	86 e9       	ldi	r24, 0x96	; 150
    1506:	98 e0       	ldi	r25, 0x08	; 8
    1508:	90 93 93 08 	sts	0x0893, r25
    150c:	80 93 92 08 	sts	0x0892, r24
    1510:	0f c0       	rjmp	.+30     	; 0x1530 <xTaskGenericCreate+0x17a>
    1512:	80 91 71 08 	lds	r24, 0x0871
    1516:	81 11       	cpse	r24, r1
    1518:	0b c0       	rjmp	.+22     	; 0x1530 <xTaskGenericCreate+0x17a>
    151a:	e0 91 d5 08 	lds	r30, 0x08D5
    151e:	f0 91 d6 08 	lds	r31, 0x08D6
    1522:	86 89       	ldd	r24, Z+22	; 0x16
    1524:	08 17       	cp	r16, r24
    1526:	20 f0       	brcs	.+8      	; 0x1530 <xTaskGenericCreate+0x17a>
    1528:	d0 93 d6 08 	sts	0x08D6, r29
    152c:	c0 93 d5 08 	sts	0x08D5, r28
    1530:	80 91 6d 08 	lds	r24, 0x086D
    1534:	8f 5f       	subi	r24, 0xFF	; 255
    1536:	80 93 6d 08 	sts	0x086D, r24
    153a:	8e 89       	ldd	r24, Y+22	; 0x16
    153c:	90 91 72 08 	lds	r25, 0x0872
    1540:	98 17       	cp	r25, r24
    1542:	10 f4       	brcc	.+4      	; 0x1548 <xTaskGenericCreate+0x192>
    1544:	80 93 72 08 	sts	0x0872, r24
    1548:	90 e0       	ldi	r25, 0x00	; 0
    154a:	9c 01       	movw	r18, r24
    154c:	22 0f       	add	r18, r18
    154e:	33 1f       	adc	r19, r19
    1550:	22 0f       	add	r18, r18
    1552:	33 1f       	adc	r19, r19
    1554:	22 0f       	add	r18, r18
    1556:	33 1f       	adc	r19, r19
    1558:	82 0f       	add	r24, r18
    155a:	93 1f       	adc	r25, r19
    155c:	b5 01       	movw	r22, r10
    155e:	88 55       	subi	r24, 0x58	; 88
    1560:	97 4f       	sbci	r25, 0xF7	; 247
    1562:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1566:	0f 90       	pop	r0
    1568:	0f be       	out	0x3f, r0	; 63
    156a:	80 91 71 08 	lds	r24, 0x0871
    156e:	88 23       	and	r24, r24
    1570:	51 f0       	breq	.+20     	; 0x1586 <xTaskGenericCreate+0x1d0>
    1572:	e0 91 d5 08 	lds	r30, 0x08D5
    1576:	f0 91 d6 08 	lds	r31, 0x08D6
    157a:	86 89       	ldd	r24, Z+22	; 0x16
    157c:	80 17       	cp	r24, r16
    157e:	28 f4       	brcc	.+10     	; 0x158a <xTaskGenericCreate+0x1d4>
    1580:	f7 da       	rcall	.-2578   	; 0xb70 <vPortYield>
    1582:	81 e0       	ldi	r24, 0x01	; 1
    1584:	1c c0       	rjmp	.+56     	; 0x15be <xTaskGenericCreate+0x208>
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	1a c0       	rjmp	.+52     	; 0x15be <xTaskGenericCreate+0x208>
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	18 c0       	rjmp	.+48     	; 0x15be <xTaskGenericCreate+0x208>
    158e:	d8 8e       	std	Y+24, r13	; 0x18
    1590:	cf 8a       	std	Y+23, r12	; 0x17
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	48 1a       	sub	r4, r24
    1596:	51 08       	sbc	r5, r1
    1598:	cf 88       	ldd	r12, Y+23	; 0x17
    159a:	d8 8c       	ldd	r13, Y+24	; 0x18
    159c:	c4 0c       	add	r12, r4
    159e:	d5 1c       	adc	r13, r5
    15a0:	d5 01       	movw	r26, r10
    15a2:	8c 91       	ld	r24, X
    15a4:	89 8f       	std	Y+25, r24	; 0x19
    15a6:	8c 91       	ld	r24, X
    15a8:	88 23       	and	r24, r24
    15aa:	09 f4       	brne	.+2      	; 0x15ae <xTaskGenericCreate+0x1f8>
    15ac:	3b cf       	rjmp	.-394    	; 0x1424 <xTaskGenericCreate+0x6e>
    15ae:	ae 01       	movw	r20, r28
    15b0:	46 5e       	subi	r20, 0xE6	; 230
    15b2:	5f 4f       	sbci	r21, 0xFF	; 255
    15b4:	f5 01       	movw	r30, r10
    15b6:	31 96       	adiw	r30, 0x01	; 1
    15b8:	27 e0       	ldi	r18, 0x07	; 7
    15ba:	29 cf       	rjmp	.-430    	; 0x140e <xTaskGenericCreate+0x58>
    15bc:	8f ef       	ldi	r24, 0xFF	; 255
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	1f 91       	pop	r17
    15c4:	0f 91       	pop	r16
    15c6:	ff 90       	pop	r15
    15c8:	ef 90       	pop	r14
    15ca:	df 90       	pop	r13
    15cc:	cf 90       	pop	r12
    15ce:	bf 90       	pop	r11
    15d0:	af 90       	pop	r10
    15d2:	9f 90       	pop	r9
    15d4:	8f 90       	pop	r8
    15d6:	7f 90       	pop	r7
    15d8:	6f 90       	pop	r6
    15da:	5f 90       	pop	r5
    15dc:	4f 90       	pop	r4
    15de:	08 95       	ret

000015e0 <vTaskResume>:
    15e0:	0f 93       	push	r16
    15e2:	1f 93       	push	r17
    15e4:	cf 93       	push	r28
    15e6:	df 93       	push	r29
    15e8:	ec 01       	movw	r28, r24
    15ea:	00 97       	sbiw	r24, 0x00	; 0
    15ec:	09 f4       	brne	.+2      	; 0x15f0 <vTaskResume+0x10>
    15ee:	3e c0       	rjmp	.+124    	; 0x166c <vTaskResume+0x8c>
    15f0:	80 91 d5 08 	lds	r24, 0x08D5
    15f4:	90 91 d6 08 	lds	r25, 0x08D6
    15f8:	c8 17       	cp	r28, r24
    15fa:	d9 07       	cpc	r29, r25
    15fc:	b9 f1       	breq	.+110    	; 0x166c <vTaskResume+0x8c>
    15fe:	0f b6       	in	r0, 0x3f	; 63
    1600:	f8 94       	cli
    1602:	0f 92       	push	r0
    1604:	8a 85       	ldd	r24, Y+10	; 0x0a
    1606:	9b 85       	ldd	r25, Y+11	; 0x0b
    1608:	86 57       	subi	r24, 0x76	; 118
    160a:	98 40       	sbci	r25, 0x08	; 8
    160c:	69 f5       	brne	.+90     	; 0x1668 <vTaskResume+0x88>
    160e:	8c 89       	ldd	r24, Y+20	; 0x14
    1610:	9d 89       	ldd	r25, Y+21	; 0x15
    1612:	28 e0       	ldi	r18, 0x08	; 8
    1614:	89 38       	cpi	r24, 0x89	; 137
    1616:	92 07       	cpc	r25, r18
    1618:	39 f1       	breq	.+78     	; 0x1668 <vTaskResume+0x88>
    161a:	89 2b       	or	r24, r25
    161c:	29 f5       	brne	.+74     	; 0x1668 <vTaskResume+0x88>
    161e:	8e 01       	movw	r16, r28
    1620:	0e 5f       	subi	r16, 0xFE	; 254
    1622:	1f 4f       	sbci	r17, 0xFF	; 255
    1624:	c8 01       	movw	r24, r16
    1626:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    162a:	8e 89       	ldd	r24, Y+22	; 0x16
    162c:	90 91 72 08 	lds	r25, 0x0872
    1630:	98 17       	cp	r25, r24
    1632:	10 f4       	brcc	.+4      	; 0x1638 <vTaskResume+0x58>
    1634:	80 93 72 08 	sts	0x0872, r24
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	9c 01       	movw	r18, r24
    163c:	22 0f       	add	r18, r18
    163e:	33 1f       	adc	r19, r19
    1640:	22 0f       	add	r18, r18
    1642:	33 1f       	adc	r19, r19
    1644:	22 0f       	add	r18, r18
    1646:	33 1f       	adc	r19, r19
    1648:	82 0f       	add	r24, r18
    164a:	93 1f       	adc	r25, r19
    164c:	b8 01       	movw	r22, r16
    164e:	88 55       	subi	r24, 0x58	; 88
    1650:	97 4f       	sbci	r25, 0xF7	; 247
    1652:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1656:	e0 91 d5 08 	lds	r30, 0x08D5
    165a:	f0 91 d6 08 	lds	r31, 0x08D6
    165e:	9e 89       	ldd	r25, Y+22	; 0x16
    1660:	86 89       	ldd	r24, Z+22	; 0x16
    1662:	98 17       	cp	r25, r24
    1664:	08 f0       	brcs	.+2      	; 0x1668 <vTaskResume+0x88>
    1666:	84 da       	rcall	.-2808   	; 0xb70 <vPortYield>
    1668:	0f 90       	pop	r0
    166a:	0f be       	out	0x3f, r0	; 63
    166c:	df 91       	pop	r29
    166e:	cf 91       	pop	r28
    1670:	1f 91       	pop	r17
    1672:	0f 91       	pop	r16
    1674:	08 95       	ret

00001676 <vTaskStartScheduler>:
    1676:	af 92       	push	r10
    1678:	bf 92       	push	r11
    167a:	cf 92       	push	r12
    167c:	df 92       	push	r13
    167e:	ef 92       	push	r14
    1680:	ff 92       	push	r15
    1682:	0f 93       	push	r16
    1684:	a1 2c       	mov	r10, r1
    1686:	b1 2c       	mov	r11, r1
    1688:	c1 2c       	mov	r12, r1
    168a:	d1 2c       	mov	r13, r1
    168c:	e1 2c       	mov	r14, r1
    168e:	f1 2c       	mov	r15, r1
    1690:	00 e0       	ldi	r16, 0x00	; 0
    1692:	20 e0       	ldi	r18, 0x00	; 0
    1694:	30 e0       	ldi	r19, 0x00	; 0
    1696:	45 e5       	ldi	r20, 0x55	; 85
    1698:	50 e0       	ldi	r21, 0x00	; 0
    169a:	66 e8       	ldi	r22, 0x86	; 134
    169c:	72 e0       	ldi	r23, 0x02	; 2
    169e:	85 ec       	ldi	r24, 0xC5	; 197
    16a0:	9c e0       	ldi	r25, 0x0C	; 12
    16a2:	89 de       	rcall	.-750    	; 0x13b6 <xTaskGenericCreate>
    16a4:	81 30       	cpi	r24, 0x01	; 1
    16a6:	41 f4       	brne	.+16     	; 0x16b8 <vTaskStartScheduler+0x42>
    16a8:	f8 94       	cli
    16aa:	80 93 71 08 	sts	0x0871, r24
    16ae:	10 92 74 08 	sts	0x0874, r1
    16b2:	10 92 73 08 	sts	0x0873, r1
    16b6:	1f da       	rcall	.-3010   	; 0xaf6 <xPortStartScheduler>
    16b8:	0f 91       	pop	r16
    16ba:	ff 90       	pop	r15
    16bc:	ef 90       	pop	r14
    16be:	df 90       	pop	r13
    16c0:	cf 90       	pop	r12
    16c2:	bf 90       	pop	r11
    16c4:	af 90       	pop	r10
    16c6:	08 95       	ret

000016c8 <vTaskSuspendAll>:
    16c8:	80 91 6c 08 	lds	r24, 0x086C
    16cc:	8f 5f       	subi	r24, 0xFF	; 255
    16ce:	80 93 6c 08 	sts	0x086C, r24
    16d2:	08 95       	ret

000016d4 <xTaskIncrementTick>:
    16d4:	cf 92       	push	r12
    16d6:	df 92       	push	r13
    16d8:	ef 92       	push	r14
    16da:	ff 92       	push	r15
    16dc:	0f 93       	push	r16
    16de:	1f 93       	push	r17
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	80 91 6c 08 	lds	r24, 0x086C
    16e8:	81 11       	cpse	r24, r1
    16ea:	99 c0       	rjmp	.+306    	; 0x181e <xTaskIncrementTick+0x14a>
    16ec:	80 91 73 08 	lds	r24, 0x0873
    16f0:	90 91 74 08 	lds	r25, 0x0874
    16f4:	01 96       	adiw	r24, 0x01	; 1
    16f6:	90 93 74 08 	sts	0x0874, r25
    16fa:	80 93 73 08 	sts	0x0873, r24
    16fe:	e0 90 73 08 	lds	r14, 0x0873
    1702:	f0 90 74 08 	lds	r15, 0x0874
    1706:	e1 14       	cp	r14, r1
    1708:	f1 04       	cpc	r15, r1
    170a:	b1 f4       	brne	.+44     	; 0x1738 <xTaskIncrementTick+0x64>
    170c:	80 91 94 08 	lds	r24, 0x0894
    1710:	90 91 95 08 	lds	r25, 0x0895
    1714:	20 91 92 08 	lds	r18, 0x0892
    1718:	30 91 93 08 	lds	r19, 0x0893
    171c:	30 93 95 08 	sts	0x0895, r19
    1720:	20 93 94 08 	sts	0x0894, r18
    1724:	90 93 93 08 	sts	0x0893, r25
    1728:	80 93 92 08 	sts	0x0892, r24
    172c:	80 91 6e 08 	lds	r24, 0x086E
    1730:	8f 5f       	subi	r24, 0xFF	; 255
    1732:	80 93 6e 08 	sts	0x086E, r24
    1736:	eb dd       	rcall	.-1066   	; 0x130e <prvResetNextTaskUnblockTime>
    1738:	80 91 01 02 	lds	r24, 0x0201
    173c:	90 91 02 02 	lds	r25, 0x0202
    1740:	e8 16       	cp	r14, r24
    1742:	f9 06       	cpc	r15, r25
    1744:	08 f4       	brcc	.+2      	; 0x1748 <xTaskIncrementTick+0x74>
    1746:	54 c0       	rjmp	.+168    	; 0x17f0 <xTaskIncrementTick+0x11c>
    1748:	d1 2c       	mov	r13, r1
    174a:	cc 24       	eor	r12, r12
    174c:	c3 94       	inc	r12
    174e:	01 c0       	rjmp	.+2      	; 0x1752 <xTaskIncrementTick+0x7e>
    1750:	dc 2c       	mov	r13, r12
    1752:	e0 91 94 08 	lds	r30, 0x0894
    1756:	f0 91 95 08 	lds	r31, 0x0895
    175a:	80 81       	ld	r24, Z
    175c:	81 11       	cpse	r24, r1
    175e:	07 c0       	rjmp	.+14     	; 0x176e <xTaskIncrementTick+0x9a>
    1760:	8f ef       	ldi	r24, 0xFF	; 255
    1762:	9f ef       	ldi	r25, 0xFF	; 255
    1764:	90 93 02 02 	sts	0x0202, r25
    1768:	80 93 01 02 	sts	0x0201, r24
    176c:	42 c0       	rjmp	.+132    	; 0x17f2 <xTaskIncrementTick+0x11e>
    176e:	e0 91 94 08 	lds	r30, 0x0894
    1772:	f0 91 95 08 	lds	r31, 0x0895
    1776:	05 80       	ldd	r0, Z+5	; 0x05
    1778:	f6 81       	ldd	r31, Z+6	; 0x06
    177a:	e0 2d       	mov	r30, r0
    177c:	c6 81       	ldd	r28, Z+6	; 0x06
    177e:	d7 81       	ldd	r29, Z+7	; 0x07
    1780:	2a 81       	ldd	r18, Y+2	; 0x02
    1782:	3b 81       	ldd	r19, Y+3	; 0x03
    1784:	e2 16       	cp	r14, r18
    1786:	f3 06       	cpc	r15, r19
    1788:	28 f4       	brcc	.+10     	; 0x1794 <xTaskIncrementTick+0xc0>
    178a:	30 93 02 02 	sts	0x0202, r19
    178e:	20 93 01 02 	sts	0x0201, r18
    1792:	2f c0       	rjmp	.+94     	; 0x17f2 <xTaskIncrementTick+0x11e>
    1794:	8e 01       	movw	r16, r28
    1796:	0e 5f       	subi	r16, 0xFE	; 254
    1798:	1f 4f       	sbci	r17, 0xFF	; 255
    179a:	c8 01       	movw	r24, r16
    179c:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    17a0:	8c 89       	ldd	r24, Y+20	; 0x14
    17a2:	9d 89       	ldd	r25, Y+21	; 0x15
    17a4:	89 2b       	or	r24, r25
    17a6:	21 f0       	breq	.+8      	; 0x17b0 <xTaskIncrementTick+0xdc>
    17a8:	ce 01       	movw	r24, r28
    17aa:	0c 96       	adiw	r24, 0x0c	; 12
    17ac:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    17b0:	2e 89       	ldd	r18, Y+22	; 0x16
    17b2:	80 91 72 08 	lds	r24, 0x0872
    17b6:	82 17       	cp	r24, r18
    17b8:	10 f4       	brcc	.+4      	; 0x17be <xTaskIncrementTick+0xea>
    17ba:	20 93 72 08 	sts	0x0872, r18
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	c9 01       	movw	r24, r18
    17c2:	88 0f       	add	r24, r24
    17c4:	99 1f       	adc	r25, r25
    17c6:	88 0f       	add	r24, r24
    17c8:	99 1f       	adc	r25, r25
    17ca:	88 0f       	add	r24, r24
    17cc:	99 1f       	adc	r25, r25
    17ce:	82 0f       	add	r24, r18
    17d0:	93 1f       	adc	r25, r19
    17d2:	b8 01       	movw	r22, r16
    17d4:	88 55       	subi	r24, 0x58	; 88
    17d6:	97 4f       	sbci	r25, 0xF7	; 247
    17d8:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    17dc:	e0 91 d5 08 	lds	r30, 0x08D5
    17e0:	f0 91 d6 08 	lds	r31, 0x08D6
    17e4:	9e 89       	ldd	r25, Y+22	; 0x16
    17e6:	86 89       	ldd	r24, Z+22	; 0x16
    17e8:	98 17       	cp	r25, r24
    17ea:	08 f0       	brcs	.+2      	; 0x17ee <xTaskIncrementTick+0x11a>
    17ec:	b1 cf       	rjmp	.-158    	; 0x1750 <xTaskIncrementTick+0x7c>
    17ee:	b1 cf       	rjmp	.-158    	; 0x1752 <xTaskIncrementTick+0x7e>
    17f0:	d1 2c       	mov	r13, r1
    17f2:	e0 91 d5 08 	lds	r30, 0x08D5
    17f6:	f0 91 d6 08 	lds	r31, 0x08D6
    17fa:	86 89       	ldd	r24, Z+22	; 0x16
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	fc 01       	movw	r30, r24
    1800:	ee 0f       	add	r30, r30
    1802:	ff 1f       	adc	r31, r31
    1804:	ee 0f       	add	r30, r30
    1806:	ff 1f       	adc	r31, r31
    1808:	ee 0f       	add	r30, r30
    180a:	ff 1f       	adc	r31, r31
    180c:	8e 0f       	add	r24, r30
    180e:	9f 1f       	adc	r25, r31
    1810:	fc 01       	movw	r30, r24
    1812:	e8 55       	subi	r30, 0x58	; 88
    1814:	f7 4f       	sbci	r31, 0xF7	; 247
    1816:	80 81       	ld	r24, Z
    1818:	82 30       	cpi	r24, 0x02	; 2
    181a:	40 f4       	brcc	.+16     	; 0x182c <xTaskIncrementTick+0x158>
    181c:	09 c0       	rjmp	.+18     	; 0x1830 <xTaskIncrementTick+0x15c>
    181e:	80 91 70 08 	lds	r24, 0x0870
    1822:	8f 5f       	subi	r24, 0xFF	; 255
    1824:	80 93 70 08 	sts	0x0870, r24
    1828:	d1 2c       	mov	r13, r1
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <xTaskIncrementTick+0x15c>
    182c:	dd 24       	eor	r13, r13
    182e:	d3 94       	inc	r13
    1830:	80 91 6f 08 	lds	r24, 0x086F
    1834:	88 23       	and	r24, r24
    1836:	11 f0       	breq	.+4      	; 0x183c <xTaskIncrementTick+0x168>
    1838:	dd 24       	eor	r13, r13
    183a:	d3 94       	inc	r13
    183c:	8d 2d       	mov	r24, r13
    183e:	df 91       	pop	r29
    1840:	cf 91       	pop	r28
    1842:	1f 91       	pop	r17
    1844:	0f 91       	pop	r16
    1846:	ff 90       	pop	r15
    1848:	ef 90       	pop	r14
    184a:	df 90       	pop	r13
    184c:	cf 90       	pop	r12
    184e:	08 95       	ret

00001850 <xTaskResumeAll>:
    1850:	df 92       	push	r13
    1852:	ef 92       	push	r14
    1854:	ff 92       	push	r15
    1856:	0f 93       	push	r16
    1858:	1f 93       	push	r17
    185a:	cf 93       	push	r28
    185c:	df 93       	push	r29
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	0f 92       	push	r0
    1864:	80 91 6c 08 	lds	r24, 0x086C
    1868:	81 50       	subi	r24, 0x01	; 1
    186a:	80 93 6c 08 	sts	0x086C, r24
    186e:	80 91 6c 08 	lds	r24, 0x086C
    1872:	81 11       	cpse	r24, r1
    1874:	5f c0       	rjmp	.+190    	; 0x1934 <xTaskResumeAll+0xe4>
    1876:	80 91 75 08 	lds	r24, 0x0875
    187a:	88 23       	and	r24, r24
    187c:	09 f4       	brne	.+2      	; 0x1880 <xTaskResumeAll+0x30>
    187e:	5c c0       	rjmp	.+184    	; 0x1938 <xTaskResumeAll+0xe8>
    1880:	0f 2e       	mov	r0, r31
    1882:	f9 e8       	ldi	r31, 0x89	; 137
    1884:	ef 2e       	mov	r14, r31
    1886:	f8 e0       	ldi	r31, 0x08	; 8
    1888:	ff 2e       	mov	r15, r31
    188a:	f0 2d       	mov	r31, r0
    188c:	dd 24       	eor	r13, r13
    188e:	d3 94       	inc	r13
    1890:	30 c0       	rjmp	.+96     	; 0x18f2 <xTaskResumeAll+0xa2>
    1892:	e0 91 8e 08 	lds	r30, 0x088E
    1896:	f0 91 8f 08 	lds	r31, 0x088F
    189a:	c6 81       	ldd	r28, Z+6	; 0x06
    189c:	d7 81       	ldd	r29, Z+7	; 0x07
    189e:	ce 01       	movw	r24, r28
    18a0:	0c 96       	adiw	r24, 0x0c	; 12
    18a2:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    18a6:	8e 01       	movw	r16, r28
    18a8:	0e 5f       	subi	r16, 0xFE	; 254
    18aa:	1f 4f       	sbci	r17, 0xFF	; 255
    18ac:	c8 01       	movw	r24, r16
    18ae:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    18b2:	8e 89       	ldd	r24, Y+22	; 0x16
    18b4:	90 91 72 08 	lds	r25, 0x0872
    18b8:	98 17       	cp	r25, r24
    18ba:	10 f4       	brcc	.+4      	; 0x18c0 <xTaskResumeAll+0x70>
    18bc:	80 93 72 08 	sts	0x0872, r24
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	9c 01       	movw	r18, r24
    18c4:	22 0f       	add	r18, r18
    18c6:	33 1f       	adc	r19, r19
    18c8:	22 0f       	add	r18, r18
    18ca:	33 1f       	adc	r19, r19
    18cc:	22 0f       	add	r18, r18
    18ce:	33 1f       	adc	r19, r19
    18d0:	82 0f       	add	r24, r18
    18d2:	93 1f       	adc	r25, r19
    18d4:	b8 01       	movw	r22, r16
    18d6:	88 55       	subi	r24, 0x58	; 88
    18d8:	97 4f       	sbci	r25, 0xF7	; 247
    18da:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    18de:	e0 91 d5 08 	lds	r30, 0x08D5
    18e2:	f0 91 d6 08 	lds	r31, 0x08D6
    18e6:	9e 89       	ldd	r25, Y+22	; 0x16
    18e8:	86 89       	ldd	r24, Z+22	; 0x16
    18ea:	98 17       	cp	r25, r24
    18ec:	10 f0       	brcs	.+4      	; 0x18f2 <xTaskResumeAll+0xa2>
    18ee:	d0 92 6f 08 	sts	0x086F, r13
    18f2:	f7 01       	movw	r30, r14
    18f4:	80 81       	ld	r24, Z
    18f6:	81 11       	cpse	r24, r1
    18f8:	cc cf       	rjmp	.-104    	; 0x1892 <xTaskResumeAll+0x42>
    18fa:	80 91 70 08 	lds	r24, 0x0870
    18fe:	88 23       	and	r24, r24
    1900:	91 f0       	breq	.+36     	; 0x1926 <xTaskResumeAll+0xd6>
    1902:	80 91 70 08 	lds	r24, 0x0870
    1906:	88 23       	and	r24, r24
    1908:	71 f0       	breq	.+28     	; 0x1926 <xTaskResumeAll+0xd6>
    190a:	c1 e0       	ldi	r28, 0x01	; 1
    190c:	e3 de       	rcall	.-570    	; 0x16d4 <xTaskIncrementTick>
    190e:	81 11       	cpse	r24, r1
    1910:	c0 93 6f 08 	sts	0x086F, r28
    1914:	80 91 70 08 	lds	r24, 0x0870
    1918:	81 50       	subi	r24, 0x01	; 1
    191a:	80 93 70 08 	sts	0x0870, r24
    191e:	80 91 70 08 	lds	r24, 0x0870
    1922:	81 11       	cpse	r24, r1
    1924:	f3 cf       	rjmp	.-26     	; 0x190c <xTaskResumeAll+0xbc>
    1926:	80 91 6f 08 	lds	r24, 0x086F
    192a:	81 30       	cpi	r24, 0x01	; 1
    192c:	39 f4       	brne	.+14     	; 0x193c <xTaskResumeAll+0xec>
    192e:	20 d9       	rcall	.-3520   	; 0xb70 <vPortYield>
    1930:	81 e0       	ldi	r24, 0x01	; 1
    1932:	05 c0       	rjmp	.+10     	; 0x193e <xTaskResumeAll+0xee>
    1934:	80 e0       	ldi	r24, 0x00	; 0
    1936:	03 c0       	rjmp	.+6      	; 0x193e <xTaskResumeAll+0xee>
    1938:	80 e0       	ldi	r24, 0x00	; 0
    193a:	01 c0       	rjmp	.+2      	; 0x193e <xTaskResumeAll+0xee>
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	08 95       	ret

00001952 <vTaskDelay>:
    1952:	cf 93       	push	r28
    1954:	df 93       	push	r29
    1956:	ec 01       	movw	r28, r24
    1958:	00 97       	sbiw	r24, 0x00	; 0
    195a:	99 f0       	breq	.+38     	; 0x1982 <vTaskDelay+0x30>
    195c:	b5 de       	rcall	.-662    	; 0x16c8 <vTaskSuspendAll>
    195e:	80 91 73 08 	lds	r24, 0x0873
    1962:	90 91 74 08 	lds	r25, 0x0874
    1966:	c8 0f       	add	r28, r24
    1968:	d9 1f       	adc	r29, r25
    196a:	80 91 d5 08 	lds	r24, 0x08D5
    196e:	90 91 d6 08 	lds	r25, 0x08D6
    1972:	02 96       	adiw	r24, 0x02	; 2
    1974:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1978:	ce 01       	movw	r24, r28
    197a:	e8 dc       	rcall	.-1584   	; 0x134c <prvAddCurrentTaskToDelayedList>
    197c:	69 df       	rcall	.-302    	; 0x1850 <xTaskResumeAll>
    197e:	81 11       	cpse	r24, r1
    1980:	01 c0       	rjmp	.+2      	; 0x1984 <vTaskDelay+0x32>
    1982:	f6 d8       	rcall	.-3604   	; 0xb70 <vPortYield>
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	08 95       	ret

0000198a <prvIdleTask>:
    198a:	0f 2e       	mov	r0, r31
    198c:	f8 ea       	ldi	r31, 0xA8	; 168
    198e:	ef 2e       	mov	r14, r31
    1990:	f8 e0       	ldi	r31, 0x08	; 8
    1992:	ff 2e       	mov	r15, r31
    1994:	f0 2d       	mov	r31, r0
    1996:	c0 e8       	ldi	r28, 0x80	; 128
    1998:	d8 e0       	ldi	r29, 0x08	; 8
    199a:	26 c0       	rjmp	.+76     	; 0x19e8 <prvIdleTask+0x5e>
    199c:	95 de       	rcall	.-726    	; 0x16c8 <vTaskSuspendAll>
    199e:	18 81       	ld	r17, Y
    19a0:	57 df       	rcall	.-338    	; 0x1850 <xTaskResumeAll>
    19a2:	11 23       	and	r17, r17
    19a4:	09 f1       	breq	.+66     	; 0x19e8 <prvIdleTask+0x5e>
    19a6:	0f b6       	in	r0, 0x3f	; 63
    19a8:	f8 94       	cli
    19aa:	0f 92       	push	r0
    19ac:	e0 91 85 08 	lds	r30, 0x0885
    19b0:	f0 91 86 08 	lds	r31, 0x0886
    19b4:	06 81       	ldd	r16, Z+6	; 0x06
    19b6:	17 81       	ldd	r17, Z+7	; 0x07
    19b8:	c8 01       	movw	r24, r16
    19ba:	02 96       	adiw	r24, 0x02	; 2
    19bc:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    19c0:	80 91 75 08 	lds	r24, 0x0875
    19c4:	81 50       	subi	r24, 0x01	; 1
    19c6:	80 93 75 08 	sts	0x0875, r24
    19ca:	80 91 7f 08 	lds	r24, 0x087F
    19ce:	81 50       	subi	r24, 0x01	; 1
    19d0:	80 93 7f 08 	sts	0x087F, r24
    19d4:	0f 90       	pop	r0
    19d6:	0f be       	out	0x3f, r0	; 63
    19d8:	f8 01       	movw	r30, r16
    19da:	87 89       	ldd	r24, Z+23	; 0x17
    19dc:	90 8d       	ldd	r25, Z+24	; 0x18
    19de:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    19e2:	c8 01       	movw	r24, r16
    19e4:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    19e8:	80 91 7f 08 	lds	r24, 0x087F
    19ec:	81 11       	cpse	r24, r1
    19ee:	d6 cf       	rjmp	.-84     	; 0x199c <prvIdleTask+0x12>
    19f0:	f7 01       	movw	r30, r14
    19f2:	80 81       	ld	r24, Z
    19f4:	82 30       	cpi	r24, 0x02	; 2
    19f6:	c0 f3       	brcs	.-16     	; 0x19e8 <prvIdleTask+0x5e>
    19f8:	bb d8       	rcall	.-3722   	; 0xb70 <vPortYield>
    19fa:	f6 cf       	rjmp	.-20     	; 0x19e8 <prvIdleTask+0x5e>

000019fc <vTaskSwitchContext>:
    19fc:	80 91 6c 08 	lds	r24, 0x086C
    1a00:	88 23       	and	r24, r24
    1a02:	21 f0       	breq	.+8      	; 0x1a0c <vTaskSwitchContext+0x10>
    1a04:	81 e0       	ldi	r24, 0x01	; 1
    1a06:	80 93 6f 08 	sts	0x086F, r24
    1a0a:	08 95       	ret
    1a0c:	10 92 6f 08 	sts	0x086F, r1
    1a10:	80 91 72 08 	lds	r24, 0x0872
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	fc 01       	movw	r30, r24
    1a18:	ee 0f       	add	r30, r30
    1a1a:	ff 1f       	adc	r31, r31
    1a1c:	ee 0f       	add	r30, r30
    1a1e:	ff 1f       	adc	r31, r31
    1a20:	ee 0f       	add	r30, r30
    1a22:	ff 1f       	adc	r31, r31
    1a24:	8e 0f       	add	r24, r30
    1a26:	9f 1f       	adc	r25, r31
    1a28:	fc 01       	movw	r30, r24
    1a2a:	e8 55       	subi	r30, 0x58	; 88
    1a2c:	f7 4f       	sbci	r31, 0xF7	; 247
    1a2e:	80 81       	ld	r24, Z
    1a30:	81 11       	cpse	r24, r1
    1a32:	17 c0       	rjmp	.+46     	; 0x1a62 <vTaskSwitchContext+0x66>
    1a34:	80 91 72 08 	lds	r24, 0x0872
    1a38:	81 50       	subi	r24, 0x01	; 1
    1a3a:	80 93 72 08 	sts	0x0872, r24
    1a3e:	80 91 72 08 	lds	r24, 0x0872
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	fc 01       	movw	r30, r24
    1a46:	ee 0f       	add	r30, r30
    1a48:	ff 1f       	adc	r31, r31
    1a4a:	ee 0f       	add	r30, r30
    1a4c:	ff 1f       	adc	r31, r31
    1a4e:	ee 0f       	add	r30, r30
    1a50:	ff 1f       	adc	r31, r31
    1a52:	8e 0f       	add	r24, r30
    1a54:	9f 1f       	adc	r25, r31
    1a56:	fc 01       	movw	r30, r24
    1a58:	e8 55       	subi	r30, 0x58	; 88
    1a5a:	f7 4f       	sbci	r31, 0xF7	; 247
    1a5c:	80 81       	ld	r24, Z
    1a5e:	88 23       	and	r24, r24
    1a60:	49 f3       	breq	.-46     	; 0x1a34 <vTaskSwitchContext+0x38>
    1a62:	e0 91 72 08 	lds	r30, 0x0872
    1a66:	f0 e0       	ldi	r31, 0x00	; 0
    1a68:	cf 01       	movw	r24, r30
    1a6a:	88 0f       	add	r24, r24
    1a6c:	99 1f       	adc	r25, r25
    1a6e:	88 0f       	add	r24, r24
    1a70:	99 1f       	adc	r25, r25
    1a72:	88 0f       	add	r24, r24
    1a74:	99 1f       	adc	r25, r25
    1a76:	e8 0f       	add	r30, r24
    1a78:	f9 1f       	adc	r31, r25
    1a7a:	e8 55       	subi	r30, 0x58	; 88
    1a7c:	f7 4f       	sbci	r31, 0xF7	; 247
    1a7e:	a1 81       	ldd	r26, Z+1	; 0x01
    1a80:	b2 81       	ldd	r27, Z+2	; 0x02
    1a82:	12 96       	adiw	r26, 0x02	; 2
    1a84:	0d 90       	ld	r0, X+
    1a86:	bc 91       	ld	r27, X
    1a88:	a0 2d       	mov	r26, r0
    1a8a:	b2 83       	std	Z+2, r27	; 0x02
    1a8c:	a1 83       	std	Z+1, r26	; 0x01
    1a8e:	cf 01       	movw	r24, r30
    1a90:	03 96       	adiw	r24, 0x03	; 3
    1a92:	a8 17       	cp	r26, r24
    1a94:	b9 07       	cpc	r27, r25
    1a96:	31 f4       	brne	.+12     	; 0x1aa4 <vTaskSwitchContext+0xa8>
    1a98:	12 96       	adiw	r26, 0x02	; 2
    1a9a:	8d 91       	ld	r24, X+
    1a9c:	9c 91       	ld	r25, X
    1a9e:	13 97       	sbiw	r26, 0x03	; 3
    1aa0:	92 83       	std	Z+2, r25	; 0x02
    1aa2:	81 83       	std	Z+1, r24	; 0x01
    1aa4:	01 80       	ldd	r0, Z+1	; 0x01
    1aa6:	f2 81       	ldd	r31, Z+2	; 0x02
    1aa8:	e0 2d       	mov	r30, r0
    1aaa:	86 81       	ldd	r24, Z+6	; 0x06
    1aac:	97 81       	ldd	r25, Z+7	; 0x07
    1aae:	90 93 d6 08 	sts	0x08D6, r25
    1ab2:	80 93 d5 08 	sts	0x08D5, r24
    1ab6:	08 95       	ret

00001ab8 <vTaskSuspend>:
    1ab8:	0f 93       	push	r16
    1aba:	1f 93       	push	r17
    1abc:	cf 93       	push	r28
    1abe:	df 93       	push	r29
    1ac0:	ec 01       	movw	r28, r24
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	0f 92       	push	r0
    1ac8:	00 97       	sbiw	r24, 0x00	; 0
    1aca:	21 f4       	brne	.+8      	; 0x1ad4 <vTaskSuspend+0x1c>
    1acc:	c0 91 d5 08 	lds	r28, 0x08D5
    1ad0:	d0 91 d6 08 	lds	r29, 0x08D6
    1ad4:	8e 01       	movw	r16, r28
    1ad6:	0e 5f       	subi	r16, 0xFE	; 254
    1ad8:	1f 4f       	sbci	r17, 0xFF	; 255
    1ada:	c8 01       	movw	r24, r16
    1adc:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1ae0:	8c 89       	ldd	r24, Y+20	; 0x14
    1ae2:	9d 89       	ldd	r25, Y+21	; 0x15
    1ae4:	89 2b       	or	r24, r25
    1ae6:	21 f0       	breq	.+8      	; 0x1af0 <vTaskSuspend+0x38>
    1ae8:	ce 01       	movw	r24, r28
    1aea:	0c 96       	adiw	r24, 0x0c	; 12
    1aec:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1af0:	b8 01       	movw	r22, r16
    1af2:	86 e7       	ldi	r24, 0x76	; 118
    1af4:	98 e0       	ldi	r25, 0x08	; 8
    1af6:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1afa:	0f 90       	pop	r0
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	80 91 d5 08 	lds	r24, 0x08D5
    1b02:	90 91 d6 08 	lds	r25, 0x08D6
    1b06:	c8 17       	cp	r28, r24
    1b08:	d9 07       	cpc	r29, r25
    1b0a:	99 f4       	brne	.+38     	; 0x1b32 <vTaskSuspend+0x7a>
    1b0c:	80 91 71 08 	lds	r24, 0x0871
    1b10:	88 23       	and	r24, r24
    1b12:	11 f0       	breq	.+4      	; 0x1b18 <vTaskSuspend+0x60>
    1b14:	2d d8       	rcall	.-4006   	; 0xb70 <vPortYield>
    1b16:	17 c0       	rjmp	.+46     	; 0x1b46 <vTaskSuspend+0x8e>
    1b18:	80 91 75 08 	lds	r24, 0x0875
    1b1c:	90 91 76 08 	lds	r25, 0x0876
    1b20:	98 13       	cpse	r25, r24
    1b22:	05 c0       	rjmp	.+10     	; 0x1b2e <vTaskSuspend+0x76>
    1b24:	10 92 d6 08 	sts	0x08D6, r1
    1b28:	10 92 d5 08 	sts	0x08D5, r1
    1b2c:	0c c0       	rjmp	.+24     	; 0x1b46 <vTaskSuspend+0x8e>
    1b2e:	66 df       	rcall	.-308    	; 0x19fc <vTaskSwitchContext>
    1b30:	0a c0       	rjmp	.+20     	; 0x1b46 <vTaskSuspend+0x8e>
    1b32:	80 91 71 08 	lds	r24, 0x0871
    1b36:	88 23       	and	r24, r24
    1b38:	31 f0       	breq	.+12     	; 0x1b46 <vTaskSuspend+0x8e>
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
    1b40:	e6 db       	rcall	.-2100   	; 0x130e <prvResetNextTaskUnblockTime>
    1b42:	0f 90       	pop	r0
    1b44:	0f be       	out	0x3f, r0	; 63
    1b46:	df 91       	pop	r29
    1b48:	cf 91       	pop	r28
    1b4a:	1f 91       	pop	r17
    1b4c:	0f 91       	pop	r16
    1b4e:	08 95       	ret

00001b50 <vTaskPlaceOnEventList>:
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	eb 01       	movw	r28, r22
    1b56:	60 91 d5 08 	lds	r22, 0x08D5
    1b5a:	70 91 d6 08 	lds	r23, 0x08D6
    1b5e:	64 5f       	subi	r22, 0xF4	; 244
    1b60:	7f 4f       	sbci	r23, 0xFF	; 255
    1b62:	0e 94 2c 02 	call	0x458	; 0x458 <vListInsert>
    1b66:	80 91 d5 08 	lds	r24, 0x08D5
    1b6a:	90 91 d6 08 	lds	r25, 0x08D6
    1b6e:	02 96       	adiw	r24, 0x02	; 2
    1b70:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1b74:	cf 3f       	cpi	r28, 0xFF	; 255
    1b76:	8f ef       	ldi	r24, 0xFF	; 255
    1b78:	d8 07       	cpc	r29, r24
    1b7a:	59 f4       	brne	.+22     	; 0x1b92 <vTaskPlaceOnEventList+0x42>
    1b7c:	60 91 d5 08 	lds	r22, 0x08D5
    1b80:	70 91 d6 08 	lds	r23, 0x08D6
    1b84:	6e 5f       	subi	r22, 0xFE	; 254
    1b86:	7f 4f       	sbci	r23, 0xFF	; 255
    1b88:	86 e7       	ldi	r24, 0x76	; 118
    1b8a:	98 e0       	ldi	r25, 0x08	; 8
    1b8c:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1b90:	07 c0       	rjmp	.+14     	; 0x1ba0 <vTaskPlaceOnEventList+0x50>
    1b92:	80 91 73 08 	lds	r24, 0x0873
    1b96:	90 91 74 08 	lds	r25, 0x0874
    1b9a:	8c 0f       	add	r24, r28
    1b9c:	9d 1f       	adc	r25, r29
    1b9e:	d6 db       	rcall	.-2132   	; 0x134c <prvAddCurrentTaskToDelayedList>
    1ba0:	df 91       	pop	r29
    1ba2:	cf 91       	pop	r28
    1ba4:	08 95       	ret

00001ba6 <xTaskRemoveFromEventList>:
    1ba6:	0f 93       	push	r16
    1ba8:	1f 93       	push	r17
    1baa:	cf 93       	push	r28
    1bac:	df 93       	push	r29
    1bae:	dc 01       	movw	r26, r24
    1bb0:	15 96       	adiw	r26, 0x05	; 5
    1bb2:	ed 91       	ld	r30, X+
    1bb4:	fc 91       	ld	r31, X
    1bb6:	16 97       	sbiw	r26, 0x06	; 6
    1bb8:	c6 81       	ldd	r28, Z+6	; 0x06
    1bba:	d7 81       	ldd	r29, Z+7	; 0x07
    1bbc:	8e 01       	movw	r16, r28
    1bbe:	04 5f       	subi	r16, 0xF4	; 244
    1bc0:	1f 4f       	sbci	r17, 0xFF	; 255
    1bc2:	c8 01       	movw	r24, r16
    1bc4:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1bc8:	80 91 6c 08 	lds	r24, 0x086C
    1bcc:	81 11       	cpse	r24, r1
    1bce:	1c c0       	rjmp	.+56     	; 0x1c08 <xTaskRemoveFromEventList+0x62>
    1bd0:	0a 50       	subi	r16, 0x0A	; 10
    1bd2:	11 09       	sbc	r17, r1
    1bd4:	c8 01       	movw	r24, r16
    1bd6:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1bda:	8e 89       	ldd	r24, Y+22	; 0x16
    1bdc:	90 91 72 08 	lds	r25, 0x0872
    1be0:	98 17       	cp	r25, r24
    1be2:	10 f4       	brcc	.+4      	; 0x1be8 <xTaskRemoveFromEventList+0x42>
    1be4:	80 93 72 08 	sts	0x0872, r24
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	9c 01       	movw	r18, r24
    1bec:	22 0f       	add	r18, r18
    1bee:	33 1f       	adc	r19, r19
    1bf0:	22 0f       	add	r18, r18
    1bf2:	33 1f       	adc	r19, r19
    1bf4:	22 0f       	add	r18, r18
    1bf6:	33 1f       	adc	r19, r19
    1bf8:	82 0f       	add	r24, r18
    1bfa:	93 1f       	adc	r25, r19
    1bfc:	b8 01       	movw	r22, r16
    1bfe:	88 55       	subi	r24, 0x58	; 88
    1c00:	97 4f       	sbci	r25, 0xF7	; 247
    1c02:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1c06:	05 c0       	rjmp	.+10     	; 0x1c12 <xTaskRemoveFromEventList+0x6c>
    1c08:	b8 01       	movw	r22, r16
    1c0a:	89 e8       	ldi	r24, 0x89	; 137
    1c0c:	98 e0       	ldi	r25, 0x08	; 8
    1c0e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1c12:	e0 91 d5 08 	lds	r30, 0x08D5
    1c16:	f0 91 d6 08 	lds	r31, 0x08D6
    1c1a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c1c:	86 89       	ldd	r24, Z+22	; 0x16
    1c1e:	89 17       	cp	r24, r25
    1c20:	20 f4       	brcc	.+8      	; 0x1c2a <xTaskRemoveFromEventList+0x84>
    1c22:	81 e0       	ldi	r24, 0x01	; 1
    1c24:	80 93 6f 08 	sts	0x086F, r24
    1c28:	01 c0       	rjmp	.+2      	; 0x1c2c <xTaskRemoveFromEventList+0x86>
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
    1c2c:	df 91       	pop	r29
    1c2e:	cf 91       	pop	r28
    1c30:	1f 91       	pop	r17
    1c32:	0f 91       	pop	r16
    1c34:	08 95       	ret

00001c36 <vTaskSetTimeOutState>:
    1c36:	20 91 6e 08 	lds	r18, 0x086E
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	20 83       	st	Z, r18
    1c3e:	20 91 73 08 	lds	r18, 0x0873
    1c42:	30 91 74 08 	lds	r19, 0x0874
    1c46:	32 83       	std	Z+2, r19	; 0x02
    1c48:	21 83       	std	Z+1, r18	; 0x01
    1c4a:	08 95       	ret

00001c4c <xTaskCheckForTimeOut>:
    1c4c:	0f b6       	in	r0, 0x3f	; 63
    1c4e:	f8 94       	cli
    1c50:	0f 92       	push	r0
    1c52:	40 91 73 08 	lds	r20, 0x0873
    1c56:	50 91 74 08 	lds	r21, 0x0874
    1c5a:	db 01       	movw	r26, r22
    1c5c:	2d 91       	ld	r18, X+
    1c5e:	3c 91       	ld	r19, X
    1c60:	2f 3f       	cpi	r18, 0xFF	; 255
    1c62:	bf ef       	ldi	r27, 0xFF	; 255
    1c64:	3b 07       	cpc	r19, r27
    1c66:	11 f1       	breq	.+68     	; 0x1cac <xTaskCheckForTimeOut+0x60>
    1c68:	e0 91 6e 08 	lds	r30, 0x086E
    1c6c:	dc 01       	movw	r26, r24
    1c6e:	fc 91       	ld	r31, X
    1c70:	fe 17       	cp	r31, r30
    1c72:	39 f0       	breq	.+14     	; 0x1c82 <xTaskCheckForTimeOut+0x36>
    1c74:	11 96       	adiw	r26, 0x01	; 1
    1c76:	ed 91       	ld	r30, X+
    1c78:	fc 91       	ld	r31, X
    1c7a:	12 97       	sbiw	r26, 0x02	; 2
    1c7c:	4e 17       	cp	r20, r30
    1c7e:	5f 07       	cpc	r21, r31
    1c80:	b8 f4       	brcc	.+46     	; 0x1cb0 <xTaskCheckForTimeOut+0x64>
    1c82:	dc 01       	movw	r26, r24
    1c84:	11 96       	adiw	r26, 0x01	; 1
    1c86:	ed 91       	ld	r30, X+
    1c88:	fc 91       	ld	r31, X
    1c8a:	12 97       	sbiw	r26, 0x02	; 2
    1c8c:	da 01       	movw	r26, r20
    1c8e:	ae 1b       	sub	r26, r30
    1c90:	bf 0b       	sbc	r27, r31
    1c92:	a2 17       	cp	r26, r18
    1c94:	b3 07       	cpc	r27, r19
    1c96:	70 f4       	brcc	.+28     	; 0x1cb4 <xTaskCheckForTimeOut+0x68>
    1c98:	e4 1b       	sub	r30, r20
    1c9a:	f5 0b       	sbc	r31, r21
    1c9c:	2e 0f       	add	r18, r30
    1c9e:	3f 1f       	adc	r19, r31
    1ca0:	fb 01       	movw	r30, r22
    1ca2:	31 83       	std	Z+1, r19	; 0x01
    1ca4:	20 83       	st	Z, r18
    1ca6:	c7 df       	rcall	.-114    	; 0x1c36 <vTaskSetTimeOutState>
    1ca8:	80 e0       	ldi	r24, 0x00	; 0
    1caa:	05 c0       	rjmp	.+10     	; 0x1cb6 <xTaskCheckForTimeOut+0x6a>
    1cac:	80 e0       	ldi	r24, 0x00	; 0
    1cae:	03 c0       	rjmp	.+6      	; 0x1cb6 <xTaskCheckForTimeOut+0x6a>
    1cb0:	81 e0       	ldi	r24, 0x01	; 1
    1cb2:	01 c0       	rjmp	.+2      	; 0x1cb6 <xTaskCheckForTimeOut+0x6a>
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	0f 90       	pop	r0
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	08 95       	ret

00001cbc <vTaskMissedYield>:
    1cbc:	81 e0       	ldi	r24, 0x01	; 1
    1cbe:	80 93 6f 08 	sts	0x086F, r24
    1cc2:	08 95       	ret

00001cc4 <vTaskPriorityInherit>:
    1cc4:	0f 93       	push	r16
    1cc6:	1f 93       	push	r17
    1cc8:	cf 93       	push	r28
    1cca:	df 93       	push	r29
    1ccc:	ec 01       	movw	r28, r24
    1cce:	00 97       	sbiw	r24, 0x00	; 0
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <vTaskPriorityInherit+0x10>
    1cd2:	51 c0       	rjmp	.+162    	; 0x1d76 <vTaskPriorityInherit+0xb2>
    1cd4:	8e 89       	ldd	r24, Y+22	; 0x16
    1cd6:	e0 91 d5 08 	lds	r30, 0x08D5
    1cda:	f0 91 d6 08 	lds	r31, 0x08D6
    1cde:	96 89       	ldd	r25, Z+22	; 0x16
    1ce0:	89 17       	cp	r24, r25
    1ce2:	08 f0       	brcs	.+2      	; 0x1ce6 <vTaskPriorityInherit+0x22>
    1ce4:	48 c0       	rjmp	.+144    	; 0x1d76 <vTaskPriorityInherit+0xb2>
    1ce6:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ce8:	3d 85       	ldd	r19, Y+13	; 0x0d
    1cea:	33 23       	and	r19, r19
    1cec:	5c f0       	brlt	.+22     	; 0x1d04 <vTaskPriorityInherit+0x40>
    1cee:	e0 91 d5 08 	lds	r30, 0x08D5
    1cf2:	f0 91 d6 08 	lds	r31, 0x08D6
    1cf6:	96 89       	ldd	r25, Z+22	; 0x16
    1cf8:	25 e0       	ldi	r18, 0x05	; 5
    1cfa:	30 e0       	ldi	r19, 0x00	; 0
    1cfc:	29 1b       	sub	r18, r25
    1cfe:	31 09       	sbc	r19, r1
    1d00:	3d 87       	std	Y+13, r19	; 0x0d
    1d02:	2c 87       	std	Y+12, r18	; 0x0c
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	9c 01       	movw	r18, r24
    1d08:	22 0f       	add	r18, r18
    1d0a:	33 1f       	adc	r19, r19
    1d0c:	22 0f       	add	r18, r18
    1d0e:	33 1f       	adc	r19, r19
    1d10:	22 0f       	add	r18, r18
    1d12:	33 1f       	adc	r19, r19
    1d14:	82 0f       	add	r24, r18
    1d16:	93 1f       	adc	r25, r19
    1d18:	88 55       	subi	r24, 0x58	; 88
    1d1a:	97 4f       	sbci	r25, 0xF7	; 247
    1d1c:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d1e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d20:	28 17       	cp	r18, r24
    1d22:	39 07       	cpc	r19, r25
    1d24:	11 f5       	brne	.+68     	; 0x1d6a <vTaskPriorityInherit+0xa6>
    1d26:	8e 01       	movw	r16, r28
    1d28:	0e 5f       	subi	r16, 0xFE	; 254
    1d2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d2c:	c8 01       	movw	r24, r16
    1d2e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1d32:	e0 91 d5 08 	lds	r30, 0x08D5
    1d36:	f0 91 d6 08 	lds	r31, 0x08D6
    1d3a:	86 89       	ldd	r24, Z+22	; 0x16
    1d3c:	8e 8b       	std	Y+22, r24	; 0x16
    1d3e:	90 91 72 08 	lds	r25, 0x0872
    1d42:	98 17       	cp	r25, r24
    1d44:	10 f4       	brcc	.+4      	; 0x1d4a <vTaskPriorityInherit+0x86>
    1d46:	80 93 72 08 	sts	0x0872, r24
    1d4a:	90 e0       	ldi	r25, 0x00	; 0
    1d4c:	9c 01       	movw	r18, r24
    1d4e:	22 0f       	add	r18, r18
    1d50:	33 1f       	adc	r19, r19
    1d52:	22 0f       	add	r18, r18
    1d54:	33 1f       	adc	r19, r19
    1d56:	22 0f       	add	r18, r18
    1d58:	33 1f       	adc	r19, r19
    1d5a:	82 0f       	add	r24, r18
    1d5c:	93 1f       	adc	r25, r19
    1d5e:	b8 01       	movw	r22, r16
    1d60:	88 55       	subi	r24, 0x58	; 88
    1d62:	97 4f       	sbci	r25, 0xF7	; 247
    1d64:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1d68:	06 c0       	rjmp	.+12     	; 0x1d76 <vTaskPriorityInherit+0xb2>
    1d6a:	e0 91 d5 08 	lds	r30, 0x08D5
    1d6e:	f0 91 d6 08 	lds	r31, 0x08D6
    1d72:	86 89       	ldd	r24, Z+22	; 0x16
    1d74:	8e 8b       	std	Y+22, r24	; 0x16
    1d76:	df 91       	pop	r29
    1d78:	cf 91       	pop	r28
    1d7a:	1f 91       	pop	r17
    1d7c:	0f 91       	pop	r16
    1d7e:	08 95       	ret

00001d80 <xTaskPriorityDisinherit>:
    1d80:	0f 93       	push	r16
    1d82:	1f 93       	push	r17
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	ec 01       	movw	r28, r24
    1d8a:	00 97       	sbiw	r24, 0x00	; 0
    1d8c:	71 f1       	breq	.+92     	; 0x1dea <xTaskPriorityDisinherit+0x6a>
    1d8e:	8a a1       	ldd	r24, Y+34	; 0x22
    1d90:	81 50       	subi	r24, 0x01	; 1
    1d92:	8a a3       	std	Y+34, r24	; 0x22
    1d94:	2e 89       	ldd	r18, Y+22	; 0x16
    1d96:	99 a1       	ldd	r25, Y+33	; 0x21
    1d98:	29 17       	cp	r18, r25
    1d9a:	49 f1       	breq	.+82     	; 0x1dee <xTaskPriorityDisinherit+0x6e>
    1d9c:	81 11       	cpse	r24, r1
    1d9e:	29 c0       	rjmp	.+82     	; 0x1df2 <xTaskPriorityDisinherit+0x72>
    1da0:	8e 01       	movw	r16, r28
    1da2:	0e 5f       	subi	r16, 0xFE	; 254
    1da4:	1f 4f       	sbci	r17, 0xFF	; 255
    1da6:	c8 01       	movw	r24, r16
    1da8:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1dac:	89 a1       	ldd	r24, Y+33	; 0x21
    1dae:	8e 8b       	std	Y+22, r24	; 0x16
    1db0:	25 e0       	ldi	r18, 0x05	; 5
    1db2:	30 e0       	ldi	r19, 0x00	; 0
    1db4:	28 1b       	sub	r18, r24
    1db6:	31 09       	sbc	r19, r1
    1db8:	3d 87       	std	Y+13, r19	; 0x0d
    1dba:	2c 87       	std	Y+12, r18	; 0x0c
    1dbc:	90 91 72 08 	lds	r25, 0x0872
    1dc0:	98 17       	cp	r25, r24
    1dc2:	10 f4       	brcc	.+4      	; 0x1dc8 <xTaskPriorityDisinherit+0x48>
    1dc4:	80 93 72 08 	sts	0x0872, r24
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	9c 01       	movw	r18, r24
    1dcc:	22 0f       	add	r18, r18
    1dce:	33 1f       	adc	r19, r19
    1dd0:	22 0f       	add	r18, r18
    1dd2:	33 1f       	adc	r19, r19
    1dd4:	22 0f       	add	r18, r18
    1dd6:	33 1f       	adc	r19, r19
    1dd8:	82 0f       	add	r24, r18
    1dda:	93 1f       	adc	r25, r19
    1ddc:	b8 01       	movw	r22, r16
    1dde:	88 55       	subi	r24, 0x58	; 88
    1de0:	97 4f       	sbci	r25, 0xF7	; 247
    1de2:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1de6:	81 e0       	ldi	r24, 0x01	; 1
    1de8:	05 c0       	rjmp	.+10     	; 0x1df4 <xTaskPriorityDisinherit+0x74>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	03 c0       	rjmp	.+6      	; 0x1df4 <xTaskPriorityDisinherit+0x74>
    1dee:	80 e0       	ldi	r24, 0x00	; 0
    1df0:	01 c0       	rjmp	.+2      	; 0x1df4 <xTaskPriorityDisinherit+0x74>
    1df2:	80 e0       	ldi	r24, 0x00	; 0
    1df4:	df 91       	pop	r29
    1df6:	cf 91       	pop	r28
    1df8:	1f 91       	pop	r17
    1dfa:	0f 91       	pop	r16
    1dfc:	08 95       	ret

00001dfe <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1dfe:	80 91 d5 08 	lds	r24, 0x08D5
    1e02:	90 91 d6 08 	lds	r25, 0x08D6
    1e06:	89 2b       	or	r24, r25
    1e08:	39 f0       	breq	.+14     	; 0x1e18 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1e0a:	e0 91 d5 08 	lds	r30, 0x08D5
    1e0e:	f0 91 d6 08 	lds	r31, 0x08D6
    1e12:	82 a1       	ldd	r24, Z+34	; 0x22
    1e14:	8f 5f       	subi	r24, 0xFF	; 255
    1e16:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1e18:	80 91 d5 08 	lds	r24, 0x08D5
    1e1c:	90 91 d6 08 	lds	r25, 0x08D6
	}
    1e20:	08 95       	ret

00001e22 <__divmodhi4>:
    1e22:	97 fb       	bst	r25, 7
    1e24:	07 2e       	mov	r0, r23
    1e26:	16 f4       	brtc	.+4      	; 0x1e2c <__divmodhi4+0xa>
    1e28:	00 94       	com	r0
    1e2a:	06 d0       	rcall	.+12     	; 0x1e38 <__divmodhi4_neg1>
    1e2c:	77 fd       	sbrc	r23, 7
    1e2e:	08 d0       	rcall	.+16     	; 0x1e40 <__divmodhi4_neg2>
    1e30:	0b d0       	rcall	.+22     	; 0x1e48 <__udivmodhi4>
    1e32:	07 fc       	sbrc	r0, 7
    1e34:	05 d0       	rcall	.+10     	; 0x1e40 <__divmodhi4_neg2>
    1e36:	3e f4       	brtc	.+14     	; 0x1e46 <__divmodhi4_exit>

00001e38 <__divmodhi4_neg1>:
    1e38:	90 95       	com	r25
    1e3a:	81 95       	neg	r24
    1e3c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e3e:	08 95       	ret

00001e40 <__divmodhi4_neg2>:
    1e40:	70 95       	com	r23
    1e42:	61 95       	neg	r22
    1e44:	7f 4f       	sbci	r23, 0xFF	; 255

00001e46 <__divmodhi4_exit>:
    1e46:	08 95       	ret

00001e48 <__udivmodhi4>:
    1e48:	aa 1b       	sub	r26, r26
    1e4a:	bb 1b       	sub	r27, r27
    1e4c:	51 e1       	ldi	r21, 0x11	; 17
    1e4e:	07 c0       	rjmp	.+14     	; 0x1e5e <__udivmodhi4_ep>

00001e50 <__udivmodhi4_loop>:
    1e50:	aa 1f       	adc	r26, r26
    1e52:	bb 1f       	adc	r27, r27
    1e54:	a6 17       	cp	r26, r22
    1e56:	b7 07       	cpc	r27, r23
    1e58:	10 f0       	brcs	.+4      	; 0x1e5e <__udivmodhi4_ep>
    1e5a:	a6 1b       	sub	r26, r22
    1e5c:	b7 0b       	sbc	r27, r23

00001e5e <__udivmodhi4_ep>:
    1e5e:	88 1f       	adc	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	5a 95       	dec	r21
    1e64:	a9 f7       	brne	.-22     	; 0x1e50 <__udivmodhi4_loop>
    1e66:	80 95       	com	r24
    1e68:	90 95       	com	r25
    1e6a:	bc 01       	movw	r22, r24
    1e6c:	cd 01       	movw	r24, r26
    1e6e:	08 95       	ret

00001e70 <memcpy>:
    1e70:	fb 01       	movw	r30, r22
    1e72:	dc 01       	movw	r26, r24
    1e74:	02 c0       	rjmp	.+4      	; 0x1e7a <memcpy+0xa>
    1e76:	01 90       	ld	r0, Z+
    1e78:	0d 92       	st	X+, r0
    1e7a:	41 50       	subi	r20, 0x01	; 1
    1e7c:	50 40       	sbci	r21, 0x00	; 0
    1e7e:	d8 f7       	brcc	.-10     	; 0x1e76 <memcpy+0x6>
    1e80:	08 95       	ret

00001e82 <__itoa_ncheck>:
    1e82:	bb 27       	eor	r27, r27
    1e84:	4a 30       	cpi	r20, 0x0A	; 10
    1e86:	31 f4       	brne	.+12     	; 0x1e94 <__itoa_ncheck+0x12>
    1e88:	99 23       	and	r25, r25
    1e8a:	22 f4       	brpl	.+8      	; 0x1e94 <__itoa_ncheck+0x12>
    1e8c:	bd e2       	ldi	r27, 0x2D	; 45
    1e8e:	90 95       	com	r25
    1e90:	81 95       	neg	r24
    1e92:	9f 4f       	sbci	r25, 0xFF	; 255
    1e94:	01 c0       	rjmp	.+2      	; 0x1e98 <__utoa_common>

00001e96 <__utoa_ncheck>:
    1e96:	bb 27       	eor	r27, r27

00001e98 <__utoa_common>:
    1e98:	fb 01       	movw	r30, r22
    1e9a:	55 27       	eor	r21, r21
    1e9c:	aa 27       	eor	r26, r26
    1e9e:	88 0f       	add	r24, r24
    1ea0:	99 1f       	adc	r25, r25
    1ea2:	aa 1f       	adc	r26, r26
    1ea4:	a4 17       	cp	r26, r20
    1ea6:	10 f0       	brcs	.+4      	; 0x1eac <__utoa_common+0x14>
    1ea8:	a4 1b       	sub	r26, r20
    1eaa:	83 95       	inc	r24
    1eac:	50 51       	subi	r21, 0x10	; 16
    1eae:	b9 f7       	brne	.-18     	; 0x1e9e <__utoa_common+0x6>
    1eb0:	a0 5d       	subi	r26, 0xD0	; 208
    1eb2:	aa 33       	cpi	r26, 0x3A	; 58
    1eb4:	08 f0       	brcs	.+2      	; 0x1eb8 <__utoa_common+0x20>
    1eb6:	a9 5d       	subi	r26, 0xD9	; 217
    1eb8:	a1 93       	st	Z+, r26
    1eba:	00 97       	sbiw	r24, 0x00	; 0
    1ebc:	79 f7       	brne	.-34     	; 0x1e9c <__utoa_common+0x4>
    1ebe:	b1 11       	cpse	r27, r1
    1ec0:	b1 93       	st	Z+, r27
    1ec2:	11 92       	st	Z+, r1
    1ec4:	cb 01       	movw	r24, r22
    1ec6:	00 c0       	rjmp	.+0      	; 0x1ec8 <strrev>

00001ec8 <strrev>:
    1ec8:	dc 01       	movw	r26, r24
    1eca:	fc 01       	movw	r30, r24
    1ecc:	67 2f       	mov	r22, r23
    1ece:	71 91       	ld	r23, Z+
    1ed0:	77 23       	and	r23, r23
    1ed2:	e1 f7       	brne	.-8      	; 0x1ecc <strrev+0x4>
    1ed4:	32 97       	sbiw	r30, 0x02	; 2
    1ed6:	04 c0       	rjmp	.+8      	; 0x1ee0 <strrev+0x18>
    1ed8:	7c 91       	ld	r23, X
    1eda:	6d 93       	st	X+, r22
    1edc:	70 83       	st	Z, r23
    1ede:	62 91       	ld	r22, -Z
    1ee0:	ae 17       	cp	r26, r30
    1ee2:	bf 07       	cpc	r27, r31
    1ee4:	c8 f3       	brcs	.-14     	; 0x1ed8 <strrev+0x10>
    1ee6:	08 95       	ret

00001ee8 <_exit>:
    1ee8:	f8 94       	cli

00001eea <__stop_program>:
    1eea:	ff cf       	rjmp	.-2      	; 0x1eea <__stop_program>
