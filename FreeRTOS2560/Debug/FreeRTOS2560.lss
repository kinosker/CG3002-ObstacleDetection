
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002da8  00002e3c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002da8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000709  0080023e  0080023e  00002e7a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002e7a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000550  00000000  00000000  00002eaa  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005dc7  00000000  00000000  000033fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016ad  00000000  00000000  000091c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000037c8  00000000  00000000  0000a86e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f10  00000000  00000000  0000e038  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000016c9  00000000  00000000  0000ef48  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004065  00000000  00000000  00010611  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004e0  00000000  00000000  00014676  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	6c c3       	rjmp	.+1752   	; 0x6fe <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	d9 c6       	rjmp	.+3506   	; 0xe18 <__vector_25>
      66:	00 00       	nop
      68:	45 c7       	rjmp	.+3722   	; 0xef4 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	fa c3       	rjmp	.+2036   	; 0x86a <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	8b c6       	rjmp	.+3350   	; 0xda8 <__vector_36>
      92:	00 00       	nop
      94:	f9 c6       	rjmp	.+3570   	; 0xe88 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myADC_startADC+0x4c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e8 ea       	ldi	r30, 0xA8	; 168
     17e:	fd e2       	ldi	r31, 0x2D	; 45
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 34       	cpi	r26, 0x47	; 71
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c7 d0       	rcall	.+398    	; 0x330 <main>
     1a2:	0c 94 d2 16 	jmp	0x2da4	; 0x2da4 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	ba d7       	rcall	.+3956   	; 0x111e <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	a6 d7       	rcall	.+3916   	; 0x10fa <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	68 d7       	rcall	.+3792   	; 0x1084 <myUSART_receiveUSART1>
     1b4:	97 d7       	rcall	.+3886   	; 0x10e4 <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	ab d7       	rcall	.+3926   	; 0x1112 <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	11 f0       	breq	.+4      	; 0x1c4 <RPI_receiveTask+0x1c>
     1c0:	61 d7       	rcall	.+3778   	; 0x1084 <myUSART_receiveUSART1>
     1c2:	f2 cf       	rjmp	.-28     	; 0x1a8 <RPI_receiveTask>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	9f d7       	rcall	.+3902   	; 0x1106 <myUSART_receiveHandShakeStart>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <RPI_receiveTask+0x28>
     1cc:	7c d7       	rcall	.+3832   	; 0x10c6 <myUSART_waitForHandshake>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	59 d7       	rcall	.+3762   	; 0x1084 <myUSART_receiveUSART1>
     1d2:	ea cf       	rjmp	.-44     	; 0x1a8 <RPI_receiveTask>

000001d4 <RPI_sendTask>:
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <RPI_sendTask+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <RPI_sendTask+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	4f ef       	ldi	r20, 0xFF	; 255
     1e4:	5f ef       	ldi	r21, 0xFF	; 255
     1e6:	be 01       	movw	r22, r28
     1e8:	6a 5f       	subi	r22, 0xFA	; 250
     1ea:	7f 4f       	sbci	r23, 0xFF	; 255
     1ec:	80 91 8f 08 	lds	r24, 0x088F
     1f0:	90 91 90 08 	lds	r25, 0x0890
     1f4:	0e 94 45 0c 	call	0x188a	; 0x188a <xQueueGenericReceive>
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	80 5d       	subi	r24, 0xD0	; 208
     1fc:	10 d7       	rcall	.+3616   	; 0x101e <myUSART_transmitUSART1_c>
     1fe:	8a e0       	ldi	r24, 0x0A	; 10
     200:	0e d7       	rcall	.+3612   	; 0x101e <myUSART_transmitUSART1_c>
     202:	8e 81       	ldd	r24, Y+6	; 0x06
     204:	9f ef       	ldi	r25, 0xFF	; 255
     206:	98 0f       	add	r25, r24
     208:	9e 83       	std	Y+6, r25	; 0x06
     20a:	88 23       	and	r24, r24
     20c:	21 f1       	breq	.+72     	; 0x256 <RPI_sendTask+0x82>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	4f ef       	ldi	r20, 0xFF	; 255
     212:	5f ef       	ldi	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 91 08 	lds	r24, 0x0891
     21e:	90 91 92 08 	lds	r25, 0x0892
     222:	0e 94 45 0c 	call	0x188a	; 0x188a <xQueueGenericReceive>
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	e3 d6       	rcall	.+3526   	; 0xff0 <myUSART_transmitUSART0_c>
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	f8 d6       	rcall	.+3568   	; 0x101e <myUSART_transmitUSART1_c>
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	92 e0       	ldi	r25, 0x02	; 2
     232:	1a d7       	rcall	.+3636   	; 0x1068 <myUSART_transmitUSART0>
     234:	ce 01       	movw	r24, r28
     236:	02 96       	adiw	r24, 0x02	; 2
     238:	17 d7       	rcall	.+3630   	; 0x1068 <myUSART_transmitUSART0>
     23a:	ce 01       	movw	r24, r28
     23c:	02 96       	adiw	r24, 0x02	; 2
     23e:	06 d7       	rcall	.+3596   	; 0x104c <myUSART_transmitUSART1>
     240:	8a e0       	ldi	r24, 0x0A	; 10
     242:	ed d6       	rcall	.+3546   	; 0x101e <myUSART_transmitUSART1_c>
     244:	89 e0       	ldi	r24, 0x09	; 9
     246:	92 e0       	ldi	r25, 0x02	; 2
     248:	0f d7       	rcall	.+3614   	; 0x1068 <myUSART_transmitUSART0>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f ef       	ldi	r25, 0xFF	; 255
     24e:	98 0f       	add	r25, r24
     250:	9e 83       	std	Y+6, r25	; 0x06
     252:	81 11       	cpse	r24, r1
     254:	dc cf       	rjmp	.-72     	; 0x20e <RPI_sendTask+0x3a>
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	cb d6       	rcall	.+3478   	; 0xff0 <myUSART_transmitUSART0_c>
     25a:	c2 cf       	rjmp	.-124    	; 0x1e0 <RPI_sendTask+0xc>

0000025c <myTimerTask>:
     25c:	f6 d4       	rcall	.+2540   	; 0xc4a <myTimer_Init>
     25e:	35 d5       	rcall	.+2666   	; 0xcca <myTimer_DelayChecker>
     260:	fe cf       	rjmp	.-4      	; 0x25e <myTimerTask+0x2>

00000262 <task1>:
     262:	26 9a       	sbi	0x04, 6	; 4
     264:	2e 9a       	sbi	0x05, 6	; 5
     266:	88 ee       	ldi	r24, 0xE8	; 232
     268:	93 e0       	ldi	r25, 0x03	; 3
     26a:	0e 94 b2 10 	call	0x2164	; 0x2164 <vTaskDelay>
     26e:	85 b1       	in	r24, 0x05	; 5
     270:	15 b8       	out	0x05, r1	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 b2 10 	call	0x2164	; 0x2164 <vTaskDelay>
     27a:	f4 cf       	rjmp	.-24     	; 0x264 <task1+0x2>

0000027c <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     27c:	8f ef       	ldi	r24, 0xFF	; 255
     27e:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     282:	ef e7       	ldi	r30, 0x7F	; 127
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	90 81       	ld	r25, Z
     288:	93 60       	ori	r25, 0x03	; 3
     28a:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     28c:	80 93 7d 00 	sts	0x007D, r24
     290:	08 95       	ret

00000292 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     292:	8c ec       	ldi	r24, 0xCC	; 204
     294:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     298:	8e e3       	ldi	r24, 0x3E	; 62
     29a:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     29e:	ee cf       	rjmp	.-36     	; 0x27c <setDigitalInputPowerReduction>
     2a0:	08 95       	ret

000002a2 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2a2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2a6:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2aa:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2ae:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2b2:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2b6:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ba:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2be:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2c2:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2c6:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2ca:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2ce:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2d2:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2d6:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2da:	10 92 73 00 	sts	0x0073, r1
     2de:	08 95       	ret

000002e0 <init>:
}

void init()
{
     2e0:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2e2:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2e4:	f8 94       	cli
	{
		clearTimer();
     2e6:	dd df       	rcall	.-70     	; 0x2a2 <clearTimer>
		setPowerReduction();
     2e8:	d4 df       	rcall	.-88     	; 0x292 <setPowerReduction>
		myUSART_USART0_Init();
     2ea:	3a d6       	rcall	.+3188   	; 0xf60 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2ec:	59 d6       	rcall	.+3250   	; 0xfa0 <myUSART_USART1_Init>
		myADC_Init();
     2ee:	f5 d2       	rcall	.+1514   	; 0x8da <myADC_Init>
		
		MaxSonar_Init();
     2f0:	83 b3       	in	r24, 0x13	; 19
     2f2:	83 60       	ori	r24, 0x03	; 3
     2f4:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     2f6:	8e d2       	rcall	.+1308   	; 0x814 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2f8:	40 e0       	ldi	r20, 0x00	; 0
     2fa:	61 e0       	ldi	r22, 0x01	; 1
     2fc:	85 e0       	ldi	r24, 0x05	; 5
     2fe:	0e 94 20 0b 	call	0x1640	; 0x1640 <xQueueGenericCreate>
     302:	90 93 90 08 	sts	0x0890, r25
     306:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     30a:	40 e0       	ldi	r20, 0x00	; 0
     30c:	65 e0       	ldi	r22, 0x05	; 5
     30e:	84 e1       	ldi	r24, 0x14	; 20
     310:	0e 94 20 0b 	call	0x1640	; 0x1640 <xQueueGenericCreate>
     314:	90 93 92 08 	sts	0x0892, r25
     318:	80 93 91 08 	sts	0x0891, r24
		
		MOTOR_LEFT_INIT();
     31c:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     31e:	e1 e0       	ldi	r30, 0x01	; 1
     320:	f1 e0       	ldi	r31, 0x01	; 1
     322:	80 81       	ld	r24, Z
     324:	80 61       	ori	r24, 0x10	; 16
     326:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     328:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     32a:	78 94       	sei
}
     32c:	cf 91       	pop	r28
     32e:	08 95       	ret

00000330 <main>:
	
	// do nth
}

int main(void)
{
     330:	cf 93       	push	r28
     332:	df 93       	push	r29
     334:	cd b7       	in	r28, 0x3d	; 61
     336:	de b7       	in	r29, 0x3e	; 62
     338:	2a 97       	sbiw	r28, 0x0a	; 10
     33a:	0f b6       	in	r0, 0x3f	; 63
     33c:	f8 94       	cli
     33e:	de bf       	out	0x3e, r29	; 62
     340:	0f be       	out	0x3f, r0	; 63
     342:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     344:	cd df       	rcall	.-102    	; 0x2e0 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     346:	a1 2c       	mov	r10, r1
     348:	b1 2c       	mov	r11, r1
     34a:	c1 2c       	mov	r12, r1
     34c:	d1 2c       	mov	r13, r1
     34e:	ce 01       	movw	r24, r28
     350:	01 96       	adiw	r24, 0x01	; 1
     352:	7c 01       	movw	r14, r24
     354:	01 e0       	ldi	r16, 0x01	; 1
     356:	20 e0       	ldi	r18, 0x00	; 0
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	45 e5       	ldi	r20, 0x55	; 85
     35c:	50 e0       	ldi	r21, 0x00	; 0
     35e:	6c e0       	ldi	r22, 0x0C	; 12
     360:	72 e0       	ldi	r23, 0x02	; 2
     362:	81 e3       	ldi	r24, 0x31	; 49
     364:	91 e0       	ldi	r25, 0x01	; 1
     366:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     36a:	ce 01       	movw	r24, r28
     36c:	03 96       	adiw	r24, 0x03	; 3
     36e:	7c 01       	movw	r14, r24
     370:	04 e0       	ldi	r16, 0x04	; 4
     372:	9c 01       	movw	r18, r24
     374:	49 e6       	ldi	r20, 0x69	; 105
     376:	50 e0       	ldi	r21, 0x00	; 0
     378:	63 e1       	ldi	r22, 0x13	; 19
     37a:	72 e0       	ldi	r23, 0x02	; 2
     37c:	8e e2       	ldi	r24, 0x2E	; 46
     37e:	91 e0       	ldi	r25, 0x01	; 1
     380:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     384:	ce 01       	movw	r24, r28
     386:	09 96       	adiw	r24, 0x09	; 9
     388:	7c 01       	movw	r14, r24
     38a:	02 e0       	ldi	r16, 0x02	; 2
     38c:	20 e0       	ldi	r18, 0x00	; 0
     38e:	30 e0       	ldi	r19, 0x00	; 0
     390:	4f e4       	ldi	r20, 0x4F	; 79
     392:	51 e0       	ldi	r21, 0x01	; 1
     394:	6b e1       	ldi	r22, 0x1B	; 27
     396:	72 e0       	ldi	r23, 0x02	; 2
     398:	8c e5       	ldi	r24, 0x5C	; 92
     39a:	92 e0       	ldi	r25, 0x02	; 2
     39c:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3a0:	ce 01       	movw	r24, r28
     3a2:	07 96       	adiw	r24, 0x07	; 7
     3a4:	7c 01       	movw	r14, r24
     3a6:	03 e0       	ldi	r16, 0x03	; 3
     3a8:	20 e0       	ldi	r18, 0x00	; 0
     3aa:	30 e0       	ldi	r19, 0x00	; 0
     3ac:	47 e8       	ldi	r20, 0x87	; 135
     3ae:	50 e0       	ldi	r21, 0x00	; 0
     3b0:	64 e2       	ldi	r22, 0x24	; 36
     3b2:	72 e0       	ldi	r23, 0x02	; 2
     3b4:	84 ed       	ldi	r24, 0xD4	; 212
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3bc:	ce 01       	movw	r24, r28
     3be:	05 96       	adiw	r24, 0x05	; 5
     3c0:	7c 01       	movw	r14, r24
     3c2:	01 e0       	ldi	r16, 0x01	; 1
     3c4:	20 e0       	ldi	r18, 0x00	; 0
     3c6:	30 e0       	ldi	r19, 0x00	; 0
     3c8:	47 e8       	ldi	r20, 0x87	; 135
     3ca:	50 e0       	ldi	r21, 0x00	; 0
     3cc:	60 e3       	ldi	r22, 0x30	; 48
     3ce:	72 e0       	ldi	r23, 0x02	; 2
     3d0:	8a ee       	ldi	r24, 0xEA	; 234
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	0e 94 97 0d 	call	0x1b2e	; 0x1b2e <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3d8:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <vTaskStartScheduler>
     3dc:	b3 cf       	rjmp	.-154    	; 0x344 <main+0x14>

000003de <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     3de:	1f 93       	push	r17
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	00 d0       	rcall	.+0      	; 0x3e6 <obstacleSend+0x8>
     3e6:	1f 92       	push	r1
     3e8:	1f 92       	push	r1
     3ea:	cd b7       	in	r28, 0x3d	; 61
     3ec:	de b7       	in	r29, 0x3e	; 62
     3ee:	18 2f       	mov	r17, r24
     3f0:	cb 01       	movw	r24, r22
	obstacleData queueData;
	
	
	
	if(deviceBlocked)
     3f2:	11 23       	and	r17, r17
     3f4:	99 f0       	breq	.+38     	; 0x41c <obstacleSend+0x3e>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
     3f6:	4a e0       	ldi	r20, 0x0A	; 10
     3f8:	be 01       	movw	r22, r28
     3fa:	6e 5f       	subi	r22, 0xFE	; 254
     3fc:	7f 4f       	sbci	r23, 0xFF	; 255
     3fe:	0e 94 9f 16 	call	0x2d3e	; 0x2d3e <__itoa_ncheck>
	{
		itoa(reading, queueData.data, 10); // convert to ascii
		
		queueData.deviceID = deviceBlocked;
     402:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &queueData, portMAX_DELAY); // send data to queueData
     404:	20 e0       	ldi	r18, 0x00	; 0
     406:	4f ef       	ldi	r20, 0xFF	; 255
     408:	5f ef       	ldi	r21, 0xFF	; 255
     40a:	be 01       	movw	r22, r28
     40c:	6f 5f       	subi	r22, 0xFF	; 255
     40e:	7f 4f       	sbci	r23, 0xFF	; 255
     410:	80 91 91 08 	lds	r24, 0x0891
     414:	90 91 92 08 	lds	r25, 0x0892
     418:	0e 94 4d 0b 	call	0x169a	; 0x169a <xQueueGenericSend>
	}
}
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	0f 90       	pop	r0
     424:	0f 90       	pop	r0
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	1f 91       	pop	r17
     42c:	08 95       	ret

0000042e <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     42e:	6f 92       	push	r6
     430:	7f 92       	push	r7
     432:	8f 92       	push	r8
     434:	9f 92       	push	r9
     436:	af 92       	push	r10
     438:	bf 92       	push	r11
     43a:	cf 92       	push	r12
     43c:	df 92       	push	r13
     43e:	ef 92       	push	r14
     440:	ff 92       	push	r15
     442:	0f 93       	push	r16
     444:	1f 93       	push	r17
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	1f 92       	push	r1
     44c:	cd b7       	in	r28, 0x3d	; 61
     44e:	de b7       	in	r29, 0x3e	; 62
     450:	89 83       	std	Y+1, r24	; 0x01
     452:	5b 01       	movw	r10, r22
     454:	3a 01       	movw	r6, r20
     456:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     458:	20 e0       	ldi	r18, 0x00	; 0
     45a:	4f ef       	ldi	r20, 0xFF	; 255
     45c:	5f ef       	ldi	r21, 0xFF	; 255
     45e:	be 01       	movw	r22, r28
     460:	6f 5f       	subi	r22, 0xFF	; 255
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	80 91 8f 08 	lds	r24, 0x088F
     468:	90 91 90 08 	lds	r25, 0x0890
     46c:	0e 94 4d 0b 	call	0x169a	; 0x169a <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     470:	b3 01       	movw	r22, r6
     472:	f5 01       	movw	r30, r10
     474:	80 81       	ld	r24, Z
     476:	b3 df       	rcall	.-154    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     478:	b4 01       	movw	r22, r8
     47a:	f5 01       	movw	r30, r10
     47c:	81 81       	ldd	r24, Z+1	; 0x01
     47e:	af df       	rcall	.-162    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     480:	b8 01       	movw	r22, r16
     482:	f5 01       	movw	r30, r10
     484:	82 81       	ldd	r24, Z+2	; 0x02
     486:	ab df       	rcall	.-170    	; 0x3de <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     488:	b7 01       	movw	r22, r14
     48a:	f5 01       	movw	r30, r10
     48c:	83 81       	ldd	r24, Z+3	; 0x03
     48e:	a7 df       	rcall	.-178    	; 0x3de <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     490:	b6 01       	movw	r22, r12
     492:	f5 01       	movw	r30, r10
     494:	84 81       	ldd	r24, Z+4	; 0x04
     496:	a3 df       	rcall	.-186    	; 0x3de <obstacleSend>
		
	}
}
     498:	0f 90       	pop	r0
     49a:	df 91       	pop	r29
     49c:	cf 91       	pop	r28
     49e:	1f 91       	pop	r17
     4a0:	0f 91       	pop	r16
     4a2:	ff 90       	pop	r15
     4a4:	ef 90       	pop	r14
     4a6:	df 90       	pop	r13
     4a8:	cf 90       	pop	r12
     4aa:	bf 90       	pop	r11
     4ac:	af 90       	pop	r10
     4ae:	9f 90       	pop	r9
     4b0:	8f 90       	pop	r8
     4b2:	7f 90       	pop	r7
     4b4:	6f 90       	pop	r6
     4b6:	08 95       	ret

000004b8 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4b8:	cf 93       	push	r28
     4ba:	df 93       	push	r29
     4bc:	cd b7       	in	r28, 0x3d	; 61
     4be:	de b7       	in	r29, 0x3e	; 62
     4c0:	2c 97       	sbiw	r28, 0x0c	; 12
     4c2:	0f b6       	in	r0, 0x3f	; 63
     4c4:	f8 94       	cli
     4c6:	de bf       	out	0x3e, r29	; 62
     4c8:	0f be       	out	0x3f, r0	; 63
     4ca:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     4cc:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     4ce:	fe 01       	movw	r30, r28
     4d0:	34 96       	adiw	r30, 0x04	; 4
     4d2:	85 e0       	ldi	r24, 0x05	; 5
     4d4:	df 01       	movw	r26, r30
     4d6:	1d 92       	st	X+, r1
     4d8:	8a 95       	dec	r24
     4da:	e9 f7       	brne	.-6      	; 0x4d6 <Sonar_Task+0x1e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     4dc:	84 e2       	ldi	r24, 0x24	; 36
     4de:	18 d3       	rcall	.+1584   	; 0xb10 <mySharpIR_Read>
     4e0:	9a 87       	std	Y+10, r25	; 0x0a
     4e2:	89 87       	std	Y+9, r24	; 0x09
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     4e4:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <xTaskGetTickCount>
     4e8:	9a 83       	std	Y+2, r25	; 0x02
     4ea:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     4ec:	ae d1       	rcall	.+860    	; 0x84a <myMaxSonar_TopStart>
		topSonar = myMaxSonar_Read(AN11);
     4ee:	83 e2       	ldi	r24, 0x23	; 35
     4f0:	b2 d1       	rcall	.+868    	; 0x856 <myMaxSonar_Read>
     4f2:	9c 87       	std	Y+12, r25	; 0x0c
     4f4:	8b 87       	std	Y+11, r24	; 0x0b
	
		myMaxSonar_BtmStart();
     4f6:	a3 d1       	rcall	.+838    	; 0x83e <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_Read(AN15);
     4f8:	87 e2       	ldi	r24, 0x27	; 39
     4fa:	ad d1       	rcall	.+858    	; 0x856 <myMaxSonar_Read>
     4fc:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_Read(AN14);
     4fe:	86 e2       	ldi	r24, 0x26	; 38
     500:	aa d1       	rcall	.+852    	; 0x856 <myMaxSonar_Read>
     502:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_Read(AN13); 
     504:	85 e2       	ldi	r24, 0x25	; 37
     506:	a7 d1       	rcall	.+846    	; 0x856 <myMaxSonar_Read>
     508:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     50a:	84 e2       	ldi	r24, 0x24	; 36
     50c:	01 d3       	rcall	.+1538   	; 0xb10 <mySharpIR_Read>
     50e:	4c 01       	movw	r8, r24
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     510:	bc 01       	movw	r22, r24
     512:	ce 01       	movw	r24, r28
     514:	09 96       	adiw	r24, 0x09	; 9
     516:	35 d3       	rcall	.+1642   	; 0xb82 <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     518:	c9 84       	ldd	r12, Y+9	; 0x09
     51a:	da 84       	ldd	r13, Y+10	; 0x0a
     51c:	54 01       	movw	r10, r8
     51e:	eb 84       	ldd	r14, Y+11	; 0x0b
     520:	fc 84       	ldd	r15, Y+12	; 0x0c
     522:	82 01       	movw	r16, r4
     524:	91 01       	movw	r18, r2
     526:	ae 01       	movw	r20, r28
     528:	4c 5f       	subi	r20, 0xFC	; 252
     52a:	5f 4f       	sbci	r21, 0xFF	; 255
     52c:	6b 81       	ldd	r22, Y+3	; 0x03
     52e:	c3 01       	movw	r24, r6
     530:	bf d2       	rcall	.+1406   	; 0xab0 <obstacleDetection>
     532:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     534:	8e 01       	movw	r16, r28
     536:	0c 5f       	subi	r16, 0xFC	; 252
     538:	1f 4f       	sbci	r17, 0xFF	; 255
     53a:	94 01       	movw	r18, r8
     53c:	a2 01       	movw	r20, r4
     53e:	b1 01       	movw	r22, r2
     540:	c3 01       	movw	r24, r6
     542:	4c d2       	rcall	.+1176   	; 0x9dc <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     544:	be 01       	movw	r22, r28
     546:	6d 5f       	subi	r22, 0xFD	; 253
     548:	7f 4f       	sbci	r23, 0xFF	; 255
     54a:	c8 01       	movw	r24, r16
     54c:	a2 d2       	rcall	.+1348   	; 0xa92 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     54e:	cb 84       	ldd	r12, Y+11	; 0x0b
     550:	dc 84       	ldd	r13, Y+12	; 0x0c
     552:	74 01       	movw	r14, r8
     554:	82 01       	movw	r16, r4
     556:	91 01       	movw	r18, r2
     558:	a3 01       	movw	r20, r6
     55a:	be 01       	movw	r22, r28
     55c:	6c 5f       	subi	r22, 0xFC	; 252
     55e:	7f 4f       	sbci	r23, 0xFF	; 255
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	65 df       	rcall	.-310    	; 0x42e <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     564:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     566:	18 86       	std	Y+8, r1	; 0x08
     568:	1f 82       	std	Y+7, r1	; 0x07
     56a:	1e 82       	std	Y+6, r1	; 0x06
     56c:	1d 82       	std	Y+5, r1	; 0x05
     56e:	1c 82       	std	Y+4, r1	; 0x04
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     570:	66 e9       	ldi	r22, 0x96	; 150
     572:	70 e0       	ldi	r23, 0x00	; 0
     574:	ce 01       	movw	r24, r28
     576:	01 96       	adiw	r24, 0x01	; 1
     578:	0e 94 74 10 	call	0x20e8	; 0x20e8 <vTaskDelayUntil>
     57c:	b7 cf       	rjmp	.-146    	; 0x4ec <Sonar_Task+0x34>

0000057e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     57e:	cf 93       	push	r28
     580:	df 93       	push	r29
     582:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     584:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     588:	80 91 3e 02 	lds	r24, 0x023E
     58c:	90 91 3f 02 	lds	r25, 0x023F
     590:	89 2b       	or	r24, r25
     592:	31 f4       	brne	.+12     	; 0x5a0 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     594:	83 e4       	ldi	r24, 0x43	; 67
     596:	92 e0       	ldi	r25, 0x02	; 2
     598:	90 93 3f 02 	sts	0x023F, r25
     59c:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     5a0:	40 91 40 02 	lds	r20, 0x0240
     5a4:	50 91 41 02 	lds	r21, 0x0241
     5a8:	9e 01       	movw	r18, r28
     5aa:	24 0f       	add	r18, r20
     5ac:	35 1f       	adc	r19, r21
     5ae:	2b 3d       	cpi	r18, 0xDB	; 219
     5b0:	85 e0       	ldi	r24, 0x05	; 5
     5b2:	38 07       	cpc	r19, r24
     5b4:	70 f4       	brcc	.+28     	; 0x5d2 <pvPortMalloc+0x54>
     5b6:	42 17       	cp	r20, r18
     5b8:	53 07       	cpc	r21, r19
     5ba:	70 f4       	brcc	.+28     	; 0x5d8 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     5bc:	c0 91 3e 02 	lds	r28, 0x023E
     5c0:	d0 91 3f 02 	lds	r29, 0x023F
     5c4:	c4 0f       	add	r28, r20
     5c6:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5c8:	30 93 41 02 	sts	0x0241, r19
     5cc:	20 93 40 02 	sts	0x0240, r18
     5d0:	05 c0       	rjmp	.+10     	; 0x5dc <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5d2:	c0 e0       	ldi	r28, 0x00	; 0
     5d4:	d0 e0       	ldi	r29, 0x00	; 0
     5d6:	02 c0       	rjmp	.+4      	; 0x5dc <pvPortMalloc+0x5e>
     5d8:	c0 e0       	ldi	r28, 0x00	; 0
     5da:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5dc:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5e0:	ce 01       	movw	r24, r28
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	08 95       	ret

000005e8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5e8:	08 95       	ret

000005ea <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     5ea:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5ec:	03 96       	adiw	r24, 0x03	; 3
     5ee:	92 83       	std	Z+2, r25	; 0x02
     5f0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     5f2:	2f ef       	ldi	r18, 0xFF	; 255
     5f4:	3f ef       	ldi	r19, 0xFF	; 255
     5f6:	34 83       	std	Z+4, r19	; 0x04
     5f8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5fa:	96 83       	std	Z+6, r25	; 0x06
     5fc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     5fe:	90 87       	std	Z+8, r25	; 0x08
     600:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     602:	10 82       	st	Z, r1
     604:	08 95       	ret

00000606 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     606:	fc 01       	movw	r30, r24
     608:	11 86       	std	Z+9, r1	; 0x09
     60a:	10 86       	std	Z+8, r1	; 0x08
     60c:	08 95       	ret

0000060e <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	9c 01       	movw	r18, r24
     614:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     616:	dc 01       	movw	r26, r24
     618:	11 96       	adiw	r26, 0x01	; 1
     61a:	cd 91       	ld	r28, X+
     61c:	dc 91       	ld	r29, X
     61e:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     620:	d3 83       	std	Z+3, r29	; 0x03
     622:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     624:	8c 81       	ldd	r24, Y+4	; 0x04
     626:	9d 81       	ldd	r25, Y+5	; 0x05
     628:	95 83       	std	Z+5, r25	; 0x05
     62a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     62c:	8c 81       	ldd	r24, Y+4	; 0x04
     62e:	9d 81       	ldd	r25, Y+5	; 0x05
     630:	dc 01       	movw	r26, r24
     632:	13 96       	adiw	r26, 0x03	; 3
     634:	7c 93       	st	X, r23
     636:	6e 93       	st	-X, r22
     638:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     63a:	7d 83       	std	Y+5, r23	; 0x05
     63c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     63e:	31 87       	std	Z+9, r19	; 0x09
     640:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     642:	f9 01       	movw	r30, r18
     644:	80 81       	ld	r24, Z
     646:	8f 5f       	subi	r24, 0xFF	; 255
     648:	80 83       	st	Z, r24
}
     64a:	df 91       	pop	r29
     64c:	cf 91       	pop	r28
     64e:	08 95       	ret

00000650 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     656:	48 81       	ld	r20, Y
     658:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     65a:	4f 3f       	cpi	r20, 0xFF	; 255
     65c:	2f ef       	ldi	r18, 0xFF	; 255
     65e:	52 07       	cpc	r21, r18
     660:	21 f4       	brne	.+8      	; 0x66a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     662:	fc 01       	movw	r30, r24
     664:	a7 81       	ldd	r26, Z+7	; 0x07
     666:	b0 85       	ldd	r27, Z+8	; 0x08
     668:	0d c0       	rjmp	.+26     	; 0x684 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     66a:	dc 01       	movw	r26, r24
     66c:	13 96       	adiw	r26, 0x03	; 3
     66e:	12 96       	adiw	r26, 0x02	; 2
     670:	ed 91       	ld	r30, X+
     672:	fc 91       	ld	r31, X
     674:	13 97       	sbiw	r26, 0x03	; 3
     676:	20 81       	ld	r18, Z
     678:	31 81       	ldd	r19, Z+1	; 0x01
     67a:	42 17       	cp	r20, r18
     67c:	53 07       	cpc	r21, r19
     67e:	10 f0       	brcs	.+4      	; 0x684 <vListInsert+0x34>
     680:	df 01       	movw	r26, r30
     682:	f5 cf       	rjmp	.-22     	; 0x66e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     684:	12 96       	adiw	r26, 0x02	; 2
     686:	ed 91       	ld	r30, X+
     688:	fc 91       	ld	r31, X
     68a:	13 97       	sbiw	r26, 0x03	; 3
     68c:	fb 83       	std	Y+3, r31	; 0x03
     68e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     690:	d5 83       	std	Z+5, r29	; 0x05
     692:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     694:	bd 83       	std	Y+5, r27	; 0x05
     696:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     698:	13 96       	adiw	r26, 0x03	; 3
     69a:	dc 93       	st	X, r29
     69c:	ce 93       	st	-X, r28
     69e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6a0:	99 87       	std	Y+9, r25	; 0x09
     6a2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6a4:	fc 01       	movw	r30, r24
     6a6:	20 81       	ld	r18, Z
     6a8:	2f 5f       	subi	r18, 0xFF	; 255
     6aa:	20 83       	st	Z, r18
}
     6ac:	df 91       	pop	r29
     6ae:	cf 91       	pop	r28
     6b0:	08 95       	ret

000006b2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     6b2:	cf 93       	push	r28
     6b4:	df 93       	push	r29
     6b6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     6b8:	a0 85       	ldd	r26, Z+8	; 0x08
     6ba:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     6bc:	c2 81       	ldd	r28, Z+2	; 0x02
     6be:	d3 81       	ldd	r29, Z+3	; 0x03
     6c0:	84 81       	ldd	r24, Z+4	; 0x04
     6c2:	95 81       	ldd	r25, Z+5	; 0x05
     6c4:	9d 83       	std	Y+5, r25	; 0x05
     6c6:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     6c8:	c4 81       	ldd	r28, Z+4	; 0x04
     6ca:	d5 81       	ldd	r29, Z+5	; 0x05
     6cc:	82 81       	ldd	r24, Z+2	; 0x02
     6ce:	93 81       	ldd	r25, Z+3	; 0x03
     6d0:	9b 83       	std	Y+3, r25	; 0x03
     6d2:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     6d4:	11 96       	adiw	r26, 0x01	; 1
     6d6:	cd 91       	ld	r28, X+
     6d8:	dc 91       	ld	r29, X
     6da:	12 97       	sbiw	r26, 0x02	; 2
     6dc:	ce 17       	cp	r28, r30
     6de:	df 07       	cpc	r29, r31
     6e0:	31 f4       	brne	.+12     	; 0x6ee <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     6e2:	8c 81       	ldd	r24, Y+4	; 0x04
     6e4:	9d 81       	ldd	r25, Y+5	; 0x05
     6e6:	12 96       	adiw	r26, 0x02	; 2
     6e8:	9c 93       	st	X, r25
     6ea:	8e 93       	st	-X, r24
     6ec:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     6ee:	11 86       	std	Z+9, r1	; 0x09
     6f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     6f2:	8c 91       	ld	r24, X
     6f4:	81 50       	subi	r24, 0x01	; 1
     6f6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     6f8:	df 91       	pop	r29
     6fa:	cf 91       	pop	r28
     6fc:	08 95       	ret

000006fe <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     6fe:	1f 92       	push	r1
     700:	0f 92       	push	r0
     702:	0f b6       	in	r0, 0x3f	; 63
     704:	0f 92       	push	r0
     706:	11 24       	eor	r1, r1
     708:	0b b6       	in	r0, 0x3b	; 59
     70a:	0f 92       	push	r0
     70c:	2f 93       	push	r18
     70e:	3f 93       	push	r19
     710:	4f 93       	push	r20
     712:	5f 93       	push	r21
     714:	6f 93       	push	r22
     716:	7f 93       	push	r23
     718:	8f 93       	push	r24
     71a:	9f 93       	push	r25
     71c:	af 93       	push	r26
     71e:	bf 93       	push	r27
     720:	ef 93       	push	r30
     722:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     724:	1b 9b       	sbis	0x03, 3	; 3
     726:	0d c0       	rjmp	.+26     	; 0x742 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     728:	aa d2       	rcall	.+1364   	; 0xc7e <myTimer_Read>
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	90 93 98 08 	sts	0x0898, r25
     730:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     734:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <xTaskGetTickCountFromISR>
     738:	90 93 94 08 	sts	0x0894, r25
     73c:	80 93 93 08 	sts	0x0893, r24
     740:	56 c0       	rjmp	.+172    	; 0x7ee <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     742:	1b 99       	sbic	0x03, 3	; 3
     744:	54 c0       	rjmp	.+168    	; 0x7ee <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     746:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <xTaskGetTickCountFromISR>
     74a:	90 93 9e 08 	sts	0x089E, r25
     74e:	80 93 9d 08 	sts	0x089D, r24
     752:	20 91 93 08 	lds	r18, 0x0893
     756:	30 91 94 08 	lds	r19, 0x0894
     75a:	82 17       	cp	r24, r18
     75c:	93 07       	cpc	r25, r19
     75e:	4c f4       	brge	.+18     	; 0x772 <__vector_9+0x74>
			ms_tickEnd += 65535;
     760:	80 91 9d 08 	lds	r24, 0x089D
     764:	90 91 9e 08 	lds	r25, 0x089E
     768:	01 97       	sbiw	r24, 0x01	; 1
     76a:	90 93 9e 08 	sts	0x089E, r25
     76e:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     772:	85 d2       	rcall	.+1290   	; 0xc7e <myTimer_Read>
     774:	90 e0       	ldi	r25, 0x00	; 0
     776:	90 93 a0 08 	sts	0x08A0, r25
     77a:	80 93 9f 08 	sts	0x089F, r24
     77e:	20 91 97 08 	lds	r18, 0x0897
     782:	30 91 98 08 	lds	r19, 0x0898
     786:	82 17       	cp	r24, r18
     788:	93 07       	cpc	r25, r19
     78a:	54 f4       	brge	.+20     	; 0x7a0 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     78c:	80 91 9f 08 	lds	r24, 0x089F
     790:	90 91 a0 08 	lds	r25, 0x08A0
     794:	86 50       	subi	r24, 0x06	; 6
     796:	9f 4f       	sbci	r25, 0xFF	; 255
     798:	90 93 a0 08 	sts	0x08A0, r25
     79c:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     7a0:	80 91 9f 08 	lds	r24, 0x089F
     7a4:	90 91 a0 08 	lds	r25, 0x08A0
     7a8:	20 91 97 08 	lds	r18, 0x0897
     7ac:	30 91 98 08 	lds	r19, 0x0898
     7b0:	82 1b       	sub	r24, r18
     7b2:	93 0b       	sbc	r25, r19
     7b4:	90 93 9a 08 	sts	0x089A, r25
     7b8:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     7bc:	80 91 9d 08 	lds	r24, 0x089D
     7c0:	90 91 9e 08 	lds	r25, 0x089E
     7c4:	20 91 93 08 	lds	r18, 0x0893
     7c8:	30 91 94 08 	lds	r19, 0x0894
     7cc:	82 1b       	sub	r24, r18
     7ce:	93 0b       	sbc	r25, r19
     7d0:	90 93 96 08 	sts	0x0896, r25
     7d4:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     7d8:	20 e0       	ldi	r18, 0x00	; 0
     7da:	40 e0       	ldi	r20, 0x00	; 0
     7dc:	50 e0       	ldi	r21, 0x00	; 0
     7de:	60 e0       	ldi	r22, 0x00	; 0
     7e0:	70 e0       	ldi	r23, 0x00	; 0
     7e2:	80 91 9b 08 	lds	r24, 0x089B
     7e6:	90 91 9c 08 	lds	r25, 0x089C
     7ea:	0e 94 0b 0c 	call	0x1816	; 0x1816 <xQueueGenericSendFromISR>
	}	
}
     7ee:	ff 91       	pop	r31
     7f0:	ef 91       	pop	r30
     7f2:	bf 91       	pop	r27
     7f4:	af 91       	pop	r26
     7f6:	9f 91       	pop	r25
     7f8:	8f 91       	pop	r24
     7fa:	7f 91       	pop	r23
     7fc:	6f 91       	pop	r22
     7fe:	5f 91       	pop	r21
     800:	4f 91       	pop	r20
     802:	3f 91       	pop	r19
     804:	2f 91       	pop	r18
     806:	0f 90       	pop	r0
     808:	0b be       	out	0x3b, r0	; 59
     80a:	0f 90       	pop	r0
     80c:	0f be       	out	0x3f, r0	; 63
     80e:	0f 90       	pop	r0
     810:	1f 90       	pop	r1
     812:	18 95       	reti

00000814 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     814:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     816:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     818:	e8 e6       	ldi	r30, 0x68	; 104
     81a:	f0 e0       	ldi	r31, 0x00	; 0
     81c:	80 81       	ld	r24, Z
     81e:	81 60       	ori	r24, 0x01	; 1
     820:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     822:	eb e6       	ldi	r30, 0x6B	; 107
     824:	f0 e0       	ldi	r31, 0x00	; 0
     826:	80 81       	ld	r24, Z
     828:	88 60       	ori	r24, 0x08	; 8
     82a:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     82c:	43 e0       	ldi	r20, 0x03	; 3
     82e:	60 e0       	ldi	r22, 0x00	; 0
     830:	81 e0       	ldi	r24, 0x01	; 1
     832:	06 d7       	rcall	.+3596   	; 0x1640 <xQueueGenericCreate>
     834:	90 93 9c 08 	sts	0x089C, r25
     838:	80 93 9b 08 	sts	0x089B, r24
     83c:	08 95       	ret

0000083e <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     83e:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     840:	89 e1       	ldi	r24, 0x19	; 25
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	1e d2       	rcall	.+1084   	; 0xc82 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     846:	a1 98       	cbi	0x14, 1	; 20
     848:	08 95       	ret

0000084a <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     84a:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     84c:	89 e1       	ldi	r24, 0x19	; 25
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	18 d2       	rcall	.+1072   	; 0xc82 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     852:	a0 98       	cbi	0x14, 0	; 20
     854:	08 95       	ret

00000856 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     856:	ab d0       	rcall	.+342    	; 0x9ae <myADC_analogRead>
     858:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     85a:	63 e0       	ldi	r22, 0x03	; 3
     85c:	70 e0       	ldi	r23, 0x00	; 0
     85e:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     862:	cb 01       	movw	r24, r22
     864:	82 0f       	add	r24, r18
     866:	93 1f       	adc	r25, r19
     868:	08 95       	ret

0000086a <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     86a:	1f 92       	push	r1
     86c:	0f 92       	push	r0
     86e:	0f b6       	in	r0, 0x3f	; 63
     870:	0f 92       	push	r0
     872:	11 24       	eor	r1, r1
     874:	0b b6       	in	r0, 0x3b	; 59
     876:	0f 92       	push	r0
     878:	2f 93       	push	r18
     87a:	3f 93       	push	r19
     87c:	4f 93       	push	r20
     87e:	5f 93       	push	r21
     880:	6f 93       	push	r22
     882:	7f 93       	push	r23
     884:	8f 93       	push	r24
     886:	9f 93       	push	r25
     888:	af 93       	push	r26
     88a:	bf 93       	push	r27
     88c:	ef 93       	push	r30
     88e:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     890:	80 91 78 00 	lds	r24, 0x0078
     894:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     898:	80 91 79 00 	lds	r24, 0x0079
     89c:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     8a0:	20 e0       	ldi	r18, 0x00	; 0
     8a2:	40 e0       	ldi	r20, 0x00	; 0
     8a4:	50 e0       	ldi	r21, 0x00	; 0
     8a6:	60 e0       	ldi	r22, 0x00	; 0
     8a8:	70 e0       	ldi	r23, 0x00	; 0
     8aa:	80 91 a5 08 	lds	r24, 0x08A5
     8ae:	90 91 a6 08 	lds	r25, 0x08A6
     8b2:	b1 d7       	rcall	.+3938   	; 0x1816 <xQueueGenericSendFromISR>
}
     8b4:	ff 91       	pop	r31
     8b6:	ef 91       	pop	r30
     8b8:	bf 91       	pop	r27
     8ba:	af 91       	pop	r26
     8bc:	9f 91       	pop	r25
     8be:	8f 91       	pop	r24
     8c0:	7f 91       	pop	r23
     8c2:	6f 91       	pop	r22
     8c4:	5f 91       	pop	r21
     8c6:	4f 91       	pop	r20
     8c8:	3f 91       	pop	r19
     8ca:	2f 91       	pop	r18
     8cc:	0f 90       	pop	r0
     8ce:	0b be       	out	0x3b, r0	; 59
     8d0:	0f 90       	pop	r0
     8d2:	0f be       	out	0x3f, r0	; 63
     8d4:	0f 90       	pop	r0
     8d6:	1f 90       	pop	r1
     8d8:	18 95       	reti

000008da <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     8da:	8f e8       	ldi	r24, 0x8F	; 143
     8dc:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     8e0:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     8e4:	80 e4       	ldi	r24, 0x40	; 64
     8e6:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     8ea:	43 e0       	ldi	r20, 0x03	; 3
     8ec:	60 e0       	ldi	r22, 0x00	; 0
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	a7 d6       	rcall	.+3406   	; 0x1640 <xQueueGenericCreate>
     8f2:	90 93 a6 08 	sts	0x08A6, r25
     8f6:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	61 d7       	rcall	.+3778   	; 0x17c0 <xQueueCreateMutex>
     8fe:	90 93 a4 08 	sts	0x08A4, r25
     902:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     906:	20 e0       	ldi	r18, 0x00	; 0
     908:	40 e0       	ldi	r20, 0x00	; 0
     90a:	50 e0       	ldi	r21, 0x00	; 0
     90c:	60 e0       	ldi	r22, 0x00	; 0
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	c4 c6       	rjmp	.+3464   	; 0x169a <xQueueGenericSend>
     912:	08 95       	ret

00000914 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     914:	cf 93       	push	r28
     916:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     918:	20 e0       	ldi	r18, 0x00	; 0
     91a:	4f ef       	ldi	r20, 0xFF	; 255
     91c:	5f ef       	ldi	r21, 0xFF	; 255
     91e:	60 e0       	ldi	r22, 0x00	; 0
     920:	70 e0       	ldi	r23, 0x00	; 0
     922:	80 91 a3 08 	lds	r24, 0x08A3
     926:	90 91 a4 08 	lds	r25, 0x08A4
     92a:	af d7       	rcall	.+3934   	; 0x188a <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     92c:	ec e7       	ldi	r30, 0x7C	; 124
     92e:	f0 e0       	ldi	r31, 0x00	; 0
     930:	80 81       	ld	r24, Z
     932:	9c 2f       	mov	r25, r28
     934:	9f 71       	andi	r25, 0x1F	; 31
     936:	80 76       	andi	r24, 0x60	; 96
     938:	89 2b       	or	r24, r25
     93a:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     93c:	eb e7       	ldi	r30, 0x7B	; 123
     93e:	f0 e0       	ldi	r31, 0x00	; 0
     940:	20 81       	ld	r18, Z
     942:	c0 72       	andi	r28, 0x20	; 32
     944:	8c 2f       	mov	r24, r28
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	95 95       	asr	r25
     94a:	87 95       	ror	r24
     94c:	95 95       	asr	r25
     94e:	87 95       	ror	r24
     950:	92 2f       	mov	r25, r18
     952:	90 76       	andi	r25, 0x60	; 96
     954:	89 2b       	or	r24, r25
     956:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     958:	ea e7       	ldi	r30, 0x7A	; 122
     95a:	f0 e0       	ldi	r31, 0x00	; 0
     95c:	80 81       	ld	r24, Z
     95e:	80 64       	ori	r24, 0x40	; 64
     960:	80 83       	st	Z, r24
}
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <myADC_readADC>:

int myADC_readADC(char channel)
{
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     96a:	20 e0       	ldi	r18, 0x00	; 0
     96c:	4f ef       	ldi	r20, 0xFF	; 255
     96e:	5f ef       	ldi	r21, 0xFF	; 255
     970:	60 e0       	ldi	r22, 0x00	; 0
     972:	70 e0       	ldi	r23, 0x00	; 0
     974:	80 91 a5 08 	lds	r24, 0x08A5
     978:	90 91 a6 08 	lds	r25, 0x08A6
     97c:	86 d7       	rcall	.+3852   	; 0x188a <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     97e:	c0 91 a2 08 	lds	r28, 0x08A2
     982:	c3 70       	andi	r28, 0x03	; 3
     984:	d0 e0       	ldi	r29, 0x00	; 0
     986:	dc 2f       	mov	r29, r28
     988:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     98a:	80 91 a1 08 	lds	r24, 0x08A1
     98e:	c8 0f       	add	r28, r24
     990:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     992:	20 e0       	ldi	r18, 0x00	; 0
     994:	40 e0       	ldi	r20, 0x00	; 0
     996:	50 e0       	ldi	r21, 0x00	; 0
     998:	60 e0       	ldi	r22, 0x00	; 0
     99a:	70 e0       	ldi	r23, 0x00	; 0
     99c:	80 91 a3 08 	lds	r24, 0x08A3
     9a0:	90 91 a4 08 	lds	r25, 0x08A4
     9a4:	7a d6       	rcall	.+3316   	; 0x169a <xQueueGenericSend>
	
	return adcReading;
     9a6:	ce 01       	movw	r24, r28
     9a8:	df 91       	pop	r29
     9aa:	cf 91       	pop	r28
     9ac:	08 95       	ret

000009ae <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     9ae:	cf 93       	push	r28
     9b0:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     9b2:	b0 df       	rcall	.-160    	; 0x914 <myADC_startADC>
	return myADC_readADC(channel);
     9b4:	8c 2f       	mov	r24, r28
     9b6:	d7 df       	rcall	.-82     	; 0x966 <myADC_readADC>
}
     9b8:	cf 91       	pop	r28
     9ba:	08 95       	ret

000009bc <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     9bc:	9c 01       	movw	r18, r24
     9be:	26 5f       	subi	r18, 0xF6	; 246
     9c0:	3f 4f       	sbci	r19, 0xFF	; 255
     9c2:	26 17       	cp	r18, r22
     9c4:	37 07       	cpc	r19, r23
     9c6:	44 f0       	brlt	.+16     	; 0x9d8 <detectStairs+0x1c>
     9c8:	24 51       	subi	r18, 0x14	; 20
     9ca:	31 09       	sbc	r19, r1
     9cc:	81 e0       	ldi	r24, 0x01	; 1
     9ce:	62 17       	cp	r22, r18
     9d0:	73 07       	cpc	r23, r19
     9d2:	1c f0       	brlt	.+6      	; 0x9da <detectStairs+0x1e>
     9d4:	80 e0       	ldi	r24, 0x00	; 0
     9d6:	08 95       	ret
	{
		return 1; // stairs found
     9d8:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     9da:	08 95       	ret

000009dc <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     9dc:	0f 93       	push	r16
     9de:	1f 93       	push	r17
     9e0:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     9e2:	83 81       	ldd	r24, Z+3	; 0x03
     9e4:	88 23       	and	r24, r24
     9e6:	39 f0       	breq	.+14     	; 0x9f6 <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     9e8:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     9ea:	e2 e0       	ldi	r30, 0x02	; 2
     9ec:	f1 e0       	ldi	r31, 0x01	; 1
     9ee:	80 81       	ld	r24, Z
     9f0:	80 61       	ori	r24, 0x10	; 16
     9f2:	80 83       	st	Z, r24
     9f4:	4b c0       	rjmp	.+150    	; 0xa8c <obstacleAvoidance+0xb0>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     9f6:	80 81       	ld	r24, Z
     9f8:	88 23       	and	r24, r24
     9fa:	51 f1       	breq	.+84     	; 0xa50 <obstacleAvoidance+0x74>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     9fc:	81 81       	ldd	r24, Z+1	; 0x01
     9fe:	81 11       	cpse	r24, r1
     a00:	0c c0       	rjmp	.+24     	; 0xa1a <obstacleAvoidance+0x3e>
     a02:	82 81       	ldd	r24, Z+2	; 0x02
     a04:	81 11       	cpse	r24, r1
     a06:	18 c0       	rjmp	.+48     	; 0xa38 <obstacleAvoidance+0x5c>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				MOTOR_LEFT_START();
     a08:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     a0a:	a2 e0       	ldi	r26, 0x02	; 2
     a0c:	b1 e0       	ldi	r27, 0x01	; 1
     a0e:	8c 91       	ld	r24, X
     a10:	8f 7e       	andi	r24, 0xEF	; 239
     a12:	8c 93       	st	X, r24
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     a14:	81 81       	ldd	r24, Z+1	; 0x01
     a16:	88 23       	and	r24, r24
     a18:	b1 f1       	breq	.+108    	; 0xa86 <obstacleAvoidance+0xaa>
     a1a:	82 81       	ldd	r24, Z+2	; 0x02
     a1c:	81 11       	cpse	r24, r1
     a1e:	36 c0       	rjmp	.+108    	; 0xa8c <obstacleAvoidance+0xb0>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     a20:	46 1b       	sub	r20, r22
     a22:	57 0b       	sbc	r21, r23
     a24:	49 30       	cpi	r20, 0x09	; 9
     a26:	51 05       	cpc	r21, r1
     a28:	8c f1       	brlt	.+98     	; 0xa8c <obstacleAvoidance+0xb0>
			{
				MOTOR_LEFT_STOP();
     a2a:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     a2c:	e2 e0       	ldi	r30, 0x02	; 2
     a2e:	f1 e0       	ldi	r31, 0x01	; 1
     a30:	80 81       	ld	r24, Z
     a32:	80 61       	ori	r24, 0x10	; 16
     a34:	80 83       	st	Z, r24
     a36:	2a c0       	rjmp	.+84     	; 0xa8c <obstacleAvoidance+0xb0>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     a38:	64 1b       	sub	r22, r20
     a3a:	75 0b       	sbc	r23, r21
     a3c:	69 30       	cpi	r22, 0x09	; 9
     a3e:	71 05       	cpc	r23, r1
     a40:	2c f1       	brlt	.+74     	; 0xa8c <obstacleAvoidance+0xb0>
			{
				MOTOR_LEFT_START();
     a42:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     a44:	e2 e0       	ldi	r30, 0x02	; 2
     a46:	f1 e0       	ldi	r31, 0x01	; 1
     a48:	80 81       	ld	r24, Z
     a4a:	8f 7e       	andi	r24, 0xEF	; 239
     a4c:	80 83       	st	Z, r24
     a4e:	1e c0       	rjmp	.+60     	; 0xa8c <obstacleAvoidance+0xb0>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     a50:	64 31       	cpi	r22, 0x14	; 20
     a52:	71 05       	cpc	r23, r1
     a54:	3c f4       	brge	.+14     	; 0xa64 <obstacleAvoidance+0x88>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     a56:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     a58:	e2 e0       	ldi	r30, 0x02	; 2
     a5a:	f1 e0       	ldi	r31, 0x01	; 1
     a5c:	80 81       	ld	r24, Z
     a5e:	80 61       	ori	r24, 0x10	; 16
     a60:	80 83       	st	Z, r24
     a62:	14 c0       	rjmp	.+40     	; 0xa8c <obstacleAvoidance+0xb0>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     a64:	44 31       	cpi	r20, 0x14	; 20
     a66:	51 05       	cpc	r21, r1
     a68:	3c f4       	brge	.+14     	; 0xa78 <obstacleAvoidance+0x9c>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     a6a:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     a6c:	e2 e0       	ldi	r30, 0x02	; 2
     a6e:	f1 e0       	ldi	r31, 0x01	; 1
     a70:	80 81       	ld	r24, Z
     a72:	8f 7e       	andi	r24, 0xEF	; 239
     a74:	80 83       	st	Z, r24
     a76:	0a c0       	rjmp	.+20     	; 0xa8c <obstacleAvoidance+0xb0>
	}
	else
	{
			MOTOR_LEFT_STOP();
     a78:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     a7a:	e2 e0       	ldi	r30, 0x02	; 2
     a7c:	f1 e0       	ldi	r31, 0x01	; 1
     a7e:	80 81       	ld	r24, Z
     a80:	8f 7e       	andi	r24, 0xEF	; 239
     a82:	80 83       	st	Z, r24
     a84:	03 c0       	rjmp	.+6      	; 0xa8c <obstacleAvoidance+0xb0>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     a86:	82 81       	ldd	r24, Z+2	; 0x02
     a88:	81 11       	cpse	r24, r1
     a8a:	d6 cf       	rjmp	.-84     	; 0xa38 <obstacleAvoidance+0x5c>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     a8c:	1f 91       	pop	r17
     a8e:	0f 91       	pop	r16
     a90:	08 95       	ret

00000a92 <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     a92:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     a94:	85 e0       	ldi	r24, 0x05	; 5
     a96:	db 01       	movw	r26, r22
     a98:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     a9a:	86 e4       	ldi	r24, 0x46	; 70
     a9c:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     a9e:	8c e4       	ldi	r24, 0x4C	; 76
     aa0:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     aa2:	82 e5       	ldi	r24, 0x52	; 82
     aa4:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     aa6:	82 e4       	ldi	r24, 0x42	; 66
     aa8:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     aaa:	84 e5       	ldi	r24, 0x54	; 84
     aac:	84 83       	std	Z+4, r24	; 0x04
     aae:	08 95       	ret

00000ab0 <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     ab0:	af 92       	push	r10
     ab2:	bf 92       	push	r11
     ab4:	cf 92       	push	r12
     ab6:	df 92       	push	r13
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	f6 2e       	mov	r15, r22
     ac4:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     ac6:	86 34       	cpi	r24, 0x46	; 70
     ac8:	91 05       	cpc	r25, r1
     aca:	1c f4       	brge	.+6      	; 0xad2 <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     acc:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     ace:	86 e4       	ldi	r24, 0x46	; 70
     ad0:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     ad2:	2e 31       	cpi	r18, 0x1E	; 30
     ad4:	31 05       	cpc	r19, r1
     ad6:	1c f4       	brge	.+6      	; 0xade <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     ad8:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     ada:	8c e4       	ldi	r24, 0x4C	; 76
     adc:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     ade:	0e 31       	cpi	r16, 0x1E	; 30
     ae0:	11 05       	cpc	r17, r1
     ae2:	1c f4       	brge	.+6      	; 0xaea <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     ae4:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     ae6:	82 e5       	ldi	r24, 0x52	; 82
     ae8:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     aea:	b5 01       	movw	r22, r10
     aec:	c6 01       	movw	r24, r12
     aee:	66 df       	rcall	.-308    	; 0x9bc <detectStairs>
     af0:	88 23       	and	r24, r24
     af2:	19 f0       	breq	.+6      	; 0xafa <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     af4:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     af6:	82 e4       	ldi	r24, 0x42	; 66
     af8:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     afa:	8f 2d       	mov	r24, r15
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	df 90       	pop	r13
     b08:	cf 90       	pop	r12
     b0a:	bf 90       	pop	r11
     b0c:	af 90       	pop	r10
     b0e:	08 95       	ret

00000b10 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     b10:	4e df       	rcall	.-356    	; 0x9ae <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     b12:	bc 01       	movw	r22, r24
     b14:	88 27       	eor	r24, r24
     b16:	77 fd       	sbrc	r23, 7
     b18:	80 95       	com	r24
     b1a:	98 2f       	mov	r25, r24
     b1c:	0e 94 b3 13 	call	0x2766	; 0x2766 <__floatsisf>
     b20:	29 e2       	ldi	r18, 0x29	; 41
     b22:	3c e5       	ldi	r19, 0x5C	; 92
     b24:	4f e6       	ldi	r20, 0x6F	; 111
     b26:	5f eb       	ldi	r21, 0xBF	; 191
     b28:	0e 94 a2 14 	call	0x2944	; 0x2944 <pow>
     b2c:	22 e5       	ldi	r18, 0x52	; 82
     b2e:	38 e6       	ldi	r19, 0x68	; 104
     b30:	46 e2       	ldi	r20, 0x26	; 38
     b32:	56 e4       	ldi	r21, 0x46	; 70
     b34:	0e 94 3f 14 	call	0x287e	; 0x287e <__mulsf3>
     b38:	20 e0       	ldi	r18, 0x00	; 0
     b3a:	30 e0       	ldi	r19, 0x00	; 0
     b3c:	40 e2       	ldi	r20, 0x20	; 32
     b3e:	51 e4       	ldi	r21, 0x41	; 65
     b40:	0e 94 1b 13 	call	0x2636	; 0x2636 <__subsf3>
     b44:	0e 94 80 13 	call	0x2700	; 0x2700 <__fixsfsi>
     b48:	cb 01       	movw	r24, r22
     b4a:	68 3e       	cpi	r22, 0xE8	; 232
     b4c:	23 e0       	ldi	r18, 0x03	; 3
     b4e:	72 07       	cpc	r23, r18
     b50:	14 f0       	brlt	.+4      	; 0xb56 <mySharpIR_Read+0x46>
     b52:	87 ee       	ldi	r24, 0xE7	; 231
     b54:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
}
     b56:	08 95       	ret

00000b58 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     b58:	fb 01       	movw	r30, r22
     b5a:	20 81       	ld	r18, Z
     b5c:	31 81       	ldd	r19, Z+1	; 0x01
     b5e:	50 e0       	ldi	r21, 0x00	; 0
     b60:	b9 01       	movw	r22, r18
     b62:	64 0f       	add	r22, r20
     b64:	75 1f       	adc	r23, r21
     b66:	68 17       	cp	r22, r24
     b68:	79 07       	cpc	r23, r25
     b6a:	4c f0       	brlt	.+18     	; 0xb7e <checkWithinRange+0x26>
     b6c:	24 1b       	sub	r18, r20
     b6e:	35 0b       	sbc	r19, r21
     b70:	41 e0       	ldi	r20, 0x01	; 1
     b72:	82 17       	cp	r24, r18
     b74:	93 07       	cpc	r25, r19
     b76:	0c f0       	brlt	.+2      	; 0xb7a <checkWithinRange+0x22>
     b78:	40 e0       	ldi	r20, 0x00	; 0
     b7a:	84 2f       	mov	r24, r20
     b7c:	08 95       	ret
     b7e:	81 e0       	ldi	r24, 0x01	; 1
}
     b80:	08 95       	ret

00000b82 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     b82:	0f 93       	push	r16
     b84:	1f 93       	push	r17
     b86:	cf 93       	push	r28
     b88:	df 93       	push	r29
     b8a:	8c 01       	movw	r16, r24
     b8c:	eb 01       	movw	r28, r22
	static const char range = 5; // put at header file later...
	static const char CALIBRATE_COUNT = 20; // put at header file later...
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, range) && i == 0)
     b8e:	45 e0       	ldi	r20, 0x05	; 5
     b90:	bc 01       	movw	r22, r24
     b92:	ce 01       	movw	r24, r28
     b94:	e1 df       	rcall	.-62     	; 0xb58 <checkWithinRange>
     b96:	88 23       	and	r24, r24
     b98:	41 f0       	breq	.+16     	; 0xbaa <mySharpIR_ReCalibrate+0x28>
     b9a:	20 91 22 08 	lds	r18, 0x0822
     b9e:	30 91 23 08 	lds	r19, 0x0823
     ba2:	21 15       	cp	r18, r1
     ba4:	31 05       	cpc	r19, r1
     ba6:	69 f4       	brne	.+26     	; 0xbc2 <mySharpIR_ReCalibrate+0x40>
     ba8:	4b c0       	rjmp	.+150    	; 0xc40 <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     baa:	20 91 22 08 	lds	r18, 0x0822
     bae:	30 91 23 08 	lds	r19, 0x0823
     bb2:	21 15       	cp	r18, r1
     bb4:	31 05       	cpc	r19, r1
     bb6:	29 f4       	brne	.+10     	; 0xbc2 <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     bb8:	d0 93 1f 08 	sts	0x081F, r29
     bbc:	c0 93 1e 08 	sts	0x081E, r28
     bc0:	32 c0       	rjmp	.+100    	; 0xc26 <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     bc2:	2a 30       	cpi	r18, 0x0A	; 10
     bc4:	31 05       	cpc	r19, r1
     bc6:	a9 f4       	brne	.+42     	; 0xbf2 <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, range))
     bc8:	45 e0       	ldi	r20, 0x05	; 5
     bca:	6e e1       	ldi	r22, 0x1E	; 30
     bcc:	78 e0       	ldi	r23, 0x08	; 8
     bce:	ce 01       	movw	r24, r28
     bd0:	c3 df       	rcall	.-122    	; 0xb58 <checkWithinRange>
     bd2:	88 23       	and	r24, r24
     bd4:	49 f0       	breq	.+18     	; 0xbe8 <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     bd6:	d0 93 1f 08 	sts	0x081F, r29
     bda:	c0 93 1e 08 	sts	0x081E, r28
			i = 0; // reset to count...
     bde:	10 92 23 08 	sts	0x0823, r1
     be2:	10 92 22 08 	sts	0x0822, r1
     be6:	1f c0       	rjmp	.+62     	; 0xc26 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     be8:	d0 93 21 08 	sts	0x0821, r29
     bec:	c0 93 20 08 	sts	0x0820, r28
     bf0:	1a c0       	rjmp	.+52     	; 0xc26 <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     bf2:	24 31       	cpi	r18, 0x14	; 20
     bf4:	31 05       	cpc	r19, r1
     bf6:	b9 f4       	brne	.+46     	; 0xc26 <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     bf8:	10 92 23 08 	sts	0x0823, r1
     bfc:	10 92 22 08 	sts	0x0822, r1

		if(checkWithinRange(reading, checkReading, range))
     c00:	45 e0       	ldi	r20, 0x05	; 5
     c02:	6e e1       	ldi	r22, 0x1E	; 30
     c04:	78 e0       	ldi	r23, 0x08	; 8
     c06:	ce 01       	movw	r24, r28
     c08:	a7 df       	rcall	.-178    	; 0xb58 <checkWithinRange>
     c0a:	88 23       	and	r24, r24
     c0c:	29 f0       	breq	.+10     	; 0xc18 <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     c0e:	d0 93 1f 08 	sts	0x081F, r29
     c12:	c0 93 1e 08 	sts	0x081E, r28
     c16:	07 c0       	rjmp	.+14     	; 0xc26 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     c18:	80 91 1e 08 	lds	r24, 0x081E
     c1c:	90 91 1f 08 	lds	r25, 0x081F
     c20:	f8 01       	movw	r30, r16
     c22:	91 83       	std	Z+1, r25	; 0x01
     c24:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     c26:	80 91 22 08 	lds	r24, 0x0822
     c2a:	90 91 23 08 	lds	r25, 0x0823
     c2e:	01 96       	adiw	r24, 0x01	; 1
     c30:	64 e1       	ldi	r22, 0x14	; 20
     c32:	70 e0       	ldi	r23, 0x00	; 0
     c34:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__divmodhi4>
     c38:	90 93 23 08 	sts	0x0823, r25
     c3c:	80 93 22 08 	sts	0x0822, r24
}
     c40:	df 91       	pop	r29
     c42:	cf 91       	pop	r28
     c44:	1f 91       	pop	r17
     c46:	0f 91       	pop	r16
     c48:	08 95       	ret

00000c4a <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     c4a:	90 93 ac 08 	sts	0x08AC, r25
     c4e:	80 93 ab 08 	sts	0x08AB, r24
     c52:	fc 01       	movw	r30, r24
     c54:	80 81       	ld	r24, Z
     c56:	91 81       	ldd	r25, Z+1	; 0x01
     c58:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskSuspend>
     c5c:	43 e0       	ldi	r20, 0x03	; 3
     c5e:	60 e0       	ldi	r22, 0x00	; 0
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	ee d4       	rcall	.+2524   	; 0x1640 <xQueueGenericCreate>
     c64:	90 93 a8 08 	sts	0x08A8, r25
     c68:	80 93 a7 08 	sts	0x08A7, r24
     c6c:	43 e0       	ldi	r20, 0x03	; 3
     c6e:	60 e0       	ldi	r22, 0x00	; 0
     c70:	81 e0       	ldi	r24, 0x01	; 1
     c72:	e6 d4       	rcall	.+2508   	; 0x1640 <xQueueGenericCreate>
     c74:	90 93 aa 08 	sts	0x08AA, r25
     c78:	80 93 a9 08 	sts	0x08A9, r24
     c7c:	08 95       	ret

00000c7e <myTimer_Read>:
     c7e:	86 b5       	in	r24, 0x26	; 38
     c80:	08 95       	ret

00000c82 <myTimer_DelayMicro>:
     c82:	46 b5       	in	r20, 0x26	; 38
     c84:	50 e0       	ldi	r21, 0x00	; 0
     c86:	9c 01       	movw	r18, r24
     c88:	99 23       	and	r25, r25
     c8a:	14 f4       	brge	.+4      	; 0xc90 <myTimer_DelayMicro+0xe>
     c8c:	2d 5f       	subi	r18, 0xFD	; 253
     c8e:	3f 4f       	sbci	r19, 0xFF	; 255
     c90:	35 95       	asr	r19
     c92:	27 95       	ror	r18
     c94:	35 95       	asr	r19
     c96:	27 95       	ror	r18
     c98:	24 0f       	add	r18, r20
     c9a:	35 1f       	adc	r19, r21
     c9c:	30 93 03 02 	sts	0x0203, r19
     ca0:	20 93 02 02 	sts	0x0202, r18
     ca4:	e0 91 ab 08 	lds	r30, 0x08AB
     ca8:	f0 91 ac 08 	lds	r31, 0x08AC
     cac:	80 81       	ld	r24, Z
     cae:	91 81       	ldd	r25, Z+1	; 0x01
     cb0:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <vTaskResume>
     cb4:	20 e0       	ldi	r18, 0x00	; 0
     cb6:	42 e0       	ldi	r20, 0x02	; 2
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	60 e0       	ldi	r22, 0x00	; 0
     cbc:	70 e0       	ldi	r23, 0x00	; 0
     cbe:	80 91 a7 08 	lds	r24, 0x08A7
     cc2:	90 91 a8 08 	lds	r25, 0x08A8
     cc6:	e1 c5       	rjmp	.+3010   	; 0x188a <xQueueGenericReceive>
     cc8:	08 95       	ret

00000cca <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     cca:	cf 93       	push	r28
     ccc:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     cce:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     cd0:	c1 11       	cpse	r28, r1
     cd2:	22 c0       	rjmp	.+68     	; 0xd18 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     cd4:	80 91 02 02 	lds	r24, 0x0202
     cd8:	90 91 03 02 	lds	r25, 0x0203
     cdc:	88 38       	cpi	r24, 0x88	; 136
     cde:	93 41       	sbci	r25, 0x13	; 19
     ce0:	51 f0       	breq	.+20     	; 0xcf6 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     ce2:	80 91 02 02 	lds	r24, 0x0202
     ce6:	90 91 03 02 	lds	r25, 0x0203
     cea:	8a 5f       	subi	r24, 0xFA	; 250
     cec:	91 09       	sbc	r25, r1
     cee:	90 93 03 02 	sts	0x0203, r25
     cf2:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     cf6:	80 91 00 02 	lds	r24, 0x0200
     cfa:	90 91 01 02 	lds	r25, 0x0201
     cfe:	88 38       	cpi	r24, 0x88	; 136
     d00:	93 41       	sbci	r25, 0x13	; 19
     d02:	51 f0       	breq	.+20     	; 0xd18 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     d04:	80 91 00 02 	lds	r24, 0x0200
     d08:	90 91 01 02 	lds	r25, 0x0201
     d0c:	8a 5f       	subi	r24, 0xFA	; 250
     d0e:	91 09       	sbc	r25, r1
     d10:	90 93 01 02 	sts	0x0201, r25
     d14:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     d18:	d0 e0       	ldi	r29, 0x00	; 0
     d1a:	80 91 02 02 	lds	r24, 0x0202
     d1e:	90 91 03 02 	lds	r25, 0x0203
     d22:	8c 17       	cp	r24, r28
     d24:	9d 07       	cpc	r25, r29
     d26:	84 f4       	brge	.+32     	; 0xd48 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     d28:	88 e8       	ldi	r24, 0x88	; 136
     d2a:	93 e1       	ldi	r25, 0x13	; 19
     d2c:	90 93 03 02 	sts	0x0203, r25
     d30:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     d34:	20 e0       	ldi	r18, 0x00	; 0
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	50 e0       	ldi	r21, 0x00	; 0
     d3a:	60 e0       	ldi	r22, 0x00	; 0
     d3c:	70 e0       	ldi	r23, 0x00	; 0
     d3e:	80 91 a7 08 	lds	r24, 0x08A7
     d42:	90 91 a8 08 	lds	r25, 0x08A8
     d46:	a9 d4       	rcall	.+2386   	; 0x169a <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     d48:	80 91 00 02 	lds	r24, 0x0200
     d4c:	90 91 01 02 	lds	r25, 0x0201
     d50:	8c 17       	cp	r24, r28
     d52:	9d 07       	cpc	r25, r29
     d54:	84 f4       	brge	.+32     	; 0xd76 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     d56:	88 e8       	ldi	r24, 0x88	; 136
     d58:	93 e1       	ldi	r25, 0x13	; 19
     d5a:	90 93 01 02 	sts	0x0201, r25
     d5e:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     d62:	20 e0       	ldi	r18, 0x00	; 0
     d64:	40 e0       	ldi	r20, 0x00	; 0
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	60 e0       	ldi	r22, 0x00	; 0
     d6a:	70 e0       	ldi	r23, 0x00	; 0
     d6c:	80 91 a9 08 	lds	r24, 0x08A9
     d70:	90 91 aa 08 	lds	r25, 0x08AA
     d74:	92 d4       	rcall	.+2340   	; 0x169a <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     d76:	80 91 02 02 	lds	r24, 0x0202
     d7a:	90 91 03 02 	lds	r25, 0x0203
     d7e:	88 38       	cpi	r24, 0x88	; 136
     d80:	93 41       	sbci	r25, 0x13	; 19
     d82:	79 f4       	brne	.+30     	; 0xda2 <myTimer_DelayChecker+0xd8>
     d84:	80 91 00 02 	lds	r24, 0x0200
     d88:	90 91 01 02 	lds	r25, 0x0201
     d8c:	88 38       	cpi	r24, 0x88	; 136
     d8e:	93 41       	sbci	r25, 0x13	; 19
     d90:	41 f4       	brne	.+16     	; 0xda2 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     d92:	e0 91 ab 08 	lds	r30, 0x08AB
     d96:	f0 91 ac 08 	lds	r31, 0x08AC
     d9a:	80 81       	ld	r24, Z
     d9c:	91 81       	ldd	r25, Z+1	; 0x01
     d9e:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskSuspend>
	}
     da2:	df 91       	pop	r29
     da4:	cf 91       	pop	r28
     da6:	08 95       	ret

00000da8 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     da8:	1f 92       	push	r1
     daa:	0f 92       	push	r0
     dac:	0f b6       	in	r0, 0x3f	; 63
     dae:	0f 92       	push	r0
     db0:	11 24       	eor	r1, r1
     db2:	0b b6       	in	r0, 0x3b	; 59
     db4:	0f 92       	push	r0
     db6:	2f 93       	push	r18
     db8:	3f 93       	push	r19
     dba:	4f 93       	push	r20
     dbc:	5f 93       	push	r21
     dbe:	6f 93       	push	r22
     dc0:	7f 93       	push	r23
     dc2:	8f 93       	push	r24
     dc4:	9f 93       	push	r25
     dc6:	af 93       	push	r26
     dc8:	bf 93       	push	r27
     dca:	ef 93       	push	r30
     dcc:	ff 93       	push	r31
     dce:	60 91 ce 00 	lds	r22, 0x00CE
     dd2:	82 e4       	ldi	r24, 0x42	; 66
     dd4:	99 e0       	ldi	r25, 0x09	; 9
     dd6:	2f d6       	rcall	.+3166   	; 0x1a36 <ringBufferPush>
     dd8:	20 e0       	ldi	r18, 0x00	; 0
     dda:	40 e0       	ldi	r20, 0x00	; 0
     ddc:	50 e0       	ldi	r21, 0x00	; 0
     dde:	60 e0       	ldi	r22, 0x00	; 0
     de0:	70 e0       	ldi	r23, 0x00	; 0
     de2:	80 91 36 09 	lds	r24, 0x0936
     de6:	90 91 37 09 	lds	r25, 0x0937
     dea:	15 d5       	rcall	.+2602   	; 0x1816 <xQueueGenericSendFromISR>
     dec:	82 e4       	ldi	r24, 0x42	; 66
     dee:	99 e0       	ldi	r25, 0x09	; 9
     df0:	39 d6       	rcall	.+3186   	; 0x1a64 <ringBufferFull>
     df2:	ff 91       	pop	r31
     df4:	ef 91       	pop	r30
     df6:	bf 91       	pop	r27
     df8:	af 91       	pop	r26
     dfa:	9f 91       	pop	r25
     dfc:	8f 91       	pop	r24
     dfe:	7f 91       	pop	r23
     e00:	6f 91       	pop	r22
     e02:	5f 91       	pop	r21
     e04:	4f 91       	pop	r20
     e06:	3f 91       	pop	r19
     e08:	2f 91       	pop	r18
     e0a:	0f 90       	pop	r0
     e0c:	0b be       	out	0x3b, r0	; 59
     e0e:	0f 90       	pop	r0
     e10:	0f be       	out	0x3f, r0	; 63
     e12:	0f 90       	pop	r0
     e14:	1f 90       	pop	r1
     e16:	18 95       	reti

00000e18 <__vector_25>:
     e18:	1f 92       	push	r1
     e1a:	0f 92       	push	r0
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	0f 92       	push	r0
     e20:	11 24       	eor	r1, r1
     e22:	0b b6       	in	r0, 0x3b	; 59
     e24:	0f 92       	push	r0
     e26:	2f 93       	push	r18
     e28:	3f 93       	push	r19
     e2a:	4f 93       	push	r20
     e2c:	5f 93       	push	r21
     e2e:	6f 93       	push	r22
     e30:	7f 93       	push	r23
     e32:	8f 93       	push	r24
     e34:	9f 93       	push	r25
     e36:	af 93       	push	r26
     e38:	bf 93       	push	r27
     e3a:	ef 93       	push	r30
     e3c:	ff 93       	push	r31
     e3e:	60 91 c6 00 	lds	r22, 0x00C6
     e42:	8d ec       	ldi	r24, 0xCD	; 205
     e44:	98 e0       	ldi	r25, 0x08	; 8
     e46:	f7 d5       	rcall	.+3054   	; 0x1a36 <ringBufferPush>
     e48:	20 e0       	ldi	r18, 0x00	; 0
     e4a:	40 e0       	ldi	r20, 0x00	; 0
     e4c:	50 e0       	ldi	r21, 0x00	; 0
     e4e:	60 e0       	ldi	r22, 0x00	; 0
     e50:	70 e0       	ldi	r23, 0x00	; 0
     e52:	80 91 36 09 	lds	r24, 0x0936
     e56:	90 91 37 09 	lds	r25, 0x0937
     e5a:	dd d4       	rcall	.+2490   	; 0x1816 <xQueueGenericSendFromISR>
     e5c:	8d ec       	ldi	r24, 0xCD	; 205
     e5e:	98 e0       	ldi	r25, 0x08	; 8
     e60:	01 d6       	rcall	.+3074   	; 0x1a64 <ringBufferFull>
     e62:	ff 91       	pop	r31
     e64:	ef 91       	pop	r30
     e66:	bf 91       	pop	r27
     e68:	af 91       	pop	r26
     e6a:	9f 91       	pop	r25
     e6c:	8f 91       	pop	r24
     e6e:	7f 91       	pop	r23
     e70:	6f 91       	pop	r22
     e72:	5f 91       	pop	r21
     e74:	4f 91       	pop	r20
     e76:	3f 91       	pop	r19
     e78:	2f 91       	pop	r18
     e7a:	0f 90       	pop	r0
     e7c:	0b be       	out	0x3b, r0	; 59
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <__vector_37>:
     e88:	1f 92       	push	r1
     e8a:	0f 92       	push	r0
     e8c:	0f b6       	in	r0, 0x3f	; 63
     e8e:	0f 92       	push	r0
     e90:	11 24       	eor	r1, r1
     e92:	0b b6       	in	r0, 0x3b	; 59
     e94:	0f 92       	push	r0
     e96:	2f 93       	push	r18
     e98:	3f 93       	push	r19
     e9a:	4f 93       	push	r20
     e9c:	5f 93       	push	r21
     e9e:	6f 93       	push	r22
     ea0:	7f 93       	push	r23
     ea2:	8f 93       	push	r24
     ea4:	9f 93       	push	r25
     ea6:	af 93       	push	r26
     ea8:	bf 93       	push	r27
     eaa:	ef 93       	push	r30
     eac:	ff 93       	push	r31
     eae:	88 e3       	ldi	r24, 0x38	; 56
     eb0:	99 e0       	ldi	r25, 0x09	; 9
     eb2:	df d5       	rcall	.+3006   	; 0x1a72 <ringBufferNotEmpty>
     eb4:	88 23       	and	r24, r24
     eb6:	31 f0       	breq	.+12     	; 0xec4 <__vector_37+0x3c>
     eb8:	88 e3       	ldi	r24, 0x38	; 56
     eba:	99 e0       	ldi	r25, 0x09	; 9
     ebc:	aa d5       	rcall	.+2900   	; 0x1a12 <ringBufferPop>
     ebe:	80 93 ce 00 	sts	0x00CE, r24
     ec2:	05 c0       	rjmp	.+10     	; 0xece <__vector_37+0x46>
     ec4:	e9 ec       	ldi	r30, 0xC9	; 201
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	80 81       	ld	r24, Z
     eca:	8f 7d       	andi	r24, 0xDF	; 223
     ecc:	80 83       	st	Z, r24
     ece:	ff 91       	pop	r31
     ed0:	ef 91       	pop	r30
     ed2:	bf 91       	pop	r27
     ed4:	af 91       	pop	r26
     ed6:	9f 91       	pop	r25
     ed8:	8f 91       	pop	r24
     eda:	7f 91       	pop	r23
     edc:	6f 91       	pop	r22
     ede:	5f 91       	pop	r21
     ee0:	4f 91       	pop	r20
     ee2:	3f 91       	pop	r19
     ee4:	2f 91       	pop	r18
     ee6:	0f 90       	pop	r0
     ee8:	0b be       	out	0x3b, r0	; 59
     eea:	0f 90       	pop	r0
     eec:	0f be       	out	0x3f, r0	; 63
     eee:	0f 90       	pop	r0
     ef0:	1f 90       	pop	r1
     ef2:	18 95       	reti

00000ef4 <__vector_26>:
     ef4:	1f 92       	push	r1
     ef6:	0f 92       	push	r0
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	0f 92       	push	r0
     efc:	11 24       	eor	r1, r1
     efe:	0b b6       	in	r0, 0x3b	; 59
     f00:	0f 92       	push	r0
     f02:	2f 93       	push	r18
     f04:	3f 93       	push	r19
     f06:	4f 93       	push	r20
     f08:	5f 93       	push	r21
     f0a:	6f 93       	push	r22
     f0c:	7f 93       	push	r23
     f0e:	8f 93       	push	r24
     f10:	9f 93       	push	r25
     f12:	af 93       	push	r26
     f14:	bf 93       	push	r27
     f16:	ef 93       	push	r30
     f18:	ff 93       	push	r31
     f1a:	8d e3       	ldi	r24, 0x3D	; 61
     f1c:	99 e0       	ldi	r25, 0x09	; 9
     f1e:	a9 d5       	rcall	.+2898   	; 0x1a72 <ringBufferNotEmpty>
     f20:	88 23       	and	r24, r24
     f22:	31 f0       	breq	.+12     	; 0xf30 <__vector_26+0x3c>
     f24:	8d e3       	ldi	r24, 0x3D	; 61
     f26:	99 e0       	ldi	r25, 0x09	; 9
     f28:	74 d5       	rcall	.+2792   	; 0x1a12 <ringBufferPop>
     f2a:	80 93 c6 00 	sts	0x00C6, r24
     f2e:	05 c0       	rjmp	.+10     	; 0xf3a <__vector_26+0x46>
     f30:	e1 ec       	ldi	r30, 0xC1	; 193
     f32:	f0 e0       	ldi	r31, 0x00	; 0
     f34:	80 81       	ld	r24, Z
     f36:	8f 7d       	andi	r24, 0xDF	; 223
     f38:	80 83       	st	Z, r24
     f3a:	ff 91       	pop	r31
     f3c:	ef 91       	pop	r30
     f3e:	bf 91       	pop	r27
     f40:	af 91       	pop	r26
     f42:	9f 91       	pop	r25
     f44:	8f 91       	pop	r24
     f46:	7f 91       	pop	r23
     f48:	6f 91       	pop	r22
     f4a:	5f 91       	pop	r21
     f4c:	4f 91       	pop	r20
     f4e:	3f 91       	pop	r19
     f50:	2f 91       	pop	r18
     f52:	0f 90       	pop	r0
     f54:	0b be       	out	0x3b, r0	; 59
     f56:	0f 90       	pop	r0
     f58:	0f be       	out	0x3f, r0	; 63
     f5a:	0f 90       	pop	r0
     f5c:	1f 90       	pop	r1
     f5e:	18 95       	reti

00000f60 <myUSART_USART0_Init>:
     f60:	10 92 c5 00 	sts	0x00C5, r1
     f64:	87 e6       	ldi	r24, 0x67	; 103
     f66:	80 93 c4 00 	sts	0x00C4, r24
     f6a:	88 eb       	ldi	r24, 0xB8	; 184
     f6c:	80 93 c1 00 	sts	0x00C1, r24
     f70:	86 e0       	ldi	r24, 0x06	; 6
     f72:	80 93 c2 00 	sts	0x00C2, r24
     f76:	40 e2       	ldi	r20, 0x20	; 32
     f78:	64 ef       	ldi	r22, 0xF4	; 244
     f7a:	78 e0       	ldi	r23, 0x08	; 8
     f7c:	8d ec       	ldi	r24, 0xCD	; 205
     f7e:	98 e0       	ldi	r25, 0x08	; 8
     f80:	37 d5       	rcall	.+2670   	; 0x19f0 <ringBufferInit>
     f82:	40 e2       	ldi	r20, 0x20	; 32
     f84:	62 ed       	ldi	r22, 0xD2	; 210
     f86:	78 e0       	ldi	r23, 0x08	; 8
     f88:	8d e3       	ldi	r24, 0x3D	; 61
     f8a:	99 e0       	ldi	r25, 0x09	; 9
     f8c:	31 d5       	rcall	.+2658   	; 0x19f0 <ringBufferInit>
     f8e:	43 e0       	ldi	r20, 0x03	; 3
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	81 e0       	ldi	r24, 0x01	; 1
     f94:	55 d3       	rcall	.+1706   	; 0x1640 <xQueueGenericCreate>
     f96:	90 93 35 09 	sts	0x0935, r25
     f9a:	80 93 34 09 	sts	0x0934, r24
     f9e:	08 95       	ret

00000fa0 <myUSART_USART1_Init>:
     fa0:	10 92 cd 00 	sts	0x00CD, r1
     fa4:	87 e6       	ldi	r24, 0x67	; 103
     fa6:	80 93 cc 00 	sts	0x00CC, r24
     faa:	88 eb       	ldi	r24, 0xB8	; 184
     fac:	80 93 c9 00 	sts	0x00C9, r24
     fb0:	86 e0       	ldi	r24, 0x06	; 6
     fb2:	80 93 ca 00 	sts	0x00CA, r24
     fb6:	40 e2       	ldi	r20, 0x20	; 32
     fb8:	6d ea       	ldi	r22, 0xAD	; 173
     fba:	78 e0       	ldi	r23, 0x08	; 8
     fbc:	82 e4       	ldi	r24, 0x42	; 66
     fbe:	99 e0       	ldi	r25, 0x09	; 9
     fc0:	17 d5       	rcall	.+2606   	; 0x19f0 <ringBufferInit>
     fc2:	40 e2       	ldi	r20, 0x20	; 32
     fc4:	64 e1       	ldi	r22, 0x14	; 20
     fc6:	79 e0       	ldi	r23, 0x09	; 9
     fc8:	88 e3       	ldi	r24, 0x38	; 56
     fca:	99 e0       	ldi	r25, 0x09	; 9
     fcc:	11 d5       	rcall	.+2594   	; 0x19f0 <ringBufferInit>
     fce:	43 e0       	ldi	r20, 0x03	; 3
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	35 d3       	rcall	.+1642   	; 0x1640 <xQueueGenericCreate>
     fd6:	90 93 37 09 	sts	0x0937, r25
     fda:	80 93 36 09 	sts	0x0936, r24
     fde:	43 e0       	ldi	r20, 0x03	; 3
     fe0:	60 e0       	ldi	r22, 0x00	; 0
     fe2:	81 e0       	ldi	r24, 0x01	; 1
     fe4:	2d d3       	rcall	.+1626   	; 0x1640 <xQueueGenericCreate>
     fe6:	90 93 f3 08 	sts	0x08F3, r25
     fea:	80 93 f2 08 	sts	0x08F2, r24
     fee:	08 95       	ret

00000ff0 <myUSART_transmitUSART0_c>:
     ff0:	cf 93       	push	r28
     ff2:	c8 2f       	mov	r28, r24
     ff4:	8d e3       	ldi	r24, 0x3D	; 61
     ff6:	99 e0       	ldi	r25, 0x09	; 9
     ff8:	35 d5       	rcall	.+2666   	; 0x1a64 <ringBufferFull>
     ffa:	81 11       	cpse	r24, r1
     ffc:	fb cf       	rjmp	.-10     	; 0xff4 <myUSART_transmitUSART0_c+0x4>
     ffe:	6c 2f       	mov	r22, r28
    1000:	8d e3       	ldi	r24, 0x3D	; 61
    1002:	99 e0       	ldi	r25, 0x09	; 9
    1004:	18 d5       	rcall	.+2608   	; 0x1a36 <ringBufferPush>
    1006:	e1 ec       	ldi	r30, 0xC1	; 193
    1008:	f0 e0       	ldi	r31, 0x00	; 0
    100a:	80 81       	ld	r24, Z
    100c:	80 62       	ori	r24, 0x20	; 32
    100e:	80 83       	st	Z, r24
    1010:	e0 ec       	ldi	r30, 0xC0	; 192
    1012:	f0 e0       	ldi	r31, 0x00	; 0
    1014:	80 81       	ld	r24, Z
    1016:	80 64       	ori	r24, 0x40	; 64
    1018:	80 83       	st	Z, r24
    101a:	cf 91       	pop	r28
    101c:	08 95       	ret

0000101e <myUSART_transmitUSART1_c>:
    101e:	cf 93       	push	r28
    1020:	c8 2f       	mov	r28, r24
    1022:	88 e3       	ldi	r24, 0x38	; 56
    1024:	99 e0       	ldi	r25, 0x09	; 9
    1026:	1e d5       	rcall	.+2620   	; 0x1a64 <ringBufferFull>
    1028:	81 11       	cpse	r24, r1
    102a:	fb cf       	rjmp	.-10     	; 0x1022 <myUSART_transmitUSART1_c+0x4>
    102c:	6c 2f       	mov	r22, r28
    102e:	88 e3       	ldi	r24, 0x38	; 56
    1030:	99 e0       	ldi	r25, 0x09	; 9
    1032:	01 d5       	rcall	.+2562   	; 0x1a36 <ringBufferPush>
    1034:	e9 ec       	ldi	r30, 0xC9	; 201
    1036:	f0 e0       	ldi	r31, 0x00	; 0
    1038:	80 81       	ld	r24, Z
    103a:	80 62       	ori	r24, 0x20	; 32
    103c:	80 83       	st	Z, r24
    103e:	e8 ec       	ldi	r30, 0xC8	; 200
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 81       	ld	r24, Z
    1044:	80 64       	ori	r24, 0x40	; 64
    1046:	80 83       	st	Z, r24
    1048:	cf 91       	pop	r28
    104a:	08 95       	ret

0000104c <myUSART_transmitUSART1>:
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	ec 01       	movw	r28, r24
    1052:	88 81       	ld	r24, Y
    1054:	88 23       	and	r24, r24
    1056:	29 f0       	breq	.+10     	; 0x1062 <myUSART_transmitUSART1+0x16>
    1058:	21 96       	adiw	r28, 0x01	; 1
    105a:	e1 df       	rcall	.-62     	; 0x101e <myUSART_transmitUSART1_c>
    105c:	89 91       	ld	r24, Y+
    105e:	81 11       	cpse	r24, r1
    1060:	fc cf       	rjmp	.-8      	; 0x105a <myUSART_transmitUSART1+0xe>
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	08 95       	ret

00001068 <myUSART_transmitUSART0>:
    1068:	cf 93       	push	r28
    106a:	df 93       	push	r29
    106c:	ec 01       	movw	r28, r24
    106e:	88 81       	ld	r24, Y
    1070:	88 23       	and	r24, r24
    1072:	29 f0       	breq	.+10     	; 0x107e <myUSART_transmitUSART0+0x16>
    1074:	21 96       	adiw	r28, 0x01	; 1
    1076:	bc df       	rcall	.-136    	; 0xff0 <myUSART_transmitUSART0_c>
    1078:	89 91       	ld	r24, Y+
    107a:	81 11       	cpse	r24, r1
    107c:	fc cf       	rjmp	.-8      	; 0x1076 <myUSART_transmitUSART0+0xe>
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	08 95       	ret

00001084 <myUSART_receiveUSART1>:
    1084:	cf 93       	push	r28
    1086:	20 e0       	ldi	r18, 0x00	; 0
    1088:	4f ef       	ldi	r20, 0xFF	; 255
    108a:	5f ef       	ldi	r21, 0xFF	; 255
    108c:	60 e0       	ldi	r22, 0x00	; 0
    108e:	70 e0       	ldi	r23, 0x00	; 0
    1090:	80 91 36 09 	lds	r24, 0x0936
    1094:	90 91 37 09 	lds	r25, 0x0937
    1098:	f8 d3       	rcall	.+2032   	; 0x188a <xQueueGenericReceive>
    109a:	82 e4       	ldi	r24, 0x42	; 66
    109c:	99 e0       	ldi	r25, 0x09	; 9
    109e:	b9 d4       	rcall	.+2418   	; 0x1a12 <ringBufferPop>
    10a0:	c8 2f       	mov	r28, r24
    10a2:	82 e4       	ldi	r24, 0x42	; 66
    10a4:	99 e0       	ldi	r25, 0x09	; 9
    10a6:	e5 d4       	rcall	.+2506   	; 0x1a72 <ringBufferNotEmpty>
    10a8:	88 23       	and	r24, r24
    10aa:	51 f0       	breq	.+20     	; 0x10c0 <myUSART_receiveUSART1+0x3c>
    10ac:	20 e0       	ldi	r18, 0x00	; 0
    10ae:	40 e0       	ldi	r20, 0x00	; 0
    10b0:	50 e0       	ldi	r21, 0x00	; 0
    10b2:	60 e0       	ldi	r22, 0x00	; 0
    10b4:	70 e0       	ldi	r23, 0x00	; 0
    10b6:	80 91 36 09 	lds	r24, 0x0936
    10ba:	90 91 37 09 	lds	r25, 0x0937
    10be:	ed d2       	rcall	.+1498   	; 0x169a <xQueueGenericSend>
    10c0:	8c 2f       	mov	r24, r28
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <myUSART_waitForHandshake>:
    10c6:	de df       	rcall	.-68     	; 0x1084 <myUSART_receiveUSART1>
    10c8:	86 31       	cpi	r24, 0x16	; 22
    10ca:	51 f4       	brne	.+20     	; 0x10e0 <myUSART_waitForHandshake+0x1a>
    10cc:	85 e0       	ldi	r24, 0x05	; 5
    10ce:	a7 df       	rcall	.-178    	; 0x101e <myUSART_transmitUSART1_c>
    10d0:	d9 df       	rcall	.-78     	; 0x1084 <myUSART_receiveUSART1>
    10d2:	91 e0       	ldi	r25, 0x01	; 1
    10d4:	86 31       	cpi	r24, 0x16	; 22
    10d6:	09 f4       	brne	.+2      	; 0x10da <myUSART_waitForHandshake+0x14>
    10d8:	90 e0       	ldi	r25, 0x00	; 0
    10da:	89 2f       	mov	r24, r25
    10dc:	81 95       	neg	r24
    10de:	08 95       	ret
    10e0:	8f ef       	ldi	r24, 0xFF	; 255
    10e2:	08 95       	ret

000010e4 <myUSART_completeHandShake>:
    10e4:	20 e0       	ldi	r18, 0x00	; 0
    10e6:	40 e0       	ldi	r20, 0x00	; 0
    10e8:	50 e0       	ldi	r21, 0x00	; 0
    10ea:	60 e0       	ldi	r22, 0x00	; 0
    10ec:	70 e0       	ldi	r23, 0x00	; 0
    10ee:	80 91 f2 08 	lds	r24, 0x08F2
    10f2:	90 91 f3 08 	lds	r25, 0x08F3
    10f6:	d1 c2       	rjmp	.+1442   	; 0x169a <xQueueGenericSend>
    10f8:	08 95       	ret

000010fa <myUSART_receiveHandShakeAck>:
    10fa:	91 e0       	ldi	r25, 0x01	; 1
    10fc:	85 30       	cpi	r24, 0x05	; 5
    10fe:	09 f0       	breq	.+2      	; 0x1102 <myUSART_receiveHandShakeAck+0x8>
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	89 2f       	mov	r24, r25
    1104:	08 95       	ret

00001106 <myUSART_receiveHandShakeStart>:
    1106:	91 e0       	ldi	r25, 0x01	; 1
    1108:	86 31       	cpi	r24, 0x16	; 22
    110a:	09 f0       	breq	.+2      	; 0x110e <myUSART_receiveHandShakeStart+0x8>
    110c:	90 e0       	ldi	r25, 0x00	; 0
    110e:	89 2f       	mov	r24, r25
    1110:	08 95       	ret

00001112 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1112:	91 e0       	ldi	r25, 0x01	; 1
    1114:	86 30       	cpi	r24, 0x06	; 6
    1116:	09 f0       	breq	.+2      	; 0x111a <myUSART_receiveMessageACK+0x8>
    1118:	90 e0       	ldi	r25, 0x00	; 0
}
    111a:	89 2f       	mov	r24, r25
    111c:	08 95       	ret

0000111e <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    111e:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    1120:	20 e0       	ldi	r18, 0x00	; 0
    1122:	4f ef       	ldi	r20, 0xFF	; 255
    1124:	5f ef       	ldi	r21, 0xFF	; 255
    1126:	60 e0       	ldi	r22, 0x00	; 0
    1128:	70 e0       	ldi	r23, 0x00	; 0
    112a:	80 91 36 09 	lds	r24, 0x0936
    112e:	90 91 37 09 	lds	r25, 0x0937
    1132:	ab d3       	rcall	.+1878   	; 0x188a <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    1134:	82 e4       	ldi	r24, 0x42	; 66
    1136:	99 e0       	ldi	r25, 0x09	; 9
    1138:	62 d4       	rcall	.+2244   	; 0x19fe <ringBufferPeek>
    113a:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    113c:	82 e4       	ldi	r24, 0x42	; 66
    113e:	99 e0       	ldi	r25, 0x09	; 9
    1140:	98 d4       	rcall	.+2352   	; 0x1a72 <ringBufferNotEmpty>
    1142:	88 23       	and	r24, r24
    1144:	51 f0       	breq	.+20     	; 0x115a <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    1146:	20 e0       	ldi	r18, 0x00	; 0
    1148:	40 e0       	ldi	r20, 0x00	; 0
    114a:	50 e0       	ldi	r21, 0x00	; 0
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	70 e0       	ldi	r23, 0x00	; 0
    1150:	80 91 36 09 	lds	r24, 0x0936
    1154:	90 91 37 09 	lds	r25, 0x0937
    1158:	a0 d2       	rcall	.+1344   	; 0x169a <xQueueGenericSend>
	}
	
	return data;
    115a:	8c 2f       	mov	r24, r28
    115c:	cf 91       	pop	r28
    115e:	08 95       	ret

00001160 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1160:	31 e1       	ldi	r19, 0x11	; 17
    1162:	fc 01       	movw	r30, r24
    1164:	30 83       	st	Z, r19
    1166:	31 97       	sbiw	r30, 0x01	; 1
    1168:	22 e2       	ldi	r18, 0x22	; 34
    116a:	20 83       	st	Z, r18
    116c:	31 97       	sbiw	r30, 0x01	; 1
    116e:	a3 e3       	ldi	r26, 0x33	; 51
    1170:	a0 83       	st	Z, r26
    1172:	31 97       	sbiw	r30, 0x01	; 1
    1174:	60 83       	st	Z, r22
    1176:	31 97       	sbiw	r30, 0x01	; 1
    1178:	70 83       	st	Z, r23
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	10 82       	st	Z, r1
    117e:	31 97       	sbiw	r30, 0x01	; 1
    1180:	10 82       	st	Z, r1
    1182:	31 97       	sbiw	r30, 0x01	; 1
    1184:	60 e8       	ldi	r22, 0x80	; 128
    1186:	60 83       	st	Z, r22
    1188:	31 97       	sbiw	r30, 0x01	; 1
    118a:	10 82       	st	Z, r1
    118c:	31 97       	sbiw	r30, 0x01	; 1
    118e:	10 82       	st	Z, r1
    1190:	31 97       	sbiw	r30, 0x01	; 1
    1192:	10 82       	st	Z, r1
    1194:	31 97       	sbiw	r30, 0x01	; 1
    1196:	62 e0       	ldi	r22, 0x02	; 2
    1198:	60 83       	st	Z, r22
    119a:	31 97       	sbiw	r30, 0x01	; 1
    119c:	63 e0       	ldi	r22, 0x03	; 3
    119e:	60 83       	st	Z, r22
    11a0:	31 97       	sbiw	r30, 0x01	; 1
    11a2:	64 e0       	ldi	r22, 0x04	; 4
    11a4:	60 83       	st	Z, r22
    11a6:	31 97       	sbiw	r30, 0x01	; 1
    11a8:	65 e0       	ldi	r22, 0x05	; 5
    11aa:	60 83       	st	Z, r22
    11ac:	31 97       	sbiw	r30, 0x01	; 1
    11ae:	66 e0       	ldi	r22, 0x06	; 6
    11b0:	60 83       	st	Z, r22
    11b2:	31 97       	sbiw	r30, 0x01	; 1
    11b4:	67 e0       	ldi	r22, 0x07	; 7
    11b6:	60 83       	st	Z, r22
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	68 e0       	ldi	r22, 0x08	; 8
    11bc:	60 83       	st	Z, r22
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	69 e0       	ldi	r22, 0x09	; 9
    11c2:	60 83       	st	Z, r22
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	60 e1       	ldi	r22, 0x10	; 16
    11c8:	60 83       	st	Z, r22
    11ca:	31 97       	sbiw	r30, 0x01	; 1
    11cc:	30 83       	st	Z, r19
    11ce:	31 97       	sbiw	r30, 0x01	; 1
    11d0:	32 e1       	ldi	r19, 0x12	; 18
    11d2:	30 83       	st	Z, r19
    11d4:	31 97       	sbiw	r30, 0x01	; 1
    11d6:	33 e1       	ldi	r19, 0x13	; 19
    11d8:	30 83       	st	Z, r19
    11da:	31 97       	sbiw	r30, 0x01	; 1
    11dc:	34 e1       	ldi	r19, 0x14	; 20
    11de:	30 83       	st	Z, r19
    11e0:	31 97       	sbiw	r30, 0x01	; 1
    11e2:	35 e1       	ldi	r19, 0x15	; 21
    11e4:	30 83       	st	Z, r19
    11e6:	31 97       	sbiw	r30, 0x01	; 1
    11e8:	36 e1       	ldi	r19, 0x16	; 22
    11ea:	30 83       	st	Z, r19
    11ec:	31 97       	sbiw	r30, 0x01	; 1
    11ee:	37 e1       	ldi	r19, 0x17	; 23
    11f0:	30 83       	st	Z, r19
    11f2:	31 97       	sbiw	r30, 0x01	; 1
    11f4:	38 e1       	ldi	r19, 0x18	; 24
    11f6:	30 83       	st	Z, r19
    11f8:	31 97       	sbiw	r30, 0x01	; 1
    11fa:	39 e1       	ldi	r19, 0x19	; 25
    11fc:	30 83       	st	Z, r19
    11fe:	31 97       	sbiw	r30, 0x01	; 1
    1200:	30 e2       	ldi	r19, 0x20	; 32
    1202:	30 83       	st	Z, r19
    1204:	31 97       	sbiw	r30, 0x01	; 1
    1206:	31 e2       	ldi	r19, 0x21	; 33
    1208:	30 83       	st	Z, r19
    120a:	31 97       	sbiw	r30, 0x01	; 1
    120c:	20 83       	st	Z, r18
    120e:	31 97       	sbiw	r30, 0x01	; 1
    1210:	23 e2       	ldi	r18, 0x23	; 35
    1212:	20 83       	st	Z, r18
    1214:	31 97       	sbiw	r30, 0x01	; 1
    1216:	40 83       	st	Z, r20
    1218:	31 97       	sbiw	r30, 0x01	; 1
    121a:	50 83       	st	Z, r21
    121c:	31 97       	sbiw	r30, 0x01	; 1
    121e:	26 e2       	ldi	r18, 0x26	; 38
    1220:	20 83       	st	Z, r18
    1222:	31 97       	sbiw	r30, 0x01	; 1
    1224:	27 e2       	ldi	r18, 0x27	; 39
    1226:	20 83       	st	Z, r18
    1228:	31 97       	sbiw	r30, 0x01	; 1
    122a:	28 e2       	ldi	r18, 0x28	; 40
    122c:	20 83       	st	Z, r18
    122e:	31 97       	sbiw	r30, 0x01	; 1
    1230:	29 e2       	ldi	r18, 0x29	; 41
    1232:	20 83       	st	Z, r18
    1234:	31 97       	sbiw	r30, 0x01	; 1
    1236:	20 e3       	ldi	r18, 0x30	; 48
    1238:	20 83       	st	Z, r18
    123a:	31 97       	sbiw	r30, 0x01	; 1
    123c:	21 e3       	ldi	r18, 0x31	; 49
    123e:	20 83       	st	Z, r18
    1240:	89 97       	sbiw	r24, 0x29	; 41
    1242:	08 95       	ret

00001244 <xPortStartScheduler>:
    1244:	82 e0       	ldi	r24, 0x02	; 2
    1246:	84 bd       	out	0x24, r24	; 36
    1248:	16 bc       	out	0x26, r1	; 38
    124a:	80 e3       	ldi	r24, 0x30	; 48
    124c:	87 bd       	out	0x27, r24	; 39
    124e:	ee e6       	ldi	r30, 0x6E	; 110
    1250:	f0 e0       	ldi	r31, 0x00	; 0
    1252:	80 81       	ld	r24, Z
    1254:	82 60       	ori	r24, 0x02	; 2
    1256:	80 83       	st	Z, r24
    1258:	83 e0       	ldi	r24, 0x03	; 3
    125a:	85 bd       	out	0x25, r24	; 37
    125c:	a0 91 8d 08 	lds	r26, 0x088D
    1260:	b0 91 8e 08 	lds	r27, 0x088E
    1264:	cd 91       	ld	r28, X+
    1266:	cd bf       	out	0x3d, r28	; 61
    1268:	dd 91       	ld	r29, X+
    126a:	de bf       	out	0x3e, r29	; 62
    126c:	ff 91       	pop	r31
    126e:	ef 91       	pop	r30
    1270:	df 91       	pop	r29
    1272:	cf 91       	pop	r28
    1274:	bf 91       	pop	r27
    1276:	af 91       	pop	r26
    1278:	9f 91       	pop	r25
    127a:	8f 91       	pop	r24
    127c:	7f 91       	pop	r23
    127e:	6f 91       	pop	r22
    1280:	5f 91       	pop	r21
    1282:	4f 91       	pop	r20
    1284:	3f 91       	pop	r19
    1286:	2f 91       	pop	r18
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	ff 90       	pop	r15
    128e:	ef 90       	pop	r14
    1290:	df 90       	pop	r13
    1292:	cf 90       	pop	r12
    1294:	bf 90       	pop	r11
    1296:	af 90       	pop	r10
    1298:	9f 90       	pop	r9
    129a:	8f 90       	pop	r8
    129c:	7f 90       	pop	r7
    129e:	6f 90       	pop	r6
    12a0:	5f 90       	pop	r5
    12a2:	4f 90       	pop	r4
    12a4:	3f 90       	pop	r3
    12a6:	2f 90       	pop	r2
    12a8:	1f 90       	pop	r1
    12aa:	0f 90       	pop	r0
    12ac:	0c be       	out	0x3c, r0	; 60
    12ae:	0f 90       	pop	r0
    12b0:	0b be       	out	0x3b, r0	; 59
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	0f 90       	pop	r0
    12b8:	08 95       	ret
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	08 95       	ret

000012be <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12be:	0f 92       	push	r0
    12c0:	0f b6       	in	r0, 0x3f	; 63
    12c2:	f8 94       	cli
    12c4:	0f 92       	push	r0
    12c6:	0b b6       	in	r0, 0x3b	; 59
    12c8:	0f 92       	push	r0
    12ca:	0c b6       	in	r0, 0x3c	; 60
    12cc:	0f 92       	push	r0
    12ce:	1f 92       	push	r1
    12d0:	11 24       	eor	r1, r1
    12d2:	2f 92       	push	r2
    12d4:	3f 92       	push	r3
    12d6:	4f 92       	push	r4
    12d8:	5f 92       	push	r5
    12da:	6f 92       	push	r6
    12dc:	7f 92       	push	r7
    12de:	8f 92       	push	r8
    12e0:	9f 92       	push	r9
    12e2:	af 92       	push	r10
    12e4:	bf 92       	push	r11
    12e6:	cf 92       	push	r12
    12e8:	df 92       	push	r13
    12ea:	ef 92       	push	r14
    12ec:	ff 92       	push	r15
    12ee:	0f 93       	push	r16
    12f0:	1f 93       	push	r17
    12f2:	2f 93       	push	r18
    12f4:	3f 93       	push	r19
    12f6:	4f 93       	push	r20
    12f8:	5f 93       	push	r21
    12fa:	6f 93       	push	r22
    12fc:	7f 93       	push	r23
    12fe:	8f 93       	push	r24
    1300:	9f 93       	push	r25
    1302:	af 93       	push	r26
    1304:	bf 93       	push	r27
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	ef 93       	push	r30
    130c:	ff 93       	push	r31
    130e:	a0 91 8d 08 	lds	r26, 0x088D
    1312:	b0 91 8e 08 	lds	r27, 0x088E
    1316:	0d b6       	in	r0, 0x3d	; 61
    1318:	0d 92       	st	X+, r0
    131a:	0e b6       	in	r0, 0x3e	; 62
    131c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    131e:	77 d7       	rcall	.+3822   	; 0x220e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1320:	a0 91 8d 08 	lds	r26, 0x088D
    1324:	b0 91 8e 08 	lds	r27, 0x088E
    1328:	cd 91       	ld	r28, X+
    132a:	cd bf       	out	0x3d, r28	; 61
    132c:	dd 91       	ld	r29, X+
    132e:	de bf       	out	0x3e, r29	; 62
    1330:	ff 91       	pop	r31
    1332:	ef 91       	pop	r30
    1334:	df 91       	pop	r29
    1336:	cf 91       	pop	r28
    1338:	bf 91       	pop	r27
    133a:	af 91       	pop	r26
    133c:	9f 91       	pop	r25
    133e:	8f 91       	pop	r24
    1340:	7f 91       	pop	r23
    1342:	6f 91       	pop	r22
    1344:	5f 91       	pop	r21
    1346:	4f 91       	pop	r20
    1348:	3f 91       	pop	r19
    134a:	2f 91       	pop	r18
    134c:	1f 91       	pop	r17
    134e:	0f 91       	pop	r16
    1350:	ff 90       	pop	r15
    1352:	ef 90       	pop	r14
    1354:	df 90       	pop	r13
    1356:	cf 90       	pop	r12
    1358:	bf 90       	pop	r11
    135a:	af 90       	pop	r10
    135c:	9f 90       	pop	r9
    135e:	8f 90       	pop	r8
    1360:	7f 90       	pop	r7
    1362:	6f 90       	pop	r6
    1364:	5f 90       	pop	r5
    1366:	4f 90       	pop	r4
    1368:	3f 90       	pop	r3
    136a:	2f 90       	pop	r2
    136c:	1f 90       	pop	r1
    136e:	0f 90       	pop	r0
    1370:	0c be       	out	0x3c, r0	; 60
    1372:	0f 90       	pop	r0
    1374:	0b be       	out	0x3b, r0	; 59
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    137c:	08 95       	ret

0000137e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    137e:	0f 92       	push	r0
    1380:	0f b6       	in	r0, 0x3f	; 63
    1382:	f8 94       	cli
    1384:	0f 92       	push	r0
    1386:	0b b6       	in	r0, 0x3b	; 59
    1388:	0f 92       	push	r0
    138a:	0c b6       	in	r0, 0x3c	; 60
    138c:	0f 92       	push	r0
    138e:	1f 92       	push	r1
    1390:	11 24       	eor	r1, r1
    1392:	2f 92       	push	r2
    1394:	3f 92       	push	r3
    1396:	4f 92       	push	r4
    1398:	5f 92       	push	r5
    139a:	6f 92       	push	r6
    139c:	7f 92       	push	r7
    139e:	8f 92       	push	r8
    13a0:	9f 92       	push	r9
    13a2:	af 92       	push	r10
    13a4:	bf 92       	push	r11
    13a6:	cf 92       	push	r12
    13a8:	df 92       	push	r13
    13aa:	ef 92       	push	r14
    13ac:	ff 92       	push	r15
    13ae:	0f 93       	push	r16
    13b0:	1f 93       	push	r17
    13b2:	2f 93       	push	r18
    13b4:	3f 93       	push	r19
    13b6:	4f 93       	push	r20
    13b8:	5f 93       	push	r21
    13ba:	6f 93       	push	r22
    13bc:	7f 93       	push	r23
    13be:	8f 93       	push	r24
    13c0:	9f 93       	push	r25
    13c2:	af 93       	push	r26
    13c4:	bf 93       	push	r27
    13c6:	cf 93       	push	r28
    13c8:	df 93       	push	r29
    13ca:	ef 93       	push	r30
    13cc:	ff 93       	push	r31
    13ce:	a0 91 8d 08 	lds	r26, 0x088D
    13d2:	b0 91 8e 08 	lds	r27, 0x088E
    13d6:	0d b6       	in	r0, 0x3d	; 61
    13d8:	0d 92       	st	X+, r0
    13da:	0e b6       	in	r0, 0x3e	; 62
    13dc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    13de:	45 d5       	rcall	.+2698   	; 0x1e6a <xTaskIncrementTick>
    13e0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    13e2:	15 d7       	rcall	.+3626   	; 0x220e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    13e4:	a0 91 8d 08 	lds	r26, 0x088D
    13e8:	b0 91 8e 08 	lds	r27, 0x088E
    13ec:	cd 91       	ld	r28, X+
    13ee:	cd bf       	out	0x3d, r28	; 61
    13f0:	dd 91       	ld	r29, X+
    13f2:	de bf       	out	0x3e, r29	; 62
    13f4:	ff 91       	pop	r31
    13f6:	ef 91       	pop	r30
    13f8:	df 91       	pop	r29
    13fa:	cf 91       	pop	r28
    13fc:	bf 91       	pop	r27
    13fe:	af 91       	pop	r26
    1400:	9f 91       	pop	r25
    1402:	8f 91       	pop	r24
    1404:	7f 91       	pop	r23
    1406:	6f 91       	pop	r22
    1408:	5f 91       	pop	r21
    140a:	4f 91       	pop	r20
    140c:	3f 91       	pop	r19
    140e:	2f 91       	pop	r18
    1410:	1f 91       	pop	r17
    1412:	0f 91       	pop	r16
    1414:	ff 90       	pop	r15
    1416:	ef 90       	pop	r14
    1418:	df 90       	pop	r13
    141a:	cf 90       	pop	r12
    141c:	bf 90       	pop	r11
    141e:	af 90       	pop	r10
    1420:	9f 90       	pop	r9
    1422:	8f 90       	pop	r8
    1424:	7f 90       	pop	r7
    1426:	6f 90       	pop	r6
    1428:	5f 90       	pop	r5
    142a:	4f 90       	pop	r4
    142c:	3f 90       	pop	r3
    142e:	2f 90       	pop	r2
    1430:	1f 90       	pop	r1
    1432:	0f 90       	pop	r0
    1434:	0c be       	out	0x3c, r0	; 60
    1436:	0f 90       	pop	r0
    1438:	0b be       	out	0x3b, r0	; 59
    143a:	0f 90       	pop	r0
    143c:	0f be       	out	0x3f, r0	; 63
    143e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1440:	08 95       	ret

00001442 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1442:	9d df       	rcall	.-198    	; 0x137e <vPortYieldFromTick>
		 asm volatile ("reti");
    1444:	18 95       	reti

00001446 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1446:	1f 93       	push	r17
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	ec 01       	movw	r28, r24
    144e:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1450:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1452:	81 11       	cpse	r24, r1
    1454:	0c c0       	rjmp	.+24     	; 0x146e <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1456:	88 81       	ld	r24, Y
    1458:	99 81       	ldd	r25, Y+1	; 0x01
    145a:	89 2b       	or	r24, r25
    145c:	09 f0       	breq	.+2      	; 0x1460 <prvCopyDataToQueue+0x1a>
    145e:	47 c0       	rjmp	.+142    	; 0x14ee <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1460:	8a 81       	ldd	r24, Y+2	; 0x02
    1462:	9b 81       	ldd	r25, Y+3	; 0x03
    1464:	0e 94 ca 12 	call	0x2594	; 0x2594 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1468:	1b 82       	std	Y+3, r1	; 0x03
    146a:	1a 82       	std	Y+2, r1	; 0x02
    146c:	47 c0       	rjmp	.+142    	; 0x14fc <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    146e:	41 11       	cpse	r20, r1
    1470:	18 c0       	rjmp	.+48     	; 0x14a2 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1472:	48 2f       	mov	r20, r24
    1474:	50 e0       	ldi	r21, 0x00	; 0
    1476:	8c 81       	ldd	r24, Y+4	; 0x04
    1478:	9d 81       	ldd	r25, Y+5	; 0x05
    147a:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    147e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1480:	8c 81       	ldd	r24, Y+4	; 0x04
    1482:	9d 81       	ldd	r25, Y+5	; 0x05
    1484:	82 0f       	add	r24, r18
    1486:	91 1d       	adc	r25, r1
    1488:	9d 83       	std	Y+5, r25	; 0x05
    148a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    148c:	2a 81       	ldd	r18, Y+2	; 0x02
    148e:	3b 81       	ldd	r19, Y+3	; 0x03
    1490:	82 17       	cp	r24, r18
    1492:	93 07       	cpc	r25, r19
    1494:	70 f1       	brcs	.+92     	; 0x14f2 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1496:	88 81       	ld	r24, Y
    1498:	99 81       	ldd	r25, Y+1	; 0x01
    149a:	9d 83       	std	Y+5, r25	; 0x05
    149c:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	2d c0       	rjmp	.+90     	; 0x14fc <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14a2:	48 2f       	mov	r20, r24
    14a4:	50 e0       	ldi	r21, 0x00	; 0
    14a6:	8e 81       	ldd	r24, Y+6	; 0x06
    14a8:	9f 81       	ldd	r25, Y+7	; 0x07
    14aa:	0e 94 96 16 	call	0x2d2c	; 0x2d2c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    14ae:	2c 8d       	ldd	r18, Y+28	; 0x1c
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	31 95       	neg	r19
    14b4:	21 95       	neg	r18
    14b6:	31 09       	sbc	r19, r1
    14b8:	8e 81       	ldd	r24, Y+6	; 0x06
    14ba:	9f 81       	ldd	r25, Y+7	; 0x07
    14bc:	82 0f       	add	r24, r18
    14be:	93 1f       	adc	r25, r19
    14c0:	9f 83       	std	Y+7, r25	; 0x07
    14c2:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    14c4:	68 81       	ld	r22, Y
    14c6:	79 81       	ldd	r23, Y+1	; 0x01
    14c8:	86 17       	cp	r24, r22
    14ca:	97 07       	cpc	r25, r23
    14cc:	30 f4       	brcc	.+12     	; 0x14da <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    14ce:	8a 81       	ldd	r24, Y+2	; 0x02
    14d0:	9b 81       	ldd	r25, Y+3	; 0x03
    14d2:	28 0f       	add	r18, r24
    14d4:	39 1f       	adc	r19, r25
    14d6:	3f 83       	std	Y+7, r19	; 0x07
    14d8:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    14da:	12 30       	cpi	r17, 0x02	; 2
    14dc:	61 f4       	brne	.+24     	; 0x14f6 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14e0:	88 23       	and	r24, r24
    14e2:	59 f0       	breq	.+22     	; 0x14fa <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    14e4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14e6:	81 50       	subi	r24, 0x01	; 1
    14e8:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	07 c0       	rjmp	.+14     	; 0x14fc <prvCopyDataToQueue+0xb6>
    14ee:	80 e0       	ldi	r24, 0x00	; 0
    14f0:	05 c0       	rjmp	.+10     	; 0x14fc <prvCopyDataToQueue+0xb6>
    14f2:	80 e0       	ldi	r24, 0x00	; 0
    14f4:	03 c0       	rjmp	.+6      	; 0x14fc <prvCopyDataToQueue+0xb6>
    14f6:	80 e0       	ldi	r24, 0x00	; 0
    14f8:	01 c0       	rjmp	.+2      	; 0x14fc <prvCopyDataToQueue+0xb6>
    14fa:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    14fc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    14fe:	9f 5f       	subi	r25, 0xFF	; 255
    1500:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1502:	df 91       	pop	r29
    1504:	cf 91       	pop	r28
    1506:	1f 91       	pop	r17
    1508:	08 95       	ret

0000150a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    150a:	fc 01       	movw	r30, r24
    150c:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    150e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1510:	44 23       	and	r20, r20
    1512:	a1 f0       	breq	.+40     	; 0x153c <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	26 81       	ldd	r18, Z+6	; 0x06
    1518:	37 81       	ldd	r19, Z+7	; 0x07
    151a:	24 0f       	add	r18, r20
    151c:	35 1f       	adc	r19, r21
    151e:	37 83       	std	Z+7, r19	; 0x07
    1520:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1522:	62 81       	ldd	r22, Z+2	; 0x02
    1524:	73 81       	ldd	r23, Z+3	; 0x03
    1526:	26 17       	cp	r18, r22
    1528:	37 07       	cpc	r19, r23
    152a:	20 f0       	brcs	.+8      	; 0x1534 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    152c:	20 81       	ld	r18, Z
    152e:	31 81       	ldd	r19, Z+1	; 0x01
    1530:	37 83       	std	Z+7, r19	; 0x07
    1532:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1534:	66 81       	ldd	r22, Z+6	; 0x06
    1536:	77 81       	ldd	r23, Z+7	; 0x07
    1538:	0c 94 96 16 	jmp	0x2d2c	; 0x2d2c <memcpy>
    153c:	08 95       	ret

0000153e <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    153e:	0f 93       	push	r16
    1540:	1f 93       	push	r17
    1542:	cf 93       	push	r28
    1544:	df 93       	push	r29
    1546:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    154e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1550:	18 16       	cp	r1, r24
    1552:	a4 f4       	brge	.+40     	; 0x157c <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1554:	89 89       	ldd	r24, Y+17	; 0x11
    1556:	88 23       	and	r24, r24
    1558:	89 f0       	breq	.+34     	; 0x157c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    155a:	8e 01       	movw	r16, r28
    155c:	0f 5e       	subi	r16, 0xEF	; 239
    155e:	1f 4f       	sbci	r17, 0xFF	; 255
    1560:	03 c0       	rjmp	.+6      	; 0x1568 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1562:	89 89       	ldd	r24, Y+17	; 0x11
    1564:	88 23       	and	r24, r24
    1566:	51 f0       	breq	.+20     	; 0x157c <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1568:	c8 01       	movw	r24, r16
    156a:	27 d7       	rcall	.+3662   	; 0x23ba <xTaskRemoveFromEventList>
    156c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    156e:	b0 d7       	rcall	.+3936   	; 0x24d0 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1570:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1572:	81 50       	subi	r24, 0x01	; 1
    1574:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1576:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1578:	18 16       	cp	r1, r24
    157a:	9c f3       	brlt	.-26     	; 0x1562 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    157c:	8f ef       	ldi	r24, 0xFF	; 255
    157e:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1580:	0f 90       	pop	r0
    1582:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1584:	0f b6       	in	r0, 0x3f	; 63
    1586:	f8 94       	cli
    1588:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    158a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    158c:	18 16       	cp	r1, r24
    158e:	a4 f4       	brge	.+40     	; 0x15b8 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1590:	88 85       	ldd	r24, Y+8	; 0x08
    1592:	88 23       	and	r24, r24
    1594:	89 f0       	breq	.+34     	; 0x15b8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1596:	8e 01       	movw	r16, r28
    1598:	08 5f       	subi	r16, 0xF8	; 248
    159a:	1f 4f       	sbci	r17, 0xFF	; 255
    159c:	03 c0       	rjmp	.+6      	; 0x15a4 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    159e:	88 85       	ldd	r24, Y+8	; 0x08
    15a0:	88 23       	and	r24, r24
    15a2:	51 f0       	breq	.+20     	; 0x15b8 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15a4:	c8 01       	movw	r24, r16
    15a6:	09 d7       	rcall	.+3602   	; 0x23ba <xTaskRemoveFromEventList>
    15a8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    15aa:	92 d7       	rcall	.+3876   	; 0x24d0 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    15ac:	8d 8d       	ldd	r24, Y+29	; 0x1d
    15ae:	81 50       	subi	r24, 0x01	; 1
    15b0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    15b2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    15b4:	18 16       	cp	r1, r24
    15b6:	9c f3       	brlt	.-26     	; 0x159e <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    15b8:	8f ef       	ldi	r24, 0xFF	; 255
    15ba:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    15bc:	0f 90       	pop	r0
    15be:	0f be       	out	0x3f, r0	; 63
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	0f 91       	pop	r16
    15c8:	08 95       	ret

000015ca <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    15ca:	cf 93       	push	r28
    15cc:	df 93       	push	r29
    15ce:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15d0:	0f b6       	in	r0, 0x3f	; 63
    15d2:	f8 94       	cli
    15d4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    15d6:	88 81       	ld	r24, Y
    15d8:	99 81       	ldd	r25, Y+1	; 0x01
    15da:	2c 8d       	ldd	r18, Y+28	; 0x1c
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	7b 8d       	ldd	r23, Y+27	; 0x1b
    15e0:	72 9f       	mul	r23, r18
    15e2:	a0 01       	movw	r20, r0
    15e4:	73 9f       	mul	r23, r19
    15e6:	50 0d       	add	r21, r0
    15e8:	11 24       	eor	r1, r1
    15ea:	fc 01       	movw	r30, r24
    15ec:	e4 0f       	add	r30, r20
    15ee:	f5 1f       	adc	r31, r21
    15f0:	fb 83       	std	Y+3, r31	; 0x03
    15f2:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    15f4:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    15f6:	9d 83       	std	Y+5, r25	; 0x05
    15f8:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    15fa:	42 1b       	sub	r20, r18
    15fc:	53 0b       	sbc	r21, r19
    15fe:	84 0f       	add	r24, r20
    1600:	95 1f       	adc	r25, r21
    1602:	9f 83       	std	Y+7, r25	; 0x07
    1604:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1606:	8f ef       	ldi	r24, 0xFF	; 255
    1608:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    160a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    160c:	61 11       	cpse	r22, r1
    160e:	0a c0       	rjmp	.+20     	; 0x1624 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1610:	88 85       	ldd	r24, Y+8	; 0x08
    1612:	88 23       	and	r24, r24
    1614:	79 f0       	breq	.+30     	; 0x1634 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1616:	ce 01       	movw	r24, r28
    1618:	08 96       	adiw	r24, 0x08	; 8
    161a:	cf d6       	rcall	.+3486   	; 0x23ba <xTaskRemoveFromEventList>
    161c:	81 30       	cpi	r24, 0x01	; 1
    161e:	51 f4       	brne	.+20     	; 0x1634 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1620:	4e de       	rcall	.-868    	; 0x12be <vPortYield>
    1622:	08 c0       	rjmp	.+16     	; 0x1634 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1624:	ce 01       	movw	r24, r28
    1626:	08 96       	adiw	r24, 0x08	; 8
    1628:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    162c:	ce 01       	movw	r24, r28
    162e:	41 96       	adiw	r24, 0x11	; 17
    1630:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1634:	0f 90       	pop	r0
    1636:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1638:	81 e0       	ldi	r24, 0x01	; 1
    163a:	df 91       	pop	r29
    163c:	cf 91       	pop	r28
    163e:	08 95       	ret

00001640 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1640:	0f 93       	push	r16
    1642:	1f 93       	push	r17
    1644:	cf 93       	push	r28
    1646:	df 93       	push	r29
    1648:	18 2f       	mov	r17, r24
    164a:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    164c:	88 23       	and	r24, r24
    164e:	e9 f0       	breq	.+58     	; 0x168a <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1650:	8f e1       	ldi	r24, 0x1F	; 31
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    1658:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    165a:	00 97       	sbiw	r24, 0x00	; 0
    165c:	c1 f0       	breq	.+48     	; 0x168e <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    165e:	10 9f       	mul	r17, r16
    1660:	c0 01       	movw	r24, r0
    1662:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1664:	01 96       	adiw	r24, 0x01	; 1
    1666:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    166a:	99 83       	std	Y+1, r25	; 0x01
    166c:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    166e:	89 2b       	or	r24, r25
    1670:	31 f0       	breq	.+12     	; 0x167e <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1672:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1674:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1676:	61 e0       	ldi	r22, 0x01	; 1
    1678:	ce 01       	movw	r24, r28
    167a:	a7 df       	rcall	.-178    	; 0x15ca <xQueueGenericReset>
    167c:	08 c0       	rjmp	.+16     	; 0x168e <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    167e:	ce 01       	movw	r24, r28
    1680:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1684:	c0 e0       	ldi	r28, 0x00	; 0
    1686:	d0 e0       	ldi	r29, 0x00	; 0
    1688:	02 c0       	rjmp	.+4      	; 0x168e <xQueueGenericCreate+0x4e>
    168a:	c0 e0       	ldi	r28, 0x00	; 0
    168c:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    168e:	ce 01       	movw	r24, r28
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	1f 91       	pop	r17
    1696:	0f 91       	pop	r16
    1698:	08 95       	ret

0000169a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    169a:	9f 92       	push	r9
    169c:	af 92       	push	r10
    169e:	bf 92       	push	r11
    16a0:	cf 92       	push	r12
    16a2:	df 92       	push	r13
    16a4:	ef 92       	push	r14
    16a6:	ff 92       	push	r15
    16a8:	0f 93       	push	r16
    16aa:	1f 93       	push	r17
    16ac:	cf 93       	push	r28
    16ae:	df 93       	push	r29
    16b0:	00 d0       	rcall	.+0      	; 0x16b2 <xQueueGenericSend+0x18>
    16b2:	1f 92       	push	r1
    16b4:	1f 92       	push	r1
    16b6:	cd b7       	in	r28, 0x3d	; 61
    16b8:	de b7       	in	r29, 0x3e	; 62
    16ba:	8c 01       	movw	r16, r24
    16bc:	6b 01       	movw	r12, r22
    16be:	5d 83       	std	Y+5, r21	; 0x05
    16c0:	4c 83       	std	Y+4, r20	; 0x04
    16c2:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    16c4:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    16c6:	99 24       	eor	r9, r9
    16c8:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16ca:	7c 01       	movw	r14, r24
    16cc:	88 e0       	ldi	r24, 0x08	; 8
    16ce:	e8 0e       	add	r14, r24
    16d0:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16d2:	0f b6       	in	r0, 0x3f	; 63
    16d4:	f8 94       	cli
    16d6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    16d8:	f8 01       	movw	r30, r16
    16da:	92 8d       	ldd	r25, Z+26	; 0x1a
    16dc:	83 8d       	ldd	r24, Z+27	; 0x1b
    16de:	98 17       	cp	r25, r24
    16e0:	18 f0       	brcs	.+6      	; 0x16e8 <xQueueGenericSend+0x4e>
    16e2:	f2 e0       	ldi	r31, 0x02	; 2
    16e4:	af 12       	cpse	r10, r31
    16e6:	15 c0       	rjmp	.+42     	; 0x1712 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    16e8:	4a 2d       	mov	r20, r10
    16ea:	b6 01       	movw	r22, r12
    16ec:	c8 01       	movw	r24, r16
    16ee:	ab de       	rcall	.-682    	; 0x1446 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16f0:	f8 01       	movw	r30, r16
    16f2:	91 89       	ldd	r25, Z+17	; 0x11
    16f4:	99 23       	and	r25, r25
    16f6:	39 f0       	breq	.+14     	; 0x1706 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    16f8:	c8 01       	movw	r24, r16
    16fa:	41 96       	adiw	r24, 0x11	; 17
    16fc:	5e d6       	rcall	.+3260   	; 0x23ba <xTaskRemoveFromEventList>
    16fe:	81 30       	cpi	r24, 0x01	; 1
    1700:	21 f4       	brne	.+8      	; 0x170a <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1702:	dd dd       	rcall	.-1094   	; 0x12be <vPortYield>
    1704:	02 c0       	rjmp	.+4      	; 0x170a <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1706:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1708:	da dd       	rcall	.-1100   	; 0x12be <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    170a:	0f 90       	pop	r0
    170c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	46 c0       	rjmp	.+140    	; 0x179e <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1712:	ec 81       	ldd	r30, Y+4	; 0x04
    1714:	fd 81       	ldd	r31, Y+5	; 0x05
    1716:	ef 2b       	or	r30, r31
    1718:	21 f4       	brne	.+8      	; 0x1722 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    171a:	0f 90       	pop	r0
    171c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    171e:	80 e0       	ldi	r24, 0x00	; 0
    1720:	3e c0       	rjmp	.+124    	; 0x179e <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1722:	b1 10       	cpse	r11, r1
    1724:	04 c0       	rjmp	.+8      	; 0x172e <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1726:	ce 01       	movw	r24, r28
    1728:	01 96       	adiw	r24, 0x01	; 1
    172a:	8f d6       	rcall	.+3358   	; 0x244a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    172c:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    172e:	0f 90       	pop	r0
    1730:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1732:	86 d3       	rcall	.+1804   	; 0x1e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	0f 92       	push	r0
    173a:	f8 01       	movw	r30, r16
    173c:	85 8d       	ldd	r24, Z+29	; 0x1d
    173e:	8f 3f       	cpi	r24, 0xFF	; 255
    1740:	09 f4       	brne	.+2      	; 0x1744 <xQueueGenericSend+0xaa>
    1742:	15 8e       	std	Z+29, r1	; 0x1d
    1744:	f8 01       	movw	r30, r16
    1746:	86 8d       	ldd	r24, Z+30	; 0x1e
    1748:	8f 3f       	cpi	r24, 0xFF	; 255
    174a:	09 f4       	brne	.+2      	; 0x174e <xQueueGenericSend+0xb4>
    174c:	16 8e       	std	Z+30, r1	; 0x1e
    174e:	0f 90       	pop	r0
    1750:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1752:	be 01       	movw	r22, r28
    1754:	6c 5f       	subi	r22, 0xFC	; 252
    1756:	7f 4f       	sbci	r23, 0xFF	; 255
    1758:	ce 01       	movw	r24, r28
    175a:	01 96       	adiw	r24, 0x01	; 1
    175c:	81 d6       	rcall	.+3330   	; 0x2460 <xTaskCheckForTimeOut>
    175e:	81 11       	cpse	r24, r1
    1760:	1a c0       	rjmp	.+52     	; 0x1796 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1768:	f8 01       	movw	r30, r16
    176a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    176c:	0f 90       	pop	r0
    176e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1770:	f8 01       	movw	r30, r16
    1772:	83 8d       	ldd	r24, Z+27	; 0x1b
    1774:	98 13       	cpse	r25, r24
    1776:	0b c0       	rjmp	.+22     	; 0x178e <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1778:	6c 81       	ldd	r22, Y+4	; 0x04
    177a:	7d 81       	ldd	r23, Y+5	; 0x05
    177c:	c7 01       	movw	r24, r14
    177e:	f2 d5       	rcall	.+3044   	; 0x2364 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1780:	c8 01       	movw	r24, r16
    1782:	dd de       	rcall	.-582    	; 0x153e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1784:	30 d4       	rcall	.+2144   	; 0x1fe6 <xTaskResumeAll>
    1786:	81 11       	cpse	r24, r1
    1788:	a4 cf       	rjmp	.-184    	; 0x16d2 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    178a:	99 dd       	rcall	.-1230   	; 0x12be <vPortYield>
    178c:	a2 cf       	rjmp	.-188    	; 0x16d2 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    178e:	c8 01       	movw	r24, r16
    1790:	d6 de       	rcall	.-596    	; 0x153e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1792:	29 d4       	rcall	.+2130   	; 0x1fe6 <xTaskResumeAll>
    1794:	9e cf       	rjmp	.-196    	; 0x16d2 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1796:	c8 01       	movw	r24, r16
    1798:	d2 de       	rcall	.-604    	; 0x153e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    179a:	25 d4       	rcall	.+2122   	; 0x1fe6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    179c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    179e:	0f 90       	pop	r0
    17a0:	0f 90       	pop	r0
    17a2:	0f 90       	pop	r0
    17a4:	0f 90       	pop	r0
    17a6:	0f 90       	pop	r0
    17a8:	df 91       	pop	r29
    17aa:	cf 91       	pop	r28
    17ac:	1f 91       	pop	r17
    17ae:	0f 91       	pop	r16
    17b0:	ff 90       	pop	r15
    17b2:	ef 90       	pop	r14
    17b4:	df 90       	pop	r13
    17b6:	cf 90       	pop	r12
    17b8:	bf 90       	pop	r11
    17ba:	af 90       	pop	r10
    17bc:	9f 90       	pop	r9
    17be:	08 95       	ret

000017c0 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    17c0:	cf 93       	push	r28
    17c2:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    17c4:	8f e1       	ldi	r24, 0x1F	; 31
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    17cc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17ce:	00 97       	sbiw	r24, 0x00	; 0
    17d0:	f1 f0       	breq	.+60     	; 0x180e <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    17d2:	1b 82       	std	Y+3, r1	; 0x03
    17d4:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    17d6:	19 82       	std	Y+1, r1	; 0x01
    17d8:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    17da:	1d 82       	std	Y+5, r1	; 0x05
    17dc:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    17de:	1f 82       	std	Y+7, r1	; 0x07
    17e0:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17e2:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    17e8:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    17ea:	8f ef       	ldi	r24, 0xFF	; 255
    17ec:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    17ee:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    17f0:	ce 01       	movw	r24, r28
    17f2:	08 96       	adiw	r24, 0x08	; 8
    17f4:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    17f8:	ce 01       	movw	r24, r28
    17fa:	41 96       	adiw	r24, 0x11	; 17
    17fc:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1800:	20 e0       	ldi	r18, 0x00	; 0
    1802:	40 e0       	ldi	r20, 0x00	; 0
    1804:	50 e0       	ldi	r21, 0x00	; 0
    1806:	60 e0       	ldi	r22, 0x00	; 0
    1808:	70 e0       	ldi	r23, 0x00	; 0
    180a:	ce 01       	movw	r24, r28
    180c:	46 df       	rcall	.-372    	; 0x169a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    180e:	ce 01       	movw	r24, r28
    1810:	df 91       	pop	r29
    1812:	cf 91       	pop	r28
    1814:	08 95       	ret

00001816 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1816:	0f 93       	push	r16
    1818:	1f 93       	push	r17
    181a:	cf 93       	push	r28
    181c:	df 93       	push	r29
    181e:	ec 01       	movw	r28, r24
    1820:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1822:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1824:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1826:	98 17       	cp	r25, r24
    1828:	10 f0       	brcs	.+4      	; 0x182e <xQueueGenericSendFromISR+0x18>
    182a:	22 30       	cpi	r18, 0x02	; 2
    182c:	11 f5       	brne	.+68     	; 0x1872 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    182e:	42 2f       	mov	r20, r18
    1830:	ce 01       	movw	r24, r28
    1832:	09 de       	rcall	.-1006   	; 0x1446 <prvCopyDataToQueue>
    1834:	88 23       	and	r24, r24
    1836:	31 f0       	breq	.+12     	; 0x1844 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1838:	01 15       	cp	r16, r1
    183a:	11 05       	cpc	r17, r1
    183c:	19 f0       	breq	.+6      	; 0x1844 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	f8 01       	movw	r30, r16
    1842:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1844:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1846:	8f 3f       	cpi	r24, 0xFF	; 255
    1848:	79 f4       	brne	.+30     	; 0x1868 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    184a:	89 89       	ldd	r24, Y+17	; 0x11
    184c:	88 23       	and	r24, r24
    184e:	99 f0       	breq	.+38     	; 0x1876 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1850:	ce 01       	movw	r24, r28
    1852:	41 96       	adiw	r24, 0x11	; 17
    1854:	b2 d5       	rcall	.+2916   	; 0x23ba <xTaskRemoveFromEventList>
    1856:	88 23       	and	r24, r24
    1858:	81 f0       	breq	.+32     	; 0x187a <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    185a:	01 15       	cp	r16, r1
    185c:	11 05       	cpc	r17, r1
    185e:	79 f0       	breq	.+30     	; 0x187e <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	f8 01       	movw	r30, r16
    1864:	80 83       	st	Z, r24
    1866:	0c c0       	rjmp	.+24     	; 0x1880 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1868:	8e 8d       	ldd	r24, Y+30	; 0x1e
    186a:	8f 5f       	subi	r24, 0xFF	; 255
    186c:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	07 c0       	rjmp	.+14     	; 0x1880 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1872:	80 e0       	ldi	r24, 0x00	; 0
    1874:	05 c0       	rjmp	.+10     	; 0x1880 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1876:	81 e0       	ldi	r24, 0x01	; 1
    1878:	03 c0       	rjmp	.+6      	; 0x1880 <xQueueGenericSendFromISR+0x6a>
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	01 c0       	rjmp	.+2      	; 0x1880 <xQueueGenericSendFromISR+0x6a>
    187e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1880:	df 91       	pop	r29
    1882:	cf 91       	pop	r28
    1884:	1f 91       	pop	r17
    1886:	0f 91       	pop	r16
    1888:	08 95       	ret

0000188a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    188a:	9f 92       	push	r9
    188c:	af 92       	push	r10
    188e:	bf 92       	push	r11
    1890:	cf 92       	push	r12
    1892:	df 92       	push	r13
    1894:	ef 92       	push	r14
    1896:	ff 92       	push	r15
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	00 d0       	rcall	.+0      	; 0x18a2 <xQueueGenericReceive+0x18>
    18a2:	1f 92       	push	r1
    18a4:	1f 92       	push	r1
    18a6:	cd b7       	in	r28, 0x3d	; 61
    18a8:	de b7       	in	r29, 0x3e	; 62
    18aa:	8c 01       	movw	r16, r24
    18ac:	6b 01       	movw	r12, r22
    18ae:	5d 83       	std	Y+5, r21	; 0x05
    18b0:	4c 83       	std	Y+4, r20	; 0x04
    18b2:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    18b4:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    18b6:	99 24       	eor	r9, r9
    18b8:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ba:	7c 01       	movw	r14, r24
    18bc:	81 e1       	ldi	r24, 0x11	; 17
    18be:	e8 0e       	add	r14, r24
    18c0:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    18c2:	0f b6       	in	r0, 0x3f	; 63
    18c4:	f8 94       	cli
    18c6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    18c8:	f8 01       	movw	r30, r16
    18ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    18cc:	88 23       	and	r24, r24
    18ce:	69 f1       	breq	.+90     	; 0x192a <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    18d0:	e6 80       	ldd	r14, Z+6	; 0x06
    18d2:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18d4:	b6 01       	movw	r22, r12
    18d6:	c8 01       	movw	r24, r16
    18d8:	18 de       	rcall	.-976    	; 0x150a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    18da:	b1 10       	cpse	r11, r1
    18dc:	17 c0       	rjmp	.+46     	; 0x190c <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    18de:	f8 01       	movw	r30, r16
    18e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    18e2:	81 50       	subi	r24, 0x01	; 1
    18e4:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18e6:	80 81       	ld	r24, Z
    18e8:	91 81       	ldd	r25, Z+1	; 0x01
    18ea:	89 2b       	or	r24, r25
    18ec:	21 f4       	brne	.+8      	; 0x18f6 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    18ee:	91 d6       	rcall	.+3362   	; 0x2612 <pvTaskIncrementMutexHeldCount>
    18f0:	f8 01       	movw	r30, r16
    18f2:	93 83       	std	Z+3, r25	; 0x03
    18f4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18f6:	f8 01       	movw	r30, r16
    18f8:	80 85       	ldd	r24, Z+8	; 0x08
    18fa:	88 23       	and	r24, r24
    18fc:	91 f0       	breq	.+36     	; 0x1922 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    18fe:	c8 01       	movw	r24, r16
    1900:	08 96       	adiw	r24, 0x08	; 8
    1902:	5b d5       	rcall	.+2742   	; 0x23ba <xTaskRemoveFromEventList>
    1904:	81 30       	cpi	r24, 0x01	; 1
    1906:	69 f4       	brne	.+26     	; 0x1922 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1908:	da dc       	rcall	.-1612   	; 0x12be <vPortYield>
    190a:	0b c0       	rjmp	.+22     	; 0x1922 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    190c:	f8 01       	movw	r30, r16
    190e:	f7 82       	std	Z+7, r15	; 0x07
    1910:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1912:	81 89       	ldd	r24, Z+17	; 0x11
    1914:	88 23       	and	r24, r24
    1916:	29 f0       	breq	.+10     	; 0x1922 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1918:	c8 01       	movw	r24, r16
    191a:	41 96       	adiw	r24, 0x11	; 17
    191c:	4e d5       	rcall	.+2716   	; 0x23ba <xTaskRemoveFromEventList>
    191e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1920:	ce dc       	rcall	.-1636   	; 0x12be <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	52 c0       	rjmp	.+164    	; 0x19ce <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    192a:	4c 81       	ldd	r20, Y+4	; 0x04
    192c:	5d 81       	ldd	r21, Y+5	; 0x05
    192e:	45 2b       	or	r20, r21
    1930:	21 f4       	brne	.+8      	; 0x193a <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1932:	0f 90       	pop	r0
    1934:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	4a c0       	rjmp	.+148    	; 0x19ce <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    193a:	a1 10       	cpse	r10, r1
    193c:	04 c0       	rjmp	.+8      	; 0x1946 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    193e:	ce 01       	movw	r24, r28
    1940:	01 96       	adiw	r24, 0x01	; 1
    1942:	83 d5       	rcall	.+2822   	; 0x244a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1944:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    194a:	7a d2       	rcall	.+1268   	; 0x1e40 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    194c:	0f b6       	in	r0, 0x3f	; 63
    194e:	f8 94       	cli
    1950:	0f 92       	push	r0
    1952:	f8 01       	movw	r30, r16
    1954:	85 8d       	ldd	r24, Z+29	; 0x1d
    1956:	8f 3f       	cpi	r24, 0xFF	; 255
    1958:	09 f4       	brne	.+2      	; 0x195c <xQueueGenericReceive+0xd2>
    195a:	15 8e       	std	Z+29, r1	; 0x1d
    195c:	f8 01       	movw	r30, r16
    195e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1960:	8f 3f       	cpi	r24, 0xFF	; 255
    1962:	09 f4       	brne	.+2      	; 0x1966 <xQueueGenericReceive+0xdc>
    1964:	16 8e       	std	Z+30, r1	; 0x1e
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    196a:	be 01       	movw	r22, r28
    196c:	6c 5f       	subi	r22, 0xFC	; 252
    196e:	7f 4f       	sbci	r23, 0xFF	; 255
    1970:	ce 01       	movw	r24, r28
    1972:	01 96       	adiw	r24, 0x01	; 1
    1974:	75 d5       	rcall	.+2794   	; 0x2460 <xTaskCheckForTimeOut>
    1976:	81 11       	cpse	r24, r1
    1978:	26 c0       	rjmp	.+76     	; 0x19c6 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1980:	f8 01       	movw	r30, r16
    1982:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1984:	0f 90       	pop	r0
    1986:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1988:	81 11       	cpse	r24, r1
    198a:	19 c0       	rjmp	.+50     	; 0x19be <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    198c:	f8 01       	movw	r30, r16
    198e:	80 81       	ld	r24, Z
    1990:	91 81       	ldd	r25, Z+1	; 0x01
    1992:	89 2b       	or	r24, r25
    1994:	49 f4       	brne	.+18     	; 0x19a8 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    199c:	f8 01       	movw	r30, r16
    199e:	82 81       	ldd	r24, Z+2	; 0x02
    19a0:	93 81       	ldd	r25, Z+3	; 0x03
    19a2:	9a d5       	rcall	.+2868   	; 0x24d8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    19a4:	0f 90       	pop	r0
    19a6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19a8:	6c 81       	ldd	r22, Y+4	; 0x04
    19aa:	7d 81       	ldd	r23, Y+5	; 0x05
    19ac:	c7 01       	movw	r24, r14
    19ae:	da d4       	rcall	.+2484   	; 0x2364 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19b0:	c8 01       	movw	r24, r16
    19b2:	c5 dd       	rcall	.-1142   	; 0x153e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19b4:	18 d3       	rcall	.+1584   	; 0x1fe6 <xTaskResumeAll>
    19b6:	81 11       	cpse	r24, r1
    19b8:	84 cf       	rjmp	.-248    	; 0x18c2 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    19ba:	81 dc       	rcall	.-1790   	; 0x12be <vPortYield>
    19bc:	82 cf       	rjmp	.-252    	; 0x18c2 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19be:	c8 01       	movw	r24, r16
    19c0:	be dd       	rcall	.-1156   	; 0x153e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19c2:	11 d3       	rcall	.+1570   	; 0x1fe6 <xTaskResumeAll>
    19c4:	7e cf       	rjmp	.-260    	; 0x18c2 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    19c6:	c8 01       	movw	r24, r16
    19c8:	ba dd       	rcall	.-1164   	; 0x153e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ca:	0d d3       	rcall	.+1562   	; 0x1fe6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    19cc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19ce:	0f 90       	pop	r0
    19d0:	0f 90       	pop	r0
    19d2:	0f 90       	pop	r0
    19d4:	0f 90       	pop	r0
    19d6:	0f 90       	pop	r0
    19d8:	df 91       	pop	r29
    19da:	cf 91       	pop	r28
    19dc:	1f 91       	pop	r17
    19de:	0f 91       	pop	r16
    19e0:	ff 90       	pop	r15
    19e2:	ef 90       	pop	r14
    19e4:	df 90       	pop	r13
    19e6:	cf 90       	pop	r12
    19e8:	bf 90       	pop	r11
    19ea:	af 90       	pop	r10
    19ec:	9f 90       	pop	r9
    19ee:	08 95       	ret

000019f0 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    19f0:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    19f2:	71 83       	std	Z+1, r23	; 0x01
    19f4:	60 83       	st	Z, r22
	ring->rSize = size;
    19f6:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    19f8:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    19fa:	13 82       	std	Z+3, r1	; 0x03
    19fc:	08 95       	ret

000019fe <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    19fe:	dc 01       	movw	r26, r24
    1a00:	14 96       	adiw	r26, 0x04	; 4
    1a02:	2c 91       	ld	r18, X
    1a04:	14 97       	sbiw	r26, 0x04	; 4
    1a06:	ed 91       	ld	r30, X+
    1a08:	fc 91       	ld	r31, X
    1a0a:	e2 0f       	add	r30, r18
    1a0c:	f1 1d       	adc	r31, r1
}
    1a0e:	80 81       	ld	r24, Z
    1a10:	08 95       	ret

00001a12 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1a12:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1a14:	94 81       	ldd	r25, Z+4	; 0x04
    1a16:	a0 81       	ld	r26, Z
    1a18:	b1 81       	ldd	r27, Z+1	; 0x01
    1a1a:	a9 0f       	add	r26, r25
    1a1c:	b1 1d       	adc	r27, r1
    1a1e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1a20:	9f 5f       	subi	r25, 0xFF	; 255
    1a22:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1a24:	22 81       	ldd	r18, Z+2	; 0x02
    1a26:	92 17       	cp	r25, r18
    1a28:	10 f0       	brcs	.+4      	; 0x1a2e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1a2a:	92 1b       	sub	r25, r18
    1a2c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1a2e:	93 81       	ldd	r25, Z+3	; 0x03
    1a30:	91 50       	subi	r25, 0x01	; 1
    1a32:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1a34:	08 95       	ret

00001a36 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1a36:	fc 01       	movw	r30, r24
    1a38:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1a3a:	83 81       	ldd	r24, Z+3	; 0x03
    1a3c:	22 81       	ldd	r18, Z+2	; 0x02
    1a3e:	82 17       	cp	r24, r18
    1a40:	80 f4       	brcc	.+32     	; 0x1a62 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1a42:	34 81       	ldd	r19, Z+4	; 0x04
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	83 0f       	add	r24, r19
    1a48:	91 1d       	adc	r25, r1
    1a4a:	62 2f       	mov	r22, r18
    1a4c:	70 e0       	ldi	r23, 0x00	; 0
    1a4e:	0e 94 6f 16 	call	0x2cde	; 0x2cde <__divmodhi4>
    1a52:	a0 81       	ld	r26, Z
    1a54:	b1 81       	ldd	r27, Z+1	; 0x01
    1a56:	a8 0f       	add	r26, r24
    1a58:	b9 1f       	adc	r27, r25
    1a5a:	4c 93       	st	X, r20
            ring->rLength++;
    1a5c:	83 81       	ldd	r24, Z+3	; 0x03
    1a5e:	8f 5f       	subi	r24, 0xFF	; 255
    1a60:	83 83       	std	Z+3, r24	; 0x03
    1a62:	08 95       	ret

00001a64 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1a64:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1a66:	81 e0       	ldi	r24, 0x01	; 1
    1a68:	22 81       	ldd	r18, Z+2	; 0x02
    1a6a:	93 81       	ldd	r25, Z+3	; 0x03
    1a6c:	29 13       	cpse	r18, r25
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
}
    1a70:	08 95       	ret

00001a72 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1a72:	21 e0       	ldi	r18, 0x01	; 1
    1a74:	fc 01       	movw	r30, r24
    1a76:	83 81       	ldd	r24, Z+3	; 0x03
    1a78:	81 11       	cpse	r24, r1
    1a7a:	01 c0       	rjmp	.+2      	; 0x1a7e <ringBufferNotEmpty+0xc>
    1a7c:	20 e0       	ldi	r18, 0x00	; 0
}
    1a7e:	82 2f       	mov	r24, r18
    1a80:	08 95       	ret

00001a82 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1a82:	e0 91 4c 08 	lds	r30, 0x084C
    1a86:	f0 91 4d 08 	lds	r31, 0x084D
    1a8a:	80 81       	ld	r24, Z
    1a8c:	81 11       	cpse	r24, r1
    1a8e:	07 c0       	rjmp	.+14     	; 0x1a9e <prvResetNextTaskUnblockTime+0x1c>
    1a90:	8f ef       	ldi	r24, 0xFF	; 255
    1a92:	9f ef       	ldi	r25, 0xFF	; 255
    1a94:	90 93 05 02 	sts	0x0205, r25
    1a98:	80 93 04 02 	sts	0x0204, r24
    1a9c:	08 95       	ret
    1a9e:	e0 91 4c 08 	lds	r30, 0x084C
    1aa2:	f0 91 4d 08 	lds	r31, 0x084D
    1aa6:	05 80       	ldd	r0, Z+5	; 0x05
    1aa8:	f6 81       	ldd	r31, Z+6	; 0x06
    1aaa:	e0 2d       	mov	r30, r0
    1aac:	06 80       	ldd	r0, Z+6	; 0x06
    1aae:	f7 81       	ldd	r31, Z+7	; 0x07
    1ab0:	e0 2d       	mov	r30, r0
    1ab2:	82 81       	ldd	r24, Z+2	; 0x02
    1ab4:	93 81       	ldd	r25, Z+3	; 0x03
    1ab6:	90 93 05 02 	sts	0x0205, r25
    1aba:	80 93 04 02 	sts	0x0204, r24
    1abe:	08 95       	ret

00001ac0 <prvAddCurrentTaskToDelayedList>:
    1ac0:	cf 93       	push	r28
    1ac2:	df 93       	push	r29
    1ac4:	ec 01       	movw	r28, r24
    1ac6:	e0 91 8d 08 	lds	r30, 0x088D
    1aca:	f0 91 8e 08 	lds	r31, 0x088E
    1ace:	93 83       	std	Z+3, r25	; 0x03
    1ad0:	82 83       	std	Z+2, r24	; 0x02
    1ad2:	80 91 2b 08 	lds	r24, 0x082B
    1ad6:	90 91 2c 08 	lds	r25, 0x082C
    1ada:	c8 17       	cp	r28, r24
    1adc:	d9 07       	cpc	r29, r25
    1ade:	68 f4       	brcc	.+26     	; 0x1afa <prvAddCurrentTaskToDelayedList+0x3a>
    1ae0:	60 91 8d 08 	lds	r22, 0x088D
    1ae4:	70 91 8e 08 	lds	r23, 0x088E
    1ae8:	80 91 4a 08 	lds	r24, 0x084A
    1aec:	90 91 4b 08 	lds	r25, 0x084B
    1af0:	6e 5f       	subi	r22, 0xFE	; 254
    1af2:	7f 4f       	sbci	r23, 0xFF	; 255
    1af4:	0e 94 28 03 	call	0x650	; 0x650 <vListInsert>
    1af8:	17 c0       	rjmp	.+46     	; 0x1b28 <prvAddCurrentTaskToDelayedList+0x68>
    1afa:	60 91 8d 08 	lds	r22, 0x088D
    1afe:	70 91 8e 08 	lds	r23, 0x088E
    1b02:	80 91 4c 08 	lds	r24, 0x084C
    1b06:	90 91 4d 08 	lds	r25, 0x084D
    1b0a:	6e 5f       	subi	r22, 0xFE	; 254
    1b0c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b0e:	0e 94 28 03 	call	0x650	; 0x650 <vListInsert>
    1b12:	80 91 04 02 	lds	r24, 0x0204
    1b16:	90 91 05 02 	lds	r25, 0x0205
    1b1a:	c8 17       	cp	r28, r24
    1b1c:	d9 07       	cpc	r29, r25
    1b1e:	20 f4       	brcc	.+8      	; 0x1b28 <prvAddCurrentTaskToDelayedList+0x68>
    1b20:	d0 93 05 02 	sts	0x0205, r29
    1b24:	c0 93 04 02 	sts	0x0204, r28
    1b28:	df 91       	pop	r29
    1b2a:	cf 91       	pop	r28
    1b2c:	08 95       	ret

00001b2e <xTaskGenericCreate>:
    1b2e:	4f 92       	push	r4
    1b30:	5f 92       	push	r5
    1b32:	6f 92       	push	r6
    1b34:	7f 92       	push	r7
    1b36:	8f 92       	push	r8
    1b38:	9f 92       	push	r9
    1b3a:	af 92       	push	r10
    1b3c:	bf 92       	push	r11
    1b3e:	cf 92       	push	r12
    1b40:	df 92       	push	r13
    1b42:	ef 92       	push	r14
    1b44:	ff 92       	push	r15
    1b46:	0f 93       	push	r16
    1b48:	1f 93       	push	r17
    1b4a:	cf 93       	push	r28
    1b4c:	df 93       	push	r29
    1b4e:	4c 01       	movw	r8, r24
    1b50:	5b 01       	movw	r10, r22
    1b52:	2a 01       	movw	r4, r20
    1b54:	39 01       	movw	r6, r18
    1b56:	83 e2       	ldi	r24, 0x23	; 35
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    1b5e:	ec 01       	movw	r28, r24
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	09 f4       	brne	.+2      	; 0x1b66 <xTaskGenericCreate+0x38>
    1b64:	e7 c0       	rjmp	.+462    	; 0x1d34 <xTaskGenericCreate+0x206>
    1b66:	c1 14       	cp	r12, r1
    1b68:	d1 04       	cpc	r13, r1
    1b6a:	09 f0       	breq	.+2      	; 0x1b6e <xTaskGenericCreate+0x40>
    1b6c:	cc c0       	rjmp	.+408    	; 0x1d06 <xTaskGenericCreate+0x1d8>
    1b6e:	c2 01       	movw	r24, r4
    1b70:	0e 94 bf 02 	call	0x57e	; 0x57e <pvPortMalloc>
    1b74:	98 8f       	std	Y+24, r25	; 0x18
    1b76:	8f 8b       	std	Y+23, r24	; 0x17
    1b78:	89 2b       	or	r24, r25
    1b7a:	09 f0       	breq	.+2      	; 0x1b7e <xTaskGenericCreate+0x50>
    1b7c:	c6 c0       	rjmp	.+396    	; 0x1d0a <xTaskGenericCreate+0x1dc>
    1b7e:	ce 01       	movw	r24, r28
    1b80:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vPortFree>
    1b84:	d7 c0       	rjmp	.+430    	; 0x1d34 <xTaskGenericCreate+0x206>
    1b86:	cf 01       	movw	r24, r30
    1b88:	31 91       	ld	r19, Z+
    1b8a:	da 01       	movw	r26, r20
    1b8c:	3d 93       	st	X+, r19
    1b8e:	ad 01       	movw	r20, r26
    1b90:	dc 01       	movw	r26, r24
    1b92:	8c 91       	ld	r24, X
    1b94:	88 23       	and	r24, r24
    1b96:	11 f0       	breq	.+4      	; 0x1b9c <xTaskGenericCreate+0x6e>
    1b98:	21 50       	subi	r18, 0x01	; 1
    1b9a:	a9 f7       	brne	.-22     	; 0x1b86 <xTaskGenericCreate+0x58>
    1b9c:	18 a2       	std	Y+32, r1	; 0x20
    1b9e:	10 2f       	mov	r17, r16
    1ba0:	05 30       	cpi	r16, 0x05	; 5
    1ba2:	08 f0       	brcs	.+2      	; 0x1ba6 <xTaskGenericCreate+0x78>
    1ba4:	14 e0       	ldi	r17, 0x04	; 4
    1ba6:	1e 8b       	std	Y+22, r17	; 0x16
    1ba8:	19 a3       	std	Y+33, r17	; 0x21
    1baa:	1a a2       	std	Y+34, r1	; 0x22
    1bac:	5e 01       	movw	r10, r28
    1bae:	b2 e0       	ldi	r27, 0x02	; 2
    1bb0:	ab 0e       	add	r10, r27
    1bb2:	b1 1c       	adc	r11, r1
    1bb4:	c5 01       	movw	r24, r10
    1bb6:	0e 94 03 03 	call	0x606	; 0x606 <vListInitialiseItem>
    1bba:	ce 01       	movw	r24, r28
    1bbc:	0c 96       	adiw	r24, 0x0c	; 12
    1bbe:	0e 94 03 03 	call	0x606	; 0x606 <vListInitialiseItem>
    1bc2:	d9 87       	std	Y+9, r29	; 0x09
    1bc4:	c8 87       	std	Y+8, r28	; 0x08
    1bc6:	85 e0       	ldi	r24, 0x05	; 5
    1bc8:	90 e0       	ldi	r25, 0x00	; 0
    1bca:	81 1b       	sub	r24, r17
    1bcc:	91 09       	sbc	r25, r1
    1bce:	9d 87       	std	Y+13, r25	; 0x0d
    1bd0:	8c 87       	std	Y+12, r24	; 0x0c
    1bd2:	db 8b       	std	Y+19, r29	; 0x13
    1bd4:	ca 8b       	std	Y+18, r28	; 0x12
    1bd6:	a3 01       	movw	r20, r6
    1bd8:	b4 01       	movw	r22, r8
    1bda:	c6 01       	movw	r24, r12
    1bdc:	c1 da       	rcall	.-2686   	; 0x1160 <pxPortInitialiseStack>
    1bde:	99 83       	std	Y+1, r25	; 0x01
    1be0:	88 83       	st	Y, r24
    1be2:	e1 14       	cp	r14, r1
    1be4:	f1 04       	cpc	r15, r1
    1be6:	19 f0       	breq	.+6      	; 0x1bee <xTaskGenericCreate+0xc0>
    1be8:	f7 01       	movw	r30, r14
    1bea:	d1 83       	std	Z+1, r29	; 0x01
    1bec:	c0 83       	st	Z, r28
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	0f 92       	push	r0
    1bf4:	80 91 2d 08 	lds	r24, 0x082D
    1bf8:	8f 5f       	subi	r24, 0xFF	; 255
    1bfa:	80 93 2d 08 	sts	0x082D, r24
    1bfe:	80 91 8d 08 	lds	r24, 0x088D
    1c02:	90 91 8e 08 	lds	r25, 0x088E
    1c06:	89 2b       	or	r24, r25
    1c08:	09 f0       	breq	.+2      	; 0x1c0c <xTaskGenericCreate+0xde>
    1c0a:	3f c0       	rjmp	.+126    	; 0x1c8a <xTaskGenericCreate+0x15c>
    1c0c:	d0 93 8e 08 	sts	0x088E, r29
    1c10:	c0 93 8d 08 	sts	0x088D, r28
    1c14:	80 91 2d 08 	lds	r24, 0x082D
    1c18:	81 30       	cpi	r24, 0x01	; 1
    1c1a:	09 f0       	breq	.+2      	; 0x1c1e <xTaskGenericCreate+0xf0>
    1c1c:	45 c0       	rjmp	.+138    	; 0x1ca8 <xTaskGenericCreate+0x17a>
    1c1e:	0f 2e       	mov	r0, r31
    1c20:	f0 e6       	ldi	r31, 0x60	; 96
    1c22:	ef 2e       	mov	r14, r31
    1c24:	f8 e0       	ldi	r31, 0x08	; 8
    1c26:	ff 2e       	mov	r15, r31
    1c28:	f0 2d       	mov	r31, r0
    1c2a:	0f 2e       	mov	r0, r31
    1c2c:	fd e8       	ldi	r31, 0x8D	; 141
    1c2e:	cf 2e       	mov	r12, r31
    1c30:	f8 e0       	ldi	r31, 0x08	; 8
    1c32:	df 2e       	mov	r13, r31
    1c34:	f0 2d       	mov	r31, r0
    1c36:	c7 01       	movw	r24, r14
    1c38:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c3c:	f9 e0       	ldi	r31, 0x09	; 9
    1c3e:	ef 0e       	add	r14, r31
    1c40:	f1 1c       	adc	r15, r1
    1c42:	ec 14       	cp	r14, r12
    1c44:	fd 04       	cpc	r15, r13
    1c46:	b9 f7       	brne	.-18     	; 0x1c36 <xTaskGenericCreate+0x108>
    1c48:	87 e5       	ldi	r24, 0x57	; 87
    1c4a:	98 e0       	ldi	r25, 0x08	; 8
    1c4c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c50:	8e e4       	ldi	r24, 0x4E	; 78
    1c52:	98 e0       	ldi	r25, 0x08	; 8
    1c54:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c58:	81 e4       	ldi	r24, 0x41	; 65
    1c5a:	98 e0       	ldi	r25, 0x08	; 8
    1c5c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c60:	88 e3       	ldi	r24, 0x38	; 56
    1c62:	98 e0       	ldi	r25, 0x08	; 8
    1c64:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c68:	8e e2       	ldi	r24, 0x2E	; 46
    1c6a:	98 e0       	ldi	r25, 0x08	; 8
    1c6c:	0e 94 f5 02 	call	0x5ea	; 0x5ea <vListInitialise>
    1c70:	87 e5       	ldi	r24, 0x57	; 87
    1c72:	98 e0       	ldi	r25, 0x08	; 8
    1c74:	90 93 4d 08 	sts	0x084D, r25
    1c78:	80 93 4c 08 	sts	0x084C, r24
    1c7c:	8e e4       	ldi	r24, 0x4E	; 78
    1c7e:	98 e0       	ldi	r25, 0x08	; 8
    1c80:	90 93 4b 08 	sts	0x084B, r25
    1c84:	80 93 4a 08 	sts	0x084A, r24
    1c88:	0f c0       	rjmp	.+30     	; 0x1ca8 <xTaskGenericCreate+0x17a>
    1c8a:	80 91 29 08 	lds	r24, 0x0829
    1c8e:	81 11       	cpse	r24, r1
    1c90:	0b c0       	rjmp	.+22     	; 0x1ca8 <xTaskGenericCreate+0x17a>
    1c92:	e0 91 8d 08 	lds	r30, 0x088D
    1c96:	f0 91 8e 08 	lds	r31, 0x088E
    1c9a:	86 89       	ldd	r24, Z+22	; 0x16
    1c9c:	08 17       	cp	r16, r24
    1c9e:	20 f0       	brcs	.+8      	; 0x1ca8 <xTaskGenericCreate+0x17a>
    1ca0:	d0 93 8e 08 	sts	0x088E, r29
    1ca4:	c0 93 8d 08 	sts	0x088D, r28
    1ca8:	80 91 25 08 	lds	r24, 0x0825
    1cac:	8f 5f       	subi	r24, 0xFF	; 255
    1cae:	80 93 25 08 	sts	0x0825, r24
    1cb2:	8e 89       	ldd	r24, Y+22	; 0x16
    1cb4:	90 91 2a 08 	lds	r25, 0x082A
    1cb8:	98 17       	cp	r25, r24
    1cba:	10 f4       	brcc	.+4      	; 0x1cc0 <xTaskGenericCreate+0x192>
    1cbc:	80 93 2a 08 	sts	0x082A, r24
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	9c 01       	movw	r18, r24
    1cc4:	22 0f       	add	r18, r18
    1cc6:	33 1f       	adc	r19, r19
    1cc8:	22 0f       	add	r18, r18
    1cca:	33 1f       	adc	r19, r19
    1ccc:	22 0f       	add	r18, r18
    1cce:	33 1f       	adc	r19, r19
    1cd0:	82 0f       	add	r24, r18
    1cd2:	93 1f       	adc	r25, r19
    1cd4:	b5 01       	movw	r22, r10
    1cd6:	80 5a       	subi	r24, 0xA0	; 160
    1cd8:	97 4f       	sbci	r25, 0xF7	; 247
    1cda:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    1cde:	0f 90       	pop	r0
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	80 91 29 08 	lds	r24, 0x0829
    1ce6:	88 23       	and	r24, r24
    1ce8:	51 f0       	breq	.+20     	; 0x1cfe <xTaskGenericCreate+0x1d0>
    1cea:	e0 91 8d 08 	lds	r30, 0x088D
    1cee:	f0 91 8e 08 	lds	r31, 0x088E
    1cf2:	86 89       	ldd	r24, Z+22	; 0x16
    1cf4:	80 17       	cp	r24, r16
    1cf6:	28 f4       	brcc	.+10     	; 0x1d02 <xTaskGenericCreate+0x1d4>
    1cf8:	e2 da       	rcall	.-2620   	; 0x12be <vPortYield>
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	1c c0       	rjmp	.+56     	; 0x1d36 <xTaskGenericCreate+0x208>
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	1a c0       	rjmp	.+52     	; 0x1d36 <xTaskGenericCreate+0x208>
    1d02:	81 e0       	ldi	r24, 0x01	; 1
    1d04:	18 c0       	rjmp	.+48     	; 0x1d36 <xTaskGenericCreate+0x208>
    1d06:	d8 8e       	std	Y+24, r13	; 0x18
    1d08:	cf 8a       	std	Y+23, r12	; 0x17
    1d0a:	81 e0       	ldi	r24, 0x01	; 1
    1d0c:	48 1a       	sub	r4, r24
    1d0e:	51 08       	sbc	r5, r1
    1d10:	cf 88       	ldd	r12, Y+23	; 0x17
    1d12:	d8 8c       	ldd	r13, Y+24	; 0x18
    1d14:	c4 0c       	add	r12, r4
    1d16:	d5 1c       	adc	r13, r5
    1d18:	d5 01       	movw	r26, r10
    1d1a:	8c 91       	ld	r24, X
    1d1c:	89 8f       	std	Y+25, r24	; 0x19
    1d1e:	8c 91       	ld	r24, X
    1d20:	88 23       	and	r24, r24
    1d22:	09 f4       	brne	.+2      	; 0x1d26 <xTaskGenericCreate+0x1f8>
    1d24:	3b cf       	rjmp	.-394    	; 0x1b9c <xTaskGenericCreate+0x6e>
    1d26:	ae 01       	movw	r20, r28
    1d28:	46 5e       	subi	r20, 0xE6	; 230
    1d2a:	5f 4f       	sbci	r21, 0xFF	; 255
    1d2c:	f5 01       	movw	r30, r10
    1d2e:	31 96       	adiw	r30, 0x01	; 1
    1d30:	27 e0       	ldi	r18, 0x07	; 7
    1d32:	29 cf       	rjmp	.-430    	; 0x1b86 <xTaskGenericCreate+0x58>
    1d34:	8f ef       	ldi	r24, 0xFF	; 255
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	1f 91       	pop	r17
    1d3c:	0f 91       	pop	r16
    1d3e:	ff 90       	pop	r15
    1d40:	ef 90       	pop	r14
    1d42:	df 90       	pop	r13
    1d44:	cf 90       	pop	r12
    1d46:	bf 90       	pop	r11
    1d48:	af 90       	pop	r10
    1d4a:	9f 90       	pop	r9
    1d4c:	8f 90       	pop	r8
    1d4e:	7f 90       	pop	r7
    1d50:	6f 90       	pop	r6
    1d52:	5f 90       	pop	r5
    1d54:	4f 90       	pop	r4
    1d56:	08 95       	ret

00001d58 <vTaskResume>:
    1d58:	0f 93       	push	r16
    1d5a:	1f 93       	push	r17
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
    1d60:	ec 01       	movw	r28, r24
    1d62:	00 97       	sbiw	r24, 0x00	; 0
    1d64:	09 f4       	brne	.+2      	; 0x1d68 <vTaskResume+0x10>
    1d66:	3e c0       	rjmp	.+124    	; 0x1de4 <vTaskResume+0x8c>
    1d68:	80 91 8d 08 	lds	r24, 0x088D
    1d6c:	90 91 8e 08 	lds	r25, 0x088E
    1d70:	c8 17       	cp	r28, r24
    1d72:	d9 07       	cpc	r29, r25
    1d74:	b9 f1       	breq	.+110    	; 0x1de4 <vTaskResume+0x8c>
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	f8 94       	cli
    1d7a:	0f 92       	push	r0
    1d7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d80:	8e 52       	subi	r24, 0x2E	; 46
    1d82:	98 40       	sbci	r25, 0x08	; 8
    1d84:	69 f5       	brne	.+90     	; 0x1de0 <vTaskResume+0x88>
    1d86:	8c 89       	ldd	r24, Y+20	; 0x14
    1d88:	9d 89       	ldd	r25, Y+21	; 0x15
    1d8a:	28 e0       	ldi	r18, 0x08	; 8
    1d8c:	81 34       	cpi	r24, 0x41	; 65
    1d8e:	92 07       	cpc	r25, r18
    1d90:	39 f1       	breq	.+78     	; 0x1de0 <vTaskResume+0x88>
    1d92:	89 2b       	or	r24, r25
    1d94:	29 f5       	brne	.+74     	; 0x1de0 <vTaskResume+0x88>
    1d96:	8e 01       	movw	r16, r28
    1d98:	0e 5f       	subi	r16, 0xFE	; 254
    1d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d9c:	c8 01       	movw	r24, r16
    1d9e:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    1da2:	8e 89       	ldd	r24, Y+22	; 0x16
    1da4:	90 91 2a 08 	lds	r25, 0x082A
    1da8:	98 17       	cp	r25, r24
    1daa:	10 f4       	brcc	.+4      	; 0x1db0 <vTaskResume+0x58>
    1dac:	80 93 2a 08 	sts	0x082A, r24
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	9c 01       	movw	r18, r24
    1db4:	22 0f       	add	r18, r18
    1db6:	33 1f       	adc	r19, r19
    1db8:	22 0f       	add	r18, r18
    1dba:	33 1f       	adc	r19, r19
    1dbc:	22 0f       	add	r18, r18
    1dbe:	33 1f       	adc	r19, r19
    1dc0:	82 0f       	add	r24, r18
    1dc2:	93 1f       	adc	r25, r19
    1dc4:	b8 01       	movw	r22, r16
    1dc6:	80 5a       	subi	r24, 0xA0	; 160
    1dc8:	97 4f       	sbci	r25, 0xF7	; 247
    1dca:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    1dce:	e0 91 8d 08 	lds	r30, 0x088D
    1dd2:	f0 91 8e 08 	lds	r31, 0x088E
    1dd6:	9e 89       	ldd	r25, Y+22	; 0x16
    1dd8:	86 89       	ldd	r24, Z+22	; 0x16
    1dda:	98 17       	cp	r25, r24
    1ddc:	08 f0       	brcs	.+2      	; 0x1de0 <vTaskResume+0x88>
    1dde:	6f da       	rcall	.-2850   	; 0x12be <vPortYield>
    1de0:	0f 90       	pop	r0
    1de2:	0f be       	out	0x3f, r0	; 63
    1de4:	df 91       	pop	r29
    1de6:	cf 91       	pop	r28
    1de8:	1f 91       	pop	r17
    1dea:	0f 91       	pop	r16
    1dec:	08 95       	ret

00001dee <vTaskStartScheduler>:
    1dee:	af 92       	push	r10
    1df0:	bf 92       	push	r11
    1df2:	cf 92       	push	r12
    1df4:	df 92       	push	r13
    1df6:	ef 92       	push	r14
    1df8:	ff 92       	push	r15
    1dfa:	0f 93       	push	r16
    1dfc:	a1 2c       	mov	r10, r1
    1dfe:	b1 2c       	mov	r11, r1
    1e00:	c1 2c       	mov	r12, r1
    1e02:	d1 2c       	mov	r13, r1
    1e04:	e1 2c       	mov	r14, r1
    1e06:	f1 2c       	mov	r15, r1
    1e08:	00 e0       	ldi	r16, 0x00	; 0
    1e0a:	20 e0       	ldi	r18, 0x00	; 0
    1e0c:	30 e0       	ldi	r19, 0x00	; 0
    1e0e:	45 e5       	ldi	r20, 0x55	; 85
    1e10:	50 e0       	ldi	r21, 0x00	; 0
    1e12:	69 e3       	ldi	r22, 0x39	; 57
    1e14:	72 e0       	ldi	r23, 0x02	; 2
    1e16:	8e ec       	ldi	r24, 0xCE	; 206
    1e18:	90 e1       	ldi	r25, 0x10	; 16
    1e1a:	89 de       	rcall	.-750    	; 0x1b2e <xTaskGenericCreate>
    1e1c:	81 30       	cpi	r24, 0x01	; 1
    1e1e:	41 f4       	brne	.+16     	; 0x1e30 <vTaskStartScheduler+0x42>
    1e20:	f8 94       	cli
    1e22:	80 93 29 08 	sts	0x0829, r24
    1e26:	10 92 2c 08 	sts	0x082C, r1
    1e2a:	10 92 2b 08 	sts	0x082B, r1
    1e2e:	0a da       	rcall	.-3052   	; 0x1244 <xPortStartScheduler>
    1e30:	0f 91       	pop	r16
    1e32:	ff 90       	pop	r15
    1e34:	ef 90       	pop	r14
    1e36:	df 90       	pop	r13
    1e38:	cf 90       	pop	r12
    1e3a:	bf 90       	pop	r11
    1e3c:	af 90       	pop	r10
    1e3e:	08 95       	ret

00001e40 <vTaskSuspendAll>:
    1e40:	80 91 24 08 	lds	r24, 0x0824
    1e44:	8f 5f       	subi	r24, 0xFF	; 255
    1e46:	80 93 24 08 	sts	0x0824, r24
    1e4a:	08 95       	ret

00001e4c <xTaskGetTickCount>:
    1e4c:	0f b6       	in	r0, 0x3f	; 63
    1e4e:	f8 94       	cli
    1e50:	0f 92       	push	r0
    1e52:	80 91 2b 08 	lds	r24, 0x082B
    1e56:	90 91 2c 08 	lds	r25, 0x082C
    1e5a:	0f 90       	pop	r0
    1e5c:	0f be       	out	0x3f, r0	; 63
    1e5e:	08 95       	ret

00001e60 <xTaskGetTickCountFromISR>:
    1e60:	80 91 2b 08 	lds	r24, 0x082B
    1e64:	90 91 2c 08 	lds	r25, 0x082C
    1e68:	08 95       	ret

00001e6a <xTaskIncrementTick>:
    1e6a:	cf 92       	push	r12
    1e6c:	df 92       	push	r13
    1e6e:	ef 92       	push	r14
    1e70:	ff 92       	push	r15
    1e72:	0f 93       	push	r16
    1e74:	1f 93       	push	r17
    1e76:	cf 93       	push	r28
    1e78:	df 93       	push	r29
    1e7a:	80 91 24 08 	lds	r24, 0x0824
    1e7e:	81 11       	cpse	r24, r1
    1e80:	99 c0       	rjmp	.+306    	; 0x1fb4 <xTaskIncrementTick+0x14a>
    1e82:	80 91 2b 08 	lds	r24, 0x082B
    1e86:	90 91 2c 08 	lds	r25, 0x082C
    1e8a:	01 96       	adiw	r24, 0x01	; 1
    1e8c:	90 93 2c 08 	sts	0x082C, r25
    1e90:	80 93 2b 08 	sts	0x082B, r24
    1e94:	e0 90 2b 08 	lds	r14, 0x082B
    1e98:	f0 90 2c 08 	lds	r15, 0x082C
    1e9c:	e1 14       	cp	r14, r1
    1e9e:	f1 04       	cpc	r15, r1
    1ea0:	b1 f4       	brne	.+44     	; 0x1ece <xTaskIncrementTick+0x64>
    1ea2:	80 91 4c 08 	lds	r24, 0x084C
    1ea6:	90 91 4d 08 	lds	r25, 0x084D
    1eaa:	20 91 4a 08 	lds	r18, 0x084A
    1eae:	30 91 4b 08 	lds	r19, 0x084B
    1eb2:	30 93 4d 08 	sts	0x084D, r19
    1eb6:	20 93 4c 08 	sts	0x084C, r18
    1eba:	90 93 4b 08 	sts	0x084B, r25
    1ebe:	80 93 4a 08 	sts	0x084A, r24
    1ec2:	80 91 26 08 	lds	r24, 0x0826
    1ec6:	8f 5f       	subi	r24, 0xFF	; 255
    1ec8:	80 93 26 08 	sts	0x0826, r24
    1ecc:	da dd       	rcall	.-1100   	; 0x1a82 <prvResetNextTaskUnblockTime>
    1ece:	80 91 04 02 	lds	r24, 0x0204
    1ed2:	90 91 05 02 	lds	r25, 0x0205
    1ed6:	e8 16       	cp	r14, r24
    1ed8:	f9 06       	cpc	r15, r25
    1eda:	08 f4       	brcc	.+2      	; 0x1ede <xTaskIncrementTick+0x74>
    1edc:	54 c0       	rjmp	.+168    	; 0x1f86 <xTaskIncrementTick+0x11c>
    1ede:	d1 2c       	mov	r13, r1
    1ee0:	cc 24       	eor	r12, r12
    1ee2:	c3 94       	inc	r12
    1ee4:	01 c0       	rjmp	.+2      	; 0x1ee8 <xTaskIncrementTick+0x7e>
    1ee6:	dc 2c       	mov	r13, r12
    1ee8:	e0 91 4c 08 	lds	r30, 0x084C
    1eec:	f0 91 4d 08 	lds	r31, 0x084D
    1ef0:	80 81       	ld	r24, Z
    1ef2:	81 11       	cpse	r24, r1
    1ef4:	07 c0       	rjmp	.+14     	; 0x1f04 <xTaskIncrementTick+0x9a>
    1ef6:	8f ef       	ldi	r24, 0xFF	; 255
    1ef8:	9f ef       	ldi	r25, 0xFF	; 255
    1efa:	90 93 05 02 	sts	0x0205, r25
    1efe:	80 93 04 02 	sts	0x0204, r24
    1f02:	42 c0       	rjmp	.+132    	; 0x1f88 <xTaskIncrementTick+0x11e>
    1f04:	e0 91 4c 08 	lds	r30, 0x084C
    1f08:	f0 91 4d 08 	lds	r31, 0x084D
    1f0c:	05 80       	ldd	r0, Z+5	; 0x05
    1f0e:	f6 81       	ldd	r31, Z+6	; 0x06
    1f10:	e0 2d       	mov	r30, r0
    1f12:	c6 81       	ldd	r28, Z+6	; 0x06
    1f14:	d7 81       	ldd	r29, Z+7	; 0x07
    1f16:	2a 81       	ldd	r18, Y+2	; 0x02
    1f18:	3b 81       	ldd	r19, Y+3	; 0x03
    1f1a:	e2 16       	cp	r14, r18
    1f1c:	f3 06       	cpc	r15, r19
    1f1e:	28 f4       	brcc	.+10     	; 0x1f2a <xTaskIncrementTick+0xc0>
    1f20:	30 93 05 02 	sts	0x0205, r19
    1f24:	20 93 04 02 	sts	0x0204, r18
    1f28:	2f c0       	rjmp	.+94     	; 0x1f88 <xTaskIncrementTick+0x11e>
    1f2a:	8e 01       	movw	r16, r28
    1f2c:	0e 5f       	subi	r16, 0xFE	; 254
    1f2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1f30:	c8 01       	movw	r24, r16
    1f32:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    1f36:	8c 89       	ldd	r24, Y+20	; 0x14
    1f38:	9d 89       	ldd	r25, Y+21	; 0x15
    1f3a:	89 2b       	or	r24, r25
    1f3c:	21 f0       	breq	.+8      	; 0x1f46 <xTaskIncrementTick+0xdc>
    1f3e:	ce 01       	movw	r24, r28
    1f40:	0c 96       	adiw	r24, 0x0c	; 12
    1f42:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    1f46:	2e 89       	ldd	r18, Y+22	; 0x16
    1f48:	80 91 2a 08 	lds	r24, 0x082A
    1f4c:	82 17       	cp	r24, r18
    1f4e:	10 f4       	brcc	.+4      	; 0x1f54 <xTaskIncrementTick+0xea>
    1f50:	20 93 2a 08 	sts	0x082A, r18
    1f54:	30 e0       	ldi	r19, 0x00	; 0
    1f56:	c9 01       	movw	r24, r18
    1f58:	88 0f       	add	r24, r24
    1f5a:	99 1f       	adc	r25, r25
    1f5c:	88 0f       	add	r24, r24
    1f5e:	99 1f       	adc	r25, r25
    1f60:	88 0f       	add	r24, r24
    1f62:	99 1f       	adc	r25, r25
    1f64:	82 0f       	add	r24, r18
    1f66:	93 1f       	adc	r25, r19
    1f68:	b8 01       	movw	r22, r16
    1f6a:	80 5a       	subi	r24, 0xA0	; 160
    1f6c:	97 4f       	sbci	r25, 0xF7	; 247
    1f6e:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    1f72:	e0 91 8d 08 	lds	r30, 0x088D
    1f76:	f0 91 8e 08 	lds	r31, 0x088E
    1f7a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f7c:	86 89       	ldd	r24, Z+22	; 0x16
    1f7e:	98 17       	cp	r25, r24
    1f80:	08 f0       	brcs	.+2      	; 0x1f84 <xTaskIncrementTick+0x11a>
    1f82:	b1 cf       	rjmp	.-158    	; 0x1ee6 <xTaskIncrementTick+0x7c>
    1f84:	b1 cf       	rjmp	.-158    	; 0x1ee8 <xTaskIncrementTick+0x7e>
    1f86:	d1 2c       	mov	r13, r1
    1f88:	e0 91 8d 08 	lds	r30, 0x088D
    1f8c:	f0 91 8e 08 	lds	r31, 0x088E
    1f90:	86 89       	ldd	r24, Z+22	; 0x16
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	fc 01       	movw	r30, r24
    1f96:	ee 0f       	add	r30, r30
    1f98:	ff 1f       	adc	r31, r31
    1f9a:	ee 0f       	add	r30, r30
    1f9c:	ff 1f       	adc	r31, r31
    1f9e:	ee 0f       	add	r30, r30
    1fa0:	ff 1f       	adc	r31, r31
    1fa2:	8e 0f       	add	r24, r30
    1fa4:	9f 1f       	adc	r25, r31
    1fa6:	fc 01       	movw	r30, r24
    1fa8:	e0 5a       	subi	r30, 0xA0	; 160
    1faa:	f7 4f       	sbci	r31, 0xF7	; 247
    1fac:	80 81       	ld	r24, Z
    1fae:	82 30       	cpi	r24, 0x02	; 2
    1fb0:	40 f4       	brcc	.+16     	; 0x1fc2 <xTaskIncrementTick+0x158>
    1fb2:	09 c0       	rjmp	.+18     	; 0x1fc6 <xTaskIncrementTick+0x15c>
    1fb4:	80 91 28 08 	lds	r24, 0x0828
    1fb8:	8f 5f       	subi	r24, 0xFF	; 255
    1fba:	80 93 28 08 	sts	0x0828, r24
    1fbe:	d1 2c       	mov	r13, r1
    1fc0:	02 c0       	rjmp	.+4      	; 0x1fc6 <xTaskIncrementTick+0x15c>
    1fc2:	dd 24       	eor	r13, r13
    1fc4:	d3 94       	inc	r13
    1fc6:	80 91 27 08 	lds	r24, 0x0827
    1fca:	88 23       	and	r24, r24
    1fcc:	11 f0       	breq	.+4      	; 0x1fd2 <xTaskIncrementTick+0x168>
    1fce:	dd 24       	eor	r13, r13
    1fd0:	d3 94       	inc	r13
    1fd2:	8d 2d       	mov	r24, r13
    1fd4:	df 91       	pop	r29
    1fd6:	cf 91       	pop	r28
    1fd8:	1f 91       	pop	r17
    1fda:	0f 91       	pop	r16
    1fdc:	ff 90       	pop	r15
    1fde:	ef 90       	pop	r14
    1fe0:	df 90       	pop	r13
    1fe2:	cf 90       	pop	r12
    1fe4:	08 95       	ret

00001fe6 <xTaskResumeAll>:
    1fe6:	df 92       	push	r13
    1fe8:	ef 92       	push	r14
    1fea:	ff 92       	push	r15
    1fec:	0f 93       	push	r16
    1fee:	1f 93       	push	r17
    1ff0:	cf 93       	push	r28
    1ff2:	df 93       	push	r29
    1ff4:	0f b6       	in	r0, 0x3f	; 63
    1ff6:	f8 94       	cli
    1ff8:	0f 92       	push	r0
    1ffa:	80 91 24 08 	lds	r24, 0x0824
    1ffe:	81 50       	subi	r24, 0x01	; 1
    2000:	80 93 24 08 	sts	0x0824, r24
    2004:	80 91 24 08 	lds	r24, 0x0824
    2008:	81 11       	cpse	r24, r1
    200a:	5f c0       	rjmp	.+190    	; 0x20ca <xTaskResumeAll+0xe4>
    200c:	80 91 2d 08 	lds	r24, 0x082D
    2010:	88 23       	and	r24, r24
    2012:	09 f4       	brne	.+2      	; 0x2016 <xTaskResumeAll+0x30>
    2014:	5c c0       	rjmp	.+184    	; 0x20ce <xTaskResumeAll+0xe8>
    2016:	0f 2e       	mov	r0, r31
    2018:	f1 e4       	ldi	r31, 0x41	; 65
    201a:	ef 2e       	mov	r14, r31
    201c:	f8 e0       	ldi	r31, 0x08	; 8
    201e:	ff 2e       	mov	r15, r31
    2020:	f0 2d       	mov	r31, r0
    2022:	dd 24       	eor	r13, r13
    2024:	d3 94       	inc	r13
    2026:	30 c0       	rjmp	.+96     	; 0x2088 <xTaskResumeAll+0xa2>
    2028:	e0 91 46 08 	lds	r30, 0x0846
    202c:	f0 91 47 08 	lds	r31, 0x0847
    2030:	c6 81       	ldd	r28, Z+6	; 0x06
    2032:	d7 81       	ldd	r29, Z+7	; 0x07
    2034:	ce 01       	movw	r24, r28
    2036:	0c 96       	adiw	r24, 0x0c	; 12
    2038:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    203c:	8e 01       	movw	r16, r28
    203e:	0e 5f       	subi	r16, 0xFE	; 254
    2040:	1f 4f       	sbci	r17, 0xFF	; 255
    2042:	c8 01       	movw	r24, r16
    2044:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    2048:	8e 89       	ldd	r24, Y+22	; 0x16
    204a:	90 91 2a 08 	lds	r25, 0x082A
    204e:	98 17       	cp	r25, r24
    2050:	10 f4       	brcc	.+4      	; 0x2056 <xTaskResumeAll+0x70>
    2052:	80 93 2a 08 	sts	0x082A, r24
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	9c 01       	movw	r18, r24
    205a:	22 0f       	add	r18, r18
    205c:	33 1f       	adc	r19, r19
    205e:	22 0f       	add	r18, r18
    2060:	33 1f       	adc	r19, r19
    2062:	22 0f       	add	r18, r18
    2064:	33 1f       	adc	r19, r19
    2066:	82 0f       	add	r24, r18
    2068:	93 1f       	adc	r25, r19
    206a:	b8 01       	movw	r22, r16
    206c:	80 5a       	subi	r24, 0xA0	; 160
    206e:	97 4f       	sbci	r25, 0xF7	; 247
    2070:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    2074:	e0 91 8d 08 	lds	r30, 0x088D
    2078:	f0 91 8e 08 	lds	r31, 0x088E
    207c:	9e 89       	ldd	r25, Y+22	; 0x16
    207e:	86 89       	ldd	r24, Z+22	; 0x16
    2080:	98 17       	cp	r25, r24
    2082:	10 f0       	brcs	.+4      	; 0x2088 <xTaskResumeAll+0xa2>
    2084:	d0 92 27 08 	sts	0x0827, r13
    2088:	f7 01       	movw	r30, r14
    208a:	80 81       	ld	r24, Z
    208c:	81 11       	cpse	r24, r1
    208e:	cc cf       	rjmp	.-104    	; 0x2028 <xTaskResumeAll+0x42>
    2090:	80 91 28 08 	lds	r24, 0x0828
    2094:	88 23       	and	r24, r24
    2096:	91 f0       	breq	.+36     	; 0x20bc <xTaskResumeAll+0xd6>
    2098:	80 91 28 08 	lds	r24, 0x0828
    209c:	88 23       	and	r24, r24
    209e:	71 f0       	breq	.+28     	; 0x20bc <xTaskResumeAll+0xd6>
    20a0:	c1 e0       	ldi	r28, 0x01	; 1
    20a2:	e3 de       	rcall	.-570    	; 0x1e6a <xTaskIncrementTick>
    20a4:	81 11       	cpse	r24, r1
    20a6:	c0 93 27 08 	sts	0x0827, r28
    20aa:	80 91 28 08 	lds	r24, 0x0828
    20ae:	81 50       	subi	r24, 0x01	; 1
    20b0:	80 93 28 08 	sts	0x0828, r24
    20b4:	80 91 28 08 	lds	r24, 0x0828
    20b8:	81 11       	cpse	r24, r1
    20ba:	f3 cf       	rjmp	.-26     	; 0x20a2 <xTaskResumeAll+0xbc>
    20bc:	80 91 27 08 	lds	r24, 0x0827
    20c0:	81 30       	cpi	r24, 0x01	; 1
    20c2:	39 f4       	brne	.+14     	; 0x20d2 <xTaskResumeAll+0xec>
    20c4:	fc d8       	rcall	.-3592   	; 0x12be <vPortYield>
    20c6:	81 e0       	ldi	r24, 0x01	; 1
    20c8:	05 c0       	rjmp	.+10     	; 0x20d4 <xTaskResumeAll+0xee>
    20ca:	80 e0       	ldi	r24, 0x00	; 0
    20cc:	03 c0       	rjmp	.+6      	; 0x20d4 <xTaskResumeAll+0xee>
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <xTaskResumeAll+0xee>
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	0f 90       	pop	r0
    20d6:	0f be       	out	0x3f, r0	; 63
    20d8:	df 91       	pop	r29
    20da:	cf 91       	pop	r28
    20dc:	1f 91       	pop	r17
    20de:	0f 91       	pop	r16
    20e0:	ff 90       	pop	r15
    20e2:	ef 90       	pop	r14
    20e4:	df 90       	pop	r13
    20e6:	08 95       	ret

000020e8 <vTaskDelayUntil>:
    20e8:	0f 93       	push	r16
    20ea:	1f 93       	push	r17
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	8c 01       	movw	r16, r24
    20f2:	eb 01       	movw	r28, r22
    20f4:	a5 de       	rcall	.-694    	; 0x1e40 <vTaskSuspendAll>
    20f6:	80 91 2b 08 	lds	r24, 0x082B
    20fa:	90 91 2c 08 	lds	r25, 0x082C
    20fe:	f8 01       	movw	r30, r16
    2100:	20 81       	ld	r18, Z
    2102:	31 81       	ldd	r19, Z+1	; 0x01
    2104:	c2 0f       	add	r28, r18
    2106:	d3 1f       	adc	r29, r19
    2108:	82 17       	cp	r24, r18
    210a:	93 07       	cpc	r25, r19
    210c:	48 f4       	brcc	.+18     	; 0x2120 <vTaskDelayUntil+0x38>
    210e:	c2 17       	cp	r28, r18
    2110:	d3 07       	cpc	r29, r19
    2112:	f8 f4       	brcc	.+62     	; 0x2152 <vTaskDelayUntil+0x6a>
    2114:	d1 83       	std	Z+1, r29	; 0x01
    2116:	c0 83       	st	Z, r28
    2118:	8c 17       	cp	r24, r28
    211a:	9d 07       	cpc	r25, r29
    211c:	88 f4       	brcc	.+34     	; 0x2140 <vTaskDelayUntil+0x58>
    211e:	07 c0       	rjmp	.+14     	; 0x212e <vTaskDelayUntil+0x46>
    2120:	c2 17       	cp	r28, r18
    2122:	d3 07       	cpc	r29, r19
    2124:	90 f0       	brcs	.+36     	; 0x214a <vTaskDelayUntil+0x62>
    2126:	8c 17       	cp	r24, r28
    2128:	9d 07       	cpc	r25, r29
    212a:	78 f0       	brcs	.+30     	; 0x214a <vTaskDelayUntil+0x62>
    212c:	12 c0       	rjmp	.+36     	; 0x2152 <vTaskDelayUntil+0x6a>
    212e:	80 91 8d 08 	lds	r24, 0x088D
    2132:	90 91 8e 08 	lds	r25, 0x088E
    2136:	02 96       	adiw	r24, 0x02	; 2
    2138:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    213c:	ce 01       	movw	r24, r28
    213e:	c0 dc       	rcall	.-1664   	; 0x1ac0 <prvAddCurrentTaskToDelayedList>
    2140:	52 df       	rcall	.-348    	; 0x1fe6 <xTaskResumeAll>
    2142:	81 11       	cpse	r24, r1
    2144:	0a c0       	rjmp	.+20     	; 0x215a <vTaskDelayUntil+0x72>
    2146:	bb d8       	rcall	.-3722   	; 0x12be <vPortYield>
    2148:	08 c0       	rjmp	.+16     	; 0x215a <vTaskDelayUntil+0x72>
    214a:	f8 01       	movw	r30, r16
    214c:	d1 83       	std	Z+1, r29	; 0x01
    214e:	c0 83       	st	Z, r28
    2150:	ee cf       	rjmp	.-36     	; 0x212e <vTaskDelayUntil+0x46>
    2152:	f8 01       	movw	r30, r16
    2154:	d1 83       	std	Z+1, r29	; 0x01
    2156:	c0 83       	st	Z, r28
    2158:	f3 cf       	rjmp	.-26     	; 0x2140 <vTaskDelayUntil+0x58>
    215a:	df 91       	pop	r29
    215c:	cf 91       	pop	r28
    215e:	1f 91       	pop	r17
    2160:	0f 91       	pop	r16
    2162:	08 95       	ret

00002164 <vTaskDelay>:
    2164:	cf 93       	push	r28
    2166:	df 93       	push	r29
    2168:	ec 01       	movw	r28, r24
    216a:	00 97       	sbiw	r24, 0x00	; 0
    216c:	99 f0       	breq	.+38     	; 0x2194 <vTaskDelay+0x30>
    216e:	68 de       	rcall	.-816    	; 0x1e40 <vTaskSuspendAll>
    2170:	80 91 2b 08 	lds	r24, 0x082B
    2174:	90 91 2c 08 	lds	r25, 0x082C
    2178:	c8 0f       	add	r28, r24
    217a:	d9 1f       	adc	r29, r25
    217c:	80 91 8d 08 	lds	r24, 0x088D
    2180:	90 91 8e 08 	lds	r25, 0x088E
    2184:	02 96       	adiw	r24, 0x02	; 2
    2186:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    218a:	ce 01       	movw	r24, r28
    218c:	99 dc       	rcall	.-1742   	; 0x1ac0 <prvAddCurrentTaskToDelayedList>
    218e:	2b df       	rcall	.-426    	; 0x1fe6 <xTaskResumeAll>
    2190:	81 11       	cpse	r24, r1
    2192:	01 c0       	rjmp	.+2      	; 0x2196 <vTaskDelay+0x32>
    2194:	94 d8       	rcall	.-3800   	; 0x12be <vPortYield>
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
    219a:	08 95       	ret

0000219c <prvIdleTask>:
    219c:	0f 2e       	mov	r0, r31
    219e:	f0 e6       	ldi	r31, 0x60	; 96
    21a0:	ef 2e       	mov	r14, r31
    21a2:	f8 e0       	ldi	r31, 0x08	; 8
    21a4:	ff 2e       	mov	r15, r31
    21a6:	f0 2d       	mov	r31, r0
    21a8:	c8 e3       	ldi	r28, 0x38	; 56
    21aa:	d8 e0       	ldi	r29, 0x08	; 8
    21ac:	26 c0       	rjmp	.+76     	; 0x21fa <prvIdleTask+0x5e>
    21ae:	48 de       	rcall	.-880    	; 0x1e40 <vTaskSuspendAll>
    21b0:	18 81       	ld	r17, Y
    21b2:	19 df       	rcall	.-462    	; 0x1fe6 <xTaskResumeAll>
    21b4:	11 23       	and	r17, r17
    21b6:	09 f1       	breq	.+66     	; 0x21fa <prvIdleTask+0x5e>
    21b8:	0f b6       	in	r0, 0x3f	; 63
    21ba:	f8 94       	cli
    21bc:	0f 92       	push	r0
    21be:	e0 91 3d 08 	lds	r30, 0x083D
    21c2:	f0 91 3e 08 	lds	r31, 0x083E
    21c6:	06 81       	ldd	r16, Z+6	; 0x06
    21c8:	17 81       	ldd	r17, Z+7	; 0x07
    21ca:	c8 01       	movw	r24, r16
    21cc:	02 96       	adiw	r24, 0x02	; 2
    21ce:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    21d2:	80 91 2d 08 	lds	r24, 0x082D
    21d6:	81 50       	subi	r24, 0x01	; 1
    21d8:	80 93 2d 08 	sts	0x082D, r24
    21dc:	80 91 37 08 	lds	r24, 0x0837
    21e0:	81 50       	subi	r24, 0x01	; 1
    21e2:	80 93 37 08 	sts	0x0837, r24
    21e6:	0f 90       	pop	r0
    21e8:	0f be       	out	0x3f, r0	; 63
    21ea:	f8 01       	movw	r30, r16
    21ec:	87 89       	ldd	r24, Z+23	; 0x17
    21ee:	90 8d       	ldd	r25, Z+24	; 0x18
    21f0:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vPortFree>
    21f4:	c8 01       	movw	r24, r16
    21f6:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <vPortFree>
    21fa:	80 91 37 08 	lds	r24, 0x0837
    21fe:	81 11       	cpse	r24, r1
    2200:	d6 cf       	rjmp	.-84     	; 0x21ae <prvIdleTask+0x12>
    2202:	f7 01       	movw	r30, r14
    2204:	80 81       	ld	r24, Z
    2206:	82 30       	cpi	r24, 0x02	; 2
    2208:	c0 f3       	brcs	.-16     	; 0x21fa <prvIdleTask+0x5e>
    220a:	59 d8       	rcall	.-3918   	; 0x12be <vPortYield>
    220c:	f6 cf       	rjmp	.-20     	; 0x21fa <prvIdleTask+0x5e>

0000220e <vTaskSwitchContext>:
    220e:	80 91 24 08 	lds	r24, 0x0824
    2212:	88 23       	and	r24, r24
    2214:	21 f0       	breq	.+8      	; 0x221e <vTaskSwitchContext+0x10>
    2216:	81 e0       	ldi	r24, 0x01	; 1
    2218:	80 93 27 08 	sts	0x0827, r24
    221c:	08 95       	ret
    221e:	10 92 27 08 	sts	0x0827, r1
    2222:	80 91 2a 08 	lds	r24, 0x082A
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	fc 01       	movw	r30, r24
    222a:	ee 0f       	add	r30, r30
    222c:	ff 1f       	adc	r31, r31
    222e:	ee 0f       	add	r30, r30
    2230:	ff 1f       	adc	r31, r31
    2232:	ee 0f       	add	r30, r30
    2234:	ff 1f       	adc	r31, r31
    2236:	8e 0f       	add	r24, r30
    2238:	9f 1f       	adc	r25, r31
    223a:	fc 01       	movw	r30, r24
    223c:	e0 5a       	subi	r30, 0xA0	; 160
    223e:	f7 4f       	sbci	r31, 0xF7	; 247
    2240:	80 81       	ld	r24, Z
    2242:	81 11       	cpse	r24, r1
    2244:	17 c0       	rjmp	.+46     	; 0x2274 <vTaskSwitchContext+0x66>
    2246:	80 91 2a 08 	lds	r24, 0x082A
    224a:	81 50       	subi	r24, 0x01	; 1
    224c:	80 93 2a 08 	sts	0x082A, r24
    2250:	80 91 2a 08 	lds	r24, 0x082A
    2254:	90 e0       	ldi	r25, 0x00	; 0
    2256:	fc 01       	movw	r30, r24
    2258:	ee 0f       	add	r30, r30
    225a:	ff 1f       	adc	r31, r31
    225c:	ee 0f       	add	r30, r30
    225e:	ff 1f       	adc	r31, r31
    2260:	ee 0f       	add	r30, r30
    2262:	ff 1f       	adc	r31, r31
    2264:	8e 0f       	add	r24, r30
    2266:	9f 1f       	adc	r25, r31
    2268:	fc 01       	movw	r30, r24
    226a:	e0 5a       	subi	r30, 0xA0	; 160
    226c:	f7 4f       	sbci	r31, 0xF7	; 247
    226e:	80 81       	ld	r24, Z
    2270:	88 23       	and	r24, r24
    2272:	49 f3       	breq	.-46     	; 0x2246 <vTaskSwitchContext+0x38>
    2274:	e0 91 2a 08 	lds	r30, 0x082A
    2278:	f0 e0       	ldi	r31, 0x00	; 0
    227a:	cf 01       	movw	r24, r30
    227c:	88 0f       	add	r24, r24
    227e:	99 1f       	adc	r25, r25
    2280:	88 0f       	add	r24, r24
    2282:	99 1f       	adc	r25, r25
    2284:	88 0f       	add	r24, r24
    2286:	99 1f       	adc	r25, r25
    2288:	e8 0f       	add	r30, r24
    228a:	f9 1f       	adc	r31, r25
    228c:	e0 5a       	subi	r30, 0xA0	; 160
    228e:	f7 4f       	sbci	r31, 0xF7	; 247
    2290:	a1 81       	ldd	r26, Z+1	; 0x01
    2292:	b2 81       	ldd	r27, Z+2	; 0x02
    2294:	12 96       	adiw	r26, 0x02	; 2
    2296:	0d 90       	ld	r0, X+
    2298:	bc 91       	ld	r27, X
    229a:	a0 2d       	mov	r26, r0
    229c:	b2 83       	std	Z+2, r27	; 0x02
    229e:	a1 83       	std	Z+1, r26	; 0x01
    22a0:	cf 01       	movw	r24, r30
    22a2:	03 96       	adiw	r24, 0x03	; 3
    22a4:	a8 17       	cp	r26, r24
    22a6:	b9 07       	cpc	r27, r25
    22a8:	31 f4       	brne	.+12     	; 0x22b6 <vTaskSwitchContext+0xa8>
    22aa:	12 96       	adiw	r26, 0x02	; 2
    22ac:	8d 91       	ld	r24, X+
    22ae:	9c 91       	ld	r25, X
    22b0:	13 97       	sbiw	r26, 0x03	; 3
    22b2:	92 83       	std	Z+2, r25	; 0x02
    22b4:	81 83       	std	Z+1, r24	; 0x01
    22b6:	01 80       	ldd	r0, Z+1	; 0x01
    22b8:	f2 81       	ldd	r31, Z+2	; 0x02
    22ba:	e0 2d       	mov	r30, r0
    22bc:	86 81       	ldd	r24, Z+6	; 0x06
    22be:	97 81       	ldd	r25, Z+7	; 0x07
    22c0:	90 93 8e 08 	sts	0x088E, r25
    22c4:	80 93 8d 08 	sts	0x088D, r24
    22c8:	08 95       	ret

000022ca <vTaskSuspend>:
    22ca:	0f 93       	push	r16
    22cc:	1f 93       	push	r17
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	ec 01       	movw	r28, r24
    22d4:	0f b6       	in	r0, 0x3f	; 63
    22d6:	f8 94       	cli
    22d8:	0f 92       	push	r0
    22da:	00 97       	sbiw	r24, 0x00	; 0
    22dc:	21 f4       	brne	.+8      	; 0x22e6 <vTaskSuspend+0x1c>
    22de:	c0 91 8d 08 	lds	r28, 0x088D
    22e2:	d0 91 8e 08 	lds	r29, 0x088E
    22e6:	8e 01       	movw	r16, r28
    22e8:	0e 5f       	subi	r16, 0xFE	; 254
    22ea:	1f 4f       	sbci	r17, 0xFF	; 255
    22ec:	c8 01       	movw	r24, r16
    22ee:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    22f2:	8c 89       	ldd	r24, Y+20	; 0x14
    22f4:	9d 89       	ldd	r25, Y+21	; 0x15
    22f6:	89 2b       	or	r24, r25
    22f8:	21 f0       	breq	.+8      	; 0x2302 <vTaskSuspend+0x38>
    22fa:	ce 01       	movw	r24, r28
    22fc:	0c 96       	adiw	r24, 0x0c	; 12
    22fe:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    2302:	b8 01       	movw	r22, r16
    2304:	8e e2       	ldi	r24, 0x2E	; 46
    2306:	98 e0       	ldi	r25, 0x08	; 8
    2308:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    230c:	0f 90       	pop	r0
    230e:	0f be       	out	0x3f, r0	; 63
    2310:	80 91 8d 08 	lds	r24, 0x088D
    2314:	90 91 8e 08 	lds	r25, 0x088E
    2318:	c8 17       	cp	r28, r24
    231a:	d9 07       	cpc	r29, r25
    231c:	a1 f4       	brne	.+40     	; 0x2346 <vTaskSuspend+0x7c>
    231e:	80 91 29 08 	lds	r24, 0x0829
    2322:	88 23       	and	r24, r24
    2324:	19 f0       	breq	.+6      	; 0x232c <vTaskSuspend+0x62>
    2326:	0e 94 5f 09 	call	0x12be	; 0x12be <vPortYield>
    232a:	17 c0       	rjmp	.+46     	; 0x235a <vTaskSuspend+0x90>
    232c:	80 91 2d 08 	lds	r24, 0x082D
    2330:	90 91 2e 08 	lds	r25, 0x082E
    2334:	98 13       	cpse	r25, r24
    2336:	05 c0       	rjmp	.+10     	; 0x2342 <vTaskSuspend+0x78>
    2338:	10 92 8e 08 	sts	0x088E, r1
    233c:	10 92 8d 08 	sts	0x088D, r1
    2340:	0c c0       	rjmp	.+24     	; 0x235a <vTaskSuspend+0x90>
    2342:	65 df       	rcall	.-310    	; 0x220e <vTaskSwitchContext>
    2344:	0a c0       	rjmp	.+20     	; 0x235a <vTaskSuspend+0x90>
    2346:	80 91 29 08 	lds	r24, 0x0829
    234a:	88 23       	and	r24, r24
    234c:	31 f0       	breq	.+12     	; 0x235a <vTaskSuspend+0x90>
    234e:	0f b6       	in	r0, 0x3f	; 63
    2350:	f8 94       	cli
    2352:	0f 92       	push	r0
    2354:	96 db       	rcall	.-2260   	; 0x1a82 <prvResetNextTaskUnblockTime>
    2356:	0f 90       	pop	r0
    2358:	0f be       	out	0x3f, r0	; 63
    235a:	df 91       	pop	r29
    235c:	cf 91       	pop	r28
    235e:	1f 91       	pop	r17
    2360:	0f 91       	pop	r16
    2362:	08 95       	ret

00002364 <vTaskPlaceOnEventList>:
    2364:	cf 93       	push	r28
    2366:	df 93       	push	r29
    2368:	eb 01       	movw	r28, r22
    236a:	60 91 8d 08 	lds	r22, 0x088D
    236e:	70 91 8e 08 	lds	r23, 0x088E
    2372:	64 5f       	subi	r22, 0xF4	; 244
    2374:	7f 4f       	sbci	r23, 0xFF	; 255
    2376:	0e 94 28 03 	call	0x650	; 0x650 <vListInsert>
    237a:	80 91 8d 08 	lds	r24, 0x088D
    237e:	90 91 8e 08 	lds	r25, 0x088E
    2382:	02 96       	adiw	r24, 0x02	; 2
    2384:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    2388:	cf 3f       	cpi	r28, 0xFF	; 255
    238a:	8f ef       	ldi	r24, 0xFF	; 255
    238c:	d8 07       	cpc	r29, r24
    238e:	59 f4       	brne	.+22     	; 0x23a6 <vTaskPlaceOnEventList+0x42>
    2390:	60 91 8d 08 	lds	r22, 0x088D
    2394:	70 91 8e 08 	lds	r23, 0x088E
    2398:	6e 5f       	subi	r22, 0xFE	; 254
    239a:	7f 4f       	sbci	r23, 0xFF	; 255
    239c:	8e e2       	ldi	r24, 0x2E	; 46
    239e:	98 e0       	ldi	r25, 0x08	; 8
    23a0:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    23a4:	07 c0       	rjmp	.+14     	; 0x23b4 <vTaskPlaceOnEventList+0x50>
    23a6:	80 91 2b 08 	lds	r24, 0x082B
    23aa:	90 91 2c 08 	lds	r25, 0x082C
    23ae:	8c 0f       	add	r24, r28
    23b0:	9d 1f       	adc	r25, r29
    23b2:	86 db       	rcall	.-2292   	; 0x1ac0 <prvAddCurrentTaskToDelayedList>
    23b4:	df 91       	pop	r29
    23b6:	cf 91       	pop	r28
    23b8:	08 95       	ret

000023ba <xTaskRemoveFromEventList>:
    23ba:	0f 93       	push	r16
    23bc:	1f 93       	push	r17
    23be:	cf 93       	push	r28
    23c0:	df 93       	push	r29
    23c2:	dc 01       	movw	r26, r24
    23c4:	15 96       	adiw	r26, 0x05	; 5
    23c6:	ed 91       	ld	r30, X+
    23c8:	fc 91       	ld	r31, X
    23ca:	16 97       	sbiw	r26, 0x06	; 6
    23cc:	c6 81       	ldd	r28, Z+6	; 0x06
    23ce:	d7 81       	ldd	r29, Z+7	; 0x07
    23d0:	8e 01       	movw	r16, r28
    23d2:	04 5f       	subi	r16, 0xF4	; 244
    23d4:	1f 4f       	sbci	r17, 0xFF	; 255
    23d6:	c8 01       	movw	r24, r16
    23d8:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    23dc:	80 91 24 08 	lds	r24, 0x0824
    23e0:	81 11       	cpse	r24, r1
    23e2:	1c c0       	rjmp	.+56     	; 0x241c <xTaskRemoveFromEventList+0x62>
    23e4:	0a 50       	subi	r16, 0x0A	; 10
    23e6:	11 09       	sbc	r17, r1
    23e8:	c8 01       	movw	r24, r16
    23ea:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    23ee:	8e 89       	ldd	r24, Y+22	; 0x16
    23f0:	90 91 2a 08 	lds	r25, 0x082A
    23f4:	98 17       	cp	r25, r24
    23f6:	10 f4       	brcc	.+4      	; 0x23fc <xTaskRemoveFromEventList+0x42>
    23f8:	80 93 2a 08 	sts	0x082A, r24
    23fc:	90 e0       	ldi	r25, 0x00	; 0
    23fe:	9c 01       	movw	r18, r24
    2400:	22 0f       	add	r18, r18
    2402:	33 1f       	adc	r19, r19
    2404:	22 0f       	add	r18, r18
    2406:	33 1f       	adc	r19, r19
    2408:	22 0f       	add	r18, r18
    240a:	33 1f       	adc	r19, r19
    240c:	82 0f       	add	r24, r18
    240e:	93 1f       	adc	r25, r19
    2410:	b8 01       	movw	r22, r16
    2412:	80 5a       	subi	r24, 0xA0	; 160
    2414:	97 4f       	sbci	r25, 0xF7	; 247
    2416:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    241a:	05 c0       	rjmp	.+10     	; 0x2426 <xTaskRemoveFromEventList+0x6c>
    241c:	b8 01       	movw	r22, r16
    241e:	81 e4       	ldi	r24, 0x41	; 65
    2420:	98 e0       	ldi	r25, 0x08	; 8
    2422:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    2426:	e0 91 8d 08 	lds	r30, 0x088D
    242a:	f0 91 8e 08 	lds	r31, 0x088E
    242e:	9e 89       	ldd	r25, Y+22	; 0x16
    2430:	86 89       	ldd	r24, Z+22	; 0x16
    2432:	89 17       	cp	r24, r25
    2434:	20 f4       	brcc	.+8      	; 0x243e <xTaskRemoveFromEventList+0x84>
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	80 93 27 08 	sts	0x0827, r24
    243c:	01 c0       	rjmp	.+2      	; 0x2440 <xTaskRemoveFromEventList+0x86>
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	df 91       	pop	r29
    2442:	cf 91       	pop	r28
    2444:	1f 91       	pop	r17
    2446:	0f 91       	pop	r16
    2448:	08 95       	ret

0000244a <vTaskSetTimeOutState>:
    244a:	20 91 26 08 	lds	r18, 0x0826
    244e:	fc 01       	movw	r30, r24
    2450:	20 83       	st	Z, r18
    2452:	20 91 2b 08 	lds	r18, 0x082B
    2456:	30 91 2c 08 	lds	r19, 0x082C
    245a:	32 83       	std	Z+2, r19	; 0x02
    245c:	21 83       	std	Z+1, r18	; 0x01
    245e:	08 95       	ret

00002460 <xTaskCheckForTimeOut>:
    2460:	0f b6       	in	r0, 0x3f	; 63
    2462:	f8 94       	cli
    2464:	0f 92       	push	r0
    2466:	40 91 2b 08 	lds	r20, 0x082B
    246a:	50 91 2c 08 	lds	r21, 0x082C
    246e:	db 01       	movw	r26, r22
    2470:	2d 91       	ld	r18, X+
    2472:	3c 91       	ld	r19, X
    2474:	2f 3f       	cpi	r18, 0xFF	; 255
    2476:	bf ef       	ldi	r27, 0xFF	; 255
    2478:	3b 07       	cpc	r19, r27
    247a:	11 f1       	breq	.+68     	; 0x24c0 <xTaskCheckForTimeOut+0x60>
    247c:	e0 91 26 08 	lds	r30, 0x0826
    2480:	dc 01       	movw	r26, r24
    2482:	fc 91       	ld	r31, X
    2484:	fe 17       	cp	r31, r30
    2486:	39 f0       	breq	.+14     	; 0x2496 <xTaskCheckForTimeOut+0x36>
    2488:	11 96       	adiw	r26, 0x01	; 1
    248a:	ed 91       	ld	r30, X+
    248c:	fc 91       	ld	r31, X
    248e:	12 97       	sbiw	r26, 0x02	; 2
    2490:	4e 17       	cp	r20, r30
    2492:	5f 07       	cpc	r21, r31
    2494:	b8 f4       	brcc	.+46     	; 0x24c4 <xTaskCheckForTimeOut+0x64>
    2496:	dc 01       	movw	r26, r24
    2498:	11 96       	adiw	r26, 0x01	; 1
    249a:	ed 91       	ld	r30, X+
    249c:	fc 91       	ld	r31, X
    249e:	12 97       	sbiw	r26, 0x02	; 2
    24a0:	da 01       	movw	r26, r20
    24a2:	ae 1b       	sub	r26, r30
    24a4:	bf 0b       	sbc	r27, r31
    24a6:	a2 17       	cp	r26, r18
    24a8:	b3 07       	cpc	r27, r19
    24aa:	70 f4       	brcc	.+28     	; 0x24c8 <xTaskCheckForTimeOut+0x68>
    24ac:	e4 1b       	sub	r30, r20
    24ae:	f5 0b       	sbc	r31, r21
    24b0:	2e 0f       	add	r18, r30
    24b2:	3f 1f       	adc	r19, r31
    24b4:	fb 01       	movw	r30, r22
    24b6:	31 83       	std	Z+1, r19	; 0x01
    24b8:	20 83       	st	Z, r18
    24ba:	c7 df       	rcall	.-114    	; 0x244a <vTaskSetTimeOutState>
    24bc:	80 e0       	ldi	r24, 0x00	; 0
    24be:	05 c0       	rjmp	.+10     	; 0x24ca <xTaskCheckForTimeOut+0x6a>
    24c0:	80 e0       	ldi	r24, 0x00	; 0
    24c2:	03 c0       	rjmp	.+6      	; 0x24ca <xTaskCheckForTimeOut+0x6a>
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	01 c0       	rjmp	.+2      	; 0x24ca <xTaskCheckForTimeOut+0x6a>
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	0f 90       	pop	r0
    24cc:	0f be       	out	0x3f, r0	; 63
    24ce:	08 95       	ret

000024d0 <vTaskMissedYield>:
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	80 93 27 08 	sts	0x0827, r24
    24d6:	08 95       	ret

000024d8 <vTaskPriorityInherit>:
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
    24e0:	ec 01       	movw	r28, r24
    24e2:	00 97       	sbiw	r24, 0x00	; 0
    24e4:	09 f4       	brne	.+2      	; 0x24e8 <vTaskPriorityInherit+0x10>
    24e6:	51 c0       	rjmp	.+162    	; 0x258a <vTaskPriorityInherit+0xb2>
    24e8:	8e 89       	ldd	r24, Y+22	; 0x16
    24ea:	e0 91 8d 08 	lds	r30, 0x088D
    24ee:	f0 91 8e 08 	lds	r31, 0x088E
    24f2:	96 89       	ldd	r25, Z+22	; 0x16
    24f4:	89 17       	cp	r24, r25
    24f6:	08 f0       	brcs	.+2      	; 0x24fa <vTaskPriorityInherit+0x22>
    24f8:	48 c0       	rjmp	.+144    	; 0x258a <vTaskPriorityInherit+0xb2>
    24fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    24fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    24fe:	33 23       	and	r19, r19
    2500:	5c f0       	brlt	.+22     	; 0x2518 <vTaskPriorityInherit+0x40>
    2502:	e0 91 8d 08 	lds	r30, 0x088D
    2506:	f0 91 8e 08 	lds	r31, 0x088E
    250a:	96 89       	ldd	r25, Z+22	; 0x16
    250c:	25 e0       	ldi	r18, 0x05	; 5
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	29 1b       	sub	r18, r25
    2512:	31 09       	sbc	r19, r1
    2514:	3d 87       	std	Y+13, r19	; 0x0d
    2516:	2c 87       	std	Y+12, r18	; 0x0c
    2518:	90 e0       	ldi	r25, 0x00	; 0
    251a:	9c 01       	movw	r18, r24
    251c:	22 0f       	add	r18, r18
    251e:	33 1f       	adc	r19, r19
    2520:	22 0f       	add	r18, r18
    2522:	33 1f       	adc	r19, r19
    2524:	22 0f       	add	r18, r18
    2526:	33 1f       	adc	r19, r19
    2528:	82 0f       	add	r24, r18
    252a:	93 1f       	adc	r25, r19
    252c:	80 5a       	subi	r24, 0xA0	; 160
    252e:	97 4f       	sbci	r25, 0xF7	; 247
    2530:	2a 85       	ldd	r18, Y+10	; 0x0a
    2532:	3b 85       	ldd	r19, Y+11	; 0x0b
    2534:	28 17       	cp	r18, r24
    2536:	39 07       	cpc	r19, r25
    2538:	11 f5       	brne	.+68     	; 0x257e <vTaskPriorityInherit+0xa6>
    253a:	8e 01       	movw	r16, r28
    253c:	0e 5f       	subi	r16, 0xFE	; 254
    253e:	1f 4f       	sbci	r17, 0xFF	; 255
    2540:	c8 01       	movw	r24, r16
    2542:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    2546:	e0 91 8d 08 	lds	r30, 0x088D
    254a:	f0 91 8e 08 	lds	r31, 0x088E
    254e:	86 89       	ldd	r24, Z+22	; 0x16
    2550:	8e 8b       	std	Y+22, r24	; 0x16
    2552:	90 91 2a 08 	lds	r25, 0x082A
    2556:	98 17       	cp	r25, r24
    2558:	10 f4       	brcc	.+4      	; 0x255e <vTaskPriorityInherit+0x86>
    255a:	80 93 2a 08 	sts	0x082A, r24
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	9c 01       	movw	r18, r24
    2562:	22 0f       	add	r18, r18
    2564:	33 1f       	adc	r19, r19
    2566:	22 0f       	add	r18, r18
    2568:	33 1f       	adc	r19, r19
    256a:	22 0f       	add	r18, r18
    256c:	33 1f       	adc	r19, r19
    256e:	82 0f       	add	r24, r18
    2570:	93 1f       	adc	r25, r19
    2572:	b8 01       	movw	r22, r16
    2574:	80 5a       	subi	r24, 0xA0	; 160
    2576:	97 4f       	sbci	r25, 0xF7	; 247
    2578:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    257c:	06 c0       	rjmp	.+12     	; 0x258a <vTaskPriorityInherit+0xb2>
    257e:	e0 91 8d 08 	lds	r30, 0x088D
    2582:	f0 91 8e 08 	lds	r31, 0x088E
    2586:	86 89       	ldd	r24, Z+22	; 0x16
    2588:	8e 8b       	std	Y+22, r24	; 0x16
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	08 95       	ret

00002594 <xTaskPriorityDisinherit>:
    2594:	0f 93       	push	r16
    2596:	1f 93       	push	r17
    2598:	cf 93       	push	r28
    259a:	df 93       	push	r29
    259c:	ec 01       	movw	r28, r24
    259e:	00 97       	sbiw	r24, 0x00	; 0
    25a0:	71 f1       	breq	.+92     	; 0x25fe <xTaskPriorityDisinherit+0x6a>
    25a2:	8a a1       	ldd	r24, Y+34	; 0x22
    25a4:	81 50       	subi	r24, 0x01	; 1
    25a6:	8a a3       	std	Y+34, r24	; 0x22
    25a8:	2e 89       	ldd	r18, Y+22	; 0x16
    25aa:	99 a1       	ldd	r25, Y+33	; 0x21
    25ac:	29 17       	cp	r18, r25
    25ae:	49 f1       	breq	.+82     	; 0x2602 <xTaskPriorityDisinherit+0x6e>
    25b0:	81 11       	cpse	r24, r1
    25b2:	29 c0       	rjmp	.+82     	; 0x2606 <xTaskPriorityDisinherit+0x72>
    25b4:	8e 01       	movw	r16, r28
    25b6:	0e 5f       	subi	r16, 0xFE	; 254
    25b8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ba:	c8 01       	movw	r24, r16
    25bc:	0e 94 59 03 	call	0x6b2	; 0x6b2 <uxListRemove>
    25c0:	89 a1       	ldd	r24, Y+33	; 0x21
    25c2:	8e 8b       	std	Y+22, r24	; 0x16
    25c4:	25 e0       	ldi	r18, 0x05	; 5
    25c6:	30 e0       	ldi	r19, 0x00	; 0
    25c8:	28 1b       	sub	r18, r24
    25ca:	31 09       	sbc	r19, r1
    25cc:	3d 87       	std	Y+13, r19	; 0x0d
    25ce:	2c 87       	std	Y+12, r18	; 0x0c
    25d0:	90 91 2a 08 	lds	r25, 0x082A
    25d4:	98 17       	cp	r25, r24
    25d6:	10 f4       	brcc	.+4      	; 0x25dc <xTaskPriorityDisinherit+0x48>
    25d8:	80 93 2a 08 	sts	0x082A, r24
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	9c 01       	movw	r18, r24
    25e0:	22 0f       	add	r18, r18
    25e2:	33 1f       	adc	r19, r19
    25e4:	22 0f       	add	r18, r18
    25e6:	33 1f       	adc	r19, r19
    25e8:	22 0f       	add	r18, r18
    25ea:	33 1f       	adc	r19, r19
    25ec:	82 0f       	add	r24, r18
    25ee:	93 1f       	adc	r25, r19
    25f0:	b8 01       	movw	r22, r16
    25f2:	80 5a       	subi	r24, 0xA0	; 160
    25f4:	97 4f       	sbci	r25, 0xF7	; 247
    25f6:	0e 94 07 03 	call	0x60e	; 0x60e <vListInsertEnd>
    25fa:	81 e0       	ldi	r24, 0x01	; 1
    25fc:	05 c0       	rjmp	.+10     	; 0x2608 <xTaskPriorityDisinherit+0x74>
    25fe:	80 e0       	ldi	r24, 0x00	; 0
    2600:	03 c0       	rjmp	.+6      	; 0x2608 <xTaskPriorityDisinherit+0x74>
    2602:	80 e0       	ldi	r24, 0x00	; 0
    2604:	01 c0       	rjmp	.+2      	; 0x2608 <xTaskPriorityDisinherit+0x74>
    2606:	80 e0       	ldi	r24, 0x00	; 0
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	1f 91       	pop	r17
    260e:	0f 91       	pop	r16
    2610:	08 95       	ret

00002612 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2612:	80 91 8d 08 	lds	r24, 0x088D
    2616:	90 91 8e 08 	lds	r25, 0x088E
    261a:	89 2b       	or	r24, r25
    261c:	39 f0       	breq	.+14     	; 0x262c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    261e:	e0 91 8d 08 	lds	r30, 0x088D
    2622:	f0 91 8e 08 	lds	r31, 0x088E
    2626:	82 a1       	ldd	r24, Z+34	; 0x22
    2628:	8f 5f       	subi	r24, 0xFF	; 255
    262a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    262c:	80 91 8d 08 	lds	r24, 0x088D
    2630:	90 91 8e 08 	lds	r25, 0x088E
	}
    2634:	08 95       	ret

00002636 <__subsf3>:
    2636:	50 58       	subi	r21, 0x80	; 128

00002638 <__addsf3>:
    2638:	bb 27       	eor	r27, r27
    263a:	aa 27       	eor	r26, r26
    263c:	0e d0       	rcall	.+28     	; 0x265a <__addsf3x>
    263e:	e5 c0       	rjmp	.+458    	; 0x280a <__fp_round>
    2640:	d6 d0       	rcall	.+428    	; 0x27ee <__fp_pscA>
    2642:	30 f0       	brcs	.+12     	; 0x2650 <__addsf3+0x18>
    2644:	db d0       	rcall	.+438    	; 0x27fc <__fp_pscB>
    2646:	20 f0       	brcs	.+8      	; 0x2650 <__addsf3+0x18>
    2648:	31 f4       	brne	.+12     	; 0x2656 <__addsf3+0x1e>
    264a:	9f 3f       	cpi	r25, 0xFF	; 255
    264c:	11 f4       	brne	.+4      	; 0x2652 <__addsf3+0x1a>
    264e:	1e f4       	brtc	.+6      	; 0x2656 <__addsf3+0x1e>
    2650:	cb c0       	rjmp	.+406    	; 0x27e8 <__fp_nan>
    2652:	0e f4       	brtc	.+2      	; 0x2656 <__addsf3+0x1e>
    2654:	e0 95       	com	r30
    2656:	e7 fb       	bst	r30, 7
    2658:	c1 c0       	rjmp	.+386    	; 0x27dc <__fp_inf>

0000265a <__addsf3x>:
    265a:	e9 2f       	mov	r30, r25
    265c:	e7 d0       	rcall	.+462    	; 0x282c <__fp_split3>
    265e:	80 f3       	brcs	.-32     	; 0x2640 <__addsf3+0x8>
    2660:	ba 17       	cp	r27, r26
    2662:	62 07       	cpc	r22, r18
    2664:	73 07       	cpc	r23, r19
    2666:	84 07       	cpc	r24, r20
    2668:	95 07       	cpc	r25, r21
    266a:	18 f0       	brcs	.+6      	; 0x2672 <__addsf3x+0x18>
    266c:	71 f4       	brne	.+28     	; 0x268a <__addsf3x+0x30>
    266e:	9e f5       	brtc	.+102    	; 0x26d6 <__addsf3x+0x7c>
    2670:	ff c0       	rjmp	.+510    	; 0x2870 <__fp_zero>
    2672:	0e f4       	brtc	.+2      	; 0x2676 <__addsf3x+0x1c>
    2674:	e0 95       	com	r30
    2676:	0b 2e       	mov	r0, r27
    2678:	ba 2f       	mov	r27, r26
    267a:	a0 2d       	mov	r26, r0
    267c:	0b 01       	movw	r0, r22
    267e:	b9 01       	movw	r22, r18
    2680:	90 01       	movw	r18, r0
    2682:	0c 01       	movw	r0, r24
    2684:	ca 01       	movw	r24, r20
    2686:	a0 01       	movw	r20, r0
    2688:	11 24       	eor	r1, r1
    268a:	ff 27       	eor	r31, r31
    268c:	59 1b       	sub	r21, r25
    268e:	99 f0       	breq	.+38     	; 0x26b6 <__addsf3x+0x5c>
    2690:	59 3f       	cpi	r21, 0xF9	; 249
    2692:	50 f4       	brcc	.+20     	; 0x26a8 <__addsf3x+0x4e>
    2694:	50 3e       	cpi	r21, 0xE0	; 224
    2696:	68 f1       	brcs	.+90     	; 0x26f2 <__addsf3x+0x98>
    2698:	1a 16       	cp	r1, r26
    269a:	f0 40       	sbci	r31, 0x00	; 0
    269c:	a2 2f       	mov	r26, r18
    269e:	23 2f       	mov	r18, r19
    26a0:	34 2f       	mov	r19, r20
    26a2:	44 27       	eor	r20, r20
    26a4:	58 5f       	subi	r21, 0xF8	; 248
    26a6:	f3 cf       	rjmp	.-26     	; 0x268e <__addsf3x+0x34>
    26a8:	46 95       	lsr	r20
    26aa:	37 95       	ror	r19
    26ac:	27 95       	ror	r18
    26ae:	a7 95       	ror	r26
    26b0:	f0 40       	sbci	r31, 0x00	; 0
    26b2:	53 95       	inc	r21
    26b4:	c9 f7       	brne	.-14     	; 0x26a8 <__addsf3x+0x4e>
    26b6:	7e f4       	brtc	.+30     	; 0x26d6 <__addsf3x+0x7c>
    26b8:	1f 16       	cp	r1, r31
    26ba:	ba 0b       	sbc	r27, r26
    26bc:	62 0b       	sbc	r22, r18
    26be:	73 0b       	sbc	r23, r19
    26c0:	84 0b       	sbc	r24, r20
    26c2:	ba f0       	brmi	.+46     	; 0x26f2 <__addsf3x+0x98>
    26c4:	91 50       	subi	r25, 0x01	; 1
    26c6:	a1 f0       	breq	.+40     	; 0x26f0 <__addsf3x+0x96>
    26c8:	ff 0f       	add	r31, r31
    26ca:	bb 1f       	adc	r27, r27
    26cc:	66 1f       	adc	r22, r22
    26ce:	77 1f       	adc	r23, r23
    26d0:	88 1f       	adc	r24, r24
    26d2:	c2 f7       	brpl	.-16     	; 0x26c4 <__addsf3x+0x6a>
    26d4:	0e c0       	rjmp	.+28     	; 0x26f2 <__addsf3x+0x98>
    26d6:	ba 0f       	add	r27, r26
    26d8:	62 1f       	adc	r22, r18
    26da:	73 1f       	adc	r23, r19
    26dc:	84 1f       	adc	r24, r20
    26de:	48 f4       	brcc	.+18     	; 0x26f2 <__addsf3x+0x98>
    26e0:	87 95       	ror	r24
    26e2:	77 95       	ror	r23
    26e4:	67 95       	ror	r22
    26e6:	b7 95       	ror	r27
    26e8:	f7 95       	ror	r31
    26ea:	9e 3f       	cpi	r25, 0xFE	; 254
    26ec:	08 f0       	brcs	.+2      	; 0x26f0 <__addsf3x+0x96>
    26ee:	b3 cf       	rjmp	.-154    	; 0x2656 <__addsf3+0x1e>
    26f0:	93 95       	inc	r25
    26f2:	88 0f       	add	r24, r24
    26f4:	08 f0       	brcs	.+2      	; 0x26f8 <__addsf3x+0x9e>
    26f6:	99 27       	eor	r25, r25
    26f8:	ee 0f       	add	r30, r30
    26fa:	97 95       	ror	r25
    26fc:	87 95       	ror	r24
    26fe:	08 95       	ret

00002700 <__fixsfsi>:
    2700:	04 d0       	rcall	.+8      	; 0x270a <__fixunssfsi>
    2702:	68 94       	set
    2704:	b1 11       	cpse	r27, r1
    2706:	b5 c0       	rjmp	.+362    	; 0x2872 <__fp_szero>
    2708:	08 95       	ret

0000270a <__fixunssfsi>:
    270a:	98 d0       	rcall	.+304    	; 0x283c <__fp_splitA>
    270c:	88 f0       	brcs	.+34     	; 0x2730 <__fixunssfsi+0x26>
    270e:	9f 57       	subi	r25, 0x7F	; 127
    2710:	90 f0       	brcs	.+36     	; 0x2736 <__fixunssfsi+0x2c>
    2712:	b9 2f       	mov	r27, r25
    2714:	99 27       	eor	r25, r25
    2716:	b7 51       	subi	r27, 0x17	; 23
    2718:	a0 f0       	brcs	.+40     	; 0x2742 <__fixunssfsi+0x38>
    271a:	d1 f0       	breq	.+52     	; 0x2750 <__fixunssfsi+0x46>
    271c:	66 0f       	add	r22, r22
    271e:	77 1f       	adc	r23, r23
    2720:	88 1f       	adc	r24, r24
    2722:	99 1f       	adc	r25, r25
    2724:	1a f0       	brmi	.+6      	; 0x272c <__fixunssfsi+0x22>
    2726:	ba 95       	dec	r27
    2728:	c9 f7       	brne	.-14     	; 0x271c <__fixunssfsi+0x12>
    272a:	12 c0       	rjmp	.+36     	; 0x2750 <__fixunssfsi+0x46>
    272c:	b1 30       	cpi	r27, 0x01	; 1
    272e:	81 f0       	breq	.+32     	; 0x2750 <__fixunssfsi+0x46>
    2730:	9f d0       	rcall	.+318    	; 0x2870 <__fp_zero>
    2732:	b1 e0       	ldi	r27, 0x01	; 1
    2734:	08 95       	ret
    2736:	9c c0       	rjmp	.+312    	; 0x2870 <__fp_zero>
    2738:	67 2f       	mov	r22, r23
    273a:	78 2f       	mov	r23, r24
    273c:	88 27       	eor	r24, r24
    273e:	b8 5f       	subi	r27, 0xF8	; 248
    2740:	39 f0       	breq	.+14     	; 0x2750 <__fixunssfsi+0x46>
    2742:	b9 3f       	cpi	r27, 0xF9	; 249
    2744:	cc f3       	brlt	.-14     	; 0x2738 <__fixunssfsi+0x2e>
    2746:	86 95       	lsr	r24
    2748:	77 95       	ror	r23
    274a:	67 95       	ror	r22
    274c:	b3 95       	inc	r27
    274e:	d9 f7       	brne	.-10     	; 0x2746 <__fixunssfsi+0x3c>
    2750:	3e f4       	brtc	.+14     	; 0x2760 <__fixunssfsi+0x56>
    2752:	90 95       	com	r25
    2754:	80 95       	com	r24
    2756:	70 95       	com	r23
    2758:	61 95       	neg	r22
    275a:	7f 4f       	sbci	r23, 0xFF	; 255
    275c:	8f 4f       	sbci	r24, 0xFF	; 255
    275e:	9f 4f       	sbci	r25, 0xFF	; 255
    2760:	08 95       	ret

00002762 <__floatunsisf>:
    2762:	e8 94       	clt
    2764:	09 c0       	rjmp	.+18     	; 0x2778 <__floatsisf+0x12>

00002766 <__floatsisf>:
    2766:	97 fb       	bst	r25, 7
    2768:	3e f4       	brtc	.+14     	; 0x2778 <__floatsisf+0x12>
    276a:	90 95       	com	r25
    276c:	80 95       	com	r24
    276e:	70 95       	com	r23
    2770:	61 95       	neg	r22
    2772:	7f 4f       	sbci	r23, 0xFF	; 255
    2774:	8f 4f       	sbci	r24, 0xFF	; 255
    2776:	9f 4f       	sbci	r25, 0xFF	; 255
    2778:	99 23       	and	r25, r25
    277a:	a9 f0       	breq	.+42     	; 0x27a6 <__floatsisf+0x40>
    277c:	f9 2f       	mov	r31, r25
    277e:	96 e9       	ldi	r25, 0x96	; 150
    2780:	bb 27       	eor	r27, r27
    2782:	93 95       	inc	r25
    2784:	f6 95       	lsr	r31
    2786:	87 95       	ror	r24
    2788:	77 95       	ror	r23
    278a:	67 95       	ror	r22
    278c:	b7 95       	ror	r27
    278e:	f1 11       	cpse	r31, r1
    2790:	f8 cf       	rjmp	.-16     	; 0x2782 <__floatsisf+0x1c>
    2792:	fa f4       	brpl	.+62     	; 0x27d2 <__floatsisf+0x6c>
    2794:	bb 0f       	add	r27, r27
    2796:	11 f4       	brne	.+4      	; 0x279c <__floatsisf+0x36>
    2798:	60 ff       	sbrs	r22, 0
    279a:	1b c0       	rjmp	.+54     	; 0x27d2 <__floatsisf+0x6c>
    279c:	6f 5f       	subi	r22, 0xFF	; 255
    279e:	7f 4f       	sbci	r23, 0xFF	; 255
    27a0:	8f 4f       	sbci	r24, 0xFF	; 255
    27a2:	9f 4f       	sbci	r25, 0xFF	; 255
    27a4:	16 c0       	rjmp	.+44     	; 0x27d2 <__floatsisf+0x6c>
    27a6:	88 23       	and	r24, r24
    27a8:	11 f0       	breq	.+4      	; 0x27ae <__floatsisf+0x48>
    27aa:	96 e9       	ldi	r25, 0x96	; 150
    27ac:	11 c0       	rjmp	.+34     	; 0x27d0 <__floatsisf+0x6a>
    27ae:	77 23       	and	r23, r23
    27b0:	21 f0       	breq	.+8      	; 0x27ba <__floatsisf+0x54>
    27b2:	9e e8       	ldi	r25, 0x8E	; 142
    27b4:	87 2f       	mov	r24, r23
    27b6:	76 2f       	mov	r23, r22
    27b8:	05 c0       	rjmp	.+10     	; 0x27c4 <__floatsisf+0x5e>
    27ba:	66 23       	and	r22, r22
    27bc:	71 f0       	breq	.+28     	; 0x27da <__floatsisf+0x74>
    27be:	96 e8       	ldi	r25, 0x86	; 134
    27c0:	86 2f       	mov	r24, r22
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	60 e0       	ldi	r22, 0x00	; 0
    27c6:	2a f0       	brmi	.+10     	; 0x27d2 <__floatsisf+0x6c>
    27c8:	9a 95       	dec	r25
    27ca:	66 0f       	add	r22, r22
    27cc:	77 1f       	adc	r23, r23
    27ce:	88 1f       	adc	r24, r24
    27d0:	da f7       	brpl	.-10     	; 0x27c8 <__floatsisf+0x62>
    27d2:	88 0f       	add	r24, r24
    27d4:	96 95       	lsr	r25
    27d6:	87 95       	ror	r24
    27d8:	97 f9       	bld	r25, 7
    27da:	08 95       	ret

000027dc <__fp_inf>:
    27dc:	97 f9       	bld	r25, 7
    27de:	9f 67       	ori	r25, 0x7F	; 127
    27e0:	80 e8       	ldi	r24, 0x80	; 128
    27e2:	70 e0       	ldi	r23, 0x00	; 0
    27e4:	60 e0       	ldi	r22, 0x00	; 0
    27e6:	08 95       	ret

000027e8 <__fp_nan>:
    27e8:	9f ef       	ldi	r25, 0xFF	; 255
    27ea:	80 ec       	ldi	r24, 0xC0	; 192
    27ec:	08 95       	ret

000027ee <__fp_pscA>:
    27ee:	00 24       	eor	r0, r0
    27f0:	0a 94       	dec	r0
    27f2:	16 16       	cp	r1, r22
    27f4:	17 06       	cpc	r1, r23
    27f6:	18 06       	cpc	r1, r24
    27f8:	09 06       	cpc	r0, r25
    27fa:	08 95       	ret

000027fc <__fp_pscB>:
    27fc:	00 24       	eor	r0, r0
    27fe:	0a 94       	dec	r0
    2800:	12 16       	cp	r1, r18
    2802:	13 06       	cpc	r1, r19
    2804:	14 06       	cpc	r1, r20
    2806:	05 06       	cpc	r0, r21
    2808:	08 95       	ret

0000280a <__fp_round>:
    280a:	09 2e       	mov	r0, r25
    280c:	03 94       	inc	r0
    280e:	00 0c       	add	r0, r0
    2810:	11 f4       	brne	.+4      	; 0x2816 <__fp_round+0xc>
    2812:	88 23       	and	r24, r24
    2814:	52 f0       	brmi	.+20     	; 0x282a <__fp_round+0x20>
    2816:	bb 0f       	add	r27, r27
    2818:	40 f4       	brcc	.+16     	; 0x282a <__fp_round+0x20>
    281a:	bf 2b       	or	r27, r31
    281c:	11 f4       	brne	.+4      	; 0x2822 <__fp_round+0x18>
    281e:	60 ff       	sbrs	r22, 0
    2820:	04 c0       	rjmp	.+8      	; 0x282a <__fp_round+0x20>
    2822:	6f 5f       	subi	r22, 0xFF	; 255
    2824:	7f 4f       	sbci	r23, 0xFF	; 255
    2826:	8f 4f       	sbci	r24, 0xFF	; 255
    2828:	9f 4f       	sbci	r25, 0xFF	; 255
    282a:	08 95       	ret

0000282c <__fp_split3>:
    282c:	57 fd       	sbrc	r21, 7
    282e:	90 58       	subi	r25, 0x80	; 128
    2830:	44 0f       	add	r20, r20
    2832:	55 1f       	adc	r21, r21
    2834:	59 f0       	breq	.+22     	; 0x284c <__fp_splitA+0x10>
    2836:	5f 3f       	cpi	r21, 0xFF	; 255
    2838:	71 f0       	breq	.+28     	; 0x2856 <__fp_splitA+0x1a>
    283a:	47 95       	ror	r20

0000283c <__fp_splitA>:
    283c:	88 0f       	add	r24, r24
    283e:	97 fb       	bst	r25, 7
    2840:	99 1f       	adc	r25, r25
    2842:	61 f0       	breq	.+24     	; 0x285c <__fp_splitA+0x20>
    2844:	9f 3f       	cpi	r25, 0xFF	; 255
    2846:	79 f0       	breq	.+30     	; 0x2866 <__fp_splitA+0x2a>
    2848:	87 95       	ror	r24
    284a:	08 95       	ret
    284c:	12 16       	cp	r1, r18
    284e:	13 06       	cpc	r1, r19
    2850:	14 06       	cpc	r1, r20
    2852:	55 1f       	adc	r21, r21
    2854:	f2 cf       	rjmp	.-28     	; 0x283a <__fp_split3+0xe>
    2856:	46 95       	lsr	r20
    2858:	f1 df       	rcall	.-30     	; 0x283c <__fp_splitA>
    285a:	08 c0       	rjmp	.+16     	; 0x286c <__fp_splitA+0x30>
    285c:	16 16       	cp	r1, r22
    285e:	17 06       	cpc	r1, r23
    2860:	18 06       	cpc	r1, r24
    2862:	99 1f       	adc	r25, r25
    2864:	f1 cf       	rjmp	.-30     	; 0x2848 <__fp_splitA+0xc>
    2866:	86 95       	lsr	r24
    2868:	71 05       	cpc	r23, r1
    286a:	61 05       	cpc	r22, r1
    286c:	08 94       	sec
    286e:	08 95       	ret

00002870 <__fp_zero>:
    2870:	e8 94       	clt

00002872 <__fp_szero>:
    2872:	bb 27       	eor	r27, r27
    2874:	66 27       	eor	r22, r22
    2876:	77 27       	eor	r23, r23
    2878:	cb 01       	movw	r24, r22
    287a:	97 f9       	bld	r25, 7
    287c:	08 95       	ret

0000287e <__mulsf3>:
    287e:	0b d0       	rcall	.+22     	; 0x2896 <__mulsf3x>
    2880:	c4 cf       	rjmp	.-120    	; 0x280a <__fp_round>
    2882:	b5 df       	rcall	.-150    	; 0x27ee <__fp_pscA>
    2884:	28 f0       	brcs	.+10     	; 0x2890 <__mulsf3+0x12>
    2886:	ba df       	rcall	.-140    	; 0x27fc <__fp_pscB>
    2888:	18 f0       	brcs	.+6      	; 0x2890 <__mulsf3+0x12>
    288a:	95 23       	and	r25, r21
    288c:	09 f0       	breq	.+2      	; 0x2890 <__mulsf3+0x12>
    288e:	a6 cf       	rjmp	.-180    	; 0x27dc <__fp_inf>
    2890:	ab cf       	rjmp	.-170    	; 0x27e8 <__fp_nan>
    2892:	11 24       	eor	r1, r1
    2894:	ee cf       	rjmp	.-36     	; 0x2872 <__fp_szero>

00002896 <__mulsf3x>:
    2896:	ca df       	rcall	.-108    	; 0x282c <__fp_split3>
    2898:	a0 f3       	brcs	.-24     	; 0x2882 <__mulsf3+0x4>

0000289a <__mulsf3_pse>:
    289a:	95 9f       	mul	r25, r21
    289c:	d1 f3       	breq	.-12     	; 0x2892 <__mulsf3+0x14>
    289e:	95 0f       	add	r25, r21
    28a0:	50 e0       	ldi	r21, 0x00	; 0
    28a2:	55 1f       	adc	r21, r21
    28a4:	62 9f       	mul	r22, r18
    28a6:	f0 01       	movw	r30, r0
    28a8:	72 9f       	mul	r23, r18
    28aa:	bb 27       	eor	r27, r27
    28ac:	f0 0d       	add	r31, r0
    28ae:	b1 1d       	adc	r27, r1
    28b0:	63 9f       	mul	r22, r19
    28b2:	aa 27       	eor	r26, r26
    28b4:	f0 0d       	add	r31, r0
    28b6:	b1 1d       	adc	r27, r1
    28b8:	aa 1f       	adc	r26, r26
    28ba:	64 9f       	mul	r22, r20
    28bc:	66 27       	eor	r22, r22
    28be:	b0 0d       	add	r27, r0
    28c0:	a1 1d       	adc	r26, r1
    28c2:	66 1f       	adc	r22, r22
    28c4:	82 9f       	mul	r24, r18
    28c6:	22 27       	eor	r18, r18
    28c8:	b0 0d       	add	r27, r0
    28ca:	a1 1d       	adc	r26, r1
    28cc:	62 1f       	adc	r22, r18
    28ce:	73 9f       	mul	r23, r19
    28d0:	b0 0d       	add	r27, r0
    28d2:	a1 1d       	adc	r26, r1
    28d4:	62 1f       	adc	r22, r18
    28d6:	83 9f       	mul	r24, r19
    28d8:	a0 0d       	add	r26, r0
    28da:	61 1d       	adc	r22, r1
    28dc:	22 1f       	adc	r18, r18
    28de:	74 9f       	mul	r23, r20
    28e0:	33 27       	eor	r19, r19
    28e2:	a0 0d       	add	r26, r0
    28e4:	61 1d       	adc	r22, r1
    28e6:	23 1f       	adc	r18, r19
    28e8:	84 9f       	mul	r24, r20
    28ea:	60 0d       	add	r22, r0
    28ec:	21 1d       	adc	r18, r1
    28ee:	82 2f       	mov	r24, r18
    28f0:	76 2f       	mov	r23, r22
    28f2:	6a 2f       	mov	r22, r26
    28f4:	11 24       	eor	r1, r1
    28f6:	9f 57       	subi	r25, 0x7F	; 127
    28f8:	50 40       	sbci	r21, 0x00	; 0
    28fa:	8a f0       	brmi	.+34     	; 0x291e <__mulsf3_pse+0x84>
    28fc:	e1 f0       	breq	.+56     	; 0x2936 <__mulsf3_pse+0x9c>
    28fe:	88 23       	and	r24, r24
    2900:	4a f0       	brmi	.+18     	; 0x2914 <__mulsf3_pse+0x7a>
    2902:	ee 0f       	add	r30, r30
    2904:	ff 1f       	adc	r31, r31
    2906:	bb 1f       	adc	r27, r27
    2908:	66 1f       	adc	r22, r22
    290a:	77 1f       	adc	r23, r23
    290c:	88 1f       	adc	r24, r24
    290e:	91 50       	subi	r25, 0x01	; 1
    2910:	50 40       	sbci	r21, 0x00	; 0
    2912:	a9 f7       	brne	.-22     	; 0x28fe <__mulsf3_pse+0x64>
    2914:	9e 3f       	cpi	r25, 0xFE	; 254
    2916:	51 05       	cpc	r21, r1
    2918:	70 f0       	brcs	.+28     	; 0x2936 <__mulsf3_pse+0x9c>
    291a:	60 cf       	rjmp	.-320    	; 0x27dc <__fp_inf>
    291c:	aa cf       	rjmp	.-172    	; 0x2872 <__fp_szero>
    291e:	5f 3f       	cpi	r21, 0xFF	; 255
    2920:	ec f3       	brlt	.-6      	; 0x291c <__mulsf3_pse+0x82>
    2922:	98 3e       	cpi	r25, 0xE8	; 232
    2924:	dc f3       	brlt	.-10     	; 0x291c <__mulsf3_pse+0x82>
    2926:	86 95       	lsr	r24
    2928:	77 95       	ror	r23
    292a:	67 95       	ror	r22
    292c:	b7 95       	ror	r27
    292e:	f7 95       	ror	r31
    2930:	e7 95       	ror	r30
    2932:	9f 5f       	subi	r25, 0xFF	; 255
    2934:	c1 f7       	brne	.-16     	; 0x2926 <__mulsf3_pse+0x8c>
    2936:	fe 2b       	or	r31, r30
    2938:	88 0f       	add	r24, r24
    293a:	91 1d       	adc	r25, r1
    293c:	96 95       	lsr	r25
    293e:	87 95       	ror	r24
    2940:	97 f9       	bld	r25, 7
    2942:	08 95       	ret

00002944 <pow>:
    2944:	fa 01       	movw	r30, r20
    2946:	ee 0f       	add	r30, r30
    2948:	ff 1f       	adc	r31, r31
    294a:	30 96       	adiw	r30, 0x00	; 0
    294c:	21 05       	cpc	r18, r1
    294e:	31 05       	cpc	r19, r1
    2950:	99 f1       	breq	.+102    	; 0x29b8 <pow+0x74>
    2952:	61 15       	cp	r22, r1
    2954:	71 05       	cpc	r23, r1
    2956:	61 f4       	brne	.+24     	; 0x2970 <pow+0x2c>
    2958:	80 38       	cpi	r24, 0x80	; 128
    295a:	bf e3       	ldi	r27, 0x3F	; 63
    295c:	9b 07       	cpc	r25, r27
    295e:	49 f1       	breq	.+82     	; 0x29b2 <pow+0x6e>
    2960:	68 94       	set
    2962:	90 38       	cpi	r25, 0x80	; 128
    2964:	81 05       	cpc	r24, r1
    2966:	61 f0       	breq	.+24     	; 0x2980 <pow+0x3c>
    2968:	80 38       	cpi	r24, 0x80	; 128
    296a:	bf ef       	ldi	r27, 0xFF	; 255
    296c:	9b 07       	cpc	r25, r27
    296e:	41 f0       	breq	.+16     	; 0x2980 <pow+0x3c>
    2970:	99 23       	and	r25, r25
    2972:	42 f5       	brpl	.+80     	; 0x29c4 <pow+0x80>
    2974:	ff 3f       	cpi	r31, 0xFF	; 255
    2976:	e1 05       	cpc	r30, r1
    2978:	31 05       	cpc	r19, r1
    297a:	21 05       	cpc	r18, r1
    297c:	11 f1       	breq	.+68     	; 0x29c2 <pow+0x7e>
    297e:	e8 94       	clt
    2980:	08 94       	sec
    2982:	e7 95       	ror	r30
    2984:	d9 01       	movw	r26, r18
    2986:	aa 23       	and	r26, r26
    2988:	29 f4       	brne	.+10     	; 0x2994 <pow+0x50>
    298a:	ab 2f       	mov	r26, r27
    298c:	be 2f       	mov	r27, r30
    298e:	f8 5f       	subi	r31, 0xF8	; 248
    2990:	d0 f3       	brcs	.-12     	; 0x2986 <pow+0x42>
    2992:	10 c0       	rjmp	.+32     	; 0x29b4 <pow+0x70>
    2994:	ff 5f       	subi	r31, 0xFF	; 255
    2996:	70 f4       	brcc	.+28     	; 0x29b4 <pow+0x70>
    2998:	a6 95       	lsr	r26
    299a:	e0 f7       	brcc	.-8      	; 0x2994 <pow+0x50>
    299c:	f7 39       	cpi	r31, 0x97	; 151
    299e:	50 f0       	brcs	.+20     	; 0x29b4 <pow+0x70>
    29a0:	19 f0       	breq	.+6      	; 0x29a8 <pow+0x64>
    29a2:	ff 3a       	cpi	r31, 0xAF	; 175
    29a4:	38 f4       	brcc	.+14     	; 0x29b4 <pow+0x70>
    29a6:	9f 77       	andi	r25, 0x7F	; 127
    29a8:	9f 93       	push	r25
    29aa:	0c d0       	rcall	.+24     	; 0x29c4 <pow+0x80>
    29ac:	0f 90       	pop	r0
    29ae:	07 fc       	sbrc	r0, 7
    29b0:	90 58       	subi	r25, 0x80	; 128
    29b2:	08 95       	ret
    29b4:	3e f0       	brts	.+14     	; 0x29c4 <pow+0x80>
    29b6:	18 cf       	rjmp	.-464    	; 0x27e8 <__fp_nan>
    29b8:	60 e0       	ldi	r22, 0x00	; 0
    29ba:	70 e0       	ldi	r23, 0x00	; 0
    29bc:	80 e8       	ldi	r24, 0x80	; 128
    29be:	9f e3       	ldi	r25, 0x3F	; 63
    29c0:	08 95       	ret
    29c2:	4f e7       	ldi	r20, 0x7F	; 127
    29c4:	9f 77       	andi	r25, 0x7F	; 127
    29c6:	5f 93       	push	r21
    29c8:	4f 93       	push	r20
    29ca:	3f 93       	push	r19
    29cc:	2f 93       	push	r18
    29ce:	9e d0       	rcall	.+316    	; 0x2b0c <log>
    29d0:	2f 91       	pop	r18
    29d2:	3f 91       	pop	r19
    29d4:	4f 91       	pop	r20
    29d6:	5f 91       	pop	r21
    29d8:	52 df       	rcall	.-348    	; 0x287e <__mulsf3>
    29da:	05 c0       	rjmp	.+10     	; 0x29e6 <exp>
    29dc:	19 f4       	brne	.+6      	; 0x29e4 <pow+0xa0>
    29de:	0e f0       	brts	.+2      	; 0x29e2 <pow+0x9e>
    29e0:	fd ce       	rjmp	.-518    	; 0x27dc <__fp_inf>
    29e2:	46 cf       	rjmp	.-372    	; 0x2870 <__fp_zero>
    29e4:	01 cf       	rjmp	.-510    	; 0x27e8 <__fp_nan>

000029e6 <exp>:
    29e6:	2a df       	rcall	.-428    	; 0x283c <__fp_splitA>
    29e8:	c8 f3       	brcs	.-14     	; 0x29dc <pow+0x98>
    29ea:	96 38       	cpi	r25, 0x86	; 134
    29ec:	c0 f7       	brcc	.-16     	; 0x29de <pow+0x9a>
    29ee:	07 f8       	bld	r0, 7
    29f0:	0f 92       	push	r0
    29f2:	e8 94       	clt
    29f4:	2b e3       	ldi	r18, 0x3B	; 59
    29f6:	3a ea       	ldi	r19, 0xAA	; 170
    29f8:	48 eb       	ldi	r20, 0xB8	; 184
    29fa:	5f e7       	ldi	r21, 0x7F	; 127
    29fc:	4e df       	rcall	.-356    	; 0x289a <__mulsf3_pse>
    29fe:	0f 92       	push	r0
    2a00:	0f 92       	push	r0
    2a02:	0f 92       	push	r0
    2a04:	4d b7       	in	r20, 0x3d	; 61
    2a06:	5e b7       	in	r21, 0x3e	; 62
    2a08:	0f 92       	push	r0
    2a0a:	c0 d0       	rcall	.+384    	; 0x2b8c <modf>
    2a0c:	e4 ee       	ldi	r30, 0xE4	; 228
    2a0e:	f0 e0       	ldi	r31, 0x00	; 0
    2a10:	16 d0       	rcall	.+44     	; 0x2a3e <__fp_powser>
    2a12:	4f 91       	pop	r20
    2a14:	5f 91       	pop	r21
    2a16:	ef 91       	pop	r30
    2a18:	ff 91       	pop	r31
    2a1a:	e5 95       	asr	r30
    2a1c:	ee 1f       	adc	r30, r30
    2a1e:	ff 1f       	adc	r31, r31
    2a20:	49 f0       	breq	.+18     	; 0x2a34 <exp+0x4e>
    2a22:	fe 57       	subi	r31, 0x7E	; 126
    2a24:	e0 68       	ori	r30, 0x80	; 128
    2a26:	44 27       	eor	r20, r20
    2a28:	ee 0f       	add	r30, r30
    2a2a:	44 1f       	adc	r20, r20
    2a2c:	fa 95       	dec	r31
    2a2e:	e1 f7       	brne	.-8      	; 0x2a28 <exp+0x42>
    2a30:	41 95       	neg	r20
    2a32:	55 0b       	sbc	r21, r21
    2a34:	32 d0       	rcall	.+100    	; 0x2a9a <ldexp>
    2a36:	0f 90       	pop	r0
    2a38:	07 fe       	sbrs	r0, 7
    2a3a:	26 c0       	rjmp	.+76     	; 0x2a88 <inverse>
    2a3c:	08 95       	ret

00002a3e <__fp_powser>:
    2a3e:	df 93       	push	r29
    2a40:	cf 93       	push	r28
    2a42:	1f 93       	push	r17
    2a44:	0f 93       	push	r16
    2a46:	ff 92       	push	r15
    2a48:	ef 92       	push	r14
    2a4a:	df 92       	push	r13
    2a4c:	7b 01       	movw	r14, r22
    2a4e:	8c 01       	movw	r16, r24
    2a50:	68 94       	set
    2a52:	05 c0       	rjmp	.+10     	; 0x2a5e <__fp_powser+0x20>
    2a54:	da 2e       	mov	r13, r26
    2a56:	ef 01       	movw	r28, r30
    2a58:	1e df       	rcall	.-452    	; 0x2896 <__mulsf3x>
    2a5a:	fe 01       	movw	r30, r28
    2a5c:	e8 94       	clt
    2a5e:	a5 91       	lpm	r26, Z+
    2a60:	25 91       	lpm	r18, Z+
    2a62:	35 91       	lpm	r19, Z+
    2a64:	45 91       	lpm	r20, Z+
    2a66:	55 91       	lpm	r21, Z+
    2a68:	ae f3       	brts	.-22     	; 0x2a54 <__fp_powser+0x16>
    2a6a:	ef 01       	movw	r28, r30
    2a6c:	f6 dd       	rcall	.-1044   	; 0x265a <__addsf3x>
    2a6e:	fe 01       	movw	r30, r28
    2a70:	97 01       	movw	r18, r14
    2a72:	a8 01       	movw	r20, r16
    2a74:	da 94       	dec	r13
    2a76:	79 f7       	brne	.-34     	; 0x2a56 <__fp_powser+0x18>
    2a78:	df 90       	pop	r13
    2a7a:	ef 90       	pop	r14
    2a7c:	ff 90       	pop	r15
    2a7e:	0f 91       	pop	r16
    2a80:	1f 91       	pop	r17
    2a82:	cf 91       	pop	r28
    2a84:	df 91       	pop	r29
    2a86:	08 95       	ret

00002a88 <inverse>:
    2a88:	9b 01       	movw	r18, r22
    2a8a:	ac 01       	movw	r20, r24
    2a8c:	60 e0       	ldi	r22, 0x00	; 0
    2a8e:	70 e0       	ldi	r23, 0x00	; 0
    2a90:	80 e8       	ldi	r24, 0x80	; 128
    2a92:	9f e3       	ldi	r25, 0x3F	; 63
    2a94:	ae c0       	rjmp	.+348    	; 0x2bf2 <__divsf3>
    2a96:	a2 ce       	rjmp	.-700    	; 0x27dc <__fp_inf>
    2a98:	14 c1       	rjmp	.+552    	; 0x2cc2 <__fp_mpack>

00002a9a <ldexp>:
    2a9a:	d0 de       	rcall	.-608    	; 0x283c <__fp_splitA>
    2a9c:	e8 f3       	brcs	.-6      	; 0x2a98 <inverse+0x10>
    2a9e:	99 23       	and	r25, r25
    2aa0:	d9 f3       	breq	.-10     	; 0x2a98 <inverse+0x10>
    2aa2:	94 0f       	add	r25, r20
    2aa4:	51 1d       	adc	r21, r1
    2aa6:	bb f3       	brvs	.-18     	; 0x2a96 <inverse+0xe>
    2aa8:	91 50       	subi	r25, 0x01	; 1
    2aaa:	50 40       	sbci	r21, 0x00	; 0
    2aac:	94 f0       	brlt	.+36     	; 0x2ad2 <ldexp+0x38>
    2aae:	59 f0       	breq	.+22     	; 0x2ac6 <ldexp+0x2c>
    2ab0:	88 23       	and	r24, r24
    2ab2:	32 f0       	brmi	.+12     	; 0x2ac0 <ldexp+0x26>
    2ab4:	66 0f       	add	r22, r22
    2ab6:	77 1f       	adc	r23, r23
    2ab8:	88 1f       	adc	r24, r24
    2aba:	91 50       	subi	r25, 0x01	; 1
    2abc:	50 40       	sbci	r21, 0x00	; 0
    2abe:	c1 f7       	brne	.-16     	; 0x2ab0 <ldexp+0x16>
    2ac0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ac2:	51 05       	cpc	r21, r1
    2ac4:	44 f7       	brge	.-48     	; 0x2a96 <inverse+0xe>
    2ac6:	88 0f       	add	r24, r24
    2ac8:	91 1d       	adc	r25, r1
    2aca:	96 95       	lsr	r25
    2acc:	87 95       	ror	r24
    2ace:	97 f9       	bld	r25, 7
    2ad0:	08 95       	ret
    2ad2:	5f 3f       	cpi	r21, 0xFF	; 255
    2ad4:	ac f0       	brlt	.+42     	; 0x2b00 <ldexp+0x66>
    2ad6:	98 3e       	cpi	r25, 0xE8	; 232
    2ad8:	9c f0       	brlt	.+38     	; 0x2b00 <ldexp+0x66>
    2ada:	bb 27       	eor	r27, r27
    2adc:	86 95       	lsr	r24
    2ade:	77 95       	ror	r23
    2ae0:	67 95       	ror	r22
    2ae2:	b7 95       	ror	r27
    2ae4:	08 f4       	brcc	.+2      	; 0x2ae8 <ldexp+0x4e>
    2ae6:	b1 60       	ori	r27, 0x01	; 1
    2ae8:	93 95       	inc	r25
    2aea:	c1 f7       	brne	.-16     	; 0x2adc <ldexp+0x42>
    2aec:	bb 0f       	add	r27, r27
    2aee:	58 f7       	brcc	.-42     	; 0x2ac6 <ldexp+0x2c>
    2af0:	11 f4       	brne	.+4      	; 0x2af6 <ldexp+0x5c>
    2af2:	60 ff       	sbrs	r22, 0
    2af4:	e8 cf       	rjmp	.-48     	; 0x2ac6 <ldexp+0x2c>
    2af6:	6f 5f       	subi	r22, 0xFF	; 255
    2af8:	7f 4f       	sbci	r23, 0xFF	; 255
    2afa:	8f 4f       	sbci	r24, 0xFF	; 255
    2afc:	9f 4f       	sbci	r25, 0xFF	; 255
    2afe:	e3 cf       	rjmp	.-58     	; 0x2ac6 <ldexp+0x2c>
    2b00:	b8 ce       	rjmp	.-656    	; 0x2872 <__fp_szero>
    2b02:	0e f0       	brts	.+2      	; 0x2b06 <ldexp+0x6c>
    2b04:	de c0       	rjmp	.+444    	; 0x2cc2 <__fp_mpack>
    2b06:	70 ce       	rjmp	.-800    	; 0x27e8 <__fp_nan>
    2b08:	68 94       	set
    2b0a:	68 ce       	rjmp	.-816    	; 0x27dc <__fp_inf>

00002b0c <log>:
    2b0c:	97 de       	rcall	.-722    	; 0x283c <__fp_splitA>
    2b0e:	c8 f3       	brcs	.-14     	; 0x2b02 <ldexp+0x68>
    2b10:	99 23       	and	r25, r25
    2b12:	d1 f3       	breq	.-12     	; 0x2b08 <ldexp+0x6e>
    2b14:	c6 f3       	brts	.-16     	; 0x2b06 <ldexp+0x6c>
    2b16:	df 93       	push	r29
    2b18:	cf 93       	push	r28
    2b1a:	1f 93       	push	r17
    2b1c:	0f 93       	push	r16
    2b1e:	ff 92       	push	r15
    2b20:	c9 2f       	mov	r28, r25
    2b22:	dd 27       	eor	r29, r29
    2b24:	88 23       	and	r24, r24
    2b26:	2a f0       	brmi	.+10     	; 0x2b32 <log+0x26>
    2b28:	21 97       	sbiw	r28, 0x01	; 1
    2b2a:	66 0f       	add	r22, r22
    2b2c:	77 1f       	adc	r23, r23
    2b2e:	88 1f       	adc	r24, r24
    2b30:	da f7       	brpl	.-10     	; 0x2b28 <log+0x1c>
    2b32:	20 e0       	ldi	r18, 0x00	; 0
    2b34:	30 e0       	ldi	r19, 0x00	; 0
    2b36:	40 e8       	ldi	r20, 0x80	; 128
    2b38:	5f eb       	ldi	r21, 0xBF	; 191
    2b3a:	9f e3       	ldi	r25, 0x3F	; 63
    2b3c:	88 39       	cpi	r24, 0x98	; 152
    2b3e:	20 f0       	brcs	.+8      	; 0x2b48 <log+0x3c>
    2b40:	80 3e       	cpi	r24, 0xE0	; 224
    2b42:	30 f0       	brcs	.+12     	; 0x2b50 <log+0x44>
    2b44:	21 96       	adiw	r28, 0x01	; 1
    2b46:	8f 77       	andi	r24, 0x7F	; 127
    2b48:	77 dd       	rcall	.-1298   	; 0x2638 <__addsf3>
    2b4a:	ec e0       	ldi	r30, 0x0C	; 12
    2b4c:	f1 e0       	ldi	r31, 0x01	; 1
    2b4e:	03 c0       	rjmp	.+6      	; 0x2b56 <log+0x4a>
    2b50:	73 dd       	rcall	.-1306   	; 0x2638 <__addsf3>
    2b52:	e9 e3       	ldi	r30, 0x39	; 57
    2b54:	f1 e0       	ldi	r31, 0x01	; 1
    2b56:	73 df       	rcall	.-282    	; 0x2a3e <__fp_powser>
    2b58:	8b 01       	movw	r16, r22
    2b5a:	be 01       	movw	r22, r28
    2b5c:	ec 01       	movw	r28, r24
    2b5e:	fb 2e       	mov	r15, r27
    2b60:	6f 57       	subi	r22, 0x7F	; 127
    2b62:	71 09       	sbc	r23, r1
    2b64:	75 95       	asr	r23
    2b66:	77 1f       	adc	r23, r23
    2b68:	88 0b       	sbc	r24, r24
    2b6a:	99 0b       	sbc	r25, r25
    2b6c:	fc dd       	rcall	.-1032   	; 0x2766 <__floatsisf>
    2b6e:	28 e1       	ldi	r18, 0x18	; 24
    2b70:	32 e7       	ldi	r19, 0x72	; 114
    2b72:	41 e3       	ldi	r20, 0x31	; 49
    2b74:	5f e3       	ldi	r21, 0x3F	; 63
    2b76:	8f de       	rcall	.-738    	; 0x2896 <__mulsf3x>
    2b78:	af 2d       	mov	r26, r15
    2b7a:	98 01       	movw	r18, r16
    2b7c:	ae 01       	movw	r20, r28
    2b7e:	ff 90       	pop	r15
    2b80:	0f 91       	pop	r16
    2b82:	1f 91       	pop	r17
    2b84:	cf 91       	pop	r28
    2b86:	df 91       	pop	r29
    2b88:	68 dd       	rcall	.-1328   	; 0x265a <__addsf3x>
    2b8a:	3f ce       	rjmp	.-898    	; 0x280a <__fp_round>

00002b8c <modf>:
    2b8c:	fa 01       	movw	r30, r20
    2b8e:	dc 01       	movw	r26, r24
    2b90:	aa 0f       	add	r26, r26
    2b92:	bb 1f       	adc	r27, r27
    2b94:	9b 01       	movw	r18, r22
    2b96:	ac 01       	movw	r20, r24
    2b98:	bf 57       	subi	r27, 0x7F	; 127
    2b9a:	28 f4       	brcc	.+10     	; 0x2ba6 <modf+0x1a>
    2b9c:	22 27       	eor	r18, r18
    2b9e:	33 27       	eor	r19, r19
    2ba0:	44 27       	eor	r20, r20
    2ba2:	50 78       	andi	r21, 0x80	; 128
    2ba4:	1f c0       	rjmp	.+62     	; 0x2be4 <modf+0x58>
    2ba6:	b7 51       	subi	r27, 0x17	; 23
    2ba8:	88 f4       	brcc	.+34     	; 0x2bcc <modf+0x40>
    2baa:	ab 2f       	mov	r26, r27
    2bac:	00 24       	eor	r0, r0
    2bae:	46 95       	lsr	r20
    2bb0:	37 95       	ror	r19
    2bb2:	27 95       	ror	r18
    2bb4:	01 1c       	adc	r0, r1
    2bb6:	a3 95       	inc	r26
    2bb8:	d2 f3       	brmi	.-12     	; 0x2bae <modf+0x22>
    2bba:	00 20       	and	r0, r0
    2bbc:	69 f0       	breq	.+26     	; 0x2bd8 <modf+0x4c>
    2bbe:	22 0f       	add	r18, r18
    2bc0:	33 1f       	adc	r19, r19
    2bc2:	44 1f       	adc	r20, r20
    2bc4:	b3 95       	inc	r27
    2bc6:	da f3       	brmi	.-10     	; 0x2bbe <modf+0x32>
    2bc8:	0d d0       	rcall	.+26     	; 0x2be4 <modf+0x58>
    2bca:	35 cd       	rjmp	.-1430   	; 0x2636 <__subsf3>
    2bcc:	61 30       	cpi	r22, 0x01	; 1
    2bce:	71 05       	cpc	r23, r1
    2bd0:	a0 e8       	ldi	r26, 0x80	; 128
    2bd2:	8a 07       	cpc	r24, r26
    2bd4:	b9 46       	sbci	r27, 0x69	; 105
    2bd6:	30 f4       	brcc	.+12     	; 0x2be4 <modf+0x58>
    2bd8:	9b 01       	movw	r18, r22
    2bda:	ac 01       	movw	r20, r24
    2bdc:	66 27       	eor	r22, r22
    2bde:	77 27       	eor	r23, r23
    2be0:	88 27       	eor	r24, r24
    2be2:	90 78       	andi	r25, 0x80	; 128
    2be4:	30 96       	adiw	r30, 0x00	; 0
    2be6:	21 f0       	breq	.+8      	; 0x2bf0 <modf+0x64>
    2be8:	20 83       	st	Z, r18
    2bea:	31 83       	std	Z+1, r19	; 0x01
    2bec:	42 83       	std	Z+2, r20	; 0x02
    2bee:	53 83       	std	Z+3, r21	; 0x03
    2bf0:	08 95       	ret

00002bf2 <__divsf3>:
    2bf2:	0c d0       	rcall	.+24     	; 0x2c0c <__divsf3x>
    2bf4:	0a ce       	rjmp	.-1004   	; 0x280a <__fp_round>
    2bf6:	02 de       	rcall	.-1020   	; 0x27fc <__fp_pscB>
    2bf8:	40 f0       	brcs	.+16     	; 0x2c0a <__divsf3+0x18>
    2bfa:	f9 dd       	rcall	.-1038   	; 0x27ee <__fp_pscA>
    2bfc:	30 f0       	brcs	.+12     	; 0x2c0a <__divsf3+0x18>
    2bfe:	21 f4       	brne	.+8      	; 0x2c08 <__divsf3+0x16>
    2c00:	5f 3f       	cpi	r21, 0xFF	; 255
    2c02:	19 f0       	breq	.+6      	; 0x2c0a <__divsf3+0x18>
    2c04:	eb cd       	rjmp	.-1066   	; 0x27dc <__fp_inf>
    2c06:	51 11       	cpse	r21, r1
    2c08:	34 ce       	rjmp	.-920    	; 0x2872 <__fp_szero>
    2c0a:	ee cd       	rjmp	.-1060   	; 0x27e8 <__fp_nan>

00002c0c <__divsf3x>:
    2c0c:	0f de       	rcall	.-994    	; 0x282c <__fp_split3>
    2c0e:	98 f3       	brcs	.-26     	; 0x2bf6 <__divsf3+0x4>

00002c10 <__divsf3_pse>:
    2c10:	99 23       	and	r25, r25
    2c12:	c9 f3       	breq	.-14     	; 0x2c06 <__divsf3+0x14>
    2c14:	55 23       	and	r21, r21
    2c16:	b1 f3       	breq	.-20     	; 0x2c04 <__divsf3+0x12>
    2c18:	95 1b       	sub	r25, r21
    2c1a:	55 0b       	sbc	r21, r21
    2c1c:	bb 27       	eor	r27, r27
    2c1e:	aa 27       	eor	r26, r26
    2c20:	62 17       	cp	r22, r18
    2c22:	73 07       	cpc	r23, r19
    2c24:	84 07       	cpc	r24, r20
    2c26:	38 f0       	brcs	.+14     	; 0x2c36 <__divsf3_pse+0x26>
    2c28:	9f 5f       	subi	r25, 0xFF	; 255
    2c2a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c2c:	22 0f       	add	r18, r18
    2c2e:	33 1f       	adc	r19, r19
    2c30:	44 1f       	adc	r20, r20
    2c32:	aa 1f       	adc	r26, r26
    2c34:	a9 f3       	breq	.-22     	; 0x2c20 <__divsf3_pse+0x10>
    2c36:	33 d0       	rcall	.+102    	; 0x2c9e <__divsf3_pse+0x8e>
    2c38:	0e 2e       	mov	r0, r30
    2c3a:	3a f0       	brmi	.+14     	; 0x2c4a <__divsf3_pse+0x3a>
    2c3c:	e0 e8       	ldi	r30, 0x80	; 128
    2c3e:	30 d0       	rcall	.+96     	; 0x2ca0 <__divsf3_pse+0x90>
    2c40:	91 50       	subi	r25, 0x01	; 1
    2c42:	50 40       	sbci	r21, 0x00	; 0
    2c44:	e6 95       	lsr	r30
    2c46:	00 1c       	adc	r0, r0
    2c48:	ca f7       	brpl	.-14     	; 0x2c3c <__divsf3_pse+0x2c>
    2c4a:	29 d0       	rcall	.+82     	; 0x2c9e <__divsf3_pse+0x8e>
    2c4c:	fe 2f       	mov	r31, r30
    2c4e:	27 d0       	rcall	.+78     	; 0x2c9e <__divsf3_pse+0x8e>
    2c50:	66 0f       	add	r22, r22
    2c52:	77 1f       	adc	r23, r23
    2c54:	88 1f       	adc	r24, r24
    2c56:	bb 1f       	adc	r27, r27
    2c58:	26 17       	cp	r18, r22
    2c5a:	37 07       	cpc	r19, r23
    2c5c:	48 07       	cpc	r20, r24
    2c5e:	ab 07       	cpc	r26, r27
    2c60:	b0 e8       	ldi	r27, 0x80	; 128
    2c62:	09 f0       	breq	.+2      	; 0x2c66 <__divsf3_pse+0x56>
    2c64:	bb 0b       	sbc	r27, r27
    2c66:	80 2d       	mov	r24, r0
    2c68:	bf 01       	movw	r22, r30
    2c6a:	ff 27       	eor	r31, r31
    2c6c:	93 58       	subi	r25, 0x83	; 131
    2c6e:	5f 4f       	sbci	r21, 0xFF	; 255
    2c70:	2a f0       	brmi	.+10     	; 0x2c7c <__divsf3_pse+0x6c>
    2c72:	9e 3f       	cpi	r25, 0xFE	; 254
    2c74:	51 05       	cpc	r21, r1
    2c76:	68 f0       	brcs	.+26     	; 0x2c92 <__divsf3_pse+0x82>
    2c78:	b1 cd       	rjmp	.-1182   	; 0x27dc <__fp_inf>
    2c7a:	fb cd       	rjmp	.-1034   	; 0x2872 <__fp_szero>
    2c7c:	5f 3f       	cpi	r21, 0xFF	; 255
    2c7e:	ec f3       	brlt	.-6      	; 0x2c7a <__divsf3_pse+0x6a>
    2c80:	98 3e       	cpi	r25, 0xE8	; 232
    2c82:	dc f3       	brlt	.-10     	; 0x2c7a <__divsf3_pse+0x6a>
    2c84:	86 95       	lsr	r24
    2c86:	77 95       	ror	r23
    2c88:	67 95       	ror	r22
    2c8a:	b7 95       	ror	r27
    2c8c:	f7 95       	ror	r31
    2c8e:	9f 5f       	subi	r25, 0xFF	; 255
    2c90:	c9 f7       	brne	.-14     	; 0x2c84 <__divsf3_pse+0x74>
    2c92:	88 0f       	add	r24, r24
    2c94:	91 1d       	adc	r25, r1
    2c96:	96 95       	lsr	r25
    2c98:	87 95       	ror	r24
    2c9a:	97 f9       	bld	r25, 7
    2c9c:	08 95       	ret
    2c9e:	e1 e0       	ldi	r30, 0x01	; 1
    2ca0:	66 0f       	add	r22, r22
    2ca2:	77 1f       	adc	r23, r23
    2ca4:	88 1f       	adc	r24, r24
    2ca6:	bb 1f       	adc	r27, r27
    2ca8:	62 17       	cp	r22, r18
    2caa:	73 07       	cpc	r23, r19
    2cac:	84 07       	cpc	r24, r20
    2cae:	ba 07       	cpc	r27, r26
    2cb0:	20 f0       	brcs	.+8      	; 0x2cba <__divsf3_pse+0xaa>
    2cb2:	62 1b       	sub	r22, r18
    2cb4:	73 0b       	sbc	r23, r19
    2cb6:	84 0b       	sbc	r24, r20
    2cb8:	ba 0b       	sbc	r27, r26
    2cba:	ee 1f       	adc	r30, r30
    2cbc:	88 f7       	brcc	.-30     	; 0x2ca0 <__divsf3_pse+0x90>
    2cbe:	e0 95       	com	r30
    2cc0:	08 95       	ret

00002cc2 <__fp_mpack>:
    2cc2:	9f 3f       	cpi	r25, 0xFF	; 255
    2cc4:	31 f0       	breq	.+12     	; 0x2cd2 <__fp_mpack_finite+0xc>

00002cc6 <__fp_mpack_finite>:
    2cc6:	91 50       	subi	r25, 0x01	; 1
    2cc8:	20 f4       	brcc	.+8      	; 0x2cd2 <__fp_mpack_finite+0xc>
    2cca:	87 95       	ror	r24
    2ccc:	77 95       	ror	r23
    2cce:	67 95       	ror	r22
    2cd0:	b7 95       	ror	r27
    2cd2:	88 0f       	add	r24, r24
    2cd4:	91 1d       	adc	r25, r1
    2cd6:	96 95       	lsr	r25
    2cd8:	87 95       	ror	r24
    2cda:	97 f9       	bld	r25, 7
    2cdc:	08 95       	ret

00002cde <__divmodhi4>:
    2cde:	97 fb       	bst	r25, 7
    2ce0:	07 2e       	mov	r0, r23
    2ce2:	16 f4       	brtc	.+4      	; 0x2ce8 <__divmodhi4+0xa>
    2ce4:	00 94       	com	r0
    2ce6:	06 d0       	rcall	.+12     	; 0x2cf4 <__divmodhi4_neg1>
    2ce8:	77 fd       	sbrc	r23, 7
    2cea:	08 d0       	rcall	.+16     	; 0x2cfc <__divmodhi4_neg2>
    2cec:	0b d0       	rcall	.+22     	; 0x2d04 <__udivmodhi4>
    2cee:	07 fc       	sbrc	r0, 7
    2cf0:	05 d0       	rcall	.+10     	; 0x2cfc <__divmodhi4_neg2>
    2cf2:	3e f4       	brtc	.+14     	; 0x2d02 <__divmodhi4_exit>

00002cf4 <__divmodhi4_neg1>:
    2cf4:	90 95       	com	r25
    2cf6:	81 95       	neg	r24
    2cf8:	9f 4f       	sbci	r25, 0xFF	; 255
    2cfa:	08 95       	ret

00002cfc <__divmodhi4_neg2>:
    2cfc:	70 95       	com	r23
    2cfe:	61 95       	neg	r22
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255

00002d02 <__divmodhi4_exit>:
    2d02:	08 95       	ret

00002d04 <__udivmodhi4>:
    2d04:	aa 1b       	sub	r26, r26
    2d06:	bb 1b       	sub	r27, r27
    2d08:	51 e1       	ldi	r21, 0x11	; 17
    2d0a:	07 c0       	rjmp	.+14     	; 0x2d1a <__udivmodhi4_ep>

00002d0c <__udivmodhi4_loop>:
    2d0c:	aa 1f       	adc	r26, r26
    2d0e:	bb 1f       	adc	r27, r27
    2d10:	a6 17       	cp	r26, r22
    2d12:	b7 07       	cpc	r27, r23
    2d14:	10 f0       	brcs	.+4      	; 0x2d1a <__udivmodhi4_ep>
    2d16:	a6 1b       	sub	r26, r22
    2d18:	b7 0b       	sbc	r27, r23

00002d1a <__udivmodhi4_ep>:
    2d1a:	88 1f       	adc	r24, r24
    2d1c:	99 1f       	adc	r25, r25
    2d1e:	5a 95       	dec	r21
    2d20:	a9 f7       	brne	.-22     	; 0x2d0c <__udivmodhi4_loop>
    2d22:	80 95       	com	r24
    2d24:	90 95       	com	r25
    2d26:	bc 01       	movw	r22, r24
    2d28:	cd 01       	movw	r24, r26
    2d2a:	08 95       	ret

00002d2c <memcpy>:
    2d2c:	fb 01       	movw	r30, r22
    2d2e:	dc 01       	movw	r26, r24
    2d30:	02 c0       	rjmp	.+4      	; 0x2d36 <memcpy+0xa>
    2d32:	01 90       	ld	r0, Z+
    2d34:	0d 92       	st	X+, r0
    2d36:	41 50       	subi	r20, 0x01	; 1
    2d38:	50 40       	sbci	r21, 0x00	; 0
    2d3a:	d8 f7       	brcc	.-10     	; 0x2d32 <memcpy+0x6>
    2d3c:	08 95       	ret

00002d3e <__itoa_ncheck>:
    2d3e:	bb 27       	eor	r27, r27
    2d40:	4a 30       	cpi	r20, 0x0A	; 10
    2d42:	31 f4       	brne	.+12     	; 0x2d50 <__itoa_ncheck+0x12>
    2d44:	99 23       	and	r25, r25
    2d46:	22 f4       	brpl	.+8      	; 0x2d50 <__itoa_ncheck+0x12>
    2d48:	bd e2       	ldi	r27, 0x2D	; 45
    2d4a:	90 95       	com	r25
    2d4c:	81 95       	neg	r24
    2d4e:	9f 4f       	sbci	r25, 0xFF	; 255
    2d50:	01 c0       	rjmp	.+2      	; 0x2d54 <__utoa_common>

00002d52 <__utoa_ncheck>:
    2d52:	bb 27       	eor	r27, r27

00002d54 <__utoa_common>:
    2d54:	fb 01       	movw	r30, r22
    2d56:	55 27       	eor	r21, r21
    2d58:	aa 27       	eor	r26, r26
    2d5a:	88 0f       	add	r24, r24
    2d5c:	99 1f       	adc	r25, r25
    2d5e:	aa 1f       	adc	r26, r26
    2d60:	a4 17       	cp	r26, r20
    2d62:	10 f0       	brcs	.+4      	; 0x2d68 <__utoa_common+0x14>
    2d64:	a4 1b       	sub	r26, r20
    2d66:	83 95       	inc	r24
    2d68:	50 51       	subi	r21, 0x10	; 16
    2d6a:	b9 f7       	brne	.-18     	; 0x2d5a <__utoa_common+0x6>
    2d6c:	a0 5d       	subi	r26, 0xD0	; 208
    2d6e:	aa 33       	cpi	r26, 0x3A	; 58
    2d70:	08 f0       	brcs	.+2      	; 0x2d74 <__utoa_common+0x20>
    2d72:	a9 5d       	subi	r26, 0xD9	; 217
    2d74:	a1 93       	st	Z+, r26
    2d76:	00 97       	sbiw	r24, 0x00	; 0
    2d78:	79 f7       	brne	.-34     	; 0x2d58 <__utoa_common+0x4>
    2d7a:	b1 11       	cpse	r27, r1
    2d7c:	b1 93       	st	Z+, r27
    2d7e:	11 92       	st	Z+, r1
    2d80:	cb 01       	movw	r24, r22
    2d82:	00 c0       	rjmp	.+0      	; 0x2d84 <strrev>

00002d84 <strrev>:
    2d84:	dc 01       	movw	r26, r24
    2d86:	fc 01       	movw	r30, r24
    2d88:	67 2f       	mov	r22, r23
    2d8a:	71 91       	ld	r23, Z+
    2d8c:	77 23       	and	r23, r23
    2d8e:	e1 f7       	brne	.-8      	; 0x2d88 <strrev+0x4>
    2d90:	32 97       	sbiw	r30, 0x02	; 2
    2d92:	04 c0       	rjmp	.+8      	; 0x2d9c <strrev+0x18>
    2d94:	7c 91       	ld	r23, X
    2d96:	6d 93       	st	X+, r22
    2d98:	70 83       	st	Z, r23
    2d9a:	62 91       	ld	r22, -Z
    2d9c:	ae 17       	cp	r26, r30
    2d9e:	bf 07       	cpc	r27, r31
    2da0:	c8 f3       	brcs	.-14     	; 0x2d94 <strrev+0x10>
    2da2:	08 95       	ret

00002da4 <_exit>:
    2da4:	f8 94       	cli

00002da6 <__stop_program>:
    2da6:	ff cf       	rjmp	.-2      	; 0x2da6 <__stop_program>
