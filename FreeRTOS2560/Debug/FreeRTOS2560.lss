
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002e96  00002f2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e96  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070b  0080023e  0080023e  00002f68  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f68  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002f98  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f43  00000000  00000000  00003508  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000016aa  00000000  00000000  0000944b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000387d  00000000  00000000  0000aaf5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f64  00000000  00000000  0000e374  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017b0  00000000  00000000  0000f2d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004277  00000000  00000000  00010a88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00014cff  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	cd c3       	rjmp	.+1946   	; 0x7c0 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 e7 0a 	jmp	0x15ce	; 0x15ce <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	9f c7       	rjmp	.+3902   	; 0xfa4 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 40 08 	jmp	0x1080	; 0x1080 <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	b4 c4       	rjmp	.+2408   	; 0x9de <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	51 c7       	rjmp	.+3746   	; 0xf34 <__vector_36>
      92:	00 00       	nop
      94:	bf c7       	rjmp	.+3966   	; 0x1014 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0xa>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e6 e9       	ldi	r30, 0x96	; 150
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a9 34       	cpi	r26, 0x49	; 73
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	c3 d0       	rcall	.+390    	; 0x328 <main>
     1a2:	0c 94 49 17 	jmp	0x2e92	; 0x2e92 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	0e 94 55 09 	call	0x12aa	; 0x12aa <myUSART_peekReceiveUSART1>
     1ac:	c8 2f       	mov	r28, r24
     1ae:	0e 94 43 09 	call	0x1286	; 0x1286 <myUSART_receiveHandShakeAck>
     1b2:	88 23       	and	r24, r24
     1b4:	29 f0       	breq	.+10     	; 0x1c0 <RPI_receiveTask+0x18>
     1b6:	0e 94 08 09 	call	0x1210	; 0x1210 <myUSART_receiveUSART1>
     1ba:	0e 94 38 09 	call	0x1270	; 0x1270 <myUSART_completeHandShake>
     1be:	f4 cf       	rjmp	.-24     	; 0x1a8 <RPI_receiveTask>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 4f 09 	call	0x129e	; 0x129e <myUSART_receiveMessageACK>
     1c6:	88 23       	and	r24, r24
     1c8:	19 f0       	breq	.+6      	; 0x1d0 <RPI_receiveTask+0x28>
     1ca:	0e 94 08 09 	call	0x1210	; 0x1210 <myUSART_receiveUSART1>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	8c 2f       	mov	r24, r28
     1d2:	0e 94 49 09 	call	0x1292	; 0x1292 <myUSART_receiveHandShakeStart>
     1d6:	88 23       	and	r24, r24
     1d8:	19 f0       	breq	.+6      	; 0x1e0 <RPI_receiveTask+0x38>
     1da:	0e 94 29 09 	call	0x1252	; 0x1252 <myUSART_waitForHandshake>
     1de:	e4 cf       	rjmp	.-56     	; 0x1a8 <RPI_receiveTask>
     1e0:	0e 94 08 09 	call	0x1210	; 0x1210 <myUSART_receiveUSART1>
     1e4:	e1 cf       	rjmp	.-62     	; 0x1a8 <RPI_receiveTask>

000001e6 <RPI_sendTask>:
     1e6:	cf 93       	push	r28
     1e8:	df 93       	push	r29
     1ea:	00 d0       	rcall	.+0      	; 0x1ec <RPI_sendTask+0x6>
     1ec:	00 d0       	rcall	.+0      	; 0x1ee <RPI_sendTask+0x8>
     1ee:	cd b7       	in	r28, 0x3d	; 61
     1f0:	de b7       	in	r29, 0x3e	; 62
     1f2:	20 e0       	ldi	r18, 0x00	; 0
     1f4:	4f ef       	ldi	r20, 0xFF	; 255
     1f6:	5f ef       	ldi	r21, 0xFF	; 255
     1f8:	be 01       	movw	r22, r28
     1fa:	6a 5f       	subi	r22, 0xFA	; 250
     1fc:	7f 4f       	sbci	r23, 0xFF	; 255
     1fe:	80 91 91 08 	lds	r24, 0x0891
     202:	90 91 92 08 	lds	r25, 0x0892
     206:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <xQueueGenericReceive>
     20a:	8e 81       	ldd	r24, Y+6	; 0x06
     20c:	80 5d       	subi	r24, 0xD0	; 208
     20e:	cd d7       	rcall	.+3994   	; 0x11aa <myUSART_transmitUSART1_c>
     210:	8a e0       	ldi	r24, 0x0A	; 10
     212:	cb d7       	rcall	.+3990   	; 0x11aa <myUSART_transmitUSART1_c>
     214:	8e 81       	ldd	r24, Y+6	; 0x06
     216:	9f ef       	ldi	r25, 0xFF	; 255
     218:	98 0f       	add	r25, r24
     21a:	9e 83       	std	Y+6, r25	; 0x06
     21c:	88 23       	and	r24, r24
     21e:	21 f1       	breq	.+72     	; 0x268 <RPI_sendTask+0x82>
     220:	20 e0       	ldi	r18, 0x00	; 0
     222:	4f ef       	ldi	r20, 0xFF	; 255
     224:	5f ef       	ldi	r21, 0xFF	; 255
     226:	be 01       	movw	r22, r28
     228:	6f 5f       	subi	r22, 0xFF	; 255
     22a:	7f 4f       	sbci	r23, 0xFF	; 255
     22c:	80 91 93 08 	lds	r24, 0x0893
     230:	90 91 94 08 	lds	r25, 0x0894
     234:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <xQueueGenericReceive>
     238:	89 81       	ldd	r24, Y+1	; 0x01
     23a:	a0 d7       	rcall	.+3904   	; 0x117c <myUSART_transmitUSART0_c>
     23c:	89 81       	ldd	r24, Y+1	; 0x01
     23e:	b5 d7       	rcall	.+3946   	; 0x11aa <myUSART_transmitUSART1_c>
     240:	8c e0       	ldi	r24, 0x0C	; 12
     242:	92 e0       	ldi	r25, 0x02	; 2
     244:	d7 d7       	rcall	.+4014   	; 0x11f4 <myUSART_transmitUSART0>
     246:	ce 01       	movw	r24, r28
     248:	02 96       	adiw	r24, 0x02	; 2
     24a:	d4 d7       	rcall	.+4008   	; 0x11f4 <myUSART_transmitUSART0>
     24c:	ce 01       	movw	r24, r28
     24e:	02 96       	adiw	r24, 0x02	; 2
     250:	c3 d7       	rcall	.+3974   	; 0x11d8 <myUSART_transmitUSART1>
     252:	8a e0       	ldi	r24, 0x0A	; 10
     254:	aa d7       	rcall	.+3924   	; 0x11aa <myUSART_transmitUSART1_c>
     256:	8f e0       	ldi	r24, 0x0F	; 15
     258:	92 e0       	ldi	r25, 0x02	; 2
     25a:	cc d7       	rcall	.+3992   	; 0x11f4 <myUSART_transmitUSART0>
     25c:	8e 81       	ldd	r24, Y+6	; 0x06
     25e:	9f ef       	ldi	r25, 0xFF	; 255
     260:	98 0f       	add	r25, r24
     262:	9e 83       	std	Y+6, r25	; 0x06
     264:	81 11       	cpse	r24, r1
     266:	dc cf       	rjmp	.-72     	; 0x220 <RPI_sendTask+0x3a>
     268:	8a e0       	ldi	r24, 0x0A	; 10
     26a:	88 d7       	rcall	.+3856   	; 0x117c <myUSART_transmitUSART0_c>
     26c:	c2 cf       	rjmp	.-124    	; 0x1f2 <RPI_sendTask+0xc>

0000026e <myTimerTask>:
     26e:	b3 d5       	rcall	.+2918   	; 0xdd6 <myTimer_Init>
     270:	f2 d5       	rcall	.+3044   	; 0xe56 <myTimer_DelayChecker>
     272:	fe cf       	rjmp	.-4      	; 0x270 <myTimerTask+0x2>

00000274 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     274:	8f ef       	ldi	r24, 0xFF	; 255
     276:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     27a:	ef e7       	ldi	r30, 0x7F	; 127
     27c:	f0 e0       	ldi	r31, 0x00	; 0
     27e:	90 81       	ld	r25, Z
     280:	93 60       	ori	r25, 0x03	; 3
     282:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     284:	80 93 7d 00 	sts	0x007D, r24
     288:	08 95       	ret

0000028a <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     28a:	8c ec       	ldi	r24, 0xCC	; 204
     28c:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     290:	8e e3       	ldi	r24, 0x3E	; 62
     292:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     296:	ee cf       	rjmp	.-36     	; 0x274 <setDigitalInputPowerReduction>
     298:	08 95       	ret

0000029a <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     29a:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     29e:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2a2:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2a6:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2aa:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2ae:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2b2:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2b6:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2ba:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2be:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2c2:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2c6:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2ca:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2ce:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2d2:	10 92 73 00 	sts	0x0073, r1
     2d6:	08 95       	ret

000002d8 <init>:
}

void init()
{
     2d8:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2da:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2dc:	f8 94       	cli
	{
		clearTimer();
     2de:	dd df       	rcall	.-70     	; 0x29a <clearTimer>
		setPowerReduction();
     2e0:	d4 df       	rcall	.-88     	; 0x28a <setPowerReduction>
		myUSART_USART0_Init();
     2e2:	04 d7       	rcall	.+3592   	; 0x10ec <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2e4:	23 d7       	rcall	.+3654   	; 0x112c <myUSART_USART1_Init>
		myADC_Init();
     2e6:	b3 d3       	rcall	.+1894   	; 0xa4e <myADC_Init>
		
		MaxSonar_Init();
     2e8:	83 b3       	in	r24, 0x13	; 19
     2ea:	83 60       	ori	r24, 0x03	; 3
     2ec:	83 bb       	out	0x13, r24	; 19
		
		myHcSonar_Init();
     2ee:	f3 d2       	rcall	.+1510   	; 0x8d6 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2f0:	40 e0       	ldi	r20, 0x00	; 0
     2f2:	61 e0       	ldi	r22, 0x01	; 1
     2f4:	85 e0       	ldi	r24, 0x05	; 5
     2f6:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <xQueueGenericCreate>
     2fa:	90 93 92 08 	sts	0x0892, r25
     2fe:	80 93 91 08 	sts	0x0891, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     302:	40 e0       	ldi	r20, 0x00	; 0
     304:	65 e0       	ldi	r22, 0x05	; 5
     306:	84 e1       	ldi	r24, 0x14	; 20
     308:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <xQueueGenericCreate>
     30c:	90 93 94 08 	sts	0x0894, r25
     310:	80 93 93 08 	sts	0x0893, r24
		
		MOTOR_LEFT_INIT();
     314:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     316:	e1 e0       	ldi	r30, 0x01	; 1
     318:	f1 e0       	ldi	r31, 0x01	; 1
     31a:	80 81       	ld	r24, Z
     31c:	80 61       	ori	r24, 0x10	; 16
     31e:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     320:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     322:	78 94       	sei
}
     324:	cf 91       	pop	r28
     326:	08 95       	ret

00000328 <main>:
	
	// do nth
}

int main(void)
{
     328:	cf 93       	push	r28
     32a:	df 93       	push	r29
     32c:	cd b7       	in	r28, 0x3d	; 61
     32e:	de b7       	in	r29, 0x3e	; 62
     330:	28 97       	sbiw	r28, 0x08	; 8
     332:	0f b6       	in	r0, 0x3f	; 63
     334:	f8 94       	cli
     336:	de bf       	out	0x3e, r29	; 62
     338:	0f be       	out	0x3f, r0	; 63
     33a:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     33c:	cd df       	rcall	.-102    	; 0x2d8 <init>

		//xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     33e:	a1 2c       	mov	r10, r1
     340:	b1 2c       	mov	r11, r1
     342:	c1 2c       	mov	r12, r1
     344:	d1 2c       	mov	r13, r1
     346:	ce 01       	movw	r24, r28
     348:	01 96       	adiw	r24, 0x01	; 1
     34a:	7c 01       	movw	r14, r24
     34c:	04 e0       	ldi	r16, 0x04	; 4
     34e:	9c 01       	movw	r18, r24
     350:	49 e6       	ldi	r20, 0x69	; 105
     352:	50 e0       	ldi	r21, 0x00	; 0
     354:	62 e1       	ldi	r22, 0x12	; 18
     356:	72 e0       	ldi	r23, 0x02	; 2
     358:	87 e3       	ldi	r24, 0x37	; 55
     35a:	91 e0       	ldi	r25, 0x01	; 1
     35c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     360:	ce 01       	movw	r24, r28
     362:	07 96       	adiw	r24, 0x07	; 7
     364:	7c 01       	movw	r14, r24
     366:	02 e0       	ldi	r16, 0x02	; 2
     368:	20 e0       	ldi	r18, 0x00	; 0
     36a:	30 e0       	ldi	r19, 0x00	; 0
     36c:	4d e6       	ldi	r20, 0x6D	; 109
     36e:	51 e0       	ldi	r21, 0x01	; 1
     370:	6a e1       	ldi	r22, 0x1A	; 26
     372:	72 e0       	ldi	r23, 0x02	; 2
     374:	8d e6       	ldi	r24, 0x6D	; 109
     376:	92 e0       	ldi	r25, 0x02	; 2
     378:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     37c:	ce 01       	movw	r24, r28
     37e:	05 96       	adiw	r24, 0x05	; 5
     380:	7c 01       	movw	r14, r24
     382:	03 e0       	ldi	r16, 0x03	; 3
     384:	20 e0       	ldi	r18, 0x00	; 0
     386:	30 e0       	ldi	r19, 0x00	; 0
     388:	47 e8       	ldi	r20, 0x87	; 135
     38a:	50 e0       	ldi	r21, 0x00	; 0
     38c:	63 e2       	ldi	r22, 0x23	; 35
     38e:	72 e0       	ldi	r23, 0x02	; 2
     390:	84 ed       	ldi	r24, 0xD4	; 212
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     398:	ce 01       	movw	r24, r28
     39a:	03 96       	adiw	r24, 0x03	; 3
     39c:	7c 01       	movw	r14, r24
     39e:	01 e0       	ldi	r16, 0x01	; 1
     3a0:	20 e0       	ldi	r18, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
     3a4:	47 e8       	ldi	r20, 0x87	; 135
     3a6:	50 e0       	ldi	r21, 0x00	; 0
     3a8:	6f e2       	ldi	r22, 0x2F	; 47
     3aa:	72 e0       	ldi	r23, 0x02	; 2
     3ac:	83 ef       	ldi	r24, 0xF3	; 243
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3b4:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <vTaskStartScheduler>
     3b8:	c1 cf       	rjmp	.-126    	; 0x33c <main+0x14>

000003ba <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3ba:	9c 01       	movw	r18, r24
     3bc:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3be:	64 e6       	ldi	r22, 0x64	; 100
     3c0:	70 e0       	ldi	r23, 0x00	; 0
     3c2:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
	
	if(input)
     3c6:	61 15       	cp	r22, r1
     3c8:	71 05       	cpc	r23, r1
     3ca:	21 f0       	breq	.+8      	; 0x3d4 <myItoa+0x1a>
		*buffer++ = input + '0';
     3cc:	80 e3       	ldi	r24, 0x30	; 48
     3ce:	86 0f       	add	r24, r22
     3d0:	80 83       	st	Z, r24
     3d2:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     3d4:	4c e9       	ldi	r20, 0x9C	; 156
     3d6:	46 03       	mulsu	r20, r22
     3d8:	c0 01       	movw	r24, r0
     3da:	47 9f       	mul	r20, r23
     3dc:	90 0d       	add	r25, r0
     3de:	11 24       	eor	r1, r1
     3e0:	28 0f       	add	r18, r24
     3e2:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     3e4:	c9 01       	movw	r24, r18
     3e6:	6a e0       	ldi	r22, 0x0A	; 10
     3e8:	70 e0       	ldi	r23, 0x00	; 0
     3ea:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
	*buffer++ = input + '0';
     3ee:	80 e3       	ldi	r24, 0x30	; 48
     3f0:	86 0f       	add	r24, r22
     3f2:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     3f4:	8a e0       	ldi	r24, 0x0A	; 10
     3f6:	68 9f       	mul	r22, r24
     3f8:	20 19       	sub	r18, r0
     3fa:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     3fc:	20 5d       	subi	r18, 0xD0	; 208
     3fe:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     400:	12 82       	std	Z+2, r1	; 0x02
     402:	08 95       	ret

00000404 <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     404:	1f 93       	push	r17
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
     40a:	00 d0       	rcall	.+0      	; 0x40c <obstacleSend+0x8>
     40c:	1f 92       	push	r1
     40e:	1f 92       	push	r1
     410:	cd b7       	in	r28, 0x3d	; 61
     412:	de b7       	in	r29, 0x3e	; 62
     414:	18 2f       	mov	r17, r24
     416:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     418:	11 23       	and	r17, r17
     41a:	89 f0       	breq	.+34     	; 0x43e <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     41c:	be 01       	movw	r22, r28
     41e:	6e 5f       	subi	r22, 0xFE	; 254
     420:	7f 4f       	sbci	r23, 0xFF	; 255
     422:	cb df       	rcall	.-106    	; 0x3ba <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     424:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     426:	20 e0       	ldi	r18, 0x00	; 0
     428:	4f ef       	ldi	r20, 0xFF	; 255
     42a:	5f ef       	ldi	r21, 0xFF	; 255
     42c:	be 01       	movw	r22, r28
     42e:	6f 5f       	subi	r22, 0xFF	; 255
     430:	7f 4f       	sbci	r23, 0xFF	; 255
     432:	80 91 93 08 	lds	r24, 0x0893
     436:	90 91 94 08 	lds	r25, 0x0894
     43a:	0e 94 13 0c 	call	0x1826	; 0x1826 <xQueueGenericSend>
	}
}
     43e:	0f 90       	pop	r0
     440:	0f 90       	pop	r0
     442:	0f 90       	pop	r0
     444:	0f 90       	pop	r0
     446:	0f 90       	pop	r0
     448:	df 91       	pop	r29
     44a:	cf 91       	pop	r28
     44c:	1f 91       	pop	r17
     44e:	08 95       	ret

00000450 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     450:	6f 92       	push	r6
     452:	7f 92       	push	r7
     454:	8f 92       	push	r8
     456:	9f 92       	push	r9
     458:	af 92       	push	r10
     45a:	bf 92       	push	r11
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	ef 92       	push	r14
     462:	ff 92       	push	r15
     464:	0f 93       	push	r16
     466:	1f 93       	push	r17
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	1f 92       	push	r1
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
     472:	89 83       	std	Y+1, r24	; 0x01
     474:	5b 01       	movw	r10, r22
     476:	3a 01       	movw	r6, r20
     478:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     47a:	20 e0       	ldi	r18, 0x00	; 0
     47c:	4f ef       	ldi	r20, 0xFF	; 255
     47e:	5f ef       	ldi	r21, 0xFF	; 255
     480:	be 01       	movw	r22, r28
     482:	6f 5f       	subi	r22, 0xFF	; 255
     484:	7f 4f       	sbci	r23, 0xFF	; 255
     486:	80 91 91 08 	lds	r24, 0x0891
     48a:	90 91 92 08 	lds	r25, 0x0892
     48e:	0e 94 13 0c 	call	0x1826	; 0x1826 <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     492:	b3 01       	movw	r22, r6
     494:	f5 01       	movw	r30, r10
     496:	80 81       	ld	r24, Z
     498:	b5 df       	rcall	.-150    	; 0x404 <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     49a:	b4 01       	movw	r22, r8
     49c:	f5 01       	movw	r30, r10
     49e:	81 81       	ldd	r24, Z+1	; 0x01
     4a0:	b1 df       	rcall	.-158    	; 0x404 <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4a2:	b8 01       	movw	r22, r16
     4a4:	f5 01       	movw	r30, r10
     4a6:	82 81       	ldd	r24, Z+2	; 0x02
     4a8:	ad df       	rcall	.-166    	; 0x404 <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4aa:	b7 01       	movw	r22, r14
     4ac:	f5 01       	movw	r30, r10
     4ae:	83 81       	ldd	r24, Z+3	; 0x03
     4b0:	a9 df       	rcall	.-174    	; 0x404 <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4b2:	b6 01       	movw	r22, r12
     4b4:	f5 01       	movw	r30, r10
     4b6:	84 81       	ldd	r24, Z+4	; 0x04
     4b8:	a5 df       	rcall	.-182    	; 0x404 <obstacleSend>
		
	}
}
     4ba:	0f 90       	pop	r0
     4bc:	df 91       	pop	r29
     4be:	cf 91       	pop	r28
     4c0:	1f 91       	pop	r17
     4c2:	0f 91       	pop	r16
     4c4:	ff 90       	pop	r15
     4c6:	ef 90       	pop	r14
     4c8:	df 90       	pop	r13
     4ca:	cf 90       	pop	r12
     4cc:	bf 90       	pop	r11
     4ce:	af 90       	pop	r10
     4d0:	9f 90       	pop	r9
     4d2:	8f 90       	pop	r8
     4d4:	7f 90       	pop	r7
     4d6:	6f 90       	pop	r6
     4d8:	08 95       	ret

000004da <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
     4de:	cd b7       	in	r28, 0x3d	; 61
     4e0:	de b7       	in	r29, 0x3e	; 62
     4e2:	ac 97       	sbiw	r28, 0x2c	; 44
     4e4:	0f b6       	in	r0, 0x3f	; 63
     4e6:	f8 94       	cli
     4e8:	de bf       	out	0x3e, r29	; 62
     4ea:	0f be       	out	0x3f, r0	; 63
     4ec:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     4ee:	1b 82       	std	Y+3, r1	; 0x03
	int prevTopSonar = 0, prevFrontSonar = 0, prevLeftSonar = 0, prevRightSonar = 0;
     4f0:	1d 82       	std	Y+5, r1	; 0x05
     4f2:	1c 82       	std	Y+4, r1	; 0x04
     4f4:	1f 82       	std	Y+7, r1	; 0x07
     4f6:	1e 82       	std	Y+6, r1	; 0x06
     4f8:	19 86       	std	Y+9, r1	; 0x09
     4fa:	18 86       	std	Y+8, r1	; 0x08
     4fc:	1b 86       	std	Y+11, r1	; 0x0b
     4fe:	1a 86       	std	Y+10, r1	; 0x0a
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[3] = {999,999,999}, frontSonarSample[3] = {999,999,999}, leftSonarSample[3] = {999,999,999}, rightSonarSample[3] = {999,999,999};
     500:	86 e0       	ldi	r24, 0x06	; 6
     502:	e6 e0       	ldi	r30, 0x06	; 6
     504:	f2 e0       	ldi	r31, 0x02	; 2
     506:	de 01       	movw	r26, r28
     508:	1c 96       	adiw	r26, 0x0c	; 12
     50a:	01 90       	ld	r0, Z+
     50c:	0d 92       	st	X+, r0
     50e:	8a 95       	dec	r24
     510:	e1 f7       	brne	.-8      	; 0x50a <Sonar_Task+0x30>
     512:	86 e0       	ldi	r24, 0x06	; 6
     514:	e6 e0       	ldi	r30, 0x06	; 6
     516:	f2 e0       	ldi	r31, 0x02	; 2
     518:	de 01       	movw	r26, r28
     51a:	52 96       	adiw	r26, 0x12	; 18
     51c:	01 90       	ld	r0, Z+
     51e:	0d 92       	st	X+, r0
     520:	8a 95       	dec	r24
     522:	e1 f7       	brne	.-8      	; 0x51c <Sonar_Task+0x42>
     524:	86 e0       	ldi	r24, 0x06	; 6
     526:	e6 e0       	ldi	r30, 0x06	; 6
     528:	f2 e0       	ldi	r31, 0x02	; 2
     52a:	de 01       	movw	r26, r28
     52c:	58 96       	adiw	r26, 0x18	; 24
     52e:	01 90       	ld	r0, Z+
     530:	0d 92       	st	X+, r0
     532:	8a 95       	dec	r24
     534:	e1 f7       	brne	.-8      	; 0x52e <Sonar_Task+0x54>
     536:	86 e0       	ldi	r24, 0x06	; 6
     538:	e6 e0       	ldi	r30, 0x06	; 6
     53a:	f2 e0       	ldi	r31, 0x02	; 2
     53c:	de 01       	movw	r26, r28
     53e:	5e 96       	adiw	r26, 0x1e	; 30
     540:	01 90       	ld	r0, Z+
     542:	0d 92       	st	X+, r0
     544:	8a 95       	dec	r24
     546:	e1 f7       	brne	.-8      	; 0x540 <Sonar_Task+0x66>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     548:	fe 01       	movw	r30, r28
     54a:	b4 96       	adiw	r30, 0x24	; 36
     54c:	85 e0       	ldi	r24, 0x05	; 5
     54e:	df 01       	movw	r26, r30
     550:	1d 92       	st	X+, r1
     552:	8a 95       	dec	r24
     554:	e9 f7       	brne	.-6      	; 0x550 <Sonar_Task+0x76>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     556:	84 e2       	ldi	r24, 0x24	; 36
     558:	a1 d3       	rcall	.+1858   	; 0xc9c <mySharpIR_Read>
     55a:	9a a7       	std	Y+42, r25	; 0x2a
     55c:	89 a7       	std	Y+41, r24	; 0x29
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     55e:	0e 94 ec 0f 	call	0x1fd8	; 0x1fd8 <xTaskGetTickCount>
     562:	9a 83       	std	Y+2, r25	; 0x02
     564:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
		myMaxSonar_TopStart();
     566:	d2 d1       	rcall	.+932    	; 0x90c <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), &prevTopSonar, topSonarSample, 3);
     568:	83 e2       	ldi	r24, 0x23	; 35
     56a:	2f d2       	rcall	.+1118   	; 0x9ca <myMaxSonar_Read>
     56c:	23 e0       	ldi	r18, 0x03	; 3
     56e:	30 e0       	ldi	r19, 0x00	; 0
     570:	ae 01       	movw	r20, r28
     572:	44 5f       	subi	r20, 0xF4	; 244
     574:	5f 4f       	sbci	r21, 0xFF	; 255
     576:	be 01       	movw	r22, r28
     578:	6c 5f       	subi	r22, 0xFC	; 252
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	15 d2       	rcall	.+1066   	; 0x9a8 <myMaxSonar_getFilteredReading>
     57e:	9c a7       	std	Y+44, r25	; 0x2c
     580:	8b a7       	std	Y+43, r24	; 0x2b
		
		myMaxSonar_BtmStart();
     582:	be d1       	rcall	.+892    	; 0x900 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), &prevFrontSonar, frontSonarSample, 3);
     584:	87 e2       	ldi	r24, 0x27	; 39
     586:	21 d2       	rcall	.+1090   	; 0x9ca <myMaxSonar_Read>
     588:	23 e0       	ldi	r18, 0x03	; 3
     58a:	30 e0       	ldi	r19, 0x00	; 0
     58c:	ae 01       	movw	r20, r28
     58e:	4e 5e       	subi	r20, 0xEE	; 238
     590:	5f 4f       	sbci	r21, 0xFF	; 255
     592:	be 01       	movw	r22, r28
     594:	6a 5f       	subi	r22, 0xFA	; 250
     596:	7f 4f       	sbci	r23, 0xFF	; 255
     598:	07 d2       	rcall	.+1038   	; 0x9a8 <myMaxSonar_getFilteredReading>
     59a:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), &prevLeftSonar, leftSonarSample, 3);
     59c:	86 e2       	ldi	r24, 0x26	; 38
     59e:	15 d2       	rcall	.+1066   	; 0x9ca <myMaxSonar_Read>
     5a0:	23 e0       	ldi	r18, 0x03	; 3
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	ae 01       	movw	r20, r28
     5a6:	48 5e       	subi	r20, 0xE8	; 232
     5a8:	5f 4f       	sbci	r21, 0xFF	; 255
     5aa:	be 01       	movw	r22, r28
     5ac:	68 5f       	subi	r22, 0xF8	; 248
     5ae:	7f 4f       	sbci	r23, 0xFF	; 255
     5b0:	fb d1       	rcall	.+1014   	; 0x9a8 <myMaxSonar_getFilteredReading>
     5b2:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), &prevRightSonar, rightSonarSample, 3); 
     5b4:	85 e2       	ldi	r24, 0x25	; 37
     5b6:	09 d2       	rcall	.+1042   	; 0x9ca <myMaxSonar_Read>
     5b8:	23 e0       	ldi	r18, 0x03	; 3
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	ae 01       	movw	r20, r28
     5be:	42 5e       	subi	r20, 0xE2	; 226
     5c0:	5f 4f       	sbci	r21, 0xFF	; 255
     5c2:	be 01       	movw	r22, r28
     5c4:	66 5f       	subi	r22, 0xF6	; 246
     5c6:	7f 4f       	sbci	r23, 0xFF	; 255
     5c8:	ef d1       	rcall	.+990    	; 0x9a8 <myMaxSonar_getFilteredReading>
     5ca:	2c 01       	movw	r4, r24
		
		btmIR		= mySharpIR_Read(AN12);	
     5cc:	84 e2       	ldi	r24, 0x24	; 36
     5ce:	66 d3       	rcall	.+1740   	; 0xc9c <mySharpIR_Read>
     5d0:	4c 01       	movw	r8, r24
		//frontSonar = myMaxSonar_Stabilizer(frontSonar, &prevFrontSonar);
		//leftSonar = myMaxSonar_Stabilizer(leftSonar, &prevLeftSonar);
		//rightSonar = myMaxSonar_Stabilizer(rightSonar, &prevRightSonar);
		
		
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5d2:	bc 01       	movw	r22, r24
     5d4:	ce 01       	movw	r24, r28
     5d6:	89 96       	adiw	r24, 0x29	; 41
     5d8:	9a d3       	rcall	.+1844   	; 0xd0e <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5da:	c9 a4       	ldd	r12, Y+41	; 0x29
     5dc:	da a4       	ldd	r13, Y+42	; 0x2a
     5de:	54 01       	movw	r10, r8
     5e0:	eb a4       	ldd	r14, Y+43	; 0x2b
     5e2:	fc a4       	ldd	r15, Y+44	; 0x2c
     5e4:	82 01       	movw	r16, r4
     5e6:	91 01       	movw	r18, r2
     5e8:	ae 01       	movw	r20, r28
     5ea:	4c 5d       	subi	r20, 0xDC	; 220
     5ec:	5f 4f       	sbci	r21, 0xFF	; 255
     5ee:	6b 81       	ldd	r22, Y+3	; 0x03
     5f0:	c3 01       	movw	r24, r6
     5f2:	24 d3       	rcall	.+1608   	; 0xc3c <obstacleDetection>
     5f4:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5f6:	8e 01       	movw	r16, r28
     5f8:	0c 5d       	subi	r16, 0xDC	; 220
     5fa:	1f 4f       	sbci	r17, 0xFF	; 255
     5fc:	94 01       	movw	r18, r8
     5fe:	a2 01       	movw	r20, r4
     600:	b1 01       	movw	r22, r2
     602:	c3 01       	movw	r24, r6
     604:	a5 d2       	rcall	.+1354   	; 0xb50 <obstacleAvoidance>
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     606:	be 01       	movw	r22, r28
     608:	6d 5f       	subi	r22, 0xFD	; 253
     60a:	7f 4f       	sbci	r23, 0xFF	; 255
     60c:	c8 01       	movw	r24, r16
     60e:	07 d3       	rcall	.+1550   	; 0xc1e <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     610:	cb a4       	ldd	r12, Y+43	; 0x2b
     612:	dc a4       	ldd	r13, Y+44	; 0x2c
     614:	74 01       	movw	r14, r8
     616:	82 01       	movw	r16, r4
     618:	91 01       	movw	r18, r2
     61a:	a3 01       	movw	r20, r6
     61c:	be 01       	movw	r22, r28
     61e:	6c 5d       	subi	r22, 0xDC	; 220
     620:	7f 4f       	sbci	r23, 0xFF	; 255
     622:	8b 81       	ldd	r24, Y+3	; 0x03
     624:	15 df       	rcall	.-470    	; 0x450 <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     626:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     628:	18 a6       	std	Y+40, r1	; 0x28
     62a:	1f a2       	std	Y+39, r1	; 0x27
     62c:	1e a2       	std	Y+38, r1	; 0x26
     62e:	1d a2       	std	Y+37, r1	; 0x25
     630:	1c a2       	std	Y+36, r1	; 0x24
		
		vTaskDelayUntil( &xLastWakeTime, 150);  // delay 150 ms for 3 sonar chain...
     632:	66 e9       	ldi	r22, 0x96	; 150
     634:	70 e0       	ldi	r23, 0x00	; 0
     636:	ce 01       	movw	r24, r28
     638:	01 96       	adiw	r24, 0x01	; 1
     63a:	0e 94 3a 11 	call	0x2274	; 0x2274 <vTaskDelayUntil>
     63e:	93 cf       	rjmp	.-218    	; 0x566 <Sonar_Task+0x8c>

00000640 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     640:	cf 93       	push	r28
     642:	df 93       	push	r29
     644:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     646:	0e 94 e6 0f 	call	0x1fcc	; 0x1fcc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     64a:	80 91 3e 02 	lds	r24, 0x023E
     64e:	90 91 3f 02 	lds	r25, 0x023F
     652:	89 2b       	or	r24, r25
     654:	31 f4       	brne	.+12     	; 0x662 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     656:	83 e4       	ldi	r24, 0x43	; 67
     658:	92 e0       	ldi	r25, 0x02	; 2
     65a:	90 93 3f 02 	sts	0x023F, r25
     65e:	80 93 3e 02 	sts	0x023E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     662:	40 91 40 02 	lds	r20, 0x0240
     666:	50 91 41 02 	lds	r21, 0x0241
     66a:	9e 01       	movw	r18, r28
     66c:	24 0f       	add	r18, r20
     66e:	35 1f       	adc	r19, r21
     670:	2b 3d       	cpi	r18, 0xDB	; 219
     672:	85 e0       	ldi	r24, 0x05	; 5
     674:	38 07       	cpc	r19, r24
     676:	70 f4       	brcc	.+28     	; 0x694 <pvPortMalloc+0x54>
     678:	42 17       	cp	r20, r18
     67a:	53 07       	cpc	r21, r19
     67c:	70 f4       	brcc	.+28     	; 0x69a <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     67e:	c0 91 3e 02 	lds	r28, 0x023E
     682:	d0 91 3f 02 	lds	r29, 0x023F
     686:	c4 0f       	add	r28, r20
     688:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     68a:	30 93 41 02 	sts	0x0241, r19
     68e:	20 93 40 02 	sts	0x0240, r18
     692:	05 c0       	rjmp	.+10     	; 0x69e <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     694:	c0 e0       	ldi	r28, 0x00	; 0
     696:	d0 e0       	ldi	r29, 0x00	; 0
     698:	02 c0       	rjmp	.+4      	; 0x69e <pvPortMalloc+0x5e>
     69a:	c0 e0       	ldi	r28, 0x00	; 0
     69c:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     69e:	0e 94 b9 10 	call	0x2172	; 0x2172 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6a2:	ce 01       	movw	r24, r28
     6a4:	df 91       	pop	r29
     6a6:	cf 91       	pop	r28
     6a8:	08 95       	ret

000006aa <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6aa:	08 95       	ret

000006ac <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6ac:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ae:	03 96       	adiw	r24, 0x03	; 3
     6b0:	92 83       	std	Z+2, r25	; 0x02
     6b2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6b4:	2f ef       	ldi	r18, 0xFF	; 255
     6b6:	3f ef       	ldi	r19, 0xFF	; 255
     6b8:	34 83       	std	Z+4, r19	; 0x04
     6ba:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6bc:	96 83       	std	Z+6, r25	; 0x06
     6be:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6c0:	90 87       	std	Z+8, r25	; 0x08
     6c2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6c4:	10 82       	st	Z, r1
     6c6:	08 95       	ret

000006c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6c8:	fc 01       	movw	r30, r24
     6ca:	11 86       	std	Z+9, r1	; 0x09
     6cc:	10 86       	std	Z+8, r1	; 0x08
     6ce:	08 95       	ret

000006d0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6d0:	cf 93       	push	r28
     6d2:	df 93       	push	r29
     6d4:	9c 01       	movw	r18, r24
     6d6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6d8:	dc 01       	movw	r26, r24
     6da:	11 96       	adiw	r26, 0x01	; 1
     6dc:	cd 91       	ld	r28, X+
     6de:	dc 91       	ld	r29, X
     6e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6e2:	d3 83       	std	Z+3, r29	; 0x03
     6e4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6e6:	8c 81       	ldd	r24, Y+4	; 0x04
     6e8:	9d 81       	ldd	r25, Y+5	; 0x05
     6ea:	95 83       	std	Z+5, r25	; 0x05
     6ec:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6ee:	8c 81       	ldd	r24, Y+4	; 0x04
     6f0:	9d 81       	ldd	r25, Y+5	; 0x05
     6f2:	dc 01       	movw	r26, r24
     6f4:	13 96       	adiw	r26, 0x03	; 3
     6f6:	7c 93       	st	X, r23
     6f8:	6e 93       	st	-X, r22
     6fa:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6fc:	7d 83       	std	Y+5, r23	; 0x05
     6fe:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     700:	31 87       	std	Z+9, r19	; 0x09
     702:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     704:	f9 01       	movw	r30, r18
     706:	80 81       	ld	r24, Z
     708:	8f 5f       	subi	r24, 0xFF	; 255
     70a:	80 83       	st	Z, r24
}
     70c:	df 91       	pop	r29
     70e:	cf 91       	pop	r28
     710:	08 95       	ret

00000712 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     712:	cf 93       	push	r28
     714:	df 93       	push	r29
     716:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     718:	48 81       	ld	r20, Y
     71a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     71c:	4f 3f       	cpi	r20, 0xFF	; 255
     71e:	2f ef       	ldi	r18, 0xFF	; 255
     720:	52 07       	cpc	r21, r18
     722:	21 f4       	brne	.+8      	; 0x72c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     724:	fc 01       	movw	r30, r24
     726:	a7 81       	ldd	r26, Z+7	; 0x07
     728:	b0 85       	ldd	r27, Z+8	; 0x08
     72a:	0d c0       	rjmp	.+26     	; 0x746 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     72c:	dc 01       	movw	r26, r24
     72e:	13 96       	adiw	r26, 0x03	; 3
     730:	12 96       	adiw	r26, 0x02	; 2
     732:	ed 91       	ld	r30, X+
     734:	fc 91       	ld	r31, X
     736:	13 97       	sbiw	r26, 0x03	; 3
     738:	20 81       	ld	r18, Z
     73a:	31 81       	ldd	r19, Z+1	; 0x01
     73c:	42 17       	cp	r20, r18
     73e:	53 07       	cpc	r21, r19
     740:	10 f0       	brcs	.+4      	; 0x746 <vListInsert+0x34>
     742:	df 01       	movw	r26, r30
     744:	f5 cf       	rjmp	.-22     	; 0x730 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     746:	12 96       	adiw	r26, 0x02	; 2
     748:	ed 91       	ld	r30, X+
     74a:	fc 91       	ld	r31, X
     74c:	13 97       	sbiw	r26, 0x03	; 3
     74e:	fb 83       	std	Y+3, r31	; 0x03
     750:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     752:	d5 83       	std	Z+5, r29	; 0x05
     754:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     756:	bd 83       	std	Y+5, r27	; 0x05
     758:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     75a:	13 96       	adiw	r26, 0x03	; 3
     75c:	dc 93       	st	X, r29
     75e:	ce 93       	st	-X, r28
     760:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     762:	99 87       	std	Y+9, r25	; 0x09
     764:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     766:	fc 01       	movw	r30, r24
     768:	20 81       	ld	r18, Z
     76a:	2f 5f       	subi	r18, 0xFF	; 255
     76c:	20 83       	st	Z, r18
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	08 95       	ret

00000774 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     77a:	a0 85       	ldd	r26, Z+8	; 0x08
     77c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     77e:	c2 81       	ldd	r28, Z+2	; 0x02
     780:	d3 81       	ldd	r29, Z+3	; 0x03
     782:	84 81       	ldd	r24, Z+4	; 0x04
     784:	95 81       	ldd	r25, Z+5	; 0x05
     786:	9d 83       	std	Y+5, r25	; 0x05
     788:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     78a:	c4 81       	ldd	r28, Z+4	; 0x04
     78c:	d5 81       	ldd	r29, Z+5	; 0x05
     78e:	82 81       	ldd	r24, Z+2	; 0x02
     790:	93 81       	ldd	r25, Z+3	; 0x03
     792:	9b 83       	std	Y+3, r25	; 0x03
     794:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     796:	11 96       	adiw	r26, 0x01	; 1
     798:	cd 91       	ld	r28, X+
     79a:	dc 91       	ld	r29, X
     79c:	12 97       	sbiw	r26, 0x02	; 2
     79e:	ce 17       	cp	r28, r30
     7a0:	df 07       	cpc	r29, r31
     7a2:	31 f4       	brne	.+12     	; 0x7b0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7a4:	8c 81       	ldd	r24, Y+4	; 0x04
     7a6:	9d 81       	ldd	r25, Y+5	; 0x05
     7a8:	12 96       	adiw	r26, 0x02	; 2
     7aa:	9c 93       	st	X, r25
     7ac:	8e 93       	st	-X, r24
     7ae:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7b0:	11 86       	std	Z+9, r1	; 0x09
     7b2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7b4:	8c 91       	ld	r24, X
     7b6:	81 50       	subi	r24, 0x01	; 1
     7b8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	08 95       	ret

000007c0 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7c0:	1f 92       	push	r1
     7c2:	0f 92       	push	r0
     7c4:	0f b6       	in	r0, 0x3f	; 63
     7c6:	0f 92       	push	r0
     7c8:	11 24       	eor	r1, r1
     7ca:	0b b6       	in	r0, 0x3b	; 59
     7cc:	0f 92       	push	r0
     7ce:	2f 93       	push	r18
     7d0:	3f 93       	push	r19
     7d2:	4f 93       	push	r20
     7d4:	5f 93       	push	r21
     7d6:	6f 93       	push	r22
     7d8:	7f 93       	push	r23
     7da:	8f 93       	push	r24
     7dc:	9f 93       	push	r25
     7de:	af 93       	push	r26
     7e0:	bf 93       	push	r27
     7e2:	ef 93       	push	r30
     7e4:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7e6:	1b 9b       	sbis	0x03, 3	; 3
     7e8:	0d c0       	rjmp	.+26     	; 0x804 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7ea:	0f d3       	rcall	.+1566   	; 0xe0a <myTimer_Read>
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	90 93 9a 08 	sts	0x089A, r25
     7f2:	80 93 99 08 	sts	0x0899, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7f6:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <xTaskGetTickCountFromISR>
     7fa:	90 93 96 08 	sts	0x0896, r25
     7fe:	80 93 95 08 	sts	0x0895, r24
     802:	56 c0       	rjmp	.+172    	; 0x8b0 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     804:	1b 99       	sbic	0x03, 3	; 3
     806:	54 c0       	rjmp	.+168    	; 0x8b0 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     808:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <xTaskGetTickCountFromISR>
     80c:	90 93 a0 08 	sts	0x08A0, r25
     810:	80 93 9f 08 	sts	0x089F, r24
     814:	20 91 95 08 	lds	r18, 0x0895
     818:	30 91 96 08 	lds	r19, 0x0896
     81c:	82 17       	cp	r24, r18
     81e:	93 07       	cpc	r25, r19
     820:	4c f4       	brge	.+18     	; 0x834 <__vector_9+0x74>
			ms_tickEnd += 65535;
     822:	80 91 9f 08 	lds	r24, 0x089F
     826:	90 91 a0 08 	lds	r25, 0x08A0
     82a:	01 97       	sbiw	r24, 0x01	; 1
     82c:	90 93 a0 08 	sts	0x08A0, r25
     830:	80 93 9f 08 	sts	0x089F, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     834:	ea d2       	rcall	.+1492   	; 0xe0a <myTimer_Read>
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	90 93 a2 08 	sts	0x08A2, r25
     83c:	80 93 a1 08 	sts	0x08A1, r24
     840:	20 91 99 08 	lds	r18, 0x0899
     844:	30 91 9a 08 	lds	r19, 0x089A
     848:	82 17       	cp	r24, r18
     84a:	93 07       	cpc	r25, r19
     84c:	54 f4       	brge	.+20     	; 0x862 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     84e:	80 91 a1 08 	lds	r24, 0x08A1
     852:	90 91 a2 08 	lds	r25, 0x08A2
     856:	86 50       	subi	r24, 0x06	; 6
     858:	9f 4f       	sbci	r25, 0xFF	; 255
     85a:	90 93 a2 08 	sts	0x08A2, r25
     85e:	80 93 a1 08 	sts	0x08A1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     862:	80 91 a1 08 	lds	r24, 0x08A1
     866:	90 91 a2 08 	lds	r25, 0x08A2
     86a:	20 91 99 08 	lds	r18, 0x0899
     86e:	30 91 9a 08 	lds	r19, 0x089A
     872:	82 1b       	sub	r24, r18
     874:	93 0b       	sbc	r25, r19
     876:	90 93 9c 08 	sts	0x089C, r25
     87a:	80 93 9b 08 	sts	0x089B, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     87e:	80 91 9f 08 	lds	r24, 0x089F
     882:	90 91 a0 08 	lds	r25, 0x08A0
     886:	20 91 95 08 	lds	r18, 0x0895
     88a:	30 91 96 08 	lds	r19, 0x0896
     88e:	82 1b       	sub	r24, r18
     890:	93 0b       	sbc	r25, r19
     892:	90 93 98 08 	sts	0x0898, r25
     896:	80 93 97 08 	sts	0x0897, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     89a:	20 e0       	ldi	r18, 0x00	; 0
     89c:	40 e0       	ldi	r20, 0x00	; 0
     89e:	50 e0       	ldi	r21, 0x00	; 0
     8a0:	60 e0       	ldi	r22, 0x00	; 0
     8a2:	70 e0       	ldi	r23, 0x00	; 0
     8a4:	80 91 9d 08 	lds	r24, 0x089D
     8a8:	90 91 9e 08 	lds	r25, 0x089E
     8ac:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <xQueueGenericSendFromISR>
	}	
}
     8b0:	ff 91       	pop	r31
     8b2:	ef 91       	pop	r30
     8b4:	bf 91       	pop	r27
     8b6:	af 91       	pop	r26
     8b8:	9f 91       	pop	r25
     8ba:	8f 91       	pop	r24
     8bc:	7f 91       	pop	r23
     8be:	6f 91       	pop	r22
     8c0:	5f 91       	pop	r21
     8c2:	4f 91       	pop	r20
     8c4:	3f 91       	pop	r19
     8c6:	2f 91       	pop	r18
     8c8:	0f 90       	pop	r0
     8ca:	0b be       	out	0x3b, r0	; 59
     8cc:	0f 90       	pop	r0
     8ce:	0f be       	out	0x3f, r0	; 63
     8d0:	0f 90       	pop	r0
     8d2:	1f 90       	pop	r1
     8d4:	18 95       	reti

000008d6 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     8d6:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     8d8:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     8da:	e8 e6       	ldi	r30, 0x68	; 104
     8dc:	f0 e0       	ldi	r31, 0x00	; 0
     8de:	80 81       	ld	r24, Z
     8e0:	81 60       	ori	r24, 0x01	; 1
     8e2:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     8e4:	eb e6       	ldi	r30, 0x6B	; 107
     8e6:	f0 e0       	ldi	r31, 0x00	; 0
     8e8:	80 81       	ld	r24, Z
     8ea:	88 60       	ori	r24, 0x08	; 8
     8ec:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     8ee:	43 e0       	ldi	r20, 0x03	; 3
     8f0:	60 e0       	ldi	r22, 0x00	; 0
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	6b d7       	rcall	.+3798   	; 0x17cc <xQueueGenericCreate>
     8f6:	90 93 9e 08 	sts	0x089E, r25
     8fa:	80 93 9d 08 	sts	0x089D, r24
     8fe:	08 95       	ret

00000900 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     900:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     902:	89 e1       	ldi	r24, 0x19	; 25
     904:	90 e0       	ldi	r25, 0x00	; 0
     906:	83 d2       	rcall	.+1286   	; 0xe0e <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     908:	a1 98       	cbi	0x14, 1	; 20
     90a:	08 95       	ret

0000090c <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     90c:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     90e:	89 e1       	ldi	r24, 0x19	; 25
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	7d d2       	rcall	.+1274   	; 0xe0e <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     914:	a0 98       	cbi	0x14, 0	; 20
     916:	08 95       	ret

00000918 <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     918:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     91a:	80 81       	ld	r24, Z
     91c:	91 81       	ldd	r25, Z+1	; 0x01
     91e:	22 81       	ldd	r18, Z+2	; 0x02
     920:	33 81       	ldd	r19, Z+3	; 0x03
     922:	28 17       	cp	r18, r24
     924:	39 07       	cpc	r19, r25
     926:	54 f4       	brge	.+20     	; 0x93c <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     928:	44 81       	ldd	r20, Z+4	; 0x04
     92a:	55 81       	ldd	r21, Z+5	; 0x05
     92c:	42 17       	cp	r20, r18
     92e:	53 07       	cpc	r21, r19
     930:	84 f0       	brlt	.+32     	; 0x952 <myMaxSonar_extractMedian+0x3a>
     932:	48 17       	cp	r20, r24
     934:	59 07       	cpc	r21, r25
     936:	74 f4       	brge	.+28     	; 0x954 <myMaxSonar_extractMedian+0x3c>
     938:	ca 01       	movw	r24, r20
     93a:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     93c:	44 81       	ldd	r20, Z+4	; 0x04
     93e:	55 81       	ldd	r21, Z+5	; 0x05
     940:	48 17       	cp	r20, r24
     942:	59 07       	cpc	r21, r25
     944:	3c f0       	brlt	.+14     	; 0x954 <myMaxSonar_extractMedian+0x3c>
     946:	ca 01       	movw	r24, r20
     948:	24 17       	cp	r18, r20
     94a:	35 07       	cpc	r19, r21
     94c:	1c f4       	brge	.+6      	; 0x954 <myMaxSonar_extractMedian+0x3c>
     94e:	c9 01       	movw	r24, r18
     950:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     952:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     954:	08 95       	ret

00000956 <myMaxSonar_AddSample>:
// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample, int sampleSize)
{
	static int i = 0; 
	
	sample[i] = currentReading;
     956:	20 91 1e 08 	lds	r18, 0x081E
     95a:	30 91 1f 08 	lds	r19, 0x081F
     95e:	f9 01       	movw	r30, r18
     960:	ee 0f       	add	r30, r30
     962:	ff 1f       	adc	r31, r31
     964:	e6 0f       	add	r30, r22
     966:	f7 1f       	adc	r31, r23
     968:	91 83       	std	Z+1, r25	; 0x01
     96a:	80 83       	st	Z, r24
	i = (i+1) % sampleSize;
     96c:	c9 01       	movw	r24, r18
     96e:	01 96       	adiw	r24, 0x01	; 1
     970:	ba 01       	movw	r22, r20
     972:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
     976:	90 93 1f 08 	sts	0x081F, r25
     97a:	80 93 1e 08 	sts	0x081E, r24
     97e:	08 95       	ret

00000980 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int* prevReading)
{
     980:	9c 01       	movw	r18, r24
	if(currentReading > (*prevReading + NOISE_RANGE) || currentReading < (*prevReading - NOISE_RANGE))
     982:	fb 01       	movw	r30, r22
     984:	80 81       	ld	r24, Z
     986:	91 81       	ldd	r25, Z+1	; 0x01
     988:	ac 01       	movw	r20, r24
     98a:	48 5f       	subi	r20, 0xF8	; 248
     98c:	5f 4f       	sbci	r21, 0xFF	; 255
     98e:	42 17       	cp	r20, r18
     990:	53 07       	cpc	r21, r19
     992:	2c f0       	brlt	.+10     	; 0x99e <myMaxSonar_Stabilizer+0x1e>
     994:	40 51       	subi	r20, 0x10	; 16
     996:	51 09       	sbc	r21, r1
     998:	24 17       	cp	r18, r20
     99a:	35 07       	cpc	r19, r21
     99c:	24 f4       	brge	.+8      	; 0x9a6 <myMaxSonar_Stabilizer+0x26>
	{
		*prevReading = currentReading;
     99e:	fb 01       	movw	r30, r22
     9a0:	31 83       	std	Z+1, r19	; 0x01
     9a2:	20 83       	st	Z, r18
		return currentReading; // when current reading exceed noise range.... return current reading
     9a4:	c9 01       	movw	r24, r18
	}
	else
		return *prevReading; // return prevReading if in noise range..
}
     9a6:	08 95       	ret

000009a8 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int* prevReading, int *sample, int sampleSize)
{
     9a8:	0f 93       	push	r16
     9aa:	1f 93       	push	r17
     9ac:	cf 93       	push	r28
     9ae:	df 93       	push	r29
     9b0:	ea 01       	movw	r28, r20
     9b2:	89 01       	movw	r16, r18
	currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
     9b4:	e5 df       	rcall	.-54     	; 0x980 <myMaxSonar_Stabilizer>
	myMaxSonar_AddSample(currentReading, sample, sampleSize);
     9b6:	a8 01       	movw	r20, r16
     9b8:	be 01       	movw	r22, r28
     9ba:	cd df       	rcall	.-102    	; 0x956 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     9bc:	ce 01       	movw	r24, r28
     9be:	ac df       	rcall	.-168    	; 0x918 <myMaxSonar_extractMedian>

}
     9c0:	df 91       	pop	r29
     9c2:	cf 91       	pop	r28
     9c4:	1f 91       	pop	r17
     9c6:	0f 91       	pop	r16
     9c8:	08 95       	ret

000009ca <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     9ca:	ab d0       	rcall	.+342    	; 0xb22 <myADC_analogRead>
     9cc:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     9ce:	63 e0       	ldi	r22, 0x03	; 3
     9d0:	70 e0       	ldi	r23, 0x00	; 0
     9d2:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     9d6:	cb 01       	movw	r24, r22
     9d8:	82 0f       	add	r24, r18
     9da:	93 1f       	adc	r25, r19
     9dc:	08 95       	ret

000009de <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9de:	1f 92       	push	r1
     9e0:	0f 92       	push	r0
     9e2:	0f b6       	in	r0, 0x3f	; 63
     9e4:	0f 92       	push	r0
     9e6:	11 24       	eor	r1, r1
     9e8:	0b b6       	in	r0, 0x3b	; 59
     9ea:	0f 92       	push	r0
     9ec:	2f 93       	push	r18
     9ee:	3f 93       	push	r19
     9f0:	4f 93       	push	r20
     9f2:	5f 93       	push	r21
     9f4:	6f 93       	push	r22
     9f6:	7f 93       	push	r23
     9f8:	8f 93       	push	r24
     9fa:	9f 93       	push	r25
     9fc:	af 93       	push	r26
     9fe:	bf 93       	push	r27
     a00:	ef 93       	push	r30
     a02:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     a04:	80 91 78 00 	lds	r24, 0x0078
     a08:	80 93 a3 08 	sts	0x08A3, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     a0c:	80 91 79 00 	lds	r24, 0x0079
     a10:	80 93 a4 08 	sts	0x08A4, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     a14:	20 e0       	ldi	r18, 0x00	; 0
     a16:	40 e0       	ldi	r20, 0x00	; 0
     a18:	50 e0       	ldi	r21, 0x00	; 0
     a1a:	60 e0       	ldi	r22, 0x00	; 0
     a1c:	70 e0       	ldi	r23, 0x00	; 0
     a1e:	80 91 a7 08 	lds	r24, 0x08A7
     a22:	90 91 a8 08 	lds	r25, 0x08A8
     a26:	bd d7       	rcall	.+3962   	; 0x19a2 <xQueueGenericSendFromISR>
}
     a28:	ff 91       	pop	r31
     a2a:	ef 91       	pop	r30
     a2c:	bf 91       	pop	r27
     a2e:	af 91       	pop	r26
     a30:	9f 91       	pop	r25
     a32:	8f 91       	pop	r24
     a34:	7f 91       	pop	r23
     a36:	6f 91       	pop	r22
     a38:	5f 91       	pop	r21
     a3a:	4f 91       	pop	r20
     a3c:	3f 91       	pop	r19
     a3e:	2f 91       	pop	r18
     a40:	0f 90       	pop	r0
     a42:	0b be       	out	0x3b, r0	; 59
     a44:	0f 90       	pop	r0
     a46:	0f be       	out	0x3f, r0	; 63
     a48:	0f 90       	pop	r0
     a4a:	1f 90       	pop	r1
     a4c:	18 95       	reti

00000a4e <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a4e:	8f e8       	ldi	r24, 0x8F	; 143
     a50:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a54:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a58:	80 e4       	ldi	r24, 0x40	; 64
     a5a:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a5e:	43 e0       	ldi	r20, 0x03	; 3
     a60:	60 e0       	ldi	r22, 0x00	; 0
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	b3 d6       	rcall	.+3430   	; 0x17cc <xQueueGenericCreate>
     a66:	90 93 a8 08 	sts	0x08A8, r25
     a6a:	80 93 a7 08 	sts	0x08A7, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	6d d7       	rcall	.+3802   	; 0x194c <xQueueCreateMutex>
     a72:	90 93 a6 08 	sts	0x08A6, r25
     a76:	80 93 a5 08 	sts	0x08A5, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a7a:	20 e0       	ldi	r18, 0x00	; 0
     a7c:	40 e0       	ldi	r20, 0x00	; 0
     a7e:	50 e0       	ldi	r21, 0x00	; 0
     a80:	60 e0       	ldi	r22, 0x00	; 0
     a82:	70 e0       	ldi	r23, 0x00	; 0
     a84:	d0 c6       	rjmp	.+3488   	; 0x1826 <xQueueGenericSend>
     a86:	08 95       	ret

00000a88 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a88:	cf 93       	push	r28
     a8a:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a8c:	20 e0       	ldi	r18, 0x00	; 0
     a8e:	4f ef       	ldi	r20, 0xFF	; 255
     a90:	5f ef       	ldi	r21, 0xFF	; 255
     a92:	60 e0       	ldi	r22, 0x00	; 0
     a94:	70 e0       	ldi	r23, 0x00	; 0
     a96:	80 91 a5 08 	lds	r24, 0x08A5
     a9a:	90 91 a6 08 	lds	r25, 0x08A6
     a9e:	bb d7       	rcall	.+3958   	; 0x1a16 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     aa0:	ec e7       	ldi	r30, 0x7C	; 124
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	80 81       	ld	r24, Z
     aa6:	9c 2f       	mov	r25, r28
     aa8:	9f 71       	andi	r25, 0x1F	; 31
     aaa:	80 76       	andi	r24, 0x60	; 96
     aac:	89 2b       	or	r24, r25
     aae:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     ab0:	eb e7       	ldi	r30, 0x7B	; 123
     ab2:	f0 e0       	ldi	r31, 0x00	; 0
     ab4:	20 81       	ld	r18, Z
     ab6:	c0 72       	andi	r28, 0x20	; 32
     ab8:	8c 2f       	mov	r24, r28
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	95 95       	asr	r25
     abe:	87 95       	ror	r24
     ac0:	95 95       	asr	r25
     ac2:	87 95       	ror	r24
     ac4:	92 2f       	mov	r25, r18
     ac6:	90 76       	andi	r25, 0x60	; 96
     ac8:	89 2b       	or	r24, r25
     aca:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     acc:	ea e7       	ldi	r30, 0x7A	; 122
     ace:	f0 e0       	ldi	r31, 0x00	; 0
     ad0:	80 81       	ld	r24, Z
     ad2:	80 64       	ori	r24, 0x40	; 64
     ad4:	80 83       	st	Z, r24
}
     ad6:	cf 91       	pop	r28
     ad8:	08 95       	ret

00000ada <myADC_readADC>:

int myADC_readADC(char channel)
{
     ada:	cf 93       	push	r28
     adc:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ade:	20 e0       	ldi	r18, 0x00	; 0
     ae0:	4f ef       	ldi	r20, 0xFF	; 255
     ae2:	5f ef       	ldi	r21, 0xFF	; 255
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	70 e0       	ldi	r23, 0x00	; 0
     ae8:	80 91 a7 08 	lds	r24, 0x08A7
     aec:	90 91 a8 08 	lds	r25, 0x08A8
     af0:	92 d7       	rcall	.+3876   	; 0x1a16 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     af2:	c0 91 a4 08 	lds	r28, 0x08A4
     af6:	c3 70       	andi	r28, 0x03	; 3
     af8:	d0 e0       	ldi	r29, 0x00	; 0
     afa:	dc 2f       	mov	r29, r28
     afc:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     afe:	80 91 a3 08 	lds	r24, 0x08A3
     b02:	c8 0f       	add	r28, r24
     b04:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     b06:	20 e0       	ldi	r18, 0x00	; 0
     b08:	40 e0       	ldi	r20, 0x00	; 0
     b0a:	50 e0       	ldi	r21, 0x00	; 0
     b0c:	60 e0       	ldi	r22, 0x00	; 0
     b0e:	70 e0       	ldi	r23, 0x00	; 0
     b10:	80 91 a5 08 	lds	r24, 0x08A5
     b14:	90 91 a6 08 	lds	r25, 0x08A6
     b18:	86 d6       	rcall	.+3340   	; 0x1826 <xQueueGenericSend>
	
	return adcReading;
     b1a:	ce 01       	movw	r24, r28
     b1c:	df 91       	pop	r29
     b1e:	cf 91       	pop	r28
     b20:	08 95       	ret

00000b22 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     b22:	cf 93       	push	r28
     b24:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b26:	b0 df       	rcall	.-160    	; 0xa88 <myADC_startADC>
	return myADC_readADC(channel);
     b28:	8c 2f       	mov	r24, r28
     b2a:	d7 df       	rcall	.-82     	; 0xada <myADC_readADC>
}
     b2c:	cf 91       	pop	r28
     b2e:	08 95       	ret

00000b30 <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b30:	9c 01       	movw	r18, r24
     b32:	24 5f       	subi	r18, 0xF4	; 244
     b34:	3f 4f       	sbci	r19, 0xFF	; 255
     b36:	26 17       	cp	r18, r22
     b38:	37 07       	cpc	r19, r23
     b3a:	44 f0       	brlt	.+16     	; 0xb4c <detectStairs+0x1c>
     b3c:	28 51       	subi	r18, 0x18	; 24
     b3e:	31 09       	sbc	r19, r1
     b40:	81 e0       	ldi	r24, 0x01	; 1
     b42:	62 17       	cp	r22, r18
     b44:	73 07       	cpc	r23, r19
     b46:	1c f0       	brlt	.+6      	; 0xb4e <detectStairs+0x1e>
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	08 95       	ret
	{
		return 1; // stairs found
     b4c:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b4e:	08 95       	ret

00000b50 <obstacleAvoidance>:


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b50:	0f 93       	push	r16
     b52:	1f 93       	push	r17
     b54:	f8 01       	movw	r30, r16
	
	if(deviceBlocked[BTM_DEVICE])
     b56:	83 81       	ldd	r24, Z+3	; 0x03
     b58:	88 23       	and	r24, r24
     b5a:	39 f0       	breq	.+14     	; 0xb6a <obstacleAvoidance+0x1a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b5c:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b5e:	e2 e0       	ldi	r30, 0x02	; 2
     b60:	f1 e0       	ldi	r31, 0x01	; 1
     b62:	80 81       	ld	r24, Z
     b64:	80 61       	ori	r24, 0x10	; 16
     b66:	80 83       	st	Z, r24
     b68:	57 c0       	rjmp	.+174    	; 0xc18 <obstacleAvoidance+0xc8>
	}
	else if(deviceBlocked[FRONT_DEVICE])
     b6a:	80 81       	ld	r24, Z
     b6c:	88 23       	and	r24, r24
     b6e:	b1 f1       	breq	.+108    	; 0xbdc <obstacleAvoidance+0x8c>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b70:	81 81       	ldd	r24, Z+1	; 0x01
     b72:	81 11       	cpse	r24, r1
     b74:	18 c0       	rjmp	.+48     	; 0xba6 <obstacleAvoidance+0x56>
     b76:	82 81       	ldd	r24, Z+2	; 0x02
     b78:	81 11       	cpse	r24, r1
     b7a:	24 c0       	rjmp	.+72     	; 0xbc4 <obstacleAvoidance+0x74>
		{
			// both not blocked... so select any side... (left safer to turn - see product)
				if(rightSonar > leftSonar + 14) // if right sonar greater than....
     b7c:	cb 01       	movw	r24, r22
     b7e:	0e 96       	adiw	r24, 0x0e	; 14
     b80:	84 17       	cp	r24, r20
     b82:	95 07       	cpc	r25, r21
     b84:	3c f4       	brge	.+14     	; 0xb94 <obstacleAvoidance+0x44>
				{
					MOTOR_LEFT_STOP();
     b86:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     b88:	a2 e0       	ldi	r26, 0x02	; 2
     b8a:	b1 e0       	ldi	r27, 0x01	; 1
     b8c:	8c 91       	ld	r24, X
     b8e:	80 61       	ori	r24, 0x10	; 16
     b90:	8c 93       	st	X, r24
     b92:	06 c0       	rjmp	.+12     	; 0xba0 <obstacleAvoidance+0x50>
				}
				else 
				{
					MOTOR_LEFT_START();
     b94:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     b96:	a2 e0       	ldi	r26, 0x02	; 2
     b98:	b1 e0       	ldi	r27, 0x01	; 1
     b9a:	8c 91       	ld	r24, X
     b9c:	8f 7e       	andi	r24, 0xEF	; 239
     b9e:	8c 93       	st	X, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     ba0:	81 81       	ldd	r24, Z+1	; 0x01
     ba2:	88 23       	and	r24, r24
     ba4:	b1 f1       	breq	.+108    	; 0xc12 <obstacleAvoidance+0xc2>
     ba6:	82 81       	ldd	r24, Z+2	; 0x02
     ba8:	81 11       	cpse	r24, r1
     baa:	36 c0       	rjmp	.+108    	; 0xc18 <obstacleAvoidance+0xc8>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     bac:	46 1b       	sub	r20, r22
     bae:	57 0b       	sbc	r21, r23
     bb0:	49 30       	cpi	r20, 0x09	; 9
     bb2:	51 05       	cpc	r21, r1
     bb4:	8c f1       	brlt	.+98     	; 0xc18 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
     bb6:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     bb8:	e2 e0       	ldi	r30, 0x02	; 2
     bba:	f1 e0       	ldi	r31, 0x01	; 1
     bbc:	80 81       	ld	r24, Z
     bbe:	80 61       	ori	r24, 0x10	; 16
     bc0:	80 83       	st	Z, r24
     bc2:	2a c0       	rjmp	.+84     	; 0xc18 <obstacleAvoidance+0xc8>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     bc4:	64 1b       	sub	r22, r20
     bc6:	75 0b       	sbc	r23, r21
     bc8:	69 30       	cpi	r22, 0x09	; 9
     bca:	71 05       	cpc	r23, r1
     bcc:	2c f1       	brlt	.+74     	; 0xc18 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_START();
     bce:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     bd0:	e2 e0       	ldi	r30, 0x02	; 2
     bd2:	f1 e0       	ldi	r31, 0x01	; 1
     bd4:	80 81       	ld	r24, Z
     bd6:	8f 7e       	andi	r24, 0xEF	; 239
     bd8:	80 83       	st	Z, r24
     bda:	1e c0       	rjmp	.+60     	; 0xc18 <obstacleAvoidance+0xc8>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     bdc:	66 32       	cpi	r22, 0x26	; 38
     bde:	71 05       	cpc	r23, r1
     be0:	3c f4       	brge	.+14     	; 0xbf0 <obstacleAvoidance+0xa0>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     be2:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     be4:	e2 e0       	ldi	r30, 0x02	; 2
     be6:	f1 e0       	ldi	r31, 0x01	; 1
     be8:	80 81       	ld	r24, Z
     bea:	80 61       	ori	r24, 0x10	; 16
     bec:	80 83       	st	Z, r24
     bee:	14 c0       	rjmp	.+40     	; 0xc18 <obstacleAvoidance+0xc8>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     bf0:	44 31       	cpi	r20, 0x14	; 20
     bf2:	51 05       	cpc	r21, r1
     bf4:	3c f4       	brge	.+14     	; 0xc04 <obstacleAvoidance+0xb4>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     bf6:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     bf8:	e2 e0       	ldi	r30, 0x02	; 2
     bfa:	f1 e0       	ldi	r31, 0x01	; 1
     bfc:	80 81       	ld	r24, Z
     bfe:	8f 7e       	andi	r24, 0xEF	; 239
     c00:	80 83       	st	Z, r24
     c02:	0a c0       	rjmp	.+20     	; 0xc18 <obstacleAvoidance+0xc8>
	}
	else
	{
			MOTOR_LEFT_STOP();
     c04:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c06:	e2 e0       	ldi	r30, 0x02	; 2
     c08:	f1 e0       	ldi	r31, 0x01	; 1
     c0a:	80 81       	ld	r24, Z
     c0c:	8f 7e       	andi	r24, 0xEF	; 239
     c0e:	80 83       	st	Z, r24
     c10:	03 c0       	rjmp	.+6      	; 0xc18 <obstacleAvoidance+0xc8>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     c12:	82 81       	ldd	r24, Z+2	; 0x02
     c14:	81 11       	cpse	r24, r1
     c16:	d6 cf       	rjmp	.-84     	; 0xbc4 <obstacleAvoidance+0x74>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	08 95       	ret

00000c1e <cheatPrintAll>:


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     c1e:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     c20:	85 e0       	ldi	r24, 0x05	; 5
     c22:	db 01       	movw	r26, r22
     c24:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c26:	86 e4       	ldi	r24, 0x46	; 70
     c28:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c2a:	8c e4       	ldi	r24, 0x4C	; 76
     c2c:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c2e:	82 e5       	ldi	r24, 0x52	; 82
     c30:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c32:	82 e4       	ldi	r24, 0x42	; 66
     c34:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     c36:	84 e5       	ldi	r24, 0x54	; 84
     c38:	84 83       	std	Z+4, r24	; 0x04
     c3a:	08 95       	ret

00000c3c <obstacleDetection>:


// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c3c:	af 92       	push	r10
     c3e:	bf 92       	push	r11
     c40:	cf 92       	push	r12
     c42:	df 92       	push	r13
     c44:	ff 92       	push	r15
     c46:	0f 93       	push	r16
     c48:	1f 93       	push	r17
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	f6 2e       	mov	r15, r22
     c50:	ea 01       	movw	r28, r20
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c52:	86 34       	cpi	r24, 0x46	; 70
     c54:	91 05       	cpc	r25, r1
     c56:	1c f4       	brge	.+6      	; 0xc5e <obstacleDetection+0x22>
	{
		obstacleDetected ++;
     c58:	f3 94       	inc	r15
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c5a:	86 e4       	ldi	r24, 0x46	; 70
     c5c:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c5e:	2e 31       	cpi	r18, 0x1E	; 30
     c60:	31 05       	cpc	r19, r1
     c62:	1c f4       	brge	.+6      	; 0xc6a <obstacleDetection+0x2e>
	{
		obstacleDetected ++;
     c64:	f3 94       	inc	r15
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c66:	8c e4       	ldi	r24, 0x4C	; 76
     c68:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c6a:	0e 31       	cpi	r16, 0x1E	; 30
     c6c:	11 05       	cpc	r17, r1
     c6e:	1c f4       	brge	.+6      	; 0xc76 <obstacleDetection+0x3a>
	{
		obstacleDetected++;
     c70:	f3 94       	inc	r15
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c72:	82 e5       	ldi	r24, 0x52	; 82
     c74:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     c76:	b5 01       	movw	r22, r10
     c78:	c6 01       	movw	r24, r12
     c7a:	5a df       	rcall	.-332    	; 0xb30 <detectStairs>
     c7c:	88 23       	and	r24, r24
     c7e:	19 f0       	breq	.+6      	; 0xc86 <obstacleDetection+0x4a>
	{
		obstacleDetected++;
     c80:	f3 94       	inc	r15
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     c82:	82 e4       	ldi	r24, 0x42	; 66
     c84:	8b 83       	std	Y+3, r24	; 0x03
	//	obstacleDetected++;
	//	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
	//}
	
	return obstacleDetected;
}
     c86:	8f 2d       	mov	r24, r15
     c88:	df 91       	pop	r29
     c8a:	cf 91       	pop	r28
     c8c:	1f 91       	pop	r17
     c8e:	0f 91       	pop	r16
     c90:	ff 90       	pop	r15
     c92:	df 90       	pop	r13
     c94:	cf 90       	pop	r12
     c96:	bf 90       	pop	r11
     c98:	af 90       	pop	r10
     c9a:	08 95       	ret

00000c9c <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     c9c:	42 df       	rcall	.-380    	; 0xb22 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     c9e:	bc 01       	movw	r22, r24
     ca0:	88 27       	eor	r24, r24
     ca2:	77 fd       	sbrc	r23, 7
     ca4:	80 95       	com	r24
     ca6:	98 2f       	mov	r25, r24
     ca8:	0e 94 5d 14 	call	0x28ba	; 0x28ba <__floatsisf>
     cac:	29 e2       	ldi	r18, 0x29	; 41
     cae:	3c e5       	ldi	r19, 0x5C	; 92
     cb0:	4f e6       	ldi	r20, 0x6F	; 111
     cb2:	5f eb       	ldi	r21, 0xBF	; 191
     cb4:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <pow>
     cb8:	22 e5       	ldi	r18, 0x52	; 82
     cba:	38 e6       	ldi	r19, 0x68	; 104
     cbc:	46 e2       	ldi	r20, 0x26	; 38
     cbe:	56 e4       	ldi	r21, 0x46	; 70
     cc0:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <__mulsf3>
     cc4:	20 e0       	ldi	r18, 0x00	; 0
     cc6:	30 e0       	ldi	r19, 0x00	; 0
     cc8:	40 e2       	ldi	r20, 0x20	; 32
     cca:	51 e4       	ldi	r21, 0x41	; 65
     ccc:	0e 94 c5 13 	call	0x278a	; 0x278a <__subsf3>
     cd0:	0e 94 2a 14 	call	0x2854	; 0x2854 <__fixsfsi>
     cd4:	cb 01       	movw	r24, r22
     cd6:	68 3e       	cpi	r22, 0xE8	; 232
     cd8:	23 e0       	ldi	r18, 0x03	; 3
     cda:	72 07       	cpc	r23, r18
     cdc:	14 f0       	brlt	.+4      	; 0xce2 <mySharpIR_Read+0x46>
     cde:	87 ee       	ldi	r24, 0xE7	; 231
     ce0:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     ce2:	08 95       	ret

00000ce4 <checkWithinRange>:

char checkWithinRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     ce4:	fb 01       	movw	r30, r22
     ce6:	20 81       	ld	r18, Z
     ce8:	31 81       	ldd	r19, Z+1	; 0x01
     cea:	50 e0       	ldi	r21, 0x00	; 0
     cec:	b9 01       	movw	r22, r18
     cee:	64 0f       	add	r22, r20
     cf0:	75 1f       	adc	r23, r21
     cf2:	68 17       	cp	r22, r24
     cf4:	79 07       	cpc	r23, r25
     cf6:	4c f0       	brlt	.+18     	; 0xd0a <checkWithinRange+0x26>
     cf8:	24 1b       	sub	r18, r20
     cfa:	35 0b       	sbc	r19, r21
     cfc:	41 e0       	ldi	r20, 0x01	; 1
     cfe:	82 17       	cp	r24, r18
     d00:	93 07       	cpc	r25, r19
     d02:	0c f0       	brlt	.+2      	; 0xd06 <checkWithinRange+0x22>
     d04:	40 e0       	ldi	r20, 0x00	; 0
     d06:	84 2f       	mov	r24, r20
     d08:	08 95       	ret
     d0a:	81 e0       	ldi	r24, 0x01	; 1
}
     d0c:	08 95       	ret

00000d0e <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     d0e:	0f 93       	push	r16
     d10:	1f 93       	push	r17
     d12:	cf 93       	push	r28
     d14:	df 93       	push	r29
     d16:	8c 01       	movw	r16, r24
     d18:	eb 01       	movw	r28, r22
	static int i = 0;
	static int checkReading[2] = {0};
	
	if(checkWithinRange(reading, calibratedReading, CALIBRATE_RANGE) && i == 0)
     d1a:	45 e0       	ldi	r20, 0x05	; 5
     d1c:	bc 01       	movw	r22, r24
     d1e:	ce 01       	movw	r24, r28
     d20:	e1 df       	rcall	.-62     	; 0xce4 <checkWithinRange>
     d22:	88 23       	and	r24, r24
     d24:	41 f0       	breq	.+16     	; 0xd36 <mySharpIR_ReCalibrate+0x28>
     d26:	20 91 24 08 	lds	r18, 0x0824
     d2a:	30 91 25 08 	lds	r19, 0x0825
     d2e:	21 15       	cp	r18, r1
     d30:	31 05       	cpc	r19, r1
     d32:	69 f4       	brne	.+26     	; 0xd4e <mySharpIR_ReCalibrate+0x40>
     d34:	4b c0       	rjmp	.+150    	; 0xdcc <mySharpIR_ReCalibrate+0xbe>
		// skip the calibration process... not needed
		return;
	}
	
	
	if (i == 0)
     d36:	20 91 24 08 	lds	r18, 0x0824
     d3a:	30 91 25 08 	lds	r19, 0x0825
     d3e:	21 15       	cp	r18, r1
     d40:	31 05       	cpc	r19, r1
     d42:	29 f4       	brne	.+10     	; 0xd4e <mySharpIR_ReCalibrate+0x40>
	{
		checkReading[0] = reading;
     d44:	d0 93 21 08 	sts	0x0821, r29
     d48:	c0 93 20 08 	sts	0x0820, r28
     d4c:	32 c0       	rjmp	.+100    	; 0xdb2 <mySharpIR_ReCalibrate+0xa4>
	}
	else if (i == CALIBRATE_COUNT/2)
     d4e:	2a 30       	cpi	r18, 0x0A	; 10
     d50:	31 05       	cpc	r19, r1
     d52:	a9 f4       	brne	.+42     	; 0xd7e <mySharpIR_ReCalibrate+0x70>
	{
		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d54:	45 e0       	ldi	r20, 0x05	; 5
     d56:	60 e2       	ldi	r22, 0x20	; 32
     d58:	78 e0       	ldi	r23, 0x08	; 8
     d5a:	ce 01       	movw	r24, r28
     d5c:	c3 df       	rcall	.-122    	; 0xce4 <checkWithinRange>
     d5e:	88 23       	and	r24, r24
     d60:	49 f0       	breq	.+18     	; 0xd74 <mySharpIR_ReCalibrate+0x66>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d62:	d0 93 21 08 	sts	0x0821, r29
     d66:	c0 93 20 08 	sts	0x0820, r28
			i = 0; // reset to count...
     d6a:	10 92 25 08 	sts	0x0825, r1
     d6e:	10 92 24 08 	sts	0x0824, r1
     d72:	1f c0       	rjmp	.+62     	; 0xdb2 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{	// within range.. need more confirmation
			checkReading[1] = reading;
     d74:	d0 93 23 08 	sts	0x0823, r29
     d78:	c0 93 22 08 	sts	0x0822, r28
     d7c:	1a c0       	rjmp	.+52     	; 0xdb2 <mySharpIR_ReCalibrate+0xa4>
		}
	}
	else if (i == CALIBRATE_COUNT)
     d7e:	24 31       	cpi	r18, 0x14	; 20
     d80:	31 05       	cpc	r19, r1
     d82:	b9 f4       	brne	.+46     	; 0xdb2 <mySharpIR_ReCalibrate+0xa4>
	{
		i = 0; // reset to count..
     d84:	10 92 25 08 	sts	0x0825, r1
     d88:	10 92 24 08 	sts	0x0824, r1

		if(checkWithinRange(reading, checkReading, CALIBRATE_RANGE))
     d8c:	45 e0       	ldi	r20, 0x05	; 5
     d8e:	60 e2       	ldi	r22, 0x20	; 32
     d90:	78 e0       	ldi	r23, 0x08	; 8
     d92:	ce 01       	movw	r24, r28
     d94:	a7 df       	rcall	.-178    	; 0xce4 <checkWithinRange>
     d96:	88 23       	and	r24, r24
     d98:	29 f0       	breq	.+10     	; 0xda4 <mySharpIR_ReCalibrate+0x96>
		{
			// Out of range.. restart to find new calibration point..
			checkReading[0] = reading;
     d9a:	d0 93 21 08 	sts	0x0821, r29
     d9e:	c0 93 20 08 	sts	0x0820, r28
     da2:	07 c0       	rjmp	.+14     	; 0xdb2 <mySharpIR_ReCalibrate+0xa4>
		}
		else
		{
			// all 3 readings within range... can calibrate as new stable.
			*calibratedReading = checkReading[0]; // btmIR is calibrated..
     da4:	80 91 20 08 	lds	r24, 0x0820
     da8:	90 91 21 08 	lds	r25, 0x0821
     dac:	f8 01       	movw	r30, r16
     dae:	91 83       	std	Z+1, r25	; 0x01
     db0:	80 83       	st	Z, r24
		}
	}
	
	i = (i+1) % CALIBRATE_COUNT;
     db2:	80 91 24 08 	lds	r24, 0x0824
     db6:	90 91 25 08 	lds	r25, 0x0825
     dba:	01 96       	adiw	r24, 0x01	; 1
     dbc:	64 e1       	ldi	r22, 0x14	; 20
     dbe:	70 e0       	ldi	r23, 0x00	; 0
     dc0:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
     dc4:	90 93 25 08 	sts	0x0825, r25
     dc8:	80 93 24 08 	sts	0x0824, r24
}
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	1f 91       	pop	r17
     dd2:	0f 91       	pop	r16
     dd4:	08 95       	ret

00000dd6 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     dd6:	90 93 ae 08 	sts	0x08AE, r25
     dda:	80 93 ad 08 	sts	0x08AD, r24
     dde:	fc 01       	movw	r30, r24
     de0:	80 81       	ld	r24, Z
     de2:	91 81       	ldd	r25, Z+1	; 0x01
     de4:	0e 94 0f 12 	call	0x241e	; 0x241e <vTaskSuspend>
     de8:	43 e0       	ldi	r20, 0x03	; 3
     dea:	60 e0       	ldi	r22, 0x00	; 0
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	ee d4       	rcall	.+2524   	; 0x17cc <xQueueGenericCreate>
     df0:	90 93 aa 08 	sts	0x08AA, r25
     df4:	80 93 a9 08 	sts	0x08A9, r24
     df8:	43 e0       	ldi	r20, 0x03	; 3
     dfa:	60 e0       	ldi	r22, 0x00	; 0
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	e6 d4       	rcall	.+2508   	; 0x17cc <xQueueGenericCreate>
     e00:	90 93 ac 08 	sts	0x08AC, r25
     e04:	80 93 ab 08 	sts	0x08AB, r24
     e08:	08 95       	ret

00000e0a <myTimer_Read>:
     e0a:	86 b5       	in	r24, 0x26	; 38
     e0c:	08 95       	ret

00000e0e <myTimer_DelayMicro>:
     e0e:	46 b5       	in	r20, 0x26	; 38
     e10:	50 e0       	ldi	r21, 0x00	; 0
     e12:	9c 01       	movw	r18, r24
     e14:	99 23       	and	r25, r25
     e16:	14 f4       	brge	.+4      	; 0xe1c <myTimer_DelayMicro+0xe>
     e18:	2d 5f       	subi	r18, 0xFD	; 253
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	35 95       	asr	r19
     e1e:	27 95       	ror	r18
     e20:	35 95       	asr	r19
     e22:	27 95       	ror	r18
     e24:	24 0f       	add	r18, r20
     e26:	35 1f       	adc	r19, r21
     e28:	30 93 03 02 	sts	0x0203, r19
     e2c:	20 93 02 02 	sts	0x0202, r18
     e30:	e0 91 ad 08 	lds	r30, 0x08AD
     e34:	f0 91 ae 08 	lds	r31, 0x08AE
     e38:	80 81       	ld	r24, Z
     e3a:	91 81       	ldd	r25, Z+1	; 0x01
     e3c:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <vTaskResume>
     e40:	20 e0       	ldi	r18, 0x00	; 0
     e42:	42 e0       	ldi	r20, 0x02	; 2
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	60 e0       	ldi	r22, 0x00	; 0
     e48:	70 e0       	ldi	r23, 0x00	; 0
     e4a:	80 91 a9 08 	lds	r24, 0x08A9
     e4e:	90 91 aa 08 	lds	r25, 0x08AA
     e52:	e1 c5       	rjmp	.+3010   	; 0x1a16 <xQueueGenericReceive>
     e54:	08 95       	ret

00000e56 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e56:	cf 93       	push	r28
     e58:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e5a:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e5c:	c1 11       	cpse	r28, r1
     e5e:	22 c0       	rjmp	.+68     	; 0xea4 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e60:	80 91 02 02 	lds	r24, 0x0202
     e64:	90 91 03 02 	lds	r25, 0x0203
     e68:	88 38       	cpi	r24, 0x88	; 136
     e6a:	93 41       	sbci	r25, 0x13	; 19
     e6c:	51 f0       	breq	.+20     	; 0xe82 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e6e:	80 91 02 02 	lds	r24, 0x0202
     e72:	90 91 03 02 	lds	r25, 0x0203
     e76:	8a 5f       	subi	r24, 0xFA	; 250
     e78:	91 09       	sbc	r25, r1
     e7a:	90 93 03 02 	sts	0x0203, r25
     e7e:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     e82:	80 91 00 02 	lds	r24, 0x0200
     e86:	90 91 01 02 	lds	r25, 0x0201
     e8a:	88 38       	cpi	r24, 0x88	; 136
     e8c:	93 41       	sbci	r25, 0x13	; 19
     e8e:	51 f0       	breq	.+20     	; 0xea4 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     e90:	80 91 00 02 	lds	r24, 0x0200
     e94:	90 91 01 02 	lds	r25, 0x0201
     e98:	8a 5f       	subi	r24, 0xFA	; 250
     e9a:	91 09       	sbc	r25, r1
     e9c:	90 93 01 02 	sts	0x0201, r25
     ea0:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     ea4:	d0 e0       	ldi	r29, 0x00	; 0
     ea6:	80 91 02 02 	lds	r24, 0x0202
     eaa:	90 91 03 02 	lds	r25, 0x0203
     eae:	8c 17       	cp	r24, r28
     eb0:	9d 07       	cpc	r25, r29
     eb2:	84 f4       	brge	.+32     	; 0xed4 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     eb4:	88 e8       	ldi	r24, 0x88	; 136
     eb6:	93 e1       	ldi	r25, 0x13	; 19
     eb8:	90 93 03 02 	sts	0x0203, r25
     ebc:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     ec0:	20 e0       	ldi	r18, 0x00	; 0
     ec2:	40 e0       	ldi	r20, 0x00	; 0
     ec4:	50 e0       	ldi	r21, 0x00	; 0
     ec6:	60 e0       	ldi	r22, 0x00	; 0
     ec8:	70 e0       	ldi	r23, 0x00	; 0
     eca:	80 91 a9 08 	lds	r24, 0x08A9
     ece:	90 91 aa 08 	lds	r25, 0x08AA
     ed2:	a9 d4       	rcall	.+2386   	; 0x1826 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     ed4:	80 91 00 02 	lds	r24, 0x0200
     ed8:	90 91 01 02 	lds	r25, 0x0201
     edc:	8c 17       	cp	r24, r28
     ede:	9d 07       	cpc	r25, r29
     ee0:	84 f4       	brge	.+32     	; 0xf02 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     ee2:	88 e8       	ldi	r24, 0x88	; 136
     ee4:	93 e1       	ldi	r25, 0x13	; 19
     ee6:	90 93 01 02 	sts	0x0201, r25
     eea:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     eee:	20 e0       	ldi	r18, 0x00	; 0
     ef0:	40 e0       	ldi	r20, 0x00	; 0
     ef2:	50 e0       	ldi	r21, 0x00	; 0
     ef4:	60 e0       	ldi	r22, 0x00	; 0
     ef6:	70 e0       	ldi	r23, 0x00	; 0
     ef8:	80 91 ab 08 	lds	r24, 0x08AB
     efc:	90 91 ac 08 	lds	r25, 0x08AC
     f00:	92 d4       	rcall	.+2340   	; 0x1826 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     f02:	80 91 02 02 	lds	r24, 0x0202
     f06:	90 91 03 02 	lds	r25, 0x0203
     f0a:	88 38       	cpi	r24, 0x88	; 136
     f0c:	93 41       	sbci	r25, 0x13	; 19
     f0e:	79 f4       	brne	.+30     	; 0xf2e <myTimer_DelayChecker+0xd8>
     f10:	80 91 00 02 	lds	r24, 0x0200
     f14:	90 91 01 02 	lds	r25, 0x0201
     f18:	88 38       	cpi	r24, 0x88	; 136
     f1a:	93 41       	sbci	r25, 0x13	; 19
     f1c:	41 f4       	brne	.+16     	; 0xf2e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f1e:	e0 91 ad 08 	lds	r30, 0x08AD
     f22:	f0 91 ae 08 	lds	r31, 0x08AE
     f26:	80 81       	ld	r24, Z
     f28:	91 81       	ldd	r25, Z+1	; 0x01
     f2a:	0e 94 0f 12 	call	0x241e	; 0x241e <vTaskSuspend>
	}
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	08 95       	ret

00000f34 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     f34:	1f 92       	push	r1
     f36:	0f 92       	push	r0
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	0f 92       	push	r0
     f3c:	11 24       	eor	r1, r1
     f3e:	0b b6       	in	r0, 0x3b	; 59
     f40:	0f 92       	push	r0
     f42:	2f 93       	push	r18
     f44:	3f 93       	push	r19
     f46:	4f 93       	push	r20
     f48:	5f 93       	push	r21
     f4a:	6f 93       	push	r22
     f4c:	7f 93       	push	r23
     f4e:	8f 93       	push	r24
     f50:	9f 93       	push	r25
     f52:	af 93       	push	r26
     f54:	bf 93       	push	r27
     f56:	ef 93       	push	r30
     f58:	ff 93       	push	r31
     f5a:	60 91 ce 00 	lds	r22, 0x00CE
     f5e:	84 e4       	ldi	r24, 0x44	; 68
     f60:	99 e0       	ldi	r25, 0x09	; 9
     f62:	2f d6       	rcall	.+3166   	; 0x1bc2 <ringBufferPush>
     f64:	20 e0       	ldi	r18, 0x00	; 0
     f66:	40 e0       	ldi	r20, 0x00	; 0
     f68:	50 e0       	ldi	r21, 0x00	; 0
     f6a:	60 e0       	ldi	r22, 0x00	; 0
     f6c:	70 e0       	ldi	r23, 0x00	; 0
     f6e:	80 91 38 09 	lds	r24, 0x0938
     f72:	90 91 39 09 	lds	r25, 0x0939
     f76:	15 d5       	rcall	.+2602   	; 0x19a2 <xQueueGenericSendFromISR>
     f78:	84 e4       	ldi	r24, 0x44	; 68
     f7a:	99 e0       	ldi	r25, 0x09	; 9
     f7c:	39 d6       	rcall	.+3186   	; 0x1bf0 <ringBufferFull>
     f7e:	ff 91       	pop	r31
     f80:	ef 91       	pop	r30
     f82:	bf 91       	pop	r27
     f84:	af 91       	pop	r26
     f86:	9f 91       	pop	r25
     f88:	8f 91       	pop	r24
     f8a:	7f 91       	pop	r23
     f8c:	6f 91       	pop	r22
     f8e:	5f 91       	pop	r21
     f90:	4f 91       	pop	r20
     f92:	3f 91       	pop	r19
     f94:	2f 91       	pop	r18
     f96:	0f 90       	pop	r0
     f98:	0b be       	out	0x3b, r0	; 59
     f9a:	0f 90       	pop	r0
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	0f 90       	pop	r0
     fa0:	1f 90       	pop	r1
     fa2:	18 95       	reti

00000fa4 <__vector_25>:
     fa4:	1f 92       	push	r1
     fa6:	0f 92       	push	r0
     fa8:	0f b6       	in	r0, 0x3f	; 63
     faa:	0f 92       	push	r0
     fac:	11 24       	eor	r1, r1
     fae:	0b b6       	in	r0, 0x3b	; 59
     fb0:	0f 92       	push	r0
     fb2:	2f 93       	push	r18
     fb4:	3f 93       	push	r19
     fb6:	4f 93       	push	r20
     fb8:	5f 93       	push	r21
     fba:	6f 93       	push	r22
     fbc:	7f 93       	push	r23
     fbe:	8f 93       	push	r24
     fc0:	9f 93       	push	r25
     fc2:	af 93       	push	r26
     fc4:	bf 93       	push	r27
     fc6:	ef 93       	push	r30
     fc8:	ff 93       	push	r31
     fca:	60 91 c6 00 	lds	r22, 0x00C6
     fce:	8f ec       	ldi	r24, 0xCF	; 207
     fd0:	98 e0       	ldi	r25, 0x08	; 8
     fd2:	f7 d5       	rcall	.+3054   	; 0x1bc2 <ringBufferPush>
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	40 e0       	ldi	r20, 0x00	; 0
     fd8:	50 e0       	ldi	r21, 0x00	; 0
     fda:	60 e0       	ldi	r22, 0x00	; 0
     fdc:	70 e0       	ldi	r23, 0x00	; 0
     fde:	80 91 38 09 	lds	r24, 0x0938
     fe2:	90 91 39 09 	lds	r25, 0x0939
     fe6:	dd d4       	rcall	.+2490   	; 0x19a2 <xQueueGenericSendFromISR>
     fe8:	8f ec       	ldi	r24, 0xCF	; 207
     fea:	98 e0       	ldi	r25, 0x08	; 8
     fec:	01 d6       	rcall	.+3074   	; 0x1bf0 <ringBufferFull>
     fee:	ff 91       	pop	r31
     ff0:	ef 91       	pop	r30
     ff2:	bf 91       	pop	r27
     ff4:	af 91       	pop	r26
     ff6:	9f 91       	pop	r25
     ff8:	8f 91       	pop	r24
     ffa:	7f 91       	pop	r23
     ffc:	6f 91       	pop	r22
     ffe:	5f 91       	pop	r21
    1000:	4f 91       	pop	r20
    1002:	3f 91       	pop	r19
    1004:	2f 91       	pop	r18
    1006:	0f 90       	pop	r0
    1008:	0b be       	out	0x3b, r0	; 59
    100a:	0f 90       	pop	r0
    100c:	0f be       	out	0x3f, r0	; 63
    100e:	0f 90       	pop	r0
    1010:	1f 90       	pop	r1
    1012:	18 95       	reti

00001014 <__vector_37>:
    1014:	1f 92       	push	r1
    1016:	0f 92       	push	r0
    1018:	0f b6       	in	r0, 0x3f	; 63
    101a:	0f 92       	push	r0
    101c:	11 24       	eor	r1, r1
    101e:	0b b6       	in	r0, 0x3b	; 59
    1020:	0f 92       	push	r0
    1022:	2f 93       	push	r18
    1024:	3f 93       	push	r19
    1026:	4f 93       	push	r20
    1028:	5f 93       	push	r21
    102a:	6f 93       	push	r22
    102c:	7f 93       	push	r23
    102e:	8f 93       	push	r24
    1030:	9f 93       	push	r25
    1032:	af 93       	push	r26
    1034:	bf 93       	push	r27
    1036:	ef 93       	push	r30
    1038:	ff 93       	push	r31
    103a:	8a e3       	ldi	r24, 0x3A	; 58
    103c:	99 e0       	ldi	r25, 0x09	; 9
    103e:	df d5       	rcall	.+3006   	; 0x1bfe <ringBufferNotEmpty>
    1040:	88 23       	and	r24, r24
    1042:	31 f0       	breq	.+12     	; 0x1050 <__vector_37+0x3c>
    1044:	8a e3       	ldi	r24, 0x3A	; 58
    1046:	99 e0       	ldi	r25, 0x09	; 9
    1048:	aa d5       	rcall	.+2900   	; 0x1b9e <ringBufferPop>
    104a:	80 93 ce 00 	sts	0x00CE, r24
    104e:	05 c0       	rjmp	.+10     	; 0x105a <__vector_37+0x46>
    1050:	e9 ec       	ldi	r30, 0xC9	; 201
    1052:	f0 e0       	ldi	r31, 0x00	; 0
    1054:	80 81       	ld	r24, Z
    1056:	8f 7d       	andi	r24, 0xDF	; 223
    1058:	80 83       	st	Z, r24
    105a:	ff 91       	pop	r31
    105c:	ef 91       	pop	r30
    105e:	bf 91       	pop	r27
    1060:	af 91       	pop	r26
    1062:	9f 91       	pop	r25
    1064:	8f 91       	pop	r24
    1066:	7f 91       	pop	r23
    1068:	6f 91       	pop	r22
    106a:	5f 91       	pop	r21
    106c:	4f 91       	pop	r20
    106e:	3f 91       	pop	r19
    1070:	2f 91       	pop	r18
    1072:	0f 90       	pop	r0
    1074:	0b be       	out	0x3b, r0	; 59
    1076:	0f 90       	pop	r0
    1078:	0f be       	out	0x3f, r0	; 63
    107a:	0f 90       	pop	r0
    107c:	1f 90       	pop	r1
    107e:	18 95       	reti

00001080 <__vector_26>:
    1080:	1f 92       	push	r1
    1082:	0f 92       	push	r0
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	0f 92       	push	r0
    1088:	11 24       	eor	r1, r1
    108a:	0b b6       	in	r0, 0x3b	; 59
    108c:	0f 92       	push	r0
    108e:	2f 93       	push	r18
    1090:	3f 93       	push	r19
    1092:	4f 93       	push	r20
    1094:	5f 93       	push	r21
    1096:	6f 93       	push	r22
    1098:	7f 93       	push	r23
    109a:	8f 93       	push	r24
    109c:	9f 93       	push	r25
    109e:	af 93       	push	r26
    10a0:	bf 93       	push	r27
    10a2:	ef 93       	push	r30
    10a4:	ff 93       	push	r31
    10a6:	8f e3       	ldi	r24, 0x3F	; 63
    10a8:	99 e0       	ldi	r25, 0x09	; 9
    10aa:	a9 d5       	rcall	.+2898   	; 0x1bfe <ringBufferNotEmpty>
    10ac:	88 23       	and	r24, r24
    10ae:	31 f0       	breq	.+12     	; 0x10bc <__vector_26+0x3c>
    10b0:	8f e3       	ldi	r24, 0x3F	; 63
    10b2:	99 e0       	ldi	r25, 0x09	; 9
    10b4:	74 d5       	rcall	.+2792   	; 0x1b9e <ringBufferPop>
    10b6:	80 93 c6 00 	sts	0x00C6, r24
    10ba:	05 c0       	rjmp	.+10     	; 0x10c6 <__vector_26+0x46>
    10bc:	e1 ec       	ldi	r30, 0xC1	; 193
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	8f 7d       	andi	r24, 0xDF	; 223
    10c4:	80 83       	st	Z, r24
    10c6:	ff 91       	pop	r31
    10c8:	ef 91       	pop	r30
    10ca:	bf 91       	pop	r27
    10cc:	af 91       	pop	r26
    10ce:	9f 91       	pop	r25
    10d0:	8f 91       	pop	r24
    10d2:	7f 91       	pop	r23
    10d4:	6f 91       	pop	r22
    10d6:	5f 91       	pop	r21
    10d8:	4f 91       	pop	r20
    10da:	3f 91       	pop	r19
    10dc:	2f 91       	pop	r18
    10de:	0f 90       	pop	r0
    10e0:	0b be       	out	0x3b, r0	; 59
    10e2:	0f 90       	pop	r0
    10e4:	0f be       	out	0x3f, r0	; 63
    10e6:	0f 90       	pop	r0
    10e8:	1f 90       	pop	r1
    10ea:	18 95       	reti

000010ec <myUSART_USART0_Init>:
    10ec:	10 92 c5 00 	sts	0x00C5, r1
    10f0:	87 e6       	ldi	r24, 0x67	; 103
    10f2:	80 93 c4 00 	sts	0x00C4, r24
    10f6:	88 eb       	ldi	r24, 0xB8	; 184
    10f8:	80 93 c1 00 	sts	0x00C1, r24
    10fc:	86 e0       	ldi	r24, 0x06	; 6
    10fe:	80 93 c2 00 	sts	0x00C2, r24
    1102:	40 e2       	ldi	r20, 0x20	; 32
    1104:	66 ef       	ldi	r22, 0xF6	; 246
    1106:	78 e0       	ldi	r23, 0x08	; 8
    1108:	8f ec       	ldi	r24, 0xCF	; 207
    110a:	98 e0       	ldi	r25, 0x08	; 8
    110c:	37 d5       	rcall	.+2670   	; 0x1b7c <ringBufferInit>
    110e:	40 e2       	ldi	r20, 0x20	; 32
    1110:	64 ed       	ldi	r22, 0xD4	; 212
    1112:	78 e0       	ldi	r23, 0x08	; 8
    1114:	8f e3       	ldi	r24, 0x3F	; 63
    1116:	99 e0       	ldi	r25, 0x09	; 9
    1118:	31 d5       	rcall	.+2658   	; 0x1b7c <ringBufferInit>
    111a:	43 e0       	ldi	r20, 0x03	; 3
    111c:	60 e0       	ldi	r22, 0x00	; 0
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	55 d3       	rcall	.+1706   	; 0x17cc <xQueueGenericCreate>
    1122:	90 93 37 09 	sts	0x0937, r25
    1126:	80 93 36 09 	sts	0x0936, r24
    112a:	08 95       	ret

0000112c <myUSART_USART1_Init>:
    112c:	10 92 cd 00 	sts	0x00CD, r1
    1130:	87 e6       	ldi	r24, 0x67	; 103
    1132:	80 93 cc 00 	sts	0x00CC, r24
    1136:	88 eb       	ldi	r24, 0xB8	; 184
    1138:	80 93 c9 00 	sts	0x00C9, r24
    113c:	86 e0       	ldi	r24, 0x06	; 6
    113e:	80 93 ca 00 	sts	0x00CA, r24
    1142:	40 e2       	ldi	r20, 0x20	; 32
    1144:	6f ea       	ldi	r22, 0xAF	; 175
    1146:	78 e0       	ldi	r23, 0x08	; 8
    1148:	84 e4       	ldi	r24, 0x44	; 68
    114a:	99 e0       	ldi	r25, 0x09	; 9
    114c:	17 d5       	rcall	.+2606   	; 0x1b7c <ringBufferInit>
    114e:	40 e2       	ldi	r20, 0x20	; 32
    1150:	66 e1       	ldi	r22, 0x16	; 22
    1152:	79 e0       	ldi	r23, 0x09	; 9
    1154:	8a e3       	ldi	r24, 0x3A	; 58
    1156:	99 e0       	ldi	r25, 0x09	; 9
    1158:	11 d5       	rcall	.+2594   	; 0x1b7c <ringBufferInit>
    115a:	43 e0       	ldi	r20, 0x03	; 3
    115c:	60 e0       	ldi	r22, 0x00	; 0
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	35 d3       	rcall	.+1642   	; 0x17cc <xQueueGenericCreate>
    1162:	90 93 39 09 	sts	0x0939, r25
    1166:	80 93 38 09 	sts	0x0938, r24
    116a:	43 e0       	ldi	r20, 0x03	; 3
    116c:	60 e0       	ldi	r22, 0x00	; 0
    116e:	81 e0       	ldi	r24, 0x01	; 1
    1170:	2d d3       	rcall	.+1626   	; 0x17cc <xQueueGenericCreate>
    1172:	90 93 f5 08 	sts	0x08F5, r25
    1176:	80 93 f4 08 	sts	0x08F4, r24
    117a:	08 95       	ret

0000117c <myUSART_transmitUSART0_c>:
    117c:	cf 93       	push	r28
    117e:	c8 2f       	mov	r28, r24
    1180:	8f e3       	ldi	r24, 0x3F	; 63
    1182:	99 e0       	ldi	r25, 0x09	; 9
    1184:	35 d5       	rcall	.+2666   	; 0x1bf0 <ringBufferFull>
    1186:	81 11       	cpse	r24, r1
    1188:	fb cf       	rjmp	.-10     	; 0x1180 <myUSART_transmitUSART0_c+0x4>
    118a:	6c 2f       	mov	r22, r28
    118c:	8f e3       	ldi	r24, 0x3F	; 63
    118e:	99 e0       	ldi	r25, 0x09	; 9
    1190:	18 d5       	rcall	.+2608   	; 0x1bc2 <ringBufferPush>
    1192:	e1 ec       	ldi	r30, 0xC1	; 193
    1194:	f0 e0       	ldi	r31, 0x00	; 0
    1196:	80 81       	ld	r24, Z
    1198:	80 62       	ori	r24, 0x20	; 32
    119a:	80 83       	st	Z, r24
    119c:	e0 ec       	ldi	r30, 0xC0	; 192
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	80 64       	ori	r24, 0x40	; 64
    11a4:	80 83       	st	Z, r24
    11a6:	cf 91       	pop	r28
    11a8:	08 95       	ret

000011aa <myUSART_transmitUSART1_c>:
    11aa:	cf 93       	push	r28
    11ac:	c8 2f       	mov	r28, r24
    11ae:	8a e3       	ldi	r24, 0x3A	; 58
    11b0:	99 e0       	ldi	r25, 0x09	; 9
    11b2:	1e d5       	rcall	.+2620   	; 0x1bf0 <ringBufferFull>
    11b4:	81 11       	cpse	r24, r1
    11b6:	fb cf       	rjmp	.-10     	; 0x11ae <myUSART_transmitUSART1_c+0x4>
    11b8:	6c 2f       	mov	r22, r28
    11ba:	8a e3       	ldi	r24, 0x3A	; 58
    11bc:	99 e0       	ldi	r25, 0x09	; 9
    11be:	01 d5       	rcall	.+2562   	; 0x1bc2 <ringBufferPush>
    11c0:	e9 ec       	ldi	r30, 0xC9	; 201
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	80 81       	ld	r24, Z
    11c6:	80 62       	ori	r24, 0x20	; 32
    11c8:	80 83       	st	Z, r24
    11ca:	e8 ec       	ldi	r30, 0xC8	; 200
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	80 64       	ori	r24, 0x40	; 64
    11d2:	80 83       	st	Z, r24
    11d4:	cf 91       	pop	r28
    11d6:	08 95       	ret

000011d8 <myUSART_transmitUSART1>:
    11d8:	cf 93       	push	r28
    11da:	df 93       	push	r29
    11dc:	ec 01       	movw	r28, r24
    11de:	88 81       	ld	r24, Y
    11e0:	88 23       	and	r24, r24
    11e2:	29 f0       	breq	.+10     	; 0x11ee <myUSART_transmitUSART1+0x16>
    11e4:	21 96       	adiw	r28, 0x01	; 1
    11e6:	e1 df       	rcall	.-62     	; 0x11aa <myUSART_transmitUSART1_c>
    11e8:	89 91       	ld	r24, Y+
    11ea:	81 11       	cpse	r24, r1
    11ec:	fc cf       	rjmp	.-8      	; 0x11e6 <myUSART_transmitUSART1+0xe>
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	08 95       	ret

000011f4 <myUSART_transmitUSART0>:
    11f4:	cf 93       	push	r28
    11f6:	df 93       	push	r29
    11f8:	ec 01       	movw	r28, r24
    11fa:	88 81       	ld	r24, Y
    11fc:	88 23       	and	r24, r24
    11fe:	29 f0       	breq	.+10     	; 0x120a <myUSART_transmitUSART0+0x16>
    1200:	21 96       	adiw	r28, 0x01	; 1
    1202:	bc df       	rcall	.-136    	; 0x117c <myUSART_transmitUSART0_c>
    1204:	89 91       	ld	r24, Y+
    1206:	81 11       	cpse	r24, r1
    1208:	fc cf       	rjmp	.-8      	; 0x1202 <myUSART_transmitUSART0+0xe>
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	08 95       	ret

00001210 <myUSART_receiveUSART1>:
    1210:	cf 93       	push	r28
    1212:	20 e0       	ldi	r18, 0x00	; 0
    1214:	4f ef       	ldi	r20, 0xFF	; 255
    1216:	5f ef       	ldi	r21, 0xFF	; 255
    1218:	60 e0       	ldi	r22, 0x00	; 0
    121a:	70 e0       	ldi	r23, 0x00	; 0
    121c:	80 91 38 09 	lds	r24, 0x0938
    1220:	90 91 39 09 	lds	r25, 0x0939
    1224:	f8 d3       	rcall	.+2032   	; 0x1a16 <xQueueGenericReceive>
    1226:	84 e4       	ldi	r24, 0x44	; 68
    1228:	99 e0       	ldi	r25, 0x09	; 9
    122a:	b9 d4       	rcall	.+2418   	; 0x1b9e <ringBufferPop>
    122c:	c8 2f       	mov	r28, r24
    122e:	84 e4       	ldi	r24, 0x44	; 68
    1230:	99 e0       	ldi	r25, 0x09	; 9
    1232:	e5 d4       	rcall	.+2506   	; 0x1bfe <ringBufferNotEmpty>
    1234:	88 23       	and	r24, r24
    1236:	51 f0       	breq	.+20     	; 0x124c <myUSART_receiveUSART1+0x3c>
    1238:	20 e0       	ldi	r18, 0x00	; 0
    123a:	40 e0       	ldi	r20, 0x00	; 0
    123c:	50 e0       	ldi	r21, 0x00	; 0
    123e:	60 e0       	ldi	r22, 0x00	; 0
    1240:	70 e0       	ldi	r23, 0x00	; 0
    1242:	80 91 38 09 	lds	r24, 0x0938
    1246:	90 91 39 09 	lds	r25, 0x0939
    124a:	ed d2       	rcall	.+1498   	; 0x1826 <xQueueGenericSend>
    124c:	8c 2f       	mov	r24, r28
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <myUSART_waitForHandshake>:
    1252:	de df       	rcall	.-68     	; 0x1210 <myUSART_receiveUSART1>
    1254:	86 31       	cpi	r24, 0x16	; 22
    1256:	51 f4       	brne	.+20     	; 0x126c <myUSART_waitForHandshake+0x1a>
    1258:	85 e0       	ldi	r24, 0x05	; 5
    125a:	a7 df       	rcall	.-178    	; 0x11aa <myUSART_transmitUSART1_c>
    125c:	d9 df       	rcall	.-78     	; 0x1210 <myUSART_receiveUSART1>
    125e:	91 e0       	ldi	r25, 0x01	; 1
    1260:	86 31       	cpi	r24, 0x16	; 22
    1262:	09 f4       	brne	.+2      	; 0x1266 <myUSART_waitForHandshake+0x14>
    1264:	90 e0       	ldi	r25, 0x00	; 0
    1266:	89 2f       	mov	r24, r25
    1268:	81 95       	neg	r24
    126a:	08 95       	ret
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	08 95       	ret

00001270 <myUSART_completeHandShake>:
    1270:	20 e0       	ldi	r18, 0x00	; 0
    1272:	40 e0       	ldi	r20, 0x00	; 0
    1274:	50 e0       	ldi	r21, 0x00	; 0
    1276:	60 e0       	ldi	r22, 0x00	; 0
    1278:	70 e0       	ldi	r23, 0x00	; 0
    127a:	80 91 f4 08 	lds	r24, 0x08F4
    127e:	90 91 f5 08 	lds	r25, 0x08F5
    1282:	d1 c2       	rjmp	.+1442   	; 0x1826 <xQueueGenericSend>
    1284:	08 95       	ret

00001286 <myUSART_receiveHandShakeAck>:
    1286:	91 e0       	ldi	r25, 0x01	; 1
    1288:	85 30       	cpi	r24, 0x05	; 5
    128a:	09 f0       	breq	.+2      	; 0x128e <myUSART_receiveHandShakeAck+0x8>
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	89 2f       	mov	r24, r25
    1290:	08 95       	ret

00001292 <myUSART_receiveHandShakeStart>:
    1292:	91 e0       	ldi	r25, 0x01	; 1
    1294:	86 31       	cpi	r24, 0x16	; 22
    1296:	09 f0       	breq	.+2      	; 0x129a <myUSART_receiveHandShakeStart+0x8>
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	89 2f       	mov	r24, r25
    129c:	08 95       	ret

0000129e <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    129e:	91 e0       	ldi	r25, 0x01	; 1
    12a0:	86 30       	cpi	r24, 0x06	; 6
    12a2:	09 f0       	breq	.+2      	; 0x12a6 <myUSART_receiveMessageACK+0x8>
    12a4:	90 e0       	ldi	r25, 0x00	; 0
}
    12a6:	89 2f       	mov	r24, r25
    12a8:	08 95       	ret

000012aa <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
    12aa:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
    12ac:	20 e0       	ldi	r18, 0x00	; 0
    12ae:	4f ef       	ldi	r20, 0xFF	; 255
    12b0:	5f ef       	ldi	r21, 0xFF	; 255
    12b2:	60 e0       	ldi	r22, 0x00	; 0
    12b4:	70 e0       	ldi	r23, 0x00	; 0
    12b6:	80 91 38 09 	lds	r24, 0x0938
    12ba:	90 91 39 09 	lds	r25, 0x0939
    12be:	ab d3       	rcall	.+1878   	; 0x1a16 <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
    12c0:	84 e4       	ldi	r24, 0x44	; 68
    12c2:	99 e0       	ldi	r25, 0x09	; 9
    12c4:	62 d4       	rcall	.+2244   	; 0x1b8a <ringBufferPeek>
    12c6:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
    12c8:	84 e4       	ldi	r24, 0x44	; 68
    12ca:	99 e0       	ldi	r25, 0x09	; 9
    12cc:	98 d4       	rcall	.+2352   	; 0x1bfe <ringBufferNotEmpty>
    12ce:	88 23       	and	r24, r24
    12d0:	51 f0       	breq	.+20     	; 0x12e6 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
    12d2:	20 e0       	ldi	r18, 0x00	; 0
    12d4:	40 e0       	ldi	r20, 0x00	; 0
    12d6:	50 e0       	ldi	r21, 0x00	; 0
    12d8:	60 e0       	ldi	r22, 0x00	; 0
    12da:	70 e0       	ldi	r23, 0x00	; 0
    12dc:	80 91 38 09 	lds	r24, 0x0938
    12e0:	90 91 39 09 	lds	r25, 0x0939
    12e4:	a0 d2       	rcall	.+1344   	; 0x1826 <xQueueGenericSend>
	}
	
	return data;
    12e6:	8c 2f       	mov	r24, r28
    12e8:	cf 91       	pop	r28
    12ea:	08 95       	ret

000012ec <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12ec:	31 e1       	ldi	r19, 0x11	; 17
    12ee:	fc 01       	movw	r30, r24
    12f0:	30 83       	st	Z, r19
    12f2:	31 97       	sbiw	r30, 0x01	; 1
    12f4:	22 e2       	ldi	r18, 0x22	; 34
    12f6:	20 83       	st	Z, r18
    12f8:	31 97       	sbiw	r30, 0x01	; 1
    12fa:	a3 e3       	ldi	r26, 0x33	; 51
    12fc:	a0 83       	st	Z, r26
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	60 83       	st	Z, r22
    1302:	31 97       	sbiw	r30, 0x01	; 1
    1304:	70 83       	st	Z, r23
    1306:	31 97       	sbiw	r30, 0x01	; 1
    1308:	10 82       	st	Z, r1
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	10 82       	st	Z, r1
    130e:	31 97       	sbiw	r30, 0x01	; 1
    1310:	60 e8       	ldi	r22, 0x80	; 128
    1312:	60 83       	st	Z, r22
    1314:	31 97       	sbiw	r30, 0x01	; 1
    1316:	10 82       	st	Z, r1
    1318:	31 97       	sbiw	r30, 0x01	; 1
    131a:	10 82       	st	Z, r1
    131c:	31 97       	sbiw	r30, 0x01	; 1
    131e:	10 82       	st	Z, r1
    1320:	31 97       	sbiw	r30, 0x01	; 1
    1322:	62 e0       	ldi	r22, 0x02	; 2
    1324:	60 83       	st	Z, r22
    1326:	31 97       	sbiw	r30, 0x01	; 1
    1328:	63 e0       	ldi	r22, 0x03	; 3
    132a:	60 83       	st	Z, r22
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	64 e0       	ldi	r22, 0x04	; 4
    1330:	60 83       	st	Z, r22
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	65 e0       	ldi	r22, 0x05	; 5
    1336:	60 83       	st	Z, r22
    1338:	31 97       	sbiw	r30, 0x01	; 1
    133a:	66 e0       	ldi	r22, 0x06	; 6
    133c:	60 83       	st	Z, r22
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	67 e0       	ldi	r22, 0x07	; 7
    1342:	60 83       	st	Z, r22
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	68 e0       	ldi	r22, 0x08	; 8
    1348:	60 83       	st	Z, r22
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	69 e0       	ldi	r22, 0x09	; 9
    134e:	60 83       	st	Z, r22
    1350:	31 97       	sbiw	r30, 0x01	; 1
    1352:	60 e1       	ldi	r22, 0x10	; 16
    1354:	60 83       	st	Z, r22
    1356:	31 97       	sbiw	r30, 0x01	; 1
    1358:	30 83       	st	Z, r19
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	32 e1       	ldi	r19, 0x12	; 18
    135e:	30 83       	st	Z, r19
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	33 e1       	ldi	r19, 0x13	; 19
    1364:	30 83       	st	Z, r19
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	34 e1       	ldi	r19, 0x14	; 20
    136a:	30 83       	st	Z, r19
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	35 e1       	ldi	r19, 0x15	; 21
    1370:	30 83       	st	Z, r19
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	36 e1       	ldi	r19, 0x16	; 22
    1376:	30 83       	st	Z, r19
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	37 e1       	ldi	r19, 0x17	; 23
    137c:	30 83       	st	Z, r19
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	38 e1       	ldi	r19, 0x18	; 24
    1382:	30 83       	st	Z, r19
    1384:	31 97       	sbiw	r30, 0x01	; 1
    1386:	39 e1       	ldi	r19, 0x19	; 25
    1388:	30 83       	st	Z, r19
    138a:	31 97       	sbiw	r30, 0x01	; 1
    138c:	30 e2       	ldi	r19, 0x20	; 32
    138e:	30 83       	st	Z, r19
    1390:	31 97       	sbiw	r30, 0x01	; 1
    1392:	31 e2       	ldi	r19, 0x21	; 33
    1394:	30 83       	st	Z, r19
    1396:	31 97       	sbiw	r30, 0x01	; 1
    1398:	20 83       	st	Z, r18
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	23 e2       	ldi	r18, 0x23	; 35
    139e:	20 83       	st	Z, r18
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	40 83       	st	Z, r20
    13a4:	31 97       	sbiw	r30, 0x01	; 1
    13a6:	50 83       	st	Z, r21
    13a8:	31 97       	sbiw	r30, 0x01	; 1
    13aa:	26 e2       	ldi	r18, 0x26	; 38
    13ac:	20 83       	st	Z, r18
    13ae:	31 97       	sbiw	r30, 0x01	; 1
    13b0:	27 e2       	ldi	r18, 0x27	; 39
    13b2:	20 83       	st	Z, r18
    13b4:	31 97       	sbiw	r30, 0x01	; 1
    13b6:	28 e2       	ldi	r18, 0x28	; 40
    13b8:	20 83       	st	Z, r18
    13ba:	31 97       	sbiw	r30, 0x01	; 1
    13bc:	29 e2       	ldi	r18, 0x29	; 41
    13be:	20 83       	st	Z, r18
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	20 e3       	ldi	r18, 0x30	; 48
    13c4:	20 83       	st	Z, r18
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	21 e3       	ldi	r18, 0x31	; 49
    13ca:	20 83       	st	Z, r18
    13cc:	89 97       	sbiw	r24, 0x29	; 41
    13ce:	08 95       	ret

000013d0 <xPortStartScheduler>:
    13d0:	82 e0       	ldi	r24, 0x02	; 2
    13d2:	84 bd       	out	0x24, r24	; 36
    13d4:	16 bc       	out	0x26, r1	; 38
    13d6:	80 e3       	ldi	r24, 0x30	; 48
    13d8:	87 bd       	out	0x27, r24	; 39
    13da:	ee e6       	ldi	r30, 0x6E	; 110
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	80 81       	ld	r24, Z
    13e0:	82 60       	ori	r24, 0x02	; 2
    13e2:	80 83       	st	Z, r24
    13e4:	83 e0       	ldi	r24, 0x03	; 3
    13e6:	85 bd       	out	0x25, r24	; 37
    13e8:	a0 91 8f 08 	lds	r26, 0x088F
    13ec:	b0 91 90 08 	lds	r27, 0x0890
    13f0:	cd 91       	ld	r28, X+
    13f2:	cd bf       	out	0x3d, r28	; 61
    13f4:	dd 91       	ld	r29, X+
    13f6:	de bf       	out	0x3e, r29	; 62
    13f8:	ff 91       	pop	r31
    13fa:	ef 91       	pop	r30
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	bf 91       	pop	r27
    1402:	af 91       	pop	r26
    1404:	9f 91       	pop	r25
    1406:	8f 91       	pop	r24
    1408:	7f 91       	pop	r23
    140a:	6f 91       	pop	r22
    140c:	5f 91       	pop	r21
    140e:	4f 91       	pop	r20
    1410:	3f 91       	pop	r19
    1412:	2f 91       	pop	r18
    1414:	1f 91       	pop	r17
    1416:	0f 91       	pop	r16
    1418:	ff 90       	pop	r15
    141a:	ef 90       	pop	r14
    141c:	df 90       	pop	r13
    141e:	cf 90       	pop	r12
    1420:	bf 90       	pop	r11
    1422:	af 90       	pop	r10
    1424:	9f 90       	pop	r9
    1426:	8f 90       	pop	r8
    1428:	7f 90       	pop	r7
    142a:	6f 90       	pop	r6
    142c:	5f 90       	pop	r5
    142e:	4f 90       	pop	r4
    1430:	3f 90       	pop	r3
    1432:	2f 90       	pop	r2
    1434:	1f 90       	pop	r1
    1436:	0f 90       	pop	r0
    1438:	0c be       	out	0x3c, r0	; 60
    143a:	0f 90       	pop	r0
    143c:	0b be       	out	0x3b, r0	; 59
    143e:	0f 90       	pop	r0
    1440:	0f be       	out	0x3f, r0	; 63
    1442:	0f 90       	pop	r0
    1444:	08 95       	ret
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	08 95       	ret

0000144a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    144a:	0f 92       	push	r0
    144c:	0f b6       	in	r0, 0x3f	; 63
    144e:	f8 94       	cli
    1450:	0f 92       	push	r0
    1452:	0b b6       	in	r0, 0x3b	; 59
    1454:	0f 92       	push	r0
    1456:	0c b6       	in	r0, 0x3c	; 60
    1458:	0f 92       	push	r0
    145a:	1f 92       	push	r1
    145c:	11 24       	eor	r1, r1
    145e:	2f 92       	push	r2
    1460:	3f 92       	push	r3
    1462:	4f 92       	push	r4
    1464:	5f 92       	push	r5
    1466:	6f 92       	push	r6
    1468:	7f 92       	push	r7
    146a:	8f 92       	push	r8
    146c:	9f 92       	push	r9
    146e:	af 92       	push	r10
    1470:	bf 92       	push	r11
    1472:	cf 92       	push	r12
    1474:	df 92       	push	r13
    1476:	ef 92       	push	r14
    1478:	ff 92       	push	r15
    147a:	0f 93       	push	r16
    147c:	1f 93       	push	r17
    147e:	2f 93       	push	r18
    1480:	3f 93       	push	r19
    1482:	4f 93       	push	r20
    1484:	5f 93       	push	r21
    1486:	6f 93       	push	r22
    1488:	7f 93       	push	r23
    148a:	8f 93       	push	r24
    148c:	9f 93       	push	r25
    148e:	af 93       	push	r26
    1490:	bf 93       	push	r27
    1492:	cf 93       	push	r28
    1494:	df 93       	push	r29
    1496:	ef 93       	push	r30
    1498:	ff 93       	push	r31
    149a:	a0 91 8f 08 	lds	r26, 0x088F
    149e:	b0 91 90 08 	lds	r27, 0x0890
    14a2:	0d b6       	in	r0, 0x3d	; 61
    14a4:	0d 92       	st	X+, r0
    14a6:	0e b6       	in	r0, 0x3e	; 62
    14a8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14aa:	5b d7       	rcall	.+3766   	; 0x2362 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14ac:	a0 91 8f 08 	lds	r26, 0x088F
    14b0:	b0 91 90 08 	lds	r27, 0x0890
    14b4:	cd 91       	ld	r28, X+
    14b6:	cd bf       	out	0x3d, r28	; 61
    14b8:	dd 91       	ld	r29, X+
    14ba:	de bf       	out	0x3e, r29	; 62
    14bc:	ff 91       	pop	r31
    14be:	ef 91       	pop	r30
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	bf 91       	pop	r27
    14c6:	af 91       	pop	r26
    14c8:	9f 91       	pop	r25
    14ca:	8f 91       	pop	r24
    14cc:	7f 91       	pop	r23
    14ce:	6f 91       	pop	r22
    14d0:	5f 91       	pop	r21
    14d2:	4f 91       	pop	r20
    14d4:	3f 91       	pop	r19
    14d6:	2f 91       	pop	r18
    14d8:	1f 91       	pop	r17
    14da:	0f 91       	pop	r16
    14dc:	ff 90       	pop	r15
    14de:	ef 90       	pop	r14
    14e0:	df 90       	pop	r13
    14e2:	cf 90       	pop	r12
    14e4:	bf 90       	pop	r11
    14e6:	af 90       	pop	r10
    14e8:	9f 90       	pop	r9
    14ea:	8f 90       	pop	r8
    14ec:	7f 90       	pop	r7
    14ee:	6f 90       	pop	r6
    14f0:	5f 90       	pop	r5
    14f2:	4f 90       	pop	r4
    14f4:	3f 90       	pop	r3
    14f6:	2f 90       	pop	r2
    14f8:	1f 90       	pop	r1
    14fa:	0f 90       	pop	r0
    14fc:	0c be       	out	0x3c, r0	; 60
    14fe:	0f 90       	pop	r0
    1500:	0b be       	out	0x3b, r0	; 59
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63
    1506:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1508:	08 95       	ret

0000150a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    150a:	0f 92       	push	r0
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	0f 92       	push	r0
    1512:	0b b6       	in	r0, 0x3b	; 59
    1514:	0f 92       	push	r0
    1516:	0c b6       	in	r0, 0x3c	; 60
    1518:	0f 92       	push	r0
    151a:	1f 92       	push	r1
    151c:	11 24       	eor	r1, r1
    151e:	2f 92       	push	r2
    1520:	3f 92       	push	r3
    1522:	4f 92       	push	r4
    1524:	5f 92       	push	r5
    1526:	6f 92       	push	r6
    1528:	7f 92       	push	r7
    152a:	8f 92       	push	r8
    152c:	9f 92       	push	r9
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	2f 93       	push	r18
    1540:	3f 93       	push	r19
    1542:	4f 93       	push	r20
    1544:	5f 93       	push	r21
    1546:	6f 93       	push	r22
    1548:	7f 93       	push	r23
    154a:	8f 93       	push	r24
    154c:	9f 93       	push	r25
    154e:	af 93       	push	r26
    1550:	bf 93       	push	r27
    1552:	cf 93       	push	r28
    1554:	df 93       	push	r29
    1556:	ef 93       	push	r30
    1558:	ff 93       	push	r31
    155a:	a0 91 8f 08 	lds	r26, 0x088F
    155e:	b0 91 90 08 	lds	r27, 0x0890
    1562:	0d b6       	in	r0, 0x3d	; 61
    1564:	0d 92       	st	X+, r0
    1566:	0e b6       	in	r0, 0x3e	; 62
    1568:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    156a:	45 d5       	rcall	.+2698   	; 0x1ff6 <xTaskIncrementTick>
    156c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    156e:	f9 d6       	rcall	.+3570   	; 0x2362 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1570:	a0 91 8f 08 	lds	r26, 0x088F
    1574:	b0 91 90 08 	lds	r27, 0x0890
    1578:	cd 91       	ld	r28, X+
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	dd 91       	ld	r29, X+
    157e:	de bf       	out	0x3e, r29	; 62
    1580:	ff 91       	pop	r31
    1582:	ef 91       	pop	r30
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	bf 91       	pop	r27
    158a:	af 91       	pop	r26
    158c:	9f 91       	pop	r25
    158e:	8f 91       	pop	r24
    1590:	7f 91       	pop	r23
    1592:	6f 91       	pop	r22
    1594:	5f 91       	pop	r21
    1596:	4f 91       	pop	r20
    1598:	3f 91       	pop	r19
    159a:	2f 91       	pop	r18
    159c:	1f 91       	pop	r17
    159e:	0f 91       	pop	r16
    15a0:	ff 90       	pop	r15
    15a2:	ef 90       	pop	r14
    15a4:	df 90       	pop	r13
    15a6:	cf 90       	pop	r12
    15a8:	bf 90       	pop	r11
    15aa:	af 90       	pop	r10
    15ac:	9f 90       	pop	r9
    15ae:	8f 90       	pop	r8
    15b0:	7f 90       	pop	r7
    15b2:	6f 90       	pop	r6
    15b4:	5f 90       	pop	r5
    15b6:	4f 90       	pop	r4
    15b8:	3f 90       	pop	r3
    15ba:	2f 90       	pop	r2
    15bc:	1f 90       	pop	r1
    15be:	0f 90       	pop	r0
    15c0:	0c be       	out	0x3c, r0	; 60
    15c2:	0f 90       	pop	r0
    15c4:	0b be       	out	0x3b, r0	; 59
    15c6:	0f 90       	pop	r0
    15c8:	0f be       	out	0x3f, r0	; 63
    15ca:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15cc:	08 95       	ret

000015ce <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    15ce:	9d df       	rcall	.-198    	; 0x150a <vPortYieldFromTick>
		 asm volatile ("reti");
    15d0:	18 95       	reti

000015d2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    15d2:	1f 93       	push	r17
    15d4:	cf 93       	push	r28
    15d6:	df 93       	push	r29
    15d8:	ec 01       	movw	r28, r24
    15da:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    15dc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    15de:	81 11       	cpse	r24, r1
    15e0:	0c c0       	rjmp	.+24     	; 0x15fa <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    15e2:	88 81       	ld	r24, Y
    15e4:	99 81       	ldd	r25, Y+1	; 0x01
    15e6:	89 2b       	or	r24, r25
    15e8:	09 f0       	breq	.+2      	; 0x15ec <prvCopyDataToQueue+0x1a>
    15ea:	47 c0       	rjmp	.+142    	; 0x167a <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    15ec:	8a 81       	ldd	r24, Y+2	; 0x02
    15ee:	9b 81       	ldd	r25, Y+3	; 0x03
    15f0:	0e 94 74 13 	call	0x26e8	; 0x26e8 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    15f4:	1b 82       	std	Y+3, r1	; 0x03
    15f6:	1a 82       	std	Y+2, r1	; 0x02
    15f8:	47 c0       	rjmp	.+142    	; 0x1688 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    15fa:	41 11       	cpse	r20, r1
    15fc:	18 c0       	rjmp	.+48     	; 0x162e <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    15fe:	48 2f       	mov	r20, r24
    1600:	50 e0       	ldi	r21, 0x00	; 0
    1602:	8c 81       	ldd	r24, Y+4	; 0x04
    1604:	9d 81       	ldd	r25, Y+5	; 0x05
    1606:	0e 94 40 17 	call	0x2e80	; 0x2e80 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    160a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    160c:	8c 81       	ldd	r24, Y+4	; 0x04
    160e:	9d 81       	ldd	r25, Y+5	; 0x05
    1610:	82 0f       	add	r24, r18
    1612:	91 1d       	adc	r25, r1
    1614:	9d 83       	std	Y+5, r25	; 0x05
    1616:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1618:	2a 81       	ldd	r18, Y+2	; 0x02
    161a:	3b 81       	ldd	r19, Y+3	; 0x03
    161c:	82 17       	cp	r24, r18
    161e:	93 07       	cpc	r25, r19
    1620:	70 f1       	brcs	.+92     	; 0x167e <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1622:	88 81       	ld	r24, Y
    1624:	99 81       	ldd	r25, Y+1	; 0x01
    1626:	9d 83       	std	Y+5, r25	; 0x05
    1628:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	2d c0       	rjmp	.+90     	; 0x1688 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    162e:	48 2f       	mov	r20, r24
    1630:	50 e0       	ldi	r21, 0x00	; 0
    1632:	8e 81       	ldd	r24, Y+6	; 0x06
    1634:	9f 81       	ldd	r25, Y+7	; 0x07
    1636:	0e 94 40 17 	call	0x2e80	; 0x2e80 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    163a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    163c:	30 e0       	ldi	r19, 0x00	; 0
    163e:	31 95       	neg	r19
    1640:	21 95       	neg	r18
    1642:	31 09       	sbc	r19, r1
    1644:	8e 81       	ldd	r24, Y+6	; 0x06
    1646:	9f 81       	ldd	r25, Y+7	; 0x07
    1648:	82 0f       	add	r24, r18
    164a:	93 1f       	adc	r25, r19
    164c:	9f 83       	std	Y+7, r25	; 0x07
    164e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1650:	68 81       	ld	r22, Y
    1652:	79 81       	ldd	r23, Y+1	; 0x01
    1654:	86 17       	cp	r24, r22
    1656:	97 07       	cpc	r25, r23
    1658:	30 f4       	brcc	.+12     	; 0x1666 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    165a:	8a 81       	ldd	r24, Y+2	; 0x02
    165c:	9b 81       	ldd	r25, Y+3	; 0x03
    165e:	28 0f       	add	r18, r24
    1660:	39 1f       	adc	r19, r25
    1662:	3f 83       	std	Y+7, r19	; 0x07
    1664:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1666:	12 30       	cpi	r17, 0x02	; 2
    1668:	61 f4       	brne	.+24     	; 0x1682 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    166a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    166c:	88 23       	and	r24, r24
    166e:	59 f0       	breq	.+22     	; 0x1686 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1670:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1672:	81 50       	subi	r24, 0x01	; 1
    1674:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1676:	80 e0       	ldi	r24, 0x00	; 0
    1678:	07 c0       	rjmp	.+14     	; 0x1688 <prvCopyDataToQueue+0xb6>
    167a:	80 e0       	ldi	r24, 0x00	; 0
    167c:	05 c0       	rjmp	.+10     	; 0x1688 <prvCopyDataToQueue+0xb6>
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	03 c0       	rjmp	.+6      	; 0x1688 <prvCopyDataToQueue+0xb6>
    1682:	80 e0       	ldi	r24, 0x00	; 0
    1684:	01 c0       	rjmp	.+2      	; 0x1688 <prvCopyDataToQueue+0xb6>
    1686:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1688:	9a 8d       	ldd	r25, Y+26	; 0x1a
    168a:	9f 5f       	subi	r25, 0xFF	; 255
    168c:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    168e:	df 91       	pop	r29
    1690:	cf 91       	pop	r28
    1692:	1f 91       	pop	r17
    1694:	08 95       	ret

00001696 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1696:	fc 01       	movw	r30, r24
    1698:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    169a:	44 8d       	ldd	r20, Z+28	; 0x1c
    169c:	44 23       	and	r20, r20
    169e:	a1 f0       	breq	.+40     	; 0x16c8 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    16a0:	50 e0       	ldi	r21, 0x00	; 0
    16a2:	26 81       	ldd	r18, Z+6	; 0x06
    16a4:	37 81       	ldd	r19, Z+7	; 0x07
    16a6:	24 0f       	add	r18, r20
    16a8:	35 1f       	adc	r19, r21
    16aa:	37 83       	std	Z+7, r19	; 0x07
    16ac:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    16ae:	62 81       	ldd	r22, Z+2	; 0x02
    16b0:	73 81       	ldd	r23, Z+3	; 0x03
    16b2:	26 17       	cp	r18, r22
    16b4:	37 07       	cpc	r19, r23
    16b6:	20 f0       	brcs	.+8      	; 0x16c0 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    16b8:	20 81       	ld	r18, Z
    16ba:	31 81       	ldd	r19, Z+1	; 0x01
    16bc:	37 83       	std	Z+7, r19	; 0x07
    16be:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    16c0:	66 81       	ldd	r22, Z+6	; 0x06
    16c2:	77 81       	ldd	r23, Z+7	; 0x07
    16c4:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <memcpy>
    16c8:	08 95       	ret

000016ca <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    16ca:	0f 93       	push	r16
    16cc:	1f 93       	push	r17
    16ce:	cf 93       	push	r28
    16d0:	df 93       	push	r29
    16d2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    16d4:	0f b6       	in	r0, 0x3f	; 63
    16d6:	f8 94       	cli
    16d8:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    16da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16dc:	18 16       	cp	r1, r24
    16de:	a4 f4       	brge	.+40     	; 0x1708 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16e0:	89 89       	ldd	r24, Y+17	; 0x11
    16e2:	88 23       	and	r24, r24
    16e4:	89 f0       	breq	.+34     	; 0x1708 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16e6:	8e 01       	movw	r16, r28
    16e8:	0f 5e       	subi	r16, 0xEF	; 239
    16ea:	1f 4f       	sbci	r17, 0xFF	; 255
    16ec:	03 c0       	rjmp	.+6      	; 0x16f4 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16ee:	89 89       	ldd	r24, Y+17	; 0x11
    16f0:	88 23       	and	r24, r24
    16f2:	51 f0       	breq	.+20     	; 0x1708 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16f4:	c8 01       	movw	r24, r16
    16f6:	0b d7       	rcall	.+3606   	; 0x250e <xTaskRemoveFromEventList>
    16f8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    16fa:	94 d7       	rcall	.+3880   	; 0x2624 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    16fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16fe:	81 50       	subi	r24, 0x01	; 1
    1700:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1702:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1704:	18 16       	cp	r1, r24
    1706:	9c f3       	brlt	.-26     	; 0x16ee <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1708:	8f ef       	ldi	r24, 0xFF	; 255
    170a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    170c:	0f 90       	pop	r0
    170e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	f8 94       	cli
    1714:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1716:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1718:	18 16       	cp	r1, r24
    171a:	a4 f4       	brge	.+40     	; 0x1744 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    171c:	88 85       	ldd	r24, Y+8	; 0x08
    171e:	88 23       	and	r24, r24
    1720:	89 f0       	breq	.+34     	; 0x1744 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1722:	8e 01       	movw	r16, r28
    1724:	08 5f       	subi	r16, 0xF8	; 248
    1726:	1f 4f       	sbci	r17, 0xFF	; 255
    1728:	03 c0       	rjmp	.+6      	; 0x1730 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    172a:	88 85       	ldd	r24, Y+8	; 0x08
    172c:	88 23       	and	r24, r24
    172e:	51 f0       	breq	.+20     	; 0x1744 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1730:	c8 01       	movw	r24, r16
    1732:	ed d6       	rcall	.+3546   	; 0x250e <xTaskRemoveFromEventList>
    1734:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1736:	76 d7       	rcall	.+3820   	; 0x2624 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1738:	8d 8d       	ldd	r24, Y+29	; 0x1d
    173a:	81 50       	subi	r24, 0x01	; 1
    173c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    173e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1740:	18 16       	cp	r1, r24
    1742:	9c f3       	brlt	.-26     	; 0x172a <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1744:	8f ef       	ldi	r24, 0xFF	; 255
    1746:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1748:	0f 90       	pop	r0
    174a:	0f be       	out	0x3f, r0	; 63
}
    174c:	df 91       	pop	r29
    174e:	cf 91       	pop	r28
    1750:	1f 91       	pop	r17
    1752:	0f 91       	pop	r16
    1754:	08 95       	ret

00001756 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    175c:	0f b6       	in	r0, 0x3f	; 63
    175e:	f8 94       	cli
    1760:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1762:	88 81       	ld	r24, Y
    1764:	99 81       	ldd	r25, Y+1	; 0x01
    1766:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1768:	30 e0       	ldi	r19, 0x00	; 0
    176a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    176c:	72 9f       	mul	r23, r18
    176e:	a0 01       	movw	r20, r0
    1770:	73 9f       	mul	r23, r19
    1772:	50 0d       	add	r21, r0
    1774:	11 24       	eor	r1, r1
    1776:	fc 01       	movw	r30, r24
    1778:	e4 0f       	add	r30, r20
    177a:	f5 1f       	adc	r31, r21
    177c:	fb 83       	std	Y+3, r31	; 0x03
    177e:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1780:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1782:	9d 83       	std	Y+5, r25	; 0x05
    1784:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1786:	42 1b       	sub	r20, r18
    1788:	53 0b       	sbc	r21, r19
    178a:	84 0f       	add	r24, r20
    178c:	95 1f       	adc	r25, r21
    178e:	9f 83       	std	Y+7, r25	; 0x07
    1790:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1792:	8f ef       	ldi	r24, 0xFF	; 255
    1794:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1796:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1798:	61 11       	cpse	r22, r1
    179a:	0a c0       	rjmp	.+20     	; 0x17b0 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    179c:	88 85       	ldd	r24, Y+8	; 0x08
    179e:	88 23       	and	r24, r24
    17a0:	79 f0       	breq	.+30     	; 0x17c0 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17a2:	ce 01       	movw	r24, r28
    17a4:	08 96       	adiw	r24, 0x08	; 8
    17a6:	b3 d6       	rcall	.+3430   	; 0x250e <xTaskRemoveFromEventList>
    17a8:	81 30       	cpi	r24, 0x01	; 1
    17aa:	51 f4       	brne	.+20     	; 0x17c0 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    17ac:	4e de       	rcall	.-868    	; 0x144a <vPortYield>
    17ae:	08 c0       	rjmp	.+16     	; 0x17c0 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    17b0:	ce 01       	movw	r24, r28
    17b2:	08 96       	adiw	r24, 0x08	; 8
    17b4:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    17b8:	ce 01       	movw	r24, r28
    17ba:	41 96       	adiw	r24, 0x11	; 17
    17bc:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    17c0:	0f 90       	pop	r0
    17c2:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	df 91       	pop	r29
    17c8:	cf 91       	pop	r28
    17ca:	08 95       	ret

000017cc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    17cc:	0f 93       	push	r16
    17ce:	1f 93       	push	r17
    17d0:	cf 93       	push	r28
    17d2:	df 93       	push	r29
    17d4:	18 2f       	mov	r17, r24
    17d6:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    17d8:	88 23       	and	r24, r24
    17da:	e9 f0       	breq	.+58     	; 0x1816 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    17dc:	8f e1       	ldi	r24, 0x1F	; 31
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	0e 94 20 03 	call	0x640	; 0x640 <pvPortMalloc>
    17e4:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17e6:	00 97       	sbiw	r24, 0x00	; 0
    17e8:	c1 f0       	breq	.+48     	; 0x181a <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17ea:	10 9f       	mul	r17, r16
    17ec:	c0 01       	movw	r24, r0
    17ee:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    17f0:	01 96       	adiw	r24, 0x01	; 1
    17f2:	0e 94 20 03 	call	0x640	; 0x640 <pvPortMalloc>
    17f6:	99 83       	std	Y+1, r25	; 0x01
    17f8:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    17fa:	89 2b       	or	r24, r25
    17fc:	31 f0       	breq	.+12     	; 0x180a <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    17fe:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1800:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1802:	61 e0       	ldi	r22, 0x01	; 1
    1804:	ce 01       	movw	r24, r28
    1806:	a7 df       	rcall	.-178    	; 0x1756 <xQueueGenericReset>
    1808:	08 c0       	rjmp	.+16     	; 0x181a <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    180a:	ce 01       	movw	r24, r28
    180c:	0e 94 55 03 	call	0x6aa	; 0x6aa <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1810:	c0 e0       	ldi	r28, 0x00	; 0
    1812:	d0 e0       	ldi	r29, 0x00	; 0
    1814:	02 c0       	rjmp	.+4      	; 0x181a <xQueueGenericCreate+0x4e>
    1816:	c0 e0       	ldi	r28, 0x00	; 0
    1818:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    181a:	ce 01       	movw	r24, r28
    181c:	df 91       	pop	r29
    181e:	cf 91       	pop	r28
    1820:	1f 91       	pop	r17
    1822:	0f 91       	pop	r16
    1824:	08 95       	ret

00001826 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1826:	9f 92       	push	r9
    1828:	af 92       	push	r10
    182a:	bf 92       	push	r11
    182c:	cf 92       	push	r12
    182e:	df 92       	push	r13
    1830:	ef 92       	push	r14
    1832:	ff 92       	push	r15
    1834:	0f 93       	push	r16
    1836:	1f 93       	push	r17
    1838:	cf 93       	push	r28
    183a:	df 93       	push	r29
    183c:	00 d0       	rcall	.+0      	; 0x183e <xQueueGenericSend+0x18>
    183e:	1f 92       	push	r1
    1840:	1f 92       	push	r1
    1842:	cd b7       	in	r28, 0x3d	; 61
    1844:	de b7       	in	r29, 0x3e	; 62
    1846:	8c 01       	movw	r16, r24
    1848:	6b 01       	movw	r12, r22
    184a:	5d 83       	std	Y+5, r21	; 0x05
    184c:	4c 83       	std	Y+4, r20	; 0x04
    184e:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1850:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1852:	99 24       	eor	r9, r9
    1854:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1856:	7c 01       	movw	r14, r24
    1858:	88 e0       	ldi	r24, 0x08	; 8
    185a:	e8 0e       	add	r14, r24
    185c:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1864:	f8 01       	movw	r30, r16
    1866:	92 8d       	ldd	r25, Z+26	; 0x1a
    1868:	83 8d       	ldd	r24, Z+27	; 0x1b
    186a:	98 17       	cp	r25, r24
    186c:	18 f0       	brcs	.+6      	; 0x1874 <xQueueGenericSend+0x4e>
    186e:	f2 e0       	ldi	r31, 0x02	; 2
    1870:	af 12       	cpse	r10, r31
    1872:	15 c0       	rjmp	.+42     	; 0x189e <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1874:	4a 2d       	mov	r20, r10
    1876:	b6 01       	movw	r22, r12
    1878:	c8 01       	movw	r24, r16
    187a:	ab de       	rcall	.-682    	; 0x15d2 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    187c:	f8 01       	movw	r30, r16
    187e:	91 89       	ldd	r25, Z+17	; 0x11
    1880:	99 23       	and	r25, r25
    1882:	39 f0       	breq	.+14     	; 0x1892 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1884:	c8 01       	movw	r24, r16
    1886:	41 96       	adiw	r24, 0x11	; 17
    1888:	42 d6       	rcall	.+3204   	; 0x250e <xTaskRemoveFromEventList>
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	21 f4       	brne	.+8      	; 0x1896 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    188e:	dd dd       	rcall	.-1094   	; 0x144a <vPortYield>
    1890:	02 c0       	rjmp	.+4      	; 0x1896 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1892:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1894:	da dd       	rcall	.-1100   	; 0x144a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1896:	0f 90       	pop	r0
    1898:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	46 c0       	rjmp	.+140    	; 0x192a <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    189e:	ec 81       	ldd	r30, Y+4	; 0x04
    18a0:	fd 81       	ldd	r31, Y+5	; 0x05
    18a2:	ef 2b       	or	r30, r31
    18a4:	21 f4       	brne	.+8      	; 0x18ae <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18a6:	0f 90       	pop	r0
    18a8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    18aa:	80 e0       	ldi	r24, 0x00	; 0
    18ac:	3e c0       	rjmp	.+124    	; 0x192a <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    18ae:	b1 10       	cpse	r11, r1
    18b0:	04 c0       	rjmp	.+8      	; 0x18ba <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18b2:	ce 01       	movw	r24, r28
    18b4:	01 96       	adiw	r24, 0x01	; 1
    18b6:	73 d6       	rcall	.+3302   	; 0x259e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18b8:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    18ba:	0f 90       	pop	r0
    18bc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18be:	86 d3       	rcall	.+1804   	; 0x1fcc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
    18c6:	f8 01       	movw	r30, r16
    18c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    18ca:	8f 3f       	cpi	r24, 0xFF	; 255
    18cc:	09 f4       	brne	.+2      	; 0x18d0 <xQueueGenericSend+0xaa>
    18ce:	15 8e       	std	Z+29, r1	; 0x1d
    18d0:	f8 01       	movw	r30, r16
    18d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    18d4:	8f 3f       	cpi	r24, 0xFF	; 255
    18d6:	09 f4       	brne	.+2      	; 0x18da <xQueueGenericSend+0xb4>
    18d8:	16 8e       	std	Z+30, r1	; 0x1e
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18de:	be 01       	movw	r22, r28
    18e0:	6c 5f       	subi	r22, 0xFC	; 252
    18e2:	7f 4f       	sbci	r23, 0xFF	; 255
    18e4:	ce 01       	movw	r24, r28
    18e6:	01 96       	adiw	r24, 0x01	; 1
    18e8:	65 d6       	rcall	.+3274   	; 0x25b4 <xTaskCheckForTimeOut>
    18ea:	81 11       	cpse	r24, r1
    18ec:	1a c0       	rjmp	.+52     	; 0x1922 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    18ee:	0f b6       	in	r0, 0x3f	; 63
    18f0:	f8 94       	cli
    18f2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    18f4:	f8 01       	movw	r30, r16
    18f6:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    18fc:	f8 01       	movw	r30, r16
    18fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1900:	98 13       	cpse	r25, r24
    1902:	0b c0       	rjmp	.+22     	; 0x191a <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1904:	6c 81       	ldd	r22, Y+4	; 0x04
    1906:	7d 81       	ldd	r23, Y+5	; 0x05
    1908:	c7 01       	movw	r24, r14
    190a:	d6 d5       	rcall	.+2988   	; 0x24b8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    190c:	c8 01       	movw	r24, r16
    190e:	dd de       	rcall	.-582    	; 0x16ca <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1910:	30 d4       	rcall	.+2144   	; 0x2172 <xTaskResumeAll>
    1912:	81 11       	cpse	r24, r1
    1914:	a4 cf       	rjmp	.-184    	; 0x185e <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1916:	99 dd       	rcall	.-1230   	; 0x144a <vPortYield>
    1918:	a2 cf       	rjmp	.-188    	; 0x185e <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    191a:	c8 01       	movw	r24, r16
    191c:	d6 de       	rcall	.-596    	; 0x16ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    191e:	29 d4       	rcall	.+2130   	; 0x2172 <xTaskResumeAll>
    1920:	9e cf       	rjmp	.-196    	; 0x185e <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1922:	c8 01       	movw	r24, r16
    1924:	d2 de       	rcall	.-604    	; 0x16ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1926:	25 d4       	rcall	.+2122   	; 0x2172 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1928:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    192a:	0f 90       	pop	r0
    192c:	0f 90       	pop	r0
    192e:	0f 90       	pop	r0
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	df 91       	pop	r29
    1936:	cf 91       	pop	r28
    1938:	1f 91       	pop	r17
    193a:	0f 91       	pop	r16
    193c:	ff 90       	pop	r15
    193e:	ef 90       	pop	r14
    1940:	df 90       	pop	r13
    1942:	cf 90       	pop	r12
    1944:	bf 90       	pop	r11
    1946:	af 90       	pop	r10
    1948:	9f 90       	pop	r9
    194a:	08 95       	ret

0000194c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    194c:	cf 93       	push	r28
    194e:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1950:	8f e1       	ldi	r24, 0x1F	; 31
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	0e 94 20 03 	call	0x640	; 0x640 <pvPortMalloc>
    1958:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    195a:	00 97       	sbiw	r24, 0x00	; 0
    195c:	f1 f0       	breq	.+60     	; 0x199a <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    195e:	1b 82       	std	Y+3, r1	; 0x03
    1960:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1962:	19 82       	std	Y+1, r1	; 0x01
    1964:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1966:	1d 82       	std	Y+5, r1	; 0x05
    1968:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    196a:	1f 82       	std	Y+7, r1	; 0x07
    196c:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    196e:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1970:	81 e0       	ldi	r24, 0x01	; 1
    1972:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1974:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1976:	8f ef       	ldi	r24, 0xFF	; 255
    1978:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    197a:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    197c:	ce 01       	movw	r24, r28
    197e:	08 96       	adiw	r24, 0x08	; 8
    1980:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1984:	ce 01       	movw	r24, r28
    1986:	41 96       	adiw	r24, 0x11	; 17
    1988:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    198c:	20 e0       	ldi	r18, 0x00	; 0
    198e:	40 e0       	ldi	r20, 0x00	; 0
    1990:	50 e0       	ldi	r21, 0x00	; 0
    1992:	60 e0       	ldi	r22, 0x00	; 0
    1994:	70 e0       	ldi	r23, 0x00	; 0
    1996:	ce 01       	movw	r24, r28
    1998:	46 df       	rcall	.-372    	; 0x1826 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    199a:	ce 01       	movw	r24, r28
    199c:	df 91       	pop	r29
    199e:	cf 91       	pop	r28
    19a0:	08 95       	ret

000019a2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	ec 01       	movw	r28, r24
    19ac:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    19ae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19b0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19b2:	98 17       	cp	r25, r24
    19b4:	10 f0       	brcs	.+4      	; 0x19ba <xQueueGenericSendFromISR+0x18>
    19b6:	22 30       	cpi	r18, 0x02	; 2
    19b8:	11 f5       	brne	.+68     	; 0x19fe <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    19ba:	42 2f       	mov	r20, r18
    19bc:	ce 01       	movw	r24, r28
    19be:	09 de       	rcall	.-1006   	; 0x15d2 <prvCopyDataToQueue>
    19c0:	88 23       	and	r24, r24
    19c2:	31 f0       	breq	.+12     	; 0x19d0 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    19c4:	01 15       	cp	r16, r1
    19c6:	11 05       	cpc	r17, r1
    19c8:	19 f0       	breq	.+6      	; 0x19d0 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    19ca:	81 e0       	ldi	r24, 0x01	; 1
    19cc:	f8 01       	movw	r30, r16
    19ce:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    19d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19d2:	8f 3f       	cpi	r24, 0xFF	; 255
    19d4:	79 f4       	brne	.+30     	; 0x19f4 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19d6:	89 89       	ldd	r24, Y+17	; 0x11
    19d8:	88 23       	and	r24, r24
    19da:	99 f0       	breq	.+38     	; 0x1a02 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19dc:	ce 01       	movw	r24, r28
    19de:	41 96       	adiw	r24, 0x11	; 17
    19e0:	96 d5       	rcall	.+2860   	; 0x250e <xTaskRemoveFromEventList>
    19e2:	88 23       	and	r24, r24
    19e4:	81 f0       	breq	.+32     	; 0x1a06 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    19e6:	01 15       	cp	r16, r1
    19e8:	11 05       	cpc	r17, r1
    19ea:	79 f0       	breq	.+30     	; 0x1a0a <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	f8 01       	movw	r30, r16
    19f0:	80 83       	st	Z, r24
    19f2:	0c c0       	rjmp	.+24     	; 0x1a0c <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    19f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19f6:	8f 5f       	subi	r24, 0xFF	; 255
    19f8:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	07 c0       	rjmp	.+14     	; 0x1a0c <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19fe:	80 e0       	ldi	r24, 0x00	; 0
    1a00:	05 c0       	rjmp	.+10     	; 0x1a0c <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	03 c0       	rjmp	.+6      	; 0x1a0c <xQueueGenericSendFromISR+0x6a>
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	01 c0       	rjmp	.+2      	; 0x1a0c <xQueueGenericSendFromISR+0x6a>
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a0c:	df 91       	pop	r29
    1a0e:	cf 91       	pop	r28
    1a10:	1f 91       	pop	r17
    1a12:	0f 91       	pop	r16
    1a14:	08 95       	ret

00001a16 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a16:	9f 92       	push	r9
    1a18:	af 92       	push	r10
    1a1a:	bf 92       	push	r11
    1a1c:	cf 92       	push	r12
    1a1e:	df 92       	push	r13
    1a20:	ef 92       	push	r14
    1a22:	ff 92       	push	r15
    1a24:	0f 93       	push	r16
    1a26:	1f 93       	push	r17
    1a28:	cf 93       	push	r28
    1a2a:	df 93       	push	r29
    1a2c:	00 d0       	rcall	.+0      	; 0x1a2e <xQueueGenericReceive+0x18>
    1a2e:	1f 92       	push	r1
    1a30:	1f 92       	push	r1
    1a32:	cd b7       	in	r28, 0x3d	; 61
    1a34:	de b7       	in	r29, 0x3e	; 62
    1a36:	8c 01       	movw	r16, r24
    1a38:	6b 01       	movw	r12, r22
    1a3a:	5d 83       	std	Y+5, r21	; 0x05
    1a3c:	4c 83       	std	Y+4, r20	; 0x04
    1a3e:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1a40:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1a42:	99 24       	eor	r9, r9
    1a44:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a46:	7c 01       	movw	r14, r24
    1a48:	81 e1       	ldi	r24, 0x11	; 17
    1a4a:	e8 0e       	add	r14, r24
    1a4c:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a4e:	0f b6       	in	r0, 0x3f	; 63
    1a50:	f8 94       	cli
    1a52:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a54:	f8 01       	movw	r30, r16
    1a56:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a58:	88 23       	and	r24, r24
    1a5a:	69 f1       	breq	.+90     	; 0x1ab6 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1a5c:	e6 80       	ldd	r14, Z+6	; 0x06
    1a5e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a60:	b6 01       	movw	r22, r12
    1a62:	c8 01       	movw	r24, r16
    1a64:	18 de       	rcall	.-976    	; 0x1696 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a66:	b1 10       	cpse	r11, r1
    1a68:	17 c0       	rjmp	.+46     	; 0x1a98 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a6e:	81 50       	subi	r24, 0x01	; 1
    1a70:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a72:	80 81       	ld	r24, Z
    1a74:	91 81       	ldd	r25, Z+1	; 0x01
    1a76:	89 2b       	or	r24, r25
    1a78:	21 f4       	brne	.+8      	; 0x1a82 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1a7a:	75 d6       	rcall	.+3306   	; 0x2766 <pvTaskIncrementMutexHeldCount>
    1a7c:	f8 01       	movw	r30, r16
    1a7e:	93 83       	std	Z+3, r25	; 0x03
    1a80:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a82:	f8 01       	movw	r30, r16
    1a84:	80 85       	ldd	r24, Z+8	; 0x08
    1a86:	88 23       	and	r24, r24
    1a88:	91 f0       	breq	.+36     	; 0x1aae <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a8a:	c8 01       	movw	r24, r16
    1a8c:	08 96       	adiw	r24, 0x08	; 8
    1a8e:	3f d5       	rcall	.+2686   	; 0x250e <xTaskRemoveFromEventList>
    1a90:	81 30       	cpi	r24, 0x01	; 1
    1a92:	69 f4       	brne	.+26     	; 0x1aae <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1a94:	da dc       	rcall	.-1612   	; 0x144a <vPortYield>
    1a96:	0b c0       	rjmp	.+22     	; 0x1aae <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1a98:	f8 01       	movw	r30, r16
    1a9a:	f7 82       	std	Z+7, r15	; 0x07
    1a9c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a9e:	81 89       	ldd	r24, Z+17	; 0x11
    1aa0:	88 23       	and	r24, r24
    1aa2:	29 f0       	breq	.+10     	; 0x1aae <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aa4:	c8 01       	movw	r24, r16
    1aa6:	41 96       	adiw	r24, 0x11	; 17
    1aa8:	32 d5       	rcall	.+2660   	; 0x250e <xTaskRemoveFromEventList>
    1aaa:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1aac:	ce dc       	rcall	.-1636   	; 0x144a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	52 c0       	rjmp	.+164    	; 0x1b5a <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ab6:	4c 81       	ldd	r20, Y+4	; 0x04
    1ab8:	5d 81       	ldd	r21, Y+5	; 0x05
    1aba:	45 2b       	or	r20, r21
    1abc:	21 f4       	brne	.+8      	; 0x1ac6 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1abe:	0f 90       	pop	r0
    1ac0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
    1ac4:	4a c0       	rjmp	.+148    	; 0x1b5a <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ac6:	a1 10       	cpse	r10, r1
    1ac8:	04 c0       	rjmp	.+8      	; 0x1ad2 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1aca:	ce 01       	movw	r24, r28
    1acc:	01 96       	adiw	r24, 0x01	; 1
    1ace:	67 d5       	rcall	.+2766   	; 0x259e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ad0:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1ad2:	0f 90       	pop	r0
    1ad4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1ad6:	7a d2       	rcall	.+1268   	; 0x1fcc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
    1ade:	f8 01       	movw	r30, r16
    1ae0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ae2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ae4:	09 f4       	brne	.+2      	; 0x1ae8 <xQueueGenericReceive+0xd2>
    1ae6:	15 8e       	std	Z+29, r1	; 0x1d
    1ae8:	f8 01       	movw	r30, r16
    1aea:	86 8d       	ldd	r24, Z+30	; 0x1e
    1aec:	8f 3f       	cpi	r24, 0xFF	; 255
    1aee:	09 f4       	brne	.+2      	; 0x1af2 <xQueueGenericReceive+0xdc>
    1af0:	16 8e       	std	Z+30, r1	; 0x1e
    1af2:	0f 90       	pop	r0
    1af4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1af6:	be 01       	movw	r22, r28
    1af8:	6c 5f       	subi	r22, 0xFC	; 252
    1afa:	7f 4f       	sbci	r23, 0xFF	; 255
    1afc:	ce 01       	movw	r24, r28
    1afe:	01 96       	adiw	r24, 0x01	; 1
    1b00:	59 d5       	rcall	.+2738   	; 0x25b4 <xTaskCheckForTimeOut>
    1b02:	81 11       	cpse	r24, r1
    1b04:	26 c0       	rjmp	.+76     	; 0x1b52 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b0c:	f8 01       	movw	r30, r16
    1b0e:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b14:	81 11       	cpse	r24, r1
    1b16:	19 c0       	rjmp	.+50     	; 0x1b4a <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b18:	f8 01       	movw	r30, r16
    1b1a:	80 81       	ld	r24, Z
    1b1c:	91 81       	ldd	r25, Z+1	; 0x01
    1b1e:	89 2b       	or	r24, r25
    1b20:	49 f4       	brne	.+18     	; 0x1b34 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	f8 94       	cli
    1b26:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b28:	f8 01       	movw	r30, r16
    1b2a:	82 81       	ldd	r24, Z+2	; 0x02
    1b2c:	93 81       	ldd	r25, Z+3	; 0x03
    1b2e:	7e d5       	rcall	.+2812   	; 0x262c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b34:	6c 81       	ldd	r22, Y+4	; 0x04
    1b36:	7d 81       	ldd	r23, Y+5	; 0x05
    1b38:	c7 01       	movw	r24, r14
    1b3a:	be d4       	rcall	.+2428   	; 0x24b8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b3c:	c8 01       	movw	r24, r16
    1b3e:	c5 dd       	rcall	.-1142   	; 0x16ca <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b40:	18 d3       	rcall	.+1584   	; 0x2172 <xTaskResumeAll>
    1b42:	81 11       	cpse	r24, r1
    1b44:	84 cf       	rjmp	.-248    	; 0x1a4e <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1b46:	81 dc       	rcall	.-1790   	; 0x144a <vPortYield>
    1b48:	82 cf       	rjmp	.-252    	; 0x1a4e <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b4a:	c8 01       	movw	r24, r16
    1b4c:	be dd       	rcall	.-1156   	; 0x16ca <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b4e:	11 d3       	rcall	.+1570   	; 0x2172 <xTaskResumeAll>
    1b50:	7e cf       	rjmp	.-260    	; 0x1a4e <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b52:	c8 01       	movw	r24, r16
    1b54:	ba dd       	rcall	.-1164   	; 0x16ca <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b56:	0d d3       	rcall	.+1562   	; 0x2172 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b58:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b5a:	0f 90       	pop	r0
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	0f 90       	pop	r0
    1b62:	0f 90       	pop	r0
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	ff 90       	pop	r15
    1b6e:	ef 90       	pop	r14
    1b70:	df 90       	pop	r13
    1b72:	cf 90       	pop	r12
    1b74:	bf 90       	pop	r11
    1b76:	af 90       	pop	r10
    1b78:	9f 90       	pop	r9
    1b7a:	08 95       	ret

00001b7c <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1b7c:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1b7e:	71 83       	std	Z+1, r23	; 0x01
    1b80:	60 83       	st	Z, r22
	ring->rSize = size;
    1b82:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1b84:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1b86:	13 82       	std	Z+3, r1	; 0x03
    1b88:	08 95       	ret

00001b8a <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    1b8a:	dc 01       	movw	r26, r24
    1b8c:	14 96       	adiw	r26, 0x04	; 4
    1b8e:	2c 91       	ld	r18, X
    1b90:	14 97       	sbiw	r26, 0x04	; 4
    1b92:	ed 91       	ld	r30, X+
    1b94:	fc 91       	ld	r31, X
    1b96:	e2 0f       	add	r30, r18
    1b98:	f1 1d       	adc	r31, r1
}
    1b9a:	80 81       	ld	r24, Z
    1b9c:	08 95       	ret

00001b9e <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1b9e:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1ba0:	94 81       	ldd	r25, Z+4	; 0x04
    1ba2:	a0 81       	ld	r26, Z
    1ba4:	b1 81       	ldd	r27, Z+1	; 0x01
    1ba6:	a9 0f       	add	r26, r25
    1ba8:	b1 1d       	adc	r27, r1
    1baa:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1bac:	9f 5f       	subi	r25, 0xFF	; 255
    1bae:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1bb0:	22 81       	ldd	r18, Z+2	; 0x02
    1bb2:	92 17       	cp	r25, r18
    1bb4:	10 f0       	brcs	.+4      	; 0x1bba <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1bb6:	92 1b       	sub	r25, r18
    1bb8:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1bba:	93 81       	ldd	r25, Z+3	; 0x03
    1bbc:	91 50       	subi	r25, 0x01	; 1
    1bbe:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1bc0:	08 95       	ret

00001bc2 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1bc2:	fc 01       	movw	r30, r24
    1bc4:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1bc6:	83 81       	ldd	r24, Z+3	; 0x03
    1bc8:	22 81       	ldd	r18, Z+2	; 0x02
    1bca:	82 17       	cp	r24, r18
    1bcc:	80 f4       	brcc	.+32     	; 0x1bee <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1bce:	34 81       	ldd	r19, Z+4	; 0x04
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	83 0f       	add	r24, r19
    1bd4:	91 1d       	adc	r25, r1
    1bd6:	62 2f       	mov	r22, r18
    1bd8:	70 e0       	ldi	r23, 0x00	; 0
    1bda:	0e 94 19 17 	call	0x2e32	; 0x2e32 <__divmodhi4>
    1bde:	a0 81       	ld	r26, Z
    1be0:	b1 81       	ldd	r27, Z+1	; 0x01
    1be2:	a8 0f       	add	r26, r24
    1be4:	b9 1f       	adc	r27, r25
    1be6:	4c 93       	st	X, r20
            ring->rLength++;
    1be8:	83 81       	ldd	r24, Z+3	; 0x03
    1bea:	8f 5f       	subi	r24, 0xFF	; 255
    1bec:	83 83       	std	Z+3, r24	; 0x03
    1bee:	08 95       	ret

00001bf0 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1bf0:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
    1bf4:	22 81       	ldd	r18, Z+2	; 0x02
    1bf6:	93 81       	ldd	r25, Z+3	; 0x03
    1bf8:	29 13       	cpse	r18, r25
    1bfa:	80 e0       	ldi	r24, 0x00	; 0
}
    1bfc:	08 95       	ret

00001bfe <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1bfe:	21 e0       	ldi	r18, 0x01	; 1
    1c00:	fc 01       	movw	r30, r24
    1c02:	83 81       	ldd	r24, Z+3	; 0x03
    1c04:	81 11       	cpse	r24, r1
    1c06:	01 c0       	rjmp	.+2      	; 0x1c0a <ringBufferNotEmpty+0xc>
    1c08:	20 e0       	ldi	r18, 0x00	; 0
}
    1c0a:	82 2f       	mov	r24, r18
    1c0c:	08 95       	ret

00001c0e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c0e:	e0 91 4e 08 	lds	r30, 0x084E
    1c12:	f0 91 4f 08 	lds	r31, 0x084F
    1c16:	80 81       	ld	r24, Z
    1c18:	81 11       	cpse	r24, r1
    1c1a:	07 c0       	rjmp	.+14     	; 0x1c2a <prvResetNextTaskUnblockTime+0x1c>
    1c1c:	8f ef       	ldi	r24, 0xFF	; 255
    1c1e:	9f ef       	ldi	r25, 0xFF	; 255
    1c20:	90 93 05 02 	sts	0x0205, r25
    1c24:	80 93 04 02 	sts	0x0204, r24
    1c28:	08 95       	ret
    1c2a:	e0 91 4e 08 	lds	r30, 0x084E
    1c2e:	f0 91 4f 08 	lds	r31, 0x084F
    1c32:	05 80       	ldd	r0, Z+5	; 0x05
    1c34:	f6 81       	ldd	r31, Z+6	; 0x06
    1c36:	e0 2d       	mov	r30, r0
    1c38:	06 80       	ldd	r0, Z+6	; 0x06
    1c3a:	f7 81       	ldd	r31, Z+7	; 0x07
    1c3c:	e0 2d       	mov	r30, r0
    1c3e:	82 81       	ldd	r24, Z+2	; 0x02
    1c40:	93 81       	ldd	r25, Z+3	; 0x03
    1c42:	90 93 05 02 	sts	0x0205, r25
    1c46:	80 93 04 02 	sts	0x0204, r24
    1c4a:	08 95       	ret

00001c4c <prvAddCurrentTaskToDelayedList>:
    1c4c:	cf 93       	push	r28
    1c4e:	df 93       	push	r29
    1c50:	ec 01       	movw	r28, r24
    1c52:	e0 91 8f 08 	lds	r30, 0x088F
    1c56:	f0 91 90 08 	lds	r31, 0x0890
    1c5a:	93 83       	std	Z+3, r25	; 0x03
    1c5c:	82 83       	std	Z+2, r24	; 0x02
    1c5e:	80 91 2d 08 	lds	r24, 0x082D
    1c62:	90 91 2e 08 	lds	r25, 0x082E
    1c66:	c8 17       	cp	r28, r24
    1c68:	d9 07       	cpc	r29, r25
    1c6a:	68 f4       	brcc	.+26     	; 0x1c86 <prvAddCurrentTaskToDelayedList+0x3a>
    1c6c:	60 91 8f 08 	lds	r22, 0x088F
    1c70:	70 91 90 08 	lds	r23, 0x0890
    1c74:	80 91 4c 08 	lds	r24, 0x084C
    1c78:	90 91 4d 08 	lds	r25, 0x084D
    1c7c:	6e 5f       	subi	r22, 0xFE	; 254
    1c7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c80:	0e 94 89 03 	call	0x712	; 0x712 <vListInsert>
    1c84:	17 c0       	rjmp	.+46     	; 0x1cb4 <prvAddCurrentTaskToDelayedList+0x68>
    1c86:	60 91 8f 08 	lds	r22, 0x088F
    1c8a:	70 91 90 08 	lds	r23, 0x0890
    1c8e:	80 91 4e 08 	lds	r24, 0x084E
    1c92:	90 91 4f 08 	lds	r25, 0x084F
    1c96:	6e 5f       	subi	r22, 0xFE	; 254
    1c98:	7f 4f       	sbci	r23, 0xFF	; 255
    1c9a:	0e 94 89 03 	call	0x712	; 0x712 <vListInsert>
    1c9e:	80 91 04 02 	lds	r24, 0x0204
    1ca2:	90 91 05 02 	lds	r25, 0x0205
    1ca6:	c8 17       	cp	r28, r24
    1ca8:	d9 07       	cpc	r29, r25
    1caa:	20 f4       	brcc	.+8      	; 0x1cb4 <prvAddCurrentTaskToDelayedList+0x68>
    1cac:	d0 93 05 02 	sts	0x0205, r29
    1cb0:	c0 93 04 02 	sts	0x0204, r28
    1cb4:	df 91       	pop	r29
    1cb6:	cf 91       	pop	r28
    1cb8:	08 95       	ret

00001cba <xTaskGenericCreate>:
    1cba:	4f 92       	push	r4
    1cbc:	5f 92       	push	r5
    1cbe:	6f 92       	push	r6
    1cc0:	7f 92       	push	r7
    1cc2:	8f 92       	push	r8
    1cc4:	9f 92       	push	r9
    1cc6:	af 92       	push	r10
    1cc8:	bf 92       	push	r11
    1cca:	cf 92       	push	r12
    1ccc:	df 92       	push	r13
    1cce:	ef 92       	push	r14
    1cd0:	ff 92       	push	r15
    1cd2:	0f 93       	push	r16
    1cd4:	1f 93       	push	r17
    1cd6:	cf 93       	push	r28
    1cd8:	df 93       	push	r29
    1cda:	4c 01       	movw	r8, r24
    1cdc:	5b 01       	movw	r10, r22
    1cde:	2a 01       	movw	r4, r20
    1ce0:	39 01       	movw	r6, r18
    1ce2:	83 e2       	ldi	r24, 0x23	; 35
    1ce4:	90 e0       	ldi	r25, 0x00	; 0
    1ce6:	0e 94 20 03 	call	0x640	; 0x640 <pvPortMalloc>
    1cea:	ec 01       	movw	r28, r24
    1cec:	00 97       	sbiw	r24, 0x00	; 0
    1cee:	09 f4       	brne	.+2      	; 0x1cf2 <xTaskGenericCreate+0x38>
    1cf0:	e7 c0       	rjmp	.+462    	; 0x1ec0 <xTaskGenericCreate+0x206>
    1cf2:	c1 14       	cp	r12, r1
    1cf4:	d1 04       	cpc	r13, r1
    1cf6:	09 f0       	breq	.+2      	; 0x1cfa <xTaskGenericCreate+0x40>
    1cf8:	cc c0       	rjmp	.+408    	; 0x1e92 <xTaskGenericCreate+0x1d8>
    1cfa:	c2 01       	movw	r24, r4
    1cfc:	0e 94 20 03 	call	0x640	; 0x640 <pvPortMalloc>
    1d00:	98 8f       	std	Y+24, r25	; 0x18
    1d02:	8f 8b       	std	Y+23, r24	; 0x17
    1d04:	89 2b       	or	r24, r25
    1d06:	09 f0       	breq	.+2      	; 0x1d0a <xTaskGenericCreate+0x50>
    1d08:	c6 c0       	rjmp	.+396    	; 0x1e96 <xTaskGenericCreate+0x1dc>
    1d0a:	ce 01       	movw	r24, r28
    1d0c:	0e 94 55 03 	call	0x6aa	; 0x6aa <vPortFree>
    1d10:	d7 c0       	rjmp	.+430    	; 0x1ec0 <xTaskGenericCreate+0x206>
    1d12:	cf 01       	movw	r24, r30
    1d14:	31 91       	ld	r19, Z+
    1d16:	da 01       	movw	r26, r20
    1d18:	3d 93       	st	X+, r19
    1d1a:	ad 01       	movw	r20, r26
    1d1c:	dc 01       	movw	r26, r24
    1d1e:	8c 91       	ld	r24, X
    1d20:	88 23       	and	r24, r24
    1d22:	11 f0       	breq	.+4      	; 0x1d28 <xTaskGenericCreate+0x6e>
    1d24:	21 50       	subi	r18, 0x01	; 1
    1d26:	a9 f7       	brne	.-22     	; 0x1d12 <xTaskGenericCreate+0x58>
    1d28:	18 a2       	std	Y+32, r1	; 0x20
    1d2a:	10 2f       	mov	r17, r16
    1d2c:	05 30       	cpi	r16, 0x05	; 5
    1d2e:	08 f0       	brcs	.+2      	; 0x1d32 <xTaskGenericCreate+0x78>
    1d30:	14 e0       	ldi	r17, 0x04	; 4
    1d32:	1e 8b       	std	Y+22, r17	; 0x16
    1d34:	19 a3       	std	Y+33, r17	; 0x21
    1d36:	1a a2       	std	Y+34, r1	; 0x22
    1d38:	5e 01       	movw	r10, r28
    1d3a:	b2 e0       	ldi	r27, 0x02	; 2
    1d3c:	ab 0e       	add	r10, r27
    1d3e:	b1 1c       	adc	r11, r1
    1d40:	c5 01       	movw	r24, r10
    1d42:	0e 94 64 03 	call	0x6c8	; 0x6c8 <vListInitialiseItem>
    1d46:	ce 01       	movw	r24, r28
    1d48:	0c 96       	adiw	r24, 0x0c	; 12
    1d4a:	0e 94 64 03 	call	0x6c8	; 0x6c8 <vListInitialiseItem>
    1d4e:	d9 87       	std	Y+9, r29	; 0x09
    1d50:	c8 87       	std	Y+8, r28	; 0x08
    1d52:	85 e0       	ldi	r24, 0x05	; 5
    1d54:	90 e0       	ldi	r25, 0x00	; 0
    1d56:	81 1b       	sub	r24, r17
    1d58:	91 09       	sbc	r25, r1
    1d5a:	9d 87       	std	Y+13, r25	; 0x0d
    1d5c:	8c 87       	std	Y+12, r24	; 0x0c
    1d5e:	db 8b       	std	Y+19, r29	; 0x13
    1d60:	ca 8b       	std	Y+18, r28	; 0x12
    1d62:	a3 01       	movw	r20, r6
    1d64:	b4 01       	movw	r22, r8
    1d66:	c6 01       	movw	r24, r12
    1d68:	c1 da       	rcall	.-2686   	; 0x12ec <pxPortInitialiseStack>
    1d6a:	99 83       	std	Y+1, r25	; 0x01
    1d6c:	88 83       	st	Y, r24
    1d6e:	e1 14       	cp	r14, r1
    1d70:	f1 04       	cpc	r15, r1
    1d72:	19 f0       	breq	.+6      	; 0x1d7a <xTaskGenericCreate+0xc0>
    1d74:	f7 01       	movw	r30, r14
    1d76:	d1 83       	std	Z+1, r29	; 0x01
    1d78:	c0 83       	st	Z, r28
    1d7a:	0f b6       	in	r0, 0x3f	; 63
    1d7c:	f8 94       	cli
    1d7e:	0f 92       	push	r0
    1d80:	80 91 2f 08 	lds	r24, 0x082F
    1d84:	8f 5f       	subi	r24, 0xFF	; 255
    1d86:	80 93 2f 08 	sts	0x082F, r24
    1d8a:	80 91 8f 08 	lds	r24, 0x088F
    1d8e:	90 91 90 08 	lds	r25, 0x0890
    1d92:	89 2b       	or	r24, r25
    1d94:	09 f0       	breq	.+2      	; 0x1d98 <xTaskGenericCreate+0xde>
    1d96:	3f c0       	rjmp	.+126    	; 0x1e16 <xTaskGenericCreate+0x15c>
    1d98:	d0 93 90 08 	sts	0x0890, r29
    1d9c:	c0 93 8f 08 	sts	0x088F, r28
    1da0:	80 91 2f 08 	lds	r24, 0x082F
    1da4:	81 30       	cpi	r24, 0x01	; 1
    1da6:	09 f0       	breq	.+2      	; 0x1daa <xTaskGenericCreate+0xf0>
    1da8:	45 c0       	rjmp	.+138    	; 0x1e34 <xTaskGenericCreate+0x17a>
    1daa:	0f 2e       	mov	r0, r31
    1dac:	f2 e6       	ldi	r31, 0x62	; 98
    1dae:	ef 2e       	mov	r14, r31
    1db0:	f8 e0       	ldi	r31, 0x08	; 8
    1db2:	ff 2e       	mov	r15, r31
    1db4:	f0 2d       	mov	r31, r0
    1db6:	0f 2e       	mov	r0, r31
    1db8:	ff e8       	ldi	r31, 0x8F	; 143
    1dba:	cf 2e       	mov	r12, r31
    1dbc:	f8 e0       	ldi	r31, 0x08	; 8
    1dbe:	df 2e       	mov	r13, r31
    1dc0:	f0 2d       	mov	r31, r0
    1dc2:	c7 01       	movw	r24, r14
    1dc4:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1dc8:	f9 e0       	ldi	r31, 0x09	; 9
    1dca:	ef 0e       	add	r14, r31
    1dcc:	f1 1c       	adc	r15, r1
    1dce:	ec 14       	cp	r14, r12
    1dd0:	fd 04       	cpc	r15, r13
    1dd2:	b9 f7       	brne	.-18     	; 0x1dc2 <xTaskGenericCreate+0x108>
    1dd4:	89 e5       	ldi	r24, 0x59	; 89
    1dd6:	98 e0       	ldi	r25, 0x08	; 8
    1dd8:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1ddc:	80 e5       	ldi	r24, 0x50	; 80
    1dde:	98 e0       	ldi	r25, 0x08	; 8
    1de0:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1de4:	83 e4       	ldi	r24, 0x43	; 67
    1de6:	98 e0       	ldi	r25, 0x08	; 8
    1de8:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1dec:	8a e3       	ldi	r24, 0x3A	; 58
    1dee:	98 e0       	ldi	r25, 0x08	; 8
    1df0:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1df4:	80 e3       	ldi	r24, 0x30	; 48
    1df6:	98 e0       	ldi	r25, 0x08	; 8
    1df8:	0e 94 56 03 	call	0x6ac	; 0x6ac <vListInitialise>
    1dfc:	89 e5       	ldi	r24, 0x59	; 89
    1dfe:	98 e0       	ldi	r25, 0x08	; 8
    1e00:	90 93 4f 08 	sts	0x084F, r25
    1e04:	80 93 4e 08 	sts	0x084E, r24
    1e08:	80 e5       	ldi	r24, 0x50	; 80
    1e0a:	98 e0       	ldi	r25, 0x08	; 8
    1e0c:	90 93 4d 08 	sts	0x084D, r25
    1e10:	80 93 4c 08 	sts	0x084C, r24
    1e14:	0f c0       	rjmp	.+30     	; 0x1e34 <xTaskGenericCreate+0x17a>
    1e16:	80 91 2b 08 	lds	r24, 0x082B
    1e1a:	81 11       	cpse	r24, r1
    1e1c:	0b c0       	rjmp	.+22     	; 0x1e34 <xTaskGenericCreate+0x17a>
    1e1e:	e0 91 8f 08 	lds	r30, 0x088F
    1e22:	f0 91 90 08 	lds	r31, 0x0890
    1e26:	86 89       	ldd	r24, Z+22	; 0x16
    1e28:	08 17       	cp	r16, r24
    1e2a:	20 f0       	brcs	.+8      	; 0x1e34 <xTaskGenericCreate+0x17a>
    1e2c:	d0 93 90 08 	sts	0x0890, r29
    1e30:	c0 93 8f 08 	sts	0x088F, r28
    1e34:	80 91 27 08 	lds	r24, 0x0827
    1e38:	8f 5f       	subi	r24, 0xFF	; 255
    1e3a:	80 93 27 08 	sts	0x0827, r24
    1e3e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e40:	90 91 2c 08 	lds	r25, 0x082C
    1e44:	98 17       	cp	r25, r24
    1e46:	10 f4       	brcc	.+4      	; 0x1e4c <xTaskGenericCreate+0x192>
    1e48:	80 93 2c 08 	sts	0x082C, r24
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	9c 01       	movw	r18, r24
    1e50:	22 0f       	add	r18, r18
    1e52:	33 1f       	adc	r19, r19
    1e54:	22 0f       	add	r18, r18
    1e56:	33 1f       	adc	r19, r19
    1e58:	22 0f       	add	r18, r18
    1e5a:	33 1f       	adc	r19, r19
    1e5c:	82 0f       	add	r24, r18
    1e5e:	93 1f       	adc	r25, r19
    1e60:	b5 01       	movw	r22, r10
    1e62:	8e 59       	subi	r24, 0x9E	; 158
    1e64:	97 4f       	sbci	r25, 0xF7	; 247
    1e66:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	80 91 2b 08 	lds	r24, 0x082B
    1e72:	88 23       	and	r24, r24
    1e74:	51 f0       	breq	.+20     	; 0x1e8a <xTaskGenericCreate+0x1d0>
    1e76:	e0 91 8f 08 	lds	r30, 0x088F
    1e7a:	f0 91 90 08 	lds	r31, 0x0890
    1e7e:	86 89       	ldd	r24, Z+22	; 0x16
    1e80:	80 17       	cp	r24, r16
    1e82:	28 f4       	brcc	.+10     	; 0x1e8e <xTaskGenericCreate+0x1d4>
    1e84:	e2 da       	rcall	.-2620   	; 0x144a <vPortYield>
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	1c c0       	rjmp	.+56     	; 0x1ec2 <xTaskGenericCreate+0x208>
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	1a c0       	rjmp	.+52     	; 0x1ec2 <xTaskGenericCreate+0x208>
    1e8e:	81 e0       	ldi	r24, 0x01	; 1
    1e90:	18 c0       	rjmp	.+48     	; 0x1ec2 <xTaskGenericCreate+0x208>
    1e92:	d8 8e       	std	Y+24, r13	; 0x18
    1e94:	cf 8a       	std	Y+23, r12	; 0x17
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	48 1a       	sub	r4, r24
    1e9a:	51 08       	sbc	r5, r1
    1e9c:	cf 88       	ldd	r12, Y+23	; 0x17
    1e9e:	d8 8c       	ldd	r13, Y+24	; 0x18
    1ea0:	c4 0c       	add	r12, r4
    1ea2:	d5 1c       	adc	r13, r5
    1ea4:	d5 01       	movw	r26, r10
    1ea6:	8c 91       	ld	r24, X
    1ea8:	89 8f       	std	Y+25, r24	; 0x19
    1eaa:	8c 91       	ld	r24, X
    1eac:	88 23       	and	r24, r24
    1eae:	09 f4       	brne	.+2      	; 0x1eb2 <xTaskGenericCreate+0x1f8>
    1eb0:	3b cf       	rjmp	.-394    	; 0x1d28 <xTaskGenericCreate+0x6e>
    1eb2:	ae 01       	movw	r20, r28
    1eb4:	46 5e       	subi	r20, 0xE6	; 230
    1eb6:	5f 4f       	sbci	r21, 0xFF	; 255
    1eb8:	f5 01       	movw	r30, r10
    1eba:	31 96       	adiw	r30, 0x01	; 1
    1ebc:	27 e0       	ldi	r18, 0x07	; 7
    1ebe:	29 cf       	rjmp	.-430    	; 0x1d12 <xTaskGenericCreate+0x58>
    1ec0:	8f ef       	ldi	r24, 0xFF	; 255
    1ec2:	df 91       	pop	r29
    1ec4:	cf 91       	pop	r28
    1ec6:	1f 91       	pop	r17
    1ec8:	0f 91       	pop	r16
    1eca:	ff 90       	pop	r15
    1ecc:	ef 90       	pop	r14
    1ece:	df 90       	pop	r13
    1ed0:	cf 90       	pop	r12
    1ed2:	bf 90       	pop	r11
    1ed4:	af 90       	pop	r10
    1ed6:	9f 90       	pop	r9
    1ed8:	8f 90       	pop	r8
    1eda:	7f 90       	pop	r7
    1edc:	6f 90       	pop	r6
    1ede:	5f 90       	pop	r5
    1ee0:	4f 90       	pop	r4
    1ee2:	08 95       	ret

00001ee4 <vTaskResume>:
    1ee4:	0f 93       	push	r16
    1ee6:	1f 93       	push	r17
    1ee8:	cf 93       	push	r28
    1eea:	df 93       	push	r29
    1eec:	ec 01       	movw	r28, r24
    1eee:	00 97       	sbiw	r24, 0x00	; 0
    1ef0:	09 f4       	brne	.+2      	; 0x1ef4 <vTaskResume+0x10>
    1ef2:	3e c0       	rjmp	.+124    	; 0x1f70 <vTaskResume+0x8c>
    1ef4:	80 91 8f 08 	lds	r24, 0x088F
    1ef8:	90 91 90 08 	lds	r25, 0x0890
    1efc:	c8 17       	cp	r28, r24
    1efe:	d9 07       	cpc	r29, r25
    1f00:	b9 f1       	breq	.+110    	; 0x1f70 <vTaskResume+0x8c>
    1f02:	0f b6       	in	r0, 0x3f	; 63
    1f04:	f8 94       	cli
    1f06:	0f 92       	push	r0
    1f08:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f0a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f0c:	80 53       	subi	r24, 0x30	; 48
    1f0e:	98 40       	sbci	r25, 0x08	; 8
    1f10:	69 f5       	brne	.+90     	; 0x1f6c <vTaskResume+0x88>
    1f12:	8c 89       	ldd	r24, Y+20	; 0x14
    1f14:	9d 89       	ldd	r25, Y+21	; 0x15
    1f16:	28 e0       	ldi	r18, 0x08	; 8
    1f18:	83 34       	cpi	r24, 0x43	; 67
    1f1a:	92 07       	cpc	r25, r18
    1f1c:	39 f1       	breq	.+78     	; 0x1f6c <vTaskResume+0x88>
    1f1e:	89 2b       	or	r24, r25
    1f20:	29 f5       	brne	.+74     	; 0x1f6c <vTaskResume+0x88>
    1f22:	8e 01       	movw	r16, r28
    1f24:	0e 5f       	subi	r16, 0xFE	; 254
    1f26:	1f 4f       	sbci	r17, 0xFF	; 255
    1f28:	c8 01       	movw	r24, r16
    1f2a:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    1f2e:	8e 89       	ldd	r24, Y+22	; 0x16
    1f30:	90 91 2c 08 	lds	r25, 0x082C
    1f34:	98 17       	cp	r25, r24
    1f36:	10 f4       	brcc	.+4      	; 0x1f3c <vTaskResume+0x58>
    1f38:	80 93 2c 08 	sts	0x082C, r24
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	9c 01       	movw	r18, r24
    1f40:	22 0f       	add	r18, r18
    1f42:	33 1f       	adc	r19, r19
    1f44:	22 0f       	add	r18, r18
    1f46:	33 1f       	adc	r19, r19
    1f48:	22 0f       	add	r18, r18
    1f4a:	33 1f       	adc	r19, r19
    1f4c:	82 0f       	add	r24, r18
    1f4e:	93 1f       	adc	r25, r19
    1f50:	b8 01       	movw	r22, r16
    1f52:	8e 59       	subi	r24, 0x9E	; 158
    1f54:	97 4f       	sbci	r25, 0xF7	; 247
    1f56:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    1f5a:	e0 91 8f 08 	lds	r30, 0x088F
    1f5e:	f0 91 90 08 	lds	r31, 0x0890
    1f62:	9e 89       	ldd	r25, Y+22	; 0x16
    1f64:	86 89       	ldd	r24, Z+22	; 0x16
    1f66:	98 17       	cp	r25, r24
    1f68:	08 f0       	brcs	.+2      	; 0x1f6c <vTaskResume+0x88>
    1f6a:	6f da       	rcall	.-2850   	; 0x144a <vPortYield>
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	df 91       	pop	r29
    1f72:	cf 91       	pop	r28
    1f74:	1f 91       	pop	r17
    1f76:	0f 91       	pop	r16
    1f78:	08 95       	ret

00001f7a <vTaskStartScheduler>:
    1f7a:	af 92       	push	r10
    1f7c:	bf 92       	push	r11
    1f7e:	cf 92       	push	r12
    1f80:	df 92       	push	r13
    1f82:	ef 92       	push	r14
    1f84:	ff 92       	push	r15
    1f86:	0f 93       	push	r16
    1f88:	a1 2c       	mov	r10, r1
    1f8a:	b1 2c       	mov	r11, r1
    1f8c:	c1 2c       	mov	r12, r1
    1f8e:	d1 2c       	mov	r13, r1
    1f90:	e1 2c       	mov	r14, r1
    1f92:	f1 2c       	mov	r15, r1
    1f94:	00 e0       	ldi	r16, 0x00	; 0
    1f96:	20 e0       	ldi	r18, 0x00	; 0
    1f98:	30 e0       	ldi	r19, 0x00	; 0
    1f9a:	45 e5       	ldi	r20, 0x55	; 85
    1f9c:	50 e0       	ldi	r21, 0x00	; 0
    1f9e:	68 e3       	ldi	r22, 0x38	; 56
    1fa0:	72 e0       	ldi	r23, 0x02	; 2
    1fa2:	88 e7       	ldi	r24, 0x78	; 120
    1fa4:	91 e1       	ldi	r25, 0x11	; 17
    1fa6:	89 de       	rcall	.-750    	; 0x1cba <xTaskGenericCreate>
    1fa8:	81 30       	cpi	r24, 0x01	; 1
    1faa:	41 f4       	brne	.+16     	; 0x1fbc <vTaskStartScheduler+0x42>
    1fac:	f8 94       	cli
    1fae:	80 93 2b 08 	sts	0x082B, r24
    1fb2:	10 92 2e 08 	sts	0x082E, r1
    1fb6:	10 92 2d 08 	sts	0x082D, r1
    1fba:	0a da       	rcall	.-3052   	; 0x13d0 <xPortStartScheduler>
    1fbc:	0f 91       	pop	r16
    1fbe:	ff 90       	pop	r15
    1fc0:	ef 90       	pop	r14
    1fc2:	df 90       	pop	r13
    1fc4:	cf 90       	pop	r12
    1fc6:	bf 90       	pop	r11
    1fc8:	af 90       	pop	r10
    1fca:	08 95       	ret

00001fcc <vTaskSuspendAll>:
    1fcc:	80 91 26 08 	lds	r24, 0x0826
    1fd0:	8f 5f       	subi	r24, 0xFF	; 255
    1fd2:	80 93 26 08 	sts	0x0826, r24
    1fd6:	08 95       	ret

00001fd8 <xTaskGetTickCount>:
    1fd8:	0f b6       	in	r0, 0x3f	; 63
    1fda:	f8 94       	cli
    1fdc:	0f 92       	push	r0
    1fde:	80 91 2d 08 	lds	r24, 0x082D
    1fe2:	90 91 2e 08 	lds	r25, 0x082E
    1fe6:	0f 90       	pop	r0
    1fe8:	0f be       	out	0x3f, r0	; 63
    1fea:	08 95       	ret

00001fec <xTaskGetTickCountFromISR>:
    1fec:	80 91 2d 08 	lds	r24, 0x082D
    1ff0:	90 91 2e 08 	lds	r25, 0x082E
    1ff4:	08 95       	ret

00001ff6 <xTaskIncrementTick>:
    1ff6:	cf 92       	push	r12
    1ff8:	df 92       	push	r13
    1ffa:	ef 92       	push	r14
    1ffc:	ff 92       	push	r15
    1ffe:	0f 93       	push	r16
    2000:	1f 93       	push	r17
    2002:	cf 93       	push	r28
    2004:	df 93       	push	r29
    2006:	80 91 26 08 	lds	r24, 0x0826
    200a:	81 11       	cpse	r24, r1
    200c:	99 c0       	rjmp	.+306    	; 0x2140 <xTaskIncrementTick+0x14a>
    200e:	80 91 2d 08 	lds	r24, 0x082D
    2012:	90 91 2e 08 	lds	r25, 0x082E
    2016:	01 96       	adiw	r24, 0x01	; 1
    2018:	90 93 2e 08 	sts	0x082E, r25
    201c:	80 93 2d 08 	sts	0x082D, r24
    2020:	e0 90 2d 08 	lds	r14, 0x082D
    2024:	f0 90 2e 08 	lds	r15, 0x082E
    2028:	e1 14       	cp	r14, r1
    202a:	f1 04       	cpc	r15, r1
    202c:	b1 f4       	brne	.+44     	; 0x205a <xTaskIncrementTick+0x64>
    202e:	80 91 4e 08 	lds	r24, 0x084E
    2032:	90 91 4f 08 	lds	r25, 0x084F
    2036:	20 91 4c 08 	lds	r18, 0x084C
    203a:	30 91 4d 08 	lds	r19, 0x084D
    203e:	30 93 4f 08 	sts	0x084F, r19
    2042:	20 93 4e 08 	sts	0x084E, r18
    2046:	90 93 4d 08 	sts	0x084D, r25
    204a:	80 93 4c 08 	sts	0x084C, r24
    204e:	80 91 28 08 	lds	r24, 0x0828
    2052:	8f 5f       	subi	r24, 0xFF	; 255
    2054:	80 93 28 08 	sts	0x0828, r24
    2058:	da dd       	rcall	.-1100   	; 0x1c0e <prvResetNextTaskUnblockTime>
    205a:	80 91 04 02 	lds	r24, 0x0204
    205e:	90 91 05 02 	lds	r25, 0x0205
    2062:	e8 16       	cp	r14, r24
    2064:	f9 06       	cpc	r15, r25
    2066:	08 f4       	brcc	.+2      	; 0x206a <xTaskIncrementTick+0x74>
    2068:	54 c0       	rjmp	.+168    	; 0x2112 <xTaskIncrementTick+0x11c>
    206a:	d1 2c       	mov	r13, r1
    206c:	cc 24       	eor	r12, r12
    206e:	c3 94       	inc	r12
    2070:	01 c0       	rjmp	.+2      	; 0x2074 <xTaskIncrementTick+0x7e>
    2072:	dc 2c       	mov	r13, r12
    2074:	e0 91 4e 08 	lds	r30, 0x084E
    2078:	f0 91 4f 08 	lds	r31, 0x084F
    207c:	80 81       	ld	r24, Z
    207e:	81 11       	cpse	r24, r1
    2080:	07 c0       	rjmp	.+14     	; 0x2090 <xTaskIncrementTick+0x9a>
    2082:	8f ef       	ldi	r24, 0xFF	; 255
    2084:	9f ef       	ldi	r25, 0xFF	; 255
    2086:	90 93 05 02 	sts	0x0205, r25
    208a:	80 93 04 02 	sts	0x0204, r24
    208e:	42 c0       	rjmp	.+132    	; 0x2114 <xTaskIncrementTick+0x11e>
    2090:	e0 91 4e 08 	lds	r30, 0x084E
    2094:	f0 91 4f 08 	lds	r31, 0x084F
    2098:	05 80       	ldd	r0, Z+5	; 0x05
    209a:	f6 81       	ldd	r31, Z+6	; 0x06
    209c:	e0 2d       	mov	r30, r0
    209e:	c6 81       	ldd	r28, Z+6	; 0x06
    20a0:	d7 81       	ldd	r29, Z+7	; 0x07
    20a2:	2a 81       	ldd	r18, Y+2	; 0x02
    20a4:	3b 81       	ldd	r19, Y+3	; 0x03
    20a6:	e2 16       	cp	r14, r18
    20a8:	f3 06       	cpc	r15, r19
    20aa:	28 f4       	brcc	.+10     	; 0x20b6 <xTaskIncrementTick+0xc0>
    20ac:	30 93 05 02 	sts	0x0205, r19
    20b0:	20 93 04 02 	sts	0x0204, r18
    20b4:	2f c0       	rjmp	.+94     	; 0x2114 <xTaskIncrementTick+0x11e>
    20b6:	8e 01       	movw	r16, r28
    20b8:	0e 5f       	subi	r16, 0xFE	; 254
    20ba:	1f 4f       	sbci	r17, 0xFF	; 255
    20bc:	c8 01       	movw	r24, r16
    20be:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    20c2:	8c 89       	ldd	r24, Y+20	; 0x14
    20c4:	9d 89       	ldd	r25, Y+21	; 0x15
    20c6:	89 2b       	or	r24, r25
    20c8:	21 f0       	breq	.+8      	; 0x20d2 <xTaskIncrementTick+0xdc>
    20ca:	ce 01       	movw	r24, r28
    20cc:	0c 96       	adiw	r24, 0x0c	; 12
    20ce:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    20d2:	2e 89       	ldd	r18, Y+22	; 0x16
    20d4:	80 91 2c 08 	lds	r24, 0x082C
    20d8:	82 17       	cp	r24, r18
    20da:	10 f4       	brcc	.+4      	; 0x20e0 <xTaskIncrementTick+0xea>
    20dc:	20 93 2c 08 	sts	0x082C, r18
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	c9 01       	movw	r24, r18
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	88 0f       	add	r24, r24
    20ea:	99 1f       	adc	r25, r25
    20ec:	88 0f       	add	r24, r24
    20ee:	99 1f       	adc	r25, r25
    20f0:	82 0f       	add	r24, r18
    20f2:	93 1f       	adc	r25, r19
    20f4:	b8 01       	movw	r22, r16
    20f6:	8e 59       	subi	r24, 0x9E	; 158
    20f8:	97 4f       	sbci	r25, 0xF7	; 247
    20fa:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    20fe:	e0 91 8f 08 	lds	r30, 0x088F
    2102:	f0 91 90 08 	lds	r31, 0x0890
    2106:	9e 89       	ldd	r25, Y+22	; 0x16
    2108:	86 89       	ldd	r24, Z+22	; 0x16
    210a:	98 17       	cp	r25, r24
    210c:	08 f0       	brcs	.+2      	; 0x2110 <xTaskIncrementTick+0x11a>
    210e:	b1 cf       	rjmp	.-158    	; 0x2072 <xTaskIncrementTick+0x7c>
    2110:	b1 cf       	rjmp	.-158    	; 0x2074 <xTaskIncrementTick+0x7e>
    2112:	d1 2c       	mov	r13, r1
    2114:	e0 91 8f 08 	lds	r30, 0x088F
    2118:	f0 91 90 08 	lds	r31, 0x0890
    211c:	86 89       	ldd	r24, Z+22	; 0x16
    211e:	90 e0       	ldi	r25, 0x00	; 0
    2120:	fc 01       	movw	r30, r24
    2122:	ee 0f       	add	r30, r30
    2124:	ff 1f       	adc	r31, r31
    2126:	ee 0f       	add	r30, r30
    2128:	ff 1f       	adc	r31, r31
    212a:	ee 0f       	add	r30, r30
    212c:	ff 1f       	adc	r31, r31
    212e:	8e 0f       	add	r24, r30
    2130:	9f 1f       	adc	r25, r31
    2132:	fc 01       	movw	r30, r24
    2134:	ee 59       	subi	r30, 0x9E	; 158
    2136:	f7 4f       	sbci	r31, 0xF7	; 247
    2138:	80 81       	ld	r24, Z
    213a:	82 30       	cpi	r24, 0x02	; 2
    213c:	40 f4       	brcc	.+16     	; 0x214e <xTaskIncrementTick+0x158>
    213e:	09 c0       	rjmp	.+18     	; 0x2152 <xTaskIncrementTick+0x15c>
    2140:	80 91 2a 08 	lds	r24, 0x082A
    2144:	8f 5f       	subi	r24, 0xFF	; 255
    2146:	80 93 2a 08 	sts	0x082A, r24
    214a:	d1 2c       	mov	r13, r1
    214c:	02 c0       	rjmp	.+4      	; 0x2152 <xTaskIncrementTick+0x15c>
    214e:	dd 24       	eor	r13, r13
    2150:	d3 94       	inc	r13
    2152:	80 91 29 08 	lds	r24, 0x0829
    2156:	88 23       	and	r24, r24
    2158:	11 f0       	breq	.+4      	; 0x215e <xTaskIncrementTick+0x168>
    215a:	dd 24       	eor	r13, r13
    215c:	d3 94       	inc	r13
    215e:	8d 2d       	mov	r24, r13
    2160:	df 91       	pop	r29
    2162:	cf 91       	pop	r28
    2164:	1f 91       	pop	r17
    2166:	0f 91       	pop	r16
    2168:	ff 90       	pop	r15
    216a:	ef 90       	pop	r14
    216c:	df 90       	pop	r13
    216e:	cf 90       	pop	r12
    2170:	08 95       	ret

00002172 <xTaskResumeAll>:
    2172:	df 92       	push	r13
    2174:	ef 92       	push	r14
    2176:	ff 92       	push	r15
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	0f b6       	in	r0, 0x3f	; 63
    2182:	f8 94       	cli
    2184:	0f 92       	push	r0
    2186:	80 91 26 08 	lds	r24, 0x0826
    218a:	81 50       	subi	r24, 0x01	; 1
    218c:	80 93 26 08 	sts	0x0826, r24
    2190:	80 91 26 08 	lds	r24, 0x0826
    2194:	81 11       	cpse	r24, r1
    2196:	5f c0       	rjmp	.+190    	; 0x2256 <__stack+0x57>
    2198:	80 91 2f 08 	lds	r24, 0x082F
    219c:	88 23       	and	r24, r24
    219e:	09 f4       	brne	.+2      	; 0x21a2 <xTaskResumeAll+0x30>
    21a0:	5c c0       	rjmp	.+184    	; 0x225a <__stack+0x5b>
    21a2:	0f 2e       	mov	r0, r31
    21a4:	f3 e4       	ldi	r31, 0x43	; 67
    21a6:	ef 2e       	mov	r14, r31
    21a8:	f8 e0       	ldi	r31, 0x08	; 8
    21aa:	ff 2e       	mov	r15, r31
    21ac:	f0 2d       	mov	r31, r0
    21ae:	dd 24       	eor	r13, r13
    21b0:	d3 94       	inc	r13
    21b2:	30 c0       	rjmp	.+96     	; 0x2214 <__stack+0x15>
    21b4:	e0 91 48 08 	lds	r30, 0x0848
    21b8:	f0 91 49 08 	lds	r31, 0x0849
    21bc:	c6 81       	ldd	r28, Z+6	; 0x06
    21be:	d7 81       	ldd	r29, Z+7	; 0x07
    21c0:	ce 01       	movw	r24, r28
    21c2:	0c 96       	adiw	r24, 0x0c	; 12
    21c4:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    21c8:	8e 01       	movw	r16, r28
    21ca:	0e 5f       	subi	r16, 0xFE	; 254
    21cc:	1f 4f       	sbci	r17, 0xFF	; 255
    21ce:	c8 01       	movw	r24, r16
    21d0:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    21d4:	8e 89       	ldd	r24, Y+22	; 0x16
    21d6:	90 91 2c 08 	lds	r25, 0x082C
    21da:	98 17       	cp	r25, r24
    21dc:	10 f4       	brcc	.+4      	; 0x21e2 <xTaskResumeAll+0x70>
    21de:	80 93 2c 08 	sts	0x082C, r24
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	9c 01       	movw	r18, r24
    21e6:	22 0f       	add	r18, r18
    21e8:	33 1f       	adc	r19, r19
    21ea:	22 0f       	add	r18, r18
    21ec:	33 1f       	adc	r19, r19
    21ee:	22 0f       	add	r18, r18
    21f0:	33 1f       	adc	r19, r19
    21f2:	82 0f       	add	r24, r18
    21f4:	93 1f       	adc	r25, r19
    21f6:	b8 01       	movw	r22, r16
    21f8:	8e 59       	subi	r24, 0x9E	; 158
    21fa:	97 4f       	sbci	r25, 0xF7	; 247
    21fc:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    2200:	e0 91 8f 08 	lds	r30, 0x088F
    2204:	f0 91 90 08 	lds	r31, 0x0890
    2208:	9e 89       	ldd	r25, Y+22	; 0x16
    220a:	86 89       	ldd	r24, Z+22	; 0x16
    220c:	98 17       	cp	r25, r24
    220e:	10 f0       	brcs	.+4      	; 0x2214 <__stack+0x15>
    2210:	d0 92 29 08 	sts	0x0829, r13
    2214:	f7 01       	movw	r30, r14
    2216:	80 81       	ld	r24, Z
    2218:	81 11       	cpse	r24, r1
    221a:	cc cf       	rjmp	.-104    	; 0x21b4 <xTaskResumeAll+0x42>
    221c:	80 91 2a 08 	lds	r24, 0x082A
    2220:	88 23       	and	r24, r24
    2222:	91 f0       	breq	.+36     	; 0x2248 <__stack+0x49>
    2224:	80 91 2a 08 	lds	r24, 0x082A
    2228:	88 23       	and	r24, r24
    222a:	71 f0       	breq	.+28     	; 0x2248 <__stack+0x49>
    222c:	c1 e0       	ldi	r28, 0x01	; 1
    222e:	e3 de       	rcall	.-570    	; 0x1ff6 <xTaskIncrementTick>
    2230:	81 11       	cpse	r24, r1
    2232:	c0 93 29 08 	sts	0x0829, r28
    2236:	80 91 2a 08 	lds	r24, 0x082A
    223a:	81 50       	subi	r24, 0x01	; 1
    223c:	80 93 2a 08 	sts	0x082A, r24
    2240:	80 91 2a 08 	lds	r24, 0x082A
    2244:	81 11       	cpse	r24, r1
    2246:	f3 cf       	rjmp	.-26     	; 0x222e <__stack+0x2f>
    2248:	80 91 29 08 	lds	r24, 0x0829
    224c:	81 30       	cpi	r24, 0x01	; 1
    224e:	39 f4       	brne	.+14     	; 0x225e <__stack+0x5f>
    2250:	fc d8       	rcall	.-3592   	; 0x144a <vPortYield>
    2252:	81 e0       	ldi	r24, 0x01	; 1
    2254:	05 c0       	rjmp	.+10     	; 0x2260 <__stack+0x61>
    2256:	80 e0       	ldi	r24, 0x00	; 0
    2258:	03 c0       	rjmp	.+6      	; 0x2260 <__stack+0x61>
    225a:	80 e0       	ldi	r24, 0x00	; 0
    225c:	01 c0       	rjmp	.+2      	; 0x2260 <__stack+0x61>
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	0f 90       	pop	r0
    2262:	0f be       	out	0x3f, r0	; 63
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	1f 91       	pop	r17
    226a:	0f 91       	pop	r16
    226c:	ff 90       	pop	r15
    226e:	ef 90       	pop	r14
    2270:	df 90       	pop	r13
    2272:	08 95       	ret

00002274 <vTaskDelayUntil>:
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	8c 01       	movw	r16, r24
    227e:	eb 01       	movw	r28, r22
    2280:	a5 de       	rcall	.-694    	; 0x1fcc <vTaskSuspendAll>
    2282:	80 91 2d 08 	lds	r24, 0x082D
    2286:	90 91 2e 08 	lds	r25, 0x082E
    228a:	f8 01       	movw	r30, r16
    228c:	20 81       	ld	r18, Z
    228e:	31 81       	ldd	r19, Z+1	; 0x01
    2290:	c2 0f       	add	r28, r18
    2292:	d3 1f       	adc	r29, r19
    2294:	82 17       	cp	r24, r18
    2296:	93 07       	cpc	r25, r19
    2298:	48 f4       	brcc	.+18     	; 0x22ac <vTaskDelayUntil+0x38>
    229a:	c2 17       	cp	r28, r18
    229c:	d3 07       	cpc	r29, r19
    229e:	f8 f4       	brcc	.+62     	; 0x22de <vTaskDelayUntil+0x6a>
    22a0:	d1 83       	std	Z+1, r29	; 0x01
    22a2:	c0 83       	st	Z, r28
    22a4:	8c 17       	cp	r24, r28
    22a6:	9d 07       	cpc	r25, r29
    22a8:	88 f4       	brcc	.+34     	; 0x22cc <vTaskDelayUntil+0x58>
    22aa:	07 c0       	rjmp	.+14     	; 0x22ba <vTaskDelayUntil+0x46>
    22ac:	c2 17       	cp	r28, r18
    22ae:	d3 07       	cpc	r29, r19
    22b0:	90 f0       	brcs	.+36     	; 0x22d6 <vTaskDelayUntil+0x62>
    22b2:	8c 17       	cp	r24, r28
    22b4:	9d 07       	cpc	r25, r29
    22b6:	78 f0       	brcs	.+30     	; 0x22d6 <vTaskDelayUntil+0x62>
    22b8:	12 c0       	rjmp	.+36     	; 0x22de <vTaskDelayUntil+0x6a>
    22ba:	80 91 8f 08 	lds	r24, 0x088F
    22be:	90 91 90 08 	lds	r25, 0x0890
    22c2:	02 96       	adiw	r24, 0x02	; 2
    22c4:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    22c8:	ce 01       	movw	r24, r28
    22ca:	c0 dc       	rcall	.-1664   	; 0x1c4c <prvAddCurrentTaskToDelayedList>
    22cc:	52 df       	rcall	.-348    	; 0x2172 <xTaskResumeAll>
    22ce:	81 11       	cpse	r24, r1
    22d0:	0a c0       	rjmp	.+20     	; 0x22e6 <vTaskDelayUntil+0x72>
    22d2:	bb d8       	rcall	.-3722   	; 0x144a <vPortYield>
    22d4:	08 c0       	rjmp	.+16     	; 0x22e6 <vTaskDelayUntil+0x72>
    22d6:	f8 01       	movw	r30, r16
    22d8:	d1 83       	std	Z+1, r29	; 0x01
    22da:	c0 83       	st	Z, r28
    22dc:	ee cf       	rjmp	.-36     	; 0x22ba <vTaskDelayUntil+0x46>
    22de:	f8 01       	movw	r30, r16
    22e0:	d1 83       	std	Z+1, r29	; 0x01
    22e2:	c0 83       	st	Z, r28
    22e4:	f3 cf       	rjmp	.-26     	; 0x22cc <vTaskDelayUntil+0x58>
    22e6:	df 91       	pop	r29
    22e8:	cf 91       	pop	r28
    22ea:	1f 91       	pop	r17
    22ec:	0f 91       	pop	r16
    22ee:	08 95       	ret

000022f0 <prvIdleTask>:
    22f0:	0f 2e       	mov	r0, r31
    22f2:	f2 e6       	ldi	r31, 0x62	; 98
    22f4:	ef 2e       	mov	r14, r31
    22f6:	f8 e0       	ldi	r31, 0x08	; 8
    22f8:	ff 2e       	mov	r15, r31
    22fa:	f0 2d       	mov	r31, r0
    22fc:	ca e3       	ldi	r28, 0x3A	; 58
    22fe:	d8 e0       	ldi	r29, 0x08	; 8
    2300:	26 c0       	rjmp	.+76     	; 0x234e <prvIdleTask+0x5e>
    2302:	64 de       	rcall	.-824    	; 0x1fcc <vTaskSuspendAll>
    2304:	18 81       	ld	r17, Y
    2306:	35 df       	rcall	.-406    	; 0x2172 <xTaskResumeAll>
    2308:	11 23       	and	r17, r17
    230a:	09 f1       	breq	.+66     	; 0x234e <prvIdleTask+0x5e>
    230c:	0f b6       	in	r0, 0x3f	; 63
    230e:	f8 94       	cli
    2310:	0f 92       	push	r0
    2312:	e0 91 3f 08 	lds	r30, 0x083F
    2316:	f0 91 40 08 	lds	r31, 0x0840
    231a:	06 81       	ldd	r16, Z+6	; 0x06
    231c:	17 81       	ldd	r17, Z+7	; 0x07
    231e:	c8 01       	movw	r24, r16
    2320:	02 96       	adiw	r24, 0x02	; 2
    2322:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2326:	80 91 2f 08 	lds	r24, 0x082F
    232a:	81 50       	subi	r24, 0x01	; 1
    232c:	80 93 2f 08 	sts	0x082F, r24
    2330:	80 91 39 08 	lds	r24, 0x0839
    2334:	81 50       	subi	r24, 0x01	; 1
    2336:	80 93 39 08 	sts	0x0839, r24
    233a:	0f 90       	pop	r0
    233c:	0f be       	out	0x3f, r0	; 63
    233e:	f8 01       	movw	r30, r16
    2340:	87 89       	ldd	r24, Z+23	; 0x17
    2342:	90 8d       	ldd	r25, Z+24	; 0x18
    2344:	0e 94 55 03 	call	0x6aa	; 0x6aa <vPortFree>
    2348:	c8 01       	movw	r24, r16
    234a:	0e 94 55 03 	call	0x6aa	; 0x6aa <vPortFree>
    234e:	80 91 39 08 	lds	r24, 0x0839
    2352:	81 11       	cpse	r24, r1
    2354:	d6 cf       	rjmp	.-84     	; 0x2302 <prvIdleTask+0x12>
    2356:	f7 01       	movw	r30, r14
    2358:	80 81       	ld	r24, Z
    235a:	82 30       	cpi	r24, 0x02	; 2
    235c:	c0 f3       	brcs	.-16     	; 0x234e <prvIdleTask+0x5e>
    235e:	75 d8       	rcall	.-3862   	; 0x144a <vPortYield>
    2360:	f6 cf       	rjmp	.-20     	; 0x234e <prvIdleTask+0x5e>

00002362 <vTaskSwitchContext>:
    2362:	80 91 26 08 	lds	r24, 0x0826
    2366:	88 23       	and	r24, r24
    2368:	21 f0       	breq	.+8      	; 0x2372 <vTaskSwitchContext+0x10>
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	80 93 29 08 	sts	0x0829, r24
    2370:	08 95       	ret
    2372:	10 92 29 08 	sts	0x0829, r1
    2376:	80 91 2c 08 	lds	r24, 0x082C
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	fc 01       	movw	r30, r24
    237e:	ee 0f       	add	r30, r30
    2380:	ff 1f       	adc	r31, r31
    2382:	ee 0f       	add	r30, r30
    2384:	ff 1f       	adc	r31, r31
    2386:	ee 0f       	add	r30, r30
    2388:	ff 1f       	adc	r31, r31
    238a:	8e 0f       	add	r24, r30
    238c:	9f 1f       	adc	r25, r31
    238e:	fc 01       	movw	r30, r24
    2390:	ee 59       	subi	r30, 0x9E	; 158
    2392:	f7 4f       	sbci	r31, 0xF7	; 247
    2394:	80 81       	ld	r24, Z
    2396:	81 11       	cpse	r24, r1
    2398:	17 c0       	rjmp	.+46     	; 0x23c8 <vTaskSwitchContext+0x66>
    239a:	80 91 2c 08 	lds	r24, 0x082C
    239e:	81 50       	subi	r24, 0x01	; 1
    23a0:	80 93 2c 08 	sts	0x082C, r24
    23a4:	80 91 2c 08 	lds	r24, 0x082C
    23a8:	90 e0       	ldi	r25, 0x00	; 0
    23aa:	fc 01       	movw	r30, r24
    23ac:	ee 0f       	add	r30, r30
    23ae:	ff 1f       	adc	r31, r31
    23b0:	ee 0f       	add	r30, r30
    23b2:	ff 1f       	adc	r31, r31
    23b4:	ee 0f       	add	r30, r30
    23b6:	ff 1f       	adc	r31, r31
    23b8:	8e 0f       	add	r24, r30
    23ba:	9f 1f       	adc	r25, r31
    23bc:	fc 01       	movw	r30, r24
    23be:	ee 59       	subi	r30, 0x9E	; 158
    23c0:	f7 4f       	sbci	r31, 0xF7	; 247
    23c2:	80 81       	ld	r24, Z
    23c4:	88 23       	and	r24, r24
    23c6:	49 f3       	breq	.-46     	; 0x239a <vTaskSwitchContext+0x38>
    23c8:	e0 91 2c 08 	lds	r30, 0x082C
    23cc:	f0 e0       	ldi	r31, 0x00	; 0
    23ce:	cf 01       	movw	r24, r30
    23d0:	88 0f       	add	r24, r24
    23d2:	99 1f       	adc	r25, r25
    23d4:	88 0f       	add	r24, r24
    23d6:	99 1f       	adc	r25, r25
    23d8:	88 0f       	add	r24, r24
    23da:	99 1f       	adc	r25, r25
    23dc:	e8 0f       	add	r30, r24
    23de:	f9 1f       	adc	r31, r25
    23e0:	ee 59       	subi	r30, 0x9E	; 158
    23e2:	f7 4f       	sbci	r31, 0xF7	; 247
    23e4:	a1 81       	ldd	r26, Z+1	; 0x01
    23e6:	b2 81       	ldd	r27, Z+2	; 0x02
    23e8:	12 96       	adiw	r26, 0x02	; 2
    23ea:	0d 90       	ld	r0, X+
    23ec:	bc 91       	ld	r27, X
    23ee:	a0 2d       	mov	r26, r0
    23f0:	b2 83       	std	Z+2, r27	; 0x02
    23f2:	a1 83       	std	Z+1, r26	; 0x01
    23f4:	cf 01       	movw	r24, r30
    23f6:	03 96       	adiw	r24, 0x03	; 3
    23f8:	a8 17       	cp	r26, r24
    23fa:	b9 07       	cpc	r27, r25
    23fc:	31 f4       	brne	.+12     	; 0x240a <vTaskSwitchContext+0xa8>
    23fe:	12 96       	adiw	r26, 0x02	; 2
    2400:	8d 91       	ld	r24, X+
    2402:	9c 91       	ld	r25, X
    2404:	13 97       	sbiw	r26, 0x03	; 3
    2406:	92 83       	std	Z+2, r25	; 0x02
    2408:	81 83       	std	Z+1, r24	; 0x01
    240a:	01 80       	ldd	r0, Z+1	; 0x01
    240c:	f2 81       	ldd	r31, Z+2	; 0x02
    240e:	e0 2d       	mov	r30, r0
    2410:	86 81       	ldd	r24, Z+6	; 0x06
    2412:	97 81       	ldd	r25, Z+7	; 0x07
    2414:	90 93 90 08 	sts	0x0890, r25
    2418:	80 93 8f 08 	sts	0x088F, r24
    241c:	08 95       	ret

0000241e <vTaskSuspend>:
    241e:	0f 93       	push	r16
    2420:	1f 93       	push	r17
    2422:	cf 93       	push	r28
    2424:	df 93       	push	r29
    2426:	ec 01       	movw	r28, r24
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	0f 92       	push	r0
    242e:	00 97       	sbiw	r24, 0x00	; 0
    2430:	21 f4       	brne	.+8      	; 0x243a <vTaskSuspend+0x1c>
    2432:	c0 91 8f 08 	lds	r28, 0x088F
    2436:	d0 91 90 08 	lds	r29, 0x0890
    243a:	8e 01       	movw	r16, r28
    243c:	0e 5f       	subi	r16, 0xFE	; 254
    243e:	1f 4f       	sbci	r17, 0xFF	; 255
    2440:	c8 01       	movw	r24, r16
    2442:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2446:	8c 89       	ldd	r24, Y+20	; 0x14
    2448:	9d 89       	ldd	r25, Y+21	; 0x15
    244a:	89 2b       	or	r24, r25
    244c:	21 f0       	breq	.+8      	; 0x2456 <vTaskSuspend+0x38>
    244e:	ce 01       	movw	r24, r28
    2450:	0c 96       	adiw	r24, 0x0c	; 12
    2452:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2456:	b8 01       	movw	r22, r16
    2458:	80 e3       	ldi	r24, 0x30	; 48
    245a:	98 e0       	ldi	r25, 0x08	; 8
    245c:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    2460:	0f 90       	pop	r0
    2462:	0f be       	out	0x3f, r0	; 63
    2464:	80 91 8f 08 	lds	r24, 0x088F
    2468:	90 91 90 08 	lds	r25, 0x0890
    246c:	c8 17       	cp	r28, r24
    246e:	d9 07       	cpc	r29, r25
    2470:	a1 f4       	brne	.+40     	; 0x249a <vTaskSuspend+0x7c>
    2472:	80 91 2b 08 	lds	r24, 0x082B
    2476:	88 23       	and	r24, r24
    2478:	19 f0       	breq	.+6      	; 0x2480 <vTaskSuspend+0x62>
    247a:	0e 94 25 0a 	call	0x144a	; 0x144a <vPortYield>
    247e:	17 c0       	rjmp	.+46     	; 0x24ae <vTaskSuspend+0x90>
    2480:	80 91 2f 08 	lds	r24, 0x082F
    2484:	90 91 30 08 	lds	r25, 0x0830
    2488:	98 13       	cpse	r25, r24
    248a:	05 c0       	rjmp	.+10     	; 0x2496 <vTaskSuspend+0x78>
    248c:	10 92 90 08 	sts	0x0890, r1
    2490:	10 92 8f 08 	sts	0x088F, r1
    2494:	0c c0       	rjmp	.+24     	; 0x24ae <vTaskSuspend+0x90>
    2496:	65 df       	rcall	.-310    	; 0x2362 <vTaskSwitchContext>
    2498:	0a c0       	rjmp	.+20     	; 0x24ae <vTaskSuspend+0x90>
    249a:	80 91 2b 08 	lds	r24, 0x082B
    249e:	88 23       	and	r24, r24
    24a0:	31 f0       	breq	.+12     	; 0x24ae <vTaskSuspend+0x90>
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	0f 92       	push	r0
    24a8:	b2 db       	rcall	.-2204   	; 0x1c0e <prvResetNextTaskUnblockTime>
    24aa:	0f 90       	pop	r0
    24ac:	0f be       	out	0x3f, r0	; 63
    24ae:	df 91       	pop	r29
    24b0:	cf 91       	pop	r28
    24b2:	1f 91       	pop	r17
    24b4:	0f 91       	pop	r16
    24b6:	08 95       	ret

000024b8 <vTaskPlaceOnEventList>:
    24b8:	cf 93       	push	r28
    24ba:	df 93       	push	r29
    24bc:	eb 01       	movw	r28, r22
    24be:	60 91 8f 08 	lds	r22, 0x088F
    24c2:	70 91 90 08 	lds	r23, 0x0890
    24c6:	64 5f       	subi	r22, 0xF4	; 244
    24c8:	7f 4f       	sbci	r23, 0xFF	; 255
    24ca:	0e 94 89 03 	call	0x712	; 0x712 <vListInsert>
    24ce:	80 91 8f 08 	lds	r24, 0x088F
    24d2:	90 91 90 08 	lds	r25, 0x0890
    24d6:	02 96       	adiw	r24, 0x02	; 2
    24d8:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    24dc:	cf 3f       	cpi	r28, 0xFF	; 255
    24de:	8f ef       	ldi	r24, 0xFF	; 255
    24e0:	d8 07       	cpc	r29, r24
    24e2:	59 f4       	brne	.+22     	; 0x24fa <vTaskPlaceOnEventList+0x42>
    24e4:	60 91 8f 08 	lds	r22, 0x088F
    24e8:	70 91 90 08 	lds	r23, 0x0890
    24ec:	6e 5f       	subi	r22, 0xFE	; 254
    24ee:	7f 4f       	sbci	r23, 0xFF	; 255
    24f0:	80 e3       	ldi	r24, 0x30	; 48
    24f2:	98 e0       	ldi	r25, 0x08	; 8
    24f4:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    24f8:	07 c0       	rjmp	.+14     	; 0x2508 <vTaskPlaceOnEventList+0x50>
    24fa:	80 91 2d 08 	lds	r24, 0x082D
    24fe:	90 91 2e 08 	lds	r25, 0x082E
    2502:	8c 0f       	add	r24, r28
    2504:	9d 1f       	adc	r25, r29
    2506:	a2 db       	rcall	.-2236   	; 0x1c4c <prvAddCurrentTaskToDelayedList>
    2508:	df 91       	pop	r29
    250a:	cf 91       	pop	r28
    250c:	08 95       	ret

0000250e <xTaskRemoveFromEventList>:
    250e:	0f 93       	push	r16
    2510:	1f 93       	push	r17
    2512:	cf 93       	push	r28
    2514:	df 93       	push	r29
    2516:	dc 01       	movw	r26, r24
    2518:	15 96       	adiw	r26, 0x05	; 5
    251a:	ed 91       	ld	r30, X+
    251c:	fc 91       	ld	r31, X
    251e:	16 97       	sbiw	r26, 0x06	; 6
    2520:	c6 81       	ldd	r28, Z+6	; 0x06
    2522:	d7 81       	ldd	r29, Z+7	; 0x07
    2524:	8e 01       	movw	r16, r28
    2526:	04 5f       	subi	r16, 0xF4	; 244
    2528:	1f 4f       	sbci	r17, 0xFF	; 255
    252a:	c8 01       	movw	r24, r16
    252c:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2530:	80 91 26 08 	lds	r24, 0x0826
    2534:	81 11       	cpse	r24, r1
    2536:	1c c0       	rjmp	.+56     	; 0x2570 <xTaskRemoveFromEventList+0x62>
    2538:	0a 50       	subi	r16, 0x0A	; 10
    253a:	11 09       	sbc	r17, r1
    253c:	c8 01       	movw	r24, r16
    253e:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2542:	8e 89       	ldd	r24, Y+22	; 0x16
    2544:	90 91 2c 08 	lds	r25, 0x082C
    2548:	98 17       	cp	r25, r24
    254a:	10 f4       	brcc	.+4      	; 0x2550 <xTaskRemoveFromEventList+0x42>
    254c:	80 93 2c 08 	sts	0x082C, r24
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	9c 01       	movw	r18, r24
    2554:	22 0f       	add	r18, r18
    2556:	33 1f       	adc	r19, r19
    2558:	22 0f       	add	r18, r18
    255a:	33 1f       	adc	r19, r19
    255c:	22 0f       	add	r18, r18
    255e:	33 1f       	adc	r19, r19
    2560:	82 0f       	add	r24, r18
    2562:	93 1f       	adc	r25, r19
    2564:	b8 01       	movw	r22, r16
    2566:	8e 59       	subi	r24, 0x9E	; 158
    2568:	97 4f       	sbci	r25, 0xF7	; 247
    256a:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    256e:	05 c0       	rjmp	.+10     	; 0x257a <xTaskRemoveFromEventList+0x6c>
    2570:	b8 01       	movw	r22, r16
    2572:	83 e4       	ldi	r24, 0x43	; 67
    2574:	98 e0       	ldi	r25, 0x08	; 8
    2576:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    257a:	e0 91 8f 08 	lds	r30, 0x088F
    257e:	f0 91 90 08 	lds	r31, 0x0890
    2582:	9e 89       	ldd	r25, Y+22	; 0x16
    2584:	86 89       	ldd	r24, Z+22	; 0x16
    2586:	89 17       	cp	r24, r25
    2588:	20 f4       	brcc	.+8      	; 0x2592 <xTaskRemoveFromEventList+0x84>
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	80 93 29 08 	sts	0x0829, r24
    2590:	01 c0       	rjmp	.+2      	; 0x2594 <xTaskRemoveFromEventList+0x86>
    2592:	80 e0       	ldi	r24, 0x00	; 0
    2594:	df 91       	pop	r29
    2596:	cf 91       	pop	r28
    2598:	1f 91       	pop	r17
    259a:	0f 91       	pop	r16
    259c:	08 95       	ret

0000259e <vTaskSetTimeOutState>:
    259e:	20 91 28 08 	lds	r18, 0x0828
    25a2:	fc 01       	movw	r30, r24
    25a4:	20 83       	st	Z, r18
    25a6:	20 91 2d 08 	lds	r18, 0x082D
    25aa:	30 91 2e 08 	lds	r19, 0x082E
    25ae:	32 83       	std	Z+2, r19	; 0x02
    25b0:	21 83       	std	Z+1, r18	; 0x01
    25b2:	08 95       	ret

000025b4 <xTaskCheckForTimeOut>:
    25b4:	0f b6       	in	r0, 0x3f	; 63
    25b6:	f8 94       	cli
    25b8:	0f 92       	push	r0
    25ba:	40 91 2d 08 	lds	r20, 0x082D
    25be:	50 91 2e 08 	lds	r21, 0x082E
    25c2:	db 01       	movw	r26, r22
    25c4:	2d 91       	ld	r18, X+
    25c6:	3c 91       	ld	r19, X
    25c8:	2f 3f       	cpi	r18, 0xFF	; 255
    25ca:	bf ef       	ldi	r27, 0xFF	; 255
    25cc:	3b 07       	cpc	r19, r27
    25ce:	11 f1       	breq	.+68     	; 0x2614 <xTaskCheckForTimeOut+0x60>
    25d0:	e0 91 28 08 	lds	r30, 0x0828
    25d4:	dc 01       	movw	r26, r24
    25d6:	fc 91       	ld	r31, X
    25d8:	fe 17       	cp	r31, r30
    25da:	39 f0       	breq	.+14     	; 0x25ea <xTaskCheckForTimeOut+0x36>
    25dc:	11 96       	adiw	r26, 0x01	; 1
    25de:	ed 91       	ld	r30, X+
    25e0:	fc 91       	ld	r31, X
    25e2:	12 97       	sbiw	r26, 0x02	; 2
    25e4:	4e 17       	cp	r20, r30
    25e6:	5f 07       	cpc	r21, r31
    25e8:	b8 f4       	brcc	.+46     	; 0x2618 <xTaskCheckForTimeOut+0x64>
    25ea:	dc 01       	movw	r26, r24
    25ec:	11 96       	adiw	r26, 0x01	; 1
    25ee:	ed 91       	ld	r30, X+
    25f0:	fc 91       	ld	r31, X
    25f2:	12 97       	sbiw	r26, 0x02	; 2
    25f4:	da 01       	movw	r26, r20
    25f6:	ae 1b       	sub	r26, r30
    25f8:	bf 0b       	sbc	r27, r31
    25fa:	a2 17       	cp	r26, r18
    25fc:	b3 07       	cpc	r27, r19
    25fe:	70 f4       	brcc	.+28     	; 0x261c <xTaskCheckForTimeOut+0x68>
    2600:	e4 1b       	sub	r30, r20
    2602:	f5 0b       	sbc	r31, r21
    2604:	2e 0f       	add	r18, r30
    2606:	3f 1f       	adc	r19, r31
    2608:	fb 01       	movw	r30, r22
    260a:	31 83       	std	Z+1, r19	; 0x01
    260c:	20 83       	st	Z, r18
    260e:	c7 df       	rcall	.-114    	; 0x259e <vTaskSetTimeOutState>
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	05 c0       	rjmp	.+10     	; 0x261e <xTaskCheckForTimeOut+0x6a>
    2614:	80 e0       	ldi	r24, 0x00	; 0
    2616:	03 c0       	rjmp	.+6      	; 0x261e <xTaskCheckForTimeOut+0x6a>
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	01 c0       	rjmp	.+2      	; 0x261e <xTaskCheckForTimeOut+0x6a>
    261c:	81 e0       	ldi	r24, 0x01	; 1
    261e:	0f 90       	pop	r0
    2620:	0f be       	out	0x3f, r0	; 63
    2622:	08 95       	ret

00002624 <vTaskMissedYield>:
    2624:	81 e0       	ldi	r24, 0x01	; 1
    2626:	80 93 29 08 	sts	0x0829, r24
    262a:	08 95       	ret

0000262c <vTaskPriorityInherit>:
    262c:	0f 93       	push	r16
    262e:	1f 93       	push	r17
    2630:	cf 93       	push	r28
    2632:	df 93       	push	r29
    2634:	ec 01       	movw	r28, r24
    2636:	00 97       	sbiw	r24, 0x00	; 0
    2638:	09 f4       	brne	.+2      	; 0x263c <vTaskPriorityInherit+0x10>
    263a:	51 c0       	rjmp	.+162    	; 0x26de <vTaskPriorityInherit+0xb2>
    263c:	8e 89       	ldd	r24, Y+22	; 0x16
    263e:	e0 91 8f 08 	lds	r30, 0x088F
    2642:	f0 91 90 08 	lds	r31, 0x0890
    2646:	96 89       	ldd	r25, Z+22	; 0x16
    2648:	89 17       	cp	r24, r25
    264a:	08 f0       	brcs	.+2      	; 0x264e <vTaskPriorityInherit+0x22>
    264c:	48 c0       	rjmp	.+144    	; 0x26de <vTaskPriorityInherit+0xb2>
    264e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2650:	3d 85       	ldd	r19, Y+13	; 0x0d
    2652:	33 23       	and	r19, r19
    2654:	5c f0       	brlt	.+22     	; 0x266c <vTaskPriorityInherit+0x40>
    2656:	e0 91 8f 08 	lds	r30, 0x088F
    265a:	f0 91 90 08 	lds	r31, 0x0890
    265e:	96 89       	ldd	r25, Z+22	; 0x16
    2660:	25 e0       	ldi	r18, 0x05	; 5
    2662:	30 e0       	ldi	r19, 0x00	; 0
    2664:	29 1b       	sub	r18, r25
    2666:	31 09       	sbc	r19, r1
    2668:	3d 87       	std	Y+13, r19	; 0x0d
    266a:	2c 87       	std	Y+12, r18	; 0x0c
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	9c 01       	movw	r18, r24
    2670:	22 0f       	add	r18, r18
    2672:	33 1f       	adc	r19, r19
    2674:	22 0f       	add	r18, r18
    2676:	33 1f       	adc	r19, r19
    2678:	22 0f       	add	r18, r18
    267a:	33 1f       	adc	r19, r19
    267c:	82 0f       	add	r24, r18
    267e:	93 1f       	adc	r25, r19
    2680:	8e 59       	subi	r24, 0x9E	; 158
    2682:	97 4f       	sbci	r25, 0xF7	; 247
    2684:	2a 85       	ldd	r18, Y+10	; 0x0a
    2686:	3b 85       	ldd	r19, Y+11	; 0x0b
    2688:	28 17       	cp	r18, r24
    268a:	39 07       	cpc	r19, r25
    268c:	11 f5       	brne	.+68     	; 0x26d2 <vTaskPriorityInherit+0xa6>
    268e:	8e 01       	movw	r16, r28
    2690:	0e 5f       	subi	r16, 0xFE	; 254
    2692:	1f 4f       	sbci	r17, 0xFF	; 255
    2694:	c8 01       	movw	r24, r16
    2696:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    269a:	e0 91 8f 08 	lds	r30, 0x088F
    269e:	f0 91 90 08 	lds	r31, 0x0890
    26a2:	86 89       	ldd	r24, Z+22	; 0x16
    26a4:	8e 8b       	std	Y+22, r24	; 0x16
    26a6:	90 91 2c 08 	lds	r25, 0x082C
    26aa:	98 17       	cp	r25, r24
    26ac:	10 f4       	brcc	.+4      	; 0x26b2 <vTaskPriorityInherit+0x86>
    26ae:	80 93 2c 08 	sts	0x082C, r24
    26b2:	90 e0       	ldi	r25, 0x00	; 0
    26b4:	9c 01       	movw	r18, r24
    26b6:	22 0f       	add	r18, r18
    26b8:	33 1f       	adc	r19, r19
    26ba:	22 0f       	add	r18, r18
    26bc:	33 1f       	adc	r19, r19
    26be:	22 0f       	add	r18, r18
    26c0:	33 1f       	adc	r19, r19
    26c2:	82 0f       	add	r24, r18
    26c4:	93 1f       	adc	r25, r19
    26c6:	b8 01       	movw	r22, r16
    26c8:	8e 59       	subi	r24, 0x9E	; 158
    26ca:	97 4f       	sbci	r25, 0xF7	; 247
    26cc:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    26d0:	06 c0       	rjmp	.+12     	; 0x26de <vTaskPriorityInherit+0xb2>
    26d2:	e0 91 8f 08 	lds	r30, 0x088F
    26d6:	f0 91 90 08 	lds	r31, 0x0890
    26da:	86 89       	ldd	r24, Z+22	; 0x16
    26dc:	8e 8b       	std	Y+22, r24	; 0x16
    26de:	df 91       	pop	r29
    26e0:	cf 91       	pop	r28
    26e2:	1f 91       	pop	r17
    26e4:	0f 91       	pop	r16
    26e6:	08 95       	ret

000026e8 <xTaskPriorityDisinherit>:
    26e8:	0f 93       	push	r16
    26ea:	1f 93       	push	r17
    26ec:	cf 93       	push	r28
    26ee:	df 93       	push	r29
    26f0:	ec 01       	movw	r28, r24
    26f2:	00 97       	sbiw	r24, 0x00	; 0
    26f4:	71 f1       	breq	.+92     	; 0x2752 <xTaskPriorityDisinherit+0x6a>
    26f6:	8a a1       	ldd	r24, Y+34	; 0x22
    26f8:	81 50       	subi	r24, 0x01	; 1
    26fa:	8a a3       	std	Y+34, r24	; 0x22
    26fc:	2e 89       	ldd	r18, Y+22	; 0x16
    26fe:	99 a1       	ldd	r25, Y+33	; 0x21
    2700:	29 17       	cp	r18, r25
    2702:	49 f1       	breq	.+82     	; 0x2756 <xTaskPriorityDisinherit+0x6e>
    2704:	81 11       	cpse	r24, r1
    2706:	29 c0       	rjmp	.+82     	; 0x275a <xTaskPriorityDisinherit+0x72>
    2708:	8e 01       	movw	r16, r28
    270a:	0e 5f       	subi	r16, 0xFE	; 254
    270c:	1f 4f       	sbci	r17, 0xFF	; 255
    270e:	c8 01       	movw	r24, r16
    2710:	0e 94 ba 03 	call	0x774	; 0x774 <uxListRemove>
    2714:	89 a1       	ldd	r24, Y+33	; 0x21
    2716:	8e 8b       	std	Y+22, r24	; 0x16
    2718:	25 e0       	ldi	r18, 0x05	; 5
    271a:	30 e0       	ldi	r19, 0x00	; 0
    271c:	28 1b       	sub	r18, r24
    271e:	31 09       	sbc	r19, r1
    2720:	3d 87       	std	Y+13, r19	; 0x0d
    2722:	2c 87       	std	Y+12, r18	; 0x0c
    2724:	90 91 2c 08 	lds	r25, 0x082C
    2728:	98 17       	cp	r25, r24
    272a:	10 f4       	brcc	.+4      	; 0x2730 <xTaskPriorityDisinherit+0x48>
    272c:	80 93 2c 08 	sts	0x082C, r24
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	9c 01       	movw	r18, r24
    2734:	22 0f       	add	r18, r18
    2736:	33 1f       	adc	r19, r19
    2738:	22 0f       	add	r18, r18
    273a:	33 1f       	adc	r19, r19
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	82 0f       	add	r24, r18
    2742:	93 1f       	adc	r25, r19
    2744:	b8 01       	movw	r22, r16
    2746:	8e 59       	subi	r24, 0x9E	; 158
    2748:	97 4f       	sbci	r25, 0xF7	; 247
    274a:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsertEnd>
    274e:	81 e0       	ldi	r24, 0x01	; 1
    2750:	05 c0       	rjmp	.+10     	; 0x275c <xTaskPriorityDisinherit+0x74>
    2752:	80 e0       	ldi	r24, 0x00	; 0
    2754:	03 c0       	rjmp	.+6      	; 0x275c <xTaskPriorityDisinherit+0x74>
    2756:	80 e0       	ldi	r24, 0x00	; 0
    2758:	01 c0       	rjmp	.+2      	; 0x275c <xTaskPriorityDisinherit+0x74>
    275a:	80 e0       	ldi	r24, 0x00	; 0
    275c:	df 91       	pop	r29
    275e:	cf 91       	pop	r28
    2760:	1f 91       	pop	r17
    2762:	0f 91       	pop	r16
    2764:	08 95       	ret

00002766 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2766:	80 91 8f 08 	lds	r24, 0x088F
    276a:	90 91 90 08 	lds	r25, 0x0890
    276e:	89 2b       	or	r24, r25
    2770:	39 f0       	breq	.+14     	; 0x2780 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2772:	e0 91 8f 08 	lds	r30, 0x088F
    2776:	f0 91 90 08 	lds	r31, 0x0890
    277a:	82 a1       	ldd	r24, Z+34	; 0x22
    277c:	8f 5f       	subi	r24, 0xFF	; 255
    277e:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2780:	80 91 8f 08 	lds	r24, 0x088F
    2784:	90 91 90 08 	lds	r25, 0x0890
	}
    2788:	08 95       	ret

0000278a <__subsf3>:
    278a:	50 58       	subi	r21, 0x80	; 128

0000278c <__addsf3>:
    278c:	bb 27       	eor	r27, r27
    278e:	aa 27       	eor	r26, r26
    2790:	0e d0       	rcall	.+28     	; 0x27ae <__addsf3x>
    2792:	e5 c0       	rjmp	.+458    	; 0x295e <__fp_round>
    2794:	d6 d0       	rcall	.+428    	; 0x2942 <__fp_pscA>
    2796:	30 f0       	brcs	.+12     	; 0x27a4 <__addsf3+0x18>
    2798:	db d0       	rcall	.+438    	; 0x2950 <__fp_pscB>
    279a:	20 f0       	brcs	.+8      	; 0x27a4 <__addsf3+0x18>
    279c:	31 f4       	brne	.+12     	; 0x27aa <__addsf3+0x1e>
    279e:	9f 3f       	cpi	r25, 0xFF	; 255
    27a0:	11 f4       	brne	.+4      	; 0x27a6 <__addsf3+0x1a>
    27a2:	1e f4       	brtc	.+6      	; 0x27aa <__addsf3+0x1e>
    27a4:	cb c0       	rjmp	.+406    	; 0x293c <__fp_nan>
    27a6:	0e f4       	brtc	.+2      	; 0x27aa <__addsf3+0x1e>
    27a8:	e0 95       	com	r30
    27aa:	e7 fb       	bst	r30, 7
    27ac:	c1 c0       	rjmp	.+386    	; 0x2930 <__fp_inf>

000027ae <__addsf3x>:
    27ae:	e9 2f       	mov	r30, r25
    27b0:	e7 d0       	rcall	.+462    	; 0x2980 <__fp_split3>
    27b2:	80 f3       	brcs	.-32     	; 0x2794 <__addsf3+0x8>
    27b4:	ba 17       	cp	r27, r26
    27b6:	62 07       	cpc	r22, r18
    27b8:	73 07       	cpc	r23, r19
    27ba:	84 07       	cpc	r24, r20
    27bc:	95 07       	cpc	r25, r21
    27be:	18 f0       	brcs	.+6      	; 0x27c6 <__addsf3x+0x18>
    27c0:	71 f4       	brne	.+28     	; 0x27de <__addsf3x+0x30>
    27c2:	9e f5       	brtc	.+102    	; 0x282a <__addsf3x+0x7c>
    27c4:	ff c0       	rjmp	.+510    	; 0x29c4 <__fp_zero>
    27c6:	0e f4       	brtc	.+2      	; 0x27ca <__addsf3x+0x1c>
    27c8:	e0 95       	com	r30
    27ca:	0b 2e       	mov	r0, r27
    27cc:	ba 2f       	mov	r27, r26
    27ce:	a0 2d       	mov	r26, r0
    27d0:	0b 01       	movw	r0, r22
    27d2:	b9 01       	movw	r22, r18
    27d4:	90 01       	movw	r18, r0
    27d6:	0c 01       	movw	r0, r24
    27d8:	ca 01       	movw	r24, r20
    27da:	a0 01       	movw	r20, r0
    27dc:	11 24       	eor	r1, r1
    27de:	ff 27       	eor	r31, r31
    27e0:	59 1b       	sub	r21, r25
    27e2:	99 f0       	breq	.+38     	; 0x280a <__addsf3x+0x5c>
    27e4:	59 3f       	cpi	r21, 0xF9	; 249
    27e6:	50 f4       	brcc	.+20     	; 0x27fc <__addsf3x+0x4e>
    27e8:	50 3e       	cpi	r21, 0xE0	; 224
    27ea:	68 f1       	brcs	.+90     	; 0x2846 <__addsf3x+0x98>
    27ec:	1a 16       	cp	r1, r26
    27ee:	f0 40       	sbci	r31, 0x00	; 0
    27f0:	a2 2f       	mov	r26, r18
    27f2:	23 2f       	mov	r18, r19
    27f4:	34 2f       	mov	r19, r20
    27f6:	44 27       	eor	r20, r20
    27f8:	58 5f       	subi	r21, 0xF8	; 248
    27fa:	f3 cf       	rjmp	.-26     	; 0x27e2 <__addsf3x+0x34>
    27fc:	46 95       	lsr	r20
    27fe:	37 95       	ror	r19
    2800:	27 95       	ror	r18
    2802:	a7 95       	ror	r26
    2804:	f0 40       	sbci	r31, 0x00	; 0
    2806:	53 95       	inc	r21
    2808:	c9 f7       	brne	.-14     	; 0x27fc <__addsf3x+0x4e>
    280a:	7e f4       	brtc	.+30     	; 0x282a <__addsf3x+0x7c>
    280c:	1f 16       	cp	r1, r31
    280e:	ba 0b       	sbc	r27, r26
    2810:	62 0b       	sbc	r22, r18
    2812:	73 0b       	sbc	r23, r19
    2814:	84 0b       	sbc	r24, r20
    2816:	ba f0       	brmi	.+46     	; 0x2846 <__addsf3x+0x98>
    2818:	91 50       	subi	r25, 0x01	; 1
    281a:	a1 f0       	breq	.+40     	; 0x2844 <__addsf3x+0x96>
    281c:	ff 0f       	add	r31, r31
    281e:	bb 1f       	adc	r27, r27
    2820:	66 1f       	adc	r22, r22
    2822:	77 1f       	adc	r23, r23
    2824:	88 1f       	adc	r24, r24
    2826:	c2 f7       	brpl	.-16     	; 0x2818 <__addsf3x+0x6a>
    2828:	0e c0       	rjmp	.+28     	; 0x2846 <__addsf3x+0x98>
    282a:	ba 0f       	add	r27, r26
    282c:	62 1f       	adc	r22, r18
    282e:	73 1f       	adc	r23, r19
    2830:	84 1f       	adc	r24, r20
    2832:	48 f4       	brcc	.+18     	; 0x2846 <__addsf3x+0x98>
    2834:	87 95       	ror	r24
    2836:	77 95       	ror	r23
    2838:	67 95       	ror	r22
    283a:	b7 95       	ror	r27
    283c:	f7 95       	ror	r31
    283e:	9e 3f       	cpi	r25, 0xFE	; 254
    2840:	08 f0       	brcs	.+2      	; 0x2844 <__addsf3x+0x96>
    2842:	b3 cf       	rjmp	.-154    	; 0x27aa <__addsf3+0x1e>
    2844:	93 95       	inc	r25
    2846:	88 0f       	add	r24, r24
    2848:	08 f0       	brcs	.+2      	; 0x284c <__addsf3x+0x9e>
    284a:	99 27       	eor	r25, r25
    284c:	ee 0f       	add	r30, r30
    284e:	97 95       	ror	r25
    2850:	87 95       	ror	r24
    2852:	08 95       	ret

00002854 <__fixsfsi>:
    2854:	04 d0       	rcall	.+8      	; 0x285e <__fixunssfsi>
    2856:	68 94       	set
    2858:	b1 11       	cpse	r27, r1
    285a:	b5 c0       	rjmp	.+362    	; 0x29c6 <__fp_szero>
    285c:	08 95       	ret

0000285e <__fixunssfsi>:
    285e:	98 d0       	rcall	.+304    	; 0x2990 <__fp_splitA>
    2860:	88 f0       	brcs	.+34     	; 0x2884 <__fixunssfsi+0x26>
    2862:	9f 57       	subi	r25, 0x7F	; 127
    2864:	90 f0       	brcs	.+36     	; 0x288a <__fixunssfsi+0x2c>
    2866:	b9 2f       	mov	r27, r25
    2868:	99 27       	eor	r25, r25
    286a:	b7 51       	subi	r27, 0x17	; 23
    286c:	a0 f0       	brcs	.+40     	; 0x2896 <__fixunssfsi+0x38>
    286e:	d1 f0       	breq	.+52     	; 0x28a4 <__fixunssfsi+0x46>
    2870:	66 0f       	add	r22, r22
    2872:	77 1f       	adc	r23, r23
    2874:	88 1f       	adc	r24, r24
    2876:	99 1f       	adc	r25, r25
    2878:	1a f0       	brmi	.+6      	; 0x2880 <__fixunssfsi+0x22>
    287a:	ba 95       	dec	r27
    287c:	c9 f7       	brne	.-14     	; 0x2870 <__fixunssfsi+0x12>
    287e:	12 c0       	rjmp	.+36     	; 0x28a4 <__fixunssfsi+0x46>
    2880:	b1 30       	cpi	r27, 0x01	; 1
    2882:	81 f0       	breq	.+32     	; 0x28a4 <__fixunssfsi+0x46>
    2884:	9f d0       	rcall	.+318    	; 0x29c4 <__fp_zero>
    2886:	b1 e0       	ldi	r27, 0x01	; 1
    2888:	08 95       	ret
    288a:	9c c0       	rjmp	.+312    	; 0x29c4 <__fp_zero>
    288c:	67 2f       	mov	r22, r23
    288e:	78 2f       	mov	r23, r24
    2890:	88 27       	eor	r24, r24
    2892:	b8 5f       	subi	r27, 0xF8	; 248
    2894:	39 f0       	breq	.+14     	; 0x28a4 <__fixunssfsi+0x46>
    2896:	b9 3f       	cpi	r27, 0xF9	; 249
    2898:	cc f3       	brlt	.-14     	; 0x288c <__fixunssfsi+0x2e>
    289a:	86 95       	lsr	r24
    289c:	77 95       	ror	r23
    289e:	67 95       	ror	r22
    28a0:	b3 95       	inc	r27
    28a2:	d9 f7       	brne	.-10     	; 0x289a <__fixunssfsi+0x3c>
    28a4:	3e f4       	brtc	.+14     	; 0x28b4 <__fixunssfsi+0x56>
    28a6:	90 95       	com	r25
    28a8:	80 95       	com	r24
    28aa:	70 95       	com	r23
    28ac:	61 95       	neg	r22
    28ae:	7f 4f       	sbci	r23, 0xFF	; 255
    28b0:	8f 4f       	sbci	r24, 0xFF	; 255
    28b2:	9f 4f       	sbci	r25, 0xFF	; 255
    28b4:	08 95       	ret

000028b6 <__floatunsisf>:
    28b6:	e8 94       	clt
    28b8:	09 c0       	rjmp	.+18     	; 0x28cc <__floatsisf+0x12>

000028ba <__floatsisf>:
    28ba:	97 fb       	bst	r25, 7
    28bc:	3e f4       	brtc	.+14     	; 0x28cc <__floatsisf+0x12>
    28be:	90 95       	com	r25
    28c0:	80 95       	com	r24
    28c2:	70 95       	com	r23
    28c4:	61 95       	neg	r22
    28c6:	7f 4f       	sbci	r23, 0xFF	; 255
    28c8:	8f 4f       	sbci	r24, 0xFF	; 255
    28ca:	9f 4f       	sbci	r25, 0xFF	; 255
    28cc:	99 23       	and	r25, r25
    28ce:	a9 f0       	breq	.+42     	; 0x28fa <__floatsisf+0x40>
    28d0:	f9 2f       	mov	r31, r25
    28d2:	96 e9       	ldi	r25, 0x96	; 150
    28d4:	bb 27       	eor	r27, r27
    28d6:	93 95       	inc	r25
    28d8:	f6 95       	lsr	r31
    28da:	87 95       	ror	r24
    28dc:	77 95       	ror	r23
    28de:	67 95       	ror	r22
    28e0:	b7 95       	ror	r27
    28e2:	f1 11       	cpse	r31, r1
    28e4:	f8 cf       	rjmp	.-16     	; 0x28d6 <__floatsisf+0x1c>
    28e6:	fa f4       	brpl	.+62     	; 0x2926 <__floatsisf+0x6c>
    28e8:	bb 0f       	add	r27, r27
    28ea:	11 f4       	brne	.+4      	; 0x28f0 <__floatsisf+0x36>
    28ec:	60 ff       	sbrs	r22, 0
    28ee:	1b c0       	rjmp	.+54     	; 0x2926 <__floatsisf+0x6c>
    28f0:	6f 5f       	subi	r22, 0xFF	; 255
    28f2:	7f 4f       	sbci	r23, 0xFF	; 255
    28f4:	8f 4f       	sbci	r24, 0xFF	; 255
    28f6:	9f 4f       	sbci	r25, 0xFF	; 255
    28f8:	16 c0       	rjmp	.+44     	; 0x2926 <__floatsisf+0x6c>
    28fa:	88 23       	and	r24, r24
    28fc:	11 f0       	breq	.+4      	; 0x2902 <__floatsisf+0x48>
    28fe:	96 e9       	ldi	r25, 0x96	; 150
    2900:	11 c0       	rjmp	.+34     	; 0x2924 <__floatsisf+0x6a>
    2902:	77 23       	and	r23, r23
    2904:	21 f0       	breq	.+8      	; 0x290e <__floatsisf+0x54>
    2906:	9e e8       	ldi	r25, 0x8E	; 142
    2908:	87 2f       	mov	r24, r23
    290a:	76 2f       	mov	r23, r22
    290c:	05 c0       	rjmp	.+10     	; 0x2918 <__floatsisf+0x5e>
    290e:	66 23       	and	r22, r22
    2910:	71 f0       	breq	.+28     	; 0x292e <__floatsisf+0x74>
    2912:	96 e8       	ldi	r25, 0x86	; 134
    2914:	86 2f       	mov	r24, r22
    2916:	70 e0       	ldi	r23, 0x00	; 0
    2918:	60 e0       	ldi	r22, 0x00	; 0
    291a:	2a f0       	brmi	.+10     	; 0x2926 <__floatsisf+0x6c>
    291c:	9a 95       	dec	r25
    291e:	66 0f       	add	r22, r22
    2920:	77 1f       	adc	r23, r23
    2922:	88 1f       	adc	r24, r24
    2924:	da f7       	brpl	.-10     	; 0x291c <__floatsisf+0x62>
    2926:	88 0f       	add	r24, r24
    2928:	96 95       	lsr	r25
    292a:	87 95       	ror	r24
    292c:	97 f9       	bld	r25, 7
    292e:	08 95       	ret

00002930 <__fp_inf>:
    2930:	97 f9       	bld	r25, 7
    2932:	9f 67       	ori	r25, 0x7F	; 127
    2934:	80 e8       	ldi	r24, 0x80	; 128
    2936:	70 e0       	ldi	r23, 0x00	; 0
    2938:	60 e0       	ldi	r22, 0x00	; 0
    293a:	08 95       	ret

0000293c <__fp_nan>:
    293c:	9f ef       	ldi	r25, 0xFF	; 255
    293e:	80 ec       	ldi	r24, 0xC0	; 192
    2940:	08 95       	ret

00002942 <__fp_pscA>:
    2942:	00 24       	eor	r0, r0
    2944:	0a 94       	dec	r0
    2946:	16 16       	cp	r1, r22
    2948:	17 06       	cpc	r1, r23
    294a:	18 06       	cpc	r1, r24
    294c:	09 06       	cpc	r0, r25
    294e:	08 95       	ret

00002950 <__fp_pscB>:
    2950:	00 24       	eor	r0, r0
    2952:	0a 94       	dec	r0
    2954:	12 16       	cp	r1, r18
    2956:	13 06       	cpc	r1, r19
    2958:	14 06       	cpc	r1, r20
    295a:	05 06       	cpc	r0, r21
    295c:	08 95       	ret

0000295e <__fp_round>:
    295e:	09 2e       	mov	r0, r25
    2960:	03 94       	inc	r0
    2962:	00 0c       	add	r0, r0
    2964:	11 f4       	brne	.+4      	; 0x296a <__fp_round+0xc>
    2966:	88 23       	and	r24, r24
    2968:	52 f0       	brmi	.+20     	; 0x297e <__fp_round+0x20>
    296a:	bb 0f       	add	r27, r27
    296c:	40 f4       	brcc	.+16     	; 0x297e <__fp_round+0x20>
    296e:	bf 2b       	or	r27, r31
    2970:	11 f4       	brne	.+4      	; 0x2976 <__fp_round+0x18>
    2972:	60 ff       	sbrs	r22, 0
    2974:	04 c0       	rjmp	.+8      	; 0x297e <__fp_round+0x20>
    2976:	6f 5f       	subi	r22, 0xFF	; 255
    2978:	7f 4f       	sbci	r23, 0xFF	; 255
    297a:	8f 4f       	sbci	r24, 0xFF	; 255
    297c:	9f 4f       	sbci	r25, 0xFF	; 255
    297e:	08 95       	ret

00002980 <__fp_split3>:
    2980:	57 fd       	sbrc	r21, 7
    2982:	90 58       	subi	r25, 0x80	; 128
    2984:	44 0f       	add	r20, r20
    2986:	55 1f       	adc	r21, r21
    2988:	59 f0       	breq	.+22     	; 0x29a0 <__fp_splitA+0x10>
    298a:	5f 3f       	cpi	r21, 0xFF	; 255
    298c:	71 f0       	breq	.+28     	; 0x29aa <__fp_splitA+0x1a>
    298e:	47 95       	ror	r20

00002990 <__fp_splitA>:
    2990:	88 0f       	add	r24, r24
    2992:	97 fb       	bst	r25, 7
    2994:	99 1f       	adc	r25, r25
    2996:	61 f0       	breq	.+24     	; 0x29b0 <__fp_splitA+0x20>
    2998:	9f 3f       	cpi	r25, 0xFF	; 255
    299a:	79 f0       	breq	.+30     	; 0x29ba <__fp_splitA+0x2a>
    299c:	87 95       	ror	r24
    299e:	08 95       	ret
    29a0:	12 16       	cp	r1, r18
    29a2:	13 06       	cpc	r1, r19
    29a4:	14 06       	cpc	r1, r20
    29a6:	55 1f       	adc	r21, r21
    29a8:	f2 cf       	rjmp	.-28     	; 0x298e <__fp_split3+0xe>
    29aa:	46 95       	lsr	r20
    29ac:	f1 df       	rcall	.-30     	; 0x2990 <__fp_splitA>
    29ae:	08 c0       	rjmp	.+16     	; 0x29c0 <__fp_splitA+0x30>
    29b0:	16 16       	cp	r1, r22
    29b2:	17 06       	cpc	r1, r23
    29b4:	18 06       	cpc	r1, r24
    29b6:	99 1f       	adc	r25, r25
    29b8:	f1 cf       	rjmp	.-30     	; 0x299c <__fp_splitA+0xc>
    29ba:	86 95       	lsr	r24
    29bc:	71 05       	cpc	r23, r1
    29be:	61 05       	cpc	r22, r1
    29c0:	08 94       	sec
    29c2:	08 95       	ret

000029c4 <__fp_zero>:
    29c4:	e8 94       	clt

000029c6 <__fp_szero>:
    29c6:	bb 27       	eor	r27, r27
    29c8:	66 27       	eor	r22, r22
    29ca:	77 27       	eor	r23, r23
    29cc:	cb 01       	movw	r24, r22
    29ce:	97 f9       	bld	r25, 7
    29d0:	08 95       	ret

000029d2 <__mulsf3>:
    29d2:	0b d0       	rcall	.+22     	; 0x29ea <__mulsf3x>
    29d4:	c4 cf       	rjmp	.-120    	; 0x295e <__fp_round>
    29d6:	b5 df       	rcall	.-150    	; 0x2942 <__fp_pscA>
    29d8:	28 f0       	brcs	.+10     	; 0x29e4 <__mulsf3+0x12>
    29da:	ba df       	rcall	.-140    	; 0x2950 <__fp_pscB>
    29dc:	18 f0       	brcs	.+6      	; 0x29e4 <__mulsf3+0x12>
    29de:	95 23       	and	r25, r21
    29e0:	09 f0       	breq	.+2      	; 0x29e4 <__mulsf3+0x12>
    29e2:	a6 cf       	rjmp	.-180    	; 0x2930 <__fp_inf>
    29e4:	ab cf       	rjmp	.-170    	; 0x293c <__fp_nan>
    29e6:	11 24       	eor	r1, r1
    29e8:	ee cf       	rjmp	.-36     	; 0x29c6 <__fp_szero>

000029ea <__mulsf3x>:
    29ea:	ca df       	rcall	.-108    	; 0x2980 <__fp_split3>
    29ec:	a0 f3       	brcs	.-24     	; 0x29d6 <__mulsf3+0x4>

000029ee <__mulsf3_pse>:
    29ee:	95 9f       	mul	r25, r21
    29f0:	d1 f3       	breq	.-12     	; 0x29e6 <__mulsf3+0x14>
    29f2:	95 0f       	add	r25, r21
    29f4:	50 e0       	ldi	r21, 0x00	; 0
    29f6:	55 1f       	adc	r21, r21
    29f8:	62 9f       	mul	r22, r18
    29fa:	f0 01       	movw	r30, r0
    29fc:	72 9f       	mul	r23, r18
    29fe:	bb 27       	eor	r27, r27
    2a00:	f0 0d       	add	r31, r0
    2a02:	b1 1d       	adc	r27, r1
    2a04:	63 9f       	mul	r22, r19
    2a06:	aa 27       	eor	r26, r26
    2a08:	f0 0d       	add	r31, r0
    2a0a:	b1 1d       	adc	r27, r1
    2a0c:	aa 1f       	adc	r26, r26
    2a0e:	64 9f       	mul	r22, r20
    2a10:	66 27       	eor	r22, r22
    2a12:	b0 0d       	add	r27, r0
    2a14:	a1 1d       	adc	r26, r1
    2a16:	66 1f       	adc	r22, r22
    2a18:	82 9f       	mul	r24, r18
    2a1a:	22 27       	eor	r18, r18
    2a1c:	b0 0d       	add	r27, r0
    2a1e:	a1 1d       	adc	r26, r1
    2a20:	62 1f       	adc	r22, r18
    2a22:	73 9f       	mul	r23, r19
    2a24:	b0 0d       	add	r27, r0
    2a26:	a1 1d       	adc	r26, r1
    2a28:	62 1f       	adc	r22, r18
    2a2a:	83 9f       	mul	r24, r19
    2a2c:	a0 0d       	add	r26, r0
    2a2e:	61 1d       	adc	r22, r1
    2a30:	22 1f       	adc	r18, r18
    2a32:	74 9f       	mul	r23, r20
    2a34:	33 27       	eor	r19, r19
    2a36:	a0 0d       	add	r26, r0
    2a38:	61 1d       	adc	r22, r1
    2a3a:	23 1f       	adc	r18, r19
    2a3c:	84 9f       	mul	r24, r20
    2a3e:	60 0d       	add	r22, r0
    2a40:	21 1d       	adc	r18, r1
    2a42:	82 2f       	mov	r24, r18
    2a44:	76 2f       	mov	r23, r22
    2a46:	6a 2f       	mov	r22, r26
    2a48:	11 24       	eor	r1, r1
    2a4a:	9f 57       	subi	r25, 0x7F	; 127
    2a4c:	50 40       	sbci	r21, 0x00	; 0
    2a4e:	8a f0       	brmi	.+34     	; 0x2a72 <__mulsf3_pse+0x84>
    2a50:	e1 f0       	breq	.+56     	; 0x2a8a <__mulsf3_pse+0x9c>
    2a52:	88 23       	and	r24, r24
    2a54:	4a f0       	brmi	.+18     	; 0x2a68 <__mulsf3_pse+0x7a>
    2a56:	ee 0f       	add	r30, r30
    2a58:	ff 1f       	adc	r31, r31
    2a5a:	bb 1f       	adc	r27, r27
    2a5c:	66 1f       	adc	r22, r22
    2a5e:	77 1f       	adc	r23, r23
    2a60:	88 1f       	adc	r24, r24
    2a62:	91 50       	subi	r25, 0x01	; 1
    2a64:	50 40       	sbci	r21, 0x00	; 0
    2a66:	a9 f7       	brne	.-22     	; 0x2a52 <__mulsf3_pse+0x64>
    2a68:	9e 3f       	cpi	r25, 0xFE	; 254
    2a6a:	51 05       	cpc	r21, r1
    2a6c:	70 f0       	brcs	.+28     	; 0x2a8a <__mulsf3_pse+0x9c>
    2a6e:	60 cf       	rjmp	.-320    	; 0x2930 <__fp_inf>
    2a70:	aa cf       	rjmp	.-172    	; 0x29c6 <__fp_szero>
    2a72:	5f 3f       	cpi	r21, 0xFF	; 255
    2a74:	ec f3       	brlt	.-6      	; 0x2a70 <__mulsf3_pse+0x82>
    2a76:	98 3e       	cpi	r25, 0xE8	; 232
    2a78:	dc f3       	brlt	.-10     	; 0x2a70 <__mulsf3_pse+0x82>
    2a7a:	86 95       	lsr	r24
    2a7c:	77 95       	ror	r23
    2a7e:	67 95       	ror	r22
    2a80:	b7 95       	ror	r27
    2a82:	f7 95       	ror	r31
    2a84:	e7 95       	ror	r30
    2a86:	9f 5f       	subi	r25, 0xFF	; 255
    2a88:	c1 f7       	brne	.-16     	; 0x2a7a <__mulsf3_pse+0x8c>
    2a8a:	fe 2b       	or	r31, r30
    2a8c:	88 0f       	add	r24, r24
    2a8e:	91 1d       	adc	r25, r1
    2a90:	96 95       	lsr	r25
    2a92:	87 95       	ror	r24
    2a94:	97 f9       	bld	r25, 7
    2a96:	08 95       	ret

00002a98 <pow>:
    2a98:	fa 01       	movw	r30, r20
    2a9a:	ee 0f       	add	r30, r30
    2a9c:	ff 1f       	adc	r31, r31
    2a9e:	30 96       	adiw	r30, 0x00	; 0
    2aa0:	21 05       	cpc	r18, r1
    2aa2:	31 05       	cpc	r19, r1
    2aa4:	99 f1       	breq	.+102    	; 0x2b0c <pow+0x74>
    2aa6:	61 15       	cp	r22, r1
    2aa8:	71 05       	cpc	r23, r1
    2aaa:	61 f4       	brne	.+24     	; 0x2ac4 <pow+0x2c>
    2aac:	80 38       	cpi	r24, 0x80	; 128
    2aae:	bf e3       	ldi	r27, 0x3F	; 63
    2ab0:	9b 07       	cpc	r25, r27
    2ab2:	49 f1       	breq	.+82     	; 0x2b06 <pow+0x6e>
    2ab4:	68 94       	set
    2ab6:	90 38       	cpi	r25, 0x80	; 128
    2ab8:	81 05       	cpc	r24, r1
    2aba:	61 f0       	breq	.+24     	; 0x2ad4 <pow+0x3c>
    2abc:	80 38       	cpi	r24, 0x80	; 128
    2abe:	bf ef       	ldi	r27, 0xFF	; 255
    2ac0:	9b 07       	cpc	r25, r27
    2ac2:	41 f0       	breq	.+16     	; 0x2ad4 <pow+0x3c>
    2ac4:	99 23       	and	r25, r25
    2ac6:	42 f5       	brpl	.+80     	; 0x2b18 <pow+0x80>
    2ac8:	ff 3f       	cpi	r31, 0xFF	; 255
    2aca:	e1 05       	cpc	r30, r1
    2acc:	31 05       	cpc	r19, r1
    2ace:	21 05       	cpc	r18, r1
    2ad0:	11 f1       	breq	.+68     	; 0x2b16 <pow+0x7e>
    2ad2:	e8 94       	clt
    2ad4:	08 94       	sec
    2ad6:	e7 95       	ror	r30
    2ad8:	d9 01       	movw	r26, r18
    2ada:	aa 23       	and	r26, r26
    2adc:	29 f4       	brne	.+10     	; 0x2ae8 <pow+0x50>
    2ade:	ab 2f       	mov	r26, r27
    2ae0:	be 2f       	mov	r27, r30
    2ae2:	f8 5f       	subi	r31, 0xF8	; 248
    2ae4:	d0 f3       	brcs	.-12     	; 0x2ada <pow+0x42>
    2ae6:	10 c0       	rjmp	.+32     	; 0x2b08 <pow+0x70>
    2ae8:	ff 5f       	subi	r31, 0xFF	; 255
    2aea:	70 f4       	brcc	.+28     	; 0x2b08 <pow+0x70>
    2aec:	a6 95       	lsr	r26
    2aee:	e0 f7       	brcc	.-8      	; 0x2ae8 <pow+0x50>
    2af0:	f7 39       	cpi	r31, 0x97	; 151
    2af2:	50 f0       	brcs	.+20     	; 0x2b08 <pow+0x70>
    2af4:	19 f0       	breq	.+6      	; 0x2afc <pow+0x64>
    2af6:	ff 3a       	cpi	r31, 0xAF	; 175
    2af8:	38 f4       	brcc	.+14     	; 0x2b08 <pow+0x70>
    2afa:	9f 77       	andi	r25, 0x7F	; 127
    2afc:	9f 93       	push	r25
    2afe:	0c d0       	rcall	.+24     	; 0x2b18 <pow+0x80>
    2b00:	0f 90       	pop	r0
    2b02:	07 fc       	sbrc	r0, 7
    2b04:	90 58       	subi	r25, 0x80	; 128
    2b06:	08 95       	ret
    2b08:	3e f0       	brts	.+14     	; 0x2b18 <pow+0x80>
    2b0a:	18 cf       	rjmp	.-464    	; 0x293c <__fp_nan>
    2b0c:	60 e0       	ldi	r22, 0x00	; 0
    2b0e:	70 e0       	ldi	r23, 0x00	; 0
    2b10:	80 e8       	ldi	r24, 0x80	; 128
    2b12:	9f e3       	ldi	r25, 0x3F	; 63
    2b14:	08 95       	ret
    2b16:	4f e7       	ldi	r20, 0x7F	; 127
    2b18:	9f 77       	andi	r25, 0x7F	; 127
    2b1a:	5f 93       	push	r21
    2b1c:	4f 93       	push	r20
    2b1e:	3f 93       	push	r19
    2b20:	2f 93       	push	r18
    2b22:	9e d0       	rcall	.+316    	; 0x2c60 <log>
    2b24:	2f 91       	pop	r18
    2b26:	3f 91       	pop	r19
    2b28:	4f 91       	pop	r20
    2b2a:	5f 91       	pop	r21
    2b2c:	52 df       	rcall	.-348    	; 0x29d2 <__mulsf3>
    2b2e:	05 c0       	rjmp	.+10     	; 0x2b3a <exp>
    2b30:	19 f4       	brne	.+6      	; 0x2b38 <pow+0xa0>
    2b32:	0e f0       	brts	.+2      	; 0x2b36 <pow+0x9e>
    2b34:	fd ce       	rjmp	.-518    	; 0x2930 <__fp_inf>
    2b36:	46 cf       	rjmp	.-372    	; 0x29c4 <__fp_zero>
    2b38:	01 cf       	rjmp	.-510    	; 0x293c <__fp_nan>

00002b3a <exp>:
    2b3a:	2a df       	rcall	.-428    	; 0x2990 <__fp_splitA>
    2b3c:	c8 f3       	brcs	.-14     	; 0x2b30 <pow+0x98>
    2b3e:	96 38       	cpi	r25, 0x86	; 134
    2b40:	c0 f7       	brcc	.-16     	; 0x2b32 <pow+0x9a>
    2b42:	07 f8       	bld	r0, 7
    2b44:	0f 92       	push	r0
    2b46:	e8 94       	clt
    2b48:	2b e3       	ldi	r18, 0x3B	; 59
    2b4a:	3a ea       	ldi	r19, 0xAA	; 170
    2b4c:	48 eb       	ldi	r20, 0xB8	; 184
    2b4e:	5f e7       	ldi	r21, 0x7F	; 127
    2b50:	4e df       	rcall	.-356    	; 0x29ee <__mulsf3_pse>
    2b52:	0f 92       	push	r0
    2b54:	0f 92       	push	r0
    2b56:	0f 92       	push	r0
    2b58:	4d b7       	in	r20, 0x3d	; 61
    2b5a:	5e b7       	in	r21, 0x3e	; 62
    2b5c:	0f 92       	push	r0
    2b5e:	c0 d0       	rcall	.+384    	; 0x2ce0 <modf>
    2b60:	e4 ee       	ldi	r30, 0xE4	; 228
    2b62:	f0 e0       	ldi	r31, 0x00	; 0
    2b64:	16 d0       	rcall	.+44     	; 0x2b92 <__fp_powser>
    2b66:	4f 91       	pop	r20
    2b68:	5f 91       	pop	r21
    2b6a:	ef 91       	pop	r30
    2b6c:	ff 91       	pop	r31
    2b6e:	e5 95       	asr	r30
    2b70:	ee 1f       	adc	r30, r30
    2b72:	ff 1f       	adc	r31, r31
    2b74:	49 f0       	breq	.+18     	; 0x2b88 <exp+0x4e>
    2b76:	fe 57       	subi	r31, 0x7E	; 126
    2b78:	e0 68       	ori	r30, 0x80	; 128
    2b7a:	44 27       	eor	r20, r20
    2b7c:	ee 0f       	add	r30, r30
    2b7e:	44 1f       	adc	r20, r20
    2b80:	fa 95       	dec	r31
    2b82:	e1 f7       	brne	.-8      	; 0x2b7c <exp+0x42>
    2b84:	41 95       	neg	r20
    2b86:	55 0b       	sbc	r21, r21
    2b88:	32 d0       	rcall	.+100    	; 0x2bee <ldexp>
    2b8a:	0f 90       	pop	r0
    2b8c:	07 fe       	sbrs	r0, 7
    2b8e:	26 c0       	rjmp	.+76     	; 0x2bdc <inverse>
    2b90:	08 95       	ret

00002b92 <__fp_powser>:
    2b92:	df 93       	push	r29
    2b94:	cf 93       	push	r28
    2b96:	1f 93       	push	r17
    2b98:	0f 93       	push	r16
    2b9a:	ff 92       	push	r15
    2b9c:	ef 92       	push	r14
    2b9e:	df 92       	push	r13
    2ba0:	7b 01       	movw	r14, r22
    2ba2:	8c 01       	movw	r16, r24
    2ba4:	68 94       	set
    2ba6:	05 c0       	rjmp	.+10     	; 0x2bb2 <__fp_powser+0x20>
    2ba8:	da 2e       	mov	r13, r26
    2baa:	ef 01       	movw	r28, r30
    2bac:	1e df       	rcall	.-452    	; 0x29ea <__mulsf3x>
    2bae:	fe 01       	movw	r30, r28
    2bb0:	e8 94       	clt
    2bb2:	a5 91       	lpm	r26, Z+
    2bb4:	25 91       	lpm	r18, Z+
    2bb6:	35 91       	lpm	r19, Z+
    2bb8:	45 91       	lpm	r20, Z+
    2bba:	55 91       	lpm	r21, Z+
    2bbc:	ae f3       	brts	.-22     	; 0x2ba8 <__fp_powser+0x16>
    2bbe:	ef 01       	movw	r28, r30
    2bc0:	f6 dd       	rcall	.-1044   	; 0x27ae <__addsf3x>
    2bc2:	fe 01       	movw	r30, r28
    2bc4:	97 01       	movw	r18, r14
    2bc6:	a8 01       	movw	r20, r16
    2bc8:	da 94       	dec	r13
    2bca:	79 f7       	brne	.-34     	; 0x2baa <__fp_powser+0x18>
    2bcc:	df 90       	pop	r13
    2bce:	ef 90       	pop	r14
    2bd0:	ff 90       	pop	r15
    2bd2:	0f 91       	pop	r16
    2bd4:	1f 91       	pop	r17
    2bd6:	cf 91       	pop	r28
    2bd8:	df 91       	pop	r29
    2bda:	08 95       	ret

00002bdc <inverse>:
    2bdc:	9b 01       	movw	r18, r22
    2bde:	ac 01       	movw	r20, r24
    2be0:	60 e0       	ldi	r22, 0x00	; 0
    2be2:	70 e0       	ldi	r23, 0x00	; 0
    2be4:	80 e8       	ldi	r24, 0x80	; 128
    2be6:	9f e3       	ldi	r25, 0x3F	; 63
    2be8:	ae c0       	rjmp	.+348    	; 0x2d46 <__divsf3>
    2bea:	a2 ce       	rjmp	.-700    	; 0x2930 <__fp_inf>
    2bec:	14 c1       	rjmp	.+552    	; 0x2e16 <__fp_mpack>

00002bee <ldexp>:
    2bee:	d0 de       	rcall	.-608    	; 0x2990 <__fp_splitA>
    2bf0:	e8 f3       	brcs	.-6      	; 0x2bec <inverse+0x10>
    2bf2:	99 23       	and	r25, r25
    2bf4:	d9 f3       	breq	.-10     	; 0x2bec <inverse+0x10>
    2bf6:	94 0f       	add	r25, r20
    2bf8:	51 1d       	adc	r21, r1
    2bfa:	bb f3       	brvs	.-18     	; 0x2bea <inverse+0xe>
    2bfc:	91 50       	subi	r25, 0x01	; 1
    2bfe:	50 40       	sbci	r21, 0x00	; 0
    2c00:	94 f0       	brlt	.+36     	; 0x2c26 <ldexp+0x38>
    2c02:	59 f0       	breq	.+22     	; 0x2c1a <ldexp+0x2c>
    2c04:	88 23       	and	r24, r24
    2c06:	32 f0       	brmi	.+12     	; 0x2c14 <ldexp+0x26>
    2c08:	66 0f       	add	r22, r22
    2c0a:	77 1f       	adc	r23, r23
    2c0c:	88 1f       	adc	r24, r24
    2c0e:	91 50       	subi	r25, 0x01	; 1
    2c10:	50 40       	sbci	r21, 0x00	; 0
    2c12:	c1 f7       	brne	.-16     	; 0x2c04 <ldexp+0x16>
    2c14:	9e 3f       	cpi	r25, 0xFE	; 254
    2c16:	51 05       	cpc	r21, r1
    2c18:	44 f7       	brge	.-48     	; 0x2bea <inverse+0xe>
    2c1a:	88 0f       	add	r24, r24
    2c1c:	91 1d       	adc	r25, r1
    2c1e:	96 95       	lsr	r25
    2c20:	87 95       	ror	r24
    2c22:	97 f9       	bld	r25, 7
    2c24:	08 95       	ret
    2c26:	5f 3f       	cpi	r21, 0xFF	; 255
    2c28:	ac f0       	brlt	.+42     	; 0x2c54 <ldexp+0x66>
    2c2a:	98 3e       	cpi	r25, 0xE8	; 232
    2c2c:	9c f0       	brlt	.+38     	; 0x2c54 <ldexp+0x66>
    2c2e:	bb 27       	eor	r27, r27
    2c30:	86 95       	lsr	r24
    2c32:	77 95       	ror	r23
    2c34:	67 95       	ror	r22
    2c36:	b7 95       	ror	r27
    2c38:	08 f4       	brcc	.+2      	; 0x2c3c <ldexp+0x4e>
    2c3a:	b1 60       	ori	r27, 0x01	; 1
    2c3c:	93 95       	inc	r25
    2c3e:	c1 f7       	brne	.-16     	; 0x2c30 <ldexp+0x42>
    2c40:	bb 0f       	add	r27, r27
    2c42:	58 f7       	brcc	.-42     	; 0x2c1a <ldexp+0x2c>
    2c44:	11 f4       	brne	.+4      	; 0x2c4a <ldexp+0x5c>
    2c46:	60 ff       	sbrs	r22, 0
    2c48:	e8 cf       	rjmp	.-48     	; 0x2c1a <ldexp+0x2c>
    2c4a:	6f 5f       	subi	r22, 0xFF	; 255
    2c4c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c4e:	8f 4f       	sbci	r24, 0xFF	; 255
    2c50:	9f 4f       	sbci	r25, 0xFF	; 255
    2c52:	e3 cf       	rjmp	.-58     	; 0x2c1a <ldexp+0x2c>
    2c54:	b8 ce       	rjmp	.-656    	; 0x29c6 <__fp_szero>
    2c56:	0e f0       	brts	.+2      	; 0x2c5a <ldexp+0x6c>
    2c58:	de c0       	rjmp	.+444    	; 0x2e16 <__fp_mpack>
    2c5a:	70 ce       	rjmp	.-800    	; 0x293c <__fp_nan>
    2c5c:	68 94       	set
    2c5e:	68 ce       	rjmp	.-816    	; 0x2930 <__fp_inf>

00002c60 <log>:
    2c60:	97 de       	rcall	.-722    	; 0x2990 <__fp_splitA>
    2c62:	c8 f3       	brcs	.-14     	; 0x2c56 <ldexp+0x68>
    2c64:	99 23       	and	r25, r25
    2c66:	d1 f3       	breq	.-12     	; 0x2c5c <ldexp+0x6e>
    2c68:	c6 f3       	brts	.-16     	; 0x2c5a <ldexp+0x6c>
    2c6a:	df 93       	push	r29
    2c6c:	cf 93       	push	r28
    2c6e:	1f 93       	push	r17
    2c70:	0f 93       	push	r16
    2c72:	ff 92       	push	r15
    2c74:	c9 2f       	mov	r28, r25
    2c76:	dd 27       	eor	r29, r29
    2c78:	88 23       	and	r24, r24
    2c7a:	2a f0       	brmi	.+10     	; 0x2c86 <log+0x26>
    2c7c:	21 97       	sbiw	r28, 0x01	; 1
    2c7e:	66 0f       	add	r22, r22
    2c80:	77 1f       	adc	r23, r23
    2c82:	88 1f       	adc	r24, r24
    2c84:	da f7       	brpl	.-10     	; 0x2c7c <log+0x1c>
    2c86:	20 e0       	ldi	r18, 0x00	; 0
    2c88:	30 e0       	ldi	r19, 0x00	; 0
    2c8a:	40 e8       	ldi	r20, 0x80	; 128
    2c8c:	5f eb       	ldi	r21, 0xBF	; 191
    2c8e:	9f e3       	ldi	r25, 0x3F	; 63
    2c90:	88 39       	cpi	r24, 0x98	; 152
    2c92:	20 f0       	brcs	.+8      	; 0x2c9c <log+0x3c>
    2c94:	80 3e       	cpi	r24, 0xE0	; 224
    2c96:	30 f0       	brcs	.+12     	; 0x2ca4 <log+0x44>
    2c98:	21 96       	adiw	r28, 0x01	; 1
    2c9a:	8f 77       	andi	r24, 0x7F	; 127
    2c9c:	77 dd       	rcall	.-1298   	; 0x278c <__addsf3>
    2c9e:	ec e0       	ldi	r30, 0x0C	; 12
    2ca0:	f1 e0       	ldi	r31, 0x01	; 1
    2ca2:	03 c0       	rjmp	.+6      	; 0x2caa <log+0x4a>
    2ca4:	73 dd       	rcall	.-1306   	; 0x278c <__addsf3>
    2ca6:	e9 e3       	ldi	r30, 0x39	; 57
    2ca8:	f1 e0       	ldi	r31, 0x01	; 1
    2caa:	73 df       	rcall	.-282    	; 0x2b92 <__fp_powser>
    2cac:	8b 01       	movw	r16, r22
    2cae:	be 01       	movw	r22, r28
    2cb0:	ec 01       	movw	r28, r24
    2cb2:	fb 2e       	mov	r15, r27
    2cb4:	6f 57       	subi	r22, 0x7F	; 127
    2cb6:	71 09       	sbc	r23, r1
    2cb8:	75 95       	asr	r23
    2cba:	77 1f       	adc	r23, r23
    2cbc:	88 0b       	sbc	r24, r24
    2cbe:	99 0b       	sbc	r25, r25
    2cc0:	fc dd       	rcall	.-1032   	; 0x28ba <__floatsisf>
    2cc2:	28 e1       	ldi	r18, 0x18	; 24
    2cc4:	32 e7       	ldi	r19, 0x72	; 114
    2cc6:	41 e3       	ldi	r20, 0x31	; 49
    2cc8:	5f e3       	ldi	r21, 0x3F	; 63
    2cca:	8f de       	rcall	.-738    	; 0x29ea <__mulsf3x>
    2ccc:	af 2d       	mov	r26, r15
    2cce:	98 01       	movw	r18, r16
    2cd0:	ae 01       	movw	r20, r28
    2cd2:	ff 90       	pop	r15
    2cd4:	0f 91       	pop	r16
    2cd6:	1f 91       	pop	r17
    2cd8:	cf 91       	pop	r28
    2cda:	df 91       	pop	r29
    2cdc:	68 dd       	rcall	.-1328   	; 0x27ae <__addsf3x>
    2cde:	3f ce       	rjmp	.-898    	; 0x295e <__fp_round>

00002ce0 <modf>:
    2ce0:	fa 01       	movw	r30, r20
    2ce2:	dc 01       	movw	r26, r24
    2ce4:	aa 0f       	add	r26, r26
    2ce6:	bb 1f       	adc	r27, r27
    2ce8:	9b 01       	movw	r18, r22
    2cea:	ac 01       	movw	r20, r24
    2cec:	bf 57       	subi	r27, 0x7F	; 127
    2cee:	28 f4       	brcc	.+10     	; 0x2cfa <modf+0x1a>
    2cf0:	22 27       	eor	r18, r18
    2cf2:	33 27       	eor	r19, r19
    2cf4:	44 27       	eor	r20, r20
    2cf6:	50 78       	andi	r21, 0x80	; 128
    2cf8:	1f c0       	rjmp	.+62     	; 0x2d38 <modf+0x58>
    2cfa:	b7 51       	subi	r27, 0x17	; 23
    2cfc:	88 f4       	brcc	.+34     	; 0x2d20 <modf+0x40>
    2cfe:	ab 2f       	mov	r26, r27
    2d00:	00 24       	eor	r0, r0
    2d02:	46 95       	lsr	r20
    2d04:	37 95       	ror	r19
    2d06:	27 95       	ror	r18
    2d08:	01 1c       	adc	r0, r1
    2d0a:	a3 95       	inc	r26
    2d0c:	d2 f3       	brmi	.-12     	; 0x2d02 <modf+0x22>
    2d0e:	00 20       	and	r0, r0
    2d10:	69 f0       	breq	.+26     	; 0x2d2c <modf+0x4c>
    2d12:	22 0f       	add	r18, r18
    2d14:	33 1f       	adc	r19, r19
    2d16:	44 1f       	adc	r20, r20
    2d18:	b3 95       	inc	r27
    2d1a:	da f3       	brmi	.-10     	; 0x2d12 <modf+0x32>
    2d1c:	0d d0       	rcall	.+26     	; 0x2d38 <modf+0x58>
    2d1e:	35 cd       	rjmp	.-1430   	; 0x278a <__subsf3>
    2d20:	61 30       	cpi	r22, 0x01	; 1
    2d22:	71 05       	cpc	r23, r1
    2d24:	a0 e8       	ldi	r26, 0x80	; 128
    2d26:	8a 07       	cpc	r24, r26
    2d28:	b9 46       	sbci	r27, 0x69	; 105
    2d2a:	30 f4       	brcc	.+12     	; 0x2d38 <modf+0x58>
    2d2c:	9b 01       	movw	r18, r22
    2d2e:	ac 01       	movw	r20, r24
    2d30:	66 27       	eor	r22, r22
    2d32:	77 27       	eor	r23, r23
    2d34:	88 27       	eor	r24, r24
    2d36:	90 78       	andi	r25, 0x80	; 128
    2d38:	30 96       	adiw	r30, 0x00	; 0
    2d3a:	21 f0       	breq	.+8      	; 0x2d44 <modf+0x64>
    2d3c:	20 83       	st	Z, r18
    2d3e:	31 83       	std	Z+1, r19	; 0x01
    2d40:	42 83       	std	Z+2, r20	; 0x02
    2d42:	53 83       	std	Z+3, r21	; 0x03
    2d44:	08 95       	ret

00002d46 <__divsf3>:
    2d46:	0c d0       	rcall	.+24     	; 0x2d60 <__divsf3x>
    2d48:	0a ce       	rjmp	.-1004   	; 0x295e <__fp_round>
    2d4a:	02 de       	rcall	.-1020   	; 0x2950 <__fp_pscB>
    2d4c:	40 f0       	brcs	.+16     	; 0x2d5e <__divsf3+0x18>
    2d4e:	f9 dd       	rcall	.-1038   	; 0x2942 <__fp_pscA>
    2d50:	30 f0       	brcs	.+12     	; 0x2d5e <__divsf3+0x18>
    2d52:	21 f4       	brne	.+8      	; 0x2d5c <__divsf3+0x16>
    2d54:	5f 3f       	cpi	r21, 0xFF	; 255
    2d56:	19 f0       	breq	.+6      	; 0x2d5e <__divsf3+0x18>
    2d58:	eb cd       	rjmp	.-1066   	; 0x2930 <__fp_inf>
    2d5a:	51 11       	cpse	r21, r1
    2d5c:	34 ce       	rjmp	.-920    	; 0x29c6 <__fp_szero>
    2d5e:	ee cd       	rjmp	.-1060   	; 0x293c <__fp_nan>

00002d60 <__divsf3x>:
    2d60:	0f de       	rcall	.-994    	; 0x2980 <__fp_split3>
    2d62:	98 f3       	brcs	.-26     	; 0x2d4a <__divsf3+0x4>

00002d64 <__divsf3_pse>:
    2d64:	99 23       	and	r25, r25
    2d66:	c9 f3       	breq	.-14     	; 0x2d5a <__divsf3+0x14>
    2d68:	55 23       	and	r21, r21
    2d6a:	b1 f3       	breq	.-20     	; 0x2d58 <__divsf3+0x12>
    2d6c:	95 1b       	sub	r25, r21
    2d6e:	55 0b       	sbc	r21, r21
    2d70:	bb 27       	eor	r27, r27
    2d72:	aa 27       	eor	r26, r26
    2d74:	62 17       	cp	r22, r18
    2d76:	73 07       	cpc	r23, r19
    2d78:	84 07       	cpc	r24, r20
    2d7a:	38 f0       	brcs	.+14     	; 0x2d8a <__divsf3_pse+0x26>
    2d7c:	9f 5f       	subi	r25, 0xFF	; 255
    2d7e:	5f 4f       	sbci	r21, 0xFF	; 255
    2d80:	22 0f       	add	r18, r18
    2d82:	33 1f       	adc	r19, r19
    2d84:	44 1f       	adc	r20, r20
    2d86:	aa 1f       	adc	r26, r26
    2d88:	a9 f3       	breq	.-22     	; 0x2d74 <__divsf3_pse+0x10>
    2d8a:	33 d0       	rcall	.+102    	; 0x2df2 <__divsf3_pse+0x8e>
    2d8c:	0e 2e       	mov	r0, r30
    2d8e:	3a f0       	brmi	.+14     	; 0x2d9e <__divsf3_pse+0x3a>
    2d90:	e0 e8       	ldi	r30, 0x80	; 128
    2d92:	30 d0       	rcall	.+96     	; 0x2df4 <__divsf3_pse+0x90>
    2d94:	91 50       	subi	r25, 0x01	; 1
    2d96:	50 40       	sbci	r21, 0x00	; 0
    2d98:	e6 95       	lsr	r30
    2d9a:	00 1c       	adc	r0, r0
    2d9c:	ca f7       	brpl	.-14     	; 0x2d90 <__divsf3_pse+0x2c>
    2d9e:	29 d0       	rcall	.+82     	; 0x2df2 <__divsf3_pse+0x8e>
    2da0:	fe 2f       	mov	r31, r30
    2da2:	27 d0       	rcall	.+78     	; 0x2df2 <__divsf3_pse+0x8e>
    2da4:	66 0f       	add	r22, r22
    2da6:	77 1f       	adc	r23, r23
    2da8:	88 1f       	adc	r24, r24
    2daa:	bb 1f       	adc	r27, r27
    2dac:	26 17       	cp	r18, r22
    2dae:	37 07       	cpc	r19, r23
    2db0:	48 07       	cpc	r20, r24
    2db2:	ab 07       	cpc	r26, r27
    2db4:	b0 e8       	ldi	r27, 0x80	; 128
    2db6:	09 f0       	breq	.+2      	; 0x2dba <__divsf3_pse+0x56>
    2db8:	bb 0b       	sbc	r27, r27
    2dba:	80 2d       	mov	r24, r0
    2dbc:	bf 01       	movw	r22, r30
    2dbe:	ff 27       	eor	r31, r31
    2dc0:	93 58       	subi	r25, 0x83	; 131
    2dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    2dc4:	2a f0       	brmi	.+10     	; 0x2dd0 <__divsf3_pse+0x6c>
    2dc6:	9e 3f       	cpi	r25, 0xFE	; 254
    2dc8:	51 05       	cpc	r21, r1
    2dca:	68 f0       	brcs	.+26     	; 0x2de6 <__divsf3_pse+0x82>
    2dcc:	b1 cd       	rjmp	.-1182   	; 0x2930 <__fp_inf>
    2dce:	fb cd       	rjmp	.-1034   	; 0x29c6 <__fp_szero>
    2dd0:	5f 3f       	cpi	r21, 0xFF	; 255
    2dd2:	ec f3       	brlt	.-6      	; 0x2dce <__divsf3_pse+0x6a>
    2dd4:	98 3e       	cpi	r25, 0xE8	; 232
    2dd6:	dc f3       	brlt	.-10     	; 0x2dce <__divsf3_pse+0x6a>
    2dd8:	86 95       	lsr	r24
    2dda:	77 95       	ror	r23
    2ddc:	67 95       	ror	r22
    2dde:	b7 95       	ror	r27
    2de0:	f7 95       	ror	r31
    2de2:	9f 5f       	subi	r25, 0xFF	; 255
    2de4:	c9 f7       	brne	.-14     	; 0x2dd8 <__divsf3_pse+0x74>
    2de6:	88 0f       	add	r24, r24
    2de8:	91 1d       	adc	r25, r1
    2dea:	96 95       	lsr	r25
    2dec:	87 95       	ror	r24
    2dee:	97 f9       	bld	r25, 7
    2df0:	08 95       	ret
    2df2:	e1 e0       	ldi	r30, 0x01	; 1
    2df4:	66 0f       	add	r22, r22
    2df6:	77 1f       	adc	r23, r23
    2df8:	88 1f       	adc	r24, r24
    2dfa:	bb 1f       	adc	r27, r27
    2dfc:	62 17       	cp	r22, r18
    2dfe:	73 07       	cpc	r23, r19
    2e00:	84 07       	cpc	r24, r20
    2e02:	ba 07       	cpc	r27, r26
    2e04:	20 f0       	brcs	.+8      	; 0x2e0e <__divsf3_pse+0xaa>
    2e06:	62 1b       	sub	r22, r18
    2e08:	73 0b       	sbc	r23, r19
    2e0a:	84 0b       	sbc	r24, r20
    2e0c:	ba 0b       	sbc	r27, r26
    2e0e:	ee 1f       	adc	r30, r30
    2e10:	88 f7       	brcc	.-30     	; 0x2df4 <__divsf3_pse+0x90>
    2e12:	e0 95       	com	r30
    2e14:	08 95       	ret

00002e16 <__fp_mpack>:
    2e16:	9f 3f       	cpi	r25, 0xFF	; 255
    2e18:	31 f0       	breq	.+12     	; 0x2e26 <__fp_mpack_finite+0xc>

00002e1a <__fp_mpack_finite>:
    2e1a:	91 50       	subi	r25, 0x01	; 1
    2e1c:	20 f4       	brcc	.+8      	; 0x2e26 <__fp_mpack_finite+0xc>
    2e1e:	87 95       	ror	r24
    2e20:	77 95       	ror	r23
    2e22:	67 95       	ror	r22
    2e24:	b7 95       	ror	r27
    2e26:	88 0f       	add	r24, r24
    2e28:	91 1d       	adc	r25, r1
    2e2a:	96 95       	lsr	r25
    2e2c:	87 95       	ror	r24
    2e2e:	97 f9       	bld	r25, 7
    2e30:	08 95       	ret

00002e32 <__divmodhi4>:
    2e32:	97 fb       	bst	r25, 7
    2e34:	07 2e       	mov	r0, r23
    2e36:	16 f4       	brtc	.+4      	; 0x2e3c <__divmodhi4+0xa>
    2e38:	00 94       	com	r0
    2e3a:	06 d0       	rcall	.+12     	; 0x2e48 <__divmodhi4_neg1>
    2e3c:	77 fd       	sbrc	r23, 7
    2e3e:	08 d0       	rcall	.+16     	; 0x2e50 <__divmodhi4_neg2>
    2e40:	0b d0       	rcall	.+22     	; 0x2e58 <__udivmodhi4>
    2e42:	07 fc       	sbrc	r0, 7
    2e44:	05 d0       	rcall	.+10     	; 0x2e50 <__divmodhi4_neg2>
    2e46:	3e f4       	brtc	.+14     	; 0x2e56 <__divmodhi4_exit>

00002e48 <__divmodhi4_neg1>:
    2e48:	90 95       	com	r25
    2e4a:	81 95       	neg	r24
    2e4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2e4e:	08 95       	ret

00002e50 <__divmodhi4_neg2>:
    2e50:	70 95       	com	r23
    2e52:	61 95       	neg	r22
    2e54:	7f 4f       	sbci	r23, 0xFF	; 255

00002e56 <__divmodhi4_exit>:
    2e56:	08 95       	ret

00002e58 <__udivmodhi4>:
    2e58:	aa 1b       	sub	r26, r26
    2e5a:	bb 1b       	sub	r27, r27
    2e5c:	51 e1       	ldi	r21, 0x11	; 17
    2e5e:	07 c0       	rjmp	.+14     	; 0x2e6e <__udivmodhi4_ep>

00002e60 <__udivmodhi4_loop>:
    2e60:	aa 1f       	adc	r26, r26
    2e62:	bb 1f       	adc	r27, r27
    2e64:	a6 17       	cp	r26, r22
    2e66:	b7 07       	cpc	r27, r23
    2e68:	10 f0       	brcs	.+4      	; 0x2e6e <__udivmodhi4_ep>
    2e6a:	a6 1b       	sub	r26, r22
    2e6c:	b7 0b       	sbc	r27, r23

00002e6e <__udivmodhi4_ep>:
    2e6e:	88 1f       	adc	r24, r24
    2e70:	99 1f       	adc	r25, r25
    2e72:	5a 95       	dec	r21
    2e74:	a9 f7       	brne	.-22     	; 0x2e60 <__udivmodhi4_loop>
    2e76:	80 95       	com	r24
    2e78:	90 95       	com	r25
    2e7a:	bc 01       	movw	r22, r24
    2e7c:	cd 01       	movw	r24, r26
    2e7e:	08 95       	ret

00002e80 <memcpy>:
    2e80:	fb 01       	movw	r30, r22
    2e82:	dc 01       	movw	r26, r24
    2e84:	02 c0       	rjmp	.+4      	; 0x2e8a <memcpy+0xa>
    2e86:	01 90       	ld	r0, Z+
    2e88:	0d 92       	st	X+, r0
    2e8a:	41 50       	subi	r20, 0x01	; 1
    2e8c:	50 40       	sbci	r21, 0x00	; 0
    2e8e:	d8 f7       	brcc	.-10     	; 0x2e86 <memcpy+0x6>
    2e90:	08 95       	ret

00002e92 <_exit>:
    2e92:	f8 94       	cli

00002e94 <__stop_program>:
    2e94:	ff cf       	rjmp	.-2      	; 0x2e94 <__stop_program>
