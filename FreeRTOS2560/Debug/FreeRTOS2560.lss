
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800200  00002226  000022ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002226  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fe  00800256  00800256  00002310  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002310  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  00002340  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000052e0  00000000  00000000  000027f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001412  00000000  00000000  00007ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000323b  00000000  00000000  00008eea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d68  00000000  00000000  0000c128  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000150f  00000000  00000000  0000ce90  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000037fa  00000000  00000000  0000e39f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011b99  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	96 c2       	rjmp	.+1324   	; 0x552 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	9c c7       	rjmp	.+3896   	; 0xf8e <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	d3 c4       	rjmp	.+2470   	; 0xa0c <__vector_25>
      66:	00 00       	nop
      68:	3f c5       	rjmp	.+2686   	; 0xae8 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c3       	rjmp	.+1618   	; 0x6c8 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	85 c4       	rjmp	.+2314   	; 0x99c <__vector_36>
      92:	00 00       	nop
      94:	f3 c4       	rjmp	.+2534   	; 0xa7c <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 e2       	ldi	r30, 0x26	; 38
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a6 35       	cpi	r26, 0x56	; 86
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a6 e5       	ldi	r26, 0x56	; 86
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a4 35       	cpi	r26, 0x54	; 84
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	02 d1       	rcall	.+516    	; 0x324 <main>
     120:	0c 94 11 11 	jmp	0x2222	; 0x2222 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	b3 d5       	rcall	.+2918   	; 0xc8e <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	81 d5       	rcall	.+2818   	; 0xc30 <myUSART_transmitUSART0>
     12e:	fb cf       	rjmp	.-10     	; 0x126 <RPI_receiveTask>

00000130 <RPI_sendTask>:
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	00 d0       	rcall	.+0      	; 0x136 <RPI_sendTask+0x6>
     136:	00 d0       	rcall	.+0      	; 0x138 <RPI_sendTask+0x8>
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	4f ef       	ldi	r20, 0xFF	; 255
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	be 01       	movw	r22, r28
     144:	6a 5f       	subi	r22, 0xFA	; 250
     146:	7f 4f       	sbci	r23, 0xFF	; 255
     148:	80 91 a1 08 	lds	r24, 0x08A1
     14c:	90 91 a2 08 	lds	r25, 0x08A2
     150:	0e 94 e3 09 	call	0x13c6	; 0x13c6 <xQueueGenericReceive>
     154:	8e 81       	ldd	r24, Y+6	; 0x06
     156:	9f ef       	ldi	r25, 0xFF	; 255
     158:	98 0f       	add	r25, r24
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	88 23       	and	r24, r24
     15e:	e9 f0       	breq	.+58     	; 0x19a <RPI_sendTask+0x6a>
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	be 01       	movw	r22, r28
     168:	6f 5f       	subi	r22, 0xFF	; 255
     16a:	7f 4f       	sbci	r23, 0xFF	; 255
     16c:	80 91 a3 08 	lds	r24, 0x08A3
     170:	90 91 a4 08 	lds	r25, 0x08A4
     174:	0e 94 e3 09 	call	0x13c6	; 0x13c6 <xQueueGenericReceive>
     178:	89 81       	ldd	r24, Y+1	; 0x01
     17a:	2c d5       	rcall	.+2648   	; 0xbd4 <myUSART_transmitUSART0_c>
     17c:	8d e1       	ldi	r24, 0x1D	; 29
     17e:	92 e0       	ldi	r25, 0x02	; 2
     180:	57 d5       	rcall	.+2734   	; 0xc30 <myUSART_transmitUSART0>
     182:	ce 01       	movw	r24, r28
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	54 d5       	rcall	.+2728   	; 0xc30 <myUSART_transmitUSART0>
     188:	80 e2       	ldi	r24, 0x20	; 32
     18a:	92 e0       	ldi	r25, 0x02	; 2
     18c:	51 d5       	rcall	.+2722   	; 0xc30 <myUSART_transmitUSART0>
     18e:	8e 81       	ldd	r24, Y+6	; 0x06
     190:	9f ef       	ldi	r25, 0xFF	; 255
     192:	98 0f       	add	r25, r24
     194:	9e 83       	std	Y+6, r25	; 0x06
     196:	81 11       	cpse	r24, r1
     198:	e3 cf       	rjmp	.-58     	; 0x160 <RPI_sendTask+0x30>
     19a:	8a e0       	ldi	r24, 0x0A	; 10
     19c:	1b d5       	rcall	.+2614   	; 0xbd4 <myUSART_transmitUSART0_c>
     19e:	84 ef       	ldi	r24, 0xF4	; 244
     1a0:	91 e0       	ldi	r25, 0x01	; 1
     1a2:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <vTaskDelay>
     1a6:	ca cf       	rjmp	.-108    	; 0x13c <RPI_sendTask+0xc>

000001a8 <task1>:
     1a8:	2e 9a       	sbi	0x05, 6	; 5
     1aa:	88 ee       	ldi	r24, 0xE8	; 232
     1ac:	93 e0       	ldi	r25, 0x03	; 3
     1ae:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <vTaskDelay>
     1b2:	85 b1       	in	r24, 0x05	; 5
     1b4:	15 b8       	out	0x05, r1	; 5
     1b6:	88 ee       	ldi	r24, 0xE8	; 232
     1b8:	93 e0       	ldi	r25, 0x03	; 3
     1ba:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <vTaskDelay>
     1be:	f4 cf       	rjmp	.-24     	; 0x1a8 <task1>

000001c0 <myTimerTask>:
     1c0:	1b d3       	rcall	.+1590   	; 0x7f8 <myTimer_Init>
     1c2:	7d d3       	rcall	.+1786   	; 0x8be <myTimer_DelayChecker>
     1c4:	fe cf       	rjmp	.-4      	; 0x1c2 <myTimerTask+0x2>

000001c6 <obstacleSend>:
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	00 d0       	rcall	.+0      	; 0x1ce <obstacleSend+0x8>
     1ce:	1f 92       	push	r1
     1d0:	1f 92       	push	r1
     1d2:	cd b7       	in	r28, 0x3d	; 61
     1d4:	de b7       	in	r29, 0x3e	; 62
     1d6:	18 2f       	mov	r17, r24
     1d8:	cb 01       	movw	r24, r22
     1da:	11 23       	and	r17, r17
     1dc:	91 f0       	breq	.+36     	; 0x202 <obstacleSend+0x3c>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6e 5f       	subi	r22, 0xFE	; 254
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 de 10 	call	0x21bc	; 0x21bc <__itoa_ncheck>
     1ea:	19 83       	std	Y+1, r17	; 0x01
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	4f ef       	ldi	r20, 0xFF	; 255
     1f0:	5f ef       	ldi	r21, 0xFF	; 255
     1f2:	be 01       	movw	r22, r28
     1f4:	6f 5f       	subi	r22, 0xFF	; 255
     1f6:	7f 4f       	sbci	r23, 0xFF	; 255
     1f8:	80 91 a3 08 	lds	r24, 0x08A3
     1fc:	90 91 a4 08 	lds	r25, 0x08A4
     200:	ed d7       	rcall	.+4058   	; 0x11dc <xQueueGenericSend>
     202:	0f 90       	pop	r0
     204:	0f 90       	pop	r0
     206:	0f 90       	pop	r0
     208:	0f 90       	pop	r0
     20a:	0f 90       	pop	r0
     20c:	df 91       	pop	r29
     20e:	cf 91       	pop	r28
     210:	1f 91       	pop	r17
     212:	08 95       	ret

00000214 <Sonar_Task>:
     214:	cf 93       	push	r28
     216:	df 93       	push	r29
     218:	00 d0       	rcall	.+0      	; 0x21a <Sonar_Task+0x6>
     21a:	cd b7       	in	r28, 0x3d	; 61
     21c:	de b7       	in	r29, 0x3e	; 62
     21e:	1b 82       	std	Y+3, r1	; 0x03
     220:	0e 94 b9 0c 	call	0x1972	; 0x1972 <xTaskGetTickCount>
     224:	9a 83       	std	Y+2, r25	; 0x02
     226:	89 83       	std	Y+1, r24	; 0x01
     228:	81 2c       	mov	r8, r1
     22a:	91 2c       	mov	r9, r1
     22c:	3d d2       	rcall	.+1146   	; 0x6a8 <myMaxSonar_Start>
     22e:	87 e2       	ldi	r24, 0x27	; 39
     230:	41 d2       	rcall	.+1154   	; 0x6b4 <myMaxSonar_Read>
     232:	5c 01       	movw	r10, r24
     234:	86 e2       	ldi	r24, 0x26	; 38
     236:	3e d2       	rcall	.+1148   	; 0x6b4 <myMaxSonar_Read>
     238:	6c 01       	movw	r12, r24
     23a:	85 e2       	ldi	r24, 0x25	; 37
     23c:	3b d2       	rcall	.+1142   	; 0x6b4 <myMaxSonar_Read>
     23e:	0a 97       	sbiw	r24, 0x0a	; 10
     240:	7c 01       	movw	r14, r24
     242:	12 d2       	rcall	.+1060   	; 0x668 <myHcSonar_Read>
     244:	8c 01       	movw	r16, r24
     246:	08 3e       	cpi	r16, 0xE8	; 232
     248:	83 e0       	ldi	r24, 0x03	; 3
     24a:	18 07       	cpc	r17, r24
     24c:	14 f0       	brlt	.+4      	; 0x252 <Sonar_Task+0x3e>
     24e:	08 2d       	mov	r16, r8
     250:	19 2d       	mov	r17, r9
     252:	8b 81       	ldd	r24, Y+3	; 0x03
     254:	8c 5f       	subi	r24, 0xFC	; 252
     256:	8b 83       	std	Y+3, r24	; 0x03
     258:	20 e0       	ldi	r18, 0x00	; 0
     25a:	4f ef       	ldi	r20, 0xFF	; 255
     25c:	5f ef       	ldi	r21, 0xFF	; 255
     25e:	be 01       	movw	r22, r28
     260:	6d 5f       	subi	r22, 0xFD	; 253
     262:	7f 4f       	sbci	r23, 0xFF	; 255
     264:	80 91 a1 08 	lds	r24, 0x08A1
     268:	90 91 a2 08 	lds	r25, 0x08A2
     26c:	b7 d7       	rcall	.+3950   	; 0x11dc <xQueueGenericSend>
     26e:	b5 01       	movw	r22, r10
     270:	86 e4       	ldi	r24, 0x46	; 70
     272:	a9 df       	rcall	.-174    	; 0x1c6 <obstacleSend>
     274:	b6 01       	movw	r22, r12
     276:	8c e4       	ldi	r24, 0x4C	; 76
     278:	a6 df       	rcall	.-180    	; 0x1c6 <obstacleSend>
     27a:	b7 01       	movw	r22, r14
     27c:	82 e5       	ldi	r24, 0x52	; 82
     27e:	a3 df       	rcall	.-186    	; 0x1c6 <obstacleSend>
     280:	b8 01       	movw	r22, r16
     282:	82 e4       	ldi	r24, 0x42	; 66
     284:	a0 df       	rcall	.-192    	; 0x1c6 <obstacleSend>
     286:	1b 82       	std	Y+3, r1	; 0x03
     288:	66 e9       	ldi	r22, 0x96	; 150
     28a:	70 e0       	ldi	r23, 0x00	; 0
     28c:	ce 01       	movw	r24, r28
     28e:	01 96       	adiw	r24, 0x01	; 1
     290:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vTaskDelayUntil>
     294:	cb cf       	rjmp	.-106    	; 0x22c <Sonar_Task+0x18>

00000296 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     296:	8c ec       	ldi	r24, 0xCC	; 204
     298:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     29c:	8e e3       	ldi	r24, 0x3E	; 62
     29e:	80 93 65 00 	sts	0x0065, r24
     2a2:	08 95       	ret

000002a4 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2a4:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2a8:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2ac:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2b0:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2b4:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2b8:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2bc:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2c0:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2c4:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2c8:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2cc:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2d0:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2d4:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2d8:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2dc:	10 92 73 00 	sts	0x0073, r1
     2e0:	08 95       	ret

000002e2 <init>:
}

void init()
{
     2e2:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2e4:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2e6:	f8 94       	cli
	{
		clearTimer();
     2e8:	dd df       	rcall	.-70     	; 0x2a4 <clearTimer>
		setPowerReduction();
     2ea:	d5 df       	rcall	.-86     	; 0x296 <setPowerReduction>
		myUSART_USART0_Init();
     2ec:	33 d4       	rcall	.+2150   	; 0xb54 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2ee:	52 d4       	rcall	.+2212   	; 0xb94 <myUSART_USART1_Init>
		myADC_Init();
     2f0:	1f d2       	rcall	.+1086   	; 0x730 <myADC_Init>
		MaxSonar_Init();
     2f2:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     2f4:	9e d1       	rcall	.+828    	; 0x632 <myHcSonar_Init>
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     2f6:	40 e0       	ldi	r20, 0x00	; 0
     2f8:	61 e0       	ldi	r22, 0x01	; 1
     2fa:	85 e0       	ldi	r24, 0x05	; 5
     2fc:	45 d7       	rcall	.+3722   	; 0x1188 <xQueueGenericCreate>
     2fe:	90 93 a2 08 	sts	0x08A2, r25
     302:	80 93 a1 08 	sts	0x08A1, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     306:	40 e0       	ldi	r20, 0x00	; 0
     308:	65 e0       	ldi	r22, 0x05	; 5
     30a:	84 e1       	ldi	r24, 0x14	; 20
     30c:	3d d7       	rcall	.+3706   	; 0x1188 <xQueueGenericCreate>
     30e:	90 93 a4 08 	sts	0x08A4, r25
     312:	80 93 a3 08 	sts	0x08A3, r24
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction for led
     316:	84 b1       	in	r24, 0x04	; 4
     318:	80 6c       	ori	r24, 0xC0	; 192
     31a:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     31c:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     31e:	78 94       	sei
}
     320:	cf 91       	pop	r28
     322:	08 95       	ret

00000324 <main>:
	
	// do nth
}

int main(void)
{
     324:	cf 93       	push	r28
     326:	df 93       	push	r29
     328:	cd b7       	in	r28, 0x3d	; 61
     32a:	de b7       	in	r29, 0x3e	; 62
     32c:	2a 97       	sbiw	r28, 0x0a	; 10
     32e:	0f b6       	in	r0, 0x3f	; 63
     330:	f8 94       	cli
     332:	de bf       	out	0x3e, r29	; 62
     334:	0f be       	out	0x3f, r0	; 63
     336:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
		
		init();
     338:	d4 df       	rcall	.-88     	; 0x2e2 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     33a:	a1 2c       	mov	r10, r1
     33c:	b1 2c       	mov	r11, r1
     33e:	c1 2c       	mov	r12, r1
     340:	d1 2c       	mov	r13, r1
     342:	ce 01       	movw	r24, r28
     344:	01 96       	adiw	r24, 0x01	; 1
     346:	7c 01       	movw	r14, r24
     348:	01 e0       	ldi	r16, 0x01	; 1
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	49 e6       	ldi	r20, 0x69	; 105
     350:	50 e0       	ldi	r21, 0x00	; 0
     352:	63 e2       	ldi	r22, 0x23	; 35
     354:	72 e0       	ldi	r23, 0x02	; 2
     356:	84 ed       	ldi	r24, 0xD4	; 212
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     35e:	ce 01       	movw	r24, r28
     360:	03 96       	adiw	r24, 0x03	; 3
     362:	7c 01       	movw	r14, r24
     364:	04 e0       	ldi	r16, 0x04	; 4
     366:	9c 01       	movw	r18, r24
     368:	49 e6       	ldi	r20, 0x69	; 105
     36a:	50 e0       	ldi	r21, 0x00	; 0
     36c:	6a e2       	ldi	r22, 0x2A	; 42
     36e:	72 e0       	ldi	r23, 0x02	; 2
     370:	80 ee       	ldi	r24, 0xE0	; 224
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     378:	ce 01       	movw	r24, r28
     37a:	09 96       	adiw	r24, 0x09	; 9
     37c:	7c 01       	movw	r14, r24
     37e:	02 e0       	ldi	r16, 0x02	; 2
     380:	20 e0       	ldi	r18, 0x00	; 0
     382:	30 e0       	ldi	r19, 0x00	; 0
     384:	4f e4       	ldi	r20, 0x4F	; 79
     386:	51 e0       	ldi	r21, 0x01	; 1
     388:	62 e3       	ldi	r22, 0x32	; 50
     38a:	72 e0       	ldi	r23, 0x02	; 2
     38c:	8a e0       	ldi	r24, 0x0A	; 10
     38e:	91 e0       	ldi	r25, 0x01	; 1
     390:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     394:	ce 01       	movw	r24, r28
     396:	07 96       	adiw	r24, 0x07	; 7
     398:	7c 01       	movw	r14, r24
     39a:	03 e0       	ldi	r16, 0x03	; 3
     39c:	20 e0       	ldi	r18, 0x00	; 0
     39e:	30 e0       	ldi	r19, 0x00	; 0
     3a0:	47 e8       	ldi	r20, 0x87	; 135
     3a2:	50 e0       	ldi	r21, 0x00	; 0
     3a4:	6b e3       	ldi	r22, 0x3B	; 59
     3a6:	72 e0       	ldi	r23, 0x02	; 2
     3a8:	83 e9       	ldi	r24, 0x93	; 147
     3aa:	90 e0       	ldi	r25, 0x00	; 0
     3ac:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3b0:	ce 01       	movw	r24, r28
     3b2:	05 96       	adiw	r24, 0x05	; 5
     3b4:	7c 01       	movw	r14, r24
     3b6:	01 e0       	ldi	r16, 0x01	; 1
     3b8:	20 e0       	ldi	r18, 0x00	; 0
     3ba:	30 e0       	ldi	r19, 0x00	; 0
     3bc:	47 e8       	ldi	r20, 0x87	; 135
     3be:	50 e0       	ldi	r21, 0x00	; 0
     3c0:	67 e4       	ldi	r22, 0x47	; 71
     3c2:	72 e0       	ldi	r23, 0x02	; 2
     3c4:	88 e9       	ldi	r24, 0x98	; 152
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	0e 94 2a 0b 	call	0x1654	; 0x1654 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3cc:	0e 94 8a 0c 	call	0x1914	; 0x1914 <vTaskStartScheduler>
     3d0:	b3 cf       	rjmp	.-154    	; 0x338 <main+0x14>

000003d2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3d2:	cf 93       	push	r28
     3d4:	df 93       	push	r29
     3d6:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3d8:	0e 94 b3 0c 	call	0x1966	; 0x1966 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3dc:	80 91 56 02 	lds	r24, 0x0256
     3e0:	90 91 57 02 	lds	r25, 0x0257
     3e4:	89 2b       	or	r24, r25
     3e6:	31 f4       	brne	.+12     	; 0x3f4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3e8:	8b e5       	ldi	r24, 0x5B	; 91
     3ea:	92 e0       	ldi	r25, 0x02	; 2
     3ec:	90 93 57 02 	sts	0x0257, r25
     3f0:	80 93 56 02 	sts	0x0256, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3f4:	40 91 58 02 	lds	r20, 0x0258
     3f8:	50 91 59 02 	lds	r21, 0x0259
     3fc:	9e 01       	movw	r18, r28
     3fe:	24 0f       	add	r18, r20
     400:	35 1f       	adc	r19, r21
     402:	2b 3d       	cpi	r18, 0xDB	; 219
     404:	85 e0       	ldi	r24, 0x05	; 5
     406:	38 07       	cpc	r19, r24
     408:	70 f4       	brcc	.+28     	; 0x426 <pvPortMalloc+0x54>
     40a:	42 17       	cp	r20, r18
     40c:	53 07       	cpc	r21, r19
     40e:	70 f4       	brcc	.+28     	; 0x42c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     410:	c0 91 56 02 	lds	r28, 0x0256
     414:	d0 91 57 02 	lds	r29, 0x0257
     418:	c4 0f       	add	r28, r20
     41a:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     41c:	30 93 59 02 	sts	0x0259, r19
     420:	20 93 58 02 	sts	0x0258, r18
     424:	05 c0       	rjmp	.+10     	; 0x430 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     426:	c0 e0       	ldi	r28, 0x00	; 0
     428:	d0 e0       	ldi	r29, 0x00	; 0
     42a:	02 c0       	rjmp	.+4      	; 0x430 <pvPortMalloc+0x5e>
     42c:	c0 e0       	ldi	r28, 0x00	; 0
     42e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     430:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     434:	ce 01       	movw	r24, r28
     436:	df 91       	pop	r29
     438:	cf 91       	pop	r28
     43a:	08 95       	ret

0000043c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     43c:	08 95       	ret

0000043e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     43e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     440:	03 96       	adiw	r24, 0x03	; 3
     442:	92 83       	std	Z+2, r25	; 0x02
     444:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     446:	2f ef       	ldi	r18, 0xFF	; 255
     448:	3f ef       	ldi	r19, 0xFF	; 255
     44a:	34 83       	std	Z+4, r19	; 0x04
     44c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     44e:	96 83       	std	Z+6, r25	; 0x06
     450:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     452:	90 87       	std	Z+8, r25	; 0x08
     454:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     456:	10 82       	st	Z, r1
     458:	08 95       	ret

0000045a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     45a:	fc 01       	movw	r30, r24
     45c:	11 86       	std	Z+9, r1	; 0x09
     45e:	10 86       	std	Z+8, r1	; 0x08
     460:	08 95       	ret

00000462 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	9c 01       	movw	r18, r24
     468:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     46a:	dc 01       	movw	r26, r24
     46c:	11 96       	adiw	r26, 0x01	; 1
     46e:	cd 91       	ld	r28, X+
     470:	dc 91       	ld	r29, X
     472:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     474:	d3 83       	std	Z+3, r29	; 0x03
     476:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     478:	8c 81       	ldd	r24, Y+4	; 0x04
     47a:	9d 81       	ldd	r25, Y+5	; 0x05
     47c:	95 83       	std	Z+5, r25	; 0x05
     47e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     480:	8c 81       	ldd	r24, Y+4	; 0x04
     482:	9d 81       	ldd	r25, Y+5	; 0x05
     484:	dc 01       	movw	r26, r24
     486:	13 96       	adiw	r26, 0x03	; 3
     488:	7c 93       	st	X, r23
     48a:	6e 93       	st	-X, r22
     48c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     48e:	7d 83       	std	Y+5, r23	; 0x05
     490:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     492:	31 87       	std	Z+9, r19	; 0x09
     494:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     496:	f9 01       	movw	r30, r18
     498:	80 81       	ld	r24, Z
     49a:	8f 5f       	subi	r24, 0xFF	; 255
     49c:	80 83       	st	Z, r24
}
     49e:	df 91       	pop	r29
     4a0:	cf 91       	pop	r28
     4a2:	08 95       	ret

000004a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     4aa:	48 81       	ld	r20, Y
     4ac:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     4ae:	4f 3f       	cpi	r20, 0xFF	; 255
     4b0:	2f ef       	ldi	r18, 0xFF	; 255
     4b2:	52 07       	cpc	r21, r18
     4b4:	21 f4       	brne	.+8      	; 0x4be <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     4b6:	fc 01       	movw	r30, r24
     4b8:	a7 81       	ldd	r26, Z+7	; 0x07
     4ba:	b0 85       	ldd	r27, Z+8	; 0x08
     4bc:	0d c0       	rjmp	.+26     	; 0x4d8 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4be:	dc 01       	movw	r26, r24
     4c0:	13 96       	adiw	r26, 0x03	; 3
     4c2:	12 96       	adiw	r26, 0x02	; 2
     4c4:	ed 91       	ld	r30, X+
     4c6:	fc 91       	ld	r31, X
     4c8:	13 97       	sbiw	r26, 0x03	; 3
     4ca:	20 81       	ld	r18, Z
     4cc:	31 81       	ldd	r19, Z+1	; 0x01
     4ce:	42 17       	cp	r20, r18
     4d0:	53 07       	cpc	r21, r19
     4d2:	10 f0       	brcs	.+4      	; 0x4d8 <vListInsert+0x34>
     4d4:	df 01       	movw	r26, r30
     4d6:	f5 cf       	rjmp	.-22     	; 0x4c2 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4d8:	12 96       	adiw	r26, 0x02	; 2
     4da:	ed 91       	ld	r30, X+
     4dc:	fc 91       	ld	r31, X
     4de:	13 97       	sbiw	r26, 0x03	; 3
     4e0:	fb 83       	std	Y+3, r31	; 0x03
     4e2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4e4:	d5 83       	std	Z+5, r29	; 0x05
     4e6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4e8:	bd 83       	std	Y+5, r27	; 0x05
     4ea:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4ec:	13 96       	adiw	r26, 0x03	; 3
     4ee:	dc 93       	st	X, r29
     4f0:	ce 93       	st	-X, r28
     4f2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4f4:	99 87       	std	Y+9, r25	; 0x09
     4f6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4f8:	fc 01       	movw	r30, r24
     4fa:	20 81       	ld	r18, Z
     4fc:	2f 5f       	subi	r18, 0xFF	; 255
     4fe:	20 83       	st	Z, r18
}
     500:	df 91       	pop	r29
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     50c:	a0 85       	ldd	r26, Z+8	; 0x08
     50e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     510:	c2 81       	ldd	r28, Z+2	; 0x02
     512:	d3 81       	ldd	r29, Z+3	; 0x03
     514:	84 81       	ldd	r24, Z+4	; 0x04
     516:	95 81       	ldd	r25, Z+5	; 0x05
     518:	9d 83       	std	Y+5, r25	; 0x05
     51a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     51c:	c4 81       	ldd	r28, Z+4	; 0x04
     51e:	d5 81       	ldd	r29, Z+5	; 0x05
     520:	82 81       	ldd	r24, Z+2	; 0x02
     522:	93 81       	ldd	r25, Z+3	; 0x03
     524:	9b 83       	std	Y+3, r25	; 0x03
     526:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     528:	11 96       	adiw	r26, 0x01	; 1
     52a:	cd 91       	ld	r28, X+
     52c:	dc 91       	ld	r29, X
     52e:	12 97       	sbiw	r26, 0x02	; 2
     530:	ce 17       	cp	r28, r30
     532:	df 07       	cpc	r29, r31
     534:	31 f4       	brne	.+12     	; 0x542 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     536:	8c 81       	ldd	r24, Y+4	; 0x04
     538:	9d 81       	ldd	r25, Y+5	; 0x05
     53a:	12 96       	adiw	r26, 0x02	; 2
     53c:	9c 93       	st	X, r25
     53e:	8e 93       	st	-X, r24
     540:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     542:	11 86       	std	Z+9, r1	; 0x09
     544:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     546:	8c 91       	ld	r24, X
     548:	81 50       	subi	r24, 0x01	; 1
     54a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     54c:	df 91       	pop	r29
     54e:	cf 91       	pop	r28
     550:	08 95       	ret

00000552 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     552:	1f 92       	push	r1
     554:	0f 92       	push	r0
     556:	0f b6       	in	r0, 0x3f	; 63
     558:	0f 92       	push	r0
     55a:	11 24       	eor	r1, r1
     55c:	0b b6       	in	r0, 0x3b	; 59
     55e:	0f 92       	push	r0
     560:	2f 93       	push	r18
     562:	3f 93       	push	r19
     564:	4f 93       	push	r20
     566:	5f 93       	push	r21
     568:	6f 93       	push	r22
     56a:	7f 93       	push	r23
     56c:	8f 93       	push	r24
     56e:	9f 93       	push	r25
     570:	af 93       	push	r26
     572:	bf 93       	push	r27
     574:	ef 93       	push	r30
     576:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     578:	1b 9b       	sbis	0x03, 3	; 3
     57a:	0d c0       	rjmp	.+26     	; 0x596 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     57c:	57 d1       	rcall	.+686    	; 0x82c <myTimer_Read>
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	90 93 aa 08 	sts	0x08AA, r25
     584:	80 93 a9 08 	sts	0x08A9, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     588:	0e 94 c3 0c 	call	0x1986	; 0x1986 <xTaskGetTickCountFromISR>
     58c:	90 93 a6 08 	sts	0x08A6, r25
     590:	80 93 a5 08 	sts	0x08A5, r24
     594:	3b c0       	rjmp	.+118    	; 0x60c <__vector_9+0xba>
	}	
	else if (!(HC_Echo_Read))
     596:	1b 99       	sbic	0x03, 3	; 3
     598:	39 c0       	rjmp	.+114    	; 0x60c <__vector_9+0xba>
	{
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     59a:	48 d1       	rcall	.+656    	; 0x82c <myTimer_Read>
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	90 93 b0 08 	sts	0x08B0, r25
     5a2:	80 93 af 08 	sts	0x08AF, r24
     5a6:	20 91 a9 08 	lds	r18, 0x08A9
     5aa:	30 91 aa 08 	lds	r19, 0x08AA
     5ae:	82 17       	cp	r24, r18
     5b0:	93 07       	cpc	r25, r19
     5b2:	54 f4       	brge	.+20     	; 0x5c8 <__vector_9+0x76>
		us_tickEnd += MAX_TICKS;
     5b4:	80 91 af 08 	lds	r24, 0x08AF
     5b8:	90 91 b0 08 	lds	r25, 0x08B0
     5bc:	86 50       	subi	r24, 0x06	; 6
     5be:	9f 4f       	sbci	r25, 0xFF	; 255
     5c0:	90 93 b0 08 	sts	0x08B0, r25
     5c4:	80 93 af 08 	sts	0x08AF, r24
			
		us_tickLapsed = myTimer_Read() - us_tickStart;
     5c8:	31 d1       	rcall	.+610    	; 0x82c <myTimer_Read>
     5ca:	20 91 a9 08 	lds	r18, 0x08A9
     5ce:	30 91 aa 08 	lds	r19, 0x08AA
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	82 1b       	sub	r24, r18
     5d6:	93 0b       	sbc	r25, r19
     5d8:	90 93 ac 08 	sts	0x08AC, r25
     5dc:	80 93 ab 08 	sts	0x08AB, r24
		ms_tickLapsed = xTaskGetTickCountFromISR() - ms_tickStart;
     5e0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <xTaskGetTickCountFromISR>
     5e4:	20 91 a5 08 	lds	r18, 0x08A5
     5e8:	30 91 a6 08 	lds	r19, 0x08A6
     5ec:	82 1b       	sub	r24, r18
     5ee:	93 0b       	sbc	r25, r19
     5f0:	90 93 a8 08 	sts	0x08A8, r25
     5f4:	80 93 a7 08 	sts	0x08A7, r24
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	40 e0       	ldi	r20, 0x00	; 0
     5fc:	50 e0       	ldi	r21, 0x00	; 0
     5fe:	60 e0       	ldi	r22, 0x00	; 0
     600:	70 e0       	ldi	r23, 0x00	; 0
     602:	80 91 ad 08 	lds	r24, 0x08AD
     606:	90 91 ae 08 	lds	r25, 0x08AE
     60a:	a3 d6       	rcall	.+3398   	; 0x1352 <xQueueGenericSendFromISR>
	}	
}
     60c:	ff 91       	pop	r31
     60e:	ef 91       	pop	r30
     610:	bf 91       	pop	r27
     612:	af 91       	pop	r26
     614:	9f 91       	pop	r25
     616:	8f 91       	pop	r24
     618:	7f 91       	pop	r23
     61a:	6f 91       	pop	r22
     61c:	5f 91       	pop	r21
     61e:	4f 91       	pop	r20
     620:	3f 91       	pop	r19
     622:	2f 91       	pop	r18
     624:	0f 90       	pop	r0
     626:	0b be       	out	0x3b, r0	; 59
     628:	0f 90       	pop	r0
     62a:	0f be       	out	0x3f, r0	; 63
     62c:	0f 90       	pop	r0
     62e:	1f 90       	pop	r1
     630:	18 95       	reti

00000632 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     632:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     634:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     636:	e8 e6       	ldi	r30, 0x68	; 104
     638:	f0 e0       	ldi	r31, 0x00	; 0
     63a:	80 81       	ld	r24, Z
     63c:	81 60       	ori	r24, 0x01	; 1
     63e:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     640:	eb e6       	ldi	r30, 0x6B	; 107
     642:	f0 e0       	ldi	r31, 0x00	; 0
     644:	80 81       	ld	r24, Z
     646:	88 60       	ori	r24, 0x08	; 8
     648:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     64a:	43 e0       	ldi	r20, 0x03	; 3
     64c:	60 e0       	ldi	r22, 0x00	; 0
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	9b d5       	rcall	.+2870   	; 0x1188 <xQueueGenericCreate>
     652:	90 93 ae 08 	sts	0x08AE, r25
     656:	80 93 ad 08 	sts	0x08AD, r24
     65a:	08 95       	ret

0000065c <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     65c:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     65e:	8e e1       	ldi	r24, 0x1E	; 30
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	0a d1       	rcall	.+532    	; 0x878 <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     664:	2a 98       	cbi	0x05, 2	; 5
     666:	08 95       	ret

00000668 <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     668:	f9 df       	rcall	.-14     	; 0x65c <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     66a:	20 e0       	ldi	r18, 0x00	; 0
     66c:	4f ef       	ldi	r20, 0xFF	; 255
     66e:	5f ef       	ldi	r21, 0xFF	; 255
     670:	60 e0       	ldi	r22, 0x00	; 0
     672:	70 e0       	ldi	r23, 0x00	; 0
     674:	80 91 ad 08 	lds	r24, 0x08AD
     678:	90 91 ae 08 	lds	r25, 0x08AE
     67c:	a4 d6       	rcall	.+3400   	; 0x13c6 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     67e:	80 91 ab 08 	lds	r24, 0x08AB
     682:	90 91 ac 08 	lds	r25, 0x08AC
	msLength = ms_tickLapsed * 17;
     686:	20 91 a7 08 	lds	r18, 0x08A7
     68a:	30 91 a8 08 	lds	r19, 0x08A8
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     68e:	6e e0       	ldi	r22, 0x0E	; 14
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	0e 94 ae 10 	call	0x215c	; 0x215c <__divmodhi4>
	msLength = ms_tickLapsed * 17;
     696:	41 e1       	ldi	r20, 0x11	; 17
     698:	42 9f       	mul	r20, r18
     69a:	c0 01       	movw	r24, r0
     69c:	43 9f       	mul	r20, r19
     69e:	90 0d       	add	r25, r0
     6a0:	11 24       	eor	r1, r1
	return usLength + msLength;
	
     6a2:	86 0f       	add	r24, r22
     6a4:	97 1f       	adc	r25, r23
     6a6:	08 95       	ret

000006a8 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     6a8:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     6aa:	89 e1       	ldi	r24, 0x19	; 25
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	c0 d0       	rcall	.+384    	; 0x830 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     6b0:	a1 98       	cbi	0x14, 1	; 20
     6b2:	08 95       	ret

000006b4 <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     6b4:	9a d0       	rcall	.+308    	; 0x7ea <myADC_analogRead>
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	9c 01       	movw	r18, r24
     6ba:	22 0f       	add	r18, r18
     6bc:	33 1f       	adc	r19, r19
     6be:	22 0f       	add	r18, r18
     6c0:	33 1f       	adc	r19, r19
}
     6c2:	82 0f       	add	r24, r18
     6c4:	93 1f       	adc	r25, r19
     6c6:	08 95       	ret

000006c8 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     6c8:	1f 92       	push	r1
     6ca:	0f 92       	push	r0
     6cc:	0f b6       	in	r0, 0x3f	; 63
     6ce:	0f 92       	push	r0
     6d0:	11 24       	eor	r1, r1
     6d2:	0b b6       	in	r0, 0x3b	; 59
     6d4:	0f 92       	push	r0
     6d6:	2f 93       	push	r18
     6d8:	3f 93       	push	r19
     6da:	4f 93       	push	r20
     6dc:	5f 93       	push	r21
     6de:	6f 93       	push	r22
     6e0:	7f 93       	push	r23
     6e2:	8f 93       	push	r24
     6e4:	9f 93       	push	r25
     6e6:	af 93       	push	r26
     6e8:	bf 93       	push	r27
     6ea:	ef 93       	push	r30
     6ec:	ff 93       	push	r31
	adcReading = ADCH; // read value
     6ee:	80 91 79 00 	lds	r24, 0x0079
     6f2:	80 93 b1 08 	sts	0x08B1, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     6f6:	20 e0       	ldi	r18, 0x00	; 0
     6f8:	40 e0       	ldi	r20, 0x00	; 0
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	60 e0       	ldi	r22, 0x00	; 0
     6fe:	70 e0       	ldi	r23, 0x00	; 0
     700:	80 91 b4 08 	lds	r24, 0x08B4
     704:	90 91 b5 08 	lds	r25, 0x08B5
     708:	24 d6       	rcall	.+3144   	; 0x1352 <xQueueGenericSendFromISR>
}
     70a:	ff 91       	pop	r31
     70c:	ef 91       	pop	r30
     70e:	bf 91       	pop	r27
     710:	af 91       	pop	r26
     712:	9f 91       	pop	r25
     714:	8f 91       	pop	r24
     716:	7f 91       	pop	r23
     718:	6f 91       	pop	r22
     71a:	5f 91       	pop	r21
     71c:	4f 91       	pop	r20
     71e:	3f 91       	pop	r19
     720:	2f 91       	pop	r18
     722:	0f 90       	pop	r0
     724:	0b be       	out	0x3b, r0	; 59
     726:	0f 90       	pop	r0
     728:	0f be       	out	0x3f, r0	; 63
     72a:	0f 90       	pop	r0
     72c:	1f 90       	pop	r1
     72e:	18 95       	reti

00000730 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     730:	8f e8       	ldi	r24, 0x8F	; 143
     732:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     736:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     73a:	80 e6       	ldi	r24, 0x60	; 96
     73c:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     740:	43 e0       	ldi	r20, 0x03	; 3
     742:	60 e0       	ldi	r22, 0x00	; 0
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	20 d5       	rcall	.+2624   	; 0x1188 <xQueueGenericCreate>
     748:	90 93 b5 08 	sts	0x08B5, r25
     74c:	80 93 b4 08 	sts	0x08B4, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     750:	81 e0       	ldi	r24, 0x01	; 1
     752:	d7 d5       	rcall	.+2990   	; 0x1302 <xQueueCreateMutex>
     754:	90 93 b3 08 	sts	0x08B3, r25
     758:	80 93 b2 08 	sts	0x08B2, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     75c:	20 e0       	ldi	r18, 0x00	; 0
     75e:	40 e0       	ldi	r20, 0x00	; 0
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	60 e0       	ldi	r22, 0x00	; 0
     764:	70 e0       	ldi	r23, 0x00	; 0
     766:	3a c5       	rjmp	.+2676   	; 0x11dc <xQueueGenericSend>
     768:	08 95       	ret

0000076a <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     76a:	cf 93       	push	r28
     76c:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     76e:	20 e0       	ldi	r18, 0x00	; 0
     770:	4f ef       	ldi	r20, 0xFF	; 255
     772:	5f ef       	ldi	r21, 0xFF	; 255
     774:	60 e0       	ldi	r22, 0x00	; 0
     776:	70 e0       	ldi	r23, 0x00	; 0
     778:	80 91 b2 08 	lds	r24, 0x08B2
     77c:	90 91 b3 08 	lds	r25, 0x08B3
     780:	22 d6       	rcall	.+3140   	; 0x13c6 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     782:	ec e7       	ldi	r30, 0x7C	; 124
     784:	f0 e0       	ldi	r31, 0x00	; 0
     786:	80 81       	ld	r24, Z
     788:	9c 2f       	mov	r25, r28
     78a:	9f 71       	andi	r25, 0x1F	; 31
     78c:	80 76       	andi	r24, 0x60	; 96
     78e:	89 2b       	or	r24, r25
     790:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     792:	eb e7       	ldi	r30, 0x7B	; 123
     794:	f0 e0       	ldi	r31, 0x00	; 0
     796:	20 81       	ld	r18, Z
     798:	c0 72       	andi	r28, 0x20	; 32
     79a:	8c 2f       	mov	r24, r28
     79c:	90 e0       	ldi	r25, 0x00	; 0
     79e:	95 95       	asr	r25
     7a0:	87 95       	ror	r24
     7a2:	95 95       	asr	r25
     7a4:	87 95       	ror	r24
     7a6:	92 2f       	mov	r25, r18
     7a8:	90 76       	andi	r25, 0x60	; 96
     7aa:	89 2b       	or	r24, r25
     7ac:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     7ae:	ea e7       	ldi	r30, 0x7A	; 122
     7b0:	f0 e0       	ldi	r31, 0x00	; 0
     7b2:	80 81       	ld	r24, Z
     7b4:	80 64       	ori	r24, 0x40	; 64
     7b6:	80 83       	st	Z, r24
}
     7b8:	cf 91       	pop	r28
     7ba:	08 95       	ret

000007bc <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     7bc:	20 e0       	ldi	r18, 0x00	; 0
     7be:	4f ef       	ldi	r20, 0xFF	; 255
     7c0:	5f ef       	ldi	r21, 0xFF	; 255
     7c2:	60 e0       	ldi	r22, 0x00	; 0
     7c4:	70 e0       	ldi	r23, 0x00	; 0
     7c6:	80 91 b4 08 	lds	r24, 0x08B4
     7ca:	90 91 b5 08 	lds	r25, 0x08B5
     7ce:	fb d5       	rcall	.+3062   	; 0x13c6 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     7d0:	20 e0       	ldi	r18, 0x00	; 0
     7d2:	40 e0       	ldi	r20, 0x00	; 0
     7d4:	50 e0       	ldi	r21, 0x00	; 0
     7d6:	60 e0       	ldi	r22, 0x00	; 0
     7d8:	70 e0       	ldi	r23, 0x00	; 0
     7da:	80 91 b2 08 	lds	r24, 0x08B2
     7de:	90 91 b3 08 	lds	r25, 0x08B3
     7e2:	fc d4       	rcall	.+2552   	; 0x11dc <xQueueGenericSend>
	return adcReading;
     7e4:	80 91 b1 08 	lds	r24, 0x08B1
     7e8:	08 95       	ret

000007ea <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     7ea:	cf 93       	push	r28
     7ec:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     7ee:	bd df       	rcall	.-134    	; 0x76a <myADC_startADC>
	return myADC_readADC(channel);
     7f0:	8c 2f       	mov	r24, r28
     7f2:	e4 df       	rcall	.-56     	; 0x7bc <myADC_readADC>
}
     7f4:	cf 91       	pop	r28
     7f6:	08 95       	ret

000007f8 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     7f8:	90 93 bb 08 	sts	0x08BB, r25
     7fc:	80 93 ba 08 	sts	0x08BA, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     800:	fc 01       	movw	r30, r24
     802:	80 81       	ld	r24, Z
     804:	91 81       	ldd	r25, Z+1	; 0x01
     806:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     80a:	43 e0       	ldi	r20, 0x03	; 3
     80c:	60 e0       	ldi	r22, 0x00	; 0
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	bb d4       	rcall	.+2422   	; 0x1188 <xQueueGenericCreate>
     812:	90 93 b7 08 	sts	0x08B7, r25
     816:	80 93 b6 08 	sts	0x08B6, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     81a:	43 e0       	ldi	r20, 0x03	; 3
     81c:	60 e0       	ldi	r22, 0x00	; 0
     81e:	81 e0       	ldi	r24, 0x01	; 1
     820:	b3 d4       	rcall	.+2406   	; 0x1188 <xQueueGenericCreate>
     822:	90 93 b9 08 	sts	0x08B9, r25
     826:	80 93 b8 08 	sts	0x08B8, r24
     82a:	08 95       	ret

0000082c <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     82c:	86 b5       	in	r24, 0x26	; 38
}
     82e:	08 95       	ret

00000830 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     830:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     832:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     834:	9c 01       	movw	r18, r24
     836:	99 23       	and	r25, r25
     838:	14 f4       	brge	.+4      	; 0x83e <myTimer_DelayMicro+0xe>
     83a:	2d 5f       	subi	r18, 0xFD	; 253
     83c:	3f 4f       	sbci	r19, 0xFF	; 255
     83e:	35 95       	asr	r19
     840:	27 95       	ror	r18
     842:	35 95       	asr	r19
     844:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     846:	24 0f       	add	r18, r20
     848:	35 1f       	adc	r19, r21
     84a:	30 93 03 02 	sts	0x0203, r19
     84e:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     852:	e0 91 ba 08 	lds	r30, 0x08BA
     856:	f0 91 bb 08 	lds	r31, 0x08BB
     85a:	80 81       	ld	r24, Z
     85c:	91 81       	ldd	r25, Z+1	; 0x01
     85e:	0e 94 3f 0c 	call	0x187e	; 0x187e <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     862:	20 e0       	ldi	r18, 0x00	; 0
     864:	42 e0       	ldi	r20, 0x02	; 2
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	60 e0       	ldi	r22, 0x00	; 0
     86a:	70 e0       	ldi	r23, 0x00	; 0
     86c:	80 91 b6 08 	lds	r24, 0x08B6
     870:	90 91 b7 08 	lds	r25, 0x08B7
     874:	a8 c5       	rjmp	.+2896   	; 0x13c6 <xQueueGenericReceive>
     876:	08 95       	ret

00000878 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     878:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     87a:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     87c:	9c 01       	movw	r18, r24
     87e:	99 23       	and	r25, r25
     880:	14 f4       	brge	.+4      	; 0x886 <myTimer_DelayMicro2+0xe>
     882:	2d 5f       	subi	r18, 0xFD	; 253
     884:	3f 4f       	sbci	r19, 0xFF	; 255
     886:	35 95       	asr	r19
     888:	27 95       	ror	r18
     88a:	35 95       	asr	r19
     88c:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     88e:	24 0f       	add	r18, r20
     890:	35 1f       	adc	r19, r21
     892:	30 93 01 02 	sts	0x0201, r19
     896:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     89a:	e0 91 ba 08 	lds	r30, 0x08BA
     89e:	f0 91 bb 08 	lds	r31, 0x08BB
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	eb d7       	rcall	.+4054   	; 0x187e <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     8a8:	20 e0       	ldi	r18, 0x00	; 0
     8aa:	42 e0       	ldi	r20, 0x02	; 2
     8ac:	50 e0       	ldi	r21, 0x00	; 0
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	70 e0       	ldi	r23, 0x00	; 0
     8b2:	80 91 b8 08 	lds	r24, 0x08B8
     8b6:	90 91 b9 08 	lds	r25, 0x08B9
     8ba:	85 c5       	rjmp	.+2826   	; 0x13c6 <xQueueGenericReceive>
     8bc:	08 95       	ret

000008be <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     8be:	cf 93       	push	r28
     8c0:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8c2:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     8c4:	c1 11       	cpse	r28, r1
     8c6:	22 c0       	rjmp	.+68     	; 0x90c <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     8c8:	80 91 02 02 	lds	r24, 0x0202
     8cc:	90 91 03 02 	lds	r25, 0x0203
     8d0:	88 38       	cpi	r24, 0x88	; 136
     8d2:	93 41       	sbci	r25, 0x13	; 19
     8d4:	51 f0       	breq	.+20     	; 0x8ea <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     8d6:	80 91 02 02 	lds	r24, 0x0202
     8da:	90 91 03 02 	lds	r25, 0x0203
     8de:	8a 5f       	subi	r24, 0xFA	; 250
     8e0:	91 09       	sbc	r25, r1
     8e2:	90 93 03 02 	sts	0x0203, r25
     8e6:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     8ea:	80 91 00 02 	lds	r24, 0x0200
     8ee:	90 91 01 02 	lds	r25, 0x0201
     8f2:	88 38       	cpi	r24, 0x88	; 136
     8f4:	93 41       	sbci	r25, 0x13	; 19
     8f6:	51 f0       	breq	.+20     	; 0x90c <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     8f8:	80 91 00 02 	lds	r24, 0x0200
     8fc:	90 91 01 02 	lds	r25, 0x0201
     900:	8a 5f       	subi	r24, 0xFA	; 250
     902:	91 09       	sbc	r25, r1
     904:	90 93 01 02 	sts	0x0201, r25
     908:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     90c:	d0 e0       	ldi	r29, 0x00	; 0
     90e:	80 91 02 02 	lds	r24, 0x0202
     912:	90 91 03 02 	lds	r25, 0x0203
     916:	8c 17       	cp	r24, r28
     918:	9d 07       	cpc	r25, r29
     91a:	84 f4       	brge	.+32     	; 0x93c <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     91c:	88 e8       	ldi	r24, 0x88	; 136
     91e:	93 e1       	ldi	r25, 0x13	; 19
     920:	90 93 03 02 	sts	0x0203, r25
     924:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     928:	20 e0       	ldi	r18, 0x00	; 0
     92a:	40 e0       	ldi	r20, 0x00	; 0
     92c:	50 e0       	ldi	r21, 0x00	; 0
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	70 e0       	ldi	r23, 0x00	; 0
     932:	80 91 b6 08 	lds	r24, 0x08B6
     936:	90 91 b7 08 	lds	r25, 0x08B7
     93a:	50 d4       	rcall	.+2208   	; 0x11dc <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     93c:	80 91 00 02 	lds	r24, 0x0200
     940:	90 91 01 02 	lds	r25, 0x0201
     944:	8c 17       	cp	r24, r28
     946:	9d 07       	cpc	r25, r29
     948:	84 f4       	brge	.+32     	; 0x96a <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     94a:	88 e8       	ldi	r24, 0x88	; 136
     94c:	93 e1       	ldi	r25, 0x13	; 19
     94e:	90 93 01 02 	sts	0x0201, r25
     952:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     956:	20 e0       	ldi	r18, 0x00	; 0
     958:	40 e0       	ldi	r20, 0x00	; 0
     95a:	50 e0       	ldi	r21, 0x00	; 0
     95c:	60 e0       	ldi	r22, 0x00	; 0
     95e:	70 e0       	ldi	r23, 0x00	; 0
     960:	80 91 b8 08 	lds	r24, 0x08B8
     964:	90 91 b9 08 	lds	r25, 0x08B9
     968:	39 d4       	rcall	.+2162   	; 0x11dc <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     96a:	80 91 02 02 	lds	r24, 0x0202
     96e:	90 91 03 02 	lds	r25, 0x0203
     972:	88 38       	cpi	r24, 0x88	; 136
     974:	93 41       	sbci	r25, 0x13	; 19
     976:	79 f4       	brne	.+30     	; 0x996 <myTimer_DelayChecker+0xd8>
     978:	80 91 00 02 	lds	r24, 0x0200
     97c:	90 91 01 02 	lds	r25, 0x0201
     980:	88 38       	cpi	r24, 0x88	; 136
     982:	93 41       	sbci	r25, 0x13	; 19
     984:	41 f4       	brne	.+16     	; 0x996 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     986:	e0 91 ba 08 	lds	r30, 0x08BA
     98a:	f0 91 bb 08 	lds	r31, 0x08BB
     98e:	80 81       	ld	r24, Z
     990:	91 81       	ldd	r25, Z+1	; 0x01
     992:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <vTaskSuspend>
	}
     996:	df 91       	pop	r29
     998:	cf 91       	pop	r28
     99a:	08 95       	ret

0000099c <__vector_36>:
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     99c:	1f 92       	push	r1
     99e:	0f 92       	push	r0
     9a0:	0f b6       	in	r0, 0x3f	; 63
     9a2:	0f 92       	push	r0
     9a4:	11 24       	eor	r1, r1
     9a6:	0b b6       	in	r0, 0x3b	; 59
     9a8:	0f 92       	push	r0
     9aa:	2f 93       	push	r18
     9ac:	3f 93       	push	r19
     9ae:	4f 93       	push	r20
     9b0:	5f 93       	push	r21
     9b2:	6f 93       	push	r22
     9b4:	7f 93       	push	r23
     9b6:	8f 93       	push	r24
     9b8:	9f 93       	push	r25
     9ba:	af 93       	push	r26
     9bc:	bf 93       	push	r27
     9be:	ef 93       	push	r30
     9c0:	ff 93       	push	r31
     9c2:	60 91 ce 00 	lds	r22, 0x00CE
     9c6:	8f e4       	ldi	r24, 0x4F	; 79
     9c8:	99 e0       	ldi	r25, 0x09	; 9
     9ca:	c9 d5       	rcall	.+2962   	; 0x155e <ringBufferPush>
     9cc:	20 e0       	ldi	r18, 0x00	; 0
     9ce:	40 e0       	ldi	r20, 0x00	; 0
     9d0:	50 e0       	ldi	r21, 0x00	; 0
     9d2:	60 e0       	ldi	r22, 0x00	; 0
     9d4:	70 e0       	ldi	r23, 0x00	; 0
     9d6:	80 91 43 09 	lds	r24, 0x0943
     9da:	90 91 44 09 	lds	r25, 0x0944
     9de:	b9 d4       	rcall	.+2418   	; 0x1352 <xQueueGenericSendFromISR>
     9e0:	8f e4       	ldi	r24, 0x4F	; 79
     9e2:	99 e0       	ldi	r25, 0x09	; 9
     9e4:	d2 d5       	rcall	.+2980   	; 0x158a <ringBufferFull>
     9e6:	ff 91       	pop	r31
     9e8:	ef 91       	pop	r30
     9ea:	bf 91       	pop	r27
     9ec:	af 91       	pop	r26
     9ee:	9f 91       	pop	r25
     9f0:	8f 91       	pop	r24
     9f2:	7f 91       	pop	r23
     9f4:	6f 91       	pop	r22
     9f6:	5f 91       	pop	r21
     9f8:	4f 91       	pop	r20
     9fa:	3f 91       	pop	r19
     9fc:	2f 91       	pop	r18
     9fe:	0f 90       	pop	r0
     a00:	0b be       	out	0x3b, r0	; 59
     a02:	0f 90       	pop	r0
     a04:	0f be       	out	0x3f, r0	; 63
     a06:	0f 90       	pop	r0
     a08:	1f 90       	pop	r1
     a0a:	18 95       	reti

00000a0c <__vector_25>:
     a0c:	1f 92       	push	r1
     a0e:	0f 92       	push	r0
     a10:	0f b6       	in	r0, 0x3f	; 63
     a12:	0f 92       	push	r0
     a14:	11 24       	eor	r1, r1
     a16:	0b b6       	in	r0, 0x3b	; 59
     a18:	0f 92       	push	r0
     a1a:	2f 93       	push	r18
     a1c:	3f 93       	push	r19
     a1e:	4f 93       	push	r20
     a20:	5f 93       	push	r21
     a22:	6f 93       	push	r22
     a24:	7f 93       	push	r23
     a26:	8f 93       	push	r24
     a28:	9f 93       	push	r25
     a2a:	af 93       	push	r26
     a2c:	bf 93       	push	r27
     a2e:	ef 93       	push	r30
     a30:	ff 93       	push	r31
     a32:	60 91 c6 00 	lds	r22, 0x00C6
     a36:	8c ed       	ldi	r24, 0xDC	; 220
     a38:	98 e0       	ldi	r25, 0x08	; 8
     a3a:	91 d5       	rcall	.+2850   	; 0x155e <ringBufferPush>
     a3c:	20 e0       	ldi	r18, 0x00	; 0
     a3e:	40 e0       	ldi	r20, 0x00	; 0
     a40:	50 e0       	ldi	r21, 0x00	; 0
     a42:	60 e0       	ldi	r22, 0x00	; 0
     a44:	70 e0       	ldi	r23, 0x00	; 0
     a46:	80 91 43 09 	lds	r24, 0x0943
     a4a:	90 91 44 09 	lds	r25, 0x0944
     a4e:	81 d4       	rcall	.+2306   	; 0x1352 <xQueueGenericSendFromISR>
     a50:	8c ed       	ldi	r24, 0xDC	; 220
     a52:	98 e0       	ldi	r25, 0x08	; 8
     a54:	9a d5       	rcall	.+2868   	; 0x158a <ringBufferFull>
     a56:	ff 91       	pop	r31
     a58:	ef 91       	pop	r30
     a5a:	bf 91       	pop	r27
     a5c:	af 91       	pop	r26
     a5e:	9f 91       	pop	r25
     a60:	8f 91       	pop	r24
     a62:	7f 91       	pop	r23
     a64:	6f 91       	pop	r22
     a66:	5f 91       	pop	r21
     a68:	4f 91       	pop	r20
     a6a:	3f 91       	pop	r19
     a6c:	2f 91       	pop	r18
     a6e:	0f 90       	pop	r0
     a70:	0b be       	out	0x3b, r0	; 59
     a72:	0f 90       	pop	r0
     a74:	0f be       	out	0x3f, r0	; 63
     a76:	0f 90       	pop	r0
     a78:	1f 90       	pop	r1
     a7a:	18 95       	reti

00000a7c <__vector_37>:
     a7c:	1f 92       	push	r1
     a7e:	0f 92       	push	r0
     a80:	0f b6       	in	r0, 0x3f	; 63
     a82:	0f 92       	push	r0
     a84:	11 24       	eor	r1, r1
     a86:	0b b6       	in	r0, 0x3b	; 59
     a88:	0f 92       	push	r0
     a8a:	2f 93       	push	r18
     a8c:	3f 93       	push	r19
     a8e:	4f 93       	push	r20
     a90:	5f 93       	push	r21
     a92:	6f 93       	push	r22
     a94:	7f 93       	push	r23
     a96:	8f 93       	push	r24
     a98:	9f 93       	push	r25
     a9a:	af 93       	push	r26
     a9c:	bf 93       	push	r27
     a9e:	ef 93       	push	r30
     aa0:	ff 93       	push	r31
     aa2:	85 e4       	ldi	r24, 0x45	; 69
     aa4:	99 e0       	ldi	r25, 0x09	; 9
     aa6:	78 d5       	rcall	.+2800   	; 0x1598 <ringBufferNotEmpty>
     aa8:	88 23       	and	r24, r24
     aaa:	31 f0       	breq	.+12     	; 0xab8 <__vector_37+0x3c>
     aac:	85 e4       	ldi	r24, 0x45	; 69
     aae:	99 e0       	ldi	r25, 0x09	; 9
     ab0:	44 d5       	rcall	.+2696   	; 0x153a <ringBufferPop>
     ab2:	80 93 ce 00 	sts	0x00CE, r24
     ab6:	05 c0       	rjmp	.+10     	; 0xac2 <__vector_37+0x46>
     ab8:	e9 ec       	ldi	r30, 0xC9	; 201
     aba:	f0 e0       	ldi	r31, 0x00	; 0
     abc:	80 81       	ld	r24, Z
     abe:	8f 7d       	andi	r24, 0xDF	; 223
     ac0:	80 83       	st	Z, r24
     ac2:	ff 91       	pop	r31
     ac4:	ef 91       	pop	r30
     ac6:	bf 91       	pop	r27
     ac8:	af 91       	pop	r26
     aca:	9f 91       	pop	r25
     acc:	8f 91       	pop	r24
     ace:	7f 91       	pop	r23
     ad0:	6f 91       	pop	r22
     ad2:	5f 91       	pop	r21
     ad4:	4f 91       	pop	r20
     ad6:	3f 91       	pop	r19
     ad8:	2f 91       	pop	r18
     ada:	0f 90       	pop	r0
     adc:	0b be       	out	0x3b, r0	; 59
     ade:	0f 90       	pop	r0
     ae0:	0f be       	out	0x3f, r0	; 63
     ae2:	0f 90       	pop	r0
     ae4:	1f 90       	pop	r1
     ae6:	18 95       	reti

00000ae8 <__vector_26>:
     ae8:	1f 92       	push	r1
     aea:	0f 92       	push	r0
     aec:	0f b6       	in	r0, 0x3f	; 63
     aee:	0f 92       	push	r0
     af0:	11 24       	eor	r1, r1
     af2:	0b b6       	in	r0, 0x3b	; 59
     af4:	0f 92       	push	r0
     af6:	2f 93       	push	r18
     af8:	3f 93       	push	r19
     afa:	4f 93       	push	r20
     afc:	5f 93       	push	r21
     afe:	6f 93       	push	r22
     b00:	7f 93       	push	r23
     b02:	8f 93       	push	r24
     b04:	9f 93       	push	r25
     b06:	af 93       	push	r26
     b08:	bf 93       	push	r27
     b0a:	ef 93       	push	r30
     b0c:	ff 93       	push	r31
     b0e:	8a e4       	ldi	r24, 0x4A	; 74
     b10:	99 e0       	ldi	r25, 0x09	; 9
     b12:	42 d5       	rcall	.+2692   	; 0x1598 <ringBufferNotEmpty>
     b14:	88 23       	and	r24, r24
     b16:	31 f0       	breq	.+12     	; 0xb24 <__vector_26+0x3c>
     b18:	8a e4       	ldi	r24, 0x4A	; 74
     b1a:	99 e0       	ldi	r25, 0x09	; 9
     b1c:	0e d5       	rcall	.+2588   	; 0x153a <ringBufferPop>
     b1e:	80 93 c6 00 	sts	0x00C6, r24
     b22:	05 c0       	rjmp	.+10     	; 0xb2e <__vector_26+0x46>
     b24:	e1 ec       	ldi	r30, 0xC1	; 193
     b26:	f0 e0       	ldi	r31, 0x00	; 0
     b28:	80 81       	ld	r24, Z
     b2a:	8f 7d       	andi	r24, 0xDF	; 223
     b2c:	80 83       	st	Z, r24
     b2e:	ff 91       	pop	r31
     b30:	ef 91       	pop	r30
     b32:	bf 91       	pop	r27
     b34:	af 91       	pop	r26
     b36:	9f 91       	pop	r25
     b38:	8f 91       	pop	r24
     b3a:	7f 91       	pop	r23
     b3c:	6f 91       	pop	r22
     b3e:	5f 91       	pop	r21
     b40:	4f 91       	pop	r20
     b42:	3f 91       	pop	r19
     b44:	2f 91       	pop	r18
     b46:	0f 90       	pop	r0
     b48:	0b be       	out	0x3b, r0	; 59
     b4a:	0f 90       	pop	r0
     b4c:	0f be       	out	0x3f, r0	; 63
     b4e:	0f 90       	pop	r0
     b50:	1f 90       	pop	r1
     b52:	18 95       	reti

00000b54 <myUSART_USART0_Init>:
     b54:	10 92 c5 00 	sts	0x00C5, r1
     b58:	87 e6       	ldi	r24, 0x67	; 103
     b5a:	80 93 c4 00 	sts	0x00C4, r24
     b5e:	88 eb       	ldi	r24, 0xB8	; 184
     b60:	80 93 c1 00 	sts	0x00C1, r24
     b64:	86 e0       	ldi	r24, 0x06	; 6
     b66:	80 93 c2 00 	sts	0x00C2, r24
     b6a:	40 e2       	ldi	r20, 0x20	; 32
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	79 e0       	ldi	r23, 0x09	; 9
     b70:	8c ed       	ldi	r24, 0xDC	; 220
     b72:	98 e0       	ldi	r25, 0x08	; 8
     b74:	db d4       	rcall	.+2486   	; 0x152c <ringBufferInit>
     b76:	40 e2       	ldi	r20, 0x20	; 32
     b78:	61 ee       	ldi	r22, 0xE1	; 225
     b7a:	78 e0       	ldi	r23, 0x08	; 8
     b7c:	8a e4       	ldi	r24, 0x4A	; 74
     b7e:	99 e0       	ldi	r25, 0x09	; 9
     b80:	d5 d4       	rcall	.+2474   	; 0x152c <ringBufferInit>
     b82:	43 e0       	ldi	r20, 0x03	; 3
     b84:	60 e0       	ldi	r22, 0x00	; 0
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	ff d2       	rcall	.+1534   	; 0x1188 <xQueueGenericCreate>
     b8a:	90 93 42 09 	sts	0x0942, r25
     b8e:	80 93 41 09 	sts	0x0941, r24
     b92:	08 95       	ret

00000b94 <myUSART_USART1_Init>:
     b94:	10 92 cd 00 	sts	0x00CD, r1
     b98:	87 e6       	ldi	r24, 0x67	; 103
     b9a:	80 93 cc 00 	sts	0x00CC, r24
     b9e:	88 eb       	ldi	r24, 0xB8	; 184
     ba0:	80 93 c9 00 	sts	0x00C9, r24
     ba4:	86 e0       	ldi	r24, 0x06	; 6
     ba6:	80 93 ca 00 	sts	0x00CA, r24
     baa:	40 e2       	ldi	r20, 0x20	; 32
     bac:	6c eb       	ldi	r22, 0xBC	; 188
     bae:	78 e0       	ldi	r23, 0x08	; 8
     bb0:	8f e4       	ldi	r24, 0x4F	; 79
     bb2:	99 e0       	ldi	r25, 0x09	; 9
     bb4:	bb d4       	rcall	.+2422   	; 0x152c <ringBufferInit>
     bb6:	40 e2       	ldi	r20, 0x20	; 32
     bb8:	61 e2       	ldi	r22, 0x21	; 33
     bba:	79 e0       	ldi	r23, 0x09	; 9
     bbc:	85 e4       	ldi	r24, 0x45	; 69
     bbe:	99 e0       	ldi	r25, 0x09	; 9
     bc0:	b5 d4       	rcall	.+2410   	; 0x152c <ringBufferInit>
     bc2:	43 e0       	ldi	r20, 0x03	; 3
     bc4:	60 e0       	ldi	r22, 0x00	; 0
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	df d2       	rcall	.+1470   	; 0x1188 <xQueueGenericCreate>
     bca:	90 93 44 09 	sts	0x0944, r25
     bce:	80 93 43 09 	sts	0x0943, r24
     bd2:	08 95       	ret

00000bd4 <myUSART_transmitUSART0_c>:
     bd4:	cf 93       	push	r28
     bd6:	c8 2f       	mov	r28, r24
     bd8:	8a e4       	ldi	r24, 0x4A	; 74
     bda:	99 e0       	ldi	r25, 0x09	; 9
     bdc:	d6 d4       	rcall	.+2476   	; 0x158a <ringBufferFull>
     bde:	81 11       	cpse	r24, r1
     be0:	fb cf       	rjmp	.-10     	; 0xbd8 <myUSART_transmitUSART0_c+0x4>
     be2:	6c 2f       	mov	r22, r28
     be4:	8a e4       	ldi	r24, 0x4A	; 74
     be6:	99 e0       	ldi	r25, 0x09	; 9
     be8:	ba d4       	rcall	.+2420   	; 0x155e <ringBufferPush>
     bea:	e1 ec       	ldi	r30, 0xC1	; 193
     bec:	f0 e0       	ldi	r31, 0x00	; 0
     bee:	80 81       	ld	r24, Z
     bf0:	80 62       	ori	r24, 0x20	; 32
     bf2:	80 83       	st	Z, r24
     bf4:	e0 ec       	ldi	r30, 0xC0	; 192
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	80 81       	ld	r24, Z
     bfa:	80 64       	ori	r24, 0x40	; 64
     bfc:	80 83       	st	Z, r24
     bfe:	cf 91       	pop	r28
     c00:	08 95       	ret

00000c02 <myUSART_transmitUSART1_c>:
     c02:	cf 93       	push	r28
     c04:	c8 2f       	mov	r28, r24
     c06:	85 e4       	ldi	r24, 0x45	; 69
     c08:	99 e0       	ldi	r25, 0x09	; 9
     c0a:	bf d4       	rcall	.+2430   	; 0x158a <ringBufferFull>
     c0c:	81 11       	cpse	r24, r1
     c0e:	fb cf       	rjmp	.-10     	; 0xc06 <myUSART_transmitUSART1_c+0x4>
     c10:	6c 2f       	mov	r22, r28
     c12:	85 e4       	ldi	r24, 0x45	; 69
     c14:	99 e0       	ldi	r25, 0x09	; 9
     c16:	a3 d4       	rcall	.+2374   	; 0x155e <ringBufferPush>
     c18:	e9 ec       	ldi	r30, 0xC9	; 201
     c1a:	f0 e0       	ldi	r31, 0x00	; 0
     c1c:	80 81       	ld	r24, Z
     c1e:	80 62       	ori	r24, 0x20	; 32
     c20:	80 83       	st	Z, r24
     c22:	e8 ec       	ldi	r30, 0xC8	; 200
     c24:	f0 e0       	ldi	r31, 0x00	; 0
     c26:	80 81       	ld	r24, Z
     c28:	80 64       	ori	r24, 0x40	; 64
     c2a:	80 83       	st	Z, r24
     c2c:	cf 91       	pop	r28
     c2e:	08 95       	ret

00000c30 <myUSART_transmitUSART0>:
     c30:	cf 93       	push	r28
     c32:	df 93       	push	r29
     c34:	ec 01       	movw	r28, r24
     c36:	88 81       	ld	r24, Y
     c38:	88 23       	and	r24, r24
     c3a:	29 f0       	breq	.+10     	; 0xc46 <myUSART_transmitUSART0+0x16>
     c3c:	21 96       	adiw	r28, 0x01	; 1
     c3e:	ca df       	rcall	.-108    	; 0xbd4 <myUSART_transmitUSART0_c>
     c40:	89 91       	ld	r24, Y+
     c42:	81 11       	cpse	r24, r1
     c44:	fc cf       	rjmp	.-8      	; 0xc3e <myUSART_transmitUSART0+0xe>
     c46:	df 91       	pop	r29
     c48:	cf 91       	pop	r28
     c4a:	08 95       	ret

00000c4c <myUSART_receiveUSART1>:
     c4c:	cf 93       	push	r28
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	4f ef       	ldi	r20, 0xFF	; 255
     c52:	5f ef       	ldi	r21, 0xFF	; 255
     c54:	60 e0       	ldi	r22, 0x00	; 0
     c56:	70 e0       	ldi	r23, 0x00	; 0
     c58:	80 91 41 09 	lds	r24, 0x0941
     c5c:	90 91 42 09 	lds	r25, 0x0942
     c60:	b2 d3       	rcall	.+1892   	; 0x13c6 <xQueueGenericReceive>
     c62:	8f e4       	ldi	r24, 0x4F	; 79
     c64:	99 e0       	ldi	r25, 0x09	; 9
     c66:	69 d4       	rcall	.+2258   	; 0x153a <ringBufferPop>
     c68:	c8 2f       	mov	r28, r24
     c6a:	8f e4       	ldi	r24, 0x4F	; 79
     c6c:	99 e0       	ldi	r25, 0x09	; 9
     c6e:	94 d4       	rcall	.+2344   	; 0x1598 <ringBufferNotEmpty>
     c70:	88 23       	and	r24, r24
     c72:	51 f0       	breq	.+20     	; 0xc88 <myUSART_receiveUSART1+0x3c>
     c74:	20 e0       	ldi	r18, 0x00	; 0
     c76:	40 e0       	ldi	r20, 0x00	; 0
     c78:	50 e0       	ldi	r21, 0x00	; 0
     c7a:	60 e0       	ldi	r22, 0x00	; 0
     c7c:	70 e0       	ldi	r23, 0x00	; 0
     c7e:	80 91 41 09 	lds	r24, 0x0941
     c82:	90 91 42 09 	lds	r25, 0x0942
     c86:	aa d2       	rcall	.+1364   	; 0x11dc <xQueueGenericSend>
     c88:	8c 2f       	mov	r24, r28
     c8a:	cf 91       	pop	r28
     c8c:	08 95       	ret

00000c8e <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c8e:	de df       	rcall	.-68     	; 0xc4c <myUSART_receiveUSART1>
     c90:	81 11       	cpse	r24, r1
     c92:	0a c0       	rjmp	.+20     	; 0xca8 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     c94:	85 e5       	ldi	r24, 0x55	; 85
     c96:	b5 df       	rcall	.-150    	; 0xc02 <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c98:	d9 df       	rcall	.-78     	; 0xc4c <myUSART_receiveUSART1>
     c9a:	91 e0       	ldi	r25, 0x01	; 1
     c9c:	81 11       	cpse	r24, r1
     c9e:	01 c0       	rjmp	.+2      	; 0xca2 <myUSART_waitForHandshake+0x14>
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	89 2f       	mov	r24, r25
     ca4:	81 95       	neg	r24
     ca6:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     ca8:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     caa:	08 95       	ret

00000cac <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     cac:	31 e1       	ldi	r19, 0x11	; 17
     cae:	fc 01       	movw	r30, r24
     cb0:	30 83       	st	Z, r19
     cb2:	31 97       	sbiw	r30, 0x01	; 1
     cb4:	22 e2       	ldi	r18, 0x22	; 34
     cb6:	20 83       	st	Z, r18
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	a3 e3       	ldi	r26, 0x33	; 51
     cbc:	a0 83       	st	Z, r26
     cbe:	31 97       	sbiw	r30, 0x01	; 1
     cc0:	60 83       	st	Z, r22
     cc2:	31 97       	sbiw	r30, 0x01	; 1
     cc4:	70 83       	st	Z, r23
     cc6:	31 97       	sbiw	r30, 0x01	; 1
     cc8:	10 82       	st	Z, r1
     cca:	31 97       	sbiw	r30, 0x01	; 1
     ccc:	10 82       	st	Z, r1
     cce:	31 97       	sbiw	r30, 0x01	; 1
     cd0:	60 e8       	ldi	r22, 0x80	; 128
     cd2:	60 83       	st	Z, r22
     cd4:	31 97       	sbiw	r30, 0x01	; 1
     cd6:	10 82       	st	Z, r1
     cd8:	31 97       	sbiw	r30, 0x01	; 1
     cda:	10 82       	st	Z, r1
     cdc:	31 97       	sbiw	r30, 0x01	; 1
     cde:	10 82       	st	Z, r1
     ce0:	31 97       	sbiw	r30, 0x01	; 1
     ce2:	62 e0       	ldi	r22, 0x02	; 2
     ce4:	60 83       	st	Z, r22
     ce6:	31 97       	sbiw	r30, 0x01	; 1
     ce8:	63 e0       	ldi	r22, 0x03	; 3
     cea:	60 83       	st	Z, r22
     cec:	31 97       	sbiw	r30, 0x01	; 1
     cee:	64 e0       	ldi	r22, 0x04	; 4
     cf0:	60 83       	st	Z, r22
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	65 e0       	ldi	r22, 0x05	; 5
     cf6:	60 83       	st	Z, r22
     cf8:	31 97       	sbiw	r30, 0x01	; 1
     cfa:	66 e0       	ldi	r22, 0x06	; 6
     cfc:	60 83       	st	Z, r22
     cfe:	31 97       	sbiw	r30, 0x01	; 1
     d00:	67 e0       	ldi	r22, 0x07	; 7
     d02:	60 83       	st	Z, r22
     d04:	31 97       	sbiw	r30, 0x01	; 1
     d06:	68 e0       	ldi	r22, 0x08	; 8
     d08:	60 83       	st	Z, r22
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	69 e0       	ldi	r22, 0x09	; 9
     d0e:	60 83       	st	Z, r22
     d10:	31 97       	sbiw	r30, 0x01	; 1
     d12:	60 e1       	ldi	r22, 0x10	; 16
     d14:	60 83       	st	Z, r22
     d16:	31 97       	sbiw	r30, 0x01	; 1
     d18:	30 83       	st	Z, r19
     d1a:	31 97       	sbiw	r30, 0x01	; 1
     d1c:	32 e1       	ldi	r19, 0x12	; 18
     d1e:	30 83       	st	Z, r19
     d20:	31 97       	sbiw	r30, 0x01	; 1
     d22:	33 e1       	ldi	r19, 0x13	; 19
     d24:	30 83       	st	Z, r19
     d26:	31 97       	sbiw	r30, 0x01	; 1
     d28:	34 e1       	ldi	r19, 0x14	; 20
     d2a:	30 83       	st	Z, r19
     d2c:	31 97       	sbiw	r30, 0x01	; 1
     d2e:	35 e1       	ldi	r19, 0x15	; 21
     d30:	30 83       	st	Z, r19
     d32:	31 97       	sbiw	r30, 0x01	; 1
     d34:	36 e1       	ldi	r19, 0x16	; 22
     d36:	30 83       	st	Z, r19
     d38:	31 97       	sbiw	r30, 0x01	; 1
     d3a:	37 e1       	ldi	r19, 0x17	; 23
     d3c:	30 83       	st	Z, r19
     d3e:	31 97       	sbiw	r30, 0x01	; 1
     d40:	38 e1       	ldi	r19, 0x18	; 24
     d42:	30 83       	st	Z, r19
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	39 e1       	ldi	r19, 0x19	; 25
     d48:	30 83       	st	Z, r19
     d4a:	31 97       	sbiw	r30, 0x01	; 1
     d4c:	30 e2       	ldi	r19, 0x20	; 32
     d4e:	30 83       	st	Z, r19
     d50:	31 97       	sbiw	r30, 0x01	; 1
     d52:	31 e2       	ldi	r19, 0x21	; 33
     d54:	30 83       	st	Z, r19
     d56:	31 97       	sbiw	r30, 0x01	; 1
     d58:	20 83       	st	Z, r18
     d5a:	31 97       	sbiw	r30, 0x01	; 1
     d5c:	23 e2       	ldi	r18, 0x23	; 35
     d5e:	20 83       	st	Z, r18
     d60:	31 97       	sbiw	r30, 0x01	; 1
     d62:	40 83       	st	Z, r20
     d64:	31 97       	sbiw	r30, 0x01	; 1
     d66:	50 83       	st	Z, r21
     d68:	31 97       	sbiw	r30, 0x01	; 1
     d6a:	26 e2       	ldi	r18, 0x26	; 38
     d6c:	20 83       	st	Z, r18
     d6e:	31 97       	sbiw	r30, 0x01	; 1
     d70:	27 e2       	ldi	r18, 0x27	; 39
     d72:	20 83       	st	Z, r18
     d74:	31 97       	sbiw	r30, 0x01	; 1
     d76:	28 e2       	ldi	r18, 0x28	; 40
     d78:	20 83       	st	Z, r18
     d7a:	31 97       	sbiw	r30, 0x01	; 1
     d7c:	29 e2       	ldi	r18, 0x29	; 41
     d7e:	20 83       	st	Z, r18
     d80:	31 97       	sbiw	r30, 0x01	; 1
     d82:	20 e3       	ldi	r18, 0x30	; 48
     d84:	20 83       	st	Z, r18
     d86:	31 97       	sbiw	r30, 0x01	; 1
     d88:	21 e3       	ldi	r18, 0x31	; 49
     d8a:	20 83       	st	Z, r18
     d8c:	89 97       	sbiw	r24, 0x29	; 41
     d8e:	08 95       	ret

00000d90 <xPortStartScheduler>:
     d90:	82 e0       	ldi	r24, 0x02	; 2
     d92:	84 bd       	out	0x24, r24	; 36
     d94:	16 bc       	out	0x26, r1	; 38
     d96:	80 e3       	ldi	r24, 0x30	; 48
     d98:	87 bd       	out	0x27, r24	; 39
     d9a:	ee e6       	ldi	r30, 0x6E	; 110
     d9c:	f0 e0       	ldi	r31, 0x00	; 0
     d9e:	80 81       	ld	r24, Z
     da0:	82 60       	ori	r24, 0x02	; 2
     da2:	80 83       	st	Z, r24
     da4:	83 e0       	ldi	r24, 0x03	; 3
     da6:	85 bd       	out	0x25, r24	; 37
     da8:	a0 91 9f 08 	lds	r26, 0x089F
     dac:	b0 91 a0 08 	lds	r27, 0x08A0
     db0:	cd 91       	ld	r28, X+
     db2:	cd bf       	out	0x3d, r28	; 61
     db4:	dd 91       	ld	r29, X+
     db6:	de bf       	out	0x3e, r29	; 62
     db8:	ff 91       	pop	r31
     dba:	ef 91       	pop	r30
     dbc:	df 91       	pop	r29
     dbe:	cf 91       	pop	r28
     dc0:	bf 91       	pop	r27
     dc2:	af 91       	pop	r26
     dc4:	9f 91       	pop	r25
     dc6:	8f 91       	pop	r24
     dc8:	7f 91       	pop	r23
     dca:	6f 91       	pop	r22
     dcc:	5f 91       	pop	r21
     dce:	4f 91       	pop	r20
     dd0:	3f 91       	pop	r19
     dd2:	2f 91       	pop	r18
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	ef 90       	pop	r14
     ddc:	df 90       	pop	r13
     dde:	cf 90       	pop	r12
     de0:	bf 90       	pop	r11
     de2:	af 90       	pop	r10
     de4:	9f 90       	pop	r9
     de6:	8f 90       	pop	r8
     de8:	7f 90       	pop	r7
     dea:	6f 90       	pop	r6
     dec:	5f 90       	pop	r5
     dee:	4f 90       	pop	r4
     df0:	3f 90       	pop	r3
     df2:	2f 90       	pop	r2
     df4:	1f 90       	pop	r1
     df6:	0f 90       	pop	r0
     df8:	0c be       	out	0x3c, r0	; 60
     dfa:	0f 90       	pop	r0
     dfc:	0b be       	out	0x3b, r0	; 59
     dfe:	0f 90       	pop	r0
     e00:	0f be       	out	0x3f, r0	; 63
     e02:	0f 90       	pop	r0
     e04:	08 95       	ret
     e06:	81 e0       	ldi	r24, 0x01	; 1
     e08:	08 95       	ret

00000e0a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e0a:	0f 92       	push	r0
     e0c:	0f b6       	in	r0, 0x3f	; 63
     e0e:	f8 94       	cli
     e10:	0f 92       	push	r0
     e12:	0b b6       	in	r0, 0x3b	; 59
     e14:	0f 92       	push	r0
     e16:	0c b6       	in	r0, 0x3c	; 60
     e18:	0f 92       	push	r0
     e1a:	1f 92       	push	r1
     e1c:	11 24       	eor	r1, r1
     e1e:	2f 92       	push	r2
     e20:	3f 92       	push	r3
     e22:	4f 92       	push	r4
     e24:	5f 92       	push	r5
     e26:	6f 92       	push	r6
     e28:	7f 92       	push	r7
     e2a:	8f 92       	push	r8
     e2c:	9f 92       	push	r9
     e2e:	af 92       	push	r10
     e30:	bf 92       	push	r11
     e32:	cf 92       	push	r12
     e34:	df 92       	push	r13
     e36:	ef 92       	push	r14
     e38:	ff 92       	push	r15
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	2f 93       	push	r18
     e40:	3f 93       	push	r19
     e42:	4f 93       	push	r20
     e44:	5f 93       	push	r21
     e46:	6f 93       	push	r22
     e48:	7f 93       	push	r23
     e4a:	8f 93       	push	r24
     e4c:	9f 93       	push	r25
     e4e:	af 93       	push	r26
     e50:	bf 93       	push	r27
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	ef 93       	push	r30
     e58:	ff 93       	push	r31
     e5a:	a0 91 9f 08 	lds	r26, 0x089F
     e5e:	b0 91 a0 08 	lds	r27, 0x08A0
     e62:	0d b6       	in	r0, 0x3d	; 61
     e64:	0d 92       	st	X+, r0
     e66:	0e b6       	in	r0, 0x3e	; 62
     e68:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e6a:	64 d7       	rcall	.+3784   	; 0x1d34 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e6c:	a0 91 9f 08 	lds	r26, 0x089F
     e70:	b0 91 a0 08 	lds	r27, 0x08A0
     e74:	cd 91       	ld	r28, X+
     e76:	cd bf       	out	0x3d, r28	; 61
     e78:	dd 91       	ld	r29, X+
     e7a:	de bf       	out	0x3e, r29	; 62
     e7c:	ff 91       	pop	r31
     e7e:	ef 91       	pop	r30
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	bf 91       	pop	r27
     e86:	af 91       	pop	r26
     e88:	9f 91       	pop	r25
     e8a:	8f 91       	pop	r24
     e8c:	7f 91       	pop	r23
     e8e:	6f 91       	pop	r22
     e90:	5f 91       	pop	r21
     e92:	4f 91       	pop	r20
     e94:	3f 91       	pop	r19
     e96:	2f 91       	pop	r18
     e98:	1f 91       	pop	r17
     e9a:	0f 91       	pop	r16
     e9c:	ff 90       	pop	r15
     e9e:	ef 90       	pop	r14
     ea0:	df 90       	pop	r13
     ea2:	cf 90       	pop	r12
     ea4:	bf 90       	pop	r11
     ea6:	af 90       	pop	r10
     ea8:	9f 90       	pop	r9
     eaa:	8f 90       	pop	r8
     eac:	7f 90       	pop	r7
     eae:	6f 90       	pop	r6
     eb0:	5f 90       	pop	r5
     eb2:	4f 90       	pop	r4
     eb4:	3f 90       	pop	r3
     eb6:	2f 90       	pop	r2
     eb8:	1f 90       	pop	r1
     eba:	0f 90       	pop	r0
     ebc:	0c be       	out	0x3c, r0	; 60
     ebe:	0f 90       	pop	r0
     ec0:	0b be       	out	0x3b, r0	; 59
     ec2:	0f 90       	pop	r0
     ec4:	0f be       	out	0x3f, r0	; 63
     ec6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ec8:	08 95       	ret

00000eca <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eca:	0f 92       	push	r0
     ecc:	0f b6       	in	r0, 0x3f	; 63
     ece:	f8 94       	cli
     ed0:	0f 92       	push	r0
     ed2:	0b b6       	in	r0, 0x3b	; 59
     ed4:	0f 92       	push	r0
     ed6:	0c b6       	in	r0, 0x3c	; 60
     ed8:	0f 92       	push	r0
     eda:	1f 92       	push	r1
     edc:	11 24       	eor	r1, r1
     ede:	2f 92       	push	r2
     ee0:	3f 92       	push	r3
     ee2:	4f 92       	push	r4
     ee4:	5f 92       	push	r5
     ee6:	6f 92       	push	r6
     ee8:	7f 92       	push	r7
     eea:	8f 92       	push	r8
     eec:	9f 92       	push	r9
     eee:	af 92       	push	r10
     ef0:	bf 92       	push	r11
     ef2:	cf 92       	push	r12
     ef4:	df 92       	push	r13
     ef6:	ef 92       	push	r14
     ef8:	ff 92       	push	r15
     efa:	0f 93       	push	r16
     efc:	1f 93       	push	r17
     efe:	2f 93       	push	r18
     f00:	3f 93       	push	r19
     f02:	4f 93       	push	r20
     f04:	5f 93       	push	r21
     f06:	6f 93       	push	r22
     f08:	7f 93       	push	r23
     f0a:	8f 93       	push	r24
     f0c:	9f 93       	push	r25
     f0e:	af 93       	push	r26
     f10:	bf 93       	push	r27
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29
     f16:	ef 93       	push	r30
     f18:	ff 93       	push	r31
     f1a:	a0 91 9f 08 	lds	r26, 0x089F
     f1e:	b0 91 a0 08 	lds	r27, 0x08A0
     f22:	0d b6       	in	r0, 0x3d	; 61
     f24:	0d 92       	st	X+, r0
     f26:	0e b6       	in	r0, 0x3e	; 62
     f28:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f2a:	32 d5       	rcall	.+2660   	; 0x1990 <xTaskIncrementTick>
     f2c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     f2e:	02 d7       	rcall	.+3588   	; 0x1d34 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f30:	a0 91 9f 08 	lds	r26, 0x089F
     f34:	b0 91 a0 08 	lds	r27, 0x08A0
     f38:	cd 91       	ld	r28, X+
     f3a:	cd bf       	out	0x3d, r28	; 61
     f3c:	dd 91       	ld	r29, X+
     f3e:	de bf       	out	0x3e, r29	; 62
     f40:	ff 91       	pop	r31
     f42:	ef 91       	pop	r30
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	bf 91       	pop	r27
     f4a:	af 91       	pop	r26
     f4c:	9f 91       	pop	r25
     f4e:	8f 91       	pop	r24
     f50:	7f 91       	pop	r23
     f52:	6f 91       	pop	r22
     f54:	5f 91       	pop	r21
     f56:	4f 91       	pop	r20
     f58:	3f 91       	pop	r19
     f5a:	2f 91       	pop	r18
     f5c:	1f 91       	pop	r17
     f5e:	0f 91       	pop	r16
     f60:	ff 90       	pop	r15
     f62:	ef 90       	pop	r14
     f64:	df 90       	pop	r13
     f66:	cf 90       	pop	r12
     f68:	bf 90       	pop	r11
     f6a:	af 90       	pop	r10
     f6c:	9f 90       	pop	r9
     f6e:	8f 90       	pop	r8
     f70:	7f 90       	pop	r7
     f72:	6f 90       	pop	r6
     f74:	5f 90       	pop	r5
     f76:	4f 90       	pop	r4
     f78:	3f 90       	pop	r3
     f7a:	2f 90       	pop	r2
     f7c:	1f 90       	pop	r1
     f7e:	0f 90       	pop	r0
     f80:	0c be       	out	0x3c, r0	; 60
     f82:	0f 90       	pop	r0
     f84:	0b be       	out	0x3b, r0	; 59
     f86:	0f 90       	pop	r0
     f88:	0f be       	out	0x3f, r0	; 63
     f8a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f8c:	08 95       	ret

00000f8e <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     f8e:	9d df       	rcall	.-198    	; 0xeca <vPortYieldFromTick>
		 asm volatile ("reti");
     f90:	18 95       	reti

00000f92 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f92:	1f 93       	push	r17
     f94:	cf 93       	push	r28
     f96:	df 93       	push	r29
     f98:	ec 01       	movw	r28, r24
     f9a:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f9c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f9e:	81 11       	cpse	r24, r1
     fa0:	0c c0       	rjmp	.+24     	; 0xfba <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fa2:	88 81       	ld	r24, Y
     fa4:	99 81       	ldd	r25, Y+1	; 0x01
     fa6:	89 2b       	or	r24, r25
     fa8:	09 f0       	breq	.+2      	; 0xfac <prvCopyDataToQueue+0x1a>
     faa:	47 c0       	rjmp	.+142    	; 0x103a <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     fac:	8a 81       	ldd	r24, Y+2	; 0x02
     fae:	9b 81       	ldd	r25, Y+3	; 0x03
     fb0:	0e 94 5d 10 	call	0x20ba	; 0x20ba <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     fb4:	1b 82       	std	Y+3, r1	; 0x03
     fb6:	1a 82       	std	Y+2, r1	; 0x02
     fb8:	47 c0       	rjmp	.+142    	; 0x1048 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     fba:	41 11       	cpse	r20, r1
     fbc:	18 c0       	rjmp	.+48     	; 0xfee <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     fbe:	48 2f       	mov	r20, r24
     fc0:	50 e0       	ldi	r21, 0x00	; 0
     fc2:	8c 81       	ldd	r24, Y+4	; 0x04
     fc4:	9d 81       	ldd	r25, Y+5	; 0x05
     fc6:	0e 94 d5 10 	call	0x21aa	; 0x21aa <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     fca:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fcc:	8c 81       	ldd	r24, Y+4	; 0x04
     fce:	9d 81       	ldd	r25, Y+5	; 0x05
     fd0:	82 0f       	add	r24, r18
     fd2:	91 1d       	adc	r25, r1
     fd4:	9d 83       	std	Y+5, r25	; 0x05
     fd6:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     fd8:	2a 81       	ldd	r18, Y+2	; 0x02
     fda:	3b 81       	ldd	r19, Y+3	; 0x03
     fdc:	82 17       	cp	r24, r18
     fde:	93 07       	cpc	r25, r19
     fe0:	70 f1       	brcs	.+92     	; 0x103e <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     fe2:	88 81       	ld	r24, Y
     fe4:	99 81       	ldd	r25, Y+1	; 0x01
     fe6:	9d 83       	std	Y+5, r25	; 0x05
     fe8:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	2d c0       	rjmp	.+90     	; 0x1048 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     fee:	48 2f       	mov	r20, r24
     ff0:	50 e0       	ldi	r21, 0x00	; 0
     ff2:	8e 81       	ldd	r24, Y+6	; 0x06
     ff4:	9f 81       	ldd	r25, Y+7	; 0x07
     ff6:	0e 94 d5 10 	call	0x21aa	; 0x21aa <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     ffa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	31 95       	neg	r19
    1000:	21 95       	neg	r18
    1002:	31 09       	sbc	r19, r1
    1004:	8e 81       	ldd	r24, Y+6	; 0x06
    1006:	9f 81       	ldd	r25, Y+7	; 0x07
    1008:	82 0f       	add	r24, r18
    100a:	93 1f       	adc	r25, r19
    100c:	9f 83       	std	Y+7, r25	; 0x07
    100e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1010:	68 81       	ld	r22, Y
    1012:	79 81       	ldd	r23, Y+1	; 0x01
    1014:	86 17       	cp	r24, r22
    1016:	97 07       	cpc	r25, r23
    1018:	30 f4       	brcc	.+12     	; 0x1026 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    101a:	8a 81       	ldd	r24, Y+2	; 0x02
    101c:	9b 81       	ldd	r25, Y+3	; 0x03
    101e:	28 0f       	add	r18, r24
    1020:	39 1f       	adc	r19, r25
    1022:	3f 83       	std	Y+7, r19	; 0x07
    1024:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1026:	12 30       	cpi	r17, 0x02	; 2
    1028:	61 f4       	brne	.+24     	; 0x1042 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    102a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    102c:	88 23       	and	r24, r24
    102e:	59 f0       	breq	.+22     	; 0x1046 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1030:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1032:	81 50       	subi	r24, 0x01	; 1
    1034:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1036:	80 e0       	ldi	r24, 0x00	; 0
    1038:	07 c0       	rjmp	.+14     	; 0x1048 <prvCopyDataToQueue+0xb6>
    103a:	80 e0       	ldi	r24, 0x00	; 0
    103c:	05 c0       	rjmp	.+10     	; 0x1048 <prvCopyDataToQueue+0xb6>
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	03 c0       	rjmp	.+6      	; 0x1048 <prvCopyDataToQueue+0xb6>
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	01 c0       	rjmp	.+2      	; 0x1048 <prvCopyDataToQueue+0xb6>
    1046:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1048:	9a 8d       	ldd	r25, Y+26	; 0x1a
    104a:	9f 5f       	subi	r25, 0xFF	; 255
    104c:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    104e:	df 91       	pop	r29
    1050:	cf 91       	pop	r28
    1052:	1f 91       	pop	r17
    1054:	08 95       	ret

00001056 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1056:	fc 01       	movw	r30, r24
    1058:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    105a:	44 8d       	ldd	r20, Z+28	; 0x1c
    105c:	44 23       	and	r20, r20
    105e:	a1 f0       	breq	.+40     	; 0x1088 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1060:	50 e0       	ldi	r21, 0x00	; 0
    1062:	26 81       	ldd	r18, Z+6	; 0x06
    1064:	37 81       	ldd	r19, Z+7	; 0x07
    1066:	24 0f       	add	r18, r20
    1068:	35 1f       	adc	r19, r21
    106a:	37 83       	std	Z+7, r19	; 0x07
    106c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    106e:	62 81       	ldd	r22, Z+2	; 0x02
    1070:	73 81       	ldd	r23, Z+3	; 0x03
    1072:	26 17       	cp	r18, r22
    1074:	37 07       	cpc	r19, r23
    1076:	20 f0       	brcs	.+8      	; 0x1080 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1078:	20 81       	ld	r18, Z
    107a:	31 81       	ldd	r19, Z+1	; 0x01
    107c:	37 83       	std	Z+7, r19	; 0x07
    107e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1080:	66 81       	ldd	r22, Z+6	; 0x06
    1082:	77 81       	ldd	r23, Z+7	; 0x07
    1084:	0c 94 d5 10 	jmp	0x21aa	; 0x21aa <memcpy>
    1088:	08 95       	ret

0000108a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    108a:	0f 93       	push	r16
    108c:	1f 93       	push	r17
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    109a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    109c:	18 16       	cp	r1, r24
    109e:	a4 f4       	brge	.+40     	; 0x10c8 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10a0:	89 89       	ldd	r24, Y+17	; 0x11
    10a2:	88 23       	and	r24, r24
    10a4:	89 f0       	breq	.+34     	; 0x10c8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10a6:	8e 01       	movw	r16, r28
    10a8:	0f 5e       	subi	r16, 0xEF	; 239
    10aa:	1f 4f       	sbci	r17, 0xFF	; 255
    10ac:	03 c0       	rjmp	.+6      	; 0x10b4 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10ae:	89 89       	ldd	r24, Y+17	; 0x11
    10b0:	88 23       	and	r24, r24
    10b2:	51 f0       	breq	.+20     	; 0x10c8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10b4:	c8 01       	movw	r24, r16
    10b6:	14 d7       	rcall	.+3624   	; 0x1ee0 <xTaskRemoveFromEventList>
    10b8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    10ba:	9d d7       	rcall	.+3898   	; 0x1ff6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    10bc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10be:	81 50       	subi	r24, 0x01	; 1
    10c0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    10c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10c4:	18 16       	cp	r1, r24
    10c6:	9c f3       	brlt	.-26     	; 0x10ae <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    10c8:	8f ef       	ldi	r24, 0xFF	; 255
    10ca:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    10cc:	0f 90       	pop	r0
    10ce:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    10d6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10d8:	18 16       	cp	r1, r24
    10da:	a4 f4       	brge	.+40     	; 0x1104 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10dc:	88 85       	ldd	r24, Y+8	; 0x08
    10de:	88 23       	and	r24, r24
    10e0:	89 f0       	breq	.+34     	; 0x1104 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10e2:	8e 01       	movw	r16, r28
    10e4:	08 5f       	subi	r16, 0xF8	; 248
    10e6:	1f 4f       	sbci	r17, 0xFF	; 255
    10e8:	03 c0       	rjmp	.+6      	; 0x10f0 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ea:	88 85       	ldd	r24, Y+8	; 0x08
    10ec:	88 23       	and	r24, r24
    10ee:	51 f0       	breq	.+20     	; 0x1104 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10f0:	c8 01       	movw	r24, r16
    10f2:	f6 d6       	rcall	.+3564   	; 0x1ee0 <xTaskRemoveFromEventList>
    10f4:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    10f6:	7f d7       	rcall	.+3838   	; 0x1ff6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    10f8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10fa:	81 50       	subi	r24, 0x01	; 1
    10fc:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    10fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1100:	18 16       	cp	r1, r24
    1102:	9c f3       	brlt	.-26     	; 0x10ea <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1104:	8f ef       	ldi	r24, 0xFF	; 255
    1106:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	08 95       	ret

00001116 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
    111a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1122:	88 81       	ld	r24, Y
    1124:	99 81       	ldd	r25, Y+1	; 0x01
    1126:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    112c:	72 9f       	mul	r23, r18
    112e:	a0 01       	movw	r20, r0
    1130:	73 9f       	mul	r23, r19
    1132:	50 0d       	add	r21, r0
    1134:	11 24       	eor	r1, r1
    1136:	fc 01       	movw	r30, r24
    1138:	e4 0f       	add	r30, r20
    113a:	f5 1f       	adc	r31, r21
    113c:	fb 83       	std	Y+3, r31	; 0x03
    113e:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1140:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1142:	9d 83       	std	Y+5, r25	; 0x05
    1144:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1146:	42 1b       	sub	r20, r18
    1148:	53 0b       	sbc	r21, r19
    114a:	84 0f       	add	r24, r20
    114c:	95 1f       	adc	r25, r21
    114e:	9f 83       	std	Y+7, r25	; 0x07
    1150:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1156:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1158:	61 11       	cpse	r22, r1
    115a:	0a c0       	rjmp	.+20     	; 0x1170 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    115c:	88 85       	ldd	r24, Y+8	; 0x08
    115e:	88 23       	and	r24, r24
    1160:	69 f0       	breq	.+26     	; 0x117c <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1162:	ce 01       	movw	r24, r28
    1164:	08 96       	adiw	r24, 0x08	; 8
    1166:	bc d6       	rcall	.+3448   	; 0x1ee0 <xTaskRemoveFromEventList>
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	41 f4       	brne	.+16     	; 0x117c <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    116c:	4e de       	rcall	.-868    	; 0xe0a <vPortYield>
    116e:	06 c0       	rjmp	.+12     	; 0x117c <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1170:	ce 01       	movw	r24, r28
    1172:	08 96       	adiw	r24, 0x08	; 8
    1174:	64 d9       	rcall	.-3384   	; 0x43e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1176:	ce 01       	movw	r24, r28
    1178:	41 96       	adiw	r24, 0x11	; 17
    117a:	61 d9       	rcall	.-3390   	; 0x43e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    117c:	0f 90       	pop	r0
    117e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	08 95       	ret

00001188 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1188:	0f 93       	push	r16
    118a:	1f 93       	push	r17
    118c:	cf 93       	push	r28
    118e:	df 93       	push	r29
    1190:	18 2f       	mov	r17, r24
    1192:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1194:	88 23       	and	r24, r24
    1196:	d1 f0       	breq	.+52     	; 0x11cc <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1198:	8f e1       	ldi	r24, 0x1F	; 31
    119a:	90 e0       	ldi	r25, 0x00	; 0
    119c:	1a d9       	rcall	.-3532   	; 0x3d2 <pvPortMalloc>
    119e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    11a0:	00 97       	sbiw	r24, 0x00	; 0
    11a2:	b1 f0       	breq	.+44     	; 0x11d0 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    11a4:	10 9f       	mul	r17, r16
    11a6:	c0 01       	movw	r24, r0
    11a8:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    11aa:	01 96       	adiw	r24, 0x01	; 1
    11ac:	12 d9       	rcall	.-3548   	; 0x3d2 <pvPortMalloc>
    11ae:	99 83       	std	Y+1, r25	; 0x01
    11b0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    11b2:	89 2b       	or	r24, r25
    11b4:	31 f0       	breq	.+12     	; 0x11c2 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    11b6:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11b8:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    11ba:	61 e0       	ldi	r22, 0x01	; 1
    11bc:	ce 01       	movw	r24, r28
    11be:	ab df       	rcall	.-170    	; 0x1116 <xQueueGenericReset>
    11c0:	07 c0       	rjmp	.+14     	; 0x11d0 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    11c2:	ce 01       	movw	r24, r28
    11c4:	3b d9       	rcall	.-3466   	; 0x43c <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    11c6:	c0 e0       	ldi	r28, 0x00	; 0
    11c8:	d0 e0       	ldi	r29, 0x00	; 0
    11ca:	02 c0       	rjmp	.+4      	; 0x11d0 <xQueueGenericCreate+0x48>
    11cc:	c0 e0       	ldi	r28, 0x00	; 0
    11ce:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    11d0:	ce 01       	movw	r24, r28
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	1f 91       	pop	r17
    11d8:	0f 91       	pop	r16
    11da:	08 95       	ret

000011dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    11dc:	9f 92       	push	r9
    11de:	af 92       	push	r10
    11e0:	bf 92       	push	r11
    11e2:	cf 92       	push	r12
    11e4:	df 92       	push	r13
    11e6:	ef 92       	push	r14
    11e8:	ff 92       	push	r15
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	00 d0       	rcall	.+0      	; 0x11f4 <xQueueGenericSend+0x18>
    11f4:	1f 92       	push	r1
    11f6:	1f 92       	push	r1
    11f8:	cd b7       	in	r28, 0x3d	; 61
    11fa:	de b7       	in	r29, 0x3e	; 62
    11fc:	8c 01       	movw	r16, r24
    11fe:	6b 01       	movw	r12, r22
    1200:	5d 83       	std	Y+5, r21	; 0x05
    1202:	4c 83       	std	Y+4, r20	; 0x04
    1204:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1206:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1208:	99 24       	eor	r9, r9
    120a:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    120c:	7c 01       	movw	r14, r24
    120e:	88 e0       	ldi	r24, 0x08	; 8
    1210:	e8 0e       	add	r14, r24
    1212:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1214:	0f b6       	in	r0, 0x3f	; 63
    1216:	f8 94       	cli
    1218:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    121a:	f8 01       	movw	r30, r16
    121c:	92 8d       	ldd	r25, Z+26	; 0x1a
    121e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1220:	98 17       	cp	r25, r24
    1222:	18 f0       	brcs	.+6      	; 0x122a <xQueueGenericSend+0x4e>
    1224:	f2 e0       	ldi	r31, 0x02	; 2
    1226:	af 12       	cpse	r10, r31
    1228:	15 c0       	rjmp	.+42     	; 0x1254 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    122a:	4a 2d       	mov	r20, r10
    122c:	b6 01       	movw	r22, r12
    122e:	c8 01       	movw	r24, r16
    1230:	b0 de       	rcall	.-672    	; 0xf92 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1232:	f8 01       	movw	r30, r16
    1234:	91 89       	ldd	r25, Z+17	; 0x11
    1236:	99 23       	and	r25, r25
    1238:	39 f0       	breq	.+14     	; 0x1248 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    123a:	c8 01       	movw	r24, r16
    123c:	41 96       	adiw	r24, 0x11	; 17
    123e:	50 d6       	rcall	.+3232   	; 0x1ee0 <xTaskRemoveFromEventList>
    1240:	81 30       	cpi	r24, 0x01	; 1
    1242:	21 f4       	brne	.+8      	; 0x124c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1244:	e2 dd       	rcall	.-1084   	; 0xe0a <vPortYield>
    1246:	02 c0       	rjmp	.+4      	; 0x124c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1248:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    124a:	df dd       	rcall	.-1090   	; 0xe0a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    124c:	0f 90       	pop	r0
    124e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	46 c0       	rjmp	.+140    	; 0x12e0 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1254:	ec 81       	ldd	r30, Y+4	; 0x04
    1256:	fd 81       	ldd	r31, Y+5	; 0x05
    1258:	ef 2b       	or	r30, r31
    125a:	21 f4       	brne	.+8      	; 0x1264 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    125c:	0f 90       	pop	r0
    125e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1260:	80 e0       	ldi	r24, 0x00	; 0
    1262:	3e c0       	rjmp	.+124    	; 0x12e0 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1264:	b1 10       	cpse	r11, r1
    1266:	04 c0       	rjmp	.+8      	; 0x1270 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1268:	ce 01       	movw	r24, r28
    126a:	01 96       	adiw	r24, 0x01	; 1
    126c:	81 d6       	rcall	.+3330   	; 0x1f70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    126e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1274:	78 d3       	rcall	.+1776   	; 0x1966 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1276:	0f b6       	in	r0, 0x3f	; 63
    1278:	f8 94       	cli
    127a:	0f 92       	push	r0
    127c:	f8 01       	movw	r30, r16
    127e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1280:	8f 3f       	cpi	r24, 0xFF	; 255
    1282:	09 f4       	brne	.+2      	; 0x1286 <xQueueGenericSend+0xaa>
    1284:	15 8e       	std	Z+29, r1	; 0x1d
    1286:	f8 01       	movw	r30, r16
    1288:	86 8d       	ldd	r24, Z+30	; 0x1e
    128a:	8f 3f       	cpi	r24, 0xFF	; 255
    128c:	09 f4       	brne	.+2      	; 0x1290 <xQueueGenericSend+0xb4>
    128e:	16 8e       	std	Z+30, r1	; 0x1e
    1290:	0f 90       	pop	r0
    1292:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1294:	be 01       	movw	r22, r28
    1296:	6c 5f       	subi	r22, 0xFC	; 252
    1298:	7f 4f       	sbci	r23, 0xFF	; 255
    129a:	ce 01       	movw	r24, r28
    129c:	01 96       	adiw	r24, 0x01	; 1
    129e:	73 d6       	rcall	.+3302   	; 0x1f86 <xTaskCheckForTimeOut>
    12a0:	81 11       	cpse	r24, r1
    12a2:	1a c0       	rjmp	.+52     	; 0x12d8 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12a4:	0f b6       	in	r0, 0x3f	; 63
    12a6:	f8 94       	cli
    12a8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12aa:	f8 01       	movw	r30, r16
    12ac:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12ae:	0f 90       	pop	r0
    12b0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12b2:	f8 01       	movw	r30, r16
    12b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    12b6:	98 13       	cpse	r25, r24
    12b8:	0b c0       	rjmp	.+22     	; 0x12d0 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12ba:	6c 81       	ldd	r22, Y+4	; 0x04
    12bc:	7d 81       	ldd	r23, Y+5	; 0x05
    12be:	c7 01       	movw	r24, r14
    12c0:	e4 d5       	rcall	.+3016   	; 0x1e8a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    12c2:	c8 01       	movw	r24, r16
    12c4:	e2 de       	rcall	.-572    	; 0x108a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12c6:	22 d4       	rcall	.+2116   	; 0x1b0c <xTaskResumeAll>
    12c8:	81 11       	cpse	r24, r1
    12ca:	a4 cf       	rjmp	.-184    	; 0x1214 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    12cc:	9e dd       	rcall	.-1220   	; 0xe0a <vPortYield>
    12ce:	a2 cf       	rjmp	.-188    	; 0x1214 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12d0:	c8 01       	movw	r24, r16
    12d2:	db de       	rcall	.-586    	; 0x108a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12d4:	1b d4       	rcall	.+2102   	; 0x1b0c <xTaskResumeAll>
    12d6:	9e cf       	rjmp	.-196    	; 0x1214 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12d8:	c8 01       	movw	r24, r16
    12da:	d7 de       	rcall	.-594    	; 0x108a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12dc:	17 d4       	rcall	.+2094   	; 0x1b0c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    12de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	0f 90       	pop	r0
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	1f 91       	pop	r17
    12f0:	0f 91       	pop	r16
    12f2:	ff 90       	pop	r15
    12f4:	ef 90       	pop	r14
    12f6:	df 90       	pop	r13
    12f8:	cf 90       	pop	r12
    12fa:	bf 90       	pop	r11
    12fc:	af 90       	pop	r10
    12fe:	9f 90       	pop	r9
    1300:	08 95       	ret

00001302 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1302:	cf 93       	push	r28
    1304:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1306:	8f e1       	ldi	r24, 0x1F	; 31
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	63 d8       	rcall	.-3898   	; 0x3d2 <pvPortMalloc>
    130c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    130e:	00 97       	sbiw	r24, 0x00	; 0
    1310:	e1 f0       	breq	.+56     	; 0x134a <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1312:	1b 82       	std	Y+3, r1	; 0x03
    1314:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1316:	19 82       	std	Y+1, r1	; 0x01
    1318:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    131a:	1d 82       	std	Y+5, r1	; 0x05
    131c:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    131e:	1f 82       	std	Y+7, r1	; 0x07
    1320:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1322:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1328:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    132a:	8f ef       	ldi	r24, 0xFF	; 255
    132c:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    132e:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1330:	ce 01       	movw	r24, r28
    1332:	08 96       	adiw	r24, 0x08	; 8
    1334:	84 d8       	rcall	.-3832   	; 0x43e <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1336:	ce 01       	movw	r24, r28
    1338:	41 96       	adiw	r24, 0x11	; 17
    133a:	81 d8       	rcall	.-3838   	; 0x43e <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    133c:	20 e0       	ldi	r18, 0x00	; 0
    133e:	40 e0       	ldi	r20, 0x00	; 0
    1340:	50 e0       	ldi	r21, 0x00	; 0
    1342:	60 e0       	ldi	r22, 0x00	; 0
    1344:	70 e0       	ldi	r23, 0x00	; 0
    1346:	ce 01       	movw	r24, r28
    1348:	49 df       	rcall	.-366    	; 0x11dc <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    134a:	ce 01       	movw	r24, r28
    134c:	df 91       	pop	r29
    134e:	cf 91       	pop	r28
    1350:	08 95       	ret

00001352 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1352:	0f 93       	push	r16
    1354:	1f 93       	push	r17
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	ec 01       	movw	r28, r24
    135c:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    135e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1360:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1362:	98 17       	cp	r25, r24
    1364:	10 f0       	brcs	.+4      	; 0x136a <xQueueGenericSendFromISR+0x18>
    1366:	22 30       	cpi	r18, 0x02	; 2
    1368:	11 f5       	brne	.+68     	; 0x13ae <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    136a:	42 2f       	mov	r20, r18
    136c:	ce 01       	movw	r24, r28
    136e:	11 de       	rcall	.-990    	; 0xf92 <prvCopyDataToQueue>
    1370:	88 23       	and	r24, r24
    1372:	31 f0       	breq	.+12     	; 0x1380 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1374:	01 15       	cp	r16, r1
    1376:	11 05       	cpc	r17, r1
    1378:	19 f0       	breq	.+6      	; 0x1380 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	f8 01       	movw	r30, r16
    137e:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1380:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1382:	8f 3f       	cpi	r24, 0xFF	; 255
    1384:	79 f4       	brne	.+30     	; 0x13a4 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1386:	89 89       	ldd	r24, Y+17	; 0x11
    1388:	88 23       	and	r24, r24
    138a:	99 f0       	breq	.+38     	; 0x13b2 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    138c:	ce 01       	movw	r24, r28
    138e:	41 96       	adiw	r24, 0x11	; 17
    1390:	a7 d5       	rcall	.+2894   	; 0x1ee0 <xTaskRemoveFromEventList>
    1392:	88 23       	and	r24, r24
    1394:	81 f0       	breq	.+32     	; 0x13b6 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1396:	01 15       	cp	r16, r1
    1398:	11 05       	cpc	r17, r1
    139a:	79 f0       	breq	.+30     	; 0x13ba <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	f8 01       	movw	r30, r16
    13a0:	80 83       	st	Z, r24
    13a2:	0c c0       	rjmp	.+24     	; 0x13bc <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13a6:	8f 5f       	subi	r24, 0xFF	; 255
    13a8:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	07 c0       	rjmp	.+14     	; 0x13bc <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	05 c0       	rjmp	.+10     	; 0x13bc <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	03 c0       	rjmp	.+6      	; 0x13bc <xQueueGenericSendFromISR+0x6a>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	01 c0       	rjmp	.+2      	; 0x13bc <xQueueGenericSendFromISR+0x6a>
    13ba:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13bc:	df 91       	pop	r29
    13be:	cf 91       	pop	r28
    13c0:	1f 91       	pop	r17
    13c2:	0f 91       	pop	r16
    13c4:	08 95       	ret

000013c6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    13c6:	9f 92       	push	r9
    13c8:	af 92       	push	r10
    13ca:	bf 92       	push	r11
    13cc:	cf 92       	push	r12
    13ce:	df 92       	push	r13
    13d0:	ef 92       	push	r14
    13d2:	ff 92       	push	r15
    13d4:	0f 93       	push	r16
    13d6:	1f 93       	push	r17
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	00 d0       	rcall	.+0      	; 0x13de <xQueueGenericReceive+0x18>
    13de:	1f 92       	push	r1
    13e0:	1f 92       	push	r1
    13e2:	cd b7       	in	r28, 0x3d	; 61
    13e4:	de b7       	in	r29, 0x3e	; 62
    13e6:	8c 01       	movw	r16, r24
    13e8:	6b 01       	movw	r12, r22
    13ea:	5d 83       	std	Y+5, r21	; 0x05
    13ec:	4c 83       	std	Y+4, r20	; 0x04
    13ee:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    13f0:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    13f2:	99 24       	eor	r9, r9
    13f4:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13f6:	7c 01       	movw	r14, r24
    13f8:	81 e1       	ldi	r24, 0x11	; 17
    13fa:	e8 0e       	add	r14, r24
    13fc:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    13fe:	0f b6       	in	r0, 0x3f	; 63
    1400:	f8 94       	cli
    1402:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1404:	f8 01       	movw	r30, r16
    1406:	82 8d       	ldd	r24, Z+26	; 0x1a
    1408:	88 23       	and	r24, r24
    140a:	69 f1       	breq	.+90     	; 0x1466 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    140c:	e6 80       	ldd	r14, Z+6	; 0x06
    140e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1410:	b6 01       	movw	r22, r12
    1412:	c8 01       	movw	r24, r16
    1414:	20 de       	rcall	.-960    	; 0x1056 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1416:	b1 10       	cpse	r11, r1
    1418:	17 c0       	rjmp	.+46     	; 0x1448 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    141a:	f8 01       	movw	r30, r16
    141c:	82 8d       	ldd	r24, Z+26	; 0x1a
    141e:	81 50       	subi	r24, 0x01	; 1
    1420:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1422:	80 81       	ld	r24, Z
    1424:	91 81       	ldd	r25, Z+1	; 0x01
    1426:	89 2b       	or	r24, r25
    1428:	21 f4       	brne	.+8      	; 0x1432 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    142a:	86 d6       	rcall	.+3340   	; 0x2138 <pvTaskIncrementMutexHeldCount>
    142c:	f8 01       	movw	r30, r16
    142e:	93 83       	std	Z+3, r25	; 0x03
    1430:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1432:	f8 01       	movw	r30, r16
    1434:	80 85       	ldd	r24, Z+8	; 0x08
    1436:	88 23       	and	r24, r24
    1438:	91 f0       	breq	.+36     	; 0x145e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    143a:	c8 01       	movw	r24, r16
    143c:	08 96       	adiw	r24, 0x08	; 8
    143e:	50 d5       	rcall	.+2720   	; 0x1ee0 <xTaskRemoveFromEventList>
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	69 f4       	brne	.+26     	; 0x145e <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1444:	e2 dc       	rcall	.-1596   	; 0xe0a <vPortYield>
    1446:	0b c0       	rjmp	.+22     	; 0x145e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1448:	f8 01       	movw	r30, r16
    144a:	f7 82       	std	Z+7, r15	; 0x07
    144c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    144e:	81 89       	ldd	r24, Z+17	; 0x11
    1450:	88 23       	and	r24, r24
    1452:	29 f0       	breq	.+10     	; 0x145e <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1454:	c8 01       	movw	r24, r16
    1456:	41 96       	adiw	r24, 0x11	; 17
    1458:	43 d5       	rcall	.+2694   	; 0x1ee0 <xTaskRemoveFromEventList>
    145a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    145c:	d6 dc       	rcall	.-1620   	; 0xe0a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	52 c0       	rjmp	.+164    	; 0x150a <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1466:	4c 81       	ldd	r20, Y+4	; 0x04
    1468:	5d 81       	ldd	r21, Y+5	; 0x05
    146a:	45 2b       	or	r20, r21
    146c:	21 f4       	brne	.+8      	; 0x1476 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    146e:	0f 90       	pop	r0
    1470:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1472:	80 e0       	ldi	r24, 0x00	; 0
    1474:	4a c0       	rjmp	.+148    	; 0x150a <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1476:	a1 10       	cpse	r10, r1
    1478:	04 c0       	rjmp	.+8      	; 0x1482 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    147a:	ce 01       	movw	r24, r28
    147c:	01 96       	adiw	r24, 0x01	; 1
    147e:	78 d5       	rcall	.+2800   	; 0x1f70 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1480:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1482:	0f 90       	pop	r0
    1484:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1486:	6f d2       	rcall	.+1246   	; 0x1966 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	0f 92       	push	r0
    148e:	f8 01       	movw	r30, r16
    1490:	85 8d       	ldd	r24, Z+29	; 0x1d
    1492:	8f 3f       	cpi	r24, 0xFF	; 255
    1494:	09 f4       	brne	.+2      	; 0x1498 <xQueueGenericReceive+0xd2>
    1496:	15 8e       	std	Z+29, r1	; 0x1d
    1498:	f8 01       	movw	r30, r16
    149a:	86 8d       	ldd	r24, Z+30	; 0x1e
    149c:	8f 3f       	cpi	r24, 0xFF	; 255
    149e:	09 f4       	brne	.+2      	; 0x14a2 <xQueueGenericReceive+0xdc>
    14a0:	16 8e       	std	Z+30, r1	; 0x1e
    14a2:	0f 90       	pop	r0
    14a4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14a6:	be 01       	movw	r22, r28
    14a8:	6c 5f       	subi	r22, 0xFC	; 252
    14aa:	7f 4f       	sbci	r23, 0xFF	; 255
    14ac:	ce 01       	movw	r24, r28
    14ae:	01 96       	adiw	r24, 0x01	; 1
    14b0:	6a d5       	rcall	.+2772   	; 0x1f86 <xTaskCheckForTimeOut>
    14b2:	81 11       	cpse	r24, r1
    14b4:	26 c0       	rjmp	.+76     	; 0x1502 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    14bc:	f8 01       	movw	r30, r16
    14be:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14c4:	81 11       	cpse	r24, r1
    14c6:	19 c0       	rjmp	.+50     	; 0x14fa <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14c8:	f8 01       	movw	r30, r16
    14ca:	80 81       	ld	r24, Z
    14cc:	91 81       	ldd	r25, Z+1	; 0x01
    14ce:	89 2b       	or	r24, r25
    14d0:	49 f4       	brne	.+18     	; 0x14e4 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    14d8:	f8 01       	movw	r30, r16
    14da:	82 81       	ldd	r24, Z+2	; 0x02
    14dc:	93 81       	ldd	r25, Z+3	; 0x03
    14de:	8f d5       	rcall	.+2846   	; 0x1ffe <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    14e0:	0f 90       	pop	r0
    14e2:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14e4:	6c 81       	ldd	r22, Y+4	; 0x04
    14e6:	7d 81       	ldd	r23, Y+5	; 0x05
    14e8:	c7 01       	movw	r24, r14
    14ea:	cf d4       	rcall	.+2462   	; 0x1e8a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14ec:	c8 01       	movw	r24, r16
    14ee:	cd dd       	rcall	.-1126   	; 0x108a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14f0:	0d d3       	rcall	.+1562   	; 0x1b0c <xTaskResumeAll>
    14f2:	81 11       	cpse	r24, r1
    14f4:	84 cf       	rjmp	.-248    	; 0x13fe <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    14f6:	89 dc       	rcall	.-1774   	; 0xe0a <vPortYield>
    14f8:	82 cf       	rjmp	.-252    	; 0x13fe <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14fa:	c8 01       	movw	r24, r16
    14fc:	c6 dd       	rcall	.-1140   	; 0x108a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14fe:	06 d3       	rcall	.+1548   	; 0x1b0c <xTaskResumeAll>
    1500:	7e cf       	rjmp	.-260    	; 0x13fe <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1502:	c8 01       	movw	r24, r16
    1504:	c2 dd       	rcall	.-1148   	; 0x108a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1506:	02 d3       	rcall	.+1540   	; 0x1b0c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1508:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	0f 90       	pop	r0
    1510:	0f 90       	pop	r0
    1512:	0f 90       	pop	r0
    1514:	df 91       	pop	r29
    1516:	cf 91       	pop	r28
    1518:	1f 91       	pop	r17
    151a:	0f 91       	pop	r16
    151c:	ff 90       	pop	r15
    151e:	ef 90       	pop	r14
    1520:	df 90       	pop	r13
    1522:	cf 90       	pop	r12
    1524:	bf 90       	pop	r11
    1526:	af 90       	pop	r10
    1528:	9f 90       	pop	r9
    152a:	08 95       	ret

0000152c <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    152c:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    152e:	71 83       	std	Z+1, r23	; 0x01
    1530:	60 83       	st	Z, r22
	ring->rSize = size;
    1532:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1534:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1536:	13 82       	std	Z+3, r1	; 0x03
    1538:	08 95       	ret

0000153a <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    153a:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    153c:	94 81       	ldd	r25, Z+4	; 0x04
    153e:	a0 81       	ld	r26, Z
    1540:	b1 81       	ldd	r27, Z+1	; 0x01
    1542:	a9 0f       	add	r26, r25
    1544:	b1 1d       	adc	r27, r1
    1546:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1548:	9f 5f       	subi	r25, 0xFF	; 255
    154a:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    154c:	22 81       	ldd	r18, Z+2	; 0x02
    154e:	92 17       	cp	r25, r18
    1550:	10 f0       	brcs	.+4      	; 0x1556 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1552:	92 1b       	sub	r25, r18
    1554:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1556:	93 81       	ldd	r25, Z+3	; 0x03
    1558:	91 50       	subi	r25, 0x01	; 1
    155a:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    155c:	08 95       	ret

0000155e <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    155e:	fc 01       	movw	r30, r24
    1560:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1562:	83 81       	ldd	r24, Z+3	; 0x03
    1564:	22 81       	ldd	r18, Z+2	; 0x02
    1566:	82 17       	cp	r24, r18
    1568:	78 f4       	brcc	.+30     	; 0x1588 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    156a:	34 81       	ldd	r19, Z+4	; 0x04
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	83 0f       	add	r24, r19
    1570:	91 1d       	adc	r25, r1
    1572:	62 2f       	mov	r22, r18
    1574:	70 e0       	ldi	r23, 0x00	; 0
    1576:	f2 d5       	rcall	.+3044   	; 0x215c <__divmodhi4>
    1578:	a0 81       	ld	r26, Z
    157a:	b1 81       	ldd	r27, Z+1	; 0x01
    157c:	a8 0f       	add	r26, r24
    157e:	b9 1f       	adc	r27, r25
    1580:	4c 93       	st	X, r20
            ring->rLength++;
    1582:	83 81       	ldd	r24, Z+3	; 0x03
    1584:	8f 5f       	subi	r24, 0xFF	; 255
    1586:	83 83       	std	Z+3, r24	; 0x03
    1588:	08 95       	ret

0000158a <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    158a:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	22 81       	ldd	r18, Z+2	; 0x02
    1590:	93 81       	ldd	r25, Z+3	; 0x03
    1592:	29 13       	cpse	r18, r25
    1594:	80 e0       	ldi	r24, 0x00	; 0
}
    1596:	08 95       	ret

00001598 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1598:	21 e0       	ldi	r18, 0x01	; 1
    159a:	fc 01       	movw	r30, r24
    159c:	83 81       	ldd	r24, Z+3	; 0x03
    159e:	81 11       	cpse	r24, r1
    15a0:	01 c0       	rjmp	.+2      	; 0x15a4 <ringBufferNotEmpty+0xc>
    15a2:	20 e0       	ldi	r18, 0x00	; 0
}
    15a4:	82 2f       	mov	r24, r18
    15a6:	08 95       	ret

000015a8 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    15a8:	e0 91 5e 08 	lds	r30, 0x085E
    15ac:	f0 91 5f 08 	lds	r31, 0x085F
    15b0:	80 81       	ld	r24, Z
    15b2:	81 11       	cpse	r24, r1
    15b4:	07 c0       	rjmp	.+14     	; 0x15c4 <prvResetNextTaskUnblockTime+0x1c>
    15b6:	8f ef       	ldi	r24, 0xFF	; 255
    15b8:	9f ef       	ldi	r25, 0xFF	; 255
    15ba:	90 93 05 02 	sts	0x0205, r25
    15be:	80 93 04 02 	sts	0x0204, r24
    15c2:	08 95       	ret
    15c4:	e0 91 5e 08 	lds	r30, 0x085E
    15c8:	f0 91 5f 08 	lds	r31, 0x085F
    15cc:	05 80       	ldd	r0, Z+5	; 0x05
    15ce:	f6 81       	ldd	r31, Z+6	; 0x06
    15d0:	e0 2d       	mov	r30, r0
    15d2:	06 80       	ldd	r0, Z+6	; 0x06
    15d4:	f7 81       	ldd	r31, Z+7	; 0x07
    15d6:	e0 2d       	mov	r30, r0
    15d8:	82 81       	ldd	r24, Z+2	; 0x02
    15da:	93 81       	ldd	r25, Z+3	; 0x03
    15dc:	90 93 05 02 	sts	0x0205, r25
    15e0:	80 93 04 02 	sts	0x0204, r24
    15e4:	08 95       	ret

000015e6 <prvAddCurrentTaskToDelayedList>:
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	ec 01       	movw	r28, r24
    15ec:	e0 91 9f 08 	lds	r30, 0x089F
    15f0:	f0 91 a0 08 	lds	r31, 0x08A0
    15f4:	93 83       	std	Z+3, r25	; 0x03
    15f6:	82 83       	std	Z+2, r24	; 0x02
    15f8:	80 91 3d 08 	lds	r24, 0x083D
    15fc:	90 91 3e 08 	lds	r25, 0x083E
    1600:	c8 17       	cp	r28, r24
    1602:	d9 07       	cpc	r29, r25
    1604:	68 f4       	brcc	.+26     	; 0x1620 <prvAddCurrentTaskToDelayedList+0x3a>
    1606:	60 91 9f 08 	lds	r22, 0x089F
    160a:	70 91 a0 08 	lds	r23, 0x08A0
    160e:	80 91 5c 08 	lds	r24, 0x085C
    1612:	90 91 5d 08 	lds	r25, 0x085D
    1616:	6e 5f       	subi	r22, 0xFE	; 254
    1618:	7f 4f       	sbci	r23, 0xFF	; 255
    161a:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vListInsert>
    161e:	17 c0       	rjmp	.+46     	; 0x164e <prvAddCurrentTaskToDelayedList+0x68>
    1620:	60 91 9f 08 	lds	r22, 0x089F
    1624:	70 91 a0 08 	lds	r23, 0x08A0
    1628:	80 91 5e 08 	lds	r24, 0x085E
    162c:	90 91 5f 08 	lds	r25, 0x085F
    1630:	6e 5f       	subi	r22, 0xFE	; 254
    1632:	7f 4f       	sbci	r23, 0xFF	; 255
    1634:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vListInsert>
    1638:	80 91 04 02 	lds	r24, 0x0204
    163c:	90 91 05 02 	lds	r25, 0x0205
    1640:	c8 17       	cp	r28, r24
    1642:	d9 07       	cpc	r29, r25
    1644:	20 f4       	brcc	.+8      	; 0x164e <prvAddCurrentTaskToDelayedList+0x68>
    1646:	d0 93 05 02 	sts	0x0205, r29
    164a:	c0 93 04 02 	sts	0x0204, r28
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	08 95       	ret

00001654 <xTaskGenericCreate>:
    1654:	4f 92       	push	r4
    1656:	5f 92       	push	r5
    1658:	6f 92       	push	r6
    165a:	7f 92       	push	r7
    165c:	8f 92       	push	r8
    165e:	9f 92       	push	r9
    1660:	af 92       	push	r10
    1662:	bf 92       	push	r11
    1664:	cf 92       	push	r12
    1666:	df 92       	push	r13
    1668:	ef 92       	push	r14
    166a:	ff 92       	push	r15
    166c:	0f 93       	push	r16
    166e:	1f 93       	push	r17
    1670:	cf 93       	push	r28
    1672:	df 93       	push	r29
    1674:	4c 01       	movw	r8, r24
    1676:	5b 01       	movw	r10, r22
    1678:	2a 01       	movw	r4, r20
    167a:	39 01       	movw	r6, r18
    167c:	83 e2       	ldi	r24, 0x23	; 35
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <pvPortMalloc>
    1684:	ec 01       	movw	r28, r24
    1686:	00 97       	sbiw	r24, 0x00	; 0
    1688:	09 f4       	brne	.+2      	; 0x168c <xTaskGenericCreate+0x38>
    168a:	e7 c0       	rjmp	.+462    	; 0x185a <xTaskGenericCreate+0x206>
    168c:	c1 14       	cp	r12, r1
    168e:	d1 04       	cpc	r13, r1
    1690:	09 f0       	breq	.+2      	; 0x1694 <xTaskGenericCreate+0x40>
    1692:	cc c0       	rjmp	.+408    	; 0x182c <xTaskGenericCreate+0x1d8>
    1694:	c2 01       	movw	r24, r4
    1696:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <pvPortMalloc>
    169a:	98 8f       	std	Y+24, r25	; 0x18
    169c:	8f 8b       	std	Y+23, r24	; 0x17
    169e:	89 2b       	or	r24, r25
    16a0:	09 f0       	breq	.+2      	; 0x16a4 <xTaskGenericCreate+0x50>
    16a2:	c6 c0       	rjmp	.+396    	; 0x1830 <xTaskGenericCreate+0x1dc>
    16a4:	ce 01       	movw	r24, r28
    16a6:	0e 94 1e 02 	call	0x43c	; 0x43c <vPortFree>
    16aa:	d7 c0       	rjmp	.+430    	; 0x185a <xTaskGenericCreate+0x206>
    16ac:	cf 01       	movw	r24, r30
    16ae:	31 91       	ld	r19, Z+
    16b0:	da 01       	movw	r26, r20
    16b2:	3d 93       	st	X+, r19
    16b4:	ad 01       	movw	r20, r26
    16b6:	dc 01       	movw	r26, r24
    16b8:	8c 91       	ld	r24, X
    16ba:	88 23       	and	r24, r24
    16bc:	11 f0       	breq	.+4      	; 0x16c2 <xTaskGenericCreate+0x6e>
    16be:	21 50       	subi	r18, 0x01	; 1
    16c0:	a9 f7       	brne	.-22     	; 0x16ac <xTaskGenericCreate+0x58>
    16c2:	18 a2       	std	Y+32, r1	; 0x20
    16c4:	10 2f       	mov	r17, r16
    16c6:	05 30       	cpi	r16, 0x05	; 5
    16c8:	08 f0       	brcs	.+2      	; 0x16cc <xTaskGenericCreate+0x78>
    16ca:	14 e0       	ldi	r17, 0x04	; 4
    16cc:	1e 8b       	std	Y+22, r17	; 0x16
    16ce:	19 a3       	std	Y+33, r17	; 0x21
    16d0:	1a a2       	std	Y+34, r1	; 0x22
    16d2:	5e 01       	movw	r10, r28
    16d4:	b2 e0       	ldi	r27, 0x02	; 2
    16d6:	ab 0e       	add	r10, r27
    16d8:	b1 1c       	adc	r11, r1
    16da:	c5 01       	movw	r24, r10
    16dc:	0e 94 2d 02 	call	0x45a	; 0x45a <vListInitialiseItem>
    16e0:	ce 01       	movw	r24, r28
    16e2:	0c 96       	adiw	r24, 0x0c	; 12
    16e4:	0e 94 2d 02 	call	0x45a	; 0x45a <vListInitialiseItem>
    16e8:	d9 87       	std	Y+9, r29	; 0x09
    16ea:	c8 87       	std	Y+8, r28	; 0x08
    16ec:	85 e0       	ldi	r24, 0x05	; 5
    16ee:	90 e0       	ldi	r25, 0x00	; 0
    16f0:	81 1b       	sub	r24, r17
    16f2:	91 09       	sbc	r25, r1
    16f4:	9d 87       	std	Y+13, r25	; 0x0d
    16f6:	8c 87       	std	Y+12, r24	; 0x0c
    16f8:	db 8b       	std	Y+19, r29	; 0x13
    16fa:	ca 8b       	std	Y+18, r28	; 0x12
    16fc:	a3 01       	movw	r20, r6
    16fe:	b4 01       	movw	r22, r8
    1700:	c6 01       	movw	r24, r12
    1702:	d4 da       	rcall	.-2648   	; 0xcac <pxPortInitialiseStack>
    1704:	99 83       	std	Y+1, r25	; 0x01
    1706:	88 83       	st	Y, r24
    1708:	e1 14       	cp	r14, r1
    170a:	f1 04       	cpc	r15, r1
    170c:	19 f0       	breq	.+6      	; 0x1714 <xTaskGenericCreate+0xc0>
    170e:	f7 01       	movw	r30, r14
    1710:	d1 83       	std	Z+1, r29	; 0x01
    1712:	c0 83       	st	Z, r28
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
    171a:	80 91 3f 08 	lds	r24, 0x083F
    171e:	8f 5f       	subi	r24, 0xFF	; 255
    1720:	80 93 3f 08 	sts	0x083F, r24
    1724:	80 91 9f 08 	lds	r24, 0x089F
    1728:	90 91 a0 08 	lds	r25, 0x08A0
    172c:	89 2b       	or	r24, r25
    172e:	09 f0       	breq	.+2      	; 0x1732 <xTaskGenericCreate+0xde>
    1730:	3f c0       	rjmp	.+126    	; 0x17b0 <xTaskGenericCreate+0x15c>
    1732:	d0 93 a0 08 	sts	0x08A0, r29
    1736:	c0 93 9f 08 	sts	0x089F, r28
    173a:	80 91 3f 08 	lds	r24, 0x083F
    173e:	81 30       	cpi	r24, 0x01	; 1
    1740:	09 f0       	breq	.+2      	; 0x1744 <xTaskGenericCreate+0xf0>
    1742:	45 c0       	rjmp	.+138    	; 0x17ce <xTaskGenericCreate+0x17a>
    1744:	0f 2e       	mov	r0, r31
    1746:	f2 e7       	ldi	r31, 0x72	; 114
    1748:	ef 2e       	mov	r14, r31
    174a:	f8 e0       	ldi	r31, 0x08	; 8
    174c:	ff 2e       	mov	r15, r31
    174e:	f0 2d       	mov	r31, r0
    1750:	0f 2e       	mov	r0, r31
    1752:	ff e9       	ldi	r31, 0x9F	; 159
    1754:	cf 2e       	mov	r12, r31
    1756:	f8 e0       	ldi	r31, 0x08	; 8
    1758:	df 2e       	mov	r13, r31
    175a:	f0 2d       	mov	r31, r0
    175c:	c7 01       	movw	r24, r14
    175e:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    1762:	f9 e0       	ldi	r31, 0x09	; 9
    1764:	ef 0e       	add	r14, r31
    1766:	f1 1c       	adc	r15, r1
    1768:	ec 14       	cp	r14, r12
    176a:	fd 04       	cpc	r15, r13
    176c:	b9 f7       	brne	.-18     	; 0x175c <xTaskGenericCreate+0x108>
    176e:	89 e6       	ldi	r24, 0x69	; 105
    1770:	98 e0       	ldi	r25, 0x08	; 8
    1772:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    1776:	80 e6       	ldi	r24, 0x60	; 96
    1778:	98 e0       	ldi	r25, 0x08	; 8
    177a:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    177e:	83 e5       	ldi	r24, 0x53	; 83
    1780:	98 e0       	ldi	r25, 0x08	; 8
    1782:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    1786:	8a e4       	ldi	r24, 0x4A	; 74
    1788:	98 e0       	ldi	r25, 0x08	; 8
    178a:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    178e:	80 e4       	ldi	r24, 0x40	; 64
    1790:	98 e0       	ldi	r25, 0x08	; 8
    1792:	0e 94 1f 02 	call	0x43e	; 0x43e <vListInitialise>
    1796:	89 e6       	ldi	r24, 0x69	; 105
    1798:	98 e0       	ldi	r25, 0x08	; 8
    179a:	90 93 5f 08 	sts	0x085F, r25
    179e:	80 93 5e 08 	sts	0x085E, r24
    17a2:	80 e6       	ldi	r24, 0x60	; 96
    17a4:	98 e0       	ldi	r25, 0x08	; 8
    17a6:	90 93 5d 08 	sts	0x085D, r25
    17aa:	80 93 5c 08 	sts	0x085C, r24
    17ae:	0f c0       	rjmp	.+30     	; 0x17ce <xTaskGenericCreate+0x17a>
    17b0:	80 91 3b 08 	lds	r24, 0x083B
    17b4:	81 11       	cpse	r24, r1
    17b6:	0b c0       	rjmp	.+22     	; 0x17ce <xTaskGenericCreate+0x17a>
    17b8:	e0 91 9f 08 	lds	r30, 0x089F
    17bc:	f0 91 a0 08 	lds	r31, 0x08A0
    17c0:	86 89       	ldd	r24, Z+22	; 0x16
    17c2:	08 17       	cp	r16, r24
    17c4:	20 f0       	brcs	.+8      	; 0x17ce <xTaskGenericCreate+0x17a>
    17c6:	d0 93 a0 08 	sts	0x08A0, r29
    17ca:	c0 93 9f 08 	sts	0x089F, r28
    17ce:	80 91 37 08 	lds	r24, 0x0837
    17d2:	8f 5f       	subi	r24, 0xFF	; 255
    17d4:	80 93 37 08 	sts	0x0837, r24
    17d8:	8e 89       	ldd	r24, Y+22	; 0x16
    17da:	90 91 3c 08 	lds	r25, 0x083C
    17de:	98 17       	cp	r25, r24
    17e0:	10 f4       	brcc	.+4      	; 0x17e6 <xTaskGenericCreate+0x192>
    17e2:	80 93 3c 08 	sts	0x083C, r24
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	9c 01       	movw	r18, r24
    17ea:	22 0f       	add	r18, r18
    17ec:	33 1f       	adc	r19, r19
    17ee:	22 0f       	add	r18, r18
    17f0:	33 1f       	adc	r19, r19
    17f2:	22 0f       	add	r18, r18
    17f4:	33 1f       	adc	r19, r19
    17f6:	82 0f       	add	r24, r18
    17f8:	93 1f       	adc	r25, r19
    17fa:	b5 01       	movw	r22, r10
    17fc:	8e 58       	subi	r24, 0x8E	; 142
    17fe:	97 4f       	sbci	r25, 0xF7	; 247
    1800:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	80 91 3b 08 	lds	r24, 0x083B
    180c:	88 23       	and	r24, r24
    180e:	51 f0       	breq	.+20     	; 0x1824 <xTaskGenericCreate+0x1d0>
    1810:	e0 91 9f 08 	lds	r30, 0x089F
    1814:	f0 91 a0 08 	lds	r31, 0x08A0
    1818:	86 89       	ldd	r24, Z+22	; 0x16
    181a:	80 17       	cp	r24, r16
    181c:	28 f4       	brcc	.+10     	; 0x1828 <xTaskGenericCreate+0x1d4>
    181e:	f5 da       	rcall	.-2582   	; 0xe0a <vPortYield>
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	1c c0       	rjmp	.+56     	; 0x185c <xTaskGenericCreate+0x208>
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	1a c0       	rjmp	.+52     	; 0x185c <xTaskGenericCreate+0x208>
    1828:	81 e0       	ldi	r24, 0x01	; 1
    182a:	18 c0       	rjmp	.+48     	; 0x185c <xTaskGenericCreate+0x208>
    182c:	d8 8e       	std	Y+24, r13	; 0x18
    182e:	cf 8a       	std	Y+23, r12	; 0x17
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	48 1a       	sub	r4, r24
    1834:	51 08       	sbc	r5, r1
    1836:	cf 88       	ldd	r12, Y+23	; 0x17
    1838:	d8 8c       	ldd	r13, Y+24	; 0x18
    183a:	c4 0c       	add	r12, r4
    183c:	d5 1c       	adc	r13, r5
    183e:	d5 01       	movw	r26, r10
    1840:	8c 91       	ld	r24, X
    1842:	89 8f       	std	Y+25, r24	; 0x19
    1844:	8c 91       	ld	r24, X
    1846:	88 23       	and	r24, r24
    1848:	09 f4       	brne	.+2      	; 0x184c <xTaskGenericCreate+0x1f8>
    184a:	3b cf       	rjmp	.-394    	; 0x16c2 <xTaskGenericCreate+0x6e>
    184c:	ae 01       	movw	r20, r28
    184e:	46 5e       	subi	r20, 0xE6	; 230
    1850:	5f 4f       	sbci	r21, 0xFF	; 255
    1852:	f5 01       	movw	r30, r10
    1854:	31 96       	adiw	r30, 0x01	; 1
    1856:	27 e0       	ldi	r18, 0x07	; 7
    1858:	29 cf       	rjmp	.-430    	; 0x16ac <xTaskGenericCreate+0x58>
    185a:	8f ef       	ldi	r24, 0xFF	; 255
    185c:	df 91       	pop	r29
    185e:	cf 91       	pop	r28
    1860:	1f 91       	pop	r17
    1862:	0f 91       	pop	r16
    1864:	ff 90       	pop	r15
    1866:	ef 90       	pop	r14
    1868:	df 90       	pop	r13
    186a:	cf 90       	pop	r12
    186c:	bf 90       	pop	r11
    186e:	af 90       	pop	r10
    1870:	9f 90       	pop	r9
    1872:	8f 90       	pop	r8
    1874:	7f 90       	pop	r7
    1876:	6f 90       	pop	r6
    1878:	5f 90       	pop	r5
    187a:	4f 90       	pop	r4
    187c:	08 95       	ret

0000187e <vTaskResume>:
    187e:	0f 93       	push	r16
    1880:	1f 93       	push	r17
    1882:	cf 93       	push	r28
    1884:	df 93       	push	r29
    1886:	ec 01       	movw	r28, r24
    1888:	00 97       	sbiw	r24, 0x00	; 0
    188a:	09 f4       	brne	.+2      	; 0x188e <vTaskResume+0x10>
    188c:	3e c0       	rjmp	.+124    	; 0x190a <vTaskResume+0x8c>
    188e:	80 91 9f 08 	lds	r24, 0x089F
    1892:	90 91 a0 08 	lds	r25, 0x08A0
    1896:	c8 17       	cp	r28, r24
    1898:	d9 07       	cpc	r29, r25
    189a:	b9 f1       	breq	.+110    	; 0x190a <vTaskResume+0x8c>
    189c:	0f b6       	in	r0, 0x3f	; 63
    189e:	f8 94       	cli
    18a0:	0f 92       	push	r0
    18a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    18a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    18a6:	80 54       	subi	r24, 0x40	; 64
    18a8:	98 40       	sbci	r25, 0x08	; 8
    18aa:	69 f5       	brne	.+90     	; 0x1906 <vTaskResume+0x88>
    18ac:	8c 89       	ldd	r24, Y+20	; 0x14
    18ae:	9d 89       	ldd	r25, Y+21	; 0x15
    18b0:	28 e0       	ldi	r18, 0x08	; 8
    18b2:	83 35       	cpi	r24, 0x53	; 83
    18b4:	92 07       	cpc	r25, r18
    18b6:	39 f1       	breq	.+78     	; 0x1906 <vTaskResume+0x88>
    18b8:	89 2b       	or	r24, r25
    18ba:	29 f5       	brne	.+74     	; 0x1906 <vTaskResume+0x88>
    18bc:	8e 01       	movw	r16, r28
    18be:	0e 5f       	subi	r16, 0xFE	; 254
    18c0:	1f 4f       	sbci	r17, 0xFF	; 255
    18c2:	c8 01       	movw	r24, r16
    18c4:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    18c8:	8e 89       	ldd	r24, Y+22	; 0x16
    18ca:	90 91 3c 08 	lds	r25, 0x083C
    18ce:	98 17       	cp	r25, r24
    18d0:	10 f4       	brcc	.+4      	; 0x18d6 <vTaskResume+0x58>
    18d2:	80 93 3c 08 	sts	0x083C, r24
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	9c 01       	movw	r18, r24
    18da:	22 0f       	add	r18, r18
    18dc:	33 1f       	adc	r19, r19
    18de:	22 0f       	add	r18, r18
    18e0:	33 1f       	adc	r19, r19
    18e2:	22 0f       	add	r18, r18
    18e4:	33 1f       	adc	r19, r19
    18e6:	82 0f       	add	r24, r18
    18e8:	93 1f       	adc	r25, r19
    18ea:	b8 01       	movw	r22, r16
    18ec:	8e 58       	subi	r24, 0x8E	; 142
    18ee:	97 4f       	sbci	r25, 0xF7	; 247
    18f0:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    18f4:	e0 91 9f 08 	lds	r30, 0x089F
    18f8:	f0 91 a0 08 	lds	r31, 0x08A0
    18fc:	9e 89       	ldd	r25, Y+22	; 0x16
    18fe:	86 89       	ldd	r24, Z+22	; 0x16
    1900:	98 17       	cp	r25, r24
    1902:	08 f0       	brcs	.+2      	; 0x1906 <vTaskResume+0x88>
    1904:	82 da       	rcall	.-2812   	; 0xe0a <vPortYield>
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63
    190a:	df 91       	pop	r29
    190c:	cf 91       	pop	r28
    190e:	1f 91       	pop	r17
    1910:	0f 91       	pop	r16
    1912:	08 95       	ret

00001914 <vTaskStartScheduler>:
    1914:	af 92       	push	r10
    1916:	bf 92       	push	r11
    1918:	cf 92       	push	r12
    191a:	df 92       	push	r13
    191c:	ef 92       	push	r14
    191e:	ff 92       	push	r15
    1920:	0f 93       	push	r16
    1922:	a1 2c       	mov	r10, r1
    1924:	b1 2c       	mov	r11, r1
    1926:	c1 2c       	mov	r12, r1
    1928:	d1 2c       	mov	r13, r1
    192a:	e1 2c       	mov	r14, r1
    192c:	f1 2c       	mov	r15, r1
    192e:	00 e0       	ldi	r16, 0x00	; 0
    1930:	20 e0       	ldi	r18, 0x00	; 0
    1932:	30 e0       	ldi	r19, 0x00	; 0
    1934:	45 e5       	ldi	r20, 0x55	; 85
    1936:	50 e0       	ldi	r21, 0x00	; 0
    1938:	60 e5       	ldi	r22, 0x50	; 80
    193a:	72 e0       	ldi	r23, 0x02	; 2
    193c:	81 e6       	ldi	r24, 0x61	; 97
    193e:	9e e0       	ldi	r25, 0x0E	; 14
    1940:	89 de       	rcall	.-750    	; 0x1654 <xTaskGenericCreate>
    1942:	81 30       	cpi	r24, 0x01	; 1
    1944:	41 f4       	brne	.+16     	; 0x1956 <vTaskStartScheduler+0x42>
    1946:	f8 94       	cli
    1948:	80 93 3b 08 	sts	0x083B, r24
    194c:	10 92 3e 08 	sts	0x083E, r1
    1950:	10 92 3d 08 	sts	0x083D, r1
    1954:	1d da       	rcall	.-3014   	; 0xd90 <xPortStartScheduler>
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	df 90       	pop	r13
    195e:	cf 90       	pop	r12
    1960:	bf 90       	pop	r11
    1962:	af 90       	pop	r10
    1964:	08 95       	ret

00001966 <vTaskSuspendAll>:
    1966:	80 91 36 08 	lds	r24, 0x0836
    196a:	8f 5f       	subi	r24, 0xFF	; 255
    196c:	80 93 36 08 	sts	0x0836, r24
    1970:	08 95       	ret

00001972 <xTaskGetTickCount>:
    1972:	0f b6       	in	r0, 0x3f	; 63
    1974:	f8 94       	cli
    1976:	0f 92       	push	r0
    1978:	80 91 3d 08 	lds	r24, 0x083D
    197c:	90 91 3e 08 	lds	r25, 0x083E
    1980:	0f 90       	pop	r0
    1982:	0f be       	out	0x3f, r0	; 63
    1984:	08 95       	ret

00001986 <xTaskGetTickCountFromISR>:
    1986:	80 91 3d 08 	lds	r24, 0x083D
    198a:	90 91 3e 08 	lds	r25, 0x083E
    198e:	08 95       	ret

00001990 <xTaskIncrementTick>:
    1990:	cf 92       	push	r12
    1992:	df 92       	push	r13
    1994:	ef 92       	push	r14
    1996:	ff 92       	push	r15
    1998:	0f 93       	push	r16
    199a:	1f 93       	push	r17
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	80 91 36 08 	lds	r24, 0x0836
    19a4:	81 11       	cpse	r24, r1
    19a6:	99 c0       	rjmp	.+306    	; 0x1ada <xTaskIncrementTick+0x14a>
    19a8:	80 91 3d 08 	lds	r24, 0x083D
    19ac:	90 91 3e 08 	lds	r25, 0x083E
    19b0:	01 96       	adiw	r24, 0x01	; 1
    19b2:	90 93 3e 08 	sts	0x083E, r25
    19b6:	80 93 3d 08 	sts	0x083D, r24
    19ba:	e0 90 3d 08 	lds	r14, 0x083D
    19be:	f0 90 3e 08 	lds	r15, 0x083E
    19c2:	e1 14       	cp	r14, r1
    19c4:	f1 04       	cpc	r15, r1
    19c6:	b1 f4       	brne	.+44     	; 0x19f4 <xTaskIncrementTick+0x64>
    19c8:	80 91 5e 08 	lds	r24, 0x085E
    19cc:	90 91 5f 08 	lds	r25, 0x085F
    19d0:	20 91 5c 08 	lds	r18, 0x085C
    19d4:	30 91 5d 08 	lds	r19, 0x085D
    19d8:	30 93 5f 08 	sts	0x085F, r19
    19dc:	20 93 5e 08 	sts	0x085E, r18
    19e0:	90 93 5d 08 	sts	0x085D, r25
    19e4:	80 93 5c 08 	sts	0x085C, r24
    19e8:	80 91 38 08 	lds	r24, 0x0838
    19ec:	8f 5f       	subi	r24, 0xFF	; 255
    19ee:	80 93 38 08 	sts	0x0838, r24
    19f2:	da dd       	rcall	.-1100   	; 0x15a8 <prvResetNextTaskUnblockTime>
    19f4:	80 91 04 02 	lds	r24, 0x0204
    19f8:	90 91 05 02 	lds	r25, 0x0205
    19fc:	e8 16       	cp	r14, r24
    19fe:	f9 06       	cpc	r15, r25
    1a00:	08 f4       	brcc	.+2      	; 0x1a04 <xTaskIncrementTick+0x74>
    1a02:	54 c0       	rjmp	.+168    	; 0x1aac <xTaskIncrementTick+0x11c>
    1a04:	d1 2c       	mov	r13, r1
    1a06:	cc 24       	eor	r12, r12
    1a08:	c3 94       	inc	r12
    1a0a:	01 c0       	rjmp	.+2      	; 0x1a0e <xTaskIncrementTick+0x7e>
    1a0c:	dc 2c       	mov	r13, r12
    1a0e:	e0 91 5e 08 	lds	r30, 0x085E
    1a12:	f0 91 5f 08 	lds	r31, 0x085F
    1a16:	80 81       	ld	r24, Z
    1a18:	81 11       	cpse	r24, r1
    1a1a:	07 c0       	rjmp	.+14     	; 0x1a2a <xTaskIncrementTick+0x9a>
    1a1c:	8f ef       	ldi	r24, 0xFF	; 255
    1a1e:	9f ef       	ldi	r25, 0xFF	; 255
    1a20:	90 93 05 02 	sts	0x0205, r25
    1a24:	80 93 04 02 	sts	0x0204, r24
    1a28:	42 c0       	rjmp	.+132    	; 0x1aae <xTaskIncrementTick+0x11e>
    1a2a:	e0 91 5e 08 	lds	r30, 0x085E
    1a2e:	f0 91 5f 08 	lds	r31, 0x085F
    1a32:	05 80       	ldd	r0, Z+5	; 0x05
    1a34:	f6 81       	ldd	r31, Z+6	; 0x06
    1a36:	e0 2d       	mov	r30, r0
    1a38:	c6 81       	ldd	r28, Z+6	; 0x06
    1a3a:	d7 81       	ldd	r29, Z+7	; 0x07
    1a3c:	2a 81       	ldd	r18, Y+2	; 0x02
    1a3e:	3b 81       	ldd	r19, Y+3	; 0x03
    1a40:	e2 16       	cp	r14, r18
    1a42:	f3 06       	cpc	r15, r19
    1a44:	28 f4       	brcc	.+10     	; 0x1a50 <xTaskIncrementTick+0xc0>
    1a46:	30 93 05 02 	sts	0x0205, r19
    1a4a:	20 93 04 02 	sts	0x0204, r18
    1a4e:	2f c0       	rjmp	.+94     	; 0x1aae <xTaskIncrementTick+0x11e>
    1a50:	8e 01       	movw	r16, r28
    1a52:	0e 5f       	subi	r16, 0xFE	; 254
    1a54:	1f 4f       	sbci	r17, 0xFF	; 255
    1a56:	c8 01       	movw	r24, r16
    1a58:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1a5c:	8c 89       	ldd	r24, Y+20	; 0x14
    1a5e:	9d 89       	ldd	r25, Y+21	; 0x15
    1a60:	89 2b       	or	r24, r25
    1a62:	21 f0       	breq	.+8      	; 0x1a6c <xTaskIncrementTick+0xdc>
    1a64:	ce 01       	movw	r24, r28
    1a66:	0c 96       	adiw	r24, 0x0c	; 12
    1a68:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1a6c:	2e 89       	ldd	r18, Y+22	; 0x16
    1a6e:	80 91 3c 08 	lds	r24, 0x083C
    1a72:	82 17       	cp	r24, r18
    1a74:	10 f4       	brcc	.+4      	; 0x1a7a <xTaskIncrementTick+0xea>
    1a76:	20 93 3c 08 	sts	0x083C, r18
    1a7a:	30 e0       	ldi	r19, 0x00	; 0
    1a7c:	c9 01       	movw	r24, r18
    1a7e:	88 0f       	add	r24, r24
    1a80:	99 1f       	adc	r25, r25
    1a82:	88 0f       	add	r24, r24
    1a84:	99 1f       	adc	r25, r25
    1a86:	88 0f       	add	r24, r24
    1a88:	99 1f       	adc	r25, r25
    1a8a:	82 0f       	add	r24, r18
    1a8c:	93 1f       	adc	r25, r19
    1a8e:	b8 01       	movw	r22, r16
    1a90:	8e 58       	subi	r24, 0x8E	; 142
    1a92:	97 4f       	sbci	r25, 0xF7	; 247
    1a94:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1a98:	e0 91 9f 08 	lds	r30, 0x089F
    1a9c:	f0 91 a0 08 	lds	r31, 0x08A0
    1aa0:	9e 89       	ldd	r25, Y+22	; 0x16
    1aa2:	86 89       	ldd	r24, Z+22	; 0x16
    1aa4:	98 17       	cp	r25, r24
    1aa6:	08 f0       	brcs	.+2      	; 0x1aaa <xTaskIncrementTick+0x11a>
    1aa8:	b1 cf       	rjmp	.-158    	; 0x1a0c <xTaskIncrementTick+0x7c>
    1aaa:	b1 cf       	rjmp	.-158    	; 0x1a0e <xTaskIncrementTick+0x7e>
    1aac:	d1 2c       	mov	r13, r1
    1aae:	e0 91 9f 08 	lds	r30, 0x089F
    1ab2:	f0 91 a0 08 	lds	r31, 0x08A0
    1ab6:	86 89       	ldd	r24, Z+22	; 0x16
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	fc 01       	movw	r30, r24
    1abc:	ee 0f       	add	r30, r30
    1abe:	ff 1f       	adc	r31, r31
    1ac0:	ee 0f       	add	r30, r30
    1ac2:	ff 1f       	adc	r31, r31
    1ac4:	ee 0f       	add	r30, r30
    1ac6:	ff 1f       	adc	r31, r31
    1ac8:	8e 0f       	add	r24, r30
    1aca:	9f 1f       	adc	r25, r31
    1acc:	fc 01       	movw	r30, r24
    1ace:	ee 58       	subi	r30, 0x8E	; 142
    1ad0:	f7 4f       	sbci	r31, 0xF7	; 247
    1ad2:	80 81       	ld	r24, Z
    1ad4:	82 30       	cpi	r24, 0x02	; 2
    1ad6:	40 f4       	brcc	.+16     	; 0x1ae8 <xTaskIncrementTick+0x158>
    1ad8:	09 c0       	rjmp	.+18     	; 0x1aec <xTaskIncrementTick+0x15c>
    1ada:	80 91 3a 08 	lds	r24, 0x083A
    1ade:	8f 5f       	subi	r24, 0xFF	; 255
    1ae0:	80 93 3a 08 	sts	0x083A, r24
    1ae4:	d1 2c       	mov	r13, r1
    1ae6:	02 c0       	rjmp	.+4      	; 0x1aec <xTaskIncrementTick+0x15c>
    1ae8:	dd 24       	eor	r13, r13
    1aea:	d3 94       	inc	r13
    1aec:	80 91 39 08 	lds	r24, 0x0839
    1af0:	88 23       	and	r24, r24
    1af2:	11 f0       	breq	.+4      	; 0x1af8 <xTaskIncrementTick+0x168>
    1af4:	dd 24       	eor	r13, r13
    1af6:	d3 94       	inc	r13
    1af8:	8d 2d       	mov	r24, r13
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	ff 90       	pop	r15
    1b04:	ef 90       	pop	r14
    1b06:	df 90       	pop	r13
    1b08:	cf 90       	pop	r12
    1b0a:	08 95       	ret

00001b0c <xTaskResumeAll>:
    1b0c:	df 92       	push	r13
    1b0e:	ef 92       	push	r14
    1b10:	ff 92       	push	r15
    1b12:	0f 93       	push	r16
    1b14:	1f 93       	push	r17
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	0f b6       	in	r0, 0x3f	; 63
    1b1c:	f8 94       	cli
    1b1e:	0f 92       	push	r0
    1b20:	80 91 36 08 	lds	r24, 0x0836
    1b24:	81 50       	subi	r24, 0x01	; 1
    1b26:	80 93 36 08 	sts	0x0836, r24
    1b2a:	80 91 36 08 	lds	r24, 0x0836
    1b2e:	81 11       	cpse	r24, r1
    1b30:	5f c0       	rjmp	.+190    	; 0x1bf0 <xTaskResumeAll+0xe4>
    1b32:	80 91 3f 08 	lds	r24, 0x083F
    1b36:	88 23       	and	r24, r24
    1b38:	09 f4       	brne	.+2      	; 0x1b3c <xTaskResumeAll+0x30>
    1b3a:	5c c0       	rjmp	.+184    	; 0x1bf4 <xTaskResumeAll+0xe8>
    1b3c:	0f 2e       	mov	r0, r31
    1b3e:	f3 e5       	ldi	r31, 0x53	; 83
    1b40:	ef 2e       	mov	r14, r31
    1b42:	f8 e0       	ldi	r31, 0x08	; 8
    1b44:	ff 2e       	mov	r15, r31
    1b46:	f0 2d       	mov	r31, r0
    1b48:	dd 24       	eor	r13, r13
    1b4a:	d3 94       	inc	r13
    1b4c:	30 c0       	rjmp	.+96     	; 0x1bae <xTaskResumeAll+0xa2>
    1b4e:	e0 91 58 08 	lds	r30, 0x0858
    1b52:	f0 91 59 08 	lds	r31, 0x0859
    1b56:	c6 81       	ldd	r28, Z+6	; 0x06
    1b58:	d7 81       	ldd	r29, Z+7	; 0x07
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	0c 96       	adiw	r24, 0x0c	; 12
    1b5e:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1b62:	8e 01       	movw	r16, r28
    1b64:	0e 5f       	subi	r16, 0xFE	; 254
    1b66:	1f 4f       	sbci	r17, 0xFF	; 255
    1b68:	c8 01       	movw	r24, r16
    1b6a:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1b6e:	8e 89       	ldd	r24, Y+22	; 0x16
    1b70:	90 91 3c 08 	lds	r25, 0x083C
    1b74:	98 17       	cp	r25, r24
    1b76:	10 f4       	brcc	.+4      	; 0x1b7c <xTaskResumeAll+0x70>
    1b78:	80 93 3c 08 	sts	0x083C, r24
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	9c 01       	movw	r18, r24
    1b80:	22 0f       	add	r18, r18
    1b82:	33 1f       	adc	r19, r19
    1b84:	22 0f       	add	r18, r18
    1b86:	33 1f       	adc	r19, r19
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	82 0f       	add	r24, r18
    1b8e:	93 1f       	adc	r25, r19
    1b90:	b8 01       	movw	r22, r16
    1b92:	8e 58       	subi	r24, 0x8E	; 142
    1b94:	97 4f       	sbci	r25, 0xF7	; 247
    1b96:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1b9a:	e0 91 9f 08 	lds	r30, 0x089F
    1b9e:	f0 91 a0 08 	lds	r31, 0x08A0
    1ba2:	9e 89       	ldd	r25, Y+22	; 0x16
    1ba4:	86 89       	ldd	r24, Z+22	; 0x16
    1ba6:	98 17       	cp	r25, r24
    1ba8:	10 f0       	brcs	.+4      	; 0x1bae <xTaskResumeAll+0xa2>
    1baa:	d0 92 39 08 	sts	0x0839, r13
    1bae:	f7 01       	movw	r30, r14
    1bb0:	80 81       	ld	r24, Z
    1bb2:	81 11       	cpse	r24, r1
    1bb4:	cc cf       	rjmp	.-104    	; 0x1b4e <xTaskResumeAll+0x42>
    1bb6:	80 91 3a 08 	lds	r24, 0x083A
    1bba:	88 23       	and	r24, r24
    1bbc:	91 f0       	breq	.+36     	; 0x1be2 <xTaskResumeAll+0xd6>
    1bbe:	80 91 3a 08 	lds	r24, 0x083A
    1bc2:	88 23       	and	r24, r24
    1bc4:	71 f0       	breq	.+28     	; 0x1be2 <xTaskResumeAll+0xd6>
    1bc6:	c1 e0       	ldi	r28, 0x01	; 1
    1bc8:	e3 de       	rcall	.-570    	; 0x1990 <xTaskIncrementTick>
    1bca:	81 11       	cpse	r24, r1
    1bcc:	c0 93 39 08 	sts	0x0839, r28
    1bd0:	80 91 3a 08 	lds	r24, 0x083A
    1bd4:	81 50       	subi	r24, 0x01	; 1
    1bd6:	80 93 3a 08 	sts	0x083A, r24
    1bda:	80 91 3a 08 	lds	r24, 0x083A
    1bde:	81 11       	cpse	r24, r1
    1be0:	f3 cf       	rjmp	.-26     	; 0x1bc8 <xTaskResumeAll+0xbc>
    1be2:	80 91 39 08 	lds	r24, 0x0839
    1be6:	81 30       	cpi	r24, 0x01	; 1
    1be8:	39 f4       	brne	.+14     	; 0x1bf8 <xTaskResumeAll+0xec>
    1bea:	0f d9       	rcall	.-3554   	; 0xe0a <vPortYield>
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	05 c0       	rjmp	.+10     	; 0x1bfa <xTaskResumeAll+0xee>
    1bf0:	80 e0       	ldi	r24, 0x00	; 0
    1bf2:	03 c0       	rjmp	.+6      	; 0x1bfa <xTaskResumeAll+0xee>
    1bf4:	80 e0       	ldi	r24, 0x00	; 0
    1bf6:	01 c0       	rjmp	.+2      	; 0x1bfa <xTaskResumeAll+0xee>
    1bf8:	80 e0       	ldi	r24, 0x00	; 0
    1bfa:	0f 90       	pop	r0
    1bfc:	0f be       	out	0x3f, r0	; 63
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	ff 90       	pop	r15
    1c08:	ef 90       	pop	r14
    1c0a:	df 90       	pop	r13
    1c0c:	08 95       	ret

00001c0e <vTaskDelayUntil>:
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	8c 01       	movw	r16, r24
    1c18:	eb 01       	movw	r28, r22
    1c1a:	a5 de       	rcall	.-694    	; 0x1966 <vTaskSuspendAll>
    1c1c:	80 91 3d 08 	lds	r24, 0x083D
    1c20:	90 91 3e 08 	lds	r25, 0x083E
    1c24:	f8 01       	movw	r30, r16
    1c26:	20 81       	ld	r18, Z
    1c28:	31 81       	ldd	r19, Z+1	; 0x01
    1c2a:	c2 0f       	add	r28, r18
    1c2c:	d3 1f       	adc	r29, r19
    1c2e:	82 17       	cp	r24, r18
    1c30:	93 07       	cpc	r25, r19
    1c32:	48 f4       	brcc	.+18     	; 0x1c46 <vTaskDelayUntil+0x38>
    1c34:	c2 17       	cp	r28, r18
    1c36:	d3 07       	cpc	r29, r19
    1c38:	f8 f4       	brcc	.+62     	; 0x1c78 <vTaskDelayUntil+0x6a>
    1c3a:	d1 83       	std	Z+1, r29	; 0x01
    1c3c:	c0 83       	st	Z, r28
    1c3e:	8c 17       	cp	r24, r28
    1c40:	9d 07       	cpc	r25, r29
    1c42:	88 f4       	brcc	.+34     	; 0x1c66 <vTaskDelayUntil+0x58>
    1c44:	07 c0       	rjmp	.+14     	; 0x1c54 <vTaskDelayUntil+0x46>
    1c46:	c2 17       	cp	r28, r18
    1c48:	d3 07       	cpc	r29, r19
    1c4a:	90 f0       	brcs	.+36     	; 0x1c70 <vTaskDelayUntil+0x62>
    1c4c:	8c 17       	cp	r24, r28
    1c4e:	9d 07       	cpc	r25, r29
    1c50:	78 f0       	brcs	.+30     	; 0x1c70 <vTaskDelayUntil+0x62>
    1c52:	12 c0       	rjmp	.+36     	; 0x1c78 <vTaskDelayUntil+0x6a>
    1c54:	80 91 9f 08 	lds	r24, 0x089F
    1c58:	90 91 a0 08 	lds	r25, 0x08A0
    1c5c:	02 96       	adiw	r24, 0x02	; 2
    1c5e:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1c62:	ce 01       	movw	r24, r28
    1c64:	c0 dc       	rcall	.-1664   	; 0x15e6 <prvAddCurrentTaskToDelayedList>
    1c66:	52 df       	rcall	.-348    	; 0x1b0c <xTaskResumeAll>
    1c68:	81 11       	cpse	r24, r1
    1c6a:	0a c0       	rjmp	.+20     	; 0x1c80 <vTaskDelayUntil+0x72>
    1c6c:	ce d8       	rcall	.-3684   	; 0xe0a <vPortYield>
    1c6e:	08 c0       	rjmp	.+16     	; 0x1c80 <vTaskDelayUntil+0x72>
    1c70:	f8 01       	movw	r30, r16
    1c72:	d1 83       	std	Z+1, r29	; 0x01
    1c74:	c0 83       	st	Z, r28
    1c76:	ee cf       	rjmp	.-36     	; 0x1c54 <vTaskDelayUntil+0x46>
    1c78:	f8 01       	movw	r30, r16
    1c7a:	d1 83       	std	Z+1, r29	; 0x01
    1c7c:	c0 83       	st	Z, r28
    1c7e:	f3 cf       	rjmp	.-26     	; 0x1c66 <vTaskDelayUntil+0x58>
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	1f 91       	pop	r17
    1c86:	0f 91       	pop	r16
    1c88:	08 95       	ret

00001c8a <vTaskDelay>:
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
    1c8e:	ec 01       	movw	r28, r24
    1c90:	00 97       	sbiw	r24, 0x00	; 0
    1c92:	99 f0       	breq	.+38     	; 0x1cba <vTaskDelay+0x30>
    1c94:	68 de       	rcall	.-816    	; 0x1966 <vTaskSuspendAll>
    1c96:	80 91 3d 08 	lds	r24, 0x083D
    1c9a:	90 91 3e 08 	lds	r25, 0x083E
    1c9e:	c8 0f       	add	r28, r24
    1ca0:	d9 1f       	adc	r29, r25
    1ca2:	80 91 9f 08 	lds	r24, 0x089F
    1ca6:	90 91 a0 08 	lds	r25, 0x08A0
    1caa:	02 96       	adiw	r24, 0x02	; 2
    1cac:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	99 dc       	rcall	.-1742   	; 0x15e6 <prvAddCurrentTaskToDelayedList>
    1cb4:	2b df       	rcall	.-426    	; 0x1b0c <xTaskResumeAll>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	01 c0       	rjmp	.+2      	; 0x1cbc <vTaskDelay+0x32>
    1cba:	a7 d8       	rcall	.-3762   	; 0xe0a <vPortYield>
    1cbc:	df 91       	pop	r29
    1cbe:	cf 91       	pop	r28
    1cc0:	08 95       	ret

00001cc2 <prvIdleTask>:
    1cc2:	0f 2e       	mov	r0, r31
    1cc4:	f2 e7       	ldi	r31, 0x72	; 114
    1cc6:	ef 2e       	mov	r14, r31
    1cc8:	f8 e0       	ldi	r31, 0x08	; 8
    1cca:	ff 2e       	mov	r15, r31
    1ccc:	f0 2d       	mov	r31, r0
    1cce:	ca e4       	ldi	r28, 0x4A	; 74
    1cd0:	d8 e0       	ldi	r29, 0x08	; 8
    1cd2:	26 c0       	rjmp	.+76     	; 0x1d20 <prvIdleTask+0x5e>
    1cd4:	48 de       	rcall	.-880    	; 0x1966 <vTaskSuspendAll>
    1cd6:	18 81       	ld	r17, Y
    1cd8:	19 df       	rcall	.-462    	; 0x1b0c <xTaskResumeAll>
    1cda:	11 23       	and	r17, r17
    1cdc:	09 f1       	breq	.+66     	; 0x1d20 <prvIdleTask+0x5e>
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	0f 92       	push	r0
    1ce4:	e0 91 4f 08 	lds	r30, 0x084F
    1ce8:	f0 91 50 08 	lds	r31, 0x0850
    1cec:	06 81       	ldd	r16, Z+6	; 0x06
    1cee:	17 81       	ldd	r17, Z+7	; 0x07
    1cf0:	c8 01       	movw	r24, r16
    1cf2:	02 96       	adiw	r24, 0x02	; 2
    1cf4:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1cf8:	80 91 3f 08 	lds	r24, 0x083F
    1cfc:	81 50       	subi	r24, 0x01	; 1
    1cfe:	80 93 3f 08 	sts	0x083F, r24
    1d02:	80 91 49 08 	lds	r24, 0x0849
    1d06:	81 50       	subi	r24, 0x01	; 1
    1d08:	80 93 49 08 	sts	0x0849, r24
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	f8 01       	movw	r30, r16
    1d12:	87 89       	ldd	r24, Z+23	; 0x17
    1d14:	90 8d       	ldd	r25, Z+24	; 0x18
    1d16:	0e 94 1e 02 	call	0x43c	; 0x43c <vPortFree>
    1d1a:	c8 01       	movw	r24, r16
    1d1c:	0e 94 1e 02 	call	0x43c	; 0x43c <vPortFree>
    1d20:	80 91 49 08 	lds	r24, 0x0849
    1d24:	81 11       	cpse	r24, r1
    1d26:	d6 cf       	rjmp	.-84     	; 0x1cd4 <prvIdleTask+0x12>
    1d28:	f7 01       	movw	r30, r14
    1d2a:	80 81       	ld	r24, Z
    1d2c:	82 30       	cpi	r24, 0x02	; 2
    1d2e:	c0 f3       	brcs	.-16     	; 0x1d20 <prvIdleTask+0x5e>
    1d30:	6c d8       	rcall	.-3880   	; 0xe0a <vPortYield>
    1d32:	f6 cf       	rjmp	.-20     	; 0x1d20 <prvIdleTask+0x5e>

00001d34 <vTaskSwitchContext>:
    1d34:	80 91 36 08 	lds	r24, 0x0836
    1d38:	88 23       	and	r24, r24
    1d3a:	21 f0       	breq	.+8      	; 0x1d44 <vTaskSwitchContext+0x10>
    1d3c:	81 e0       	ldi	r24, 0x01	; 1
    1d3e:	80 93 39 08 	sts	0x0839, r24
    1d42:	08 95       	ret
    1d44:	10 92 39 08 	sts	0x0839, r1
    1d48:	80 91 3c 08 	lds	r24, 0x083C
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	fc 01       	movw	r30, r24
    1d50:	ee 0f       	add	r30, r30
    1d52:	ff 1f       	adc	r31, r31
    1d54:	ee 0f       	add	r30, r30
    1d56:	ff 1f       	adc	r31, r31
    1d58:	ee 0f       	add	r30, r30
    1d5a:	ff 1f       	adc	r31, r31
    1d5c:	8e 0f       	add	r24, r30
    1d5e:	9f 1f       	adc	r25, r31
    1d60:	fc 01       	movw	r30, r24
    1d62:	ee 58       	subi	r30, 0x8E	; 142
    1d64:	f7 4f       	sbci	r31, 0xF7	; 247
    1d66:	80 81       	ld	r24, Z
    1d68:	81 11       	cpse	r24, r1
    1d6a:	17 c0       	rjmp	.+46     	; 0x1d9a <vTaskSwitchContext+0x66>
    1d6c:	80 91 3c 08 	lds	r24, 0x083C
    1d70:	81 50       	subi	r24, 0x01	; 1
    1d72:	80 93 3c 08 	sts	0x083C, r24
    1d76:	80 91 3c 08 	lds	r24, 0x083C
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	fc 01       	movw	r30, r24
    1d7e:	ee 0f       	add	r30, r30
    1d80:	ff 1f       	adc	r31, r31
    1d82:	ee 0f       	add	r30, r30
    1d84:	ff 1f       	adc	r31, r31
    1d86:	ee 0f       	add	r30, r30
    1d88:	ff 1f       	adc	r31, r31
    1d8a:	8e 0f       	add	r24, r30
    1d8c:	9f 1f       	adc	r25, r31
    1d8e:	fc 01       	movw	r30, r24
    1d90:	ee 58       	subi	r30, 0x8E	; 142
    1d92:	f7 4f       	sbci	r31, 0xF7	; 247
    1d94:	80 81       	ld	r24, Z
    1d96:	88 23       	and	r24, r24
    1d98:	49 f3       	breq	.-46     	; 0x1d6c <vTaskSwitchContext+0x38>
    1d9a:	e0 91 3c 08 	lds	r30, 0x083C
    1d9e:	f0 e0       	ldi	r31, 0x00	; 0
    1da0:	cf 01       	movw	r24, r30
    1da2:	88 0f       	add	r24, r24
    1da4:	99 1f       	adc	r25, r25
    1da6:	88 0f       	add	r24, r24
    1da8:	99 1f       	adc	r25, r25
    1daa:	88 0f       	add	r24, r24
    1dac:	99 1f       	adc	r25, r25
    1dae:	e8 0f       	add	r30, r24
    1db0:	f9 1f       	adc	r31, r25
    1db2:	ee 58       	subi	r30, 0x8E	; 142
    1db4:	f7 4f       	sbci	r31, 0xF7	; 247
    1db6:	a1 81       	ldd	r26, Z+1	; 0x01
    1db8:	b2 81       	ldd	r27, Z+2	; 0x02
    1dba:	12 96       	adiw	r26, 0x02	; 2
    1dbc:	0d 90       	ld	r0, X+
    1dbe:	bc 91       	ld	r27, X
    1dc0:	a0 2d       	mov	r26, r0
    1dc2:	b2 83       	std	Z+2, r27	; 0x02
    1dc4:	a1 83       	std	Z+1, r26	; 0x01
    1dc6:	cf 01       	movw	r24, r30
    1dc8:	03 96       	adiw	r24, 0x03	; 3
    1dca:	a8 17       	cp	r26, r24
    1dcc:	b9 07       	cpc	r27, r25
    1dce:	31 f4       	brne	.+12     	; 0x1ddc <vTaskSwitchContext+0xa8>
    1dd0:	12 96       	adiw	r26, 0x02	; 2
    1dd2:	8d 91       	ld	r24, X+
    1dd4:	9c 91       	ld	r25, X
    1dd6:	13 97       	sbiw	r26, 0x03	; 3
    1dd8:	92 83       	std	Z+2, r25	; 0x02
    1dda:	81 83       	std	Z+1, r24	; 0x01
    1ddc:	01 80       	ldd	r0, Z+1	; 0x01
    1dde:	f2 81       	ldd	r31, Z+2	; 0x02
    1de0:	e0 2d       	mov	r30, r0
    1de2:	86 81       	ldd	r24, Z+6	; 0x06
    1de4:	97 81       	ldd	r25, Z+7	; 0x07
    1de6:	90 93 a0 08 	sts	0x08A0, r25
    1dea:	80 93 9f 08 	sts	0x089F, r24
    1dee:	08 95       	ret

00001df0 <vTaskSuspend>:
    1df0:	0f 93       	push	r16
    1df2:	1f 93       	push	r17
    1df4:	cf 93       	push	r28
    1df6:	df 93       	push	r29
    1df8:	ec 01       	movw	r28, r24
    1dfa:	0f b6       	in	r0, 0x3f	; 63
    1dfc:	f8 94       	cli
    1dfe:	0f 92       	push	r0
    1e00:	00 97       	sbiw	r24, 0x00	; 0
    1e02:	21 f4       	brne	.+8      	; 0x1e0c <vTaskSuspend+0x1c>
    1e04:	c0 91 9f 08 	lds	r28, 0x089F
    1e08:	d0 91 a0 08 	lds	r29, 0x08A0
    1e0c:	8e 01       	movw	r16, r28
    1e0e:	0e 5f       	subi	r16, 0xFE	; 254
    1e10:	1f 4f       	sbci	r17, 0xFF	; 255
    1e12:	c8 01       	movw	r24, r16
    1e14:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1e18:	8c 89       	ldd	r24, Y+20	; 0x14
    1e1a:	9d 89       	ldd	r25, Y+21	; 0x15
    1e1c:	89 2b       	or	r24, r25
    1e1e:	21 f0       	breq	.+8      	; 0x1e28 <vTaskSuspend+0x38>
    1e20:	ce 01       	movw	r24, r28
    1e22:	0c 96       	adiw	r24, 0x0c	; 12
    1e24:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1e28:	b8 01       	movw	r22, r16
    1e2a:	80 e4       	ldi	r24, 0x40	; 64
    1e2c:	98 e0       	ldi	r25, 0x08	; 8
    1e2e:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1e32:	0f 90       	pop	r0
    1e34:	0f be       	out	0x3f, r0	; 63
    1e36:	80 91 9f 08 	lds	r24, 0x089F
    1e3a:	90 91 a0 08 	lds	r25, 0x08A0
    1e3e:	c8 17       	cp	r28, r24
    1e40:	d9 07       	cpc	r29, r25
    1e42:	a1 f4       	brne	.+40     	; 0x1e6c <vTaskSuspend+0x7c>
    1e44:	80 91 3b 08 	lds	r24, 0x083B
    1e48:	88 23       	and	r24, r24
    1e4a:	19 f0       	breq	.+6      	; 0x1e52 <vTaskSuspend+0x62>
    1e4c:	0e 94 05 07 	call	0xe0a	; 0xe0a <vPortYield>
    1e50:	17 c0       	rjmp	.+46     	; 0x1e80 <vTaskSuspend+0x90>
    1e52:	80 91 3f 08 	lds	r24, 0x083F
    1e56:	90 91 40 08 	lds	r25, 0x0840
    1e5a:	98 13       	cpse	r25, r24
    1e5c:	05 c0       	rjmp	.+10     	; 0x1e68 <vTaskSuspend+0x78>
    1e5e:	10 92 a0 08 	sts	0x08A0, r1
    1e62:	10 92 9f 08 	sts	0x089F, r1
    1e66:	0c c0       	rjmp	.+24     	; 0x1e80 <vTaskSuspend+0x90>
    1e68:	65 df       	rcall	.-310    	; 0x1d34 <vTaskSwitchContext>
    1e6a:	0a c0       	rjmp	.+20     	; 0x1e80 <vTaskSuspend+0x90>
    1e6c:	80 91 3b 08 	lds	r24, 0x083B
    1e70:	88 23       	and	r24, r24
    1e72:	31 f0       	breq	.+12     	; 0x1e80 <vTaskSuspend+0x90>
    1e74:	0f b6       	in	r0, 0x3f	; 63
    1e76:	f8 94       	cli
    1e78:	0f 92       	push	r0
    1e7a:	96 db       	rcall	.-2260   	; 0x15a8 <prvResetNextTaskUnblockTime>
    1e7c:	0f 90       	pop	r0
    1e7e:	0f be       	out	0x3f, r0	; 63
    1e80:	df 91       	pop	r29
    1e82:	cf 91       	pop	r28
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	08 95       	ret

00001e8a <vTaskPlaceOnEventList>:
    1e8a:	cf 93       	push	r28
    1e8c:	df 93       	push	r29
    1e8e:	eb 01       	movw	r28, r22
    1e90:	60 91 9f 08 	lds	r22, 0x089F
    1e94:	70 91 a0 08 	lds	r23, 0x08A0
    1e98:	64 5f       	subi	r22, 0xF4	; 244
    1e9a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vListInsert>
    1ea0:	80 91 9f 08 	lds	r24, 0x089F
    1ea4:	90 91 a0 08 	lds	r25, 0x08A0
    1ea8:	02 96       	adiw	r24, 0x02	; 2
    1eaa:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1eae:	cf 3f       	cpi	r28, 0xFF	; 255
    1eb0:	8f ef       	ldi	r24, 0xFF	; 255
    1eb2:	d8 07       	cpc	r29, r24
    1eb4:	59 f4       	brne	.+22     	; 0x1ecc <vTaskPlaceOnEventList+0x42>
    1eb6:	60 91 9f 08 	lds	r22, 0x089F
    1eba:	70 91 a0 08 	lds	r23, 0x08A0
    1ebe:	6e 5f       	subi	r22, 0xFE	; 254
    1ec0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec2:	80 e4       	ldi	r24, 0x40	; 64
    1ec4:	98 e0       	ldi	r25, 0x08	; 8
    1ec6:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1eca:	07 c0       	rjmp	.+14     	; 0x1eda <vTaskPlaceOnEventList+0x50>
    1ecc:	80 91 3d 08 	lds	r24, 0x083D
    1ed0:	90 91 3e 08 	lds	r25, 0x083E
    1ed4:	8c 0f       	add	r24, r28
    1ed6:	9d 1f       	adc	r25, r29
    1ed8:	86 db       	rcall	.-2292   	; 0x15e6 <prvAddCurrentTaskToDelayedList>
    1eda:	df 91       	pop	r29
    1edc:	cf 91       	pop	r28
    1ede:	08 95       	ret

00001ee0 <xTaskRemoveFromEventList>:
    1ee0:	0f 93       	push	r16
    1ee2:	1f 93       	push	r17
    1ee4:	cf 93       	push	r28
    1ee6:	df 93       	push	r29
    1ee8:	dc 01       	movw	r26, r24
    1eea:	15 96       	adiw	r26, 0x05	; 5
    1eec:	ed 91       	ld	r30, X+
    1eee:	fc 91       	ld	r31, X
    1ef0:	16 97       	sbiw	r26, 0x06	; 6
    1ef2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ef4:	d7 81       	ldd	r29, Z+7	; 0x07
    1ef6:	8e 01       	movw	r16, r28
    1ef8:	04 5f       	subi	r16, 0xF4	; 244
    1efa:	1f 4f       	sbci	r17, 0xFF	; 255
    1efc:	c8 01       	movw	r24, r16
    1efe:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1f02:	80 91 36 08 	lds	r24, 0x0836
    1f06:	81 11       	cpse	r24, r1
    1f08:	1c c0       	rjmp	.+56     	; 0x1f42 <xTaskRemoveFromEventList+0x62>
    1f0a:	0a 50       	subi	r16, 0x0A	; 10
    1f0c:	11 09       	sbc	r17, r1
    1f0e:	c8 01       	movw	r24, r16
    1f10:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    1f14:	8e 89       	ldd	r24, Y+22	; 0x16
    1f16:	90 91 3c 08 	lds	r25, 0x083C
    1f1a:	98 17       	cp	r25, r24
    1f1c:	10 f4       	brcc	.+4      	; 0x1f22 <xTaskRemoveFromEventList+0x42>
    1f1e:	80 93 3c 08 	sts	0x083C, r24
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	9c 01       	movw	r18, r24
    1f26:	22 0f       	add	r18, r18
    1f28:	33 1f       	adc	r19, r19
    1f2a:	22 0f       	add	r18, r18
    1f2c:	33 1f       	adc	r19, r19
    1f2e:	22 0f       	add	r18, r18
    1f30:	33 1f       	adc	r19, r19
    1f32:	82 0f       	add	r24, r18
    1f34:	93 1f       	adc	r25, r19
    1f36:	b8 01       	movw	r22, r16
    1f38:	8e 58       	subi	r24, 0x8E	; 142
    1f3a:	97 4f       	sbci	r25, 0xF7	; 247
    1f3c:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1f40:	05 c0       	rjmp	.+10     	; 0x1f4c <xTaskRemoveFromEventList+0x6c>
    1f42:	b8 01       	movw	r22, r16
    1f44:	83 e5       	ldi	r24, 0x53	; 83
    1f46:	98 e0       	ldi	r25, 0x08	; 8
    1f48:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    1f4c:	e0 91 9f 08 	lds	r30, 0x089F
    1f50:	f0 91 a0 08 	lds	r31, 0x08A0
    1f54:	9e 89       	ldd	r25, Y+22	; 0x16
    1f56:	86 89       	ldd	r24, Z+22	; 0x16
    1f58:	89 17       	cp	r24, r25
    1f5a:	20 f4       	brcc	.+8      	; 0x1f64 <xTaskRemoveFromEventList+0x84>
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	80 93 39 08 	sts	0x0839, r24
    1f62:	01 c0       	rjmp	.+2      	; 0x1f66 <xTaskRemoveFromEventList+0x86>
    1f64:	80 e0       	ldi	r24, 0x00	; 0
    1f66:	df 91       	pop	r29
    1f68:	cf 91       	pop	r28
    1f6a:	1f 91       	pop	r17
    1f6c:	0f 91       	pop	r16
    1f6e:	08 95       	ret

00001f70 <vTaskSetTimeOutState>:
    1f70:	20 91 38 08 	lds	r18, 0x0838
    1f74:	fc 01       	movw	r30, r24
    1f76:	20 83       	st	Z, r18
    1f78:	20 91 3d 08 	lds	r18, 0x083D
    1f7c:	30 91 3e 08 	lds	r19, 0x083E
    1f80:	32 83       	std	Z+2, r19	; 0x02
    1f82:	21 83       	std	Z+1, r18	; 0x01
    1f84:	08 95       	ret

00001f86 <xTaskCheckForTimeOut>:
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	0f 92       	push	r0
    1f8c:	40 91 3d 08 	lds	r20, 0x083D
    1f90:	50 91 3e 08 	lds	r21, 0x083E
    1f94:	db 01       	movw	r26, r22
    1f96:	2d 91       	ld	r18, X+
    1f98:	3c 91       	ld	r19, X
    1f9a:	2f 3f       	cpi	r18, 0xFF	; 255
    1f9c:	bf ef       	ldi	r27, 0xFF	; 255
    1f9e:	3b 07       	cpc	r19, r27
    1fa0:	11 f1       	breq	.+68     	; 0x1fe6 <xTaskCheckForTimeOut+0x60>
    1fa2:	e0 91 38 08 	lds	r30, 0x0838
    1fa6:	dc 01       	movw	r26, r24
    1fa8:	fc 91       	ld	r31, X
    1faa:	fe 17       	cp	r31, r30
    1fac:	39 f0       	breq	.+14     	; 0x1fbc <xTaskCheckForTimeOut+0x36>
    1fae:	11 96       	adiw	r26, 0x01	; 1
    1fb0:	ed 91       	ld	r30, X+
    1fb2:	fc 91       	ld	r31, X
    1fb4:	12 97       	sbiw	r26, 0x02	; 2
    1fb6:	4e 17       	cp	r20, r30
    1fb8:	5f 07       	cpc	r21, r31
    1fba:	b8 f4       	brcc	.+46     	; 0x1fea <xTaskCheckForTimeOut+0x64>
    1fbc:	dc 01       	movw	r26, r24
    1fbe:	11 96       	adiw	r26, 0x01	; 1
    1fc0:	ed 91       	ld	r30, X+
    1fc2:	fc 91       	ld	r31, X
    1fc4:	12 97       	sbiw	r26, 0x02	; 2
    1fc6:	da 01       	movw	r26, r20
    1fc8:	ae 1b       	sub	r26, r30
    1fca:	bf 0b       	sbc	r27, r31
    1fcc:	a2 17       	cp	r26, r18
    1fce:	b3 07       	cpc	r27, r19
    1fd0:	70 f4       	brcc	.+28     	; 0x1fee <xTaskCheckForTimeOut+0x68>
    1fd2:	e4 1b       	sub	r30, r20
    1fd4:	f5 0b       	sbc	r31, r21
    1fd6:	2e 0f       	add	r18, r30
    1fd8:	3f 1f       	adc	r19, r31
    1fda:	fb 01       	movw	r30, r22
    1fdc:	31 83       	std	Z+1, r19	; 0x01
    1fde:	20 83       	st	Z, r18
    1fe0:	c7 df       	rcall	.-114    	; 0x1f70 <vTaskSetTimeOutState>
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	05 c0       	rjmp	.+10     	; 0x1ff0 <xTaskCheckForTimeOut+0x6a>
    1fe6:	80 e0       	ldi	r24, 0x00	; 0
    1fe8:	03 c0       	rjmp	.+6      	; 0x1ff0 <xTaskCheckForTimeOut+0x6a>
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	01 c0       	rjmp	.+2      	; 0x1ff0 <xTaskCheckForTimeOut+0x6a>
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63
    1ff4:	08 95       	ret

00001ff6 <vTaskMissedYield>:
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	80 93 39 08 	sts	0x0839, r24
    1ffc:	08 95       	ret

00001ffe <vTaskPriorityInherit>:
    1ffe:	0f 93       	push	r16
    2000:	1f 93       	push	r17
    2002:	cf 93       	push	r28
    2004:	df 93       	push	r29
    2006:	ec 01       	movw	r28, r24
    2008:	00 97       	sbiw	r24, 0x00	; 0
    200a:	09 f4       	brne	.+2      	; 0x200e <vTaskPriorityInherit+0x10>
    200c:	51 c0       	rjmp	.+162    	; 0x20b0 <vTaskPriorityInherit+0xb2>
    200e:	8e 89       	ldd	r24, Y+22	; 0x16
    2010:	e0 91 9f 08 	lds	r30, 0x089F
    2014:	f0 91 a0 08 	lds	r31, 0x08A0
    2018:	96 89       	ldd	r25, Z+22	; 0x16
    201a:	89 17       	cp	r24, r25
    201c:	08 f0       	brcs	.+2      	; 0x2020 <vTaskPriorityInherit+0x22>
    201e:	48 c0       	rjmp	.+144    	; 0x20b0 <vTaskPriorityInherit+0xb2>
    2020:	2c 85       	ldd	r18, Y+12	; 0x0c
    2022:	3d 85       	ldd	r19, Y+13	; 0x0d
    2024:	33 23       	and	r19, r19
    2026:	5c f0       	brlt	.+22     	; 0x203e <vTaskPriorityInherit+0x40>
    2028:	e0 91 9f 08 	lds	r30, 0x089F
    202c:	f0 91 a0 08 	lds	r31, 0x08A0
    2030:	96 89       	ldd	r25, Z+22	; 0x16
    2032:	25 e0       	ldi	r18, 0x05	; 5
    2034:	30 e0       	ldi	r19, 0x00	; 0
    2036:	29 1b       	sub	r18, r25
    2038:	31 09       	sbc	r19, r1
    203a:	3d 87       	std	Y+13, r19	; 0x0d
    203c:	2c 87       	std	Y+12, r18	; 0x0c
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	9c 01       	movw	r18, r24
    2042:	22 0f       	add	r18, r18
    2044:	33 1f       	adc	r19, r19
    2046:	22 0f       	add	r18, r18
    2048:	33 1f       	adc	r19, r19
    204a:	22 0f       	add	r18, r18
    204c:	33 1f       	adc	r19, r19
    204e:	82 0f       	add	r24, r18
    2050:	93 1f       	adc	r25, r19
    2052:	8e 58       	subi	r24, 0x8E	; 142
    2054:	97 4f       	sbci	r25, 0xF7	; 247
    2056:	2a 85       	ldd	r18, Y+10	; 0x0a
    2058:	3b 85       	ldd	r19, Y+11	; 0x0b
    205a:	28 17       	cp	r18, r24
    205c:	39 07       	cpc	r19, r25
    205e:	11 f5       	brne	.+68     	; 0x20a4 <vTaskPriorityInherit+0xa6>
    2060:	8e 01       	movw	r16, r28
    2062:	0e 5f       	subi	r16, 0xFE	; 254
    2064:	1f 4f       	sbci	r17, 0xFF	; 255
    2066:	c8 01       	movw	r24, r16
    2068:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    206c:	e0 91 9f 08 	lds	r30, 0x089F
    2070:	f0 91 a0 08 	lds	r31, 0x08A0
    2074:	86 89       	ldd	r24, Z+22	; 0x16
    2076:	8e 8b       	std	Y+22, r24	; 0x16
    2078:	90 91 3c 08 	lds	r25, 0x083C
    207c:	98 17       	cp	r25, r24
    207e:	10 f4       	brcc	.+4      	; 0x2084 <vTaskPriorityInherit+0x86>
    2080:	80 93 3c 08 	sts	0x083C, r24
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	9c 01       	movw	r18, r24
    2088:	22 0f       	add	r18, r18
    208a:	33 1f       	adc	r19, r19
    208c:	22 0f       	add	r18, r18
    208e:	33 1f       	adc	r19, r19
    2090:	22 0f       	add	r18, r18
    2092:	33 1f       	adc	r19, r19
    2094:	82 0f       	add	r24, r18
    2096:	93 1f       	adc	r25, r19
    2098:	b8 01       	movw	r22, r16
    209a:	8e 58       	subi	r24, 0x8E	; 142
    209c:	97 4f       	sbci	r25, 0xF7	; 247
    209e:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    20a2:	06 c0       	rjmp	.+12     	; 0x20b0 <vTaskPriorityInherit+0xb2>
    20a4:	e0 91 9f 08 	lds	r30, 0x089F
    20a8:	f0 91 a0 08 	lds	r31, 0x08A0
    20ac:	86 89       	ldd	r24, Z+22	; 0x16
    20ae:	8e 8b       	std	Y+22, r24	; 0x16
    20b0:	df 91       	pop	r29
    20b2:	cf 91       	pop	r28
    20b4:	1f 91       	pop	r17
    20b6:	0f 91       	pop	r16
    20b8:	08 95       	ret

000020ba <xTaskPriorityDisinherit>:
    20ba:	0f 93       	push	r16
    20bc:	1f 93       	push	r17
    20be:	cf 93       	push	r28
    20c0:	df 93       	push	r29
    20c2:	ec 01       	movw	r28, r24
    20c4:	00 97       	sbiw	r24, 0x00	; 0
    20c6:	71 f1       	breq	.+92     	; 0x2124 <xTaskPriorityDisinherit+0x6a>
    20c8:	8a a1       	ldd	r24, Y+34	; 0x22
    20ca:	81 50       	subi	r24, 0x01	; 1
    20cc:	8a a3       	std	Y+34, r24	; 0x22
    20ce:	2e 89       	ldd	r18, Y+22	; 0x16
    20d0:	99 a1       	ldd	r25, Y+33	; 0x21
    20d2:	29 17       	cp	r18, r25
    20d4:	49 f1       	breq	.+82     	; 0x2128 <xTaskPriorityDisinherit+0x6e>
    20d6:	81 11       	cpse	r24, r1
    20d8:	29 c0       	rjmp	.+82     	; 0x212c <xTaskPriorityDisinherit+0x72>
    20da:	8e 01       	movw	r16, r28
    20dc:	0e 5f       	subi	r16, 0xFE	; 254
    20de:	1f 4f       	sbci	r17, 0xFF	; 255
    20e0:	c8 01       	movw	r24, r16
    20e2:	0e 94 83 02 	call	0x506	; 0x506 <uxListRemove>
    20e6:	89 a1       	ldd	r24, Y+33	; 0x21
    20e8:	8e 8b       	std	Y+22, r24	; 0x16
    20ea:	25 e0       	ldi	r18, 0x05	; 5
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	28 1b       	sub	r18, r24
    20f0:	31 09       	sbc	r19, r1
    20f2:	3d 87       	std	Y+13, r19	; 0x0d
    20f4:	2c 87       	std	Y+12, r18	; 0x0c
    20f6:	90 91 3c 08 	lds	r25, 0x083C
    20fa:	98 17       	cp	r25, r24
    20fc:	10 f4       	brcc	.+4      	; 0x2102 <xTaskPriorityDisinherit+0x48>
    20fe:	80 93 3c 08 	sts	0x083C, r24
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	9c 01       	movw	r18, r24
    2106:	22 0f       	add	r18, r18
    2108:	33 1f       	adc	r19, r19
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	82 0f       	add	r24, r18
    2114:	93 1f       	adc	r25, r19
    2116:	b8 01       	movw	r22, r16
    2118:	8e 58       	subi	r24, 0x8E	; 142
    211a:	97 4f       	sbci	r25, 0xF7	; 247
    211c:	0e 94 31 02 	call	0x462	; 0x462 <vListInsertEnd>
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	05 c0       	rjmp	.+10     	; 0x212e <xTaskPriorityDisinherit+0x74>
    2124:	80 e0       	ldi	r24, 0x00	; 0
    2126:	03 c0       	rjmp	.+6      	; 0x212e <xTaskPriorityDisinherit+0x74>
    2128:	80 e0       	ldi	r24, 0x00	; 0
    212a:	01 c0       	rjmp	.+2      	; 0x212e <xTaskPriorityDisinherit+0x74>
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	1f 91       	pop	r17
    2134:	0f 91       	pop	r16
    2136:	08 95       	ret

00002138 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2138:	80 91 9f 08 	lds	r24, 0x089F
    213c:	90 91 a0 08 	lds	r25, 0x08A0
    2140:	89 2b       	or	r24, r25
    2142:	39 f0       	breq	.+14     	; 0x2152 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2144:	e0 91 9f 08 	lds	r30, 0x089F
    2148:	f0 91 a0 08 	lds	r31, 0x08A0
    214c:	82 a1       	ldd	r24, Z+34	; 0x22
    214e:	8f 5f       	subi	r24, 0xFF	; 255
    2150:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2152:	80 91 9f 08 	lds	r24, 0x089F
    2156:	90 91 a0 08 	lds	r25, 0x08A0
	}
    215a:	08 95       	ret

0000215c <__divmodhi4>:
    215c:	97 fb       	bst	r25, 7
    215e:	07 2e       	mov	r0, r23
    2160:	16 f4       	brtc	.+4      	; 0x2166 <__divmodhi4+0xa>
    2162:	00 94       	com	r0
    2164:	06 d0       	rcall	.+12     	; 0x2172 <__divmodhi4_neg1>
    2166:	77 fd       	sbrc	r23, 7
    2168:	08 d0       	rcall	.+16     	; 0x217a <__divmodhi4_neg2>
    216a:	0b d0       	rcall	.+22     	; 0x2182 <__udivmodhi4>
    216c:	07 fc       	sbrc	r0, 7
    216e:	05 d0       	rcall	.+10     	; 0x217a <__divmodhi4_neg2>
    2170:	3e f4       	brtc	.+14     	; 0x2180 <__divmodhi4_exit>

00002172 <__divmodhi4_neg1>:
    2172:	90 95       	com	r25
    2174:	81 95       	neg	r24
    2176:	9f 4f       	sbci	r25, 0xFF	; 255
    2178:	08 95       	ret

0000217a <__divmodhi4_neg2>:
    217a:	70 95       	com	r23
    217c:	61 95       	neg	r22
    217e:	7f 4f       	sbci	r23, 0xFF	; 255

00002180 <__divmodhi4_exit>:
    2180:	08 95       	ret

00002182 <__udivmodhi4>:
    2182:	aa 1b       	sub	r26, r26
    2184:	bb 1b       	sub	r27, r27
    2186:	51 e1       	ldi	r21, 0x11	; 17
    2188:	07 c0       	rjmp	.+14     	; 0x2198 <__udivmodhi4_ep>

0000218a <__udivmodhi4_loop>:
    218a:	aa 1f       	adc	r26, r26
    218c:	bb 1f       	adc	r27, r27
    218e:	a6 17       	cp	r26, r22
    2190:	b7 07       	cpc	r27, r23
    2192:	10 f0       	brcs	.+4      	; 0x2198 <__udivmodhi4_ep>
    2194:	a6 1b       	sub	r26, r22
    2196:	b7 0b       	sbc	r27, r23

00002198 <__udivmodhi4_ep>:
    2198:	88 1f       	adc	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	5a 95       	dec	r21
    219e:	a9 f7       	brne	.-22     	; 0x218a <__udivmodhi4_loop>
    21a0:	80 95       	com	r24
    21a2:	90 95       	com	r25
    21a4:	bc 01       	movw	r22, r24
    21a6:	cd 01       	movw	r24, r26
    21a8:	08 95       	ret

000021aa <memcpy>:
    21aa:	fb 01       	movw	r30, r22
    21ac:	dc 01       	movw	r26, r24
    21ae:	02 c0       	rjmp	.+4      	; 0x21b4 <memcpy+0xa>
    21b0:	01 90       	ld	r0, Z+
    21b2:	0d 92       	st	X+, r0
    21b4:	41 50       	subi	r20, 0x01	; 1
    21b6:	50 40       	sbci	r21, 0x00	; 0
    21b8:	d8 f7       	brcc	.-10     	; 0x21b0 <memcpy+0x6>
    21ba:	08 95       	ret

000021bc <__itoa_ncheck>:
    21bc:	bb 27       	eor	r27, r27
    21be:	4a 30       	cpi	r20, 0x0A	; 10
    21c0:	31 f4       	brne	.+12     	; 0x21ce <__itoa_ncheck+0x12>
    21c2:	99 23       	and	r25, r25
    21c4:	22 f4       	brpl	.+8      	; 0x21ce <__itoa_ncheck+0x12>
    21c6:	bd e2       	ldi	r27, 0x2D	; 45
    21c8:	90 95       	com	r25
    21ca:	81 95       	neg	r24
    21cc:	9f 4f       	sbci	r25, 0xFF	; 255
    21ce:	01 c0       	rjmp	.+2      	; 0x21d2 <__utoa_common>

000021d0 <__utoa_ncheck>:
    21d0:	bb 27       	eor	r27, r27

000021d2 <__utoa_common>:
    21d2:	fb 01       	movw	r30, r22
    21d4:	55 27       	eor	r21, r21
    21d6:	aa 27       	eor	r26, r26
    21d8:	88 0f       	add	r24, r24
    21da:	99 1f       	adc	r25, r25
    21dc:	aa 1f       	adc	r26, r26
    21de:	a4 17       	cp	r26, r20
    21e0:	10 f0       	brcs	.+4      	; 0x21e6 <__utoa_common+0x14>
    21e2:	a4 1b       	sub	r26, r20
    21e4:	83 95       	inc	r24
    21e6:	50 51       	subi	r21, 0x10	; 16
    21e8:	b9 f7       	brne	.-18     	; 0x21d8 <__utoa_common+0x6>
    21ea:	a0 5d       	subi	r26, 0xD0	; 208
    21ec:	aa 33       	cpi	r26, 0x3A	; 58
    21ee:	08 f0       	brcs	.+2      	; 0x21f2 <__utoa_common+0x20>
    21f0:	a9 5d       	subi	r26, 0xD9	; 217
    21f2:	a1 93       	st	Z+, r26
    21f4:	00 97       	sbiw	r24, 0x00	; 0
    21f6:	79 f7       	brne	.-34     	; 0x21d6 <__utoa_common+0x4>
    21f8:	b1 11       	cpse	r27, r1
    21fa:	b1 93       	st	Z+, r27
    21fc:	11 92       	st	Z+, r1
    21fe:	cb 01       	movw	r24, r22
    2200:	00 c0       	rjmp	.+0      	; 0x2202 <strrev>

00002202 <strrev>:
    2202:	dc 01       	movw	r26, r24
    2204:	fc 01       	movw	r30, r24
    2206:	67 2f       	mov	r22, r23
    2208:	71 91       	ld	r23, Z+
    220a:	77 23       	and	r23, r23
    220c:	e1 f7       	brne	.-8      	; 0x2206 <strrev+0x4>
    220e:	32 97       	sbiw	r30, 0x02	; 2
    2210:	04 c0       	rjmp	.+8      	; 0x221a <strrev+0x18>
    2212:	7c 91       	ld	r23, X
    2214:	6d 93       	st	X+, r22
    2216:	70 83       	st	Z, r23
    2218:	62 91       	ld	r22, -Z
    221a:	ae 17       	cp	r26, r30
    221c:	bf 07       	cpc	r27, r31
    221e:	c8 f3       	brcs	.-14     	; 0x2212 <strrev+0x10>
    2220:	08 95       	ret

00002222 <_exit>:
    2222:	f8 94       	cli

00002224 <__stop_program>:
    2224:	ff cf       	rjmp	.-2      	; 0x2224 <__stop_program>
