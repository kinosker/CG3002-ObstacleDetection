
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000056  00800200  000022ee  00002382  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000022ee  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000701  00800256  00800256  000023d8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023d8  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  00002408  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005361  00000000  00000000  000028c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001428  00000000  00000000  00007c21  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000032dd  00000000  00000000  00009049  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d68  00000000  00000000  0000c328  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001534  00000000  00000000  0000d090  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000385d  00000000  00000000  0000e5c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  00011e21  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	d5 c2       	rjmp	.+1450   	; 0x5d0 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 2b 08 	jmp	0x1056	; 0x1056 <__vector_21>
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	37 c5       	rjmp	.+2670   	; 0xad4 <__vector_25>
      66:	00 00       	nop
      68:	a3 c5       	rjmp	.+2886   	; 0xbb0 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	83 c3       	rjmp	.+1798   	; 0x77c <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e9 c4       	rjmp	.+2514   	; 0xa64 <__vector_36>
      92:	00 00       	nop
      94:	57 c5       	rjmp	.+2734   	; 0xb44 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ee ee       	ldi	r30, 0xEE	; 238
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a6 35       	cpi	r26, 0x56	; 86
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a6 e5       	ldi	r26, 0x56	; 86
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a7 35       	cpi	r26, 0x57	; 87
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	41 d1       	rcall	.+642    	; 0x3a2 <main>
     120:	0c 94 75 11 	jmp	0x22ea	; 0x22ea <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <RPI_receiveTask>:
}



void setDigitalInputPowerReduction()
{
     126:	17 d6       	rcall	.+3118   	; 0xd56 <myUSART_waitForHandshake>
     128:	86 e0       	ldi	r24, 0x06	; 6
     12a:	92 e0       	ldi	r25, 0x02	; 2
     12c:	e5 d5       	rcall	.+3018   	; 0xcf8 <myUSART_transmitUSART0>
     12e:	fb cf       	rjmp	.-10     	; 0x126 <RPI_receiveTask>

00000130 <RPI_sendTask>:
     130:	cf 93       	push	r28
     132:	df 93       	push	r29
     134:	00 d0       	rcall	.+0      	; 0x136 <RPI_sendTask+0x6>
     136:	00 d0       	rcall	.+0      	; 0x138 <RPI_sendTask+0x8>
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	4f ef       	ldi	r20, 0xFF	; 255
     140:	5f ef       	ldi	r21, 0xFF	; 255
     142:	be 01       	movw	r22, r28
     144:	6a 5f       	subi	r22, 0xFA	; 250
     146:	7f 4f       	sbci	r23, 0xFF	; 255
     148:	80 91 a1 08 	lds	r24, 0x08A1
     14c:	90 91 a2 08 	lds	r25, 0x08A2
     150:	0e 94 47 0a 	call	0x148e	; 0x148e <xQueueGenericReceive>
     154:	8e 81       	ldd	r24, Y+6	; 0x06
     156:	9f ef       	ldi	r25, 0xFF	; 255
     158:	98 0f       	add	r25, r24
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	88 23       	and	r24, r24
     15e:	e9 f0       	breq	.+58     	; 0x19a <RPI_sendTask+0x6a>
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	be 01       	movw	r22, r28
     168:	6f 5f       	subi	r22, 0xFF	; 255
     16a:	7f 4f       	sbci	r23, 0xFF	; 255
     16c:	80 91 a3 08 	lds	r24, 0x08A3
     170:	90 91 a4 08 	lds	r25, 0x08A4
     174:	0e 94 47 0a 	call	0x148e	; 0x148e <xQueueGenericReceive>
     178:	89 81       	ldd	r24, Y+1	; 0x01
     17a:	90 d5       	rcall	.+2848   	; 0xc9c <myUSART_transmitUSART0_c>
     17c:	8d e1       	ldi	r24, 0x1D	; 29
     17e:	92 e0       	ldi	r25, 0x02	; 2
     180:	bb d5       	rcall	.+2934   	; 0xcf8 <myUSART_transmitUSART0>
     182:	ce 01       	movw	r24, r28
     184:	02 96       	adiw	r24, 0x02	; 2
     186:	b8 d5       	rcall	.+2928   	; 0xcf8 <myUSART_transmitUSART0>
     188:	80 e2       	ldi	r24, 0x20	; 32
     18a:	92 e0       	ldi	r25, 0x02	; 2
     18c:	b5 d5       	rcall	.+2922   	; 0xcf8 <myUSART_transmitUSART0>
     18e:	8e 81       	ldd	r24, Y+6	; 0x06
     190:	9f ef       	ldi	r25, 0xFF	; 255
     192:	98 0f       	add	r25, r24
     194:	9e 83       	std	Y+6, r25	; 0x06
     196:	81 11       	cpse	r24, r1
     198:	e3 cf       	rjmp	.-58     	; 0x160 <RPI_sendTask+0x30>
     19a:	8a e0       	ldi	r24, 0x0A	; 10
     19c:	7f d5       	rcall	.+2814   	; 0xc9c <myUSART_transmitUSART0_c>
     19e:	84 ef       	ldi	r24, 0xF4	; 244
     1a0:	91 e0       	ldi	r25, 0x01	; 1
     1a2:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <vTaskDelay>
     1a6:	ca cf       	rjmp	.-108    	; 0x13c <RPI_sendTask+0xc>

000001a8 <task1>:
     1a8:	26 9a       	sbi	0x04, 6	; 4
     1aa:	2e 9a       	sbi	0x05, 6	; 5
     1ac:	88 ee       	ldi	r24, 0xE8	; 232
     1ae:	93 e0       	ldi	r25, 0x03	; 3
     1b0:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <vTaskDelay>
     1b4:	85 b1       	in	r24, 0x05	; 5
     1b6:	15 b8       	out	0x05, r1	; 5
     1b8:	88 ee       	ldi	r24, 0xE8	; 232
     1ba:	93 e0       	ldi	r25, 0x03	; 3
     1bc:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <vTaskDelay>
     1c0:	f4 cf       	rjmp	.-24     	; 0x1aa <task1+0x2>

000001c2 <myTimerTask>:
     1c2:	7e d3       	rcall	.+1788   	; 0x8c0 <myTimer_Init>
     1c4:	e0 d3       	rcall	.+1984   	; 0x986 <myTimer_DelayChecker>
     1c6:	fe cf       	rjmp	.-4      	; 0x1c4 <myTimerTask+0x2>

000001c8 <obstacleSend>:
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
     1ce:	00 d0       	rcall	.+0      	; 0x1d0 <obstacleSend+0x8>
     1d0:	1f 92       	push	r1
     1d2:	1f 92       	push	r1
     1d4:	cd b7       	in	r28, 0x3d	; 61
     1d6:	de b7       	in	r29, 0x3e	; 62
     1d8:	18 2f       	mov	r17, r24
     1da:	cb 01       	movw	r24, r22
     1dc:	11 23       	and	r17, r17
     1de:	99 f0       	breq	.+38     	; 0x206 <obstacleSend+0x3e>
     1e0:	4a e0       	ldi	r20, 0x0A	; 10
     1e2:	be 01       	movw	r22, r28
     1e4:	6e 5f       	subi	r22, 0xFE	; 254
     1e6:	7f 4f       	sbci	r23, 0xFF	; 255
     1e8:	0e 94 42 11 	call	0x2284	; 0x2284 <__itoa_ncheck>
     1ec:	19 83       	std	Y+1, r17	; 0x01
     1ee:	20 e0       	ldi	r18, 0x00	; 0
     1f0:	4f ef       	ldi	r20, 0xFF	; 255
     1f2:	5f ef       	ldi	r21, 0xFF	; 255
     1f4:	be 01       	movw	r22, r28
     1f6:	6f 5f       	subi	r22, 0xFF	; 255
     1f8:	7f 4f       	sbci	r23, 0xFF	; 255
     1fa:	80 91 a3 08 	lds	r24, 0x08A3
     1fe:	90 91 a4 08 	lds	r25, 0x08A4
     202:	0e 94 52 09 	call	0x12a4	; 0x12a4 <xQueueGenericSend>
     206:	0f 90       	pop	r0
     208:	0f 90       	pop	r0
     20a:	0f 90       	pop	r0
     20c:	0f 90       	pop	r0
     20e:	0f 90       	pop	r0
     210:	df 91       	pop	r29
     212:	cf 91       	pop	r28
     214:	1f 91       	pop	r17
     216:	08 95       	ret

00000218 <Sonar_Task>:
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	00 d0       	rcall	.+0      	; 0x21e <Sonar_Task+0x6>
     21e:	cd b7       	in	r28, 0x3d	; 61
     220:	de b7       	in	r29, 0x3e	; 62
     222:	1b 82       	std	Y+3, r1	; 0x03
     224:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <xTaskGetTickCount>
     228:	9a 83       	std	Y+2, r25	; 0x02
     22a:	89 83       	std	Y+1, r24	; 0x01
     22c:	0f 2e       	mov	r0, r31
     22e:	f8 e7       	ldi	r31, 0x78	; 120
     230:	6f 2e       	mov	r6, r31
     232:	f0 2d       	mov	r31, r0
     234:	0f 2e       	mov	r0, r31
     236:	f3 e0       	ldi	r31, 0x03	; 3
     238:	7f 2e       	mov	r7, r31
     23a:	f0 2d       	mov	r31, r0
     23c:	68 94       	set
     23e:	88 24       	eor	r8, r8
     240:	81 f8       	bld	r8, 1
     242:	99 24       	eor	r9, r9
     244:	93 94       	inc	r9
     246:	8a d2       	rcall	.+1300   	; 0x75c <myMaxSonar_Start>
     248:	87 e2       	ldi	r24, 0x27	; 39
     24a:	8e d2       	rcall	.+1308   	; 0x768 <myMaxSonar_Read>
     24c:	7c 01       	movw	r14, r24
     24e:	86 e2       	ldi	r24, 0x26	; 38
     250:	8b d2       	rcall	.+1302   	; 0x768 <myMaxSonar_Read>
     252:	6c 01       	movw	r12, r24
     254:	85 e2       	ldi	r24, 0x25	; 37
     256:	88 d2       	rcall	.+1296   	; 0x768 <myMaxSonar_Read>
     258:	0a 97       	sbiw	r24, 0x0a	; 10
     25a:	5c 01       	movw	r10, r24
     25c:	82 e3       	ldi	r24, 0x32	; 50
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <vTaskDelay>
     264:	5a d2       	rcall	.+1204   	; 0x71a <myHcSonar_Read>
     266:	8c 01       	movw	r16, r24
     268:	08 3e       	cpi	r16, 0xE8	; 232
     26a:	83 e0       	ldi	r24, 0x03	; 3
     26c:	18 07       	cpc	r17, r24
     26e:	14 f0       	brlt	.+4      	; 0x274 <Sonar_Task+0x5c>
     270:	06 2d       	mov	r16, r6
     272:	17 2d       	mov	r17, r7
     274:	e6 e4       	ldi	r30, 0x46	; 70
     276:	ee 16       	cp	r14, r30
     278:	f1 04       	cpc	r15, r1
     27a:	14 f5       	brge	.+68     	; 0x2c0 <Sonar_Task+0xa8>
     27c:	fd e2       	ldi	r31, 0x2D	; 45
     27e:	cf 16       	cp	r12, r31
     280:	d1 04       	cpc	r13, r1
     282:	54 f4       	brge	.+20     	; 0x298 <Sonar_Task+0x80>
     284:	8d e2       	ldi	r24, 0x2D	; 45
     286:	a8 16       	cp	r10, r24
     288:	b1 04       	cpc	r11, r1
     28a:	34 f4       	brge	.+12     	; 0x298 <Sonar_Task+0x80>
     28c:	74 9a       	sbi	0x0e, 4	; 14
     28e:	f4 01       	movw	r30, r8
     290:	80 81       	ld	r24, Z
     292:	80 61       	ori	r24, 0x10	; 16
     294:	80 83       	st	Z, r24
     296:	19 c0       	rjmp	.+50     	; 0x2ca <Sonar_Task+0xb2>
     298:	c6 01       	movw	r24, r12
     29a:	0a 96       	adiw	r24, 0x0a	; 10
     29c:	a8 16       	cp	r10, r24
     29e:	b9 06       	cpc	r11, r25
     2a0:	34 f4       	brge	.+12     	; 0x2ae <Sonar_Task+0x96>
     2a2:	f4 01       	movw	r30, r8
     2a4:	80 81       	ld	r24, Z
     2a6:	8f 7e       	andi	r24, 0xEF	; 239
     2a8:	80 83       	st	Z, r24
     2aa:	74 9a       	sbi	0x0e, 4	; 14
     2ac:	0e c0       	rjmp	.+28     	; 0x2ca <Sonar_Task+0xb2>
     2ae:	8a 15       	cp	r24, r10
     2b0:	9b 05       	cpc	r25, r11
     2b2:	5c f4       	brge	.+22     	; 0x2ca <Sonar_Task+0xb2>
     2b4:	74 98       	cbi	0x0e, 4	; 14
     2b6:	f4 01       	movw	r30, r8
     2b8:	80 81       	ld	r24, Z
     2ba:	80 61       	ori	r24, 0x10	; 16
     2bc:	80 83       	st	Z, r24
     2be:	05 c0       	rjmp	.+10     	; 0x2ca <Sonar_Task+0xb2>
     2c0:	f4 01       	movw	r30, r8
     2c2:	80 81       	ld	r24, Z
     2c4:	8f 7e       	andi	r24, 0xEF	; 239
     2c6:	80 83       	st	Z, r24
     2c8:	74 98       	cbi	0x0e, 4	; 14
     2ca:	8b 81       	ldd	r24, Y+3	; 0x03
     2cc:	8c 5f       	subi	r24, 0xFC	; 252
     2ce:	8b 83       	std	Y+3, r24	; 0x03
     2d0:	20 e0       	ldi	r18, 0x00	; 0
     2d2:	4f ef       	ldi	r20, 0xFF	; 255
     2d4:	5f ef       	ldi	r21, 0xFF	; 255
     2d6:	be 01       	movw	r22, r28
     2d8:	6d 5f       	subi	r22, 0xFD	; 253
     2da:	7f 4f       	sbci	r23, 0xFF	; 255
     2dc:	80 91 a1 08 	lds	r24, 0x08A1
     2e0:	90 91 a2 08 	lds	r25, 0x08A2
     2e4:	df d7       	rcall	.+4030   	; 0x12a4 <xQueueGenericSend>
     2e6:	b7 01       	movw	r22, r14
     2e8:	86 e4       	ldi	r24, 0x46	; 70
     2ea:	6e df       	rcall	.-292    	; 0x1c8 <obstacleSend>
     2ec:	b6 01       	movw	r22, r12
     2ee:	8c e4       	ldi	r24, 0x4C	; 76
     2f0:	6b df       	rcall	.-298    	; 0x1c8 <obstacleSend>
     2f2:	b5 01       	movw	r22, r10
     2f4:	82 e5       	ldi	r24, 0x52	; 82
     2f6:	68 df       	rcall	.-304    	; 0x1c8 <obstacleSend>
     2f8:	b8 01       	movw	r22, r16
     2fa:	82 e4       	ldi	r24, 0x42	; 66
     2fc:	65 df       	rcall	.-310    	; 0x1c8 <obstacleSend>
     2fe:	1b 82       	std	Y+3, r1	; 0x03
     300:	68 ec       	ldi	r22, 0xC8	; 200
     302:	70 e0       	ldi	r23, 0x00	; 0
     304:	ce 01       	movw	r24, r28
     306:	01 96       	adiw	r24, 0x01	; 1
     308:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <vTaskDelayUntil>
     30c:	9c cf       	rjmp	.-200    	; 0x246 <Sonar_Task+0x2e>

0000030e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     30e:	8c ec       	ldi	r24, 0xCC	; 204
     310:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     314:	8e e3       	ldi	r24, 0x3E	; 62
     316:	80 93 65 00 	sts	0x0065, r24
     31a:	08 95       	ret

0000031c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     31c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     320:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     324:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     328:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     32c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     330:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     334:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     338:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     33c:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     340:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     344:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     348:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     34c:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     350:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     354:	10 92 73 00 	sts	0x0073, r1
     358:	08 95       	ret

0000035a <init>:
}

void init()
{
     35a:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     35c:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     35e:	f8 94       	cli
	{
		clearTimer();
     360:	dd df       	rcall	.-70     	; 0x31c <clearTimer>
		setPowerReduction();
     362:	d5 df       	rcall	.-86     	; 0x30e <setPowerReduction>
		myUSART_USART0_Init();
     364:	5b d4       	rcall	.+2230   	; 0xc1c <myUSART_USART0_Init>
		myUSART_USART1_Init();
     366:	7a d4       	rcall	.+2292   	; 0xc5c <myUSART_USART1_Init>
		myADC_Init();
     368:	41 d2       	rcall	.+1154   	; 0x7ec <myADC_Init>
		MaxSonar_Init();
     36a:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     36c:	bb d1       	rcall	.+886    	; 0x6e4 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     36e:	40 e0       	ldi	r20, 0x00	; 0
     370:	61 e0       	ldi	r22, 0x01	; 1
     372:	85 e0       	ldi	r24, 0x05	; 5
     374:	6d d7       	rcall	.+3802   	; 0x1250 <xQueueGenericCreate>
     376:	90 93 a2 08 	sts	0x08A2, r25
     37a:	80 93 a1 08 	sts	0x08A1, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     37e:	40 e0       	ldi	r20, 0x00	; 0
     380:	65 e0       	ldi	r22, 0x05	; 5
     382:	84 e1       	ldi	r24, 0x14	; 20
     384:	65 d7       	rcall	.+3786   	; 0x1250 <xQueueGenericCreate>
     386:	90 93 a4 08 	sts	0x08A4, r25
     38a:	80 93 a3 08 	sts	0x08A3, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     38e:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     390:	e1 e0       	ldi	r30, 0x01	; 1
     392:	f1 e0       	ldi	r31, 0x01	; 1
     394:	80 81       	ld	r24, Z
     396:	80 61       	ori	r24, 0x10	; 16
     398:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     39a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     39c:	78 94       	sei
}
     39e:	cf 91       	pop	r28
     3a0:	08 95       	ret

000003a2 <main>:
	
	// do nth
}

int main(void)
{
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	cd b7       	in	r28, 0x3d	; 61
     3a8:	de b7       	in	r29, 0x3e	; 62
     3aa:	2a 97       	sbiw	r28, 0x0a	; 10
     3ac:	0f b6       	in	r0, 0x3f	; 63
     3ae:	f8 94       	cli
     3b0:	de bf       	out	0x3e, r29	; 62
     3b2:	0f be       	out	0x3f, r0	; 63
     3b4:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
		
		init();
     3b6:	d1 df       	rcall	.-94     	; 0x35a <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     3b8:	a1 2c       	mov	r10, r1
     3ba:	b1 2c       	mov	r11, r1
     3bc:	c1 2c       	mov	r12, r1
     3be:	d1 2c       	mov	r13, r1
     3c0:	ce 01       	movw	r24, r28
     3c2:	01 96       	adiw	r24, 0x01	; 1
     3c4:	7c 01       	movw	r14, r24
     3c6:	01 e0       	ldi	r16, 0x01	; 1
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	45 e5       	ldi	r20, 0x55	; 85
     3ce:	50 e0       	ldi	r21, 0x00	; 0
     3d0:	63 e2       	ldi	r22, 0x23	; 35
     3d2:	72 e0       	ldi	r23, 0x02	; 2
     3d4:	84 ed       	ldi	r24, 0xD4	; 212
     3d6:	90 e0       	ldi	r25, 0x00	; 0
     3d8:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     3dc:	ce 01       	movw	r24, r28
     3de:	03 96       	adiw	r24, 0x03	; 3
     3e0:	7c 01       	movw	r14, r24
     3e2:	04 e0       	ldi	r16, 0x04	; 4
     3e4:	9c 01       	movw	r18, r24
     3e6:	49 e6       	ldi	r20, 0x69	; 105
     3e8:	50 e0       	ldi	r21, 0x00	; 0
     3ea:	6a e2       	ldi	r22, 0x2A	; 42
     3ec:	72 e0       	ldi	r23, 0x02	; 2
     3ee:	81 ee       	ldi	r24, 0xE1	; 225
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     3f6:	ce 01       	movw	r24, r28
     3f8:	09 96       	adiw	r24, 0x09	; 9
     3fa:	7c 01       	movw	r14, r24
     3fc:	02 e0       	ldi	r16, 0x02	; 2
     3fe:	20 e0       	ldi	r18, 0x00	; 0
     400:	30 e0       	ldi	r19, 0x00	; 0
     402:	4f e4       	ldi	r20, 0x4F	; 79
     404:	51 e0       	ldi	r21, 0x01	; 1
     406:	62 e3       	ldi	r22, 0x32	; 50
     408:	72 e0       	ldi	r23, 0x02	; 2
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	91 e0       	ldi	r25, 0x01	; 1
     40e:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>

		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     412:	ce 01       	movw	r24, r28
     414:	07 96       	adiw	r24, 0x07	; 7
     416:	7c 01       	movw	r14, r24
     418:	03 e0       	ldi	r16, 0x03	; 3
     41a:	20 e0       	ldi	r18, 0x00	; 0
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	47 e8       	ldi	r20, 0x87	; 135
     420:	50 e0       	ldi	r21, 0x00	; 0
     422:	6b e3       	ldi	r22, 0x3B	; 59
     424:	72 e0       	ldi	r23, 0x02	; 2
     426:	83 e9       	ldi	r24, 0x93	; 147
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     42e:	ce 01       	movw	r24, r28
     430:	05 96       	adiw	r24, 0x05	; 5
     432:	7c 01       	movw	r14, r24
     434:	01 e0       	ldi	r16, 0x01	; 1
     436:	20 e0       	ldi	r18, 0x00	; 0
     438:	30 e0       	ldi	r19, 0x00	; 0
     43a:	47 e8       	ldi	r20, 0x87	; 135
     43c:	50 e0       	ldi	r21, 0x00	; 0
     43e:	67 e4       	ldi	r22, 0x47	; 71
     440:	72 e0       	ldi	r23, 0x02	; 2
     442:	88 e9       	ldi	r24, 0x98	; 152
     444:	90 e0       	ldi	r25, 0x00	; 0
     446:	0e 94 8e 0b 	call	0x171c	; 0x171c <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     44a:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <vTaskStartScheduler>
     44e:	b3 cf       	rjmp	.-154    	; 0x3b6 <main+0x14>

00000450 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     456:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     45a:	80 91 56 02 	lds	r24, 0x0256
     45e:	90 91 57 02 	lds	r25, 0x0257
     462:	89 2b       	or	r24, r25
     464:	31 f4       	brne	.+12     	; 0x472 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     466:	8b e5       	ldi	r24, 0x5B	; 91
     468:	92 e0       	ldi	r25, 0x02	; 2
     46a:	90 93 57 02 	sts	0x0257, r25
     46e:	80 93 56 02 	sts	0x0256, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     472:	40 91 58 02 	lds	r20, 0x0258
     476:	50 91 59 02 	lds	r21, 0x0259
     47a:	9e 01       	movw	r18, r28
     47c:	24 0f       	add	r18, r20
     47e:	35 1f       	adc	r19, r21
     480:	2b 3d       	cpi	r18, 0xDB	; 219
     482:	85 e0       	ldi	r24, 0x05	; 5
     484:	38 07       	cpc	r19, r24
     486:	70 f4       	brcc	.+28     	; 0x4a4 <pvPortMalloc+0x54>
     488:	42 17       	cp	r20, r18
     48a:	53 07       	cpc	r21, r19
     48c:	70 f4       	brcc	.+28     	; 0x4aa <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     48e:	c0 91 56 02 	lds	r28, 0x0256
     492:	d0 91 57 02 	lds	r29, 0x0257
     496:	c4 0f       	add	r28, r20
     498:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     49a:	30 93 59 02 	sts	0x0259, r19
     49e:	20 93 58 02 	sts	0x0258, r18
     4a2:	05 c0       	rjmp	.+10     	; 0x4ae <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     4a4:	c0 e0       	ldi	r28, 0x00	; 0
     4a6:	d0 e0       	ldi	r29, 0x00	; 0
     4a8:	02 c0       	rjmp	.+4      	; 0x4ae <pvPortMalloc+0x5e>
     4aa:	c0 e0       	ldi	r28, 0x00	; 0
     4ac:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     4ae:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     4b2:	ce 01       	movw	r24, r28
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	08 95       	ret

000004ba <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     4ba:	08 95       	ret

000004bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     4bc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4be:	03 96       	adiw	r24, 0x03	; 3
     4c0:	92 83       	std	Z+2, r25	; 0x02
     4c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     4c4:	2f ef       	ldi	r18, 0xFF	; 255
     4c6:	3f ef       	ldi	r19, 0xFF	; 255
     4c8:	34 83       	std	Z+4, r19	; 0x04
     4ca:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4cc:	96 83       	std	Z+6, r25	; 0x06
     4ce:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4d0:	90 87       	std	Z+8, r25	; 0x08
     4d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     4d4:	10 82       	st	Z, r1
     4d6:	08 95       	ret

000004d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     4d8:	fc 01       	movw	r30, r24
     4da:	11 86       	std	Z+9, r1	; 0x09
     4dc:	10 86       	std	Z+8, r1	; 0x08
     4de:	08 95       	ret

000004e0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	9c 01       	movw	r18, r24
     4e6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     4e8:	dc 01       	movw	r26, r24
     4ea:	11 96       	adiw	r26, 0x01	; 1
     4ec:	cd 91       	ld	r28, X+
     4ee:	dc 91       	ld	r29, X
     4f0:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     4f2:	d3 83       	std	Z+3, r29	; 0x03
     4f4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     4f6:	8c 81       	ldd	r24, Y+4	; 0x04
     4f8:	9d 81       	ldd	r25, Y+5	; 0x05
     4fa:	95 83       	std	Z+5, r25	; 0x05
     4fc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     4fe:	8c 81       	ldd	r24, Y+4	; 0x04
     500:	9d 81       	ldd	r25, Y+5	; 0x05
     502:	dc 01       	movw	r26, r24
     504:	13 96       	adiw	r26, 0x03	; 3
     506:	7c 93       	st	X, r23
     508:	6e 93       	st	-X, r22
     50a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     50c:	7d 83       	std	Y+5, r23	; 0x05
     50e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     510:	31 87       	std	Z+9, r19	; 0x09
     512:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     514:	f9 01       	movw	r30, r18
     516:	80 81       	ld	r24, Z
     518:	8f 5f       	subi	r24, 0xFF	; 255
     51a:	80 83       	st	Z, r24
}
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	08 95       	ret

00000522 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     522:	cf 93       	push	r28
     524:	df 93       	push	r29
     526:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     528:	48 81       	ld	r20, Y
     52a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     52c:	4f 3f       	cpi	r20, 0xFF	; 255
     52e:	2f ef       	ldi	r18, 0xFF	; 255
     530:	52 07       	cpc	r21, r18
     532:	21 f4       	brne	.+8      	; 0x53c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     534:	fc 01       	movw	r30, r24
     536:	a7 81       	ldd	r26, Z+7	; 0x07
     538:	b0 85       	ldd	r27, Z+8	; 0x08
     53a:	0d c0       	rjmp	.+26     	; 0x556 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     53c:	dc 01       	movw	r26, r24
     53e:	13 96       	adiw	r26, 0x03	; 3
     540:	12 96       	adiw	r26, 0x02	; 2
     542:	ed 91       	ld	r30, X+
     544:	fc 91       	ld	r31, X
     546:	13 97       	sbiw	r26, 0x03	; 3
     548:	20 81       	ld	r18, Z
     54a:	31 81       	ldd	r19, Z+1	; 0x01
     54c:	42 17       	cp	r20, r18
     54e:	53 07       	cpc	r21, r19
     550:	10 f0       	brcs	.+4      	; 0x556 <vListInsert+0x34>
     552:	df 01       	movw	r26, r30
     554:	f5 cf       	rjmp	.-22     	; 0x540 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     556:	12 96       	adiw	r26, 0x02	; 2
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	13 97       	sbiw	r26, 0x03	; 3
     55e:	fb 83       	std	Y+3, r31	; 0x03
     560:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     562:	d5 83       	std	Z+5, r29	; 0x05
     564:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     566:	bd 83       	std	Y+5, r27	; 0x05
     568:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     56a:	13 96       	adiw	r26, 0x03	; 3
     56c:	dc 93       	st	X, r29
     56e:	ce 93       	st	-X, r28
     570:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     572:	99 87       	std	Y+9, r25	; 0x09
     574:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     576:	fc 01       	movw	r30, r24
     578:	20 81       	ld	r18, Z
     57a:	2f 5f       	subi	r18, 0xFF	; 255
     57c:	20 83       	st	Z, r18
}
     57e:	df 91       	pop	r29
     580:	cf 91       	pop	r28
     582:	08 95       	ret

00000584 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     584:	cf 93       	push	r28
     586:	df 93       	push	r29
     588:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     58a:	a0 85       	ldd	r26, Z+8	; 0x08
     58c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     58e:	c2 81       	ldd	r28, Z+2	; 0x02
     590:	d3 81       	ldd	r29, Z+3	; 0x03
     592:	84 81       	ldd	r24, Z+4	; 0x04
     594:	95 81       	ldd	r25, Z+5	; 0x05
     596:	9d 83       	std	Y+5, r25	; 0x05
     598:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     59a:	c4 81       	ldd	r28, Z+4	; 0x04
     59c:	d5 81       	ldd	r29, Z+5	; 0x05
     59e:	82 81       	ldd	r24, Z+2	; 0x02
     5a0:	93 81       	ldd	r25, Z+3	; 0x03
     5a2:	9b 83       	std	Y+3, r25	; 0x03
     5a4:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     5a6:	11 96       	adiw	r26, 0x01	; 1
     5a8:	cd 91       	ld	r28, X+
     5aa:	dc 91       	ld	r29, X
     5ac:	12 97       	sbiw	r26, 0x02	; 2
     5ae:	ce 17       	cp	r28, r30
     5b0:	df 07       	cpc	r29, r31
     5b2:	31 f4       	brne	.+12     	; 0x5c0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     5b4:	8c 81       	ldd	r24, Y+4	; 0x04
     5b6:	9d 81       	ldd	r25, Y+5	; 0x05
     5b8:	12 96       	adiw	r26, 0x02	; 2
     5ba:	9c 93       	st	X, r25
     5bc:	8e 93       	st	-X, r24
     5be:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     5c0:	11 86       	std	Z+9, r1	; 0x09
     5c2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     5c4:	8c 91       	ld	r24, X
     5c6:	81 50       	subi	r24, 0x01	; 1
     5c8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	08 95       	ret

000005d0 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     5d0:	1f 92       	push	r1
     5d2:	0f 92       	push	r0
     5d4:	0f b6       	in	r0, 0x3f	; 63
     5d6:	0f 92       	push	r0
     5d8:	11 24       	eor	r1, r1
     5da:	0b b6       	in	r0, 0x3b	; 59
     5dc:	0f 92       	push	r0
     5de:	2f 93       	push	r18
     5e0:	3f 93       	push	r19
     5e2:	4f 93       	push	r20
     5e4:	5f 93       	push	r21
     5e6:	6f 93       	push	r22
     5e8:	7f 93       	push	r23
     5ea:	8f 93       	push	r24
     5ec:	9f 93       	push	r25
     5ee:	af 93       	push	r26
     5f0:	bf 93       	push	r27
     5f2:	ef 93       	push	r30
     5f4:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     5f6:	1b 9b       	sbis	0x03, 3	; 3
     5f8:	0d c0       	rjmp	.+26     	; 0x614 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     5fa:	7c d1       	rcall	.+760    	; 0x8f4 <myTimer_Read>
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	90 93 aa 08 	sts	0x08AA, r25
     602:	80 93 a9 08 	sts	0x08A9, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     606:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <xTaskGetTickCountFromISR>
     60a:	90 93 a6 08 	sts	0x08A6, r25
     60e:	80 93 a5 08 	sts	0x08A5, r24
     612:	55 c0       	rjmp	.+170    	; 0x6be <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     614:	1b 99       	sbic	0x03, 3	; 3
     616:	53 c0       	rjmp	.+166    	; 0x6be <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     618:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <xTaskGetTickCountFromISR>
     61c:	90 93 b0 08 	sts	0x08B0, r25
     620:	80 93 af 08 	sts	0x08AF, r24
     624:	20 91 a5 08 	lds	r18, 0x08A5
     628:	30 91 a6 08 	lds	r19, 0x08A6
     62c:	82 17       	cp	r24, r18
     62e:	93 07       	cpc	r25, r19
     630:	4c f4       	brge	.+18     	; 0x644 <__vector_9+0x74>
			ms_tickEnd += 65535;
     632:	80 91 af 08 	lds	r24, 0x08AF
     636:	90 91 b0 08 	lds	r25, 0x08B0
     63a:	01 97       	sbiw	r24, 0x01	; 1
     63c:	90 93 b0 08 	sts	0x08B0, r25
     640:	80 93 af 08 	sts	0x08AF, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     644:	57 d1       	rcall	.+686    	; 0x8f4 <myTimer_Read>
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	90 93 b2 08 	sts	0x08B2, r25
     64c:	80 93 b1 08 	sts	0x08B1, r24
     650:	20 91 a9 08 	lds	r18, 0x08A9
     654:	30 91 aa 08 	lds	r19, 0x08AA
     658:	82 17       	cp	r24, r18
     65a:	93 07       	cpc	r25, r19
     65c:	54 f4       	brge	.+20     	; 0x672 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     65e:	80 91 b1 08 	lds	r24, 0x08B1
     662:	90 91 b2 08 	lds	r25, 0x08B2
     666:	86 50       	subi	r24, 0x06	; 6
     668:	9f 4f       	sbci	r25, 0xFF	; 255
     66a:	90 93 b2 08 	sts	0x08B2, r25
     66e:	80 93 b1 08 	sts	0x08B1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     672:	80 91 b1 08 	lds	r24, 0x08B1
     676:	90 91 b2 08 	lds	r25, 0x08B2
     67a:	20 91 a9 08 	lds	r18, 0x08A9
     67e:	30 91 aa 08 	lds	r19, 0x08AA
     682:	82 1b       	sub	r24, r18
     684:	93 0b       	sbc	r25, r19
     686:	90 93 ac 08 	sts	0x08AC, r25
     68a:	80 93 ab 08 	sts	0x08AB, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     68e:	80 91 af 08 	lds	r24, 0x08AF
     692:	90 91 b0 08 	lds	r25, 0x08B0
     696:	20 91 a5 08 	lds	r18, 0x08A5
     69a:	30 91 a6 08 	lds	r19, 0x08A6
     69e:	82 1b       	sub	r24, r18
     6a0:	93 0b       	sbc	r25, r19
     6a2:	90 93 a8 08 	sts	0x08A8, r25
     6a6:	80 93 a7 08 	sts	0x08A7, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	40 e0       	ldi	r20, 0x00	; 0
     6ae:	50 e0       	ldi	r21, 0x00	; 0
     6b0:	60 e0       	ldi	r22, 0x00	; 0
     6b2:	70 e0       	ldi	r23, 0x00	; 0
     6b4:	80 91 ad 08 	lds	r24, 0x08AD
     6b8:	90 91 ae 08 	lds	r25, 0x08AE
     6bc:	ae d6       	rcall	.+3420   	; 0x141a <xQueueGenericSendFromISR>
	}	
}
     6be:	ff 91       	pop	r31
     6c0:	ef 91       	pop	r30
     6c2:	bf 91       	pop	r27
     6c4:	af 91       	pop	r26
     6c6:	9f 91       	pop	r25
     6c8:	8f 91       	pop	r24
     6ca:	7f 91       	pop	r23
     6cc:	6f 91       	pop	r22
     6ce:	5f 91       	pop	r21
     6d0:	4f 91       	pop	r20
     6d2:	3f 91       	pop	r19
     6d4:	2f 91       	pop	r18
     6d6:	0f 90       	pop	r0
     6d8:	0b be       	out	0x3b, r0	; 59
     6da:	0f 90       	pop	r0
     6dc:	0f be       	out	0x3f, r0	; 63
     6de:	0f 90       	pop	r0
     6e0:	1f 90       	pop	r1
     6e2:	18 95       	reti

000006e4 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     6e4:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     6e6:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     6e8:	e8 e6       	ldi	r30, 0x68	; 104
     6ea:	f0 e0       	ldi	r31, 0x00	; 0
     6ec:	80 81       	ld	r24, Z
     6ee:	81 60       	ori	r24, 0x01	; 1
     6f0:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     6f2:	eb e6       	ldi	r30, 0x6B	; 107
     6f4:	f0 e0       	ldi	r31, 0x00	; 0
     6f6:	80 81       	ld	r24, Z
     6f8:	88 60       	ori	r24, 0x08	; 8
     6fa:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     6fc:	43 e0       	ldi	r20, 0x03	; 3
     6fe:	60 e0       	ldi	r22, 0x00	; 0
     700:	81 e0       	ldi	r24, 0x01	; 1
     702:	a6 d5       	rcall	.+2892   	; 0x1250 <xQueueGenericCreate>
     704:	90 93 ae 08 	sts	0x08AE, r25
     708:	80 93 ad 08 	sts	0x08AD, r24
     70c:	08 95       	ret

0000070e <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     70e:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(30); // delay 20 micro seconds for the pulse
     710:	8e e1       	ldi	r24, 0x1E	; 30
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	15 d1       	rcall	.+554    	; 0x940 <myTimer_DelayMicro2>
	
	HcSonar_TriggerStop();
     716:	2a 98       	cbi	0x05, 2	; 5
     718:	08 95       	ret

0000071a <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     71a:	f9 df       	rcall	.-14     	; 0x70e <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	4f ef       	ldi	r20, 0xFF	; 255
     720:	5f ef       	ldi	r21, 0xFF	; 255
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	80 91 ad 08 	lds	r24, 0x08AD
     72a:	90 91 ae 08 	lds	r25, 0x08AE
     72e:	af d6       	rcall	.+3422   	; 0x148e <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     730:	80 91 ab 08 	lds	r24, 0x08AB
     734:	90 91 ac 08 	lds	r25, 0x08AC
	msLength = ms_tickLapsed * 5;
     738:	20 91 a7 08 	lds	r18, 0x08A7
     73c:	30 91 a8 08 	lds	r19, 0x08A8
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, portMAX_DELAY);
	
	usLength = us_tickLapsed / 14;
     740:	6e e0       	ldi	r22, 0x0E	; 14
     742:	70 e0       	ldi	r23, 0x00	; 0
     744:	0e 94 12 11 	call	0x2224	; 0x2224 <__divmodhi4>
	msLength = ms_tickLapsed * 5;
     748:	c9 01       	movw	r24, r18
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	88 0f       	add	r24, r24
     750:	99 1f       	adc	r25, r25
     752:	82 0f       	add	r24, r18
     754:	93 1f       	adc	r25, r19
	return usLength + msLength;
	
     756:	86 0f       	add	r24, r22
     758:	97 1f       	adc	r25, r23
     75a:	08 95       	ret

0000075c <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     75c:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     75e:	89 e1       	ldi	r24, 0x19	; 25
     760:	90 e0       	ldi	r25, 0x00	; 0
     762:	ca d0       	rcall	.+404    	; 0x8f8 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     764:	a1 98       	cbi	0x14, 1	; 20
     766:	08 95       	ret

00000768 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	unsigned char adcReading = myADC_analogRead(analogChannel);
     768:	a4 d0       	rcall	.+328    	; 0x8b2 <myADC_analogRead>
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     76a:	2b ea       	ldi	r18, 0xAB	; 171
     76c:	82 9f       	mul	r24, r18
     76e:	21 2d       	mov	r18, r1
     770:	11 24       	eor	r1, r1
     772:	26 95       	lsr	r18
	reading += adcReading; // add the exact adcReading
     774:	90 e0       	ldi	r25, 0x00	; 0
	
	return reading;
}
     776:	82 0f       	add	r24, r18
     778:	91 1d       	adc	r25, r1
     77a:	08 95       	ret

0000077c <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     77c:	1f 92       	push	r1
     77e:	0f 92       	push	r0
     780:	0f b6       	in	r0, 0x3f	; 63
     782:	0f 92       	push	r0
     784:	11 24       	eor	r1, r1
     786:	0b b6       	in	r0, 0x3b	; 59
     788:	0f 92       	push	r0
     78a:	2f 93       	push	r18
     78c:	3f 93       	push	r19
     78e:	4f 93       	push	r20
     790:	5f 93       	push	r21
     792:	6f 93       	push	r22
     794:	7f 93       	push	r23
     796:	8f 93       	push	r24
     798:	9f 93       	push	r25
     79a:	af 93       	push	r26
     79c:	bf 93       	push	r27
     79e:	ef 93       	push	r30
     7a0:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     7a2:	80 91 78 00 	lds	r24, 0x0078
     7a6:	80 93 b3 08 	sts	0x08B3, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     7aa:	80 91 79 00 	lds	r24, 0x0079
     7ae:	80 93 b4 08 	sts	0x08B4, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     7b2:	20 e0       	ldi	r18, 0x00	; 0
     7b4:	40 e0       	ldi	r20, 0x00	; 0
     7b6:	50 e0       	ldi	r21, 0x00	; 0
     7b8:	60 e0       	ldi	r22, 0x00	; 0
     7ba:	70 e0       	ldi	r23, 0x00	; 0
     7bc:	80 91 b7 08 	lds	r24, 0x08B7
     7c0:	90 91 b8 08 	lds	r25, 0x08B8
     7c4:	2a d6       	rcall	.+3156   	; 0x141a <xQueueGenericSendFromISR>
}
     7c6:	ff 91       	pop	r31
     7c8:	ef 91       	pop	r30
     7ca:	bf 91       	pop	r27
     7cc:	af 91       	pop	r26
     7ce:	9f 91       	pop	r25
     7d0:	8f 91       	pop	r24
     7d2:	7f 91       	pop	r23
     7d4:	6f 91       	pop	r22
     7d6:	5f 91       	pop	r21
     7d8:	4f 91       	pop	r20
     7da:	3f 91       	pop	r19
     7dc:	2f 91       	pop	r18
     7de:	0f 90       	pop	r0
     7e0:	0b be       	out	0x3b, r0	; 59
     7e2:	0f 90       	pop	r0
     7e4:	0f be       	out	0x3f, r0	; 63
     7e6:	0f 90       	pop	r0
     7e8:	1f 90       	pop	r1
     7ea:	18 95       	reti

000007ec <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     7ec:	8f e8       	ldi	r24, 0x8F	; 143
     7ee:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     7f2:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     7f6:	80 e4       	ldi	r24, 0x40	; 64
     7f8:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     7fc:	43 e0       	ldi	r20, 0x03	; 3
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	26 d5       	rcall	.+2636   	; 0x1250 <xQueueGenericCreate>
     804:	90 93 b8 08 	sts	0x08B8, r25
     808:	80 93 b7 08 	sts	0x08B7, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     80c:	81 e0       	ldi	r24, 0x01	; 1
     80e:	dd d5       	rcall	.+3002   	; 0x13ca <xQueueCreateMutex>
     810:	90 93 b6 08 	sts	0x08B6, r25
     814:	80 93 b5 08 	sts	0x08B5, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	40 e0       	ldi	r20, 0x00	; 0
     81c:	50 e0       	ldi	r21, 0x00	; 0
     81e:	60 e0       	ldi	r22, 0x00	; 0
     820:	70 e0       	ldi	r23, 0x00	; 0
     822:	40 c5       	rjmp	.+2688   	; 0x12a4 <xQueueGenericSend>
     824:	08 95       	ret

00000826 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     826:	cf 93       	push	r28
     828:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     82a:	20 e0       	ldi	r18, 0x00	; 0
     82c:	4f ef       	ldi	r20, 0xFF	; 255
     82e:	5f ef       	ldi	r21, 0xFF	; 255
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	70 e0       	ldi	r23, 0x00	; 0
     834:	80 91 b5 08 	lds	r24, 0x08B5
     838:	90 91 b6 08 	lds	r25, 0x08B6
     83c:	28 d6       	rcall	.+3152   	; 0x148e <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     83e:	ec e7       	ldi	r30, 0x7C	; 124
     840:	f0 e0       	ldi	r31, 0x00	; 0
     842:	80 81       	ld	r24, Z
     844:	9c 2f       	mov	r25, r28
     846:	9f 71       	andi	r25, 0x1F	; 31
     848:	80 76       	andi	r24, 0x60	; 96
     84a:	89 2b       	or	r24, r25
     84c:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     84e:	eb e7       	ldi	r30, 0x7B	; 123
     850:	f0 e0       	ldi	r31, 0x00	; 0
     852:	20 81       	ld	r18, Z
     854:	c0 72       	andi	r28, 0x20	; 32
     856:	8c 2f       	mov	r24, r28
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	95 95       	asr	r25
     85c:	87 95       	ror	r24
     85e:	95 95       	asr	r25
     860:	87 95       	ror	r24
     862:	92 2f       	mov	r25, r18
     864:	90 76       	andi	r25, 0x60	; 96
     866:	89 2b       	or	r24, r25
     868:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     86a:	ea e7       	ldi	r30, 0x7A	; 122
     86c:	f0 e0       	ldi	r31, 0x00	; 0
     86e:	80 81       	ld	r24, Z
     870:	80 64       	ori	r24, 0x40	; 64
     872:	80 83       	st	Z, r24
}
     874:	cf 91       	pop	r28
     876:	08 95       	ret

00000878 <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     878:	20 e0       	ldi	r18, 0x00	; 0
     87a:	4f ef       	ldi	r20, 0xFF	; 255
     87c:	5f ef       	ldi	r21, 0xFF	; 255
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	80 91 b7 08 	lds	r24, 0x08B7
     886:	90 91 b8 08 	lds	r25, 0x08B8
     88a:	01 d6       	rcall	.+3074   	; 0x148e <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     88c:	20 e0       	ldi	r18, 0x00	; 0
     88e:	40 e0       	ldi	r20, 0x00	; 0
     890:	50 e0       	ldi	r21, 0x00	; 0
     892:	60 e0       	ldi	r22, 0x00	; 0
     894:	70 e0       	ldi	r23, 0x00	; 0
     896:	80 91 b5 08 	lds	r24, 0x08B5
     89a:	90 91 b6 08 	lds	r25, 0x08B6
     89e:	02 d5       	rcall	.+2564   	; 0x12a4 <xQueueGenericSend>

	if(adcReading_H)
     8a0:	80 91 b4 08 	lds	r24, 0x08B4
     8a4:	81 11       	cpse	r24, r1
     8a6:	03 c0       	rjmp	.+6      	; 0x8ae <myADC_readADC+0x36>
	{
		return 0xFF; // return max reading if got high reading..
	}
	else
	{
			return adcReading_L; // return L bits reading dont need far distance...		
     8a8:	80 91 b3 08 	lds	r24, 0x08B3
     8ac:	08 95       	ret
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC

	if(adcReading_H)
	{
		return 0xFF; // return max reading if got high reading..
     8ae:	8f ef       	ldi	r24, 0xFF	; 255
	}
	else
	{
			return adcReading_L; // return L bits reading dont need far distance...		
	}
     8b0:	08 95       	ret

000008b2 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     8b2:	cf 93       	push	r28
     8b4:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     8b6:	b7 df       	rcall	.-146    	; 0x826 <myADC_startADC>
	return myADC_readADC(channel);
     8b8:	8c 2f       	mov	r24, r28
     8ba:	de df       	rcall	.-68     	; 0x878 <myADC_readADC>
}
     8bc:	cf 91       	pop	r28
     8be:	08 95       	ret

000008c0 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     8c0:	90 93 be 08 	sts	0x08BE, r25
     8c4:	80 93 bd 08 	sts	0x08BD, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     8c8:	fc 01       	movw	r30, r24
     8ca:	80 81       	ld	r24, Z
     8cc:	91 81       	ldd	r25, Z+1	; 0x01
     8ce:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     8d2:	43 e0       	ldi	r20, 0x03	; 3
     8d4:	60 e0       	ldi	r22, 0x00	; 0
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	bb d4       	rcall	.+2422   	; 0x1250 <xQueueGenericCreate>
     8da:	90 93 ba 08 	sts	0x08BA, r25
     8de:	80 93 b9 08 	sts	0x08B9, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     8e2:	43 e0       	ldi	r20, 0x03	; 3
     8e4:	60 e0       	ldi	r22, 0x00	; 0
     8e6:	81 e0       	ldi	r24, 0x01	; 1
     8e8:	b3 d4       	rcall	.+2406   	; 0x1250 <xQueueGenericCreate>
     8ea:	90 93 bc 08 	sts	0x08BC, r25
     8ee:	80 93 bb 08 	sts	0x08BB, r24
     8f2:	08 95       	ret

000008f4 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8f4:	86 b5       	in	r24, 0x26	; 38
}
     8f6:	08 95       	ret

000008f8 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     8f8:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     8fa:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     8fc:	9c 01       	movw	r18, r24
     8fe:	99 23       	and	r25, r25
     900:	14 f4       	brge	.+4      	; 0x906 <myTimer_DelayMicro+0xe>
     902:	2d 5f       	subi	r18, 0xFD	; 253
     904:	3f 4f       	sbci	r19, 0xFF	; 255
     906:	35 95       	asr	r19
     908:	27 95       	ror	r18
     90a:	35 95       	asr	r19
     90c:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     90e:	24 0f       	add	r18, r20
     910:	35 1f       	adc	r19, r21
     912:	30 93 03 02 	sts	0x0203, r19
     916:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     91a:	e0 91 bd 08 	lds	r30, 0x08BD
     91e:	f0 91 be 08 	lds	r31, 0x08BE
     922:	80 81       	ld	r24, Z
     924:	91 81       	ldd	r25, Z+1	; 0x01
     926:	0e 94 a3 0c 	call	0x1946	; 0x1946 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	42 e0       	ldi	r20, 0x02	; 2
     92e:	50 e0       	ldi	r21, 0x00	; 0
     930:	60 e0       	ldi	r22, 0x00	; 0
     932:	70 e0       	ldi	r23, 0x00	; 0
     934:	80 91 b9 08 	lds	r24, 0x08B9
     938:	90 91 ba 08 	lds	r25, 0x08BA
     93c:	a8 c5       	rjmp	.+2896   	; 0x148e <xQueueGenericReceive>
     93e:	08 95       	ret

00000940 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     940:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     942:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     944:	9c 01       	movw	r18, r24
     946:	99 23       	and	r25, r25
     948:	14 f4       	brge	.+4      	; 0x94e <myTimer_DelayMicro2+0xe>
     94a:	2d 5f       	subi	r18, 0xFD	; 253
     94c:	3f 4f       	sbci	r19, 0xFF	; 255
     94e:	35 95       	asr	r19
     950:	27 95       	ror	r18
     952:	35 95       	asr	r19
     954:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     956:	24 0f       	add	r18, r20
     958:	35 1f       	adc	r19, r21
     95a:	30 93 01 02 	sts	0x0201, r19
     95e:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     962:	e0 91 bd 08 	lds	r30, 0x08BD
     966:	f0 91 be 08 	lds	r31, 0x08BE
     96a:	80 81       	ld	r24, Z
     96c:	91 81       	ldd	r25, Z+1	; 0x01
     96e:	eb d7       	rcall	.+4054   	; 0x1946 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     970:	20 e0       	ldi	r18, 0x00	; 0
     972:	42 e0       	ldi	r20, 0x02	; 2
     974:	50 e0       	ldi	r21, 0x00	; 0
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	70 e0       	ldi	r23, 0x00	; 0
     97a:	80 91 bb 08 	lds	r24, 0x08BB
     97e:	90 91 bc 08 	lds	r25, 0x08BC
     982:	85 c5       	rjmp	.+2826   	; 0x148e <xQueueGenericReceive>
     984:	08 95       	ret

00000986 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     986:	cf 93       	push	r28
     988:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     98a:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     98c:	c1 11       	cpse	r28, r1
     98e:	22 c0       	rjmp	.+68     	; 0x9d4 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     990:	80 91 02 02 	lds	r24, 0x0202
     994:	90 91 03 02 	lds	r25, 0x0203
     998:	88 38       	cpi	r24, 0x88	; 136
     99a:	93 41       	sbci	r25, 0x13	; 19
     99c:	51 f0       	breq	.+20     	; 0x9b2 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     99e:	80 91 02 02 	lds	r24, 0x0202
     9a2:	90 91 03 02 	lds	r25, 0x0203
     9a6:	8a 5f       	subi	r24, 0xFA	; 250
     9a8:	91 09       	sbc	r25, r1
     9aa:	90 93 03 02 	sts	0x0203, r25
     9ae:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     9b2:	80 91 00 02 	lds	r24, 0x0200
     9b6:	90 91 01 02 	lds	r25, 0x0201
     9ba:	88 38       	cpi	r24, 0x88	; 136
     9bc:	93 41       	sbci	r25, 0x13	; 19
     9be:	51 f0       	breq	.+20     	; 0x9d4 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     9c0:	80 91 00 02 	lds	r24, 0x0200
     9c4:	90 91 01 02 	lds	r25, 0x0201
     9c8:	8a 5f       	subi	r24, 0xFA	; 250
     9ca:	91 09       	sbc	r25, r1
     9cc:	90 93 01 02 	sts	0x0201, r25
     9d0:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     9d4:	d0 e0       	ldi	r29, 0x00	; 0
     9d6:	80 91 02 02 	lds	r24, 0x0202
     9da:	90 91 03 02 	lds	r25, 0x0203
     9de:	8c 17       	cp	r24, r28
     9e0:	9d 07       	cpc	r25, r29
     9e2:	84 f4       	brge	.+32     	; 0xa04 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     9e4:	88 e8       	ldi	r24, 0x88	; 136
     9e6:	93 e1       	ldi	r25, 0x13	; 19
     9e8:	90 93 03 02 	sts	0x0203, r25
     9ec:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     9f0:	20 e0       	ldi	r18, 0x00	; 0
     9f2:	40 e0       	ldi	r20, 0x00	; 0
     9f4:	50 e0       	ldi	r21, 0x00	; 0
     9f6:	60 e0       	ldi	r22, 0x00	; 0
     9f8:	70 e0       	ldi	r23, 0x00	; 0
     9fa:	80 91 b9 08 	lds	r24, 0x08B9
     9fe:	90 91 ba 08 	lds	r25, 0x08BA
     a02:	50 d4       	rcall	.+2208   	; 0x12a4 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     a04:	80 91 00 02 	lds	r24, 0x0200
     a08:	90 91 01 02 	lds	r25, 0x0201
     a0c:	8c 17       	cp	r24, r28
     a0e:	9d 07       	cpc	r25, r29
     a10:	84 f4       	brge	.+32     	; 0xa32 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     a12:	88 e8       	ldi	r24, 0x88	; 136
     a14:	93 e1       	ldi	r25, 0x13	; 19
     a16:	90 93 01 02 	sts	0x0201, r25
     a1a:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     a1e:	20 e0       	ldi	r18, 0x00	; 0
     a20:	40 e0       	ldi	r20, 0x00	; 0
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	80 91 bb 08 	lds	r24, 0x08BB
     a2c:	90 91 bc 08 	lds	r25, 0x08BC
     a30:	39 d4       	rcall	.+2162   	; 0x12a4 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     a32:	80 91 02 02 	lds	r24, 0x0202
     a36:	90 91 03 02 	lds	r25, 0x0203
     a3a:	88 38       	cpi	r24, 0x88	; 136
     a3c:	93 41       	sbci	r25, 0x13	; 19
     a3e:	79 f4       	brne	.+30     	; 0xa5e <myTimer_DelayChecker+0xd8>
     a40:	80 91 00 02 	lds	r24, 0x0200
     a44:	90 91 01 02 	lds	r25, 0x0201
     a48:	88 38       	cpi	r24, 0x88	; 136
     a4a:	93 41       	sbci	r25, 0x13	; 19
     a4c:	41 f4       	brne	.+16     	; 0xa5e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     a4e:	e0 91 bd 08 	lds	r30, 0x08BD
     a52:	f0 91 be 08 	lds	r31, 0x08BE
     a56:	80 81       	ld	r24, Z
     a58:	91 81       	ldd	r25, Z+1	; 0x01
     a5a:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <vTaskSuspend>
	}
     a5e:	df 91       	pop	r29
     a60:	cf 91       	pop	r28
     a62:	08 95       	ret

00000a64 <__vector_36>:

	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     a64:	1f 92       	push	r1
     a66:	0f 92       	push	r0
     a68:	0f b6       	in	r0, 0x3f	; 63
     a6a:	0f 92       	push	r0
     a6c:	11 24       	eor	r1, r1
     a6e:	0b b6       	in	r0, 0x3b	; 59
     a70:	0f 92       	push	r0
     a72:	2f 93       	push	r18
     a74:	3f 93       	push	r19
     a76:	4f 93       	push	r20
     a78:	5f 93       	push	r21
     a7a:	6f 93       	push	r22
     a7c:	7f 93       	push	r23
     a7e:	8f 93       	push	r24
     a80:	9f 93       	push	r25
     a82:	af 93       	push	r26
     a84:	bf 93       	push	r27
     a86:	ef 93       	push	r30
     a88:	ff 93       	push	r31
     a8a:	60 91 ce 00 	lds	r22, 0x00CE
     a8e:	82 e5       	ldi	r24, 0x52	; 82
     a90:	99 e0       	ldi	r25, 0x09	; 9
     a92:	c9 d5       	rcall	.+2962   	; 0x1626 <ringBufferPush>
     a94:	20 e0       	ldi	r18, 0x00	; 0
     a96:	40 e0       	ldi	r20, 0x00	; 0
     a98:	50 e0       	ldi	r21, 0x00	; 0
     a9a:	60 e0       	ldi	r22, 0x00	; 0
     a9c:	70 e0       	ldi	r23, 0x00	; 0
     a9e:	80 91 46 09 	lds	r24, 0x0946
     aa2:	90 91 47 09 	lds	r25, 0x0947
     aa6:	b9 d4       	rcall	.+2418   	; 0x141a <xQueueGenericSendFromISR>
     aa8:	82 e5       	ldi	r24, 0x52	; 82
     aaa:	99 e0       	ldi	r25, 0x09	; 9
     aac:	d2 d5       	rcall	.+2980   	; 0x1652 <ringBufferFull>
     aae:	ff 91       	pop	r31
     ab0:	ef 91       	pop	r30
     ab2:	bf 91       	pop	r27
     ab4:	af 91       	pop	r26
     ab6:	9f 91       	pop	r25
     ab8:	8f 91       	pop	r24
     aba:	7f 91       	pop	r23
     abc:	6f 91       	pop	r22
     abe:	5f 91       	pop	r21
     ac0:	4f 91       	pop	r20
     ac2:	3f 91       	pop	r19
     ac4:	2f 91       	pop	r18
     ac6:	0f 90       	pop	r0
     ac8:	0b be       	out	0x3b, r0	; 59
     aca:	0f 90       	pop	r0
     acc:	0f be       	out	0x3f, r0	; 63
     ace:	0f 90       	pop	r0
     ad0:	1f 90       	pop	r1
     ad2:	18 95       	reti

00000ad4 <__vector_25>:
     ad4:	1f 92       	push	r1
     ad6:	0f 92       	push	r0
     ad8:	0f b6       	in	r0, 0x3f	; 63
     ada:	0f 92       	push	r0
     adc:	11 24       	eor	r1, r1
     ade:	0b b6       	in	r0, 0x3b	; 59
     ae0:	0f 92       	push	r0
     ae2:	2f 93       	push	r18
     ae4:	3f 93       	push	r19
     ae6:	4f 93       	push	r20
     ae8:	5f 93       	push	r21
     aea:	6f 93       	push	r22
     aec:	7f 93       	push	r23
     aee:	8f 93       	push	r24
     af0:	9f 93       	push	r25
     af2:	af 93       	push	r26
     af4:	bf 93       	push	r27
     af6:	ef 93       	push	r30
     af8:	ff 93       	push	r31
     afa:	60 91 c6 00 	lds	r22, 0x00C6
     afe:	8f ed       	ldi	r24, 0xDF	; 223
     b00:	98 e0       	ldi	r25, 0x08	; 8
     b02:	91 d5       	rcall	.+2850   	; 0x1626 <ringBufferPush>
     b04:	20 e0       	ldi	r18, 0x00	; 0
     b06:	40 e0       	ldi	r20, 0x00	; 0
     b08:	50 e0       	ldi	r21, 0x00	; 0
     b0a:	60 e0       	ldi	r22, 0x00	; 0
     b0c:	70 e0       	ldi	r23, 0x00	; 0
     b0e:	80 91 46 09 	lds	r24, 0x0946
     b12:	90 91 47 09 	lds	r25, 0x0947
     b16:	81 d4       	rcall	.+2306   	; 0x141a <xQueueGenericSendFromISR>
     b18:	8f ed       	ldi	r24, 0xDF	; 223
     b1a:	98 e0       	ldi	r25, 0x08	; 8
     b1c:	9a d5       	rcall	.+2868   	; 0x1652 <ringBufferFull>
     b1e:	ff 91       	pop	r31
     b20:	ef 91       	pop	r30
     b22:	bf 91       	pop	r27
     b24:	af 91       	pop	r26
     b26:	9f 91       	pop	r25
     b28:	8f 91       	pop	r24
     b2a:	7f 91       	pop	r23
     b2c:	6f 91       	pop	r22
     b2e:	5f 91       	pop	r21
     b30:	4f 91       	pop	r20
     b32:	3f 91       	pop	r19
     b34:	2f 91       	pop	r18
     b36:	0f 90       	pop	r0
     b38:	0b be       	out	0x3b, r0	; 59
     b3a:	0f 90       	pop	r0
     b3c:	0f be       	out	0x3f, r0	; 63
     b3e:	0f 90       	pop	r0
     b40:	1f 90       	pop	r1
     b42:	18 95       	reti

00000b44 <__vector_37>:
     b44:	1f 92       	push	r1
     b46:	0f 92       	push	r0
     b48:	0f b6       	in	r0, 0x3f	; 63
     b4a:	0f 92       	push	r0
     b4c:	11 24       	eor	r1, r1
     b4e:	0b b6       	in	r0, 0x3b	; 59
     b50:	0f 92       	push	r0
     b52:	2f 93       	push	r18
     b54:	3f 93       	push	r19
     b56:	4f 93       	push	r20
     b58:	5f 93       	push	r21
     b5a:	6f 93       	push	r22
     b5c:	7f 93       	push	r23
     b5e:	8f 93       	push	r24
     b60:	9f 93       	push	r25
     b62:	af 93       	push	r26
     b64:	bf 93       	push	r27
     b66:	ef 93       	push	r30
     b68:	ff 93       	push	r31
     b6a:	88 e4       	ldi	r24, 0x48	; 72
     b6c:	99 e0       	ldi	r25, 0x09	; 9
     b6e:	78 d5       	rcall	.+2800   	; 0x1660 <ringBufferNotEmpty>
     b70:	88 23       	and	r24, r24
     b72:	31 f0       	breq	.+12     	; 0xb80 <__vector_37+0x3c>
     b74:	88 e4       	ldi	r24, 0x48	; 72
     b76:	99 e0       	ldi	r25, 0x09	; 9
     b78:	44 d5       	rcall	.+2696   	; 0x1602 <ringBufferPop>
     b7a:	80 93 ce 00 	sts	0x00CE, r24
     b7e:	05 c0       	rjmp	.+10     	; 0xb8a <__vector_37+0x46>
     b80:	e9 ec       	ldi	r30, 0xC9	; 201
     b82:	f0 e0       	ldi	r31, 0x00	; 0
     b84:	80 81       	ld	r24, Z
     b86:	8f 7d       	andi	r24, 0xDF	; 223
     b88:	80 83       	st	Z, r24
     b8a:	ff 91       	pop	r31
     b8c:	ef 91       	pop	r30
     b8e:	bf 91       	pop	r27
     b90:	af 91       	pop	r26
     b92:	9f 91       	pop	r25
     b94:	8f 91       	pop	r24
     b96:	7f 91       	pop	r23
     b98:	6f 91       	pop	r22
     b9a:	5f 91       	pop	r21
     b9c:	4f 91       	pop	r20
     b9e:	3f 91       	pop	r19
     ba0:	2f 91       	pop	r18
     ba2:	0f 90       	pop	r0
     ba4:	0b be       	out	0x3b, r0	; 59
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	0f 90       	pop	r0
     bac:	1f 90       	pop	r1
     bae:	18 95       	reti

00000bb0 <__vector_26>:
     bb0:	1f 92       	push	r1
     bb2:	0f 92       	push	r0
     bb4:	0f b6       	in	r0, 0x3f	; 63
     bb6:	0f 92       	push	r0
     bb8:	11 24       	eor	r1, r1
     bba:	0b b6       	in	r0, 0x3b	; 59
     bbc:	0f 92       	push	r0
     bbe:	2f 93       	push	r18
     bc0:	3f 93       	push	r19
     bc2:	4f 93       	push	r20
     bc4:	5f 93       	push	r21
     bc6:	6f 93       	push	r22
     bc8:	7f 93       	push	r23
     bca:	8f 93       	push	r24
     bcc:	9f 93       	push	r25
     bce:	af 93       	push	r26
     bd0:	bf 93       	push	r27
     bd2:	ef 93       	push	r30
     bd4:	ff 93       	push	r31
     bd6:	8d e4       	ldi	r24, 0x4D	; 77
     bd8:	99 e0       	ldi	r25, 0x09	; 9
     bda:	42 d5       	rcall	.+2692   	; 0x1660 <ringBufferNotEmpty>
     bdc:	88 23       	and	r24, r24
     bde:	31 f0       	breq	.+12     	; 0xbec <__vector_26+0x3c>
     be0:	8d e4       	ldi	r24, 0x4D	; 77
     be2:	99 e0       	ldi	r25, 0x09	; 9
     be4:	0e d5       	rcall	.+2588   	; 0x1602 <ringBufferPop>
     be6:	80 93 c6 00 	sts	0x00C6, r24
     bea:	05 c0       	rjmp	.+10     	; 0xbf6 <__vector_26+0x46>
     bec:	e1 ec       	ldi	r30, 0xC1	; 193
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	80 81       	ld	r24, Z
     bf2:	8f 7d       	andi	r24, 0xDF	; 223
     bf4:	80 83       	st	Z, r24
     bf6:	ff 91       	pop	r31
     bf8:	ef 91       	pop	r30
     bfa:	bf 91       	pop	r27
     bfc:	af 91       	pop	r26
     bfe:	9f 91       	pop	r25
     c00:	8f 91       	pop	r24
     c02:	7f 91       	pop	r23
     c04:	6f 91       	pop	r22
     c06:	5f 91       	pop	r21
     c08:	4f 91       	pop	r20
     c0a:	3f 91       	pop	r19
     c0c:	2f 91       	pop	r18
     c0e:	0f 90       	pop	r0
     c10:	0b be       	out	0x3b, r0	; 59
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
     c16:	0f 90       	pop	r0
     c18:	1f 90       	pop	r1
     c1a:	18 95       	reti

00000c1c <myUSART_USART0_Init>:
     c1c:	10 92 c5 00 	sts	0x00C5, r1
     c20:	87 e6       	ldi	r24, 0x67	; 103
     c22:	80 93 c4 00 	sts	0x00C4, r24
     c26:	88 eb       	ldi	r24, 0xB8	; 184
     c28:	80 93 c1 00 	sts	0x00C1, r24
     c2c:	86 e0       	ldi	r24, 0x06	; 6
     c2e:	80 93 c2 00 	sts	0x00C2, r24
     c32:	40 e2       	ldi	r20, 0x20	; 32
     c34:	64 e0       	ldi	r22, 0x04	; 4
     c36:	79 e0       	ldi	r23, 0x09	; 9
     c38:	8f ed       	ldi	r24, 0xDF	; 223
     c3a:	98 e0       	ldi	r25, 0x08	; 8
     c3c:	db d4       	rcall	.+2486   	; 0x15f4 <ringBufferInit>
     c3e:	40 e2       	ldi	r20, 0x20	; 32
     c40:	64 ee       	ldi	r22, 0xE4	; 228
     c42:	78 e0       	ldi	r23, 0x08	; 8
     c44:	8d e4       	ldi	r24, 0x4D	; 77
     c46:	99 e0       	ldi	r25, 0x09	; 9
     c48:	d5 d4       	rcall	.+2474   	; 0x15f4 <ringBufferInit>
     c4a:	43 e0       	ldi	r20, 0x03	; 3
     c4c:	60 e0       	ldi	r22, 0x00	; 0
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	ff d2       	rcall	.+1534   	; 0x1250 <xQueueGenericCreate>
     c52:	90 93 45 09 	sts	0x0945, r25
     c56:	80 93 44 09 	sts	0x0944, r24
     c5a:	08 95       	ret

00000c5c <myUSART_USART1_Init>:
     c5c:	10 92 cd 00 	sts	0x00CD, r1
     c60:	87 e6       	ldi	r24, 0x67	; 103
     c62:	80 93 cc 00 	sts	0x00CC, r24
     c66:	88 eb       	ldi	r24, 0xB8	; 184
     c68:	80 93 c9 00 	sts	0x00C9, r24
     c6c:	86 e0       	ldi	r24, 0x06	; 6
     c6e:	80 93 ca 00 	sts	0x00CA, r24
     c72:	40 e2       	ldi	r20, 0x20	; 32
     c74:	6f eb       	ldi	r22, 0xBF	; 191
     c76:	78 e0       	ldi	r23, 0x08	; 8
     c78:	82 e5       	ldi	r24, 0x52	; 82
     c7a:	99 e0       	ldi	r25, 0x09	; 9
     c7c:	bb d4       	rcall	.+2422   	; 0x15f4 <ringBufferInit>
     c7e:	40 e2       	ldi	r20, 0x20	; 32
     c80:	64 e2       	ldi	r22, 0x24	; 36
     c82:	79 e0       	ldi	r23, 0x09	; 9
     c84:	88 e4       	ldi	r24, 0x48	; 72
     c86:	99 e0       	ldi	r25, 0x09	; 9
     c88:	b5 d4       	rcall	.+2410   	; 0x15f4 <ringBufferInit>
     c8a:	43 e0       	ldi	r20, 0x03	; 3
     c8c:	60 e0       	ldi	r22, 0x00	; 0
     c8e:	81 e0       	ldi	r24, 0x01	; 1
     c90:	df d2       	rcall	.+1470   	; 0x1250 <xQueueGenericCreate>
     c92:	90 93 47 09 	sts	0x0947, r25
     c96:	80 93 46 09 	sts	0x0946, r24
     c9a:	08 95       	ret

00000c9c <myUSART_transmitUSART0_c>:
     c9c:	cf 93       	push	r28
     c9e:	c8 2f       	mov	r28, r24
     ca0:	8d e4       	ldi	r24, 0x4D	; 77
     ca2:	99 e0       	ldi	r25, 0x09	; 9
     ca4:	d6 d4       	rcall	.+2476   	; 0x1652 <ringBufferFull>
     ca6:	81 11       	cpse	r24, r1
     ca8:	fb cf       	rjmp	.-10     	; 0xca0 <myUSART_transmitUSART0_c+0x4>
     caa:	6c 2f       	mov	r22, r28
     cac:	8d e4       	ldi	r24, 0x4D	; 77
     cae:	99 e0       	ldi	r25, 0x09	; 9
     cb0:	ba d4       	rcall	.+2420   	; 0x1626 <ringBufferPush>
     cb2:	e1 ec       	ldi	r30, 0xC1	; 193
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	80 81       	ld	r24, Z
     cb8:	80 62       	ori	r24, 0x20	; 32
     cba:	80 83       	st	Z, r24
     cbc:	e0 ec       	ldi	r30, 0xC0	; 192
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	80 81       	ld	r24, Z
     cc2:	80 64       	ori	r24, 0x40	; 64
     cc4:	80 83       	st	Z, r24
     cc6:	cf 91       	pop	r28
     cc8:	08 95       	ret

00000cca <myUSART_transmitUSART1_c>:
     cca:	cf 93       	push	r28
     ccc:	c8 2f       	mov	r28, r24
     cce:	88 e4       	ldi	r24, 0x48	; 72
     cd0:	99 e0       	ldi	r25, 0x09	; 9
     cd2:	bf d4       	rcall	.+2430   	; 0x1652 <ringBufferFull>
     cd4:	81 11       	cpse	r24, r1
     cd6:	fb cf       	rjmp	.-10     	; 0xcce <myUSART_transmitUSART1_c+0x4>
     cd8:	6c 2f       	mov	r22, r28
     cda:	88 e4       	ldi	r24, 0x48	; 72
     cdc:	99 e0       	ldi	r25, 0x09	; 9
     cde:	a3 d4       	rcall	.+2374   	; 0x1626 <ringBufferPush>
     ce0:	e9 ec       	ldi	r30, 0xC9	; 201
     ce2:	f0 e0       	ldi	r31, 0x00	; 0
     ce4:	80 81       	ld	r24, Z
     ce6:	80 62       	ori	r24, 0x20	; 32
     ce8:	80 83       	st	Z, r24
     cea:	e8 ec       	ldi	r30, 0xC8	; 200
     cec:	f0 e0       	ldi	r31, 0x00	; 0
     cee:	80 81       	ld	r24, Z
     cf0:	80 64       	ori	r24, 0x40	; 64
     cf2:	80 83       	st	Z, r24
     cf4:	cf 91       	pop	r28
     cf6:	08 95       	ret

00000cf8 <myUSART_transmitUSART0>:
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	ec 01       	movw	r28, r24
     cfe:	88 81       	ld	r24, Y
     d00:	88 23       	and	r24, r24
     d02:	29 f0       	breq	.+10     	; 0xd0e <myUSART_transmitUSART0+0x16>
     d04:	21 96       	adiw	r28, 0x01	; 1
     d06:	ca df       	rcall	.-108    	; 0xc9c <myUSART_transmitUSART0_c>
     d08:	89 91       	ld	r24, Y+
     d0a:	81 11       	cpse	r24, r1
     d0c:	fc cf       	rjmp	.-8      	; 0xd06 <myUSART_transmitUSART0+0xe>
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	08 95       	ret

00000d14 <myUSART_receiveUSART1>:
     d14:	cf 93       	push	r28
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	4f ef       	ldi	r20, 0xFF	; 255
     d1a:	5f ef       	ldi	r21, 0xFF	; 255
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	70 e0       	ldi	r23, 0x00	; 0
     d20:	80 91 44 09 	lds	r24, 0x0944
     d24:	90 91 45 09 	lds	r25, 0x0945
     d28:	b2 d3       	rcall	.+1892   	; 0x148e <xQueueGenericReceive>
     d2a:	82 e5       	ldi	r24, 0x52	; 82
     d2c:	99 e0       	ldi	r25, 0x09	; 9
     d2e:	69 d4       	rcall	.+2258   	; 0x1602 <ringBufferPop>
     d30:	c8 2f       	mov	r28, r24
     d32:	82 e5       	ldi	r24, 0x52	; 82
     d34:	99 e0       	ldi	r25, 0x09	; 9
     d36:	94 d4       	rcall	.+2344   	; 0x1660 <ringBufferNotEmpty>
     d38:	88 23       	and	r24, r24
     d3a:	51 f0       	breq	.+20     	; 0xd50 <myUSART_receiveUSART1+0x3c>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	40 e0       	ldi	r20, 0x00	; 0
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	60 e0       	ldi	r22, 0x00	; 0
     d44:	70 e0       	ldi	r23, 0x00	; 0
     d46:	80 91 44 09 	lds	r24, 0x0944
     d4a:	90 91 45 09 	lds	r25, 0x0945
     d4e:	aa d2       	rcall	.+1364   	; 0x12a4 <xQueueGenericSend>
     d50:	8c 2f       	mov	r24, r28
     d52:	cf 91       	pop	r28
     d54:	08 95       	ret

00000d56 <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d56:	de df       	rcall	.-68     	; 0xd14 <myUSART_receiveUSART1>
     d58:	81 11       	cpse	r24, r1
     d5a:	0a c0       	rjmp	.+20     	; 0xd70 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     d5c:	85 e5       	ldi	r24, 0x55	; 85
     d5e:	b5 df       	rcall	.-150    	; 0xcca <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     d60:	d9 df       	rcall	.-78     	; 0xd14 <myUSART_receiveUSART1>
     d62:	91 e0       	ldi	r25, 0x01	; 1
     d64:	81 11       	cpse	r24, r1
     d66:	01 c0       	rjmp	.+2      	; 0xd6a <myUSART_waitForHandshake+0x14>
     d68:	90 e0       	ldi	r25, 0x00	; 0
     d6a:	89 2f       	mov	r24, r25
     d6c:	81 95       	neg	r24
     d6e:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     d70:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     d72:	08 95       	ret

00000d74 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d74:	31 e1       	ldi	r19, 0x11	; 17
     d76:	fc 01       	movw	r30, r24
     d78:	30 83       	st	Z, r19
     d7a:	31 97       	sbiw	r30, 0x01	; 1
     d7c:	22 e2       	ldi	r18, 0x22	; 34
     d7e:	20 83       	st	Z, r18
     d80:	31 97       	sbiw	r30, 0x01	; 1
     d82:	a3 e3       	ldi	r26, 0x33	; 51
     d84:	a0 83       	st	Z, r26
     d86:	31 97       	sbiw	r30, 0x01	; 1
     d88:	60 83       	st	Z, r22
     d8a:	31 97       	sbiw	r30, 0x01	; 1
     d8c:	70 83       	st	Z, r23
     d8e:	31 97       	sbiw	r30, 0x01	; 1
     d90:	10 82       	st	Z, r1
     d92:	31 97       	sbiw	r30, 0x01	; 1
     d94:	10 82       	st	Z, r1
     d96:	31 97       	sbiw	r30, 0x01	; 1
     d98:	60 e8       	ldi	r22, 0x80	; 128
     d9a:	60 83       	st	Z, r22
     d9c:	31 97       	sbiw	r30, 0x01	; 1
     d9e:	10 82       	st	Z, r1
     da0:	31 97       	sbiw	r30, 0x01	; 1
     da2:	10 82       	st	Z, r1
     da4:	31 97       	sbiw	r30, 0x01	; 1
     da6:	10 82       	st	Z, r1
     da8:	31 97       	sbiw	r30, 0x01	; 1
     daa:	62 e0       	ldi	r22, 0x02	; 2
     dac:	60 83       	st	Z, r22
     dae:	31 97       	sbiw	r30, 0x01	; 1
     db0:	63 e0       	ldi	r22, 0x03	; 3
     db2:	60 83       	st	Z, r22
     db4:	31 97       	sbiw	r30, 0x01	; 1
     db6:	64 e0       	ldi	r22, 0x04	; 4
     db8:	60 83       	st	Z, r22
     dba:	31 97       	sbiw	r30, 0x01	; 1
     dbc:	65 e0       	ldi	r22, 0x05	; 5
     dbe:	60 83       	st	Z, r22
     dc0:	31 97       	sbiw	r30, 0x01	; 1
     dc2:	66 e0       	ldi	r22, 0x06	; 6
     dc4:	60 83       	st	Z, r22
     dc6:	31 97       	sbiw	r30, 0x01	; 1
     dc8:	67 e0       	ldi	r22, 0x07	; 7
     dca:	60 83       	st	Z, r22
     dcc:	31 97       	sbiw	r30, 0x01	; 1
     dce:	68 e0       	ldi	r22, 0x08	; 8
     dd0:	60 83       	st	Z, r22
     dd2:	31 97       	sbiw	r30, 0x01	; 1
     dd4:	69 e0       	ldi	r22, 0x09	; 9
     dd6:	60 83       	st	Z, r22
     dd8:	31 97       	sbiw	r30, 0x01	; 1
     dda:	60 e1       	ldi	r22, 0x10	; 16
     ddc:	60 83       	st	Z, r22
     dde:	31 97       	sbiw	r30, 0x01	; 1
     de0:	30 83       	st	Z, r19
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	32 e1       	ldi	r19, 0x12	; 18
     de6:	30 83       	st	Z, r19
     de8:	31 97       	sbiw	r30, 0x01	; 1
     dea:	33 e1       	ldi	r19, 0x13	; 19
     dec:	30 83       	st	Z, r19
     dee:	31 97       	sbiw	r30, 0x01	; 1
     df0:	34 e1       	ldi	r19, 0x14	; 20
     df2:	30 83       	st	Z, r19
     df4:	31 97       	sbiw	r30, 0x01	; 1
     df6:	35 e1       	ldi	r19, 0x15	; 21
     df8:	30 83       	st	Z, r19
     dfa:	31 97       	sbiw	r30, 0x01	; 1
     dfc:	36 e1       	ldi	r19, 0x16	; 22
     dfe:	30 83       	st	Z, r19
     e00:	31 97       	sbiw	r30, 0x01	; 1
     e02:	37 e1       	ldi	r19, 0x17	; 23
     e04:	30 83       	st	Z, r19
     e06:	31 97       	sbiw	r30, 0x01	; 1
     e08:	38 e1       	ldi	r19, 0x18	; 24
     e0a:	30 83       	st	Z, r19
     e0c:	31 97       	sbiw	r30, 0x01	; 1
     e0e:	39 e1       	ldi	r19, 0x19	; 25
     e10:	30 83       	st	Z, r19
     e12:	31 97       	sbiw	r30, 0x01	; 1
     e14:	30 e2       	ldi	r19, 0x20	; 32
     e16:	30 83       	st	Z, r19
     e18:	31 97       	sbiw	r30, 0x01	; 1
     e1a:	31 e2       	ldi	r19, 0x21	; 33
     e1c:	30 83       	st	Z, r19
     e1e:	31 97       	sbiw	r30, 0x01	; 1
     e20:	20 83       	st	Z, r18
     e22:	31 97       	sbiw	r30, 0x01	; 1
     e24:	23 e2       	ldi	r18, 0x23	; 35
     e26:	20 83       	st	Z, r18
     e28:	31 97       	sbiw	r30, 0x01	; 1
     e2a:	40 83       	st	Z, r20
     e2c:	31 97       	sbiw	r30, 0x01	; 1
     e2e:	50 83       	st	Z, r21
     e30:	31 97       	sbiw	r30, 0x01	; 1
     e32:	26 e2       	ldi	r18, 0x26	; 38
     e34:	20 83       	st	Z, r18
     e36:	31 97       	sbiw	r30, 0x01	; 1
     e38:	27 e2       	ldi	r18, 0x27	; 39
     e3a:	20 83       	st	Z, r18
     e3c:	31 97       	sbiw	r30, 0x01	; 1
     e3e:	28 e2       	ldi	r18, 0x28	; 40
     e40:	20 83       	st	Z, r18
     e42:	31 97       	sbiw	r30, 0x01	; 1
     e44:	29 e2       	ldi	r18, 0x29	; 41
     e46:	20 83       	st	Z, r18
     e48:	31 97       	sbiw	r30, 0x01	; 1
     e4a:	20 e3       	ldi	r18, 0x30	; 48
     e4c:	20 83       	st	Z, r18
     e4e:	31 97       	sbiw	r30, 0x01	; 1
     e50:	21 e3       	ldi	r18, 0x31	; 49
     e52:	20 83       	st	Z, r18
     e54:	89 97       	sbiw	r24, 0x29	; 41
     e56:	08 95       	ret

00000e58 <xPortStartScheduler>:
     e58:	82 e0       	ldi	r24, 0x02	; 2
     e5a:	84 bd       	out	0x24, r24	; 36
     e5c:	16 bc       	out	0x26, r1	; 38
     e5e:	80 e3       	ldi	r24, 0x30	; 48
     e60:	87 bd       	out	0x27, r24	; 39
     e62:	ee e6       	ldi	r30, 0x6E	; 110
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	82 60       	ori	r24, 0x02	; 2
     e6a:	80 83       	st	Z, r24
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	85 bd       	out	0x25, r24	; 37
     e70:	a0 91 9f 08 	lds	r26, 0x089F
     e74:	b0 91 a0 08 	lds	r27, 0x08A0
     e78:	cd 91       	ld	r28, X+
     e7a:	cd bf       	out	0x3d, r28	; 61
     e7c:	dd 91       	ld	r29, X+
     e7e:	de bf       	out	0x3e, r29	; 62
     e80:	ff 91       	pop	r31
     e82:	ef 91       	pop	r30
     e84:	df 91       	pop	r29
     e86:	cf 91       	pop	r28
     e88:	bf 91       	pop	r27
     e8a:	af 91       	pop	r26
     e8c:	9f 91       	pop	r25
     e8e:	8f 91       	pop	r24
     e90:	7f 91       	pop	r23
     e92:	6f 91       	pop	r22
     e94:	5f 91       	pop	r21
     e96:	4f 91       	pop	r20
     e98:	3f 91       	pop	r19
     e9a:	2f 91       	pop	r18
     e9c:	1f 91       	pop	r17
     e9e:	0f 91       	pop	r16
     ea0:	ff 90       	pop	r15
     ea2:	ef 90       	pop	r14
     ea4:	df 90       	pop	r13
     ea6:	cf 90       	pop	r12
     ea8:	bf 90       	pop	r11
     eaa:	af 90       	pop	r10
     eac:	9f 90       	pop	r9
     eae:	8f 90       	pop	r8
     eb0:	7f 90       	pop	r7
     eb2:	6f 90       	pop	r6
     eb4:	5f 90       	pop	r5
     eb6:	4f 90       	pop	r4
     eb8:	3f 90       	pop	r3
     eba:	2f 90       	pop	r2
     ebc:	1f 90       	pop	r1
     ebe:	0f 90       	pop	r0
     ec0:	0c be       	out	0x3c, r0	; 60
     ec2:	0f 90       	pop	r0
     ec4:	0b be       	out	0x3b, r0	; 59
     ec6:	0f 90       	pop	r0
     ec8:	0f be       	out	0x3f, r0	; 63
     eca:	0f 90       	pop	r0
     ecc:	08 95       	ret
     ece:	81 e0       	ldi	r24, 0x01	; 1
     ed0:	08 95       	ret

00000ed2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ed2:	0f 92       	push	r0
     ed4:	0f b6       	in	r0, 0x3f	; 63
     ed6:	f8 94       	cli
     ed8:	0f 92       	push	r0
     eda:	0b b6       	in	r0, 0x3b	; 59
     edc:	0f 92       	push	r0
     ede:	0c b6       	in	r0, 0x3c	; 60
     ee0:	0f 92       	push	r0
     ee2:	1f 92       	push	r1
     ee4:	11 24       	eor	r1, r1
     ee6:	2f 92       	push	r2
     ee8:	3f 92       	push	r3
     eea:	4f 92       	push	r4
     eec:	5f 92       	push	r5
     eee:	6f 92       	push	r6
     ef0:	7f 92       	push	r7
     ef2:	8f 92       	push	r8
     ef4:	9f 92       	push	r9
     ef6:	af 92       	push	r10
     ef8:	bf 92       	push	r11
     efa:	cf 92       	push	r12
     efc:	df 92       	push	r13
     efe:	ef 92       	push	r14
     f00:	ff 92       	push	r15
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	2f 93       	push	r18
     f08:	3f 93       	push	r19
     f0a:	4f 93       	push	r20
     f0c:	5f 93       	push	r21
     f0e:	6f 93       	push	r22
     f10:	7f 93       	push	r23
     f12:	8f 93       	push	r24
     f14:	9f 93       	push	r25
     f16:	af 93       	push	r26
     f18:	bf 93       	push	r27
     f1a:	cf 93       	push	r28
     f1c:	df 93       	push	r29
     f1e:	ef 93       	push	r30
     f20:	ff 93       	push	r31
     f22:	a0 91 9f 08 	lds	r26, 0x089F
     f26:	b0 91 a0 08 	lds	r27, 0x08A0
     f2a:	0d b6       	in	r0, 0x3d	; 61
     f2c:	0d 92       	st	X+, r0
     f2e:	0e b6       	in	r0, 0x3e	; 62
     f30:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f32:	64 d7       	rcall	.+3784   	; 0x1dfc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f34:	a0 91 9f 08 	lds	r26, 0x089F
     f38:	b0 91 a0 08 	lds	r27, 0x08A0
     f3c:	cd 91       	ld	r28, X+
     f3e:	cd bf       	out	0x3d, r28	; 61
     f40:	dd 91       	ld	r29, X+
     f42:	de bf       	out	0x3e, r29	; 62
     f44:	ff 91       	pop	r31
     f46:	ef 91       	pop	r30
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	bf 91       	pop	r27
     f4e:	af 91       	pop	r26
     f50:	9f 91       	pop	r25
     f52:	8f 91       	pop	r24
     f54:	7f 91       	pop	r23
     f56:	6f 91       	pop	r22
     f58:	5f 91       	pop	r21
     f5a:	4f 91       	pop	r20
     f5c:	3f 91       	pop	r19
     f5e:	2f 91       	pop	r18
     f60:	1f 91       	pop	r17
     f62:	0f 91       	pop	r16
     f64:	ff 90       	pop	r15
     f66:	ef 90       	pop	r14
     f68:	df 90       	pop	r13
     f6a:	cf 90       	pop	r12
     f6c:	bf 90       	pop	r11
     f6e:	af 90       	pop	r10
     f70:	9f 90       	pop	r9
     f72:	8f 90       	pop	r8
     f74:	7f 90       	pop	r7
     f76:	6f 90       	pop	r6
     f78:	5f 90       	pop	r5
     f7a:	4f 90       	pop	r4
     f7c:	3f 90       	pop	r3
     f7e:	2f 90       	pop	r2
     f80:	1f 90       	pop	r1
     f82:	0f 90       	pop	r0
     f84:	0c be       	out	0x3c, r0	; 60
     f86:	0f 90       	pop	r0
     f88:	0b be       	out	0x3b, r0	; 59
     f8a:	0f 90       	pop	r0
     f8c:	0f be       	out	0x3f, r0	; 63
     f8e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f90:	08 95       	ret

00000f92 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f92:	0f 92       	push	r0
     f94:	0f b6       	in	r0, 0x3f	; 63
     f96:	f8 94       	cli
     f98:	0f 92       	push	r0
     f9a:	0b b6       	in	r0, 0x3b	; 59
     f9c:	0f 92       	push	r0
     f9e:	0c b6       	in	r0, 0x3c	; 60
     fa0:	0f 92       	push	r0
     fa2:	1f 92       	push	r1
     fa4:	11 24       	eor	r1, r1
     fa6:	2f 92       	push	r2
     fa8:	3f 92       	push	r3
     faa:	4f 92       	push	r4
     fac:	5f 92       	push	r5
     fae:	6f 92       	push	r6
     fb0:	7f 92       	push	r7
     fb2:	8f 92       	push	r8
     fb4:	9f 92       	push	r9
     fb6:	af 92       	push	r10
     fb8:	bf 92       	push	r11
     fba:	cf 92       	push	r12
     fbc:	df 92       	push	r13
     fbe:	ef 92       	push	r14
     fc0:	ff 92       	push	r15
     fc2:	0f 93       	push	r16
     fc4:	1f 93       	push	r17
     fc6:	2f 93       	push	r18
     fc8:	3f 93       	push	r19
     fca:	4f 93       	push	r20
     fcc:	5f 93       	push	r21
     fce:	6f 93       	push	r22
     fd0:	7f 93       	push	r23
     fd2:	8f 93       	push	r24
     fd4:	9f 93       	push	r25
     fd6:	af 93       	push	r26
     fd8:	bf 93       	push	r27
     fda:	cf 93       	push	r28
     fdc:	df 93       	push	r29
     fde:	ef 93       	push	r30
     fe0:	ff 93       	push	r31
     fe2:	a0 91 9f 08 	lds	r26, 0x089F
     fe6:	b0 91 a0 08 	lds	r27, 0x08A0
     fea:	0d b6       	in	r0, 0x3d	; 61
     fec:	0d 92       	st	X+, r0
     fee:	0e b6       	in	r0, 0x3e	; 62
     ff0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     ff2:	32 d5       	rcall	.+2660   	; 0x1a58 <xTaskIncrementTick>
     ff4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ff6:	02 d7       	rcall	.+3588   	; 0x1dfc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     ff8:	a0 91 9f 08 	lds	r26, 0x089F
     ffc:	b0 91 a0 08 	lds	r27, 0x08A0
    1000:	cd 91       	ld	r28, X+
    1002:	cd bf       	out	0x3d, r28	; 61
    1004:	dd 91       	ld	r29, X+
    1006:	de bf       	out	0x3e, r29	; 62
    1008:	ff 91       	pop	r31
    100a:	ef 91       	pop	r30
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	bf 91       	pop	r27
    1012:	af 91       	pop	r26
    1014:	9f 91       	pop	r25
    1016:	8f 91       	pop	r24
    1018:	7f 91       	pop	r23
    101a:	6f 91       	pop	r22
    101c:	5f 91       	pop	r21
    101e:	4f 91       	pop	r20
    1020:	3f 91       	pop	r19
    1022:	2f 91       	pop	r18
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	df 90       	pop	r13
    102e:	cf 90       	pop	r12
    1030:	bf 90       	pop	r11
    1032:	af 90       	pop	r10
    1034:	9f 90       	pop	r9
    1036:	8f 90       	pop	r8
    1038:	7f 90       	pop	r7
    103a:	6f 90       	pop	r6
    103c:	5f 90       	pop	r5
    103e:	4f 90       	pop	r4
    1040:	3f 90       	pop	r3
    1042:	2f 90       	pop	r2
    1044:	1f 90       	pop	r1
    1046:	0f 90       	pop	r0
    1048:	0c be       	out	0x3c, r0	; 60
    104a:	0f 90       	pop	r0
    104c:	0b be       	out	0x3b, r0	; 59
    104e:	0f 90       	pop	r0
    1050:	0f be       	out	0x3f, r0	; 63
    1052:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1054:	08 95       	ret

00001056 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1056:	9d df       	rcall	.-198    	; 0xf92 <vPortYieldFromTick>
		 asm volatile ("reti");
    1058:	18 95       	reti

0000105a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    105a:	1f 93       	push	r17
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	ec 01       	movw	r28, r24
    1062:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1064:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1066:	81 11       	cpse	r24, r1
    1068:	0c c0       	rjmp	.+24     	; 0x1082 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    106a:	88 81       	ld	r24, Y
    106c:	99 81       	ldd	r25, Y+1	; 0x01
    106e:	89 2b       	or	r24, r25
    1070:	09 f0       	breq	.+2      	; 0x1074 <prvCopyDataToQueue+0x1a>
    1072:	47 c0       	rjmp	.+142    	; 0x1102 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	9b 81       	ldd	r25, Y+3	; 0x03
    1078:	0e 94 c1 10 	call	0x2182	; 0x2182 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    107c:	1b 82       	std	Y+3, r1	; 0x03
    107e:	1a 82       	std	Y+2, r1	; 0x02
    1080:	47 c0       	rjmp	.+142    	; 0x1110 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1082:	41 11       	cpse	r20, r1
    1084:	18 c0       	rjmp	.+48     	; 0x10b6 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1086:	48 2f       	mov	r20, r24
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	8c 81       	ldd	r24, Y+4	; 0x04
    108c:	9d 81       	ldd	r25, Y+5	; 0x05
    108e:	0e 94 39 11 	call	0x2272	; 0x2272 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1092:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1094:	8c 81       	ldd	r24, Y+4	; 0x04
    1096:	9d 81       	ldd	r25, Y+5	; 0x05
    1098:	82 0f       	add	r24, r18
    109a:	91 1d       	adc	r25, r1
    109c:	9d 83       	std	Y+5, r25	; 0x05
    109e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    10a0:	2a 81       	ldd	r18, Y+2	; 0x02
    10a2:	3b 81       	ldd	r19, Y+3	; 0x03
    10a4:	82 17       	cp	r24, r18
    10a6:	93 07       	cpc	r25, r19
    10a8:	70 f1       	brcs	.+92     	; 0x1106 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    10aa:	88 81       	ld	r24, Y
    10ac:	99 81       	ldd	r25, Y+1	; 0x01
    10ae:	9d 83       	std	Y+5, r25	; 0x05
    10b0:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    10b2:	80 e0       	ldi	r24, 0x00	; 0
    10b4:	2d c0       	rjmp	.+90     	; 0x1110 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    10b6:	48 2f       	mov	r20, r24
    10b8:	50 e0       	ldi	r21, 0x00	; 0
    10ba:	8e 81       	ldd	r24, Y+6	; 0x06
    10bc:	9f 81       	ldd	r25, Y+7	; 0x07
    10be:	0e 94 39 11 	call	0x2272	; 0x2272 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    10c2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	31 95       	neg	r19
    10c8:	21 95       	neg	r18
    10ca:	31 09       	sbc	r19, r1
    10cc:	8e 81       	ldd	r24, Y+6	; 0x06
    10ce:	9f 81       	ldd	r25, Y+7	; 0x07
    10d0:	82 0f       	add	r24, r18
    10d2:	93 1f       	adc	r25, r19
    10d4:	9f 83       	std	Y+7, r25	; 0x07
    10d6:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    10d8:	68 81       	ld	r22, Y
    10da:	79 81       	ldd	r23, Y+1	; 0x01
    10dc:	86 17       	cp	r24, r22
    10de:	97 07       	cpc	r25, r23
    10e0:	30 f4       	brcc	.+12     	; 0x10ee <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    10e2:	8a 81       	ldd	r24, Y+2	; 0x02
    10e4:	9b 81       	ldd	r25, Y+3	; 0x03
    10e6:	28 0f       	add	r18, r24
    10e8:	39 1f       	adc	r19, r25
    10ea:	3f 83       	std	Y+7, r19	; 0x07
    10ec:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    10ee:	12 30       	cpi	r17, 0x02	; 2
    10f0:	61 f4       	brne	.+24     	; 0x110a <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    10f2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10f4:	88 23       	and	r24, r24
    10f6:	59 f0       	breq	.+22     	; 0x110e <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    10f8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10fa:	81 50       	subi	r24, 0x01	; 1
    10fc:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    10fe:	80 e0       	ldi	r24, 0x00	; 0
    1100:	07 c0       	rjmp	.+14     	; 0x1110 <prvCopyDataToQueue+0xb6>
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	05 c0       	rjmp	.+10     	; 0x1110 <prvCopyDataToQueue+0xb6>
    1106:	80 e0       	ldi	r24, 0x00	; 0
    1108:	03 c0       	rjmp	.+6      	; 0x1110 <prvCopyDataToQueue+0xb6>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	01 c0       	rjmp	.+2      	; 0x1110 <prvCopyDataToQueue+0xb6>
    110e:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1110:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1112:	9f 5f       	subi	r25, 0xFF	; 255
    1114:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	08 95       	ret

0000111e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    111e:	fc 01       	movw	r30, r24
    1120:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1122:	44 8d       	ldd	r20, Z+28	; 0x1c
    1124:	44 23       	and	r20, r20
    1126:	a1 f0       	breq	.+40     	; 0x1150 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1128:	50 e0       	ldi	r21, 0x00	; 0
    112a:	26 81       	ldd	r18, Z+6	; 0x06
    112c:	37 81       	ldd	r19, Z+7	; 0x07
    112e:	24 0f       	add	r18, r20
    1130:	35 1f       	adc	r19, r21
    1132:	37 83       	std	Z+7, r19	; 0x07
    1134:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1136:	62 81       	ldd	r22, Z+2	; 0x02
    1138:	73 81       	ldd	r23, Z+3	; 0x03
    113a:	26 17       	cp	r18, r22
    113c:	37 07       	cpc	r19, r23
    113e:	20 f0       	brcs	.+8      	; 0x1148 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1140:	20 81       	ld	r18, Z
    1142:	31 81       	ldd	r19, Z+1	; 0x01
    1144:	37 83       	std	Z+7, r19	; 0x07
    1146:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1148:	66 81       	ldd	r22, Z+6	; 0x06
    114a:	77 81       	ldd	r23, Z+7	; 0x07
    114c:	0c 94 39 11 	jmp	0x2272	; 0x2272 <memcpy>
    1150:	08 95       	ret

00001152 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1152:	0f 93       	push	r16
    1154:	1f 93       	push	r17
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    115c:	0f b6       	in	r0, 0x3f	; 63
    115e:	f8 94       	cli
    1160:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1162:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1164:	18 16       	cp	r1, r24
    1166:	a4 f4       	brge	.+40     	; 0x1190 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1168:	89 89       	ldd	r24, Y+17	; 0x11
    116a:	88 23       	and	r24, r24
    116c:	89 f0       	breq	.+34     	; 0x1190 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    116e:	8e 01       	movw	r16, r28
    1170:	0f 5e       	subi	r16, 0xEF	; 239
    1172:	1f 4f       	sbci	r17, 0xFF	; 255
    1174:	03 c0       	rjmp	.+6      	; 0x117c <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1176:	89 89       	ldd	r24, Y+17	; 0x11
    1178:	88 23       	and	r24, r24
    117a:	51 f0       	breq	.+20     	; 0x1190 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    117c:	c8 01       	movw	r24, r16
    117e:	14 d7       	rcall	.+3624   	; 0x1fa8 <xTaskRemoveFromEventList>
    1180:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1182:	9d d7       	rcall	.+3898   	; 0x20be <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1184:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    118a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    118c:	18 16       	cp	r1, r24
    118e:	9c f3       	brlt	.-26     	; 0x1176 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1190:	8f ef       	ldi	r24, 0xFF	; 255
    1192:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1194:	0f 90       	pop	r0
    1196:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    119e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11a0:	18 16       	cp	r1, r24
    11a2:	a4 f4       	brge	.+40     	; 0x11cc <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11a4:	88 85       	ldd	r24, Y+8	; 0x08
    11a6:	88 23       	and	r24, r24
    11a8:	89 f0       	breq	.+34     	; 0x11cc <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11aa:	8e 01       	movw	r16, r28
    11ac:	08 5f       	subi	r16, 0xF8	; 248
    11ae:	1f 4f       	sbci	r17, 0xFF	; 255
    11b0:	03 c0       	rjmp	.+6      	; 0x11b8 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    11b2:	88 85       	ldd	r24, Y+8	; 0x08
    11b4:	88 23       	and	r24, r24
    11b6:	51 f0       	breq	.+20     	; 0x11cc <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    11b8:	c8 01       	movw	r24, r16
    11ba:	f6 d6       	rcall	.+3564   	; 0x1fa8 <xTaskRemoveFromEventList>
    11bc:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    11be:	7f d7       	rcall	.+3838   	; 0x20be <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    11c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11c2:	81 50       	subi	r24, 0x01	; 1
    11c4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    11c6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11c8:	18 16       	cp	r1, r24
    11ca:	9c f3       	brlt	.-26     	; 0x11b2 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    11cc:	8f ef       	ldi	r24, 0xFF	; 255
    11ce:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
}
    11d4:	df 91       	pop	r29
    11d6:	cf 91       	pop	r28
    11d8:	1f 91       	pop	r17
    11da:	0f 91       	pop	r16
    11dc:	08 95       	ret

000011de <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
    11e2:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    11ea:	88 81       	ld	r24, Y
    11ec:	99 81       	ldd	r25, Y+1	; 0x01
    11ee:	2c 8d       	ldd	r18, Y+28	; 0x1c
    11f0:	30 e0       	ldi	r19, 0x00	; 0
    11f2:	7b 8d       	ldd	r23, Y+27	; 0x1b
    11f4:	72 9f       	mul	r23, r18
    11f6:	a0 01       	movw	r20, r0
    11f8:	73 9f       	mul	r23, r19
    11fa:	50 0d       	add	r21, r0
    11fc:	11 24       	eor	r1, r1
    11fe:	fc 01       	movw	r30, r24
    1200:	e4 0f       	add	r30, r20
    1202:	f5 1f       	adc	r31, r21
    1204:	fb 83       	std	Y+3, r31	; 0x03
    1206:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1208:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    120a:	9d 83       	std	Y+5, r25	; 0x05
    120c:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    120e:	42 1b       	sub	r20, r18
    1210:	53 0b       	sbc	r21, r19
    1212:	84 0f       	add	r24, r20
    1214:	95 1f       	adc	r25, r21
    1216:	9f 83       	std	Y+7, r25	; 0x07
    1218:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    121a:	8f ef       	ldi	r24, 0xFF	; 255
    121c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    121e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1220:	61 11       	cpse	r22, r1
    1222:	0a c0       	rjmp	.+20     	; 0x1238 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1224:	88 85       	ldd	r24, Y+8	; 0x08
    1226:	88 23       	and	r24, r24
    1228:	69 f0       	breq	.+26     	; 0x1244 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    122a:	ce 01       	movw	r24, r28
    122c:	08 96       	adiw	r24, 0x08	; 8
    122e:	bc d6       	rcall	.+3448   	; 0x1fa8 <xTaskRemoveFromEventList>
    1230:	81 30       	cpi	r24, 0x01	; 1
    1232:	41 f4       	brne	.+16     	; 0x1244 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1234:	4e de       	rcall	.-868    	; 0xed2 <vPortYield>
    1236:	06 c0       	rjmp	.+12     	; 0x1244 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1238:	ce 01       	movw	r24, r28
    123a:	08 96       	adiw	r24, 0x08	; 8
    123c:	3f d9       	rcall	.-3458   	; 0x4bc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    123e:	ce 01       	movw	r24, r28
    1240:	41 96       	adiw	r24, 0x11	; 17
    1242:	3c d9       	rcall	.-3464   	; 0x4bc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	08 95       	ret

00001250 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1250:	0f 93       	push	r16
    1252:	1f 93       	push	r17
    1254:	cf 93       	push	r28
    1256:	df 93       	push	r29
    1258:	18 2f       	mov	r17, r24
    125a:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    125c:	88 23       	and	r24, r24
    125e:	d1 f0       	breq	.+52     	; 0x1294 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1260:	8f e1       	ldi	r24, 0x1F	; 31
    1262:	90 e0       	ldi	r25, 0x00	; 0
    1264:	f5 d8       	rcall	.-3606   	; 0x450 <pvPortMalloc>
    1266:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1268:	00 97       	sbiw	r24, 0x00	; 0
    126a:	b1 f0       	breq	.+44     	; 0x1298 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    126c:	10 9f       	mul	r17, r16
    126e:	c0 01       	movw	r24, r0
    1270:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1272:	01 96       	adiw	r24, 0x01	; 1
    1274:	ed d8       	rcall	.-3622   	; 0x450 <pvPortMalloc>
    1276:	99 83       	std	Y+1, r25	; 0x01
    1278:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    127a:	89 2b       	or	r24, r25
    127c:	31 f0       	breq	.+12     	; 0x128a <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    127e:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1280:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1282:	61 e0       	ldi	r22, 0x01	; 1
    1284:	ce 01       	movw	r24, r28
    1286:	ab df       	rcall	.-170    	; 0x11de <xQueueGenericReset>
    1288:	07 c0       	rjmp	.+14     	; 0x1298 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    128a:	ce 01       	movw	r24, r28
    128c:	16 d9       	rcall	.-3540   	; 0x4ba <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    128e:	c0 e0       	ldi	r28, 0x00	; 0
    1290:	d0 e0       	ldi	r29, 0x00	; 0
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <xQueueGenericCreate+0x48>
    1294:	c0 e0       	ldi	r28, 0x00	; 0
    1296:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1298:	ce 01       	movw	r24, r28
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    12a4:	9f 92       	push	r9
    12a6:	af 92       	push	r10
    12a8:	bf 92       	push	r11
    12aa:	cf 92       	push	r12
    12ac:	df 92       	push	r13
    12ae:	ef 92       	push	r14
    12b0:	ff 92       	push	r15
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	00 d0       	rcall	.+0      	; 0x12bc <xQueueGenericSend+0x18>
    12bc:	1f 92       	push	r1
    12be:	1f 92       	push	r1
    12c0:	cd b7       	in	r28, 0x3d	; 61
    12c2:	de b7       	in	r29, 0x3e	; 62
    12c4:	8c 01       	movw	r16, r24
    12c6:	6b 01       	movw	r12, r22
    12c8:	5d 83       	std	Y+5, r21	; 0x05
    12ca:	4c 83       	std	Y+4, r20	; 0x04
    12cc:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    12ce:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    12d0:	99 24       	eor	r9, r9
    12d2:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12d4:	7c 01       	movw	r14, r24
    12d6:	88 e0       	ldi	r24, 0x08	; 8
    12d8:	e8 0e       	add	r14, r24
    12da:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    12dc:	0f b6       	in	r0, 0x3f	; 63
    12de:	f8 94       	cli
    12e0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    12e2:	f8 01       	movw	r30, r16
    12e4:	92 8d       	ldd	r25, Z+26	; 0x1a
    12e6:	83 8d       	ldd	r24, Z+27	; 0x1b
    12e8:	98 17       	cp	r25, r24
    12ea:	18 f0       	brcs	.+6      	; 0x12f2 <xQueueGenericSend+0x4e>
    12ec:	f2 e0       	ldi	r31, 0x02	; 2
    12ee:	af 12       	cpse	r10, r31
    12f0:	15 c0       	rjmp	.+42     	; 0x131c <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    12f2:	4a 2d       	mov	r20, r10
    12f4:	b6 01       	movw	r22, r12
    12f6:	c8 01       	movw	r24, r16
    12f8:	b0 de       	rcall	.-672    	; 0x105a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12fa:	f8 01       	movw	r30, r16
    12fc:	91 89       	ldd	r25, Z+17	; 0x11
    12fe:	99 23       	and	r25, r25
    1300:	39 f0       	breq	.+14     	; 0x1310 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1302:	c8 01       	movw	r24, r16
    1304:	41 96       	adiw	r24, 0x11	; 17
    1306:	50 d6       	rcall	.+3232   	; 0x1fa8 <xTaskRemoveFromEventList>
    1308:	81 30       	cpi	r24, 0x01	; 1
    130a:	21 f4       	brne	.+8      	; 0x1314 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    130c:	e2 dd       	rcall	.-1084   	; 0xed2 <vPortYield>
    130e:	02 c0       	rjmp	.+4      	; 0x1314 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1310:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1312:	df dd       	rcall	.-1090   	; 0xed2 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1314:	0f 90       	pop	r0
    1316:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	46 c0       	rjmp	.+140    	; 0x13a8 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    131c:	ec 81       	ldd	r30, Y+4	; 0x04
    131e:	fd 81       	ldd	r31, Y+5	; 0x05
    1320:	ef 2b       	or	r30, r31
    1322:	21 f4       	brne	.+8      	; 0x132c <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1328:	80 e0       	ldi	r24, 0x00	; 0
    132a:	3e c0       	rjmp	.+124    	; 0x13a8 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    132c:	b1 10       	cpse	r11, r1
    132e:	04 c0       	rjmp	.+8      	; 0x1338 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1330:	ce 01       	movw	r24, r28
    1332:	01 96       	adiw	r24, 0x01	; 1
    1334:	81 d6       	rcall	.+3330   	; 0x2038 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1336:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1338:	0f 90       	pop	r0
    133a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    133c:	78 d3       	rcall	.+1776   	; 0x1a2e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    133e:	0f b6       	in	r0, 0x3f	; 63
    1340:	f8 94       	cli
    1342:	0f 92       	push	r0
    1344:	f8 01       	movw	r30, r16
    1346:	85 8d       	ldd	r24, Z+29	; 0x1d
    1348:	8f 3f       	cpi	r24, 0xFF	; 255
    134a:	09 f4       	brne	.+2      	; 0x134e <xQueueGenericSend+0xaa>
    134c:	15 8e       	std	Z+29, r1	; 0x1d
    134e:	f8 01       	movw	r30, r16
    1350:	86 8d       	ldd	r24, Z+30	; 0x1e
    1352:	8f 3f       	cpi	r24, 0xFF	; 255
    1354:	09 f4       	brne	.+2      	; 0x1358 <xQueueGenericSend+0xb4>
    1356:	16 8e       	std	Z+30, r1	; 0x1e
    1358:	0f 90       	pop	r0
    135a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    135c:	be 01       	movw	r22, r28
    135e:	6c 5f       	subi	r22, 0xFC	; 252
    1360:	7f 4f       	sbci	r23, 0xFF	; 255
    1362:	ce 01       	movw	r24, r28
    1364:	01 96       	adiw	r24, 0x01	; 1
    1366:	73 d6       	rcall	.+3302   	; 0x204e <xTaskCheckForTimeOut>
    1368:	81 11       	cpse	r24, r1
    136a:	1a c0       	rjmp	.+52     	; 0x13a0 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    136c:	0f b6       	in	r0, 0x3f	; 63
    136e:	f8 94       	cli
    1370:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1372:	f8 01       	movw	r30, r16
    1374:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1376:	0f 90       	pop	r0
    1378:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    137a:	f8 01       	movw	r30, r16
    137c:	83 8d       	ldd	r24, Z+27	; 0x1b
    137e:	98 13       	cpse	r25, r24
    1380:	0b c0       	rjmp	.+22     	; 0x1398 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1382:	6c 81       	ldd	r22, Y+4	; 0x04
    1384:	7d 81       	ldd	r23, Y+5	; 0x05
    1386:	c7 01       	movw	r24, r14
    1388:	e4 d5       	rcall	.+3016   	; 0x1f52 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    138a:	c8 01       	movw	r24, r16
    138c:	e2 de       	rcall	.-572    	; 0x1152 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    138e:	22 d4       	rcall	.+2116   	; 0x1bd4 <xTaskResumeAll>
    1390:	81 11       	cpse	r24, r1
    1392:	a4 cf       	rjmp	.-184    	; 0x12dc <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1394:	9e dd       	rcall	.-1220   	; 0xed2 <vPortYield>
    1396:	a2 cf       	rjmp	.-188    	; 0x12dc <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1398:	c8 01       	movw	r24, r16
    139a:	db de       	rcall	.-586    	; 0x1152 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    139c:	1b d4       	rcall	.+2102   	; 0x1bd4 <xTaskResumeAll>
    139e:	9e cf       	rjmp	.-196    	; 0x12dc <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    13a0:	c8 01       	movw	r24, r16
    13a2:	d7 de       	rcall	.-594    	; 0x1152 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13a4:	17 d4       	rcall	.+2094   	; 0x1bd4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    13a6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    13a8:	0f 90       	pop	r0
    13aa:	0f 90       	pop	r0
    13ac:	0f 90       	pop	r0
    13ae:	0f 90       	pop	r0
    13b0:	0f 90       	pop	r0
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	1f 91       	pop	r17
    13b8:	0f 91       	pop	r16
    13ba:	ff 90       	pop	r15
    13bc:	ef 90       	pop	r14
    13be:	df 90       	pop	r13
    13c0:	cf 90       	pop	r12
    13c2:	bf 90       	pop	r11
    13c4:	af 90       	pop	r10
    13c6:	9f 90       	pop	r9
    13c8:	08 95       	ret

000013ca <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    13ce:	8f e1       	ldi	r24, 0x1F	; 31
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	3e d8       	rcall	.-3972   	; 0x450 <pvPortMalloc>
    13d4:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    13d6:	00 97       	sbiw	r24, 0x00	; 0
    13d8:	e1 f0       	breq	.+56     	; 0x1412 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    13da:	1b 82       	std	Y+3, r1	; 0x03
    13dc:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    13de:	19 82       	std	Y+1, r1	; 0x01
    13e0:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    13e2:	1d 82       	std	Y+5, r1	; 0x05
    13e4:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    13e6:	1f 82       	std	Y+7, r1	; 0x07
    13e8:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    13ea:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    13f0:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    13f2:	8f ef       	ldi	r24, 0xFF	; 255
    13f4:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    13f6:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    13f8:	ce 01       	movw	r24, r28
    13fa:	08 96       	adiw	r24, 0x08	; 8
    13fc:	5f d8       	rcall	.-3906   	; 0x4bc <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    13fe:	ce 01       	movw	r24, r28
    1400:	41 96       	adiw	r24, 0x11	; 17
    1402:	5c d8       	rcall	.-3912   	; 0x4bc <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1404:	20 e0       	ldi	r18, 0x00	; 0
    1406:	40 e0       	ldi	r20, 0x00	; 0
    1408:	50 e0       	ldi	r21, 0x00	; 0
    140a:	60 e0       	ldi	r22, 0x00	; 0
    140c:	70 e0       	ldi	r23, 0x00	; 0
    140e:	ce 01       	movw	r24, r28
    1410:	49 df       	rcall	.-366    	; 0x12a4 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1412:	ce 01       	movw	r24, r28
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	08 95       	ret

0000141a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    141a:	0f 93       	push	r16
    141c:	1f 93       	push	r17
    141e:	cf 93       	push	r28
    1420:	df 93       	push	r29
    1422:	ec 01       	movw	r28, r24
    1424:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1426:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1428:	8b 8d       	ldd	r24, Y+27	; 0x1b
    142a:	98 17       	cp	r25, r24
    142c:	10 f0       	brcs	.+4      	; 0x1432 <xQueueGenericSendFromISR+0x18>
    142e:	22 30       	cpi	r18, 0x02	; 2
    1430:	11 f5       	brne	.+68     	; 0x1476 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1432:	42 2f       	mov	r20, r18
    1434:	ce 01       	movw	r24, r28
    1436:	11 de       	rcall	.-990    	; 0x105a <prvCopyDataToQueue>
    1438:	88 23       	and	r24, r24
    143a:	31 f0       	breq	.+12     	; 0x1448 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    143c:	01 15       	cp	r16, r1
    143e:	11 05       	cpc	r17, r1
    1440:	19 f0       	breq	.+6      	; 0x1448 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	f8 01       	movw	r30, r16
    1446:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1448:	8e 8d       	ldd	r24, Y+30	; 0x1e
    144a:	8f 3f       	cpi	r24, 0xFF	; 255
    144c:	79 f4       	brne	.+30     	; 0x146c <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    144e:	89 89       	ldd	r24, Y+17	; 0x11
    1450:	88 23       	and	r24, r24
    1452:	99 f0       	breq	.+38     	; 0x147a <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1454:	ce 01       	movw	r24, r28
    1456:	41 96       	adiw	r24, 0x11	; 17
    1458:	a7 d5       	rcall	.+2894   	; 0x1fa8 <xTaskRemoveFromEventList>
    145a:	88 23       	and	r24, r24
    145c:	81 f0       	breq	.+32     	; 0x147e <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    145e:	01 15       	cp	r16, r1
    1460:	11 05       	cpc	r17, r1
    1462:	79 f0       	breq	.+30     	; 0x1482 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1464:	81 e0       	ldi	r24, 0x01	; 1
    1466:	f8 01       	movw	r30, r16
    1468:	80 83       	st	Z, r24
    146a:	0c c0       	rjmp	.+24     	; 0x1484 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    146c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    146e:	8f 5f       	subi	r24, 0xFF	; 255
    1470:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	07 c0       	rjmp	.+14     	; 0x1484 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	05 c0       	rjmp	.+10     	; 0x1484 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    147a:	81 e0       	ldi	r24, 0x01	; 1
    147c:	03 c0       	rjmp	.+6      	; 0x1484 <xQueueGenericSendFromISR+0x6a>
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	01 c0       	rjmp	.+2      	; 0x1484 <xQueueGenericSendFromISR+0x6a>
    1482:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	1f 91       	pop	r17
    148a:	0f 91       	pop	r16
    148c:	08 95       	ret

0000148e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    148e:	9f 92       	push	r9
    1490:	af 92       	push	r10
    1492:	bf 92       	push	r11
    1494:	cf 92       	push	r12
    1496:	df 92       	push	r13
    1498:	ef 92       	push	r14
    149a:	ff 92       	push	r15
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	00 d0       	rcall	.+0      	; 0x14a6 <xQueueGenericReceive+0x18>
    14a6:	1f 92       	push	r1
    14a8:	1f 92       	push	r1
    14aa:	cd b7       	in	r28, 0x3d	; 61
    14ac:	de b7       	in	r29, 0x3e	; 62
    14ae:	8c 01       	movw	r16, r24
    14b0:	6b 01       	movw	r12, r22
    14b2:	5d 83       	std	Y+5, r21	; 0x05
    14b4:	4c 83       	std	Y+4, r20	; 0x04
    14b6:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    14b8:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    14ba:	99 24       	eor	r9, r9
    14bc:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14be:	7c 01       	movw	r14, r24
    14c0:	81 e1       	ldi	r24, 0x11	; 17
    14c2:	e8 0e       	add	r14, r24
    14c4:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14c6:	0f b6       	in	r0, 0x3f	; 63
    14c8:	f8 94       	cli
    14ca:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    14cc:	f8 01       	movw	r30, r16
    14ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    14d0:	88 23       	and	r24, r24
    14d2:	69 f1       	breq	.+90     	; 0x152e <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    14d4:	e6 80       	ldd	r14, Z+6	; 0x06
    14d6:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    14d8:	b6 01       	movw	r22, r12
    14da:	c8 01       	movw	r24, r16
    14dc:	20 de       	rcall	.-960    	; 0x111e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    14de:	b1 10       	cpse	r11, r1
    14e0:	17 c0       	rjmp	.+46     	; 0x1510 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    14e2:	f8 01       	movw	r30, r16
    14e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    14e6:	81 50       	subi	r24, 0x01	; 1
    14e8:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14ea:	80 81       	ld	r24, Z
    14ec:	91 81       	ldd	r25, Z+1	; 0x01
    14ee:	89 2b       	or	r24, r25
    14f0:	21 f4       	brne	.+8      	; 0x14fa <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    14f2:	86 d6       	rcall	.+3340   	; 0x2200 <pvTaskIncrementMutexHeldCount>
    14f4:	f8 01       	movw	r30, r16
    14f6:	93 83       	std	Z+3, r25	; 0x03
    14f8:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14fa:	f8 01       	movw	r30, r16
    14fc:	80 85       	ldd	r24, Z+8	; 0x08
    14fe:	88 23       	and	r24, r24
    1500:	91 f0       	breq	.+36     	; 0x1526 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1502:	c8 01       	movw	r24, r16
    1504:	08 96       	adiw	r24, 0x08	; 8
    1506:	50 d5       	rcall	.+2720   	; 0x1fa8 <xTaskRemoveFromEventList>
    1508:	81 30       	cpi	r24, 0x01	; 1
    150a:	69 f4       	brne	.+26     	; 0x1526 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    150c:	e2 dc       	rcall	.-1596   	; 0xed2 <vPortYield>
    150e:	0b c0       	rjmp	.+22     	; 0x1526 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1510:	f8 01       	movw	r30, r16
    1512:	f7 82       	std	Z+7, r15	; 0x07
    1514:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1516:	81 89       	ldd	r24, Z+17	; 0x11
    1518:	88 23       	and	r24, r24
    151a:	29 f0       	breq	.+10     	; 0x1526 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    151c:	c8 01       	movw	r24, r16
    151e:	41 96       	adiw	r24, 0x11	; 17
    1520:	43 d5       	rcall	.+2694   	; 0x1fa8 <xTaskRemoveFromEventList>
    1522:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1524:	d6 dc       	rcall	.-1620   	; 0xed2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1526:	0f 90       	pop	r0
    1528:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	52 c0       	rjmp	.+164    	; 0x15d2 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    152e:	4c 81       	ldd	r20, Y+4	; 0x04
    1530:	5d 81       	ldd	r21, Y+5	; 0x05
    1532:	45 2b       	or	r20, r21
    1534:	21 f4       	brne	.+8      	; 0x153e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1536:	0f 90       	pop	r0
    1538:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    153a:	80 e0       	ldi	r24, 0x00	; 0
    153c:	4a c0       	rjmp	.+148    	; 0x15d2 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    153e:	a1 10       	cpse	r10, r1
    1540:	04 c0       	rjmp	.+8      	; 0x154a <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1542:	ce 01       	movw	r24, r28
    1544:	01 96       	adiw	r24, 0x01	; 1
    1546:	78 d5       	rcall	.+2800   	; 0x2038 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1548:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    154a:	0f 90       	pop	r0
    154c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    154e:	6f d2       	rcall	.+1246   	; 0x1a2e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1550:	0f b6       	in	r0, 0x3f	; 63
    1552:	f8 94       	cli
    1554:	0f 92       	push	r0
    1556:	f8 01       	movw	r30, r16
    1558:	85 8d       	ldd	r24, Z+29	; 0x1d
    155a:	8f 3f       	cpi	r24, 0xFF	; 255
    155c:	09 f4       	brne	.+2      	; 0x1560 <xQueueGenericReceive+0xd2>
    155e:	15 8e       	std	Z+29, r1	; 0x1d
    1560:	f8 01       	movw	r30, r16
    1562:	86 8d       	ldd	r24, Z+30	; 0x1e
    1564:	8f 3f       	cpi	r24, 0xFF	; 255
    1566:	09 f4       	brne	.+2      	; 0x156a <xQueueGenericReceive+0xdc>
    1568:	16 8e       	std	Z+30, r1	; 0x1e
    156a:	0f 90       	pop	r0
    156c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    156e:	be 01       	movw	r22, r28
    1570:	6c 5f       	subi	r22, 0xFC	; 252
    1572:	7f 4f       	sbci	r23, 0xFF	; 255
    1574:	ce 01       	movw	r24, r28
    1576:	01 96       	adiw	r24, 0x01	; 1
    1578:	6a d5       	rcall	.+2772   	; 0x204e <xTaskCheckForTimeOut>
    157a:	81 11       	cpse	r24, r1
    157c:	26 c0       	rjmp	.+76     	; 0x15ca <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    157e:	0f b6       	in	r0, 0x3f	; 63
    1580:	f8 94       	cli
    1582:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1584:	f8 01       	movw	r30, r16
    1586:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1588:	0f 90       	pop	r0
    158a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    158c:	81 11       	cpse	r24, r1
    158e:	19 c0       	rjmp	.+50     	; 0x15c2 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1590:	f8 01       	movw	r30, r16
    1592:	80 81       	ld	r24, Z
    1594:	91 81       	ldd	r25, Z+1	; 0x01
    1596:	89 2b       	or	r24, r25
    1598:	49 f4       	brne	.+18     	; 0x15ac <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	f8 94       	cli
    159e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    15a0:	f8 01       	movw	r30, r16
    15a2:	82 81       	ldd	r24, Z+2	; 0x02
    15a4:	93 81       	ldd	r25, Z+3	; 0x03
    15a6:	8f d5       	rcall	.+2846   	; 0x20c6 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    15a8:	0f 90       	pop	r0
    15aa:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15ac:	6c 81       	ldd	r22, Y+4	; 0x04
    15ae:	7d 81       	ldd	r23, Y+5	; 0x05
    15b0:	c7 01       	movw	r24, r14
    15b2:	cf d4       	rcall	.+2462   	; 0x1f52 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15b4:	c8 01       	movw	r24, r16
    15b6:	cd dd       	rcall	.-1126   	; 0x1152 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    15b8:	0d d3       	rcall	.+1562   	; 0x1bd4 <xTaskResumeAll>
    15ba:	81 11       	cpse	r24, r1
    15bc:	84 cf       	rjmp	.-248    	; 0x14c6 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    15be:	89 dc       	rcall	.-1774   	; 0xed2 <vPortYield>
    15c0:	82 cf       	rjmp	.-252    	; 0x14c6 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15c2:	c8 01       	movw	r24, r16
    15c4:	c6 dd       	rcall	.-1140   	; 0x1152 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15c6:	06 d3       	rcall	.+1548   	; 0x1bd4 <xTaskResumeAll>
    15c8:	7e cf       	rjmp	.-260    	; 0x14c6 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    15ca:	c8 01       	movw	r24, r16
    15cc:	c2 dd       	rcall	.-1148   	; 0x1152 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15ce:	02 d3       	rcall	.+1540   	; 0x1bd4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    15d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    15d2:	0f 90       	pop	r0
    15d4:	0f 90       	pop	r0
    15d6:	0f 90       	pop	r0
    15d8:	0f 90       	pop	r0
    15da:	0f 90       	pop	r0
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	1f 91       	pop	r17
    15e2:	0f 91       	pop	r16
    15e4:	ff 90       	pop	r15
    15e6:	ef 90       	pop	r14
    15e8:	df 90       	pop	r13
    15ea:	cf 90       	pop	r12
    15ec:	bf 90       	pop	r11
    15ee:	af 90       	pop	r10
    15f0:	9f 90       	pop	r9
    15f2:	08 95       	ret

000015f4 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    15f4:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    15f6:	71 83       	std	Z+1, r23	; 0x01
    15f8:	60 83       	st	Z, r22
	ring->rSize = size;
    15fa:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    15fc:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    15fe:	13 82       	std	Z+3, r1	; 0x03
    1600:	08 95       	ret

00001602 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1602:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1604:	94 81       	ldd	r25, Z+4	; 0x04
    1606:	a0 81       	ld	r26, Z
    1608:	b1 81       	ldd	r27, Z+1	; 0x01
    160a:	a9 0f       	add	r26, r25
    160c:	b1 1d       	adc	r27, r1
    160e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1610:	9f 5f       	subi	r25, 0xFF	; 255
    1612:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1614:	22 81       	ldd	r18, Z+2	; 0x02
    1616:	92 17       	cp	r25, r18
    1618:	10 f0       	brcs	.+4      	; 0x161e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    161a:	92 1b       	sub	r25, r18
    161c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    161e:	93 81       	ldd	r25, Z+3	; 0x03
    1620:	91 50       	subi	r25, 0x01	; 1
    1622:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1624:	08 95       	ret

00001626 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1626:	fc 01       	movw	r30, r24
    1628:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    162a:	83 81       	ldd	r24, Z+3	; 0x03
    162c:	22 81       	ldd	r18, Z+2	; 0x02
    162e:	82 17       	cp	r24, r18
    1630:	78 f4       	brcc	.+30     	; 0x1650 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1632:	34 81       	ldd	r19, Z+4	; 0x04
    1634:	90 e0       	ldi	r25, 0x00	; 0
    1636:	83 0f       	add	r24, r19
    1638:	91 1d       	adc	r25, r1
    163a:	62 2f       	mov	r22, r18
    163c:	70 e0       	ldi	r23, 0x00	; 0
    163e:	f2 d5       	rcall	.+3044   	; 0x2224 <__divmodhi4>
    1640:	a0 81       	ld	r26, Z
    1642:	b1 81       	ldd	r27, Z+1	; 0x01
    1644:	a8 0f       	add	r26, r24
    1646:	b9 1f       	adc	r27, r25
    1648:	4c 93       	st	X, r20
            ring->rLength++;
    164a:	83 81       	ldd	r24, Z+3	; 0x03
    164c:	8f 5f       	subi	r24, 0xFF	; 255
    164e:	83 83       	std	Z+3, r24	; 0x03
    1650:	08 95       	ret

00001652 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1652:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	22 81       	ldd	r18, Z+2	; 0x02
    1658:	93 81       	ldd	r25, Z+3	; 0x03
    165a:	29 13       	cpse	r18, r25
    165c:	80 e0       	ldi	r24, 0x00	; 0
}
    165e:	08 95       	ret

00001660 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1660:	21 e0       	ldi	r18, 0x01	; 1
    1662:	fc 01       	movw	r30, r24
    1664:	83 81       	ldd	r24, Z+3	; 0x03
    1666:	81 11       	cpse	r24, r1
    1668:	01 c0       	rjmp	.+2      	; 0x166c <ringBufferNotEmpty+0xc>
    166a:	20 e0       	ldi	r18, 0x00	; 0
}
    166c:	82 2f       	mov	r24, r18
    166e:	08 95       	ret

00001670 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1670:	e0 91 5e 08 	lds	r30, 0x085E
    1674:	f0 91 5f 08 	lds	r31, 0x085F
    1678:	80 81       	ld	r24, Z
    167a:	81 11       	cpse	r24, r1
    167c:	07 c0       	rjmp	.+14     	; 0x168c <prvResetNextTaskUnblockTime+0x1c>
    167e:	8f ef       	ldi	r24, 0xFF	; 255
    1680:	9f ef       	ldi	r25, 0xFF	; 255
    1682:	90 93 05 02 	sts	0x0205, r25
    1686:	80 93 04 02 	sts	0x0204, r24
    168a:	08 95       	ret
    168c:	e0 91 5e 08 	lds	r30, 0x085E
    1690:	f0 91 5f 08 	lds	r31, 0x085F
    1694:	05 80       	ldd	r0, Z+5	; 0x05
    1696:	f6 81       	ldd	r31, Z+6	; 0x06
    1698:	e0 2d       	mov	r30, r0
    169a:	06 80       	ldd	r0, Z+6	; 0x06
    169c:	f7 81       	ldd	r31, Z+7	; 0x07
    169e:	e0 2d       	mov	r30, r0
    16a0:	82 81       	ldd	r24, Z+2	; 0x02
    16a2:	93 81       	ldd	r25, Z+3	; 0x03
    16a4:	90 93 05 02 	sts	0x0205, r25
    16a8:	80 93 04 02 	sts	0x0204, r24
    16ac:	08 95       	ret

000016ae <prvAddCurrentTaskToDelayedList>:
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	ec 01       	movw	r28, r24
    16b4:	e0 91 9f 08 	lds	r30, 0x089F
    16b8:	f0 91 a0 08 	lds	r31, 0x08A0
    16bc:	93 83       	std	Z+3, r25	; 0x03
    16be:	82 83       	std	Z+2, r24	; 0x02
    16c0:	80 91 3d 08 	lds	r24, 0x083D
    16c4:	90 91 3e 08 	lds	r25, 0x083E
    16c8:	c8 17       	cp	r28, r24
    16ca:	d9 07       	cpc	r29, r25
    16cc:	68 f4       	brcc	.+26     	; 0x16e8 <prvAddCurrentTaskToDelayedList+0x3a>
    16ce:	60 91 9f 08 	lds	r22, 0x089F
    16d2:	70 91 a0 08 	lds	r23, 0x08A0
    16d6:	80 91 5c 08 	lds	r24, 0x085C
    16da:	90 91 5d 08 	lds	r25, 0x085D
    16de:	6e 5f       	subi	r22, 0xFE	; 254
    16e0:	7f 4f       	sbci	r23, 0xFF	; 255
    16e2:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    16e6:	17 c0       	rjmp	.+46     	; 0x1716 <prvAddCurrentTaskToDelayedList+0x68>
    16e8:	60 91 9f 08 	lds	r22, 0x089F
    16ec:	70 91 a0 08 	lds	r23, 0x08A0
    16f0:	80 91 5e 08 	lds	r24, 0x085E
    16f4:	90 91 5f 08 	lds	r25, 0x085F
    16f8:	6e 5f       	subi	r22, 0xFE	; 254
    16fa:	7f 4f       	sbci	r23, 0xFF	; 255
    16fc:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    1700:	80 91 04 02 	lds	r24, 0x0204
    1704:	90 91 05 02 	lds	r25, 0x0205
    1708:	c8 17       	cp	r28, r24
    170a:	d9 07       	cpc	r29, r25
    170c:	20 f4       	brcc	.+8      	; 0x1716 <prvAddCurrentTaskToDelayedList+0x68>
    170e:	d0 93 05 02 	sts	0x0205, r29
    1712:	c0 93 04 02 	sts	0x0204, r28
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	08 95       	ret

0000171c <xTaskGenericCreate>:
    171c:	4f 92       	push	r4
    171e:	5f 92       	push	r5
    1720:	6f 92       	push	r6
    1722:	7f 92       	push	r7
    1724:	8f 92       	push	r8
    1726:	9f 92       	push	r9
    1728:	af 92       	push	r10
    172a:	bf 92       	push	r11
    172c:	cf 92       	push	r12
    172e:	df 92       	push	r13
    1730:	ef 92       	push	r14
    1732:	ff 92       	push	r15
    1734:	0f 93       	push	r16
    1736:	1f 93       	push	r17
    1738:	cf 93       	push	r28
    173a:	df 93       	push	r29
    173c:	4c 01       	movw	r8, r24
    173e:	5b 01       	movw	r10, r22
    1740:	2a 01       	movw	r4, r20
    1742:	39 01       	movw	r6, r18
    1744:	83 e2       	ldi	r24, 0x23	; 35
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	0e 94 28 02 	call	0x450	; 0x450 <pvPortMalloc>
    174c:	ec 01       	movw	r28, r24
    174e:	00 97       	sbiw	r24, 0x00	; 0
    1750:	09 f4       	brne	.+2      	; 0x1754 <xTaskGenericCreate+0x38>
    1752:	e7 c0       	rjmp	.+462    	; 0x1922 <xTaskGenericCreate+0x206>
    1754:	c1 14       	cp	r12, r1
    1756:	d1 04       	cpc	r13, r1
    1758:	09 f0       	breq	.+2      	; 0x175c <xTaskGenericCreate+0x40>
    175a:	cc c0       	rjmp	.+408    	; 0x18f4 <xTaskGenericCreate+0x1d8>
    175c:	c2 01       	movw	r24, r4
    175e:	0e 94 28 02 	call	0x450	; 0x450 <pvPortMalloc>
    1762:	98 8f       	std	Y+24, r25	; 0x18
    1764:	8f 8b       	std	Y+23, r24	; 0x17
    1766:	89 2b       	or	r24, r25
    1768:	09 f0       	breq	.+2      	; 0x176c <xTaskGenericCreate+0x50>
    176a:	c6 c0       	rjmp	.+396    	; 0x18f8 <xTaskGenericCreate+0x1dc>
    176c:	ce 01       	movw	r24, r28
    176e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1772:	d7 c0       	rjmp	.+430    	; 0x1922 <xTaskGenericCreate+0x206>
    1774:	cf 01       	movw	r24, r30
    1776:	31 91       	ld	r19, Z+
    1778:	da 01       	movw	r26, r20
    177a:	3d 93       	st	X+, r19
    177c:	ad 01       	movw	r20, r26
    177e:	dc 01       	movw	r26, r24
    1780:	8c 91       	ld	r24, X
    1782:	88 23       	and	r24, r24
    1784:	11 f0       	breq	.+4      	; 0x178a <xTaskGenericCreate+0x6e>
    1786:	21 50       	subi	r18, 0x01	; 1
    1788:	a9 f7       	brne	.-22     	; 0x1774 <xTaskGenericCreate+0x58>
    178a:	18 a2       	std	Y+32, r1	; 0x20
    178c:	10 2f       	mov	r17, r16
    178e:	05 30       	cpi	r16, 0x05	; 5
    1790:	08 f0       	brcs	.+2      	; 0x1794 <xTaskGenericCreate+0x78>
    1792:	14 e0       	ldi	r17, 0x04	; 4
    1794:	1e 8b       	std	Y+22, r17	; 0x16
    1796:	19 a3       	std	Y+33, r17	; 0x21
    1798:	1a a2       	std	Y+34, r1	; 0x22
    179a:	5e 01       	movw	r10, r28
    179c:	b2 e0       	ldi	r27, 0x02	; 2
    179e:	ab 0e       	add	r10, r27
    17a0:	b1 1c       	adc	r11, r1
    17a2:	c5 01       	movw	r24, r10
    17a4:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <vListInitialiseItem>
    17a8:	ce 01       	movw	r24, r28
    17aa:	0c 96       	adiw	r24, 0x0c	; 12
    17ac:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <vListInitialiseItem>
    17b0:	d9 87       	std	Y+9, r29	; 0x09
    17b2:	c8 87       	std	Y+8, r28	; 0x08
    17b4:	85 e0       	ldi	r24, 0x05	; 5
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	81 1b       	sub	r24, r17
    17ba:	91 09       	sbc	r25, r1
    17bc:	9d 87       	std	Y+13, r25	; 0x0d
    17be:	8c 87       	std	Y+12, r24	; 0x0c
    17c0:	db 8b       	std	Y+19, r29	; 0x13
    17c2:	ca 8b       	std	Y+18, r28	; 0x12
    17c4:	a3 01       	movw	r20, r6
    17c6:	b4 01       	movw	r22, r8
    17c8:	c6 01       	movw	r24, r12
    17ca:	d4 da       	rcall	.-2648   	; 0xd74 <pxPortInitialiseStack>
    17cc:	99 83       	std	Y+1, r25	; 0x01
    17ce:	88 83       	st	Y, r24
    17d0:	e1 14       	cp	r14, r1
    17d2:	f1 04       	cpc	r15, r1
    17d4:	19 f0       	breq	.+6      	; 0x17dc <xTaskGenericCreate+0xc0>
    17d6:	f7 01       	movw	r30, r14
    17d8:	d1 83       	std	Z+1, r29	; 0x01
    17da:	c0 83       	st	Z, r28
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	0f 92       	push	r0
    17e2:	80 91 3f 08 	lds	r24, 0x083F
    17e6:	8f 5f       	subi	r24, 0xFF	; 255
    17e8:	80 93 3f 08 	sts	0x083F, r24
    17ec:	80 91 9f 08 	lds	r24, 0x089F
    17f0:	90 91 a0 08 	lds	r25, 0x08A0
    17f4:	89 2b       	or	r24, r25
    17f6:	09 f0       	breq	.+2      	; 0x17fa <xTaskGenericCreate+0xde>
    17f8:	3f c0       	rjmp	.+126    	; 0x1878 <xTaskGenericCreate+0x15c>
    17fa:	d0 93 a0 08 	sts	0x08A0, r29
    17fe:	c0 93 9f 08 	sts	0x089F, r28
    1802:	80 91 3f 08 	lds	r24, 0x083F
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	09 f0       	breq	.+2      	; 0x180c <xTaskGenericCreate+0xf0>
    180a:	45 c0       	rjmp	.+138    	; 0x1896 <xTaskGenericCreate+0x17a>
    180c:	0f 2e       	mov	r0, r31
    180e:	f2 e7       	ldi	r31, 0x72	; 114
    1810:	ef 2e       	mov	r14, r31
    1812:	f8 e0       	ldi	r31, 0x08	; 8
    1814:	ff 2e       	mov	r15, r31
    1816:	f0 2d       	mov	r31, r0
    1818:	0f 2e       	mov	r0, r31
    181a:	ff e9       	ldi	r31, 0x9F	; 159
    181c:	cf 2e       	mov	r12, r31
    181e:	f8 e0       	ldi	r31, 0x08	; 8
    1820:	df 2e       	mov	r13, r31
    1822:	f0 2d       	mov	r31, r0
    1824:	c7 01       	movw	r24, r14
    1826:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    182a:	f9 e0       	ldi	r31, 0x09	; 9
    182c:	ef 0e       	add	r14, r31
    182e:	f1 1c       	adc	r15, r1
    1830:	ec 14       	cp	r14, r12
    1832:	fd 04       	cpc	r15, r13
    1834:	b9 f7       	brne	.-18     	; 0x1824 <xTaskGenericCreate+0x108>
    1836:	89 e6       	ldi	r24, 0x69	; 105
    1838:	98 e0       	ldi	r25, 0x08	; 8
    183a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    183e:	80 e6       	ldi	r24, 0x60	; 96
    1840:	98 e0       	ldi	r25, 0x08	; 8
    1842:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    1846:	83 e5       	ldi	r24, 0x53	; 83
    1848:	98 e0       	ldi	r25, 0x08	; 8
    184a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    184e:	8a e4       	ldi	r24, 0x4A	; 74
    1850:	98 e0       	ldi	r25, 0x08	; 8
    1852:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    1856:	80 e4       	ldi	r24, 0x40	; 64
    1858:	98 e0       	ldi	r25, 0x08	; 8
    185a:	0e 94 5e 02 	call	0x4bc	; 0x4bc <vListInitialise>
    185e:	89 e6       	ldi	r24, 0x69	; 105
    1860:	98 e0       	ldi	r25, 0x08	; 8
    1862:	90 93 5f 08 	sts	0x085F, r25
    1866:	80 93 5e 08 	sts	0x085E, r24
    186a:	80 e6       	ldi	r24, 0x60	; 96
    186c:	98 e0       	ldi	r25, 0x08	; 8
    186e:	90 93 5d 08 	sts	0x085D, r25
    1872:	80 93 5c 08 	sts	0x085C, r24
    1876:	0f c0       	rjmp	.+30     	; 0x1896 <xTaskGenericCreate+0x17a>
    1878:	80 91 3b 08 	lds	r24, 0x083B
    187c:	81 11       	cpse	r24, r1
    187e:	0b c0       	rjmp	.+22     	; 0x1896 <xTaskGenericCreate+0x17a>
    1880:	e0 91 9f 08 	lds	r30, 0x089F
    1884:	f0 91 a0 08 	lds	r31, 0x08A0
    1888:	86 89       	ldd	r24, Z+22	; 0x16
    188a:	08 17       	cp	r16, r24
    188c:	20 f0       	brcs	.+8      	; 0x1896 <xTaskGenericCreate+0x17a>
    188e:	d0 93 a0 08 	sts	0x08A0, r29
    1892:	c0 93 9f 08 	sts	0x089F, r28
    1896:	80 91 37 08 	lds	r24, 0x0837
    189a:	8f 5f       	subi	r24, 0xFF	; 255
    189c:	80 93 37 08 	sts	0x0837, r24
    18a0:	8e 89       	ldd	r24, Y+22	; 0x16
    18a2:	90 91 3c 08 	lds	r25, 0x083C
    18a6:	98 17       	cp	r25, r24
    18a8:	10 f4       	brcc	.+4      	; 0x18ae <xTaskGenericCreate+0x192>
    18aa:	80 93 3c 08 	sts	0x083C, r24
    18ae:	90 e0       	ldi	r25, 0x00	; 0
    18b0:	9c 01       	movw	r18, r24
    18b2:	22 0f       	add	r18, r18
    18b4:	33 1f       	adc	r19, r19
    18b6:	22 0f       	add	r18, r18
    18b8:	33 1f       	adc	r19, r19
    18ba:	22 0f       	add	r18, r18
    18bc:	33 1f       	adc	r19, r19
    18be:	82 0f       	add	r24, r18
    18c0:	93 1f       	adc	r25, r19
    18c2:	b5 01       	movw	r22, r10
    18c4:	8e 58       	subi	r24, 0x8E	; 142
    18c6:	97 4f       	sbci	r25, 0xF7	; 247
    18c8:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    18cc:	0f 90       	pop	r0
    18ce:	0f be       	out	0x3f, r0	; 63
    18d0:	80 91 3b 08 	lds	r24, 0x083B
    18d4:	88 23       	and	r24, r24
    18d6:	51 f0       	breq	.+20     	; 0x18ec <xTaskGenericCreate+0x1d0>
    18d8:	e0 91 9f 08 	lds	r30, 0x089F
    18dc:	f0 91 a0 08 	lds	r31, 0x08A0
    18e0:	86 89       	ldd	r24, Z+22	; 0x16
    18e2:	80 17       	cp	r24, r16
    18e4:	28 f4       	brcc	.+10     	; 0x18f0 <xTaskGenericCreate+0x1d4>
    18e6:	f5 da       	rcall	.-2582   	; 0xed2 <vPortYield>
    18e8:	81 e0       	ldi	r24, 0x01	; 1
    18ea:	1c c0       	rjmp	.+56     	; 0x1924 <xTaskGenericCreate+0x208>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	1a c0       	rjmp	.+52     	; 0x1924 <xTaskGenericCreate+0x208>
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	18 c0       	rjmp	.+48     	; 0x1924 <xTaskGenericCreate+0x208>
    18f4:	d8 8e       	std	Y+24, r13	; 0x18
    18f6:	cf 8a       	std	Y+23, r12	; 0x17
    18f8:	81 e0       	ldi	r24, 0x01	; 1
    18fa:	48 1a       	sub	r4, r24
    18fc:	51 08       	sbc	r5, r1
    18fe:	cf 88       	ldd	r12, Y+23	; 0x17
    1900:	d8 8c       	ldd	r13, Y+24	; 0x18
    1902:	c4 0c       	add	r12, r4
    1904:	d5 1c       	adc	r13, r5
    1906:	d5 01       	movw	r26, r10
    1908:	8c 91       	ld	r24, X
    190a:	89 8f       	std	Y+25, r24	; 0x19
    190c:	8c 91       	ld	r24, X
    190e:	88 23       	and	r24, r24
    1910:	09 f4       	brne	.+2      	; 0x1914 <xTaskGenericCreate+0x1f8>
    1912:	3b cf       	rjmp	.-394    	; 0x178a <xTaskGenericCreate+0x6e>
    1914:	ae 01       	movw	r20, r28
    1916:	46 5e       	subi	r20, 0xE6	; 230
    1918:	5f 4f       	sbci	r21, 0xFF	; 255
    191a:	f5 01       	movw	r30, r10
    191c:	31 96       	adiw	r30, 0x01	; 1
    191e:	27 e0       	ldi	r18, 0x07	; 7
    1920:	29 cf       	rjmp	.-430    	; 0x1774 <xTaskGenericCreate+0x58>
    1922:	8f ef       	ldi	r24, 0xFF	; 255
    1924:	df 91       	pop	r29
    1926:	cf 91       	pop	r28
    1928:	1f 91       	pop	r17
    192a:	0f 91       	pop	r16
    192c:	ff 90       	pop	r15
    192e:	ef 90       	pop	r14
    1930:	df 90       	pop	r13
    1932:	cf 90       	pop	r12
    1934:	bf 90       	pop	r11
    1936:	af 90       	pop	r10
    1938:	9f 90       	pop	r9
    193a:	8f 90       	pop	r8
    193c:	7f 90       	pop	r7
    193e:	6f 90       	pop	r6
    1940:	5f 90       	pop	r5
    1942:	4f 90       	pop	r4
    1944:	08 95       	ret

00001946 <vTaskResume>:
    1946:	0f 93       	push	r16
    1948:	1f 93       	push	r17
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	ec 01       	movw	r28, r24
    1950:	00 97       	sbiw	r24, 0x00	; 0
    1952:	09 f4       	brne	.+2      	; 0x1956 <vTaskResume+0x10>
    1954:	3e c0       	rjmp	.+124    	; 0x19d2 <vTaskResume+0x8c>
    1956:	80 91 9f 08 	lds	r24, 0x089F
    195a:	90 91 a0 08 	lds	r25, 0x08A0
    195e:	c8 17       	cp	r28, r24
    1960:	d9 07       	cpc	r29, r25
    1962:	b9 f1       	breq	.+110    	; 0x19d2 <vTaskResume+0x8c>
    1964:	0f b6       	in	r0, 0x3f	; 63
    1966:	f8 94       	cli
    1968:	0f 92       	push	r0
    196a:	8a 85       	ldd	r24, Y+10	; 0x0a
    196c:	9b 85       	ldd	r25, Y+11	; 0x0b
    196e:	80 54       	subi	r24, 0x40	; 64
    1970:	98 40       	sbci	r25, 0x08	; 8
    1972:	69 f5       	brne	.+90     	; 0x19ce <vTaskResume+0x88>
    1974:	8c 89       	ldd	r24, Y+20	; 0x14
    1976:	9d 89       	ldd	r25, Y+21	; 0x15
    1978:	28 e0       	ldi	r18, 0x08	; 8
    197a:	83 35       	cpi	r24, 0x53	; 83
    197c:	92 07       	cpc	r25, r18
    197e:	39 f1       	breq	.+78     	; 0x19ce <vTaskResume+0x88>
    1980:	89 2b       	or	r24, r25
    1982:	29 f5       	brne	.+74     	; 0x19ce <vTaskResume+0x88>
    1984:	8e 01       	movw	r16, r28
    1986:	0e 5f       	subi	r16, 0xFE	; 254
    1988:	1f 4f       	sbci	r17, 0xFF	; 255
    198a:	c8 01       	movw	r24, r16
    198c:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1990:	8e 89       	ldd	r24, Y+22	; 0x16
    1992:	90 91 3c 08 	lds	r25, 0x083C
    1996:	98 17       	cp	r25, r24
    1998:	10 f4       	brcc	.+4      	; 0x199e <vTaskResume+0x58>
    199a:	80 93 3c 08 	sts	0x083C, r24
    199e:	90 e0       	ldi	r25, 0x00	; 0
    19a0:	9c 01       	movw	r18, r24
    19a2:	22 0f       	add	r18, r18
    19a4:	33 1f       	adc	r19, r19
    19a6:	22 0f       	add	r18, r18
    19a8:	33 1f       	adc	r19, r19
    19aa:	22 0f       	add	r18, r18
    19ac:	33 1f       	adc	r19, r19
    19ae:	82 0f       	add	r24, r18
    19b0:	93 1f       	adc	r25, r19
    19b2:	b8 01       	movw	r22, r16
    19b4:	8e 58       	subi	r24, 0x8E	; 142
    19b6:	97 4f       	sbci	r25, 0xF7	; 247
    19b8:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    19bc:	e0 91 9f 08 	lds	r30, 0x089F
    19c0:	f0 91 a0 08 	lds	r31, 0x08A0
    19c4:	9e 89       	ldd	r25, Y+22	; 0x16
    19c6:	86 89       	ldd	r24, Z+22	; 0x16
    19c8:	98 17       	cp	r25, r24
    19ca:	08 f0       	brcs	.+2      	; 0x19ce <vTaskResume+0x88>
    19cc:	82 da       	rcall	.-2812   	; 0xed2 <vPortYield>
    19ce:	0f 90       	pop	r0
    19d0:	0f be       	out	0x3f, r0	; 63
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	1f 91       	pop	r17
    19d8:	0f 91       	pop	r16
    19da:	08 95       	ret

000019dc <vTaskStartScheduler>:
    19dc:	af 92       	push	r10
    19de:	bf 92       	push	r11
    19e0:	cf 92       	push	r12
    19e2:	df 92       	push	r13
    19e4:	ef 92       	push	r14
    19e6:	ff 92       	push	r15
    19e8:	0f 93       	push	r16
    19ea:	a1 2c       	mov	r10, r1
    19ec:	b1 2c       	mov	r11, r1
    19ee:	c1 2c       	mov	r12, r1
    19f0:	d1 2c       	mov	r13, r1
    19f2:	e1 2c       	mov	r14, r1
    19f4:	f1 2c       	mov	r15, r1
    19f6:	00 e0       	ldi	r16, 0x00	; 0
    19f8:	20 e0       	ldi	r18, 0x00	; 0
    19fa:	30 e0       	ldi	r19, 0x00	; 0
    19fc:	45 e5       	ldi	r20, 0x55	; 85
    19fe:	50 e0       	ldi	r21, 0x00	; 0
    1a00:	60 e5       	ldi	r22, 0x50	; 80
    1a02:	72 e0       	ldi	r23, 0x02	; 2
    1a04:	85 ec       	ldi	r24, 0xC5	; 197
    1a06:	9e e0       	ldi	r25, 0x0E	; 14
    1a08:	89 de       	rcall	.-750    	; 0x171c <xTaskGenericCreate>
    1a0a:	81 30       	cpi	r24, 0x01	; 1
    1a0c:	41 f4       	brne	.+16     	; 0x1a1e <vTaskStartScheduler+0x42>
    1a0e:	f8 94       	cli
    1a10:	80 93 3b 08 	sts	0x083B, r24
    1a14:	10 92 3e 08 	sts	0x083E, r1
    1a18:	10 92 3d 08 	sts	0x083D, r1
    1a1c:	1d da       	rcall	.-3014   	; 0xe58 <xPortStartScheduler>
    1a1e:	0f 91       	pop	r16
    1a20:	ff 90       	pop	r15
    1a22:	ef 90       	pop	r14
    1a24:	df 90       	pop	r13
    1a26:	cf 90       	pop	r12
    1a28:	bf 90       	pop	r11
    1a2a:	af 90       	pop	r10
    1a2c:	08 95       	ret

00001a2e <vTaskSuspendAll>:
    1a2e:	80 91 36 08 	lds	r24, 0x0836
    1a32:	8f 5f       	subi	r24, 0xFF	; 255
    1a34:	80 93 36 08 	sts	0x0836, r24
    1a38:	08 95       	ret

00001a3a <xTaskGetTickCount>:
    1a3a:	0f b6       	in	r0, 0x3f	; 63
    1a3c:	f8 94       	cli
    1a3e:	0f 92       	push	r0
    1a40:	80 91 3d 08 	lds	r24, 0x083D
    1a44:	90 91 3e 08 	lds	r25, 0x083E
    1a48:	0f 90       	pop	r0
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	08 95       	ret

00001a4e <xTaskGetTickCountFromISR>:
    1a4e:	80 91 3d 08 	lds	r24, 0x083D
    1a52:	90 91 3e 08 	lds	r25, 0x083E
    1a56:	08 95       	ret

00001a58 <xTaskIncrementTick>:
    1a58:	cf 92       	push	r12
    1a5a:	df 92       	push	r13
    1a5c:	ef 92       	push	r14
    1a5e:	ff 92       	push	r15
    1a60:	0f 93       	push	r16
    1a62:	1f 93       	push	r17
    1a64:	cf 93       	push	r28
    1a66:	df 93       	push	r29
    1a68:	80 91 36 08 	lds	r24, 0x0836
    1a6c:	81 11       	cpse	r24, r1
    1a6e:	99 c0       	rjmp	.+306    	; 0x1ba2 <xTaskIncrementTick+0x14a>
    1a70:	80 91 3d 08 	lds	r24, 0x083D
    1a74:	90 91 3e 08 	lds	r25, 0x083E
    1a78:	01 96       	adiw	r24, 0x01	; 1
    1a7a:	90 93 3e 08 	sts	0x083E, r25
    1a7e:	80 93 3d 08 	sts	0x083D, r24
    1a82:	e0 90 3d 08 	lds	r14, 0x083D
    1a86:	f0 90 3e 08 	lds	r15, 0x083E
    1a8a:	e1 14       	cp	r14, r1
    1a8c:	f1 04       	cpc	r15, r1
    1a8e:	b1 f4       	brne	.+44     	; 0x1abc <xTaskIncrementTick+0x64>
    1a90:	80 91 5e 08 	lds	r24, 0x085E
    1a94:	90 91 5f 08 	lds	r25, 0x085F
    1a98:	20 91 5c 08 	lds	r18, 0x085C
    1a9c:	30 91 5d 08 	lds	r19, 0x085D
    1aa0:	30 93 5f 08 	sts	0x085F, r19
    1aa4:	20 93 5e 08 	sts	0x085E, r18
    1aa8:	90 93 5d 08 	sts	0x085D, r25
    1aac:	80 93 5c 08 	sts	0x085C, r24
    1ab0:	80 91 38 08 	lds	r24, 0x0838
    1ab4:	8f 5f       	subi	r24, 0xFF	; 255
    1ab6:	80 93 38 08 	sts	0x0838, r24
    1aba:	da dd       	rcall	.-1100   	; 0x1670 <prvResetNextTaskUnblockTime>
    1abc:	80 91 04 02 	lds	r24, 0x0204
    1ac0:	90 91 05 02 	lds	r25, 0x0205
    1ac4:	e8 16       	cp	r14, r24
    1ac6:	f9 06       	cpc	r15, r25
    1ac8:	08 f4       	brcc	.+2      	; 0x1acc <xTaskIncrementTick+0x74>
    1aca:	54 c0       	rjmp	.+168    	; 0x1b74 <xTaskIncrementTick+0x11c>
    1acc:	d1 2c       	mov	r13, r1
    1ace:	cc 24       	eor	r12, r12
    1ad0:	c3 94       	inc	r12
    1ad2:	01 c0       	rjmp	.+2      	; 0x1ad6 <xTaskIncrementTick+0x7e>
    1ad4:	dc 2c       	mov	r13, r12
    1ad6:	e0 91 5e 08 	lds	r30, 0x085E
    1ada:	f0 91 5f 08 	lds	r31, 0x085F
    1ade:	80 81       	ld	r24, Z
    1ae0:	81 11       	cpse	r24, r1
    1ae2:	07 c0       	rjmp	.+14     	; 0x1af2 <xTaskIncrementTick+0x9a>
    1ae4:	8f ef       	ldi	r24, 0xFF	; 255
    1ae6:	9f ef       	ldi	r25, 0xFF	; 255
    1ae8:	90 93 05 02 	sts	0x0205, r25
    1aec:	80 93 04 02 	sts	0x0204, r24
    1af0:	42 c0       	rjmp	.+132    	; 0x1b76 <xTaskIncrementTick+0x11e>
    1af2:	e0 91 5e 08 	lds	r30, 0x085E
    1af6:	f0 91 5f 08 	lds	r31, 0x085F
    1afa:	05 80       	ldd	r0, Z+5	; 0x05
    1afc:	f6 81       	ldd	r31, Z+6	; 0x06
    1afe:	e0 2d       	mov	r30, r0
    1b00:	c6 81       	ldd	r28, Z+6	; 0x06
    1b02:	d7 81       	ldd	r29, Z+7	; 0x07
    1b04:	2a 81       	ldd	r18, Y+2	; 0x02
    1b06:	3b 81       	ldd	r19, Y+3	; 0x03
    1b08:	e2 16       	cp	r14, r18
    1b0a:	f3 06       	cpc	r15, r19
    1b0c:	28 f4       	brcc	.+10     	; 0x1b18 <xTaskIncrementTick+0xc0>
    1b0e:	30 93 05 02 	sts	0x0205, r19
    1b12:	20 93 04 02 	sts	0x0204, r18
    1b16:	2f c0       	rjmp	.+94     	; 0x1b76 <xTaskIncrementTick+0x11e>
    1b18:	8e 01       	movw	r16, r28
    1b1a:	0e 5f       	subi	r16, 0xFE	; 254
    1b1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b1e:	c8 01       	movw	r24, r16
    1b20:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1b24:	8c 89       	ldd	r24, Y+20	; 0x14
    1b26:	9d 89       	ldd	r25, Y+21	; 0x15
    1b28:	89 2b       	or	r24, r25
    1b2a:	21 f0       	breq	.+8      	; 0x1b34 <xTaskIncrementTick+0xdc>
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	0c 96       	adiw	r24, 0x0c	; 12
    1b30:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1b34:	2e 89       	ldd	r18, Y+22	; 0x16
    1b36:	80 91 3c 08 	lds	r24, 0x083C
    1b3a:	82 17       	cp	r24, r18
    1b3c:	10 f4       	brcc	.+4      	; 0x1b42 <xTaskIncrementTick+0xea>
    1b3e:	20 93 3c 08 	sts	0x083C, r18
    1b42:	30 e0       	ldi	r19, 0x00	; 0
    1b44:	c9 01       	movw	r24, r18
    1b46:	88 0f       	add	r24, r24
    1b48:	99 1f       	adc	r25, r25
    1b4a:	88 0f       	add	r24, r24
    1b4c:	99 1f       	adc	r25, r25
    1b4e:	88 0f       	add	r24, r24
    1b50:	99 1f       	adc	r25, r25
    1b52:	82 0f       	add	r24, r18
    1b54:	93 1f       	adc	r25, r19
    1b56:	b8 01       	movw	r22, r16
    1b58:	8e 58       	subi	r24, 0x8E	; 142
    1b5a:	97 4f       	sbci	r25, 0xF7	; 247
    1b5c:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1b60:	e0 91 9f 08 	lds	r30, 0x089F
    1b64:	f0 91 a0 08 	lds	r31, 0x08A0
    1b68:	9e 89       	ldd	r25, Y+22	; 0x16
    1b6a:	86 89       	ldd	r24, Z+22	; 0x16
    1b6c:	98 17       	cp	r25, r24
    1b6e:	08 f0       	brcs	.+2      	; 0x1b72 <xTaskIncrementTick+0x11a>
    1b70:	b1 cf       	rjmp	.-158    	; 0x1ad4 <xTaskIncrementTick+0x7c>
    1b72:	b1 cf       	rjmp	.-158    	; 0x1ad6 <xTaskIncrementTick+0x7e>
    1b74:	d1 2c       	mov	r13, r1
    1b76:	e0 91 9f 08 	lds	r30, 0x089F
    1b7a:	f0 91 a0 08 	lds	r31, 0x08A0
    1b7e:	86 89       	ldd	r24, Z+22	; 0x16
    1b80:	90 e0       	ldi	r25, 0x00	; 0
    1b82:	fc 01       	movw	r30, r24
    1b84:	ee 0f       	add	r30, r30
    1b86:	ff 1f       	adc	r31, r31
    1b88:	ee 0f       	add	r30, r30
    1b8a:	ff 1f       	adc	r31, r31
    1b8c:	ee 0f       	add	r30, r30
    1b8e:	ff 1f       	adc	r31, r31
    1b90:	8e 0f       	add	r24, r30
    1b92:	9f 1f       	adc	r25, r31
    1b94:	fc 01       	movw	r30, r24
    1b96:	ee 58       	subi	r30, 0x8E	; 142
    1b98:	f7 4f       	sbci	r31, 0xF7	; 247
    1b9a:	80 81       	ld	r24, Z
    1b9c:	82 30       	cpi	r24, 0x02	; 2
    1b9e:	40 f4       	brcc	.+16     	; 0x1bb0 <xTaskIncrementTick+0x158>
    1ba0:	09 c0       	rjmp	.+18     	; 0x1bb4 <xTaskIncrementTick+0x15c>
    1ba2:	80 91 3a 08 	lds	r24, 0x083A
    1ba6:	8f 5f       	subi	r24, 0xFF	; 255
    1ba8:	80 93 3a 08 	sts	0x083A, r24
    1bac:	d1 2c       	mov	r13, r1
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <xTaskIncrementTick+0x15c>
    1bb0:	dd 24       	eor	r13, r13
    1bb2:	d3 94       	inc	r13
    1bb4:	80 91 39 08 	lds	r24, 0x0839
    1bb8:	88 23       	and	r24, r24
    1bba:	11 f0       	breq	.+4      	; 0x1bc0 <xTaskIncrementTick+0x168>
    1bbc:	dd 24       	eor	r13, r13
    1bbe:	d3 94       	inc	r13
    1bc0:	8d 2d       	mov	r24, r13
    1bc2:	df 91       	pop	r29
    1bc4:	cf 91       	pop	r28
    1bc6:	1f 91       	pop	r17
    1bc8:	0f 91       	pop	r16
    1bca:	ff 90       	pop	r15
    1bcc:	ef 90       	pop	r14
    1bce:	df 90       	pop	r13
    1bd0:	cf 90       	pop	r12
    1bd2:	08 95       	ret

00001bd4 <xTaskResumeAll>:
    1bd4:	df 92       	push	r13
    1bd6:	ef 92       	push	r14
    1bd8:	ff 92       	push	r15
    1bda:	0f 93       	push	r16
    1bdc:	1f 93       	push	r17
    1bde:	cf 93       	push	r28
    1be0:	df 93       	push	r29
    1be2:	0f b6       	in	r0, 0x3f	; 63
    1be4:	f8 94       	cli
    1be6:	0f 92       	push	r0
    1be8:	80 91 36 08 	lds	r24, 0x0836
    1bec:	81 50       	subi	r24, 0x01	; 1
    1bee:	80 93 36 08 	sts	0x0836, r24
    1bf2:	80 91 36 08 	lds	r24, 0x0836
    1bf6:	81 11       	cpse	r24, r1
    1bf8:	5f c0       	rjmp	.+190    	; 0x1cb8 <xTaskResumeAll+0xe4>
    1bfa:	80 91 3f 08 	lds	r24, 0x083F
    1bfe:	88 23       	and	r24, r24
    1c00:	09 f4       	brne	.+2      	; 0x1c04 <xTaskResumeAll+0x30>
    1c02:	5c c0       	rjmp	.+184    	; 0x1cbc <xTaskResumeAll+0xe8>
    1c04:	0f 2e       	mov	r0, r31
    1c06:	f3 e5       	ldi	r31, 0x53	; 83
    1c08:	ef 2e       	mov	r14, r31
    1c0a:	f8 e0       	ldi	r31, 0x08	; 8
    1c0c:	ff 2e       	mov	r15, r31
    1c0e:	f0 2d       	mov	r31, r0
    1c10:	dd 24       	eor	r13, r13
    1c12:	d3 94       	inc	r13
    1c14:	30 c0       	rjmp	.+96     	; 0x1c76 <xTaskResumeAll+0xa2>
    1c16:	e0 91 58 08 	lds	r30, 0x0858
    1c1a:	f0 91 59 08 	lds	r31, 0x0859
    1c1e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c20:	d7 81       	ldd	r29, Z+7	; 0x07
    1c22:	ce 01       	movw	r24, r28
    1c24:	0c 96       	adiw	r24, 0x0c	; 12
    1c26:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1c2a:	8e 01       	movw	r16, r28
    1c2c:	0e 5f       	subi	r16, 0xFE	; 254
    1c2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c30:	c8 01       	movw	r24, r16
    1c32:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1c36:	8e 89       	ldd	r24, Y+22	; 0x16
    1c38:	90 91 3c 08 	lds	r25, 0x083C
    1c3c:	98 17       	cp	r25, r24
    1c3e:	10 f4       	brcc	.+4      	; 0x1c44 <xTaskResumeAll+0x70>
    1c40:	80 93 3c 08 	sts	0x083C, r24
    1c44:	90 e0       	ldi	r25, 0x00	; 0
    1c46:	9c 01       	movw	r18, r24
    1c48:	22 0f       	add	r18, r18
    1c4a:	33 1f       	adc	r19, r19
    1c4c:	22 0f       	add	r18, r18
    1c4e:	33 1f       	adc	r19, r19
    1c50:	22 0f       	add	r18, r18
    1c52:	33 1f       	adc	r19, r19
    1c54:	82 0f       	add	r24, r18
    1c56:	93 1f       	adc	r25, r19
    1c58:	b8 01       	movw	r22, r16
    1c5a:	8e 58       	subi	r24, 0x8E	; 142
    1c5c:	97 4f       	sbci	r25, 0xF7	; 247
    1c5e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1c62:	e0 91 9f 08 	lds	r30, 0x089F
    1c66:	f0 91 a0 08 	lds	r31, 0x08A0
    1c6a:	9e 89       	ldd	r25, Y+22	; 0x16
    1c6c:	86 89       	ldd	r24, Z+22	; 0x16
    1c6e:	98 17       	cp	r25, r24
    1c70:	10 f0       	brcs	.+4      	; 0x1c76 <xTaskResumeAll+0xa2>
    1c72:	d0 92 39 08 	sts	0x0839, r13
    1c76:	f7 01       	movw	r30, r14
    1c78:	80 81       	ld	r24, Z
    1c7a:	81 11       	cpse	r24, r1
    1c7c:	cc cf       	rjmp	.-104    	; 0x1c16 <xTaskResumeAll+0x42>
    1c7e:	80 91 3a 08 	lds	r24, 0x083A
    1c82:	88 23       	and	r24, r24
    1c84:	91 f0       	breq	.+36     	; 0x1caa <xTaskResumeAll+0xd6>
    1c86:	80 91 3a 08 	lds	r24, 0x083A
    1c8a:	88 23       	and	r24, r24
    1c8c:	71 f0       	breq	.+28     	; 0x1caa <xTaskResumeAll+0xd6>
    1c8e:	c1 e0       	ldi	r28, 0x01	; 1
    1c90:	e3 de       	rcall	.-570    	; 0x1a58 <xTaskIncrementTick>
    1c92:	81 11       	cpse	r24, r1
    1c94:	c0 93 39 08 	sts	0x0839, r28
    1c98:	80 91 3a 08 	lds	r24, 0x083A
    1c9c:	81 50       	subi	r24, 0x01	; 1
    1c9e:	80 93 3a 08 	sts	0x083A, r24
    1ca2:	80 91 3a 08 	lds	r24, 0x083A
    1ca6:	81 11       	cpse	r24, r1
    1ca8:	f3 cf       	rjmp	.-26     	; 0x1c90 <xTaskResumeAll+0xbc>
    1caa:	80 91 39 08 	lds	r24, 0x0839
    1cae:	81 30       	cpi	r24, 0x01	; 1
    1cb0:	39 f4       	brne	.+14     	; 0x1cc0 <xTaskResumeAll+0xec>
    1cb2:	0f d9       	rcall	.-3554   	; 0xed2 <vPortYield>
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	05 c0       	rjmp	.+10     	; 0x1cc2 <xTaskResumeAll+0xee>
    1cb8:	80 e0       	ldi	r24, 0x00	; 0
    1cba:	03 c0       	rjmp	.+6      	; 0x1cc2 <xTaskResumeAll+0xee>
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	01 c0       	rjmp	.+2      	; 0x1cc2 <xTaskResumeAll+0xee>
    1cc0:	80 e0       	ldi	r24, 0x00	; 0
    1cc2:	0f 90       	pop	r0
    1cc4:	0f be       	out	0x3f, r0	; 63
    1cc6:	df 91       	pop	r29
    1cc8:	cf 91       	pop	r28
    1cca:	1f 91       	pop	r17
    1ccc:	0f 91       	pop	r16
    1cce:	ff 90       	pop	r15
    1cd0:	ef 90       	pop	r14
    1cd2:	df 90       	pop	r13
    1cd4:	08 95       	ret

00001cd6 <vTaskDelayUntil>:
    1cd6:	0f 93       	push	r16
    1cd8:	1f 93       	push	r17
    1cda:	cf 93       	push	r28
    1cdc:	df 93       	push	r29
    1cde:	8c 01       	movw	r16, r24
    1ce0:	eb 01       	movw	r28, r22
    1ce2:	a5 de       	rcall	.-694    	; 0x1a2e <vTaskSuspendAll>
    1ce4:	80 91 3d 08 	lds	r24, 0x083D
    1ce8:	90 91 3e 08 	lds	r25, 0x083E
    1cec:	f8 01       	movw	r30, r16
    1cee:	20 81       	ld	r18, Z
    1cf0:	31 81       	ldd	r19, Z+1	; 0x01
    1cf2:	c2 0f       	add	r28, r18
    1cf4:	d3 1f       	adc	r29, r19
    1cf6:	82 17       	cp	r24, r18
    1cf8:	93 07       	cpc	r25, r19
    1cfa:	48 f4       	brcc	.+18     	; 0x1d0e <vTaskDelayUntil+0x38>
    1cfc:	c2 17       	cp	r28, r18
    1cfe:	d3 07       	cpc	r29, r19
    1d00:	f8 f4       	brcc	.+62     	; 0x1d40 <vTaskDelayUntil+0x6a>
    1d02:	d1 83       	std	Z+1, r29	; 0x01
    1d04:	c0 83       	st	Z, r28
    1d06:	8c 17       	cp	r24, r28
    1d08:	9d 07       	cpc	r25, r29
    1d0a:	88 f4       	brcc	.+34     	; 0x1d2e <vTaskDelayUntil+0x58>
    1d0c:	07 c0       	rjmp	.+14     	; 0x1d1c <vTaskDelayUntil+0x46>
    1d0e:	c2 17       	cp	r28, r18
    1d10:	d3 07       	cpc	r29, r19
    1d12:	90 f0       	brcs	.+36     	; 0x1d38 <vTaskDelayUntil+0x62>
    1d14:	8c 17       	cp	r24, r28
    1d16:	9d 07       	cpc	r25, r29
    1d18:	78 f0       	brcs	.+30     	; 0x1d38 <vTaskDelayUntil+0x62>
    1d1a:	12 c0       	rjmp	.+36     	; 0x1d40 <vTaskDelayUntil+0x6a>
    1d1c:	80 91 9f 08 	lds	r24, 0x089F
    1d20:	90 91 a0 08 	lds	r25, 0x08A0
    1d24:	02 96       	adiw	r24, 0x02	; 2
    1d26:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1d2a:	ce 01       	movw	r24, r28
    1d2c:	c0 dc       	rcall	.-1664   	; 0x16ae <prvAddCurrentTaskToDelayedList>
    1d2e:	52 df       	rcall	.-348    	; 0x1bd4 <xTaskResumeAll>
    1d30:	81 11       	cpse	r24, r1
    1d32:	0a c0       	rjmp	.+20     	; 0x1d48 <vTaskDelayUntil+0x72>
    1d34:	ce d8       	rcall	.-3684   	; 0xed2 <vPortYield>
    1d36:	08 c0       	rjmp	.+16     	; 0x1d48 <vTaskDelayUntil+0x72>
    1d38:	f8 01       	movw	r30, r16
    1d3a:	d1 83       	std	Z+1, r29	; 0x01
    1d3c:	c0 83       	st	Z, r28
    1d3e:	ee cf       	rjmp	.-36     	; 0x1d1c <vTaskDelayUntil+0x46>
    1d40:	f8 01       	movw	r30, r16
    1d42:	d1 83       	std	Z+1, r29	; 0x01
    1d44:	c0 83       	st	Z, r28
    1d46:	f3 cf       	rjmp	.-26     	; 0x1d2e <vTaskDelayUntil+0x58>
    1d48:	df 91       	pop	r29
    1d4a:	cf 91       	pop	r28
    1d4c:	1f 91       	pop	r17
    1d4e:	0f 91       	pop	r16
    1d50:	08 95       	ret

00001d52 <vTaskDelay>:
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	ec 01       	movw	r28, r24
    1d58:	00 97       	sbiw	r24, 0x00	; 0
    1d5a:	99 f0       	breq	.+38     	; 0x1d82 <vTaskDelay+0x30>
    1d5c:	68 de       	rcall	.-816    	; 0x1a2e <vTaskSuspendAll>
    1d5e:	80 91 3d 08 	lds	r24, 0x083D
    1d62:	90 91 3e 08 	lds	r25, 0x083E
    1d66:	c8 0f       	add	r28, r24
    1d68:	d9 1f       	adc	r29, r25
    1d6a:	80 91 9f 08 	lds	r24, 0x089F
    1d6e:	90 91 a0 08 	lds	r25, 0x08A0
    1d72:	02 96       	adiw	r24, 0x02	; 2
    1d74:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1d78:	ce 01       	movw	r24, r28
    1d7a:	99 dc       	rcall	.-1742   	; 0x16ae <prvAddCurrentTaskToDelayedList>
    1d7c:	2b df       	rcall	.-426    	; 0x1bd4 <xTaskResumeAll>
    1d7e:	81 11       	cpse	r24, r1
    1d80:	01 c0       	rjmp	.+2      	; 0x1d84 <vTaskDelay+0x32>
    1d82:	a7 d8       	rcall	.-3762   	; 0xed2 <vPortYield>
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	08 95       	ret

00001d8a <prvIdleTask>:
    1d8a:	0f 2e       	mov	r0, r31
    1d8c:	f2 e7       	ldi	r31, 0x72	; 114
    1d8e:	ef 2e       	mov	r14, r31
    1d90:	f8 e0       	ldi	r31, 0x08	; 8
    1d92:	ff 2e       	mov	r15, r31
    1d94:	f0 2d       	mov	r31, r0
    1d96:	ca e4       	ldi	r28, 0x4A	; 74
    1d98:	d8 e0       	ldi	r29, 0x08	; 8
    1d9a:	26 c0       	rjmp	.+76     	; 0x1de8 <prvIdleTask+0x5e>
    1d9c:	48 de       	rcall	.-880    	; 0x1a2e <vTaskSuspendAll>
    1d9e:	18 81       	ld	r17, Y
    1da0:	19 df       	rcall	.-462    	; 0x1bd4 <xTaskResumeAll>
    1da2:	11 23       	and	r17, r17
    1da4:	09 f1       	breq	.+66     	; 0x1de8 <prvIdleTask+0x5e>
    1da6:	0f b6       	in	r0, 0x3f	; 63
    1da8:	f8 94       	cli
    1daa:	0f 92       	push	r0
    1dac:	e0 91 4f 08 	lds	r30, 0x084F
    1db0:	f0 91 50 08 	lds	r31, 0x0850
    1db4:	06 81       	ldd	r16, Z+6	; 0x06
    1db6:	17 81       	ldd	r17, Z+7	; 0x07
    1db8:	c8 01       	movw	r24, r16
    1dba:	02 96       	adiw	r24, 0x02	; 2
    1dbc:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1dc0:	80 91 3f 08 	lds	r24, 0x083F
    1dc4:	81 50       	subi	r24, 0x01	; 1
    1dc6:	80 93 3f 08 	sts	0x083F, r24
    1dca:	80 91 49 08 	lds	r24, 0x0849
    1dce:	81 50       	subi	r24, 0x01	; 1
    1dd0:	80 93 49 08 	sts	0x0849, r24
    1dd4:	0f 90       	pop	r0
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	f8 01       	movw	r30, r16
    1dda:	87 89       	ldd	r24, Z+23	; 0x17
    1ddc:	90 8d       	ldd	r25, Z+24	; 0x18
    1dde:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1de2:	c8 01       	movw	r24, r16
    1de4:	0e 94 5d 02 	call	0x4ba	; 0x4ba <vPortFree>
    1de8:	80 91 49 08 	lds	r24, 0x0849
    1dec:	81 11       	cpse	r24, r1
    1dee:	d6 cf       	rjmp	.-84     	; 0x1d9c <prvIdleTask+0x12>
    1df0:	f7 01       	movw	r30, r14
    1df2:	80 81       	ld	r24, Z
    1df4:	82 30       	cpi	r24, 0x02	; 2
    1df6:	c0 f3       	brcs	.-16     	; 0x1de8 <prvIdleTask+0x5e>
    1df8:	6c d8       	rcall	.-3880   	; 0xed2 <vPortYield>
    1dfa:	f6 cf       	rjmp	.-20     	; 0x1de8 <prvIdleTask+0x5e>

00001dfc <vTaskSwitchContext>:
    1dfc:	80 91 36 08 	lds	r24, 0x0836
    1e00:	88 23       	and	r24, r24
    1e02:	21 f0       	breq	.+8      	; 0x1e0c <vTaskSwitchContext+0x10>
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	80 93 39 08 	sts	0x0839, r24
    1e0a:	08 95       	ret
    1e0c:	10 92 39 08 	sts	0x0839, r1
    1e10:	80 91 3c 08 	lds	r24, 0x083C
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	fc 01       	movw	r30, r24
    1e18:	ee 0f       	add	r30, r30
    1e1a:	ff 1f       	adc	r31, r31
    1e1c:	ee 0f       	add	r30, r30
    1e1e:	ff 1f       	adc	r31, r31
    1e20:	ee 0f       	add	r30, r30
    1e22:	ff 1f       	adc	r31, r31
    1e24:	8e 0f       	add	r24, r30
    1e26:	9f 1f       	adc	r25, r31
    1e28:	fc 01       	movw	r30, r24
    1e2a:	ee 58       	subi	r30, 0x8E	; 142
    1e2c:	f7 4f       	sbci	r31, 0xF7	; 247
    1e2e:	80 81       	ld	r24, Z
    1e30:	81 11       	cpse	r24, r1
    1e32:	17 c0       	rjmp	.+46     	; 0x1e62 <vTaskSwitchContext+0x66>
    1e34:	80 91 3c 08 	lds	r24, 0x083C
    1e38:	81 50       	subi	r24, 0x01	; 1
    1e3a:	80 93 3c 08 	sts	0x083C, r24
    1e3e:	80 91 3c 08 	lds	r24, 0x083C
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	fc 01       	movw	r30, r24
    1e46:	ee 0f       	add	r30, r30
    1e48:	ff 1f       	adc	r31, r31
    1e4a:	ee 0f       	add	r30, r30
    1e4c:	ff 1f       	adc	r31, r31
    1e4e:	ee 0f       	add	r30, r30
    1e50:	ff 1f       	adc	r31, r31
    1e52:	8e 0f       	add	r24, r30
    1e54:	9f 1f       	adc	r25, r31
    1e56:	fc 01       	movw	r30, r24
    1e58:	ee 58       	subi	r30, 0x8E	; 142
    1e5a:	f7 4f       	sbci	r31, 0xF7	; 247
    1e5c:	80 81       	ld	r24, Z
    1e5e:	88 23       	and	r24, r24
    1e60:	49 f3       	breq	.-46     	; 0x1e34 <vTaskSwitchContext+0x38>
    1e62:	e0 91 3c 08 	lds	r30, 0x083C
    1e66:	f0 e0       	ldi	r31, 0x00	; 0
    1e68:	cf 01       	movw	r24, r30
    1e6a:	88 0f       	add	r24, r24
    1e6c:	99 1f       	adc	r25, r25
    1e6e:	88 0f       	add	r24, r24
    1e70:	99 1f       	adc	r25, r25
    1e72:	88 0f       	add	r24, r24
    1e74:	99 1f       	adc	r25, r25
    1e76:	e8 0f       	add	r30, r24
    1e78:	f9 1f       	adc	r31, r25
    1e7a:	ee 58       	subi	r30, 0x8E	; 142
    1e7c:	f7 4f       	sbci	r31, 0xF7	; 247
    1e7e:	a1 81       	ldd	r26, Z+1	; 0x01
    1e80:	b2 81       	ldd	r27, Z+2	; 0x02
    1e82:	12 96       	adiw	r26, 0x02	; 2
    1e84:	0d 90       	ld	r0, X+
    1e86:	bc 91       	ld	r27, X
    1e88:	a0 2d       	mov	r26, r0
    1e8a:	b2 83       	std	Z+2, r27	; 0x02
    1e8c:	a1 83       	std	Z+1, r26	; 0x01
    1e8e:	cf 01       	movw	r24, r30
    1e90:	03 96       	adiw	r24, 0x03	; 3
    1e92:	a8 17       	cp	r26, r24
    1e94:	b9 07       	cpc	r27, r25
    1e96:	31 f4       	brne	.+12     	; 0x1ea4 <vTaskSwitchContext+0xa8>
    1e98:	12 96       	adiw	r26, 0x02	; 2
    1e9a:	8d 91       	ld	r24, X+
    1e9c:	9c 91       	ld	r25, X
    1e9e:	13 97       	sbiw	r26, 0x03	; 3
    1ea0:	92 83       	std	Z+2, r25	; 0x02
    1ea2:	81 83       	std	Z+1, r24	; 0x01
    1ea4:	01 80       	ldd	r0, Z+1	; 0x01
    1ea6:	f2 81       	ldd	r31, Z+2	; 0x02
    1ea8:	e0 2d       	mov	r30, r0
    1eaa:	86 81       	ldd	r24, Z+6	; 0x06
    1eac:	97 81       	ldd	r25, Z+7	; 0x07
    1eae:	90 93 a0 08 	sts	0x08A0, r25
    1eb2:	80 93 9f 08 	sts	0x089F, r24
    1eb6:	08 95       	ret

00001eb8 <vTaskSuspend>:
    1eb8:	0f 93       	push	r16
    1eba:	1f 93       	push	r17
    1ebc:	cf 93       	push	r28
    1ebe:	df 93       	push	r29
    1ec0:	ec 01       	movw	r28, r24
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	0f 92       	push	r0
    1ec8:	00 97       	sbiw	r24, 0x00	; 0
    1eca:	21 f4       	brne	.+8      	; 0x1ed4 <vTaskSuspend+0x1c>
    1ecc:	c0 91 9f 08 	lds	r28, 0x089F
    1ed0:	d0 91 a0 08 	lds	r29, 0x08A0
    1ed4:	8e 01       	movw	r16, r28
    1ed6:	0e 5f       	subi	r16, 0xFE	; 254
    1ed8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eda:	c8 01       	movw	r24, r16
    1edc:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1ee0:	8c 89       	ldd	r24, Y+20	; 0x14
    1ee2:	9d 89       	ldd	r25, Y+21	; 0x15
    1ee4:	89 2b       	or	r24, r25
    1ee6:	21 f0       	breq	.+8      	; 0x1ef0 <vTaskSuspend+0x38>
    1ee8:	ce 01       	movw	r24, r28
    1eea:	0c 96       	adiw	r24, 0x0c	; 12
    1eec:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1ef0:	b8 01       	movw	r22, r16
    1ef2:	80 e4       	ldi	r24, 0x40	; 64
    1ef4:	98 e0       	ldi	r25, 0x08	; 8
    1ef6:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1efa:	0f 90       	pop	r0
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	80 91 9f 08 	lds	r24, 0x089F
    1f02:	90 91 a0 08 	lds	r25, 0x08A0
    1f06:	c8 17       	cp	r28, r24
    1f08:	d9 07       	cpc	r29, r25
    1f0a:	a1 f4       	brne	.+40     	; 0x1f34 <vTaskSuspend+0x7c>
    1f0c:	80 91 3b 08 	lds	r24, 0x083B
    1f10:	88 23       	and	r24, r24
    1f12:	19 f0       	breq	.+6      	; 0x1f1a <vTaskSuspend+0x62>
    1f14:	0e 94 69 07 	call	0xed2	; 0xed2 <vPortYield>
    1f18:	17 c0       	rjmp	.+46     	; 0x1f48 <vTaskSuspend+0x90>
    1f1a:	80 91 3f 08 	lds	r24, 0x083F
    1f1e:	90 91 40 08 	lds	r25, 0x0840
    1f22:	98 13       	cpse	r25, r24
    1f24:	05 c0       	rjmp	.+10     	; 0x1f30 <vTaskSuspend+0x78>
    1f26:	10 92 a0 08 	sts	0x08A0, r1
    1f2a:	10 92 9f 08 	sts	0x089F, r1
    1f2e:	0c c0       	rjmp	.+24     	; 0x1f48 <vTaskSuspend+0x90>
    1f30:	65 df       	rcall	.-310    	; 0x1dfc <vTaskSwitchContext>
    1f32:	0a c0       	rjmp	.+20     	; 0x1f48 <vTaskSuspend+0x90>
    1f34:	80 91 3b 08 	lds	r24, 0x083B
    1f38:	88 23       	and	r24, r24
    1f3a:	31 f0       	breq	.+12     	; 0x1f48 <vTaskSuspend+0x90>
    1f3c:	0f b6       	in	r0, 0x3f	; 63
    1f3e:	f8 94       	cli
    1f40:	0f 92       	push	r0
    1f42:	96 db       	rcall	.-2260   	; 0x1670 <prvResetNextTaskUnblockTime>
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	df 91       	pop	r29
    1f4a:	cf 91       	pop	r28
    1f4c:	1f 91       	pop	r17
    1f4e:	0f 91       	pop	r16
    1f50:	08 95       	ret

00001f52 <vTaskPlaceOnEventList>:
    1f52:	cf 93       	push	r28
    1f54:	df 93       	push	r29
    1f56:	eb 01       	movw	r28, r22
    1f58:	60 91 9f 08 	lds	r22, 0x089F
    1f5c:	70 91 a0 08 	lds	r23, 0x08A0
    1f60:	64 5f       	subi	r22, 0xF4	; 244
    1f62:	7f 4f       	sbci	r23, 0xFF	; 255
    1f64:	0e 94 91 02 	call	0x522	; 0x522 <vListInsert>
    1f68:	80 91 9f 08 	lds	r24, 0x089F
    1f6c:	90 91 a0 08 	lds	r25, 0x08A0
    1f70:	02 96       	adiw	r24, 0x02	; 2
    1f72:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1f76:	cf 3f       	cpi	r28, 0xFF	; 255
    1f78:	8f ef       	ldi	r24, 0xFF	; 255
    1f7a:	d8 07       	cpc	r29, r24
    1f7c:	59 f4       	brne	.+22     	; 0x1f94 <vTaskPlaceOnEventList+0x42>
    1f7e:	60 91 9f 08 	lds	r22, 0x089F
    1f82:	70 91 a0 08 	lds	r23, 0x08A0
    1f86:	6e 5f       	subi	r22, 0xFE	; 254
    1f88:	7f 4f       	sbci	r23, 0xFF	; 255
    1f8a:	80 e4       	ldi	r24, 0x40	; 64
    1f8c:	98 e0       	ldi	r25, 0x08	; 8
    1f8e:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    1f92:	07 c0       	rjmp	.+14     	; 0x1fa2 <vTaskPlaceOnEventList+0x50>
    1f94:	80 91 3d 08 	lds	r24, 0x083D
    1f98:	90 91 3e 08 	lds	r25, 0x083E
    1f9c:	8c 0f       	add	r24, r28
    1f9e:	9d 1f       	adc	r25, r29
    1fa0:	86 db       	rcall	.-2292   	; 0x16ae <prvAddCurrentTaskToDelayedList>
    1fa2:	df 91       	pop	r29
    1fa4:	cf 91       	pop	r28
    1fa6:	08 95       	ret

00001fa8 <xTaskRemoveFromEventList>:
    1fa8:	0f 93       	push	r16
    1faa:	1f 93       	push	r17
    1fac:	cf 93       	push	r28
    1fae:	df 93       	push	r29
    1fb0:	dc 01       	movw	r26, r24
    1fb2:	15 96       	adiw	r26, 0x05	; 5
    1fb4:	ed 91       	ld	r30, X+
    1fb6:	fc 91       	ld	r31, X
    1fb8:	16 97       	sbiw	r26, 0x06	; 6
    1fba:	c6 81       	ldd	r28, Z+6	; 0x06
    1fbc:	d7 81       	ldd	r29, Z+7	; 0x07
    1fbe:	8e 01       	movw	r16, r28
    1fc0:	04 5f       	subi	r16, 0xF4	; 244
    1fc2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc4:	c8 01       	movw	r24, r16
    1fc6:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1fca:	80 91 36 08 	lds	r24, 0x0836
    1fce:	81 11       	cpse	r24, r1
    1fd0:	1c c0       	rjmp	.+56     	; 0x200a <xTaskRemoveFromEventList+0x62>
    1fd2:	0a 50       	subi	r16, 0x0A	; 10
    1fd4:	11 09       	sbc	r17, r1
    1fd6:	c8 01       	movw	r24, r16
    1fd8:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    1fdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1fde:	90 91 3c 08 	lds	r25, 0x083C
    1fe2:	98 17       	cp	r25, r24
    1fe4:	10 f4       	brcc	.+4      	; 0x1fea <xTaskRemoveFromEventList+0x42>
    1fe6:	80 93 3c 08 	sts	0x083C, r24
    1fea:	90 e0       	ldi	r25, 0x00	; 0
    1fec:	9c 01       	movw	r18, r24
    1fee:	22 0f       	add	r18, r18
    1ff0:	33 1f       	adc	r19, r19
    1ff2:	22 0f       	add	r18, r18
    1ff4:	33 1f       	adc	r19, r19
    1ff6:	22 0f       	add	r18, r18
    1ff8:	33 1f       	adc	r19, r19
    1ffa:	82 0f       	add	r24, r18
    1ffc:	93 1f       	adc	r25, r19
    1ffe:	b8 01       	movw	r22, r16
    2000:	8e 58       	subi	r24, 0x8E	; 142
    2002:	97 4f       	sbci	r25, 0xF7	; 247
    2004:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    2008:	05 c0       	rjmp	.+10     	; 0x2014 <xTaskRemoveFromEventList+0x6c>
    200a:	b8 01       	movw	r22, r16
    200c:	83 e5       	ldi	r24, 0x53	; 83
    200e:	98 e0       	ldi	r25, 0x08	; 8
    2010:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    2014:	e0 91 9f 08 	lds	r30, 0x089F
    2018:	f0 91 a0 08 	lds	r31, 0x08A0
    201c:	9e 89       	ldd	r25, Y+22	; 0x16
    201e:	86 89       	ldd	r24, Z+22	; 0x16
    2020:	89 17       	cp	r24, r25
    2022:	20 f4       	brcc	.+8      	; 0x202c <xTaskRemoveFromEventList+0x84>
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	80 93 39 08 	sts	0x0839, r24
    202a:	01 c0       	rjmp	.+2      	; 0x202e <xTaskRemoveFromEventList+0x86>
    202c:	80 e0       	ldi	r24, 0x00	; 0
    202e:	df 91       	pop	r29
    2030:	cf 91       	pop	r28
    2032:	1f 91       	pop	r17
    2034:	0f 91       	pop	r16
    2036:	08 95       	ret

00002038 <vTaskSetTimeOutState>:
    2038:	20 91 38 08 	lds	r18, 0x0838
    203c:	fc 01       	movw	r30, r24
    203e:	20 83       	st	Z, r18
    2040:	20 91 3d 08 	lds	r18, 0x083D
    2044:	30 91 3e 08 	lds	r19, 0x083E
    2048:	32 83       	std	Z+2, r19	; 0x02
    204a:	21 83       	std	Z+1, r18	; 0x01
    204c:	08 95       	ret

0000204e <xTaskCheckForTimeOut>:
    204e:	0f b6       	in	r0, 0x3f	; 63
    2050:	f8 94       	cli
    2052:	0f 92       	push	r0
    2054:	40 91 3d 08 	lds	r20, 0x083D
    2058:	50 91 3e 08 	lds	r21, 0x083E
    205c:	db 01       	movw	r26, r22
    205e:	2d 91       	ld	r18, X+
    2060:	3c 91       	ld	r19, X
    2062:	2f 3f       	cpi	r18, 0xFF	; 255
    2064:	bf ef       	ldi	r27, 0xFF	; 255
    2066:	3b 07       	cpc	r19, r27
    2068:	11 f1       	breq	.+68     	; 0x20ae <xTaskCheckForTimeOut+0x60>
    206a:	e0 91 38 08 	lds	r30, 0x0838
    206e:	dc 01       	movw	r26, r24
    2070:	fc 91       	ld	r31, X
    2072:	fe 17       	cp	r31, r30
    2074:	39 f0       	breq	.+14     	; 0x2084 <xTaskCheckForTimeOut+0x36>
    2076:	11 96       	adiw	r26, 0x01	; 1
    2078:	ed 91       	ld	r30, X+
    207a:	fc 91       	ld	r31, X
    207c:	12 97       	sbiw	r26, 0x02	; 2
    207e:	4e 17       	cp	r20, r30
    2080:	5f 07       	cpc	r21, r31
    2082:	b8 f4       	brcc	.+46     	; 0x20b2 <xTaskCheckForTimeOut+0x64>
    2084:	dc 01       	movw	r26, r24
    2086:	11 96       	adiw	r26, 0x01	; 1
    2088:	ed 91       	ld	r30, X+
    208a:	fc 91       	ld	r31, X
    208c:	12 97       	sbiw	r26, 0x02	; 2
    208e:	da 01       	movw	r26, r20
    2090:	ae 1b       	sub	r26, r30
    2092:	bf 0b       	sbc	r27, r31
    2094:	a2 17       	cp	r26, r18
    2096:	b3 07       	cpc	r27, r19
    2098:	70 f4       	brcc	.+28     	; 0x20b6 <xTaskCheckForTimeOut+0x68>
    209a:	e4 1b       	sub	r30, r20
    209c:	f5 0b       	sbc	r31, r21
    209e:	2e 0f       	add	r18, r30
    20a0:	3f 1f       	adc	r19, r31
    20a2:	fb 01       	movw	r30, r22
    20a4:	31 83       	std	Z+1, r19	; 0x01
    20a6:	20 83       	st	Z, r18
    20a8:	c7 df       	rcall	.-114    	; 0x2038 <vTaskSetTimeOutState>
    20aa:	80 e0       	ldi	r24, 0x00	; 0
    20ac:	05 c0       	rjmp	.+10     	; 0x20b8 <xTaskCheckForTimeOut+0x6a>
    20ae:	80 e0       	ldi	r24, 0x00	; 0
    20b0:	03 c0       	rjmp	.+6      	; 0x20b8 <xTaskCheckForTimeOut+0x6a>
    20b2:	81 e0       	ldi	r24, 0x01	; 1
    20b4:	01 c0       	rjmp	.+2      	; 0x20b8 <xTaskCheckForTimeOut+0x6a>
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	0f 90       	pop	r0
    20ba:	0f be       	out	0x3f, r0	; 63
    20bc:	08 95       	ret

000020be <vTaskMissedYield>:
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	80 93 39 08 	sts	0x0839, r24
    20c4:	08 95       	ret

000020c6 <vTaskPriorityInherit>:
    20c6:	0f 93       	push	r16
    20c8:	1f 93       	push	r17
    20ca:	cf 93       	push	r28
    20cc:	df 93       	push	r29
    20ce:	ec 01       	movw	r28, r24
    20d0:	00 97       	sbiw	r24, 0x00	; 0
    20d2:	09 f4       	brne	.+2      	; 0x20d6 <vTaskPriorityInherit+0x10>
    20d4:	51 c0       	rjmp	.+162    	; 0x2178 <vTaskPriorityInherit+0xb2>
    20d6:	8e 89       	ldd	r24, Y+22	; 0x16
    20d8:	e0 91 9f 08 	lds	r30, 0x089F
    20dc:	f0 91 a0 08 	lds	r31, 0x08A0
    20e0:	96 89       	ldd	r25, Z+22	; 0x16
    20e2:	89 17       	cp	r24, r25
    20e4:	08 f0       	brcs	.+2      	; 0x20e8 <vTaskPriorityInherit+0x22>
    20e6:	48 c0       	rjmp	.+144    	; 0x2178 <vTaskPriorityInherit+0xb2>
    20e8:	2c 85       	ldd	r18, Y+12	; 0x0c
    20ea:	3d 85       	ldd	r19, Y+13	; 0x0d
    20ec:	33 23       	and	r19, r19
    20ee:	5c f0       	brlt	.+22     	; 0x2106 <vTaskPriorityInherit+0x40>
    20f0:	e0 91 9f 08 	lds	r30, 0x089F
    20f4:	f0 91 a0 08 	lds	r31, 0x08A0
    20f8:	96 89       	ldd	r25, Z+22	; 0x16
    20fa:	25 e0       	ldi	r18, 0x05	; 5
    20fc:	30 e0       	ldi	r19, 0x00	; 0
    20fe:	29 1b       	sub	r18, r25
    2100:	31 09       	sbc	r19, r1
    2102:	3d 87       	std	Y+13, r19	; 0x0d
    2104:	2c 87       	std	Y+12, r18	; 0x0c
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	9c 01       	movw	r18, r24
    210a:	22 0f       	add	r18, r18
    210c:	33 1f       	adc	r19, r19
    210e:	22 0f       	add	r18, r18
    2110:	33 1f       	adc	r19, r19
    2112:	22 0f       	add	r18, r18
    2114:	33 1f       	adc	r19, r19
    2116:	82 0f       	add	r24, r18
    2118:	93 1f       	adc	r25, r19
    211a:	8e 58       	subi	r24, 0x8E	; 142
    211c:	97 4f       	sbci	r25, 0xF7	; 247
    211e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2120:	3b 85       	ldd	r19, Y+11	; 0x0b
    2122:	28 17       	cp	r18, r24
    2124:	39 07       	cpc	r19, r25
    2126:	11 f5       	brne	.+68     	; 0x216c <vTaskPriorityInherit+0xa6>
    2128:	8e 01       	movw	r16, r28
    212a:	0e 5f       	subi	r16, 0xFE	; 254
    212c:	1f 4f       	sbci	r17, 0xFF	; 255
    212e:	c8 01       	movw	r24, r16
    2130:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    2134:	e0 91 9f 08 	lds	r30, 0x089F
    2138:	f0 91 a0 08 	lds	r31, 0x08A0
    213c:	86 89       	ldd	r24, Z+22	; 0x16
    213e:	8e 8b       	std	Y+22, r24	; 0x16
    2140:	90 91 3c 08 	lds	r25, 0x083C
    2144:	98 17       	cp	r25, r24
    2146:	10 f4       	brcc	.+4      	; 0x214c <vTaskPriorityInherit+0x86>
    2148:	80 93 3c 08 	sts	0x083C, r24
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	9c 01       	movw	r18, r24
    2150:	22 0f       	add	r18, r18
    2152:	33 1f       	adc	r19, r19
    2154:	22 0f       	add	r18, r18
    2156:	33 1f       	adc	r19, r19
    2158:	22 0f       	add	r18, r18
    215a:	33 1f       	adc	r19, r19
    215c:	82 0f       	add	r24, r18
    215e:	93 1f       	adc	r25, r19
    2160:	b8 01       	movw	r22, r16
    2162:	8e 58       	subi	r24, 0x8E	; 142
    2164:	97 4f       	sbci	r25, 0xF7	; 247
    2166:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    216a:	06 c0       	rjmp	.+12     	; 0x2178 <vTaskPriorityInherit+0xb2>
    216c:	e0 91 9f 08 	lds	r30, 0x089F
    2170:	f0 91 a0 08 	lds	r31, 0x08A0
    2174:	86 89       	ldd	r24, Z+22	; 0x16
    2176:	8e 8b       	std	Y+22, r24	; 0x16
    2178:	df 91       	pop	r29
    217a:	cf 91       	pop	r28
    217c:	1f 91       	pop	r17
    217e:	0f 91       	pop	r16
    2180:	08 95       	ret

00002182 <xTaskPriorityDisinherit>:
    2182:	0f 93       	push	r16
    2184:	1f 93       	push	r17
    2186:	cf 93       	push	r28
    2188:	df 93       	push	r29
    218a:	ec 01       	movw	r28, r24
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	71 f1       	breq	.+92     	; 0x21ec <xTaskPriorityDisinherit+0x6a>
    2190:	8a a1       	ldd	r24, Y+34	; 0x22
    2192:	81 50       	subi	r24, 0x01	; 1
    2194:	8a a3       	std	Y+34, r24	; 0x22
    2196:	2e 89       	ldd	r18, Y+22	; 0x16
    2198:	99 a1       	ldd	r25, Y+33	; 0x21
    219a:	29 17       	cp	r18, r25
    219c:	49 f1       	breq	.+82     	; 0x21f0 <xTaskPriorityDisinherit+0x6e>
    219e:	81 11       	cpse	r24, r1
    21a0:	29 c0       	rjmp	.+82     	; 0x21f4 <xTaskPriorityDisinherit+0x72>
    21a2:	8e 01       	movw	r16, r28
    21a4:	0e 5f       	subi	r16, 0xFE	; 254
    21a6:	1f 4f       	sbci	r17, 0xFF	; 255
    21a8:	c8 01       	movw	r24, r16
    21aa:	0e 94 c2 02 	call	0x584	; 0x584 <uxListRemove>
    21ae:	89 a1       	ldd	r24, Y+33	; 0x21
    21b0:	8e 8b       	std	Y+22, r24	; 0x16
    21b2:	25 e0       	ldi	r18, 0x05	; 5
    21b4:	30 e0       	ldi	r19, 0x00	; 0
    21b6:	28 1b       	sub	r18, r24
    21b8:	31 09       	sbc	r19, r1
    21ba:	3d 87       	std	Y+13, r19	; 0x0d
    21bc:	2c 87       	std	Y+12, r18	; 0x0c
    21be:	90 91 3c 08 	lds	r25, 0x083C
    21c2:	98 17       	cp	r25, r24
    21c4:	10 f4       	brcc	.+4      	; 0x21ca <xTaskPriorityDisinherit+0x48>
    21c6:	80 93 3c 08 	sts	0x083C, r24
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	9c 01       	movw	r18, r24
    21ce:	22 0f       	add	r18, r18
    21d0:	33 1f       	adc	r19, r19
    21d2:	22 0f       	add	r18, r18
    21d4:	33 1f       	adc	r19, r19
    21d6:	22 0f       	add	r18, r18
    21d8:	33 1f       	adc	r19, r19
    21da:	82 0f       	add	r24, r18
    21dc:	93 1f       	adc	r25, r19
    21de:	b8 01       	movw	r22, r16
    21e0:	8e 58       	subi	r24, 0x8E	; 142
    21e2:	97 4f       	sbci	r25, 0xF7	; 247
    21e4:	0e 94 70 02 	call	0x4e0	; 0x4e0 <vListInsertEnd>
    21e8:	81 e0       	ldi	r24, 0x01	; 1
    21ea:	05 c0       	rjmp	.+10     	; 0x21f6 <xTaskPriorityDisinherit+0x74>
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	03 c0       	rjmp	.+6      	; 0x21f6 <xTaskPriorityDisinherit+0x74>
    21f0:	80 e0       	ldi	r24, 0x00	; 0
    21f2:	01 c0       	rjmp	.+2      	; 0x21f6 <xTaskPriorityDisinherit+0x74>
    21f4:	80 e0       	ldi	r24, 0x00	; 0
    21f6:	df 91       	pop	r29
    21f8:	cf 91       	pop	r28
    21fa:	1f 91       	pop	r17
    21fc:	0f 91       	pop	r16
    21fe:	08 95       	ret

00002200 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2200:	80 91 9f 08 	lds	r24, 0x089F
    2204:	90 91 a0 08 	lds	r25, 0x08A0
    2208:	89 2b       	or	r24, r25
    220a:	39 f0       	breq	.+14     	; 0x221a <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    220c:	e0 91 9f 08 	lds	r30, 0x089F
    2210:	f0 91 a0 08 	lds	r31, 0x08A0
    2214:	82 a1       	ldd	r24, Z+34	; 0x22
    2216:	8f 5f       	subi	r24, 0xFF	; 255
    2218:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    221a:	80 91 9f 08 	lds	r24, 0x089F
    221e:	90 91 a0 08 	lds	r25, 0x08A0
	}
    2222:	08 95       	ret

00002224 <__divmodhi4>:
    2224:	97 fb       	bst	r25, 7
    2226:	07 2e       	mov	r0, r23
    2228:	16 f4       	brtc	.+4      	; 0x222e <__divmodhi4+0xa>
    222a:	00 94       	com	r0
    222c:	06 d0       	rcall	.+12     	; 0x223a <__divmodhi4_neg1>
    222e:	77 fd       	sbrc	r23, 7
    2230:	08 d0       	rcall	.+16     	; 0x2242 <__divmodhi4_neg2>
    2232:	0b d0       	rcall	.+22     	; 0x224a <__udivmodhi4>
    2234:	07 fc       	sbrc	r0, 7
    2236:	05 d0       	rcall	.+10     	; 0x2242 <__divmodhi4_neg2>
    2238:	3e f4       	brtc	.+14     	; 0x2248 <__divmodhi4_exit>

0000223a <__divmodhi4_neg1>:
    223a:	90 95       	com	r25
    223c:	81 95       	neg	r24
    223e:	9f 4f       	sbci	r25, 0xFF	; 255
    2240:	08 95       	ret

00002242 <__divmodhi4_neg2>:
    2242:	70 95       	com	r23
    2244:	61 95       	neg	r22
    2246:	7f 4f       	sbci	r23, 0xFF	; 255

00002248 <__divmodhi4_exit>:
    2248:	08 95       	ret

0000224a <__udivmodhi4>:
    224a:	aa 1b       	sub	r26, r26
    224c:	bb 1b       	sub	r27, r27
    224e:	51 e1       	ldi	r21, 0x11	; 17
    2250:	07 c0       	rjmp	.+14     	; 0x2260 <__udivmodhi4_ep>

00002252 <__udivmodhi4_loop>:
    2252:	aa 1f       	adc	r26, r26
    2254:	bb 1f       	adc	r27, r27
    2256:	a6 17       	cp	r26, r22
    2258:	b7 07       	cpc	r27, r23
    225a:	10 f0       	brcs	.+4      	; 0x2260 <__udivmodhi4_ep>
    225c:	a6 1b       	sub	r26, r22
    225e:	b7 0b       	sbc	r27, r23

00002260 <__udivmodhi4_ep>:
    2260:	88 1f       	adc	r24, r24
    2262:	99 1f       	adc	r25, r25
    2264:	5a 95       	dec	r21
    2266:	a9 f7       	brne	.-22     	; 0x2252 <__udivmodhi4_loop>
    2268:	80 95       	com	r24
    226a:	90 95       	com	r25
    226c:	bc 01       	movw	r22, r24
    226e:	cd 01       	movw	r24, r26
    2270:	08 95       	ret

00002272 <memcpy>:
    2272:	fb 01       	movw	r30, r22
    2274:	dc 01       	movw	r26, r24
    2276:	02 c0       	rjmp	.+4      	; 0x227c <memcpy+0xa>
    2278:	01 90       	ld	r0, Z+
    227a:	0d 92       	st	X+, r0
    227c:	41 50       	subi	r20, 0x01	; 1
    227e:	50 40       	sbci	r21, 0x00	; 0
    2280:	d8 f7       	brcc	.-10     	; 0x2278 <memcpy+0x6>
    2282:	08 95       	ret

00002284 <__itoa_ncheck>:
    2284:	bb 27       	eor	r27, r27
    2286:	4a 30       	cpi	r20, 0x0A	; 10
    2288:	31 f4       	brne	.+12     	; 0x2296 <__itoa_ncheck+0x12>
    228a:	99 23       	and	r25, r25
    228c:	22 f4       	brpl	.+8      	; 0x2296 <__itoa_ncheck+0x12>
    228e:	bd e2       	ldi	r27, 0x2D	; 45
    2290:	90 95       	com	r25
    2292:	81 95       	neg	r24
    2294:	9f 4f       	sbci	r25, 0xFF	; 255
    2296:	01 c0       	rjmp	.+2      	; 0x229a <__utoa_common>

00002298 <__utoa_ncheck>:
    2298:	bb 27       	eor	r27, r27

0000229a <__utoa_common>:
    229a:	fb 01       	movw	r30, r22
    229c:	55 27       	eor	r21, r21
    229e:	aa 27       	eor	r26, r26
    22a0:	88 0f       	add	r24, r24
    22a2:	99 1f       	adc	r25, r25
    22a4:	aa 1f       	adc	r26, r26
    22a6:	a4 17       	cp	r26, r20
    22a8:	10 f0       	brcs	.+4      	; 0x22ae <__utoa_common+0x14>
    22aa:	a4 1b       	sub	r26, r20
    22ac:	83 95       	inc	r24
    22ae:	50 51       	subi	r21, 0x10	; 16
    22b0:	b9 f7       	brne	.-18     	; 0x22a0 <__utoa_common+0x6>
    22b2:	a0 5d       	subi	r26, 0xD0	; 208
    22b4:	aa 33       	cpi	r26, 0x3A	; 58
    22b6:	08 f0       	brcs	.+2      	; 0x22ba <__utoa_common+0x20>
    22b8:	a9 5d       	subi	r26, 0xD9	; 217
    22ba:	a1 93       	st	Z+, r26
    22bc:	00 97       	sbiw	r24, 0x00	; 0
    22be:	79 f7       	brne	.-34     	; 0x229e <__utoa_common+0x4>
    22c0:	b1 11       	cpse	r27, r1
    22c2:	b1 93       	st	Z+, r27
    22c4:	11 92       	st	Z+, r1
    22c6:	cb 01       	movw	r24, r22
    22c8:	00 c0       	rjmp	.+0      	; 0x22ca <strrev>

000022ca <strrev>:
    22ca:	dc 01       	movw	r26, r24
    22cc:	fc 01       	movw	r30, r24
    22ce:	67 2f       	mov	r22, r23
    22d0:	71 91       	ld	r23, Z+
    22d2:	77 23       	and	r23, r23
    22d4:	e1 f7       	brne	.-8      	; 0x22ce <strrev+0x4>
    22d6:	32 97       	sbiw	r30, 0x02	; 2
    22d8:	04 c0       	rjmp	.+8      	; 0x22e2 <strrev+0x18>
    22da:	7c 91       	ld	r23, X
    22dc:	6d 93       	st	X+, r22
    22de:	70 83       	st	Z, r23
    22e0:	62 91       	ld	r22, -Z
    22e2:	ae 17       	cp	r26, r30
    22e4:	bf 07       	cpc	r27, r31
    22e6:	c8 f3       	brcs	.-14     	; 0x22da <strrev+0x10>
    22e8:	08 95       	ret

000022ea <_exit>:
    22ea:	f8 94       	cli

000022ec <__stop_program>:
    22ec:	ff cf       	rjmp	.-2      	; 0x22ec <__stop_program>
