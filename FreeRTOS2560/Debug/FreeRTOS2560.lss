
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800200  00001f7e  00002012  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f7e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006ee  0080028c  0080028c  0000209e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000209e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000480  00000000  00000000  000020ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004eb8  00000000  00000000  0000254e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001230  00000000  00000000  00007406  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002f95  00000000  00000000  00008636  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000ca0  00000000  00000000  0000b5cc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000135a  00000000  00000000  0000c26c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003578  00000000  00000000  0000d5c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000440  00000000  00000000  00010b3e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	98 c6       	rjmp	.+3376   	; 0xd86 <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	c4 c3       	rjmp	.+1928   	; 0x7ee <__vector_25>
      66:	00 00       	nop
      68:	30 c4       	rjmp	.+2144   	; 0x8ca <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	5c c2       	rjmp	.+1208   	; 0x52e <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	76 c3       	rjmp	.+1772   	; 0x77e <__vector_36>
      92:	00 00       	nop
      94:	e4 c3       	rjmp	.+1992   	; 0x85e <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ee e7       	ldi	r30, 0x7E	; 126
      fc:	ff e1       	ldi	r31, 0x1F	; 31
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 38       	cpi	r26, 0x8C	; 140
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	ac e8       	ldi	r26, 0x8C	; 140
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	aa 37       	cpi	r26, 0x7A	; 122
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	cf d0       	rcall	.+414    	; 0x2be <main>
     120:	0c 94 bd 0f 	jmp	0x1f7a	; 0x1f7a <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	97 d4       	rcall	.+2350   	; 0xa86 <waitForHandshake>
     158:	84 e0       	ldi	r24, 0x04	; 4
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	5a c4       	rjmp	.+2228   	; 0xa12 <transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	87 d4       	rcall	.+2318   	; 0xa70 <startHandShake>
     162:	8b e1       	ldi	r24, 0x1B	; 27
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	55 c4       	rjmp	.+2218   	; 0xa12 <transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a6 97       	sbiw	r28, 0x26	; 38
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e1 e3       	ldi	r30, 0x31	; 49
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	15 96       	adiw	r26, 0x05	; 5
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	e9 e3       	ldi	r30, 0x39	; 57
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1d 96       	adiw	r26, 0x0d	; 13
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e0 e4       	ldi	r30, 0x40	; 64
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	54 96       	adiw	r26, 0x14	; 20
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	e8 e4       	ldi	r30, 0x48	; 72
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5c 96       	adiw	r26, 0x1c	; 28
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	ee e4       	ldi	r30, 0x4E	; 78
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	92 96       	adiw	r26, 0x22	; 34
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	96 d1       	rcall	.+812    	; 0x506 <MaxSonar_Start>
     1da:	87 e2       	ldi	r24, 0x27	; 39
     1dc:	9e d1       	rcall	.+828    	; 0x51a <MaxSonar_Read>
     1de:	4a e0       	ldi	r20, 0x0A	; 10
     1e0:	be 01       	movw	r22, r28
     1e2:	6f 5f       	subi	r22, 0xFF	; 255
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <__itoa_ncheck>
     1ea:	ce 01       	movw	r24, r28
     1ec:	05 96       	adiw	r24, 0x05	; 5
     1ee:	11 d4       	rcall	.+2082   	; 0xa12 <transmitUSART0>
     1f0:	ce 01       	movw	r24, r28
     1f2:	01 96       	adiw	r24, 0x01	; 1
     1f4:	0e d4       	rcall	.+2076   	; 0xa12 <transmitUSART0>
     1f6:	ce 01       	movw	r24, r28
     1f8:	4c 96       	adiw	r24, 0x1c	; 28
     1fa:	0b d4       	rcall	.+2070   	; 0xa12 <transmitUSART0>
     1fc:	86 e2       	ldi	r24, 0x26	; 38
     1fe:	8d d1       	rcall	.+794    	; 0x51a <MaxSonar_Read>
     200:	4a e0       	ldi	r20, 0x0A	; 10
     202:	be 01       	movw	r22, r28
     204:	6f 5f       	subi	r22, 0xFF	; 255
     206:	7f 4f       	sbci	r23, 0xFF	; 255
     208:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <__itoa_ncheck>
     20c:	ce 01       	movw	r24, r28
     20e:	0d 96       	adiw	r24, 0x0d	; 13
     210:	00 d4       	rcall	.+2048   	; 0xa12 <transmitUSART0>
     212:	ce 01       	movw	r24, r28
     214:	01 96       	adiw	r24, 0x01	; 1
     216:	fd d3       	rcall	.+2042   	; 0xa12 <transmitUSART0>
     218:	ce 01       	movw	r24, r28
     21a:	4c 96       	adiw	r24, 0x1c	; 28
     21c:	fa d3       	rcall	.+2036   	; 0xa12 <transmitUSART0>
     21e:	85 e2       	ldi	r24, 0x25	; 37
     220:	7c d1       	rcall	.+760    	; 0x51a <MaxSonar_Read>
     222:	4a e0       	ldi	r20, 0x0A	; 10
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	0a 97       	sbiw	r24, 0x0a	; 10
     22c:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <__itoa_ncheck>
     230:	ce 01       	movw	r24, r28
     232:	44 96       	adiw	r24, 0x14	; 20
     234:	ee d3       	rcall	.+2012   	; 0xa12 <transmitUSART0>
     236:	ce 01       	movw	r24, r28
     238:	01 96       	adiw	r24, 0x01	; 1
     23a:	eb d3       	rcall	.+2006   	; 0xa12 <transmitUSART0>
     23c:	ce 01       	movw	r24, r28
     23e:	82 96       	adiw	r24, 0x22	; 34
     240:	e8 d3       	rcall	.+2000   	; 0xa12 <transmitUSART0>
     242:	86 e9       	ldi	r24, 0x96	; 150
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <vTaskDelay>
     24a:	c6 cf       	rjmp	.-116    	; 0x1d8 <maxSonarTask+0x6e>

0000024c <myTimerTask>:
     24c:	08 d2       	rcall	.+1040   	; 0x65e <MyTimer_Init>
     24e:	61 d2       	rcall	.+1218   	; 0x712 <delayMicroCheck>
     250:	fe cf       	rjmp	.-4      	; 0x24e <myTimerTask+0x2>

00000252 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     252:	8c ec       	ldi	r24, 0xCC	; 204
     254:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     258:	8e e3       	ldi	r24, 0x3E	; 62
     25a:	80 93 65 00 	sts	0x0065, r24
     25e:	08 95       	ret

00000260 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     260:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     264:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     268:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     26c:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     270:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     274:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     278:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     27c:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     280:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     284:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     288:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     28c:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     290:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     294:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     298:	10 92 73 00 	sts	0x0073, r1
     29c:	08 95       	ret

0000029e <init>:
}

void init()
{
     29e:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2a0:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2a2:	f8 94       	cli
	{
		clearTimer();
     2a4:	dd df       	rcall	.-70     	; 0x260 <clearTimer>
		setPowerReduction();
     2a6:	d5 df       	rcall	.-86     	; 0x252 <setPowerReduction>
		USART0_Init();
     2a8:	46 d3       	rcall	.+1676   	; 0x936 <USART0_Init>
		USART1_Init();
     2aa:	65 d3       	rcall	.+1738   	; 0x976 <USART1_Init>
		ADC_Init();
     2ac:	74 d1       	rcall	.+744    	; 0x596 <ADC_Init>
		MaxSonar_Init();
     2ae:	99 9a       	sbi	0x13, 1	; 19
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2b0:	84 b1       	in	r24, 0x04	; 4
     2b2:	80 6c       	ori	r24, 0xC0	; 192
     2b4:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2b6:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2b8:	78 94       	sei
}
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <main>:
	
	// do nth
}

int main(void)
{
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	cd b7       	in	r28, 0x3d	; 61
     2c4:	de b7       	in	r29, 0x3e	; 62
     2c6:	2c 97       	sbiw	r28, 0x0c	; 12
     2c8:	0f b6       	in	r0, 0x3f	; 63
     2ca:	f8 94       	cli
     2cc:	de bf       	out	0x3e, r29	; 62
     2ce:	0f be       	out	0x3f, r0	; 63
     2d0:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     2d2:	e5 df       	rcall	.-54     	; 0x29e <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     2d4:	a1 2c       	mov	r10, r1
     2d6:	b1 2c       	mov	r11, r1
     2d8:	c1 2c       	mov	r12, r1
     2da:	d1 2c       	mov	r13, r1
     2dc:	ce 01       	movw	r24, r28
     2de:	01 96       	adiw	r24, 0x01	; 1
     2e0:	7c 01       	movw	r14, r24
     2e2:	04 e0       	ldi	r16, 0x04	; 4
     2e4:	9c 01       	movw	r18, r24
     2e6:	49 e6       	ldi	r20, 0x69	; 105
     2e8:	50 e0       	ldi	r21, 0x00	; 0
     2ea:	63 e5       	ldi	r22, 0x53	; 83
     2ec:	72 e0       	ldi	r23, 0x02	; 2
     2ee:	86 e2       	ldi	r24, 0x26	; 38
     2f0:	91 e0       	ldi	r25, 0x01	; 1
     2f2:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     2f6:	ce 01       	movw	r24, r28
     2f8:	07 96       	adiw	r24, 0x07	; 7
     2fa:	7c 01       	movw	r14, r24
     2fc:	02 e0       	ldi	r16, 0x02	; 2
     2fe:	20 e0       	ldi	r18, 0x00	; 0
     300:	30 e0       	ldi	r19, 0x00	; 0
     302:	4d e1       	ldi	r20, 0x1D	; 29
     304:	51 e0       	ldi	r21, 0x01	; 1
     306:	6b e5       	ldi	r22, 0x5B	; 91
     308:	72 e0       	ldi	r23, 0x02	; 2
     30a:	85 eb       	ldi	r24, 0xB5	; 181
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     312:	ce 01       	movw	r24, r28
     314:	0b 96       	adiw	r24, 0x0b	; 11
     316:	7c 01       	movw	r14, r24
     318:	01 e0       	ldi	r16, 0x01	; 1
     31a:	20 e0       	ldi	r18, 0x00	; 0
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	49 e6       	ldi	r20, 0x69	; 105
     320:	50 e0       	ldi	r21, 0x00	; 0
     322:	64 e6       	ldi	r22, 0x64	; 100
     324:	72 e0       	ldi	r23, 0x02	; 2
     326:	83 e9       	ldi	r24, 0x93	; 147
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     32e:	ce 01       	movw	r24, r28
     330:	09 96       	adiw	r24, 0x09	; 9
     332:	7c 01       	movw	r14, r24
     334:	20 e0       	ldi	r18, 0x00	; 0
     336:	30 e0       	ldi	r19, 0x00	; 0
     338:	49 e6       	ldi	r20, 0x69	; 105
     33a:	50 e0       	ldi	r21, 0x00	; 0
     33c:	6b e6       	ldi	r22, 0x6B	; 107
     33e:	72 e0       	ldi	r23, 0x02	; 2
     340:	8f e9       	ldi	r24, 0x9F	; 159
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     348:	ce 01       	movw	r24, r28
     34a:	05 96       	adiw	r24, 0x05	; 5
     34c:	7c 01       	movw	r14, r24
     34e:	03 e0       	ldi	r16, 0x03	; 3
     350:	20 e0       	ldi	r18, 0x00	; 0
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	47 e8       	ldi	r20, 0x87	; 135
     356:	50 e0       	ldi	r21, 0x00	; 0
     358:	62 e7       	ldi	r22, 0x72	; 114
     35a:	72 e0       	ldi	r23, 0x02	; 2
     35c:	8b ea       	ldi	r24, 0xAB	; 171
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     364:	ce 01       	movw	r24, r28
     366:	03 96       	adiw	r24, 0x03	; 3
     368:	7c 01       	movw	r14, r24
     36a:	02 e0       	ldi	r16, 0x02	; 2
     36c:	20 e0       	ldi	r18, 0x00	; 0
     36e:	30 e0       	ldi	r19, 0x00	; 0
     370:	47 e8       	ldi	r20, 0x87	; 135
     372:	50 e0       	ldi	r21, 0x00	; 0
     374:	6e e7       	ldi	r22, 0x7E	; 126
     376:	72 e0       	ldi	r23, 0x02	; 2
     378:	80 eb       	ldi	r24, 0xB0	; 176
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	0e 94 24 0a 	call	0x1448	; 0x1448 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     380:	0e 94 84 0b 	call	0x1708	; 0x1708 <vTaskStartScheduler>
     384:	a6 cf       	rjmp	.-180    	; 0x2d2 <main+0x14>

00000386 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     386:	cf 93       	push	r28
     388:	df 93       	push	r29
     38a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     38c:	0e 94 ad 0b 	call	0x175a	; 0x175a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     390:	80 91 8c 02 	lds	r24, 0x028C
     394:	90 91 8d 02 	lds	r25, 0x028D
     398:	89 2b       	or	r24, r25
     39a:	31 f4       	brne	.+12     	; 0x3a8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     39c:	81 e9       	ldi	r24, 0x91	; 145
     39e:	92 e0       	ldi	r25, 0x02	; 2
     3a0:	90 93 8d 02 	sts	0x028D, r25
     3a4:	80 93 8c 02 	sts	0x028C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3a8:	40 91 8e 02 	lds	r20, 0x028E
     3ac:	50 91 8f 02 	lds	r21, 0x028F
     3b0:	9e 01       	movw	r18, r28
     3b2:	24 0f       	add	r18, r20
     3b4:	35 1f       	adc	r19, r21
     3b6:	2b 3d       	cpi	r18, 0xDB	; 219
     3b8:	85 e0       	ldi	r24, 0x05	; 5
     3ba:	38 07       	cpc	r19, r24
     3bc:	70 f4       	brcc	.+28     	; 0x3da <pvPortMalloc+0x54>
     3be:	42 17       	cp	r20, r18
     3c0:	53 07       	cpc	r21, r19
     3c2:	70 f4       	brcc	.+28     	; 0x3e0 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3c4:	c0 91 8c 02 	lds	r28, 0x028C
     3c8:	d0 91 8d 02 	lds	r29, 0x028D
     3cc:	c4 0f       	add	r28, r20
     3ce:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3d0:	30 93 8f 02 	sts	0x028F, r19
     3d4:	20 93 8e 02 	sts	0x028E, r18
     3d8:	05 c0       	rjmp	.+10     	; 0x3e4 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3da:	c0 e0       	ldi	r28, 0x00	; 0
     3dc:	d0 e0       	ldi	r29, 0x00	; 0
     3de:	02 c0       	rjmp	.+4      	; 0x3e4 <pvPortMalloc+0x5e>
     3e0:	c0 e0       	ldi	r28, 0x00	; 0
     3e2:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     3e4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     3e8:	ce 01       	movw	r24, r28
     3ea:	df 91       	pop	r29
     3ec:	cf 91       	pop	r28
     3ee:	08 95       	ret

000003f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     3f0:	08 95       	ret

000003f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3f2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3f4:	03 96       	adiw	r24, 0x03	; 3
     3f6:	92 83       	std	Z+2, r25	; 0x02
     3f8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3fa:	2f ef       	ldi	r18, 0xFF	; 255
     3fc:	3f ef       	ldi	r19, 0xFF	; 255
     3fe:	34 83       	std	Z+4, r19	; 0x04
     400:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     402:	96 83       	std	Z+6, r25	; 0x06
     404:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     406:	90 87       	std	Z+8, r25	; 0x08
     408:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     40a:	10 82       	st	Z, r1
     40c:	08 95       	ret

0000040e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     40e:	fc 01       	movw	r30, r24
     410:	11 86       	std	Z+9, r1	; 0x09
     412:	10 86       	std	Z+8, r1	; 0x08
     414:	08 95       	ret

00000416 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     416:	cf 93       	push	r28
     418:	df 93       	push	r29
     41a:	9c 01       	movw	r18, r24
     41c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     41e:	dc 01       	movw	r26, r24
     420:	11 96       	adiw	r26, 0x01	; 1
     422:	cd 91       	ld	r28, X+
     424:	dc 91       	ld	r29, X
     426:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     428:	d3 83       	std	Z+3, r29	; 0x03
     42a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     42c:	8c 81       	ldd	r24, Y+4	; 0x04
     42e:	9d 81       	ldd	r25, Y+5	; 0x05
     430:	95 83       	std	Z+5, r25	; 0x05
     432:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     434:	8c 81       	ldd	r24, Y+4	; 0x04
     436:	9d 81       	ldd	r25, Y+5	; 0x05
     438:	dc 01       	movw	r26, r24
     43a:	13 96       	adiw	r26, 0x03	; 3
     43c:	7c 93       	st	X, r23
     43e:	6e 93       	st	-X, r22
     440:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     442:	7d 83       	std	Y+5, r23	; 0x05
     444:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     446:	31 87       	std	Z+9, r19	; 0x09
     448:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     44a:	f9 01       	movw	r30, r18
     44c:	80 81       	ld	r24, Z
     44e:	8f 5f       	subi	r24, 0xFF	; 255
     450:	80 83       	st	Z, r24
}
     452:	df 91       	pop	r29
     454:	cf 91       	pop	r28
     456:	08 95       	ret

00000458 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     458:	cf 93       	push	r28
     45a:	df 93       	push	r29
     45c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     45e:	48 81       	ld	r20, Y
     460:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     462:	4f 3f       	cpi	r20, 0xFF	; 255
     464:	2f ef       	ldi	r18, 0xFF	; 255
     466:	52 07       	cpc	r21, r18
     468:	21 f4       	brne	.+8      	; 0x472 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     46a:	fc 01       	movw	r30, r24
     46c:	a7 81       	ldd	r26, Z+7	; 0x07
     46e:	b0 85       	ldd	r27, Z+8	; 0x08
     470:	0d c0       	rjmp	.+26     	; 0x48c <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     472:	dc 01       	movw	r26, r24
     474:	13 96       	adiw	r26, 0x03	; 3
     476:	12 96       	adiw	r26, 0x02	; 2
     478:	ed 91       	ld	r30, X+
     47a:	fc 91       	ld	r31, X
     47c:	13 97       	sbiw	r26, 0x03	; 3
     47e:	20 81       	ld	r18, Z
     480:	31 81       	ldd	r19, Z+1	; 0x01
     482:	42 17       	cp	r20, r18
     484:	53 07       	cpc	r21, r19
     486:	10 f0       	brcs	.+4      	; 0x48c <vListInsert+0x34>
     488:	df 01       	movw	r26, r30
     48a:	f5 cf       	rjmp	.-22     	; 0x476 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     48c:	12 96       	adiw	r26, 0x02	; 2
     48e:	ed 91       	ld	r30, X+
     490:	fc 91       	ld	r31, X
     492:	13 97       	sbiw	r26, 0x03	; 3
     494:	fb 83       	std	Y+3, r31	; 0x03
     496:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     498:	d5 83       	std	Z+5, r29	; 0x05
     49a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     49c:	bd 83       	std	Y+5, r27	; 0x05
     49e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4a0:	13 96       	adiw	r26, 0x03	; 3
     4a2:	dc 93       	st	X, r29
     4a4:	ce 93       	st	-X, r28
     4a6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4a8:	99 87       	std	Y+9, r25	; 0x09
     4aa:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4ac:	fc 01       	movw	r30, r24
     4ae:	20 81       	ld	r18, Z
     4b0:	2f 5f       	subi	r18, 0xFF	; 255
     4b2:	20 83       	st	Z, r18
}
     4b4:	df 91       	pop	r29
     4b6:	cf 91       	pop	r28
     4b8:	08 95       	ret

000004ba <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4ba:	cf 93       	push	r28
     4bc:	df 93       	push	r29
     4be:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4c0:	a0 85       	ldd	r26, Z+8	; 0x08
     4c2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4c4:	c2 81       	ldd	r28, Z+2	; 0x02
     4c6:	d3 81       	ldd	r29, Z+3	; 0x03
     4c8:	84 81       	ldd	r24, Z+4	; 0x04
     4ca:	95 81       	ldd	r25, Z+5	; 0x05
     4cc:	9d 83       	std	Y+5, r25	; 0x05
     4ce:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4d0:	c4 81       	ldd	r28, Z+4	; 0x04
     4d2:	d5 81       	ldd	r29, Z+5	; 0x05
     4d4:	82 81       	ldd	r24, Z+2	; 0x02
     4d6:	93 81       	ldd	r25, Z+3	; 0x03
     4d8:	9b 83       	std	Y+3, r25	; 0x03
     4da:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4dc:	11 96       	adiw	r26, 0x01	; 1
     4de:	cd 91       	ld	r28, X+
     4e0:	dc 91       	ld	r29, X
     4e2:	12 97       	sbiw	r26, 0x02	; 2
     4e4:	ce 17       	cp	r28, r30
     4e6:	df 07       	cpc	r29, r31
     4e8:	31 f4       	brne	.+12     	; 0x4f6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4ea:	8c 81       	ldd	r24, Y+4	; 0x04
     4ec:	9d 81       	ldd	r25, Y+5	; 0x05
     4ee:	12 96       	adiw	r26, 0x02	; 2
     4f0:	9c 93       	st	X, r25
     4f2:	8e 93       	st	-X, r24
     4f4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     4f6:	11 86       	std	Z+9, r1	; 0x09
     4f8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4fa:	8c 91       	ld	r24, X
     4fc:	81 50       	subi	r24, 0x01	; 1
     4fe:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     500:	df 91       	pop	r29
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <MaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void MaxSonar_Start()
{
	MaxSonar_TriggerStart();
     506:	a1 9a       	sbi	0x14, 1	; 20
	
	delayMicro(25); // delay 25 micro seconds...
     508:	89 e1       	ldi	r24, 0x19	; 25
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	c2 d0       	rcall	.+388    	; 0x692 <delayMicro>
	delayMicro2(20);
     50e:	84 e1       	ldi	r24, 0x14	; 20
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	df d0       	rcall	.+446    	; 0x6d2 <delayMicro2>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     514:	84 b3       	in	r24, 0x14	; 20
     516:	14 ba       	out	0x14, r1	; 20
     518:	08 95       	ret

0000051a <MaxSonar_Read>:
}

// Return distance in cm
int MaxSonar_Read(char analogChannel)
{
	return analogRead(analogChannel) * valueToCM;
     51a:	9a d0       	rcall	.+308    	; 0x650 <analogRead>
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	9c 01       	movw	r18, r24
     520:	22 0f       	add	r18, r18
     522:	33 1f       	adc	r19, r19
     524:	22 0f       	add	r18, r18
     526:	33 1f       	adc	r19, r19
}
     528:	82 0f       	add	r24, r18
     52a:	93 1f       	adc	r25, r19
     52c:	08 95       	ret

0000052e <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     52e:	1f 92       	push	r1
     530:	0f 92       	push	r0
     532:	0f b6       	in	r0, 0x3f	; 63
     534:	0f 92       	push	r0
     536:	11 24       	eor	r1, r1
     538:	0b b6       	in	r0, 0x3b	; 59
     53a:	0f 92       	push	r0
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	ef 93       	push	r30
     552:	ff 93       	push	r31
	adcReading = ADCH; // read value
     554:	80 91 79 00 	lds	r24, 0x0079
     558:	80 93 d7 08 	sts	0x08D7, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     55c:	20 e0       	ldi	r18, 0x00	; 0
     55e:	40 e0       	ldi	r20, 0x00	; 0
     560:	50 e0       	ldi	r21, 0x00	; 0
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	70 e0       	ldi	r23, 0x00	; 0
     566:	80 91 da 08 	lds	r24, 0x08DA
     56a:	90 91 db 08 	lds	r25, 0x08DB
     56e:	ed d5       	rcall	.+3034   	; 0x114a <xQueueGenericSendFromISR>
}
     570:	ff 91       	pop	r31
     572:	ef 91       	pop	r30
     574:	bf 91       	pop	r27
     576:	af 91       	pop	r26
     578:	9f 91       	pop	r25
     57a:	8f 91       	pop	r24
     57c:	7f 91       	pop	r23
     57e:	6f 91       	pop	r22
     580:	5f 91       	pop	r21
     582:	4f 91       	pop	r20
     584:	3f 91       	pop	r19
     586:	2f 91       	pop	r18
     588:	0f 90       	pop	r0
     58a:	0b be       	out	0x3b, r0	; 59
     58c:	0f 90       	pop	r0
     58e:	0f be       	out	0x3f, r0	; 63
     590:	0f 90       	pop	r0
     592:	1f 90       	pop	r1
     594:	18 95       	reti

00000596 <ADC_Init>:

void ADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     596:	8f e8       	ldi	r24, 0x8F	; 143
     598:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     59c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     5a0:	80 e6       	ldi	r24, 0x60	; 96
     5a2:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     5a6:	43 e0       	ldi	r20, 0x03	; 3
     5a8:	60 e0       	ldi	r22, 0x00	; 0
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	e9 d4       	rcall	.+2514   	; 0xf80 <xQueueGenericCreate>
     5ae:	90 93 db 08 	sts	0x08DB, r25
     5b2:	80 93 da 08 	sts	0x08DA, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	a0 d5       	rcall	.+2880   	; 0x10fa <xQueueCreateMutex>
     5ba:	90 93 d9 08 	sts	0x08D9, r25
     5be:	80 93 d8 08 	sts	0x08D8, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     5c2:	20 e0       	ldi	r18, 0x00	; 0
     5c4:	40 e0       	ldi	r20, 0x00	; 0
     5c6:	50 e0       	ldi	r21, 0x00	; 0
     5c8:	60 e0       	ldi	r22, 0x00	; 0
     5ca:	70 e0       	ldi	r23, 0x00	; 0
     5cc:	03 c5       	rjmp	.+2566   	; 0xfd4 <xQueueGenericSend>
     5ce:	08 95       	ret

000005d0 <startADC>:
	return readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void startADC(char channel)
{
     5d0:	cf 93       	push	r28
     5d2:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	4f ef       	ldi	r20, 0xFF	; 255
     5d8:	5f ef       	ldi	r21, 0xFF	; 255
     5da:	60 e0       	ldi	r22, 0x00	; 0
     5dc:	70 e0       	ldi	r23, 0x00	; 0
     5de:	80 91 d8 08 	lds	r24, 0x08D8
     5e2:	90 91 d9 08 	lds	r25, 0x08D9
     5e6:	eb d5       	rcall	.+3030   	; 0x11be <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     5e8:	ec e7       	ldi	r30, 0x7C	; 124
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	80 81       	ld	r24, Z
     5ee:	9c 2f       	mov	r25, r28
     5f0:	9f 71       	andi	r25, 0x1F	; 31
     5f2:	80 76       	andi	r24, 0x60	; 96
     5f4:	89 2b       	or	r24, r25
     5f6:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     5f8:	eb e7       	ldi	r30, 0x7B	; 123
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	20 81       	ld	r18, Z
     5fe:	c0 72       	andi	r28, 0x20	; 32
     600:	8c 2f       	mov	r24, r28
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	95 95       	asr	r25
     606:	87 95       	ror	r24
     608:	95 95       	asr	r25
     60a:	87 95       	ror	r24
     60c:	92 2f       	mov	r25, r18
     60e:	90 76       	andi	r25, 0x60	; 96
     610:	89 2b       	or	r24, r25
     612:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     614:	ea e7       	ldi	r30, 0x7A	; 122
     616:	f0 e0       	ldi	r31, 0x00	; 0
     618:	80 81       	ld	r24, Z
     61a:	80 64       	ori	r24, 0x40	; 64
     61c:	80 83       	st	Z, r24
}
     61e:	cf 91       	pop	r28
     620:	08 95       	ret

00000622 <readADC>:

unsigned char readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	4f ef       	ldi	r20, 0xFF	; 255
     626:	5f ef       	ldi	r21, 0xFF	; 255
     628:	60 e0       	ldi	r22, 0x00	; 0
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	80 91 da 08 	lds	r24, 0x08DA
     630:	90 91 db 08 	lds	r25, 0x08DB
     634:	c4 d5       	rcall	.+2952   	; 0x11be <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	40 e0       	ldi	r20, 0x00	; 0
     63a:	50 e0       	ldi	r21, 0x00	; 0
     63c:	60 e0       	ldi	r22, 0x00	; 0
     63e:	70 e0       	ldi	r23, 0x00	; 0
     640:	80 91 d8 08 	lds	r24, 0x08D8
     644:	90 91 d9 08 	lds	r25, 0x08D9
     648:	c5 d4       	rcall	.+2442   	; 0xfd4 <xQueueGenericSend>
	return adcReading;
     64a:	80 91 d7 08 	lds	r24, 0x08D7
     64e:	08 95       	ret

00000650 <analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char analogRead(char channel)
{
     650:	cf 93       	push	r28
     652:	c8 2f       	mov	r28, r24
	startADC(channel);
     654:	bd df       	rcall	.-134    	; 0x5d0 <startADC>
	return readADC(channel);
     656:	8c 2f       	mov	r24, r28
     658:	e4 df       	rcall	.-56     	; 0x622 <readADC>
}
     65a:	cf 91       	pop	r28
     65c:	08 95       	ret

0000065e <MyTimer_Init>:

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
}
     65e:	90 93 e1 08 	sts	0x08E1, r25
     662:	80 93 e0 08 	sts	0x08E0, r24
     666:	fc 01       	movw	r30, r24
     668:	80 81       	ld	r24, Z
     66a:	91 81       	ldd	r25, Z+1	; 0x01
     66c:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <vTaskSuspend>
     670:	43 e0       	ldi	r20, 0x03	; 3
     672:	60 e0       	ldi	r22, 0x00	; 0
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	84 d4       	rcall	.+2312   	; 0xf80 <xQueueGenericCreate>
     678:	90 93 dd 08 	sts	0x08DD, r25
     67c:	80 93 dc 08 	sts	0x08DC, r24
     680:	43 e0       	ldi	r20, 0x03	; 3
     682:	60 e0       	ldi	r22, 0x00	; 0
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	7c d4       	rcall	.+2296   	; 0xf80 <xQueueGenericCreate>
     688:	90 93 df 08 	sts	0x08DF, r25
     68c:	80 93 de 08 	sts	0x08DE, r24
     690:	08 95       	ret

00000692 <delayMicro>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     692:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     694:	4f 5f       	subi	r20, 0xFF	; 255
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = readTimer();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     696:	9c 01       	movw	r18, r24
     698:	99 23       	and	r25, r25
     69a:	14 f4       	brge	.+4      	; 0x6a0 <delayMicro+0xe>
     69c:	2d 5f       	subi	r18, 0xFD	; 253
     69e:	3f 4f       	sbci	r19, 0xFF	; 255
     6a0:	35 95       	asr	r19
     6a2:	27 95       	ror	r18
     6a4:	35 95       	asr	r19
     6a6:	27 95       	ror	r18
	expectedTick = currentTick + delay + 1; // add 1 tick for positive error...	
     6a8:	24 0f       	add	r18, r20
     6aa:	20 93 01 02 	sts	0x0201, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     6ae:	e0 91 e0 08 	lds	r30, 0x08E0
     6b2:	f0 91 e1 08 	lds	r31, 0x08E1
     6b6:	80 81       	ld	r24, Z
     6b8:	91 81       	ldd	r25, Z+1	; 0x01
     6ba:	db d7       	rcall	.+4022   	; 0x1672 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     6bc:	20 e0       	ldi	r18, 0x00	; 0
     6be:	42 e0       	ldi	r20, 0x02	; 2
     6c0:	50 e0       	ldi	r21, 0x00	; 0
     6c2:	60 e0       	ldi	r22, 0x00	; 0
     6c4:	70 e0       	ldi	r23, 0x00	; 0
     6c6:	80 91 dc 08 	lds	r24, 0x08DC
     6ca:	90 91 dd 08 	lds	r25, 0x08DD
     6ce:	77 c5       	rjmp	.+2798   	; 0x11be <xQueueGenericReceive>
     6d0:	08 95       	ret

000006d2 <delayMicro2>:
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     6d2:	46 b5       	in	r20, 0x26	; 38
void delayMicro2(int delay)
{
	unsigned char currentTick = readTimer();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay + 1; // add 1 tick for positive error...
     6d4:	4f 5f       	subi	r20, 0xFF	; 255
// duplicate of delayMicro....
void delayMicro2(int delay)
{
	unsigned char currentTick = readTimer();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     6d6:	9c 01       	movw	r18, r24
     6d8:	99 23       	and	r25, r25
     6da:	14 f4       	brge	.+4      	; 0x6e0 <delayMicro2+0xe>
     6dc:	2d 5f       	subi	r18, 0xFD	; 253
     6de:	3f 4f       	sbci	r19, 0xFF	; 255
     6e0:	35 95       	asr	r19
     6e2:	27 95       	ror	r18
     6e4:	35 95       	asr	r19
     6e6:	27 95       	ror	r18
	expectedTick2 = currentTick + delay + 1; // add 1 tick for positive error...
     6e8:	24 0f       	add	r18, r20
     6ea:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     6ee:	e0 91 e0 08 	lds	r30, 0x08E0
     6f2:	f0 91 e1 08 	lds	r31, 0x08E1
     6f6:	80 81       	ld	r24, Z
     6f8:	91 81       	ldd	r25, Z+1	; 0x01
     6fa:	bb d7       	rcall	.+3958   	; 0x1672 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     6fc:	20 e0       	ldi	r18, 0x00	; 0
     6fe:	42 e0       	ldi	r20, 0x02	; 2
     700:	50 e0       	ldi	r21, 0x00	; 0
     702:	60 e0       	ldi	r22, 0x00	; 0
     704:	70 e0       	ldi	r23, 0x00	; 0
     706:	80 91 de 08 	lds	r24, 0x08DE
     70a:	90 91 df 08 	lds	r25, 0x08DF
     70e:	57 c5       	rjmp	.+2734   	; 0x11be <xQueueGenericReceive>
     710:	08 95       	ret

00000712 <delayMicroCheck>:
}

// Semaphore on sale if u match lucky number ...
void delayMicroCheck()
{
     712:	cf 93       	push	r28
}

// Return timer 0 value
unsigned char readTimer()
{
	return TCNT0;
     714:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void delayMicroCheck()
{
	unsigned char currentTick = readTimer();
	
	if( currentTick >= expectedTick)
     716:	80 91 01 02 	lds	r24, 0x0201
     71a:	c8 17       	cp	r28, r24
     71c:	68 f0       	brcs	.+26     	; 0x738 <delayMicroCheck+0x26>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     71e:	8e ef       	ldi	r24, 0xFE	; 254
     720:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     724:	20 e0       	ldi	r18, 0x00	; 0
     726:	40 e0       	ldi	r20, 0x00	; 0
     728:	50 e0       	ldi	r21, 0x00	; 0
     72a:	60 e0       	ldi	r22, 0x00	; 0
     72c:	70 e0       	ldi	r23, 0x00	; 0
     72e:	80 91 dc 08 	lds	r24, 0x08DC
     732:	90 91 dd 08 	lds	r25, 0x08DD
     736:	4e d4       	rcall	.+2204   	; 0xfd4 <xQueueGenericSend>
	}
	
	
	if( currentTick >= expectedTick2)
     738:	80 91 00 02 	lds	r24, 0x0200
     73c:	c8 17       	cp	r28, r24
     73e:	68 f0       	brcs	.+26     	; 0x75a <delayMicroCheck+0x48>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     740:	8e ef       	ldi	r24, 0xFE	; 254
     742:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	40 e0       	ldi	r20, 0x00	; 0
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	80 91 de 08 	lds	r24, 0x08DE
     754:	90 91 df 08 	lds	r25, 0x08DF
     758:	3d d4       	rcall	.+2170   	; 0xfd4 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     75a:	80 91 01 02 	lds	r24, 0x0201
     75e:	8e 3f       	cpi	r24, 0xFE	; 254
     760:	61 f4       	brne	.+24     	; 0x77a <delayMicroCheck+0x68>
     762:	80 91 00 02 	lds	r24, 0x0200
     766:	8e 3f       	cpi	r24, 0xFE	; 254
     768:	41 f4       	brne	.+16     	; 0x77a <delayMicroCheck+0x68>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     76a:	e0 91 e0 08 	lds	r30, 0x08E0
     76e:	f0 91 e1 08 	lds	r31, 0x08E1
     772:	80 81       	ld	r24, Z
     774:	91 81       	ldd	r25, Z+1	; 0x01
     776:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <vTaskSuspend>
	}
     77a:	cf 91       	pop	r28
     77c:	08 95       	ret

0000077e <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     77e:	1f 92       	push	r1
     780:	0f 92       	push	r0
     782:	0f b6       	in	r0, 0x3f	; 63
     784:	0f 92       	push	r0
     786:	11 24       	eor	r1, r1
     788:	0b b6       	in	r0, 0x3b	; 59
     78a:	0f 92       	push	r0
     78c:	2f 93       	push	r18
     78e:	3f 93       	push	r19
     790:	4f 93       	push	r20
     792:	5f 93       	push	r21
     794:	6f 93       	push	r22
     796:	7f 93       	push	r23
     798:	8f 93       	push	r24
     79a:	9f 93       	push	r25
     79c:	af 93       	push	r26
     79e:	bf 93       	push	r27
     7a0:	ef 93       	push	r30
     7a2:	ff 93       	push	r31
     7a4:	60 91 ce 00 	lds	r22, 0x00CE
     7a8:	85 e7       	ldi	r24, 0x75	; 117
     7aa:	99 e0       	ldi	r25, 0x09	; 9
     7ac:	d4 d5       	rcall	.+2984   	; 0x1356 <ringBufferPush>
     7ae:	20 e0       	ldi	r18, 0x00	; 0
     7b0:	40 e0       	ldi	r20, 0x00	; 0
     7b2:	50 e0       	ldi	r21, 0x00	; 0
     7b4:	60 e0       	ldi	r22, 0x00	; 0
     7b6:	70 e0       	ldi	r23, 0x00	; 0
     7b8:	80 91 69 09 	lds	r24, 0x0969
     7bc:	90 91 6a 09 	lds	r25, 0x096A
     7c0:	c4 d4       	rcall	.+2440   	; 0x114a <xQueueGenericSendFromISR>
     7c2:	85 e7       	ldi	r24, 0x75	; 117
     7c4:	99 e0       	ldi	r25, 0x09	; 9
     7c6:	dd d5       	rcall	.+3002   	; 0x1382 <ringBufferFull>
     7c8:	ff 91       	pop	r31
     7ca:	ef 91       	pop	r30
     7cc:	bf 91       	pop	r27
     7ce:	af 91       	pop	r26
     7d0:	9f 91       	pop	r25
     7d2:	8f 91       	pop	r24
     7d4:	7f 91       	pop	r23
     7d6:	6f 91       	pop	r22
     7d8:	5f 91       	pop	r21
     7da:	4f 91       	pop	r20
     7dc:	3f 91       	pop	r19
     7de:	2f 91       	pop	r18
     7e0:	0f 90       	pop	r0
     7e2:	0b be       	out	0x3b, r0	; 59
     7e4:	0f 90       	pop	r0
     7e6:	0f be       	out	0x3f, r0	; 63
     7e8:	0f 90       	pop	r0
     7ea:	1f 90       	pop	r1
     7ec:	18 95       	reti

000007ee <__vector_25>:
     7ee:	1f 92       	push	r1
     7f0:	0f 92       	push	r0
     7f2:	0f b6       	in	r0, 0x3f	; 63
     7f4:	0f 92       	push	r0
     7f6:	11 24       	eor	r1, r1
     7f8:	0b b6       	in	r0, 0x3b	; 59
     7fa:	0f 92       	push	r0
     7fc:	2f 93       	push	r18
     7fe:	3f 93       	push	r19
     800:	4f 93       	push	r20
     802:	5f 93       	push	r21
     804:	6f 93       	push	r22
     806:	7f 93       	push	r23
     808:	8f 93       	push	r24
     80a:	9f 93       	push	r25
     80c:	af 93       	push	r26
     80e:	bf 93       	push	r27
     810:	ef 93       	push	r30
     812:	ff 93       	push	r31
     814:	60 91 c6 00 	lds	r22, 0x00C6
     818:	82 e0       	ldi	r24, 0x02	; 2
     81a:	99 e0       	ldi	r25, 0x09	; 9
     81c:	9c d5       	rcall	.+2872   	; 0x1356 <ringBufferPush>
     81e:	20 e0       	ldi	r18, 0x00	; 0
     820:	40 e0       	ldi	r20, 0x00	; 0
     822:	50 e0       	ldi	r21, 0x00	; 0
     824:	60 e0       	ldi	r22, 0x00	; 0
     826:	70 e0       	ldi	r23, 0x00	; 0
     828:	80 91 69 09 	lds	r24, 0x0969
     82c:	90 91 6a 09 	lds	r25, 0x096A
     830:	8c d4       	rcall	.+2328   	; 0x114a <xQueueGenericSendFromISR>
     832:	82 e0       	ldi	r24, 0x02	; 2
     834:	99 e0       	ldi	r25, 0x09	; 9
     836:	a5 d5       	rcall	.+2890   	; 0x1382 <ringBufferFull>
     838:	ff 91       	pop	r31
     83a:	ef 91       	pop	r30
     83c:	bf 91       	pop	r27
     83e:	af 91       	pop	r26
     840:	9f 91       	pop	r25
     842:	8f 91       	pop	r24
     844:	7f 91       	pop	r23
     846:	6f 91       	pop	r22
     848:	5f 91       	pop	r21
     84a:	4f 91       	pop	r20
     84c:	3f 91       	pop	r19
     84e:	2f 91       	pop	r18
     850:	0f 90       	pop	r0
     852:	0b be       	out	0x3b, r0	; 59
     854:	0f 90       	pop	r0
     856:	0f be       	out	0x3f, r0	; 63
     858:	0f 90       	pop	r0
     85a:	1f 90       	pop	r1
     85c:	18 95       	reti

0000085e <__vector_37>:
     85e:	1f 92       	push	r1
     860:	0f 92       	push	r0
     862:	0f b6       	in	r0, 0x3f	; 63
     864:	0f 92       	push	r0
     866:	11 24       	eor	r1, r1
     868:	0b b6       	in	r0, 0x3b	; 59
     86a:	0f 92       	push	r0
     86c:	2f 93       	push	r18
     86e:	3f 93       	push	r19
     870:	4f 93       	push	r20
     872:	5f 93       	push	r21
     874:	6f 93       	push	r22
     876:	7f 93       	push	r23
     878:	8f 93       	push	r24
     87a:	9f 93       	push	r25
     87c:	af 93       	push	r26
     87e:	bf 93       	push	r27
     880:	ef 93       	push	r30
     882:	ff 93       	push	r31
     884:	8b e6       	ldi	r24, 0x6B	; 107
     886:	99 e0       	ldi	r25, 0x09	; 9
     888:	83 d5       	rcall	.+2822   	; 0x1390 <ringBufferNotEmpty>
     88a:	88 23       	and	r24, r24
     88c:	31 f0       	breq	.+12     	; 0x89a <__vector_37+0x3c>
     88e:	8b e6       	ldi	r24, 0x6B	; 107
     890:	99 e0       	ldi	r25, 0x09	; 9
     892:	4f d5       	rcall	.+2718   	; 0x1332 <ringBufferPop>
     894:	80 93 ce 00 	sts	0x00CE, r24
     898:	05 c0       	rjmp	.+10     	; 0x8a4 <__vector_37+0x46>
     89a:	e9 ec       	ldi	r30, 0xC9	; 201
     89c:	f0 e0       	ldi	r31, 0x00	; 0
     89e:	80 81       	ld	r24, Z
     8a0:	8f 7d       	andi	r24, 0xDF	; 223
     8a2:	80 83       	st	Z, r24
     8a4:	ff 91       	pop	r31
     8a6:	ef 91       	pop	r30
     8a8:	bf 91       	pop	r27
     8aa:	af 91       	pop	r26
     8ac:	9f 91       	pop	r25
     8ae:	8f 91       	pop	r24
     8b0:	7f 91       	pop	r23
     8b2:	6f 91       	pop	r22
     8b4:	5f 91       	pop	r21
     8b6:	4f 91       	pop	r20
     8b8:	3f 91       	pop	r19
     8ba:	2f 91       	pop	r18
     8bc:	0f 90       	pop	r0
     8be:	0b be       	out	0x3b, r0	; 59
     8c0:	0f 90       	pop	r0
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	0f 90       	pop	r0
     8c6:	1f 90       	pop	r1
     8c8:	18 95       	reti

000008ca <__vector_26>:
     8ca:	1f 92       	push	r1
     8cc:	0f 92       	push	r0
     8ce:	0f b6       	in	r0, 0x3f	; 63
     8d0:	0f 92       	push	r0
     8d2:	11 24       	eor	r1, r1
     8d4:	0b b6       	in	r0, 0x3b	; 59
     8d6:	0f 92       	push	r0
     8d8:	2f 93       	push	r18
     8da:	3f 93       	push	r19
     8dc:	4f 93       	push	r20
     8de:	5f 93       	push	r21
     8e0:	6f 93       	push	r22
     8e2:	7f 93       	push	r23
     8e4:	8f 93       	push	r24
     8e6:	9f 93       	push	r25
     8e8:	af 93       	push	r26
     8ea:	bf 93       	push	r27
     8ec:	ef 93       	push	r30
     8ee:	ff 93       	push	r31
     8f0:	80 e7       	ldi	r24, 0x70	; 112
     8f2:	99 e0       	ldi	r25, 0x09	; 9
     8f4:	4d d5       	rcall	.+2714   	; 0x1390 <ringBufferNotEmpty>
     8f6:	88 23       	and	r24, r24
     8f8:	31 f0       	breq	.+12     	; 0x906 <__vector_26+0x3c>
     8fa:	80 e7       	ldi	r24, 0x70	; 112
     8fc:	99 e0       	ldi	r25, 0x09	; 9
     8fe:	19 d5       	rcall	.+2610   	; 0x1332 <ringBufferPop>
     900:	80 93 c6 00 	sts	0x00C6, r24
     904:	05 c0       	rjmp	.+10     	; 0x910 <__vector_26+0x46>
     906:	e1 ec       	ldi	r30, 0xC1	; 193
     908:	f0 e0       	ldi	r31, 0x00	; 0
     90a:	80 81       	ld	r24, Z
     90c:	8f 7d       	andi	r24, 0xDF	; 223
     90e:	80 83       	st	Z, r24
     910:	ff 91       	pop	r31
     912:	ef 91       	pop	r30
     914:	bf 91       	pop	r27
     916:	af 91       	pop	r26
     918:	9f 91       	pop	r25
     91a:	8f 91       	pop	r24
     91c:	7f 91       	pop	r23
     91e:	6f 91       	pop	r22
     920:	5f 91       	pop	r21
     922:	4f 91       	pop	r20
     924:	3f 91       	pop	r19
     926:	2f 91       	pop	r18
     928:	0f 90       	pop	r0
     92a:	0b be       	out	0x3b, r0	; 59
     92c:	0f 90       	pop	r0
     92e:	0f be       	out	0x3f, r0	; 63
     930:	0f 90       	pop	r0
     932:	1f 90       	pop	r1
     934:	18 95       	reti

00000936 <USART0_Init>:
     936:	10 92 c5 00 	sts	0x00C5, r1
     93a:	87 e6       	ldi	r24, 0x67	; 103
     93c:	80 93 c4 00 	sts	0x00C4, r24
     940:	88 eb       	ldi	r24, 0xB8	; 184
     942:	80 93 c1 00 	sts	0x00C1, r24
     946:	86 e0       	ldi	r24, 0x06	; 6
     948:	80 93 c2 00 	sts	0x00C2, r24
     94c:	40 e2       	ldi	r20, 0x20	; 32
     94e:	67 e2       	ldi	r22, 0x27	; 39
     950:	79 e0       	ldi	r23, 0x09	; 9
     952:	82 e0       	ldi	r24, 0x02	; 2
     954:	99 e0       	ldi	r25, 0x09	; 9
     956:	e6 d4       	rcall	.+2508   	; 0x1324 <ringBufferInit>
     958:	40 e2       	ldi	r20, 0x20	; 32
     95a:	67 e0       	ldi	r22, 0x07	; 7
     95c:	79 e0       	ldi	r23, 0x09	; 9
     95e:	80 e7       	ldi	r24, 0x70	; 112
     960:	99 e0       	ldi	r25, 0x09	; 9
     962:	e0 d4       	rcall	.+2496   	; 0x1324 <ringBufferInit>
     964:	43 e0       	ldi	r20, 0x03	; 3
     966:	60 e0       	ldi	r22, 0x00	; 0
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	0a d3       	rcall	.+1556   	; 0xf80 <xQueueGenericCreate>
     96c:	90 93 68 09 	sts	0x0968, r25
     970:	80 93 67 09 	sts	0x0967, r24
     974:	08 95       	ret

00000976 <USART1_Init>:
     976:	10 92 cd 00 	sts	0x00CD, r1
     97a:	87 e6       	ldi	r24, 0x67	; 103
     97c:	80 93 cc 00 	sts	0x00CC, r24
     980:	88 eb       	ldi	r24, 0xB8	; 184
     982:	80 93 c9 00 	sts	0x00C9, r24
     986:	86 e0       	ldi	r24, 0x06	; 6
     988:	80 93 ca 00 	sts	0x00CA, r24
     98c:	40 e2       	ldi	r20, 0x20	; 32
     98e:	62 ee       	ldi	r22, 0xE2	; 226
     990:	78 e0       	ldi	r23, 0x08	; 8
     992:	85 e7       	ldi	r24, 0x75	; 117
     994:	99 e0       	ldi	r25, 0x09	; 9
     996:	c6 d4       	rcall	.+2444   	; 0x1324 <ringBufferInit>
     998:	40 e2       	ldi	r20, 0x20	; 32
     99a:	67 e4       	ldi	r22, 0x47	; 71
     99c:	79 e0       	ldi	r23, 0x09	; 9
     99e:	8b e6       	ldi	r24, 0x6B	; 107
     9a0:	99 e0       	ldi	r25, 0x09	; 9
     9a2:	c0 d4       	rcall	.+2432   	; 0x1324 <ringBufferInit>
     9a4:	43 e0       	ldi	r20, 0x03	; 3
     9a6:	60 e0       	ldi	r22, 0x00	; 0
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	ea d2       	rcall	.+1492   	; 0xf80 <xQueueGenericCreate>
     9ac:	90 93 6a 09 	sts	0x096A, r25
     9b0:	80 93 69 09 	sts	0x0969, r24
     9b4:	08 95       	ret

000009b6 <transmitUSART0_c>:
     9b6:	cf 93       	push	r28
     9b8:	c8 2f       	mov	r28, r24
     9ba:	80 e7       	ldi	r24, 0x70	; 112
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	e1 d4       	rcall	.+2498   	; 0x1382 <ringBufferFull>
     9c0:	81 11       	cpse	r24, r1
     9c2:	fb cf       	rjmp	.-10     	; 0x9ba <transmitUSART0_c+0x4>
     9c4:	6c 2f       	mov	r22, r28
     9c6:	80 e7       	ldi	r24, 0x70	; 112
     9c8:	99 e0       	ldi	r25, 0x09	; 9
     9ca:	c5 d4       	rcall	.+2442   	; 0x1356 <ringBufferPush>
     9cc:	e1 ec       	ldi	r30, 0xC1	; 193
     9ce:	f0 e0       	ldi	r31, 0x00	; 0
     9d0:	80 81       	ld	r24, Z
     9d2:	80 62       	ori	r24, 0x20	; 32
     9d4:	80 83       	st	Z, r24
     9d6:	e0 ec       	ldi	r30, 0xC0	; 192
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	80 81       	ld	r24, Z
     9dc:	80 64       	ori	r24, 0x40	; 64
     9de:	80 83       	st	Z, r24
     9e0:	cf 91       	pop	r28
     9e2:	08 95       	ret

000009e4 <transmitUSART1_c>:
     9e4:	cf 93       	push	r28
     9e6:	c8 2f       	mov	r28, r24
     9e8:	8b e6       	ldi	r24, 0x6B	; 107
     9ea:	99 e0       	ldi	r25, 0x09	; 9
     9ec:	ca d4       	rcall	.+2452   	; 0x1382 <ringBufferFull>
     9ee:	81 11       	cpse	r24, r1
     9f0:	fb cf       	rjmp	.-10     	; 0x9e8 <transmitUSART1_c+0x4>
     9f2:	6c 2f       	mov	r22, r28
     9f4:	8b e6       	ldi	r24, 0x6B	; 107
     9f6:	99 e0       	ldi	r25, 0x09	; 9
     9f8:	ae d4       	rcall	.+2396   	; 0x1356 <ringBufferPush>
     9fa:	e9 ec       	ldi	r30, 0xC9	; 201
     9fc:	f0 e0       	ldi	r31, 0x00	; 0
     9fe:	80 81       	ld	r24, Z
     a00:	80 62       	ori	r24, 0x20	; 32
     a02:	80 83       	st	Z, r24
     a04:	e8 ec       	ldi	r30, 0xC8	; 200
     a06:	f0 e0       	ldi	r31, 0x00	; 0
     a08:	80 81       	ld	r24, Z
     a0a:	80 64       	ori	r24, 0x40	; 64
     a0c:	80 83       	st	Z, r24
     a0e:	cf 91       	pop	r28
     a10:	08 95       	ret

00000a12 <transmitUSART0>:
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	ec 01       	movw	r28, r24
     a18:	88 81       	ld	r24, Y
     a1a:	88 23       	and	r24, r24
     a1c:	29 f0       	breq	.+10     	; 0xa28 <transmitUSART0+0x16>
     a1e:	21 96       	adiw	r28, 0x01	; 1
     a20:	ca df       	rcall	.-108    	; 0x9b6 <transmitUSART0_c>
     a22:	89 91       	ld	r24, Y+
     a24:	81 11       	cpse	r24, r1
     a26:	fc cf       	rjmp	.-8      	; 0xa20 <transmitUSART0+0xe>
     a28:	df 91       	pop	r29
     a2a:	cf 91       	pop	r28
     a2c:	08 95       	ret

00000a2e <receiveUSART1>:
     a2e:	cf 93       	push	r28
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	4f ef       	ldi	r20, 0xFF	; 255
     a34:	5f ef       	ldi	r21, 0xFF	; 255
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	70 e0       	ldi	r23, 0x00	; 0
     a3a:	80 91 67 09 	lds	r24, 0x0967
     a3e:	90 91 68 09 	lds	r25, 0x0968
     a42:	bd d3       	rcall	.+1914   	; 0x11be <xQueueGenericReceive>
     a44:	85 e7       	ldi	r24, 0x75	; 117
     a46:	99 e0       	ldi	r25, 0x09	; 9
     a48:	74 d4       	rcall	.+2280   	; 0x1332 <ringBufferPop>
     a4a:	c8 2f       	mov	r28, r24
     a4c:	85 e7       	ldi	r24, 0x75	; 117
     a4e:	99 e0       	ldi	r25, 0x09	; 9
     a50:	9f d4       	rcall	.+2366   	; 0x1390 <ringBufferNotEmpty>
     a52:	88 23       	and	r24, r24
     a54:	51 f0       	breq	.+20     	; 0xa6a <receiveUSART1+0x3c>
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	40 e0       	ldi	r20, 0x00	; 0
     a5a:	50 e0       	ldi	r21, 0x00	; 0
     a5c:	60 e0       	ldi	r22, 0x00	; 0
     a5e:	70 e0       	ldi	r23, 0x00	; 0
     a60:	80 91 67 09 	lds	r24, 0x0967
     a64:	90 91 68 09 	lds	r25, 0x0968
     a68:	b5 d2       	rcall	.+1386   	; 0xfd4 <xQueueGenericSend>
     a6a:	8c 2f       	mov	r24, r28
     a6c:	cf 91       	pop	r28
     a6e:	08 95       	ret

00000a70 <startHandShake>:

// -1 if fail, 0 success
char startHandShake()
{
	transmitUSART1_c(HANDSHAKE_START);
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	b8 df       	rcall	.-144    	; 0x9e4 <transmitUSART1_c>
	
	if (! receiveHandShakeAck(receiveUSART1()))
     a74:	dc df       	rcall	.-72     	; 0xa2e <receiveUSART1>
     a76:	85 35       	cpi	r24, 0x55	; 85
     a78:	21 f4       	brne	.+8      	; 0xa82 <startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
     a7a:	8f ef       	ldi	r24, 0xFF	; 255
     a7c:	b3 df       	rcall	.-154    	; 0x9e4 <transmitUSART1_c>
	
	return 0;
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	08 95       	ret
{
	transmitUSART1_c(HANDSHAKE_START);
	
	if (! receiveHandShakeAck(receiveUSART1()))
	{
		return -1; //error handling
     a82:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     a84:	08 95       	ret

00000a86 <waitForHandshake>:


// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
     a86:	d3 df       	rcall	.-90     	; 0xa2e <receiveUSART1>
     a88:	81 11       	cpse	r24, r1
     a8a:	0a c0       	rjmp	.+20     	; 0xaa0 <waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	transmitUSART1_c(HANDSHAKE_ACK);
     a8c:	85 e5       	ldi	r24, 0x55	; 85
     a8e:	aa df       	rcall	.-172    	; 0x9e4 <transmitUSART1_c>
	
	if (! receiveHandShakeStart(receiveUSART1()))
     a90:	ce df       	rcall	.-100    	; 0xa2e <receiveUSART1>
     a92:	91 e0       	ldi	r25, 0x01	; 1
     a94:	81 11       	cpse	r24, r1
     a96:	01 c0       	rjmp	.+2      	; 0xa9a <waitForHandshake+0x14>
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	89 2f       	mov	r24, r25
     a9c:	81 95       	neg	r24
     a9e:	08 95       	ret
// -1 if fail, 0 success
char waitForHandshake()
{
	if (! receiveHandShakeStart(receiveUSART1()))
	{
		return -1; // error handling
     aa0:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     aa2:	08 95       	ret

00000aa4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     aa4:	31 e1       	ldi	r19, 0x11	; 17
     aa6:	fc 01       	movw	r30, r24
     aa8:	30 83       	st	Z, r19
     aaa:	31 97       	sbiw	r30, 0x01	; 1
     aac:	22 e2       	ldi	r18, 0x22	; 34
     aae:	20 83       	st	Z, r18
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	a3 e3       	ldi	r26, 0x33	; 51
     ab4:	a0 83       	st	Z, r26
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	60 83       	st	Z, r22
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	70 83       	st	Z, r23
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	10 82       	st	Z, r1
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	10 82       	st	Z, r1
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	60 e8       	ldi	r22, 0x80	; 128
     aca:	60 83       	st	Z, r22
     acc:	31 97       	sbiw	r30, 0x01	; 1
     ace:	10 82       	st	Z, r1
     ad0:	31 97       	sbiw	r30, 0x01	; 1
     ad2:	10 82       	st	Z, r1
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	10 82       	st	Z, r1
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	62 e0       	ldi	r22, 0x02	; 2
     adc:	60 83       	st	Z, r22
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	63 e0       	ldi	r22, 0x03	; 3
     ae2:	60 83       	st	Z, r22
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	64 e0       	ldi	r22, 0x04	; 4
     ae8:	60 83       	st	Z, r22
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	65 e0       	ldi	r22, 0x05	; 5
     aee:	60 83       	st	Z, r22
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	66 e0       	ldi	r22, 0x06	; 6
     af4:	60 83       	st	Z, r22
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	67 e0       	ldi	r22, 0x07	; 7
     afa:	60 83       	st	Z, r22
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	68 e0       	ldi	r22, 0x08	; 8
     b00:	60 83       	st	Z, r22
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	69 e0       	ldi	r22, 0x09	; 9
     b06:	60 83       	st	Z, r22
     b08:	31 97       	sbiw	r30, 0x01	; 1
     b0a:	60 e1       	ldi	r22, 0x10	; 16
     b0c:	60 83       	st	Z, r22
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	30 83       	st	Z, r19
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	32 e1       	ldi	r19, 0x12	; 18
     b16:	30 83       	st	Z, r19
     b18:	31 97       	sbiw	r30, 0x01	; 1
     b1a:	33 e1       	ldi	r19, 0x13	; 19
     b1c:	30 83       	st	Z, r19
     b1e:	31 97       	sbiw	r30, 0x01	; 1
     b20:	34 e1       	ldi	r19, 0x14	; 20
     b22:	30 83       	st	Z, r19
     b24:	31 97       	sbiw	r30, 0x01	; 1
     b26:	35 e1       	ldi	r19, 0x15	; 21
     b28:	30 83       	st	Z, r19
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	36 e1       	ldi	r19, 0x16	; 22
     b2e:	30 83       	st	Z, r19
     b30:	31 97       	sbiw	r30, 0x01	; 1
     b32:	37 e1       	ldi	r19, 0x17	; 23
     b34:	30 83       	st	Z, r19
     b36:	31 97       	sbiw	r30, 0x01	; 1
     b38:	38 e1       	ldi	r19, 0x18	; 24
     b3a:	30 83       	st	Z, r19
     b3c:	31 97       	sbiw	r30, 0x01	; 1
     b3e:	39 e1       	ldi	r19, 0x19	; 25
     b40:	30 83       	st	Z, r19
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	30 e2       	ldi	r19, 0x20	; 32
     b46:	30 83       	st	Z, r19
     b48:	31 97       	sbiw	r30, 0x01	; 1
     b4a:	31 e2       	ldi	r19, 0x21	; 33
     b4c:	30 83       	st	Z, r19
     b4e:	31 97       	sbiw	r30, 0x01	; 1
     b50:	20 83       	st	Z, r18
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	23 e2       	ldi	r18, 0x23	; 35
     b56:	20 83       	st	Z, r18
     b58:	31 97       	sbiw	r30, 0x01	; 1
     b5a:	40 83       	st	Z, r20
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	50 83       	st	Z, r21
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	26 e2       	ldi	r18, 0x26	; 38
     b64:	20 83       	st	Z, r18
     b66:	31 97       	sbiw	r30, 0x01	; 1
     b68:	27 e2       	ldi	r18, 0x27	; 39
     b6a:	20 83       	st	Z, r18
     b6c:	31 97       	sbiw	r30, 0x01	; 1
     b6e:	28 e2       	ldi	r18, 0x28	; 40
     b70:	20 83       	st	Z, r18
     b72:	31 97       	sbiw	r30, 0x01	; 1
     b74:	29 e2       	ldi	r18, 0x29	; 41
     b76:	20 83       	st	Z, r18
     b78:	31 97       	sbiw	r30, 0x01	; 1
     b7a:	20 e3       	ldi	r18, 0x30	; 48
     b7c:	20 83       	st	Z, r18
     b7e:	31 97       	sbiw	r30, 0x01	; 1
     b80:	21 e3       	ldi	r18, 0x31	; 49
     b82:	20 83       	st	Z, r18
     b84:	89 97       	sbiw	r24, 0x29	; 41
     b86:	08 95       	ret

00000b88 <xPortStartScheduler>:
     b88:	82 e0       	ldi	r24, 0x02	; 2
     b8a:	84 bd       	out	0x24, r24	; 36
     b8c:	16 bc       	out	0x26, r1	; 38
     b8e:	80 e3       	ldi	r24, 0x30	; 48
     b90:	87 bd       	out	0x27, r24	; 39
     b92:	ee e6       	ldi	r30, 0x6E	; 110
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	80 81       	ld	r24, Z
     b98:	82 60       	ori	r24, 0x02	; 2
     b9a:	80 83       	st	Z, r24
     b9c:	83 e0       	ldi	r24, 0x03	; 3
     b9e:	85 bd       	out	0x25, r24	; 37
     ba0:	a0 91 d5 08 	lds	r26, 0x08D5
     ba4:	b0 91 d6 08 	lds	r27, 0x08D6
     ba8:	cd 91       	ld	r28, X+
     baa:	cd bf       	out	0x3d, r28	; 61
     bac:	dd 91       	ld	r29, X+
     bae:	de bf       	out	0x3e, r29	; 62
     bb0:	ff 91       	pop	r31
     bb2:	ef 91       	pop	r30
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	bf 91       	pop	r27
     bba:	af 91       	pop	r26
     bbc:	9f 91       	pop	r25
     bbe:	8f 91       	pop	r24
     bc0:	7f 91       	pop	r23
     bc2:	6f 91       	pop	r22
     bc4:	5f 91       	pop	r21
     bc6:	4f 91       	pop	r20
     bc8:	3f 91       	pop	r19
     bca:	2f 91       	pop	r18
     bcc:	1f 91       	pop	r17
     bce:	0f 91       	pop	r16
     bd0:	ff 90       	pop	r15
     bd2:	ef 90       	pop	r14
     bd4:	df 90       	pop	r13
     bd6:	cf 90       	pop	r12
     bd8:	bf 90       	pop	r11
     bda:	af 90       	pop	r10
     bdc:	9f 90       	pop	r9
     bde:	8f 90       	pop	r8
     be0:	7f 90       	pop	r7
     be2:	6f 90       	pop	r6
     be4:	5f 90       	pop	r5
     be6:	4f 90       	pop	r4
     be8:	3f 90       	pop	r3
     bea:	2f 90       	pop	r2
     bec:	1f 90       	pop	r1
     bee:	0f 90       	pop	r0
     bf0:	0c be       	out	0x3c, r0	; 60
     bf2:	0f 90       	pop	r0
     bf4:	0b be       	out	0x3b, r0	; 59
     bf6:	0f 90       	pop	r0
     bf8:	0f be       	out	0x3f, r0	; 63
     bfa:	0f 90       	pop	r0
     bfc:	08 95       	ret
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	08 95       	ret

00000c02 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c02:	0f 92       	push	r0
     c04:	0f b6       	in	r0, 0x3f	; 63
     c06:	f8 94       	cli
     c08:	0f 92       	push	r0
     c0a:	0b b6       	in	r0, 0x3b	; 59
     c0c:	0f 92       	push	r0
     c0e:	0c b6       	in	r0, 0x3c	; 60
     c10:	0f 92       	push	r0
     c12:	1f 92       	push	r1
     c14:	11 24       	eor	r1, r1
     c16:	2f 92       	push	r2
     c18:	3f 92       	push	r3
     c1a:	4f 92       	push	r4
     c1c:	5f 92       	push	r5
     c1e:	6f 92       	push	r6
     c20:	7f 92       	push	r7
     c22:	8f 92       	push	r8
     c24:	9f 92       	push	r9
     c26:	af 92       	push	r10
     c28:	bf 92       	push	r11
     c2a:	cf 92       	push	r12
     c2c:	df 92       	push	r13
     c2e:	ef 92       	push	r14
     c30:	ff 92       	push	r15
     c32:	0f 93       	push	r16
     c34:	1f 93       	push	r17
     c36:	2f 93       	push	r18
     c38:	3f 93       	push	r19
     c3a:	4f 93       	push	r20
     c3c:	5f 93       	push	r21
     c3e:	6f 93       	push	r22
     c40:	7f 93       	push	r23
     c42:	8f 93       	push	r24
     c44:	9f 93       	push	r25
     c46:	af 93       	push	r26
     c48:	bf 93       	push	r27
     c4a:	cf 93       	push	r28
     c4c:	df 93       	push	r29
     c4e:	ef 93       	push	r30
     c50:	ff 93       	push	r31
     c52:	a0 91 d5 08 	lds	r26, 0x08D5
     c56:	b0 91 d6 08 	lds	r27, 0x08D6
     c5a:	0d b6       	in	r0, 0x3d	; 61
     c5c:	0d 92       	st	X+, r0
     c5e:	0e b6       	in	r0, 0x3e	; 62
     c60:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c62:	15 d7       	rcall	.+3626   	; 0x1a8e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c64:	a0 91 d5 08 	lds	r26, 0x08D5
     c68:	b0 91 d6 08 	lds	r27, 0x08D6
     c6c:	cd 91       	ld	r28, X+
     c6e:	cd bf       	out	0x3d, r28	; 61
     c70:	dd 91       	ld	r29, X+
     c72:	de bf       	out	0x3e, r29	; 62
     c74:	ff 91       	pop	r31
     c76:	ef 91       	pop	r30
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	bf 91       	pop	r27
     c7e:	af 91       	pop	r26
     c80:	9f 91       	pop	r25
     c82:	8f 91       	pop	r24
     c84:	7f 91       	pop	r23
     c86:	6f 91       	pop	r22
     c88:	5f 91       	pop	r21
     c8a:	4f 91       	pop	r20
     c8c:	3f 91       	pop	r19
     c8e:	2f 91       	pop	r18
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	bf 90       	pop	r11
     c9e:	af 90       	pop	r10
     ca0:	9f 90       	pop	r9
     ca2:	8f 90       	pop	r8
     ca4:	7f 90       	pop	r7
     ca6:	6f 90       	pop	r6
     ca8:	5f 90       	pop	r5
     caa:	4f 90       	pop	r4
     cac:	3f 90       	pop	r3
     cae:	2f 90       	pop	r2
     cb0:	1f 90       	pop	r1
     cb2:	0f 90       	pop	r0
     cb4:	0c be       	out	0x3c, r0	; 60
     cb6:	0f 90       	pop	r0
     cb8:	0b be       	out	0x3b, r0	; 59
     cba:	0f 90       	pop	r0
     cbc:	0f be       	out	0x3f, r0	; 63
     cbe:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cc0:	08 95       	ret

00000cc2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     cc2:	0f 92       	push	r0
     cc4:	0f b6       	in	r0, 0x3f	; 63
     cc6:	f8 94       	cli
     cc8:	0f 92       	push	r0
     cca:	0b b6       	in	r0, 0x3b	; 59
     ccc:	0f 92       	push	r0
     cce:	0c b6       	in	r0, 0x3c	; 60
     cd0:	0f 92       	push	r0
     cd2:	1f 92       	push	r1
     cd4:	11 24       	eor	r1, r1
     cd6:	2f 92       	push	r2
     cd8:	3f 92       	push	r3
     cda:	4f 92       	push	r4
     cdc:	5f 92       	push	r5
     cde:	6f 92       	push	r6
     ce0:	7f 92       	push	r7
     ce2:	8f 92       	push	r8
     ce4:	9f 92       	push	r9
     ce6:	af 92       	push	r10
     ce8:	bf 92       	push	r11
     cea:	cf 92       	push	r12
     cec:	df 92       	push	r13
     cee:	ef 92       	push	r14
     cf0:	ff 92       	push	r15
     cf2:	0f 93       	push	r16
     cf4:	1f 93       	push	r17
     cf6:	2f 93       	push	r18
     cf8:	3f 93       	push	r19
     cfa:	4f 93       	push	r20
     cfc:	5f 93       	push	r21
     cfe:	6f 93       	push	r22
     d00:	7f 93       	push	r23
     d02:	8f 93       	push	r24
     d04:	9f 93       	push	r25
     d06:	af 93       	push	r26
     d08:	bf 93       	push	r27
     d0a:	cf 93       	push	r28
     d0c:	df 93       	push	r29
     d0e:	ef 93       	push	r30
     d10:	ff 93       	push	r31
     d12:	a0 91 d5 08 	lds	r26, 0x08D5
     d16:	b0 91 d6 08 	lds	r27, 0x08D6
     d1a:	0d b6       	in	r0, 0x3d	; 61
     d1c:	0d 92       	st	X+, r0
     d1e:	0e b6       	in	r0, 0x3e	; 62
     d20:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d22:	21 d5       	rcall	.+2626   	; 0x1766 <xTaskIncrementTick>
     d24:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d26:	b3 d6       	rcall	.+3430   	; 0x1a8e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d28:	a0 91 d5 08 	lds	r26, 0x08D5
     d2c:	b0 91 d6 08 	lds	r27, 0x08D6
     d30:	cd 91       	ld	r28, X+
     d32:	cd bf       	out	0x3d, r28	; 61
     d34:	dd 91       	ld	r29, X+
     d36:	de bf       	out	0x3e, r29	; 62
     d38:	ff 91       	pop	r31
     d3a:	ef 91       	pop	r30
     d3c:	df 91       	pop	r29
     d3e:	cf 91       	pop	r28
     d40:	bf 91       	pop	r27
     d42:	af 91       	pop	r26
     d44:	9f 91       	pop	r25
     d46:	8f 91       	pop	r24
     d48:	7f 91       	pop	r23
     d4a:	6f 91       	pop	r22
     d4c:	5f 91       	pop	r21
     d4e:	4f 91       	pop	r20
     d50:	3f 91       	pop	r19
     d52:	2f 91       	pop	r18
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	ef 90       	pop	r14
     d5c:	df 90       	pop	r13
     d5e:	cf 90       	pop	r12
     d60:	bf 90       	pop	r11
     d62:	af 90       	pop	r10
     d64:	9f 90       	pop	r9
     d66:	8f 90       	pop	r8
     d68:	7f 90       	pop	r7
     d6a:	6f 90       	pop	r6
     d6c:	5f 90       	pop	r5
     d6e:	4f 90       	pop	r4
     d70:	3f 90       	pop	r3
     d72:	2f 90       	pop	r2
     d74:	1f 90       	pop	r1
     d76:	0f 90       	pop	r0
     d78:	0c be       	out	0x3c, r0	; 60
     d7a:	0f 90       	pop	r0
     d7c:	0b be       	out	0x3b, r0	; 59
     d7e:	0f 90       	pop	r0
     d80:	0f be       	out	0x3f, r0	; 63
     d82:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d84:	08 95       	ret

00000d86 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     d86:	9d df       	rcall	.-198    	; 0xcc2 <vPortYieldFromTick>
		 asm volatile ("reti");
     d88:	18 95       	reti

00000d8a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	ec 01       	movw	r28, r24
     d92:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     d94:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d96:	81 11       	cpse	r24, r1
     d98:	0c c0       	rjmp	.+24     	; 0xdb2 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d9a:	88 81       	ld	r24, Y
     d9c:	99 81       	ldd	r25, Y+1	; 0x01
     d9e:	89 2b       	or	r24, r25
     da0:	09 f0       	breq	.+2      	; 0xda4 <prvCopyDataToQueue+0x1a>
     da2:	47 c0       	rjmp	.+142    	; 0xe32 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     da4:	8a 81       	ldd	r24, Y+2	; 0x02
     da6:	9b 81       	ldd	r25, Y+3	; 0x03
     da8:	0e 94 09 0f 	call	0x1e12	; 0x1e12 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     dac:	1b 82       	std	Y+3, r1	; 0x03
     dae:	1a 82       	std	Y+2, r1	; 0x02
     db0:	47 c0       	rjmp	.+142    	; 0xe40 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     db2:	41 11       	cpse	r20, r1
     db4:	18 c0       	rjmp	.+48     	; 0xde6 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     db6:	48 2f       	mov	r20, r24
     db8:	50 e0       	ldi	r21, 0x00	; 0
     dba:	8c 81       	ldd	r24, Y+4	; 0x04
     dbc:	9d 81       	ldd	r25, Y+5	; 0x05
     dbe:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     dc2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     dc4:	8c 81       	ldd	r24, Y+4	; 0x04
     dc6:	9d 81       	ldd	r25, Y+5	; 0x05
     dc8:	82 0f       	add	r24, r18
     dca:	91 1d       	adc	r25, r1
     dcc:	9d 83       	std	Y+5, r25	; 0x05
     dce:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     dd0:	2a 81       	ldd	r18, Y+2	; 0x02
     dd2:	3b 81       	ldd	r19, Y+3	; 0x03
     dd4:	82 17       	cp	r24, r18
     dd6:	93 07       	cpc	r25, r19
     dd8:	70 f1       	brcs	.+92     	; 0xe36 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     dda:	88 81       	ld	r24, Y
     ddc:	99 81       	ldd	r25, Y+1	; 0x01
     dde:	9d 83       	std	Y+5, r25	; 0x05
     de0:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     de2:	80 e0       	ldi	r24, 0x00	; 0
     de4:	2d c0       	rjmp	.+90     	; 0xe40 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     de6:	48 2f       	mov	r20, r24
     de8:	50 e0       	ldi	r21, 0x00	; 0
     dea:	8e 81       	ldd	r24, Y+6	; 0x06
     dec:	9f 81       	ldd	r25, Y+7	; 0x07
     dee:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     df2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	31 95       	neg	r19
     df8:	21 95       	neg	r18
     dfa:	31 09       	sbc	r19, r1
     dfc:	8e 81       	ldd	r24, Y+6	; 0x06
     dfe:	9f 81       	ldd	r25, Y+7	; 0x07
     e00:	82 0f       	add	r24, r18
     e02:	93 1f       	adc	r25, r19
     e04:	9f 83       	std	Y+7, r25	; 0x07
     e06:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     e08:	68 81       	ld	r22, Y
     e0a:	79 81       	ldd	r23, Y+1	; 0x01
     e0c:	86 17       	cp	r24, r22
     e0e:	97 07       	cpc	r25, r23
     e10:	30 f4       	brcc	.+12     	; 0xe1e <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     e12:	8a 81       	ldd	r24, Y+2	; 0x02
     e14:	9b 81       	ldd	r25, Y+3	; 0x03
     e16:	28 0f       	add	r18, r24
     e18:	39 1f       	adc	r19, r25
     e1a:	3f 83       	std	Y+7, r19	; 0x07
     e1c:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     e1e:	12 30       	cpi	r17, 0x02	; 2
     e20:	61 f4       	brne	.+24     	; 0xe3a <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     e22:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e24:	88 23       	and	r24, r24
     e26:	59 f0       	breq	.+22     	; 0xe3e <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     e28:	8a 8d       	ldd	r24, Y+26	; 0x1a
     e2a:	81 50       	subi	r24, 0x01	; 1
     e2c:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	07 c0       	rjmp	.+14     	; 0xe40 <prvCopyDataToQueue+0xb6>
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	05 c0       	rjmp	.+10     	; 0xe40 <prvCopyDataToQueue+0xb6>
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	03 c0       	rjmp	.+6      	; 0xe40 <prvCopyDataToQueue+0xb6>
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	01 c0       	rjmp	.+2      	; 0xe40 <prvCopyDataToQueue+0xb6>
     e3e:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     e40:	9a 8d       	ldd	r25, Y+26	; 0x1a
     e42:	9f 5f       	subi	r25, 0xFF	; 255
     e44:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	08 95       	ret

00000e4e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     e4e:	fc 01       	movw	r30, r24
     e50:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     e52:	44 8d       	ldd	r20, Z+28	; 0x1c
     e54:	44 23       	and	r20, r20
     e56:	a1 f0       	breq	.+40     	; 0xe80 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	26 81       	ldd	r18, Z+6	; 0x06
     e5c:	37 81       	ldd	r19, Z+7	; 0x07
     e5e:	24 0f       	add	r18, r20
     e60:	35 1f       	adc	r19, r21
     e62:	37 83       	std	Z+7, r19	; 0x07
     e64:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     e66:	62 81       	ldd	r22, Z+2	; 0x02
     e68:	73 81       	ldd	r23, Z+3	; 0x03
     e6a:	26 17       	cp	r18, r22
     e6c:	37 07       	cpc	r19, r23
     e6e:	20 f0       	brcs	.+8      	; 0xe78 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     e70:	20 81       	ld	r18, Z
     e72:	31 81       	ldd	r19, Z+1	; 0x01
     e74:	37 83       	std	Z+7, r19	; 0x07
     e76:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     e78:	66 81       	ldd	r22, Z+6	; 0x06
     e7a:	77 81       	ldd	r23, Z+7	; 0x07
     e7c:	0c 94 81 0f 	jmp	0x1f02	; 0x1f02 <memcpy>
     e80:	08 95       	ret

00000e82 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     e82:	0f 93       	push	r16
     e84:	1f 93       	push	r17
     e86:	cf 93       	push	r28
     e88:	df 93       	push	r29
     e8a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     e8c:	0f b6       	in	r0, 0x3f	; 63
     e8e:	f8 94       	cli
     e90:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     e92:	8e 8d       	ldd	r24, Y+30	; 0x1e
     e94:	18 16       	cp	r1, r24
     e96:	a4 f4       	brge	.+40     	; 0xec0 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e98:	89 89       	ldd	r24, Y+17	; 0x11
     e9a:	88 23       	and	r24, r24
     e9c:	89 f0       	breq	.+34     	; 0xec0 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e9e:	8e 01       	movw	r16, r28
     ea0:	0f 5e       	subi	r16, 0xEF	; 239
     ea2:	1f 4f       	sbci	r17, 0xFF	; 255
     ea4:	03 c0       	rjmp	.+6      	; 0xeac <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ea6:	89 89       	ldd	r24, Y+17	; 0x11
     ea8:	88 23       	and	r24, r24
     eaa:	51 f0       	breq	.+20     	; 0xec0 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     eac:	c8 01       	movw	r24, r16
     eae:	c4 d6       	rcall	.+3464   	; 0x1c38 <xTaskRemoveFromEventList>
     eb0:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     eb2:	4d d7       	rcall	.+3738   	; 0x1d4e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     eb4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     eb6:	81 50       	subi	r24, 0x01	; 1
     eb8:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     eba:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ebc:	18 16       	cp	r1, r24
     ebe:	9c f3       	brlt	.-26     	; 0xea6 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     ec0:	8f ef       	ldi	r24, 0xFF	; 255
     ec2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     ec4:	0f 90       	pop	r0
     ec6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     ec8:	0f b6       	in	r0, 0x3f	; 63
     eca:	f8 94       	cli
     ecc:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ece:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ed0:	18 16       	cp	r1, r24
     ed2:	a4 f4       	brge	.+40     	; 0xefc <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ed4:	88 85       	ldd	r24, Y+8	; 0x08
     ed6:	88 23       	and	r24, r24
     ed8:	89 f0       	breq	.+34     	; 0xefc <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     eda:	8e 01       	movw	r16, r28
     edc:	08 5f       	subi	r16, 0xF8	; 248
     ede:	1f 4f       	sbci	r17, 0xFF	; 255
     ee0:	03 c0       	rjmp	.+6      	; 0xee8 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ee2:	88 85       	ldd	r24, Y+8	; 0x08
     ee4:	88 23       	and	r24, r24
     ee6:	51 f0       	breq	.+20     	; 0xefc <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ee8:	c8 01       	movw	r24, r16
     eea:	a6 d6       	rcall	.+3404   	; 0x1c38 <xTaskRemoveFromEventList>
     eec:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     eee:	2f d7       	rcall	.+3678   	; 0x1d4e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     ef0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ef2:	81 50       	subi	r24, 0x01	; 1
     ef4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     ef6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ef8:	18 16       	cp	r1, r24
     efa:	9c f3       	brlt	.-26     	; 0xee2 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     efc:	8f ef       	ldi	r24, 0xFF	; 255
     efe:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     f00:	0f 90       	pop	r0
     f02:	0f be       	out	0x3f, r0	; 63
}
     f04:	df 91       	pop	r29
     f06:	cf 91       	pop	r28
     f08:	1f 91       	pop	r17
     f0a:	0f 91       	pop	r16
     f0c:	08 95       	ret

00000f0e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     f1a:	88 81       	ld	r24, Y
     f1c:	99 81       	ldd	r25, Y+1	; 0x01
     f1e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f20:	30 e0       	ldi	r19, 0x00	; 0
     f22:	7b 8d       	ldd	r23, Y+27	; 0x1b
     f24:	72 9f       	mul	r23, r18
     f26:	a0 01       	movw	r20, r0
     f28:	73 9f       	mul	r23, r19
     f2a:	50 0d       	add	r21, r0
     f2c:	11 24       	eor	r1, r1
     f2e:	fc 01       	movw	r30, r24
     f30:	e4 0f       	add	r30, r20
     f32:	f5 1f       	adc	r31, r21
     f34:	fb 83       	std	Y+3, r31	; 0x03
     f36:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     f38:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     f3a:	9d 83       	std	Y+5, r25	; 0x05
     f3c:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     f3e:	42 1b       	sub	r20, r18
     f40:	53 0b       	sbc	r21, r19
     f42:	84 0f       	add	r24, r20
     f44:	95 1f       	adc	r25, r21
     f46:	9f 83       	std	Y+7, r25	; 0x07
     f48:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     f4a:	8f ef       	ldi	r24, 0xFF	; 255
     f4c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     f4e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     f50:	61 11       	cpse	r22, r1
     f52:	0a c0       	rjmp	.+20     	; 0xf68 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f54:	88 85       	ldd	r24, Y+8	; 0x08
     f56:	88 23       	and	r24, r24
     f58:	69 f0       	breq	.+26     	; 0xf74 <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f5a:	ce 01       	movw	r24, r28
     f5c:	08 96       	adiw	r24, 0x08	; 8
     f5e:	6c d6       	rcall	.+3288   	; 0x1c38 <xTaskRemoveFromEventList>
     f60:	81 30       	cpi	r24, 0x01	; 1
     f62:	41 f4       	brne	.+16     	; 0xf74 <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
     f64:	4e de       	rcall	.-868    	; 0xc02 <vPortYield>
     f66:	06 c0       	rjmp	.+12     	; 0xf74 <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     f68:	ce 01       	movw	r24, r28
     f6a:	08 96       	adiw	r24, 0x08	; 8
     f6c:	42 da       	rcall	.-2940   	; 0x3f2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     f6e:	ce 01       	movw	r24, r28
     f70:	41 96       	adiw	r24, 0x11	; 17
     f72:	3f da       	rcall	.-2946   	; 0x3f2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     f74:	0f 90       	pop	r0
     f76:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     f78:	81 e0       	ldi	r24, 0x01	; 1
     f7a:	df 91       	pop	r29
     f7c:	cf 91       	pop	r28
     f7e:	08 95       	ret

00000f80 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     f80:	0f 93       	push	r16
     f82:	1f 93       	push	r17
     f84:	cf 93       	push	r28
     f86:	df 93       	push	r29
     f88:	18 2f       	mov	r17, r24
     f8a:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
     f8c:	88 23       	and	r24, r24
     f8e:	d1 f0       	breq	.+52     	; 0xfc4 <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
     f90:	8f e1       	ldi	r24, 0x1F	; 31
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	f8 d9       	rcall	.-3088   	; 0x386 <pvPortMalloc>
     f96:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     f98:	00 97       	sbiw	r24, 0x00	; 0
     f9a:	b1 f0       	breq	.+44     	; 0xfc8 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     f9c:	10 9f       	mul	r17, r16
     f9e:	c0 01       	movw	r24, r0
     fa0:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
     fa2:	01 96       	adiw	r24, 0x01	; 1
     fa4:	f0 d9       	rcall	.-3104   	; 0x386 <pvPortMalloc>
     fa6:	99 83       	std	Y+1, r25	; 0x01
     fa8:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     faa:	89 2b       	or	r24, r25
     fac:	31 f0       	breq	.+12     	; 0xfba <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     fae:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     fb0:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     fb2:	61 e0       	ldi	r22, 0x01	; 1
     fb4:	ce 01       	movw	r24, r28
     fb6:	ab df       	rcall	.-170    	; 0xf0e <xQueueGenericReset>
     fb8:	07 c0       	rjmp	.+14     	; 0xfc8 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     fba:	ce 01       	movw	r24, r28
     fbc:	19 da       	rcall	.-3022   	; 0x3f0 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
     fbe:	c0 e0       	ldi	r28, 0x00	; 0
     fc0:	d0 e0       	ldi	r29, 0x00	; 0
     fc2:	02 c0       	rjmp	.+4      	; 0xfc8 <xQueueGenericCreate+0x48>
     fc4:	c0 e0       	ldi	r28, 0x00	; 0
     fc6:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     fc8:	ce 01       	movw	r24, r28
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	1f 91       	pop	r17
     fd0:	0f 91       	pop	r16
     fd2:	08 95       	ret

00000fd4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     fd4:	9f 92       	push	r9
     fd6:	af 92       	push	r10
     fd8:	bf 92       	push	r11
     fda:	cf 92       	push	r12
     fdc:	df 92       	push	r13
     fde:	ef 92       	push	r14
     fe0:	ff 92       	push	r15
     fe2:	0f 93       	push	r16
     fe4:	1f 93       	push	r17
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	00 d0       	rcall	.+0      	; 0xfec <xQueueGenericSend+0x18>
     fec:	1f 92       	push	r1
     fee:	1f 92       	push	r1
     ff0:	cd b7       	in	r28, 0x3d	; 61
     ff2:	de b7       	in	r29, 0x3e	; 62
     ff4:	8c 01       	movw	r16, r24
     ff6:	6b 01       	movw	r12, r22
     ff8:	5d 83       	std	Y+5, r21	; 0x05
     ffa:	4c 83       	std	Y+4, r20	; 0x04
     ffc:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     ffe:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1000:	99 24       	eor	r9, r9
    1002:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1004:	7c 01       	movw	r14, r24
    1006:	88 e0       	ldi	r24, 0x08	; 8
    1008:	e8 0e       	add	r14, r24
    100a:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    100c:	0f b6       	in	r0, 0x3f	; 63
    100e:	f8 94       	cli
    1010:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1012:	f8 01       	movw	r30, r16
    1014:	92 8d       	ldd	r25, Z+26	; 0x1a
    1016:	83 8d       	ldd	r24, Z+27	; 0x1b
    1018:	98 17       	cp	r25, r24
    101a:	18 f0       	brcs	.+6      	; 0x1022 <xQueueGenericSend+0x4e>
    101c:	f2 e0       	ldi	r31, 0x02	; 2
    101e:	af 12       	cpse	r10, r31
    1020:	15 c0       	rjmp	.+42     	; 0x104c <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1022:	4a 2d       	mov	r20, r10
    1024:	b6 01       	movw	r22, r12
    1026:	c8 01       	movw	r24, r16
    1028:	b0 de       	rcall	.-672    	; 0xd8a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    102a:	f8 01       	movw	r30, r16
    102c:	91 89       	ldd	r25, Z+17	; 0x11
    102e:	99 23       	and	r25, r25
    1030:	39 f0       	breq	.+14     	; 0x1040 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1032:	c8 01       	movw	r24, r16
    1034:	41 96       	adiw	r24, 0x11	; 17
    1036:	00 d6       	rcall	.+3072   	; 0x1c38 <xTaskRemoveFromEventList>
    1038:	81 30       	cpi	r24, 0x01	; 1
    103a:	21 f4       	brne	.+8      	; 0x1044 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    103c:	e2 dd       	rcall	.-1084   	; 0xc02 <vPortYield>
    103e:	02 c0       	rjmp	.+4      	; 0x1044 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1040:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1042:	df dd       	rcall	.-1090   	; 0xc02 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1044:	0f 90       	pop	r0
    1046:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	46 c0       	rjmp	.+140    	; 0x10d8 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    104c:	ec 81       	ldd	r30, Y+4	; 0x04
    104e:	fd 81       	ldd	r31, Y+5	; 0x05
    1050:	ef 2b       	or	r30, r31
    1052:	21 f4       	brne	.+8      	; 0x105c <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1054:	0f 90       	pop	r0
    1056:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	3e c0       	rjmp	.+124    	; 0x10d8 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    105c:	b1 10       	cpse	r11, r1
    105e:	04 c0       	rjmp	.+8      	; 0x1068 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1060:	ce 01       	movw	r24, r28
    1062:	01 96       	adiw	r24, 0x01	; 1
    1064:	31 d6       	rcall	.+3170   	; 0x1cc8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1066:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1068:	0f 90       	pop	r0
    106a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    106c:	76 d3       	rcall	.+1772   	; 0x175a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
    1074:	f8 01       	movw	r30, r16
    1076:	85 8d       	ldd	r24, Z+29	; 0x1d
    1078:	8f 3f       	cpi	r24, 0xFF	; 255
    107a:	09 f4       	brne	.+2      	; 0x107e <xQueueGenericSend+0xaa>
    107c:	15 8e       	std	Z+29, r1	; 0x1d
    107e:	f8 01       	movw	r30, r16
    1080:	86 8d       	ldd	r24, Z+30	; 0x1e
    1082:	8f 3f       	cpi	r24, 0xFF	; 255
    1084:	09 f4       	brne	.+2      	; 0x1088 <xQueueGenericSend+0xb4>
    1086:	16 8e       	std	Z+30, r1	; 0x1e
    1088:	0f 90       	pop	r0
    108a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    108c:	be 01       	movw	r22, r28
    108e:	6c 5f       	subi	r22, 0xFC	; 252
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	ce 01       	movw	r24, r28
    1094:	01 96       	adiw	r24, 0x01	; 1
    1096:	23 d6       	rcall	.+3142   	; 0x1cde <xTaskCheckForTimeOut>
    1098:	81 11       	cpse	r24, r1
    109a:	1a c0       	rjmp	.+52     	; 0x10d0 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    109c:	0f b6       	in	r0, 0x3f	; 63
    109e:	f8 94       	cli
    10a0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    10a2:	f8 01       	movw	r30, r16
    10a4:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    10a6:	0f 90       	pop	r0
    10a8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    10aa:	f8 01       	movw	r30, r16
    10ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    10ae:	98 13       	cpse	r25, r24
    10b0:	0b c0       	rjmp	.+22     	; 0x10c8 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    10b2:	6c 81       	ldd	r22, Y+4	; 0x04
    10b4:	7d 81       	ldd	r23, Y+5	; 0x05
    10b6:	c7 01       	movw	r24, r14
    10b8:	94 d5       	rcall	.+2856   	; 0x1be2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    10ba:	c8 01       	movw	r24, r16
    10bc:	e2 de       	rcall	.-572    	; 0xe82 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    10be:	11 d4       	rcall	.+2082   	; 0x18e2 <xTaskResumeAll>
    10c0:	81 11       	cpse	r24, r1
    10c2:	a4 cf       	rjmp	.-184    	; 0x100c <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    10c4:	9e dd       	rcall	.-1220   	; 0xc02 <vPortYield>
    10c6:	a2 cf       	rjmp	.-188    	; 0x100c <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10c8:	c8 01       	movw	r24, r16
    10ca:	db de       	rcall	.-586    	; 0xe82 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10cc:	0a d4       	rcall	.+2068   	; 0x18e2 <xTaskResumeAll>
    10ce:	9e cf       	rjmp	.-196    	; 0x100c <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    10d0:	c8 01       	movw	r24, r16
    10d2:	d7 de       	rcall	.-594    	; 0xe82 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10d4:	06 d4       	rcall	.+2060   	; 0x18e2 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    10d6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	0f 90       	pop	r0
    10e0:	0f 90       	pop	r0
    10e2:	df 91       	pop	r29
    10e4:	cf 91       	pop	r28
    10e6:	1f 91       	pop	r17
    10e8:	0f 91       	pop	r16
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	df 90       	pop	r13
    10f0:	cf 90       	pop	r12
    10f2:	bf 90       	pop	r11
    10f4:	af 90       	pop	r10
    10f6:	9f 90       	pop	r9
    10f8:	08 95       	ret

000010fa <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    10fa:	cf 93       	push	r28
    10fc:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    10fe:	8f e1       	ldi	r24, 0x1F	; 31
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	41 d9       	rcall	.-3454   	; 0x386 <pvPortMalloc>
    1104:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1106:	00 97       	sbiw	r24, 0x00	; 0
    1108:	e1 f0       	breq	.+56     	; 0x1142 <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    110a:	1b 82       	std	Y+3, r1	; 0x03
    110c:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    110e:	19 82       	std	Y+1, r1	; 0x01
    1110:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1112:	1d 82       	std	Y+5, r1	; 0x05
    1114:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1116:	1f 82       	std	Y+7, r1	; 0x07
    1118:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    111a:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    111c:	81 e0       	ldi	r24, 0x01	; 1
    111e:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1120:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1126:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1128:	ce 01       	movw	r24, r28
    112a:	08 96       	adiw	r24, 0x08	; 8
    112c:	62 d9       	rcall	.-3388   	; 0x3f2 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    112e:	ce 01       	movw	r24, r28
    1130:	41 96       	adiw	r24, 0x11	; 17
    1132:	5f d9       	rcall	.-3394   	; 0x3f2 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1134:	20 e0       	ldi	r18, 0x00	; 0
    1136:	40 e0       	ldi	r20, 0x00	; 0
    1138:	50 e0       	ldi	r21, 0x00	; 0
    113a:	60 e0       	ldi	r22, 0x00	; 0
    113c:	70 e0       	ldi	r23, 0x00	; 0
    113e:	ce 01       	movw	r24, r28
    1140:	49 df       	rcall	.-366    	; 0xfd4 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1142:	ce 01       	movw	r24, r28
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	08 95       	ret

0000114a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	cf 93       	push	r28
    1150:	df 93       	push	r29
    1152:	ec 01       	movw	r28, r24
    1154:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1156:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1158:	8b 8d       	ldd	r24, Y+27	; 0x1b
    115a:	98 17       	cp	r25, r24
    115c:	10 f0       	brcs	.+4      	; 0x1162 <xQueueGenericSendFromISR+0x18>
    115e:	22 30       	cpi	r18, 0x02	; 2
    1160:	11 f5       	brne	.+68     	; 0x11a6 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1162:	42 2f       	mov	r20, r18
    1164:	ce 01       	movw	r24, r28
    1166:	11 de       	rcall	.-990    	; 0xd8a <prvCopyDataToQueue>
    1168:	88 23       	and	r24, r24
    116a:	31 f0       	breq	.+12     	; 0x1178 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    116c:	01 15       	cp	r16, r1
    116e:	11 05       	cpc	r17, r1
    1170:	19 f0       	breq	.+6      	; 0x1178 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	f8 01       	movw	r30, r16
    1176:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1178:	8e 8d       	ldd	r24, Y+30	; 0x1e
    117a:	8f 3f       	cpi	r24, 0xFF	; 255
    117c:	79 f4       	brne	.+30     	; 0x119c <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    117e:	89 89       	ldd	r24, Y+17	; 0x11
    1180:	88 23       	and	r24, r24
    1182:	99 f0       	breq	.+38     	; 0x11aa <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1184:	ce 01       	movw	r24, r28
    1186:	41 96       	adiw	r24, 0x11	; 17
    1188:	57 d5       	rcall	.+2734   	; 0x1c38 <xTaskRemoveFromEventList>
    118a:	88 23       	and	r24, r24
    118c:	81 f0       	breq	.+32     	; 0x11ae <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    118e:	01 15       	cp	r16, r1
    1190:	11 05       	cpc	r17, r1
    1192:	79 f0       	breq	.+30     	; 0x11b2 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1194:	81 e0       	ldi	r24, 0x01	; 1
    1196:	f8 01       	movw	r30, r16
    1198:	80 83       	st	Z, r24
    119a:	0c c0       	rjmp	.+24     	; 0x11b4 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    119c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    119e:	8f 5f       	subi	r24, 0xFF	; 255
    11a0:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    11a2:	81 e0       	ldi	r24, 0x01	; 1
    11a4:	07 c0       	rjmp	.+14     	; 0x11b4 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	05 c0       	rjmp	.+10     	; 0x11b4 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	03 c0       	rjmp	.+6      	; 0x11b4 <xQueueGenericSendFromISR+0x6a>
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	01 c0       	rjmp	.+2      	; 0x11b4 <xQueueGenericSendFromISR+0x6a>
    11b2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    11b4:	df 91       	pop	r29
    11b6:	cf 91       	pop	r28
    11b8:	1f 91       	pop	r17
    11ba:	0f 91       	pop	r16
    11bc:	08 95       	ret

000011be <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    11be:	9f 92       	push	r9
    11c0:	af 92       	push	r10
    11c2:	bf 92       	push	r11
    11c4:	cf 92       	push	r12
    11c6:	df 92       	push	r13
    11c8:	ef 92       	push	r14
    11ca:	ff 92       	push	r15
    11cc:	0f 93       	push	r16
    11ce:	1f 93       	push	r17
    11d0:	cf 93       	push	r28
    11d2:	df 93       	push	r29
    11d4:	00 d0       	rcall	.+0      	; 0x11d6 <xQueueGenericReceive+0x18>
    11d6:	1f 92       	push	r1
    11d8:	1f 92       	push	r1
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
    11de:	8c 01       	movw	r16, r24
    11e0:	6b 01       	movw	r12, r22
    11e2:	5d 83       	std	Y+5, r21	; 0x05
    11e4:	4c 83       	std	Y+4, r20	; 0x04
    11e6:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    11e8:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    11ea:	99 24       	eor	r9, r9
    11ec:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11ee:	7c 01       	movw	r14, r24
    11f0:	81 e1       	ldi	r24, 0x11	; 17
    11f2:	e8 0e       	add	r14, r24
    11f4:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    11f6:	0f b6       	in	r0, 0x3f	; 63
    11f8:	f8 94       	cli
    11fa:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    11fc:	f8 01       	movw	r30, r16
    11fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1200:	88 23       	and	r24, r24
    1202:	69 f1       	breq	.+90     	; 0x125e <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1204:	e6 80       	ldd	r14, Z+6	; 0x06
    1206:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1208:	b6 01       	movw	r22, r12
    120a:	c8 01       	movw	r24, r16
    120c:	20 de       	rcall	.-960    	; 0xe4e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    120e:	b1 10       	cpse	r11, r1
    1210:	17 c0       	rjmp	.+46     	; 0x1240 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1212:	f8 01       	movw	r30, r16
    1214:	82 8d       	ldd	r24, Z+26	; 0x1a
    1216:	81 50       	subi	r24, 0x01	; 1
    1218:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    121a:	80 81       	ld	r24, Z
    121c:	91 81       	ldd	r25, Z+1	; 0x01
    121e:	89 2b       	or	r24, r25
    1220:	21 f4       	brne	.+8      	; 0x122a <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1222:	36 d6       	rcall	.+3180   	; 0x1e90 <pvTaskIncrementMutexHeldCount>
    1224:	f8 01       	movw	r30, r16
    1226:	93 83       	std	Z+3, r25	; 0x03
    1228:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    122a:	f8 01       	movw	r30, r16
    122c:	80 85       	ldd	r24, Z+8	; 0x08
    122e:	88 23       	and	r24, r24
    1230:	91 f0       	breq	.+36     	; 0x1256 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1232:	c8 01       	movw	r24, r16
    1234:	08 96       	adiw	r24, 0x08	; 8
    1236:	00 d5       	rcall	.+2560   	; 0x1c38 <xTaskRemoveFromEventList>
    1238:	81 30       	cpi	r24, 0x01	; 1
    123a:	69 f4       	brne	.+26     	; 0x1256 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    123c:	e2 dc       	rcall	.-1596   	; 0xc02 <vPortYield>
    123e:	0b c0       	rjmp	.+22     	; 0x1256 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1240:	f8 01       	movw	r30, r16
    1242:	f7 82       	std	Z+7, r15	; 0x07
    1244:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1246:	81 89       	ldd	r24, Z+17	; 0x11
    1248:	88 23       	and	r24, r24
    124a:	29 f0       	breq	.+10     	; 0x1256 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    124c:	c8 01       	movw	r24, r16
    124e:	41 96       	adiw	r24, 0x11	; 17
    1250:	f3 d4       	rcall	.+2534   	; 0x1c38 <xTaskRemoveFromEventList>
    1252:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1254:	d6 dc       	rcall	.-1620   	; 0xc02 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1256:	0f 90       	pop	r0
    1258:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	52 c0       	rjmp	.+164    	; 0x1302 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    125e:	4c 81       	ldd	r20, Y+4	; 0x04
    1260:	5d 81       	ldd	r21, Y+5	; 0x05
    1262:	45 2b       	or	r20, r21
    1264:	21 f4       	brne	.+8      	; 0x126e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1266:	0f 90       	pop	r0
    1268:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	4a c0       	rjmp	.+148    	; 0x1302 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    126e:	a1 10       	cpse	r10, r1
    1270:	04 c0       	rjmp	.+8      	; 0x127a <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1272:	ce 01       	movw	r24, r28
    1274:	01 96       	adiw	r24, 0x01	; 1
    1276:	28 d5       	rcall	.+2640   	; 0x1cc8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1278:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    127a:	0f 90       	pop	r0
    127c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    127e:	6d d2       	rcall	.+1242   	; 0x175a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	0f 92       	push	r0
    1286:	f8 01       	movw	r30, r16
    1288:	85 8d       	ldd	r24, Z+29	; 0x1d
    128a:	8f 3f       	cpi	r24, 0xFF	; 255
    128c:	09 f4       	brne	.+2      	; 0x1290 <xQueueGenericReceive+0xd2>
    128e:	15 8e       	std	Z+29, r1	; 0x1d
    1290:	f8 01       	movw	r30, r16
    1292:	86 8d       	ldd	r24, Z+30	; 0x1e
    1294:	8f 3f       	cpi	r24, 0xFF	; 255
    1296:	09 f4       	brne	.+2      	; 0x129a <xQueueGenericReceive+0xdc>
    1298:	16 8e       	std	Z+30, r1	; 0x1e
    129a:	0f 90       	pop	r0
    129c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    129e:	be 01       	movw	r22, r28
    12a0:	6c 5f       	subi	r22, 0xFC	; 252
    12a2:	7f 4f       	sbci	r23, 0xFF	; 255
    12a4:	ce 01       	movw	r24, r28
    12a6:	01 96       	adiw	r24, 0x01	; 1
    12a8:	1a d5       	rcall	.+2612   	; 0x1cde <xTaskCheckForTimeOut>
    12aa:	81 11       	cpse	r24, r1
    12ac:	26 c0       	rjmp	.+76     	; 0x12fa <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12b4:	f8 01       	movw	r30, r16
    12b6:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    12bc:	81 11       	cpse	r24, r1
    12be:	19 c0       	rjmp	.+50     	; 0x12f2 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12c0:	f8 01       	movw	r30, r16
    12c2:	80 81       	ld	r24, Z
    12c4:	91 81       	ldd	r25, Z+1	; 0x01
    12c6:	89 2b       	or	r24, r25
    12c8:	49 f4       	brne	.+18     	; 0x12dc <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    12ca:	0f b6       	in	r0, 0x3f	; 63
    12cc:	f8 94       	cli
    12ce:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    12d0:	f8 01       	movw	r30, r16
    12d2:	82 81       	ldd	r24, Z+2	; 0x02
    12d4:	93 81       	ldd	r25, Z+3	; 0x03
    12d6:	3f d5       	rcall	.+2686   	; 0x1d56 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    12d8:	0f 90       	pop	r0
    12da:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12dc:	6c 81       	ldd	r22, Y+4	; 0x04
    12de:	7d 81       	ldd	r23, Y+5	; 0x05
    12e0:	c7 01       	movw	r24, r14
    12e2:	7f d4       	rcall	.+2302   	; 0x1be2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    12e4:	c8 01       	movw	r24, r16
    12e6:	cd dd       	rcall	.-1126   	; 0xe82 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    12e8:	fc d2       	rcall	.+1528   	; 0x18e2 <xTaskResumeAll>
    12ea:	81 11       	cpse	r24, r1
    12ec:	84 cf       	rjmp	.-248    	; 0x11f6 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    12ee:	89 dc       	rcall	.-1774   	; 0xc02 <vPortYield>
    12f0:	82 cf       	rjmp	.-252    	; 0x11f6 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12f2:	c8 01       	movw	r24, r16
    12f4:	c6 dd       	rcall	.-1140   	; 0xe82 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12f6:	f5 d2       	rcall	.+1514   	; 0x18e2 <xTaskResumeAll>
    12f8:	7e cf       	rjmp	.-260    	; 0x11f6 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    12fa:	c8 01       	movw	r24, r16
    12fc:	c2 dd       	rcall	.-1148   	; 0xe82 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12fe:	f1 d2       	rcall	.+1506   	; 0x18e2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1300:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1302:	0f 90       	pop	r0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	0f 90       	pop	r0
    130a:	0f 90       	pop	r0
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10
    1320:	9f 90       	pop	r9
    1322:	08 95       	ret

00001324 <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    1324:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1326:	71 83       	std	Z+1, r23	; 0x01
    1328:	60 83       	st	Z, r22
	ring->rSize = size;
    132a:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    132c:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    132e:	13 82       	std	Z+3, r1	; 0x03
    1330:	08 95       	ret

00001332 <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1332:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1334:	94 81       	ldd	r25, Z+4	; 0x04
    1336:	a0 81       	ld	r26, Z
    1338:	b1 81       	ldd	r27, Z+1	; 0x01
    133a:	a9 0f       	add	r26, r25
    133c:	b1 1d       	adc	r27, r1
    133e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1340:	9f 5f       	subi	r25, 0xFF	; 255
    1342:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1344:	22 81       	ldd	r18, Z+2	; 0x02
    1346:	92 17       	cp	r25, r18
    1348:	10 f0       	brcs	.+4      	; 0x134e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    134a:	92 1b       	sub	r25, r18
    134c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    134e:	93 81       	ldd	r25, Z+3	; 0x03
    1350:	91 50       	subi	r25, 0x01	; 1
    1352:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1354:	08 95       	ret

00001356 <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1356:	fc 01       	movw	r30, r24
    1358:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    135a:	83 81       	ldd	r24, Z+3	; 0x03
    135c:	22 81       	ldd	r18, Z+2	; 0x02
    135e:	82 17       	cp	r24, r18
    1360:	78 f4       	brcc	.+30     	; 0x1380 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1362:	34 81       	ldd	r19, Z+4	; 0x04
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	83 0f       	add	r24, r19
    1368:	91 1d       	adc	r25, r1
    136a:	62 2f       	mov	r22, r18
    136c:	70 e0       	ldi	r23, 0x00	; 0
    136e:	a2 d5       	rcall	.+2884   	; 0x1eb4 <__divmodhi4>
    1370:	a0 81       	ld	r26, Z
    1372:	b1 81       	ldd	r27, Z+1	; 0x01
    1374:	a8 0f       	add	r26, r24
    1376:	b9 1f       	adc	r27, r25
    1378:	4c 93       	st	X, r20
            ring->rLength++;
    137a:	83 81       	ldd	r24, Z+3	; 0x03
    137c:	8f 5f       	subi	r24, 0xFF	; 255
    137e:	83 83       	std	Z+3, r24	; 0x03
    1380:	08 95       	ret

00001382 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1382:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	22 81       	ldd	r18, Z+2	; 0x02
    1388:	93 81       	ldd	r25, Z+3	; 0x03
    138a:	29 13       	cpse	r18, r25
    138c:	80 e0       	ldi	r24, 0x00	; 0
}
    138e:	08 95       	ret

00001390 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1390:	21 e0       	ldi	r18, 0x01	; 1
    1392:	fc 01       	movw	r30, r24
    1394:	83 81       	ldd	r24, Z+3	; 0x03
    1396:	81 11       	cpse	r24, r1
    1398:	01 c0       	rjmp	.+2      	; 0x139c <ringBufferNotEmpty+0xc>
    139a:	20 e0       	ldi	r18, 0x00	; 0
}
    139c:	82 2f       	mov	r24, r18
    139e:	08 95       	ret

000013a0 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    13a0:	e0 91 94 08 	lds	r30, 0x0894
    13a4:	f0 91 95 08 	lds	r31, 0x0895
    13a8:	80 81       	ld	r24, Z
    13aa:	81 11       	cpse	r24, r1
    13ac:	07 c0       	rjmp	.+14     	; 0x13bc <prvResetNextTaskUnblockTime+0x1c>
    13ae:	8f ef       	ldi	r24, 0xFF	; 255
    13b0:	9f ef       	ldi	r25, 0xFF	; 255
    13b2:	90 93 03 02 	sts	0x0203, r25
    13b6:	80 93 02 02 	sts	0x0202, r24
    13ba:	08 95       	ret
    13bc:	e0 91 94 08 	lds	r30, 0x0894
    13c0:	f0 91 95 08 	lds	r31, 0x0895
    13c4:	05 80       	ldd	r0, Z+5	; 0x05
    13c6:	f6 81       	ldd	r31, Z+6	; 0x06
    13c8:	e0 2d       	mov	r30, r0
    13ca:	06 80       	ldd	r0, Z+6	; 0x06
    13cc:	f7 81       	ldd	r31, Z+7	; 0x07
    13ce:	e0 2d       	mov	r30, r0
    13d0:	82 81       	ldd	r24, Z+2	; 0x02
    13d2:	93 81       	ldd	r25, Z+3	; 0x03
    13d4:	90 93 03 02 	sts	0x0203, r25
    13d8:	80 93 02 02 	sts	0x0202, r24
    13dc:	08 95       	ret

000013de <prvAddCurrentTaskToDelayedList>:
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	ec 01       	movw	r28, r24
    13e4:	e0 91 d5 08 	lds	r30, 0x08D5
    13e8:	f0 91 d6 08 	lds	r31, 0x08D6
    13ec:	93 83       	std	Z+3, r25	; 0x03
    13ee:	82 83       	std	Z+2, r24	; 0x02
    13f0:	80 91 73 08 	lds	r24, 0x0873
    13f4:	90 91 74 08 	lds	r25, 0x0874
    13f8:	c8 17       	cp	r28, r24
    13fa:	d9 07       	cpc	r29, r25
    13fc:	60 f4       	brcc	.+24     	; 0x1416 <prvAddCurrentTaskToDelayedList+0x38>
    13fe:	60 91 d5 08 	lds	r22, 0x08D5
    1402:	70 91 d6 08 	lds	r23, 0x08D6
    1406:	80 91 92 08 	lds	r24, 0x0892
    140a:	90 91 93 08 	lds	r25, 0x0893
    140e:	6e 5f       	subi	r22, 0xFE	; 254
    1410:	7f 4f       	sbci	r23, 0xFF	; 255
    1412:	22 d8       	rcall	.-4028   	; 0x458 <vListInsert>
    1414:	16 c0       	rjmp	.+44     	; 0x1442 <prvAddCurrentTaskToDelayedList+0x64>
    1416:	60 91 d5 08 	lds	r22, 0x08D5
    141a:	70 91 d6 08 	lds	r23, 0x08D6
    141e:	80 91 94 08 	lds	r24, 0x0894
    1422:	90 91 95 08 	lds	r25, 0x0895
    1426:	6e 5f       	subi	r22, 0xFE	; 254
    1428:	7f 4f       	sbci	r23, 0xFF	; 255
    142a:	16 d8       	rcall	.-4052   	; 0x458 <vListInsert>
    142c:	80 91 02 02 	lds	r24, 0x0202
    1430:	90 91 03 02 	lds	r25, 0x0203
    1434:	c8 17       	cp	r28, r24
    1436:	d9 07       	cpc	r29, r25
    1438:	20 f4       	brcc	.+8      	; 0x1442 <prvAddCurrentTaskToDelayedList+0x64>
    143a:	d0 93 03 02 	sts	0x0203, r29
    143e:	c0 93 02 02 	sts	0x0202, r28
    1442:	df 91       	pop	r29
    1444:	cf 91       	pop	r28
    1446:	08 95       	ret

00001448 <xTaskGenericCreate>:
    1448:	4f 92       	push	r4
    144a:	5f 92       	push	r5
    144c:	6f 92       	push	r6
    144e:	7f 92       	push	r7
    1450:	8f 92       	push	r8
    1452:	9f 92       	push	r9
    1454:	af 92       	push	r10
    1456:	bf 92       	push	r11
    1458:	cf 92       	push	r12
    145a:	df 92       	push	r13
    145c:	ef 92       	push	r14
    145e:	ff 92       	push	r15
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
    1468:	4c 01       	movw	r8, r24
    146a:	5b 01       	movw	r10, r22
    146c:	2a 01       	movw	r4, r20
    146e:	39 01       	movw	r6, r18
    1470:	83 e2       	ldi	r24, 0x23	; 35
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	0e 94 c3 01 	call	0x386	; 0x386 <pvPortMalloc>
    1478:	ec 01       	movw	r28, r24
    147a:	00 97       	sbiw	r24, 0x00	; 0
    147c:	09 f4       	brne	.+2      	; 0x1480 <xTaskGenericCreate+0x38>
    147e:	e7 c0       	rjmp	.+462    	; 0x164e <xTaskGenericCreate+0x206>
    1480:	c1 14       	cp	r12, r1
    1482:	d1 04       	cpc	r13, r1
    1484:	09 f0       	breq	.+2      	; 0x1488 <xTaskGenericCreate+0x40>
    1486:	cc c0       	rjmp	.+408    	; 0x1620 <xTaskGenericCreate+0x1d8>
    1488:	c2 01       	movw	r24, r4
    148a:	0e 94 c3 01 	call	0x386	; 0x386 <pvPortMalloc>
    148e:	98 8f       	std	Y+24, r25	; 0x18
    1490:	8f 8b       	std	Y+23, r24	; 0x17
    1492:	89 2b       	or	r24, r25
    1494:	09 f0       	breq	.+2      	; 0x1498 <xTaskGenericCreate+0x50>
    1496:	c6 c0       	rjmp	.+396    	; 0x1624 <xTaskGenericCreate+0x1dc>
    1498:	ce 01       	movw	r24, r28
    149a:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    149e:	d7 c0       	rjmp	.+430    	; 0x164e <xTaskGenericCreate+0x206>
    14a0:	cf 01       	movw	r24, r30
    14a2:	31 91       	ld	r19, Z+
    14a4:	da 01       	movw	r26, r20
    14a6:	3d 93       	st	X+, r19
    14a8:	ad 01       	movw	r20, r26
    14aa:	dc 01       	movw	r26, r24
    14ac:	8c 91       	ld	r24, X
    14ae:	88 23       	and	r24, r24
    14b0:	11 f0       	breq	.+4      	; 0x14b6 <xTaskGenericCreate+0x6e>
    14b2:	21 50       	subi	r18, 0x01	; 1
    14b4:	a9 f7       	brne	.-22     	; 0x14a0 <xTaskGenericCreate+0x58>
    14b6:	18 a2       	std	Y+32, r1	; 0x20
    14b8:	10 2f       	mov	r17, r16
    14ba:	05 30       	cpi	r16, 0x05	; 5
    14bc:	08 f0       	brcs	.+2      	; 0x14c0 <xTaskGenericCreate+0x78>
    14be:	14 e0       	ldi	r17, 0x04	; 4
    14c0:	1e 8b       	std	Y+22, r17	; 0x16
    14c2:	19 a3       	std	Y+33, r17	; 0x21
    14c4:	1a a2       	std	Y+34, r1	; 0x22
    14c6:	5e 01       	movw	r10, r28
    14c8:	b2 e0       	ldi	r27, 0x02	; 2
    14ca:	ab 0e       	add	r10, r27
    14cc:	b1 1c       	adc	r11, r1
    14ce:	c5 01       	movw	r24, r10
    14d0:	0e 94 07 02 	call	0x40e	; 0x40e <vListInitialiseItem>
    14d4:	ce 01       	movw	r24, r28
    14d6:	0c 96       	adiw	r24, 0x0c	; 12
    14d8:	0e 94 07 02 	call	0x40e	; 0x40e <vListInitialiseItem>
    14dc:	d9 87       	std	Y+9, r29	; 0x09
    14de:	c8 87       	std	Y+8, r28	; 0x08
    14e0:	85 e0       	ldi	r24, 0x05	; 5
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	81 1b       	sub	r24, r17
    14e6:	91 09       	sbc	r25, r1
    14e8:	9d 87       	std	Y+13, r25	; 0x0d
    14ea:	8c 87       	std	Y+12, r24	; 0x0c
    14ec:	db 8b       	std	Y+19, r29	; 0x13
    14ee:	ca 8b       	std	Y+18, r28	; 0x12
    14f0:	a3 01       	movw	r20, r6
    14f2:	b4 01       	movw	r22, r8
    14f4:	c6 01       	movw	r24, r12
    14f6:	d6 da       	rcall	.-2644   	; 0xaa4 <pxPortInitialiseStack>
    14f8:	99 83       	std	Y+1, r25	; 0x01
    14fa:	88 83       	st	Y, r24
    14fc:	e1 14       	cp	r14, r1
    14fe:	f1 04       	cpc	r15, r1
    1500:	19 f0       	breq	.+6      	; 0x1508 <xTaskGenericCreate+0xc0>
    1502:	f7 01       	movw	r30, r14
    1504:	d1 83       	std	Z+1, r29	; 0x01
    1506:	c0 83       	st	Z, r28
    1508:	0f b6       	in	r0, 0x3f	; 63
    150a:	f8 94       	cli
    150c:	0f 92       	push	r0
    150e:	80 91 75 08 	lds	r24, 0x0875
    1512:	8f 5f       	subi	r24, 0xFF	; 255
    1514:	80 93 75 08 	sts	0x0875, r24
    1518:	80 91 d5 08 	lds	r24, 0x08D5
    151c:	90 91 d6 08 	lds	r25, 0x08D6
    1520:	89 2b       	or	r24, r25
    1522:	09 f0       	breq	.+2      	; 0x1526 <xTaskGenericCreate+0xde>
    1524:	3f c0       	rjmp	.+126    	; 0x15a4 <xTaskGenericCreate+0x15c>
    1526:	d0 93 d6 08 	sts	0x08D6, r29
    152a:	c0 93 d5 08 	sts	0x08D5, r28
    152e:	80 91 75 08 	lds	r24, 0x0875
    1532:	81 30       	cpi	r24, 0x01	; 1
    1534:	09 f0       	breq	.+2      	; 0x1538 <xTaskGenericCreate+0xf0>
    1536:	45 c0       	rjmp	.+138    	; 0x15c2 <xTaskGenericCreate+0x17a>
    1538:	0f 2e       	mov	r0, r31
    153a:	f8 ea       	ldi	r31, 0xA8	; 168
    153c:	ef 2e       	mov	r14, r31
    153e:	f8 e0       	ldi	r31, 0x08	; 8
    1540:	ff 2e       	mov	r15, r31
    1542:	f0 2d       	mov	r31, r0
    1544:	0f 2e       	mov	r0, r31
    1546:	f5 ed       	ldi	r31, 0xD5	; 213
    1548:	cf 2e       	mov	r12, r31
    154a:	f8 e0       	ldi	r31, 0x08	; 8
    154c:	df 2e       	mov	r13, r31
    154e:	f0 2d       	mov	r31, r0
    1550:	c7 01       	movw	r24, r14
    1552:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    1556:	f9 e0       	ldi	r31, 0x09	; 9
    1558:	ef 0e       	add	r14, r31
    155a:	f1 1c       	adc	r15, r1
    155c:	ec 14       	cp	r14, r12
    155e:	fd 04       	cpc	r15, r13
    1560:	b9 f7       	brne	.-18     	; 0x1550 <xTaskGenericCreate+0x108>
    1562:	8f e9       	ldi	r24, 0x9F	; 159
    1564:	98 e0       	ldi	r25, 0x08	; 8
    1566:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    156a:	86 e9       	ldi	r24, 0x96	; 150
    156c:	98 e0       	ldi	r25, 0x08	; 8
    156e:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    1572:	89 e8       	ldi	r24, 0x89	; 137
    1574:	98 e0       	ldi	r25, 0x08	; 8
    1576:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    157a:	80 e8       	ldi	r24, 0x80	; 128
    157c:	98 e0       	ldi	r25, 0x08	; 8
    157e:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    1582:	86 e7       	ldi	r24, 0x76	; 118
    1584:	98 e0       	ldi	r25, 0x08	; 8
    1586:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInitialise>
    158a:	8f e9       	ldi	r24, 0x9F	; 159
    158c:	98 e0       	ldi	r25, 0x08	; 8
    158e:	90 93 95 08 	sts	0x0895, r25
    1592:	80 93 94 08 	sts	0x0894, r24
    1596:	86 e9       	ldi	r24, 0x96	; 150
    1598:	98 e0       	ldi	r25, 0x08	; 8
    159a:	90 93 93 08 	sts	0x0893, r25
    159e:	80 93 92 08 	sts	0x0892, r24
    15a2:	0f c0       	rjmp	.+30     	; 0x15c2 <xTaskGenericCreate+0x17a>
    15a4:	80 91 71 08 	lds	r24, 0x0871
    15a8:	81 11       	cpse	r24, r1
    15aa:	0b c0       	rjmp	.+22     	; 0x15c2 <xTaskGenericCreate+0x17a>
    15ac:	e0 91 d5 08 	lds	r30, 0x08D5
    15b0:	f0 91 d6 08 	lds	r31, 0x08D6
    15b4:	86 89       	ldd	r24, Z+22	; 0x16
    15b6:	08 17       	cp	r16, r24
    15b8:	20 f0       	brcs	.+8      	; 0x15c2 <xTaskGenericCreate+0x17a>
    15ba:	d0 93 d6 08 	sts	0x08D6, r29
    15be:	c0 93 d5 08 	sts	0x08D5, r28
    15c2:	80 91 6d 08 	lds	r24, 0x086D
    15c6:	8f 5f       	subi	r24, 0xFF	; 255
    15c8:	80 93 6d 08 	sts	0x086D, r24
    15cc:	8e 89       	ldd	r24, Y+22	; 0x16
    15ce:	90 91 72 08 	lds	r25, 0x0872
    15d2:	98 17       	cp	r25, r24
    15d4:	10 f4       	brcc	.+4      	; 0x15da <xTaskGenericCreate+0x192>
    15d6:	80 93 72 08 	sts	0x0872, r24
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	9c 01       	movw	r18, r24
    15de:	22 0f       	add	r18, r18
    15e0:	33 1f       	adc	r19, r19
    15e2:	22 0f       	add	r18, r18
    15e4:	33 1f       	adc	r19, r19
    15e6:	22 0f       	add	r18, r18
    15e8:	33 1f       	adc	r19, r19
    15ea:	82 0f       	add	r24, r18
    15ec:	93 1f       	adc	r25, r19
    15ee:	b5 01       	movw	r22, r10
    15f0:	88 55       	subi	r24, 0x58	; 88
    15f2:	97 4f       	sbci	r25, 0xF7	; 247
    15f4:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    15f8:	0f 90       	pop	r0
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	80 91 71 08 	lds	r24, 0x0871
    1600:	88 23       	and	r24, r24
    1602:	51 f0       	breq	.+20     	; 0x1618 <xTaskGenericCreate+0x1d0>
    1604:	e0 91 d5 08 	lds	r30, 0x08D5
    1608:	f0 91 d6 08 	lds	r31, 0x08D6
    160c:	86 89       	ldd	r24, Z+22	; 0x16
    160e:	80 17       	cp	r24, r16
    1610:	28 f4       	brcc	.+10     	; 0x161c <xTaskGenericCreate+0x1d4>
    1612:	f7 da       	rcall	.-2578   	; 0xc02 <vPortYield>
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	1c c0       	rjmp	.+56     	; 0x1650 <xTaskGenericCreate+0x208>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	1a c0       	rjmp	.+52     	; 0x1650 <xTaskGenericCreate+0x208>
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	18 c0       	rjmp	.+48     	; 0x1650 <xTaskGenericCreate+0x208>
    1620:	d8 8e       	std	Y+24, r13	; 0x18
    1622:	cf 8a       	std	Y+23, r12	; 0x17
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	48 1a       	sub	r4, r24
    1628:	51 08       	sbc	r5, r1
    162a:	cf 88       	ldd	r12, Y+23	; 0x17
    162c:	d8 8c       	ldd	r13, Y+24	; 0x18
    162e:	c4 0c       	add	r12, r4
    1630:	d5 1c       	adc	r13, r5
    1632:	d5 01       	movw	r26, r10
    1634:	8c 91       	ld	r24, X
    1636:	89 8f       	std	Y+25, r24	; 0x19
    1638:	8c 91       	ld	r24, X
    163a:	88 23       	and	r24, r24
    163c:	09 f4       	brne	.+2      	; 0x1640 <xTaskGenericCreate+0x1f8>
    163e:	3b cf       	rjmp	.-394    	; 0x14b6 <xTaskGenericCreate+0x6e>
    1640:	ae 01       	movw	r20, r28
    1642:	46 5e       	subi	r20, 0xE6	; 230
    1644:	5f 4f       	sbci	r21, 0xFF	; 255
    1646:	f5 01       	movw	r30, r10
    1648:	31 96       	adiw	r30, 0x01	; 1
    164a:	27 e0       	ldi	r18, 0x07	; 7
    164c:	29 cf       	rjmp	.-430    	; 0x14a0 <xTaskGenericCreate+0x58>
    164e:	8f ef       	ldi	r24, 0xFF	; 255
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	1f 91       	pop	r17
    1656:	0f 91       	pop	r16
    1658:	ff 90       	pop	r15
    165a:	ef 90       	pop	r14
    165c:	df 90       	pop	r13
    165e:	cf 90       	pop	r12
    1660:	bf 90       	pop	r11
    1662:	af 90       	pop	r10
    1664:	9f 90       	pop	r9
    1666:	8f 90       	pop	r8
    1668:	7f 90       	pop	r7
    166a:	6f 90       	pop	r6
    166c:	5f 90       	pop	r5
    166e:	4f 90       	pop	r4
    1670:	08 95       	ret

00001672 <vTaskResume>:
    1672:	0f 93       	push	r16
    1674:	1f 93       	push	r17
    1676:	cf 93       	push	r28
    1678:	df 93       	push	r29
    167a:	ec 01       	movw	r28, r24
    167c:	00 97       	sbiw	r24, 0x00	; 0
    167e:	09 f4       	brne	.+2      	; 0x1682 <vTaskResume+0x10>
    1680:	3e c0       	rjmp	.+124    	; 0x16fe <vTaskResume+0x8c>
    1682:	80 91 d5 08 	lds	r24, 0x08D5
    1686:	90 91 d6 08 	lds	r25, 0x08D6
    168a:	c8 17       	cp	r28, r24
    168c:	d9 07       	cpc	r29, r25
    168e:	b9 f1       	breq	.+110    	; 0x16fe <vTaskResume+0x8c>
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	f8 94       	cli
    1694:	0f 92       	push	r0
    1696:	8a 85       	ldd	r24, Y+10	; 0x0a
    1698:	9b 85       	ldd	r25, Y+11	; 0x0b
    169a:	86 57       	subi	r24, 0x76	; 118
    169c:	98 40       	sbci	r25, 0x08	; 8
    169e:	69 f5       	brne	.+90     	; 0x16fa <vTaskResume+0x88>
    16a0:	8c 89       	ldd	r24, Y+20	; 0x14
    16a2:	9d 89       	ldd	r25, Y+21	; 0x15
    16a4:	28 e0       	ldi	r18, 0x08	; 8
    16a6:	89 38       	cpi	r24, 0x89	; 137
    16a8:	92 07       	cpc	r25, r18
    16aa:	39 f1       	breq	.+78     	; 0x16fa <vTaskResume+0x88>
    16ac:	89 2b       	or	r24, r25
    16ae:	29 f5       	brne	.+74     	; 0x16fa <vTaskResume+0x88>
    16b0:	8e 01       	movw	r16, r28
    16b2:	0e 5f       	subi	r16, 0xFE	; 254
    16b4:	1f 4f       	sbci	r17, 0xFF	; 255
    16b6:	c8 01       	movw	r24, r16
    16b8:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    16bc:	8e 89       	ldd	r24, Y+22	; 0x16
    16be:	90 91 72 08 	lds	r25, 0x0872
    16c2:	98 17       	cp	r25, r24
    16c4:	10 f4       	brcc	.+4      	; 0x16ca <vTaskResume+0x58>
    16c6:	80 93 72 08 	sts	0x0872, r24
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	9c 01       	movw	r18, r24
    16ce:	22 0f       	add	r18, r18
    16d0:	33 1f       	adc	r19, r19
    16d2:	22 0f       	add	r18, r18
    16d4:	33 1f       	adc	r19, r19
    16d6:	22 0f       	add	r18, r18
    16d8:	33 1f       	adc	r19, r19
    16da:	82 0f       	add	r24, r18
    16dc:	93 1f       	adc	r25, r19
    16de:	b8 01       	movw	r22, r16
    16e0:	88 55       	subi	r24, 0x58	; 88
    16e2:	97 4f       	sbci	r25, 0xF7	; 247
    16e4:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    16e8:	e0 91 d5 08 	lds	r30, 0x08D5
    16ec:	f0 91 d6 08 	lds	r31, 0x08D6
    16f0:	9e 89       	ldd	r25, Y+22	; 0x16
    16f2:	86 89       	ldd	r24, Z+22	; 0x16
    16f4:	98 17       	cp	r25, r24
    16f6:	08 f0       	brcs	.+2      	; 0x16fa <vTaskResume+0x88>
    16f8:	84 da       	rcall	.-2808   	; 0xc02 <vPortYield>
    16fa:	0f 90       	pop	r0
    16fc:	0f be       	out	0x3f, r0	; 63
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	08 95       	ret

00001708 <vTaskStartScheduler>:
    1708:	af 92       	push	r10
    170a:	bf 92       	push	r11
    170c:	cf 92       	push	r12
    170e:	df 92       	push	r13
    1710:	ef 92       	push	r14
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	a1 2c       	mov	r10, r1
    1718:	b1 2c       	mov	r11, r1
    171a:	c1 2c       	mov	r12, r1
    171c:	d1 2c       	mov	r13, r1
    171e:	e1 2c       	mov	r14, r1
    1720:	f1 2c       	mov	r15, r1
    1722:	00 e0       	ldi	r16, 0x00	; 0
    1724:	20 e0       	ldi	r18, 0x00	; 0
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	45 e5       	ldi	r20, 0x55	; 85
    172a:	50 e0       	ldi	r21, 0x00	; 0
    172c:	67 e8       	ldi	r22, 0x87	; 135
    172e:	72 e0       	ldi	r23, 0x02	; 2
    1730:	8e e0       	ldi	r24, 0x0E	; 14
    1732:	9d e0       	ldi	r25, 0x0D	; 13
    1734:	89 de       	rcall	.-750    	; 0x1448 <xTaskGenericCreate>
    1736:	81 30       	cpi	r24, 0x01	; 1
    1738:	41 f4       	brne	.+16     	; 0x174a <vTaskStartScheduler+0x42>
    173a:	f8 94       	cli
    173c:	80 93 71 08 	sts	0x0871, r24
    1740:	10 92 74 08 	sts	0x0874, r1
    1744:	10 92 73 08 	sts	0x0873, r1
    1748:	1f da       	rcall	.-3010   	; 0xb88 <xPortStartScheduler>
    174a:	0f 91       	pop	r16
    174c:	ff 90       	pop	r15
    174e:	ef 90       	pop	r14
    1750:	df 90       	pop	r13
    1752:	cf 90       	pop	r12
    1754:	bf 90       	pop	r11
    1756:	af 90       	pop	r10
    1758:	08 95       	ret

0000175a <vTaskSuspendAll>:
    175a:	80 91 6c 08 	lds	r24, 0x086C
    175e:	8f 5f       	subi	r24, 0xFF	; 255
    1760:	80 93 6c 08 	sts	0x086C, r24
    1764:	08 95       	ret

00001766 <xTaskIncrementTick>:
    1766:	cf 92       	push	r12
    1768:	df 92       	push	r13
    176a:	ef 92       	push	r14
    176c:	ff 92       	push	r15
    176e:	0f 93       	push	r16
    1770:	1f 93       	push	r17
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	80 91 6c 08 	lds	r24, 0x086C
    177a:	81 11       	cpse	r24, r1
    177c:	99 c0       	rjmp	.+306    	; 0x18b0 <xTaskIncrementTick+0x14a>
    177e:	80 91 73 08 	lds	r24, 0x0873
    1782:	90 91 74 08 	lds	r25, 0x0874
    1786:	01 96       	adiw	r24, 0x01	; 1
    1788:	90 93 74 08 	sts	0x0874, r25
    178c:	80 93 73 08 	sts	0x0873, r24
    1790:	e0 90 73 08 	lds	r14, 0x0873
    1794:	f0 90 74 08 	lds	r15, 0x0874
    1798:	e1 14       	cp	r14, r1
    179a:	f1 04       	cpc	r15, r1
    179c:	b1 f4       	brne	.+44     	; 0x17ca <xTaskIncrementTick+0x64>
    179e:	80 91 94 08 	lds	r24, 0x0894
    17a2:	90 91 95 08 	lds	r25, 0x0895
    17a6:	20 91 92 08 	lds	r18, 0x0892
    17aa:	30 91 93 08 	lds	r19, 0x0893
    17ae:	30 93 95 08 	sts	0x0895, r19
    17b2:	20 93 94 08 	sts	0x0894, r18
    17b6:	90 93 93 08 	sts	0x0893, r25
    17ba:	80 93 92 08 	sts	0x0892, r24
    17be:	80 91 6e 08 	lds	r24, 0x086E
    17c2:	8f 5f       	subi	r24, 0xFF	; 255
    17c4:	80 93 6e 08 	sts	0x086E, r24
    17c8:	eb dd       	rcall	.-1066   	; 0x13a0 <prvResetNextTaskUnblockTime>
    17ca:	80 91 02 02 	lds	r24, 0x0202
    17ce:	90 91 03 02 	lds	r25, 0x0203
    17d2:	e8 16       	cp	r14, r24
    17d4:	f9 06       	cpc	r15, r25
    17d6:	08 f4       	brcc	.+2      	; 0x17da <xTaskIncrementTick+0x74>
    17d8:	54 c0       	rjmp	.+168    	; 0x1882 <xTaskIncrementTick+0x11c>
    17da:	d1 2c       	mov	r13, r1
    17dc:	cc 24       	eor	r12, r12
    17de:	c3 94       	inc	r12
    17e0:	01 c0       	rjmp	.+2      	; 0x17e4 <xTaskIncrementTick+0x7e>
    17e2:	dc 2c       	mov	r13, r12
    17e4:	e0 91 94 08 	lds	r30, 0x0894
    17e8:	f0 91 95 08 	lds	r31, 0x0895
    17ec:	80 81       	ld	r24, Z
    17ee:	81 11       	cpse	r24, r1
    17f0:	07 c0       	rjmp	.+14     	; 0x1800 <xTaskIncrementTick+0x9a>
    17f2:	8f ef       	ldi	r24, 0xFF	; 255
    17f4:	9f ef       	ldi	r25, 0xFF	; 255
    17f6:	90 93 03 02 	sts	0x0203, r25
    17fa:	80 93 02 02 	sts	0x0202, r24
    17fe:	42 c0       	rjmp	.+132    	; 0x1884 <xTaskIncrementTick+0x11e>
    1800:	e0 91 94 08 	lds	r30, 0x0894
    1804:	f0 91 95 08 	lds	r31, 0x0895
    1808:	05 80       	ldd	r0, Z+5	; 0x05
    180a:	f6 81       	ldd	r31, Z+6	; 0x06
    180c:	e0 2d       	mov	r30, r0
    180e:	c6 81       	ldd	r28, Z+6	; 0x06
    1810:	d7 81       	ldd	r29, Z+7	; 0x07
    1812:	2a 81       	ldd	r18, Y+2	; 0x02
    1814:	3b 81       	ldd	r19, Y+3	; 0x03
    1816:	e2 16       	cp	r14, r18
    1818:	f3 06       	cpc	r15, r19
    181a:	28 f4       	brcc	.+10     	; 0x1826 <xTaskIncrementTick+0xc0>
    181c:	30 93 03 02 	sts	0x0203, r19
    1820:	20 93 02 02 	sts	0x0202, r18
    1824:	2f c0       	rjmp	.+94     	; 0x1884 <xTaskIncrementTick+0x11e>
    1826:	8e 01       	movw	r16, r28
    1828:	0e 5f       	subi	r16, 0xFE	; 254
    182a:	1f 4f       	sbci	r17, 0xFF	; 255
    182c:	c8 01       	movw	r24, r16
    182e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1832:	8c 89       	ldd	r24, Y+20	; 0x14
    1834:	9d 89       	ldd	r25, Y+21	; 0x15
    1836:	89 2b       	or	r24, r25
    1838:	21 f0       	breq	.+8      	; 0x1842 <xTaskIncrementTick+0xdc>
    183a:	ce 01       	movw	r24, r28
    183c:	0c 96       	adiw	r24, 0x0c	; 12
    183e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1842:	2e 89       	ldd	r18, Y+22	; 0x16
    1844:	80 91 72 08 	lds	r24, 0x0872
    1848:	82 17       	cp	r24, r18
    184a:	10 f4       	brcc	.+4      	; 0x1850 <xTaskIncrementTick+0xea>
    184c:	20 93 72 08 	sts	0x0872, r18
    1850:	30 e0       	ldi	r19, 0x00	; 0
    1852:	c9 01       	movw	r24, r18
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	88 0f       	add	r24, r24
    185a:	99 1f       	adc	r25, r25
    185c:	88 0f       	add	r24, r24
    185e:	99 1f       	adc	r25, r25
    1860:	82 0f       	add	r24, r18
    1862:	93 1f       	adc	r25, r19
    1864:	b8 01       	movw	r22, r16
    1866:	88 55       	subi	r24, 0x58	; 88
    1868:	97 4f       	sbci	r25, 0xF7	; 247
    186a:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    186e:	e0 91 d5 08 	lds	r30, 0x08D5
    1872:	f0 91 d6 08 	lds	r31, 0x08D6
    1876:	9e 89       	ldd	r25, Y+22	; 0x16
    1878:	86 89       	ldd	r24, Z+22	; 0x16
    187a:	98 17       	cp	r25, r24
    187c:	08 f0       	brcs	.+2      	; 0x1880 <xTaskIncrementTick+0x11a>
    187e:	b1 cf       	rjmp	.-158    	; 0x17e2 <xTaskIncrementTick+0x7c>
    1880:	b1 cf       	rjmp	.-158    	; 0x17e4 <xTaskIncrementTick+0x7e>
    1882:	d1 2c       	mov	r13, r1
    1884:	e0 91 d5 08 	lds	r30, 0x08D5
    1888:	f0 91 d6 08 	lds	r31, 0x08D6
    188c:	86 89       	ldd	r24, Z+22	; 0x16
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	fc 01       	movw	r30, r24
    1892:	ee 0f       	add	r30, r30
    1894:	ff 1f       	adc	r31, r31
    1896:	ee 0f       	add	r30, r30
    1898:	ff 1f       	adc	r31, r31
    189a:	ee 0f       	add	r30, r30
    189c:	ff 1f       	adc	r31, r31
    189e:	8e 0f       	add	r24, r30
    18a0:	9f 1f       	adc	r25, r31
    18a2:	fc 01       	movw	r30, r24
    18a4:	e8 55       	subi	r30, 0x58	; 88
    18a6:	f7 4f       	sbci	r31, 0xF7	; 247
    18a8:	80 81       	ld	r24, Z
    18aa:	82 30       	cpi	r24, 0x02	; 2
    18ac:	40 f4       	brcc	.+16     	; 0x18be <xTaskIncrementTick+0x158>
    18ae:	09 c0       	rjmp	.+18     	; 0x18c2 <xTaskIncrementTick+0x15c>
    18b0:	80 91 70 08 	lds	r24, 0x0870
    18b4:	8f 5f       	subi	r24, 0xFF	; 255
    18b6:	80 93 70 08 	sts	0x0870, r24
    18ba:	d1 2c       	mov	r13, r1
    18bc:	02 c0       	rjmp	.+4      	; 0x18c2 <xTaskIncrementTick+0x15c>
    18be:	dd 24       	eor	r13, r13
    18c0:	d3 94       	inc	r13
    18c2:	80 91 6f 08 	lds	r24, 0x086F
    18c6:	88 23       	and	r24, r24
    18c8:	11 f0       	breq	.+4      	; 0x18ce <xTaskIncrementTick+0x168>
    18ca:	dd 24       	eor	r13, r13
    18cc:	d3 94       	inc	r13
    18ce:	8d 2d       	mov	r24, r13
    18d0:	df 91       	pop	r29
    18d2:	cf 91       	pop	r28
    18d4:	1f 91       	pop	r17
    18d6:	0f 91       	pop	r16
    18d8:	ff 90       	pop	r15
    18da:	ef 90       	pop	r14
    18dc:	df 90       	pop	r13
    18de:	cf 90       	pop	r12
    18e0:	08 95       	ret

000018e2 <xTaskResumeAll>:
    18e2:	df 92       	push	r13
    18e4:	ef 92       	push	r14
    18e6:	ff 92       	push	r15
    18e8:	0f 93       	push	r16
    18ea:	1f 93       	push	r17
    18ec:	cf 93       	push	r28
    18ee:	df 93       	push	r29
    18f0:	0f b6       	in	r0, 0x3f	; 63
    18f2:	f8 94       	cli
    18f4:	0f 92       	push	r0
    18f6:	80 91 6c 08 	lds	r24, 0x086C
    18fa:	81 50       	subi	r24, 0x01	; 1
    18fc:	80 93 6c 08 	sts	0x086C, r24
    1900:	80 91 6c 08 	lds	r24, 0x086C
    1904:	81 11       	cpse	r24, r1
    1906:	5f c0       	rjmp	.+190    	; 0x19c6 <xTaskResumeAll+0xe4>
    1908:	80 91 75 08 	lds	r24, 0x0875
    190c:	88 23       	and	r24, r24
    190e:	09 f4       	brne	.+2      	; 0x1912 <xTaskResumeAll+0x30>
    1910:	5c c0       	rjmp	.+184    	; 0x19ca <xTaskResumeAll+0xe8>
    1912:	0f 2e       	mov	r0, r31
    1914:	f9 e8       	ldi	r31, 0x89	; 137
    1916:	ef 2e       	mov	r14, r31
    1918:	f8 e0       	ldi	r31, 0x08	; 8
    191a:	ff 2e       	mov	r15, r31
    191c:	f0 2d       	mov	r31, r0
    191e:	dd 24       	eor	r13, r13
    1920:	d3 94       	inc	r13
    1922:	30 c0       	rjmp	.+96     	; 0x1984 <xTaskResumeAll+0xa2>
    1924:	e0 91 8e 08 	lds	r30, 0x088E
    1928:	f0 91 8f 08 	lds	r31, 0x088F
    192c:	c6 81       	ldd	r28, Z+6	; 0x06
    192e:	d7 81       	ldd	r29, Z+7	; 0x07
    1930:	ce 01       	movw	r24, r28
    1932:	0c 96       	adiw	r24, 0x0c	; 12
    1934:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1938:	8e 01       	movw	r16, r28
    193a:	0e 5f       	subi	r16, 0xFE	; 254
    193c:	1f 4f       	sbci	r17, 0xFF	; 255
    193e:	c8 01       	movw	r24, r16
    1940:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1944:	8e 89       	ldd	r24, Y+22	; 0x16
    1946:	90 91 72 08 	lds	r25, 0x0872
    194a:	98 17       	cp	r25, r24
    194c:	10 f4       	brcc	.+4      	; 0x1952 <xTaskResumeAll+0x70>
    194e:	80 93 72 08 	sts	0x0872, r24
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	9c 01       	movw	r18, r24
    1956:	22 0f       	add	r18, r18
    1958:	33 1f       	adc	r19, r19
    195a:	22 0f       	add	r18, r18
    195c:	33 1f       	adc	r19, r19
    195e:	22 0f       	add	r18, r18
    1960:	33 1f       	adc	r19, r19
    1962:	82 0f       	add	r24, r18
    1964:	93 1f       	adc	r25, r19
    1966:	b8 01       	movw	r22, r16
    1968:	88 55       	subi	r24, 0x58	; 88
    196a:	97 4f       	sbci	r25, 0xF7	; 247
    196c:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1970:	e0 91 d5 08 	lds	r30, 0x08D5
    1974:	f0 91 d6 08 	lds	r31, 0x08D6
    1978:	9e 89       	ldd	r25, Y+22	; 0x16
    197a:	86 89       	ldd	r24, Z+22	; 0x16
    197c:	98 17       	cp	r25, r24
    197e:	10 f0       	brcs	.+4      	; 0x1984 <xTaskResumeAll+0xa2>
    1980:	d0 92 6f 08 	sts	0x086F, r13
    1984:	f7 01       	movw	r30, r14
    1986:	80 81       	ld	r24, Z
    1988:	81 11       	cpse	r24, r1
    198a:	cc cf       	rjmp	.-104    	; 0x1924 <xTaskResumeAll+0x42>
    198c:	80 91 70 08 	lds	r24, 0x0870
    1990:	88 23       	and	r24, r24
    1992:	91 f0       	breq	.+36     	; 0x19b8 <xTaskResumeAll+0xd6>
    1994:	80 91 70 08 	lds	r24, 0x0870
    1998:	88 23       	and	r24, r24
    199a:	71 f0       	breq	.+28     	; 0x19b8 <xTaskResumeAll+0xd6>
    199c:	c1 e0       	ldi	r28, 0x01	; 1
    199e:	e3 de       	rcall	.-570    	; 0x1766 <xTaskIncrementTick>
    19a0:	81 11       	cpse	r24, r1
    19a2:	c0 93 6f 08 	sts	0x086F, r28
    19a6:	80 91 70 08 	lds	r24, 0x0870
    19aa:	81 50       	subi	r24, 0x01	; 1
    19ac:	80 93 70 08 	sts	0x0870, r24
    19b0:	80 91 70 08 	lds	r24, 0x0870
    19b4:	81 11       	cpse	r24, r1
    19b6:	f3 cf       	rjmp	.-26     	; 0x199e <xTaskResumeAll+0xbc>
    19b8:	80 91 6f 08 	lds	r24, 0x086F
    19bc:	81 30       	cpi	r24, 0x01	; 1
    19be:	39 f4       	brne	.+14     	; 0x19ce <xTaskResumeAll+0xec>
    19c0:	20 d9       	rcall	.-3520   	; 0xc02 <vPortYield>
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	05 c0       	rjmp	.+10     	; 0x19d0 <xTaskResumeAll+0xee>
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	03 c0       	rjmp	.+6      	; 0x19d0 <xTaskResumeAll+0xee>
    19ca:	80 e0       	ldi	r24, 0x00	; 0
    19cc:	01 c0       	rjmp	.+2      	; 0x19d0 <xTaskResumeAll+0xee>
    19ce:	80 e0       	ldi	r24, 0x00	; 0
    19d0:	0f 90       	pop	r0
    19d2:	0f be       	out	0x3f, r0	; 63
    19d4:	df 91       	pop	r29
    19d6:	cf 91       	pop	r28
    19d8:	1f 91       	pop	r17
    19da:	0f 91       	pop	r16
    19dc:	ff 90       	pop	r15
    19de:	ef 90       	pop	r14
    19e0:	df 90       	pop	r13
    19e2:	08 95       	ret

000019e4 <vTaskDelay>:
    19e4:	cf 93       	push	r28
    19e6:	df 93       	push	r29
    19e8:	ec 01       	movw	r28, r24
    19ea:	00 97       	sbiw	r24, 0x00	; 0
    19ec:	99 f0       	breq	.+38     	; 0x1a14 <vTaskDelay+0x30>
    19ee:	b5 de       	rcall	.-662    	; 0x175a <vTaskSuspendAll>
    19f0:	80 91 73 08 	lds	r24, 0x0873
    19f4:	90 91 74 08 	lds	r25, 0x0874
    19f8:	c8 0f       	add	r28, r24
    19fa:	d9 1f       	adc	r29, r25
    19fc:	80 91 d5 08 	lds	r24, 0x08D5
    1a00:	90 91 d6 08 	lds	r25, 0x08D6
    1a04:	02 96       	adiw	r24, 0x02	; 2
    1a06:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1a0a:	ce 01       	movw	r24, r28
    1a0c:	e8 dc       	rcall	.-1584   	; 0x13de <prvAddCurrentTaskToDelayedList>
    1a0e:	69 df       	rcall	.-302    	; 0x18e2 <xTaskResumeAll>
    1a10:	81 11       	cpse	r24, r1
    1a12:	01 c0       	rjmp	.+2      	; 0x1a16 <vTaskDelay+0x32>
    1a14:	f6 d8       	rcall	.-3604   	; 0xc02 <vPortYield>
    1a16:	df 91       	pop	r29
    1a18:	cf 91       	pop	r28
    1a1a:	08 95       	ret

00001a1c <prvIdleTask>:
    1a1c:	0f 2e       	mov	r0, r31
    1a1e:	f8 ea       	ldi	r31, 0xA8	; 168
    1a20:	ef 2e       	mov	r14, r31
    1a22:	f8 e0       	ldi	r31, 0x08	; 8
    1a24:	ff 2e       	mov	r15, r31
    1a26:	f0 2d       	mov	r31, r0
    1a28:	c0 e8       	ldi	r28, 0x80	; 128
    1a2a:	d8 e0       	ldi	r29, 0x08	; 8
    1a2c:	26 c0       	rjmp	.+76     	; 0x1a7a <prvIdleTask+0x5e>
    1a2e:	95 de       	rcall	.-726    	; 0x175a <vTaskSuspendAll>
    1a30:	18 81       	ld	r17, Y
    1a32:	57 df       	rcall	.-338    	; 0x18e2 <xTaskResumeAll>
    1a34:	11 23       	and	r17, r17
    1a36:	09 f1       	breq	.+66     	; 0x1a7a <prvIdleTask+0x5e>
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
    1a3e:	e0 91 85 08 	lds	r30, 0x0885
    1a42:	f0 91 86 08 	lds	r31, 0x0886
    1a46:	06 81       	ldd	r16, Z+6	; 0x06
    1a48:	17 81       	ldd	r17, Z+7	; 0x07
    1a4a:	c8 01       	movw	r24, r16
    1a4c:	02 96       	adiw	r24, 0x02	; 2
    1a4e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1a52:	80 91 75 08 	lds	r24, 0x0875
    1a56:	81 50       	subi	r24, 0x01	; 1
    1a58:	80 93 75 08 	sts	0x0875, r24
    1a5c:	80 91 7f 08 	lds	r24, 0x087F
    1a60:	81 50       	subi	r24, 0x01	; 1
    1a62:	80 93 7f 08 	sts	0x087F, r24
    1a66:	0f 90       	pop	r0
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	87 89       	ldd	r24, Z+23	; 0x17
    1a6e:	90 8d       	ldd	r25, Z+24	; 0x18
    1a70:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    1a74:	c8 01       	movw	r24, r16
    1a76:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortFree>
    1a7a:	80 91 7f 08 	lds	r24, 0x087F
    1a7e:	81 11       	cpse	r24, r1
    1a80:	d6 cf       	rjmp	.-84     	; 0x1a2e <prvIdleTask+0x12>
    1a82:	f7 01       	movw	r30, r14
    1a84:	80 81       	ld	r24, Z
    1a86:	82 30       	cpi	r24, 0x02	; 2
    1a88:	c0 f3       	brcs	.-16     	; 0x1a7a <prvIdleTask+0x5e>
    1a8a:	bb d8       	rcall	.-3722   	; 0xc02 <vPortYield>
    1a8c:	f6 cf       	rjmp	.-20     	; 0x1a7a <prvIdleTask+0x5e>

00001a8e <vTaskSwitchContext>:
    1a8e:	80 91 6c 08 	lds	r24, 0x086C
    1a92:	88 23       	and	r24, r24
    1a94:	21 f0       	breq	.+8      	; 0x1a9e <vTaskSwitchContext+0x10>
    1a96:	81 e0       	ldi	r24, 0x01	; 1
    1a98:	80 93 6f 08 	sts	0x086F, r24
    1a9c:	08 95       	ret
    1a9e:	10 92 6f 08 	sts	0x086F, r1
    1aa2:	80 91 72 08 	lds	r24, 0x0872
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	ee 0f       	add	r30, r30
    1aac:	ff 1f       	adc	r31, r31
    1aae:	ee 0f       	add	r30, r30
    1ab0:	ff 1f       	adc	r31, r31
    1ab2:	ee 0f       	add	r30, r30
    1ab4:	ff 1f       	adc	r31, r31
    1ab6:	8e 0f       	add	r24, r30
    1ab8:	9f 1f       	adc	r25, r31
    1aba:	fc 01       	movw	r30, r24
    1abc:	e8 55       	subi	r30, 0x58	; 88
    1abe:	f7 4f       	sbci	r31, 0xF7	; 247
    1ac0:	80 81       	ld	r24, Z
    1ac2:	81 11       	cpse	r24, r1
    1ac4:	17 c0       	rjmp	.+46     	; 0x1af4 <vTaskSwitchContext+0x66>
    1ac6:	80 91 72 08 	lds	r24, 0x0872
    1aca:	81 50       	subi	r24, 0x01	; 1
    1acc:	80 93 72 08 	sts	0x0872, r24
    1ad0:	80 91 72 08 	lds	r24, 0x0872
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	ee 0f       	add	r30, r30
    1ada:	ff 1f       	adc	r31, r31
    1adc:	ee 0f       	add	r30, r30
    1ade:	ff 1f       	adc	r31, r31
    1ae0:	ee 0f       	add	r30, r30
    1ae2:	ff 1f       	adc	r31, r31
    1ae4:	8e 0f       	add	r24, r30
    1ae6:	9f 1f       	adc	r25, r31
    1ae8:	fc 01       	movw	r30, r24
    1aea:	e8 55       	subi	r30, 0x58	; 88
    1aec:	f7 4f       	sbci	r31, 0xF7	; 247
    1aee:	80 81       	ld	r24, Z
    1af0:	88 23       	and	r24, r24
    1af2:	49 f3       	breq	.-46     	; 0x1ac6 <vTaskSwitchContext+0x38>
    1af4:	e0 91 72 08 	lds	r30, 0x0872
    1af8:	f0 e0       	ldi	r31, 0x00	; 0
    1afa:	cf 01       	movw	r24, r30
    1afc:	88 0f       	add	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	88 0f       	add	r24, r24
    1b06:	99 1f       	adc	r25, r25
    1b08:	e8 0f       	add	r30, r24
    1b0a:	f9 1f       	adc	r31, r25
    1b0c:	e8 55       	subi	r30, 0x58	; 88
    1b0e:	f7 4f       	sbci	r31, 0xF7	; 247
    1b10:	a1 81       	ldd	r26, Z+1	; 0x01
    1b12:	b2 81       	ldd	r27, Z+2	; 0x02
    1b14:	12 96       	adiw	r26, 0x02	; 2
    1b16:	0d 90       	ld	r0, X+
    1b18:	bc 91       	ld	r27, X
    1b1a:	a0 2d       	mov	r26, r0
    1b1c:	b2 83       	std	Z+2, r27	; 0x02
    1b1e:	a1 83       	std	Z+1, r26	; 0x01
    1b20:	cf 01       	movw	r24, r30
    1b22:	03 96       	adiw	r24, 0x03	; 3
    1b24:	a8 17       	cp	r26, r24
    1b26:	b9 07       	cpc	r27, r25
    1b28:	31 f4       	brne	.+12     	; 0x1b36 <vTaskSwitchContext+0xa8>
    1b2a:	12 96       	adiw	r26, 0x02	; 2
    1b2c:	8d 91       	ld	r24, X+
    1b2e:	9c 91       	ld	r25, X
    1b30:	13 97       	sbiw	r26, 0x03	; 3
    1b32:	92 83       	std	Z+2, r25	; 0x02
    1b34:	81 83       	std	Z+1, r24	; 0x01
    1b36:	01 80       	ldd	r0, Z+1	; 0x01
    1b38:	f2 81       	ldd	r31, Z+2	; 0x02
    1b3a:	e0 2d       	mov	r30, r0
    1b3c:	86 81       	ldd	r24, Z+6	; 0x06
    1b3e:	97 81       	ldd	r25, Z+7	; 0x07
    1b40:	90 93 d6 08 	sts	0x08D6, r25
    1b44:	80 93 d5 08 	sts	0x08D5, r24
    1b48:	08 95       	ret

00001b4a <vTaskSuspend>:
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	ec 01       	movw	r28, r24
    1b54:	0f b6       	in	r0, 0x3f	; 63
    1b56:	f8 94       	cli
    1b58:	0f 92       	push	r0
    1b5a:	00 97       	sbiw	r24, 0x00	; 0
    1b5c:	21 f4       	brne	.+8      	; 0x1b66 <vTaskSuspend+0x1c>
    1b5e:	c0 91 d5 08 	lds	r28, 0x08D5
    1b62:	d0 91 d6 08 	lds	r29, 0x08D6
    1b66:	8e 01       	movw	r16, r28
    1b68:	0e 5f       	subi	r16, 0xFE	; 254
    1b6a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b6c:	c8 01       	movw	r24, r16
    1b6e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1b72:	8c 89       	ldd	r24, Y+20	; 0x14
    1b74:	9d 89       	ldd	r25, Y+21	; 0x15
    1b76:	89 2b       	or	r24, r25
    1b78:	21 f0       	breq	.+8      	; 0x1b82 <vTaskSuspend+0x38>
    1b7a:	ce 01       	movw	r24, r28
    1b7c:	0c 96       	adiw	r24, 0x0c	; 12
    1b7e:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1b82:	b8 01       	movw	r22, r16
    1b84:	86 e7       	ldi	r24, 0x76	; 118
    1b86:	98 e0       	ldi	r25, 0x08	; 8
    1b88:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1b8c:	0f 90       	pop	r0
    1b8e:	0f be       	out	0x3f, r0	; 63
    1b90:	80 91 d5 08 	lds	r24, 0x08D5
    1b94:	90 91 d6 08 	lds	r25, 0x08D6
    1b98:	c8 17       	cp	r28, r24
    1b9a:	d9 07       	cpc	r29, r25
    1b9c:	99 f4       	brne	.+38     	; 0x1bc4 <vTaskSuspend+0x7a>
    1b9e:	80 91 71 08 	lds	r24, 0x0871
    1ba2:	88 23       	and	r24, r24
    1ba4:	11 f0       	breq	.+4      	; 0x1baa <vTaskSuspend+0x60>
    1ba6:	2d d8       	rcall	.-4006   	; 0xc02 <vPortYield>
    1ba8:	17 c0       	rjmp	.+46     	; 0x1bd8 <vTaskSuspend+0x8e>
    1baa:	80 91 75 08 	lds	r24, 0x0875
    1bae:	90 91 76 08 	lds	r25, 0x0876
    1bb2:	98 13       	cpse	r25, r24
    1bb4:	05 c0       	rjmp	.+10     	; 0x1bc0 <vTaskSuspend+0x76>
    1bb6:	10 92 d6 08 	sts	0x08D6, r1
    1bba:	10 92 d5 08 	sts	0x08D5, r1
    1bbe:	0c c0       	rjmp	.+24     	; 0x1bd8 <vTaskSuspend+0x8e>
    1bc0:	66 df       	rcall	.-308    	; 0x1a8e <vTaskSwitchContext>
    1bc2:	0a c0       	rjmp	.+20     	; 0x1bd8 <vTaskSuspend+0x8e>
    1bc4:	80 91 71 08 	lds	r24, 0x0871
    1bc8:	88 23       	and	r24, r24
    1bca:	31 f0       	breq	.+12     	; 0x1bd8 <vTaskSuspend+0x8e>
    1bcc:	0f b6       	in	r0, 0x3f	; 63
    1bce:	f8 94       	cli
    1bd0:	0f 92       	push	r0
    1bd2:	e6 db       	rcall	.-2100   	; 0x13a0 <prvResetNextTaskUnblockTime>
    1bd4:	0f 90       	pop	r0
    1bd6:	0f be       	out	0x3f, r0	; 63
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	08 95       	ret

00001be2 <vTaskPlaceOnEventList>:
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	eb 01       	movw	r28, r22
    1be8:	60 91 d5 08 	lds	r22, 0x08D5
    1bec:	70 91 d6 08 	lds	r23, 0x08D6
    1bf0:	64 5f       	subi	r22, 0xF4	; 244
    1bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf4:	0e 94 2c 02 	call	0x458	; 0x458 <vListInsert>
    1bf8:	80 91 d5 08 	lds	r24, 0x08D5
    1bfc:	90 91 d6 08 	lds	r25, 0x08D6
    1c00:	02 96       	adiw	r24, 0x02	; 2
    1c02:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1c06:	cf 3f       	cpi	r28, 0xFF	; 255
    1c08:	8f ef       	ldi	r24, 0xFF	; 255
    1c0a:	d8 07       	cpc	r29, r24
    1c0c:	59 f4       	brne	.+22     	; 0x1c24 <vTaskPlaceOnEventList+0x42>
    1c0e:	60 91 d5 08 	lds	r22, 0x08D5
    1c12:	70 91 d6 08 	lds	r23, 0x08D6
    1c16:	6e 5f       	subi	r22, 0xFE	; 254
    1c18:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1a:	86 e7       	ldi	r24, 0x76	; 118
    1c1c:	98 e0       	ldi	r25, 0x08	; 8
    1c1e:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1c22:	07 c0       	rjmp	.+14     	; 0x1c32 <vTaskPlaceOnEventList+0x50>
    1c24:	80 91 73 08 	lds	r24, 0x0873
    1c28:	90 91 74 08 	lds	r25, 0x0874
    1c2c:	8c 0f       	add	r24, r28
    1c2e:	9d 1f       	adc	r25, r29
    1c30:	d6 db       	rcall	.-2132   	; 0x13de <prvAddCurrentTaskToDelayedList>
    1c32:	df 91       	pop	r29
    1c34:	cf 91       	pop	r28
    1c36:	08 95       	ret

00001c38 <xTaskRemoveFromEventList>:
    1c38:	0f 93       	push	r16
    1c3a:	1f 93       	push	r17
    1c3c:	cf 93       	push	r28
    1c3e:	df 93       	push	r29
    1c40:	dc 01       	movw	r26, r24
    1c42:	15 96       	adiw	r26, 0x05	; 5
    1c44:	ed 91       	ld	r30, X+
    1c46:	fc 91       	ld	r31, X
    1c48:	16 97       	sbiw	r26, 0x06	; 6
    1c4a:	c6 81       	ldd	r28, Z+6	; 0x06
    1c4c:	d7 81       	ldd	r29, Z+7	; 0x07
    1c4e:	8e 01       	movw	r16, r28
    1c50:	04 5f       	subi	r16, 0xF4	; 244
    1c52:	1f 4f       	sbci	r17, 0xFF	; 255
    1c54:	c8 01       	movw	r24, r16
    1c56:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1c5a:	80 91 6c 08 	lds	r24, 0x086C
    1c5e:	81 11       	cpse	r24, r1
    1c60:	1c c0       	rjmp	.+56     	; 0x1c9a <xTaskRemoveFromEventList+0x62>
    1c62:	0a 50       	subi	r16, 0x0A	; 10
    1c64:	11 09       	sbc	r17, r1
    1c66:	c8 01       	movw	r24, r16
    1c68:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1c6c:	8e 89       	ldd	r24, Y+22	; 0x16
    1c6e:	90 91 72 08 	lds	r25, 0x0872
    1c72:	98 17       	cp	r25, r24
    1c74:	10 f4       	brcc	.+4      	; 0x1c7a <xTaskRemoveFromEventList+0x42>
    1c76:	80 93 72 08 	sts	0x0872, r24
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	9c 01       	movw	r18, r24
    1c7e:	22 0f       	add	r18, r18
    1c80:	33 1f       	adc	r19, r19
    1c82:	22 0f       	add	r18, r18
    1c84:	33 1f       	adc	r19, r19
    1c86:	22 0f       	add	r18, r18
    1c88:	33 1f       	adc	r19, r19
    1c8a:	82 0f       	add	r24, r18
    1c8c:	93 1f       	adc	r25, r19
    1c8e:	b8 01       	movw	r22, r16
    1c90:	88 55       	subi	r24, 0x58	; 88
    1c92:	97 4f       	sbci	r25, 0xF7	; 247
    1c94:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1c98:	05 c0       	rjmp	.+10     	; 0x1ca4 <xTaskRemoveFromEventList+0x6c>
    1c9a:	b8 01       	movw	r22, r16
    1c9c:	89 e8       	ldi	r24, 0x89	; 137
    1c9e:	98 e0       	ldi	r25, 0x08	; 8
    1ca0:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1ca4:	e0 91 d5 08 	lds	r30, 0x08D5
    1ca8:	f0 91 d6 08 	lds	r31, 0x08D6
    1cac:	9e 89       	ldd	r25, Y+22	; 0x16
    1cae:	86 89       	ldd	r24, Z+22	; 0x16
    1cb0:	89 17       	cp	r24, r25
    1cb2:	20 f4       	brcc	.+8      	; 0x1cbc <xTaskRemoveFromEventList+0x84>
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	80 93 6f 08 	sts	0x086F, r24
    1cba:	01 c0       	rjmp	.+2      	; 0x1cbe <xTaskRemoveFromEventList+0x86>
    1cbc:	80 e0       	ldi	r24, 0x00	; 0
    1cbe:	df 91       	pop	r29
    1cc0:	cf 91       	pop	r28
    1cc2:	1f 91       	pop	r17
    1cc4:	0f 91       	pop	r16
    1cc6:	08 95       	ret

00001cc8 <vTaskSetTimeOutState>:
    1cc8:	20 91 6e 08 	lds	r18, 0x086E
    1ccc:	fc 01       	movw	r30, r24
    1cce:	20 83       	st	Z, r18
    1cd0:	20 91 73 08 	lds	r18, 0x0873
    1cd4:	30 91 74 08 	lds	r19, 0x0874
    1cd8:	32 83       	std	Z+2, r19	; 0x02
    1cda:	21 83       	std	Z+1, r18	; 0x01
    1cdc:	08 95       	ret

00001cde <xTaskCheckForTimeOut>:
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	0f 92       	push	r0
    1ce4:	40 91 73 08 	lds	r20, 0x0873
    1ce8:	50 91 74 08 	lds	r21, 0x0874
    1cec:	db 01       	movw	r26, r22
    1cee:	2d 91       	ld	r18, X+
    1cf0:	3c 91       	ld	r19, X
    1cf2:	2f 3f       	cpi	r18, 0xFF	; 255
    1cf4:	bf ef       	ldi	r27, 0xFF	; 255
    1cf6:	3b 07       	cpc	r19, r27
    1cf8:	11 f1       	breq	.+68     	; 0x1d3e <xTaskCheckForTimeOut+0x60>
    1cfa:	e0 91 6e 08 	lds	r30, 0x086E
    1cfe:	dc 01       	movw	r26, r24
    1d00:	fc 91       	ld	r31, X
    1d02:	fe 17       	cp	r31, r30
    1d04:	39 f0       	breq	.+14     	; 0x1d14 <xTaskCheckForTimeOut+0x36>
    1d06:	11 96       	adiw	r26, 0x01	; 1
    1d08:	ed 91       	ld	r30, X+
    1d0a:	fc 91       	ld	r31, X
    1d0c:	12 97       	sbiw	r26, 0x02	; 2
    1d0e:	4e 17       	cp	r20, r30
    1d10:	5f 07       	cpc	r21, r31
    1d12:	b8 f4       	brcc	.+46     	; 0x1d42 <xTaskCheckForTimeOut+0x64>
    1d14:	dc 01       	movw	r26, r24
    1d16:	11 96       	adiw	r26, 0x01	; 1
    1d18:	ed 91       	ld	r30, X+
    1d1a:	fc 91       	ld	r31, X
    1d1c:	12 97       	sbiw	r26, 0x02	; 2
    1d1e:	da 01       	movw	r26, r20
    1d20:	ae 1b       	sub	r26, r30
    1d22:	bf 0b       	sbc	r27, r31
    1d24:	a2 17       	cp	r26, r18
    1d26:	b3 07       	cpc	r27, r19
    1d28:	70 f4       	brcc	.+28     	; 0x1d46 <xTaskCheckForTimeOut+0x68>
    1d2a:	e4 1b       	sub	r30, r20
    1d2c:	f5 0b       	sbc	r31, r21
    1d2e:	2e 0f       	add	r18, r30
    1d30:	3f 1f       	adc	r19, r31
    1d32:	fb 01       	movw	r30, r22
    1d34:	31 83       	std	Z+1, r19	; 0x01
    1d36:	20 83       	st	Z, r18
    1d38:	c7 df       	rcall	.-114    	; 0x1cc8 <vTaskSetTimeOutState>
    1d3a:	80 e0       	ldi	r24, 0x00	; 0
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <xTaskCheckForTimeOut+0x6a>
    1d3e:	80 e0       	ldi	r24, 0x00	; 0
    1d40:	03 c0       	rjmp	.+6      	; 0x1d48 <xTaskCheckForTimeOut+0x6a>
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	01 c0       	rjmp	.+2      	; 0x1d48 <xTaskCheckForTimeOut+0x6a>
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	0f 90       	pop	r0
    1d4a:	0f be       	out	0x3f, r0	; 63
    1d4c:	08 95       	ret

00001d4e <vTaskMissedYield>:
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	80 93 6f 08 	sts	0x086F, r24
    1d54:	08 95       	ret

00001d56 <vTaskPriorityInherit>:
    1d56:	0f 93       	push	r16
    1d58:	1f 93       	push	r17
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	ec 01       	movw	r28, r24
    1d60:	00 97       	sbiw	r24, 0x00	; 0
    1d62:	09 f4       	brne	.+2      	; 0x1d66 <vTaskPriorityInherit+0x10>
    1d64:	51 c0       	rjmp	.+162    	; 0x1e08 <vTaskPriorityInherit+0xb2>
    1d66:	8e 89       	ldd	r24, Y+22	; 0x16
    1d68:	e0 91 d5 08 	lds	r30, 0x08D5
    1d6c:	f0 91 d6 08 	lds	r31, 0x08D6
    1d70:	96 89       	ldd	r25, Z+22	; 0x16
    1d72:	89 17       	cp	r24, r25
    1d74:	08 f0       	brcs	.+2      	; 0x1d78 <vTaskPriorityInherit+0x22>
    1d76:	48 c0       	rjmp	.+144    	; 0x1e08 <vTaskPriorityInherit+0xb2>
    1d78:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d7a:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d7c:	33 23       	and	r19, r19
    1d7e:	5c f0       	brlt	.+22     	; 0x1d96 <vTaskPriorityInherit+0x40>
    1d80:	e0 91 d5 08 	lds	r30, 0x08D5
    1d84:	f0 91 d6 08 	lds	r31, 0x08D6
    1d88:	96 89       	ldd	r25, Z+22	; 0x16
    1d8a:	25 e0       	ldi	r18, 0x05	; 5
    1d8c:	30 e0       	ldi	r19, 0x00	; 0
    1d8e:	29 1b       	sub	r18, r25
    1d90:	31 09       	sbc	r19, r1
    1d92:	3d 87       	std	Y+13, r19	; 0x0d
    1d94:	2c 87       	std	Y+12, r18	; 0x0c
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	9c 01       	movw	r18, r24
    1d9a:	22 0f       	add	r18, r18
    1d9c:	33 1f       	adc	r19, r19
    1d9e:	22 0f       	add	r18, r18
    1da0:	33 1f       	adc	r19, r19
    1da2:	22 0f       	add	r18, r18
    1da4:	33 1f       	adc	r19, r19
    1da6:	82 0f       	add	r24, r18
    1da8:	93 1f       	adc	r25, r19
    1daa:	88 55       	subi	r24, 0x58	; 88
    1dac:	97 4f       	sbci	r25, 0xF7	; 247
    1dae:	2a 85       	ldd	r18, Y+10	; 0x0a
    1db0:	3b 85       	ldd	r19, Y+11	; 0x0b
    1db2:	28 17       	cp	r18, r24
    1db4:	39 07       	cpc	r19, r25
    1db6:	11 f5       	brne	.+68     	; 0x1dfc <vTaskPriorityInherit+0xa6>
    1db8:	8e 01       	movw	r16, r28
    1dba:	0e 5f       	subi	r16, 0xFE	; 254
    1dbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dbe:	c8 01       	movw	r24, r16
    1dc0:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1dc4:	e0 91 d5 08 	lds	r30, 0x08D5
    1dc8:	f0 91 d6 08 	lds	r31, 0x08D6
    1dcc:	86 89       	ldd	r24, Z+22	; 0x16
    1dce:	8e 8b       	std	Y+22, r24	; 0x16
    1dd0:	90 91 72 08 	lds	r25, 0x0872
    1dd4:	98 17       	cp	r25, r24
    1dd6:	10 f4       	brcc	.+4      	; 0x1ddc <vTaskPriorityInherit+0x86>
    1dd8:	80 93 72 08 	sts	0x0872, r24
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	9c 01       	movw	r18, r24
    1de0:	22 0f       	add	r18, r18
    1de2:	33 1f       	adc	r19, r19
    1de4:	22 0f       	add	r18, r18
    1de6:	33 1f       	adc	r19, r19
    1de8:	22 0f       	add	r18, r18
    1dea:	33 1f       	adc	r19, r19
    1dec:	82 0f       	add	r24, r18
    1dee:	93 1f       	adc	r25, r19
    1df0:	b8 01       	movw	r22, r16
    1df2:	88 55       	subi	r24, 0x58	; 88
    1df4:	97 4f       	sbci	r25, 0xF7	; 247
    1df6:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1dfa:	06 c0       	rjmp	.+12     	; 0x1e08 <vTaskPriorityInherit+0xb2>
    1dfc:	e0 91 d5 08 	lds	r30, 0x08D5
    1e00:	f0 91 d6 08 	lds	r31, 0x08D6
    1e04:	86 89       	ldd	r24, Z+22	; 0x16
    1e06:	8e 8b       	std	Y+22, r24	; 0x16
    1e08:	df 91       	pop	r29
    1e0a:	cf 91       	pop	r28
    1e0c:	1f 91       	pop	r17
    1e0e:	0f 91       	pop	r16
    1e10:	08 95       	ret

00001e12 <xTaskPriorityDisinherit>:
    1e12:	0f 93       	push	r16
    1e14:	1f 93       	push	r17
    1e16:	cf 93       	push	r28
    1e18:	df 93       	push	r29
    1e1a:	ec 01       	movw	r28, r24
    1e1c:	00 97       	sbiw	r24, 0x00	; 0
    1e1e:	71 f1       	breq	.+92     	; 0x1e7c <xTaskPriorityDisinherit+0x6a>
    1e20:	8a a1       	ldd	r24, Y+34	; 0x22
    1e22:	81 50       	subi	r24, 0x01	; 1
    1e24:	8a a3       	std	Y+34, r24	; 0x22
    1e26:	2e 89       	ldd	r18, Y+22	; 0x16
    1e28:	99 a1       	ldd	r25, Y+33	; 0x21
    1e2a:	29 17       	cp	r18, r25
    1e2c:	49 f1       	breq	.+82     	; 0x1e80 <xTaskPriorityDisinherit+0x6e>
    1e2e:	81 11       	cpse	r24, r1
    1e30:	29 c0       	rjmp	.+82     	; 0x1e84 <xTaskPriorityDisinherit+0x72>
    1e32:	8e 01       	movw	r16, r28
    1e34:	0e 5f       	subi	r16, 0xFE	; 254
    1e36:	1f 4f       	sbci	r17, 0xFF	; 255
    1e38:	c8 01       	movw	r24, r16
    1e3a:	0e 94 5d 02 	call	0x4ba	; 0x4ba <uxListRemove>
    1e3e:	89 a1       	ldd	r24, Y+33	; 0x21
    1e40:	8e 8b       	std	Y+22, r24	; 0x16
    1e42:	25 e0       	ldi	r18, 0x05	; 5
    1e44:	30 e0       	ldi	r19, 0x00	; 0
    1e46:	28 1b       	sub	r18, r24
    1e48:	31 09       	sbc	r19, r1
    1e4a:	3d 87       	std	Y+13, r19	; 0x0d
    1e4c:	2c 87       	std	Y+12, r18	; 0x0c
    1e4e:	90 91 72 08 	lds	r25, 0x0872
    1e52:	98 17       	cp	r25, r24
    1e54:	10 f4       	brcc	.+4      	; 0x1e5a <xTaskPriorityDisinherit+0x48>
    1e56:	80 93 72 08 	sts	0x0872, r24
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	9c 01       	movw	r18, r24
    1e5e:	22 0f       	add	r18, r18
    1e60:	33 1f       	adc	r19, r19
    1e62:	22 0f       	add	r18, r18
    1e64:	33 1f       	adc	r19, r19
    1e66:	22 0f       	add	r18, r18
    1e68:	33 1f       	adc	r19, r19
    1e6a:	82 0f       	add	r24, r18
    1e6c:	93 1f       	adc	r25, r19
    1e6e:	b8 01       	movw	r22, r16
    1e70:	88 55       	subi	r24, 0x58	; 88
    1e72:	97 4f       	sbci	r25, 0xF7	; 247
    1e74:	0e 94 0b 02 	call	0x416	; 0x416 <vListInsertEnd>
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	05 c0       	rjmp	.+10     	; 0x1e86 <xTaskPriorityDisinherit+0x74>
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	03 c0       	rjmp	.+6      	; 0x1e86 <xTaskPriorityDisinherit+0x74>
    1e80:	80 e0       	ldi	r24, 0x00	; 0
    1e82:	01 c0       	rjmp	.+2      	; 0x1e86 <xTaskPriorityDisinherit+0x74>
    1e84:	80 e0       	ldi	r24, 0x00	; 0
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	1f 91       	pop	r17
    1e8c:	0f 91       	pop	r16
    1e8e:	08 95       	ret

00001e90 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1e90:	80 91 d5 08 	lds	r24, 0x08D5
    1e94:	90 91 d6 08 	lds	r25, 0x08D6
    1e98:	89 2b       	or	r24, r25
    1e9a:	39 f0       	breq	.+14     	; 0x1eaa <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1e9c:	e0 91 d5 08 	lds	r30, 0x08D5
    1ea0:	f0 91 d6 08 	lds	r31, 0x08D6
    1ea4:	82 a1       	ldd	r24, Z+34	; 0x22
    1ea6:	8f 5f       	subi	r24, 0xFF	; 255
    1ea8:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1eaa:	80 91 d5 08 	lds	r24, 0x08D5
    1eae:	90 91 d6 08 	lds	r25, 0x08D6
	}
    1eb2:	08 95       	ret

00001eb4 <__divmodhi4>:
    1eb4:	97 fb       	bst	r25, 7
    1eb6:	07 2e       	mov	r0, r23
    1eb8:	16 f4       	brtc	.+4      	; 0x1ebe <__divmodhi4+0xa>
    1eba:	00 94       	com	r0
    1ebc:	06 d0       	rcall	.+12     	; 0x1eca <__divmodhi4_neg1>
    1ebe:	77 fd       	sbrc	r23, 7
    1ec0:	08 d0       	rcall	.+16     	; 0x1ed2 <__divmodhi4_neg2>
    1ec2:	0b d0       	rcall	.+22     	; 0x1eda <__udivmodhi4>
    1ec4:	07 fc       	sbrc	r0, 7
    1ec6:	05 d0       	rcall	.+10     	; 0x1ed2 <__divmodhi4_neg2>
    1ec8:	3e f4       	brtc	.+14     	; 0x1ed8 <__divmodhi4_exit>

00001eca <__divmodhi4_neg1>:
    1eca:	90 95       	com	r25
    1ecc:	81 95       	neg	r24
    1ece:	9f 4f       	sbci	r25, 0xFF	; 255
    1ed0:	08 95       	ret

00001ed2 <__divmodhi4_neg2>:
    1ed2:	70 95       	com	r23
    1ed4:	61 95       	neg	r22
    1ed6:	7f 4f       	sbci	r23, 0xFF	; 255

00001ed8 <__divmodhi4_exit>:
    1ed8:	08 95       	ret

00001eda <__udivmodhi4>:
    1eda:	aa 1b       	sub	r26, r26
    1edc:	bb 1b       	sub	r27, r27
    1ede:	51 e1       	ldi	r21, 0x11	; 17
    1ee0:	07 c0       	rjmp	.+14     	; 0x1ef0 <__udivmodhi4_ep>

00001ee2 <__udivmodhi4_loop>:
    1ee2:	aa 1f       	adc	r26, r26
    1ee4:	bb 1f       	adc	r27, r27
    1ee6:	a6 17       	cp	r26, r22
    1ee8:	b7 07       	cpc	r27, r23
    1eea:	10 f0       	brcs	.+4      	; 0x1ef0 <__udivmodhi4_ep>
    1eec:	a6 1b       	sub	r26, r22
    1eee:	b7 0b       	sbc	r27, r23

00001ef0 <__udivmodhi4_ep>:
    1ef0:	88 1f       	adc	r24, r24
    1ef2:	99 1f       	adc	r25, r25
    1ef4:	5a 95       	dec	r21
    1ef6:	a9 f7       	brne	.-22     	; 0x1ee2 <__udivmodhi4_loop>
    1ef8:	80 95       	com	r24
    1efa:	90 95       	com	r25
    1efc:	bc 01       	movw	r22, r24
    1efe:	cd 01       	movw	r24, r26
    1f00:	08 95       	ret

00001f02 <memcpy>:
    1f02:	fb 01       	movw	r30, r22
    1f04:	dc 01       	movw	r26, r24
    1f06:	02 c0       	rjmp	.+4      	; 0x1f0c <memcpy+0xa>
    1f08:	01 90       	ld	r0, Z+
    1f0a:	0d 92       	st	X+, r0
    1f0c:	41 50       	subi	r20, 0x01	; 1
    1f0e:	50 40       	sbci	r21, 0x00	; 0
    1f10:	d8 f7       	brcc	.-10     	; 0x1f08 <memcpy+0x6>
    1f12:	08 95       	ret

00001f14 <__itoa_ncheck>:
    1f14:	bb 27       	eor	r27, r27
    1f16:	4a 30       	cpi	r20, 0x0A	; 10
    1f18:	31 f4       	brne	.+12     	; 0x1f26 <__itoa_ncheck+0x12>
    1f1a:	99 23       	and	r25, r25
    1f1c:	22 f4       	brpl	.+8      	; 0x1f26 <__itoa_ncheck+0x12>
    1f1e:	bd e2       	ldi	r27, 0x2D	; 45
    1f20:	90 95       	com	r25
    1f22:	81 95       	neg	r24
    1f24:	9f 4f       	sbci	r25, 0xFF	; 255
    1f26:	01 c0       	rjmp	.+2      	; 0x1f2a <__utoa_common>

00001f28 <__utoa_ncheck>:
    1f28:	bb 27       	eor	r27, r27

00001f2a <__utoa_common>:
    1f2a:	fb 01       	movw	r30, r22
    1f2c:	55 27       	eor	r21, r21
    1f2e:	aa 27       	eor	r26, r26
    1f30:	88 0f       	add	r24, r24
    1f32:	99 1f       	adc	r25, r25
    1f34:	aa 1f       	adc	r26, r26
    1f36:	a4 17       	cp	r26, r20
    1f38:	10 f0       	brcs	.+4      	; 0x1f3e <__utoa_common+0x14>
    1f3a:	a4 1b       	sub	r26, r20
    1f3c:	83 95       	inc	r24
    1f3e:	50 51       	subi	r21, 0x10	; 16
    1f40:	b9 f7       	brne	.-18     	; 0x1f30 <__utoa_common+0x6>
    1f42:	a0 5d       	subi	r26, 0xD0	; 208
    1f44:	aa 33       	cpi	r26, 0x3A	; 58
    1f46:	08 f0       	brcs	.+2      	; 0x1f4a <__utoa_common+0x20>
    1f48:	a9 5d       	subi	r26, 0xD9	; 217
    1f4a:	a1 93       	st	Z+, r26
    1f4c:	00 97       	sbiw	r24, 0x00	; 0
    1f4e:	79 f7       	brne	.-34     	; 0x1f2e <__utoa_common+0x4>
    1f50:	b1 11       	cpse	r27, r1
    1f52:	b1 93       	st	Z+, r27
    1f54:	11 92       	st	Z+, r1
    1f56:	cb 01       	movw	r24, r22
    1f58:	00 c0       	rjmp	.+0      	; 0x1f5a <strrev>

00001f5a <strrev>:
    1f5a:	dc 01       	movw	r26, r24
    1f5c:	fc 01       	movw	r30, r24
    1f5e:	67 2f       	mov	r22, r23
    1f60:	71 91       	ld	r23, Z+
    1f62:	77 23       	and	r23, r23
    1f64:	e1 f7       	brne	.-8      	; 0x1f5e <strrev+0x4>
    1f66:	32 97       	sbiw	r30, 0x02	; 2
    1f68:	04 c0       	rjmp	.+8      	; 0x1f72 <strrev+0x18>
    1f6a:	7c 91       	ld	r23, X
    1f6c:	6d 93       	st	X+, r22
    1f6e:	70 83       	st	Z, r23
    1f70:	62 91       	ld	r22, -Z
    1f72:	ae 17       	cp	r26, r30
    1f74:	bf 07       	cpc	r27, r31
    1f76:	c8 f3       	brcs	.-14     	; 0x1f6a <strrev+0x10>
    1f78:	08 95       	ret

00001f7a <_exit>:
    1f7a:	f8 94       	cli

00001f7c <__stop_program>:
    1f7c:	ff cf       	rjmp	.-2      	; 0x1f7c <__stop_program>
