
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000038  00800200  00002f4a  00002fde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f4a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000070b  00800238  00800238  00003016  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003016  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00003046  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005f5a  00000000  00000000  000035b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000164e  00000000  00000000  00009510  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000394f  00000000  00000000  0000ab5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000f9c  00000000  00000000  0000e4b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000017c2  00000000  00000000  0000f44c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004429  00000000  00000000  00010c0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  00015037  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	c4 c3       	rjmp	.+1928   	; 0x7ae <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 4b 0b 	jmp	0x1696	; 0x1696 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	e5 c7       	rjmp	.+4042   	; 0x1030 <__vector_25>
      66:	00 00       	nop
      68:	0c 94 90 08 	jmp	0x1120	; 0x1120 <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	9f c4       	rjmp	.+2366   	; 0x9b4 <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	97 c7       	rjmp	.+3886   	; 0xfc0 <__vector_36>
      92:	00 00       	nop
      94:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__vector_37>
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_AddSample+0x2a>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ea e4       	ldi	r30, 0x4A	; 74
     17e:	ff e2       	ldi	r31, 0x2F	; 47
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 33       	cpi	r26, 0x38	; 56
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a8 e3       	ldi	r26, 0x38	; 56
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a3 34       	cpi	r26, 0x43	; 67
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	e0 d0       	rcall	.+448    	; 0x362 <main>
     1a2:	0c 94 a3 17 	jmp	0x2f46	; 0x2f46 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 82 09 	call	0x1304	; 0x1304 <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 c2 09 	call	0x1384	; 0x1384 <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 b7 09 	call	0x136e	; 0x136e <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 38 02 	lds	r24, 0x0238
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 c8 09 	call	0x1390	; 0x1390 <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 45 09 	call	0x128a	; 0x128a <myUSART_transmitUSART1_c>
     1e2:	d0 93 38 02 	sts	0x0238, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 ce 09 	call	0x139c	; 0x139c <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 38 02 	sts	0x0238, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 38 02 	sts	0x0238, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 38 02 	sts	0x0238, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 a3 09 	call	0x1346	; 0x1346 <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 91 08 	lds	r24, 0x0891
     232:	90 91 92 08 	lds	r25, 0x0892
     236:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericReceive>
     23a:	11 23       	and	r17, r17
     23c:	69 f1       	breq	.+90     	; 0x298 <RPI_sendTask+0x88>
     23e:	8e 81       	ldd	r24, Y+6	; 0x06
     240:	80 5d       	subi	r24, 0xD0	; 208
     242:	0e 94 45 09 	call	0x128a	; 0x128a <myUSART_transmitUSART1_c>
     246:	8a e0       	ldi	r24, 0x0A	; 10
     248:	0e 94 45 09 	call	0x128a	; 0x128a <myUSART_transmitUSART1_c>
     24c:	25 c0       	rjmp	.+74     	; 0x298 <RPI_sendTask+0x88>
     24e:	20 e0       	ldi	r18, 0x00	; 0
     250:	4f ef       	ldi	r20, 0xFF	; 255
     252:	5f ef       	ldi	r21, 0xFF	; 255
     254:	be 01       	movw	r22, r28
     256:	6f 5f       	subi	r22, 0xFF	; 255
     258:	7f 4f       	sbci	r23, 0xFF	; 255
     25a:	80 91 93 08 	lds	r24, 0x0893
     25e:	90 91 94 08 	lds	r25, 0x0894
     262:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericReceive>
     266:	89 81       	ldd	r24, Y+1	; 0x01
     268:	ef d7       	rcall	.+4062   	; 0x1248 <myUSART_transmitUSART0_c>
     26a:	87 e0       	ldi	r24, 0x07	; 7
     26c:	92 e0       	ldi	r25, 0x02	; 2
     26e:	0e 94 74 09 	call	0x12e8	; 0x12e8 <myUSART_transmitUSART0>
     272:	ce 01       	movw	r24, r28
     274:	02 96       	adiw	r24, 0x02	; 2
     276:	0e 94 74 09 	call	0x12e8	; 0x12e8 <myUSART_transmitUSART0>
     27a:	8a e0       	ldi	r24, 0x0A	; 10
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	0e 94 74 09 	call	0x12e8	; 0x12e8 <myUSART_transmitUSART0>
     282:	11 23       	and	r17, r17
     284:	49 f0       	breq	.+18     	; 0x298 <RPI_sendTask+0x88>
     286:	89 81       	ldd	r24, Y+1	; 0x01
     288:	0e 94 45 09 	call	0x128a	; 0x128a <myUSART_transmitUSART1_c>
     28c:	ce 01       	movw	r24, r28
     28e:	02 96       	adiw	r24, 0x02	; 2
     290:	0e 94 66 09 	call	0x12cc	; 0x12cc <myUSART_transmitUSART1>
     294:	8a e0       	ldi	r24, 0x0A	; 10
     296:	f9 d7       	rcall	.+4082   	; 0x128a <myUSART_transmitUSART1_c>
     298:	9e 81       	ldd	r25, Y+6	; 0x06
     29a:	2f ef       	ldi	r18, 0xFF	; 255
     29c:	29 0f       	add	r18, r25
     29e:	2e 83       	std	Y+6, r18	; 0x06
     2a0:	91 11       	cpse	r25, r1
     2a2:	d5 cf       	rjmp	.-86     	; 0x24e <RPI_sendTask+0x3e>
     2a4:	8a e0       	ldi	r24, 0x0A	; 10
     2a6:	d0 d7       	rcall	.+4000   	; 0x1248 <myUSART_transmitUSART0_c>
     2a8:	b9 cf       	rjmp	.-142    	; 0x21c <RPI_sendTask+0xc>

000002aa <myTimerTask>:
     2aa:	b7 d5       	rcall	.+2926   	; 0xe1a <myTimer_Init>
     2ac:	1a d6       	rcall	.+3124   	; 0xee2 <myTimer_DelayChecker>
     2ae:	fe cf       	rjmp	.-4      	; 0x2ac <myTimerTask+0x2>

000002b0 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2b0:	8f ef       	ldi	r24, 0xFF	; 255
     2b2:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2b6:	ef e7       	ldi	r30, 0x7F	; 127
     2b8:	f0 e0       	ldi	r31, 0x00	; 0
     2ba:	90 81       	ld	r25, Z
     2bc:	93 60       	ori	r25, 0x03	; 3
     2be:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2c0:	80 93 7d 00 	sts	0x007D, r24
     2c4:	08 95       	ret

000002c6 <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2c6:	8c ec       	ldi	r24, 0xCC	; 204
     2c8:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2cc:	8e e3       	ldi	r24, 0x3E	; 62
     2ce:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2d2:	ee cf       	rjmp	.-36     	; 0x2b0 <setDigitalInputPowerReduction>
     2d4:	08 95       	ret

000002d6 <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2d6:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2da:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2de:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2e2:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2e6:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2ea:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2ee:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2f2:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2f6:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2fa:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2fe:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     302:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     306:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     30a:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     30e:	10 92 73 00 	sts	0x0073, r1
     312:	08 95       	ret

00000314 <init>:
}

void init()
{
     314:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     316:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     318:	f8 94       	cli
	{
		clearTimer();
     31a:	dd df       	rcall	.-70     	; 0x2d6 <clearTimer>
		setPowerReduction();
     31c:	d4 df       	rcall	.-88     	; 0x2c6 <setPowerReduction>
		myUSART_USART0_Init();
     31e:	40 d7       	rcall	.+3712   	; 0x11a0 <myUSART_USART0_Init>
		myUSART_USART1_Init();
     320:	65 d7       	rcall	.+3786   	; 0x11ec <myUSART_USART1_Init>
		myADC_Init();
     322:	81 d3       	rcall	.+1794   	; 0xa26 <myADC_Init>
		
		MaxSonar_Init();
     324:	83 b3       	in	r24, 0x13	; 19
     326:	83 60       	ori	r24, 0x03	; 3
     328:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     32a:	40 e0       	ldi	r20, 0x00	; 0
     32c:	61 e0       	ldi	r22, 0x01	; 1
     32e:	85 e0       	ldi	r24, 0x05	; 5
     330:	0e 94 4a 0c 	call	0x1894	; 0x1894 <xQueueGenericCreate>
     334:	90 93 92 08 	sts	0x0892, r25
     338:	80 93 91 08 	sts	0x0891, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleStruct)); // create queue
     33c:	40 e0       	ldi	r20, 0x00	; 0
     33e:	65 e0       	ldi	r22, 0x05	; 5
     340:	84 e1       	ldi	r24, 0x14	; 20
     342:	0e 94 4a 0c 	call	0x1894	; 0x1894 <xQueueGenericCreate>
     346:	90 93 94 08 	sts	0x0894, r25
     34a:	80 93 93 08 	sts	0x0893, r24
		
		MOTOR_LEFT_INIT();
     34e:	6c 9a       	sbi	0x0d, 4	; 13
		MOTOR_RIGHT_INIT();
     350:	e1 e0       	ldi	r30, 0x01	; 1
     352:	f1 e0       	ldi	r31, 0x01	; 1
     354:	80 81       	ld	r24, Z
     356:	80 61       	ori	r24, 0x10	; 16
     358:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     35a:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     35c:	78 94       	sei
}
     35e:	cf 91       	pop	r28
     360:	08 95       	ret

00000362 <main>:
	
	// do nth
}

int main(void)
{
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	cd b7       	in	r28, 0x3d	; 61
     368:	de b7       	in	r29, 0x3e	; 62
     36a:	28 97       	sbiw	r28, 0x08	; 8
     36c:	0f b6       	in	r0, 0x3f	; 63
     36e:	f8 94       	cli
     370:	de bf       	out	0x3e, r29	; 62
     372:	0f be       	out	0x3f, r0	; 63
     374:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     376:	ce df       	rcall	.-100    	; 0x314 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     378:	a1 2c       	mov	r10, r1
     37a:	b1 2c       	mov	r11, r1
     37c:	c1 2c       	mov	r12, r1
     37e:	d1 2c       	mov	r13, r1
     380:	ce 01       	movw	r24, r28
     382:	01 96       	adiw	r24, 0x01	; 1
     384:	7c 01       	movw	r14, r24
     386:	04 e0       	ldi	r16, 0x04	; 4
     388:	9c 01       	movw	r18, r24
     38a:	49 e6       	ldi	r20, 0x69	; 105
     38c:	50 e0       	ldi	r21, 0x00	; 0
     38e:	6d e0       	ldi	r22, 0x0D	; 13
     390:	72 e0       	ldi	r23, 0x02	; 2
     392:	85 e5       	ldi	r24, 0x55	; 85
     394:	91 e0       	ldi	r25, 0x01	; 1
     396:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     39a:	ce 01       	movw	r24, r28
     39c:	07 96       	adiw	r24, 0x07	; 7
     39e:	7c 01       	movw	r14, r24
     3a0:	02 e0       	ldi	r16, 0x02	; 2
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	30 e0       	ldi	r19, 0x00	; 0
     3a6:	4d e6       	ldi	r20, 0x6D	; 109
     3a8:	51 e0       	ldi	r21, 0x01	; 1
     3aa:	65 e1       	ldi	r22, 0x15	; 21
     3ac:	72 e0       	ldi	r23, 0x02	; 2
     3ae:	8a e8       	ldi	r24, 0x8A	; 138
     3b0:	92 e0       	ldi	r25, 0x02	; 2
     3b2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3b6:	ce 01       	movw	r24, r28
     3b8:	05 96       	adiw	r24, 0x05	; 5
     3ba:	7c 01       	movw	r14, r24
     3bc:	03 e0       	ldi	r16, 0x03	; 3
     3be:	20 e0       	ldi	r18, 0x00	; 0
     3c0:	30 e0       	ldi	r19, 0x00	; 0
     3c2:	47 e8       	ldi	r20, 0x87	; 135
     3c4:	50 e0       	ldi	r21, 0x00	; 0
     3c6:	6e e1       	ldi	r22, 0x1E	; 30
     3c8:	72 e0       	ldi	r23, 0x02	; 2
     3ca:	84 ed       	ldi	r24, 0xD4	; 212
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3d2:	ce 01       	movw	r24, r28
     3d4:	03 96       	adiw	r24, 0x03	; 3
     3d6:	7c 01       	movw	r14, r24
     3d8:	01 e0       	ldi	r16, 0x01	; 1
     3da:	20 e0       	ldi	r18, 0x00	; 0
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	47 e8       	ldi	r20, 0x87	; 135
     3e0:	50 e0       	ldi	r21, 0x00	; 0
     3e2:	6a e2       	ldi	r22, 0x2A	; 42
     3e4:	72 e0       	ldi	r23, 0x02	; 2
     3e6:	88 e0       	ldi	r24, 0x08	; 8
     3e8:	91 e0       	ldi	r25, 0x01	; 1
     3ea:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ee:	0e 94 17 10 	call	0x202e	; 0x202e <vTaskStartScheduler>
     3f2:	c1 cf       	rjmp	.-126    	; 0x376 <main+0x14>

000003f4 <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3f4:	9c 01       	movw	r18, r24
     3f6:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3f8:	64 e6       	ldi	r22, 0x64	; 100
     3fa:	70 e0       	ldi	r23, 0x00	; 0
     3fc:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <__divmodhi4>
	
	if(input)
     400:	61 15       	cp	r22, r1
     402:	71 05       	cpc	r23, r1
     404:	21 f0       	breq	.+8      	; 0x40e <myItoa+0x1a>
		*buffer++ = input + '0';
     406:	80 e3       	ldi	r24, 0x30	; 48
     408:	86 0f       	add	r24, r22
     40a:	80 83       	st	Z, r24
     40c:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     40e:	4c e9       	ldi	r20, 0x9C	; 156
     410:	46 03       	mulsu	r20, r22
     412:	c0 01       	movw	r24, r0
     414:	47 9f       	mul	r20, r23
     416:	90 0d       	add	r25, r0
     418:	11 24       	eor	r1, r1
     41a:	28 0f       	add	r18, r24
     41c:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     41e:	c9 01       	movw	r24, r18
     420:	6a e0       	ldi	r22, 0x0A	; 10
     422:	70 e0       	ldi	r23, 0x00	; 0
     424:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <__divmodhi4>
	*buffer++ = input + '0';
     428:	80 e3       	ldi	r24, 0x30	; 48
     42a:	86 0f       	add	r24, r22
     42c:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     42e:	8a e0       	ldi	r24, 0x0A	; 10
     430:	68 9f       	mul	r22, r24
     432:	20 19       	sub	r18, r0
     434:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     436:	20 5d       	subi	r18, 0xD0	; 208
     438:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     43a:	12 82       	std	Z+2, r1	; 0x02
     43c:	08 95       	ret

0000043e <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	00 d0       	rcall	.+0      	; 0x446 <obstacleSend+0x8>
     446:	1f 92       	push	r1
     448:	1f 92       	push	r1
     44a:	cd b7       	in	r28, 0x3d	; 61
     44c:	de b7       	in	r29, 0x3e	; 62
     44e:	18 2f       	mov	r17, r24
     450:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
	
	
	
	if(deviceBlocked)
     452:	11 23       	and	r17, r17
     454:	89 f0       	breq	.+34     	; 0x478 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     456:	be 01       	movw	r22, r28
     458:	6e 5f       	subi	r22, 0xFE	; 254
     45a:	7f 4f       	sbci	r23, 0xFF	; 255
     45c:	cb df       	rcall	.-106    	; 0x3f4 <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     45e:	19 83       	std	Y+1, r17	; 0x01
		
		xQueueSendToBack(queueObstacleData, &obstacleInfo, portMAX_DELAY); // send data to queueData
     460:	20 e0       	ldi	r18, 0x00	; 0
     462:	4f ef       	ldi	r20, 0xFF	; 255
     464:	5f ef       	ldi	r21, 0xFF	; 255
     466:	be 01       	movw	r22, r28
     468:	6f 5f       	subi	r22, 0xFF	; 255
     46a:	7f 4f       	sbci	r23, 0xFF	; 255
     46c:	80 91 93 08 	lds	r24, 0x0893
     470:	90 91 94 08 	lds	r25, 0x0894
     474:	0e 94 77 0c 	call	0x18ee	; 0x18ee <xQueueGenericSend>
	}
}
     478:	0f 90       	pop	r0
     47a:	0f 90       	pop	r0
     47c:	0f 90       	pop	r0
     47e:	0f 90       	pop	r0
     480:	0f 90       	pop	r0
     482:	df 91       	pop	r29
     484:	cf 91       	pop	r28
     486:	1f 91       	pop	r17
     488:	08 95       	ret

0000048a <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar)
{
     48a:	6f 92       	push	r6
     48c:	7f 92       	push	r7
     48e:	8f 92       	push	r8
     490:	9f 92       	push	r9
     492:	af 92       	push	r10
     494:	bf 92       	push	r11
     496:	cf 92       	push	r12
     498:	df 92       	push	r13
     49a:	ef 92       	push	r14
     49c:	ff 92       	push	r15
     49e:	0f 93       	push	r16
     4a0:	1f 93       	push	r17
     4a2:	cf 93       	push	r28
     4a4:	df 93       	push	r29
     4a6:	1f 92       	push	r1
     4a8:	cd b7       	in	r28, 0x3d	; 61
     4aa:	de b7       	in	r29, 0x3e	; 62
     4ac:	89 83       	std	Y+1, r24	; 0x01
     4ae:	5b 01       	movw	r10, r22
     4b0:	3a 01       	movw	r6, r20
     4b2:	49 01       	movw	r8, r18
	//if(obstacleDetected > 0)
	{
		
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	4f ef       	ldi	r20, 0xFF	; 255
     4b8:	5f ef       	ldi	r21, 0xFF	; 255
     4ba:	be 01       	movw	r22, r28
     4bc:	6f 5f       	subi	r22, 0xFF	; 255
     4be:	7f 4f       	sbci	r23, 0xFF	; 255
     4c0:	80 91 91 08 	lds	r24, 0x0891
     4c4:	90 91 92 08 	lds	r25, 0x0892
     4c8:	0e 94 77 0c 	call	0x18ee	; 0x18ee <xQueueGenericSend>
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4cc:	b3 01       	movw	r22, r6
     4ce:	f5 01       	movw	r30, r10
     4d0:	80 81       	ld	r24, Z
     4d2:	b5 df       	rcall	.-150    	; 0x43e <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4d4:	b4 01       	movw	r22, r8
     4d6:	f5 01       	movw	r30, r10
     4d8:	81 81       	ldd	r24, Z+1	; 0x01
     4da:	b1 df       	rcall	.-158    	; 0x43e <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4dc:	b8 01       	movw	r22, r16
     4de:	f5 01       	movw	r30, r10
     4e0:	82 81       	ldd	r24, Z+2	; 0x02
     4e2:	ad df       	rcall	.-166    	; 0x43e <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4e4:	b7 01       	movw	r22, r14
     4e6:	f5 01       	movw	r30, r10
     4e8:	83 81       	ldd	r24, Z+3	; 0x03
     4ea:	a9 df       	rcall	.-174    	; 0x43e <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4ec:	b6 01       	movw	r22, r12
     4ee:	f5 01       	movw	r30, r10
     4f0:	84 81       	ldd	r24, Z+4	; 0x04
     4f2:	a5 df       	rcall	.-182    	; 0x43e <obstacleSend>
		
	}
}
     4f4:	0f 90       	pop	r0
     4f6:	df 91       	pop	r29
     4f8:	cf 91       	pop	r28
     4fa:	1f 91       	pop	r17
     4fc:	0f 91       	pop	r16
     4fe:	ff 90       	pop	r15
     500:	ef 90       	pop	r14
     502:	df 90       	pop	r13
     504:	cf 90       	pop	r12
     506:	bf 90       	pop	r11
     508:	af 90       	pop	r10
     50a:	9f 90       	pop	r9
     50c:	8f 90       	pop	r8
     50e:	7f 90       	pop	r7
     510:	6f 90       	pop	r6
     512:	08 95       	ret

00000514 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     514:	cf 93       	push	r28
     516:	df 93       	push	r29
     518:	cd b7       	in	r28, 0x3d	; 61
     51a:	de b7       	in	r29, 0x3e	; 62
     51c:	a4 97       	sbiw	r28, 0x24	; 36
     51e:	0f b6       	in	r0, 0x3f	; 63
     520:	f8 94       	cli
     522:	de bf       	out	0x3e, r29	; 62
     524:	0f be       	out	0x3f, r0	; 63
     526:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     528:	1b 82       	std	Y+3, r1	; 0x03
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     52a:	86 e0       	ldi	r24, 0x06	; 6
     52c:	fe 01       	movw	r30, r28
     52e:	34 96       	adiw	r30, 0x04	; 4
     530:	df 01       	movw	r26, r30
     532:	98 2f       	mov	r25, r24
     534:	1d 92       	st	X+, r1
     536:	9a 95       	dec	r25
     538:	e9 f7       	brne	.-6      	; 0x534 <Sonar_Task+0x20>
     53a:	36 96       	adiw	r30, 0x06	; 6
     53c:	df 01       	movw	r26, r30
     53e:	98 2f       	mov	r25, r24
     540:	1d 92       	st	X+, r1
     542:	9a 95       	dec	r25
     544:	e9 f7       	brne	.-6      	; 0x540 <Sonar_Task+0x2c>
     546:	36 96       	adiw	r30, 0x06	; 6
     548:	df 01       	movw	r26, r30
     54a:	98 2f       	mov	r25, r24
     54c:	1d 92       	st	X+, r1
     54e:	9a 95       	dec	r25
     550:	e9 f7       	brne	.-6      	; 0x54c <Sonar_Task+0x38>
     552:	36 96       	adiw	r30, 0x06	; 6
     554:	df 01       	movw	r26, r30
     556:	1d 92       	st	X+, r1
     558:	8a 95       	dec	r24
     55a:	e9 f7       	brne	.-6      	; 0x556 <Sonar_Task+0x42>
	char deviceBlocked[5] = {0}; // flag to indicate if we should send the reading to RPI
     55c:	36 96       	adiw	r30, 0x06	; 6
     55e:	85 e0       	ldi	r24, 0x05	; 5
     560:	df 01       	movw	r26, r30
     562:	1d 92       	st	X+, r1
     564:	8a 95       	dec	r24
     566:	e9 f7       	brne	.-6      	; 0x562 <Sonar_Task+0x4e>
	
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     568:	84 e2       	ldi	r24, 0x24	; 36
     56a:	b7 d3       	rcall	.+1902   	; 0xcda <mySharpIR_Read>
     56c:	9a a3       	std	Y+34, r25	; 0x22
     56e:	89 a3       	std	Y+33, r24	; 0x21
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     570:	0e 94 46 10 	call	0x208c	; 0x208c <xTaskGetTickCount>
     574:	9a 83       	std	Y+2, r25	; 0x02
     576:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     578:	a5 d1       	rcall	.+842    	; 0x8c4 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     57a:	87 e2       	ldi	r24, 0x27	; 39
     57c:	09 d2       	rcall	.+1042   	; 0x990 <myMaxSonar_Read>
     57e:	be 01       	movw	r22, r28
     580:	66 5f       	subi	r22, 0xF6	; 246
     582:	7f 4f       	sbci	r23, 0xFF	; 255
     584:	fc d1       	rcall	.+1016   	; 0x97e <myMaxSonar_getFilteredReading>
     586:	3c 01       	movw	r6, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     588:	86 e2       	ldi	r24, 0x26	; 38
     58a:	02 d2       	rcall	.+1028   	; 0x990 <myMaxSonar_Read>
     58c:	be 01       	movw	r22, r28
     58e:	60 5f       	subi	r22, 0xF0	; 240
     590:	7f 4f       	sbci	r23, 0xFF	; 255
     592:	f5 d1       	rcall	.+1002   	; 0x97e <myMaxSonar_getFilteredReading>
     594:	1c 01       	movw	r2, r24
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     596:	85 e2       	ldi	r24, 0x25	; 37
     598:	fb d1       	rcall	.+1014   	; 0x990 <myMaxSonar_Read>
     59a:	be 01       	movw	r22, r28
     59c:	6a 5e       	subi	r22, 0xEA	; 234
     59e:	7f 4f       	sbci	r23, 0xFF	; 255
     5a0:	ee d1       	rcall	.+988    	; 0x97e <myMaxSonar_getFilteredReading>
     5a2:	2c 01       	movw	r4, r24
		
		myMaxSonar_TopStart();
     5a4:	95 d1       	rcall	.+810    	; 0x8d0 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5a6:	83 e2       	ldi	r24, 0x23	; 35
     5a8:	f3 d1       	rcall	.+998    	; 0x990 <myMaxSonar_Read>
     5aa:	be 01       	movw	r22, r28
     5ac:	6c 5f       	subi	r22, 0xFC	; 252
     5ae:	7f 4f       	sbci	r23, 0xFF	; 255
     5b0:	e6 d1       	rcall	.+972    	; 0x97e <myMaxSonar_getFilteredReading>
     5b2:	9c a3       	std	Y+36, r25	; 0x24
     5b4:	8b a3       	std	Y+35, r24	; 0x23
			
			
		btmIR		= mySharpIR_Read(AN12);
     5b6:	84 e2       	ldi	r24, 0x24	; 36
     5b8:	90 d3       	rcall	.+1824   	; 0xcda <mySharpIR_Read>
     5ba:	4c 01       	movw	r8, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, btmIR); // attempt to re-calibrate btm ir sensor if stable enough..
     5bc:	bc 01       	movw	r22, r24
     5be:	ce 01       	movw	r24, r28
     5c0:	81 96       	adiw	r24, 0x21	; 33
     5c2:	c4 d3       	rcall	.+1928   	; 0xd4c <mySharpIR_ReCalibrate>
	
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR);
     5c4:	c9 a0       	ldd	r12, Y+33	; 0x21
     5c6:	da a0       	ldd	r13, Y+34	; 0x22
     5c8:	54 01       	movw	r10, r8
     5ca:	eb a0       	ldd	r14, Y+35	; 0x23
     5cc:	fc a0       	ldd	r15, Y+36	; 0x24
     5ce:	82 01       	movw	r16, r4
     5d0:	91 01       	movw	r18, r2
     5d2:	ae 01       	movw	r20, r28
     5d4:	44 5e       	subi	r20, 0xE4	; 228
     5d6:	5f 4f       	sbci	r21, 0xFF	; 255
     5d8:	6b 81       	ldd	r22, Y+3	; 0x03
     5da:	c3 01       	movw	r24, r6
     5dc:	44 d3       	rcall	.+1672   	; 0xc66 <obstacleDetection>
     5de:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, deviceBlocked);
     5e0:	ce 01       	movw	r24, r28
     5e2:	4c 96       	adiw	r24, 0x1c	; 28
     5e4:	7c 01       	movw	r14, r24
     5e6:	84 01       	movw	r16, r8
     5e8:	92 01       	movw	r18, r4
     5ea:	a1 01       	movw	r20, r2
     5ec:	6b a1       	ldd	r22, Y+35	; 0x23
     5ee:	7c a1       	ldd	r23, Y+36	; 0x24
     5f0:	c3 01       	movw	r24, r6
     5f2:	b7 d2       	rcall	.+1390   	; 0xb62 <obstacleAvoidance>
		
		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     5f4:	be 01       	movw	r22, r28
     5f6:	6d 5f       	subi	r22, 0xFD	; 253
     5f8:	7f 4f       	sbci	r23, 0xFF	; 255
     5fa:	c7 01       	movw	r24, r14
     5fc:	97 d2       	rcall	.+1326   	; 0xb2c <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar);
     5fe:	cb a0       	ldd	r12, Y+35	; 0x23
     600:	dc a0       	ldd	r13, Y+36	; 0x24
     602:	74 01       	movw	r14, r8
     604:	82 01       	movw	r16, r4
     606:	91 01       	movw	r18, r2
     608:	a3 01       	movw	r20, r6
     60a:	be 01       	movw	r22, r28
     60c:	64 5e       	subi	r22, 0xE4	; 228
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	8b 81       	ldd	r24, Y+3	; 0x03
     612:	3b df       	rcall	.-394    	; 0x48a <sendObstacleDetected>
	
		// reset the variables back to 0
		obstacleDetected = 0; 
     614:	1b 82       	std	Y+3, r1	; 0x03
		deviceBlocked[0] = deviceBlocked[1] = deviceBlocked[2] = deviceBlocked[3] = deviceBlocked[4] = 0;
     616:	18 a2       	std	Y+32, r1	; 0x20
     618:	1f 8e       	std	Y+31, r1	; 0x1f
     61a:	1e 8e       	std	Y+30, r1	; 0x1e
     61c:	1d 8e       	std	Y+29, r1	; 0x1d
     61e:	1c 8e       	std	Y+28, r1	; 0x1c
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     620:	66 e9       	ldi	r22, 0x96	; 150
     622:	70 e0       	ldi	r23, 0x00	; 0
     624:	ce 01       	movw	r24, r28
     626:	01 96       	adiw	r24, 0x01	; 1
     628:	0e 94 94 11 	call	0x2328	; 0x2328 <vTaskDelayUntil>
     62c:	a5 cf       	rjmp	.-182    	; 0x578 <Sonar_Task+0x64>

0000062e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     62e:	cf 93       	push	r28
     630:	df 93       	push	r29
     632:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     634:	0e 94 40 10 	call	0x2080	; 0x2080 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     638:	80 91 39 02 	lds	r24, 0x0239
     63c:	90 91 3a 02 	lds	r25, 0x023A
     640:	89 2b       	or	r24, r25
     642:	31 f4       	brne	.+12     	; 0x650 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     644:	8e e3       	ldi	r24, 0x3E	; 62
     646:	92 e0       	ldi	r25, 0x02	; 2
     648:	90 93 3a 02 	sts	0x023A, r25
     64c:	80 93 39 02 	sts	0x0239, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     650:	40 91 3b 02 	lds	r20, 0x023B
     654:	50 91 3c 02 	lds	r21, 0x023C
     658:	9e 01       	movw	r18, r28
     65a:	24 0f       	add	r18, r20
     65c:	35 1f       	adc	r19, r21
     65e:	2b 3d       	cpi	r18, 0xDB	; 219
     660:	85 e0       	ldi	r24, 0x05	; 5
     662:	38 07       	cpc	r19, r24
     664:	70 f4       	brcc	.+28     	; 0x682 <pvPortMalloc+0x54>
     666:	42 17       	cp	r20, r18
     668:	53 07       	cpc	r21, r19
     66a:	70 f4       	brcc	.+28     	; 0x688 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     66c:	c0 91 39 02 	lds	r28, 0x0239
     670:	d0 91 3a 02 	lds	r29, 0x023A
     674:	c4 0f       	add	r28, r20
     676:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     678:	30 93 3c 02 	sts	0x023C, r19
     67c:	20 93 3b 02 	sts	0x023B, r18
     680:	05 c0       	rjmp	.+10     	; 0x68c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     682:	c0 e0       	ldi	r28, 0x00	; 0
     684:	d0 e0       	ldi	r29, 0x00	; 0
     686:	02 c0       	rjmp	.+4      	; 0x68c <pvPortMalloc+0x5e>
     688:	c0 e0       	ldi	r28, 0x00	; 0
     68a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     68c:	0e 94 13 11 	call	0x2226	; 0x2226 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     690:	ce 01       	movw	r24, r28
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	08 95       	ret

00000698 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     698:	08 95       	ret

0000069a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     69a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     69c:	03 96       	adiw	r24, 0x03	; 3
     69e:	92 83       	std	Z+2, r25	; 0x02
     6a0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6a2:	2f ef       	ldi	r18, 0xFF	; 255
     6a4:	3f ef       	ldi	r19, 0xFF	; 255
     6a6:	34 83       	std	Z+4, r19	; 0x04
     6a8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6aa:	96 83       	std	Z+6, r25	; 0x06
     6ac:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ae:	90 87       	std	Z+8, r25	; 0x08
     6b0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6b2:	10 82       	st	Z, r1
     6b4:	08 95       	ret

000006b6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6b6:	fc 01       	movw	r30, r24
     6b8:	11 86       	std	Z+9, r1	; 0x09
     6ba:	10 86       	std	Z+8, r1	; 0x08
     6bc:	08 95       	ret

000006be <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
     6c2:	9c 01       	movw	r18, r24
     6c4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6c6:	dc 01       	movw	r26, r24
     6c8:	11 96       	adiw	r26, 0x01	; 1
     6ca:	cd 91       	ld	r28, X+
     6cc:	dc 91       	ld	r29, X
     6ce:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6d0:	d3 83       	std	Z+3, r29	; 0x03
     6d2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6d4:	8c 81       	ldd	r24, Y+4	; 0x04
     6d6:	9d 81       	ldd	r25, Y+5	; 0x05
     6d8:	95 83       	std	Z+5, r25	; 0x05
     6da:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6dc:	8c 81       	ldd	r24, Y+4	; 0x04
     6de:	9d 81       	ldd	r25, Y+5	; 0x05
     6e0:	dc 01       	movw	r26, r24
     6e2:	13 96       	adiw	r26, 0x03	; 3
     6e4:	7c 93       	st	X, r23
     6e6:	6e 93       	st	-X, r22
     6e8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6ea:	7d 83       	std	Y+5, r23	; 0x05
     6ec:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6ee:	31 87       	std	Z+9, r19	; 0x09
     6f0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     6f2:	f9 01       	movw	r30, r18
     6f4:	80 81       	ld	r24, Z
     6f6:	8f 5f       	subi	r24, 0xFF	; 255
     6f8:	80 83       	st	Z, r24
}
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	08 95       	ret

00000700 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     700:	cf 93       	push	r28
     702:	df 93       	push	r29
     704:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     706:	48 81       	ld	r20, Y
     708:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     70a:	4f 3f       	cpi	r20, 0xFF	; 255
     70c:	2f ef       	ldi	r18, 0xFF	; 255
     70e:	52 07       	cpc	r21, r18
     710:	21 f4       	brne	.+8      	; 0x71a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     712:	fc 01       	movw	r30, r24
     714:	a7 81       	ldd	r26, Z+7	; 0x07
     716:	b0 85       	ldd	r27, Z+8	; 0x08
     718:	0d c0       	rjmp	.+26     	; 0x734 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     71a:	dc 01       	movw	r26, r24
     71c:	13 96       	adiw	r26, 0x03	; 3
     71e:	12 96       	adiw	r26, 0x02	; 2
     720:	ed 91       	ld	r30, X+
     722:	fc 91       	ld	r31, X
     724:	13 97       	sbiw	r26, 0x03	; 3
     726:	20 81       	ld	r18, Z
     728:	31 81       	ldd	r19, Z+1	; 0x01
     72a:	42 17       	cp	r20, r18
     72c:	53 07       	cpc	r21, r19
     72e:	10 f0       	brcs	.+4      	; 0x734 <vListInsert+0x34>
     730:	df 01       	movw	r26, r30
     732:	f5 cf       	rjmp	.-22     	; 0x71e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     734:	12 96       	adiw	r26, 0x02	; 2
     736:	ed 91       	ld	r30, X+
     738:	fc 91       	ld	r31, X
     73a:	13 97       	sbiw	r26, 0x03	; 3
     73c:	fb 83       	std	Y+3, r31	; 0x03
     73e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     740:	d5 83       	std	Z+5, r29	; 0x05
     742:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     744:	bd 83       	std	Y+5, r27	; 0x05
     746:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     748:	13 96       	adiw	r26, 0x03	; 3
     74a:	dc 93       	st	X, r29
     74c:	ce 93       	st	-X, r28
     74e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     750:	99 87       	std	Y+9, r25	; 0x09
     752:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     754:	fc 01       	movw	r30, r24
     756:	20 81       	ld	r18, Z
     758:	2f 5f       	subi	r18, 0xFF	; 255
     75a:	20 83       	st	Z, r18
}
     75c:	df 91       	pop	r29
     75e:	cf 91       	pop	r28
     760:	08 95       	ret

00000762 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     768:	a0 85       	ldd	r26, Z+8	; 0x08
     76a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     76c:	c2 81       	ldd	r28, Z+2	; 0x02
     76e:	d3 81       	ldd	r29, Z+3	; 0x03
     770:	84 81       	ldd	r24, Z+4	; 0x04
     772:	95 81       	ldd	r25, Z+5	; 0x05
     774:	9d 83       	std	Y+5, r25	; 0x05
     776:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     778:	c4 81       	ldd	r28, Z+4	; 0x04
     77a:	d5 81       	ldd	r29, Z+5	; 0x05
     77c:	82 81       	ldd	r24, Z+2	; 0x02
     77e:	93 81       	ldd	r25, Z+3	; 0x03
     780:	9b 83       	std	Y+3, r25	; 0x03
     782:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     784:	11 96       	adiw	r26, 0x01	; 1
     786:	cd 91       	ld	r28, X+
     788:	dc 91       	ld	r29, X
     78a:	12 97       	sbiw	r26, 0x02	; 2
     78c:	ce 17       	cp	r28, r30
     78e:	df 07       	cpc	r29, r31
     790:	31 f4       	brne	.+12     	; 0x79e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     792:	8c 81       	ldd	r24, Y+4	; 0x04
     794:	9d 81       	ldd	r25, Y+5	; 0x05
     796:	12 96       	adiw	r26, 0x02	; 2
     798:	9c 93       	st	X, r25
     79a:	8e 93       	st	-X, r24
     79c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     79e:	11 86       	std	Z+9, r1	; 0x09
     7a0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7a2:	8c 91       	ld	r24, X
     7a4:	81 50       	subi	r24, 0x01	; 1
     7a6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	08 95       	ret

000007ae <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7ae:	1f 92       	push	r1
     7b0:	0f 92       	push	r0
     7b2:	0f b6       	in	r0, 0x3f	; 63
     7b4:	0f 92       	push	r0
     7b6:	11 24       	eor	r1, r1
     7b8:	0b b6       	in	r0, 0x3b	; 59
     7ba:	0f 92       	push	r0
     7bc:	2f 93       	push	r18
     7be:	3f 93       	push	r19
     7c0:	4f 93       	push	r20
     7c2:	5f 93       	push	r21
     7c4:	6f 93       	push	r22
     7c6:	7f 93       	push	r23
     7c8:	8f 93       	push	r24
     7ca:	9f 93       	push	r25
     7cc:	af 93       	push	r26
     7ce:	bf 93       	push	r27
     7d0:	ef 93       	push	r30
     7d2:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7d4:	1b 9b       	sbis	0x03, 3	; 3
     7d6:	0d c0       	rjmp	.+26     	; 0x7f2 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7d8:	3a d3       	rcall	.+1652   	; 0xe4e <myTimer_Read>
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	90 93 9a 08 	sts	0x089A, r25
     7e0:	80 93 99 08 	sts	0x0899, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7e4:	0e 94 50 10 	call	0x20a0	; 0x20a0 <xTaskGetTickCountFromISR>
     7e8:	90 93 96 08 	sts	0x0896, r25
     7ec:	80 93 95 08 	sts	0x0895, r24
     7f0:	56 c0       	rjmp	.+172    	; 0x89e <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     7f2:	1b 99       	sbic	0x03, 3	; 3
     7f4:	54 c0       	rjmp	.+168    	; 0x89e <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     7f6:	0e 94 50 10 	call	0x20a0	; 0x20a0 <xTaskGetTickCountFromISR>
     7fa:	90 93 a0 08 	sts	0x08A0, r25
     7fe:	80 93 9f 08 	sts	0x089F, r24
     802:	20 91 95 08 	lds	r18, 0x0895
     806:	30 91 96 08 	lds	r19, 0x0896
     80a:	82 17       	cp	r24, r18
     80c:	93 07       	cpc	r25, r19
     80e:	4c f4       	brge	.+18     	; 0x822 <__vector_9+0x74>
			ms_tickEnd += 65535;
     810:	80 91 9f 08 	lds	r24, 0x089F
     814:	90 91 a0 08 	lds	r25, 0x08A0
     818:	01 97       	sbiw	r24, 0x01	; 1
     81a:	90 93 a0 08 	sts	0x08A0, r25
     81e:	80 93 9f 08 	sts	0x089F, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     822:	15 d3       	rcall	.+1578   	; 0xe4e <myTimer_Read>
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	90 93 a2 08 	sts	0x08A2, r25
     82a:	80 93 a1 08 	sts	0x08A1, r24
     82e:	20 91 99 08 	lds	r18, 0x0899
     832:	30 91 9a 08 	lds	r19, 0x089A
     836:	82 17       	cp	r24, r18
     838:	93 07       	cpc	r25, r19
     83a:	54 f4       	brge	.+20     	; 0x850 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     83c:	80 91 a1 08 	lds	r24, 0x08A1
     840:	90 91 a2 08 	lds	r25, 0x08A2
     844:	86 50       	subi	r24, 0x06	; 6
     846:	9f 4f       	sbci	r25, 0xFF	; 255
     848:	90 93 a2 08 	sts	0x08A2, r25
     84c:	80 93 a1 08 	sts	0x08A1, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     850:	80 91 a1 08 	lds	r24, 0x08A1
     854:	90 91 a2 08 	lds	r25, 0x08A2
     858:	20 91 99 08 	lds	r18, 0x0899
     85c:	30 91 9a 08 	lds	r19, 0x089A
     860:	82 1b       	sub	r24, r18
     862:	93 0b       	sbc	r25, r19
     864:	90 93 9c 08 	sts	0x089C, r25
     868:	80 93 9b 08 	sts	0x089B, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     86c:	80 91 9f 08 	lds	r24, 0x089F
     870:	90 91 a0 08 	lds	r25, 0x08A0
     874:	20 91 95 08 	lds	r18, 0x0895
     878:	30 91 96 08 	lds	r19, 0x0896
     87c:	82 1b       	sub	r24, r18
     87e:	93 0b       	sbc	r25, r19
     880:	90 93 98 08 	sts	0x0898, r25
     884:	80 93 97 08 	sts	0x0897, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	40 e0       	ldi	r20, 0x00	; 0
     88c:	50 e0       	ldi	r21, 0x00	; 0
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	70 e0       	ldi	r23, 0x00	; 0
     892:	80 91 9d 08 	lds	r24, 0x089D
     896:	90 91 9e 08 	lds	r25, 0x089E
     89a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xQueueGenericSendFromISR>
	}	
}
     89e:	ff 91       	pop	r31
     8a0:	ef 91       	pop	r30
     8a2:	bf 91       	pop	r27
     8a4:	af 91       	pop	r26
     8a6:	9f 91       	pop	r25
     8a8:	8f 91       	pop	r24
     8aa:	7f 91       	pop	r23
     8ac:	6f 91       	pop	r22
     8ae:	5f 91       	pop	r21
     8b0:	4f 91       	pop	r20
     8b2:	3f 91       	pop	r19
     8b4:	2f 91       	pop	r18
     8b6:	0f 90       	pop	r0
     8b8:	0b be       	out	0x3b, r0	; 59
     8ba:	0f 90       	pop	r0
     8bc:	0f be       	out	0x3f, r0	; 63
     8be:	0f 90       	pop	r0
     8c0:	1f 90       	pop	r1
     8c2:	18 95       	reti

000008c4 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8c4:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8c6:	89 e1       	ldi	r24, 0x19	; 25
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	c3 d2       	rcall	.+1414   	; 0xe52 <myTimer_DelayMicro>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_BtmTriggerStop();
     8cc:	a1 98       	cbi	0x14, 1	; 20
     8ce:	08 95       	ret

000008d0 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     8d0:	a0 9a       	sbi	0x14, 0	; 20
	
	myTimer_DelayMicro2(25); // delay 25 micro seconds...
     8d2:	89 e1       	ldi	r24, 0x19	; 25
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	e1 d2       	rcall	.+1474   	; 0xe9a <myTimer_DelayMicro2>
	//vTaskDelay(5000);	// delay 1ms using vTaskDelay
	
	MaxSonar_TopTriggerStop();
     8d8:	a0 98       	cbi	0x14, 0	; 20
     8da:	08 95       	ret

000008dc <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     8dc:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     8de:	80 81       	ld	r24, Z
     8e0:	91 81       	ldd	r25, Z+1	; 0x01
     8e2:	22 81       	ldd	r18, Z+2	; 0x02
     8e4:	33 81       	ldd	r19, Z+3	; 0x03
     8e6:	28 17       	cp	r18, r24
     8e8:	39 07       	cpc	r19, r25
     8ea:	54 f4       	brge	.+20     	; 0x900 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     8ec:	44 81       	ldd	r20, Z+4	; 0x04
     8ee:	55 81       	ldd	r21, Z+5	; 0x05
     8f0:	42 17       	cp	r20, r18
     8f2:	53 07       	cpc	r21, r19
     8f4:	84 f0       	brlt	.+32     	; 0x916 <myMaxSonar_extractMedian+0x3a>
     8f6:	48 17       	cp	r20, r24
     8f8:	59 07       	cpc	r21, r25
     8fa:	74 f4       	brge	.+28     	; 0x918 <myMaxSonar_extractMedian+0x3c>
     8fc:	ca 01       	movw	r24, r20
     8fe:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     900:	44 81       	ldd	r20, Z+4	; 0x04
     902:	55 81       	ldd	r21, Z+5	; 0x05
     904:	48 17       	cp	r20, r24
     906:	59 07       	cpc	r21, r25
     908:	3c f0       	brlt	.+14     	; 0x918 <myMaxSonar_extractMedian+0x3c>
     90a:	ca 01       	movw	r24, r20
     90c:	24 17       	cp	r18, r20
     90e:	35 07       	cpc	r19, r21
     910:	1c f4       	brge	.+6      	; 0x918 <myMaxSonar_extractMedian+0x3c>
     912:	c9 01       	movw	r24, r18
     914:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     916:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     918:	08 95       	ret

0000091a <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     91a:	9b 01       	movw	r18, r22
     91c:	28 5f       	subi	r18, 0xF8	; 248
     91e:	3f 4f       	sbci	r19, 0xFF	; 255
     920:	28 17       	cp	r18, r24
     922:	39 07       	cpc	r19, r25
     924:	3c f0       	brlt	.+14     	; 0x934 <myMaxSonar_Stabilizer+0x1a>
     926:	20 51       	subi	r18, 0x10	; 16
     928:	31 09       	sbc	r19, r1
     92a:	82 17       	cp	r24, r18
     92c:	93 07       	cpc	r25, r19
     92e:	14 f0       	brlt	.+4      	; 0x934 <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     930:	86 2f       	mov	r24, r22
     932:	97 2f       	mov	r25, r23
}
     934:	08 95       	ret

00000936 <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     936:	0f 93       	push	r16
     938:	1f 93       	push	r17
     93a:	cf 93       	push	r28
     93c:	df 93       	push	r29
     93e:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     940:	00 91 00 02 	lds	r16, 0x0200
     944:	10 e0       	ldi	r17, 0x00	; 0
     946:	f8 01       	movw	r30, r16
     948:	ee 0f       	add	r30, r30
     94a:	ff 1f       	adc	r31, r31
     94c:	e6 0f       	add	r30, r22
     94e:	f7 1f       	adc	r31, r23
     950:	60 81       	ld	r22, Z
     952:	71 81       	ldd	r23, Z+1	; 0x01
     954:	e2 df       	rcall	.-60     	; 0x91a <myMaxSonar_Stabilizer>
     956:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     958:	c8 01       	movw	r24, r16
     95a:	01 96       	adiw	r24, 0x01	; 1
     95c:	63 e0       	ldi	r22, 0x03	; 3
     95e:	70 e0       	ldi	r23, 0x00	; 0
     960:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <__divmodhi4>
     964:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	c8 0f       	add	r28, r24
     96e:	d9 1f       	adc	r29, r25
     970:	39 83       	std	Y+1, r19	; 0x01
     972:	28 83       	st	Y, r18
}
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	08 95       	ret

0000097e <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     984:	d8 df       	rcall	.-80     	; 0x936 <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     986:	ce 01       	movw	r24, r28
     988:	a9 df       	rcall	.-174    	; 0x8dc <myMaxSonar_extractMedian>

}
     98a:	df 91       	pop	r29
     98c:	cf 91       	pop	r28
     98e:	08 95       	ret

00000990 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     990:	b6 d0       	rcall	.+364    	; 0xafe <myADC_analogRead>
     992:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     994:	63 e0       	ldi	r22, 0x03	; 3
     996:	70 e0       	ldi	r23, 0x00	; 0
     998:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     99c:	26 0f       	add	r18, r22
     99e:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     9a0:	29 3e       	cpi	r18, 0xE9	; 233
     9a2:	83 e0       	ldi	r24, 0x03	; 3
     9a4:	38 07       	cpc	r19, r24
     9a6:	1c f0       	brlt	.+6      	; 0x9ae <myMaxSonar_Read+0x1e>
		return 999;
     9a8:	87 ee       	ldi	r24, 0xE7	; 231
     9aa:	93 e0       	ldi	r25, 0x03	; 3
     9ac:	08 95       	ret
	
	return reading;
     9ae:	82 2f       	mov	r24, r18
     9b0:	93 2f       	mov	r25, r19
}
     9b2:	08 95       	ret

000009b4 <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9b4:	1f 92       	push	r1
     9b6:	0f 92       	push	r0
     9b8:	0f b6       	in	r0, 0x3f	; 63
     9ba:	0f 92       	push	r0
     9bc:	11 24       	eor	r1, r1
     9be:	0b b6       	in	r0, 0x3b	; 59
     9c0:	0f 92       	push	r0
     9c2:	2f 93       	push	r18
     9c4:	3f 93       	push	r19
     9c6:	4f 93       	push	r20
     9c8:	5f 93       	push	r21
     9ca:	6f 93       	push	r22
     9cc:	7f 93       	push	r23
     9ce:	8f 93       	push	r24
     9d0:	9f 93       	push	r25
     9d2:	af 93       	push	r26
     9d4:	bf 93       	push	r27
     9d6:	ef 93       	push	r30
     9d8:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     9da:	80 91 78 00 	lds	r24, 0x0078
     9de:	80 93 a3 08 	sts	0x08A3, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     9e2:	80 91 79 00 	lds	r24, 0x0079
     9e6:	80 93 a4 08 	sts	0x08A4, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     9ea:	20 e0       	ldi	r18, 0x00	; 0
     9ec:	40 e0       	ldi	r20, 0x00	; 0
     9ee:	50 e0       	ldi	r21, 0x00	; 0
     9f0:	60 e0       	ldi	r22, 0x00	; 0
     9f2:	70 e0       	ldi	r23, 0x00	; 0
     9f4:	80 91 a7 08 	lds	r24, 0x08A7
     9f8:	90 91 a8 08 	lds	r25, 0x08A8
     9fc:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <xQueueGenericSendFromISR>
}
     a00:	ff 91       	pop	r31
     a02:	ef 91       	pop	r30
     a04:	bf 91       	pop	r27
     a06:	af 91       	pop	r26
     a08:	9f 91       	pop	r25
     a0a:	8f 91       	pop	r24
     a0c:	7f 91       	pop	r23
     a0e:	6f 91       	pop	r22
     a10:	5f 91       	pop	r21
     a12:	4f 91       	pop	r20
     a14:	3f 91       	pop	r19
     a16:	2f 91       	pop	r18
     a18:	0f 90       	pop	r0
     a1a:	0b be       	out	0x3b, r0	; 59
     a1c:	0f 90       	pop	r0
     a1e:	0f be       	out	0x3f, r0	; 63
     a20:	0f 90       	pop	r0
     a22:	1f 90       	pop	r1
     a24:	18 95       	reti

00000a26 <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a26:	8f e8       	ldi	r24, 0x8F	; 143
     a28:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a2c:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a30:	80 e4       	ldi	r24, 0x40	; 64
     a32:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a36:	43 e0       	ldi	r20, 0x03	; 3
     a38:	60 e0       	ldi	r22, 0x00	; 0
     a3a:	81 e0       	ldi	r24, 0x01	; 1
     a3c:	2b d7       	rcall	.+3670   	; 0x1894 <xQueueGenericCreate>
     a3e:	90 93 a8 08 	sts	0x08A8, r25
     a42:	80 93 a7 08 	sts	0x08A7, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a46:	81 e0       	ldi	r24, 0x01	; 1
     a48:	e5 d7       	rcall	.+4042   	; 0x1a14 <xQueueCreateMutex>
     a4a:	90 93 a6 08 	sts	0x08A6, r25
     a4e:	80 93 a5 08 	sts	0x08A5, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a52:	20 e0       	ldi	r18, 0x00	; 0
     a54:	40 e0       	ldi	r20, 0x00	; 0
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	60 e0       	ldi	r22, 0x00	; 0
     a5a:	70 e0       	ldi	r23, 0x00	; 0
     a5c:	48 c7       	rjmp	.+3728   	; 0x18ee <xQueueGenericSend>
     a5e:	08 95       	ret

00000a60 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a60:	cf 93       	push	r28
     a62:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a64:	20 e0       	ldi	r18, 0x00	; 0
     a66:	4f ef       	ldi	r20, 0xFF	; 255
     a68:	5f ef       	ldi	r21, 0xFF	; 255
     a6a:	60 e0       	ldi	r22, 0x00	; 0
     a6c:	70 e0       	ldi	r23, 0x00	; 0
     a6e:	80 91 a5 08 	lds	r24, 0x08A5
     a72:	90 91 a6 08 	lds	r25, 0x08A6
     a76:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a7a:	ec e7       	ldi	r30, 0x7C	; 124
     a7c:	f0 e0       	ldi	r31, 0x00	; 0
     a7e:	80 81       	ld	r24, Z
     a80:	9c 2f       	mov	r25, r28
     a82:	9f 71       	andi	r25, 0x1F	; 31
     a84:	80 76       	andi	r24, 0x60	; 96
     a86:	89 2b       	or	r24, r25
     a88:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a8a:	eb e7       	ldi	r30, 0x7B	; 123
     a8c:	f0 e0       	ldi	r31, 0x00	; 0
     a8e:	20 81       	ld	r18, Z
     a90:	c0 72       	andi	r28, 0x20	; 32
     a92:	8c 2f       	mov	r24, r28
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	95 95       	asr	r25
     a98:	87 95       	ror	r24
     a9a:	95 95       	asr	r25
     a9c:	87 95       	ror	r24
     a9e:	92 2f       	mov	r25, r18
     aa0:	90 76       	andi	r25, 0x60	; 96
     aa2:	89 2b       	or	r24, r25
     aa4:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     aa6:	ea e7       	ldi	r30, 0x7A	; 122
     aa8:	f0 e0       	ldi	r31, 0x00	; 0
     aaa:	80 81       	ld	r24, Z
     aac:	80 64       	ori	r24, 0x40	; 64
     aae:	80 83       	st	Z, r24
}
     ab0:	cf 91       	pop	r28
     ab2:	08 95       	ret

00000ab4 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ab4:	cf 93       	push	r28
     ab6:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     ab8:	20 e0       	ldi	r18, 0x00	; 0
     aba:	4f ef       	ldi	r20, 0xFF	; 255
     abc:	5f ef       	ldi	r21, 0xFF	; 255
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 91 a7 08 	lds	r24, 0x08A7
     ac6:	90 91 a8 08 	lds	r25, 0x08A8
     aca:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     ace:	c0 91 a4 08 	lds	r28, 0x08A4
     ad2:	c3 70       	andi	r28, 0x03	; 3
     ad4:	d0 e0       	ldi	r29, 0x00	; 0
     ad6:	dc 2f       	mov	r29, r28
     ad8:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     ada:	80 91 a3 08 	lds	r24, 0x08A3
     ade:	c8 0f       	add	r28, r24
     ae0:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     ae2:	20 e0       	ldi	r18, 0x00	; 0
     ae4:	40 e0       	ldi	r20, 0x00	; 0
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	60 e0       	ldi	r22, 0x00	; 0
     aea:	70 e0       	ldi	r23, 0x00	; 0
     aec:	80 91 a5 08 	lds	r24, 0x08A5
     af0:	90 91 a6 08 	lds	r25, 0x08A6
     af4:	fc d6       	rcall	.+3576   	; 0x18ee <xQueueGenericSend>
	
	return adcReading;
     af6:	ce 01       	movw	r24, r28
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     afe:	cf 93       	push	r28
     b00:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b02:	ae df       	rcall	.-164    	; 0xa60 <myADC_startADC>
	return myADC_readADC(channel);
     b04:	8c 2f       	mov	r24, r28
     b06:	d6 df       	rcall	.-84     	; 0xab4 <myADC_readADC>
}
     b08:	cf 91       	pop	r28
     b0a:	08 95       	ret

00000b0c <detectStairs>:



char detectStairs(int calibratedBtmIR, int btmIR)
{
	if(btmIR > calibratedBtmIR + STAIRS_OFFSET || btmIR < calibratedBtmIR - STAIRS_OFFSET)
     b0c:	9c 01       	movw	r18, r24
     b0e:	28 5f       	subi	r18, 0xF8	; 248
     b10:	3f 4f       	sbci	r19, 0xFF	; 255
     b12:	26 17       	cp	r18, r22
     b14:	37 07       	cpc	r19, r23
     b16:	44 f0       	brlt	.+16     	; 0xb28 <detectStairs+0x1c>
     b18:	20 51       	subi	r18, 0x10	; 16
     b1a:	31 09       	sbc	r19, r1
     b1c:	81 e0       	ldi	r24, 0x01	; 1
     b1e:	62 17       	cp	r22, r18
     b20:	73 07       	cpc	r23, r19
     b22:	1c f0       	brlt	.+6      	; 0xb2a <detectStairs+0x1e>
     b24:	80 e0       	ldi	r24, 0x00	; 0
     b26:	08 95       	ret
	{
		return 1; // stairs found
     b28:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		return 0; // no stairs
		
	}
}
     b2a:	08 95       	ret

00000b2c <cheatPrintAll>:
	}
}


void cheatPrintAll(char* deviceBlocked, char *obstacleDetected)
{
     b2c:	fc 01       	movw	r30, r24
	*obstacleDetected = 5;
     b2e:	85 e0       	ldi	r24, 0x05	; 5
     b30:	db 01       	movw	r26, r22
     b32:	8c 93       	st	X, r24
	deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     b34:	86 e4       	ldi	r24, 0x46	; 70
     b36:	80 83       	st	Z, r24
	deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     b38:	8c e4       	ldi	r24, 0x4C	; 76
     b3a:	81 83       	std	Z+1, r24	; 0x01
	deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     b3c:	82 e5       	ldi	r24, 0x52	; 82
     b3e:	82 83       	std	Z+2, r24	; 0x02
	deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     b40:	82 e4       	ldi	r24, 0x42	; 66
     b42:	83 83       	std	Z+3, r24	; 0x03
	deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     b44:	84 e5       	ldi	r24, 0x54	; 84
     b46:	84 83       	std	Z+4, r24	; 0x04
     b48:	08 95       	ret

00000b4a <possibleStairs>:
}

// detect possibleStairs infront 
char possibleStairs(int frontSonar, int topSonar)
{
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
     b4a:	c2 97       	sbiw	r24, 0x32	; 50
     b4c:	44 f4       	brge	.+16     	; 0xb5e <possibleStairs+0x14>
     b4e:	61 55       	subi	r22, 0x51	; 81
     b50:	71 09       	sbc	r23, r1
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	6d 31       	cpi	r22, 0x1D	; 29
     b56:	71 05       	cpc	r23, r1
     b58:	18 f0       	brcs	.+6      	; 0xb60 <possibleStairs+0x16>
     b5a:	80 e0       	ldi	r24, 0x00	; 0
     b5c:	08 95       	ret
		return 1;
	else 
		return 0;
     b5e:	80 e0       	ldi	r24, 0x00	; 0
	
}
     b60:	08 95       	ret

00000b62 <obstacleAvoidance>:
}


// Priority => BTM, Front, Side
void obstacleAvoidance(int frontSonar, int topSonar, int leftSonar, int rightSonar, int btmIR, char * deviceBlocked)
{
     b62:	cf 92       	push	r12
     b64:	df 92       	push	r13
     b66:	ef 92       	push	r14
     b68:	ff 92       	push	r15
     b6a:	0f 93       	push	r16
     b6c:	1f 93       	push	r17
     b6e:	cf 93       	push	r28
     b70:	df 93       	push	r29
     b72:	8a 01       	movw	r16, r20
     b74:	69 01       	movw	r12, r18
     b76:	e7 01       	movw	r28, r14
	
	if(deviceBlocked[BTM_DEVICE])
     b78:	2b 81       	ldd	r18, Y+3	; 0x03
     b7a:	22 23       	and	r18, r18
     b7c:	39 f0       	breq	.+14     	; 0xb8c <obstacleAvoidance+0x2a>
	{
		// stairs detected
			MOTOR_LEFT_START();
     b7e:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();
     b80:	e2 e0       	ldi	r30, 0x02	; 2
     b82:	f1 e0       	ldi	r31, 0x01	; 1
     b84:	80 81       	ld	r24, Z
     b86:	80 61       	ori	r24, 0x10	; 16
     b88:	80 83       	st	Z, r24
     b8a:	64 c0       	rjmp	.+200    	; 0xc54 <obstacleAvoidance+0xf2>
	}
	else if( (deviceBlocked[FRONT_DEVICE] && (!possibleStairs(frontSonar, topSonar))) || deviceBlocked[TOP_DEVICE])
     b8c:	28 81       	ld	r18, Y
     b8e:	22 23       	and	r18, r18
     b90:	19 f0       	breq	.+6      	; 0xb98 <obstacleAvoidance+0x36>
     b92:	db df       	rcall	.-74     	; 0xb4a <possibleStairs>
     b94:	88 23       	and	r24, r24
     b96:	19 f0       	breq	.+6      	; 0xb9e <obstacleAvoidance+0x3c>
     b98:	8c 81       	ldd	r24, Y+4	; 0x04
     b9a:	88 23       	and	r24, r24
     b9c:	e1 f1       	breq	.+120    	; 0xc16 <obstacleAvoidance+0xb4>
	{
		// front sensor detected
		if(!deviceBlocked[LEFT_DEVICE] && !deviceBlocked[RIGHT_DEVICE])
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	81 11       	cpse	r24, r1
     ba2:	1d c0       	rjmp	.+58     	; 0xbde <obstacleAvoidance+0x7c>
     ba4:	8a 81       	ldd	r24, Y+2	; 0x02
     ba6:	81 11       	cpse	r24, r1
     ba8:	2a c0       	rjmp	.+84     	; 0xbfe <obstacleAvoidance+0x9c>
		{
			
			leftSonar -= LEFT_POSITIONAL_OFFSET;  // left sonar reading is now on approx ...
     baa:	04 51       	subi	r16, 0x14	; 20
     bac:	11 09       	sbc	r17, r1
			
			// both not blocked... so select side that have more range... (if both close... left safer to turn - see product)
				if(rightSonar > leftSonar && (rightSonar - leftSonar > INDISTINGUISHABLE_RANGE)) // if right sonar greater than....
     bae:	0c 15       	cp	r16, r12
     bb0:	1d 05       	cpc	r17, r13
     bb2:	64 f4       	brge	.+24     	; 0xbcc <obstacleAvoidance+0x6a>
     bb4:	c6 01       	movw	r24, r12
     bb6:	80 1b       	sub	r24, r16
     bb8:	91 0b       	sbc	r25, r17
     bba:	08 97       	sbiw	r24, 0x08	; 8
     bbc:	3c f0       	brlt	.+14     	; 0xbcc <obstacleAvoidance+0x6a>
				{
					MOTOR_LEFT_STOP();
     bbe:	74 98       	cbi	0x0e, 4	; 14
					MOTOR_RIGHT_START();
     bc0:	e2 e0       	ldi	r30, 0x02	; 2
     bc2:	f1 e0       	ldi	r31, 0x01	; 1
     bc4:	80 81       	ld	r24, Z
     bc6:	80 61       	ori	r24, 0x10	; 16
     bc8:	80 83       	st	Z, r24
     bca:	06 c0       	rjmp	.+12     	; 0xbd8 <obstacleAvoidance+0x76>
				}
				else 
				{
					MOTOR_LEFT_START();
     bcc:	74 9a       	sbi	0x0e, 4	; 14
					MOTOR_RIGHT_STOP();
     bce:	e2 e0       	ldi	r30, 0x02	; 2
     bd0:	f1 e0       	ldi	r31, 0x01	; 1
     bd2:	80 81       	ld	r24, Z
     bd4:	8f 7e       	andi	r24, 0xEF	; 239
     bd6:	80 83       	st	Z, r24
					
				}
		}
		if(deviceBlocked[LEFT_DEVICE] && !(deviceBlocked[RIGHT_DEVICE]))
     bd8:	89 81       	ldd	r24, Y+1	; 0x01
     bda:	88 23       	and	r24, r24
     bdc:	c1 f1       	breq	.+112    	; 0xc4e <obstacleAvoidance+0xec>
     bde:	8a 81       	ldd	r24, Y+2	; 0x02
     be0:	81 11       	cpse	r24, r1
     be2:	38 c0       	rjmp	.+112    	; 0xc54 <obstacleAvoidance+0xf2>
		{
			// left is blocked but not right
			if((rightSonar - leftSonar) > INDISTINGUISHABLE_RANGE) // if there's enough difference, prompt the user to move..
     be4:	c0 1a       	sub	r12, r16
     be6:	d1 0a       	sbc	r13, r17
     be8:	88 e0       	ldi	r24, 0x08	; 8
     bea:	c8 16       	cp	r12, r24
     bec:	d1 04       	cpc	r13, r1
     bee:	94 f1       	brlt	.+100    	; 0xc54 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_STOP();
     bf0:	74 98       	cbi	0x0e, 4	; 14
				MOTOR_RIGHT_START();	
     bf2:	e2 e0       	ldi	r30, 0x02	; 2
     bf4:	f1 e0       	ldi	r31, 0x01	; 1
     bf6:	80 81       	ld	r24, Z
     bf8:	80 61       	ori	r24, 0x10	; 16
     bfa:	80 83       	st	Z, r24
     bfc:	2b c0       	rjmp	.+86     	; 0xc54 <obstacleAvoidance+0xf2>
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
		{
			// right is blocked but not left..
			if((leftSonar - rightSonar) > INDISTINGUISHABLE_RANGE) // if there's enough different, prompt the user to move...
     bfe:	0c 19       	sub	r16, r12
     c00:	1d 09       	sbc	r17, r13
     c02:	08 30       	cpi	r16, 0x08	; 8
     c04:	11 05       	cpc	r17, r1
     c06:	34 f1       	brlt	.+76     	; 0xc54 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_START();
     c08:	74 9a       	sbi	0x0e, 4	; 14
				MOTOR_RIGHT_STOP();
     c0a:	e2 e0       	ldi	r30, 0x02	; 2
     c0c:	f1 e0       	ldi	r31, 0x01	; 1
     c0e:	80 81       	ld	r24, Z
     c10:	8f 7e       	andi	r24, 0xEF	; 239
     c12:	80 83       	st	Z, r24
     c14:	1f c0       	rjmp	.+62     	; 0xc54 <obstacleAvoidance+0xf2>
			//MOTOR_LEFT_STOP(); 
			//MOTOR_RIGHT_STOP();	
		}
		
	}
	else if (leftSonar < LEFT_TOO_NEAR)
     c16:	0f 31       	cpi	r16, 0x1F	; 31
     c18:	11 05       	cpc	r17, r1
     c1a:	3c f4       	brge	.+14     	; 0xc2a <obstacleAvoidance+0xc8>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_STOP();
     c1c:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_START();		
     c1e:	e2 e0       	ldi	r30, 0x02	; 2
     c20:	f1 e0       	ldi	r31, 0x01	; 1
     c22:	80 81       	ld	r24, Z
     c24:	80 61       	ori	r24, 0x10	; 16
     c26:	80 83       	st	Z, r24
     c28:	15 c0       	rjmp	.+42     	; 0xc54 <obstacleAvoidance+0xf2>
	}
	else if (rightSonar < RIGHT_TOO_NEAR)
     c2a:	86 e1       	ldi	r24, 0x16	; 22
     c2c:	c8 16       	cp	r12, r24
     c2e:	d1 04       	cpc	r13, r1
     c30:	3c f4       	brge	.+14     	; 0xc40 <obstacleAvoidance+0xde>
	{
		// front able to walk, too near to wall or obstacle...
			MOTOR_LEFT_START();
     c32:	74 9a       	sbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c34:	e2 e0       	ldi	r30, 0x02	; 2
     c36:	f1 e0       	ldi	r31, 0x01	; 1
     c38:	80 81       	ld	r24, Z
     c3a:	8f 7e       	andi	r24, 0xEF	; 239
     c3c:	80 83       	st	Z, r24
     c3e:	0a c0       	rjmp	.+20     	; 0xc54 <obstacleAvoidance+0xf2>
	}
	else
	{
			MOTOR_LEFT_STOP();
     c40:	74 98       	cbi	0x0e, 4	; 14
			MOTOR_RIGHT_STOP();
     c42:	e2 e0       	ldi	r30, 0x02	; 2
     c44:	f1 e0       	ldi	r31, 0x01	; 1
     c46:	80 81       	ld	r24, Z
     c48:	8f 7e       	andi	r24, 0xEF	; 239
     c4a:	80 83       	st	Z, r24
     c4c:	03 c0       	rjmp	.+6      	; 0xc54 <obstacleAvoidance+0xf2>
			{
				MOTOR_LEFT_STOP();
				MOTOR_RIGHT_START();	
			}
		}
		else if (deviceBlocked[RIGHT_DEVICE] && !(deviceBlocked[LEFT_DEVICE]))
     c4e:	8a 81       	ldd	r24, Y+2	; 0x02
     c50:	81 11       	cpse	r24, r1
     c52:	d5 cf       	rjmp	.-86     	; 0xbfe <obstacleAvoidance+0x9c>
	else
	{
			MOTOR_LEFT_STOP();
			MOTOR_RIGHT_STOP();
	}
}
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	1f 91       	pop	r17
     c5a:	0f 91       	pop	r16
     c5c:	ff 90       	pop	r15
     c5e:	ef 90       	pop	r14
     c60:	df 90       	pop	r13
     c62:	cf 90       	pop	r12
     c64:	08 95       	ret

00000c66 <obstacleDetection>:
}

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR)
{
     c66:	9f 92       	push	r9
     c68:	af 92       	push	r10
     c6a:	bf 92       	push	r11
     c6c:	cf 92       	push	r12
     c6e:	df 92       	push	r13
     c70:	ef 92       	push	r14
     c72:	ff 92       	push	r15
     c74:	0f 93       	push	r16
     c76:	1f 93       	push	r17
     c78:	cf 93       	push	r28
     c7a:	df 93       	push	r29
     c7c:	96 2e       	mov	r9, r22
     c7e:	ea 01       	movw	r28, r20
     c80:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c82:	c2 97       	sbiw	r24, 0x32	; 50
     c84:	1c f4       	brge	.+6      	; 0xc8c <obstacleDetection+0x26>
	{
		obstacleDetected ++;
     c86:	93 94       	inc	r9
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c88:	86 e4       	ldi	r24, 0x46	; 70
     c8a:	88 83       	st	Y, r24
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c8c:	2f 31       	cpi	r18, 0x1F	; 31
     c8e:	31 05       	cpc	r19, r1
     c90:	1c f4       	brge	.+6      	; 0xc98 <obstacleDetection+0x32>
	{
		obstacleDetected ++;
     c92:	93 94       	inc	r9
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c94:	8c e4       	ldi	r24, 0x4C	; 76
     c96:	89 83       	std	Y+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c98:	0e 31       	cpi	r16, 0x1E	; 30
     c9a:	11 05       	cpc	r17, r1
     c9c:	1c f4       	brge	.+6      	; 0xca4 <obstacleDetection+0x3e>
	{
		obstacleDetected++;
     c9e:	93 94       	inc	r9
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     ca0:	82 e5       	ldi	r24, 0x52	; 82
     ca2:	8a 83       	std	Y+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     ca4:	c6 01       	movw	r24, r12
     ca6:	32 df       	rcall	.-412    	; 0xb0c <detectStairs>
     ca8:	88 23       	and	r24, r24
     caa:	19 f0       	breq	.+6      	; 0xcb2 <obstacleDetection+0x4c>
	{
		obstacleDetected++;
     cac:	93 94       	inc	r9
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     cae:	82 e4       	ldi	r24, 0x42	; 66
     cb0:	8b 83       	std	Y+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     cb2:	87 e3       	ldi	r24, 0x37	; 55
     cb4:	e8 16       	cp	r14, r24
     cb6:	f1 04       	cpc	r15, r1
     cb8:	1c f4       	brge	.+6      	; 0xcc0 <obstacleDetection+0x5a>
	{
		obstacleDetected++;
     cba:	93 94       	inc	r9
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     cbc:	84 e5       	ldi	r24, 0x54	; 84
     cbe:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	return obstacleDetected;
}
     cc0:	89 2d       	mov	r24, r9
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	ef 90       	pop	r14
     cce:	df 90       	pop	r13
     cd0:	cf 90       	pop	r12
     cd2:	bf 90       	pop	r11
     cd4:	af 90       	pop	r10
     cd6:	9f 90       	pop	r9
     cd8:	08 95       	ret

00000cda <mySharpIR_Read>:
#include <myUSART.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     cda:	11 df       	rcall	.-478    	; 0xafe <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cdc:	bc 01       	movw	r22, r24
     cde:	88 27       	eor	r24, r24
     ce0:	77 fd       	sbrc	r23, 7
     ce2:	80 95       	com	r24
     ce4:	98 2f       	mov	r25, r24
     ce6:	0e 94 b7 14 	call	0x296e	; 0x296e <__floatsisf>
     cea:	29 e2       	ldi	r18, 0x29	; 41
     cec:	3c e5       	ldi	r19, 0x5C	; 92
     cee:	4f e6       	ldi	r20, 0x6F	; 111
     cf0:	5f eb       	ldi	r21, 0xBF	; 191
     cf2:	0e 94 a6 15 	call	0x2b4c	; 0x2b4c <pow>
     cf6:	22 e5       	ldi	r18, 0x52	; 82
     cf8:	38 e6       	ldi	r19, 0x68	; 104
     cfa:	46 e2       	ldi	r20, 0x26	; 38
     cfc:	56 e4       	ldi	r21, 0x46	; 70
     cfe:	0e 94 43 15 	call	0x2a86	; 0x2a86 <__mulsf3>
     d02:	20 e0       	ldi	r18, 0x00	; 0
     d04:	30 e0       	ldi	r19, 0x00	; 0
     d06:	40 e2       	ldi	r20, 0x20	; 32
     d08:	51 e4       	ldi	r21, 0x41	; 65
     d0a:	0e 94 1f 14 	call	0x283e	; 0x283e <__subsf3>
     d0e:	0e 94 84 14 	call	0x2908	; 0x2908 <__fixsfsi>
     d12:	cb 01       	movw	r24, r22
     d14:	68 3e       	cpi	r22, 0xE8	; 232
     d16:	23 e0       	ldi	r18, 0x03	; 3
     d18:	72 07       	cpc	r23, r18
     d1a:	14 f0       	brlt	.+4      	; 0xd20 <mySharpIR_Read+0x46>
     d1c:	87 ee       	ldi	r24, 0xE7	; 231
     d1e:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > IR_MAX_VALUE)
		adcReading = IR_MAX_VALUE;
	
	return adcReading;
}
     d20:	08 95       	ret

00000d22 <checkOutOfRange>:

// return 1 if out of range..
char checkOutOfRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d22:	fb 01       	movw	r30, r22
     d24:	20 81       	ld	r18, Z
     d26:	31 81       	ldd	r19, Z+1	; 0x01
     d28:	50 e0       	ldi	r21, 0x00	; 0
     d2a:	b9 01       	movw	r22, r18
     d2c:	64 0f       	add	r22, r20
     d2e:	75 1f       	adc	r23, r21
     d30:	68 17       	cp	r22, r24
     d32:	79 07       	cpc	r23, r25
     d34:	4c f0       	brlt	.+18     	; 0xd48 <checkOutOfRange+0x26>
     d36:	24 1b       	sub	r18, r20
     d38:	35 0b       	sbc	r19, r21
     d3a:	41 e0       	ldi	r20, 0x01	; 1
     d3c:	82 17       	cp	r24, r18
     d3e:	93 07       	cpc	r25, r19
     d40:	0c f0       	brlt	.+2      	; 0xd44 <checkOutOfRange+0x22>
     d42:	40 e0       	ldi	r20, 0x00	; 0
     d44:	84 2f       	mov	r24, r20
     d46:	08 95       	ret
     d48:	81 e0       	ldi	r24, 0x01	; 1
}
     d4a:	08 95       	ret

00000d4c <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int reading)
{
     d4c:	ff 92       	push	r15
     d4e:	0f 93       	push	r16
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	8c 01       	movw	r16, r24
     d58:	eb 01       	movw	r28, r22
	static uint8_t sampleCount = 0;
	static int referenceReading = 0;
	//static int testPrint = 0;
	
	if(!checkOutOfRange(reading, calibratedReading, CALIBRATE_RANGE) && sampleCount == 0)
     d5a:	45 e0       	ldi	r20, 0x05	; 5
     d5c:	bc 01       	movw	r22, r24
     d5e:	ce 01       	movw	r24, r28
     d60:	e0 df       	rcall	.-64     	; 0xd22 <checkOutOfRange>
     d62:	81 11       	cpse	r24, r1
     d64:	05 c0       	rjmp	.+10     	; 0xd70 <mySharpIR_ReCalibrate+0x24>
     d66:	80 91 1b 08 	lds	r24, 0x081B
     d6a:	88 23       	and	r24, r24
     d6c:	09 f4       	brne	.+2      	; 0xd70 <mySharpIR_ReCalibrate+0x24>
     d6e:	4f c0       	rjmp	.+158    	; 0xe0e <mySharpIR_ReCalibrate+0xc2>
		// if current reading and calibratedReading is within range and no checking in progess
		// skip the calibration process... not needed
		return;
	}
	
	if(reading < CALIBRATE_LOW_THRESHOLD || reading > CALIBRATE_HIGH_THRESHOLD)
     d70:	ce 01       	movw	r24, r28
     d72:	49 97       	sbiw	r24, 0x19	; 25
     d74:	45 97       	sbiw	r24, 0x15	; 21
     d76:	28 f0       	brcs	.+10     	; 0xd82 <mySharpIR_ReCalibrate+0x36>
	{
		// Too low or Too high for it to be ground..
		referenceReading = 0;
     d78:	10 92 1a 08 	sts	0x081A, r1
     d7c:	10 92 19 08 	sts	0x0819, r1
		return;		
     d80:	46 c0       	rjmp	.+140    	; 0xe0e <mySharpIR_ReCalibrate+0xc2>
	}
	
	
	if (sampleCount == 0)
     d82:	f0 90 1b 08 	lds	r15, 0x081B
     d86:	f1 10       	cpse	r15, r1
     d88:	05 c0       	rjmp	.+10     	; 0xd94 <mySharpIR_ReCalibrate+0x48>
	{
		// Possible calibration... take reference from reading
		//testPrint = 0;
		referenceReading = reading;
     d8a:	d0 93 1a 08 	sts	0x081A, r29
     d8e:	c0 93 19 08 	sts	0x0819, r28
     d92:	3a c0       	rjmp	.+116    	; 0xe08 <mySharpIR_ReCalibrate+0xbc>
		//myUSART_transmitUSART0("\n-----RS----\n");

	}
	else if ((sampleCount % CALIBRATE_SAMPLE_RATE) == 0) // when count reach 
     d94:	8d ec       	ldi	r24, 0xCD	; 205
     d96:	f8 9e       	mul	r15, r24
     d98:	81 2d       	mov	r24, r1
     d9a:	11 24       	eor	r1, r1
     d9c:	82 95       	swap	r24
     d9e:	8f 70       	andi	r24, 0x0F	; 15
     da0:	88 0f       	add	r24, r24
     da2:	88 0f       	add	r24, r24
     da4:	98 2f       	mov	r25, r24
     da6:	99 0f       	add	r25, r25
     da8:	99 0f       	add	r25, r25
     daa:	89 0f       	add	r24, r25
     dac:	f8 12       	cpse	r15, r24
     dae:	13 c0       	rjmp	.+38     	; 0xdd6 <mySharpIR_ReCalibrate+0x8a>
	{
		//testPrint++;
		//myUSART_transmitUSART0_c(testPrint + '0');
		//myUSART_transmitUSART0("\n");
		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     db0:	45 e0       	ldi	r20, 0x05	; 5
     db2:	69 e1       	ldi	r22, 0x19	; 25
     db4:	78 e0       	ldi	r23, 0x08	; 8
     db6:	ce 01       	movw	r24, r28
     db8:	b4 df       	rcall	.-152    	; 0xd22 <checkOutOfRange>
     dba:	88 23       	and	r24, r24
     dbc:	39 f0       	breq	.+14     	; 0xdcc <mySharpIR_ReCalibrate+0x80>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     dbe:	10 92 1a 08 	sts	0x081A, r1
     dc2:	10 92 19 08 	sts	0x0819, r1
			sampleCount = 0; // reset to count...
     dc6:	10 92 1b 08 	sts	0x081B, r1
			return;
     dca:	21 c0       	rjmp	.+66     	; 0xe0e <mySharpIR_ReCalibrate+0xc2>
		}
		else
		{	// within range.. need more confirmation, update reference point..
			referenceReading = reading;
     dcc:	d0 93 1a 08 	sts	0x081A, r29
     dd0:	c0 93 19 08 	sts	0x0819, r28
     dd4:	19 c0       	rjmp	.+50     	; 0xe08 <mySharpIR_ReCalibrate+0xbc>
		}
	}
	else if (sampleCount >= CALIBRATE_SAMPLE_REQUIRE)
     dd6:	85 e4       	ldi	r24, 0x45	; 69
     dd8:	8f 15       	cp	r24, r15
     dda:	b0 f4       	brcc	.+44     	; 0xe08 <mySharpIR_ReCalibrate+0xbc>
	{
		// Sample long enough...
		sampleCount = 0; // reset to count..
     ddc:	10 92 1b 08 	sts	0x081B, r1

		if(checkOutOfRange(reading, &referenceReading, CALIBRATE_RANGE))
     de0:	45 e0       	ldi	r20, 0x05	; 5
     de2:	69 e1       	ldi	r22, 0x19	; 25
     de4:	78 e0       	ldi	r23, 0x08	; 8
     de6:	ce 01       	movw	r24, r28
     de8:	9c df       	rcall	.-200    	; 0xd22 <checkOutOfRange>
     dea:	88 23       	and	r24, r24
     dec:	29 f0       	breq	.+10     	; 0xdf8 <mySharpIR_ReCalibrate+0xac>
		{
			// Out of range.. restart to find new calibration point..
			referenceReading = 0;
     dee:	10 92 1a 08 	sts	0x081A, r1
     df2:	10 92 19 08 	sts	0x0819, r1
			return;
     df6:	0b c0       	rjmp	.+22     	; 0xe0e <mySharpIR_ReCalibrate+0xc2>
		}
		else
		{
			// all readings within range... can calibrate as new stable.
			*calibratedReading = referenceReading; // btmIR is calibrated..
     df8:	80 91 19 08 	lds	r24, 0x0819
     dfc:	90 91 1a 08 	lds	r25, 0x081A
     e00:	f8 01       	movw	r30, r16
     e02:	91 83       	std	Z+1, r25	; 0x01
     e04:	80 83       	st	Z, r24
			//myUSART_transmitUSART0("\nACK\n");
			return;
     e06:	03 c0       	rjmp	.+6      	; 0xe0e <mySharpIR_ReCalibrate+0xc2>
		}
	}
	
	sampleCount++;
     e08:	f3 94       	inc	r15
     e0a:	f0 92 1b 08 	sts	0x081B, r15
}
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	ff 90       	pop	r15
     e18:	08 95       	ret

00000e1a <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     e1a:	90 93 ae 08 	sts	0x08AE, r25
     e1e:	80 93 ad 08 	sts	0x08AD, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     e22:	fc 01       	movw	r30, r24
     e24:	80 81       	ld	r24, Z
     e26:	91 81       	ldd	r25, Z+1	; 0x01
     e28:	0e 94 69 12 	call	0x24d2	; 0x24d2 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     e2c:	43 e0       	ldi	r20, 0x03	; 3
     e2e:	60 e0       	ldi	r22, 0x00	; 0
     e30:	81 e0       	ldi	r24, 0x01	; 1
     e32:	30 d5       	rcall	.+2656   	; 0x1894 <xQueueGenericCreate>
     e34:	90 93 aa 08 	sts	0x08AA, r25
     e38:	80 93 a9 08 	sts	0x08A9, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     e3c:	43 e0       	ldi	r20, 0x03	; 3
     e3e:	60 e0       	ldi	r22, 0x00	; 0
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	28 d5       	rcall	.+2640   	; 0x1894 <xQueueGenericCreate>
     e44:	90 93 ac 08 	sts	0x08AC, r25
     e48:	80 93 ab 08 	sts	0x08AB, r24
     e4c:	08 95       	ret

00000e4e <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e4e:	86 b5       	in	r24, 0x26	; 38
}
     e50:	08 95       	ret

00000e52 <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e52:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     e54:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e56:	9c 01       	movw	r18, r24
     e58:	99 23       	and	r25, r25
     e5a:	14 f4       	brge	.+4      	; 0xe60 <myTimer_DelayMicro+0xe>
     e5c:	2d 5f       	subi	r18, 0xFD	; 253
     e5e:	3f 4f       	sbci	r19, 0xFF	; 255
     e60:	35 95       	asr	r19
     e62:	27 95       	ror	r18
     e64:	35 95       	asr	r19
     e66:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     e68:	24 0f       	add	r18, r20
     e6a:	35 1f       	adc	r19, r21
     e6c:	30 93 04 02 	sts	0x0204, r19
     e70:	20 93 03 02 	sts	0x0203, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     e74:	e0 91 ad 08 	lds	r30, 0x08AD
     e78:	f0 91 ae 08 	lds	r31, 0x08AE
     e7c:	80 81       	ld	r24, Z
     e7e:	91 81       	ldd	r25, Z+1	; 0x01
     e80:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e84:	20 e0       	ldi	r18, 0x00	; 0
     e86:	42 e0       	ldi	r20, 0x02	; 2
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 91 a9 08 	lds	r24, 0x08A9
     e92:	90 91 aa 08 	lds	r25, 0x08AA
     e96:	23 c6       	rjmp	.+3142   	; 0x1ade <xQueueGenericReceive>
     e98:	08 95       	ret

00000e9a <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e9a:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     e9c:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     e9e:	9c 01       	movw	r18, r24
     ea0:	99 23       	and	r25, r25
     ea2:	14 f4       	brge	.+4      	; 0xea8 <myTimer_DelayMicro2+0xe>
     ea4:	2d 5f       	subi	r18, 0xFD	; 253
     ea6:	3f 4f       	sbci	r19, 0xFF	; 255
     ea8:	35 95       	asr	r19
     eaa:	27 95       	ror	r18
     eac:	35 95       	asr	r19
     eae:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     eb0:	24 0f       	add	r18, r20
     eb2:	35 1f       	adc	r19, r21
     eb4:	30 93 02 02 	sts	0x0202, r19
     eb8:	20 93 01 02 	sts	0x0201, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     ebc:	e0 91 ad 08 	lds	r30, 0x08AD
     ec0:	f0 91 ae 08 	lds	r31, 0x08AE
     ec4:	80 81       	ld	r24, Z
     ec6:	91 81       	ldd	r25, Z+1	; 0x01
     ec8:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     ecc:	20 e0       	ldi	r18, 0x00	; 0
     ece:	42 e0       	ldi	r20, 0x02	; 2
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	70 e0       	ldi	r23, 0x00	; 0
     ed6:	80 91 ab 08 	lds	r24, 0x08AB
     eda:	90 91 ac 08 	lds	r25, 0x08AC
     ede:	ff c5       	rjmp	.+3070   	; 0x1ade <xQueueGenericReceive>
     ee0:	08 95       	ret

00000ee2 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     ee6:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     ee8:	c1 11       	cpse	r28, r1
     eea:	22 c0       	rjmp	.+68     	; 0xf30 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     eec:	80 91 03 02 	lds	r24, 0x0203
     ef0:	90 91 04 02 	lds	r25, 0x0204
     ef4:	88 38       	cpi	r24, 0x88	; 136
     ef6:	93 41       	sbci	r25, 0x13	; 19
     ef8:	51 f0       	breq	.+20     	; 0xf0e <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     efa:	80 91 03 02 	lds	r24, 0x0203
     efe:	90 91 04 02 	lds	r25, 0x0204
     f02:	8a 5f       	subi	r24, 0xFA	; 250
     f04:	91 09       	sbc	r25, r1
     f06:	90 93 04 02 	sts	0x0204, r25
     f0a:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     f0e:	80 91 01 02 	lds	r24, 0x0201
     f12:	90 91 02 02 	lds	r25, 0x0202
     f16:	88 38       	cpi	r24, 0x88	; 136
     f18:	93 41       	sbci	r25, 0x13	; 19
     f1a:	51 f0       	breq	.+20     	; 0xf30 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     f1c:	80 91 01 02 	lds	r24, 0x0201
     f20:	90 91 02 02 	lds	r25, 0x0202
     f24:	8a 5f       	subi	r24, 0xFA	; 250
     f26:	91 09       	sbc	r25, r1
     f28:	90 93 02 02 	sts	0x0202, r25
     f2c:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     f30:	d0 e0       	ldi	r29, 0x00	; 0
     f32:	80 91 03 02 	lds	r24, 0x0203
     f36:	90 91 04 02 	lds	r25, 0x0204
     f3a:	8c 17       	cp	r24, r28
     f3c:	9d 07       	cpc	r25, r29
     f3e:	84 f4       	brge	.+32     	; 0xf60 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     f40:	88 e8       	ldi	r24, 0x88	; 136
     f42:	93 e1       	ldi	r25, 0x13	; 19
     f44:	90 93 04 02 	sts	0x0204, r25
     f48:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     f4c:	20 e0       	ldi	r18, 0x00	; 0
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	50 e0       	ldi	r21, 0x00	; 0
     f52:	60 e0       	ldi	r22, 0x00	; 0
     f54:	70 e0       	ldi	r23, 0x00	; 0
     f56:	80 91 a9 08 	lds	r24, 0x08A9
     f5a:	90 91 aa 08 	lds	r25, 0x08AA
     f5e:	c7 d4       	rcall	.+2446   	; 0x18ee <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     f60:	80 91 01 02 	lds	r24, 0x0201
     f64:	90 91 02 02 	lds	r25, 0x0202
     f68:	8c 17       	cp	r24, r28
     f6a:	9d 07       	cpc	r25, r29
     f6c:	84 f4       	brge	.+32     	; 0xf8e <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     f6e:	88 e8       	ldi	r24, 0x88	; 136
     f70:	93 e1       	ldi	r25, 0x13	; 19
     f72:	90 93 02 02 	sts	0x0202, r25
     f76:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     f7a:	20 e0       	ldi	r18, 0x00	; 0
     f7c:	40 e0       	ldi	r20, 0x00	; 0
     f7e:	50 e0       	ldi	r21, 0x00	; 0
     f80:	60 e0       	ldi	r22, 0x00	; 0
     f82:	70 e0       	ldi	r23, 0x00	; 0
     f84:	80 91 ab 08 	lds	r24, 0x08AB
     f88:	90 91 ac 08 	lds	r25, 0x08AC
     f8c:	b0 d4       	rcall	.+2400   	; 0x18ee <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     f8e:	80 91 03 02 	lds	r24, 0x0203
     f92:	90 91 04 02 	lds	r25, 0x0204
     f96:	88 38       	cpi	r24, 0x88	; 136
     f98:	93 41       	sbci	r25, 0x13	; 19
     f9a:	79 f4       	brne	.+30     	; 0xfba <myTimer_DelayChecker+0xd8>
     f9c:	80 91 01 02 	lds	r24, 0x0201
     fa0:	90 91 02 02 	lds	r25, 0x0202
     fa4:	88 38       	cpi	r24, 0x88	; 136
     fa6:	93 41       	sbci	r25, 0x13	; 19
     fa8:	41 f4       	brne	.+16     	; 0xfba <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     faa:	e0 91 ad 08 	lds	r30, 0x08AD
     fae:	f0 91 ae 08 	lds	r31, 0x08AE
     fb2:	80 81       	ld	r24, Z
     fb4:	91 81       	ldd	r25, Z+1	; 0x01
     fb6:	0e 94 69 12 	call	0x24d2	; 0x24d2 <vTaskSuspend>
	}
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	08 95       	ret

00000fc0 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     fc0:	1f 92       	push	r1
     fc2:	0f 92       	push	r0
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	0f 92       	push	r0
     fc8:	11 24       	eor	r1, r1
     fca:	0b b6       	in	r0, 0x3b	; 59
     fcc:	0f 92       	push	r0
     fce:	2f 93       	push	r18
     fd0:	3f 93       	push	r19
     fd2:	4f 93       	push	r20
     fd4:	5f 93       	push	r21
     fd6:	6f 93       	push	r22
     fd8:	7f 93       	push	r23
     fda:	8f 93       	push	r24
     fdc:	9f 93       	push	r25
     fde:	af 93       	push	r26
     fe0:	bf 93       	push	r27
     fe2:	ef 93       	push	r30
     fe4:	ff 93       	push	r31
     fe6:	60 91 ce 00 	lds	r22, 0x00CE
     fea:	8e e3       	ldi	r24, 0x3E	; 62
     fec:	99 e0       	ldi	r25, 0x09	; 9
     fee:	43 d6       	rcall	.+3206   	; 0x1c76 <ringBufferPush>
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	40 e0       	ldi	r20, 0x00	; 0
     ff4:	50 e0       	ldi	r21, 0x00	; 0
     ff6:	60 e0       	ldi	r22, 0x00	; 0
     ff8:	70 e0       	ldi	r23, 0x00	; 0
     ffa:	80 91 24 08 	lds	r24, 0x0824
     ffe:	90 91 25 08 	lds	r25, 0x0825
    1002:	33 d5       	rcall	.+2662   	; 0x1a6a <xQueueGenericSendFromISR>
    1004:	8e e3       	ldi	r24, 0x3E	; 62
    1006:	99 e0       	ldi	r25, 0x09	; 9
    1008:	4d d6       	rcall	.+3226   	; 0x1ca4 <ringBufferFull>
    100a:	ff 91       	pop	r31
    100c:	ef 91       	pop	r30
    100e:	bf 91       	pop	r27
    1010:	af 91       	pop	r26
    1012:	9f 91       	pop	r25
    1014:	8f 91       	pop	r24
    1016:	7f 91       	pop	r23
    1018:	6f 91       	pop	r22
    101a:	5f 91       	pop	r21
    101c:	4f 91       	pop	r20
    101e:	3f 91       	pop	r19
    1020:	2f 91       	pop	r18
    1022:	0f 90       	pop	r0
    1024:	0b be       	out	0x3b, r0	; 59
    1026:	0f 90       	pop	r0
    1028:	0f be       	out	0x3f, r0	; 63
    102a:	0f 90       	pop	r0
    102c:	1f 90       	pop	r1
    102e:	18 95       	reti

00001030 <__vector_25>:
    1030:	1f 92       	push	r1
    1032:	0f 92       	push	r0
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	0f 92       	push	r0
    1038:	11 24       	eor	r1, r1
    103a:	0b b6       	in	r0, 0x3b	; 59
    103c:	0f 92       	push	r0
    103e:	2f 93       	push	r18
    1040:	3f 93       	push	r19
    1042:	4f 93       	push	r20
    1044:	5f 93       	push	r21
    1046:	6f 93       	push	r22
    1048:	7f 93       	push	r23
    104a:	8f 93       	push	r24
    104c:	9f 93       	push	r25
    104e:	af 93       	push	r26
    1050:	bf 93       	push	r27
    1052:	ef 93       	push	r30
    1054:	ff 93       	push	r31
    1056:	60 91 c6 00 	lds	r22, 0x00C6
    105a:	8f ec       	ldi	r24, 0xCF	; 207
    105c:	98 e0       	ldi	r25, 0x08	; 8
    105e:	0b d6       	rcall	.+3094   	; 0x1c76 <ringBufferPush>
    1060:	20 e0       	ldi	r18, 0x00	; 0
    1062:	40 e0       	ldi	r20, 0x00	; 0
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	60 e0       	ldi	r22, 0x00	; 0
    1068:	70 e0       	ldi	r23, 0x00	; 0
    106a:	80 91 24 08 	lds	r24, 0x0824
    106e:	90 91 25 08 	lds	r25, 0x0825
    1072:	fb d4       	rcall	.+2550   	; 0x1a6a <xQueueGenericSendFromISR>
    1074:	8f ec       	ldi	r24, 0xCF	; 207
    1076:	98 e0       	ldi	r25, 0x08	; 8
    1078:	15 d6       	rcall	.+3114   	; 0x1ca4 <ringBufferFull>
    107a:	ff 91       	pop	r31
    107c:	ef 91       	pop	r30
    107e:	bf 91       	pop	r27
    1080:	af 91       	pop	r26
    1082:	9f 91       	pop	r25
    1084:	8f 91       	pop	r24
    1086:	7f 91       	pop	r23
    1088:	6f 91       	pop	r22
    108a:	5f 91       	pop	r21
    108c:	4f 91       	pop	r20
    108e:	3f 91       	pop	r19
    1090:	2f 91       	pop	r18
    1092:	0f 90       	pop	r0
    1094:	0b be       	out	0x3b, r0	; 59
    1096:	0f 90       	pop	r0
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	0f 90       	pop	r0
    109c:	1f 90       	pop	r1
    109e:	18 95       	reti

000010a0 <__vector_37>:
    10a0:	1f 92       	push	r1
    10a2:	0f 92       	push	r0
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	0f 92       	push	r0
    10a8:	11 24       	eor	r1, r1
    10aa:	0b b6       	in	r0, 0x3b	; 59
    10ac:	0f 92       	push	r0
    10ae:	2f 93       	push	r18
    10b0:	3f 93       	push	r19
    10b2:	4f 93       	push	r20
    10b4:	5f 93       	push	r21
    10b6:	6f 93       	push	r22
    10b8:	7f 93       	push	r23
    10ba:	8f 93       	push	r24
    10bc:	9f 93       	push	r25
    10be:	af 93       	push	r26
    10c0:	bf 93       	push	r27
    10c2:	ef 93       	push	r30
    10c4:	ff 93       	push	r31
    10c6:	84 e3       	ldi	r24, 0x34	; 52
    10c8:	99 e0       	ldi	r25, 0x09	; 9
    10ca:	f3 d5       	rcall	.+3046   	; 0x1cb2 <ringBufferNotEmpty>
    10cc:	88 23       	and	r24, r24
    10ce:	31 f0       	breq	.+12     	; 0x10dc <__vector_37+0x3c>
    10d0:	84 e3       	ldi	r24, 0x34	; 52
    10d2:	99 e0       	ldi	r25, 0x09	; 9
    10d4:	be d5       	rcall	.+2940   	; 0x1c52 <ringBufferPop>
    10d6:	80 93 ce 00 	sts	0x00CE, r24
    10da:	0f c0       	rjmp	.+30     	; 0x10fa <__vector_37+0x5a>
    10dc:	e9 ec       	ldi	r30, 0xC9	; 201
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	8f 7d       	andi	r24, 0xDF	; 223
    10e4:	80 83       	st	Z, r24
    10e6:	20 e0       	ldi	r18, 0x00	; 0
    10e8:	40 e0       	ldi	r20, 0x00	; 0
    10ea:	50 e0       	ldi	r21, 0x00	; 0
    10ec:	60 e0       	ldi	r22, 0x00	; 0
    10ee:	70 e0       	ldi	r23, 0x00	; 0
    10f0:	80 91 1c 08 	lds	r24, 0x081C
    10f4:	90 91 1d 08 	lds	r25, 0x081D
    10f8:	b8 d4       	rcall	.+2416   	; 0x1a6a <xQueueGenericSendFromISR>
    10fa:	ff 91       	pop	r31
    10fc:	ef 91       	pop	r30
    10fe:	bf 91       	pop	r27
    1100:	af 91       	pop	r26
    1102:	9f 91       	pop	r25
    1104:	8f 91       	pop	r24
    1106:	7f 91       	pop	r23
    1108:	6f 91       	pop	r22
    110a:	5f 91       	pop	r21
    110c:	4f 91       	pop	r20
    110e:	3f 91       	pop	r19
    1110:	2f 91       	pop	r18
    1112:	0f 90       	pop	r0
    1114:	0b be       	out	0x3b, r0	; 59
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0
    111c:	1f 90       	pop	r1
    111e:	18 95       	reti

00001120 <__vector_26>:
    1120:	1f 92       	push	r1
    1122:	0f 92       	push	r0
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	0f 92       	push	r0
    1128:	11 24       	eor	r1, r1
    112a:	0b b6       	in	r0, 0x3b	; 59
    112c:	0f 92       	push	r0
    112e:	2f 93       	push	r18
    1130:	3f 93       	push	r19
    1132:	4f 93       	push	r20
    1134:	5f 93       	push	r21
    1136:	6f 93       	push	r22
    1138:	7f 93       	push	r23
    113a:	8f 93       	push	r24
    113c:	9f 93       	push	r25
    113e:	af 93       	push	r26
    1140:	bf 93       	push	r27
    1142:	ef 93       	push	r30
    1144:	ff 93       	push	r31
    1146:	89 e3       	ldi	r24, 0x39	; 57
    1148:	99 e0       	ldi	r25, 0x09	; 9
    114a:	b3 d5       	rcall	.+2918   	; 0x1cb2 <ringBufferNotEmpty>
    114c:	88 23       	and	r24, r24
    114e:	31 f0       	breq	.+12     	; 0x115c <__vector_26+0x3c>
    1150:	89 e3       	ldi	r24, 0x39	; 57
    1152:	99 e0       	ldi	r25, 0x09	; 9
    1154:	7e d5       	rcall	.+2812   	; 0x1c52 <ringBufferPop>
    1156:	80 93 c6 00 	sts	0x00C6, r24
    115a:	0f c0       	rjmp	.+30     	; 0x117a <__vector_26+0x5a>
    115c:	e1 ec       	ldi	r30, 0xC1	; 193
    115e:	f0 e0       	ldi	r31, 0x00	; 0
    1160:	80 81       	ld	r24, Z
    1162:	8f 7d       	andi	r24, 0xDF	; 223
    1164:	80 83       	st	Z, r24
    1166:	20 e0       	ldi	r18, 0x00	; 0
    1168:	40 e0       	ldi	r20, 0x00	; 0
    116a:	50 e0       	ldi	r21, 0x00	; 0
    116c:	60 e0       	ldi	r22, 0x00	; 0
    116e:	70 e0       	ldi	r23, 0x00	; 0
    1170:	80 91 1e 08 	lds	r24, 0x081E
    1174:	90 91 1f 08 	lds	r25, 0x081F
    1178:	78 d4       	rcall	.+2288   	; 0x1a6a <xQueueGenericSendFromISR>
    117a:	ff 91       	pop	r31
    117c:	ef 91       	pop	r30
    117e:	bf 91       	pop	r27
    1180:	af 91       	pop	r26
    1182:	9f 91       	pop	r25
    1184:	8f 91       	pop	r24
    1186:	7f 91       	pop	r23
    1188:	6f 91       	pop	r22
    118a:	5f 91       	pop	r21
    118c:	4f 91       	pop	r20
    118e:	3f 91       	pop	r19
    1190:	2f 91       	pop	r18
    1192:	0f 90       	pop	r0
    1194:	0b be       	out	0x3b, r0	; 59
    1196:	0f 90       	pop	r0
    1198:	0f be       	out	0x3f, r0	; 63
    119a:	0f 90       	pop	r0
    119c:	1f 90       	pop	r1
    119e:	18 95       	reti

000011a0 <myUSART_USART0_Init>:
    11a0:	10 92 c5 00 	sts	0x00C5, r1
    11a4:	87 e6       	ldi	r24, 0x67	; 103
    11a6:	80 93 c4 00 	sts	0x00C4, r24
    11aa:	88 eb       	ldi	r24, 0xB8	; 184
    11ac:	80 93 c1 00 	sts	0x00C1, r24
    11b0:	86 e0       	ldi	r24, 0x06	; 6
    11b2:	80 93 c2 00 	sts	0x00C2, r24
    11b6:	40 e2       	ldi	r20, 0x20	; 32
    11b8:	64 ef       	ldi	r22, 0xF4	; 244
    11ba:	78 e0       	ldi	r23, 0x08	; 8
    11bc:	8f ec       	ldi	r24, 0xCF	; 207
    11be:	98 e0       	ldi	r25, 0x08	; 8
    11c0:	41 d5       	rcall	.+2690   	; 0x1c44 <ringBufferInit>
    11c2:	40 e2       	ldi	r20, 0x20	; 32
    11c4:	64 ed       	ldi	r22, 0xD4	; 212
    11c6:	78 e0       	ldi	r23, 0x08	; 8
    11c8:	89 e3       	ldi	r24, 0x39	; 57
    11ca:	99 e0       	ldi	r25, 0x09	; 9
    11cc:	3b d5       	rcall	.+2678   	; 0x1c44 <ringBufferInit>
    11ce:	43 e0       	ldi	r20, 0x03	; 3
    11d0:	60 e0       	ldi	r22, 0x00	; 0
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	5f d3       	rcall	.+1726   	; 0x1894 <xQueueGenericCreate>
    11d6:	90 93 23 08 	sts	0x0823, r25
    11da:	80 93 22 08 	sts	0x0822, r24
    11de:	81 e0       	ldi	r24, 0x01	; 1
    11e0:	19 d4       	rcall	.+2098   	; 0x1a14 <xQueueCreateMutex>
    11e2:	90 93 1f 08 	sts	0x081F, r25
    11e6:	80 93 1e 08 	sts	0x081E, r24
    11ea:	08 95       	ret

000011ec <myUSART_USART1_Init>:
    11ec:	10 92 cd 00 	sts	0x00CD, r1
    11f0:	87 e6       	ldi	r24, 0x67	; 103
    11f2:	80 93 cc 00 	sts	0x00CC, r24
    11f6:	88 eb       	ldi	r24, 0xB8	; 184
    11f8:	80 93 c9 00 	sts	0x00C9, r24
    11fc:	86 e0       	ldi	r24, 0x06	; 6
    11fe:	80 93 ca 00 	sts	0x00CA, r24
    1202:	40 e2       	ldi	r20, 0x20	; 32
    1204:	6f ea       	ldi	r22, 0xAF	; 175
    1206:	78 e0       	ldi	r23, 0x08	; 8
    1208:	8e e3       	ldi	r24, 0x3E	; 62
    120a:	99 e0       	ldi	r25, 0x09	; 9
    120c:	1b d5       	rcall	.+2614   	; 0x1c44 <ringBufferInit>
    120e:	40 e2       	ldi	r20, 0x20	; 32
    1210:	64 e1       	ldi	r22, 0x14	; 20
    1212:	79 e0       	ldi	r23, 0x09	; 9
    1214:	84 e3       	ldi	r24, 0x34	; 52
    1216:	99 e0       	ldi	r25, 0x09	; 9
    1218:	15 d5       	rcall	.+2602   	; 0x1c44 <ringBufferInit>
    121a:	43 e0       	ldi	r20, 0x03	; 3
    121c:	60 e0       	ldi	r22, 0x00	; 0
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	39 d3       	rcall	.+1650   	; 0x1894 <xQueueGenericCreate>
    1222:	90 93 25 08 	sts	0x0825, r25
    1226:	80 93 24 08 	sts	0x0824, r24
    122a:	43 e0       	ldi	r20, 0x03	; 3
    122c:	60 e0       	ldi	r22, 0x00	; 0
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	31 d3       	rcall	.+1634   	; 0x1894 <xQueueGenericCreate>
    1232:	90 93 21 08 	sts	0x0821, r25
    1236:	80 93 20 08 	sts	0x0820, r24
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	eb d3       	rcall	.+2006   	; 0x1a14 <xQueueCreateMutex>
    123e:	90 93 1d 08 	sts	0x081D, r25
    1242:	80 93 1c 08 	sts	0x081C, r24
    1246:	08 95       	ret

00001248 <myUSART_transmitUSART0_c>:
    1248:	cf 93       	push	r28
    124a:	c8 2f       	mov	r28, r24
    124c:	20 e0       	ldi	r18, 0x00	; 0
    124e:	4f ef       	ldi	r20, 0xFF	; 255
    1250:	5f ef       	ldi	r21, 0xFF	; 255
    1252:	60 e0       	ldi	r22, 0x00	; 0
    1254:	70 e0       	ldi	r23, 0x00	; 0
    1256:	80 91 1e 08 	lds	r24, 0x081E
    125a:	90 91 1f 08 	lds	r25, 0x081F
    125e:	3f d4       	rcall	.+2174   	; 0x1ade <xQueueGenericReceive>
    1260:	89 e3       	ldi	r24, 0x39	; 57
    1262:	99 e0       	ldi	r25, 0x09	; 9
    1264:	1f d5       	rcall	.+2622   	; 0x1ca4 <ringBufferFull>
    1266:	81 11       	cpse	r24, r1
    1268:	fb cf       	rjmp	.-10     	; 0x1260 <myUSART_transmitUSART0_c+0x18>
    126a:	6c 2f       	mov	r22, r28
    126c:	89 e3       	ldi	r24, 0x39	; 57
    126e:	99 e0       	ldi	r25, 0x09	; 9
    1270:	02 d5       	rcall	.+2564   	; 0x1c76 <ringBufferPush>
    1272:	e1 ec       	ldi	r30, 0xC1	; 193
    1274:	f0 e0       	ldi	r31, 0x00	; 0
    1276:	80 81       	ld	r24, Z
    1278:	80 62       	ori	r24, 0x20	; 32
    127a:	80 83       	st	Z, r24
    127c:	e0 ec       	ldi	r30, 0xC0	; 192
    127e:	f0 e0       	ldi	r31, 0x00	; 0
    1280:	80 81       	ld	r24, Z
    1282:	80 64       	ori	r24, 0x40	; 64
    1284:	80 83       	st	Z, r24
    1286:	cf 91       	pop	r28
    1288:	08 95       	ret

0000128a <myUSART_transmitUSART1_c>:
    128a:	cf 93       	push	r28
    128c:	c8 2f       	mov	r28, r24
    128e:	20 e0       	ldi	r18, 0x00	; 0
    1290:	4f ef       	ldi	r20, 0xFF	; 255
    1292:	5f ef       	ldi	r21, 0xFF	; 255
    1294:	60 e0       	ldi	r22, 0x00	; 0
    1296:	70 e0       	ldi	r23, 0x00	; 0
    1298:	80 91 1c 08 	lds	r24, 0x081C
    129c:	90 91 1d 08 	lds	r25, 0x081D
    12a0:	1e d4       	rcall	.+2108   	; 0x1ade <xQueueGenericReceive>
    12a2:	84 e3       	ldi	r24, 0x34	; 52
    12a4:	99 e0       	ldi	r25, 0x09	; 9
    12a6:	fe d4       	rcall	.+2556   	; 0x1ca4 <ringBufferFull>
    12a8:	81 11       	cpse	r24, r1
    12aa:	fb cf       	rjmp	.-10     	; 0x12a2 <myUSART_transmitUSART1_c+0x18>
    12ac:	6c 2f       	mov	r22, r28
    12ae:	84 e3       	ldi	r24, 0x34	; 52
    12b0:	99 e0       	ldi	r25, 0x09	; 9
    12b2:	e1 d4       	rcall	.+2498   	; 0x1c76 <ringBufferPush>
    12b4:	e9 ec       	ldi	r30, 0xC9	; 201
    12b6:	f0 e0       	ldi	r31, 0x00	; 0
    12b8:	80 81       	ld	r24, Z
    12ba:	80 62       	ori	r24, 0x20	; 32
    12bc:	80 83       	st	Z, r24
    12be:	e8 ec       	ldi	r30, 0xC8	; 200
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	80 81       	ld	r24, Z
    12c4:	80 64       	ori	r24, 0x40	; 64
    12c6:	80 83       	st	Z, r24
    12c8:	cf 91       	pop	r28
    12ca:	08 95       	ret

000012cc <myUSART_transmitUSART1>:
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	ec 01       	movw	r28, r24
    12d2:	88 81       	ld	r24, Y
    12d4:	88 23       	and	r24, r24
    12d6:	29 f0       	breq	.+10     	; 0x12e2 <myUSART_transmitUSART1+0x16>
    12d8:	21 96       	adiw	r28, 0x01	; 1
    12da:	d7 df       	rcall	.-82     	; 0x128a <myUSART_transmitUSART1_c>
    12dc:	89 91       	ld	r24, Y+
    12de:	81 11       	cpse	r24, r1
    12e0:	fc cf       	rjmp	.-8      	; 0x12da <myUSART_transmitUSART1+0xe>
    12e2:	df 91       	pop	r29
    12e4:	cf 91       	pop	r28
    12e6:	08 95       	ret

000012e8 <myUSART_transmitUSART0>:
    12e8:	cf 93       	push	r28
    12ea:	df 93       	push	r29
    12ec:	ec 01       	movw	r28, r24
    12ee:	88 81       	ld	r24, Y
    12f0:	88 23       	and	r24, r24
    12f2:	29 f0       	breq	.+10     	; 0x12fe <myUSART_transmitUSART0+0x16>
    12f4:	21 96       	adiw	r28, 0x01	; 1
    12f6:	a8 df       	rcall	.-176    	; 0x1248 <myUSART_transmitUSART0_c>
    12f8:	89 91       	ld	r24, Y+
    12fa:	81 11       	cpse	r24, r1
    12fc:	fc cf       	rjmp	.-8      	; 0x12f6 <myUSART_transmitUSART0+0xe>
    12fe:	df 91       	pop	r29
    1300:	cf 91       	pop	r28
    1302:	08 95       	ret

00001304 <myUSART_receiveUSART1>:
    1304:	cf 93       	push	r28
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	4f ef       	ldi	r20, 0xFF	; 255
    130a:	5f ef       	ldi	r21, 0xFF	; 255
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	70 e0       	ldi	r23, 0x00	; 0
    1310:	80 91 24 08 	lds	r24, 0x0824
    1314:	90 91 25 08 	lds	r25, 0x0825
    1318:	e2 d3       	rcall	.+1988   	; 0x1ade <xQueueGenericReceive>
    131a:	8e e3       	ldi	r24, 0x3E	; 62
    131c:	99 e0       	ldi	r25, 0x09	; 9
    131e:	99 d4       	rcall	.+2354   	; 0x1c52 <ringBufferPop>
    1320:	c8 2f       	mov	r28, r24
    1322:	8e e3       	ldi	r24, 0x3E	; 62
    1324:	99 e0       	ldi	r25, 0x09	; 9
    1326:	c5 d4       	rcall	.+2442   	; 0x1cb2 <ringBufferNotEmpty>
    1328:	88 23       	and	r24, r24
    132a:	51 f0       	breq	.+20     	; 0x1340 <myUSART_receiveUSART1+0x3c>
    132c:	20 e0       	ldi	r18, 0x00	; 0
    132e:	40 e0       	ldi	r20, 0x00	; 0
    1330:	50 e0       	ldi	r21, 0x00	; 0
    1332:	60 e0       	ldi	r22, 0x00	; 0
    1334:	70 e0       	ldi	r23, 0x00	; 0
    1336:	80 91 24 08 	lds	r24, 0x0824
    133a:	90 91 25 08 	lds	r25, 0x0825
    133e:	d7 d2       	rcall	.+1454   	; 0x18ee <xQueueGenericSend>
    1340:	8c 2f       	mov	r24, r28
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret

00001346 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    1346:	86 e1       	ldi	r24, 0x16	; 22
    1348:	a0 df       	rcall	.-192    	; 0x128a <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    134a:	20 e0       	ldi	r18, 0x00	; 0
    134c:	4a ef       	ldi	r20, 0xFA	; 250
    134e:	50 e0       	ldi	r21, 0x00	; 0
    1350:	60 e0       	ldi	r22, 0x00	; 0
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	80 91 20 08 	lds	r24, 0x0820
    1358:	90 91 21 08 	lds	r25, 0x0821
    135c:	c0 d3       	rcall	.+1920   	; 0x1ade <xQueueGenericReceive>
    135e:	81 30       	cpi	r24, 0x01	; 1
    1360:	21 f4       	brne	.+8      	; 0x136a <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    1362:	82 e0       	ldi	r24, 0x02	; 2
    1364:	92 df       	rcall	.-220    	; 0x128a <myUSART_transmitUSART1_c>
		return 1;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	08 95       	ret
	}
	else
	{
		return 0;
    136a:	80 e0       	ldi	r24, 0x00	; 0
	}


	//xSemaphoreTake(semaUsart1HandShake, portMAX_DELAY); // wait for handshake to be ack...
	//( TickType_t ) 10 ) == pdTRUE ... if fail return 0 => at main put state to determine when to send to UART1...
}
    136c:	08 95       	ret

0000136e <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    136e:	20 e0       	ldi	r18, 0x00	; 0
    1370:	40 e0       	ldi	r20, 0x00	; 0
    1372:	50 e0       	ldi	r21, 0x00	; 0
    1374:	60 e0       	ldi	r22, 0x00	; 0
    1376:	70 e0       	ldi	r23, 0x00	; 0
    1378:	80 91 20 08 	lds	r24, 0x0820
    137c:	90 91 21 08 	lds	r25, 0x0821
    1380:	b6 c2       	rjmp	.+1388   	; 0x18ee <xQueueGenericSend>
    1382:	08 95       	ret

00001384 <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    1384:	91 e0       	ldi	r25, 0x01	; 1
    1386:	85 30       	cpi	r24, 0x05	; 5
    1388:	09 f0       	breq	.+2      	; 0x138c <myUSART_receiveHandShakeAck+0x8>
    138a:	90 e0       	ldi	r25, 0x00	; 0
}
    138c:	89 2f       	mov	r24, r25
    138e:	08 95       	ret

00001390 <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    1390:	91 e0       	ldi	r25, 0x01	; 1
    1392:	86 31       	cpi	r24, 0x16	; 22
    1394:	09 f0       	breq	.+2      	; 0x1398 <myUSART_receiveHandShakeStart+0x8>
    1396:	90 e0       	ldi	r25, 0x00	; 0
}
    1398:	89 2f       	mov	r24, r25
    139a:	08 95       	ret

0000139c <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    139c:	91 e0       	ldi	r25, 0x01	; 1
    139e:	82 30       	cpi	r24, 0x02	; 2
    13a0:	09 f0       	breq	.+2      	; 0x13a4 <myUSART_receiveHandShakeFin+0x8>
    13a2:	90 e0       	ldi	r25, 0x00	; 0
}
    13a4:	89 2f       	mov	r24, r25
    13a6:	08 95       	ret

000013a8 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    13a8:	91 e0       	ldi	r25, 0x01	; 1
    13aa:	86 30       	cpi	r24, 0x06	; 6
    13ac:	09 f0       	breq	.+2      	; 0x13b0 <myUSART_receiveMessageACK+0x8>
    13ae:	90 e0       	ldi	r25, 0x00	; 0
}
    13b0:	89 2f       	mov	r24, r25
    13b2:	08 95       	ret

000013b4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    13b4:	31 e1       	ldi	r19, 0x11	; 17
    13b6:	fc 01       	movw	r30, r24
    13b8:	30 83       	st	Z, r19
    13ba:	31 97       	sbiw	r30, 0x01	; 1
    13bc:	22 e2       	ldi	r18, 0x22	; 34
    13be:	20 83       	st	Z, r18
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	a3 e3       	ldi	r26, 0x33	; 51
    13c4:	a0 83       	st	Z, r26
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	60 83       	st	Z, r22
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	70 83       	st	Z, r23
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	10 82       	st	Z, r1
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	10 82       	st	Z, r1
    13d6:	31 97       	sbiw	r30, 0x01	; 1
    13d8:	60 e8       	ldi	r22, 0x80	; 128
    13da:	60 83       	st	Z, r22
    13dc:	31 97       	sbiw	r30, 0x01	; 1
    13de:	10 82       	st	Z, r1
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	10 82       	st	Z, r1
    13e4:	31 97       	sbiw	r30, 0x01	; 1
    13e6:	10 82       	st	Z, r1
    13e8:	31 97       	sbiw	r30, 0x01	; 1
    13ea:	62 e0       	ldi	r22, 0x02	; 2
    13ec:	60 83       	st	Z, r22
    13ee:	31 97       	sbiw	r30, 0x01	; 1
    13f0:	63 e0       	ldi	r22, 0x03	; 3
    13f2:	60 83       	st	Z, r22
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	64 e0       	ldi	r22, 0x04	; 4
    13f8:	60 83       	st	Z, r22
    13fa:	31 97       	sbiw	r30, 0x01	; 1
    13fc:	65 e0       	ldi	r22, 0x05	; 5
    13fe:	60 83       	st	Z, r22
    1400:	31 97       	sbiw	r30, 0x01	; 1
    1402:	66 e0       	ldi	r22, 0x06	; 6
    1404:	60 83       	st	Z, r22
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	67 e0       	ldi	r22, 0x07	; 7
    140a:	60 83       	st	Z, r22
    140c:	31 97       	sbiw	r30, 0x01	; 1
    140e:	68 e0       	ldi	r22, 0x08	; 8
    1410:	60 83       	st	Z, r22
    1412:	31 97       	sbiw	r30, 0x01	; 1
    1414:	69 e0       	ldi	r22, 0x09	; 9
    1416:	60 83       	st	Z, r22
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	60 e1       	ldi	r22, 0x10	; 16
    141c:	60 83       	st	Z, r22
    141e:	31 97       	sbiw	r30, 0x01	; 1
    1420:	30 83       	st	Z, r19
    1422:	31 97       	sbiw	r30, 0x01	; 1
    1424:	32 e1       	ldi	r19, 0x12	; 18
    1426:	30 83       	st	Z, r19
    1428:	31 97       	sbiw	r30, 0x01	; 1
    142a:	33 e1       	ldi	r19, 0x13	; 19
    142c:	30 83       	st	Z, r19
    142e:	31 97       	sbiw	r30, 0x01	; 1
    1430:	34 e1       	ldi	r19, 0x14	; 20
    1432:	30 83       	st	Z, r19
    1434:	31 97       	sbiw	r30, 0x01	; 1
    1436:	35 e1       	ldi	r19, 0x15	; 21
    1438:	30 83       	st	Z, r19
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	36 e1       	ldi	r19, 0x16	; 22
    143e:	30 83       	st	Z, r19
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	37 e1       	ldi	r19, 0x17	; 23
    1444:	30 83       	st	Z, r19
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	38 e1       	ldi	r19, 0x18	; 24
    144a:	30 83       	st	Z, r19
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	39 e1       	ldi	r19, 0x19	; 25
    1450:	30 83       	st	Z, r19
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	30 e2       	ldi	r19, 0x20	; 32
    1456:	30 83       	st	Z, r19
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	31 e2       	ldi	r19, 0x21	; 33
    145c:	30 83       	st	Z, r19
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	20 83       	st	Z, r18
    1462:	31 97       	sbiw	r30, 0x01	; 1
    1464:	23 e2       	ldi	r18, 0x23	; 35
    1466:	20 83       	st	Z, r18
    1468:	31 97       	sbiw	r30, 0x01	; 1
    146a:	40 83       	st	Z, r20
    146c:	31 97       	sbiw	r30, 0x01	; 1
    146e:	50 83       	st	Z, r21
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	26 e2       	ldi	r18, 0x26	; 38
    1474:	20 83       	st	Z, r18
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	27 e2       	ldi	r18, 0x27	; 39
    147a:	20 83       	st	Z, r18
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	28 e2       	ldi	r18, 0x28	; 40
    1480:	20 83       	st	Z, r18
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	29 e2       	ldi	r18, 0x29	; 41
    1486:	20 83       	st	Z, r18
    1488:	31 97       	sbiw	r30, 0x01	; 1
    148a:	20 e3       	ldi	r18, 0x30	; 48
    148c:	20 83       	st	Z, r18
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	21 e3       	ldi	r18, 0x31	; 49
    1492:	20 83       	st	Z, r18
    1494:	89 97       	sbiw	r24, 0x29	; 41
    1496:	08 95       	ret

00001498 <xPortStartScheduler>:
    1498:	82 e0       	ldi	r24, 0x02	; 2
    149a:	84 bd       	out	0x24, r24	; 36
    149c:	16 bc       	out	0x26, r1	; 38
    149e:	80 e3       	ldi	r24, 0x30	; 48
    14a0:	87 bd       	out	0x27, r24	; 39
    14a2:	ee e6       	ldi	r30, 0x6E	; 110
    14a4:	f0 e0       	ldi	r31, 0x00	; 0
    14a6:	80 81       	ld	r24, Z
    14a8:	82 60       	ori	r24, 0x02	; 2
    14aa:	80 83       	st	Z, r24
    14ac:	83 e0       	ldi	r24, 0x03	; 3
    14ae:	85 bd       	out	0x25, r24	; 37
    14b0:	a0 91 8f 08 	lds	r26, 0x088F
    14b4:	b0 91 90 08 	lds	r27, 0x0890
    14b8:	cd 91       	ld	r28, X+
    14ba:	cd bf       	out	0x3d, r28	; 61
    14bc:	dd 91       	ld	r29, X+
    14be:	de bf       	out	0x3e, r29	; 62
    14c0:	ff 91       	pop	r31
    14c2:	ef 91       	pop	r30
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
    14c8:	bf 91       	pop	r27
    14ca:	af 91       	pop	r26
    14cc:	9f 91       	pop	r25
    14ce:	8f 91       	pop	r24
    14d0:	7f 91       	pop	r23
    14d2:	6f 91       	pop	r22
    14d4:	5f 91       	pop	r21
    14d6:	4f 91       	pop	r20
    14d8:	3f 91       	pop	r19
    14da:	2f 91       	pop	r18
    14dc:	1f 91       	pop	r17
    14de:	0f 91       	pop	r16
    14e0:	ff 90       	pop	r15
    14e2:	ef 90       	pop	r14
    14e4:	df 90       	pop	r13
    14e6:	cf 90       	pop	r12
    14e8:	bf 90       	pop	r11
    14ea:	af 90       	pop	r10
    14ec:	9f 90       	pop	r9
    14ee:	8f 90       	pop	r8
    14f0:	7f 90       	pop	r7
    14f2:	6f 90       	pop	r6
    14f4:	5f 90       	pop	r5
    14f6:	4f 90       	pop	r4
    14f8:	3f 90       	pop	r3
    14fa:	2f 90       	pop	r2
    14fc:	1f 90       	pop	r1
    14fe:	0f 90       	pop	r0
    1500:	0c be       	out	0x3c, r0	; 60
    1502:	0f 90       	pop	r0
    1504:	0b be       	out	0x3b, r0	; 59
    1506:	0f 90       	pop	r0
    1508:	0f be       	out	0x3f, r0	; 63
    150a:	0f 90       	pop	r0
    150c:	08 95       	ret
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	08 95       	ret

00001512 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1512:	0f 92       	push	r0
    1514:	0f b6       	in	r0, 0x3f	; 63
    1516:	f8 94       	cli
    1518:	0f 92       	push	r0
    151a:	0b b6       	in	r0, 0x3b	; 59
    151c:	0f 92       	push	r0
    151e:	0c b6       	in	r0, 0x3c	; 60
    1520:	0f 92       	push	r0
    1522:	1f 92       	push	r1
    1524:	11 24       	eor	r1, r1
    1526:	2f 92       	push	r2
    1528:	3f 92       	push	r3
    152a:	4f 92       	push	r4
    152c:	5f 92       	push	r5
    152e:	6f 92       	push	r6
    1530:	7f 92       	push	r7
    1532:	8f 92       	push	r8
    1534:	9f 92       	push	r9
    1536:	af 92       	push	r10
    1538:	bf 92       	push	r11
    153a:	cf 92       	push	r12
    153c:	df 92       	push	r13
    153e:	ef 92       	push	r14
    1540:	ff 92       	push	r15
    1542:	0f 93       	push	r16
    1544:	1f 93       	push	r17
    1546:	2f 93       	push	r18
    1548:	3f 93       	push	r19
    154a:	4f 93       	push	r20
    154c:	5f 93       	push	r21
    154e:	6f 93       	push	r22
    1550:	7f 93       	push	r23
    1552:	8f 93       	push	r24
    1554:	9f 93       	push	r25
    1556:	af 93       	push	r26
    1558:	bf 93       	push	r27
    155a:	cf 93       	push	r28
    155c:	df 93       	push	r29
    155e:	ef 93       	push	r30
    1560:	ff 93       	push	r31
    1562:	a0 91 8f 08 	lds	r26, 0x088F
    1566:	b0 91 90 08 	lds	r27, 0x0890
    156a:	0d b6       	in	r0, 0x3d	; 61
    156c:	0d 92       	st	X+, r0
    156e:	0e b6       	in	r0, 0x3e	; 62
    1570:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1572:	51 d7       	rcall	.+3746   	; 0x2416 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1574:	a0 91 8f 08 	lds	r26, 0x088F
    1578:	b0 91 90 08 	lds	r27, 0x0890
    157c:	cd 91       	ld	r28, X+
    157e:	cd bf       	out	0x3d, r28	; 61
    1580:	dd 91       	ld	r29, X+
    1582:	de bf       	out	0x3e, r29	; 62
    1584:	ff 91       	pop	r31
    1586:	ef 91       	pop	r30
    1588:	df 91       	pop	r29
    158a:	cf 91       	pop	r28
    158c:	bf 91       	pop	r27
    158e:	af 91       	pop	r26
    1590:	9f 91       	pop	r25
    1592:	8f 91       	pop	r24
    1594:	7f 91       	pop	r23
    1596:	6f 91       	pop	r22
    1598:	5f 91       	pop	r21
    159a:	4f 91       	pop	r20
    159c:	3f 91       	pop	r19
    159e:	2f 91       	pop	r18
    15a0:	1f 91       	pop	r17
    15a2:	0f 91       	pop	r16
    15a4:	ff 90       	pop	r15
    15a6:	ef 90       	pop	r14
    15a8:	df 90       	pop	r13
    15aa:	cf 90       	pop	r12
    15ac:	bf 90       	pop	r11
    15ae:	af 90       	pop	r10
    15b0:	9f 90       	pop	r9
    15b2:	8f 90       	pop	r8
    15b4:	7f 90       	pop	r7
    15b6:	6f 90       	pop	r6
    15b8:	5f 90       	pop	r5
    15ba:	4f 90       	pop	r4
    15bc:	3f 90       	pop	r3
    15be:	2f 90       	pop	r2
    15c0:	1f 90       	pop	r1
    15c2:	0f 90       	pop	r0
    15c4:	0c be       	out	0x3c, r0	; 60
    15c6:	0f 90       	pop	r0
    15c8:	0b be       	out	0x3b, r0	; 59
    15ca:	0f 90       	pop	r0
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15d0:	08 95       	ret

000015d2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    15d2:	0f 92       	push	r0
    15d4:	0f b6       	in	r0, 0x3f	; 63
    15d6:	f8 94       	cli
    15d8:	0f 92       	push	r0
    15da:	0b b6       	in	r0, 0x3b	; 59
    15dc:	0f 92       	push	r0
    15de:	0c b6       	in	r0, 0x3c	; 60
    15e0:	0f 92       	push	r0
    15e2:	1f 92       	push	r1
    15e4:	11 24       	eor	r1, r1
    15e6:	2f 92       	push	r2
    15e8:	3f 92       	push	r3
    15ea:	4f 92       	push	r4
    15ec:	5f 92       	push	r5
    15ee:	6f 92       	push	r6
    15f0:	7f 92       	push	r7
    15f2:	8f 92       	push	r8
    15f4:	9f 92       	push	r9
    15f6:	af 92       	push	r10
    15f8:	bf 92       	push	r11
    15fa:	cf 92       	push	r12
    15fc:	df 92       	push	r13
    15fe:	ef 92       	push	r14
    1600:	ff 92       	push	r15
    1602:	0f 93       	push	r16
    1604:	1f 93       	push	r17
    1606:	2f 93       	push	r18
    1608:	3f 93       	push	r19
    160a:	4f 93       	push	r20
    160c:	5f 93       	push	r21
    160e:	6f 93       	push	r22
    1610:	7f 93       	push	r23
    1612:	8f 93       	push	r24
    1614:	9f 93       	push	r25
    1616:	af 93       	push	r26
    1618:	bf 93       	push	r27
    161a:	cf 93       	push	r28
    161c:	df 93       	push	r29
    161e:	ef 93       	push	r30
    1620:	ff 93       	push	r31
    1622:	a0 91 8f 08 	lds	r26, 0x088F
    1626:	b0 91 90 08 	lds	r27, 0x0890
    162a:	0d b6       	in	r0, 0x3d	; 61
    162c:	0d 92       	st	X+, r0
    162e:	0e b6       	in	r0, 0x3e	; 62
    1630:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1632:	3b d5       	rcall	.+2678   	; 0x20aa <xTaskIncrementTick>
    1634:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1636:	ef d6       	rcall	.+3550   	; 0x2416 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1638:	a0 91 8f 08 	lds	r26, 0x088F
    163c:	b0 91 90 08 	lds	r27, 0x0890
    1640:	cd 91       	ld	r28, X+
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	dd 91       	ld	r29, X+
    1646:	de bf       	out	0x3e, r29	; 62
    1648:	ff 91       	pop	r31
    164a:	ef 91       	pop	r30
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	bf 91       	pop	r27
    1652:	af 91       	pop	r26
    1654:	9f 91       	pop	r25
    1656:	8f 91       	pop	r24
    1658:	7f 91       	pop	r23
    165a:	6f 91       	pop	r22
    165c:	5f 91       	pop	r21
    165e:	4f 91       	pop	r20
    1660:	3f 91       	pop	r19
    1662:	2f 91       	pop	r18
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	ff 90       	pop	r15
    166a:	ef 90       	pop	r14
    166c:	df 90       	pop	r13
    166e:	cf 90       	pop	r12
    1670:	bf 90       	pop	r11
    1672:	af 90       	pop	r10
    1674:	9f 90       	pop	r9
    1676:	8f 90       	pop	r8
    1678:	7f 90       	pop	r7
    167a:	6f 90       	pop	r6
    167c:	5f 90       	pop	r5
    167e:	4f 90       	pop	r4
    1680:	3f 90       	pop	r3
    1682:	2f 90       	pop	r2
    1684:	1f 90       	pop	r1
    1686:	0f 90       	pop	r0
    1688:	0c be       	out	0x3c, r0	; 60
    168a:	0f 90       	pop	r0
    168c:	0b be       	out	0x3b, r0	; 59
    168e:	0f 90       	pop	r0
    1690:	0f be       	out	0x3f, r0	; 63
    1692:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1694:	08 95       	ret

00001696 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1696:	9d df       	rcall	.-198    	; 0x15d2 <vPortYieldFromTick>
		 asm volatile ("reti");
    1698:	18 95       	reti

0000169a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    169a:	1f 93       	push	r17
    169c:	cf 93       	push	r28
    169e:	df 93       	push	r29
    16a0:	ec 01       	movw	r28, r24
    16a2:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    16a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    16a6:	81 11       	cpse	r24, r1
    16a8:	0c c0       	rjmp	.+24     	; 0x16c2 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16aa:	88 81       	ld	r24, Y
    16ac:	99 81       	ldd	r25, Y+1	; 0x01
    16ae:	89 2b       	or	r24, r25
    16b0:	09 f0       	breq	.+2      	; 0x16b4 <prvCopyDataToQueue+0x1a>
    16b2:	47 c0       	rjmp	.+142    	; 0x1742 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    16b4:	8a 81       	ldd	r24, Y+2	; 0x02
    16b6:	9b 81       	ldd	r25, Y+3	; 0x03
    16b8:	0e 94 ce 13 	call	0x279c	; 0x279c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    16bc:	1b 82       	std	Y+3, r1	; 0x03
    16be:	1a 82       	std	Y+2, r1	; 0x02
    16c0:	47 c0       	rjmp	.+142    	; 0x1750 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    16c2:	41 11       	cpse	r20, r1
    16c4:	18 c0       	rjmp	.+48     	; 0x16f6 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    16c6:	48 2f       	mov	r20, r24
    16c8:	50 e0       	ldi	r21, 0x00	; 0
    16ca:	8c 81       	ldd	r24, Y+4	; 0x04
    16cc:	9d 81       	ldd	r25, Y+5	; 0x05
    16ce:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16d2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16d4:	8c 81       	ldd	r24, Y+4	; 0x04
    16d6:	9d 81       	ldd	r25, Y+5	; 0x05
    16d8:	82 0f       	add	r24, r18
    16da:	91 1d       	adc	r25, r1
    16dc:	9d 83       	std	Y+5, r25	; 0x05
    16de:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16e0:	2a 81       	ldd	r18, Y+2	; 0x02
    16e2:	3b 81       	ldd	r19, Y+3	; 0x03
    16e4:	82 17       	cp	r24, r18
    16e6:	93 07       	cpc	r25, r19
    16e8:	70 f1       	brcs	.+92     	; 0x1746 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    16ea:	88 81       	ld	r24, Y
    16ec:	99 81       	ldd	r25, Y+1	; 0x01
    16ee:	9d 83       	std	Y+5, r25	; 0x05
    16f0:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	2d c0       	rjmp	.+90     	; 0x1750 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16f6:	48 2f       	mov	r20, r24
    16f8:	50 e0       	ldi	r21, 0x00	; 0
    16fa:	8e 81       	ldd	r24, Y+6	; 0x06
    16fc:	9f 81       	ldd	r25, Y+7	; 0x07
    16fe:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1702:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1704:	30 e0       	ldi	r19, 0x00	; 0
    1706:	31 95       	neg	r19
    1708:	21 95       	neg	r18
    170a:	31 09       	sbc	r19, r1
    170c:	8e 81       	ldd	r24, Y+6	; 0x06
    170e:	9f 81       	ldd	r25, Y+7	; 0x07
    1710:	82 0f       	add	r24, r18
    1712:	93 1f       	adc	r25, r19
    1714:	9f 83       	std	Y+7, r25	; 0x07
    1716:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1718:	68 81       	ld	r22, Y
    171a:	79 81       	ldd	r23, Y+1	; 0x01
    171c:	86 17       	cp	r24, r22
    171e:	97 07       	cpc	r25, r23
    1720:	30 f4       	brcc	.+12     	; 0x172e <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1722:	8a 81       	ldd	r24, Y+2	; 0x02
    1724:	9b 81       	ldd	r25, Y+3	; 0x03
    1726:	28 0f       	add	r18, r24
    1728:	39 1f       	adc	r19, r25
    172a:	3f 83       	std	Y+7, r19	; 0x07
    172c:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    172e:	12 30       	cpi	r17, 0x02	; 2
    1730:	61 f4       	brne	.+24     	; 0x174a <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1732:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1734:	88 23       	and	r24, r24
    1736:	59 f0       	breq	.+22     	; 0x174e <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1738:	8a 8d       	ldd	r24, Y+26	; 0x1a
    173a:	81 50       	subi	r24, 0x01	; 1
    173c:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    173e:	80 e0       	ldi	r24, 0x00	; 0
    1740:	07 c0       	rjmp	.+14     	; 0x1750 <prvCopyDataToQueue+0xb6>
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	05 c0       	rjmp	.+10     	; 0x1750 <prvCopyDataToQueue+0xb6>
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	03 c0       	rjmp	.+6      	; 0x1750 <prvCopyDataToQueue+0xb6>
    174a:	80 e0       	ldi	r24, 0x00	; 0
    174c:	01 c0       	rjmp	.+2      	; 0x1750 <prvCopyDataToQueue+0xb6>
    174e:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1750:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1752:	9f 5f       	subi	r25, 0xFF	; 255
    1754:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    1756:	df 91       	pop	r29
    1758:	cf 91       	pop	r28
    175a:	1f 91       	pop	r17
    175c:	08 95       	ret

0000175e <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    175e:	fc 01       	movw	r30, r24
    1760:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1762:	44 8d       	ldd	r20, Z+28	; 0x1c
    1764:	44 23       	and	r20, r20
    1766:	a1 f0       	breq	.+40     	; 0x1790 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1768:	50 e0       	ldi	r21, 0x00	; 0
    176a:	26 81       	ldd	r18, Z+6	; 0x06
    176c:	37 81       	ldd	r19, Z+7	; 0x07
    176e:	24 0f       	add	r18, r20
    1770:	35 1f       	adc	r19, r21
    1772:	37 83       	std	Z+7, r19	; 0x07
    1774:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1776:	62 81       	ldd	r22, Z+2	; 0x02
    1778:	73 81       	ldd	r23, Z+3	; 0x03
    177a:	26 17       	cp	r18, r22
    177c:	37 07       	cpc	r19, r23
    177e:	20 f0       	brcs	.+8      	; 0x1788 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1780:	20 81       	ld	r18, Z
    1782:	31 81       	ldd	r19, Z+1	; 0x01
    1784:	37 83       	std	Z+7, r19	; 0x07
    1786:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1788:	66 81       	ldd	r22, Z+6	; 0x06
    178a:	77 81       	ldd	r23, Z+7	; 0x07
    178c:	0c 94 9a 17 	jmp	0x2f34	; 0x2f34 <memcpy>
    1790:	08 95       	ret

00001792 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1792:	0f 93       	push	r16
    1794:	1f 93       	push	r17
    1796:	cf 93       	push	r28
    1798:	df 93       	push	r29
    179a:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    179c:	0f b6       	in	r0, 0x3f	; 63
    179e:	f8 94       	cli
    17a0:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17a4:	18 16       	cp	r1, r24
    17a6:	a4 f4       	brge	.+40     	; 0x17d0 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17a8:	89 89       	ldd	r24, Y+17	; 0x11
    17aa:	88 23       	and	r24, r24
    17ac:	89 f0       	breq	.+34     	; 0x17d0 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ae:	8e 01       	movw	r16, r28
    17b0:	0f 5e       	subi	r16, 0xEF	; 239
    17b2:	1f 4f       	sbci	r17, 0xFF	; 255
    17b4:	03 c0       	rjmp	.+6      	; 0x17bc <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17b6:	89 89       	ldd	r24, Y+17	; 0x11
    17b8:	88 23       	and	r24, r24
    17ba:	51 f0       	breq	.+20     	; 0x17d0 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17bc:	c8 01       	movw	r24, r16
    17be:	01 d7       	rcall	.+3586   	; 0x25c2 <xTaskRemoveFromEventList>
    17c0:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    17c2:	8a d7       	rcall	.+3860   	; 0x26d8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    17c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17c6:	81 50       	subi	r24, 0x01	; 1
    17c8:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    17ca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    17cc:	18 16       	cp	r1, r24
    17ce:	9c f3       	brlt	.-26     	; 0x17b6 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17d0:	8f ef       	ldi	r24, 0xFF	; 255
    17d2:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17de:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17e0:	18 16       	cp	r1, r24
    17e2:	a4 f4       	brge	.+40     	; 0x180c <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17e4:	88 85       	ldd	r24, Y+8	; 0x08
    17e6:	88 23       	and	r24, r24
    17e8:	89 f0       	breq	.+34     	; 0x180c <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17ea:	8e 01       	movw	r16, r28
    17ec:	08 5f       	subi	r16, 0xF8	; 248
    17ee:	1f 4f       	sbci	r17, 0xFF	; 255
    17f0:	03 c0       	rjmp	.+6      	; 0x17f8 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17f2:	88 85       	ldd	r24, Y+8	; 0x08
    17f4:	88 23       	and	r24, r24
    17f6:	51 f0       	breq	.+20     	; 0x180c <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17f8:	c8 01       	movw	r24, r16
    17fa:	e3 d6       	rcall	.+3526   	; 0x25c2 <xTaskRemoveFromEventList>
    17fc:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    17fe:	6c d7       	rcall	.+3800   	; 0x26d8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1800:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1802:	81 50       	subi	r24, 0x01	; 1
    1804:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1806:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1808:	18 16       	cp	r1, r24
    180a:	9c f3       	brlt	.-26     	; 0x17f2 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    180c:	8f ef       	ldi	r24, 0xFF	; 255
    180e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
}
    1814:	df 91       	pop	r29
    1816:	cf 91       	pop	r28
    1818:	1f 91       	pop	r17
    181a:	0f 91       	pop	r16
    181c:	08 95       	ret

0000181e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    181e:	cf 93       	push	r28
    1820:	df 93       	push	r29
    1822:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1824:	0f b6       	in	r0, 0x3f	; 63
    1826:	f8 94       	cli
    1828:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    182a:	88 81       	ld	r24, Y
    182c:	99 81       	ldd	r25, Y+1	; 0x01
    182e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1830:	30 e0       	ldi	r19, 0x00	; 0
    1832:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1834:	72 9f       	mul	r23, r18
    1836:	a0 01       	movw	r20, r0
    1838:	73 9f       	mul	r23, r19
    183a:	50 0d       	add	r21, r0
    183c:	11 24       	eor	r1, r1
    183e:	fc 01       	movw	r30, r24
    1840:	e4 0f       	add	r30, r20
    1842:	f5 1f       	adc	r31, r21
    1844:	fb 83       	std	Y+3, r31	; 0x03
    1846:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1848:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    184a:	9d 83       	std	Y+5, r25	; 0x05
    184c:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    184e:	42 1b       	sub	r20, r18
    1850:	53 0b       	sbc	r21, r19
    1852:	84 0f       	add	r24, r20
    1854:	95 1f       	adc	r25, r21
    1856:	9f 83       	std	Y+7, r25	; 0x07
    1858:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    185a:	8f ef       	ldi	r24, 0xFF	; 255
    185c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    185e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1860:	61 11       	cpse	r22, r1
    1862:	0a c0       	rjmp	.+20     	; 0x1878 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1864:	88 85       	ldd	r24, Y+8	; 0x08
    1866:	88 23       	and	r24, r24
    1868:	79 f0       	breq	.+30     	; 0x1888 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    186a:	ce 01       	movw	r24, r28
    186c:	08 96       	adiw	r24, 0x08	; 8
    186e:	a9 d6       	rcall	.+3410   	; 0x25c2 <xTaskRemoveFromEventList>
    1870:	81 30       	cpi	r24, 0x01	; 1
    1872:	51 f4       	brne	.+20     	; 0x1888 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1874:	4e de       	rcall	.-868    	; 0x1512 <vPortYield>
    1876:	08 c0       	rjmp	.+16     	; 0x1888 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1878:	ce 01       	movw	r24, r28
    187a:	08 96       	adiw	r24, 0x08	; 8
    187c:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1880:	ce 01       	movw	r24, r28
    1882:	41 96       	adiw	r24, 0x11	; 17
    1884:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1888:	0f 90       	pop	r0
    188a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	df 91       	pop	r29
    1890:	cf 91       	pop	r28
    1892:	08 95       	ret

00001894 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1894:	0f 93       	push	r16
    1896:	1f 93       	push	r17
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
    189c:	18 2f       	mov	r17, r24
    189e:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    18a0:	88 23       	and	r24, r24
    18a2:	e9 f0       	breq	.+58     	; 0x18de <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    18a4:	8f e1       	ldi	r24, 0x1F	; 31
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	0e 94 17 03 	call	0x62e	; 0x62e <pvPortMalloc>
    18ac:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	c1 f0       	breq	.+48     	; 0x18e2 <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    18b2:	10 9f       	mul	r17, r16
    18b4:	c0 01       	movw	r24, r0
    18b6:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	0e 94 17 03 	call	0x62e	; 0x62e <pvPortMalloc>
    18be:	99 83       	std	Y+1, r25	; 0x01
    18c0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    18c2:	89 2b       	or	r24, r25
    18c4:	31 f0       	breq	.+12     	; 0x18d2 <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    18c6:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    18c8:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    18ca:	61 e0       	ldi	r22, 0x01	; 1
    18cc:	ce 01       	movw	r24, r28
    18ce:	a7 df       	rcall	.-178    	; 0x181e <xQueueGenericReset>
    18d0:	08 c0       	rjmp	.+16     	; 0x18e2 <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    18d2:	ce 01       	movw	r24, r28
    18d4:	0e 94 4c 03 	call	0x698	; 0x698 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    18d8:	c0 e0       	ldi	r28, 0x00	; 0
    18da:	d0 e0       	ldi	r29, 0x00	; 0
    18dc:	02 c0       	rjmp	.+4      	; 0x18e2 <xQueueGenericCreate+0x4e>
    18de:	c0 e0       	ldi	r28, 0x00	; 0
    18e0:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    18e2:	ce 01       	movw	r24, r28
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	1f 91       	pop	r17
    18ea:	0f 91       	pop	r16
    18ec:	08 95       	ret

000018ee <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    18ee:	9f 92       	push	r9
    18f0:	af 92       	push	r10
    18f2:	bf 92       	push	r11
    18f4:	cf 92       	push	r12
    18f6:	df 92       	push	r13
    18f8:	ef 92       	push	r14
    18fa:	ff 92       	push	r15
    18fc:	0f 93       	push	r16
    18fe:	1f 93       	push	r17
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	00 d0       	rcall	.+0      	; 0x1906 <xQueueGenericSend+0x18>
    1906:	1f 92       	push	r1
    1908:	1f 92       	push	r1
    190a:	cd b7       	in	r28, 0x3d	; 61
    190c:	de b7       	in	r29, 0x3e	; 62
    190e:	8c 01       	movw	r16, r24
    1910:	6b 01       	movw	r12, r22
    1912:	5d 83       	std	Y+5, r21	; 0x05
    1914:	4c 83       	std	Y+4, r20	; 0x04
    1916:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1918:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    191a:	99 24       	eor	r9, r9
    191c:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    191e:	7c 01       	movw	r14, r24
    1920:	88 e0       	ldi	r24, 0x08	; 8
    1922:	e8 0e       	add	r14, r24
    1924:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	f8 94       	cli
    192a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    192c:	f8 01       	movw	r30, r16
    192e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1930:	83 8d       	ldd	r24, Z+27	; 0x1b
    1932:	98 17       	cp	r25, r24
    1934:	18 f0       	brcs	.+6      	; 0x193c <xQueueGenericSend+0x4e>
    1936:	f2 e0       	ldi	r31, 0x02	; 2
    1938:	af 12       	cpse	r10, r31
    193a:	15 c0       	rjmp	.+42     	; 0x1966 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    193c:	4a 2d       	mov	r20, r10
    193e:	b6 01       	movw	r22, r12
    1940:	c8 01       	movw	r24, r16
    1942:	ab de       	rcall	.-682    	; 0x169a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1944:	f8 01       	movw	r30, r16
    1946:	91 89       	ldd	r25, Z+17	; 0x11
    1948:	99 23       	and	r25, r25
    194a:	39 f0       	breq	.+14     	; 0x195a <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    194c:	c8 01       	movw	r24, r16
    194e:	41 96       	adiw	r24, 0x11	; 17
    1950:	38 d6       	rcall	.+3184   	; 0x25c2 <xTaskRemoveFromEventList>
    1952:	81 30       	cpi	r24, 0x01	; 1
    1954:	21 f4       	brne	.+8      	; 0x195e <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1956:	dd dd       	rcall	.-1094   	; 0x1512 <vPortYield>
    1958:	02 c0       	rjmp	.+4      	; 0x195e <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    195a:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    195c:	da dd       	rcall	.-1100   	; 0x1512 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	46 c0       	rjmp	.+140    	; 0x19f2 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1966:	ec 81       	ldd	r30, Y+4	; 0x04
    1968:	fd 81       	ldd	r31, Y+5	; 0x05
    196a:	ef 2b       	or	r30, r31
    196c:	21 f4       	brne	.+8      	; 0x1976 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    196e:	0f 90       	pop	r0
    1970:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	3e c0       	rjmp	.+124    	; 0x19f2 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1976:	b1 10       	cpse	r11, r1
    1978:	04 c0       	rjmp	.+8      	; 0x1982 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    197a:	ce 01       	movw	r24, r28
    197c:	01 96       	adiw	r24, 0x01	; 1
    197e:	69 d6       	rcall	.+3282   	; 0x2652 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1980:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1982:	0f 90       	pop	r0
    1984:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1986:	7c d3       	rcall	.+1784   	; 0x2080 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1988:	0f b6       	in	r0, 0x3f	; 63
    198a:	f8 94       	cli
    198c:	0f 92       	push	r0
    198e:	f8 01       	movw	r30, r16
    1990:	85 8d       	ldd	r24, Z+29	; 0x1d
    1992:	8f 3f       	cpi	r24, 0xFF	; 255
    1994:	09 f4       	brne	.+2      	; 0x1998 <xQueueGenericSend+0xaa>
    1996:	15 8e       	std	Z+29, r1	; 0x1d
    1998:	f8 01       	movw	r30, r16
    199a:	86 8d       	ldd	r24, Z+30	; 0x1e
    199c:	8f 3f       	cpi	r24, 0xFF	; 255
    199e:	09 f4       	brne	.+2      	; 0x19a2 <xQueueGenericSend+0xb4>
    19a0:	16 8e       	std	Z+30, r1	; 0x1e
    19a2:	0f 90       	pop	r0
    19a4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19a6:	be 01       	movw	r22, r28
    19a8:	6c 5f       	subi	r22, 0xFC	; 252
    19aa:	7f 4f       	sbci	r23, 0xFF	; 255
    19ac:	ce 01       	movw	r24, r28
    19ae:	01 96       	adiw	r24, 0x01	; 1
    19b0:	5b d6       	rcall	.+3254   	; 0x2668 <xTaskCheckForTimeOut>
    19b2:	81 11       	cpse	r24, r1
    19b4:	1a c0       	rjmp	.+52     	; 0x19ea <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    19b6:	0f b6       	in	r0, 0x3f	; 63
    19b8:	f8 94       	cli
    19ba:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    19bc:	f8 01       	movw	r30, r16
    19be:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    19c0:	0f 90       	pop	r0
    19c2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    19c4:	f8 01       	movw	r30, r16
    19c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    19c8:	98 13       	cpse	r25, r24
    19ca:	0b c0       	rjmp	.+22     	; 0x19e2 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19cc:	6c 81       	ldd	r22, Y+4	; 0x04
    19ce:	7d 81       	ldd	r23, Y+5	; 0x05
    19d0:	c7 01       	movw	r24, r14
    19d2:	cc d5       	rcall	.+2968   	; 0x256c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    19d4:	c8 01       	movw	r24, r16
    19d6:	dd de       	rcall	.-582    	; 0x1792 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    19d8:	26 d4       	rcall	.+2124   	; 0x2226 <xTaskResumeAll>
    19da:	81 11       	cpse	r24, r1
    19dc:	a4 cf       	rjmp	.-184    	; 0x1926 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    19de:	99 dd       	rcall	.-1230   	; 0x1512 <vPortYield>
    19e0:	a2 cf       	rjmp	.-188    	; 0x1926 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19e2:	c8 01       	movw	r24, r16
    19e4:	d6 de       	rcall	.-596    	; 0x1792 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19e6:	1f d4       	rcall	.+2110   	; 0x2226 <xTaskResumeAll>
    19e8:	9e cf       	rjmp	.-196    	; 0x1926 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    19ea:	c8 01       	movw	r24, r16
    19ec:	d2 de       	rcall	.-604    	; 0x1792 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ee:	1b d4       	rcall	.+2102   	; 0x2226 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    19f0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19f2:	0f 90       	pop	r0
    19f4:	0f 90       	pop	r0
    19f6:	0f 90       	pop	r0
    19f8:	0f 90       	pop	r0
    19fa:	0f 90       	pop	r0
    19fc:	df 91       	pop	r29
    19fe:	cf 91       	pop	r28
    1a00:	1f 91       	pop	r17
    1a02:	0f 91       	pop	r16
    1a04:	ff 90       	pop	r15
    1a06:	ef 90       	pop	r14
    1a08:	df 90       	pop	r13
    1a0a:	cf 90       	pop	r12
    1a0c:	bf 90       	pop	r11
    1a0e:	af 90       	pop	r10
    1a10:	9f 90       	pop	r9
    1a12:	08 95       	ret

00001a14 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1a14:	cf 93       	push	r28
    1a16:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1a18:	8f e1       	ldi	r24, 0x1F	; 31
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	0e 94 17 03 	call	0x62e	; 0x62e <pvPortMalloc>
    1a20:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1a22:	00 97       	sbiw	r24, 0x00	; 0
    1a24:	f1 f0       	breq	.+60     	; 0x1a62 <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1a26:	1b 82       	std	Y+3, r1	; 0x03
    1a28:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1a2a:	19 82       	std	Y+1, r1	; 0x01
    1a2c:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    1a2e:	1d 82       	std	Y+5, r1	; 0x05
    1a30:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1a32:	1f 82       	std	Y+7, r1	; 0x07
    1a34:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1a36:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1a3c:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    1a3e:	8f ef       	ldi	r24, 0xFF	; 255
    1a40:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1a42:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1a44:	ce 01       	movw	r24, r28
    1a46:	08 96       	adiw	r24, 0x08	; 8
    1a48:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1a4c:	ce 01       	movw	r24, r28
    1a4e:	41 96       	adiw	r24, 0x11	; 17
    1a50:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1a54:	20 e0       	ldi	r18, 0x00	; 0
    1a56:	40 e0       	ldi	r20, 0x00	; 0
    1a58:	50 e0       	ldi	r21, 0x00	; 0
    1a5a:	60 e0       	ldi	r22, 0x00	; 0
    1a5c:	70 e0       	ldi	r23, 0x00	; 0
    1a5e:	ce 01       	movw	r24, r28
    1a60:	46 df       	rcall	.-372    	; 0x18ee <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1a62:	ce 01       	movw	r24, r28
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	08 95       	ret

00001a6a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a6a:	0f 93       	push	r16
    1a6c:	1f 93       	push	r17
    1a6e:	cf 93       	push	r28
    1a70:	df 93       	push	r29
    1a72:	ec 01       	movw	r28, r24
    1a74:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a76:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a78:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a7a:	98 17       	cp	r25, r24
    1a7c:	10 f0       	brcs	.+4      	; 0x1a82 <xQueueGenericSendFromISR+0x18>
    1a7e:	22 30       	cpi	r18, 0x02	; 2
    1a80:	11 f5       	brne	.+68     	; 0x1ac6 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a82:	42 2f       	mov	r20, r18
    1a84:	ce 01       	movw	r24, r28
    1a86:	09 de       	rcall	.-1006   	; 0x169a <prvCopyDataToQueue>
    1a88:	88 23       	and	r24, r24
    1a8a:	31 f0       	breq	.+12     	; 0x1a98 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1a8c:	01 15       	cp	r16, r1
    1a8e:	11 05       	cpc	r17, r1
    1a90:	19 f0       	breq	.+6      	; 0x1a98 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	f8 01       	movw	r30, r16
    1a96:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a9a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a9c:	79 f4       	brne	.+30     	; 0x1abc <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a9e:	89 89       	ldd	r24, Y+17	; 0x11
    1aa0:	88 23       	and	r24, r24
    1aa2:	99 f0       	breq	.+38     	; 0x1aca <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	41 96       	adiw	r24, 0x11	; 17
    1aa8:	8c d5       	rcall	.+2840   	; 0x25c2 <xTaskRemoveFromEventList>
    1aaa:	88 23       	and	r24, r24
    1aac:	81 f0       	breq	.+32     	; 0x1ace <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1aae:	01 15       	cp	r16, r1
    1ab0:	11 05       	cpc	r17, r1
    1ab2:	79 f0       	breq	.+30     	; 0x1ad2 <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	80 83       	st	Z, r24
    1aba:	0c c0       	rjmp	.+24     	; 0x1ad4 <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1abc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1abe:	8f 5f       	subi	r24, 0xFF	; 255
    1ac0:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	07 c0       	rjmp	.+14     	; 0x1ad4 <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	05 c0       	rjmp	.+10     	; 0x1ad4 <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1aca:	81 e0       	ldi	r24, 0x01	; 1
    1acc:	03 c0       	rjmp	.+6      	; 0x1ad4 <xQueueGenericSendFromISR+0x6a>
    1ace:	81 e0       	ldi	r24, 0x01	; 1
    1ad0:	01 c0       	rjmp	.+2      	; 0x1ad4 <xQueueGenericSendFromISR+0x6a>
    1ad2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	08 95       	ret

00001ade <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1ade:	9f 92       	push	r9
    1ae0:	af 92       	push	r10
    1ae2:	bf 92       	push	r11
    1ae4:	cf 92       	push	r12
    1ae6:	df 92       	push	r13
    1ae8:	ef 92       	push	r14
    1aea:	ff 92       	push	r15
    1aec:	0f 93       	push	r16
    1aee:	1f 93       	push	r17
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	00 d0       	rcall	.+0      	; 0x1af6 <xQueueGenericReceive+0x18>
    1af6:	1f 92       	push	r1
    1af8:	1f 92       	push	r1
    1afa:	cd b7       	in	r28, 0x3d	; 61
    1afc:	de b7       	in	r29, 0x3e	; 62
    1afe:	8c 01       	movw	r16, r24
    1b00:	6b 01       	movw	r12, r22
    1b02:	5d 83       	std	Y+5, r21	; 0x05
    1b04:	4c 83       	std	Y+4, r20	; 0x04
    1b06:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1b08:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1b0a:	99 24       	eor	r9, r9
    1b0c:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b0e:	7c 01       	movw	r14, r24
    1b10:	81 e1       	ldi	r24, 0x11	; 17
    1b12:	e8 0e       	add	r14, r24
    1b14:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b20:	88 23       	and	r24, r24
    1b22:	69 f1       	breq	.+90     	; 0x1b7e <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1b24:	e6 80       	ldd	r14, Z+6	; 0x06
    1b26:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b28:	b6 01       	movw	r22, r12
    1b2a:	c8 01       	movw	r24, r16
    1b2c:	18 de       	rcall	.-976    	; 0x175e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b2e:	b1 10       	cpse	r11, r1
    1b30:	17 c0       	rjmp	.+46     	; 0x1b60 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1b32:	f8 01       	movw	r30, r16
    1b34:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b36:	81 50       	subi	r24, 0x01	; 1
    1b38:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b3a:	80 81       	ld	r24, Z
    1b3c:	91 81       	ldd	r25, Z+1	; 0x01
    1b3e:	89 2b       	or	r24, r25
    1b40:	21 f4       	brne	.+8      	; 0x1b4a <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1b42:	6b d6       	rcall	.+3286   	; 0x281a <pvTaskIncrementMutexHeldCount>
    1b44:	f8 01       	movw	r30, r16
    1b46:	93 83       	std	Z+3, r25	; 0x03
    1b48:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	80 85       	ldd	r24, Z+8	; 0x08
    1b4e:	88 23       	and	r24, r24
    1b50:	91 f0       	breq	.+36     	; 0x1b76 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1b52:	c8 01       	movw	r24, r16
    1b54:	08 96       	adiw	r24, 0x08	; 8
    1b56:	35 d5       	rcall	.+2666   	; 0x25c2 <xTaskRemoveFromEventList>
    1b58:	81 30       	cpi	r24, 0x01	; 1
    1b5a:	69 f4       	brne	.+26     	; 0x1b76 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1b5c:	da dc       	rcall	.-1612   	; 0x1512 <vPortYield>
    1b5e:	0b c0       	rjmp	.+22     	; 0x1b76 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1b60:	f8 01       	movw	r30, r16
    1b62:	f7 82       	std	Z+7, r15	; 0x07
    1b64:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b66:	81 89       	ldd	r24, Z+17	; 0x11
    1b68:	88 23       	and	r24, r24
    1b6a:	29 f0       	breq	.+10     	; 0x1b76 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b6c:	c8 01       	movw	r24, r16
    1b6e:	41 96       	adiw	r24, 0x11	; 17
    1b70:	28 d5       	rcall	.+2640   	; 0x25c2 <xTaskRemoveFromEventList>
    1b72:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b74:	ce dc       	rcall	.-1636   	; 0x1512 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b76:	0f 90       	pop	r0
    1b78:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	52 c0       	rjmp	.+164    	; 0x1c22 <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b7e:	4c 81       	ldd	r20, Y+4	; 0x04
    1b80:	5d 81       	ldd	r21, Y+5	; 0x05
    1b82:	45 2b       	or	r20, r21
    1b84:	21 f4       	brne	.+8      	; 0x1b8e <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b86:	0f 90       	pop	r0
    1b88:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	4a c0       	rjmp	.+148    	; 0x1c22 <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b8e:	a1 10       	cpse	r10, r1
    1b90:	04 c0       	rjmp	.+8      	; 0x1b9a <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b92:	ce 01       	movw	r24, r28
    1b94:	01 96       	adiw	r24, 0x01	; 1
    1b96:	5d d5       	rcall	.+2746   	; 0x2652 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b98:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b9e:	70 d2       	rcall	.+1248   	; 0x2080 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ba0:	0f b6       	in	r0, 0x3f	; 63
    1ba2:	f8 94       	cli
    1ba4:	0f 92       	push	r0
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1baa:	8f 3f       	cpi	r24, 0xFF	; 255
    1bac:	09 f4       	brne	.+2      	; 0x1bb0 <xQueueGenericReceive+0xd2>
    1bae:	15 8e       	std	Z+29, r1	; 0x1d
    1bb0:	f8 01       	movw	r30, r16
    1bb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bb4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <xQueueGenericReceive+0xdc>
    1bb8:	16 8e       	std	Z+30, r1	; 0x1e
    1bba:	0f 90       	pop	r0
    1bbc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1bbe:	be 01       	movw	r22, r28
    1bc0:	6c 5f       	subi	r22, 0xFC	; 252
    1bc2:	7f 4f       	sbci	r23, 0xFF	; 255
    1bc4:	ce 01       	movw	r24, r28
    1bc6:	01 96       	adiw	r24, 0x01	; 1
    1bc8:	4f d5       	rcall	.+2718   	; 0x2668 <xTaskCheckForTimeOut>
    1bca:	81 11       	cpse	r24, r1
    1bcc:	26 c0       	rjmp	.+76     	; 0x1c1a <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1bd4:	f8 01       	movw	r30, r16
    1bd6:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1bd8:	0f 90       	pop	r0
    1bda:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1bdc:	81 11       	cpse	r24, r1
    1bde:	19 c0       	rjmp	.+50     	; 0x1c12 <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1be0:	f8 01       	movw	r30, r16
    1be2:	80 81       	ld	r24, Z
    1be4:	91 81       	ldd	r25, Z+1	; 0x01
    1be6:	89 2b       	or	r24, r25
    1be8:	49 f4       	brne	.+18     	; 0x1bfc <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1bf0:	f8 01       	movw	r30, r16
    1bf2:	82 81       	ldd	r24, Z+2	; 0x02
    1bf4:	93 81       	ldd	r25, Z+3	; 0x03
    1bf6:	74 d5       	rcall	.+2792   	; 0x26e0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1bf8:	0f 90       	pop	r0
    1bfa:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1bfc:	6c 81       	ldd	r22, Y+4	; 0x04
    1bfe:	7d 81       	ldd	r23, Y+5	; 0x05
    1c00:	c7 01       	movw	r24, r14
    1c02:	b4 d4       	rcall	.+2408   	; 0x256c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c04:	c8 01       	movw	r24, r16
    1c06:	c5 dd       	rcall	.-1142   	; 0x1792 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c08:	0e d3       	rcall	.+1564   	; 0x2226 <xTaskResumeAll>
    1c0a:	81 11       	cpse	r24, r1
    1c0c:	84 cf       	rjmp	.-248    	; 0x1b16 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1c0e:	81 dc       	rcall	.-1790   	; 0x1512 <vPortYield>
    1c10:	82 cf       	rjmp	.-252    	; 0x1b16 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c12:	c8 01       	movw	r24, r16
    1c14:	be dd       	rcall	.-1156   	; 0x1792 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c16:	07 d3       	rcall	.+1550   	; 0x2226 <xTaskResumeAll>
    1c18:	7e cf       	rjmp	.-260    	; 0x1b16 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c1a:	c8 01       	movw	r24, r16
    1c1c:	ba dd       	rcall	.-1164   	; 0x1792 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1c1e:	03 d3       	rcall	.+1542   	; 0x2226 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1c20:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1c22:	0f 90       	pop	r0
    1c24:	0f 90       	pop	r0
    1c26:	0f 90       	pop	r0
    1c28:	0f 90       	pop	r0
    1c2a:	0f 90       	pop	r0
    1c2c:	df 91       	pop	r29
    1c2e:	cf 91       	pop	r28
    1c30:	1f 91       	pop	r17
    1c32:	0f 91       	pop	r16
    1c34:	ff 90       	pop	r15
    1c36:	ef 90       	pop	r14
    1c38:	df 90       	pop	r13
    1c3a:	cf 90       	pop	r12
    1c3c:	bf 90       	pop	r11
    1c3e:	af 90       	pop	r10
    1c40:	9f 90       	pop	r9
    1c42:	08 95       	ret

00001c44 <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1c44:	fc 01       	movw	r30, r24
    1c46:	71 83       	std	Z+1, r23	; 0x01
    1c48:	60 83       	st	Z, r22
    1c4a:	42 83       	std	Z+2, r20	; 0x02
    1c4c:	14 82       	std	Z+4, r1	; 0x04
    1c4e:	13 82       	std	Z+3, r1	; 0x03
    1c50:	08 95       	ret

00001c52 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1c52:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1c54:	94 81       	ldd	r25, Z+4	; 0x04
    1c56:	a0 81       	ld	r26, Z
    1c58:	b1 81       	ldd	r27, Z+1	; 0x01
    1c5a:	a9 0f       	add	r26, r25
    1c5c:	b1 1d       	adc	r27, r1
    1c5e:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1c60:	9f 5f       	subi	r25, 0xFF	; 255
    1c62:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1c64:	22 81       	ldd	r18, Z+2	; 0x02
    1c66:	92 17       	cp	r25, r18
    1c68:	10 f0       	brcs	.+4      	; 0x1c6e <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1c6a:	92 1b       	sub	r25, r18
    1c6c:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c6e:	93 81       	ldd	r25, Z+3	; 0x03
    1c70:	91 50       	subi	r25, 0x01	; 1
    1c72:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c74:	08 95       	ret

00001c76 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c76:	fc 01       	movw	r30, r24
    1c78:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c7a:	83 81       	ldd	r24, Z+3	; 0x03
    1c7c:	22 81       	ldd	r18, Z+2	; 0x02
    1c7e:	82 17       	cp	r24, r18
    1c80:	80 f4       	brcc	.+32     	; 0x1ca2 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c82:	34 81       	ldd	r19, Z+4	; 0x04
    1c84:	90 e0       	ldi	r25, 0x00	; 0
    1c86:	83 0f       	add	r24, r19
    1c88:	91 1d       	adc	r25, r1
    1c8a:	62 2f       	mov	r22, r18
    1c8c:	70 e0       	ldi	r23, 0x00	; 0
    1c8e:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <__divmodhi4>
    1c92:	a0 81       	ld	r26, Z
    1c94:	b1 81       	ldd	r27, Z+1	; 0x01
    1c96:	a8 0f       	add	r26, r24
    1c98:	b9 1f       	adc	r27, r25
    1c9a:	4c 93       	st	X, r20
            ring->rLength++;
    1c9c:	83 81       	ldd	r24, Z+3	; 0x03
    1c9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ca0:	83 83       	std	Z+3, r24	; 0x03
    1ca2:	08 95       	ret

00001ca4 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1ca4:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1ca6:	81 e0       	ldi	r24, 0x01	; 1
    1ca8:	22 81       	ldd	r18, Z+2	; 0x02
    1caa:	93 81       	ldd	r25, Z+3	; 0x03
    1cac:	29 13       	cpse	r18, r25
    1cae:	80 e0       	ldi	r24, 0x00	; 0
}
    1cb0:	08 95       	ret

00001cb2 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1cb2:	21 e0       	ldi	r18, 0x01	; 1
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	83 81       	ldd	r24, Z+3	; 0x03
    1cb8:	81 11       	cpse	r24, r1
    1cba:	01 c0       	rjmp	.+2      	; 0x1cbe <ringBufferNotEmpty+0xc>
    1cbc:	20 e0       	ldi	r18, 0x00	; 0
}
    1cbe:	82 2f       	mov	r24, r18
    1cc0:	08 95       	ret

00001cc2 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1cc2:	e0 91 4e 08 	lds	r30, 0x084E
    1cc6:	f0 91 4f 08 	lds	r31, 0x084F
    1cca:	80 81       	ld	r24, Z
    1ccc:	81 11       	cpse	r24, r1
    1cce:	07 c0       	rjmp	.+14     	; 0x1cde <prvResetNextTaskUnblockTime+0x1c>
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	9f ef       	ldi	r25, 0xFF	; 255
    1cd4:	90 93 06 02 	sts	0x0206, r25
    1cd8:	80 93 05 02 	sts	0x0205, r24
    1cdc:	08 95       	ret
    1cde:	e0 91 4e 08 	lds	r30, 0x084E
    1ce2:	f0 91 4f 08 	lds	r31, 0x084F
    1ce6:	05 80       	ldd	r0, Z+5	; 0x05
    1ce8:	f6 81       	ldd	r31, Z+6	; 0x06
    1cea:	e0 2d       	mov	r30, r0
    1cec:	06 80       	ldd	r0, Z+6	; 0x06
    1cee:	f7 81       	ldd	r31, Z+7	; 0x07
    1cf0:	e0 2d       	mov	r30, r0
    1cf2:	82 81       	ldd	r24, Z+2	; 0x02
    1cf4:	93 81       	ldd	r25, Z+3	; 0x03
    1cf6:	90 93 06 02 	sts	0x0206, r25
    1cfa:	80 93 05 02 	sts	0x0205, r24
    1cfe:	08 95       	ret

00001d00 <prvAddCurrentTaskToDelayedList>:
    1d00:	cf 93       	push	r28
    1d02:	df 93       	push	r29
    1d04:	ec 01       	movw	r28, r24
    1d06:	e0 91 8f 08 	lds	r30, 0x088F
    1d0a:	f0 91 90 08 	lds	r31, 0x0890
    1d0e:	93 83       	std	Z+3, r25	; 0x03
    1d10:	82 83       	std	Z+2, r24	; 0x02
    1d12:	80 91 2d 08 	lds	r24, 0x082D
    1d16:	90 91 2e 08 	lds	r25, 0x082E
    1d1a:	c8 17       	cp	r28, r24
    1d1c:	d9 07       	cpc	r29, r25
    1d1e:	68 f4       	brcc	.+26     	; 0x1d3a <prvAddCurrentTaskToDelayedList+0x3a>
    1d20:	60 91 8f 08 	lds	r22, 0x088F
    1d24:	70 91 90 08 	lds	r23, 0x0890
    1d28:	80 91 4c 08 	lds	r24, 0x084C
    1d2c:	90 91 4d 08 	lds	r25, 0x084D
    1d30:	6e 5f       	subi	r22, 0xFE	; 254
    1d32:	7f 4f       	sbci	r23, 0xFF	; 255
    1d34:	0e 94 80 03 	call	0x700	; 0x700 <vListInsert>
    1d38:	17 c0       	rjmp	.+46     	; 0x1d68 <prvAddCurrentTaskToDelayedList+0x68>
    1d3a:	60 91 8f 08 	lds	r22, 0x088F
    1d3e:	70 91 90 08 	lds	r23, 0x0890
    1d42:	80 91 4e 08 	lds	r24, 0x084E
    1d46:	90 91 4f 08 	lds	r25, 0x084F
    1d4a:	6e 5f       	subi	r22, 0xFE	; 254
    1d4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d4e:	0e 94 80 03 	call	0x700	; 0x700 <vListInsert>
    1d52:	80 91 05 02 	lds	r24, 0x0205
    1d56:	90 91 06 02 	lds	r25, 0x0206
    1d5a:	c8 17       	cp	r28, r24
    1d5c:	d9 07       	cpc	r29, r25
    1d5e:	20 f4       	brcc	.+8      	; 0x1d68 <prvAddCurrentTaskToDelayedList+0x68>
    1d60:	d0 93 06 02 	sts	0x0206, r29
    1d64:	c0 93 05 02 	sts	0x0205, r28
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	08 95       	ret

00001d6e <xTaskGenericCreate>:
    1d6e:	4f 92       	push	r4
    1d70:	5f 92       	push	r5
    1d72:	6f 92       	push	r6
    1d74:	7f 92       	push	r7
    1d76:	8f 92       	push	r8
    1d78:	9f 92       	push	r9
    1d7a:	af 92       	push	r10
    1d7c:	bf 92       	push	r11
    1d7e:	cf 92       	push	r12
    1d80:	df 92       	push	r13
    1d82:	ef 92       	push	r14
    1d84:	ff 92       	push	r15
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	4c 01       	movw	r8, r24
    1d90:	5b 01       	movw	r10, r22
    1d92:	2a 01       	movw	r4, r20
    1d94:	39 01       	movw	r6, r18
    1d96:	83 e2       	ldi	r24, 0x23	; 35
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	0e 94 17 03 	call	0x62e	; 0x62e <pvPortMalloc>
    1d9e:	ec 01       	movw	r28, r24
    1da0:	00 97       	sbiw	r24, 0x00	; 0
    1da2:	09 f4       	brne	.+2      	; 0x1da6 <xTaskGenericCreate+0x38>
    1da4:	e7 c0       	rjmp	.+462    	; 0x1f74 <xTaskGenericCreate+0x206>
    1da6:	c1 14       	cp	r12, r1
    1da8:	d1 04       	cpc	r13, r1
    1daa:	09 f0       	breq	.+2      	; 0x1dae <xTaskGenericCreate+0x40>
    1dac:	cc c0       	rjmp	.+408    	; 0x1f46 <xTaskGenericCreate+0x1d8>
    1dae:	c2 01       	movw	r24, r4
    1db0:	0e 94 17 03 	call	0x62e	; 0x62e <pvPortMalloc>
    1db4:	98 8f       	std	Y+24, r25	; 0x18
    1db6:	8f 8b       	std	Y+23, r24	; 0x17
    1db8:	89 2b       	or	r24, r25
    1dba:	09 f0       	breq	.+2      	; 0x1dbe <xTaskGenericCreate+0x50>
    1dbc:	c6 c0       	rjmp	.+396    	; 0x1f4a <xTaskGenericCreate+0x1dc>
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	0e 94 4c 03 	call	0x698	; 0x698 <vPortFree>
    1dc4:	d7 c0       	rjmp	.+430    	; 0x1f74 <xTaskGenericCreate+0x206>
    1dc6:	cf 01       	movw	r24, r30
    1dc8:	31 91       	ld	r19, Z+
    1dca:	da 01       	movw	r26, r20
    1dcc:	3d 93       	st	X+, r19
    1dce:	ad 01       	movw	r20, r26
    1dd0:	dc 01       	movw	r26, r24
    1dd2:	8c 91       	ld	r24, X
    1dd4:	88 23       	and	r24, r24
    1dd6:	11 f0       	breq	.+4      	; 0x1ddc <xTaskGenericCreate+0x6e>
    1dd8:	21 50       	subi	r18, 0x01	; 1
    1dda:	a9 f7       	brne	.-22     	; 0x1dc6 <xTaskGenericCreate+0x58>
    1ddc:	18 a2       	std	Y+32, r1	; 0x20
    1dde:	10 2f       	mov	r17, r16
    1de0:	05 30       	cpi	r16, 0x05	; 5
    1de2:	08 f0       	brcs	.+2      	; 0x1de6 <xTaskGenericCreate+0x78>
    1de4:	14 e0       	ldi	r17, 0x04	; 4
    1de6:	1e 8b       	std	Y+22, r17	; 0x16
    1de8:	19 a3       	std	Y+33, r17	; 0x21
    1dea:	1a a2       	std	Y+34, r1	; 0x22
    1dec:	5e 01       	movw	r10, r28
    1dee:	b2 e0       	ldi	r27, 0x02	; 2
    1df0:	ab 0e       	add	r10, r27
    1df2:	b1 1c       	adc	r11, r1
    1df4:	c5 01       	movw	r24, r10
    1df6:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInitialiseItem>
    1dfa:	ce 01       	movw	r24, r28
    1dfc:	0c 96       	adiw	r24, 0x0c	; 12
    1dfe:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <vListInitialiseItem>
    1e02:	d9 87       	std	Y+9, r29	; 0x09
    1e04:	c8 87       	std	Y+8, r28	; 0x08
    1e06:	85 e0       	ldi	r24, 0x05	; 5
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	81 1b       	sub	r24, r17
    1e0c:	91 09       	sbc	r25, r1
    1e0e:	9d 87       	std	Y+13, r25	; 0x0d
    1e10:	8c 87       	std	Y+12, r24	; 0x0c
    1e12:	db 8b       	std	Y+19, r29	; 0x13
    1e14:	ca 8b       	std	Y+18, r28	; 0x12
    1e16:	a3 01       	movw	r20, r6
    1e18:	b4 01       	movw	r22, r8
    1e1a:	c6 01       	movw	r24, r12
    1e1c:	cb da       	rcall	.-2666   	; 0x13b4 <pxPortInitialiseStack>
    1e1e:	99 83       	std	Y+1, r25	; 0x01
    1e20:	88 83       	st	Y, r24
    1e22:	e1 14       	cp	r14, r1
    1e24:	f1 04       	cpc	r15, r1
    1e26:	19 f0       	breq	.+6      	; 0x1e2e <xTaskGenericCreate+0xc0>
    1e28:	f7 01       	movw	r30, r14
    1e2a:	d1 83       	std	Z+1, r29	; 0x01
    1e2c:	c0 83       	st	Z, r28
    1e2e:	0f b6       	in	r0, 0x3f	; 63
    1e30:	f8 94       	cli
    1e32:	0f 92       	push	r0
    1e34:	80 91 2f 08 	lds	r24, 0x082F
    1e38:	8f 5f       	subi	r24, 0xFF	; 255
    1e3a:	80 93 2f 08 	sts	0x082F, r24
    1e3e:	80 91 8f 08 	lds	r24, 0x088F
    1e42:	90 91 90 08 	lds	r25, 0x0890
    1e46:	89 2b       	or	r24, r25
    1e48:	09 f0       	breq	.+2      	; 0x1e4c <xTaskGenericCreate+0xde>
    1e4a:	3f c0       	rjmp	.+126    	; 0x1eca <xTaskGenericCreate+0x15c>
    1e4c:	d0 93 90 08 	sts	0x0890, r29
    1e50:	c0 93 8f 08 	sts	0x088F, r28
    1e54:	80 91 2f 08 	lds	r24, 0x082F
    1e58:	81 30       	cpi	r24, 0x01	; 1
    1e5a:	09 f0       	breq	.+2      	; 0x1e5e <xTaskGenericCreate+0xf0>
    1e5c:	45 c0       	rjmp	.+138    	; 0x1ee8 <xTaskGenericCreate+0x17a>
    1e5e:	0f 2e       	mov	r0, r31
    1e60:	f2 e6       	ldi	r31, 0x62	; 98
    1e62:	ef 2e       	mov	r14, r31
    1e64:	f8 e0       	ldi	r31, 0x08	; 8
    1e66:	ff 2e       	mov	r15, r31
    1e68:	f0 2d       	mov	r31, r0
    1e6a:	0f 2e       	mov	r0, r31
    1e6c:	ff e8       	ldi	r31, 0x8F	; 143
    1e6e:	cf 2e       	mov	r12, r31
    1e70:	f8 e0       	ldi	r31, 0x08	; 8
    1e72:	df 2e       	mov	r13, r31
    1e74:	f0 2d       	mov	r31, r0
    1e76:	c7 01       	movw	r24, r14
    1e78:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1e7c:	f9 e0       	ldi	r31, 0x09	; 9
    1e7e:	ef 0e       	add	r14, r31
    1e80:	f1 1c       	adc	r15, r1
    1e82:	ec 14       	cp	r14, r12
    1e84:	fd 04       	cpc	r15, r13
    1e86:	b9 f7       	brne	.-18     	; 0x1e76 <xTaskGenericCreate+0x108>
    1e88:	89 e5       	ldi	r24, 0x59	; 89
    1e8a:	98 e0       	ldi	r25, 0x08	; 8
    1e8c:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1e90:	80 e5       	ldi	r24, 0x50	; 80
    1e92:	98 e0       	ldi	r25, 0x08	; 8
    1e94:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1e98:	83 e4       	ldi	r24, 0x43	; 67
    1e9a:	98 e0       	ldi	r25, 0x08	; 8
    1e9c:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1ea0:	8a e3       	ldi	r24, 0x3A	; 58
    1ea2:	98 e0       	ldi	r25, 0x08	; 8
    1ea4:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1ea8:	80 e3       	ldi	r24, 0x30	; 48
    1eaa:	98 e0       	ldi	r25, 0x08	; 8
    1eac:	0e 94 4d 03 	call	0x69a	; 0x69a <vListInitialise>
    1eb0:	89 e5       	ldi	r24, 0x59	; 89
    1eb2:	98 e0       	ldi	r25, 0x08	; 8
    1eb4:	90 93 4f 08 	sts	0x084F, r25
    1eb8:	80 93 4e 08 	sts	0x084E, r24
    1ebc:	80 e5       	ldi	r24, 0x50	; 80
    1ebe:	98 e0       	ldi	r25, 0x08	; 8
    1ec0:	90 93 4d 08 	sts	0x084D, r25
    1ec4:	80 93 4c 08 	sts	0x084C, r24
    1ec8:	0f c0       	rjmp	.+30     	; 0x1ee8 <xTaskGenericCreate+0x17a>
    1eca:	80 91 2b 08 	lds	r24, 0x082B
    1ece:	81 11       	cpse	r24, r1
    1ed0:	0b c0       	rjmp	.+22     	; 0x1ee8 <xTaskGenericCreate+0x17a>
    1ed2:	e0 91 8f 08 	lds	r30, 0x088F
    1ed6:	f0 91 90 08 	lds	r31, 0x0890
    1eda:	86 89       	ldd	r24, Z+22	; 0x16
    1edc:	08 17       	cp	r16, r24
    1ede:	20 f0       	brcs	.+8      	; 0x1ee8 <xTaskGenericCreate+0x17a>
    1ee0:	d0 93 90 08 	sts	0x0890, r29
    1ee4:	c0 93 8f 08 	sts	0x088F, r28
    1ee8:	80 91 27 08 	lds	r24, 0x0827
    1eec:	8f 5f       	subi	r24, 0xFF	; 255
    1eee:	80 93 27 08 	sts	0x0827, r24
    1ef2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ef4:	90 91 2c 08 	lds	r25, 0x082C
    1ef8:	98 17       	cp	r25, r24
    1efa:	10 f4       	brcc	.+4      	; 0x1f00 <xTaskGenericCreate+0x192>
    1efc:	80 93 2c 08 	sts	0x082C, r24
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	9c 01       	movw	r18, r24
    1f04:	22 0f       	add	r18, r18
    1f06:	33 1f       	adc	r19, r19
    1f08:	22 0f       	add	r18, r18
    1f0a:	33 1f       	adc	r19, r19
    1f0c:	22 0f       	add	r18, r18
    1f0e:	33 1f       	adc	r19, r19
    1f10:	82 0f       	add	r24, r18
    1f12:	93 1f       	adc	r25, r19
    1f14:	b5 01       	movw	r22, r10
    1f16:	8e 59       	subi	r24, 0x9E	; 158
    1f18:	97 4f       	sbci	r25, 0xF7	; 247
    1f1a:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    1f1e:	0f 90       	pop	r0
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	80 91 2b 08 	lds	r24, 0x082B
    1f26:	88 23       	and	r24, r24
    1f28:	51 f0       	breq	.+20     	; 0x1f3e <xTaskGenericCreate+0x1d0>
    1f2a:	e0 91 8f 08 	lds	r30, 0x088F
    1f2e:	f0 91 90 08 	lds	r31, 0x0890
    1f32:	86 89       	ldd	r24, Z+22	; 0x16
    1f34:	80 17       	cp	r24, r16
    1f36:	28 f4       	brcc	.+10     	; 0x1f42 <xTaskGenericCreate+0x1d4>
    1f38:	ec da       	rcall	.-2600   	; 0x1512 <vPortYield>
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	1c c0       	rjmp	.+56     	; 0x1f76 <xTaskGenericCreate+0x208>
    1f3e:	81 e0       	ldi	r24, 0x01	; 1
    1f40:	1a c0       	rjmp	.+52     	; 0x1f76 <xTaskGenericCreate+0x208>
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	18 c0       	rjmp	.+48     	; 0x1f76 <xTaskGenericCreate+0x208>
    1f46:	d8 8e       	std	Y+24, r13	; 0x18
    1f48:	cf 8a       	std	Y+23, r12	; 0x17
    1f4a:	81 e0       	ldi	r24, 0x01	; 1
    1f4c:	48 1a       	sub	r4, r24
    1f4e:	51 08       	sbc	r5, r1
    1f50:	cf 88       	ldd	r12, Y+23	; 0x17
    1f52:	d8 8c       	ldd	r13, Y+24	; 0x18
    1f54:	c4 0c       	add	r12, r4
    1f56:	d5 1c       	adc	r13, r5
    1f58:	d5 01       	movw	r26, r10
    1f5a:	8c 91       	ld	r24, X
    1f5c:	89 8f       	std	Y+25, r24	; 0x19
    1f5e:	8c 91       	ld	r24, X
    1f60:	88 23       	and	r24, r24
    1f62:	09 f4       	brne	.+2      	; 0x1f66 <xTaskGenericCreate+0x1f8>
    1f64:	3b cf       	rjmp	.-394    	; 0x1ddc <xTaskGenericCreate+0x6e>
    1f66:	ae 01       	movw	r20, r28
    1f68:	46 5e       	subi	r20, 0xE6	; 230
    1f6a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f6c:	f5 01       	movw	r30, r10
    1f6e:	31 96       	adiw	r30, 0x01	; 1
    1f70:	27 e0       	ldi	r18, 0x07	; 7
    1f72:	29 cf       	rjmp	.-430    	; 0x1dc6 <xTaskGenericCreate+0x58>
    1f74:	8f ef       	ldi	r24, 0xFF	; 255
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	1f 91       	pop	r17
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	df 90       	pop	r13
    1f84:	cf 90       	pop	r12
    1f86:	bf 90       	pop	r11
    1f88:	af 90       	pop	r10
    1f8a:	9f 90       	pop	r9
    1f8c:	8f 90       	pop	r8
    1f8e:	7f 90       	pop	r7
    1f90:	6f 90       	pop	r6
    1f92:	5f 90       	pop	r5
    1f94:	4f 90       	pop	r4
    1f96:	08 95       	ret

00001f98 <vTaskResume>:
    1f98:	0f 93       	push	r16
    1f9a:	1f 93       	push	r17
    1f9c:	cf 93       	push	r28
    1f9e:	df 93       	push	r29
    1fa0:	ec 01       	movw	r28, r24
    1fa2:	00 97       	sbiw	r24, 0x00	; 0
    1fa4:	09 f4       	brne	.+2      	; 0x1fa8 <vTaskResume+0x10>
    1fa6:	3e c0       	rjmp	.+124    	; 0x2024 <vTaskResume+0x8c>
    1fa8:	80 91 8f 08 	lds	r24, 0x088F
    1fac:	90 91 90 08 	lds	r25, 0x0890
    1fb0:	c8 17       	cp	r28, r24
    1fb2:	d9 07       	cpc	r29, r25
    1fb4:	b9 f1       	breq	.+110    	; 0x2024 <vTaskResume+0x8c>
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	0f 92       	push	r0
    1fbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fc0:	80 53       	subi	r24, 0x30	; 48
    1fc2:	98 40       	sbci	r25, 0x08	; 8
    1fc4:	69 f5       	brne	.+90     	; 0x2020 <vTaskResume+0x88>
    1fc6:	8c 89       	ldd	r24, Y+20	; 0x14
    1fc8:	9d 89       	ldd	r25, Y+21	; 0x15
    1fca:	28 e0       	ldi	r18, 0x08	; 8
    1fcc:	83 34       	cpi	r24, 0x43	; 67
    1fce:	92 07       	cpc	r25, r18
    1fd0:	39 f1       	breq	.+78     	; 0x2020 <vTaskResume+0x88>
    1fd2:	89 2b       	or	r24, r25
    1fd4:	29 f5       	brne	.+74     	; 0x2020 <vTaskResume+0x88>
    1fd6:	8e 01       	movw	r16, r28
    1fd8:	0e 5f       	subi	r16, 0xFE	; 254
    1fda:	1f 4f       	sbci	r17, 0xFF	; 255
    1fdc:	c8 01       	movw	r24, r16
    1fde:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    1fe2:	8e 89       	ldd	r24, Y+22	; 0x16
    1fe4:	90 91 2c 08 	lds	r25, 0x082C
    1fe8:	98 17       	cp	r25, r24
    1fea:	10 f4       	brcc	.+4      	; 0x1ff0 <vTaskResume+0x58>
    1fec:	80 93 2c 08 	sts	0x082C, r24
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	9c 01       	movw	r18, r24
    1ff4:	22 0f       	add	r18, r18
    1ff6:	33 1f       	adc	r19, r19
    1ff8:	22 0f       	add	r18, r18
    1ffa:	33 1f       	adc	r19, r19
    1ffc:	22 0f       	add	r18, r18
    1ffe:	33 1f       	adc	r19, r19
    2000:	82 0f       	add	r24, r18
    2002:	93 1f       	adc	r25, r19
    2004:	b8 01       	movw	r22, r16
    2006:	8e 59       	subi	r24, 0x9E	; 158
    2008:	97 4f       	sbci	r25, 0xF7	; 247
    200a:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    200e:	e0 91 8f 08 	lds	r30, 0x088F
    2012:	f0 91 90 08 	lds	r31, 0x0890
    2016:	9e 89       	ldd	r25, Y+22	; 0x16
    2018:	86 89       	ldd	r24, Z+22	; 0x16
    201a:	98 17       	cp	r25, r24
    201c:	08 f0       	brcs	.+2      	; 0x2020 <vTaskResume+0x88>
    201e:	79 da       	rcall	.-2830   	; 0x1512 <vPortYield>
    2020:	0f 90       	pop	r0
    2022:	0f be       	out	0x3f, r0	; 63
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	1f 91       	pop	r17
    202a:	0f 91       	pop	r16
    202c:	08 95       	ret

0000202e <vTaskStartScheduler>:
    202e:	af 92       	push	r10
    2030:	bf 92       	push	r11
    2032:	cf 92       	push	r12
    2034:	df 92       	push	r13
    2036:	ef 92       	push	r14
    2038:	ff 92       	push	r15
    203a:	0f 93       	push	r16
    203c:	a1 2c       	mov	r10, r1
    203e:	b1 2c       	mov	r11, r1
    2040:	c1 2c       	mov	r12, r1
    2042:	d1 2c       	mov	r13, r1
    2044:	e1 2c       	mov	r14, r1
    2046:	f1 2c       	mov	r15, r1
    2048:	00 e0       	ldi	r16, 0x00	; 0
    204a:	20 e0       	ldi	r18, 0x00	; 0
    204c:	30 e0       	ldi	r19, 0x00	; 0
    204e:	45 e5       	ldi	r20, 0x55	; 85
    2050:	50 e0       	ldi	r21, 0x00	; 0
    2052:	63 e3       	ldi	r22, 0x33	; 51
    2054:	72 e0       	ldi	r23, 0x02	; 2
    2056:	82 ed       	ldi	r24, 0xD2	; 210
    2058:	91 e1       	ldi	r25, 0x11	; 17
    205a:	89 de       	rcall	.-750    	; 0x1d6e <xTaskGenericCreate>
    205c:	81 30       	cpi	r24, 0x01	; 1
    205e:	41 f4       	brne	.+16     	; 0x2070 <vTaskStartScheduler+0x42>
    2060:	f8 94       	cli
    2062:	80 93 2b 08 	sts	0x082B, r24
    2066:	10 92 2e 08 	sts	0x082E, r1
    206a:	10 92 2d 08 	sts	0x082D, r1
    206e:	14 da       	rcall	.-3032   	; 0x1498 <xPortStartScheduler>
    2070:	0f 91       	pop	r16
    2072:	ff 90       	pop	r15
    2074:	ef 90       	pop	r14
    2076:	df 90       	pop	r13
    2078:	cf 90       	pop	r12
    207a:	bf 90       	pop	r11
    207c:	af 90       	pop	r10
    207e:	08 95       	ret

00002080 <vTaskSuspendAll>:
    2080:	80 91 26 08 	lds	r24, 0x0826
    2084:	8f 5f       	subi	r24, 0xFF	; 255
    2086:	80 93 26 08 	sts	0x0826, r24
    208a:	08 95       	ret

0000208c <xTaskGetTickCount>:
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	f8 94       	cli
    2090:	0f 92       	push	r0
    2092:	80 91 2d 08 	lds	r24, 0x082D
    2096:	90 91 2e 08 	lds	r25, 0x082E
    209a:	0f 90       	pop	r0
    209c:	0f be       	out	0x3f, r0	; 63
    209e:	08 95       	ret

000020a0 <xTaskGetTickCountFromISR>:
    20a0:	80 91 2d 08 	lds	r24, 0x082D
    20a4:	90 91 2e 08 	lds	r25, 0x082E
    20a8:	08 95       	ret

000020aa <xTaskIncrementTick>:
    20aa:	cf 92       	push	r12
    20ac:	df 92       	push	r13
    20ae:	ef 92       	push	r14
    20b0:	ff 92       	push	r15
    20b2:	0f 93       	push	r16
    20b4:	1f 93       	push	r17
    20b6:	cf 93       	push	r28
    20b8:	df 93       	push	r29
    20ba:	80 91 26 08 	lds	r24, 0x0826
    20be:	81 11       	cpse	r24, r1
    20c0:	99 c0       	rjmp	.+306    	; 0x21f4 <xTaskIncrementTick+0x14a>
    20c2:	80 91 2d 08 	lds	r24, 0x082D
    20c6:	90 91 2e 08 	lds	r25, 0x082E
    20ca:	01 96       	adiw	r24, 0x01	; 1
    20cc:	90 93 2e 08 	sts	0x082E, r25
    20d0:	80 93 2d 08 	sts	0x082D, r24
    20d4:	e0 90 2d 08 	lds	r14, 0x082D
    20d8:	f0 90 2e 08 	lds	r15, 0x082E
    20dc:	e1 14       	cp	r14, r1
    20de:	f1 04       	cpc	r15, r1
    20e0:	b1 f4       	brne	.+44     	; 0x210e <xTaskIncrementTick+0x64>
    20e2:	80 91 4e 08 	lds	r24, 0x084E
    20e6:	90 91 4f 08 	lds	r25, 0x084F
    20ea:	20 91 4c 08 	lds	r18, 0x084C
    20ee:	30 91 4d 08 	lds	r19, 0x084D
    20f2:	30 93 4f 08 	sts	0x084F, r19
    20f6:	20 93 4e 08 	sts	0x084E, r18
    20fa:	90 93 4d 08 	sts	0x084D, r25
    20fe:	80 93 4c 08 	sts	0x084C, r24
    2102:	80 91 28 08 	lds	r24, 0x0828
    2106:	8f 5f       	subi	r24, 0xFF	; 255
    2108:	80 93 28 08 	sts	0x0828, r24
    210c:	da dd       	rcall	.-1100   	; 0x1cc2 <prvResetNextTaskUnblockTime>
    210e:	80 91 05 02 	lds	r24, 0x0205
    2112:	90 91 06 02 	lds	r25, 0x0206
    2116:	e8 16       	cp	r14, r24
    2118:	f9 06       	cpc	r15, r25
    211a:	08 f4       	brcc	.+2      	; 0x211e <xTaskIncrementTick+0x74>
    211c:	54 c0       	rjmp	.+168    	; 0x21c6 <xTaskIncrementTick+0x11c>
    211e:	d1 2c       	mov	r13, r1
    2120:	cc 24       	eor	r12, r12
    2122:	c3 94       	inc	r12
    2124:	01 c0       	rjmp	.+2      	; 0x2128 <xTaskIncrementTick+0x7e>
    2126:	dc 2c       	mov	r13, r12
    2128:	e0 91 4e 08 	lds	r30, 0x084E
    212c:	f0 91 4f 08 	lds	r31, 0x084F
    2130:	80 81       	ld	r24, Z
    2132:	81 11       	cpse	r24, r1
    2134:	07 c0       	rjmp	.+14     	; 0x2144 <xTaskIncrementTick+0x9a>
    2136:	8f ef       	ldi	r24, 0xFF	; 255
    2138:	9f ef       	ldi	r25, 0xFF	; 255
    213a:	90 93 06 02 	sts	0x0206, r25
    213e:	80 93 05 02 	sts	0x0205, r24
    2142:	42 c0       	rjmp	.+132    	; 0x21c8 <xTaskIncrementTick+0x11e>
    2144:	e0 91 4e 08 	lds	r30, 0x084E
    2148:	f0 91 4f 08 	lds	r31, 0x084F
    214c:	05 80       	ldd	r0, Z+5	; 0x05
    214e:	f6 81       	ldd	r31, Z+6	; 0x06
    2150:	e0 2d       	mov	r30, r0
    2152:	c6 81       	ldd	r28, Z+6	; 0x06
    2154:	d7 81       	ldd	r29, Z+7	; 0x07
    2156:	2a 81       	ldd	r18, Y+2	; 0x02
    2158:	3b 81       	ldd	r19, Y+3	; 0x03
    215a:	e2 16       	cp	r14, r18
    215c:	f3 06       	cpc	r15, r19
    215e:	28 f4       	brcc	.+10     	; 0x216a <xTaskIncrementTick+0xc0>
    2160:	30 93 06 02 	sts	0x0206, r19
    2164:	20 93 05 02 	sts	0x0205, r18
    2168:	2f c0       	rjmp	.+94     	; 0x21c8 <xTaskIncrementTick+0x11e>
    216a:	8e 01       	movw	r16, r28
    216c:	0e 5f       	subi	r16, 0xFE	; 254
    216e:	1f 4f       	sbci	r17, 0xFF	; 255
    2170:	c8 01       	movw	r24, r16
    2172:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    2176:	8c 89       	ldd	r24, Y+20	; 0x14
    2178:	9d 89       	ldd	r25, Y+21	; 0x15
    217a:	89 2b       	or	r24, r25
    217c:	21 f0       	breq	.+8      	; 0x2186 <xTaskIncrementTick+0xdc>
    217e:	ce 01       	movw	r24, r28
    2180:	0c 96       	adiw	r24, 0x0c	; 12
    2182:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    2186:	2e 89       	ldd	r18, Y+22	; 0x16
    2188:	80 91 2c 08 	lds	r24, 0x082C
    218c:	82 17       	cp	r24, r18
    218e:	10 f4       	brcc	.+4      	; 0x2194 <xTaskIncrementTick+0xea>
    2190:	20 93 2c 08 	sts	0x082C, r18
    2194:	30 e0       	ldi	r19, 0x00	; 0
    2196:	c9 01       	movw	r24, r18
    2198:	88 0f       	add	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	88 0f       	add	r24, r24
    219e:	99 1f       	adc	r25, r25
    21a0:	88 0f       	add	r24, r24
    21a2:	99 1f       	adc	r25, r25
    21a4:	82 0f       	add	r24, r18
    21a6:	93 1f       	adc	r25, r19
    21a8:	b8 01       	movw	r22, r16
    21aa:	8e 59       	subi	r24, 0x9E	; 158
    21ac:	97 4f       	sbci	r25, 0xF7	; 247
    21ae:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    21b2:	e0 91 8f 08 	lds	r30, 0x088F
    21b6:	f0 91 90 08 	lds	r31, 0x0890
    21ba:	9e 89       	ldd	r25, Y+22	; 0x16
    21bc:	86 89       	ldd	r24, Z+22	; 0x16
    21be:	98 17       	cp	r25, r24
    21c0:	08 f0       	brcs	.+2      	; 0x21c4 <xTaskIncrementTick+0x11a>
    21c2:	b1 cf       	rjmp	.-158    	; 0x2126 <xTaskIncrementTick+0x7c>
    21c4:	b1 cf       	rjmp	.-158    	; 0x2128 <xTaskIncrementTick+0x7e>
    21c6:	d1 2c       	mov	r13, r1
    21c8:	e0 91 8f 08 	lds	r30, 0x088F
    21cc:	f0 91 90 08 	lds	r31, 0x0890
    21d0:	86 89       	ldd	r24, Z+22	; 0x16
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	fc 01       	movw	r30, r24
    21d6:	ee 0f       	add	r30, r30
    21d8:	ff 1f       	adc	r31, r31
    21da:	ee 0f       	add	r30, r30
    21dc:	ff 1f       	adc	r31, r31
    21de:	ee 0f       	add	r30, r30
    21e0:	ff 1f       	adc	r31, r31
    21e2:	8e 0f       	add	r24, r30
    21e4:	9f 1f       	adc	r25, r31
    21e6:	fc 01       	movw	r30, r24
    21e8:	ee 59       	subi	r30, 0x9E	; 158
    21ea:	f7 4f       	sbci	r31, 0xF7	; 247
    21ec:	80 81       	ld	r24, Z
    21ee:	82 30       	cpi	r24, 0x02	; 2
    21f0:	40 f4       	brcc	.+16     	; 0x2202 <__stack+0x3>
    21f2:	09 c0       	rjmp	.+18     	; 0x2206 <__stack+0x7>
    21f4:	80 91 2a 08 	lds	r24, 0x082A
    21f8:	8f 5f       	subi	r24, 0xFF	; 255
    21fa:	80 93 2a 08 	sts	0x082A, r24
    21fe:	d1 2c       	mov	r13, r1
    2200:	02 c0       	rjmp	.+4      	; 0x2206 <__stack+0x7>
    2202:	dd 24       	eor	r13, r13
    2204:	d3 94       	inc	r13
    2206:	80 91 29 08 	lds	r24, 0x0829
    220a:	88 23       	and	r24, r24
    220c:	11 f0       	breq	.+4      	; 0x2212 <__stack+0x13>
    220e:	dd 24       	eor	r13, r13
    2210:	d3 94       	inc	r13
    2212:	8d 2d       	mov	r24, r13
    2214:	df 91       	pop	r29
    2216:	cf 91       	pop	r28
    2218:	1f 91       	pop	r17
    221a:	0f 91       	pop	r16
    221c:	ff 90       	pop	r15
    221e:	ef 90       	pop	r14
    2220:	df 90       	pop	r13
    2222:	cf 90       	pop	r12
    2224:	08 95       	ret

00002226 <xTaskResumeAll>:
    2226:	df 92       	push	r13
    2228:	ef 92       	push	r14
    222a:	ff 92       	push	r15
    222c:	0f 93       	push	r16
    222e:	1f 93       	push	r17
    2230:	cf 93       	push	r28
    2232:	df 93       	push	r29
    2234:	0f b6       	in	r0, 0x3f	; 63
    2236:	f8 94       	cli
    2238:	0f 92       	push	r0
    223a:	80 91 26 08 	lds	r24, 0x0826
    223e:	81 50       	subi	r24, 0x01	; 1
    2240:	80 93 26 08 	sts	0x0826, r24
    2244:	80 91 26 08 	lds	r24, 0x0826
    2248:	81 11       	cpse	r24, r1
    224a:	5f c0       	rjmp	.+190    	; 0x230a <xTaskResumeAll+0xe4>
    224c:	80 91 2f 08 	lds	r24, 0x082F
    2250:	88 23       	and	r24, r24
    2252:	09 f4       	brne	.+2      	; 0x2256 <xTaskResumeAll+0x30>
    2254:	5c c0       	rjmp	.+184    	; 0x230e <xTaskResumeAll+0xe8>
    2256:	0f 2e       	mov	r0, r31
    2258:	f3 e4       	ldi	r31, 0x43	; 67
    225a:	ef 2e       	mov	r14, r31
    225c:	f8 e0       	ldi	r31, 0x08	; 8
    225e:	ff 2e       	mov	r15, r31
    2260:	f0 2d       	mov	r31, r0
    2262:	dd 24       	eor	r13, r13
    2264:	d3 94       	inc	r13
    2266:	30 c0       	rjmp	.+96     	; 0x22c8 <xTaskResumeAll+0xa2>
    2268:	e0 91 48 08 	lds	r30, 0x0848
    226c:	f0 91 49 08 	lds	r31, 0x0849
    2270:	c6 81       	ldd	r28, Z+6	; 0x06
    2272:	d7 81       	ldd	r29, Z+7	; 0x07
    2274:	ce 01       	movw	r24, r28
    2276:	0c 96       	adiw	r24, 0x0c	; 12
    2278:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    227c:	8e 01       	movw	r16, r28
    227e:	0e 5f       	subi	r16, 0xFE	; 254
    2280:	1f 4f       	sbci	r17, 0xFF	; 255
    2282:	c8 01       	movw	r24, r16
    2284:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    2288:	8e 89       	ldd	r24, Y+22	; 0x16
    228a:	90 91 2c 08 	lds	r25, 0x082C
    228e:	98 17       	cp	r25, r24
    2290:	10 f4       	brcc	.+4      	; 0x2296 <xTaskResumeAll+0x70>
    2292:	80 93 2c 08 	sts	0x082C, r24
    2296:	90 e0       	ldi	r25, 0x00	; 0
    2298:	9c 01       	movw	r18, r24
    229a:	22 0f       	add	r18, r18
    229c:	33 1f       	adc	r19, r19
    229e:	22 0f       	add	r18, r18
    22a0:	33 1f       	adc	r19, r19
    22a2:	22 0f       	add	r18, r18
    22a4:	33 1f       	adc	r19, r19
    22a6:	82 0f       	add	r24, r18
    22a8:	93 1f       	adc	r25, r19
    22aa:	b8 01       	movw	r22, r16
    22ac:	8e 59       	subi	r24, 0x9E	; 158
    22ae:	97 4f       	sbci	r25, 0xF7	; 247
    22b0:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    22b4:	e0 91 8f 08 	lds	r30, 0x088F
    22b8:	f0 91 90 08 	lds	r31, 0x0890
    22bc:	9e 89       	ldd	r25, Y+22	; 0x16
    22be:	86 89       	ldd	r24, Z+22	; 0x16
    22c0:	98 17       	cp	r25, r24
    22c2:	10 f0       	brcs	.+4      	; 0x22c8 <xTaskResumeAll+0xa2>
    22c4:	d0 92 29 08 	sts	0x0829, r13
    22c8:	f7 01       	movw	r30, r14
    22ca:	80 81       	ld	r24, Z
    22cc:	81 11       	cpse	r24, r1
    22ce:	cc cf       	rjmp	.-104    	; 0x2268 <xTaskResumeAll+0x42>
    22d0:	80 91 2a 08 	lds	r24, 0x082A
    22d4:	88 23       	and	r24, r24
    22d6:	91 f0       	breq	.+36     	; 0x22fc <xTaskResumeAll+0xd6>
    22d8:	80 91 2a 08 	lds	r24, 0x082A
    22dc:	88 23       	and	r24, r24
    22de:	71 f0       	breq	.+28     	; 0x22fc <xTaskResumeAll+0xd6>
    22e0:	c1 e0       	ldi	r28, 0x01	; 1
    22e2:	e3 de       	rcall	.-570    	; 0x20aa <xTaskIncrementTick>
    22e4:	81 11       	cpse	r24, r1
    22e6:	c0 93 29 08 	sts	0x0829, r28
    22ea:	80 91 2a 08 	lds	r24, 0x082A
    22ee:	81 50       	subi	r24, 0x01	; 1
    22f0:	80 93 2a 08 	sts	0x082A, r24
    22f4:	80 91 2a 08 	lds	r24, 0x082A
    22f8:	81 11       	cpse	r24, r1
    22fa:	f3 cf       	rjmp	.-26     	; 0x22e2 <xTaskResumeAll+0xbc>
    22fc:	80 91 29 08 	lds	r24, 0x0829
    2300:	81 30       	cpi	r24, 0x01	; 1
    2302:	39 f4       	brne	.+14     	; 0x2312 <xTaskResumeAll+0xec>
    2304:	06 d9       	rcall	.-3572   	; 0x1512 <vPortYield>
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	05 c0       	rjmp	.+10     	; 0x2314 <xTaskResumeAll+0xee>
    230a:	80 e0       	ldi	r24, 0x00	; 0
    230c:	03 c0       	rjmp	.+6      	; 0x2314 <xTaskResumeAll+0xee>
    230e:	80 e0       	ldi	r24, 0x00	; 0
    2310:	01 c0       	rjmp	.+2      	; 0x2314 <xTaskResumeAll+0xee>
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	0f 90       	pop	r0
    2316:	0f be       	out	0x3f, r0	; 63
    2318:	df 91       	pop	r29
    231a:	cf 91       	pop	r28
    231c:	1f 91       	pop	r17
    231e:	0f 91       	pop	r16
    2320:	ff 90       	pop	r15
    2322:	ef 90       	pop	r14
    2324:	df 90       	pop	r13
    2326:	08 95       	ret

00002328 <vTaskDelayUntil>:
    2328:	0f 93       	push	r16
    232a:	1f 93       	push	r17
    232c:	cf 93       	push	r28
    232e:	df 93       	push	r29
    2330:	8c 01       	movw	r16, r24
    2332:	eb 01       	movw	r28, r22
    2334:	a5 de       	rcall	.-694    	; 0x2080 <vTaskSuspendAll>
    2336:	80 91 2d 08 	lds	r24, 0x082D
    233a:	90 91 2e 08 	lds	r25, 0x082E
    233e:	f8 01       	movw	r30, r16
    2340:	20 81       	ld	r18, Z
    2342:	31 81       	ldd	r19, Z+1	; 0x01
    2344:	c2 0f       	add	r28, r18
    2346:	d3 1f       	adc	r29, r19
    2348:	82 17       	cp	r24, r18
    234a:	93 07       	cpc	r25, r19
    234c:	48 f4       	brcc	.+18     	; 0x2360 <vTaskDelayUntil+0x38>
    234e:	c2 17       	cp	r28, r18
    2350:	d3 07       	cpc	r29, r19
    2352:	f8 f4       	brcc	.+62     	; 0x2392 <vTaskDelayUntil+0x6a>
    2354:	d1 83       	std	Z+1, r29	; 0x01
    2356:	c0 83       	st	Z, r28
    2358:	8c 17       	cp	r24, r28
    235a:	9d 07       	cpc	r25, r29
    235c:	88 f4       	brcc	.+34     	; 0x2380 <vTaskDelayUntil+0x58>
    235e:	07 c0       	rjmp	.+14     	; 0x236e <vTaskDelayUntil+0x46>
    2360:	c2 17       	cp	r28, r18
    2362:	d3 07       	cpc	r29, r19
    2364:	90 f0       	brcs	.+36     	; 0x238a <vTaskDelayUntil+0x62>
    2366:	8c 17       	cp	r24, r28
    2368:	9d 07       	cpc	r25, r29
    236a:	78 f0       	brcs	.+30     	; 0x238a <vTaskDelayUntil+0x62>
    236c:	12 c0       	rjmp	.+36     	; 0x2392 <vTaskDelayUntil+0x6a>
    236e:	80 91 8f 08 	lds	r24, 0x088F
    2372:	90 91 90 08 	lds	r25, 0x0890
    2376:	02 96       	adiw	r24, 0x02	; 2
    2378:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    237c:	ce 01       	movw	r24, r28
    237e:	c0 dc       	rcall	.-1664   	; 0x1d00 <prvAddCurrentTaskToDelayedList>
    2380:	52 df       	rcall	.-348    	; 0x2226 <xTaskResumeAll>
    2382:	81 11       	cpse	r24, r1
    2384:	0a c0       	rjmp	.+20     	; 0x239a <vTaskDelayUntil+0x72>
    2386:	c5 d8       	rcall	.-3702   	; 0x1512 <vPortYield>
    2388:	08 c0       	rjmp	.+16     	; 0x239a <vTaskDelayUntil+0x72>
    238a:	f8 01       	movw	r30, r16
    238c:	d1 83       	std	Z+1, r29	; 0x01
    238e:	c0 83       	st	Z, r28
    2390:	ee cf       	rjmp	.-36     	; 0x236e <vTaskDelayUntil+0x46>
    2392:	f8 01       	movw	r30, r16
    2394:	d1 83       	std	Z+1, r29	; 0x01
    2396:	c0 83       	st	Z, r28
    2398:	f3 cf       	rjmp	.-26     	; 0x2380 <vTaskDelayUntil+0x58>
    239a:	df 91       	pop	r29
    239c:	cf 91       	pop	r28
    239e:	1f 91       	pop	r17
    23a0:	0f 91       	pop	r16
    23a2:	08 95       	ret

000023a4 <prvIdleTask>:
    23a4:	0f 2e       	mov	r0, r31
    23a6:	f2 e6       	ldi	r31, 0x62	; 98
    23a8:	ef 2e       	mov	r14, r31
    23aa:	f8 e0       	ldi	r31, 0x08	; 8
    23ac:	ff 2e       	mov	r15, r31
    23ae:	f0 2d       	mov	r31, r0
    23b0:	ca e3       	ldi	r28, 0x3A	; 58
    23b2:	d8 e0       	ldi	r29, 0x08	; 8
    23b4:	26 c0       	rjmp	.+76     	; 0x2402 <prvIdleTask+0x5e>
    23b6:	64 de       	rcall	.-824    	; 0x2080 <vTaskSuspendAll>
    23b8:	18 81       	ld	r17, Y
    23ba:	35 df       	rcall	.-406    	; 0x2226 <xTaskResumeAll>
    23bc:	11 23       	and	r17, r17
    23be:	09 f1       	breq	.+66     	; 0x2402 <prvIdleTask+0x5e>
    23c0:	0f b6       	in	r0, 0x3f	; 63
    23c2:	f8 94       	cli
    23c4:	0f 92       	push	r0
    23c6:	e0 91 3f 08 	lds	r30, 0x083F
    23ca:	f0 91 40 08 	lds	r31, 0x0840
    23ce:	06 81       	ldd	r16, Z+6	; 0x06
    23d0:	17 81       	ldd	r17, Z+7	; 0x07
    23d2:	c8 01       	movw	r24, r16
    23d4:	02 96       	adiw	r24, 0x02	; 2
    23d6:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    23da:	80 91 2f 08 	lds	r24, 0x082F
    23de:	81 50       	subi	r24, 0x01	; 1
    23e0:	80 93 2f 08 	sts	0x082F, r24
    23e4:	80 91 39 08 	lds	r24, 0x0839
    23e8:	81 50       	subi	r24, 0x01	; 1
    23ea:	80 93 39 08 	sts	0x0839, r24
    23ee:	0f 90       	pop	r0
    23f0:	0f be       	out	0x3f, r0	; 63
    23f2:	f8 01       	movw	r30, r16
    23f4:	87 89       	ldd	r24, Z+23	; 0x17
    23f6:	90 8d       	ldd	r25, Z+24	; 0x18
    23f8:	0e 94 4c 03 	call	0x698	; 0x698 <vPortFree>
    23fc:	c8 01       	movw	r24, r16
    23fe:	0e 94 4c 03 	call	0x698	; 0x698 <vPortFree>
    2402:	80 91 39 08 	lds	r24, 0x0839
    2406:	81 11       	cpse	r24, r1
    2408:	d6 cf       	rjmp	.-84     	; 0x23b6 <prvIdleTask+0x12>
    240a:	f7 01       	movw	r30, r14
    240c:	80 81       	ld	r24, Z
    240e:	82 30       	cpi	r24, 0x02	; 2
    2410:	c0 f3       	brcs	.-16     	; 0x2402 <prvIdleTask+0x5e>
    2412:	7f d8       	rcall	.-3842   	; 0x1512 <vPortYield>
    2414:	f6 cf       	rjmp	.-20     	; 0x2402 <prvIdleTask+0x5e>

00002416 <vTaskSwitchContext>:
    2416:	80 91 26 08 	lds	r24, 0x0826
    241a:	88 23       	and	r24, r24
    241c:	21 f0       	breq	.+8      	; 0x2426 <vTaskSwitchContext+0x10>
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	80 93 29 08 	sts	0x0829, r24
    2424:	08 95       	ret
    2426:	10 92 29 08 	sts	0x0829, r1
    242a:	80 91 2c 08 	lds	r24, 0x082C
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	fc 01       	movw	r30, r24
    2432:	ee 0f       	add	r30, r30
    2434:	ff 1f       	adc	r31, r31
    2436:	ee 0f       	add	r30, r30
    2438:	ff 1f       	adc	r31, r31
    243a:	ee 0f       	add	r30, r30
    243c:	ff 1f       	adc	r31, r31
    243e:	8e 0f       	add	r24, r30
    2440:	9f 1f       	adc	r25, r31
    2442:	fc 01       	movw	r30, r24
    2444:	ee 59       	subi	r30, 0x9E	; 158
    2446:	f7 4f       	sbci	r31, 0xF7	; 247
    2448:	80 81       	ld	r24, Z
    244a:	81 11       	cpse	r24, r1
    244c:	17 c0       	rjmp	.+46     	; 0x247c <vTaskSwitchContext+0x66>
    244e:	80 91 2c 08 	lds	r24, 0x082C
    2452:	81 50       	subi	r24, 0x01	; 1
    2454:	80 93 2c 08 	sts	0x082C, r24
    2458:	80 91 2c 08 	lds	r24, 0x082C
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	fc 01       	movw	r30, r24
    2460:	ee 0f       	add	r30, r30
    2462:	ff 1f       	adc	r31, r31
    2464:	ee 0f       	add	r30, r30
    2466:	ff 1f       	adc	r31, r31
    2468:	ee 0f       	add	r30, r30
    246a:	ff 1f       	adc	r31, r31
    246c:	8e 0f       	add	r24, r30
    246e:	9f 1f       	adc	r25, r31
    2470:	fc 01       	movw	r30, r24
    2472:	ee 59       	subi	r30, 0x9E	; 158
    2474:	f7 4f       	sbci	r31, 0xF7	; 247
    2476:	80 81       	ld	r24, Z
    2478:	88 23       	and	r24, r24
    247a:	49 f3       	breq	.-46     	; 0x244e <vTaskSwitchContext+0x38>
    247c:	e0 91 2c 08 	lds	r30, 0x082C
    2480:	f0 e0       	ldi	r31, 0x00	; 0
    2482:	cf 01       	movw	r24, r30
    2484:	88 0f       	add	r24, r24
    2486:	99 1f       	adc	r25, r25
    2488:	88 0f       	add	r24, r24
    248a:	99 1f       	adc	r25, r25
    248c:	88 0f       	add	r24, r24
    248e:	99 1f       	adc	r25, r25
    2490:	e8 0f       	add	r30, r24
    2492:	f9 1f       	adc	r31, r25
    2494:	ee 59       	subi	r30, 0x9E	; 158
    2496:	f7 4f       	sbci	r31, 0xF7	; 247
    2498:	a1 81       	ldd	r26, Z+1	; 0x01
    249a:	b2 81       	ldd	r27, Z+2	; 0x02
    249c:	12 96       	adiw	r26, 0x02	; 2
    249e:	0d 90       	ld	r0, X+
    24a0:	bc 91       	ld	r27, X
    24a2:	a0 2d       	mov	r26, r0
    24a4:	b2 83       	std	Z+2, r27	; 0x02
    24a6:	a1 83       	std	Z+1, r26	; 0x01
    24a8:	cf 01       	movw	r24, r30
    24aa:	03 96       	adiw	r24, 0x03	; 3
    24ac:	a8 17       	cp	r26, r24
    24ae:	b9 07       	cpc	r27, r25
    24b0:	31 f4       	brne	.+12     	; 0x24be <vTaskSwitchContext+0xa8>
    24b2:	12 96       	adiw	r26, 0x02	; 2
    24b4:	8d 91       	ld	r24, X+
    24b6:	9c 91       	ld	r25, X
    24b8:	13 97       	sbiw	r26, 0x03	; 3
    24ba:	92 83       	std	Z+2, r25	; 0x02
    24bc:	81 83       	std	Z+1, r24	; 0x01
    24be:	01 80       	ldd	r0, Z+1	; 0x01
    24c0:	f2 81       	ldd	r31, Z+2	; 0x02
    24c2:	e0 2d       	mov	r30, r0
    24c4:	86 81       	ldd	r24, Z+6	; 0x06
    24c6:	97 81       	ldd	r25, Z+7	; 0x07
    24c8:	90 93 90 08 	sts	0x0890, r25
    24cc:	80 93 8f 08 	sts	0x088F, r24
    24d0:	08 95       	ret

000024d2 <vTaskSuspend>:
    24d2:	0f 93       	push	r16
    24d4:	1f 93       	push	r17
    24d6:	cf 93       	push	r28
    24d8:	df 93       	push	r29
    24da:	ec 01       	movw	r28, r24
    24dc:	0f b6       	in	r0, 0x3f	; 63
    24de:	f8 94       	cli
    24e0:	0f 92       	push	r0
    24e2:	00 97       	sbiw	r24, 0x00	; 0
    24e4:	21 f4       	brne	.+8      	; 0x24ee <vTaskSuspend+0x1c>
    24e6:	c0 91 8f 08 	lds	r28, 0x088F
    24ea:	d0 91 90 08 	lds	r29, 0x0890
    24ee:	8e 01       	movw	r16, r28
    24f0:	0e 5f       	subi	r16, 0xFE	; 254
    24f2:	1f 4f       	sbci	r17, 0xFF	; 255
    24f4:	c8 01       	movw	r24, r16
    24f6:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    24fa:	8c 89       	ldd	r24, Y+20	; 0x14
    24fc:	9d 89       	ldd	r25, Y+21	; 0x15
    24fe:	89 2b       	or	r24, r25
    2500:	21 f0       	breq	.+8      	; 0x250a <vTaskSuspend+0x38>
    2502:	ce 01       	movw	r24, r28
    2504:	0c 96       	adiw	r24, 0x0c	; 12
    2506:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    250a:	b8 01       	movw	r22, r16
    250c:	80 e3       	ldi	r24, 0x30	; 48
    250e:	98 e0       	ldi	r25, 0x08	; 8
    2510:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    2514:	0f 90       	pop	r0
    2516:	0f be       	out	0x3f, r0	; 63
    2518:	80 91 8f 08 	lds	r24, 0x088F
    251c:	90 91 90 08 	lds	r25, 0x0890
    2520:	c8 17       	cp	r28, r24
    2522:	d9 07       	cpc	r29, r25
    2524:	a1 f4       	brne	.+40     	; 0x254e <vTaskSuspend+0x7c>
    2526:	80 91 2b 08 	lds	r24, 0x082B
    252a:	88 23       	and	r24, r24
    252c:	19 f0       	breq	.+6      	; 0x2534 <vTaskSuspend+0x62>
    252e:	0e 94 89 0a 	call	0x1512	; 0x1512 <vPortYield>
    2532:	17 c0       	rjmp	.+46     	; 0x2562 <vTaskSuspend+0x90>
    2534:	80 91 2f 08 	lds	r24, 0x082F
    2538:	90 91 30 08 	lds	r25, 0x0830
    253c:	98 13       	cpse	r25, r24
    253e:	05 c0       	rjmp	.+10     	; 0x254a <vTaskSuspend+0x78>
    2540:	10 92 90 08 	sts	0x0890, r1
    2544:	10 92 8f 08 	sts	0x088F, r1
    2548:	0c c0       	rjmp	.+24     	; 0x2562 <vTaskSuspend+0x90>
    254a:	65 df       	rcall	.-310    	; 0x2416 <vTaskSwitchContext>
    254c:	0a c0       	rjmp	.+20     	; 0x2562 <vTaskSuspend+0x90>
    254e:	80 91 2b 08 	lds	r24, 0x082B
    2552:	88 23       	and	r24, r24
    2554:	31 f0       	breq	.+12     	; 0x2562 <vTaskSuspend+0x90>
    2556:	0f b6       	in	r0, 0x3f	; 63
    2558:	f8 94       	cli
    255a:	0f 92       	push	r0
    255c:	b2 db       	rcall	.-2204   	; 0x1cc2 <prvResetNextTaskUnblockTime>
    255e:	0f 90       	pop	r0
    2560:	0f be       	out	0x3f, r0	; 63
    2562:	df 91       	pop	r29
    2564:	cf 91       	pop	r28
    2566:	1f 91       	pop	r17
    2568:	0f 91       	pop	r16
    256a:	08 95       	ret

0000256c <vTaskPlaceOnEventList>:
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	eb 01       	movw	r28, r22
    2572:	60 91 8f 08 	lds	r22, 0x088F
    2576:	70 91 90 08 	lds	r23, 0x0890
    257a:	64 5f       	subi	r22, 0xF4	; 244
    257c:	7f 4f       	sbci	r23, 0xFF	; 255
    257e:	0e 94 80 03 	call	0x700	; 0x700 <vListInsert>
    2582:	80 91 8f 08 	lds	r24, 0x088F
    2586:	90 91 90 08 	lds	r25, 0x0890
    258a:	02 96       	adiw	r24, 0x02	; 2
    258c:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    2590:	cf 3f       	cpi	r28, 0xFF	; 255
    2592:	8f ef       	ldi	r24, 0xFF	; 255
    2594:	d8 07       	cpc	r29, r24
    2596:	59 f4       	brne	.+22     	; 0x25ae <vTaskPlaceOnEventList+0x42>
    2598:	60 91 8f 08 	lds	r22, 0x088F
    259c:	70 91 90 08 	lds	r23, 0x0890
    25a0:	6e 5f       	subi	r22, 0xFE	; 254
    25a2:	7f 4f       	sbci	r23, 0xFF	; 255
    25a4:	80 e3       	ldi	r24, 0x30	; 48
    25a6:	98 e0       	ldi	r25, 0x08	; 8
    25a8:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    25ac:	07 c0       	rjmp	.+14     	; 0x25bc <vTaskPlaceOnEventList+0x50>
    25ae:	80 91 2d 08 	lds	r24, 0x082D
    25b2:	90 91 2e 08 	lds	r25, 0x082E
    25b6:	8c 0f       	add	r24, r28
    25b8:	9d 1f       	adc	r25, r29
    25ba:	a2 db       	rcall	.-2236   	; 0x1d00 <prvAddCurrentTaskToDelayedList>
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	08 95       	ret

000025c2 <xTaskRemoveFromEventList>:
    25c2:	0f 93       	push	r16
    25c4:	1f 93       	push	r17
    25c6:	cf 93       	push	r28
    25c8:	df 93       	push	r29
    25ca:	dc 01       	movw	r26, r24
    25cc:	15 96       	adiw	r26, 0x05	; 5
    25ce:	ed 91       	ld	r30, X+
    25d0:	fc 91       	ld	r31, X
    25d2:	16 97       	sbiw	r26, 0x06	; 6
    25d4:	c6 81       	ldd	r28, Z+6	; 0x06
    25d6:	d7 81       	ldd	r29, Z+7	; 0x07
    25d8:	8e 01       	movw	r16, r28
    25da:	04 5f       	subi	r16, 0xF4	; 244
    25dc:	1f 4f       	sbci	r17, 0xFF	; 255
    25de:	c8 01       	movw	r24, r16
    25e0:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    25e4:	80 91 26 08 	lds	r24, 0x0826
    25e8:	81 11       	cpse	r24, r1
    25ea:	1c c0       	rjmp	.+56     	; 0x2624 <xTaskRemoveFromEventList+0x62>
    25ec:	0a 50       	subi	r16, 0x0A	; 10
    25ee:	11 09       	sbc	r17, r1
    25f0:	c8 01       	movw	r24, r16
    25f2:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    25f6:	8e 89       	ldd	r24, Y+22	; 0x16
    25f8:	90 91 2c 08 	lds	r25, 0x082C
    25fc:	98 17       	cp	r25, r24
    25fe:	10 f4       	brcc	.+4      	; 0x2604 <xTaskRemoveFromEventList+0x42>
    2600:	80 93 2c 08 	sts	0x082C, r24
    2604:	90 e0       	ldi	r25, 0x00	; 0
    2606:	9c 01       	movw	r18, r24
    2608:	22 0f       	add	r18, r18
    260a:	33 1f       	adc	r19, r19
    260c:	22 0f       	add	r18, r18
    260e:	33 1f       	adc	r19, r19
    2610:	22 0f       	add	r18, r18
    2612:	33 1f       	adc	r19, r19
    2614:	82 0f       	add	r24, r18
    2616:	93 1f       	adc	r25, r19
    2618:	b8 01       	movw	r22, r16
    261a:	8e 59       	subi	r24, 0x9E	; 158
    261c:	97 4f       	sbci	r25, 0xF7	; 247
    261e:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    2622:	05 c0       	rjmp	.+10     	; 0x262e <xTaskRemoveFromEventList+0x6c>
    2624:	b8 01       	movw	r22, r16
    2626:	83 e4       	ldi	r24, 0x43	; 67
    2628:	98 e0       	ldi	r25, 0x08	; 8
    262a:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    262e:	e0 91 8f 08 	lds	r30, 0x088F
    2632:	f0 91 90 08 	lds	r31, 0x0890
    2636:	9e 89       	ldd	r25, Y+22	; 0x16
    2638:	86 89       	ldd	r24, Z+22	; 0x16
    263a:	89 17       	cp	r24, r25
    263c:	20 f4       	brcc	.+8      	; 0x2646 <xTaskRemoveFromEventList+0x84>
    263e:	81 e0       	ldi	r24, 0x01	; 1
    2640:	80 93 29 08 	sts	0x0829, r24
    2644:	01 c0       	rjmp	.+2      	; 0x2648 <xTaskRemoveFromEventList+0x86>
    2646:	80 e0       	ldi	r24, 0x00	; 0
    2648:	df 91       	pop	r29
    264a:	cf 91       	pop	r28
    264c:	1f 91       	pop	r17
    264e:	0f 91       	pop	r16
    2650:	08 95       	ret

00002652 <vTaskSetTimeOutState>:
    2652:	20 91 28 08 	lds	r18, 0x0828
    2656:	fc 01       	movw	r30, r24
    2658:	20 83       	st	Z, r18
    265a:	20 91 2d 08 	lds	r18, 0x082D
    265e:	30 91 2e 08 	lds	r19, 0x082E
    2662:	32 83       	std	Z+2, r19	; 0x02
    2664:	21 83       	std	Z+1, r18	; 0x01
    2666:	08 95       	ret

00002668 <xTaskCheckForTimeOut>:
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	0f 92       	push	r0
    266e:	40 91 2d 08 	lds	r20, 0x082D
    2672:	50 91 2e 08 	lds	r21, 0x082E
    2676:	db 01       	movw	r26, r22
    2678:	2d 91       	ld	r18, X+
    267a:	3c 91       	ld	r19, X
    267c:	2f 3f       	cpi	r18, 0xFF	; 255
    267e:	bf ef       	ldi	r27, 0xFF	; 255
    2680:	3b 07       	cpc	r19, r27
    2682:	11 f1       	breq	.+68     	; 0x26c8 <xTaskCheckForTimeOut+0x60>
    2684:	e0 91 28 08 	lds	r30, 0x0828
    2688:	dc 01       	movw	r26, r24
    268a:	fc 91       	ld	r31, X
    268c:	fe 17       	cp	r31, r30
    268e:	39 f0       	breq	.+14     	; 0x269e <xTaskCheckForTimeOut+0x36>
    2690:	11 96       	adiw	r26, 0x01	; 1
    2692:	ed 91       	ld	r30, X+
    2694:	fc 91       	ld	r31, X
    2696:	12 97       	sbiw	r26, 0x02	; 2
    2698:	4e 17       	cp	r20, r30
    269a:	5f 07       	cpc	r21, r31
    269c:	b8 f4       	brcc	.+46     	; 0x26cc <xTaskCheckForTimeOut+0x64>
    269e:	dc 01       	movw	r26, r24
    26a0:	11 96       	adiw	r26, 0x01	; 1
    26a2:	ed 91       	ld	r30, X+
    26a4:	fc 91       	ld	r31, X
    26a6:	12 97       	sbiw	r26, 0x02	; 2
    26a8:	da 01       	movw	r26, r20
    26aa:	ae 1b       	sub	r26, r30
    26ac:	bf 0b       	sbc	r27, r31
    26ae:	a2 17       	cp	r26, r18
    26b0:	b3 07       	cpc	r27, r19
    26b2:	70 f4       	brcc	.+28     	; 0x26d0 <xTaskCheckForTimeOut+0x68>
    26b4:	e4 1b       	sub	r30, r20
    26b6:	f5 0b       	sbc	r31, r21
    26b8:	2e 0f       	add	r18, r30
    26ba:	3f 1f       	adc	r19, r31
    26bc:	fb 01       	movw	r30, r22
    26be:	31 83       	std	Z+1, r19	; 0x01
    26c0:	20 83       	st	Z, r18
    26c2:	c7 df       	rcall	.-114    	; 0x2652 <vTaskSetTimeOutState>
    26c4:	80 e0       	ldi	r24, 0x00	; 0
    26c6:	05 c0       	rjmp	.+10     	; 0x26d2 <xTaskCheckForTimeOut+0x6a>
    26c8:	80 e0       	ldi	r24, 0x00	; 0
    26ca:	03 c0       	rjmp	.+6      	; 0x26d2 <xTaskCheckForTimeOut+0x6a>
    26cc:	81 e0       	ldi	r24, 0x01	; 1
    26ce:	01 c0       	rjmp	.+2      	; 0x26d2 <xTaskCheckForTimeOut+0x6a>
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	0f 90       	pop	r0
    26d4:	0f be       	out	0x3f, r0	; 63
    26d6:	08 95       	ret

000026d8 <vTaskMissedYield>:
    26d8:	81 e0       	ldi	r24, 0x01	; 1
    26da:	80 93 29 08 	sts	0x0829, r24
    26de:	08 95       	ret

000026e0 <vTaskPriorityInherit>:
    26e0:	0f 93       	push	r16
    26e2:	1f 93       	push	r17
    26e4:	cf 93       	push	r28
    26e6:	df 93       	push	r29
    26e8:	ec 01       	movw	r28, r24
    26ea:	00 97       	sbiw	r24, 0x00	; 0
    26ec:	09 f4       	brne	.+2      	; 0x26f0 <vTaskPriorityInherit+0x10>
    26ee:	51 c0       	rjmp	.+162    	; 0x2792 <vTaskPriorityInherit+0xb2>
    26f0:	8e 89       	ldd	r24, Y+22	; 0x16
    26f2:	e0 91 8f 08 	lds	r30, 0x088F
    26f6:	f0 91 90 08 	lds	r31, 0x0890
    26fa:	96 89       	ldd	r25, Z+22	; 0x16
    26fc:	89 17       	cp	r24, r25
    26fe:	08 f0       	brcs	.+2      	; 0x2702 <vTaskPriorityInherit+0x22>
    2700:	48 c0       	rjmp	.+144    	; 0x2792 <vTaskPriorityInherit+0xb2>
    2702:	2c 85       	ldd	r18, Y+12	; 0x0c
    2704:	3d 85       	ldd	r19, Y+13	; 0x0d
    2706:	33 23       	and	r19, r19
    2708:	5c f0       	brlt	.+22     	; 0x2720 <vTaskPriorityInherit+0x40>
    270a:	e0 91 8f 08 	lds	r30, 0x088F
    270e:	f0 91 90 08 	lds	r31, 0x0890
    2712:	96 89       	ldd	r25, Z+22	; 0x16
    2714:	25 e0       	ldi	r18, 0x05	; 5
    2716:	30 e0       	ldi	r19, 0x00	; 0
    2718:	29 1b       	sub	r18, r25
    271a:	31 09       	sbc	r19, r1
    271c:	3d 87       	std	Y+13, r19	; 0x0d
    271e:	2c 87       	std	Y+12, r18	; 0x0c
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	9c 01       	movw	r18, r24
    2724:	22 0f       	add	r18, r18
    2726:	33 1f       	adc	r19, r19
    2728:	22 0f       	add	r18, r18
    272a:	33 1f       	adc	r19, r19
    272c:	22 0f       	add	r18, r18
    272e:	33 1f       	adc	r19, r19
    2730:	82 0f       	add	r24, r18
    2732:	93 1f       	adc	r25, r19
    2734:	8e 59       	subi	r24, 0x9E	; 158
    2736:	97 4f       	sbci	r25, 0xF7	; 247
    2738:	2a 85       	ldd	r18, Y+10	; 0x0a
    273a:	3b 85       	ldd	r19, Y+11	; 0x0b
    273c:	28 17       	cp	r18, r24
    273e:	39 07       	cpc	r19, r25
    2740:	11 f5       	brne	.+68     	; 0x2786 <vTaskPriorityInherit+0xa6>
    2742:	8e 01       	movw	r16, r28
    2744:	0e 5f       	subi	r16, 0xFE	; 254
    2746:	1f 4f       	sbci	r17, 0xFF	; 255
    2748:	c8 01       	movw	r24, r16
    274a:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    274e:	e0 91 8f 08 	lds	r30, 0x088F
    2752:	f0 91 90 08 	lds	r31, 0x0890
    2756:	86 89       	ldd	r24, Z+22	; 0x16
    2758:	8e 8b       	std	Y+22, r24	; 0x16
    275a:	90 91 2c 08 	lds	r25, 0x082C
    275e:	98 17       	cp	r25, r24
    2760:	10 f4       	brcc	.+4      	; 0x2766 <vTaskPriorityInherit+0x86>
    2762:	80 93 2c 08 	sts	0x082C, r24
    2766:	90 e0       	ldi	r25, 0x00	; 0
    2768:	9c 01       	movw	r18, r24
    276a:	22 0f       	add	r18, r18
    276c:	33 1f       	adc	r19, r19
    276e:	22 0f       	add	r18, r18
    2770:	33 1f       	adc	r19, r19
    2772:	22 0f       	add	r18, r18
    2774:	33 1f       	adc	r19, r19
    2776:	82 0f       	add	r24, r18
    2778:	93 1f       	adc	r25, r19
    277a:	b8 01       	movw	r22, r16
    277c:	8e 59       	subi	r24, 0x9E	; 158
    277e:	97 4f       	sbci	r25, 0xF7	; 247
    2780:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    2784:	06 c0       	rjmp	.+12     	; 0x2792 <vTaskPriorityInherit+0xb2>
    2786:	e0 91 8f 08 	lds	r30, 0x088F
    278a:	f0 91 90 08 	lds	r31, 0x0890
    278e:	86 89       	ldd	r24, Z+22	; 0x16
    2790:	8e 8b       	std	Y+22, r24	; 0x16
    2792:	df 91       	pop	r29
    2794:	cf 91       	pop	r28
    2796:	1f 91       	pop	r17
    2798:	0f 91       	pop	r16
    279a:	08 95       	ret

0000279c <xTaskPriorityDisinherit>:
    279c:	0f 93       	push	r16
    279e:	1f 93       	push	r17
    27a0:	cf 93       	push	r28
    27a2:	df 93       	push	r29
    27a4:	ec 01       	movw	r28, r24
    27a6:	00 97       	sbiw	r24, 0x00	; 0
    27a8:	71 f1       	breq	.+92     	; 0x2806 <xTaskPriorityDisinherit+0x6a>
    27aa:	8a a1       	ldd	r24, Y+34	; 0x22
    27ac:	81 50       	subi	r24, 0x01	; 1
    27ae:	8a a3       	std	Y+34, r24	; 0x22
    27b0:	2e 89       	ldd	r18, Y+22	; 0x16
    27b2:	99 a1       	ldd	r25, Y+33	; 0x21
    27b4:	29 17       	cp	r18, r25
    27b6:	49 f1       	breq	.+82     	; 0x280a <xTaskPriorityDisinherit+0x6e>
    27b8:	81 11       	cpse	r24, r1
    27ba:	29 c0       	rjmp	.+82     	; 0x280e <xTaskPriorityDisinherit+0x72>
    27bc:	8e 01       	movw	r16, r28
    27be:	0e 5f       	subi	r16, 0xFE	; 254
    27c0:	1f 4f       	sbci	r17, 0xFF	; 255
    27c2:	c8 01       	movw	r24, r16
    27c4:	0e 94 b1 03 	call	0x762	; 0x762 <uxListRemove>
    27c8:	89 a1       	ldd	r24, Y+33	; 0x21
    27ca:	8e 8b       	std	Y+22, r24	; 0x16
    27cc:	25 e0       	ldi	r18, 0x05	; 5
    27ce:	30 e0       	ldi	r19, 0x00	; 0
    27d0:	28 1b       	sub	r18, r24
    27d2:	31 09       	sbc	r19, r1
    27d4:	3d 87       	std	Y+13, r19	; 0x0d
    27d6:	2c 87       	std	Y+12, r18	; 0x0c
    27d8:	90 91 2c 08 	lds	r25, 0x082C
    27dc:	98 17       	cp	r25, r24
    27de:	10 f4       	brcc	.+4      	; 0x27e4 <xTaskPriorityDisinherit+0x48>
    27e0:	80 93 2c 08 	sts	0x082C, r24
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	9c 01       	movw	r18, r24
    27e8:	22 0f       	add	r18, r18
    27ea:	33 1f       	adc	r19, r19
    27ec:	22 0f       	add	r18, r18
    27ee:	33 1f       	adc	r19, r19
    27f0:	22 0f       	add	r18, r18
    27f2:	33 1f       	adc	r19, r19
    27f4:	82 0f       	add	r24, r18
    27f6:	93 1f       	adc	r25, r19
    27f8:	b8 01       	movw	r22, r16
    27fa:	8e 59       	subi	r24, 0x9E	; 158
    27fc:	97 4f       	sbci	r25, 0xF7	; 247
    27fe:	0e 94 5f 03 	call	0x6be	; 0x6be <vListInsertEnd>
    2802:	81 e0       	ldi	r24, 0x01	; 1
    2804:	05 c0       	rjmp	.+10     	; 0x2810 <xTaskPriorityDisinherit+0x74>
    2806:	80 e0       	ldi	r24, 0x00	; 0
    2808:	03 c0       	rjmp	.+6      	; 0x2810 <xTaskPriorityDisinherit+0x74>
    280a:	80 e0       	ldi	r24, 0x00	; 0
    280c:	01 c0       	rjmp	.+2      	; 0x2810 <xTaskPriorityDisinherit+0x74>
    280e:	80 e0       	ldi	r24, 0x00	; 0
    2810:	df 91       	pop	r29
    2812:	cf 91       	pop	r28
    2814:	1f 91       	pop	r17
    2816:	0f 91       	pop	r16
    2818:	08 95       	ret

0000281a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    281a:	80 91 8f 08 	lds	r24, 0x088F
    281e:	90 91 90 08 	lds	r25, 0x0890
    2822:	89 2b       	or	r24, r25
    2824:	39 f0       	breq	.+14     	; 0x2834 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2826:	e0 91 8f 08 	lds	r30, 0x088F
    282a:	f0 91 90 08 	lds	r31, 0x0890
    282e:	82 a1       	ldd	r24, Z+34	; 0x22
    2830:	8f 5f       	subi	r24, 0xFF	; 255
    2832:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2834:	80 91 8f 08 	lds	r24, 0x088F
    2838:	90 91 90 08 	lds	r25, 0x0890
	}
    283c:	08 95       	ret

0000283e <__subsf3>:
    283e:	50 58       	subi	r21, 0x80	; 128

00002840 <__addsf3>:
    2840:	bb 27       	eor	r27, r27
    2842:	aa 27       	eor	r26, r26
    2844:	0e d0       	rcall	.+28     	; 0x2862 <__addsf3x>
    2846:	e5 c0       	rjmp	.+458    	; 0x2a12 <__fp_round>
    2848:	d6 d0       	rcall	.+428    	; 0x29f6 <__fp_pscA>
    284a:	30 f0       	brcs	.+12     	; 0x2858 <__addsf3+0x18>
    284c:	db d0       	rcall	.+438    	; 0x2a04 <__fp_pscB>
    284e:	20 f0       	brcs	.+8      	; 0x2858 <__addsf3+0x18>
    2850:	31 f4       	brne	.+12     	; 0x285e <__addsf3+0x1e>
    2852:	9f 3f       	cpi	r25, 0xFF	; 255
    2854:	11 f4       	brne	.+4      	; 0x285a <__addsf3+0x1a>
    2856:	1e f4       	brtc	.+6      	; 0x285e <__addsf3+0x1e>
    2858:	cb c0       	rjmp	.+406    	; 0x29f0 <__fp_nan>
    285a:	0e f4       	brtc	.+2      	; 0x285e <__addsf3+0x1e>
    285c:	e0 95       	com	r30
    285e:	e7 fb       	bst	r30, 7
    2860:	c1 c0       	rjmp	.+386    	; 0x29e4 <__fp_inf>

00002862 <__addsf3x>:
    2862:	e9 2f       	mov	r30, r25
    2864:	e7 d0       	rcall	.+462    	; 0x2a34 <__fp_split3>
    2866:	80 f3       	brcs	.-32     	; 0x2848 <__addsf3+0x8>
    2868:	ba 17       	cp	r27, r26
    286a:	62 07       	cpc	r22, r18
    286c:	73 07       	cpc	r23, r19
    286e:	84 07       	cpc	r24, r20
    2870:	95 07       	cpc	r25, r21
    2872:	18 f0       	brcs	.+6      	; 0x287a <__addsf3x+0x18>
    2874:	71 f4       	brne	.+28     	; 0x2892 <__addsf3x+0x30>
    2876:	9e f5       	brtc	.+102    	; 0x28de <__addsf3x+0x7c>
    2878:	ff c0       	rjmp	.+510    	; 0x2a78 <__fp_zero>
    287a:	0e f4       	brtc	.+2      	; 0x287e <__addsf3x+0x1c>
    287c:	e0 95       	com	r30
    287e:	0b 2e       	mov	r0, r27
    2880:	ba 2f       	mov	r27, r26
    2882:	a0 2d       	mov	r26, r0
    2884:	0b 01       	movw	r0, r22
    2886:	b9 01       	movw	r22, r18
    2888:	90 01       	movw	r18, r0
    288a:	0c 01       	movw	r0, r24
    288c:	ca 01       	movw	r24, r20
    288e:	a0 01       	movw	r20, r0
    2890:	11 24       	eor	r1, r1
    2892:	ff 27       	eor	r31, r31
    2894:	59 1b       	sub	r21, r25
    2896:	99 f0       	breq	.+38     	; 0x28be <__addsf3x+0x5c>
    2898:	59 3f       	cpi	r21, 0xF9	; 249
    289a:	50 f4       	brcc	.+20     	; 0x28b0 <__addsf3x+0x4e>
    289c:	50 3e       	cpi	r21, 0xE0	; 224
    289e:	68 f1       	brcs	.+90     	; 0x28fa <__addsf3x+0x98>
    28a0:	1a 16       	cp	r1, r26
    28a2:	f0 40       	sbci	r31, 0x00	; 0
    28a4:	a2 2f       	mov	r26, r18
    28a6:	23 2f       	mov	r18, r19
    28a8:	34 2f       	mov	r19, r20
    28aa:	44 27       	eor	r20, r20
    28ac:	58 5f       	subi	r21, 0xF8	; 248
    28ae:	f3 cf       	rjmp	.-26     	; 0x2896 <__addsf3x+0x34>
    28b0:	46 95       	lsr	r20
    28b2:	37 95       	ror	r19
    28b4:	27 95       	ror	r18
    28b6:	a7 95       	ror	r26
    28b8:	f0 40       	sbci	r31, 0x00	; 0
    28ba:	53 95       	inc	r21
    28bc:	c9 f7       	brne	.-14     	; 0x28b0 <__addsf3x+0x4e>
    28be:	7e f4       	brtc	.+30     	; 0x28de <__addsf3x+0x7c>
    28c0:	1f 16       	cp	r1, r31
    28c2:	ba 0b       	sbc	r27, r26
    28c4:	62 0b       	sbc	r22, r18
    28c6:	73 0b       	sbc	r23, r19
    28c8:	84 0b       	sbc	r24, r20
    28ca:	ba f0       	brmi	.+46     	; 0x28fa <__addsf3x+0x98>
    28cc:	91 50       	subi	r25, 0x01	; 1
    28ce:	a1 f0       	breq	.+40     	; 0x28f8 <__addsf3x+0x96>
    28d0:	ff 0f       	add	r31, r31
    28d2:	bb 1f       	adc	r27, r27
    28d4:	66 1f       	adc	r22, r22
    28d6:	77 1f       	adc	r23, r23
    28d8:	88 1f       	adc	r24, r24
    28da:	c2 f7       	brpl	.-16     	; 0x28cc <__addsf3x+0x6a>
    28dc:	0e c0       	rjmp	.+28     	; 0x28fa <__addsf3x+0x98>
    28de:	ba 0f       	add	r27, r26
    28e0:	62 1f       	adc	r22, r18
    28e2:	73 1f       	adc	r23, r19
    28e4:	84 1f       	adc	r24, r20
    28e6:	48 f4       	brcc	.+18     	; 0x28fa <__addsf3x+0x98>
    28e8:	87 95       	ror	r24
    28ea:	77 95       	ror	r23
    28ec:	67 95       	ror	r22
    28ee:	b7 95       	ror	r27
    28f0:	f7 95       	ror	r31
    28f2:	9e 3f       	cpi	r25, 0xFE	; 254
    28f4:	08 f0       	brcs	.+2      	; 0x28f8 <__addsf3x+0x96>
    28f6:	b3 cf       	rjmp	.-154    	; 0x285e <__addsf3+0x1e>
    28f8:	93 95       	inc	r25
    28fa:	88 0f       	add	r24, r24
    28fc:	08 f0       	brcs	.+2      	; 0x2900 <__addsf3x+0x9e>
    28fe:	99 27       	eor	r25, r25
    2900:	ee 0f       	add	r30, r30
    2902:	97 95       	ror	r25
    2904:	87 95       	ror	r24
    2906:	08 95       	ret

00002908 <__fixsfsi>:
    2908:	04 d0       	rcall	.+8      	; 0x2912 <__fixunssfsi>
    290a:	68 94       	set
    290c:	b1 11       	cpse	r27, r1
    290e:	b5 c0       	rjmp	.+362    	; 0x2a7a <__fp_szero>
    2910:	08 95       	ret

00002912 <__fixunssfsi>:
    2912:	98 d0       	rcall	.+304    	; 0x2a44 <__fp_splitA>
    2914:	88 f0       	brcs	.+34     	; 0x2938 <__fixunssfsi+0x26>
    2916:	9f 57       	subi	r25, 0x7F	; 127
    2918:	90 f0       	brcs	.+36     	; 0x293e <__fixunssfsi+0x2c>
    291a:	b9 2f       	mov	r27, r25
    291c:	99 27       	eor	r25, r25
    291e:	b7 51       	subi	r27, 0x17	; 23
    2920:	a0 f0       	brcs	.+40     	; 0x294a <__fixunssfsi+0x38>
    2922:	d1 f0       	breq	.+52     	; 0x2958 <__fixunssfsi+0x46>
    2924:	66 0f       	add	r22, r22
    2926:	77 1f       	adc	r23, r23
    2928:	88 1f       	adc	r24, r24
    292a:	99 1f       	adc	r25, r25
    292c:	1a f0       	brmi	.+6      	; 0x2934 <__fixunssfsi+0x22>
    292e:	ba 95       	dec	r27
    2930:	c9 f7       	brne	.-14     	; 0x2924 <__fixunssfsi+0x12>
    2932:	12 c0       	rjmp	.+36     	; 0x2958 <__fixunssfsi+0x46>
    2934:	b1 30       	cpi	r27, 0x01	; 1
    2936:	81 f0       	breq	.+32     	; 0x2958 <__fixunssfsi+0x46>
    2938:	9f d0       	rcall	.+318    	; 0x2a78 <__fp_zero>
    293a:	b1 e0       	ldi	r27, 0x01	; 1
    293c:	08 95       	ret
    293e:	9c c0       	rjmp	.+312    	; 0x2a78 <__fp_zero>
    2940:	67 2f       	mov	r22, r23
    2942:	78 2f       	mov	r23, r24
    2944:	88 27       	eor	r24, r24
    2946:	b8 5f       	subi	r27, 0xF8	; 248
    2948:	39 f0       	breq	.+14     	; 0x2958 <__fixunssfsi+0x46>
    294a:	b9 3f       	cpi	r27, 0xF9	; 249
    294c:	cc f3       	brlt	.-14     	; 0x2940 <__fixunssfsi+0x2e>
    294e:	86 95       	lsr	r24
    2950:	77 95       	ror	r23
    2952:	67 95       	ror	r22
    2954:	b3 95       	inc	r27
    2956:	d9 f7       	brne	.-10     	; 0x294e <__fixunssfsi+0x3c>
    2958:	3e f4       	brtc	.+14     	; 0x2968 <__fixunssfsi+0x56>
    295a:	90 95       	com	r25
    295c:	80 95       	com	r24
    295e:	70 95       	com	r23
    2960:	61 95       	neg	r22
    2962:	7f 4f       	sbci	r23, 0xFF	; 255
    2964:	8f 4f       	sbci	r24, 0xFF	; 255
    2966:	9f 4f       	sbci	r25, 0xFF	; 255
    2968:	08 95       	ret

0000296a <__floatunsisf>:
    296a:	e8 94       	clt
    296c:	09 c0       	rjmp	.+18     	; 0x2980 <__floatsisf+0x12>

0000296e <__floatsisf>:
    296e:	97 fb       	bst	r25, 7
    2970:	3e f4       	brtc	.+14     	; 0x2980 <__floatsisf+0x12>
    2972:	90 95       	com	r25
    2974:	80 95       	com	r24
    2976:	70 95       	com	r23
    2978:	61 95       	neg	r22
    297a:	7f 4f       	sbci	r23, 0xFF	; 255
    297c:	8f 4f       	sbci	r24, 0xFF	; 255
    297e:	9f 4f       	sbci	r25, 0xFF	; 255
    2980:	99 23       	and	r25, r25
    2982:	a9 f0       	breq	.+42     	; 0x29ae <__floatsisf+0x40>
    2984:	f9 2f       	mov	r31, r25
    2986:	96 e9       	ldi	r25, 0x96	; 150
    2988:	bb 27       	eor	r27, r27
    298a:	93 95       	inc	r25
    298c:	f6 95       	lsr	r31
    298e:	87 95       	ror	r24
    2990:	77 95       	ror	r23
    2992:	67 95       	ror	r22
    2994:	b7 95       	ror	r27
    2996:	f1 11       	cpse	r31, r1
    2998:	f8 cf       	rjmp	.-16     	; 0x298a <__floatsisf+0x1c>
    299a:	fa f4       	brpl	.+62     	; 0x29da <__floatsisf+0x6c>
    299c:	bb 0f       	add	r27, r27
    299e:	11 f4       	brne	.+4      	; 0x29a4 <__floatsisf+0x36>
    29a0:	60 ff       	sbrs	r22, 0
    29a2:	1b c0       	rjmp	.+54     	; 0x29da <__floatsisf+0x6c>
    29a4:	6f 5f       	subi	r22, 0xFF	; 255
    29a6:	7f 4f       	sbci	r23, 0xFF	; 255
    29a8:	8f 4f       	sbci	r24, 0xFF	; 255
    29aa:	9f 4f       	sbci	r25, 0xFF	; 255
    29ac:	16 c0       	rjmp	.+44     	; 0x29da <__floatsisf+0x6c>
    29ae:	88 23       	and	r24, r24
    29b0:	11 f0       	breq	.+4      	; 0x29b6 <__floatsisf+0x48>
    29b2:	96 e9       	ldi	r25, 0x96	; 150
    29b4:	11 c0       	rjmp	.+34     	; 0x29d8 <__floatsisf+0x6a>
    29b6:	77 23       	and	r23, r23
    29b8:	21 f0       	breq	.+8      	; 0x29c2 <__floatsisf+0x54>
    29ba:	9e e8       	ldi	r25, 0x8E	; 142
    29bc:	87 2f       	mov	r24, r23
    29be:	76 2f       	mov	r23, r22
    29c0:	05 c0       	rjmp	.+10     	; 0x29cc <__floatsisf+0x5e>
    29c2:	66 23       	and	r22, r22
    29c4:	71 f0       	breq	.+28     	; 0x29e2 <__floatsisf+0x74>
    29c6:	96 e8       	ldi	r25, 0x86	; 134
    29c8:	86 2f       	mov	r24, r22
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	60 e0       	ldi	r22, 0x00	; 0
    29ce:	2a f0       	brmi	.+10     	; 0x29da <__floatsisf+0x6c>
    29d0:	9a 95       	dec	r25
    29d2:	66 0f       	add	r22, r22
    29d4:	77 1f       	adc	r23, r23
    29d6:	88 1f       	adc	r24, r24
    29d8:	da f7       	brpl	.-10     	; 0x29d0 <__floatsisf+0x62>
    29da:	88 0f       	add	r24, r24
    29dc:	96 95       	lsr	r25
    29de:	87 95       	ror	r24
    29e0:	97 f9       	bld	r25, 7
    29e2:	08 95       	ret

000029e4 <__fp_inf>:
    29e4:	97 f9       	bld	r25, 7
    29e6:	9f 67       	ori	r25, 0x7F	; 127
    29e8:	80 e8       	ldi	r24, 0x80	; 128
    29ea:	70 e0       	ldi	r23, 0x00	; 0
    29ec:	60 e0       	ldi	r22, 0x00	; 0
    29ee:	08 95       	ret

000029f0 <__fp_nan>:
    29f0:	9f ef       	ldi	r25, 0xFF	; 255
    29f2:	80 ec       	ldi	r24, 0xC0	; 192
    29f4:	08 95       	ret

000029f6 <__fp_pscA>:
    29f6:	00 24       	eor	r0, r0
    29f8:	0a 94       	dec	r0
    29fa:	16 16       	cp	r1, r22
    29fc:	17 06       	cpc	r1, r23
    29fe:	18 06       	cpc	r1, r24
    2a00:	09 06       	cpc	r0, r25
    2a02:	08 95       	ret

00002a04 <__fp_pscB>:
    2a04:	00 24       	eor	r0, r0
    2a06:	0a 94       	dec	r0
    2a08:	12 16       	cp	r1, r18
    2a0a:	13 06       	cpc	r1, r19
    2a0c:	14 06       	cpc	r1, r20
    2a0e:	05 06       	cpc	r0, r21
    2a10:	08 95       	ret

00002a12 <__fp_round>:
    2a12:	09 2e       	mov	r0, r25
    2a14:	03 94       	inc	r0
    2a16:	00 0c       	add	r0, r0
    2a18:	11 f4       	brne	.+4      	; 0x2a1e <__fp_round+0xc>
    2a1a:	88 23       	and	r24, r24
    2a1c:	52 f0       	brmi	.+20     	; 0x2a32 <__fp_round+0x20>
    2a1e:	bb 0f       	add	r27, r27
    2a20:	40 f4       	brcc	.+16     	; 0x2a32 <__fp_round+0x20>
    2a22:	bf 2b       	or	r27, r31
    2a24:	11 f4       	brne	.+4      	; 0x2a2a <__fp_round+0x18>
    2a26:	60 ff       	sbrs	r22, 0
    2a28:	04 c0       	rjmp	.+8      	; 0x2a32 <__fp_round+0x20>
    2a2a:	6f 5f       	subi	r22, 0xFF	; 255
    2a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2e:	8f 4f       	sbci	r24, 0xFF	; 255
    2a30:	9f 4f       	sbci	r25, 0xFF	; 255
    2a32:	08 95       	ret

00002a34 <__fp_split3>:
    2a34:	57 fd       	sbrc	r21, 7
    2a36:	90 58       	subi	r25, 0x80	; 128
    2a38:	44 0f       	add	r20, r20
    2a3a:	55 1f       	adc	r21, r21
    2a3c:	59 f0       	breq	.+22     	; 0x2a54 <__fp_splitA+0x10>
    2a3e:	5f 3f       	cpi	r21, 0xFF	; 255
    2a40:	71 f0       	breq	.+28     	; 0x2a5e <__fp_splitA+0x1a>
    2a42:	47 95       	ror	r20

00002a44 <__fp_splitA>:
    2a44:	88 0f       	add	r24, r24
    2a46:	97 fb       	bst	r25, 7
    2a48:	99 1f       	adc	r25, r25
    2a4a:	61 f0       	breq	.+24     	; 0x2a64 <__fp_splitA+0x20>
    2a4c:	9f 3f       	cpi	r25, 0xFF	; 255
    2a4e:	79 f0       	breq	.+30     	; 0x2a6e <__fp_splitA+0x2a>
    2a50:	87 95       	ror	r24
    2a52:	08 95       	ret
    2a54:	12 16       	cp	r1, r18
    2a56:	13 06       	cpc	r1, r19
    2a58:	14 06       	cpc	r1, r20
    2a5a:	55 1f       	adc	r21, r21
    2a5c:	f2 cf       	rjmp	.-28     	; 0x2a42 <__fp_split3+0xe>
    2a5e:	46 95       	lsr	r20
    2a60:	f1 df       	rcall	.-30     	; 0x2a44 <__fp_splitA>
    2a62:	08 c0       	rjmp	.+16     	; 0x2a74 <__fp_splitA+0x30>
    2a64:	16 16       	cp	r1, r22
    2a66:	17 06       	cpc	r1, r23
    2a68:	18 06       	cpc	r1, r24
    2a6a:	99 1f       	adc	r25, r25
    2a6c:	f1 cf       	rjmp	.-30     	; 0x2a50 <__fp_splitA+0xc>
    2a6e:	86 95       	lsr	r24
    2a70:	71 05       	cpc	r23, r1
    2a72:	61 05       	cpc	r22, r1
    2a74:	08 94       	sec
    2a76:	08 95       	ret

00002a78 <__fp_zero>:
    2a78:	e8 94       	clt

00002a7a <__fp_szero>:
    2a7a:	bb 27       	eor	r27, r27
    2a7c:	66 27       	eor	r22, r22
    2a7e:	77 27       	eor	r23, r23
    2a80:	cb 01       	movw	r24, r22
    2a82:	97 f9       	bld	r25, 7
    2a84:	08 95       	ret

00002a86 <__mulsf3>:
    2a86:	0b d0       	rcall	.+22     	; 0x2a9e <__mulsf3x>
    2a88:	c4 cf       	rjmp	.-120    	; 0x2a12 <__fp_round>
    2a8a:	b5 df       	rcall	.-150    	; 0x29f6 <__fp_pscA>
    2a8c:	28 f0       	brcs	.+10     	; 0x2a98 <__mulsf3+0x12>
    2a8e:	ba df       	rcall	.-140    	; 0x2a04 <__fp_pscB>
    2a90:	18 f0       	brcs	.+6      	; 0x2a98 <__mulsf3+0x12>
    2a92:	95 23       	and	r25, r21
    2a94:	09 f0       	breq	.+2      	; 0x2a98 <__mulsf3+0x12>
    2a96:	a6 cf       	rjmp	.-180    	; 0x29e4 <__fp_inf>
    2a98:	ab cf       	rjmp	.-170    	; 0x29f0 <__fp_nan>
    2a9a:	11 24       	eor	r1, r1
    2a9c:	ee cf       	rjmp	.-36     	; 0x2a7a <__fp_szero>

00002a9e <__mulsf3x>:
    2a9e:	ca df       	rcall	.-108    	; 0x2a34 <__fp_split3>
    2aa0:	a0 f3       	brcs	.-24     	; 0x2a8a <__mulsf3+0x4>

00002aa2 <__mulsf3_pse>:
    2aa2:	95 9f       	mul	r25, r21
    2aa4:	d1 f3       	breq	.-12     	; 0x2a9a <__mulsf3+0x14>
    2aa6:	95 0f       	add	r25, r21
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	55 1f       	adc	r21, r21
    2aac:	62 9f       	mul	r22, r18
    2aae:	f0 01       	movw	r30, r0
    2ab0:	72 9f       	mul	r23, r18
    2ab2:	bb 27       	eor	r27, r27
    2ab4:	f0 0d       	add	r31, r0
    2ab6:	b1 1d       	adc	r27, r1
    2ab8:	63 9f       	mul	r22, r19
    2aba:	aa 27       	eor	r26, r26
    2abc:	f0 0d       	add	r31, r0
    2abe:	b1 1d       	adc	r27, r1
    2ac0:	aa 1f       	adc	r26, r26
    2ac2:	64 9f       	mul	r22, r20
    2ac4:	66 27       	eor	r22, r22
    2ac6:	b0 0d       	add	r27, r0
    2ac8:	a1 1d       	adc	r26, r1
    2aca:	66 1f       	adc	r22, r22
    2acc:	82 9f       	mul	r24, r18
    2ace:	22 27       	eor	r18, r18
    2ad0:	b0 0d       	add	r27, r0
    2ad2:	a1 1d       	adc	r26, r1
    2ad4:	62 1f       	adc	r22, r18
    2ad6:	73 9f       	mul	r23, r19
    2ad8:	b0 0d       	add	r27, r0
    2ada:	a1 1d       	adc	r26, r1
    2adc:	62 1f       	adc	r22, r18
    2ade:	83 9f       	mul	r24, r19
    2ae0:	a0 0d       	add	r26, r0
    2ae2:	61 1d       	adc	r22, r1
    2ae4:	22 1f       	adc	r18, r18
    2ae6:	74 9f       	mul	r23, r20
    2ae8:	33 27       	eor	r19, r19
    2aea:	a0 0d       	add	r26, r0
    2aec:	61 1d       	adc	r22, r1
    2aee:	23 1f       	adc	r18, r19
    2af0:	84 9f       	mul	r24, r20
    2af2:	60 0d       	add	r22, r0
    2af4:	21 1d       	adc	r18, r1
    2af6:	82 2f       	mov	r24, r18
    2af8:	76 2f       	mov	r23, r22
    2afa:	6a 2f       	mov	r22, r26
    2afc:	11 24       	eor	r1, r1
    2afe:	9f 57       	subi	r25, 0x7F	; 127
    2b00:	50 40       	sbci	r21, 0x00	; 0
    2b02:	8a f0       	brmi	.+34     	; 0x2b26 <__mulsf3_pse+0x84>
    2b04:	e1 f0       	breq	.+56     	; 0x2b3e <__mulsf3_pse+0x9c>
    2b06:	88 23       	and	r24, r24
    2b08:	4a f0       	brmi	.+18     	; 0x2b1c <__mulsf3_pse+0x7a>
    2b0a:	ee 0f       	add	r30, r30
    2b0c:	ff 1f       	adc	r31, r31
    2b0e:	bb 1f       	adc	r27, r27
    2b10:	66 1f       	adc	r22, r22
    2b12:	77 1f       	adc	r23, r23
    2b14:	88 1f       	adc	r24, r24
    2b16:	91 50       	subi	r25, 0x01	; 1
    2b18:	50 40       	sbci	r21, 0x00	; 0
    2b1a:	a9 f7       	brne	.-22     	; 0x2b06 <__mulsf3_pse+0x64>
    2b1c:	9e 3f       	cpi	r25, 0xFE	; 254
    2b1e:	51 05       	cpc	r21, r1
    2b20:	70 f0       	brcs	.+28     	; 0x2b3e <__mulsf3_pse+0x9c>
    2b22:	60 cf       	rjmp	.-320    	; 0x29e4 <__fp_inf>
    2b24:	aa cf       	rjmp	.-172    	; 0x2a7a <__fp_szero>
    2b26:	5f 3f       	cpi	r21, 0xFF	; 255
    2b28:	ec f3       	brlt	.-6      	; 0x2b24 <__mulsf3_pse+0x82>
    2b2a:	98 3e       	cpi	r25, 0xE8	; 232
    2b2c:	dc f3       	brlt	.-10     	; 0x2b24 <__mulsf3_pse+0x82>
    2b2e:	86 95       	lsr	r24
    2b30:	77 95       	ror	r23
    2b32:	67 95       	ror	r22
    2b34:	b7 95       	ror	r27
    2b36:	f7 95       	ror	r31
    2b38:	e7 95       	ror	r30
    2b3a:	9f 5f       	subi	r25, 0xFF	; 255
    2b3c:	c1 f7       	brne	.-16     	; 0x2b2e <__mulsf3_pse+0x8c>
    2b3e:	fe 2b       	or	r31, r30
    2b40:	88 0f       	add	r24, r24
    2b42:	91 1d       	adc	r25, r1
    2b44:	96 95       	lsr	r25
    2b46:	87 95       	ror	r24
    2b48:	97 f9       	bld	r25, 7
    2b4a:	08 95       	ret

00002b4c <pow>:
    2b4c:	fa 01       	movw	r30, r20
    2b4e:	ee 0f       	add	r30, r30
    2b50:	ff 1f       	adc	r31, r31
    2b52:	30 96       	adiw	r30, 0x00	; 0
    2b54:	21 05       	cpc	r18, r1
    2b56:	31 05       	cpc	r19, r1
    2b58:	99 f1       	breq	.+102    	; 0x2bc0 <pow+0x74>
    2b5a:	61 15       	cp	r22, r1
    2b5c:	71 05       	cpc	r23, r1
    2b5e:	61 f4       	brne	.+24     	; 0x2b78 <pow+0x2c>
    2b60:	80 38       	cpi	r24, 0x80	; 128
    2b62:	bf e3       	ldi	r27, 0x3F	; 63
    2b64:	9b 07       	cpc	r25, r27
    2b66:	49 f1       	breq	.+82     	; 0x2bba <pow+0x6e>
    2b68:	68 94       	set
    2b6a:	90 38       	cpi	r25, 0x80	; 128
    2b6c:	81 05       	cpc	r24, r1
    2b6e:	61 f0       	breq	.+24     	; 0x2b88 <pow+0x3c>
    2b70:	80 38       	cpi	r24, 0x80	; 128
    2b72:	bf ef       	ldi	r27, 0xFF	; 255
    2b74:	9b 07       	cpc	r25, r27
    2b76:	41 f0       	breq	.+16     	; 0x2b88 <pow+0x3c>
    2b78:	99 23       	and	r25, r25
    2b7a:	42 f5       	brpl	.+80     	; 0x2bcc <pow+0x80>
    2b7c:	ff 3f       	cpi	r31, 0xFF	; 255
    2b7e:	e1 05       	cpc	r30, r1
    2b80:	31 05       	cpc	r19, r1
    2b82:	21 05       	cpc	r18, r1
    2b84:	11 f1       	breq	.+68     	; 0x2bca <pow+0x7e>
    2b86:	e8 94       	clt
    2b88:	08 94       	sec
    2b8a:	e7 95       	ror	r30
    2b8c:	d9 01       	movw	r26, r18
    2b8e:	aa 23       	and	r26, r26
    2b90:	29 f4       	brne	.+10     	; 0x2b9c <pow+0x50>
    2b92:	ab 2f       	mov	r26, r27
    2b94:	be 2f       	mov	r27, r30
    2b96:	f8 5f       	subi	r31, 0xF8	; 248
    2b98:	d0 f3       	brcs	.-12     	; 0x2b8e <pow+0x42>
    2b9a:	10 c0       	rjmp	.+32     	; 0x2bbc <pow+0x70>
    2b9c:	ff 5f       	subi	r31, 0xFF	; 255
    2b9e:	70 f4       	brcc	.+28     	; 0x2bbc <pow+0x70>
    2ba0:	a6 95       	lsr	r26
    2ba2:	e0 f7       	brcc	.-8      	; 0x2b9c <pow+0x50>
    2ba4:	f7 39       	cpi	r31, 0x97	; 151
    2ba6:	50 f0       	brcs	.+20     	; 0x2bbc <pow+0x70>
    2ba8:	19 f0       	breq	.+6      	; 0x2bb0 <pow+0x64>
    2baa:	ff 3a       	cpi	r31, 0xAF	; 175
    2bac:	38 f4       	brcc	.+14     	; 0x2bbc <pow+0x70>
    2bae:	9f 77       	andi	r25, 0x7F	; 127
    2bb0:	9f 93       	push	r25
    2bb2:	0c d0       	rcall	.+24     	; 0x2bcc <pow+0x80>
    2bb4:	0f 90       	pop	r0
    2bb6:	07 fc       	sbrc	r0, 7
    2bb8:	90 58       	subi	r25, 0x80	; 128
    2bba:	08 95       	ret
    2bbc:	3e f0       	brts	.+14     	; 0x2bcc <pow+0x80>
    2bbe:	18 cf       	rjmp	.-464    	; 0x29f0 <__fp_nan>
    2bc0:	60 e0       	ldi	r22, 0x00	; 0
    2bc2:	70 e0       	ldi	r23, 0x00	; 0
    2bc4:	80 e8       	ldi	r24, 0x80	; 128
    2bc6:	9f e3       	ldi	r25, 0x3F	; 63
    2bc8:	08 95       	ret
    2bca:	4f e7       	ldi	r20, 0x7F	; 127
    2bcc:	9f 77       	andi	r25, 0x7F	; 127
    2bce:	5f 93       	push	r21
    2bd0:	4f 93       	push	r20
    2bd2:	3f 93       	push	r19
    2bd4:	2f 93       	push	r18
    2bd6:	9e d0       	rcall	.+316    	; 0x2d14 <log>
    2bd8:	2f 91       	pop	r18
    2bda:	3f 91       	pop	r19
    2bdc:	4f 91       	pop	r20
    2bde:	5f 91       	pop	r21
    2be0:	52 df       	rcall	.-348    	; 0x2a86 <__mulsf3>
    2be2:	05 c0       	rjmp	.+10     	; 0x2bee <exp>
    2be4:	19 f4       	brne	.+6      	; 0x2bec <pow+0xa0>
    2be6:	0e f0       	brts	.+2      	; 0x2bea <pow+0x9e>
    2be8:	fd ce       	rjmp	.-518    	; 0x29e4 <__fp_inf>
    2bea:	46 cf       	rjmp	.-372    	; 0x2a78 <__fp_zero>
    2bec:	01 cf       	rjmp	.-510    	; 0x29f0 <__fp_nan>

00002bee <exp>:
    2bee:	2a df       	rcall	.-428    	; 0x2a44 <__fp_splitA>
    2bf0:	c8 f3       	brcs	.-14     	; 0x2be4 <pow+0x98>
    2bf2:	96 38       	cpi	r25, 0x86	; 134
    2bf4:	c0 f7       	brcc	.-16     	; 0x2be6 <pow+0x9a>
    2bf6:	07 f8       	bld	r0, 7
    2bf8:	0f 92       	push	r0
    2bfa:	e8 94       	clt
    2bfc:	2b e3       	ldi	r18, 0x3B	; 59
    2bfe:	3a ea       	ldi	r19, 0xAA	; 170
    2c00:	48 eb       	ldi	r20, 0xB8	; 184
    2c02:	5f e7       	ldi	r21, 0x7F	; 127
    2c04:	4e df       	rcall	.-356    	; 0x2aa2 <__mulsf3_pse>
    2c06:	0f 92       	push	r0
    2c08:	0f 92       	push	r0
    2c0a:	0f 92       	push	r0
    2c0c:	4d b7       	in	r20, 0x3d	; 61
    2c0e:	5e b7       	in	r21, 0x3e	; 62
    2c10:	0f 92       	push	r0
    2c12:	c0 d0       	rcall	.+384    	; 0x2d94 <modf>
    2c14:	e4 ee       	ldi	r30, 0xE4	; 228
    2c16:	f0 e0       	ldi	r31, 0x00	; 0
    2c18:	16 d0       	rcall	.+44     	; 0x2c46 <__fp_powser>
    2c1a:	4f 91       	pop	r20
    2c1c:	5f 91       	pop	r21
    2c1e:	ef 91       	pop	r30
    2c20:	ff 91       	pop	r31
    2c22:	e5 95       	asr	r30
    2c24:	ee 1f       	adc	r30, r30
    2c26:	ff 1f       	adc	r31, r31
    2c28:	49 f0       	breq	.+18     	; 0x2c3c <exp+0x4e>
    2c2a:	fe 57       	subi	r31, 0x7E	; 126
    2c2c:	e0 68       	ori	r30, 0x80	; 128
    2c2e:	44 27       	eor	r20, r20
    2c30:	ee 0f       	add	r30, r30
    2c32:	44 1f       	adc	r20, r20
    2c34:	fa 95       	dec	r31
    2c36:	e1 f7       	brne	.-8      	; 0x2c30 <exp+0x42>
    2c38:	41 95       	neg	r20
    2c3a:	55 0b       	sbc	r21, r21
    2c3c:	32 d0       	rcall	.+100    	; 0x2ca2 <ldexp>
    2c3e:	0f 90       	pop	r0
    2c40:	07 fe       	sbrs	r0, 7
    2c42:	26 c0       	rjmp	.+76     	; 0x2c90 <inverse>
    2c44:	08 95       	ret

00002c46 <__fp_powser>:
    2c46:	df 93       	push	r29
    2c48:	cf 93       	push	r28
    2c4a:	1f 93       	push	r17
    2c4c:	0f 93       	push	r16
    2c4e:	ff 92       	push	r15
    2c50:	ef 92       	push	r14
    2c52:	df 92       	push	r13
    2c54:	7b 01       	movw	r14, r22
    2c56:	8c 01       	movw	r16, r24
    2c58:	68 94       	set
    2c5a:	05 c0       	rjmp	.+10     	; 0x2c66 <__fp_powser+0x20>
    2c5c:	da 2e       	mov	r13, r26
    2c5e:	ef 01       	movw	r28, r30
    2c60:	1e df       	rcall	.-452    	; 0x2a9e <__mulsf3x>
    2c62:	fe 01       	movw	r30, r28
    2c64:	e8 94       	clt
    2c66:	a5 91       	lpm	r26, Z+
    2c68:	25 91       	lpm	r18, Z+
    2c6a:	35 91       	lpm	r19, Z+
    2c6c:	45 91       	lpm	r20, Z+
    2c6e:	55 91       	lpm	r21, Z+
    2c70:	ae f3       	brts	.-22     	; 0x2c5c <__fp_powser+0x16>
    2c72:	ef 01       	movw	r28, r30
    2c74:	f6 dd       	rcall	.-1044   	; 0x2862 <__addsf3x>
    2c76:	fe 01       	movw	r30, r28
    2c78:	97 01       	movw	r18, r14
    2c7a:	a8 01       	movw	r20, r16
    2c7c:	da 94       	dec	r13
    2c7e:	79 f7       	brne	.-34     	; 0x2c5e <__fp_powser+0x18>
    2c80:	df 90       	pop	r13
    2c82:	ef 90       	pop	r14
    2c84:	ff 90       	pop	r15
    2c86:	0f 91       	pop	r16
    2c88:	1f 91       	pop	r17
    2c8a:	cf 91       	pop	r28
    2c8c:	df 91       	pop	r29
    2c8e:	08 95       	ret

00002c90 <inverse>:
    2c90:	9b 01       	movw	r18, r22
    2c92:	ac 01       	movw	r20, r24
    2c94:	60 e0       	ldi	r22, 0x00	; 0
    2c96:	70 e0       	ldi	r23, 0x00	; 0
    2c98:	80 e8       	ldi	r24, 0x80	; 128
    2c9a:	9f e3       	ldi	r25, 0x3F	; 63
    2c9c:	ae c0       	rjmp	.+348    	; 0x2dfa <__divsf3>
    2c9e:	a2 ce       	rjmp	.-700    	; 0x29e4 <__fp_inf>
    2ca0:	14 c1       	rjmp	.+552    	; 0x2eca <__fp_mpack>

00002ca2 <ldexp>:
    2ca2:	d0 de       	rcall	.-608    	; 0x2a44 <__fp_splitA>
    2ca4:	e8 f3       	brcs	.-6      	; 0x2ca0 <inverse+0x10>
    2ca6:	99 23       	and	r25, r25
    2ca8:	d9 f3       	breq	.-10     	; 0x2ca0 <inverse+0x10>
    2caa:	94 0f       	add	r25, r20
    2cac:	51 1d       	adc	r21, r1
    2cae:	bb f3       	brvs	.-18     	; 0x2c9e <inverse+0xe>
    2cb0:	91 50       	subi	r25, 0x01	; 1
    2cb2:	50 40       	sbci	r21, 0x00	; 0
    2cb4:	94 f0       	brlt	.+36     	; 0x2cda <ldexp+0x38>
    2cb6:	59 f0       	breq	.+22     	; 0x2cce <ldexp+0x2c>
    2cb8:	88 23       	and	r24, r24
    2cba:	32 f0       	brmi	.+12     	; 0x2cc8 <ldexp+0x26>
    2cbc:	66 0f       	add	r22, r22
    2cbe:	77 1f       	adc	r23, r23
    2cc0:	88 1f       	adc	r24, r24
    2cc2:	91 50       	subi	r25, 0x01	; 1
    2cc4:	50 40       	sbci	r21, 0x00	; 0
    2cc6:	c1 f7       	brne	.-16     	; 0x2cb8 <ldexp+0x16>
    2cc8:	9e 3f       	cpi	r25, 0xFE	; 254
    2cca:	51 05       	cpc	r21, r1
    2ccc:	44 f7       	brge	.-48     	; 0x2c9e <inverse+0xe>
    2cce:	88 0f       	add	r24, r24
    2cd0:	91 1d       	adc	r25, r1
    2cd2:	96 95       	lsr	r25
    2cd4:	87 95       	ror	r24
    2cd6:	97 f9       	bld	r25, 7
    2cd8:	08 95       	ret
    2cda:	5f 3f       	cpi	r21, 0xFF	; 255
    2cdc:	ac f0       	brlt	.+42     	; 0x2d08 <ldexp+0x66>
    2cde:	98 3e       	cpi	r25, 0xE8	; 232
    2ce0:	9c f0       	brlt	.+38     	; 0x2d08 <ldexp+0x66>
    2ce2:	bb 27       	eor	r27, r27
    2ce4:	86 95       	lsr	r24
    2ce6:	77 95       	ror	r23
    2ce8:	67 95       	ror	r22
    2cea:	b7 95       	ror	r27
    2cec:	08 f4       	brcc	.+2      	; 0x2cf0 <ldexp+0x4e>
    2cee:	b1 60       	ori	r27, 0x01	; 1
    2cf0:	93 95       	inc	r25
    2cf2:	c1 f7       	brne	.-16     	; 0x2ce4 <ldexp+0x42>
    2cf4:	bb 0f       	add	r27, r27
    2cf6:	58 f7       	brcc	.-42     	; 0x2cce <ldexp+0x2c>
    2cf8:	11 f4       	brne	.+4      	; 0x2cfe <ldexp+0x5c>
    2cfa:	60 ff       	sbrs	r22, 0
    2cfc:	e8 cf       	rjmp	.-48     	; 0x2cce <ldexp+0x2c>
    2cfe:	6f 5f       	subi	r22, 0xFF	; 255
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	8f 4f       	sbci	r24, 0xFF	; 255
    2d04:	9f 4f       	sbci	r25, 0xFF	; 255
    2d06:	e3 cf       	rjmp	.-58     	; 0x2cce <ldexp+0x2c>
    2d08:	b8 ce       	rjmp	.-656    	; 0x2a7a <__fp_szero>
    2d0a:	0e f0       	brts	.+2      	; 0x2d0e <ldexp+0x6c>
    2d0c:	de c0       	rjmp	.+444    	; 0x2eca <__fp_mpack>
    2d0e:	70 ce       	rjmp	.-800    	; 0x29f0 <__fp_nan>
    2d10:	68 94       	set
    2d12:	68 ce       	rjmp	.-816    	; 0x29e4 <__fp_inf>

00002d14 <log>:
    2d14:	97 de       	rcall	.-722    	; 0x2a44 <__fp_splitA>
    2d16:	c8 f3       	brcs	.-14     	; 0x2d0a <ldexp+0x68>
    2d18:	99 23       	and	r25, r25
    2d1a:	d1 f3       	breq	.-12     	; 0x2d10 <ldexp+0x6e>
    2d1c:	c6 f3       	brts	.-16     	; 0x2d0e <ldexp+0x6c>
    2d1e:	df 93       	push	r29
    2d20:	cf 93       	push	r28
    2d22:	1f 93       	push	r17
    2d24:	0f 93       	push	r16
    2d26:	ff 92       	push	r15
    2d28:	c9 2f       	mov	r28, r25
    2d2a:	dd 27       	eor	r29, r29
    2d2c:	88 23       	and	r24, r24
    2d2e:	2a f0       	brmi	.+10     	; 0x2d3a <log+0x26>
    2d30:	21 97       	sbiw	r28, 0x01	; 1
    2d32:	66 0f       	add	r22, r22
    2d34:	77 1f       	adc	r23, r23
    2d36:	88 1f       	adc	r24, r24
    2d38:	da f7       	brpl	.-10     	; 0x2d30 <log+0x1c>
    2d3a:	20 e0       	ldi	r18, 0x00	; 0
    2d3c:	30 e0       	ldi	r19, 0x00	; 0
    2d3e:	40 e8       	ldi	r20, 0x80	; 128
    2d40:	5f eb       	ldi	r21, 0xBF	; 191
    2d42:	9f e3       	ldi	r25, 0x3F	; 63
    2d44:	88 39       	cpi	r24, 0x98	; 152
    2d46:	20 f0       	brcs	.+8      	; 0x2d50 <log+0x3c>
    2d48:	80 3e       	cpi	r24, 0xE0	; 224
    2d4a:	30 f0       	brcs	.+12     	; 0x2d58 <log+0x44>
    2d4c:	21 96       	adiw	r28, 0x01	; 1
    2d4e:	8f 77       	andi	r24, 0x7F	; 127
    2d50:	77 dd       	rcall	.-1298   	; 0x2840 <__addsf3>
    2d52:	ec e0       	ldi	r30, 0x0C	; 12
    2d54:	f1 e0       	ldi	r31, 0x01	; 1
    2d56:	03 c0       	rjmp	.+6      	; 0x2d5e <log+0x4a>
    2d58:	73 dd       	rcall	.-1306   	; 0x2840 <__addsf3>
    2d5a:	e9 e3       	ldi	r30, 0x39	; 57
    2d5c:	f1 e0       	ldi	r31, 0x01	; 1
    2d5e:	73 df       	rcall	.-282    	; 0x2c46 <__fp_powser>
    2d60:	8b 01       	movw	r16, r22
    2d62:	be 01       	movw	r22, r28
    2d64:	ec 01       	movw	r28, r24
    2d66:	fb 2e       	mov	r15, r27
    2d68:	6f 57       	subi	r22, 0x7F	; 127
    2d6a:	71 09       	sbc	r23, r1
    2d6c:	75 95       	asr	r23
    2d6e:	77 1f       	adc	r23, r23
    2d70:	88 0b       	sbc	r24, r24
    2d72:	99 0b       	sbc	r25, r25
    2d74:	fc dd       	rcall	.-1032   	; 0x296e <__floatsisf>
    2d76:	28 e1       	ldi	r18, 0x18	; 24
    2d78:	32 e7       	ldi	r19, 0x72	; 114
    2d7a:	41 e3       	ldi	r20, 0x31	; 49
    2d7c:	5f e3       	ldi	r21, 0x3F	; 63
    2d7e:	8f de       	rcall	.-738    	; 0x2a9e <__mulsf3x>
    2d80:	af 2d       	mov	r26, r15
    2d82:	98 01       	movw	r18, r16
    2d84:	ae 01       	movw	r20, r28
    2d86:	ff 90       	pop	r15
    2d88:	0f 91       	pop	r16
    2d8a:	1f 91       	pop	r17
    2d8c:	cf 91       	pop	r28
    2d8e:	df 91       	pop	r29
    2d90:	68 dd       	rcall	.-1328   	; 0x2862 <__addsf3x>
    2d92:	3f ce       	rjmp	.-898    	; 0x2a12 <__fp_round>

00002d94 <modf>:
    2d94:	fa 01       	movw	r30, r20
    2d96:	dc 01       	movw	r26, r24
    2d98:	aa 0f       	add	r26, r26
    2d9a:	bb 1f       	adc	r27, r27
    2d9c:	9b 01       	movw	r18, r22
    2d9e:	ac 01       	movw	r20, r24
    2da0:	bf 57       	subi	r27, 0x7F	; 127
    2da2:	28 f4       	brcc	.+10     	; 0x2dae <modf+0x1a>
    2da4:	22 27       	eor	r18, r18
    2da6:	33 27       	eor	r19, r19
    2da8:	44 27       	eor	r20, r20
    2daa:	50 78       	andi	r21, 0x80	; 128
    2dac:	1f c0       	rjmp	.+62     	; 0x2dec <modf+0x58>
    2dae:	b7 51       	subi	r27, 0x17	; 23
    2db0:	88 f4       	brcc	.+34     	; 0x2dd4 <modf+0x40>
    2db2:	ab 2f       	mov	r26, r27
    2db4:	00 24       	eor	r0, r0
    2db6:	46 95       	lsr	r20
    2db8:	37 95       	ror	r19
    2dba:	27 95       	ror	r18
    2dbc:	01 1c       	adc	r0, r1
    2dbe:	a3 95       	inc	r26
    2dc0:	d2 f3       	brmi	.-12     	; 0x2db6 <modf+0x22>
    2dc2:	00 20       	and	r0, r0
    2dc4:	69 f0       	breq	.+26     	; 0x2de0 <modf+0x4c>
    2dc6:	22 0f       	add	r18, r18
    2dc8:	33 1f       	adc	r19, r19
    2dca:	44 1f       	adc	r20, r20
    2dcc:	b3 95       	inc	r27
    2dce:	da f3       	brmi	.-10     	; 0x2dc6 <modf+0x32>
    2dd0:	0d d0       	rcall	.+26     	; 0x2dec <modf+0x58>
    2dd2:	35 cd       	rjmp	.-1430   	; 0x283e <__subsf3>
    2dd4:	61 30       	cpi	r22, 0x01	; 1
    2dd6:	71 05       	cpc	r23, r1
    2dd8:	a0 e8       	ldi	r26, 0x80	; 128
    2dda:	8a 07       	cpc	r24, r26
    2ddc:	b9 46       	sbci	r27, 0x69	; 105
    2dde:	30 f4       	brcc	.+12     	; 0x2dec <modf+0x58>
    2de0:	9b 01       	movw	r18, r22
    2de2:	ac 01       	movw	r20, r24
    2de4:	66 27       	eor	r22, r22
    2de6:	77 27       	eor	r23, r23
    2de8:	88 27       	eor	r24, r24
    2dea:	90 78       	andi	r25, 0x80	; 128
    2dec:	30 96       	adiw	r30, 0x00	; 0
    2dee:	21 f0       	breq	.+8      	; 0x2df8 <modf+0x64>
    2df0:	20 83       	st	Z, r18
    2df2:	31 83       	std	Z+1, r19	; 0x01
    2df4:	42 83       	std	Z+2, r20	; 0x02
    2df6:	53 83       	std	Z+3, r21	; 0x03
    2df8:	08 95       	ret

00002dfa <__divsf3>:
    2dfa:	0c d0       	rcall	.+24     	; 0x2e14 <__divsf3x>
    2dfc:	0a ce       	rjmp	.-1004   	; 0x2a12 <__fp_round>
    2dfe:	02 de       	rcall	.-1020   	; 0x2a04 <__fp_pscB>
    2e00:	40 f0       	brcs	.+16     	; 0x2e12 <__divsf3+0x18>
    2e02:	f9 dd       	rcall	.-1038   	; 0x29f6 <__fp_pscA>
    2e04:	30 f0       	brcs	.+12     	; 0x2e12 <__divsf3+0x18>
    2e06:	21 f4       	brne	.+8      	; 0x2e10 <__divsf3+0x16>
    2e08:	5f 3f       	cpi	r21, 0xFF	; 255
    2e0a:	19 f0       	breq	.+6      	; 0x2e12 <__divsf3+0x18>
    2e0c:	eb cd       	rjmp	.-1066   	; 0x29e4 <__fp_inf>
    2e0e:	51 11       	cpse	r21, r1
    2e10:	34 ce       	rjmp	.-920    	; 0x2a7a <__fp_szero>
    2e12:	ee cd       	rjmp	.-1060   	; 0x29f0 <__fp_nan>

00002e14 <__divsf3x>:
    2e14:	0f de       	rcall	.-994    	; 0x2a34 <__fp_split3>
    2e16:	98 f3       	brcs	.-26     	; 0x2dfe <__divsf3+0x4>

00002e18 <__divsf3_pse>:
    2e18:	99 23       	and	r25, r25
    2e1a:	c9 f3       	breq	.-14     	; 0x2e0e <__divsf3+0x14>
    2e1c:	55 23       	and	r21, r21
    2e1e:	b1 f3       	breq	.-20     	; 0x2e0c <__divsf3+0x12>
    2e20:	95 1b       	sub	r25, r21
    2e22:	55 0b       	sbc	r21, r21
    2e24:	bb 27       	eor	r27, r27
    2e26:	aa 27       	eor	r26, r26
    2e28:	62 17       	cp	r22, r18
    2e2a:	73 07       	cpc	r23, r19
    2e2c:	84 07       	cpc	r24, r20
    2e2e:	38 f0       	brcs	.+14     	; 0x2e3e <__divsf3_pse+0x26>
    2e30:	9f 5f       	subi	r25, 0xFF	; 255
    2e32:	5f 4f       	sbci	r21, 0xFF	; 255
    2e34:	22 0f       	add	r18, r18
    2e36:	33 1f       	adc	r19, r19
    2e38:	44 1f       	adc	r20, r20
    2e3a:	aa 1f       	adc	r26, r26
    2e3c:	a9 f3       	breq	.-22     	; 0x2e28 <__divsf3_pse+0x10>
    2e3e:	33 d0       	rcall	.+102    	; 0x2ea6 <__divsf3_pse+0x8e>
    2e40:	0e 2e       	mov	r0, r30
    2e42:	3a f0       	brmi	.+14     	; 0x2e52 <__divsf3_pse+0x3a>
    2e44:	e0 e8       	ldi	r30, 0x80	; 128
    2e46:	30 d0       	rcall	.+96     	; 0x2ea8 <__divsf3_pse+0x90>
    2e48:	91 50       	subi	r25, 0x01	; 1
    2e4a:	50 40       	sbci	r21, 0x00	; 0
    2e4c:	e6 95       	lsr	r30
    2e4e:	00 1c       	adc	r0, r0
    2e50:	ca f7       	brpl	.-14     	; 0x2e44 <__divsf3_pse+0x2c>
    2e52:	29 d0       	rcall	.+82     	; 0x2ea6 <__divsf3_pse+0x8e>
    2e54:	fe 2f       	mov	r31, r30
    2e56:	27 d0       	rcall	.+78     	; 0x2ea6 <__divsf3_pse+0x8e>
    2e58:	66 0f       	add	r22, r22
    2e5a:	77 1f       	adc	r23, r23
    2e5c:	88 1f       	adc	r24, r24
    2e5e:	bb 1f       	adc	r27, r27
    2e60:	26 17       	cp	r18, r22
    2e62:	37 07       	cpc	r19, r23
    2e64:	48 07       	cpc	r20, r24
    2e66:	ab 07       	cpc	r26, r27
    2e68:	b0 e8       	ldi	r27, 0x80	; 128
    2e6a:	09 f0       	breq	.+2      	; 0x2e6e <__divsf3_pse+0x56>
    2e6c:	bb 0b       	sbc	r27, r27
    2e6e:	80 2d       	mov	r24, r0
    2e70:	bf 01       	movw	r22, r30
    2e72:	ff 27       	eor	r31, r31
    2e74:	93 58       	subi	r25, 0x83	; 131
    2e76:	5f 4f       	sbci	r21, 0xFF	; 255
    2e78:	2a f0       	brmi	.+10     	; 0x2e84 <__divsf3_pse+0x6c>
    2e7a:	9e 3f       	cpi	r25, 0xFE	; 254
    2e7c:	51 05       	cpc	r21, r1
    2e7e:	68 f0       	brcs	.+26     	; 0x2e9a <__divsf3_pse+0x82>
    2e80:	b1 cd       	rjmp	.-1182   	; 0x29e4 <__fp_inf>
    2e82:	fb cd       	rjmp	.-1034   	; 0x2a7a <__fp_szero>
    2e84:	5f 3f       	cpi	r21, 0xFF	; 255
    2e86:	ec f3       	brlt	.-6      	; 0x2e82 <__divsf3_pse+0x6a>
    2e88:	98 3e       	cpi	r25, 0xE8	; 232
    2e8a:	dc f3       	brlt	.-10     	; 0x2e82 <__divsf3_pse+0x6a>
    2e8c:	86 95       	lsr	r24
    2e8e:	77 95       	ror	r23
    2e90:	67 95       	ror	r22
    2e92:	b7 95       	ror	r27
    2e94:	f7 95       	ror	r31
    2e96:	9f 5f       	subi	r25, 0xFF	; 255
    2e98:	c9 f7       	brne	.-14     	; 0x2e8c <__divsf3_pse+0x74>
    2e9a:	88 0f       	add	r24, r24
    2e9c:	91 1d       	adc	r25, r1
    2e9e:	96 95       	lsr	r25
    2ea0:	87 95       	ror	r24
    2ea2:	97 f9       	bld	r25, 7
    2ea4:	08 95       	ret
    2ea6:	e1 e0       	ldi	r30, 0x01	; 1
    2ea8:	66 0f       	add	r22, r22
    2eaa:	77 1f       	adc	r23, r23
    2eac:	88 1f       	adc	r24, r24
    2eae:	bb 1f       	adc	r27, r27
    2eb0:	62 17       	cp	r22, r18
    2eb2:	73 07       	cpc	r23, r19
    2eb4:	84 07       	cpc	r24, r20
    2eb6:	ba 07       	cpc	r27, r26
    2eb8:	20 f0       	brcs	.+8      	; 0x2ec2 <__divsf3_pse+0xaa>
    2eba:	62 1b       	sub	r22, r18
    2ebc:	73 0b       	sbc	r23, r19
    2ebe:	84 0b       	sbc	r24, r20
    2ec0:	ba 0b       	sbc	r27, r26
    2ec2:	ee 1f       	adc	r30, r30
    2ec4:	88 f7       	brcc	.-30     	; 0x2ea8 <__divsf3_pse+0x90>
    2ec6:	e0 95       	com	r30
    2ec8:	08 95       	ret

00002eca <__fp_mpack>:
    2eca:	9f 3f       	cpi	r25, 0xFF	; 255
    2ecc:	31 f0       	breq	.+12     	; 0x2eda <__fp_mpack_finite+0xc>

00002ece <__fp_mpack_finite>:
    2ece:	91 50       	subi	r25, 0x01	; 1
    2ed0:	20 f4       	brcc	.+8      	; 0x2eda <__fp_mpack_finite+0xc>
    2ed2:	87 95       	ror	r24
    2ed4:	77 95       	ror	r23
    2ed6:	67 95       	ror	r22
    2ed8:	b7 95       	ror	r27
    2eda:	88 0f       	add	r24, r24
    2edc:	91 1d       	adc	r25, r1
    2ede:	96 95       	lsr	r25
    2ee0:	87 95       	ror	r24
    2ee2:	97 f9       	bld	r25, 7
    2ee4:	08 95       	ret

00002ee6 <__divmodhi4>:
    2ee6:	97 fb       	bst	r25, 7
    2ee8:	07 2e       	mov	r0, r23
    2eea:	16 f4       	brtc	.+4      	; 0x2ef0 <__divmodhi4+0xa>
    2eec:	00 94       	com	r0
    2eee:	06 d0       	rcall	.+12     	; 0x2efc <__divmodhi4_neg1>
    2ef0:	77 fd       	sbrc	r23, 7
    2ef2:	08 d0       	rcall	.+16     	; 0x2f04 <__divmodhi4_neg2>
    2ef4:	0b d0       	rcall	.+22     	; 0x2f0c <__udivmodhi4>
    2ef6:	07 fc       	sbrc	r0, 7
    2ef8:	05 d0       	rcall	.+10     	; 0x2f04 <__divmodhi4_neg2>
    2efa:	3e f4       	brtc	.+14     	; 0x2f0a <__divmodhi4_exit>

00002efc <__divmodhi4_neg1>:
    2efc:	90 95       	com	r25
    2efe:	81 95       	neg	r24
    2f00:	9f 4f       	sbci	r25, 0xFF	; 255
    2f02:	08 95       	ret

00002f04 <__divmodhi4_neg2>:
    2f04:	70 95       	com	r23
    2f06:	61 95       	neg	r22
    2f08:	7f 4f       	sbci	r23, 0xFF	; 255

00002f0a <__divmodhi4_exit>:
    2f0a:	08 95       	ret

00002f0c <__udivmodhi4>:
    2f0c:	aa 1b       	sub	r26, r26
    2f0e:	bb 1b       	sub	r27, r27
    2f10:	51 e1       	ldi	r21, 0x11	; 17
    2f12:	07 c0       	rjmp	.+14     	; 0x2f22 <__udivmodhi4_ep>

00002f14 <__udivmodhi4_loop>:
    2f14:	aa 1f       	adc	r26, r26
    2f16:	bb 1f       	adc	r27, r27
    2f18:	a6 17       	cp	r26, r22
    2f1a:	b7 07       	cpc	r27, r23
    2f1c:	10 f0       	brcs	.+4      	; 0x2f22 <__udivmodhi4_ep>
    2f1e:	a6 1b       	sub	r26, r22
    2f20:	b7 0b       	sbc	r27, r23

00002f22 <__udivmodhi4_ep>:
    2f22:	88 1f       	adc	r24, r24
    2f24:	99 1f       	adc	r25, r25
    2f26:	5a 95       	dec	r21
    2f28:	a9 f7       	brne	.-22     	; 0x2f14 <__udivmodhi4_loop>
    2f2a:	80 95       	com	r24
    2f2c:	90 95       	com	r25
    2f2e:	bc 01       	movw	r22, r24
    2f30:	cd 01       	movw	r24, r26
    2f32:	08 95       	ret

00002f34 <memcpy>:
    2f34:	fb 01       	movw	r30, r22
    2f36:	dc 01       	movw	r26, r24
    2f38:	02 c0       	rjmp	.+4      	; 0x2f3e <memcpy+0xa>
    2f3a:	01 90       	ld	r0, Z+
    2f3c:	0d 92       	st	X+, r0
    2f3e:	41 50       	subi	r20, 0x01	; 1
    2f40:	50 40       	sbci	r21, 0x00	; 0
    2f42:	d8 f7       	brcc	.-10     	; 0x2f3a <memcpy+0x6>
    2f44:	08 95       	ret

00002f46 <_exit>:
    2f46:	f8 94       	cli

00002f48 <__stop_program>:
    2f48:	ff cf       	rjmp	.-2      	; 0x2f48 <__stop_program>
