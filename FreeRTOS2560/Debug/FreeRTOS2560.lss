
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002c04  00002c98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c04  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000705  0080023e  0080023e  00002cd6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002cd6  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000510  00000000  00000000  00002d06  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000059f6  00000000  00000000  00003216  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000015b0  00000000  00000000  00008c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000035af  00000000  00000000  0000a1bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000e4c  00000000  00000000  0000d76c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001619  00000000  00000000  0000e5b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003cd5  00000000  00000000  0000fbd1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004b0  00000000  00000000  000138a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	cc c3       	rjmp	.+1944   	; 0x7be <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 57 09 	jmp	0x12ae	; 0x12ae <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c6       	rjmp	.+3102   	; 0xc84 <__vector_25>
      66:	00 00       	nop
      68:	7b c6       	rjmp	.+3318   	; 0xd60 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	53 c4       	rjmp	.+2214   	; 0x91c <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	c1 c5       	rjmp	.+2946   	; 0xc14 <__vector_36>
      92:	00 00       	nop
      94:	2f c6       	rjmp	.+3166   	; 0xcf4 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <__vector_29+0x44>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 e0       	ldi	r30, 0x04	; 4
     17e:	fc e2       	ldi	r31, 0x2C	; 44
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a3 34       	cpi	r26, 0x43	; 67
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	f7 d1       	rcall	.+1006   	; 0x590 <main>
     1a2:	0c 94 00 16 	jmp	0x2c00	; 0x2c00 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	f0 d6       	rcall	.+3552   	; 0xf8a <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	dc d6       	rcall	.+3512   	; 0xf66 <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	9e d6       	rcall	.+3388   	; 0xef0 <myUSART_receiveUSART1>
     1b4:	cd d6       	rcall	.+3482   	; 0xf50 <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	e1 d6       	rcall	.+3522   	; 0xf7e <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	11 f0       	breq	.+4      	; 0x1c4 <RPI_receiveTask+0x1c>
     1c0:	97 d6       	rcall	.+3374   	; 0xef0 <myUSART_receiveUSART1>
     1c2:	f2 cf       	rjmp	.-28     	; 0x1a8 <RPI_receiveTask>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	d5 d6       	rcall	.+3498   	; 0xf72 <myUSART_receiveHandShakeStart>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <RPI_receiveTask+0x28>
     1cc:	b2 d6       	rcall	.+3428   	; 0xf32 <myUSART_waitForHandshake>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	8f d6       	rcall	.+3358   	; 0xef0 <myUSART_receiveUSART1>
     1d2:	ea cf       	rjmp	.-44     	; 0x1a8 <RPI_receiveTask>

000001d4 <RPI_sendTask>:
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <RPI_sendTask+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <RPI_sendTask+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	4f ef       	ldi	r20, 0xFF	; 255
     1e4:	5f ef       	ldi	r21, 0xFF	; 255
     1e6:	be 01       	movw	r22, r28
     1e8:	6a 5f       	subi	r22, 0xFA	; 250
     1ea:	7f 4f       	sbci	r23, 0xFF	; 255
     1ec:	80 91 8b 08 	lds	r24, 0x088B
     1f0:	90 91 8c 08 	lds	r25, 0x088C
     1f4:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <xQueueGenericReceive>
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	80 5d       	subi	r24, 0xD0	; 208
     1fc:	46 d6       	rcall	.+3212   	; 0xe8a <myUSART_transmitUSART1_c>
     1fe:	8a e0       	ldi	r24, 0x0A	; 10
     200:	44 d6       	rcall	.+3208   	; 0xe8a <myUSART_transmitUSART1_c>
     202:	8e 81       	ldd	r24, Y+6	; 0x06
     204:	9f ef       	ldi	r25, 0xFF	; 255
     206:	98 0f       	add	r25, r24
     208:	9e 83       	std	Y+6, r25	; 0x06
     20a:	88 23       	and	r24, r24
     20c:	21 f1       	breq	.+72     	; 0x256 <RPI_sendTask+0x82>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	4f ef       	ldi	r20, 0xFF	; 255
     212:	5f ef       	ldi	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 8d 08 	lds	r24, 0x088D
     21e:	90 91 8e 08 	lds	r25, 0x088E
     222:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <xQueueGenericReceive>
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	19 d6       	rcall	.+3122   	; 0xe5c <myUSART_transmitUSART0_c>
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	2e d6       	rcall	.+3164   	; 0xe8a <myUSART_transmitUSART1_c>
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	92 e0       	ldi	r25, 0x02	; 2
     232:	50 d6       	rcall	.+3232   	; 0xed4 <myUSART_transmitUSART0>
     234:	ce 01       	movw	r24, r28
     236:	02 96       	adiw	r24, 0x02	; 2
     238:	4d d6       	rcall	.+3226   	; 0xed4 <myUSART_transmitUSART0>
     23a:	ce 01       	movw	r24, r28
     23c:	02 96       	adiw	r24, 0x02	; 2
     23e:	3c d6       	rcall	.+3192   	; 0xeb8 <myUSART_transmitUSART1>
     240:	8a e0       	ldi	r24, 0x0A	; 10
     242:	23 d6       	rcall	.+3142   	; 0xe8a <myUSART_transmitUSART1_c>
     244:	89 e0       	ldi	r24, 0x09	; 9
     246:	92 e0       	ldi	r25, 0x02	; 2
     248:	45 d6       	rcall	.+3210   	; 0xed4 <myUSART_transmitUSART0>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f ef       	ldi	r25, 0xFF	; 255
     24e:	98 0f       	add	r25, r24
     250:	9e 83       	std	Y+6, r25	; 0x06
     252:	81 11       	cpse	r24, r1
     254:	dc cf       	rjmp	.-72     	; 0x20e <RPI_sendTask+0x3a>
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	01 d6       	rcall	.+3074   	; 0xe5c <myUSART_transmitUSART0_c>
     25a:	c2 cf       	rjmp	.-124    	; 0x1e0 <RPI_sendTask+0xc>

0000025c <myTimerTask>:
     25c:	2c d4       	rcall	.+2136   	; 0xab6 <myTimer_Init>
     25e:	6b d4       	rcall	.+2262   	; 0xb36 <myTimer_DelayChecker>
     260:	fe cf       	rjmp	.-4      	; 0x25e <myTimerTask+0x2>

00000262 <task1>:
     262:	26 9a       	sbi	0x04, 6	; 4
     264:	2e 9a       	sbi	0x05, 6	; 5
     266:	88 ee       	ldi	r24, 0xE8	; 232
     268:	93 e0       	ldi	r25, 0x03	; 3
     26a:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <vTaskDelay>
     26e:	85 b1       	in	r24, 0x05	; 5
     270:	15 b8       	out	0x05, r1	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 e0 0f 	call	0x1fc0	; 0x1fc0 <vTaskDelay>
     27a:	f4 cf       	rjmp	.-24     	; 0x264 <task1+0x2>

0000027c <obstacleSend>:
     27c:	1f 93       	push	r17
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	00 d0       	rcall	.+0      	; 0x284 <obstacleSend+0x8>
     284:	1f 92       	push	r1
     286:	1f 92       	push	r1
     288:	cd b7       	in	r28, 0x3d	; 61
     28a:	de b7       	in	r29, 0x3e	; 62
     28c:	18 2f       	mov	r17, r24
     28e:	cb 01       	movw	r24, r22
     290:	11 23       	and	r17, r17
     292:	99 f0       	breq	.+38     	; 0x2ba <obstacleSend+0x3e>
     294:	4a e0       	ldi	r20, 0x0A	; 10
     296:	be 01       	movw	r22, r28
     298:	6e 5f       	subi	r22, 0xFE	; 254
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	0e 94 cd 15 	call	0x2b9a	; 0x2b9a <__itoa_ncheck>
     2a0:	19 83       	std	Y+1, r17	; 0x01
     2a2:	20 e0       	ldi	r18, 0x00	; 0
     2a4:	4f ef       	ldi	r20, 0xFF	; 255
     2a6:	5f ef       	ldi	r21, 0xFF	; 255
     2a8:	be 01       	movw	r22, r28
     2aa:	6f 5f       	subi	r22, 0xFF	; 255
     2ac:	7f 4f       	sbci	r23, 0xFF	; 255
     2ae:	80 91 8d 08 	lds	r24, 0x088D
     2b2:	90 91 8e 08 	lds	r25, 0x088E
     2b6:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <xQueueGenericSend>
     2ba:	0f 90       	pop	r0
     2bc:	0f 90       	pop	r0
     2be:	0f 90       	pop	r0
     2c0:	0f 90       	pop	r0
     2c2:	0f 90       	pop	r0
     2c4:	df 91       	pop	r29
     2c6:	cf 91       	pop	r28
     2c8:	1f 91       	pop	r17
     2ca:	08 95       	ret

000002cc <storeBtmReadings>:
     2cc:	0f 93       	push	r16
     2ce:	1f 93       	push	r17
     2d0:	cf 93       	push	r28
     2d2:	df 93       	push	r29
     2d4:	e0 91 3e 02 	lds	r30, 0x023E
     2d8:	f0 91 3f 02 	lds	r31, 0x023F
     2dc:	df 01       	movw	r26, r30
     2de:	aa 0f       	add	r26, r26
     2e0:	bb 1f       	adc	r27, r27
     2e2:	8a 0f       	add	r24, r26
     2e4:	9b 1f       	adc	r25, r27
     2e6:	8b 01       	movw	r16, r22
     2e8:	04 0f       	add	r16, r20
     2ea:	15 1f       	adc	r17, r21
     2ec:	ec 01       	movw	r28, r24
     2ee:	19 83       	std	Y+1, r17	; 0x01
     2f0:	08 83       	st	Y, r16
     2f2:	a2 0f       	add	r26, r18
     2f4:	b3 1f       	adc	r27, r19
     2f6:	64 1b       	sub	r22, r20
     2f8:	75 0b       	sbc	r23, r21
     2fa:	6d 93       	st	X+, r22
     2fc:	7c 93       	st	X, r23
     2fe:	cf 01       	movw	r24, r30
     300:	01 96       	adiw	r24, 0x01	; 1
     302:	65 e0       	ldi	r22, 0x05	; 5
     304:	70 e0       	ldi	r23, 0x00	; 0
     306:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <__divmodhi4>
     30a:	90 93 3f 02 	sts	0x023F, r25
     30e:	80 93 3e 02 	sts	0x023E, r24
     312:	df 91       	pop	r29
     314:	cf 91       	pop	r28
     316:	1f 91       	pop	r17
     318:	0f 91       	pop	r16
     31a:	08 95       	ret

0000031c <detectStairs>:
     31c:	0f 93       	push	r16
     31e:	1f 93       	push	r17
     320:	cf 93       	push	r28
     322:	df 93       	push	r29
     324:	fc 01       	movw	r30, r24
     326:	db 01       	movw	r26, r22
     328:	ec 01       	movw	r28, r24
     32a:	2a 96       	adiw	r28, 0x0a	; 10
     32c:	21 91       	ld	r18, Z+
     32e:	31 91       	ld	r19, Z+
     330:	21 15       	cp	r18, r1
     332:	31 05       	cpc	r19, r1
     334:	59 f0       	breq	.+22     	; 0x34c <detectStairs+0x30>
     336:	0d 91       	ld	r16, X+
     338:	1c 91       	ld	r17, X
     33a:	11 97       	sbiw	r26, 0x01	; 1
     33c:	01 2b       	or	r16, r17
     33e:	31 f0       	breq	.+12     	; 0x34c <detectStairs+0x30>
     340:	24 17       	cp	r18, r20
     342:	35 07       	cpc	r19, r21
     344:	44 f0       	brlt	.+16     	; 0x356 <detectStairs+0x3a>
     346:	86 17       	cp	r24, r22
     348:	97 07       	cpc	r25, r23
     34a:	38 f0       	brcs	.+14     	; 0x35a <detectStairs+0x3e>
     34c:	12 96       	adiw	r26, 0x02	; 2
     34e:	ec 17       	cp	r30, r28
     350:	fd 07       	cpc	r31, r29
     352:	61 f7       	brne	.-40     	; 0x32c <detectStairs+0x10>
     354:	04 c0       	rjmp	.+8      	; 0x35e <detectStairs+0x42>
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	03 c0       	rjmp	.+6      	; 0x360 <detectStairs+0x44>
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	01 c0       	rjmp	.+2      	; 0x360 <detectStairs+0x44>
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	1f 91       	pop	r17
     366:	0f 91       	pop	r16
     368:	08 95       	ret

0000036a <obstacleDetection>:
     36a:	ef 92       	push	r14
     36c:	ff 92       	push	r15
     36e:	0f 93       	push	r16
     370:	1f 93       	push	r17
     372:	86 34       	cpi	r24, 0x46	; 70
     374:	91 05       	cpc	r25, r1
     376:	1c f5       	brge	.+70     	; 0x3be <obstacleDetection+0x54>
     378:	6d 32       	cpi	r22, 0x2D	; 45
     37a:	71 05       	cpc	r23, r1
     37c:	54 f4       	brge	.+20     	; 0x392 <obstacleDetection+0x28>
     37e:	4d 32       	cpi	r20, 0x2D	; 45
     380:	51 05       	cpc	r21, r1
     382:	3c f4       	brge	.+14     	; 0x392 <obstacleDetection+0x28>
     384:	74 9a       	sbi	0x0e, 4	; 14
     386:	e2 e0       	ldi	r30, 0x02	; 2
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	80 81       	ld	r24, Z
     38c:	80 61       	ori	r24, 0x10	; 16
     38e:	80 83       	st	Z, r24
     390:	43 c0       	rjmp	.+134    	; 0x418 <obstacleDetection+0xae>
     392:	66 5f       	subi	r22, 0xF6	; 246
     394:	7f 4f       	sbci	r23, 0xFF	; 255
     396:	46 17       	cp	r20, r22
     398:	57 07       	cpc	r21, r23
     39a:	3c f4       	brge	.+14     	; 0x3aa <obstacleDetection+0x40>
     39c:	e2 e0       	ldi	r30, 0x02	; 2
     39e:	f1 e0       	ldi	r31, 0x01	; 1
     3a0:	80 81       	ld	r24, Z
     3a2:	8f 7e       	andi	r24, 0xEF	; 239
     3a4:	80 83       	st	Z, r24
     3a6:	74 9a       	sbi	0x0e, 4	; 14
     3a8:	37 c0       	rjmp	.+110    	; 0x418 <obstacleDetection+0xae>
     3aa:	64 17       	cp	r22, r20
     3ac:	75 07       	cpc	r23, r21
     3ae:	a4 f5       	brge	.+104    	; 0x418 <obstacleDetection+0xae>
     3b0:	74 98       	cbi	0x0e, 4	; 14
     3b2:	e2 e0       	ldi	r30, 0x02	; 2
     3b4:	f1 e0       	ldi	r31, 0x01	; 1
     3b6:	80 81       	ld	r24, Z
     3b8:	80 61       	ori	r24, 0x10	; 16
     3ba:	80 83       	st	Z, r24
     3bc:	2d c0       	rjmp	.+90     	; 0x418 <obstacleDetection+0xae>
     3be:	4e 31       	cpi	r20, 0x1E	; 30
     3c0:	51 05       	cpc	r21, r1
     3c2:	54 f4       	brge	.+20     	; 0x3d8 <obstacleDetection+0x6e>
     3c4:	6f 31       	cpi	r22, 0x1F	; 31
     3c6:	71 05       	cpc	r23, r1
     3c8:	3c f0       	brlt	.+14     	; 0x3d8 <obstacleDetection+0x6e>
     3ca:	e2 e0       	ldi	r30, 0x02	; 2
     3cc:	f1 e0       	ldi	r31, 0x01	; 1
     3ce:	80 81       	ld	r24, Z
     3d0:	8f 7e       	andi	r24, 0xEF	; 239
     3d2:	80 83       	st	Z, r24
     3d4:	74 9a       	sbi	0x0e, 4	; 14
     3d6:	20 c0       	rjmp	.+64     	; 0x418 <obstacleDetection+0xae>
     3d8:	6e 31       	cpi	r22, 0x1E	; 30
     3da:	71 05       	cpc	r23, r1
     3dc:	54 f4       	brge	.+20     	; 0x3f2 <obstacleDetection+0x88>
     3de:	4f 31       	cpi	r20, 0x1F	; 31
     3e0:	51 05       	cpc	r21, r1
     3e2:	3c f0       	brlt	.+14     	; 0x3f2 <obstacleDetection+0x88>
     3e4:	e2 e0       	ldi	r30, 0x02	; 2
     3e6:	f1 e0       	ldi	r31, 0x01	; 1
     3e8:	80 81       	ld	r24, Z
     3ea:	80 61       	ori	r24, 0x10	; 16
     3ec:	80 83       	st	Z, r24
     3ee:	74 98       	cbi	0x0e, 4	; 14
     3f0:	13 c0       	rjmp	.+38     	; 0x418 <obstacleDetection+0xae>
     3f2:	a7 01       	movw	r20, r14
     3f4:	b8 01       	movw	r22, r16
     3f6:	c9 01       	movw	r24, r18
     3f8:	91 df       	rcall	.-222    	; 0x31c <detectStairs>
     3fa:	88 23       	and	r24, r24
     3fc:	39 f0       	breq	.+14     	; 0x40c <obstacleDetection+0xa2>
     3fe:	74 9a       	sbi	0x0e, 4	; 14
     400:	e2 e0       	ldi	r30, 0x02	; 2
     402:	f1 e0       	ldi	r31, 0x01	; 1
     404:	80 81       	ld	r24, Z
     406:	80 61       	ori	r24, 0x10	; 16
     408:	80 83       	st	Z, r24
     40a:	06 c0       	rjmp	.+12     	; 0x418 <obstacleDetection+0xae>
     40c:	e2 e0       	ldi	r30, 0x02	; 2
     40e:	f1 e0       	ldi	r31, 0x01	; 1
     410:	80 81       	ld	r24, Z
     412:	8f 7e       	andi	r24, 0xEF	; 239
     414:	80 83       	st	Z, r24
     416:	74 98       	cbi	0x0e, 4	; 14
     418:	1f 91       	pop	r17
     41a:	0f 91       	pop	r16
     41c:	ff 90       	pop	r15
     41e:	ef 90       	pop	r14
     420:	08 95       	ret

00000422 <Sonar_Task>:
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	cd b7       	in	r28, 0x3d	; 61
     428:	de b7       	in	r29, 0x3e	; 62
     42a:	67 97       	sbiw	r28, 0x17	; 23
     42c:	0f b6       	in	r0, 0x3f	; 63
     42e:	f8 94       	cli
     430:	de bf       	out	0x3e, r29	; 62
     432:	0f be       	out	0x3f, r0	; 63
     434:	cd bf       	out	0x3d, r28	; 61
     436:	1b 82       	std	Y+3, r1	; 0x03
     438:	8a e0       	ldi	r24, 0x0A	; 10
     43a:	fe 01       	movw	r30, r28
     43c:	34 96       	adiw	r30, 0x04	; 4
     43e:	df 01       	movw	r26, r30
     440:	98 2f       	mov	r25, r24
     442:	1d 92       	st	X+, r1
     444:	9a 95       	dec	r25
     446:	e9 f7       	brne	.-6      	; 0x442 <Sonar_Task+0x20>
     448:	3a 96       	adiw	r30, 0x0a	; 10
     44a:	df 01       	movw	r26, r30
     44c:	1d 92       	st	X+, r1
     44e:	8a 95       	dec	r24
     450:	e9 f7       	brne	.-6      	; 0x44c <Sonar_Task+0x2a>
     452:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <xTaskGetTickCount>
     456:	9a 83       	std	Y+2, r25	; 0x02
     458:	89 83       	std	Y+1, r24	; 0x01
     45a:	50 d2       	rcall	.+1184   	; 0x8fc <myMaxSonar_Start>
     45c:	87 e2       	ldi	r24, 0x27	; 39
     45e:	54 d2       	rcall	.+1192   	; 0x908 <myMaxSonar_Read>
     460:	3c 01       	movw	r6, r24
     462:	86 e2       	ldi	r24, 0x26	; 38
     464:	51 d2       	rcall	.+1186   	; 0x908 <myMaxSonar_Read>
     466:	4c 01       	movw	r8, r24
     468:	85 e2       	ldi	r24, 0x25	; 37
     46a:	4e d2       	rcall	.+1180   	; 0x908 <myMaxSonar_Read>
     46c:	5c 01       	movw	r10, r24
     46e:	84 e2       	ldi	r24, 0x24	; 36
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	fd d2       	rcall	.+1530   	; 0xa6e <mySharpIR_Read>
     474:	6c 01       	movw	r12, r24
     476:	9e 01       	movw	r18, r28
     478:	22 5f       	subi	r18, 0xF2	; 242
     47a:	3f 4f       	sbci	r19, 0xFF	; 255
     47c:	4f e0       	ldi	r20, 0x0F	; 15
     47e:	50 e0       	ldi	r21, 0x00	; 0
     480:	bc 01       	movw	r22, r24
     482:	ce 01       	movw	r24, r28
     484:	04 96       	adiw	r24, 0x04	; 4
     486:	22 df       	rcall	.-444    	; 0x2cc <storeBtmReadings>
     488:	76 01       	movw	r14, r12
     48a:	8e 01       	movw	r16, r28
     48c:	02 5f       	subi	r16, 0xF2	; 242
     48e:	1f 4f       	sbci	r17, 0xFF	; 255
     490:	9e 01       	movw	r18, r28
     492:	2c 5f       	subi	r18, 0xFC	; 252
     494:	3f 4f       	sbci	r19, 0xFF	; 255
     496:	a5 01       	movw	r20, r10
     498:	b4 01       	movw	r22, r8
     49a:	c3 01       	movw	r24, r6
     49c:	66 df       	rcall	.-308    	; 0x36a <obstacleDetection>
     49e:	8b 81       	ldd	r24, Y+3	; 0x03
     4a0:	8c 5f       	subi	r24, 0xFC	; 252
     4a2:	8b 83       	std	Y+3, r24	; 0x03
     4a4:	20 e0       	ldi	r18, 0x00	; 0
     4a6:	4f ef       	ldi	r20, 0xFF	; 255
     4a8:	5f ef       	ldi	r21, 0xFF	; 255
     4aa:	be 01       	movw	r22, r28
     4ac:	6d 5f       	subi	r22, 0xFD	; 253
     4ae:	7f 4f       	sbci	r23, 0xFF	; 255
     4b0:	80 91 8b 08 	lds	r24, 0x088B
     4b4:	90 91 8c 08 	lds	r25, 0x088C
     4b8:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <xQueueGenericSend>
     4bc:	b3 01       	movw	r22, r6
     4be:	86 e4       	ldi	r24, 0x46	; 70
     4c0:	dd de       	rcall	.-582    	; 0x27c <obstacleSend>
     4c2:	b4 01       	movw	r22, r8
     4c4:	8c e4       	ldi	r24, 0x4C	; 76
     4c6:	da de       	rcall	.-588    	; 0x27c <obstacleSend>
     4c8:	b5 01       	movw	r22, r10
     4ca:	82 e5       	ldi	r24, 0x52	; 82
     4cc:	d7 de       	rcall	.-594    	; 0x27c <obstacleSend>
     4ce:	b6 01       	movw	r22, r12
     4d0:	82 e4       	ldi	r24, 0x42	; 66
     4d2:	d4 de       	rcall	.-600    	; 0x27c <obstacleSend>
     4d4:	1b 82       	std	Y+3, r1	; 0x03
     4d6:	66 e9       	ldi	r22, 0x96	; 150
     4d8:	70 e0       	ldi	r23, 0x00	; 0
     4da:	ce 01       	movw	r24, r28
     4dc:	01 96       	adiw	r24, 0x01	; 1
     4de:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <vTaskDelayUntil>
     4e2:	bb cf       	rjmp	.-138    	; 0x45a <Sonar_Task+0x38>

000004e4 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     4e4:	8f ef       	ldi	r24, 0xFF	; 255
     4e6:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     4ea:	ef e7       	ldi	r30, 0x7F	; 127
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	90 81       	ld	r25, Z
     4f0:	93 60       	ori	r25, 0x03	; 3
     4f2:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     4f4:	80 93 7d 00 	sts	0x007D, r24
     4f8:	08 95       	ret

000004fa <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     4fa:	8c ec       	ldi	r24, 0xCC	; 204
     4fc:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     500:	8e e3       	ldi	r24, 0x3E	; 62
     502:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     506:	ee cf       	rjmp	.-36     	; 0x4e4 <setDigitalInputPowerReduction>
     508:	08 95       	ret

0000050a <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     50a:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     50e:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     512:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     516:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     51a:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     51e:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     522:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     526:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     52a:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     52e:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     532:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     536:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     53a:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     53e:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     542:	10 92 73 00 	sts	0x0073, r1
     546:	08 95       	ret

00000548 <init>:
}

void init()
{
     548:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     54a:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     54c:	f8 94       	cli
	{
		clearTimer();
     54e:	dd df       	rcall	.-70     	; 0x50a <clearTimer>
		setPowerReduction();
     550:	d4 df       	rcall	.-88     	; 0x4fa <setPowerReduction>
		myUSART_USART0_Init();
     552:	3c d4       	rcall	.+2168   	; 0xdcc <myUSART_USART0_Init>
		myUSART_USART1_Init();
     554:	5b d4       	rcall	.+2230   	; 0xe0c <myUSART_USART1_Init>
		myADC_Init();
     556:	1a d2       	rcall	.+1076   	; 0x98c <myADC_Init>
		MaxSonar_Init();
     558:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     55a:	bb d1       	rcall	.+886    	; 0x8d2 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     55c:	40 e0       	ldi	r20, 0x00	; 0
     55e:	61 e0       	ldi	r22, 0x01	; 1
     560:	85 e0       	ldi	r24, 0x05	; 5
     562:	a2 d7       	rcall	.+3908   	; 0x14a8 <xQueueGenericCreate>
     564:	90 93 8c 08 	sts	0x088C, r25
     568:	80 93 8b 08 	sts	0x088B, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	65 e0       	ldi	r22, 0x05	; 5
     570:	84 e1       	ldi	r24, 0x14	; 20
     572:	9a d7       	rcall	.+3892   	; 0x14a8 <xQueueGenericCreate>
     574:	90 93 8e 08 	sts	0x088E, r25
     578:	80 93 8d 08 	sts	0x088D, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     57c:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     57e:	e1 e0       	ldi	r30, 0x01	; 1
     580:	f1 e0       	ldi	r31, 0x01	; 1
     582:	80 81       	ld	r24, Z
     584:	80 61       	ori	r24, 0x10	; 16
     586:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     588:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     58a:	78 94       	sei
}
     58c:	cf 91       	pop	r28
     58e:	08 95       	ret

00000590 <main>:
	
	// do nth
}

int main(void)
{
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	cd b7       	in	r28, 0x3d	; 61
     596:	de b7       	in	r29, 0x3e	; 62
     598:	2a 97       	sbiw	r28, 0x0a	; 10
     59a:	0f b6       	in	r0, 0x3f	; 63
     59c:	f8 94       	cli
     59e:	de bf       	out	0x3e, r29	; 62
     5a0:	0f be       	out	0x3f, r0	; 63
     5a2:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     5a4:	d1 df       	rcall	.-94     	; 0x548 <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     5a6:	a1 2c       	mov	r10, r1
     5a8:	b1 2c       	mov	r11, r1
     5aa:	c1 2c       	mov	r12, r1
     5ac:	d1 2c       	mov	r13, r1
     5ae:	ce 01       	movw	r24, r28
     5b0:	01 96       	adiw	r24, 0x01	; 1
     5b2:	7c 01       	movw	r14, r24
     5b4:	01 e0       	ldi	r16, 0x01	; 1
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	30 e0       	ldi	r19, 0x00	; 0
     5ba:	45 e5       	ldi	r20, 0x55	; 85
     5bc:	50 e0       	ldi	r21, 0x00	; 0
     5be:	6c e0       	ldi	r22, 0x0C	; 12
     5c0:	72 e0       	ldi	r23, 0x02	; 2
     5c2:	81 e3       	ldi	r24, 0x31	; 49
     5c4:	91 e0       	ldi	r25, 0x01	; 1
     5c6:	0e 94 c5 0c 	call	0x198a	; 0x198a <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     5ca:	ce 01       	movw	r24, r28
     5cc:	03 96       	adiw	r24, 0x03	; 3
     5ce:	7c 01       	movw	r14, r24
     5d0:	04 e0       	ldi	r16, 0x04	; 4
     5d2:	9c 01       	movw	r18, r24
     5d4:	49 e6       	ldi	r20, 0x69	; 105
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	63 e1       	ldi	r22, 0x13	; 19
     5da:	72 e0       	ldi	r23, 0x02	; 2
     5dc:	8e e2       	ldi	r24, 0x2E	; 46
     5de:	91 e0       	ldi	r25, 0x01	; 1
     5e0:	0e 94 c5 0c 	call	0x198a	; 0x198a <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     5e4:	ce 01       	movw	r24, r28
     5e6:	09 96       	adiw	r24, 0x09	; 9
     5e8:	7c 01       	movw	r14, r24
     5ea:	02 e0       	ldi	r16, 0x02	; 2
     5ec:	20 e0       	ldi	r18, 0x00	; 0
     5ee:	30 e0       	ldi	r19, 0x00	; 0
     5f0:	4f e4       	ldi	r20, 0x4F	; 79
     5f2:	51 e0       	ldi	r21, 0x01	; 1
     5f4:	6b e1       	ldi	r22, 0x1B	; 27
     5f6:	72 e0       	ldi	r23, 0x02	; 2
     5f8:	81 e1       	ldi	r24, 0x11	; 17
     5fa:	92 e0       	ldi	r25, 0x02	; 2
     5fc:	0e 94 c5 0c 	call	0x198a	; 0x198a <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     600:	ce 01       	movw	r24, r28
     602:	07 96       	adiw	r24, 0x07	; 7
     604:	7c 01       	movw	r14, r24
     606:	03 e0       	ldi	r16, 0x03	; 3
     608:	20 e0       	ldi	r18, 0x00	; 0
     60a:	30 e0       	ldi	r19, 0x00	; 0
     60c:	47 e8       	ldi	r20, 0x87	; 135
     60e:	50 e0       	ldi	r21, 0x00	; 0
     610:	64 e2       	ldi	r22, 0x24	; 36
     612:	72 e0       	ldi	r23, 0x02	; 2
     614:	84 ed       	ldi	r24, 0xD4	; 212
     616:	90 e0       	ldi	r25, 0x00	; 0
     618:	0e 94 c5 0c 	call	0x198a	; 0x198a <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     61c:	ce 01       	movw	r24, r28
     61e:	05 96       	adiw	r24, 0x05	; 5
     620:	7c 01       	movw	r14, r24
     622:	01 e0       	ldi	r16, 0x01	; 1
     624:	20 e0       	ldi	r18, 0x00	; 0
     626:	30 e0       	ldi	r19, 0x00	; 0
     628:	47 e8       	ldi	r20, 0x87	; 135
     62a:	50 e0       	ldi	r21, 0x00	; 0
     62c:	60 e3       	ldi	r22, 0x30	; 48
     62e:	72 e0       	ldi	r23, 0x02	; 2
     630:	8a ee       	ldi	r24, 0xEA	; 234
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	0e 94 c5 0c 	call	0x198a	; 0x198a <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     638:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vTaskStartScheduler>
     63c:	b3 cf       	rjmp	.-154    	; 0x5a4 <main+0x14>

0000063e <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     63e:	cf 93       	push	r28
     640:	df 93       	push	r29
     642:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     644:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     648:	80 91 40 02 	lds	r24, 0x0240
     64c:	90 91 41 02 	lds	r25, 0x0241
     650:	89 2b       	or	r24, r25
     652:	31 f4       	brne	.+12     	; 0x660 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     654:	85 e4       	ldi	r24, 0x45	; 69
     656:	92 e0       	ldi	r25, 0x02	; 2
     658:	90 93 41 02 	sts	0x0241, r25
     65c:	80 93 40 02 	sts	0x0240, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     660:	40 91 42 02 	lds	r20, 0x0242
     664:	50 91 43 02 	lds	r21, 0x0243
     668:	9e 01       	movw	r18, r28
     66a:	24 0f       	add	r18, r20
     66c:	35 1f       	adc	r19, r21
     66e:	2b 3d       	cpi	r18, 0xDB	; 219
     670:	85 e0       	ldi	r24, 0x05	; 5
     672:	38 07       	cpc	r19, r24
     674:	70 f4       	brcc	.+28     	; 0x692 <pvPortMalloc+0x54>
     676:	42 17       	cp	r20, r18
     678:	53 07       	cpc	r21, r19
     67a:	70 f4       	brcc	.+28     	; 0x698 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     67c:	c0 91 40 02 	lds	r28, 0x0240
     680:	d0 91 41 02 	lds	r29, 0x0241
     684:	c4 0f       	add	r28, r20
     686:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     688:	30 93 43 02 	sts	0x0243, r19
     68c:	20 93 42 02 	sts	0x0242, r18
     690:	05 c0       	rjmp	.+10     	; 0x69c <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     692:	c0 e0       	ldi	r28, 0x00	; 0
     694:	d0 e0       	ldi	r29, 0x00	; 0
     696:	02 c0       	rjmp	.+4      	; 0x69c <pvPortMalloc+0x5e>
     698:	c0 e0       	ldi	r28, 0x00	; 0
     69a:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     69c:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6a0:	ce 01       	movw	r24, r28
     6a2:	df 91       	pop	r29
     6a4:	cf 91       	pop	r28
     6a6:	08 95       	ret

000006a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6a8:	08 95       	ret

000006aa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6aa:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ac:	03 96       	adiw	r24, 0x03	; 3
     6ae:	92 83       	std	Z+2, r25	; 0x02
     6b0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6b2:	2f ef       	ldi	r18, 0xFF	; 255
     6b4:	3f ef       	ldi	r19, 0xFF	; 255
     6b6:	34 83       	std	Z+4, r19	; 0x04
     6b8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ba:	96 83       	std	Z+6, r25	; 0x06
     6bc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6be:	90 87       	std	Z+8, r25	; 0x08
     6c0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6c2:	10 82       	st	Z, r1
     6c4:	08 95       	ret

000006c6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6c6:	fc 01       	movw	r30, r24
     6c8:	11 86       	std	Z+9, r1	; 0x09
     6ca:	10 86       	std	Z+8, r1	; 0x08
     6cc:	08 95       	ret

000006ce <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
     6d2:	9c 01       	movw	r18, r24
     6d4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6d6:	dc 01       	movw	r26, r24
     6d8:	11 96       	adiw	r26, 0x01	; 1
     6da:	cd 91       	ld	r28, X+
     6dc:	dc 91       	ld	r29, X
     6de:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6e0:	d3 83       	std	Z+3, r29	; 0x03
     6e2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6e4:	8c 81       	ldd	r24, Y+4	; 0x04
     6e6:	9d 81       	ldd	r25, Y+5	; 0x05
     6e8:	95 83       	std	Z+5, r25	; 0x05
     6ea:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6ec:	8c 81       	ldd	r24, Y+4	; 0x04
     6ee:	9d 81       	ldd	r25, Y+5	; 0x05
     6f0:	dc 01       	movw	r26, r24
     6f2:	13 96       	adiw	r26, 0x03	; 3
     6f4:	7c 93       	st	X, r23
     6f6:	6e 93       	st	-X, r22
     6f8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6fa:	7d 83       	std	Y+5, r23	; 0x05
     6fc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6fe:	31 87       	std	Z+9, r19	; 0x09
     700:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     702:	f9 01       	movw	r30, r18
     704:	80 81       	ld	r24, Z
     706:	8f 5f       	subi	r24, 0xFF	; 255
     708:	80 83       	st	Z, r24
}
     70a:	df 91       	pop	r29
     70c:	cf 91       	pop	r28
     70e:	08 95       	ret

00000710 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     716:	48 81       	ld	r20, Y
     718:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     71a:	4f 3f       	cpi	r20, 0xFF	; 255
     71c:	2f ef       	ldi	r18, 0xFF	; 255
     71e:	52 07       	cpc	r21, r18
     720:	21 f4       	brne	.+8      	; 0x72a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     722:	fc 01       	movw	r30, r24
     724:	a7 81       	ldd	r26, Z+7	; 0x07
     726:	b0 85       	ldd	r27, Z+8	; 0x08
     728:	0d c0       	rjmp	.+26     	; 0x744 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     72a:	dc 01       	movw	r26, r24
     72c:	13 96       	adiw	r26, 0x03	; 3
     72e:	12 96       	adiw	r26, 0x02	; 2
     730:	ed 91       	ld	r30, X+
     732:	fc 91       	ld	r31, X
     734:	13 97       	sbiw	r26, 0x03	; 3
     736:	20 81       	ld	r18, Z
     738:	31 81       	ldd	r19, Z+1	; 0x01
     73a:	42 17       	cp	r20, r18
     73c:	53 07       	cpc	r21, r19
     73e:	10 f0       	brcs	.+4      	; 0x744 <vListInsert+0x34>
     740:	df 01       	movw	r26, r30
     742:	f5 cf       	rjmp	.-22     	; 0x72e <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     744:	12 96       	adiw	r26, 0x02	; 2
     746:	ed 91       	ld	r30, X+
     748:	fc 91       	ld	r31, X
     74a:	13 97       	sbiw	r26, 0x03	; 3
     74c:	fb 83       	std	Y+3, r31	; 0x03
     74e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     750:	d5 83       	std	Z+5, r29	; 0x05
     752:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     754:	bd 83       	std	Y+5, r27	; 0x05
     756:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     758:	13 96       	adiw	r26, 0x03	; 3
     75a:	dc 93       	st	X, r29
     75c:	ce 93       	st	-X, r28
     75e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     760:	99 87       	std	Y+9, r25	; 0x09
     762:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     764:	fc 01       	movw	r30, r24
     766:	20 81       	ld	r18, Z
     768:	2f 5f       	subi	r18, 0xFF	; 255
     76a:	20 83       	st	Z, r18
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	08 95       	ret

00000772 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     778:	a0 85       	ldd	r26, Z+8	; 0x08
     77a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     77c:	c2 81       	ldd	r28, Z+2	; 0x02
     77e:	d3 81       	ldd	r29, Z+3	; 0x03
     780:	84 81       	ldd	r24, Z+4	; 0x04
     782:	95 81       	ldd	r25, Z+5	; 0x05
     784:	9d 83       	std	Y+5, r25	; 0x05
     786:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     788:	c4 81       	ldd	r28, Z+4	; 0x04
     78a:	d5 81       	ldd	r29, Z+5	; 0x05
     78c:	82 81       	ldd	r24, Z+2	; 0x02
     78e:	93 81       	ldd	r25, Z+3	; 0x03
     790:	9b 83       	std	Y+3, r25	; 0x03
     792:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     794:	11 96       	adiw	r26, 0x01	; 1
     796:	cd 91       	ld	r28, X+
     798:	dc 91       	ld	r29, X
     79a:	12 97       	sbiw	r26, 0x02	; 2
     79c:	ce 17       	cp	r28, r30
     79e:	df 07       	cpc	r29, r31
     7a0:	31 f4       	brne	.+12     	; 0x7ae <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7a2:	8c 81       	ldd	r24, Y+4	; 0x04
     7a4:	9d 81       	ldd	r25, Y+5	; 0x05
     7a6:	12 96       	adiw	r26, 0x02	; 2
     7a8:	9c 93       	st	X, r25
     7aa:	8e 93       	st	-X, r24
     7ac:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7ae:	11 86       	std	Z+9, r1	; 0x09
     7b0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7b2:	8c 91       	ld	r24, X
     7b4:	81 50       	subi	r24, 0x01	; 1
     7b6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7b8:	df 91       	pop	r29
     7ba:	cf 91       	pop	r28
     7bc:	08 95       	ret

000007be <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7be:	1f 92       	push	r1
     7c0:	0f 92       	push	r0
     7c2:	0f b6       	in	r0, 0x3f	; 63
     7c4:	0f 92       	push	r0
     7c6:	11 24       	eor	r1, r1
     7c8:	0b b6       	in	r0, 0x3b	; 59
     7ca:	0f 92       	push	r0
     7cc:	2f 93       	push	r18
     7ce:	3f 93       	push	r19
     7d0:	4f 93       	push	r20
     7d2:	5f 93       	push	r21
     7d4:	6f 93       	push	r22
     7d6:	7f 93       	push	r23
     7d8:	8f 93       	push	r24
     7da:	9f 93       	push	r25
     7dc:	af 93       	push	r26
     7de:	bf 93       	push	r27
     7e0:	ef 93       	push	r30
     7e2:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     7e4:	1b 9b       	sbis	0x03, 3	; 3
     7e6:	0d c0       	rjmp	.+26     	; 0x802 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     7e8:	80 d1       	rcall	.+768    	; 0xaea <myTimer_Read>
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	90 93 94 08 	sts	0x0894, r25
     7f0:	80 93 93 08 	sts	0x0893, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     7f4:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <xTaskGetTickCountFromISR>
     7f8:	90 93 90 08 	sts	0x0890, r25
     7fc:	80 93 8f 08 	sts	0x088F, r24
     800:	55 c0       	rjmp	.+170    	; 0x8ac <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     802:	1b 99       	sbic	0x03, 3	; 3
     804:	53 c0       	rjmp	.+166    	; 0x8ac <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     806:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <xTaskGetTickCountFromISR>
     80a:	90 93 9a 08 	sts	0x089A, r25
     80e:	80 93 99 08 	sts	0x0899, r24
     812:	20 91 8f 08 	lds	r18, 0x088F
     816:	30 91 90 08 	lds	r19, 0x0890
     81a:	82 17       	cp	r24, r18
     81c:	93 07       	cpc	r25, r19
     81e:	4c f4       	brge	.+18     	; 0x832 <__vector_9+0x74>
			ms_tickEnd += 65535;
     820:	80 91 99 08 	lds	r24, 0x0899
     824:	90 91 9a 08 	lds	r25, 0x089A
     828:	01 97       	sbiw	r24, 0x01	; 1
     82a:	90 93 9a 08 	sts	0x089A, r25
     82e:	80 93 99 08 	sts	0x0899, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     832:	5b d1       	rcall	.+694    	; 0xaea <myTimer_Read>
     834:	90 e0       	ldi	r25, 0x00	; 0
     836:	90 93 9c 08 	sts	0x089C, r25
     83a:	80 93 9b 08 	sts	0x089B, r24
     83e:	20 91 93 08 	lds	r18, 0x0893
     842:	30 91 94 08 	lds	r19, 0x0894
     846:	82 17       	cp	r24, r18
     848:	93 07       	cpc	r25, r19
     84a:	54 f4       	brge	.+20     	; 0x860 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     84c:	80 91 9b 08 	lds	r24, 0x089B
     850:	90 91 9c 08 	lds	r25, 0x089C
     854:	86 50       	subi	r24, 0x06	; 6
     856:	9f 4f       	sbci	r25, 0xFF	; 255
     858:	90 93 9c 08 	sts	0x089C, r25
     85c:	80 93 9b 08 	sts	0x089B, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     860:	80 91 9b 08 	lds	r24, 0x089B
     864:	90 91 9c 08 	lds	r25, 0x089C
     868:	20 91 93 08 	lds	r18, 0x0893
     86c:	30 91 94 08 	lds	r19, 0x0894
     870:	82 1b       	sub	r24, r18
     872:	93 0b       	sbc	r25, r19
     874:	90 93 96 08 	sts	0x0896, r25
     878:	80 93 95 08 	sts	0x0895, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     87c:	80 91 99 08 	lds	r24, 0x0899
     880:	90 91 9a 08 	lds	r25, 0x089A
     884:	20 91 8f 08 	lds	r18, 0x088F
     888:	30 91 90 08 	lds	r19, 0x0890
     88c:	82 1b       	sub	r24, r18
     88e:	93 0b       	sbc	r25, r19
     890:	90 93 92 08 	sts	0x0892, r25
     894:	80 93 91 08 	sts	0x0891, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     898:	20 e0       	ldi	r18, 0x00	; 0
     89a:	40 e0       	ldi	r20, 0x00	; 0
     89c:	50 e0       	ldi	r21, 0x00	; 0
     89e:	60 e0       	ldi	r22, 0x00	; 0
     8a0:	70 e0       	ldi	r23, 0x00	; 0
     8a2:	80 91 97 08 	lds	r24, 0x0897
     8a6:	90 91 98 08 	lds	r25, 0x0898
     8aa:	e3 d6       	rcall	.+3526   	; 0x1672 <xQueueGenericSendFromISR>
	}	
}
     8ac:	ff 91       	pop	r31
     8ae:	ef 91       	pop	r30
     8b0:	bf 91       	pop	r27
     8b2:	af 91       	pop	r26
     8b4:	9f 91       	pop	r25
     8b6:	8f 91       	pop	r24
     8b8:	7f 91       	pop	r23
     8ba:	6f 91       	pop	r22
     8bc:	5f 91       	pop	r21
     8be:	4f 91       	pop	r20
     8c0:	3f 91       	pop	r19
     8c2:	2f 91       	pop	r18
     8c4:	0f 90       	pop	r0
     8c6:	0b be       	out	0x3b, r0	; 59
     8c8:	0f 90       	pop	r0
     8ca:	0f be       	out	0x3f, r0	; 63
     8cc:	0f 90       	pop	r0
     8ce:	1f 90       	pop	r1
     8d0:	18 95       	reti

000008d2 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     8d2:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     8d4:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     8d6:	e8 e6       	ldi	r30, 0x68	; 104
     8d8:	f0 e0       	ldi	r31, 0x00	; 0
     8da:	80 81       	ld	r24, Z
     8dc:	81 60       	ori	r24, 0x01	; 1
     8de:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     8e0:	eb e6       	ldi	r30, 0x6B	; 107
     8e2:	f0 e0       	ldi	r31, 0x00	; 0
     8e4:	80 81       	ld	r24, Z
     8e6:	88 60       	ori	r24, 0x08	; 8
     8e8:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     8ea:	43 e0       	ldi	r20, 0x03	; 3
     8ec:	60 e0       	ldi	r22, 0x00	; 0
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	db d5       	rcall	.+2998   	; 0x14a8 <xQueueGenericCreate>
     8f2:	90 93 98 08 	sts	0x0898, r25
     8f6:	80 93 97 08 	sts	0x0897, r24
     8fa:	08 95       	ret

000008fc <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     8fc:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     8fe:	89 e1       	ldi	r24, 0x19	; 25
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	f5 d0       	rcall	.+490    	; 0xaee <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     904:	a1 98       	cbi	0x14, 1	; 20
     906:	08 95       	ret

00000908 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     908:	ab d0       	rcall	.+342    	; 0xa60 <myADC_analogRead>
     90a:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     90c:	63 e0       	ldi	r22, 0x03	; 3
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     914:	cb 01       	movw	r24, r22
     916:	82 0f       	add	r24, r18
     918:	93 1f       	adc	r25, r19
     91a:	08 95       	ret

0000091c <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     91c:	1f 92       	push	r1
     91e:	0f 92       	push	r0
     920:	0f b6       	in	r0, 0x3f	; 63
     922:	0f 92       	push	r0
     924:	11 24       	eor	r1, r1
     926:	0b b6       	in	r0, 0x3b	; 59
     928:	0f 92       	push	r0
     92a:	2f 93       	push	r18
     92c:	3f 93       	push	r19
     92e:	4f 93       	push	r20
     930:	5f 93       	push	r21
     932:	6f 93       	push	r22
     934:	7f 93       	push	r23
     936:	8f 93       	push	r24
     938:	9f 93       	push	r25
     93a:	af 93       	push	r26
     93c:	bf 93       	push	r27
     93e:	ef 93       	push	r30
     940:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     942:	80 91 78 00 	lds	r24, 0x0078
     946:	80 93 9d 08 	sts	0x089D, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     94a:	80 91 79 00 	lds	r24, 0x0079
     94e:	80 93 9e 08 	sts	0x089E, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     952:	20 e0       	ldi	r18, 0x00	; 0
     954:	40 e0       	ldi	r20, 0x00	; 0
     956:	50 e0       	ldi	r21, 0x00	; 0
     958:	60 e0       	ldi	r22, 0x00	; 0
     95a:	70 e0       	ldi	r23, 0x00	; 0
     95c:	80 91 a1 08 	lds	r24, 0x08A1
     960:	90 91 a2 08 	lds	r25, 0x08A2
     964:	86 d6       	rcall	.+3340   	; 0x1672 <xQueueGenericSendFromISR>
}
     966:	ff 91       	pop	r31
     968:	ef 91       	pop	r30
     96a:	bf 91       	pop	r27
     96c:	af 91       	pop	r26
     96e:	9f 91       	pop	r25
     970:	8f 91       	pop	r24
     972:	7f 91       	pop	r23
     974:	6f 91       	pop	r22
     976:	5f 91       	pop	r21
     978:	4f 91       	pop	r20
     97a:	3f 91       	pop	r19
     97c:	2f 91       	pop	r18
     97e:	0f 90       	pop	r0
     980:	0b be       	out	0x3b, r0	; 59
     982:	0f 90       	pop	r0
     984:	0f be       	out	0x3f, r0	; 63
     986:	0f 90       	pop	r0
     988:	1f 90       	pop	r1
     98a:	18 95       	reti

0000098c <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     98c:	8f e8       	ldi	r24, 0x8F	; 143
     98e:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     992:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     996:	80 e4       	ldi	r24, 0x40	; 64
     998:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     99c:	43 e0       	ldi	r20, 0x03	; 3
     99e:	60 e0       	ldi	r22, 0x00	; 0
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	82 d5       	rcall	.+2820   	; 0x14a8 <xQueueGenericCreate>
     9a4:	90 93 a2 08 	sts	0x08A2, r25
     9a8:	80 93 a1 08 	sts	0x08A1, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     9ac:	81 e0       	ldi	r24, 0x01	; 1
     9ae:	39 d6       	rcall	.+3186   	; 0x1622 <xQueueCreateMutex>
     9b0:	90 93 a0 08 	sts	0x08A0, r25
     9b4:	80 93 9f 08 	sts	0x089F, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     9b8:	20 e0       	ldi	r18, 0x00	; 0
     9ba:	40 e0       	ldi	r20, 0x00	; 0
     9bc:	50 e0       	ldi	r21, 0x00	; 0
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	70 e0       	ldi	r23, 0x00	; 0
     9c2:	9c c5       	rjmp	.+2872   	; 0x14fc <xQueueGenericSend>
     9c4:	08 95       	ret

000009c6 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     9c6:	cf 93       	push	r28
     9c8:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     9ca:	20 e0       	ldi	r18, 0x00	; 0
     9cc:	4f ef       	ldi	r20, 0xFF	; 255
     9ce:	5f ef       	ldi	r21, 0xFF	; 255
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	80 91 9f 08 	lds	r24, 0x089F
     9d8:	90 91 a0 08 	lds	r25, 0x08A0
     9dc:	84 d6       	rcall	.+3336   	; 0x16e6 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     9de:	ec e7       	ldi	r30, 0x7C	; 124
     9e0:	f0 e0       	ldi	r31, 0x00	; 0
     9e2:	80 81       	ld	r24, Z
     9e4:	9c 2f       	mov	r25, r28
     9e6:	9f 71       	andi	r25, 0x1F	; 31
     9e8:	80 76       	andi	r24, 0x60	; 96
     9ea:	89 2b       	or	r24, r25
     9ec:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     9ee:	eb e7       	ldi	r30, 0x7B	; 123
     9f0:	f0 e0       	ldi	r31, 0x00	; 0
     9f2:	20 81       	ld	r18, Z
     9f4:	c0 72       	andi	r28, 0x20	; 32
     9f6:	8c 2f       	mov	r24, r28
     9f8:	90 e0       	ldi	r25, 0x00	; 0
     9fa:	95 95       	asr	r25
     9fc:	87 95       	ror	r24
     9fe:	95 95       	asr	r25
     a00:	87 95       	ror	r24
     a02:	92 2f       	mov	r25, r18
     a04:	90 76       	andi	r25, 0x60	; 96
     a06:	89 2b       	or	r24, r25
     a08:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a0a:	ea e7       	ldi	r30, 0x7A	; 122
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	80 81       	ld	r24, Z
     a10:	80 64       	ori	r24, 0x40	; 64
     a12:	80 83       	st	Z, r24
}
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <myADC_readADC>:

int myADC_readADC(char channel)
{
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a1c:	20 e0       	ldi	r18, 0x00	; 0
     a1e:	4f ef       	ldi	r20, 0xFF	; 255
     a20:	5f ef       	ldi	r21, 0xFF	; 255
     a22:	60 e0       	ldi	r22, 0x00	; 0
     a24:	70 e0       	ldi	r23, 0x00	; 0
     a26:	80 91 a1 08 	lds	r24, 0x08A1
     a2a:	90 91 a2 08 	lds	r25, 0x08A2
     a2e:	5b d6       	rcall	.+3254   	; 0x16e6 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     a30:	c0 91 9e 08 	lds	r28, 0x089E
     a34:	c3 70       	andi	r28, 0x03	; 3
     a36:	d0 e0       	ldi	r29, 0x00	; 0
     a38:	dc 2f       	mov	r29, r28
     a3a:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     a3c:	80 91 9d 08 	lds	r24, 0x089D
     a40:	c8 0f       	add	r28, r24
     a42:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     a44:	20 e0       	ldi	r18, 0x00	; 0
     a46:	40 e0       	ldi	r20, 0x00	; 0
     a48:	50 e0       	ldi	r21, 0x00	; 0
     a4a:	60 e0       	ldi	r22, 0x00	; 0
     a4c:	70 e0       	ldi	r23, 0x00	; 0
     a4e:	80 91 9f 08 	lds	r24, 0x089F
     a52:	90 91 a0 08 	lds	r25, 0x08A0
     a56:	52 d5       	rcall	.+2724   	; 0x14fc <xQueueGenericSend>
	
	return adcReading;
     a58:	ce 01       	movw	r24, r28
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	08 95       	ret

00000a60 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     a60:	cf 93       	push	r28
     a62:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     a64:	b0 df       	rcall	.-160    	; 0x9c6 <myADC_startADC>
	return myADC_readADC(channel);
     a66:	8c 2f       	mov	r24, r28
     a68:	d7 df       	rcall	.-82     	; 0xa18 <myADC_readADC>
}
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     a6e:	f8 df       	rcall	.-16     	; 0xa60 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     a70:	bc 01       	movw	r22, r24
     a72:	88 27       	eor	r24, r24
     a74:	77 fd       	sbrc	r23, 7
     a76:	80 95       	com	r24
     a78:	98 2f       	mov	r25, r24
     a7a:	0e 94 e1 12 	call	0x25c2	; 0x25c2 <__floatsisf>
     a7e:	29 e2       	ldi	r18, 0x29	; 41
     a80:	3c e5       	ldi	r19, 0x5C	; 92
     a82:	4f e6       	ldi	r20, 0x6F	; 111
     a84:	5f eb       	ldi	r21, 0xBF	; 191
     a86:	0e 94 d0 13 	call	0x27a0	; 0x27a0 <pow>
     a8a:	22 e5       	ldi	r18, 0x52	; 82
     a8c:	38 e6       	ldi	r19, 0x68	; 104
     a8e:	46 e2       	ldi	r20, 0x26	; 38
     a90:	56 e4       	ldi	r21, 0x46	; 70
     a92:	0e 94 6d 13 	call	0x26da	; 0x26da <__mulsf3>
     a96:	20 e0       	ldi	r18, 0x00	; 0
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	40 e2       	ldi	r20, 0x20	; 32
     a9c:	51 e4       	ldi	r21, 0x41	; 65
     a9e:	0e 94 49 12 	call	0x2492	; 0x2492 <__subsf3>
     aa2:	0e 94 ae 12 	call	0x255c	; 0x255c <__fixsfsi>
     aa6:	cb 01       	movw	r24, r22
     aa8:	68 3e       	cpi	r22, 0xE8	; 232
     aaa:	23 e0       	ldi	r18, 0x03	; 3
     aac:	72 07       	cpc	r23, r18
     aae:	14 f0       	brlt	.+4      	; 0xab4 <mySharpIR_Read+0x46>
     ab0:	87 ee       	ldi	r24, 0xE7	; 231
     ab2:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
     ab4:	08 95       	ret

00000ab6 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     ab6:	90 93 a8 08 	sts	0x08A8, r25
     aba:	80 93 a7 08 	sts	0x08A7, r24
     abe:	fc 01       	movw	r30, r24
     ac0:	80 81       	ld	r24, Z
     ac2:	91 81       	ldd	r25, Z+1	; 0x01
     ac4:	0e 94 93 10 	call	0x2126	; 0x2126 <vTaskSuspend>
     ac8:	43 e0       	ldi	r20, 0x03	; 3
     aca:	60 e0       	ldi	r22, 0x00	; 0
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	ec d4       	rcall	.+2520   	; 0x14a8 <xQueueGenericCreate>
     ad0:	90 93 a4 08 	sts	0x08A4, r25
     ad4:	80 93 a3 08 	sts	0x08A3, r24
     ad8:	43 e0       	ldi	r20, 0x03	; 3
     ada:	60 e0       	ldi	r22, 0x00	; 0
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	e4 d4       	rcall	.+2504   	; 0x14a8 <xQueueGenericCreate>
     ae0:	90 93 a6 08 	sts	0x08A6, r25
     ae4:	80 93 a5 08 	sts	0x08A5, r24
     ae8:	08 95       	ret

00000aea <myTimer_Read>:
     aea:	86 b5       	in	r24, 0x26	; 38
     aec:	08 95       	ret

00000aee <myTimer_DelayMicro>:
     aee:	46 b5       	in	r20, 0x26	; 38
     af0:	50 e0       	ldi	r21, 0x00	; 0
     af2:	9c 01       	movw	r18, r24
     af4:	99 23       	and	r25, r25
     af6:	14 f4       	brge	.+4      	; 0xafc <myTimer_DelayMicro+0xe>
     af8:	2d 5f       	subi	r18, 0xFD	; 253
     afa:	3f 4f       	sbci	r19, 0xFF	; 255
     afc:	35 95       	asr	r19
     afe:	27 95       	ror	r18
     b00:	35 95       	asr	r19
     b02:	27 95       	ror	r18
     b04:	24 0f       	add	r18, r20
     b06:	35 1f       	adc	r19, r21
     b08:	30 93 03 02 	sts	0x0203, r19
     b0c:	20 93 02 02 	sts	0x0202, r18
     b10:	e0 91 a7 08 	lds	r30, 0x08A7
     b14:	f0 91 a8 08 	lds	r31, 0x08A8
     b18:	80 81       	ld	r24, Z
     b1a:	91 81       	ldd	r25, Z+1	; 0x01
     b1c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vTaskResume>
     b20:	20 e0       	ldi	r18, 0x00	; 0
     b22:	42 e0       	ldi	r20, 0x02	; 2
     b24:	50 e0       	ldi	r21, 0x00	; 0
     b26:	60 e0       	ldi	r22, 0x00	; 0
     b28:	70 e0       	ldi	r23, 0x00	; 0
     b2a:	80 91 a3 08 	lds	r24, 0x08A3
     b2e:	90 91 a4 08 	lds	r25, 0x08A4
     b32:	d9 c5       	rjmp	.+2994   	; 0x16e6 <xQueueGenericReceive>
     b34:	08 95       	ret

00000b36 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     b3a:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     b3c:	c1 11       	cpse	r28, r1
     b3e:	22 c0       	rjmp	.+68     	; 0xb84 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     b40:	80 91 02 02 	lds	r24, 0x0202
     b44:	90 91 03 02 	lds	r25, 0x0203
     b48:	88 38       	cpi	r24, 0x88	; 136
     b4a:	93 41       	sbci	r25, 0x13	; 19
     b4c:	51 f0       	breq	.+20     	; 0xb62 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     b4e:	80 91 02 02 	lds	r24, 0x0202
     b52:	90 91 03 02 	lds	r25, 0x0203
     b56:	8a 5f       	subi	r24, 0xFA	; 250
     b58:	91 09       	sbc	r25, r1
     b5a:	90 93 03 02 	sts	0x0203, r25
     b5e:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     b62:	80 91 00 02 	lds	r24, 0x0200
     b66:	90 91 01 02 	lds	r25, 0x0201
     b6a:	88 38       	cpi	r24, 0x88	; 136
     b6c:	93 41       	sbci	r25, 0x13	; 19
     b6e:	51 f0       	breq	.+20     	; 0xb84 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     b70:	80 91 00 02 	lds	r24, 0x0200
     b74:	90 91 01 02 	lds	r25, 0x0201
     b78:	8a 5f       	subi	r24, 0xFA	; 250
     b7a:	91 09       	sbc	r25, r1
     b7c:	90 93 01 02 	sts	0x0201, r25
     b80:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     b84:	d0 e0       	ldi	r29, 0x00	; 0
     b86:	80 91 02 02 	lds	r24, 0x0202
     b8a:	90 91 03 02 	lds	r25, 0x0203
     b8e:	8c 17       	cp	r24, r28
     b90:	9d 07       	cpc	r25, r29
     b92:	84 f4       	brge	.+32     	; 0xbb4 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     b94:	88 e8       	ldi	r24, 0x88	; 136
     b96:	93 e1       	ldi	r25, 0x13	; 19
     b98:	90 93 03 02 	sts	0x0203, r25
     b9c:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     ba0:	20 e0       	ldi	r18, 0x00	; 0
     ba2:	40 e0       	ldi	r20, 0x00	; 0
     ba4:	50 e0       	ldi	r21, 0x00	; 0
     ba6:	60 e0       	ldi	r22, 0x00	; 0
     ba8:	70 e0       	ldi	r23, 0x00	; 0
     baa:	80 91 a3 08 	lds	r24, 0x08A3
     bae:	90 91 a4 08 	lds	r25, 0x08A4
     bb2:	a4 d4       	rcall	.+2376   	; 0x14fc <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     bb4:	80 91 00 02 	lds	r24, 0x0200
     bb8:	90 91 01 02 	lds	r25, 0x0201
     bbc:	8c 17       	cp	r24, r28
     bbe:	9d 07       	cpc	r25, r29
     bc0:	84 f4       	brge	.+32     	; 0xbe2 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     bc2:	88 e8       	ldi	r24, 0x88	; 136
     bc4:	93 e1       	ldi	r25, 0x13	; 19
     bc6:	90 93 01 02 	sts	0x0201, r25
     bca:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     bce:	20 e0       	ldi	r18, 0x00	; 0
     bd0:	40 e0       	ldi	r20, 0x00	; 0
     bd2:	50 e0       	ldi	r21, 0x00	; 0
     bd4:	60 e0       	ldi	r22, 0x00	; 0
     bd6:	70 e0       	ldi	r23, 0x00	; 0
     bd8:	80 91 a5 08 	lds	r24, 0x08A5
     bdc:	90 91 a6 08 	lds	r25, 0x08A6
     be0:	8d d4       	rcall	.+2330   	; 0x14fc <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     be2:	80 91 02 02 	lds	r24, 0x0202
     be6:	90 91 03 02 	lds	r25, 0x0203
     bea:	88 38       	cpi	r24, 0x88	; 136
     bec:	93 41       	sbci	r25, 0x13	; 19
     bee:	79 f4       	brne	.+30     	; 0xc0e <myTimer_DelayChecker+0xd8>
     bf0:	80 91 00 02 	lds	r24, 0x0200
     bf4:	90 91 01 02 	lds	r25, 0x0201
     bf8:	88 38       	cpi	r24, 0x88	; 136
     bfa:	93 41       	sbci	r25, 0x13	; 19
     bfc:	41 f4       	brne	.+16     	; 0xc0e <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     bfe:	e0 91 a7 08 	lds	r30, 0x08A7
     c02:	f0 91 a8 08 	lds	r31, 0x08A8
     c06:	80 81       	ld	r24, Z
     c08:	91 81       	ldd	r25, Z+1	; 0x01
     c0a:	0e 94 93 10 	call	0x2126	; 0x2126 <vTaskSuspend>
	}
     c0e:	df 91       	pop	r29
     c10:	cf 91       	pop	r28
     c12:	08 95       	ret

00000c14 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     c14:	1f 92       	push	r1
     c16:	0f 92       	push	r0
     c18:	0f b6       	in	r0, 0x3f	; 63
     c1a:	0f 92       	push	r0
     c1c:	11 24       	eor	r1, r1
     c1e:	0b b6       	in	r0, 0x3b	; 59
     c20:	0f 92       	push	r0
     c22:	2f 93       	push	r18
     c24:	3f 93       	push	r19
     c26:	4f 93       	push	r20
     c28:	5f 93       	push	r21
     c2a:	6f 93       	push	r22
     c2c:	7f 93       	push	r23
     c2e:	8f 93       	push	r24
     c30:	9f 93       	push	r25
     c32:	af 93       	push	r26
     c34:	bf 93       	push	r27
     c36:	ef 93       	push	r30
     c38:	ff 93       	push	r31
     c3a:	60 91 ce 00 	lds	r22, 0x00CE
     c3e:	8e e3       	ldi	r24, 0x3E	; 62
     c40:	99 e0       	ldi	r25, 0x09	; 9
     c42:	27 d6       	rcall	.+3150   	; 0x1892 <ringBufferPush>
     c44:	20 e0       	ldi	r18, 0x00	; 0
     c46:	40 e0       	ldi	r20, 0x00	; 0
     c48:	50 e0       	ldi	r21, 0x00	; 0
     c4a:	60 e0       	ldi	r22, 0x00	; 0
     c4c:	70 e0       	ldi	r23, 0x00	; 0
     c4e:	80 91 32 09 	lds	r24, 0x0932
     c52:	90 91 33 09 	lds	r25, 0x0933
     c56:	0d d5       	rcall	.+2586   	; 0x1672 <xQueueGenericSendFromISR>
     c58:	8e e3       	ldi	r24, 0x3E	; 62
     c5a:	99 e0       	ldi	r25, 0x09	; 9
     c5c:	31 d6       	rcall	.+3170   	; 0x18c0 <ringBufferFull>
     c5e:	ff 91       	pop	r31
     c60:	ef 91       	pop	r30
     c62:	bf 91       	pop	r27
     c64:	af 91       	pop	r26
     c66:	9f 91       	pop	r25
     c68:	8f 91       	pop	r24
     c6a:	7f 91       	pop	r23
     c6c:	6f 91       	pop	r22
     c6e:	5f 91       	pop	r21
     c70:	4f 91       	pop	r20
     c72:	3f 91       	pop	r19
     c74:	2f 91       	pop	r18
     c76:	0f 90       	pop	r0
     c78:	0b be       	out	0x3b, r0	; 59
     c7a:	0f 90       	pop	r0
     c7c:	0f be       	out	0x3f, r0	; 63
     c7e:	0f 90       	pop	r0
     c80:	1f 90       	pop	r1
     c82:	18 95       	reti

00000c84 <__vector_25>:
     c84:	1f 92       	push	r1
     c86:	0f 92       	push	r0
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	0f 92       	push	r0
     c8c:	11 24       	eor	r1, r1
     c8e:	0b b6       	in	r0, 0x3b	; 59
     c90:	0f 92       	push	r0
     c92:	2f 93       	push	r18
     c94:	3f 93       	push	r19
     c96:	4f 93       	push	r20
     c98:	5f 93       	push	r21
     c9a:	6f 93       	push	r22
     c9c:	7f 93       	push	r23
     c9e:	8f 93       	push	r24
     ca0:	9f 93       	push	r25
     ca2:	af 93       	push	r26
     ca4:	bf 93       	push	r27
     ca6:	ef 93       	push	r30
     ca8:	ff 93       	push	r31
     caa:	60 91 c6 00 	lds	r22, 0x00C6
     cae:	89 ec       	ldi	r24, 0xC9	; 201
     cb0:	98 e0       	ldi	r25, 0x08	; 8
     cb2:	ef d5       	rcall	.+3038   	; 0x1892 <ringBufferPush>
     cb4:	20 e0       	ldi	r18, 0x00	; 0
     cb6:	40 e0       	ldi	r20, 0x00	; 0
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	60 e0       	ldi	r22, 0x00	; 0
     cbc:	70 e0       	ldi	r23, 0x00	; 0
     cbe:	80 91 32 09 	lds	r24, 0x0932
     cc2:	90 91 33 09 	lds	r25, 0x0933
     cc6:	d5 d4       	rcall	.+2474   	; 0x1672 <xQueueGenericSendFromISR>
     cc8:	89 ec       	ldi	r24, 0xC9	; 201
     cca:	98 e0       	ldi	r25, 0x08	; 8
     ccc:	f9 d5       	rcall	.+3058   	; 0x18c0 <ringBufferFull>
     cce:	ff 91       	pop	r31
     cd0:	ef 91       	pop	r30
     cd2:	bf 91       	pop	r27
     cd4:	af 91       	pop	r26
     cd6:	9f 91       	pop	r25
     cd8:	8f 91       	pop	r24
     cda:	7f 91       	pop	r23
     cdc:	6f 91       	pop	r22
     cde:	5f 91       	pop	r21
     ce0:	4f 91       	pop	r20
     ce2:	3f 91       	pop	r19
     ce4:	2f 91       	pop	r18
     ce6:	0f 90       	pop	r0
     ce8:	0b be       	out	0x3b, r0	; 59
     cea:	0f 90       	pop	r0
     cec:	0f be       	out	0x3f, r0	; 63
     cee:	0f 90       	pop	r0
     cf0:	1f 90       	pop	r1
     cf2:	18 95       	reti

00000cf4 <__vector_37>:
     cf4:	1f 92       	push	r1
     cf6:	0f 92       	push	r0
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	0f 92       	push	r0
     cfc:	11 24       	eor	r1, r1
     cfe:	0b b6       	in	r0, 0x3b	; 59
     d00:	0f 92       	push	r0
     d02:	2f 93       	push	r18
     d04:	3f 93       	push	r19
     d06:	4f 93       	push	r20
     d08:	5f 93       	push	r21
     d0a:	6f 93       	push	r22
     d0c:	7f 93       	push	r23
     d0e:	8f 93       	push	r24
     d10:	9f 93       	push	r25
     d12:	af 93       	push	r26
     d14:	bf 93       	push	r27
     d16:	ef 93       	push	r30
     d18:	ff 93       	push	r31
     d1a:	84 e3       	ldi	r24, 0x34	; 52
     d1c:	99 e0       	ldi	r25, 0x09	; 9
     d1e:	d7 d5       	rcall	.+2990   	; 0x18ce <ringBufferNotEmpty>
     d20:	88 23       	and	r24, r24
     d22:	31 f0       	breq	.+12     	; 0xd30 <__vector_37+0x3c>
     d24:	84 e3       	ldi	r24, 0x34	; 52
     d26:	99 e0       	ldi	r25, 0x09	; 9
     d28:	a2 d5       	rcall	.+2884   	; 0x186e <ringBufferPop>
     d2a:	80 93 ce 00 	sts	0x00CE, r24
     d2e:	05 c0       	rjmp	.+10     	; 0xd3a <__vector_37+0x46>
     d30:	e9 ec       	ldi	r30, 0xC9	; 201
     d32:	f0 e0       	ldi	r31, 0x00	; 0
     d34:	80 81       	ld	r24, Z
     d36:	8f 7d       	andi	r24, 0xDF	; 223
     d38:	80 83       	st	Z, r24
     d3a:	ff 91       	pop	r31
     d3c:	ef 91       	pop	r30
     d3e:	bf 91       	pop	r27
     d40:	af 91       	pop	r26
     d42:	9f 91       	pop	r25
     d44:	8f 91       	pop	r24
     d46:	7f 91       	pop	r23
     d48:	6f 91       	pop	r22
     d4a:	5f 91       	pop	r21
     d4c:	4f 91       	pop	r20
     d4e:	3f 91       	pop	r19
     d50:	2f 91       	pop	r18
     d52:	0f 90       	pop	r0
     d54:	0b be       	out	0x3b, r0	; 59
     d56:	0f 90       	pop	r0
     d58:	0f be       	out	0x3f, r0	; 63
     d5a:	0f 90       	pop	r0
     d5c:	1f 90       	pop	r1
     d5e:	18 95       	reti

00000d60 <__vector_26>:
     d60:	1f 92       	push	r1
     d62:	0f 92       	push	r0
     d64:	0f b6       	in	r0, 0x3f	; 63
     d66:	0f 92       	push	r0
     d68:	11 24       	eor	r1, r1
     d6a:	0b b6       	in	r0, 0x3b	; 59
     d6c:	0f 92       	push	r0
     d6e:	2f 93       	push	r18
     d70:	3f 93       	push	r19
     d72:	4f 93       	push	r20
     d74:	5f 93       	push	r21
     d76:	6f 93       	push	r22
     d78:	7f 93       	push	r23
     d7a:	8f 93       	push	r24
     d7c:	9f 93       	push	r25
     d7e:	af 93       	push	r26
     d80:	bf 93       	push	r27
     d82:	ef 93       	push	r30
     d84:	ff 93       	push	r31
     d86:	89 e3       	ldi	r24, 0x39	; 57
     d88:	99 e0       	ldi	r25, 0x09	; 9
     d8a:	a1 d5       	rcall	.+2882   	; 0x18ce <ringBufferNotEmpty>
     d8c:	88 23       	and	r24, r24
     d8e:	31 f0       	breq	.+12     	; 0xd9c <__vector_26+0x3c>
     d90:	89 e3       	ldi	r24, 0x39	; 57
     d92:	99 e0       	ldi	r25, 0x09	; 9
     d94:	6c d5       	rcall	.+2776   	; 0x186e <ringBufferPop>
     d96:	80 93 c6 00 	sts	0x00C6, r24
     d9a:	05 c0       	rjmp	.+10     	; 0xda6 <__vector_26+0x46>
     d9c:	e1 ec       	ldi	r30, 0xC1	; 193
     d9e:	f0 e0       	ldi	r31, 0x00	; 0
     da0:	80 81       	ld	r24, Z
     da2:	8f 7d       	andi	r24, 0xDF	; 223
     da4:	80 83       	st	Z, r24
     da6:	ff 91       	pop	r31
     da8:	ef 91       	pop	r30
     daa:	bf 91       	pop	r27
     dac:	af 91       	pop	r26
     dae:	9f 91       	pop	r25
     db0:	8f 91       	pop	r24
     db2:	7f 91       	pop	r23
     db4:	6f 91       	pop	r22
     db6:	5f 91       	pop	r21
     db8:	4f 91       	pop	r20
     dba:	3f 91       	pop	r19
     dbc:	2f 91       	pop	r18
     dbe:	0f 90       	pop	r0
     dc0:	0b be       	out	0x3b, r0	; 59
     dc2:	0f 90       	pop	r0
     dc4:	0f be       	out	0x3f, r0	; 63
     dc6:	0f 90       	pop	r0
     dc8:	1f 90       	pop	r1
     dca:	18 95       	reti

00000dcc <myUSART_USART0_Init>:
     dcc:	10 92 c5 00 	sts	0x00C5, r1
     dd0:	87 e6       	ldi	r24, 0x67	; 103
     dd2:	80 93 c4 00 	sts	0x00C4, r24
     dd6:	88 eb       	ldi	r24, 0xB8	; 184
     dd8:	80 93 c1 00 	sts	0x00C1, r24
     ddc:	86 e0       	ldi	r24, 0x06	; 6
     dde:	80 93 c2 00 	sts	0x00C2, r24
     de2:	40 e2       	ldi	r20, 0x20	; 32
     de4:	60 ef       	ldi	r22, 0xF0	; 240
     de6:	78 e0       	ldi	r23, 0x08	; 8
     de8:	89 ec       	ldi	r24, 0xC9	; 201
     dea:	98 e0       	ldi	r25, 0x08	; 8
     dec:	2f d5       	rcall	.+2654   	; 0x184c <ringBufferInit>
     dee:	40 e2       	ldi	r20, 0x20	; 32
     df0:	6e ec       	ldi	r22, 0xCE	; 206
     df2:	78 e0       	ldi	r23, 0x08	; 8
     df4:	89 e3       	ldi	r24, 0x39	; 57
     df6:	99 e0       	ldi	r25, 0x09	; 9
     df8:	29 d5       	rcall	.+2642   	; 0x184c <ringBufferInit>
     dfa:	43 e0       	ldi	r20, 0x03	; 3
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	81 e0       	ldi	r24, 0x01	; 1
     e00:	53 d3       	rcall	.+1702   	; 0x14a8 <xQueueGenericCreate>
     e02:	90 93 31 09 	sts	0x0931, r25
     e06:	80 93 30 09 	sts	0x0930, r24
     e0a:	08 95       	ret

00000e0c <myUSART_USART1_Init>:
     e0c:	10 92 cd 00 	sts	0x00CD, r1
     e10:	87 e6       	ldi	r24, 0x67	; 103
     e12:	80 93 cc 00 	sts	0x00CC, r24
     e16:	88 eb       	ldi	r24, 0xB8	; 184
     e18:	80 93 c9 00 	sts	0x00C9, r24
     e1c:	86 e0       	ldi	r24, 0x06	; 6
     e1e:	80 93 ca 00 	sts	0x00CA, r24
     e22:	40 e2       	ldi	r20, 0x20	; 32
     e24:	69 ea       	ldi	r22, 0xA9	; 169
     e26:	78 e0       	ldi	r23, 0x08	; 8
     e28:	8e e3       	ldi	r24, 0x3E	; 62
     e2a:	99 e0       	ldi	r25, 0x09	; 9
     e2c:	0f d5       	rcall	.+2590   	; 0x184c <ringBufferInit>
     e2e:	40 e2       	ldi	r20, 0x20	; 32
     e30:	60 e1       	ldi	r22, 0x10	; 16
     e32:	79 e0       	ldi	r23, 0x09	; 9
     e34:	84 e3       	ldi	r24, 0x34	; 52
     e36:	99 e0       	ldi	r25, 0x09	; 9
     e38:	09 d5       	rcall	.+2578   	; 0x184c <ringBufferInit>
     e3a:	43 e0       	ldi	r20, 0x03	; 3
     e3c:	60 e0       	ldi	r22, 0x00	; 0
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	33 d3       	rcall	.+1638   	; 0x14a8 <xQueueGenericCreate>
     e42:	90 93 33 09 	sts	0x0933, r25
     e46:	80 93 32 09 	sts	0x0932, r24
     e4a:	43 e0       	ldi	r20, 0x03	; 3
     e4c:	60 e0       	ldi	r22, 0x00	; 0
     e4e:	81 e0       	ldi	r24, 0x01	; 1
     e50:	2b d3       	rcall	.+1622   	; 0x14a8 <xQueueGenericCreate>
     e52:	90 93 ef 08 	sts	0x08EF, r25
     e56:	80 93 ee 08 	sts	0x08EE, r24
     e5a:	08 95       	ret

00000e5c <myUSART_transmitUSART0_c>:
     e5c:	cf 93       	push	r28
     e5e:	c8 2f       	mov	r28, r24
     e60:	89 e3       	ldi	r24, 0x39	; 57
     e62:	99 e0       	ldi	r25, 0x09	; 9
     e64:	2d d5       	rcall	.+2650   	; 0x18c0 <ringBufferFull>
     e66:	81 11       	cpse	r24, r1
     e68:	fb cf       	rjmp	.-10     	; 0xe60 <myUSART_transmitUSART0_c+0x4>
     e6a:	6c 2f       	mov	r22, r28
     e6c:	89 e3       	ldi	r24, 0x39	; 57
     e6e:	99 e0       	ldi	r25, 0x09	; 9
     e70:	10 d5       	rcall	.+2592   	; 0x1892 <ringBufferPush>
     e72:	e1 ec       	ldi	r30, 0xC1	; 193
     e74:	f0 e0       	ldi	r31, 0x00	; 0
     e76:	80 81       	ld	r24, Z
     e78:	80 62       	ori	r24, 0x20	; 32
     e7a:	80 83       	st	Z, r24
     e7c:	e0 ec       	ldi	r30, 0xC0	; 192
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	80 81       	ld	r24, Z
     e82:	80 64       	ori	r24, 0x40	; 64
     e84:	80 83       	st	Z, r24
     e86:	cf 91       	pop	r28
     e88:	08 95       	ret

00000e8a <myUSART_transmitUSART1_c>:
     e8a:	cf 93       	push	r28
     e8c:	c8 2f       	mov	r28, r24
     e8e:	84 e3       	ldi	r24, 0x34	; 52
     e90:	99 e0       	ldi	r25, 0x09	; 9
     e92:	16 d5       	rcall	.+2604   	; 0x18c0 <ringBufferFull>
     e94:	81 11       	cpse	r24, r1
     e96:	fb cf       	rjmp	.-10     	; 0xe8e <myUSART_transmitUSART1_c+0x4>
     e98:	6c 2f       	mov	r22, r28
     e9a:	84 e3       	ldi	r24, 0x34	; 52
     e9c:	99 e0       	ldi	r25, 0x09	; 9
     e9e:	f9 d4       	rcall	.+2546   	; 0x1892 <ringBufferPush>
     ea0:	e9 ec       	ldi	r30, 0xC9	; 201
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	80 81       	ld	r24, Z
     ea6:	80 62       	ori	r24, 0x20	; 32
     ea8:	80 83       	st	Z, r24
     eaa:	e8 ec       	ldi	r30, 0xC8	; 200
     eac:	f0 e0       	ldi	r31, 0x00	; 0
     eae:	80 81       	ld	r24, Z
     eb0:	80 64       	ori	r24, 0x40	; 64
     eb2:	80 83       	st	Z, r24
     eb4:	cf 91       	pop	r28
     eb6:	08 95       	ret

00000eb8 <myUSART_transmitUSART1>:
     eb8:	cf 93       	push	r28
     eba:	df 93       	push	r29
     ebc:	ec 01       	movw	r28, r24
     ebe:	88 81       	ld	r24, Y
     ec0:	88 23       	and	r24, r24
     ec2:	29 f0       	breq	.+10     	; 0xece <myUSART_transmitUSART1+0x16>
     ec4:	21 96       	adiw	r28, 0x01	; 1
     ec6:	e1 df       	rcall	.-62     	; 0xe8a <myUSART_transmitUSART1_c>
     ec8:	89 91       	ld	r24, Y+
     eca:	81 11       	cpse	r24, r1
     ecc:	fc cf       	rjmp	.-8      	; 0xec6 <myUSART_transmitUSART1+0xe>
     ece:	df 91       	pop	r29
     ed0:	cf 91       	pop	r28
     ed2:	08 95       	ret

00000ed4 <myUSART_transmitUSART0>:
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	ec 01       	movw	r28, r24
     eda:	88 81       	ld	r24, Y
     edc:	88 23       	and	r24, r24
     ede:	29 f0       	breq	.+10     	; 0xeea <myUSART_transmitUSART0+0x16>
     ee0:	21 96       	adiw	r28, 0x01	; 1
     ee2:	bc df       	rcall	.-136    	; 0xe5c <myUSART_transmitUSART0_c>
     ee4:	89 91       	ld	r24, Y+
     ee6:	81 11       	cpse	r24, r1
     ee8:	fc cf       	rjmp	.-8      	; 0xee2 <myUSART_transmitUSART0+0xe>
     eea:	df 91       	pop	r29
     eec:	cf 91       	pop	r28
     eee:	08 95       	ret

00000ef0 <myUSART_receiveUSART1>:
     ef0:	cf 93       	push	r28
     ef2:	20 e0       	ldi	r18, 0x00	; 0
     ef4:	4f ef       	ldi	r20, 0xFF	; 255
     ef6:	5f ef       	ldi	r21, 0xFF	; 255
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	70 e0       	ldi	r23, 0x00	; 0
     efc:	80 91 32 09 	lds	r24, 0x0932
     f00:	90 91 33 09 	lds	r25, 0x0933
     f04:	f0 d3       	rcall	.+2016   	; 0x16e6 <xQueueGenericReceive>
     f06:	8e e3       	ldi	r24, 0x3E	; 62
     f08:	99 e0       	ldi	r25, 0x09	; 9
     f0a:	b1 d4       	rcall	.+2402   	; 0x186e <ringBufferPop>
     f0c:	c8 2f       	mov	r28, r24
     f0e:	8e e3       	ldi	r24, 0x3E	; 62
     f10:	99 e0       	ldi	r25, 0x09	; 9
     f12:	dd d4       	rcall	.+2490   	; 0x18ce <ringBufferNotEmpty>
     f14:	88 23       	and	r24, r24
     f16:	51 f0       	breq	.+20     	; 0xf2c <myUSART_receiveUSART1+0x3c>
     f18:	20 e0       	ldi	r18, 0x00	; 0
     f1a:	40 e0       	ldi	r20, 0x00	; 0
     f1c:	50 e0       	ldi	r21, 0x00	; 0
     f1e:	60 e0       	ldi	r22, 0x00	; 0
     f20:	70 e0       	ldi	r23, 0x00	; 0
     f22:	80 91 32 09 	lds	r24, 0x0932
     f26:	90 91 33 09 	lds	r25, 0x0933
     f2a:	e8 d2       	rcall	.+1488   	; 0x14fc <xQueueGenericSend>
     f2c:	8c 2f       	mov	r24, r28
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret

00000f32 <myUSART_waitForHandshake>:
     f32:	de df       	rcall	.-68     	; 0xef0 <myUSART_receiveUSART1>
     f34:	86 31       	cpi	r24, 0x16	; 22
     f36:	51 f4       	brne	.+20     	; 0xf4c <myUSART_waitForHandshake+0x1a>
     f38:	85 e0       	ldi	r24, 0x05	; 5
     f3a:	a7 df       	rcall	.-178    	; 0xe8a <myUSART_transmitUSART1_c>
     f3c:	d9 df       	rcall	.-78     	; 0xef0 <myUSART_receiveUSART1>
     f3e:	91 e0       	ldi	r25, 0x01	; 1
     f40:	86 31       	cpi	r24, 0x16	; 22
     f42:	09 f4       	brne	.+2      	; 0xf46 <myUSART_waitForHandshake+0x14>
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	89 2f       	mov	r24, r25
     f48:	81 95       	neg	r24
     f4a:	08 95       	ret
     f4c:	8f ef       	ldi	r24, 0xFF	; 255
     f4e:	08 95       	ret

00000f50 <myUSART_completeHandShake>:
     f50:	20 e0       	ldi	r18, 0x00	; 0
     f52:	40 e0       	ldi	r20, 0x00	; 0
     f54:	50 e0       	ldi	r21, 0x00	; 0
     f56:	60 e0       	ldi	r22, 0x00	; 0
     f58:	70 e0       	ldi	r23, 0x00	; 0
     f5a:	80 91 ee 08 	lds	r24, 0x08EE
     f5e:	90 91 ef 08 	lds	r25, 0x08EF
     f62:	cc c2       	rjmp	.+1432   	; 0x14fc <xQueueGenericSend>
     f64:	08 95       	ret

00000f66 <myUSART_receiveHandShakeAck>:
     f66:	91 e0       	ldi	r25, 0x01	; 1
     f68:	85 30       	cpi	r24, 0x05	; 5
     f6a:	09 f0       	breq	.+2      	; 0xf6e <myUSART_receiveHandShakeAck+0x8>
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	89 2f       	mov	r24, r25
     f70:	08 95       	ret

00000f72 <myUSART_receiveHandShakeStart>:
     f72:	91 e0       	ldi	r25, 0x01	; 1
     f74:	86 31       	cpi	r24, 0x16	; 22
     f76:	09 f0       	breq	.+2      	; 0xf7a <myUSART_receiveHandShakeStart+0x8>
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	89 2f       	mov	r24, r25
     f7c:	08 95       	ret

00000f7e <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
     f7e:	91 e0       	ldi	r25, 0x01	; 1
     f80:	86 30       	cpi	r24, 0x06	; 6
     f82:	09 f0       	breq	.+2      	; 0xf86 <myUSART_receiveMessageACK+0x8>
     f84:	90 e0       	ldi	r25, 0x00	; 0
}
     f86:	89 2f       	mov	r24, r25
     f88:	08 95       	ret

00000f8a <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
     f8a:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
     f8c:	20 e0       	ldi	r18, 0x00	; 0
     f8e:	4f ef       	ldi	r20, 0xFF	; 255
     f90:	5f ef       	ldi	r21, 0xFF	; 255
     f92:	60 e0       	ldi	r22, 0x00	; 0
     f94:	70 e0       	ldi	r23, 0x00	; 0
     f96:	80 91 32 09 	lds	r24, 0x0932
     f9a:	90 91 33 09 	lds	r25, 0x0933
     f9e:	a3 d3       	rcall	.+1862   	; 0x16e6 <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
     fa0:	8e e3       	ldi	r24, 0x3E	; 62
     fa2:	99 e0       	ldi	r25, 0x09	; 9
     fa4:	5a d4       	rcall	.+2228   	; 0x185a <ringBufferPeek>
     fa6:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
     fa8:	8e e3       	ldi	r24, 0x3E	; 62
     faa:	99 e0       	ldi	r25, 0x09	; 9
     fac:	90 d4       	rcall	.+2336   	; 0x18ce <ringBufferNotEmpty>
     fae:	88 23       	and	r24, r24
     fb0:	51 f0       	breq	.+20     	; 0xfc6 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
     fb2:	20 e0       	ldi	r18, 0x00	; 0
     fb4:	40 e0       	ldi	r20, 0x00	; 0
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	60 e0       	ldi	r22, 0x00	; 0
     fba:	70 e0       	ldi	r23, 0x00	; 0
     fbc:	80 91 32 09 	lds	r24, 0x0932
     fc0:	90 91 33 09 	lds	r25, 0x0933
     fc4:	9b d2       	rcall	.+1334   	; 0x14fc <xQueueGenericSend>
	}
	
	return data;
     fc6:	8c 2f       	mov	r24, r28
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     fcc:	31 e1       	ldi	r19, 0x11	; 17
     fce:	fc 01       	movw	r30, r24
     fd0:	30 83       	st	Z, r19
     fd2:	31 97       	sbiw	r30, 0x01	; 1
     fd4:	22 e2       	ldi	r18, 0x22	; 34
     fd6:	20 83       	st	Z, r18
     fd8:	31 97       	sbiw	r30, 0x01	; 1
     fda:	a3 e3       	ldi	r26, 0x33	; 51
     fdc:	a0 83       	st	Z, r26
     fde:	31 97       	sbiw	r30, 0x01	; 1
     fe0:	60 83       	st	Z, r22
     fe2:	31 97       	sbiw	r30, 0x01	; 1
     fe4:	70 83       	st	Z, r23
     fe6:	31 97       	sbiw	r30, 0x01	; 1
     fe8:	10 82       	st	Z, r1
     fea:	31 97       	sbiw	r30, 0x01	; 1
     fec:	10 82       	st	Z, r1
     fee:	31 97       	sbiw	r30, 0x01	; 1
     ff0:	60 e8       	ldi	r22, 0x80	; 128
     ff2:	60 83       	st	Z, r22
     ff4:	31 97       	sbiw	r30, 0x01	; 1
     ff6:	10 82       	st	Z, r1
     ff8:	31 97       	sbiw	r30, 0x01	; 1
     ffa:	10 82       	st	Z, r1
     ffc:	31 97       	sbiw	r30, 0x01	; 1
     ffe:	10 82       	st	Z, r1
    1000:	31 97       	sbiw	r30, 0x01	; 1
    1002:	62 e0       	ldi	r22, 0x02	; 2
    1004:	60 83       	st	Z, r22
    1006:	31 97       	sbiw	r30, 0x01	; 1
    1008:	63 e0       	ldi	r22, 0x03	; 3
    100a:	60 83       	st	Z, r22
    100c:	31 97       	sbiw	r30, 0x01	; 1
    100e:	64 e0       	ldi	r22, 0x04	; 4
    1010:	60 83       	st	Z, r22
    1012:	31 97       	sbiw	r30, 0x01	; 1
    1014:	65 e0       	ldi	r22, 0x05	; 5
    1016:	60 83       	st	Z, r22
    1018:	31 97       	sbiw	r30, 0x01	; 1
    101a:	66 e0       	ldi	r22, 0x06	; 6
    101c:	60 83       	st	Z, r22
    101e:	31 97       	sbiw	r30, 0x01	; 1
    1020:	67 e0       	ldi	r22, 0x07	; 7
    1022:	60 83       	st	Z, r22
    1024:	31 97       	sbiw	r30, 0x01	; 1
    1026:	68 e0       	ldi	r22, 0x08	; 8
    1028:	60 83       	st	Z, r22
    102a:	31 97       	sbiw	r30, 0x01	; 1
    102c:	69 e0       	ldi	r22, 0x09	; 9
    102e:	60 83       	st	Z, r22
    1030:	31 97       	sbiw	r30, 0x01	; 1
    1032:	60 e1       	ldi	r22, 0x10	; 16
    1034:	60 83       	st	Z, r22
    1036:	31 97       	sbiw	r30, 0x01	; 1
    1038:	30 83       	st	Z, r19
    103a:	31 97       	sbiw	r30, 0x01	; 1
    103c:	32 e1       	ldi	r19, 0x12	; 18
    103e:	30 83       	st	Z, r19
    1040:	31 97       	sbiw	r30, 0x01	; 1
    1042:	33 e1       	ldi	r19, 0x13	; 19
    1044:	30 83       	st	Z, r19
    1046:	31 97       	sbiw	r30, 0x01	; 1
    1048:	34 e1       	ldi	r19, 0x14	; 20
    104a:	30 83       	st	Z, r19
    104c:	31 97       	sbiw	r30, 0x01	; 1
    104e:	35 e1       	ldi	r19, 0x15	; 21
    1050:	30 83       	st	Z, r19
    1052:	31 97       	sbiw	r30, 0x01	; 1
    1054:	36 e1       	ldi	r19, 0x16	; 22
    1056:	30 83       	st	Z, r19
    1058:	31 97       	sbiw	r30, 0x01	; 1
    105a:	37 e1       	ldi	r19, 0x17	; 23
    105c:	30 83       	st	Z, r19
    105e:	31 97       	sbiw	r30, 0x01	; 1
    1060:	38 e1       	ldi	r19, 0x18	; 24
    1062:	30 83       	st	Z, r19
    1064:	31 97       	sbiw	r30, 0x01	; 1
    1066:	39 e1       	ldi	r19, 0x19	; 25
    1068:	30 83       	st	Z, r19
    106a:	31 97       	sbiw	r30, 0x01	; 1
    106c:	30 e2       	ldi	r19, 0x20	; 32
    106e:	30 83       	st	Z, r19
    1070:	31 97       	sbiw	r30, 0x01	; 1
    1072:	31 e2       	ldi	r19, 0x21	; 33
    1074:	30 83       	st	Z, r19
    1076:	31 97       	sbiw	r30, 0x01	; 1
    1078:	20 83       	st	Z, r18
    107a:	31 97       	sbiw	r30, 0x01	; 1
    107c:	23 e2       	ldi	r18, 0x23	; 35
    107e:	20 83       	st	Z, r18
    1080:	31 97       	sbiw	r30, 0x01	; 1
    1082:	40 83       	st	Z, r20
    1084:	31 97       	sbiw	r30, 0x01	; 1
    1086:	50 83       	st	Z, r21
    1088:	31 97       	sbiw	r30, 0x01	; 1
    108a:	26 e2       	ldi	r18, 0x26	; 38
    108c:	20 83       	st	Z, r18
    108e:	31 97       	sbiw	r30, 0x01	; 1
    1090:	27 e2       	ldi	r18, 0x27	; 39
    1092:	20 83       	st	Z, r18
    1094:	31 97       	sbiw	r30, 0x01	; 1
    1096:	28 e2       	ldi	r18, 0x28	; 40
    1098:	20 83       	st	Z, r18
    109a:	31 97       	sbiw	r30, 0x01	; 1
    109c:	29 e2       	ldi	r18, 0x29	; 41
    109e:	20 83       	st	Z, r18
    10a0:	31 97       	sbiw	r30, 0x01	; 1
    10a2:	20 e3       	ldi	r18, 0x30	; 48
    10a4:	20 83       	st	Z, r18
    10a6:	31 97       	sbiw	r30, 0x01	; 1
    10a8:	21 e3       	ldi	r18, 0x31	; 49
    10aa:	20 83       	st	Z, r18
    10ac:	89 97       	sbiw	r24, 0x29	; 41
    10ae:	08 95       	ret

000010b0 <xPortStartScheduler>:
    10b0:	82 e0       	ldi	r24, 0x02	; 2
    10b2:	84 bd       	out	0x24, r24	; 36
    10b4:	16 bc       	out	0x26, r1	; 38
    10b6:	80 e3       	ldi	r24, 0x30	; 48
    10b8:	87 bd       	out	0x27, r24	; 39
    10ba:	ee e6       	ldi	r30, 0x6E	; 110
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	80 81       	ld	r24, Z
    10c0:	82 60       	ori	r24, 0x02	; 2
    10c2:	80 83       	st	Z, r24
    10c4:	83 e0       	ldi	r24, 0x03	; 3
    10c6:	85 bd       	out	0x25, r24	; 37
    10c8:	a0 91 89 08 	lds	r26, 0x0889
    10cc:	b0 91 8a 08 	lds	r27, 0x088A
    10d0:	cd 91       	ld	r28, X+
    10d2:	cd bf       	out	0x3d, r28	; 61
    10d4:	dd 91       	ld	r29, X+
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	ff 91       	pop	r31
    10da:	ef 91       	pop	r30
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	bf 91       	pop	r27
    10e2:	af 91       	pop	r26
    10e4:	9f 91       	pop	r25
    10e6:	8f 91       	pop	r24
    10e8:	7f 91       	pop	r23
    10ea:	6f 91       	pop	r22
    10ec:	5f 91       	pop	r21
    10ee:	4f 91       	pop	r20
    10f0:	3f 91       	pop	r19
    10f2:	2f 91       	pop	r18
    10f4:	1f 91       	pop	r17
    10f6:	0f 91       	pop	r16
    10f8:	ff 90       	pop	r15
    10fa:	ef 90       	pop	r14
    10fc:	df 90       	pop	r13
    10fe:	cf 90       	pop	r12
    1100:	bf 90       	pop	r11
    1102:	af 90       	pop	r10
    1104:	9f 90       	pop	r9
    1106:	8f 90       	pop	r8
    1108:	7f 90       	pop	r7
    110a:	6f 90       	pop	r6
    110c:	5f 90       	pop	r5
    110e:	4f 90       	pop	r4
    1110:	3f 90       	pop	r3
    1112:	2f 90       	pop	r2
    1114:	1f 90       	pop	r1
    1116:	0f 90       	pop	r0
    1118:	0c be       	out	0x3c, r0	; 60
    111a:	0f 90       	pop	r0
    111c:	0b be       	out	0x3b, r0	; 59
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63
    1122:	0f 90       	pop	r0
    1124:	08 95       	ret
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	08 95       	ret

0000112a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    112a:	0f 92       	push	r0
    112c:	0f b6       	in	r0, 0x3f	; 63
    112e:	f8 94       	cli
    1130:	0f 92       	push	r0
    1132:	0b b6       	in	r0, 0x3b	; 59
    1134:	0f 92       	push	r0
    1136:	0c b6       	in	r0, 0x3c	; 60
    1138:	0f 92       	push	r0
    113a:	1f 92       	push	r1
    113c:	11 24       	eor	r1, r1
    113e:	2f 92       	push	r2
    1140:	3f 92       	push	r3
    1142:	4f 92       	push	r4
    1144:	5f 92       	push	r5
    1146:	6f 92       	push	r6
    1148:	7f 92       	push	r7
    114a:	8f 92       	push	r8
    114c:	9f 92       	push	r9
    114e:	af 92       	push	r10
    1150:	bf 92       	push	r11
    1152:	cf 92       	push	r12
    1154:	df 92       	push	r13
    1156:	ef 92       	push	r14
    1158:	ff 92       	push	r15
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
    115e:	2f 93       	push	r18
    1160:	3f 93       	push	r19
    1162:	4f 93       	push	r20
    1164:	5f 93       	push	r21
    1166:	6f 93       	push	r22
    1168:	7f 93       	push	r23
    116a:	8f 93       	push	r24
    116c:	9f 93       	push	r25
    116e:	af 93       	push	r26
    1170:	bf 93       	push	r27
    1172:	cf 93       	push	r28
    1174:	df 93       	push	r29
    1176:	ef 93       	push	r30
    1178:	ff 93       	push	r31
    117a:	a0 91 89 08 	lds	r26, 0x0889
    117e:	b0 91 8a 08 	lds	r27, 0x088A
    1182:	0d b6       	in	r0, 0x3d	; 61
    1184:	0d 92       	st	X+, r0
    1186:	0e b6       	in	r0, 0x3e	; 62
    1188:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    118a:	6f d7       	rcall	.+3806   	; 0x206a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    118c:	a0 91 89 08 	lds	r26, 0x0889
    1190:	b0 91 8a 08 	lds	r27, 0x088A
    1194:	cd 91       	ld	r28, X+
    1196:	cd bf       	out	0x3d, r28	; 61
    1198:	dd 91       	ld	r29, X+
    119a:	de bf       	out	0x3e, r29	; 62
    119c:	ff 91       	pop	r31
    119e:	ef 91       	pop	r30
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	bf 91       	pop	r27
    11a6:	af 91       	pop	r26
    11a8:	9f 91       	pop	r25
    11aa:	8f 91       	pop	r24
    11ac:	7f 91       	pop	r23
    11ae:	6f 91       	pop	r22
    11b0:	5f 91       	pop	r21
    11b2:	4f 91       	pop	r20
    11b4:	3f 91       	pop	r19
    11b6:	2f 91       	pop	r18
    11b8:	1f 91       	pop	r17
    11ba:	0f 91       	pop	r16
    11bc:	ff 90       	pop	r15
    11be:	ef 90       	pop	r14
    11c0:	df 90       	pop	r13
    11c2:	cf 90       	pop	r12
    11c4:	bf 90       	pop	r11
    11c6:	af 90       	pop	r10
    11c8:	9f 90       	pop	r9
    11ca:	8f 90       	pop	r8
    11cc:	7f 90       	pop	r7
    11ce:	6f 90       	pop	r6
    11d0:	5f 90       	pop	r5
    11d2:	4f 90       	pop	r4
    11d4:	3f 90       	pop	r3
    11d6:	2f 90       	pop	r2
    11d8:	1f 90       	pop	r1
    11da:	0f 90       	pop	r0
    11dc:	0c be       	out	0x3c, r0	; 60
    11de:	0f 90       	pop	r0
    11e0:	0b be       	out	0x3b, r0	; 59
    11e2:	0f 90       	pop	r0
    11e4:	0f be       	out	0x3f, r0	; 63
    11e6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11e8:	08 95       	ret

000011ea <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    11ea:	0f 92       	push	r0
    11ec:	0f b6       	in	r0, 0x3f	; 63
    11ee:	f8 94       	cli
    11f0:	0f 92       	push	r0
    11f2:	0b b6       	in	r0, 0x3b	; 59
    11f4:	0f 92       	push	r0
    11f6:	0c b6       	in	r0, 0x3c	; 60
    11f8:	0f 92       	push	r0
    11fa:	1f 92       	push	r1
    11fc:	11 24       	eor	r1, r1
    11fe:	2f 92       	push	r2
    1200:	3f 92       	push	r3
    1202:	4f 92       	push	r4
    1204:	5f 92       	push	r5
    1206:	6f 92       	push	r6
    1208:	7f 92       	push	r7
    120a:	8f 92       	push	r8
    120c:	9f 92       	push	r9
    120e:	af 92       	push	r10
    1210:	bf 92       	push	r11
    1212:	cf 92       	push	r12
    1214:	df 92       	push	r13
    1216:	ef 92       	push	r14
    1218:	ff 92       	push	r15
    121a:	0f 93       	push	r16
    121c:	1f 93       	push	r17
    121e:	2f 93       	push	r18
    1220:	3f 93       	push	r19
    1222:	4f 93       	push	r20
    1224:	5f 93       	push	r21
    1226:	6f 93       	push	r22
    1228:	7f 93       	push	r23
    122a:	8f 93       	push	r24
    122c:	9f 93       	push	r25
    122e:	af 93       	push	r26
    1230:	bf 93       	push	r27
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	ef 93       	push	r30
    1238:	ff 93       	push	r31
    123a:	a0 91 89 08 	lds	r26, 0x0889
    123e:	b0 91 8a 08 	lds	r27, 0x088A
    1242:	0d b6       	in	r0, 0x3d	; 61
    1244:	0d 92       	st	X+, r0
    1246:	0e b6       	in	r0, 0x3e	; 62
    1248:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    124a:	3d d5       	rcall	.+2682   	; 0x1cc6 <xTaskIncrementTick>
    124c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    124e:	0d d7       	rcall	.+3610   	; 0x206a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1250:	a0 91 89 08 	lds	r26, 0x0889
    1254:	b0 91 8a 08 	lds	r27, 0x088A
    1258:	cd 91       	ld	r28, X+
    125a:	cd bf       	out	0x3d, r28	; 61
    125c:	dd 91       	ld	r29, X+
    125e:	de bf       	out	0x3e, r29	; 62
    1260:	ff 91       	pop	r31
    1262:	ef 91       	pop	r30
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	bf 91       	pop	r27
    126a:	af 91       	pop	r26
    126c:	9f 91       	pop	r25
    126e:	8f 91       	pop	r24
    1270:	7f 91       	pop	r23
    1272:	6f 91       	pop	r22
    1274:	5f 91       	pop	r21
    1276:	4f 91       	pop	r20
    1278:	3f 91       	pop	r19
    127a:	2f 91       	pop	r18
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	cf 90       	pop	r12
    1288:	bf 90       	pop	r11
    128a:	af 90       	pop	r10
    128c:	9f 90       	pop	r9
    128e:	8f 90       	pop	r8
    1290:	7f 90       	pop	r7
    1292:	6f 90       	pop	r6
    1294:	5f 90       	pop	r5
    1296:	4f 90       	pop	r4
    1298:	3f 90       	pop	r3
    129a:	2f 90       	pop	r2
    129c:	1f 90       	pop	r1
    129e:	0f 90       	pop	r0
    12a0:	0c be       	out	0x3c, r0	; 60
    12a2:	0f 90       	pop	r0
    12a4:	0b be       	out	0x3b, r0	; 59
    12a6:	0f 90       	pop	r0
    12a8:	0f be       	out	0x3f, r0	; 63
    12aa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12ac:	08 95       	ret

000012ae <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    12ae:	9d df       	rcall	.-198    	; 0x11ea <vPortYieldFromTick>
		 asm volatile ("reti");
    12b0:	18 95       	reti

000012b2 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    12bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12be:	81 11       	cpse	r24, r1
    12c0:	0c c0       	rjmp	.+24     	; 0x12da <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    12c2:	88 81       	ld	r24, Y
    12c4:	99 81       	ldd	r25, Y+1	; 0x01
    12c6:	89 2b       	or	r24, r25
    12c8:	09 f0       	breq	.+2      	; 0x12cc <prvCopyDataToQueue+0x1a>
    12ca:	47 c0       	rjmp	.+142    	; 0x135a <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    12cc:	8a 81       	ldd	r24, Y+2	; 0x02
    12ce:	9b 81       	ldd	r25, Y+3	; 0x03
    12d0:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    12d4:	1b 82       	std	Y+3, r1	; 0x03
    12d6:	1a 82       	std	Y+2, r1	; 0x02
    12d8:	47 c0       	rjmp	.+142    	; 0x1368 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    12da:	41 11       	cpse	r20, r1
    12dc:	18 c0       	rjmp	.+48     	; 0x130e <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    12de:	48 2f       	mov	r20, r24
    12e0:	50 e0       	ldi	r21, 0x00	; 0
    12e2:	8c 81       	ldd	r24, Y+4	; 0x04
    12e4:	9d 81       	ldd	r25, Y+5	; 0x05
    12e6:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    12ea:	2c 8d       	ldd	r18, Y+28	; 0x1c
    12ec:	8c 81       	ldd	r24, Y+4	; 0x04
    12ee:	9d 81       	ldd	r25, Y+5	; 0x05
    12f0:	82 0f       	add	r24, r18
    12f2:	91 1d       	adc	r25, r1
    12f4:	9d 83       	std	Y+5, r25	; 0x05
    12f6:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    12f8:	2a 81       	ldd	r18, Y+2	; 0x02
    12fa:	3b 81       	ldd	r19, Y+3	; 0x03
    12fc:	82 17       	cp	r24, r18
    12fe:	93 07       	cpc	r25, r19
    1300:	70 f1       	brcs	.+92     	; 0x135e <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1302:	88 81       	ld	r24, Y
    1304:	99 81       	ldd	r25, Y+1	; 0x01
    1306:	9d 83       	std	Y+5, r25	; 0x05
    1308:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    130a:	80 e0       	ldi	r24, 0x00	; 0
    130c:	2d c0       	rjmp	.+90     	; 0x1368 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    130e:	48 2f       	mov	r20, r24
    1310:	50 e0       	ldi	r21, 0x00	; 0
    1312:	8e 81       	ldd	r24, Y+6	; 0x06
    1314:	9f 81       	ldd	r25, Y+7	; 0x07
    1316:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    131a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    131c:	30 e0       	ldi	r19, 0x00	; 0
    131e:	31 95       	neg	r19
    1320:	21 95       	neg	r18
    1322:	31 09       	sbc	r19, r1
    1324:	8e 81       	ldd	r24, Y+6	; 0x06
    1326:	9f 81       	ldd	r25, Y+7	; 0x07
    1328:	82 0f       	add	r24, r18
    132a:	93 1f       	adc	r25, r19
    132c:	9f 83       	std	Y+7, r25	; 0x07
    132e:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1330:	68 81       	ld	r22, Y
    1332:	79 81       	ldd	r23, Y+1	; 0x01
    1334:	86 17       	cp	r24, r22
    1336:	97 07       	cpc	r25, r23
    1338:	30 f4       	brcc	.+12     	; 0x1346 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    133a:	8a 81       	ldd	r24, Y+2	; 0x02
    133c:	9b 81       	ldd	r25, Y+3	; 0x03
    133e:	28 0f       	add	r18, r24
    1340:	39 1f       	adc	r19, r25
    1342:	3f 83       	std	Y+7, r19	; 0x07
    1344:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1346:	12 30       	cpi	r17, 0x02	; 2
    1348:	61 f4       	brne	.+24     	; 0x1362 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    134a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    134c:	88 23       	and	r24, r24
    134e:	59 f0       	breq	.+22     	; 0x1366 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1350:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1352:	81 50       	subi	r24, 0x01	; 1
    1354:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1356:	80 e0       	ldi	r24, 0x00	; 0
    1358:	07 c0       	rjmp	.+14     	; 0x1368 <prvCopyDataToQueue+0xb6>
    135a:	80 e0       	ldi	r24, 0x00	; 0
    135c:	05 c0       	rjmp	.+10     	; 0x1368 <prvCopyDataToQueue+0xb6>
    135e:	80 e0       	ldi	r24, 0x00	; 0
    1360:	03 c0       	rjmp	.+6      	; 0x1368 <prvCopyDataToQueue+0xb6>
    1362:	80 e0       	ldi	r24, 0x00	; 0
    1364:	01 c0       	rjmp	.+2      	; 0x1368 <prvCopyDataToQueue+0xb6>
    1366:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1368:	9a 8d       	ldd	r25, Y+26	; 0x1a
    136a:	9f 5f       	subi	r25, 0xFF	; 255
    136c:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	1f 91       	pop	r17
    1374:	08 95       	ret

00001376 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1376:	fc 01       	movw	r30, r24
    1378:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    137a:	44 8d       	ldd	r20, Z+28	; 0x1c
    137c:	44 23       	and	r20, r20
    137e:	a1 f0       	breq	.+40     	; 0x13a8 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1380:	50 e0       	ldi	r21, 0x00	; 0
    1382:	26 81       	ldd	r18, Z+6	; 0x06
    1384:	37 81       	ldd	r19, Z+7	; 0x07
    1386:	24 0f       	add	r18, r20
    1388:	35 1f       	adc	r19, r21
    138a:	37 83       	std	Z+7, r19	; 0x07
    138c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    138e:	62 81       	ldd	r22, Z+2	; 0x02
    1390:	73 81       	ldd	r23, Z+3	; 0x03
    1392:	26 17       	cp	r18, r22
    1394:	37 07       	cpc	r19, r23
    1396:	20 f0       	brcs	.+8      	; 0x13a0 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1398:	20 81       	ld	r18, Z
    139a:	31 81       	ldd	r19, Z+1	; 0x01
    139c:	37 83       	std	Z+7, r19	; 0x07
    139e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    13a0:	66 81       	ldd	r22, Z+6	; 0x06
    13a2:	77 81       	ldd	r23, Z+7	; 0x07
    13a4:	0c 94 c4 15 	jmp	0x2b88	; 0x2b88 <memcpy>
    13a8:	08 95       	ret

000013aa <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    13aa:	0f 93       	push	r16
    13ac:	1f 93       	push	r17
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    13b4:	0f b6       	in	r0, 0x3f	; 63
    13b6:	f8 94       	cli
    13b8:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13ba:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13bc:	18 16       	cp	r1, r24
    13be:	a4 f4       	brge	.+40     	; 0x13e8 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13c0:	89 89       	ldd	r24, Y+17	; 0x11
    13c2:	88 23       	and	r24, r24
    13c4:	89 f0       	breq	.+34     	; 0x13e8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13c6:	8e 01       	movw	r16, r28
    13c8:	0f 5e       	subi	r16, 0xEF	; 239
    13ca:	1f 4f       	sbci	r17, 0xFF	; 255
    13cc:	03 c0       	rjmp	.+6      	; 0x13d4 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ce:	89 89       	ldd	r24, Y+17	; 0x11
    13d0:	88 23       	and	r24, r24
    13d2:	51 f0       	breq	.+20     	; 0x13e8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13d4:	c8 01       	movw	r24, r16
    13d6:	1f d7       	rcall	.+3646   	; 0x2216 <xTaskRemoveFromEventList>
    13d8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    13da:	a8 d7       	rcall	.+3920   	; 0x232c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    13dc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13de:	81 50       	subi	r24, 0x01	; 1
    13e0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13e4:	18 16       	cp	r1, r24
    13e6:	9c f3       	brlt	.-26     	; 0x13ce <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    13e8:	8f ef       	ldi	r24, 0xFF	; 255
    13ea:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    13ec:	0f 90       	pop	r0
    13ee:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    13f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    13f8:	18 16       	cp	r1, r24
    13fa:	a4 f4       	brge	.+40     	; 0x1424 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13fc:	88 85       	ldd	r24, Y+8	; 0x08
    13fe:	88 23       	and	r24, r24
    1400:	89 f0       	breq	.+34     	; 0x1424 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1402:	8e 01       	movw	r16, r28
    1404:	08 5f       	subi	r16, 0xF8	; 248
    1406:	1f 4f       	sbci	r17, 0xFF	; 255
    1408:	03 c0       	rjmp	.+6      	; 0x1410 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    140a:	88 85       	ldd	r24, Y+8	; 0x08
    140c:	88 23       	and	r24, r24
    140e:	51 f0       	breq	.+20     	; 0x1424 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1410:	c8 01       	movw	r24, r16
    1412:	01 d7       	rcall	.+3586   	; 0x2216 <xTaskRemoveFromEventList>
    1414:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1416:	8a d7       	rcall	.+3860   	; 0x232c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1418:	8d 8d       	ldd	r24, Y+29	; 0x1d
    141a:	81 50       	subi	r24, 0x01	; 1
    141c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    141e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1420:	18 16       	cp	r1, r24
    1422:	9c f3       	brlt	.-26     	; 0x140a <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1424:	8f ef       	ldi	r24, 0xFF	; 255
    1426:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1428:	0f 90       	pop	r0
    142a:	0f be       	out	0x3f, r0	; 63
}
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	1f 91       	pop	r17
    1432:	0f 91       	pop	r16
    1434:	08 95       	ret

00001436 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1442:	88 81       	ld	r24, Y
    1444:	99 81       	ldd	r25, Y+1	; 0x01
    1446:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1448:	30 e0       	ldi	r19, 0x00	; 0
    144a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    144c:	72 9f       	mul	r23, r18
    144e:	a0 01       	movw	r20, r0
    1450:	73 9f       	mul	r23, r19
    1452:	50 0d       	add	r21, r0
    1454:	11 24       	eor	r1, r1
    1456:	fc 01       	movw	r30, r24
    1458:	e4 0f       	add	r30, r20
    145a:	f5 1f       	adc	r31, r21
    145c:	fb 83       	std	Y+3, r31	; 0x03
    145e:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1460:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1462:	9d 83       	std	Y+5, r25	; 0x05
    1464:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1466:	42 1b       	sub	r20, r18
    1468:	53 0b       	sbc	r21, r19
    146a:	84 0f       	add	r24, r20
    146c:	95 1f       	adc	r25, r21
    146e:	9f 83       	std	Y+7, r25	; 0x07
    1470:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1472:	8f ef       	ldi	r24, 0xFF	; 255
    1474:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1476:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1478:	61 11       	cpse	r22, r1
    147a:	0a c0       	rjmp	.+20     	; 0x1490 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    147c:	88 85       	ldd	r24, Y+8	; 0x08
    147e:	88 23       	and	r24, r24
    1480:	69 f0       	breq	.+26     	; 0x149c <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1482:	ce 01       	movw	r24, r28
    1484:	08 96       	adiw	r24, 0x08	; 8
    1486:	c7 d6       	rcall	.+3470   	; 0x2216 <xTaskRemoveFromEventList>
    1488:	81 30       	cpi	r24, 0x01	; 1
    148a:	41 f4       	brne	.+16     	; 0x149c <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    148c:	4e de       	rcall	.-868    	; 0x112a <vPortYield>
    148e:	06 c0       	rjmp	.+12     	; 0x149c <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1490:	ce 01       	movw	r24, r28
    1492:	08 96       	adiw	r24, 0x08	; 8
    1494:	0a d9       	rcall	.-3564   	; 0x6aa <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1496:	ce 01       	movw	r24, r28
    1498:	41 96       	adiw	r24, 0x11	; 17
    149a:	07 d9       	rcall	.-3570   	; 0x6aa <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    149c:	0f 90       	pop	r0
    149e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    14a0:	81 e0       	ldi	r24, 0x01	; 1
    14a2:	df 91       	pop	r29
    14a4:	cf 91       	pop	r28
    14a6:	08 95       	ret

000014a8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    14a8:	0f 93       	push	r16
    14aa:	1f 93       	push	r17
    14ac:	cf 93       	push	r28
    14ae:	df 93       	push	r29
    14b0:	18 2f       	mov	r17, r24
    14b2:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    14b4:	88 23       	and	r24, r24
    14b6:	d1 f0       	breq	.+52     	; 0x14ec <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    14b8:	8f e1       	ldi	r24, 0x1F	; 31
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	c0 d8       	rcall	.-3712   	; 0x63e <pvPortMalloc>
    14be:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	b1 f0       	breq	.+44     	; 0x14f0 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14c4:	10 9f       	mul	r17, r16
    14c6:	c0 01       	movw	r24, r0
    14c8:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    14ca:	01 96       	adiw	r24, 0x01	; 1
    14cc:	b8 d8       	rcall	.-3728   	; 0x63e <pvPortMalloc>
    14ce:	99 83       	std	Y+1, r25	; 0x01
    14d0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    14d2:	89 2b       	or	r24, r25
    14d4:	31 f0       	breq	.+12     	; 0x14e2 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    14d6:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    14d8:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    14da:	61 e0       	ldi	r22, 0x01	; 1
    14dc:	ce 01       	movw	r24, r28
    14de:	ab df       	rcall	.-170    	; 0x1436 <xQueueGenericReset>
    14e0:	07 c0       	rjmp	.+14     	; 0x14f0 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    14e2:	ce 01       	movw	r24, r28
    14e4:	e1 d8       	rcall	.-3646   	; 0x6a8 <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    14e6:	c0 e0       	ldi	r28, 0x00	; 0
    14e8:	d0 e0       	ldi	r29, 0x00	; 0
    14ea:	02 c0       	rjmp	.+4      	; 0x14f0 <xQueueGenericCreate+0x48>
    14ec:	c0 e0       	ldi	r28, 0x00	; 0
    14ee:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    14f0:	ce 01       	movw	r24, r28
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	08 95       	ret

000014fc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    14fc:	9f 92       	push	r9
    14fe:	af 92       	push	r10
    1500:	bf 92       	push	r11
    1502:	cf 92       	push	r12
    1504:	df 92       	push	r13
    1506:	ef 92       	push	r14
    1508:	ff 92       	push	r15
    150a:	0f 93       	push	r16
    150c:	1f 93       	push	r17
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	00 d0       	rcall	.+0      	; 0x1514 <xQueueGenericSend+0x18>
    1514:	1f 92       	push	r1
    1516:	1f 92       	push	r1
    1518:	cd b7       	in	r28, 0x3d	; 61
    151a:	de b7       	in	r29, 0x3e	; 62
    151c:	8c 01       	movw	r16, r24
    151e:	6b 01       	movw	r12, r22
    1520:	5d 83       	std	Y+5, r21	; 0x05
    1522:	4c 83       	std	Y+4, r20	; 0x04
    1524:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1526:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1528:	99 24       	eor	r9, r9
    152a:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    152c:	7c 01       	movw	r14, r24
    152e:	88 e0       	ldi	r24, 0x08	; 8
    1530:	e8 0e       	add	r14, r24
    1532:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1534:	0f b6       	in	r0, 0x3f	; 63
    1536:	f8 94       	cli
    1538:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    153a:	f8 01       	movw	r30, r16
    153c:	92 8d       	ldd	r25, Z+26	; 0x1a
    153e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1540:	98 17       	cp	r25, r24
    1542:	18 f0       	brcs	.+6      	; 0x154a <xQueueGenericSend+0x4e>
    1544:	f2 e0       	ldi	r31, 0x02	; 2
    1546:	af 12       	cpse	r10, r31
    1548:	15 c0       	rjmp	.+42     	; 0x1574 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    154a:	4a 2d       	mov	r20, r10
    154c:	b6 01       	movw	r22, r12
    154e:	c8 01       	movw	r24, r16
    1550:	b0 de       	rcall	.-672    	; 0x12b2 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1552:	f8 01       	movw	r30, r16
    1554:	91 89       	ldd	r25, Z+17	; 0x11
    1556:	99 23       	and	r25, r25
    1558:	39 f0       	breq	.+14     	; 0x1568 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    155a:	c8 01       	movw	r24, r16
    155c:	41 96       	adiw	r24, 0x11	; 17
    155e:	5b d6       	rcall	.+3254   	; 0x2216 <xTaskRemoveFromEventList>
    1560:	81 30       	cpi	r24, 0x01	; 1
    1562:	21 f4       	brne	.+8      	; 0x156c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1564:	e2 dd       	rcall	.-1084   	; 0x112a <vPortYield>
    1566:	02 c0       	rjmp	.+4      	; 0x156c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1568:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    156a:	df dd       	rcall	.-1090   	; 0x112a <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	46 c0       	rjmp	.+140    	; 0x1600 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1574:	ec 81       	ldd	r30, Y+4	; 0x04
    1576:	fd 81       	ldd	r31, Y+5	; 0x05
    1578:	ef 2b       	or	r30, r31
    157a:	21 f4       	brne	.+8      	; 0x1584 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1580:	80 e0       	ldi	r24, 0x00	; 0
    1582:	3e c0       	rjmp	.+124    	; 0x1600 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1584:	b1 10       	cpse	r11, r1
    1586:	04 c0       	rjmp	.+8      	; 0x1590 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1588:	ce 01       	movw	r24, r28
    158a:	01 96       	adiw	r24, 0x01	; 1
    158c:	8c d6       	rcall	.+3352   	; 0x22a6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    158e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1590:	0f 90       	pop	r0
    1592:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1594:	83 d3       	rcall	.+1798   	; 0x1c9c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1596:	0f b6       	in	r0, 0x3f	; 63
    1598:	f8 94       	cli
    159a:	0f 92       	push	r0
    159c:	f8 01       	movw	r30, r16
    159e:	85 8d       	ldd	r24, Z+29	; 0x1d
    15a0:	8f 3f       	cpi	r24, 0xFF	; 255
    15a2:	09 f4       	brne	.+2      	; 0x15a6 <xQueueGenericSend+0xaa>
    15a4:	15 8e       	std	Z+29, r1	; 0x1d
    15a6:	f8 01       	movw	r30, r16
    15a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    15aa:	8f 3f       	cpi	r24, 0xFF	; 255
    15ac:	09 f4       	brne	.+2      	; 0x15b0 <xQueueGenericSend+0xb4>
    15ae:	16 8e       	std	Z+30, r1	; 0x1e
    15b0:	0f 90       	pop	r0
    15b2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15b4:	be 01       	movw	r22, r28
    15b6:	6c 5f       	subi	r22, 0xFC	; 252
    15b8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ba:	ce 01       	movw	r24, r28
    15bc:	01 96       	adiw	r24, 0x01	; 1
    15be:	7e d6       	rcall	.+3324   	; 0x22bc <xTaskCheckForTimeOut>
    15c0:	81 11       	cpse	r24, r1
    15c2:	1a c0       	rjmp	.+52     	; 0x15f8 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    15c4:	0f b6       	in	r0, 0x3f	; 63
    15c6:	f8 94       	cli
    15c8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    15ca:	f8 01       	movw	r30, r16
    15cc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    15ce:	0f 90       	pop	r0
    15d0:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15d2:	f8 01       	movw	r30, r16
    15d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    15d6:	98 13       	cpse	r25, r24
    15d8:	0b c0       	rjmp	.+22     	; 0x15f0 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15da:	6c 81       	ldd	r22, Y+4	; 0x04
    15dc:	7d 81       	ldd	r23, Y+5	; 0x05
    15de:	c7 01       	movw	r24, r14
    15e0:	ef d5       	rcall	.+3038   	; 0x21c0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    15e2:	c8 01       	movw	r24, r16
    15e4:	e2 de       	rcall	.-572    	; 0x13aa <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    15e6:	2d d4       	rcall	.+2138   	; 0x1e42 <xTaskResumeAll>
    15e8:	81 11       	cpse	r24, r1
    15ea:	a4 cf       	rjmp	.-184    	; 0x1534 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    15ec:	9e dd       	rcall	.-1220   	; 0x112a <vPortYield>
    15ee:	a2 cf       	rjmp	.-188    	; 0x1534 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    15f0:	c8 01       	movw	r24, r16
    15f2:	db de       	rcall	.-586    	; 0x13aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    15f4:	26 d4       	rcall	.+2124   	; 0x1e42 <xTaskResumeAll>
    15f6:	9e cf       	rjmp	.-196    	; 0x1534 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    15f8:	c8 01       	movw	r24, r16
    15fa:	d7 de       	rcall	.-594    	; 0x13aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    15fc:	22 d4       	rcall	.+2116   	; 0x1e42 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    15fe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1600:	0f 90       	pop	r0
    1602:	0f 90       	pop	r0
    1604:	0f 90       	pop	r0
    1606:	0f 90       	pop	r0
    1608:	0f 90       	pop	r0
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	1f 91       	pop	r17
    1610:	0f 91       	pop	r16
    1612:	ff 90       	pop	r15
    1614:	ef 90       	pop	r14
    1616:	df 90       	pop	r13
    1618:	cf 90       	pop	r12
    161a:	bf 90       	pop	r11
    161c:	af 90       	pop	r10
    161e:	9f 90       	pop	r9
    1620:	08 95       	ret

00001622 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1622:	cf 93       	push	r28
    1624:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1626:	8f e1       	ldi	r24, 0x1F	; 31
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	09 d8       	rcall	.-4078   	; 0x63e <pvPortMalloc>
    162c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    162e:	00 97       	sbiw	r24, 0x00	; 0
    1630:	e1 f0       	breq	.+56     	; 0x166a <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1632:	1b 82       	std	Y+3, r1	; 0x03
    1634:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1636:	19 82       	std	Y+1, r1	; 0x01
    1638:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    163a:	1d 82       	std	Y+5, r1	; 0x05
    163c:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    163e:	1f 82       	std	Y+7, r1	; 0x07
    1640:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1642:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1648:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    164a:	8f ef       	ldi	r24, 0xFF	; 255
    164c:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    164e:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1650:	ce 01       	movw	r24, r28
    1652:	08 96       	adiw	r24, 0x08	; 8
    1654:	2a d8       	rcall	.-4012   	; 0x6aa <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1656:	ce 01       	movw	r24, r28
    1658:	41 96       	adiw	r24, 0x11	; 17
    165a:	27 d8       	rcall	.-4018   	; 0x6aa <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    165c:	20 e0       	ldi	r18, 0x00	; 0
    165e:	40 e0       	ldi	r20, 0x00	; 0
    1660:	50 e0       	ldi	r21, 0x00	; 0
    1662:	60 e0       	ldi	r22, 0x00	; 0
    1664:	70 e0       	ldi	r23, 0x00	; 0
    1666:	ce 01       	movw	r24, r28
    1668:	49 df       	rcall	.-366    	; 0x14fc <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    166a:	ce 01       	movw	r24, r28
    166c:	df 91       	pop	r29
    166e:	cf 91       	pop	r28
    1670:	08 95       	ret

00001672 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1672:	0f 93       	push	r16
    1674:	1f 93       	push	r17
    1676:	cf 93       	push	r28
    1678:	df 93       	push	r29
    167a:	ec 01       	movw	r28, r24
    167c:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    167e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1680:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1682:	98 17       	cp	r25, r24
    1684:	10 f0       	brcs	.+4      	; 0x168a <xQueueGenericSendFromISR+0x18>
    1686:	22 30       	cpi	r18, 0x02	; 2
    1688:	11 f5       	brne	.+68     	; 0x16ce <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    168a:	42 2f       	mov	r20, r18
    168c:	ce 01       	movw	r24, r28
    168e:	11 de       	rcall	.-990    	; 0x12b2 <prvCopyDataToQueue>
    1690:	88 23       	and	r24, r24
    1692:	31 f0       	breq	.+12     	; 0x16a0 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1694:	01 15       	cp	r16, r1
    1696:	11 05       	cpc	r17, r1
    1698:	19 f0       	breq	.+6      	; 0x16a0 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	f8 01       	movw	r30, r16
    169e:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    16a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16a2:	8f 3f       	cpi	r24, 0xFF	; 255
    16a4:	79 f4       	brne	.+30     	; 0x16c4 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16a6:	89 89       	ldd	r24, Y+17	; 0x11
    16a8:	88 23       	and	r24, r24
    16aa:	99 f0       	breq	.+38     	; 0x16d2 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16ac:	ce 01       	movw	r24, r28
    16ae:	41 96       	adiw	r24, 0x11	; 17
    16b0:	b2 d5       	rcall	.+2916   	; 0x2216 <xTaskRemoveFromEventList>
    16b2:	88 23       	and	r24, r24
    16b4:	81 f0       	breq	.+32     	; 0x16d6 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16b6:	01 15       	cp	r16, r1
    16b8:	11 05       	cpc	r17, r1
    16ba:	79 f0       	breq	.+30     	; 0x16da <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	f8 01       	movw	r30, r16
    16c0:	80 83       	st	Z, r24
    16c2:	0c c0       	rjmp	.+24     	; 0x16dc <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    16c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16c6:	8f 5f       	subi	r24, 0xFF	; 255
    16c8:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	07 c0       	rjmp	.+14     	; 0x16dc <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    16ce:	80 e0       	ldi	r24, 0x00	; 0
    16d0:	05 c0       	rjmp	.+10     	; 0x16dc <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	03 c0       	rjmp	.+6      	; 0x16dc <xQueueGenericSendFromISR+0x6a>
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	01 c0       	rjmp	.+2      	; 0x16dc <xQueueGenericSendFromISR+0x6a>
    16da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	1f 91       	pop	r17
    16e2:	0f 91       	pop	r16
    16e4:	08 95       	ret

000016e6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    16e6:	9f 92       	push	r9
    16e8:	af 92       	push	r10
    16ea:	bf 92       	push	r11
    16ec:	cf 92       	push	r12
    16ee:	df 92       	push	r13
    16f0:	ef 92       	push	r14
    16f2:	ff 92       	push	r15
    16f4:	0f 93       	push	r16
    16f6:	1f 93       	push	r17
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	00 d0       	rcall	.+0      	; 0x16fe <xQueueGenericReceive+0x18>
    16fe:	1f 92       	push	r1
    1700:	1f 92       	push	r1
    1702:	cd b7       	in	r28, 0x3d	; 61
    1704:	de b7       	in	r29, 0x3e	; 62
    1706:	8c 01       	movw	r16, r24
    1708:	6b 01       	movw	r12, r22
    170a:	5d 83       	std	Y+5, r21	; 0x05
    170c:	4c 83       	std	Y+4, r20	; 0x04
    170e:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1710:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1712:	99 24       	eor	r9, r9
    1714:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1716:	7c 01       	movw	r14, r24
    1718:	81 e1       	ldi	r24, 0x11	; 17
    171a:	e8 0e       	add	r14, r24
    171c:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1724:	f8 01       	movw	r30, r16
    1726:	82 8d       	ldd	r24, Z+26	; 0x1a
    1728:	88 23       	and	r24, r24
    172a:	69 f1       	breq	.+90     	; 0x1786 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    172c:	e6 80       	ldd	r14, Z+6	; 0x06
    172e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1730:	b6 01       	movw	r22, r12
    1732:	c8 01       	movw	r24, r16
    1734:	20 de       	rcall	.-960    	; 0x1376 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1736:	b1 10       	cpse	r11, r1
    1738:	17 c0       	rjmp	.+46     	; 0x1768 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    173a:	f8 01       	movw	r30, r16
    173c:	82 8d       	ldd	r24, Z+26	; 0x1a
    173e:	81 50       	subi	r24, 0x01	; 1
    1740:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1742:	80 81       	ld	r24, Z
    1744:	91 81       	ldd	r25, Z+1	; 0x01
    1746:	89 2b       	or	r24, r25
    1748:	21 f4       	brne	.+8      	; 0x1752 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    174a:	91 d6       	rcall	.+3362   	; 0x246e <pvTaskIncrementMutexHeldCount>
    174c:	f8 01       	movw	r30, r16
    174e:	93 83       	std	Z+3, r25	; 0x03
    1750:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1752:	f8 01       	movw	r30, r16
    1754:	80 85       	ldd	r24, Z+8	; 0x08
    1756:	88 23       	and	r24, r24
    1758:	91 f0       	breq	.+36     	; 0x177e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    175a:	c8 01       	movw	r24, r16
    175c:	08 96       	adiw	r24, 0x08	; 8
    175e:	5b d5       	rcall	.+2742   	; 0x2216 <xTaskRemoveFromEventList>
    1760:	81 30       	cpi	r24, 0x01	; 1
    1762:	69 f4       	brne	.+26     	; 0x177e <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1764:	e2 dc       	rcall	.-1596   	; 0x112a <vPortYield>
    1766:	0b c0       	rjmp	.+22     	; 0x177e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1768:	f8 01       	movw	r30, r16
    176a:	f7 82       	std	Z+7, r15	; 0x07
    176c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    176e:	81 89       	ldd	r24, Z+17	; 0x11
    1770:	88 23       	and	r24, r24
    1772:	29 f0       	breq	.+10     	; 0x177e <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1774:	c8 01       	movw	r24, r16
    1776:	41 96       	adiw	r24, 0x11	; 17
    1778:	4e d5       	rcall	.+2716   	; 0x2216 <xTaskRemoveFromEventList>
    177a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    177c:	d6 dc       	rcall	.-1620   	; 0x112a <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    177e:	0f 90       	pop	r0
    1780:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	52 c0       	rjmp	.+164    	; 0x182a <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1786:	4c 81       	ldd	r20, Y+4	; 0x04
    1788:	5d 81       	ldd	r21, Y+5	; 0x05
    178a:	45 2b       	or	r20, r21
    178c:	21 f4       	brne	.+8      	; 0x1796 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1792:	80 e0       	ldi	r24, 0x00	; 0
    1794:	4a c0       	rjmp	.+148    	; 0x182a <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1796:	a1 10       	cpse	r10, r1
    1798:	04 c0       	rjmp	.+8      	; 0x17a2 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    179a:	ce 01       	movw	r24, r28
    179c:	01 96       	adiw	r24, 0x01	; 1
    179e:	83 d5       	rcall	.+2822   	; 0x22a6 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17a0:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17a2:	0f 90       	pop	r0
    17a4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17a6:	7a d2       	rcall	.+1268   	; 0x1c9c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17a8:	0f b6       	in	r0, 0x3f	; 63
    17aa:	f8 94       	cli
    17ac:	0f 92       	push	r0
    17ae:	f8 01       	movw	r30, r16
    17b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    17b2:	8f 3f       	cpi	r24, 0xFF	; 255
    17b4:	09 f4       	brne	.+2      	; 0x17b8 <xQueueGenericReceive+0xd2>
    17b6:	15 8e       	std	Z+29, r1	; 0x1d
    17b8:	f8 01       	movw	r30, r16
    17ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    17bc:	8f 3f       	cpi	r24, 0xFF	; 255
    17be:	09 f4       	brne	.+2      	; 0x17c2 <xQueueGenericReceive+0xdc>
    17c0:	16 8e       	std	Z+30, r1	; 0x1e
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17c6:	be 01       	movw	r22, r28
    17c8:	6c 5f       	subi	r22, 0xFC	; 252
    17ca:	7f 4f       	sbci	r23, 0xFF	; 255
    17cc:	ce 01       	movw	r24, r28
    17ce:	01 96       	adiw	r24, 0x01	; 1
    17d0:	75 d5       	rcall	.+2794   	; 0x22bc <xTaskCheckForTimeOut>
    17d2:	81 11       	cpse	r24, r1
    17d4:	26 c0       	rjmp	.+76     	; 0x1822 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    17d6:	0f b6       	in	r0, 0x3f	; 63
    17d8:	f8 94       	cli
    17da:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    17dc:	f8 01       	movw	r30, r16
    17de:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17e4:	81 11       	cpse	r24, r1
    17e6:	19 c0       	rjmp	.+50     	; 0x181a <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    17e8:	f8 01       	movw	r30, r16
    17ea:	80 81       	ld	r24, Z
    17ec:	91 81       	ldd	r25, Z+1	; 0x01
    17ee:	89 2b       	or	r24, r25
    17f0:	49 f4       	brne	.+18     	; 0x1804 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    17f8:	f8 01       	movw	r30, r16
    17fa:	82 81       	ldd	r24, Z+2	; 0x02
    17fc:	93 81       	ldd	r25, Z+3	; 0x03
    17fe:	9a d5       	rcall	.+2868   	; 0x2334 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1804:	6c 81       	ldd	r22, Y+4	; 0x04
    1806:	7d 81       	ldd	r23, Y+5	; 0x05
    1808:	c7 01       	movw	r24, r14
    180a:	da d4       	rcall	.+2484   	; 0x21c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    180c:	c8 01       	movw	r24, r16
    180e:	cd dd       	rcall	.-1126   	; 0x13aa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1810:	18 d3       	rcall	.+1584   	; 0x1e42 <xTaskResumeAll>
    1812:	81 11       	cpse	r24, r1
    1814:	84 cf       	rjmp	.-248    	; 0x171e <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1816:	89 dc       	rcall	.-1774   	; 0x112a <vPortYield>
    1818:	82 cf       	rjmp	.-252    	; 0x171e <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    181a:	c8 01       	movw	r24, r16
    181c:	c6 dd       	rcall	.-1140   	; 0x13aa <prvUnlockQueue>
				( void ) xTaskResumeAll();
    181e:	11 d3       	rcall	.+1570   	; 0x1e42 <xTaskResumeAll>
    1820:	7e cf       	rjmp	.-260    	; 0x171e <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1822:	c8 01       	movw	r24, r16
    1824:	c2 dd       	rcall	.-1148   	; 0x13aa <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1826:	0d d3       	rcall	.+1562   	; 0x1e42 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1828:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    182a:	0f 90       	pop	r0
    182c:	0f 90       	pop	r0
    182e:	0f 90       	pop	r0
    1830:	0f 90       	pop	r0
    1832:	0f 90       	pop	r0
    1834:	df 91       	pop	r29
    1836:	cf 91       	pop	r28
    1838:	1f 91       	pop	r17
    183a:	0f 91       	pop	r16
    183c:	ff 90       	pop	r15
    183e:	ef 90       	pop	r14
    1840:	df 90       	pop	r13
    1842:	cf 90       	pop	r12
    1844:	bf 90       	pop	r11
    1846:	af 90       	pop	r10
    1848:	9f 90       	pop	r9
    184a:	08 95       	ret

0000184c <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    184c:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    184e:	71 83       	std	Z+1, r23	; 0x01
    1850:	60 83       	st	Z, r22
	ring->rSize = size;
    1852:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1854:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1856:	13 82       	std	Z+3, r1	; 0x03
    1858:	08 95       	ret

0000185a <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    185a:	dc 01       	movw	r26, r24
    185c:	14 96       	adiw	r26, 0x04	; 4
    185e:	2c 91       	ld	r18, X
    1860:	14 97       	sbiw	r26, 0x04	; 4
    1862:	ed 91       	ld	r30, X+
    1864:	fc 91       	ld	r31, X
    1866:	e2 0f       	add	r30, r18
    1868:	f1 1d       	adc	r31, r1
}
    186a:	80 81       	ld	r24, Z
    186c:	08 95       	ret

0000186e <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    186e:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1870:	94 81       	ldd	r25, Z+4	; 0x04
    1872:	a0 81       	ld	r26, Z
    1874:	b1 81       	ldd	r27, Z+1	; 0x01
    1876:	a9 0f       	add	r26, r25
    1878:	b1 1d       	adc	r27, r1
    187a:	8c 91       	ld	r24, X
            ring->rIndex ++;
    187c:	9f 5f       	subi	r25, 0xFF	; 255
    187e:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1880:	22 81       	ldd	r18, Z+2	; 0x02
    1882:	92 17       	cp	r25, r18
    1884:	10 f0       	brcs	.+4      	; 0x188a <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1886:	92 1b       	sub	r25, r18
    1888:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    188a:	93 81       	ldd	r25, Z+3	; 0x03
    188c:	91 50       	subi	r25, 0x01	; 1
    188e:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1890:	08 95       	ret

00001892 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1892:	fc 01       	movw	r30, r24
    1894:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1896:	83 81       	ldd	r24, Z+3	; 0x03
    1898:	22 81       	ldd	r18, Z+2	; 0x02
    189a:	82 17       	cp	r24, r18
    189c:	80 f4       	brcc	.+32     	; 0x18be <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    189e:	34 81       	ldd	r19, Z+4	; 0x04
    18a0:	90 e0       	ldi	r25, 0x00	; 0
    18a2:	83 0f       	add	r24, r19
    18a4:	91 1d       	adc	r25, r1
    18a6:	62 2f       	mov	r22, r18
    18a8:	70 e0       	ldi	r23, 0x00	; 0
    18aa:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <__divmodhi4>
    18ae:	a0 81       	ld	r26, Z
    18b0:	b1 81       	ldd	r27, Z+1	; 0x01
    18b2:	a8 0f       	add	r26, r24
    18b4:	b9 1f       	adc	r27, r25
    18b6:	4c 93       	st	X, r20
            ring->rLength++;
    18b8:	83 81       	ldd	r24, Z+3	; 0x03
    18ba:	8f 5f       	subi	r24, 0xFF	; 255
    18bc:	83 83       	std	Z+3, r24	; 0x03
    18be:	08 95       	ret

000018c0 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    18c0:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	22 81       	ldd	r18, Z+2	; 0x02
    18c6:	93 81       	ldd	r25, Z+3	; 0x03
    18c8:	29 13       	cpse	r18, r25
    18ca:	80 e0       	ldi	r24, 0x00	; 0
}
    18cc:	08 95       	ret

000018ce <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    18ce:	21 e0       	ldi	r18, 0x01	; 1
    18d0:	fc 01       	movw	r30, r24
    18d2:	83 81       	ldd	r24, Z+3	; 0x03
    18d4:	81 11       	cpse	r24, r1
    18d6:	01 c0       	rjmp	.+2      	; 0x18da <ringBufferNotEmpty+0xc>
    18d8:	20 e0       	ldi	r18, 0x00	; 0
}
    18da:	82 2f       	mov	r24, r18
    18dc:	08 95       	ret

000018de <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    18de:	e0 91 48 08 	lds	r30, 0x0848
    18e2:	f0 91 49 08 	lds	r31, 0x0849
    18e6:	80 81       	ld	r24, Z
    18e8:	81 11       	cpse	r24, r1
    18ea:	07 c0       	rjmp	.+14     	; 0x18fa <prvResetNextTaskUnblockTime+0x1c>
    18ec:	8f ef       	ldi	r24, 0xFF	; 255
    18ee:	9f ef       	ldi	r25, 0xFF	; 255
    18f0:	90 93 05 02 	sts	0x0205, r25
    18f4:	80 93 04 02 	sts	0x0204, r24
    18f8:	08 95       	ret
    18fa:	e0 91 48 08 	lds	r30, 0x0848
    18fe:	f0 91 49 08 	lds	r31, 0x0849
    1902:	05 80       	ldd	r0, Z+5	; 0x05
    1904:	f6 81       	ldd	r31, Z+6	; 0x06
    1906:	e0 2d       	mov	r30, r0
    1908:	06 80       	ldd	r0, Z+6	; 0x06
    190a:	f7 81       	ldd	r31, Z+7	; 0x07
    190c:	e0 2d       	mov	r30, r0
    190e:	82 81       	ldd	r24, Z+2	; 0x02
    1910:	93 81       	ldd	r25, Z+3	; 0x03
    1912:	90 93 05 02 	sts	0x0205, r25
    1916:	80 93 04 02 	sts	0x0204, r24
    191a:	08 95       	ret

0000191c <prvAddCurrentTaskToDelayedList>:
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	ec 01       	movw	r28, r24
    1922:	e0 91 89 08 	lds	r30, 0x0889
    1926:	f0 91 8a 08 	lds	r31, 0x088A
    192a:	93 83       	std	Z+3, r25	; 0x03
    192c:	82 83       	std	Z+2, r24	; 0x02
    192e:	80 91 27 08 	lds	r24, 0x0827
    1932:	90 91 28 08 	lds	r25, 0x0828
    1936:	c8 17       	cp	r28, r24
    1938:	d9 07       	cpc	r29, r25
    193a:	68 f4       	brcc	.+26     	; 0x1956 <prvAddCurrentTaskToDelayedList+0x3a>
    193c:	60 91 89 08 	lds	r22, 0x0889
    1940:	70 91 8a 08 	lds	r23, 0x088A
    1944:	80 91 46 08 	lds	r24, 0x0846
    1948:	90 91 47 08 	lds	r25, 0x0847
    194c:	6e 5f       	subi	r22, 0xFE	; 254
    194e:	7f 4f       	sbci	r23, 0xFF	; 255
    1950:	0e 94 88 03 	call	0x710	; 0x710 <vListInsert>
    1954:	17 c0       	rjmp	.+46     	; 0x1984 <prvAddCurrentTaskToDelayedList+0x68>
    1956:	60 91 89 08 	lds	r22, 0x0889
    195a:	70 91 8a 08 	lds	r23, 0x088A
    195e:	80 91 48 08 	lds	r24, 0x0848
    1962:	90 91 49 08 	lds	r25, 0x0849
    1966:	6e 5f       	subi	r22, 0xFE	; 254
    1968:	7f 4f       	sbci	r23, 0xFF	; 255
    196a:	0e 94 88 03 	call	0x710	; 0x710 <vListInsert>
    196e:	80 91 04 02 	lds	r24, 0x0204
    1972:	90 91 05 02 	lds	r25, 0x0205
    1976:	c8 17       	cp	r28, r24
    1978:	d9 07       	cpc	r29, r25
    197a:	20 f4       	brcc	.+8      	; 0x1984 <prvAddCurrentTaskToDelayedList+0x68>
    197c:	d0 93 05 02 	sts	0x0205, r29
    1980:	c0 93 04 02 	sts	0x0204, r28
    1984:	df 91       	pop	r29
    1986:	cf 91       	pop	r28
    1988:	08 95       	ret

0000198a <xTaskGenericCreate>:
    198a:	4f 92       	push	r4
    198c:	5f 92       	push	r5
    198e:	6f 92       	push	r6
    1990:	7f 92       	push	r7
    1992:	8f 92       	push	r8
    1994:	9f 92       	push	r9
    1996:	af 92       	push	r10
    1998:	bf 92       	push	r11
    199a:	cf 92       	push	r12
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	4c 01       	movw	r8, r24
    19ac:	5b 01       	movw	r10, r22
    19ae:	2a 01       	movw	r4, r20
    19b0:	39 01       	movw	r6, r18
    19b2:	83 e2       	ldi	r24, 0x23	; 35
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	0e 94 1f 03 	call	0x63e	; 0x63e <pvPortMalloc>
    19ba:	ec 01       	movw	r28, r24
    19bc:	00 97       	sbiw	r24, 0x00	; 0
    19be:	09 f4       	brne	.+2      	; 0x19c2 <xTaskGenericCreate+0x38>
    19c0:	e7 c0       	rjmp	.+462    	; 0x1b90 <xTaskGenericCreate+0x206>
    19c2:	c1 14       	cp	r12, r1
    19c4:	d1 04       	cpc	r13, r1
    19c6:	09 f0       	breq	.+2      	; 0x19ca <xTaskGenericCreate+0x40>
    19c8:	cc c0       	rjmp	.+408    	; 0x1b62 <xTaskGenericCreate+0x1d8>
    19ca:	c2 01       	movw	r24, r4
    19cc:	0e 94 1f 03 	call	0x63e	; 0x63e <pvPortMalloc>
    19d0:	98 8f       	std	Y+24, r25	; 0x18
    19d2:	8f 8b       	std	Y+23, r24	; 0x17
    19d4:	89 2b       	or	r24, r25
    19d6:	09 f0       	breq	.+2      	; 0x19da <xTaskGenericCreate+0x50>
    19d8:	c6 c0       	rjmp	.+396    	; 0x1b66 <xTaskGenericCreate+0x1dc>
    19da:	ce 01       	movw	r24, r28
    19dc:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vPortFree>
    19e0:	d7 c0       	rjmp	.+430    	; 0x1b90 <xTaskGenericCreate+0x206>
    19e2:	cf 01       	movw	r24, r30
    19e4:	31 91       	ld	r19, Z+
    19e6:	da 01       	movw	r26, r20
    19e8:	3d 93       	st	X+, r19
    19ea:	ad 01       	movw	r20, r26
    19ec:	dc 01       	movw	r26, r24
    19ee:	8c 91       	ld	r24, X
    19f0:	88 23       	and	r24, r24
    19f2:	11 f0       	breq	.+4      	; 0x19f8 <xTaskGenericCreate+0x6e>
    19f4:	21 50       	subi	r18, 0x01	; 1
    19f6:	a9 f7       	brne	.-22     	; 0x19e2 <xTaskGenericCreate+0x58>
    19f8:	18 a2       	std	Y+32, r1	; 0x20
    19fa:	10 2f       	mov	r17, r16
    19fc:	05 30       	cpi	r16, 0x05	; 5
    19fe:	08 f0       	brcs	.+2      	; 0x1a02 <xTaskGenericCreate+0x78>
    1a00:	14 e0       	ldi	r17, 0x04	; 4
    1a02:	1e 8b       	std	Y+22, r17	; 0x16
    1a04:	19 a3       	std	Y+33, r17	; 0x21
    1a06:	1a a2       	std	Y+34, r1	; 0x22
    1a08:	5e 01       	movw	r10, r28
    1a0a:	b2 e0       	ldi	r27, 0x02	; 2
    1a0c:	ab 0e       	add	r10, r27
    1a0e:	b1 1c       	adc	r11, r1
    1a10:	c5 01       	movw	r24, r10
    1a12:	0e 94 63 03 	call	0x6c6	; 0x6c6 <vListInitialiseItem>
    1a16:	ce 01       	movw	r24, r28
    1a18:	0c 96       	adiw	r24, 0x0c	; 12
    1a1a:	0e 94 63 03 	call	0x6c6	; 0x6c6 <vListInitialiseItem>
    1a1e:	d9 87       	std	Y+9, r29	; 0x09
    1a20:	c8 87       	std	Y+8, r28	; 0x08
    1a22:	85 e0       	ldi	r24, 0x05	; 5
    1a24:	90 e0       	ldi	r25, 0x00	; 0
    1a26:	81 1b       	sub	r24, r17
    1a28:	91 09       	sbc	r25, r1
    1a2a:	9d 87       	std	Y+13, r25	; 0x0d
    1a2c:	8c 87       	std	Y+12, r24	; 0x0c
    1a2e:	db 8b       	std	Y+19, r29	; 0x13
    1a30:	ca 8b       	std	Y+18, r28	; 0x12
    1a32:	a3 01       	movw	r20, r6
    1a34:	b4 01       	movw	r22, r8
    1a36:	c6 01       	movw	r24, r12
    1a38:	c9 da       	rcall	.-2670   	; 0xfcc <pxPortInitialiseStack>
    1a3a:	99 83       	std	Y+1, r25	; 0x01
    1a3c:	88 83       	st	Y, r24
    1a3e:	e1 14       	cp	r14, r1
    1a40:	f1 04       	cpc	r15, r1
    1a42:	19 f0       	breq	.+6      	; 0x1a4a <xTaskGenericCreate+0xc0>
    1a44:	f7 01       	movw	r30, r14
    1a46:	d1 83       	std	Z+1, r29	; 0x01
    1a48:	c0 83       	st	Z, r28
    1a4a:	0f b6       	in	r0, 0x3f	; 63
    1a4c:	f8 94       	cli
    1a4e:	0f 92       	push	r0
    1a50:	80 91 29 08 	lds	r24, 0x0829
    1a54:	8f 5f       	subi	r24, 0xFF	; 255
    1a56:	80 93 29 08 	sts	0x0829, r24
    1a5a:	80 91 89 08 	lds	r24, 0x0889
    1a5e:	90 91 8a 08 	lds	r25, 0x088A
    1a62:	89 2b       	or	r24, r25
    1a64:	09 f0       	breq	.+2      	; 0x1a68 <xTaskGenericCreate+0xde>
    1a66:	3f c0       	rjmp	.+126    	; 0x1ae6 <xTaskGenericCreate+0x15c>
    1a68:	d0 93 8a 08 	sts	0x088A, r29
    1a6c:	c0 93 89 08 	sts	0x0889, r28
    1a70:	80 91 29 08 	lds	r24, 0x0829
    1a74:	81 30       	cpi	r24, 0x01	; 1
    1a76:	09 f0       	breq	.+2      	; 0x1a7a <xTaskGenericCreate+0xf0>
    1a78:	45 c0       	rjmp	.+138    	; 0x1b04 <xTaskGenericCreate+0x17a>
    1a7a:	0f 2e       	mov	r0, r31
    1a7c:	fc e5       	ldi	r31, 0x5C	; 92
    1a7e:	ef 2e       	mov	r14, r31
    1a80:	f8 e0       	ldi	r31, 0x08	; 8
    1a82:	ff 2e       	mov	r15, r31
    1a84:	f0 2d       	mov	r31, r0
    1a86:	0f 2e       	mov	r0, r31
    1a88:	f9 e8       	ldi	r31, 0x89	; 137
    1a8a:	cf 2e       	mov	r12, r31
    1a8c:	f8 e0       	ldi	r31, 0x08	; 8
    1a8e:	df 2e       	mov	r13, r31
    1a90:	f0 2d       	mov	r31, r0
    1a92:	c7 01       	movw	r24, r14
    1a94:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1a98:	f9 e0       	ldi	r31, 0x09	; 9
    1a9a:	ef 0e       	add	r14, r31
    1a9c:	f1 1c       	adc	r15, r1
    1a9e:	ec 14       	cp	r14, r12
    1aa0:	fd 04       	cpc	r15, r13
    1aa2:	b9 f7       	brne	.-18     	; 0x1a92 <xTaskGenericCreate+0x108>
    1aa4:	83 e5       	ldi	r24, 0x53	; 83
    1aa6:	98 e0       	ldi	r25, 0x08	; 8
    1aa8:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1aac:	8a e4       	ldi	r24, 0x4A	; 74
    1aae:	98 e0       	ldi	r25, 0x08	; 8
    1ab0:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1ab4:	8d e3       	ldi	r24, 0x3D	; 61
    1ab6:	98 e0       	ldi	r25, 0x08	; 8
    1ab8:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1abc:	84 e3       	ldi	r24, 0x34	; 52
    1abe:	98 e0       	ldi	r25, 0x08	; 8
    1ac0:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1ac4:	8a e2       	ldi	r24, 0x2A	; 42
    1ac6:	98 e0       	ldi	r25, 0x08	; 8
    1ac8:	0e 94 55 03 	call	0x6aa	; 0x6aa <vListInitialise>
    1acc:	83 e5       	ldi	r24, 0x53	; 83
    1ace:	98 e0       	ldi	r25, 0x08	; 8
    1ad0:	90 93 49 08 	sts	0x0849, r25
    1ad4:	80 93 48 08 	sts	0x0848, r24
    1ad8:	8a e4       	ldi	r24, 0x4A	; 74
    1ada:	98 e0       	ldi	r25, 0x08	; 8
    1adc:	90 93 47 08 	sts	0x0847, r25
    1ae0:	80 93 46 08 	sts	0x0846, r24
    1ae4:	0f c0       	rjmp	.+30     	; 0x1b04 <xTaskGenericCreate+0x17a>
    1ae6:	80 91 25 08 	lds	r24, 0x0825
    1aea:	81 11       	cpse	r24, r1
    1aec:	0b c0       	rjmp	.+22     	; 0x1b04 <xTaskGenericCreate+0x17a>
    1aee:	e0 91 89 08 	lds	r30, 0x0889
    1af2:	f0 91 8a 08 	lds	r31, 0x088A
    1af6:	86 89       	ldd	r24, Z+22	; 0x16
    1af8:	08 17       	cp	r16, r24
    1afa:	20 f0       	brcs	.+8      	; 0x1b04 <xTaskGenericCreate+0x17a>
    1afc:	d0 93 8a 08 	sts	0x088A, r29
    1b00:	c0 93 89 08 	sts	0x0889, r28
    1b04:	80 91 21 08 	lds	r24, 0x0821
    1b08:	8f 5f       	subi	r24, 0xFF	; 255
    1b0a:	80 93 21 08 	sts	0x0821, r24
    1b0e:	8e 89       	ldd	r24, Y+22	; 0x16
    1b10:	90 91 26 08 	lds	r25, 0x0826
    1b14:	98 17       	cp	r25, r24
    1b16:	10 f4       	brcc	.+4      	; 0x1b1c <xTaskGenericCreate+0x192>
    1b18:	80 93 26 08 	sts	0x0826, r24
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	9c 01       	movw	r18, r24
    1b20:	22 0f       	add	r18, r18
    1b22:	33 1f       	adc	r19, r19
    1b24:	22 0f       	add	r18, r18
    1b26:	33 1f       	adc	r19, r19
    1b28:	22 0f       	add	r18, r18
    1b2a:	33 1f       	adc	r19, r19
    1b2c:	82 0f       	add	r24, r18
    1b2e:	93 1f       	adc	r25, r19
    1b30:	b5 01       	movw	r22, r10
    1b32:	84 5a       	subi	r24, 0xA4	; 164
    1b34:	97 4f       	sbci	r25, 0xF7	; 247
    1b36:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    1b3a:	0f 90       	pop	r0
    1b3c:	0f be       	out	0x3f, r0	; 63
    1b3e:	80 91 25 08 	lds	r24, 0x0825
    1b42:	88 23       	and	r24, r24
    1b44:	51 f0       	breq	.+20     	; 0x1b5a <xTaskGenericCreate+0x1d0>
    1b46:	e0 91 89 08 	lds	r30, 0x0889
    1b4a:	f0 91 8a 08 	lds	r31, 0x088A
    1b4e:	86 89       	ldd	r24, Z+22	; 0x16
    1b50:	80 17       	cp	r24, r16
    1b52:	28 f4       	brcc	.+10     	; 0x1b5e <xTaskGenericCreate+0x1d4>
    1b54:	ea da       	rcall	.-2604   	; 0x112a <vPortYield>
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	1c c0       	rjmp	.+56     	; 0x1b92 <xTaskGenericCreate+0x208>
    1b5a:	81 e0       	ldi	r24, 0x01	; 1
    1b5c:	1a c0       	rjmp	.+52     	; 0x1b92 <xTaskGenericCreate+0x208>
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	18 c0       	rjmp	.+48     	; 0x1b92 <xTaskGenericCreate+0x208>
    1b62:	d8 8e       	std	Y+24, r13	; 0x18
    1b64:	cf 8a       	std	Y+23, r12	; 0x17
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	48 1a       	sub	r4, r24
    1b6a:	51 08       	sbc	r5, r1
    1b6c:	cf 88       	ldd	r12, Y+23	; 0x17
    1b6e:	d8 8c       	ldd	r13, Y+24	; 0x18
    1b70:	c4 0c       	add	r12, r4
    1b72:	d5 1c       	adc	r13, r5
    1b74:	d5 01       	movw	r26, r10
    1b76:	8c 91       	ld	r24, X
    1b78:	89 8f       	std	Y+25, r24	; 0x19
    1b7a:	8c 91       	ld	r24, X
    1b7c:	88 23       	and	r24, r24
    1b7e:	09 f4       	brne	.+2      	; 0x1b82 <xTaskGenericCreate+0x1f8>
    1b80:	3b cf       	rjmp	.-394    	; 0x19f8 <xTaskGenericCreate+0x6e>
    1b82:	ae 01       	movw	r20, r28
    1b84:	46 5e       	subi	r20, 0xE6	; 230
    1b86:	5f 4f       	sbci	r21, 0xFF	; 255
    1b88:	f5 01       	movw	r30, r10
    1b8a:	31 96       	adiw	r30, 0x01	; 1
    1b8c:	27 e0       	ldi	r18, 0x07	; 7
    1b8e:	29 cf       	rjmp	.-430    	; 0x19e2 <xTaskGenericCreate+0x58>
    1b90:	8f ef       	ldi	r24, 0xFF	; 255
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	ff 90       	pop	r15
    1b9c:	ef 90       	pop	r14
    1b9e:	df 90       	pop	r13
    1ba0:	cf 90       	pop	r12
    1ba2:	bf 90       	pop	r11
    1ba4:	af 90       	pop	r10
    1ba6:	9f 90       	pop	r9
    1ba8:	8f 90       	pop	r8
    1baa:	7f 90       	pop	r7
    1bac:	6f 90       	pop	r6
    1bae:	5f 90       	pop	r5
    1bb0:	4f 90       	pop	r4
    1bb2:	08 95       	ret

00001bb4 <vTaskResume>:
    1bb4:	0f 93       	push	r16
    1bb6:	1f 93       	push	r17
    1bb8:	cf 93       	push	r28
    1bba:	df 93       	push	r29
    1bbc:	ec 01       	movw	r28, r24
    1bbe:	00 97       	sbiw	r24, 0x00	; 0
    1bc0:	09 f4       	brne	.+2      	; 0x1bc4 <vTaskResume+0x10>
    1bc2:	3e c0       	rjmp	.+124    	; 0x1c40 <vTaskResume+0x8c>
    1bc4:	80 91 89 08 	lds	r24, 0x0889
    1bc8:	90 91 8a 08 	lds	r25, 0x088A
    1bcc:	c8 17       	cp	r28, r24
    1bce:	d9 07       	cpc	r29, r25
    1bd0:	b9 f1       	breq	.+110    	; 0x1c40 <vTaskResume+0x8c>
    1bd2:	0f b6       	in	r0, 0x3f	; 63
    1bd4:	f8 94       	cli
    1bd6:	0f 92       	push	r0
    1bd8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bda:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bdc:	8a 52       	subi	r24, 0x2A	; 42
    1bde:	98 40       	sbci	r25, 0x08	; 8
    1be0:	69 f5       	brne	.+90     	; 0x1c3c <vTaskResume+0x88>
    1be2:	8c 89       	ldd	r24, Y+20	; 0x14
    1be4:	9d 89       	ldd	r25, Y+21	; 0x15
    1be6:	28 e0       	ldi	r18, 0x08	; 8
    1be8:	8d 33       	cpi	r24, 0x3D	; 61
    1bea:	92 07       	cpc	r25, r18
    1bec:	39 f1       	breq	.+78     	; 0x1c3c <vTaskResume+0x88>
    1bee:	89 2b       	or	r24, r25
    1bf0:	29 f5       	brne	.+74     	; 0x1c3c <vTaskResume+0x88>
    1bf2:	8e 01       	movw	r16, r28
    1bf4:	0e 5f       	subi	r16, 0xFE	; 254
    1bf6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bf8:	c8 01       	movw	r24, r16
    1bfa:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1bfe:	8e 89       	ldd	r24, Y+22	; 0x16
    1c00:	90 91 26 08 	lds	r25, 0x0826
    1c04:	98 17       	cp	r25, r24
    1c06:	10 f4       	brcc	.+4      	; 0x1c0c <vTaskResume+0x58>
    1c08:	80 93 26 08 	sts	0x0826, r24
    1c0c:	90 e0       	ldi	r25, 0x00	; 0
    1c0e:	9c 01       	movw	r18, r24
    1c10:	22 0f       	add	r18, r18
    1c12:	33 1f       	adc	r19, r19
    1c14:	22 0f       	add	r18, r18
    1c16:	33 1f       	adc	r19, r19
    1c18:	22 0f       	add	r18, r18
    1c1a:	33 1f       	adc	r19, r19
    1c1c:	82 0f       	add	r24, r18
    1c1e:	93 1f       	adc	r25, r19
    1c20:	b8 01       	movw	r22, r16
    1c22:	84 5a       	subi	r24, 0xA4	; 164
    1c24:	97 4f       	sbci	r25, 0xF7	; 247
    1c26:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    1c2a:	e0 91 89 08 	lds	r30, 0x0889
    1c2e:	f0 91 8a 08 	lds	r31, 0x088A
    1c32:	9e 89       	ldd	r25, Y+22	; 0x16
    1c34:	86 89       	ldd	r24, Z+22	; 0x16
    1c36:	98 17       	cp	r25, r24
    1c38:	08 f0       	brcs	.+2      	; 0x1c3c <vTaskResume+0x88>
    1c3a:	77 da       	rcall	.-2834   	; 0x112a <vPortYield>
    1c3c:	0f 90       	pop	r0
    1c3e:	0f be       	out	0x3f, r0	; 63
    1c40:	df 91       	pop	r29
    1c42:	cf 91       	pop	r28
    1c44:	1f 91       	pop	r17
    1c46:	0f 91       	pop	r16
    1c48:	08 95       	ret

00001c4a <vTaskStartScheduler>:
    1c4a:	af 92       	push	r10
    1c4c:	bf 92       	push	r11
    1c4e:	cf 92       	push	r12
    1c50:	df 92       	push	r13
    1c52:	ef 92       	push	r14
    1c54:	ff 92       	push	r15
    1c56:	0f 93       	push	r16
    1c58:	a1 2c       	mov	r10, r1
    1c5a:	b1 2c       	mov	r11, r1
    1c5c:	c1 2c       	mov	r12, r1
    1c5e:	d1 2c       	mov	r13, r1
    1c60:	e1 2c       	mov	r14, r1
    1c62:	f1 2c       	mov	r15, r1
    1c64:	00 e0       	ldi	r16, 0x00	; 0
    1c66:	20 e0       	ldi	r18, 0x00	; 0
    1c68:	30 e0       	ldi	r19, 0x00	; 0
    1c6a:	45 e5       	ldi	r20, 0x55	; 85
    1c6c:	50 e0       	ldi	r21, 0x00	; 0
    1c6e:	69 e3       	ldi	r22, 0x39	; 57
    1c70:	72 e0       	ldi	r23, 0x02	; 2
    1c72:	8c ef       	ldi	r24, 0xFC	; 252
    1c74:	9f e0       	ldi	r25, 0x0F	; 15
    1c76:	89 de       	rcall	.-750    	; 0x198a <xTaskGenericCreate>
    1c78:	81 30       	cpi	r24, 0x01	; 1
    1c7a:	41 f4       	brne	.+16     	; 0x1c8c <vTaskStartScheduler+0x42>
    1c7c:	f8 94       	cli
    1c7e:	80 93 25 08 	sts	0x0825, r24
    1c82:	10 92 28 08 	sts	0x0828, r1
    1c86:	10 92 27 08 	sts	0x0827, r1
    1c8a:	12 da       	rcall	.-3036   	; 0x10b0 <xPortStartScheduler>
    1c8c:	0f 91       	pop	r16
    1c8e:	ff 90       	pop	r15
    1c90:	ef 90       	pop	r14
    1c92:	df 90       	pop	r13
    1c94:	cf 90       	pop	r12
    1c96:	bf 90       	pop	r11
    1c98:	af 90       	pop	r10
    1c9a:	08 95       	ret

00001c9c <vTaskSuspendAll>:
    1c9c:	80 91 20 08 	lds	r24, 0x0820
    1ca0:	8f 5f       	subi	r24, 0xFF	; 255
    1ca2:	80 93 20 08 	sts	0x0820, r24
    1ca6:	08 95       	ret

00001ca8 <xTaskGetTickCount>:
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	0f 92       	push	r0
    1cae:	80 91 27 08 	lds	r24, 0x0827
    1cb2:	90 91 28 08 	lds	r25, 0x0828
    1cb6:	0f 90       	pop	r0
    1cb8:	0f be       	out	0x3f, r0	; 63
    1cba:	08 95       	ret

00001cbc <xTaskGetTickCountFromISR>:
    1cbc:	80 91 27 08 	lds	r24, 0x0827
    1cc0:	90 91 28 08 	lds	r25, 0x0828
    1cc4:	08 95       	ret

00001cc6 <xTaskIncrementTick>:
    1cc6:	cf 92       	push	r12
    1cc8:	df 92       	push	r13
    1cca:	ef 92       	push	r14
    1ccc:	ff 92       	push	r15
    1cce:	0f 93       	push	r16
    1cd0:	1f 93       	push	r17
    1cd2:	cf 93       	push	r28
    1cd4:	df 93       	push	r29
    1cd6:	80 91 20 08 	lds	r24, 0x0820
    1cda:	81 11       	cpse	r24, r1
    1cdc:	99 c0       	rjmp	.+306    	; 0x1e10 <xTaskIncrementTick+0x14a>
    1cde:	80 91 27 08 	lds	r24, 0x0827
    1ce2:	90 91 28 08 	lds	r25, 0x0828
    1ce6:	01 96       	adiw	r24, 0x01	; 1
    1ce8:	90 93 28 08 	sts	0x0828, r25
    1cec:	80 93 27 08 	sts	0x0827, r24
    1cf0:	e0 90 27 08 	lds	r14, 0x0827
    1cf4:	f0 90 28 08 	lds	r15, 0x0828
    1cf8:	e1 14       	cp	r14, r1
    1cfa:	f1 04       	cpc	r15, r1
    1cfc:	b1 f4       	brne	.+44     	; 0x1d2a <xTaskIncrementTick+0x64>
    1cfe:	80 91 48 08 	lds	r24, 0x0848
    1d02:	90 91 49 08 	lds	r25, 0x0849
    1d06:	20 91 46 08 	lds	r18, 0x0846
    1d0a:	30 91 47 08 	lds	r19, 0x0847
    1d0e:	30 93 49 08 	sts	0x0849, r19
    1d12:	20 93 48 08 	sts	0x0848, r18
    1d16:	90 93 47 08 	sts	0x0847, r25
    1d1a:	80 93 46 08 	sts	0x0846, r24
    1d1e:	80 91 22 08 	lds	r24, 0x0822
    1d22:	8f 5f       	subi	r24, 0xFF	; 255
    1d24:	80 93 22 08 	sts	0x0822, r24
    1d28:	da dd       	rcall	.-1100   	; 0x18de <prvResetNextTaskUnblockTime>
    1d2a:	80 91 04 02 	lds	r24, 0x0204
    1d2e:	90 91 05 02 	lds	r25, 0x0205
    1d32:	e8 16       	cp	r14, r24
    1d34:	f9 06       	cpc	r15, r25
    1d36:	08 f4       	brcc	.+2      	; 0x1d3a <xTaskIncrementTick+0x74>
    1d38:	54 c0       	rjmp	.+168    	; 0x1de2 <xTaskIncrementTick+0x11c>
    1d3a:	d1 2c       	mov	r13, r1
    1d3c:	cc 24       	eor	r12, r12
    1d3e:	c3 94       	inc	r12
    1d40:	01 c0       	rjmp	.+2      	; 0x1d44 <xTaskIncrementTick+0x7e>
    1d42:	dc 2c       	mov	r13, r12
    1d44:	e0 91 48 08 	lds	r30, 0x0848
    1d48:	f0 91 49 08 	lds	r31, 0x0849
    1d4c:	80 81       	ld	r24, Z
    1d4e:	81 11       	cpse	r24, r1
    1d50:	07 c0       	rjmp	.+14     	; 0x1d60 <xTaskIncrementTick+0x9a>
    1d52:	8f ef       	ldi	r24, 0xFF	; 255
    1d54:	9f ef       	ldi	r25, 0xFF	; 255
    1d56:	90 93 05 02 	sts	0x0205, r25
    1d5a:	80 93 04 02 	sts	0x0204, r24
    1d5e:	42 c0       	rjmp	.+132    	; 0x1de4 <xTaskIncrementTick+0x11e>
    1d60:	e0 91 48 08 	lds	r30, 0x0848
    1d64:	f0 91 49 08 	lds	r31, 0x0849
    1d68:	05 80       	ldd	r0, Z+5	; 0x05
    1d6a:	f6 81       	ldd	r31, Z+6	; 0x06
    1d6c:	e0 2d       	mov	r30, r0
    1d6e:	c6 81       	ldd	r28, Z+6	; 0x06
    1d70:	d7 81       	ldd	r29, Z+7	; 0x07
    1d72:	2a 81       	ldd	r18, Y+2	; 0x02
    1d74:	3b 81       	ldd	r19, Y+3	; 0x03
    1d76:	e2 16       	cp	r14, r18
    1d78:	f3 06       	cpc	r15, r19
    1d7a:	28 f4       	brcc	.+10     	; 0x1d86 <xTaskIncrementTick+0xc0>
    1d7c:	30 93 05 02 	sts	0x0205, r19
    1d80:	20 93 04 02 	sts	0x0204, r18
    1d84:	2f c0       	rjmp	.+94     	; 0x1de4 <xTaskIncrementTick+0x11e>
    1d86:	8e 01       	movw	r16, r28
    1d88:	0e 5f       	subi	r16, 0xFE	; 254
    1d8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d8c:	c8 01       	movw	r24, r16
    1d8e:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1d92:	8c 89       	ldd	r24, Y+20	; 0x14
    1d94:	9d 89       	ldd	r25, Y+21	; 0x15
    1d96:	89 2b       	or	r24, r25
    1d98:	21 f0       	breq	.+8      	; 0x1da2 <xTaskIncrementTick+0xdc>
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	0c 96       	adiw	r24, 0x0c	; 12
    1d9e:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1da2:	2e 89       	ldd	r18, Y+22	; 0x16
    1da4:	80 91 26 08 	lds	r24, 0x0826
    1da8:	82 17       	cp	r24, r18
    1daa:	10 f4       	brcc	.+4      	; 0x1db0 <xTaskIncrementTick+0xea>
    1dac:	20 93 26 08 	sts	0x0826, r18
    1db0:	30 e0       	ldi	r19, 0x00	; 0
    1db2:	c9 01       	movw	r24, r18
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	88 0f       	add	r24, r24
    1dba:	99 1f       	adc	r25, r25
    1dbc:	88 0f       	add	r24, r24
    1dbe:	99 1f       	adc	r25, r25
    1dc0:	82 0f       	add	r24, r18
    1dc2:	93 1f       	adc	r25, r19
    1dc4:	b8 01       	movw	r22, r16
    1dc6:	84 5a       	subi	r24, 0xA4	; 164
    1dc8:	97 4f       	sbci	r25, 0xF7	; 247
    1dca:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    1dce:	e0 91 89 08 	lds	r30, 0x0889
    1dd2:	f0 91 8a 08 	lds	r31, 0x088A
    1dd6:	9e 89       	ldd	r25, Y+22	; 0x16
    1dd8:	86 89       	ldd	r24, Z+22	; 0x16
    1dda:	98 17       	cp	r25, r24
    1ddc:	08 f0       	brcs	.+2      	; 0x1de0 <xTaskIncrementTick+0x11a>
    1dde:	b1 cf       	rjmp	.-158    	; 0x1d42 <xTaskIncrementTick+0x7c>
    1de0:	b1 cf       	rjmp	.-158    	; 0x1d44 <xTaskIncrementTick+0x7e>
    1de2:	d1 2c       	mov	r13, r1
    1de4:	e0 91 89 08 	lds	r30, 0x0889
    1de8:	f0 91 8a 08 	lds	r31, 0x088A
    1dec:	86 89       	ldd	r24, Z+22	; 0x16
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	fc 01       	movw	r30, r24
    1df2:	ee 0f       	add	r30, r30
    1df4:	ff 1f       	adc	r31, r31
    1df6:	ee 0f       	add	r30, r30
    1df8:	ff 1f       	adc	r31, r31
    1dfa:	ee 0f       	add	r30, r30
    1dfc:	ff 1f       	adc	r31, r31
    1dfe:	8e 0f       	add	r24, r30
    1e00:	9f 1f       	adc	r25, r31
    1e02:	fc 01       	movw	r30, r24
    1e04:	e4 5a       	subi	r30, 0xA4	; 164
    1e06:	f7 4f       	sbci	r31, 0xF7	; 247
    1e08:	80 81       	ld	r24, Z
    1e0a:	82 30       	cpi	r24, 0x02	; 2
    1e0c:	40 f4       	brcc	.+16     	; 0x1e1e <xTaskIncrementTick+0x158>
    1e0e:	09 c0       	rjmp	.+18     	; 0x1e22 <xTaskIncrementTick+0x15c>
    1e10:	80 91 24 08 	lds	r24, 0x0824
    1e14:	8f 5f       	subi	r24, 0xFF	; 255
    1e16:	80 93 24 08 	sts	0x0824, r24
    1e1a:	d1 2c       	mov	r13, r1
    1e1c:	02 c0       	rjmp	.+4      	; 0x1e22 <xTaskIncrementTick+0x15c>
    1e1e:	dd 24       	eor	r13, r13
    1e20:	d3 94       	inc	r13
    1e22:	80 91 23 08 	lds	r24, 0x0823
    1e26:	88 23       	and	r24, r24
    1e28:	11 f0       	breq	.+4      	; 0x1e2e <xTaskIncrementTick+0x168>
    1e2a:	dd 24       	eor	r13, r13
    1e2c:	d3 94       	inc	r13
    1e2e:	8d 2d       	mov	r24, r13
    1e30:	df 91       	pop	r29
    1e32:	cf 91       	pop	r28
    1e34:	1f 91       	pop	r17
    1e36:	0f 91       	pop	r16
    1e38:	ff 90       	pop	r15
    1e3a:	ef 90       	pop	r14
    1e3c:	df 90       	pop	r13
    1e3e:	cf 90       	pop	r12
    1e40:	08 95       	ret

00001e42 <xTaskResumeAll>:
    1e42:	df 92       	push	r13
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	cf 93       	push	r28
    1e4e:	df 93       	push	r29
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
    1e56:	80 91 20 08 	lds	r24, 0x0820
    1e5a:	81 50       	subi	r24, 0x01	; 1
    1e5c:	80 93 20 08 	sts	0x0820, r24
    1e60:	80 91 20 08 	lds	r24, 0x0820
    1e64:	81 11       	cpse	r24, r1
    1e66:	5f c0       	rjmp	.+190    	; 0x1f26 <xTaskResumeAll+0xe4>
    1e68:	80 91 29 08 	lds	r24, 0x0829
    1e6c:	88 23       	and	r24, r24
    1e6e:	09 f4       	brne	.+2      	; 0x1e72 <xTaskResumeAll+0x30>
    1e70:	5c c0       	rjmp	.+184    	; 0x1f2a <xTaskResumeAll+0xe8>
    1e72:	0f 2e       	mov	r0, r31
    1e74:	fd e3       	ldi	r31, 0x3D	; 61
    1e76:	ef 2e       	mov	r14, r31
    1e78:	f8 e0       	ldi	r31, 0x08	; 8
    1e7a:	ff 2e       	mov	r15, r31
    1e7c:	f0 2d       	mov	r31, r0
    1e7e:	dd 24       	eor	r13, r13
    1e80:	d3 94       	inc	r13
    1e82:	30 c0       	rjmp	.+96     	; 0x1ee4 <xTaskResumeAll+0xa2>
    1e84:	e0 91 42 08 	lds	r30, 0x0842
    1e88:	f0 91 43 08 	lds	r31, 0x0843
    1e8c:	c6 81       	ldd	r28, Z+6	; 0x06
    1e8e:	d7 81       	ldd	r29, Z+7	; 0x07
    1e90:	ce 01       	movw	r24, r28
    1e92:	0c 96       	adiw	r24, 0x0c	; 12
    1e94:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1e98:	8e 01       	movw	r16, r28
    1e9a:	0e 5f       	subi	r16, 0xFE	; 254
    1e9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1ea4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ea6:	90 91 26 08 	lds	r25, 0x0826
    1eaa:	98 17       	cp	r25, r24
    1eac:	10 f4       	brcc	.+4      	; 0x1eb2 <xTaskResumeAll+0x70>
    1eae:	80 93 26 08 	sts	0x0826, r24
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	9c 01       	movw	r18, r24
    1eb6:	22 0f       	add	r18, r18
    1eb8:	33 1f       	adc	r19, r19
    1eba:	22 0f       	add	r18, r18
    1ebc:	33 1f       	adc	r19, r19
    1ebe:	22 0f       	add	r18, r18
    1ec0:	33 1f       	adc	r19, r19
    1ec2:	82 0f       	add	r24, r18
    1ec4:	93 1f       	adc	r25, r19
    1ec6:	b8 01       	movw	r22, r16
    1ec8:	84 5a       	subi	r24, 0xA4	; 164
    1eca:	97 4f       	sbci	r25, 0xF7	; 247
    1ecc:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    1ed0:	e0 91 89 08 	lds	r30, 0x0889
    1ed4:	f0 91 8a 08 	lds	r31, 0x088A
    1ed8:	9e 89       	ldd	r25, Y+22	; 0x16
    1eda:	86 89       	ldd	r24, Z+22	; 0x16
    1edc:	98 17       	cp	r25, r24
    1ede:	10 f0       	brcs	.+4      	; 0x1ee4 <xTaskResumeAll+0xa2>
    1ee0:	d0 92 23 08 	sts	0x0823, r13
    1ee4:	f7 01       	movw	r30, r14
    1ee6:	80 81       	ld	r24, Z
    1ee8:	81 11       	cpse	r24, r1
    1eea:	cc cf       	rjmp	.-104    	; 0x1e84 <xTaskResumeAll+0x42>
    1eec:	80 91 24 08 	lds	r24, 0x0824
    1ef0:	88 23       	and	r24, r24
    1ef2:	91 f0       	breq	.+36     	; 0x1f18 <xTaskResumeAll+0xd6>
    1ef4:	80 91 24 08 	lds	r24, 0x0824
    1ef8:	88 23       	and	r24, r24
    1efa:	71 f0       	breq	.+28     	; 0x1f18 <xTaskResumeAll+0xd6>
    1efc:	c1 e0       	ldi	r28, 0x01	; 1
    1efe:	e3 de       	rcall	.-570    	; 0x1cc6 <xTaskIncrementTick>
    1f00:	81 11       	cpse	r24, r1
    1f02:	c0 93 23 08 	sts	0x0823, r28
    1f06:	80 91 24 08 	lds	r24, 0x0824
    1f0a:	81 50       	subi	r24, 0x01	; 1
    1f0c:	80 93 24 08 	sts	0x0824, r24
    1f10:	80 91 24 08 	lds	r24, 0x0824
    1f14:	81 11       	cpse	r24, r1
    1f16:	f3 cf       	rjmp	.-26     	; 0x1efe <xTaskResumeAll+0xbc>
    1f18:	80 91 23 08 	lds	r24, 0x0823
    1f1c:	81 30       	cpi	r24, 0x01	; 1
    1f1e:	39 f4       	brne	.+14     	; 0x1f2e <xTaskResumeAll+0xec>
    1f20:	04 d9       	rcall	.-3576   	; 0x112a <vPortYield>
    1f22:	81 e0       	ldi	r24, 0x01	; 1
    1f24:	05 c0       	rjmp	.+10     	; 0x1f30 <xTaskResumeAll+0xee>
    1f26:	80 e0       	ldi	r24, 0x00	; 0
    1f28:	03 c0       	rjmp	.+6      	; 0x1f30 <xTaskResumeAll+0xee>
    1f2a:	80 e0       	ldi	r24, 0x00	; 0
    1f2c:	01 c0       	rjmp	.+2      	; 0x1f30 <xTaskResumeAll+0xee>
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63
    1f34:	df 91       	pop	r29
    1f36:	cf 91       	pop	r28
    1f38:	1f 91       	pop	r17
    1f3a:	0f 91       	pop	r16
    1f3c:	ff 90       	pop	r15
    1f3e:	ef 90       	pop	r14
    1f40:	df 90       	pop	r13
    1f42:	08 95       	ret

00001f44 <vTaskDelayUntil>:
    1f44:	0f 93       	push	r16
    1f46:	1f 93       	push	r17
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
    1f4c:	8c 01       	movw	r16, r24
    1f4e:	eb 01       	movw	r28, r22
    1f50:	a5 de       	rcall	.-694    	; 0x1c9c <vTaskSuspendAll>
    1f52:	80 91 27 08 	lds	r24, 0x0827
    1f56:	90 91 28 08 	lds	r25, 0x0828
    1f5a:	f8 01       	movw	r30, r16
    1f5c:	20 81       	ld	r18, Z
    1f5e:	31 81       	ldd	r19, Z+1	; 0x01
    1f60:	c2 0f       	add	r28, r18
    1f62:	d3 1f       	adc	r29, r19
    1f64:	82 17       	cp	r24, r18
    1f66:	93 07       	cpc	r25, r19
    1f68:	48 f4       	brcc	.+18     	; 0x1f7c <vTaskDelayUntil+0x38>
    1f6a:	c2 17       	cp	r28, r18
    1f6c:	d3 07       	cpc	r29, r19
    1f6e:	f8 f4       	brcc	.+62     	; 0x1fae <vTaskDelayUntil+0x6a>
    1f70:	d1 83       	std	Z+1, r29	; 0x01
    1f72:	c0 83       	st	Z, r28
    1f74:	8c 17       	cp	r24, r28
    1f76:	9d 07       	cpc	r25, r29
    1f78:	88 f4       	brcc	.+34     	; 0x1f9c <vTaskDelayUntil+0x58>
    1f7a:	07 c0       	rjmp	.+14     	; 0x1f8a <vTaskDelayUntil+0x46>
    1f7c:	c2 17       	cp	r28, r18
    1f7e:	d3 07       	cpc	r29, r19
    1f80:	90 f0       	brcs	.+36     	; 0x1fa6 <vTaskDelayUntil+0x62>
    1f82:	8c 17       	cp	r24, r28
    1f84:	9d 07       	cpc	r25, r29
    1f86:	78 f0       	brcs	.+30     	; 0x1fa6 <vTaskDelayUntil+0x62>
    1f88:	12 c0       	rjmp	.+36     	; 0x1fae <vTaskDelayUntil+0x6a>
    1f8a:	80 91 89 08 	lds	r24, 0x0889
    1f8e:	90 91 8a 08 	lds	r25, 0x088A
    1f92:	02 96       	adiw	r24, 0x02	; 2
    1f94:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1f98:	ce 01       	movw	r24, r28
    1f9a:	c0 dc       	rcall	.-1664   	; 0x191c <prvAddCurrentTaskToDelayedList>
    1f9c:	52 df       	rcall	.-348    	; 0x1e42 <xTaskResumeAll>
    1f9e:	81 11       	cpse	r24, r1
    1fa0:	0a c0       	rjmp	.+20     	; 0x1fb6 <vTaskDelayUntil+0x72>
    1fa2:	c3 d8       	rcall	.-3706   	; 0x112a <vPortYield>
    1fa4:	08 c0       	rjmp	.+16     	; 0x1fb6 <vTaskDelayUntil+0x72>
    1fa6:	f8 01       	movw	r30, r16
    1fa8:	d1 83       	std	Z+1, r29	; 0x01
    1faa:	c0 83       	st	Z, r28
    1fac:	ee cf       	rjmp	.-36     	; 0x1f8a <vTaskDelayUntil+0x46>
    1fae:	f8 01       	movw	r30, r16
    1fb0:	d1 83       	std	Z+1, r29	; 0x01
    1fb2:	c0 83       	st	Z, r28
    1fb4:	f3 cf       	rjmp	.-26     	; 0x1f9c <vTaskDelayUntil+0x58>
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	08 95       	ret

00001fc0 <vTaskDelay>:
    1fc0:	cf 93       	push	r28
    1fc2:	df 93       	push	r29
    1fc4:	ec 01       	movw	r28, r24
    1fc6:	00 97       	sbiw	r24, 0x00	; 0
    1fc8:	99 f0       	breq	.+38     	; 0x1ff0 <vTaskDelay+0x30>
    1fca:	68 de       	rcall	.-816    	; 0x1c9c <vTaskSuspendAll>
    1fcc:	80 91 27 08 	lds	r24, 0x0827
    1fd0:	90 91 28 08 	lds	r25, 0x0828
    1fd4:	c8 0f       	add	r28, r24
    1fd6:	d9 1f       	adc	r29, r25
    1fd8:	80 91 89 08 	lds	r24, 0x0889
    1fdc:	90 91 8a 08 	lds	r25, 0x088A
    1fe0:	02 96       	adiw	r24, 0x02	; 2
    1fe2:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    1fe6:	ce 01       	movw	r24, r28
    1fe8:	99 dc       	rcall	.-1742   	; 0x191c <prvAddCurrentTaskToDelayedList>
    1fea:	2b df       	rcall	.-426    	; 0x1e42 <xTaskResumeAll>
    1fec:	81 11       	cpse	r24, r1
    1fee:	01 c0       	rjmp	.+2      	; 0x1ff2 <vTaskDelay+0x32>
    1ff0:	9c d8       	rcall	.-3784   	; 0x112a <vPortYield>
    1ff2:	df 91       	pop	r29
    1ff4:	cf 91       	pop	r28
    1ff6:	08 95       	ret

00001ff8 <prvIdleTask>:
    1ff8:	0f 2e       	mov	r0, r31
    1ffa:	fc e5       	ldi	r31, 0x5C	; 92
    1ffc:	ef 2e       	mov	r14, r31
    1ffe:	f8 e0       	ldi	r31, 0x08	; 8
    2000:	ff 2e       	mov	r15, r31
    2002:	f0 2d       	mov	r31, r0
    2004:	c4 e3       	ldi	r28, 0x34	; 52
    2006:	d8 e0       	ldi	r29, 0x08	; 8
    2008:	26 c0       	rjmp	.+76     	; 0x2056 <prvIdleTask+0x5e>
    200a:	48 de       	rcall	.-880    	; 0x1c9c <vTaskSuspendAll>
    200c:	18 81       	ld	r17, Y
    200e:	19 df       	rcall	.-462    	; 0x1e42 <xTaskResumeAll>
    2010:	11 23       	and	r17, r17
    2012:	09 f1       	breq	.+66     	; 0x2056 <prvIdleTask+0x5e>
    2014:	0f b6       	in	r0, 0x3f	; 63
    2016:	f8 94       	cli
    2018:	0f 92       	push	r0
    201a:	e0 91 39 08 	lds	r30, 0x0839
    201e:	f0 91 3a 08 	lds	r31, 0x083A
    2022:	06 81       	ldd	r16, Z+6	; 0x06
    2024:	17 81       	ldd	r17, Z+7	; 0x07
    2026:	c8 01       	movw	r24, r16
    2028:	02 96       	adiw	r24, 0x02	; 2
    202a:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    202e:	80 91 29 08 	lds	r24, 0x0829
    2032:	81 50       	subi	r24, 0x01	; 1
    2034:	80 93 29 08 	sts	0x0829, r24
    2038:	80 91 33 08 	lds	r24, 0x0833
    203c:	81 50       	subi	r24, 0x01	; 1
    203e:	80 93 33 08 	sts	0x0833, r24
    2042:	0f 90       	pop	r0
    2044:	0f be       	out	0x3f, r0	; 63
    2046:	f8 01       	movw	r30, r16
    2048:	87 89       	ldd	r24, Z+23	; 0x17
    204a:	90 8d       	ldd	r25, Z+24	; 0x18
    204c:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vPortFree>
    2050:	c8 01       	movw	r24, r16
    2052:	0e 94 54 03 	call	0x6a8	; 0x6a8 <vPortFree>
    2056:	80 91 33 08 	lds	r24, 0x0833
    205a:	81 11       	cpse	r24, r1
    205c:	d6 cf       	rjmp	.-84     	; 0x200a <prvIdleTask+0x12>
    205e:	f7 01       	movw	r30, r14
    2060:	80 81       	ld	r24, Z
    2062:	82 30       	cpi	r24, 0x02	; 2
    2064:	c0 f3       	brcs	.-16     	; 0x2056 <prvIdleTask+0x5e>
    2066:	61 d8       	rcall	.-3902   	; 0x112a <vPortYield>
    2068:	f6 cf       	rjmp	.-20     	; 0x2056 <prvIdleTask+0x5e>

0000206a <vTaskSwitchContext>:
    206a:	80 91 20 08 	lds	r24, 0x0820
    206e:	88 23       	and	r24, r24
    2070:	21 f0       	breq	.+8      	; 0x207a <vTaskSwitchContext+0x10>
    2072:	81 e0       	ldi	r24, 0x01	; 1
    2074:	80 93 23 08 	sts	0x0823, r24
    2078:	08 95       	ret
    207a:	10 92 23 08 	sts	0x0823, r1
    207e:	80 91 26 08 	lds	r24, 0x0826
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	fc 01       	movw	r30, r24
    2086:	ee 0f       	add	r30, r30
    2088:	ff 1f       	adc	r31, r31
    208a:	ee 0f       	add	r30, r30
    208c:	ff 1f       	adc	r31, r31
    208e:	ee 0f       	add	r30, r30
    2090:	ff 1f       	adc	r31, r31
    2092:	8e 0f       	add	r24, r30
    2094:	9f 1f       	adc	r25, r31
    2096:	fc 01       	movw	r30, r24
    2098:	e4 5a       	subi	r30, 0xA4	; 164
    209a:	f7 4f       	sbci	r31, 0xF7	; 247
    209c:	80 81       	ld	r24, Z
    209e:	81 11       	cpse	r24, r1
    20a0:	17 c0       	rjmp	.+46     	; 0x20d0 <vTaskSwitchContext+0x66>
    20a2:	80 91 26 08 	lds	r24, 0x0826
    20a6:	81 50       	subi	r24, 0x01	; 1
    20a8:	80 93 26 08 	sts	0x0826, r24
    20ac:	80 91 26 08 	lds	r24, 0x0826
    20b0:	90 e0       	ldi	r25, 0x00	; 0
    20b2:	fc 01       	movw	r30, r24
    20b4:	ee 0f       	add	r30, r30
    20b6:	ff 1f       	adc	r31, r31
    20b8:	ee 0f       	add	r30, r30
    20ba:	ff 1f       	adc	r31, r31
    20bc:	ee 0f       	add	r30, r30
    20be:	ff 1f       	adc	r31, r31
    20c0:	8e 0f       	add	r24, r30
    20c2:	9f 1f       	adc	r25, r31
    20c4:	fc 01       	movw	r30, r24
    20c6:	e4 5a       	subi	r30, 0xA4	; 164
    20c8:	f7 4f       	sbci	r31, 0xF7	; 247
    20ca:	80 81       	ld	r24, Z
    20cc:	88 23       	and	r24, r24
    20ce:	49 f3       	breq	.-46     	; 0x20a2 <vTaskSwitchContext+0x38>
    20d0:	e0 91 26 08 	lds	r30, 0x0826
    20d4:	f0 e0       	ldi	r31, 0x00	; 0
    20d6:	cf 01       	movw	r24, r30
    20d8:	88 0f       	add	r24, r24
    20da:	99 1f       	adc	r25, r25
    20dc:	88 0f       	add	r24, r24
    20de:	99 1f       	adc	r25, r25
    20e0:	88 0f       	add	r24, r24
    20e2:	99 1f       	adc	r25, r25
    20e4:	e8 0f       	add	r30, r24
    20e6:	f9 1f       	adc	r31, r25
    20e8:	e4 5a       	subi	r30, 0xA4	; 164
    20ea:	f7 4f       	sbci	r31, 0xF7	; 247
    20ec:	a1 81       	ldd	r26, Z+1	; 0x01
    20ee:	b2 81       	ldd	r27, Z+2	; 0x02
    20f0:	12 96       	adiw	r26, 0x02	; 2
    20f2:	0d 90       	ld	r0, X+
    20f4:	bc 91       	ld	r27, X
    20f6:	a0 2d       	mov	r26, r0
    20f8:	b2 83       	std	Z+2, r27	; 0x02
    20fa:	a1 83       	std	Z+1, r26	; 0x01
    20fc:	cf 01       	movw	r24, r30
    20fe:	03 96       	adiw	r24, 0x03	; 3
    2100:	a8 17       	cp	r26, r24
    2102:	b9 07       	cpc	r27, r25
    2104:	31 f4       	brne	.+12     	; 0x2112 <vTaskSwitchContext+0xa8>
    2106:	12 96       	adiw	r26, 0x02	; 2
    2108:	8d 91       	ld	r24, X+
    210a:	9c 91       	ld	r25, X
    210c:	13 97       	sbiw	r26, 0x03	; 3
    210e:	92 83       	std	Z+2, r25	; 0x02
    2110:	81 83       	std	Z+1, r24	; 0x01
    2112:	01 80       	ldd	r0, Z+1	; 0x01
    2114:	f2 81       	ldd	r31, Z+2	; 0x02
    2116:	e0 2d       	mov	r30, r0
    2118:	86 81       	ldd	r24, Z+6	; 0x06
    211a:	97 81       	ldd	r25, Z+7	; 0x07
    211c:	90 93 8a 08 	sts	0x088A, r25
    2120:	80 93 89 08 	sts	0x0889, r24
    2124:	08 95       	ret

00002126 <vTaskSuspend>:
    2126:	0f 93       	push	r16
    2128:	1f 93       	push	r17
    212a:	cf 93       	push	r28
    212c:	df 93       	push	r29
    212e:	ec 01       	movw	r28, r24
    2130:	0f b6       	in	r0, 0x3f	; 63
    2132:	f8 94       	cli
    2134:	0f 92       	push	r0
    2136:	00 97       	sbiw	r24, 0x00	; 0
    2138:	21 f4       	brne	.+8      	; 0x2142 <vTaskSuspend+0x1c>
    213a:	c0 91 89 08 	lds	r28, 0x0889
    213e:	d0 91 8a 08 	lds	r29, 0x088A
    2142:	8e 01       	movw	r16, r28
    2144:	0e 5f       	subi	r16, 0xFE	; 254
    2146:	1f 4f       	sbci	r17, 0xFF	; 255
    2148:	c8 01       	movw	r24, r16
    214a:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    214e:	8c 89       	ldd	r24, Y+20	; 0x14
    2150:	9d 89       	ldd	r25, Y+21	; 0x15
    2152:	89 2b       	or	r24, r25
    2154:	21 f0       	breq	.+8      	; 0x215e <vTaskSuspend+0x38>
    2156:	ce 01       	movw	r24, r28
    2158:	0c 96       	adiw	r24, 0x0c	; 12
    215a:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    215e:	b8 01       	movw	r22, r16
    2160:	8a e2       	ldi	r24, 0x2A	; 42
    2162:	98 e0       	ldi	r25, 0x08	; 8
    2164:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	80 91 89 08 	lds	r24, 0x0889
    2170:	90 91 8a 08 	lds	r25, 0x088A
    2174:	c8 17       	cp	r28, r24
    2176:	d9 07       	cpc	r29, r25
    2178:	a1 f4       	brne	.+40     	; 0x21a2 <vTaskSuspend+0x7c>
    217a:	80 91 25 08 	lds	r24, 0x0825
    217e:	88 23       	and	r24, r24
    2180:	19 f0       	breq	.+6      	; 0x2188 <vTaskSuspend+0x62>
    2182:	0e 94 95 08 	call	0x112a	; 0x112a <vPortYield>
    2186:	17 c0       	rjmp	.+46     	; 0x21b6 <vTaskSuspend+0x90>
    2188:	80 91 29 08 	lds	r24, 0x0829
    218c:	90 91 2a 08 	lds	r25, 0x082A
    2190:	98 13       	cpse	r25, r24
    2192:	05 c0       	rjmp	.+10     	; 0x219e <vTaskSuspend+0x78>
    2194:	10 92 8a 08 	sts	0x088A, r1
    2198:	10 92 89 08 	sts	0x0889, r1
    219c:	0c c0       	rjmp	.+24     	; 0x21b6 <vTaskSuspend+0x90>
    219e:	65 df       	rcall	.-310    	; 0x206a <vTaskSwitchContext>
    21a0:	0a c0       	rjmp	.+20     	; 0x21b6 <vTaskSuspend+0x90>
    21a2:	80 91 25 08 	lds	r24, 0x0825
    21a6:	88 23       	and	r24, r24
    21a8:	31 f0       	breq	.+12     	; 0x21b6 <vTaskSuspend+0x90>
    21aa:	0f b6       	in	r0, 0x3f	; 63
    21ac:	f8 94       	cli
    21ae:	0f 92       	push	r0
    21b0:	96 db       	rcall	.-2260   	; 0x18de <prvResetNextTaskUnblockTime>
    21b2:	0f 90       	pop	r0
    21b4:	0f be       	out	0x3f, r0	; 63
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	1f 91       	pop	r17
    21bc:	0f 91       	pop	r16
    21be:	08 95       	ret

000021c0 <vTaskPlaceOnEventList>:
    21c0:	cf 93       	push	r28
    21c2:	df 93       	push	r29
    21c4:	eb 01       	movw	r28, r22
    21c6:	60 91 89 08 	lds	r22, 0x0889
    21ca:	70 91 8a 08 	lds	r23, 0x088A
    21ce:	64 5f       	subi	r22, 0xF4	; 244
    21d0:	7f 4f       	sbci	r23, 0xFF	; 255
    21d2:	0e 94 88 03 	call	0x710	; 0x710 <vListInsert>
    21d6:	80 91 89 08 	lds	r24, 0x0889
    21da:	90 91 8a 08 	lds	r25, 0x088A
    21de:	02 96       	adiw	r24, 0x02	; 2
    21e0:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    21e4:	cf 3f       	cpi	r28, 0xFF	; 255
    21e6:	8f ef       	ldi	r24, 0xFF	; 255
    21e8:	d8 07       	cpc	r29, r24
    21ea:	59 f4       	brne	.+22     	; 0x2202 <__stack+0x3>
    21ec:	60 91 89 08 	lds	r22, 0x0889
    21f0:	70 91 8a 08 	lds	r23, 0x088A
    21f4:	6e 5f       	subi	r22, 0xFE	; 254
    21f6:	7f 4f       	sbci	r23, 0xFF	; 255
    21f8:	8a e2       	ldi	r24, 0x2A	; 42
    21fa:	98 e0       	ldi	r25, 0x08	; 8
    21fc:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    2200:	07 c0       	rjmp	.+14     	; 0x2210 <__stack+0x11>
    2202:	80 91 27 08 	lds	r24, 0x0827
    2206:	90 91 28 08 	lds	r25, 0x0828
    220a:	8c 0f       	add	r24, r28
    220c:	9d 1f       	adc	r25, r29
    220e:	86 db       	rcall	.-2292   	; 0x191c <prvAddCurrentTaskToDelayedList>
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	08 95       	ret

00002216 <xTaskRemoveFromEventList>:
    2216:	0f 93       	push	r16
    2218:	1f 93       	push	r17
    221a:	cf 93       	push	r28
    221c:	df 93       	push	r29
    221e:	dc 01       	movw	r26, r24
    2220:	15 96       	adiw	r26, 0x05	; 5
    2222:	ed 91       	ld	r30, X+
    2224:	fc 91       	ld	r31, X
    2226:	16 97       	sbiw	r26, 0x06	; 6
    2228:	c6 81       	ldd	r28, Z+6	; 0x06
    222a:	d7 81       	ldd	r29, Z+7	; 0x07
    222c:	8e 01       	movw	r16, r28
    222e:	04 5f       	subi	r16, 0xF4	; 244
    2230:	1f 4f       	sbci	r17, 0xFF	; 255
    2232:	c8 01       	movw	r24, r16
    2234:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    2238:	80 91 20 08 	lds	r24, 0x0820
    223c:	81 11       	cpse	r24, r1
    223e:	1c c0       	rjmp	.+56     	; 0x2278 <xTaskRemoveFromEventList+0x62>
    2240:	0a 50       	subi	r16, 0x0A	; 10
    2242:	11 09       	sbc	r17, r1
    2244:	c8 01       	movw	r24, r16
    2246:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    224a:	8e 89       	ldd	r24, Y+22	; 0x16
    224c:	90 91 26 08 	lds	r25, 0x0826
    2250:	98 17       	cp	r25, r24
    2252:	10 f4       	brcc	.+4      	; 0x2258 <xTaskRemoveFromEventList+0x42>
    2254:	80 93 26 08 	sts	0x0826, r24
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	9c 01       	movw	r18, r24
    225c:	22 0f       	add	r18, r18
    225e:	33 1f       	adc	r19, r19
    2260:	22 0f       	add	r18, r18
    2262:	33 1f       	adc	r19, r19
    2264:	22 0f       	add	r18, r18
    2266:	33 1f       	adc	r19, r19
    2268:	82 0f       	add	r24, r18
    226a:	93 1f       	adc	r25, r19
    226c:	b8 01       	movw	r22, r16
    226e:	84 5a       	subi	r24, 0xA4	; 164
    2270:	97 4f       	sbci	r25, 0xF7	; 247
    2272:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    2276:	05 c0       	rjmp	.+10     	; 0x2282 <xTaskRemoveFromEventList+0x6c>
    2278:	b8 01       	movw	r22, r16
    227a:	8d e3       	ldi	r24, 0x3D	; 61
    227c:	98 e0       	ldi	r25, 0x08	; 8
    227e:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    2282:	e0 91 89 08 	lds	r30, 0x0889
    2286:	f0 91 8a 08 	lds	r31, 0x088A
    228a:	9e 89       	ldd	r25, Y+22	; 0x16
    228c:	86 89       	ldd	r24, Z+22	; 0x16
    228e:	89 17       	cp	r24, r25
    2290:	20 f4       	brcc	.+8      	; 0x229a <xTaskRemoveFromEventList+0x84>
    2292:	81 e0       	ldi	r24, 0x01	; 1
    2294:	80 93 23 08 	sts	0x0823, r24
    2298:	01 c0       	rjmp	.+2      	; 0x229c <xTaskRemoveFromEventList+0x86>
    229a:	80 e0       	ldi	r24, 0x00	; 0
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	08 95       	ret

000022a6 <vTaskSetTimeOutState>:
    22a6:	20 91 22 08 	lds	r18, 0x0822
    22aa:	fc 01       	movw	r30, r24
    22ac:	20 83       	st	Z, r18
    22ae:	20 91 27 08 	lds	r18, 0x0827
    22b2:	30 91 28 08 	lds	r19, 0x0828
    22b6:	32 83       	std	Z+2, r19	; 0x02
    22b8:	21 83       	std	Z+1, r18	; 0x01
    22ba:	08 95       	ret

000022bc <xTaskCheckForTimeOut>:
    22bc:	0f b6       	in	r0, 0x3f	; 63
    22be:	f8 94       	cli
    22c0:	0f 92       	push	r0
    22c2:	40 91 27 08 	lds	r20, 0x0827
    22c6:	50 91 28 08 	lds	r21, 0x0828
    22ca:	db 01       	movw	r26, r22
    22cc:	2d 91       	ld	r18, X+
    22ce:	3c 91       	ld	r19, X
    22d0:	2f 3f       	cpi	r18, 0xFF	; 255
    22d2:	bf ef       	ldi	r27, 0xFF	; 255
    22d4:	3b 07       	cpc	r19, r27
    22d6:	11 f1       	breq	.+68     	; 0x231c <xTaskCheckForTimeOut+0x60>
    22d8:	e0 91 22 08 	lds	r30, 0x0822
    22dc:	dc 01       	movw	r26, r24
    22de:	fc 91       	ld	r31, X
    22e0:	fe 17       	cp	r31, r30
    22e2:	39 f0       	breq	.+14     	; 0x22f2 <xTaskCheckForTimeOut+0x36>
    22e4:	11 96       	adiw	r26, 0x01	; 1
    22e6:	ed 91       	ld	r30, X+
    22e8:	fc 91       	ld	r31, X
    22ea:	12 97       	sbiw	r26, 0x02	; 2
    22ec:	4e 17       	cp	r20, r30
    22ee:	5f 07       	cpc	r21, r31
    22f0:	b8 f4       	brcc	.+46     	; 0x2320 <xTaskCheckForTimeOut+0x64>
    22f2:	dc 01       	movw	r26, r24
    22f4:	11 96       	adiw	r26, 0x01	; 1
    22f6:	ed 91       	ld	r30, X+
    22f8:	fc 91       	ld	r31, X
    22fa:	12 97       	sbiw	r26, 0x02	; 2
    22fc:	da 01       	movw	r26, r20
    22fe:	ae 1b       	sub	r26, r30
    2300:	bf 0b       	sbc	r27, r31
    2302:	a2 17       	cp	r26, r18
    2304:	b3 07       	cpc	r27, r19
    2306:	70 f4       	brcc	.+28     	; 0x2324 <xTaskCheckForTimeOut+0x68>
    2308:	e4 1b       	sub	r30, r20
    230a:	f5 0b       	sbc	r31, r21
    230c:	2e 0f       	add	r18, r30
    230e:	3f 1f       	adc	r19, r31
    2310:	fb 01       	movw	r30, r22
    2312:	31 83       	std	Z+1, r19	; 0x01
    2314:	20 83       	st	Z, r18
    2316:	c7 df       	rcall	.-114    	; 0x22a6 <vTaskSetTimeOutState>
    2318:	80 e0       	ldi	r24, 0x00	; 0
    231a:	05 c0       	rjmp	.+10     	; 0x2326 <xTaskCheckForTimeOut+0x6a>
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	03 c0       	rjmp	.+6      	; 0x2326 <xTaskCheckForTimeOut+0x6a>
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	01 c0       	rjmp	.+2      	; 0x2326 <xTaskCheckForTimeOut+0x6a>
    2324:	81 e0       	ldi	r24, 0x01	; 1
    2326:	0f 90       	pop	r0
    2328:	0f be       	out	0x3f, r0	; 63
    232a:	08 95       	ret

0000232c <vTaskMissedYield>:
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	80 93 23 08 	sts	0x0823, r24
    2332:	08 95       	ret

00002334 <vTaskPriorityInherit>:
    2334:	0f 93       	push	r16
    2336:	1f 93       	push	r17
    2338:	cf 93       	push	r28
    233a:	df 93       	push	r29
    233c:	ec 01       	movw	r28, r24
    233e:	00 97       	sbiw	r24, 0x00	; 0
    2340:	09 f4       	brne	.+2      	; 0x2344 <vTaskPriorityInherit+0x10>
    2342:	51 c0       	rjmp	.+162    	; 0x23e6 <vTaskPriorityInherit+0xb2>
    2344:	8e 89       	ldd	r24, Y+22	; 0x16
    2346:	e0 91 89 08 	lds	r30, 0x0889
    234a:	f0 91 8a 08 	lds	r31, 0x088A
    234e:	96 89       	ldd	r25, Z+22	; 0x16
    2350:	89 17       	cp	r24, r25
    2352:	08 f0       	brcs	.+2      	; 0x2356 <vTaskPriorityInherit+0x22>
    2354:	48 c0       	rjmp	.+144    	; 0x23e6 <vTaskPriorityInherit+0xb2>
    2356:	2c 85       	ldd	r18, Y+12	; 0x0c
    2358:	3d 85       	ldd	r19, Y+13	; 0x0d
    235a:	33 23       	and	r19, r19
    235c:	5c f0       	brlt	.+22     	; 0x2374 <vTaskPriorityInherit+0x40>
    235e:	e0 91 89 08 	lds	r30, 0x0889
    2362:	f0 91 8a 08 	lds	r31, 0x088A
    2366:	96 89       	ldd	r25, Z+22	; 0x16
    2368:	25 e0       	ldi	r18, 0x05	; 5
    236a:	30 e0       	ldi	r19, 0x00	; 0
    236c:	29 1b       	sub	r18, r25
    236e:	31 09       	sbc	r19, r1
    2370:	3d 87       	std	Y+13, r19	; 0x0d
    2372:	2c 87       	std	Y+12, r18	; 0x0c
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	9c 01       	movw	r18, r24
    2378:	22 0f       	add	r18, r18
    237a:	33 1f       	adc	r19, r19
    237c:	22 0f       	add	r18, r18
    237e:	33 1f       	adc	r19, r19
    2380:	22 0f       	add	r18, r18
    2382:	33 1f       	adc	r19, r19
    2384:	82 0f       	add	r24, r18
    2386:	93 1f       	adc	r25, r19
    2388:	84 5a       	subi	r24, 0xA4	; 164
    238a:	97 4f       	sbci	r25, 0xF7	; 247
    238c:	2a 85       	ldd	r18, Y+10	; 0x0a
    238e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2390:	28 17       	cp	r18, r24
    2392:	39 07       	cpc	r19, r25
    2394:	11 f5       	brne	.+68     	; 0x23da <vTaskPriorityInherit+0xa6>
    2396:	8e 01       	movw	r16, r28
    2398:	0e 5f       	subi	r16, 0xFE	; 254
    239a:	1f 4f       	sbci	r17, 0xFF	; 255
    239c:	c8 01       	movw	r24, r16
    239e:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    23a2:	e0 91 89 08 	lds	r30, 0x0889
    23a6:	f0 91 8a 08 	lds	r31, 0x088A
    23aa:	86 89       	ldd	r24, Z+22	; 0x16
    23ac:	8e 8b       	std	Y+22, r24	; 0x16
    23ae:	90 91 26 08 	lds	r25, 0x0826
    23b2:	98 17       	cp	r25, r24
    23b4:	10 f4       	brcc	.+4      	; 0x23ba <vTaskPriorityInherit+0x86>
    23b6:	80 93 26 08 	sts	0x0826, r24
    23ba:	90 e0       	ldi	r25, 0x00	; 0
    23bc:	9c 01       	movw	r18, r24
    23be:	22 0f       	add	r18, r18
    23c0:	33 1f       	adc	r19, r19
    23c2:	22 0f       	add	r18, r18
    23c4:	33 1f       	adc	r19, r19
    23c6:	22 0f       	add	r18, r18
    23c8:	33 1f       	adc	r19, r19
    23ca:	82 0f       	add	r24, r18
    23cc:	93 1f       	adc	r25, r19
    23ce:	b8 01       	movw	r22, r16
    23d0:	84 5a       	subi	r24, 0xA4	; 164
    23d2:	97 4f       	sbci	r25, 0xF7	; 247
    23d4:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    23d8:	06 c0       	rjmp	.+12     	; 0x23e6 <vTaskPriorityInherit+0xb2>
    23da:	e0 91 89 08 	lds	r30, 0x0889
    23de:	f0 91 8a 08 	lds	r31, 0x088A
    23e2:	86 89       	ldd	r24, Z+22	; 0x16
    23e4:	8e 8b       	std	Y+22, r24	; 0x16
    23e6:	df 91       	pop	r29
    23e8:	cf 91       	pop	r28
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	08 95       	ret

000023f0 <xTaskPriorityDisinherit>:
    23f0:	0f 93       	push	r16
    23f2:	1f 93       	push	r17
    23f4:	cf 93       	push	r28
    23f6:	df 93       	push	r29
    23f8:	ec 01       	movw	r28, r24
    23fa:	00 97       	sbiw	r24, 0x00	; 0
    23fc:	71 f1       	breq	.+92     	; 0x245a <xTaskPriorityDisinherit+0x6a>
    23fe:	8a a1       	ldd	r24, Y+34	; 0x22
    2400:	81 50       	subi	r24, 0x01	; 1
    2402:	8a a3       	std	Y+34, r24	; 0x22
    2404:	2e 89       	ldd	r18, Y+22	; 0x16
    2406:	99 a1       	ldd	r25, Y+33	; 0x21
    2408:	29 17       	cp	r18, r25
    240a:	49 f1       	breq	.+82     	; 0x245e <xTaskPriorityDisinherit+0x6e>
    240c:	81 11       	cpse	r24, r1
    240e:	29 c0       	rjmp	.+82     	; 0x2462 <xTaskPriorityDisinherit+0x72>
    2410:	8e 01       	movw	r16, r28
    2412:	0e 5f       	subi	r16, 0xFE	; 254
    2414:	1f 4f       	sbci	r17, 0xFF	; 255
    2416:	c8 01       	movw	r24, r16
    2418:	0e 94 b9 03 	call	0x772	; 0x772 <uxListRemove>
    241c:	89 a1       	ldd	r24, Y+33	; 0x21
    241e:	8e 8b       	std	Y+22, r24	; 0x16
    2420:	25 e0       	ldi	r18, 0x05	; 5
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	28 1b       	sub	r18, r24
    2426:	31 09       	sbc	r19, r1
    2428:	3d 87       	std	Y+13, r19	; 0x0d
    242a:	2c 87       	std	Y+12, r18	; 0x0c
    242c:	90 91 26 08 	lds	r25, 0x0826
    2430:	98 17       	cp	r25, r24
    2432:	10 f4       	brcc	.+4      	; 0x2438 <xTaskPriorityDisinherit+0x48>
    2434:	80 93 26 08 	sts	0x0826, r24
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	9c 01       	movw	r18, r24
    243c:	22 0f       	add	r18, r18
    243e:	33 1f       	adc	r19, r19
    2440:	22 0f       	add	r18, r18
    2442:	33 1f       	adc	r19, r19
    2444:	22 0f       	add	r18, r18
    2446:	33 1f       	adc	r19, r19
    2448:	82 0f       	add	r24, r18
    244a:	93 1f       	adc	r25, r19
    244c:	b8 01       	movw	r22, r16
    244e:	84 5a       	subi	r24, 0xA4	; 164
    2450:	97 4f       	sbci	r25, 0xF7	; 247
    2452:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInsertEnd>
    2456:	81 e0       	ldi	r24, 0x01	; 1
    2458:	05 c0       	rjmp	.+10     	; 0x2464 <xTaskPriorityDisinherit+0x74>
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	03 c0       	rjmp	.+6      	; 0x2464 <xTaskPriorityDisinherit+0x74>
    245e:	80 e0       	ldi	r24, 0x00	; 0
    2460:	01 c0       	rjmp	.+2      	; 0x2464 <xTaskPriorityDisinherit+0x74>
    2462:	80 e0       	ldi	r24, 0x00	; 0
    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	1f 91       	pop	r17
    246a:	0f 91       	pop	r16
    246c:	08 95       	ret

0000246e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    246e:	80 91 89 08 	lds	r24, 0x0889
    2472:	90 91 8a 08 	lds	r25, 0x088A
    2476:	89 2b       	or	r24, r25
    2478:	39 f0       	breq	.+14     	; 0x2488 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    247a:	e0 91 89 08 	lds	r30, 0x0889
    247e:	f0 91 8a 08 	lds	r31, 0x088A
    2482:	82 a1       	ldd	r24, Z+34	; 0x22
    2484:	8f 5f       	subi	r24, 0xFF	; 255
    2486:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2488:	80 91 89 08 	lds	r24, 0x0889
    248c:	90 91 8a 08 	lds	r25, 0x088A
	}
    2490:	08 95       	ret

00002492 <__subsf3>:
    2492:	50 58       	subi	r21, 0x80	; 128

00002494 <__addsf3>:
    2494:	bb 27       	eor	r27, r27
    2496:	aa 27       	eor	r26, r26
    2498:	0e d0       	rcall	.+28     	; 0x24b6 <__addsf3x>
    249a:	e5 c0       	rjmp	.+458    	; 0x2666 <__fp_round>
    249c:	d6 d0       	rcall	.+428    	; 0x264a <__fp_pscA>
    249e:	30 f0       	brcs	.+12     	; 0x24ac <__addsf3+0x18>
    24a0:	db d0       	rcall	.+438    	; 0x2658 <__fp_pscB>
    24a2:	20 f0       	brcs	.+8      	; 0x24ac <__addsf3+0x18>
    24a4:	31 f4       	brne	.+12     	; 0x24b2 <__addsf3+0x1e>
    24a6:	9f 3f       	cpi	r25, 0xFF	; 255
    24a8:	11 f4       	brne	.+4      	; 0x24ae <__addsf3+0x1a>
    24aa:	1e f4       	brtc	.+6      	; 0x24b2 <__addsf3+0x1e>
    24ac:	cb c0       	rjmp	.+406    	; 0x2644 <__fp_nan>
    24ae:	0e f4       	brtc	.+2      	; 0x24b2 <__addsf3+0x1e>
    24b0:	e0 95       	com	r30
    24b2:	e7 fb       	bst	r30, 7
    24b4:	c1 c0       	rjmp	.+386    	; 0x2638 <__fp_inf>

000024b6 <__addsf3x>:
    24b6:	e9 2f       	mov	r30, r25
    24b8:	e7 d0       	rcall	.+462    	; 0x2688 <__fp_split3>
    24ba:	80 f3       	brcs	.-32     	; 0x249c <__addsf3+0x8>
    24bc:	ba 17       	cp	r27, r26
    24be:	62 07       	cpc	r22, r18
    24c0:	73 07       	cpc	r23, r19
    24c2:	84 07       	cpc	r24, r20
    24c4:	95 07       	cpc	r25, r21
    24c6:	18 f0       	brcs	.+6      	; 0x24ce <__addsf3x+0x18>
    24c8:	71 f4       	brne	.+28     	; 0x24e6 <__addsf3x+0x30>
    24ca:	9e f5       	brtc	.+102    	; 0x2532 <__addsf3x+0x7c>
    24cc:	ff c0       	rjmp	.+510    	; 0x26cc <__fp_zero>
    24ce:	0e f4       	brtc	.+2      	; 0x24d2 <__addsf3x+0x1c>
    24d0:	e0 95       	com	r30
    24d2:	0b 2e       	mov	r0, r27
    24d4:	ba 2f       	mov	r27, r26
    24d6:	a0 2d       	mov	r26, r0
    24d8:	0b 01       	movw	r0, r22
    24da:	b9 01       	movw	r22, r18
    24dc:	90 01       	movw	r18, r0
    24de:	0c 01       	movw	r0, r24
    24e0:	ca 01       	movw	r24, r20
    24e2:	a0 01       	movw	r20, r0
    24e4:	11 24       	eor	r1, r1
    24e6:	ff 27       	eor	r31, r31
    24e8:	59 1b       	sub	r21, r25
    24ea:	99 f0       	breq	.+38     	; 0x2512 <__addsf3x+0x5c>
    24ec:	59 3f       	cpi	r21, 0xF9	; 249
    24ee:	50 f4       	brcc	.+20     	; 0x2504 <__addsf3x+0x4e>
    24f0:	50 3e       	cpi	r21, 0xE0	; 224
    24f2:	68 f1       	brcs	.+90     	; 0x254e <__addsf3x+0x98>
    24f4:	1a 16       	cp	r1, r26
    24f6:	f0 40       	sbci	r31, 0x00	; 0
    24f8:	a2 2f       	mov	r26, r18
    24fa:	23 2f       	mov	r18, r19
    24fc:	34 2f       	mov	r19, r20
    24fe:	44 27       	eor	r20, r20
    2500:	58 5f       	subi	r21, 0xF8	; 248
    2502:	f3 cf       	rjmp	.-26     	; 0x24ea <__addsf3x+0x34>
    2504:	46 95       	lsr	r20
    2506:	37 95       	ror	r19
    2508:	27 95       	ror	r18
    250a:	a7 95       	ror	r26
    250c:	f0 40       	sbci	r31, 0x00	; 0
    250e:	53 95       	inc	r21
    2510:	c9 f7       	brne	.-14     	; 0x2504 <__addsf3x+0x4e>
    2512:	7e f4       	brtc	.+30     	; 0x2532 <__addsf3x+0x7c>
    2514:	1f 16       	cp	r1, r31
    2516:	ba 0b       	sbc	r27, r26
    2518:	62 0b       	sbc	r22, r18
    251a:	73 0b       	sbc	r23, r19
    251c:	84 0b       	sbc	r24, r20
    251e:	ba f0       	brmi	.+46     	; 0x254e <__addsf3x+0x98>
    2520:	91 50       	subi	r25, 0x01	; 1
    2522:	a1 f0       	breq	.+40     	; 0x254c <__addsf3x+0x96>
    2524:	ff 0f       	add	r31, r31
    2526:	bb 1f       	adc	r27, r27
    2528:	66 1f       	adc	r22, r22
    252a:	77 1f       	adc	r23, r23
    252c:	88 1f       	adc	r24, r24
    252e:	c2 f7       	brpl	.-16     	; 0x2520 <__addsf3x+0x6a>
    2530:	0e c0       	rjmp	.+28     	; 0x254e <__addsf3x+0x98>
    2532:	ba 0f       	add	r27, r26
    2534:	62 1f       	adc	r22, r18
    2536:	73 1f       	adc	r23, r19
    2538:	84 1f       	adc	r24, r20
    253a:	48 f4       	brcc	.+18     	; 0x254e <__addsf3x+0x98>
    253c:	87 95       	ror	r24
    253e:	77 95       	ror	r23
    2540:	67 95       	ror	r22
    2542:	b7 95       	ror	r27
    2544:	f7 95       	ror	r31
    2546:	9e 3f       	cpi	r25, 0xFE	; 254
    2548:	08 f0       	brcs	.+2      	; 0x254c <__addsf3x+0x96>
    254a:	b3 cf       	rjmp	.-154    	; 0x24b2 <__addsf3+0x1e>
    254c:	93 95       	inc	r25
    254e:	88 0f       	add	r24, r24
    2550:	08 f0       	brcs	.+2      	; 0x2554 <__addsf3x+0x9e>
    2552:	99 27       	eor	r25, r25
    2554:	ee 0f       	add	r30, r30
    2556:	97 95       	ror	r25
    2558:	87 95       	ror	r24
    255a:	08 95       	ret

0000255c <__fixsfsi>:
    255c:	04 d0       	rcall	.+8      	; 0x2566 <__fixunssfsi>
    255e:	68 94       	set
    2560:	b1 11       	cpse	r27, r1
    2562:	b5 c0       	rjmp	.+362    	; 0x26ce <__fp_szero>
    2564:	08 95       	ret

00002566 <__fixunssfsi>:
    2566:	98 d0       	rcall	.+304    	; 0x2698 <__fp_splitA>
    2568:	88 f0       	brcs	.+34     	; 0x258c <__fixunssfsi+0x26>
    256a:	9f 57       	subi	r25, 0x7F	; 127
    256c:	90 f0       	brcs	.+36     	; 0x2592 <__fixunssfsi+0x2c>
    256e:	b9 2f       	mov	r27, r25
    2570:	99 27       	eor	r25, r25
    2572:	b7 51       	subi	r27, 0x17	; 23
    2574:	a0 f0       	brcs	.+40     	; 0x259e <__fixunssfsi+0x38>
    2576:	d1 f0       	breq	.+52     	; 0x25ac <__fixunssfsi+0x46>
    2578:	66 0f       	add	r22, r22
    257a:	77 1f       	adc	r23, r23
    257c:	88 1f       	adc	r24, r24
    257e:	99 1f       	adc	r25, r25
    2580:	1a f0       	brmi	.+6      	; 0x2588 <__fixunssfsi+0x22>
    2582:	ba 95       	dec	r27
    2584:	c9 f7       	brne	.-14     	; 0x2578 <__fixunssfsi+0x12>
    2586:	12 c0       	rjmp	.+36     	; 0x25ac <__fixunssfsi+0x46>
    2588:	b1 30       	cpi	r27, 0x01	; 1
    258a:	81 f0       	breq	.+32     	; 0x25ac <__fixunssfsi+0x46>
    258c:	9f d0       	rcall	.+318    	; 0x26cc <__fp_zero>
    258e:	b1 e0       	ldi	r27, 0x01	; 1
    2590:	08 95       	ret
    2592:	9c c0       	rjmp	.+312    	; 0x26cc <__fp_zero>
    2594:	67 2f       	mov	r22, r23
    2596:	78 2f       	mov	r23, r24
    2598:	88 27       	eor	r24, r24
    259a:	b8 5f       	subi	r27, 0xF8	; 248
    259c:	39 f0       	breq	.+14     	; 0x25ac <__fixunssfsi+0x46>
    259e:	b9 3f       	cpi	r27, 0xF9	; 249
    25a0:	cc f3       	brlt	.-14     	; 0x2594 <__fixunssfsi+0x2e>
    25a2:	86 95       	lsr	r24
    25a4:	77 95       	ror	r23
    25a6:	67 95       	ror	r22
    25a8:	b3 95       	inc	r27
    25aa:	d9 f7       	brne	.-10     	; 0x25a2 <__fixunssfsi+0x3c>
    25ac:	3e f4       	brtc	.+14     	; 0x25bc <__fixunssfsi+0x56>
    25ae:	90 95       	com	r25
    25b0:	80 95       	com	r24
    25b2:	70 95       	com	r23
    25b4:	61 95       	neg	r22
    25b6:	7f 4f       	sbci	r23, 0xFF	; 255
    25b8:	8f 4f       	sbci	r24, 0xFF	; 255
    25ba:	9f 4f       	sbci	r25, 0xFF	; 255
    25bc:	08 95       	ret

000025be <__floatunsisf>:
    25be:	e8 94       	clt
    25c0:	09 c0       	rjmp	.+18     	; 0x25d4 <__floatsisf+0x12>

000025c2 <__floatsisf>:
    25c2:	97 fb       	bst	r25, 7
    25c4:	3e f4       	brtc	.+14     	; 0x25d4 <__floatsisf+0x12>
    25c6:	90 95       	com	r25
    25c8:	80 95       	com	r24
    25ca:	70 95       	com	r23
    25cc:	61 95       	neg	r22
    25ce:	7f 4f       	sbci	r23, 0xFF	; 255
    25d0:	8f 4f       	sbci	r24, 0xFF	; 255
    25d2:	9f 4f       	sbci	r25, 0xFF	; 255
    25d4:	99 23       	and	r25, r25
    25d6:	a9 f0       	breq	.+42     	; 0x2602 <__floatsisf+0x40>
    25d8:	f9 2f       	mov	r31, r25
    25da:	96 e9       	ldi	r25, 0x96	; 150
    25dc:	bb 27       	eor	r27, r27
    25de:	93 95       	inc	r25
    25e0:	f6 95       	lsr	r31
    25e2:	87 95       	ror	r24
    25e4:	77 95       	ror	r23
    25e6:	67 95       	ror	r22
    25e8:	b7 95       	ror	r27
    25ea:	f1 11       	cpse	r31, r1
    25ec:	f8 cf       	rjmp	.-16     	; 0x25de <__floatsisf+0x1c>
    25ee:	fa f4       	brpl	.+62     	; 0x262e <__floatsisf+0x6c>
    25f0:	bb 0f       	add	r27, r27
    25f2:	11 f4       	brne	.+4      	; 0x25f8 <__floatsisf+0x36>
    25f4:	60 ff       	sbrs	r22, 0
    25f6:	1b c0       	rjmp	.+54     	; 0x262e <__floatsisf+0x6c>
    25f8:	6f 5f       	subi	r22, 0xFF	; 255
    25fa:	7f 4f       	sbci	r23, 0xFF	; 255
    25fc:	8f 4f       	sbci	r24, 0xFF	; 255
    25fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2600:	16 c0       	rjmp	.+44     	; 0x262e <__floatsisf+0x6c>
    2602:	88 23       	and	r24, r24
    2604:	11 f0       	breq	.+4      	; 0x260a <__floatsisf+0x48>
    2606:	96 e9       	ldi	r25, 0x96	; 150
    2608:	11 c0       	rjmp	.+34     	; 0x262c <__floatsisf+0x6a>
    260a:	77 23       	and	r23, r23
    260c:	21 f0       	breq	.+8      	; 0x2616 <__floatsisf+0x54>
    260e:	9e e8       	ldi	r25, 0x8E	; 142
    2610:	87 2f       	mov	r24, r23
    2612:	76 2f       	mov	r23, r22
    2614:	05 c0       	rjmp	.+10     	; 0x2620 <__floatsisf+0x5e>
    2616:	66 23       	and	r22, r22
    2618:	71 f0       	breq	.+28     	; 0x2636 <__floatsisf+0x74>
    261a:	96 e8       	ldi	r25, 0x86	; 134
    261c:	86 2f       	mov	r24, r22
    261e:	70 e0       	ldi	r23, 0x00	; 0
    2620:	60 e0       	ldi	r22, 0x00	; 0
    2622:	2a f0       	brmi	.+10     	; 0x262e <__floatsisf+0x6c>
    2624:	9a 95       	dec	r25
    2626:	66 0f       	add	r22, r22
    2628:	77 1f       	adc	r23, r23
    262a:	88 1f       	adc	r24, r24
    262c:	da f7       	brpl	.-10     	; 0x2624 <__floatsisf+0x62>
    262e:	88 0f       	add	r24, r24
    2630:	96 95       	lsr	r25
    2632:	87 95       	ror	r24
    2634:	97 f9       	bld	r25, 7
    2636:	08 95       	ret

00002638 <__fp_inf>:
    2638:	97 f9       	bld	r25, 7
    263a:	9f 67       	ori	r25, 0x7F	; 127
    263c:	80 e8       	ldi	r24, 0x80	; 128
    263e:	70 e0       	ldi	r23, 0x00	; 0
    2640:	60 e0       	ldi	r22, 0x00	; 0
    2642:	08 95       	ret

00002644 <__fp_nan>:
    2644:	9f ef       	ldi	r25, 0xFF	; 255
    2646:	80 ec       	ldi	r24, 0xC0	; 192
    2648:	08 95       	ret

0000264a <__fp_pscA>:
    264a:	00 24       	eor	r0, r0
    264c:	0a 94       	dec	r0
    264e:	16 16       	cp	r1, r22
    2650:	17 06       	cpc	r1, r23
    2652:	18 06       	cpc	r1, r24
    2654:	09 06       	cpc	r0, r25
    2656:	08 95       	ret

00002658 <__fp_pscB>:
    2658:	00 24       	eor	r0, r0
    265a:	0a 94       	dec	r0
    265c:	12 16       	cp	r1, r18
    265e:	13 06       	cpc	r1, r19
    2660:	14 06       	cpc	r1, r20
    2662:	05 06       	cpc	r0, r21
    2664:	08 95       	ret

00002666 <__fp_round>:
    2666:	09 2e       	mov	r0, r25
    2668:	03 94       	inc	r0
    266a:	00 0c       	add	r0, r0
    266c:	11 f4       	brne	.+4      	; 0x2672 <__fp_round+0xc>
    266e:	88 23       	and	r24, r24
    2670:	52 f0       	brmi	.+20     	; 0x2686 <__fp_round+0x20>
    2672:	bb 0f       	add	r27, r27
    2674:	40 f4       	brcc	.+16     	; 0x2686 <__fp_round+0x20>
    2676:	bf 2b       	or	r27, r31
    2678:	11 f4       	brne	.+4      	; 0x267e <__fp_round+0x18>
    267a:	60 ff       	sbrs	r22, 0
    267c:	04 c0       	rjmp	.+8      	; 0x2686 <__fp_round+0x20>
    267e:	6f 5f       	subi	r22, 0xFF	; 255
    2680:	7f 4f       	sbci	r23, 0xFF	; 255
    2682:	8f 4f       	sbci	r24, 0xFF	; 255
    2684:	9f 4f       	sbci	r25, 0xFF	; 255
    2686:	08 95       	ret

00002688 <__fp_split3>:
    2688:	57 fd       	sbrc	r21, 7
    268a:	90 58       	subi	r25, 0x80	; 128
    268c:	44 0f       	add	r20, r20
    268e:	55 1f       	adc	r21, r21
    2690:	59 f0       	breq	.+22     	; 0x26a8 <__fp_splitA+0x10>
    2692:	5f 3f       	cpi	r21, 0xFF	; 255
    2694:	71 f0       	breq	.+28     	; 0x26b2 <__fp_splitA+0x1a>
    2696:	47 95       	ror	r20

00002698 <__fp_splitA>:
    2698:	88 0f       	add	r24, r24
    269a:	97 fb       	bst	r25, 7
    269c:	99 1f       	adc	r25, r25
    269e:	61 f0       	breq	.+24     	; 0x26b8 <__fp_splitA+0x20>
    26a0:	9f 3f       	cpi	r25, 0xFF	; 255
    26a2:	79 f0       	breq	.+30     	; 0x26c2 <__fp_splitA+0x2a>
    26a4:	87 95       	ror	r24
    26a6:	08 95       	ret
    26a8:	12 16       	cp	r1, r18
    26aa:	13 06       	cpc	r1, r19
    26ac:	14 06       	cpc	r1, r20
    26ae:	55 1f       	adc	r21, r21
    26b0:	f2 cf       	rjmp	.-28     	; 0x2696 <__fp_split3+0xe>
    26b2:	46 95       	lsr	r20
    26b4:	f1 df       	rcall	.-30     	; 0x2698 <__fp_splitA>
    26b6:	08 c0       	rjmp	.+16     	; 0x26c8 <__fp_splitA+0x30>
    26b8:	16 16       	cp	r1, r22
    26ba:	17 06       	cpc	r1, r23
    26bc:	18 06       	cpc	r1, r24
    26be:	99 1f       	adc	r25, r25
    26c0:	f1 cf       	rjmp	.-30     	; 0x26a4 <__fp_splitA+0xc>
    26c2:	86 95       	lsr	r24
    26c4:	71 05       	cpc	r23, r1
    26c6:	61 05       	cpc	r22, r1
    26c8:	08 94       	sec
    26ca:	08 95       	ret

000026cc <__fp_zero>:
    26cc:	e8 94       	clt

000026ce <__fp_szero>:
    26ce:	bb 27       	eor	r27, r27
    26d0:	66 27       	eor	r22, r22
    26d2:	77 27       	eor	r23, r23
    26d4:	cb 01       	movw	r24, r22
    26d6:	97 f9       	bld	r25, 7
    26d8:	08 95       	ret

000026da <__mulsf3>:
    26da:	0b d0       	rcall	.+22     	; 0x26f2 <__mulsf3x>
    26dc:	c4 cf       	rjmp	.-120    	; 0x2666 <__fp_round>
    26de:	b5 df       	rcall	.-150    	; 0x264a <__fp_pscA>
    26e0:	28 f0       	brcs	.+10     	; 0x26ec <__mulsf3+0x12>
    26e2:	ba df       	rcall	.-140    	; 0x2658 <__fp_pscB>
    26e4:	18 f0       	brcs	.+6      	; 0x26ec <__mulsf3+0x12>
    26e6:	95 23       	and	r25, r21
    26e8:	09 f0       	breq	.+2      	; 0x26ec <__mulsf3+0x12>
    26ea:	a6 cf       	rjmp	.-180    	; 0x2638 <__fp_inf>
    26ec:	ab cf       	rjmp	.-170    	; 0x2644 <__fp_nan>
    26ee:	11 24       	eor	r1, r1
    26f0:	ee cf       	rjmp	.-36     	; 0x26ce <__fp_szero>

000026f2 <__mulsf3x>:
    26f2:	ca df       	rcall	.-108    	; 0x2688 <__fp_split3>
    26f4:	a0 f3       	brcs	.-24     	; 0x26de <__mulsf3+0x4>

000026f6 <__mulsf3_pse>:
    26f6:	95 9f       	mul	r25, r21
    26f8:	d1 f3       	breq	.-12     	; 0x26ee <__mulsf3+0x14>
    26fa:	95 0f       	add	r25, r21
    26fc:	50 e0       	ldi	r21, 0x00	; 0
    26fe:	55 1f       	adc	r21, r21
    2700:	62 9f       	mul	r22, r18
    2702:	f0 01       	movw	r30, r0
    2704:	72 9f       	mul	r23, r18
    2706:	bb 27       	eor	r27, r27
    2708:	f0 0d       	add	r31, r0
    270a:	b1 1d       	adc	r27, r1
    270c:	63 9f       	mul	r22, r19
    270e:	aa 27       	eor	r26, r26
    2710:	f0 0d       	add	r31, r0
    2712:	b1 1d       	adc	r27, r1
    2714:	aa 1f       	adc	r26, r26
    2716:	64 9f       	mul	r22, r20
    2718:	66 27       	eor	r22, r22
    271a:	b0 0d       	add	r27, r0
    271c:	a1 1d       	adc	r26, r1
    271e:	66 1f       	adc	r22, r22
    2720:	82 9f       	mul	r24, r18
    2722:	22 27       	eor	r18, r18
    2724:	b0 0d       	add	r27, r0
    2726:	a1 1d       	adc	r26, r1
    2728:	62 1f       	adc	r22, r18
    272a:	73 9f       	mul	r23, r19
    272c:	b0 0d       	add	r27, r0
    272e:	a1 1d       	adc	r26, r1
    2730:	62 1f       	adc	r22, r18
    2732:	83 9f       	mul	r24, r19
    2734:	a0 0d       	add	r26, r0
    2736:	61 1d       	adc	r22, r1
    2738:	22 1f       	adc	r18, r18
    273a:	74 9f       	mul	r23, r20
    273c:	33 27       	eor	r19, r19
    273e:	a0 0d       	add	r26, r0
    2740:	61 1d       	adc	r22, r1
    2742:	23 1f       	adc	r18, r19
    2744:	84 9f       	mul	r24, r20
    2746:	60 0d       	add	r22, r0
    2748:	21 1d       	adc	r18, r1
    274a:	82 2f       	mov	r24, r18
    274c:	76 2f       	mov	r23, r22
    274e:	6a 2f       	mov	r22, r26
    2750:	11 24       	eor	r1, r1
    2752:	9f 57       	subi	r25, 0x7F	; 127
    2754:	50 40       	sbci	r21, 0x00	; 0
    2756:	8a f0       	brmi	.+34     	; 0x277a <__mulsf3_pse+0x84>
    2758:	e1 f0       	breq	.+56     	; 0x2792 <__mulsf3_pse+0x9c>
    275a:	88 23       	and	r24, r24
    275c:	4a f0       	brmi	.+18     	; 0x2770 <__mulsf3_pse+0x7a>
    275e:	ee 0f       	add	r30, r30
    2760:	ff 1f       	adc	r31, r31
    2762:	bb 1f       	adc	r27, r27
    2764:	66 1f       	adc	r22, r22
    2766:	77 1f       	adc	r23, r23
    2768:	88 1f       	adc	r24, r24
    276a:	91 50       	subi	r25, 0x01	; 1
    276c:	50 40       	sbci	r21, 0x00	; 0
    276e:	a9 f7       	brne	.-22     	; 0x275a <__mulsf3_pse+0x64>
    2770:	9e 3f       	cpi	r25, 0xFE	; 254
    2772:	51 05       	cpc	r21, r1
    2774:	70 f0       	brcs	.+28     	; 0x2792 <__mulsf3_pse+0x9c>
    2776:	60 cf       	rjmp	.-320    	; 0x2638 <__fp_inf>
    2778:	aa cf       	rjmp	.-172    	; 0x26ce <__fp_szero>
    277a:	5f 3f       	cpi	r21, 0xFF	; 255
    277c:	ec f3       	brlt	.-6      	; 0x2778 <__mulsf3_pse+0x82>
    277e:	98 3e       	cpi	r25, 0xE8	; 232
    2780:	dc f3       	brlt	.-10     	; 0x2778 <__mulsf3_pse+0x82>
    2782:	86 95       	lsr	r24
    2784:	77 95       	ror	r23
    2786:	67 95       	ror	r22
    2788:	b7 95       	ror	r27
    278a:	f7 95       	ror	r31
    278c:	e7 95       	ror	r30
    278e:	9f 5f       	subi	r25, 0xFF	; 255
    2790:	c1 f7       	brne	.-16     	; 0x2782 <__mulsf3_pse+0x8c>
    2792:	fe 2b       	or	r31, r30
    2794:	88 0f       	add	r24, r24
    2796:	91 1d       	adc	r25, r1
    2798:	96 95       	lsr	r25
    279a:	87 95       	ror	r24
    279c:	97 f9       	bld	r25, 7
    279e:	08 95       	ret

000027a0 <pow>:
    27a0:	fa 01       	movw	r30, r20
    27a2:	ee 0f       	add	r30, r30
    27a4:	ff 1f       	adc	r31, r31
    27a6:	30 96       	adiw	r30, 0x00	; 0
    27a8:	21 05       	cpc	r18, r1
    27aa:	31 05       	cpc	r19, r1
    27ac:	99 f1       	breq	.+102    	; 0x2814 <pow+0x74>
    27ae:	61 15       	cp	r22, r1
    27b0:	71 05       	cpc	r23, r1
    27b2:	61 f4       	brne	.+24     	; 0x27cc <pow+0x2c>
    27b4:	80 38       	cpi	r24, 0x80	; 128
    27b6:	bf e3       	ldi	r27, 0x3F	; 63
    27b8:	9b 07       	cpc	r25, r27
    27ba:	49 f1       	breq	.+82     	; 0x280e <pow+0x6e>
    27bc:	68 94       	set
    27be:	90 38       	cpi	r25, 0x80	; 128
    27c0:	81 05       	cpc	r24, r1
    27c2:	61 f0       	breq	.+24     	; 0x27dc <pow+0x3c>
    27c4:	80 38       	cpi	r24, 0x80	; 128
    27c6:	bf ef       	ldi	r27, 0xFF	; 255
    27c8:	9b 07       	cpc	r25, r27
    27ca:	41 f0       	breq	.+16     	; 0x27dc <pow+0x3c>
    27cc:	99 23       	and	r25, r25
    27ce:	42 f5       	brpl	.+80     	; 0x2820 <pow+0x80>
    27d0:	ff 3f       	cpi	r31, 0xFF	; 255
    27d2:	e1 05       	cpc	r30, r1
    27d4:	31 05       	cpc	r19, r1
    27d6:	21 05       	cpc	r18, r1
    27d8:	11 f1       	breq	.+68     	; 0x281e <pow+0x7e>
    27da:	e8 94       	clt
    27dc:	08 94       	sec
    27de:	e7 95       	ror	r30
    27e0:	d9 01       	movw	r26, r18
    27e2:	aa 23       	and	r26, r26
    27e4:	29 f4       	brne	.+10     	; 0x27f0 <pow+0x50>
    27e6:	ab 2f       	mov	r26, r27
    27e8:	be 2f       	mov	r27, r30
    27ea:	f8 5f       	subi	r31, 0xF8	; 248
    27ec:	d0 f3       	brcs	.-12     	; 0x27e2 <pow+0x42>
    27ee:	10 c0       	rjmp	.+32     	; 0x2810 <pow+0x70>
    27f0:	ff 5f       	subi	r31, 0xFF	; 255
    27f2:	70 f4       	brcc	.+28     	; 0x2810 <pow+0x70>
    27f4:	a6 95       	lsr	r26
    27f6:	e0 f7       	brcc	.-8      	; 0x27f0 <pow+0x50>
    27f8:	f7 39       	cpi	r31, 0x97	; 151
    27fa:	50 f0       	brcs	.+20     	; 0x2810 <pow+0x70>
    27fc:	19 f0       	breq	.+6      	; 0x2804 <pow+0x64>
    27fe:	ff 3a       	cpi	r31, 0xAF	; 175
    2800:	38 f4       	brcc	.+14     	; 0x2810 <pow+0x70>
    2802:	9f 77       	andi	r25, 0x7F	; 127
    2804:	9f 93       	push	r25
    2806:	0c d0       	rcall	.+24     	; 0x2820 <pow+0x80>
    2808:	0f 90       	pop	r0
    280a:	07 fc       	sbrc	r0, 7
    280c:	90 58       	subi	r25, 0x80	; 128
    280e:	08 95       	ret
    2810:	3e f0       	brts	.+14     	; 0x2820 <pow+0x80>
    2812:	18 cf       	rjmp	.-464    	; 0x2644 <__fp_nan>
    2814:	60 e0       	ldi	r22, 0x00	; 0
    2816:	70 e0       	ldi	r23, 0x00	; 0
    2818:	80 e8       	ldi	r24, 0x80	; 128
    281a:	9f e3       	ldi	r25, 0x3F	; 63
    281c:	08 95       	ret
    281e:	4f e7       	ldi	r20, 0x7F	; 127
    2820:	9f 77       	andi	r25, 0x7F	; 127
    2822:	5f 93       	push	r21
    2824:	4f 93       	push	r20
    2826:	3f 93       	push	r19
    2828:	2f 93       	push	r18
    282a:	9e d0       	rcall	.+316    	; 0x2968 <log>
    282c:	2f 91       	pop	r18
    282e:	3f 91       	pop	r19
    2830:	4f 91       	pop	r20
    2832:	5f 91       	pop	r21
    2834:	52 df       	rcall	.-348    	; 0x26da <__mulsf3>
    2836:	05 c0       	rjmp	.+10     	; 0x2842 <exp>
    2838:	19 f4       	brne	.+6      	; 0x2840 <pow+0xa0>
    283a:	0e f0       	brts	.+2      	; 0x283e <pow+0x9e>
    283c:	fd ce       	rjmp	.-518    	; 0x2638 <__fp_inf>
    283e:	46 cf       	rjmp	.-372    	; 0x26cc <__fp_zero>
    2840:	01 cf       	rjmp	.-510    	; 0x2644 <__fp_nan>

00002842 <exp>:
    2842:	2a df       	rcall	.-428    	; 0x2698 <__fp_splitA>
    2844:	c8 f3       	brcs	.-14     	; 0x2838 <pow+0x98>
    2846:	96 38       	cpi	r25, 0x86	; 134
    2848:	c0 f7       	brcc	.-16     	; 0x283a <pow+0x9a>
    284a:	07 f8       	bld	r0, 7
    284c:	0f 92       	push	r0
    284e:	e8 94       	clt
    2850:	2b e3       	ldi	r18, 0x3B	; 59
    2852:	3a ea       	ldi	r19, 0xAA	; 170
    2854:	48 eb       	ldi	r20, 0xB8	; 184
    2856:	5f e7       	ldi	r21, 0x7F	; 127
    2858:	4e df       	rcall	.-356    	; 0x26f6 <__mulsf3_pse>
    285a:	0f 92       	push	r0
    285c:	0f 92       	push	r0
    285e:	0f 92       	push	r0
    2860:	4d b7       	in	r20, 0x3d	; 61
    2862:	5e b7       	in	r21, 0x3e	; 62
    2864:	0f 92       	push	r0
    2866:	c0 d0       	rcall	.+384    	; 0x29e8 <modf>
    2868:	e4 ee       	ldi	r30, 0xE4	; 228
    286a:	f0 e0       	ldi	r31, 0x00	; 0
    286c:	16 d0       	rcall	.+44     	; 0x289a <__fp_powser>
    286e:	4f 91       	pop	r20
    2870:	5f 91       	pop	r21
    2872:	ef 91       	pop	r30
    2874:	ff 91       	pop	r31
    2876:	e5 95       	asr	r30
    2878:	ee 1f       	adc	r30, r30
    287a:	ff 1f       	adc	r31, r31
    287c:	49 f0       	breq	.+18     	; 0x2890 <exp+0x4e>
    287e:	fe 57       	subi	r31, 0x7E	; 126
    2880:	e0 68       	ori	r30, 0x80	; 128
    2882:	44 27       	eor	r20, r20
    2884:	ee 0f       	add	r30, r30
    2886:	44 1f       	adc	r20, r20
    2888:	fa 95       	dec	r31
    288a:	e1 f7       	brne	.-8      	; 0x2884 <exp+0x42>
    288c:	41 95       	neg	r20
    288e:	55 0b       	sbc	r21, r21
    2890:	32 d0       	rcall	.+100    	; 0x28f6 <ldexp>
    2892:	0f 90       	pop	r0
    2894:	07 fe       	sbrs	r0, 7
    2896:	26 c0       	rjmp	.+76     	; 0x28e4 <inverse>
    2898:	08 95       	ret

0000289a <__fp_powser>:
    289a:	df 93       	push	r29
    289c:	cf 93       	push	r28
    289e:	1f 93       	push	r17
    28a0:	0f 93       	push	r16
    28a2:	ff 92       	push	r15
    28a4:	ef 92       	push	r14
    28a6:	df 92       	push	r13
    28a8:	7b 01       	movw	r14, r22
    28aa:	8c 01       	movw	r16, r24
    28ac:	68 94       	set
    28ae:	05 c0       	rjmp	.+10     	; 0x28ba <__fp_powser+0x20>
    28b0:	da 2e       	mov	r13, r26
    28b2:	ef 01       	movw	r28, r30
    28b4:	1e df       	rcall	.-452    	; 0x26f2 <__mulsf3x>
    28b6:	fe 01       	movw	r30, r28
    28b8:	e8 94       	clt
    28ba:	a5 91       	lpm	r26, Z+
    28bc:	25 91       	lpm	r18, Z+
    28be:	35 91       	lpm	r19, Z+
    28c0:	45 91       	lpm	r20, Z+
    28c2:	55 91       	lpm	r21, Z+
    28c4:	ae f3       	brts	.-22     	; 0x28b0 <__fp_powser+0x16>
    28c6:	ef 01       	movw	r28, r30
    28c8:	f6 dd       	rcall	.-1044   	; 0x24b6 <__addsf3x>
    28ca:	fe 01       	movw	r30, r28
    28cc:	97 01       	movw	r18, r14
    28ce:	a8 01       	movw	r20, r16
    28d0:	da 94       	dec	r13
    28d2:	79 f7       	brne	.-34     	; 0x28b2 <__fp_powser+0x18>
    28d4:	df 90       	pop	r13
    28d6:	ef 90       	pop	r14
    28d8:	ff 90       	pop	r15
    28da:	0f 91       	pop	r16
    28dc:	1f 91       	pop	r17
    28de:	cf 91       	pop	r28
    28e0:	df 91       	pop	r29
    28e2:	08 95       	ret

000028e4 <inverse>:
    28e4:	9b 01       	movw	r18, r22
    28e6:	ac 01       	movw	r20, r24
    28e8:	60 e0       	ldi	r22, 0x00	; 0
    28ea:	70 e0       	ldi	r23, 0x00	; 0
    28ec:	80 e8       	ldi	r24, 0x80	; 128
    28ee:	9f e3       	ldi	r25, 0x3F	; 63
    28f0:	ae c0       	rjmp	.+348    	; 0x2a4e <__divsf3>
    28f2:	a2 ce       	rjmp	.-700    	; 0x2638 <__fp_inf>
    28f4:	14 c1       	rjmp	.+552    	; 0x2b1e <__fp_mpack>

000028f6 <ldexp>:
    28f6:	d0 de       	rcall	.-608    	; 0x2698 <__fp_splitA>
    28f8:	e8 f3       	brcs	.-6      	; 0x28f4 <inverse+0x10>
    28fa:	99 23       	and	r25, r25
    28fc:	d9 f3       	breq	.-10     	; 0x28f4 <inverse+0x10>
    28fe:	94 0f       	add	r25, r20
    2900:	51 1d       	adc	r21, r1
    2902:	bb f3       	brvs	.-18     	; 0x28f2 <inverse+0xe>
    2904:	91 50       	subi	r25, 0x01	; 1
    2906:	50 40       	sbci	r21, 0x00	; 0
    2908:	94 f0       	brlt	.+36     	; 0x292e <ldexp+0x38>
    290a:	59 f0       	breq	.+22     	; 0x2922 <ldexp+0x2c>
    290c:	88 23       	and	r24, r24
    290e:	32 f0       	brmi	.+12     	; 0x291c <ldexp+0x26>
    2910:	66 0f       	add	r22, r22
    2912:	77 1f       	adc	r23, r23
    2914:	88 1f       	adc	r24, r24
    2916:	91 50       	subi	r25, 0x01	; 1
    2918:	50 40       	sbci	r21, 0x00	; 0
    291a:	c1 f7       	brne	.-16     	; 0x290c <ldexp+0x16>
    291c:	9e 3f       	cpi	r25, 0xFE	; 254
    291e:	51 05       	cpc	r21, r1
    2920:	44 f7       	brge	.-48     	; 0x28f2 <inverse+0xe>
    2922:	88 0f       	add	r24, r24
    2924:	91 1d       	adc	r25, r1
    2926:	96 95       	lsr	r25
    2928:	87 95       	ror	r24
    292a:	97 f9       	bld	r25, 7
    292c:	08 95       	ret
    292e:	5f 3f       	cpi	r21, 0xFF	; 255
    2930:	ac f0       	brlt	.+42     	; 0x295c <ldexp+0x66>
    2932:	98 3e       	cpi	r25, 0xE8	; 232
    2934:	9c f0       	brlt	.+38     	; 0x295c <ldexp+0x66>
    2936:	bb 27       	eor	r27, r27
    2938:	86 95       	lsr	r24
    293a:	77 95       	ror	r23
    293c:	67 95       	ror	r22
    293e:	b7 95       	ror	r27
    2940:	08 f4       	brcc	.+2      	; 0x2944 <ldexp+0x4e>
    2942:	b1 60       	ori	r27, 0x01	; 1
    2944:	93 95       	inc	r25
    2946:	c1 f7       	brne	.-16     	; 0x2938 <ldexp+0x42>
    2948:	bb 0f       	add	r27, r27
    294a:	58 f7       	brcc	.-42     	; 0x2922 <ldexp+0x2c>
    294c:	11 f4       	brne	.+4      	; 0x2952 <ldexp+0x5c>
    294e:	60 ff       	sbrs	r22, 0
    2950:	e8 cf       	rjmp	.-48     	; 0x2922 <ldexp+0x2c>
    2952:	6f 5f       	subi	r22, 0xFF	; 255
    2954:	7f 4f       	sbci	r23, 0xFF	; 255
    2956:	8f 4f       	sbci	r24, 0xFF	; 255
    2958:	9f 4f       	sbci	r25, 0xFF	; 255
    295a:	e3 cf       	rjmp	.-58     	; 0x2922 <ldexp+0x2c>
    295c:	b8 ce       	rjmp	.-656    	; 0x26ce <__fp_szero>
    295e:	0e f0       	brts	.+2      	; 0x2962 <ldexp+0x6c>
    2960:	de c0       	rjmp	.+444    	; 0x2b1e <__fp_mpack>
    2962:	70 ce       	rjmp	.-800    	; 0x2644 <__fp_nan>
    2964:	68 94       	set
    2966:	68 ce       	rjmp	.-816    	; 0x2638 <__fp_inf>

00002968 <log>:
    2968:	97 de       	rcall	.-722    	; 0x2698 <__fp_splitA>
    296a:	c8 f3       	brcs	.-14     	; 0x295e <ldexp+0x68>
    296c:	99 23       	and	r25, r25
    296e:	d1 f3       	breq	.-12     	; 0x2964 <ldexp+0x6e>
    2970:	c6 f3       	brts	.-16     	; 0x2962 <ldexp+0x6c>
    2972:	df 93       	push	r29
    2974:	cf 93       	push	r28
    2976:	1f 93       	push	r17
    2978:	0f 93       	push	r16
    297a:	ff 92       	push	r15
    297c:	c9 2f       	mov	r28, r25
    297e:	dd 27       	eor	r29, r29
    2980:	88 23       	and	r24, r24
    2982:	2a f0       	brmi	.+10     	; 0x298e <log+0x26>
    2984:	21 97       	sbiw	r28, 0x01	; 1
    2986:	66 0f       	add	r22, r22
    2988:	77 1f       	adc	r23, r23
    298a:	88 1f       	adc	r24, r24
    298c:	da f7       	brpl	.-10     	; 0x2984 <log+0x1c>
    298e:	20 e0       	ldi	r18, 0x00	; 0
    2990:	30 e0       	ldi	r19, 0x00	; 0
    2992:	40 e8       	ldi	r20, 0x80	; 128
    2994:	5f eb       	ldi	r21, 0xBF	; 191
    2996:	9f e3       	ldi	r25, 0x3F	; 63
    2998:	88 39       	cpi	r24, 0x98	; 152
    299a:	20 f0       	brcs	.+8      	; 0x29a4 <log+0x3c>
    299c:	80 3e       	cpi	r24, 0xE0	; 224
    299e:	30 f0       	brcs	.+12     	; 0x29ac <log+0x44>
    29a0:	21 96       	adiw	r28, 0x01	; 1
    29a2:	8f 77       	andi	r24, 0x7F	; 127
    29a4:	77 dd       	rcall	.-1298   	; 0x2494 <__addsf3>
    29a6:	ec e0       	ldi	r30, 0x0C	; 12
    29a8:	f1 e0       	ldi	r31, 0x01	; 1
    29aa:	03 c0       	rjmp	.+6      	; 0x29b2 <log+0x4a>
    29ac:	73 dd       	rcall	.-1306   	; 0x2494 <__addsf3>
    29ae:	e9 e3       	ldi	r30, 0x39	; 57
    29b0:	f1 e0       	ldi	r31, 0x01	; 1
    29b2:	73 df       	rcall	.-282    	; 0x289a <__fp_powser>
    29b4:	8b 01       	movw	r16, r22
    29b6:	be 01       	movw	r22, r28
    29b8:	ec 01       	movw	r28, r24
    29ba:	fb 2e       	mov	r15, r27
    29bc:	6f 57       	subi	r22, 0x7F	; 127
    29be:	71 09       	sbc	r23, r1
    29c0:	75 95       	asr	r23
    29c2:	77 1f       	adc	r23, r23
    29c4:	88 0b       	sbc	r24, r24
    29c6:	99 0b       	sbc	r25, r25
    29c8:	fc dd       	rcall	.-1032   	; 0x25c2 <__floatsisf>
    29ca:	28 e1       	ldi	r18, 0x18	; 24
    29cc:	32 e7       	ldi	r19, 0x72	; 114
    29ce:	41 e3       	ldi	r20, 0x31	; 49
    29d0:	5f e3       	ldi	r21, 0x3F	; 63
    29d2:	8f de       	rcall	.-738    	; 0x26f2 <__mulsf3x>
    29d4:	af 2d       	mov	r26, r15
    29d6:	98 01       	movw	r18, r16
    29d8:	ae 01       	movw	r20, r28
    29da:	ff 90       	pop	r15
    29dc:	0f 91       	pop	r16
    29de:	1f 91       	pop	r17
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	68 dd       	rcall	.-1328   	; 0x24b6 <__addsf3x>
    29e6:	3f ce       	rjmp	.-898    	; 0x2666 <__fp_round>

000029e8 <modf>:
    29e8:	fa 01       	movw	r30, r20
    29ea:	dc 01       	movw	r26, r24
    29ec:	aa 0f       	add	r26, r26
    29ee:	bb 1f       	adc	r27, r27
    29f0:	9b 01       	movw	r18, r22
    29f2:	ac 01       	movw	r20, r24
    29f4:	bf 57       	subi	r27, 0x7F	; 127
    29f6:	28 f4       	brcc	.+10     	; 0x2a02 <modf+0x1a>
    29f8:	22 27       	eor	r18, r18
    29fa:	33 27       	eor	r19, r19
    29fc:	44 27       	eor	r20, r20
    29fe:	50 78       	andi	r21, 0x80	; 128
    2a00:	1f c0       	rjmp	.+62     	; 0x2a40 <modf+0x58>
    2a02:	b7 51       	subi	r27, 0x17	; 23
    2a04:	88 f4       	brcc	.+34     	; 0x2a28 <modf+0x40>
    2a06:	ab 2f       	mov	r26, r27
    2a08:	00 24       	eor	r0, r0
    2a0a:	46 95       	lsr	r20
    2a0c:	37 95       	ror	r19
    2a0e:	27 95       	ror	r18
    2a10:	01 1c       	adc	r0, r1
    2a12:	a3 95       	inc	r26
    2a14:	d2 f3       	brmi	.-12     	; 0x2a0a <modf+0x22>
    2a16:	00 20       	and	r0, r0
    2a18:	69 f0       	breq	.+26     	; 0x2a34 <modf+0x4c>
    2a1a:	22 0f       	add	r18, r18
    2a1c:	33 1f       	adc	r19, r19
    2a1e:	44 1f       	adc	r20, r20
    2a20:	b3 95       	inc	r27
    2a22:	da f3       	brmi	.-10     	; 0x2a1a <modf+0x32>
    2a24:	0d d0       	rcall	.+26     	; 0x2a40 <modf+0x58>
    2a26:	35 cd       	rjmp	.-1430   	; 0x2492 <__subsf3>
    2a28:	61 30       	cpi	r22, 0x01	; 1
    2a2a:	71 05       	cpc	r23, r1
    2a2c:	a0 e8       	ldi	r26, 0x80	; 128
    2a2e:	8a 07       	cpc	r24, r26
    2a30:	b9 46       	sbci	r27, 0x69	; 105
    2a32:	30 f4       	brcc	.+12     	; 0x2a40 <modf+0x58>
    2a34:	9b 01       	movw	r18, r22
    2a36:	ac 01       	movw	r20, r24
    2a38:	66 27       	eor	r22, r22
    2a3a:	77 27       	eor	r23, r23
    2a3c:	88 27       	eor	r24, r24
    2a3e:	90 78       	andi	r25, 0x80	; 128
    2a40:	30 96       	adiw	r30, 0x00	; 0
    2a42:	21 f0       	breq	.+8      	; 0x2a4c <modf+0x64>
    2a44:	20 83       	st	Z, r18
    2a46:	31 83       	std	Z+1, r19	; 0x01
    2a48:	42 83       	std	Z+2, r20	; 0x02
    2a4a:	53 83       	std	Z+3, r21	; 0x03
    2a4c:	08 95       	ret

00002a4e <__divsf3>:
    2a4e:	0c d0       	rcall	.+24     	; 0x2a68 <__divsf3x>
    2a50:	0a ce       	rjmp	.-1004   	; 0x2666 <__fp_round>
    2a52:	02 de       	rcall	.-1020   	; 0x2658 <__fp_pscB>
    2a54:	40 f0       	brcs	.+16     	; 0x2a66 <__divsf3+0x18>
    2a56:	f9 dd       	rcall	.-1038   	; 0x264a <__fp_pscA>
    2a58:	30 f0       	brcs	.+12     	; 0x2a66 <__divsf3+0x18>
    2a5a:	21 f4       	brne	.+8      	; 0x2a64 <__divsf3+0x16>
    2a5c:	5f 3f       	cpi	r21, 0xFF	; 255
    2a5e:	19 f0       	breq	.+6      	; 0x2a66 <__divsf3+0x18>
    2a60:	eb cd       	rjmp	.-1066   	; 0x2638 <__fp_inf>
    2a62:	51 11       	cpse	r21, r1
    2a64:	34 ce       	rjmp	.-920    	; 0x26ce <__fp_szero>
    2a66:	ee cd       	rjmp	.-1060   	; 0x2644 <__fp_nan>

00002a68 <__divsf3x>:
    2a68:	0f de       	rcall	.-994    	; 0x2688 <__fp_split3>
    2a6a:	98 f3       	brcs	.-26     	; 0x2a52 <__divsf3+0x4>

00002a6c <__divsf3_pse>:
    2a6c:	99 23       	and	r25, r25
    2a6e:	c9 f3       	breq	.-14     	; 0x2a62 <__divsf3+0x14>
    2a70:	55 23       	and	r21, r21
    2a72:	b1 f3       	breq	.-20     	; 0x2a60 <__divsf3+0x12>
    2a74:	95 1b       	sub	r25, r21
    2a76:	55 0b       	sbc	r21, r21
    2a78:	bb 27       	eor	r27, r27
    2a7a:	aa 27       	eor	r26, r26
    2a7c:	62 17       	cp	r22, r18
    2a7e:	73 07       	cpc	r23, r19
    2a80:	84 07       	cpc	r24, r20
    2a82:	38 f0       	brcs	.+14     	; 0x2a92 <__divsf3_pse+0x26>
    2a84:	9f 5f       	subi	r25, 0xFF	; 255
    2a86:	5f 4f       	sbci	r21, 0xFF	; 255
    2a88:	22 0f       	add	r18, r18
    2a8a:	33 1f       	adc	r19, r19
    2a8c:	44 1f       	adc	r20, r20
    2a8e:	aa 1f       	adc	r26, r26
    2a90:	a9 f3       	breq	.-22     	; 0x2a7c <__divsf3_pse+0x10>
    2a92:	33 d0       	rcall	.+102    	; 0x2afa <__divsf3_pse+0x8e>
    2a94:	0e 2e       	mov	r0, r30
    2a96:	3a f0       	brmi	.+14     	; 0x2aa6 <__divsf3_pse+0x3a>
    2a98:	e0 e8       	ldi	r30, 0x80	; 128
    2a9a:	30 d0       	rcall	.+96     	; 0x2afc <__divsf3_pse+0x90>
    2a9c:	91 50       	subi	r25, 0x01	; 1
    2a9e:	50 40       	sbci	r21, 0x00	; 0
    2aa0:	e6 95       	lsr	r30
    2aa2:	00 1c       	adc	r0, r0
    2aa4:	ca f7       	brpl	.-14     	; 0x2a98 <__divsf3_pse+0x2c>
    2aa6:	29 d0       	rcall	.+82     	; 0x2afa <__divsf3_pse+0x8e>
    2aa8:	fe 2f       	mov	r31, r30
    2aaa:	27 d0       	rcall	.+78     	; 0x2afa <__divsf3_pse+0x8e>
    2aac:	66 0f       	add	r22, r22
    2aae:	77 1f       	adc	r23, r23
    2ab0:	88 1f       	adc	r24, r24
    2ab2:	bb 1f       	adc	r27, r27
    2ab4:	26 17       	cp	r18, r22
    2ab6:	37 07       	cpc	r19, r23
    2ab8:	48 07       	cpc	r20, r24
    2aba:	ab 07       	cpc	r26, r27
    2abc:	b0 e8       	ldi	r27, 0x80	; 128
    2abe:	09 f0       	breq	.+2      	; 0x2ac2 <__divsf3_pse+0x56>
    2ac0:	bb 0b       	sbc	r27, r27
    2ac2:	80 2d       	mov	r24, r0
    2ac4:	bf 01       	movw	r22, r30
    2ac6:	ff 27       	eor	r31, r31
    2ac8:	93 58       	subi	r25, 0x83	; 131
    2aca:	5f 4f       	sbci	r21, 0xFF	; 255
    2acc:	2a f0       	brmi	.+10     	; 0x2ad8 <__divsf3_pse+0x6c>
    2ace:	9e 3f       	cpi	r25, 0xFE	; 254
    2ad0:	51 05       	cpc	r21, r1
    2ad2:	68 f0       	brcs	.+26     	; 0x2aee <__divsf3_pse+0x82>
    2ad4:	b1 cd       	rjmp	.-1182   	; 0x2638 <__fp_inf>
    2ad6:	fb cd       	rjmp	.-1034   	; 0x26ce <__fp_szero>
    2ad8:	5f 3f       	cpi	r21, 0xFF	; 255
    2ada:	ec f3       	brlt	.-6      	; 0x2ad6 <__divsf3_pse+0x6a>
    2adc:	98 3e       	cpi	r25, 0xE8	; 232
    2ade:	dc f3       	brlt	.-10     	; 0x2ad6 <__divsf3_pse+0x6a>
    2ae0:	86 95       	lsr	r24
    2ae2:	77 95       	ror	r23
    2ae4:	67 95       	ror	r22
    2ae6:	b7 95       	ror	r27
    2ae8:	f7 95       	ror	r31
    2aea:	9f 5f       	subi	r25, 0xFF	; 255
    2aec:	c9 f7       	brne	.-14     	; 0x2ae0 <__divsf3_pse+0x74>
    2aee:	88 0f       	add	r24, r24
    2af0:	91 1d       	adc	r25, r1
    2af2:	96 95       	lsr	r25
    2af4:	87 95       	ror	r24
    2af6:	97 f9       	bld	r25, 7
    2af8:	08 95       	ret
    2afa:	e1 e0       	ldi	r30, 0x01	; 1
    2afc:	66 0f       	add	r22, r22
    2afe:	77 1f       	adc	r23, r23
    2b00:	88 1f       	adc	r24, r24
    2b02:	bb 1f       	adc	r27, r27
    2b04:	62 17       	cp	r22, r18
    2b06:	73 07       	cpc	r23, r19
    2b08:	84 07       	cpc	r24, r20
    2b0a:	ba 07       	cpc	r27, r26
    2b0c:	20 f0       	brcs	.+8      	; 0x2b16 <__divsf3_pse+0xaa>
    2b0e:	62 1b       	sub	r22, r18
    2b10:	73 0b       	sbc	r23, r19
    2b12:	84 0b       	sbc	r24, r20
    2b14:	ba 0b       	sbc	r27, r26
    2b16:	ee 1f       	adc	r30, r30
    2b18:	88 f7       	brcc	.-30     	; 0x2afc <__divsf3_pse+0x90>
    2b1a:	e0 95       	com	r30
    2b1c:	08 95       	ret

00002b1e <__fp_mpack>:
    2b1e:	9f 3f       	cpi	r25, 0xFF	; 255
    2b20:	31 f0       	breq	.+12     	; 0x2b2e <__fp_mpack_finite+0xc>

00002b22 <__fp_mpack_finite>:
    2b22:	91 50       	subi	r25, 0x01	; 1
    2b24:	20 f4       	brcc	.+8      	; 0x2b2e <__fp_mpack_finite+0xc>
    2b26:	87 95       	ror	r24
    2b28:	77 95       	ror	r23
    2b2a:	67 95       	ror	r22
    2b2c:	b7 95       	ror	r27
    2b2e:	88 0f       	add	r24, r24
    2b30:	91 1d       	adc	r25, r1
    2b32:	96 95       	lsr	r25
    2b34:	87 95       	ror	r24
    2b36:	97 f9       	bld	r25, 7
    2b38:	08 95       	ret

00002b3a <__divmodhi4>:
    2b3a:	97 fb       	bst	r25, 7
    2b3c:	07 2e       	mov	r0, r23
    2b3e:	16 f4       	brtc	.+4      	; 0x2b44 <__divmodhi4+0xa>
    2b40:	00 94       	com	r0
    2b42:	06 d0       	rcall	.+12     	; 0x2b50 <__divmodhi4_neg1>
    2b44:	77 fd       	sbrc	r23, 7
    2b46:	08 d0       	rcall	.+16     	; 0x2b58 <__divmodhi4_neg2>
    2b48:	0b d0       	rcall	.+22     	; 0x2b60 <__udivmodhi4>
    2b4a:	07 fc       	sbrc	r0, 7
    2b4c:	05 d0       	rcall	.+10     	; 0x2b58 <__divmodhi4_neg2>
    2b4e:	3e f4       	brtc	.+14     	; 0x2b5e <__divmodhi4_exit>

00002b50 <__divmodhi4_neg1>:
    2b50:	90 95       	com	r25
    2b52:	81 95       	neg	r24
    2b54:	9f 4f       	sbci	r25, 0xFF	; 255
    2b56:	08 95       	ret

00002b58 <__divmodhi4_neg2>:
    2b58:	70 95       	com	r23
    2b5a:	61 95       	neg	r22
    2b5c:	7f 4f       	sbci	r23, 0xFF	; 255

00002b5e <__divmodhi4_exit>:
    2b5e:	08 95       	ret

00002b60 <__udivmodhi4>:
    2b60:	aa 1b       	sub	r26, r26
    2b62:	bb 1b       	sub	r27, r27
    2b64:	51 e1       	ldi	r21, 0x11	; 17
    2b66:	07 c0       	rjmp	.+14     	; 0x2b76 <__udivmodhi4_ep>

00002b68 <__udivmodhi4_loop>:
    2b68:	aa 1f       	adc	r26, r26
    2b6a:	bb 1f       	adc	r27, r27
    2b6c:	a6 17       	cp	r26, r22
    2b6e:	b7 07       	cpc	r27, r23
    2b70:	10 f0       	brcs	.+4      	; 0x2b76 <__udivmodhi4_ep>
    2b72:	a6 1b       	sub	r26, r22
    2b74:	b7 0b       	sbc	r27, r23

00002b76 <__udivmodhi4_ep>:
    2b76:	88 1f       	adc	r24, r24
    2b78:	99 1f       	adc	r25, r25
    2b7a:	5a 95       	dec	r21
    2b7c:	a9 f7       	brne	.-22     	; 0x2b68 <__udivmodhi4_loop>
    2b7e:	80 95       	com	r24
    2b80:	90 95       	com	r25
    2b82:	bc 01       	movw	r22, r24
    2b84:	cd 01       	movw	r24, r26
    2b86:	08 95       	ret

00002b88 <memcpy>:
    2b88:	fb 01       	movw	r30, r22
    2b8a:	dc 01       	movw	r26, r24
    2b8c:	02 c0       	rjmp	.+4      	; 0x2b92 <memcpy+0xa>
    2b8e:	01 90       	ld	r0, Z+
    2b90:	0d 92       	st	X+, r0
    2b92:	41 50       	subi	r20, 0x01	; 1
    2b94:	50 40       	sbci	r21, 0x00	; 0
    2b96:	d8 f7       	brcc	.-10     	; 0x2b8e <memcpy+0x6>
    2b98:	08 95       	ret

00002b9a <__itoa_ncheck>:
    2b9a:	bb 27       	eor	r27, r27
    2b9c:	4a 30       	cpi	r20, 0x0A	; 10
    2b9e:	31 f4       	brne	.+12     	; 0x2bac <__itoa_ncheck+0x12>
    2ba0:	99 23       	and	r25, r25
    2ba2:	22 f4       	brpl	.+8      	; 0x2bac <__itoa_ncheck+0x12>
    2ba4:	bd e2       	ldi	r27, 0x2D	; 45
    2ba6:	90 95       	com	r25
    2ba8:	81 95       	neg	r24
    2baa:	9f 4f       	sbci	r25, 0xFF	; 255
    2bac:	01 c0       	rjmp	.+2      	; 0x2bb0 <__utoa_common>

00002bae <__utoa_ncheck>:
    2bae:	bb 27       	eor	r27, r27

00002bb0 <__utoa_common>:
    2bb0:	fb 01       	movw	r30, r22
    2bb2:	55 27       	eor	r21, r21
    2bb4:	aa 27       	eor	r26, r26
    2bb6:	88 0f       	add	r24, r24
    2bb8:	99 1f       	adc	r25, r25
    2bba:	aa 1f       	adc	r26, r26
    2bbc:	a4 17       	cp	r26, r20
    2bbe:	10 f0       	brcs	.+4      	; 0x2bc4 <__utoa_common+0x14>
    2bc0:	a4 1b       	sub	r26, r20
    2bc2:	83 95       	inc	r24
    2bc4:	50 51       	subi	r21, 0x10	; 16
    2bc6:	b9 f7       	brne	.-18     	; 0x2bb6 <__utoa_common+0x6>
    2bc8:	a0 5d       	subi	r26, 0xD0	; 208
    2bca:	aa 33       	cpi	r26, 0x3A	; 58
    2bcc:	08 f0       	brcs	.+2      	; 0x2bd0 <__utoa_common+0x20>
    2bce:	a9 5d       	subi	r26, 0xD9	; 217
    2bd0:	a1 93       	st	Z+, r26
    2bd2:	00 97       	sbiw	r24, 0x00	; 0
    2bd4:	79 f7       	brne	.-34     	; 0x2bb4 <__utoa_common+0x4>
    2bd6:	b1 11       	cpse	r27, r1
    2bd8:	b1 93       	st	Z+, r27
    2bda:	11 92       	st	Z+, r1
    2bdc:	cb 01       	movw	r24, r22
    2bde:	00 c0       	rjmp	.+0      	; 0x2be0 <strrev>

00002be0 <strrev>:
    2be0:	dc 01       	movw	r26, r24
    2be2:	fc 01       	movw	r30, r24
    2be4:	67 2f       	mov	r22, r23
    2be6:	71 91       	ld	r23, Z+
    2be8:	77 23       	and	r23, r23
    2bea:	e1 f7       	brne	.-8      	; 0x2be4 <strrev+0x4>
    2bec:	32 97       	sbiw	r30, 0x02	; 2
    2bee:	04 c0       	rjmp	.+8      	; 0x2bf8 <strrev+0x18>
    2bf0:	7c 91       	ld	r23, X
    2bf2:	6d 93       	st	X+, r22
    2bf4:	70 83       	st	Z, r23
    2bf6:	62 91       	ld	r22, -Z
    2bf8:	ae 17       	cp	r26, r30
    2bfa:	bf 07       	cpc	r27, r31
    2bfc:	c8 f3       	brcs	.-14     	; 0x2bf0 <strrev+0x10>
    2bfe:	08 95       	ret

00002c00 <_exit>:
    2c00:	f8 94       	cli

00002c02 <__stop_program>:
    2c02:	ff cf       	rjmp	.-2      	; 0x2c02 <__stop_program>
