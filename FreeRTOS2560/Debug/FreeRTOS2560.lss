
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800200  00002c46  00002cda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000709  0080023e  0080023e  00002d18  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002d18  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000518  00000000  00000000  00002d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00005a5f  00000000  00000000  00003260  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000015c3  00000000  00000000  00008cbf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003608  00000000  00000000  0000a282  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000e40  00000000  00000000  0000d88c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001656  00000000  00000000  0000e6cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003cc7  00000000  00000000  0000fd22  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004b8  00000000  00000000  000139e9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	ed c3       	rjmp	.+2010   	; 0x800 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 78 09 	jmp	0x12f0	; 0x12f0 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	30 c6       	rjmp	.+3168   	; 0xcc6 <__vector_25>
      66:	00 00       	nop
      68:	9c c6       	rjmp	.+3384   	; 0xda2 <__vector_26>
      6a:	00 00       	nop
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	74 c4       	rjmp	.+2280   	; 0x95e <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e2 c5       	rjmp	.+3012   	; 0xc56 <__vector_36>
      92:	00 00       	nop
      94:	50 c6       	rjmp	.+3232   	; 0xd36 <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <__vector_29+0x2>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e6 e4       	ldi	r30, 0x46	; 70
     17e:	fc e2       	ldi	r31, 0x2C	; 44
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 33       	cpi	r26, 0x3E	; 62
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	ae e3       	ldi	r26, 0x3E	; 62
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a7 34       	cpi	r26, 0x47	; 71
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	18 d2       	rcall	.+1072   	; 0x5d2 <main>
     1a2:	0c 94 21 16 	jmp	0x2c42	; 0x2c42 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	11 d7       	rcall	.+3618   	; 0xfcc <myUSART_peekReceiveUSART1>
     1aa:	c8 2f       	mov	r28, r24
     1ac:	fd d6       	rcall	.+3578   	; 0xfa8 <myUSART_receiveHandShakeAck>
     1ae:	88 23       	and	r24, r24
     1b0:	19 f0       	breq	.+6      	; 0x1b8 <RPI_receiveTask+0x10>
     1b2:	bf d6       	rcall	.+3454   	; 0xf32 <myUSART_receiveUSART1>
     1b4:	ee d6       	rcall	.+3548   	; 0xf92 <myUSART_completeHandShake>
     1b6:	f8 cf       	rjmp	.-16     	; 0x1a8 <RPI_receiveTask>
     1b8:	8c 2f       	mov	r24, r28
     1ba:	02 d7       	rcall	.+3588   	; 0xfc0 <myUSART_receiveMessageACK>
     1bc:	88 23       	and	r24, r24
     1be:	11 f0       	breq	.+4      	; 0x1c4 <RPI_receiveTask+0x1c>
     1c0:	b8 d6       	rcall	.+3440   	; 0xf32 <myUSART_receiveUSART1>
     1c2:	f2 cf       	rjmp	.-28     	; 0x1a8 <RPI_receiveTask>
     1c4:	8c 2f       	mov	r24, r28
     1c6:	f6 d6       	rcall	.+3564   	; 0xfb4 <myUSART_receiveHandShakeStart>
     1c8:	88 23       	and	r24, r24
     1ca:	11 f0       	breq	.+4      	; 0x1d0 <RPI_receiveTask+0x28>
     1cc:	d3 d6       	rcall	.+3494   	; 0xf74 <myUSART_waitForHandshake>
     1ce:	ec cf       	rjmp	.-40     	; 0x1a8 <RPI_receiveTask>
     1d0:	b0 d6       	rcall	.+3424   	; 0xf32 <myUSART_receiveUSART1>
     1d2:	ea cf       	rjmp	.-44     	; 0x1a8 <RPI_receiveTask>

000001d4 <RPI_sendTask>:
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <RPI_sendTask+0x6>
     1da:	00 d0       	rcall	.+0      	; 0x1dc <RPI_sendTask+0x8>
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	20 e0       	ldi	r18, 0x00	; 0
     1e2:	4f ef       	ldi	r20, 0xFF	; 255
     1e4:	5f ef       	ldi	r21, 0xFF	; 255
     1e6:	be 01       	movw	r22, r28
     1e8:	6a 5f       	subi	r22, 0xFA	; 250
     1ea:	7f 4f       	sbci	r23, 0xFF	; 255
     1ec:	80 91 8f 08 	lds	r24, 0x088F
     1f0:	90 91 90 08 	lds	r25, 0x0890
     1f4:	0e 94 94 0b 	call	0x1728	; 0x1728 <xQueueGenericReceive>
     1f8:	8e 81       	ldd	r24, Y+6	; 0x06
     1fa:	80 5d       	subi	r24, 0xD0	; 208
     1fc:	67 d6       	rcall	.+3278   	; 0xecc <myUSART_transmitUSART1_c>
     1fe:	8a e0       	ldi	r24, 0x0A	; 10
     200:	65 d6       	rcall	.+3274   	; 0xecc <myUSART_transmitUSART1_c>
     202:	8e 81       	ldd	r24, Y+6	; 0x06
     204:	9f ef       	ldi	r25, 0xFF	; 255
     206:	98 0f       	add	r25, r24
     208:	9e 83       	std	Y+6, r25	; 0x06
     20a:	88 23       	and	r24, r24
     20c:	21 f1       	breq	.+72     	; 0x256 <RPI_sendTask+0x82>
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	4f ef       	ldi	r20, 0xFF	; 255
     212:	5f ef       	ldi	r21, 0xFF	; 255
     214:	be 01       	movw	r22, r28
     216:	6f 5f       	subi	r22, 0xFF	; 255
     218:	7f 4f       	sbci	r23, 0xFF	; 255
     21a:	80 91 91 08 	lds	r24, 0x0891
     21e:	90 91 92 08 	lds	r25, 0x0892
     222:	0e 94 94 0b 	call	0x1728	; 0x1728 <xQueueGenericReceive>
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	3a d6       	rcall	.+3188   	; 0xe9e <myUSART_transmitUSART0_c>
     22a:	89 81       	ldd	r24, Y+1	; 0x01
     22c:	4f d6       	rcall	.+3230   	; 0xecc <myUSART_transmitUSART1_c>
     22e:	86 e0       	ldi	r24, 0x06	; 6
     230:	92 e0       	ldi	r25, 0x02	; 2
     232:	71 d6       	rcall	.+3298   	; 0xf16 <myUSART_transmitUSART0>
     234:	ce 01       	movw	r24, r28
     236:	02 96       	adiw	r24, 0x02	; 2
     238:	6e d6       	rcall	.+3292   	; 0xf16 <myUSART_transmitUSART0>
     23a:	ce 01       	movw	r24, r28
     23c:	02 96       	adiw	r24, 0x02	; 2
     23e:	5d d6       	rcall	.+3258   	; 0xefa <myUSART_transmitUSART1>
     240:	8a e0       	ldi	r24, 0x0A	; 10
     242:	44 d6       	rcall	.+3208   	; 0xecc <myUSART_transmitUSART1_c>
     244:	89 e0       	ldi	r24, 0x09	; 9
     246:	92 e0       	ldi	r25, 0x02	; 2
     248:	66 d6       	rcall	.+3276   	; 0xf16 <myUSART_transmitUSART0>
     24a:	8e 81       	ldd	r24, Y+6	; 0x06
     24c:	9f ef       	ldi	r25, 0xFF	; 255
     24e:	98 0f       	add	r25, r24
     250:	9e 83       	std	Y+6, r25	; 0x06
     252:	81 11       	cpse	r24, r1
     254:	dc cf       	rjmp	.-72     	; 0x20e <RPI_sendTask+0x3a>
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	22 d6       	rcall	.+3140   	; 0xe9e <myUSART_transmitUSART0_c>
     25a:	c2 cf       	rjmp	.-124    	; 0x1e0 <RPI_sendTask+0xc>

0000025c <myTimerTask>:
     25c:	4d d4       	rcall	.+2202   	; 0xaf8 <myTimer_Init>
     25e:	8c d4       	rcall	.+2328   	; 0xb78 <myTimer_DelayChecker>
     260:	fe cf       	rjmp	.-4      	; 0x25e <myTimerTask+0x2>

00000262 <task1>:
     262:	26 9a       	sbi	0x04, 6	; 4
     264:	2e 9a       	sbi	0x05, 6	; 5
     266:	88 ee       	ldi	r24, 0xE8	; 232
     268:	93 e0       	ldi	r25, 0x03	; 3
     26a:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskDelay>
     26e:	85 b1       	in	r24, 0x05	; 5
     270:	15 b8       	out	0x05, r1	; 5
     272:	88 ee       	ldi	r24, 0xE8	; 232
     274:	93 e0       	ldi	r25, 0x03	; 3
     276:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskDelay>
     27a:	f4 cf       	rjmp	.-24     	; 0x264 <task1+0x2>

0000027c <checkWithinRange>:
     27c:	fb 01       	movw	r30, r22
     27e:	20 81       	ld	r18, Z
     280:	31 81       	ldd	r19, Z+1	; 0x01
     282:	50 e0       	ldi	r21, 0x00	; 0
     284:	b9 01       	movw	r22, r18
     286:	64 0f       	add	r22, r20
     288:	75 1f       	adc	r23, r21
     28a:	68 17       	cp	r22, r24
     28c:	79 07       	cpc	r23, r25
     28e:	4c f0       	brlt	.+18     	; 0x2a2 <checkWithinRange+0x26>
     290:	24 1b       	sub	r18, r20
     292:	35 0b       	sbc	r19, r21
     294:	41 e0       	ldi	r20, 0x01	; 1
     296:	82 17       	cp	r24, r18
     298:	93 07       	cpc	r25, r19
     29a:	0c f0       	brlt	.+2      	; 0x29e <checkWithinRange+0x22>
     29c:	40 e0       	ldi	r20, 0x00	; 0
     29e:	84 2f       	mov	r24, r20
     2a0:	08 95       	ret
     2a2:	81 e0       	ldi	r24, 0x01	; 1
     2a4:	08 95       	ret

000002a6 <activeCalibration>:
     2a6:	0f 93       	push	r16
     2a8:	1f 93       	push	r17
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	8c 01       	movw	r16, r24
     2b0:	eb 01       	movw	r28, r22
     2b2:	45 e0       	ldi	r20, 0x05	; 5
     2b4:	bc 01       	movw	r22, r24
     2b6:	ce 01       	movw	r24, r28
     2b8:	e1 df       	rcall	.-62     	; 0x27c <checkWithinRange>
     2ba:	88 23       	and	r24, r24
     2bc:	41 f0       	breq	.+16     	; 0x2ce <activeCalibration+0x28>
     2be:	20 91 42 02 	lds	r18, 0x0242
     2c2:	30 91 43 02 	lds	r19, 0x0243
     2c6:	21 15       	cp	r18, r1
     2c8:	31 05       	cpc	r19, r1
     2ca:	69 f4       	brne	.+26     	; 0x2e6 <activeCalibration+0x40>
     2cc:	4b c0       	rjmp	.+150    	; 0x364 <activeCalibration+0xbe>
     2ce:	20 91 42 02 	lds	r18, 0x0242
     2d2:	30 91 43 02 	lds	r19, 0x0243
     2d6:	21 15       	cp	r18, r1
     2d8:	31 05       	cpc	r19, r1
     2da:	29 f4       	brne	.+10     	; 0x2e6 <activeCalibration+0x40>
     2dc:	d0 93 3f 02 	sts	0x023F, r29
     2e0:	c0 93 3e 02 	sts	0x023E, r28
     2e4:	32 c0       	rjmp	.+100    	; 0x34a <activeCalibration+0xa4>
     2e6:	2a 30       	cpi	r18, 0x0A	; 10
     2e8:	31 05       	cpc	r19, r1
     2ea:	a9 f4       	brne	.+42     	; 0x316 <activeCalibration+0x70>
     2ec:	45 e0       	ldi	r20, 0x05	; 5
     2ee:	6e e3       	ldi	r22, 0x3E	; 62
     2f0:	72 e0       	ldi	r23, 0x02	; 2
     2f2:	ce 01       	movw	r24, r28
     2f4:	c3 df       	rcall	.-122    	; 0x27c <checkWithinRange>
     2f6:	88 23       	and	r24, r24
     2f8:	49 f0       	breq	.+18     	; 0x30c <activeCalibration+0x66>
     2fa:	d0 93 3f 02 	sts	0x023F, r29
     2fe:	c0 93 3e 02 	sts	0x023E, r28
     302:	10 92 43 02 	sts	0x0243, r1
     306:	10 92 42 02 	sts	0x0242, r1
     30a:	1f c0       	rjmp	.+62     	; 0x34a <activeCalibration+0xa4>
     30c:	d0 93 41 02 	sts	0x0241, r29
     310:	c0 93 40 02 	sts	0x0240, r28
     314:	1a c0       	rjmp	.+52     	; 0x34a <activeCalibration+0xa4>
     316:	24 31       	cpi	r18, 0x14	; 20
     318:	31 05       	cpc	r19, r1
     31a:	b9 f4       	brne	.+46     	; 0x34a <activeCalibration+0xa4>
     31c:	10 92 43 02 	sts	0x0243, r1
     320:	10 92 42 02 	sts	0x0242, r1
     324:	45 e0       	ldi	r20, 0x05	; 5
     326:	6e e3       	ldi	r22, 0x3E	; 62
     328:	72 e0       	ldi	r23, 0x02	; 2
     32a:	ce 01       	movw	r24, r28
     32c:	a7 df       	rcall	.-178    	; 0x27c <checkWithinRange>
     32e:	88 23       	and	r24, r24
     330:	29 f0       	breq	.+10     	; 0x33c <activeCalibration+0x96>
     332:	d0 93 3f 02 	sts	0x023F, r29
     336:	c0 93 3e 02 	sts	0x023E, r28
     33a:	07 c0       	rjmp	.+14     	; 0x34a <activeCalibration+0xa4>
     33c:	80 91 3e 02 	lds	r24, 0x023E
     340:	90 91 3f 02 	lds	r25, 0x023F
     344:	f8 01       	movw	r30, r16
     346:	91 83       	std	Z+1, r25	; 0x01
     348:	80 83       	st	Z, r24
     34a:	80 91 42 02 	lds	r24, 0x0242
     34e:	90 91 43 02 	lds	r25, 0x0243
     352:	01 96       	adiw	r24, 0x01	; 1
     354:	64 e1       	ldi	r22, 0x14	; 20
     356:	70 e0       	ldi	r23, 0x00	; 0
     358:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <__divmodhi4>
     35c:	90 93 43 02 	sts	0x0243, r25
     360:	80 93 42 02 	sts	0x0242, r24
     364:	df 91       	pop	r29
     366:	cf 91       	pop	r28
     368:	1f 91       	pop	r17
     36a:	0f 91       	pop	r16
     36c:	08 95       	ret

0000036e <obstacleSend>:
     36e:	1f 93       	push	r17
     370:	cf 93       	push	r28
     372:	df 93       	push	r29
     374:	00 d0       	rcall	.+0      	; 0x376 <obstacleSend+0x8>
     376:	1f 92       	push	r1
     378:	1f 92       	push	r1
     37a:	cd b7       	in	r28, 0x3d	; 61
     37c:	de b7       	in	r29, 0x3e	; 62
     37e:	18 2f       	mov	r17, r24
     380:	cb 01       	movw	r24, r22
     382:	11 23       	and	r17, r17
     384:	99 f0       	breq	.+38     	; 0x3ac <obstacleSend+0x3e>
     386:	4a e0       	ldi	r20, 0x0A	; 10
     388:	be 01       	movw	r22, r28
     38a:	6e 5f       	subi	r22, 0xFE	; 254
     38c:	7f 4f       	sbci	r23, 0xFF	; 255
     38e:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <__itoa_ncheck>
     392:	19 83       	std	Y+1, r17	; 0x01
     394:	20 e0       	ldi	r18, 0x00	; 0
     396:	4f ef       	ldi	r20, 0xFF	; 255
     398:	5f ef       	ldi	r21, 0xFF	; 255
     39a:	be 01       	movw	r22, r28
     39c:	6f 5f       	subi	r22, 0xFF	; 255
     39e:	7f 4f       	sbci	r23, 0xFF	; 255
     3a0:	80 91 91 08 	lds	r24, 0x0891
     3a4:	90 91 92 08 	lds	r25, 0x0892
     3a8:	0e 94 9f 0a 	call	0x153e	; 0x153e <xQueueGenericSend>
     3ac:	0f 90       	pop	r0
     3ae:	0f 90       	pop	r0
     3b0:	0f 90       	pop	r0
     3b2:	0f 90       	pop	r0
     3b4:	0f 90       	pop	r0
     3b6:	df 91       	pop	r29
     3b8:	cf 91       	pop	r28
     3ba:	1f 91       	pop	r17
     3bc:	08 95       	ret

000003be <detectStairs>:
     3be:	9c 01       	movw	r18, r24
     3c0:	21 5f       	subi	r18, 0xF1	; 241
     3c2:	3f 4f       	sbci	r19, 0xFF	; 255
     3c4:	26 17       	cp	r18, r22
     3c6:	37 07       	cpc	r19, r23
     3c8:	44 f0       	brlt	.+16     	; 0x3da <detectStairs+0x1c>
     3ca:	2e 51       	subi	r18, 0x1E	; 30
     3cc:	31 09       	sbc	r19, r1
     3ce:	81 e0       	ldi	r24, 0x01	; 1
     3d0:	62 17       	cp	r22, r18
     3d2:	73 07       	cpc	r23, r19
     3d4:	1c f0       	brlt	.+6      	; 0x3dc <detectStairs+0x1e>
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	08 95       	ret
     3da:	81 e0       	ldi	r24, 0x01	; 1
     3dc:	08 95       	ret

000003de <obstacleDetection>:
     3de:	0f 93       	push	r16
     3e0:	1f 93       	push	r17
     3e2:	86 34       	cpi	r24, 0x46	; 70
     3e4:	91 05       	cpc	r25, r1
     3e6:	1c f5       	brge	.+70     	; 0x42e <obstacleDetection+0x50>
     3e8:	6d 32       	cpi	r22, 0x2D	; 45
     3ea:	71 05       	cpc	r23, r1
     3ec:	54 f4       	brge	.+20     	; 0x402 <obstacleDetection+0x24>
     3ee:	4d 32       	cpi	r20, 0x2D	; 45
     3f0:	51 05       	cpc	r21, r1
     3f2:	3c f4       	brge	.+14     	; 0x402 <obstacleDetection+0x24>
     3f4:	74 9a       	sbi	0x0e, 4	; 14
     3f6:	e2 e0       	ldi	r30, 0x02	; 2
     3f8:	f1 e0       	ldi	r31, 0x01	; 1
     3fa:	80 81       	ld	r24, Z
     3fc:	80 61       	ori	r24, 0x10	; 16
     3fe:	80 83       	st	Z, r24
     400:	42 c0       	rjmp	.+132    	; 0x486 <obstacleDetection+0xa8>
     402:	66 5f       	subi	r22, 0xF6	; 246
     404:	7f 4f       	sbci	r23, 0xFF	; 255
     406:	46 17       	cp	r20, r22
     408:	57 07       	cpc	r21, r23
     40a:	3c f4       	brge	.+14     	; 0x41a <obstacleDetection+0x3c>
     40c:	e2 e0       	ldi	r30, 0x02	; 2
     40e:	f1 e0       	ldi	r31, 0x01	; 1
     410:	80 81       	ld	r24, Z
     412:	8f 7e       	andi	r24, 0xEF	; 239
     414:	80 83       	st	Z, r24
     416:	74 9a       	sbi	0x0e, 4	; 14
     418:	36 c0       	rjmp	.+108    	; 0x486 <obstacleDetection+0xa8>
     41a:	64 17       	cp	r22, r20
     41c:	75 07       	cpc	r23, r21
     41e:	9c f5       	brge	.+102    	; 0x486 <obstacleDetection+0xa8>
     420:	74 98       	cbi	0x0e, 4	; 14
     422:	e2 e0       	ldi	r30, 0x02	; 2
     424:	f1 e0       	ldi	r31, 0x01	; 1
     426:	80 81       	ld	r24, Z
     428:	80 61       	ori	r24, 0x10	; 16
     42a:	80 83       	st	Z, r24
     42c:	2c c0       	rjmp	.+88     	; 0x486 <obstacleDetection+0xa8>
     42e:	4e 31       	cpi	r20, 0x1E	; 30
     430:	51 05       	cpc	r21, r1
     432:	54 f4       	brge	.+20     	; 0x448 <obstacleDetection+0x6a>
     434:	6f 31       	cpi	r22, 0x1F	; 31
     436:	71 05       	cpc	r23, r1
     438:	3c f0       	brlt	.+14     	; 0x448 <obstacleDetection+0x6a>
     43a:	e2 e0       	ldi	r30, 0x02	; 2
     43c:	f1 e0       	ldi	r31, 0x01	; 1
     43e:	80 81       	ld	r24, Z
     440:	8f 7e       	andi	r24, 0xEF	; 239
     442:	80 83       	st	Z, r24
     444:	74 9a       	sbi	0x0e, 4	; 14
     446:	1f c0       	rjmp	.+62     	; 0x486 <obstacleDetection+0xa8>
     448:	6e 31       	cpi	r22, 0x1E	; 30
     44a:	71 05       	cpc	r23, r1
     44c:	54 f4       	brge	.+20     	; 0x462 <obstacleDetection+0x84>
     44e:	4f 31       	cpi	r20, 0x1F	; 31
     450:	51 05       	cpc	r21, r1
     452:	3c f0       	brlt	.+14     	; 0x462 <obstacleDetection+0x84>
     454:	e2 e0       	ldi	r30, 0x02	; 2
     456:	f1 e0       	ldi	r31, 0x01	; 1
     458:	80 81       	ld	r24, Z
     45a:	80 61       	ori	r24, 0x10	; 16
     45c:	80 83       	st	Z, r24
     45e:	74 98       	cbi	0x0e, 4	; 14
     460:	12 c0       	rjmp	.+36     	; 0x486 <obstacleDetection+0xa8>
     462:	b9 01       	movw	r22, r18
     464:	c8 01       	movw	r24, r16
     466:	ab df       	rcall	.-170    	; 0x3be <detectStairs>
     468:	88 23       	and	r24, r24
     46a:	39 f0       	breq	.+14     	; 0x47a <obstacleDetection+0x9c>
     46c:	74 9a       	sbi	0x0e, 4	; 14
     46e:	e2 e0       	ldi	r30, 0x02	; 2
     470:	f1 e0       	ldi	r31, 0x01	; 1
     472:	80 81       	ld	r24, Z
     474:	80 61       	ori	r24, 0x10	; 16
     476:	80 83       	st	Z, r24
     478:	06 c0       	rjmp	.+12     	; 0x486 <obstacleDetection+0xa8>
     47a:	e2 e0       	ldi	r30, 0x02	; 2
     47c:	f1 e0       	ldi	r31, 0x01	; 1
     47e:	80 81       	ld	r24, Z
     480:	8f 7e       	andi	r24, 0xEF	; 239
     482:	80 83       	st	Z, r24
     484:	74 98       	cbi	0x0e, 4	; 14
     486:	1f 91       	pop	r17
     488:	0f 91       	pop	r16
     48a:	08 95       	ret

0000048c <Sonar_Task>:
     48c:	cf 93       	push	r28
     48e:	df 93       	push	r29
     490:	00 d0       	rcall	.+0      	; 0x492 <Sonar_Task+0x6>
     492:	1f 92       	push	r1
     494:	1f 92       	push	r1
     496:	cd b7       	in	r28, 0x3d	; 61
     498:	de b7       	in	r29, 0x3e	; 62
     49a:	1b 82       	std	Y+3, r1	; 0x03
     49c:	84 e2       	ldi	r24, 0x24	; 36
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	07 d3       	rcall	.+1550   	; 0xab0 <mySharpIR_Read>
     4a2:	9d 83       	std	Y+5, r25	; 0x05
     4a4:	8c 83       	std	Y+4, r24	; 0x04
     4a6:	0e 94 75 0e 	call	0x1cea	; 0x1cea <xTaskGetTickCount>
     4aa:	9a 83       	std	Y+2, r25	; 0x02
     4ac:	89 83       	std	Y+1, r24	; 0x01
     4ae:	47 d2       	rcall	.+1166   	; 0x93e <myMaxSonar_Start>
     4b0:	87 e2       	ldi	r24, 0x27	; 39
     4b2:	4b d2       	rcall	.+1174   	; 0x94a <myMaxSonar_Read>
     4b4:	4c 01       	movw	r8, r24
     4b6:	86 e2       	ldi	r24, 0x26	; 38
     4b8:	48 d2       	rcall	.+1168   	; 0x94a <myMaxSonar_Read>
     4ba:	5c 01       	movw	r10, r24
     4bc:	85 e2       	ldi	r24, 0x25	; 37
     4be:	45 d2       	rcall	.+1162   	; 0x94a <myMaxSonar_Read>
     4c0:	6c 01       	movw	r12, r24
     4c2:	84 e2       	ldi	r24, 0x24	; 36
     4c4:	90 e0       	ldi	r25, 0x00	; 0
     4c6:	f4 d2       	rcall	.+1512   	; 0xab0 <mySharpIR_Read>
     4c8:	7c 01       	movw	r14, r24
     4ca:	bc 01       	movw	r22, r24
     4cc:	ce 01       	movw	r24, r28
     4ce:	04 96       	adiw	r24, 0x04	; 4
     4d0:	ea de       	rcall	.-556    	; 0x2a6 <activeCalibration>
     4d2:	0c 81       	ldd	r16, Y+4	; 0x04
     4d4:	1d 81       	ldd	r17, Y+5	; 0x05
     4d6:	97 01       	movw	r18, r14
     4d8:	a6 01       	movw	r20, r12
     4da:	b5 01       	movw	r22, r10
     4dc:	c4 01       	movw	r24, r8
     4de:	7f df       	rcall	.-258    	; 0x3de <obstacleDetection>
     4e0:	8b 81       	ldd	r24, Y+3	; 0x03
     4e2:	8c 5f       	subi	r24, 0xFC	; 252
     4e4:	8b 83       	std	Y+3, r24	; 0x03
     4e6:	20 e0       	ldi	r18, 0x00	; 0
     4e8:	4f ef       	ldi	r20, 0xFF	; 255
     4ea:	5f ef       	ldi	r21, 0xFF	; 255
     4ec:	be 01       	movw	r22, r28
     4ee:	6d 5f       	subi	r22, 0xFD	; 253
     4f0:	7f 4f       	sbci	r23, 0xFF	; 255
     4f2:	80 91 8f 08 	lds	r24, 0x088F
     4f6:	90 91 90 08 	lds	r25, 0x0890
     4fa:	0e 94 9f 0a 	call	0x153e	; 0x153e <xQueueGenericSend>
     4fe:	b4 01       	movw	r22, r8
     500:	86 e4       	ldi	r24, 0x46	; 70
     502:	35 df       	rcall	.-406    	; 0x36e <obstacleSend>
     504:	b5 01       	movw	r22, r10
     506:	8c e4       	ldi	r24, 0x4C	; 76
     508:	32 df       	rcall	.-412    	; 0x36e <obstacleSend>
     50a:	b6 01       	movw	r22, r12
     50c:	82 e5       	ldi	r24, 0x52	; 82
     50e:	2f df       	rcall	.-418    	; 0x36e <obstacleSend>
     510:	b7 01       	movw	r22, r14
     512:	82 e4       	ldi	r24, 0x42	; 66
     514:	2c df       	rcall	.-424    	; 0x36e <obstacleSend>
     516:	1b 82       	std	Y+3, r1	; 0x03
     518:	66 e9       	ldi	r22, 0x96	; 150
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	ce 01       	movw	r24, r28
     51e:	01 96       	adiw	r24, 0x01	; 1
     520:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <vTaskDelayUntil>
     524:	c4 cf       	rjmp	.-120    	; 0x4ae <Sonar_Task+0x22>

00000526 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     526:	8f ef       	ldi	r24, 0xFF	; 255
     528:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     52c:	ef e7       	ldi	r30, 0x7F	; 127
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	90 81       	ld	r25, Z
     532:	93 60       	ori	r25, 0x03	; 3
     534:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     536:	80 93 7d 00 	sts	0x007D, r24
     53a:	08 95       	ret

0000053c <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     53c:	8c ec       	ldi	r24, 0xCC	; 204
     53e:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     542:	8e e3       	ldi	r24, 0x3E	; 62
     544:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     548:	ee cf       	rjmp	.-36     	; 0x526 <setDigitalInputPowerReduction>
     54a:	08 95       	ret

0000054c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     54c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     550:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     554:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     558:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     55c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     560:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     564:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     568:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     56c:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     570:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     574:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     578:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     57c:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     580:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     584:	10 92 73 00 	sts	0x0073, r1
     588:	08 95       	ret

0000058a <init>:
}

void init()
{
     58a:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     58c:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     58e:	f8 94       	cli
	{
		clearTimer();
     590:	dd df       	rcall	.-70     	; 0x54c <clearTimer>
		setPowerReduction();
     592:	d4 df       	rcall	.-88     	; 0x53c <setPowerReduction>
		myUSART_USART0_Init();
     594:	3c d4       	rcall	.+2168   	; 0xe0e <myUSART_USART0_Init>
		myUSART_USART1_Init();
     596:	5b d4       	rcall	.+2230   	; 0xe4e <myUSART_USART1_Init>
		myADC_Init();
     598:	1a d2       	rcall	.+1076   	; 0x9ce <myADC_Init>
		MaxSonar_Init();
     59a:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     59c:	bb d1       	rcall	.+886    	; 0x914 <myHcSonar_Init>
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	61 e0       	ldi	r22, 0x01	; 1
     5a2:	85 e0       	ldi	r24, 0x05	; 5
     5a4:	a2 d7       	rcall	.+3908   	; 0x14ea <xQueueGenericCreate>
     5a6:	90 93 90 08 	sts	0x0890, r25
     5aa:	80 93 8f 08 	sts	0x088F, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SONAR_NUM), sizeof (obstacleData)); // create queue
     5ae:	40 e0       	ldi	r20, 0x00	; 0
     5b0:	65 e0       	ldi	r22, 0x05	; 5
     5b2:	84 e1       	ldi	r24, 0x14	; 20
     5b4:	9a d7       	rcall	.+3892   	; 0x14ea <xQueueGenericCreate>
     5b6:	90 93 92 08 	sts	0x0892, r25
     5ba:	80 93 91 08 	sts	0x0891, r24
		
		DDRE |= (1 << DDE4) ; // E4 => digitial pin 2 (LEFT)
     5be:	6c 9a       	sbi	0x0d, 4	; 13
		DDRH |= (1 << DDH4) ; // H4 => digital pin 7 (RIGHT)
     5c0:	e1 e0       	ldi	r30, 0x01	; 1
     5c2:	f1 e0       	ldi	r31, 0x01	; 1
     5c4:	80 81       	ld	r24, Z
     5c6:	80 61       	ori	r24, 0x10	; 16
     5c8:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     5ca:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     5cc:	78 94       	sei
}
     5ce:	cf 91       	pop	r28
     5d0:	08 95       	ret

000005d2 <main>:
	
	// do nth
}

int main(void)
{
     5d2:	cf 93       	push	r28
     5d4:	df 93       	push	r29
     5d6:	cd b7       	in	r28, 0x3d	; 61
     5d8:	de b7       	in	r29, 0x3e	; 62
     5da:	2a 97       	sbiw	r28, 0x0a	; 10
     5dc:	0f b6       	in	r0, 0x3f	; 63
     5de:	f8 94       	cli
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	0f be       	out	0x3f, r0	; 63
     5e4:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay, t1;
	
		init();
     5e6:	d1 df       	rcall	.-94     	; 0x58a <init>

		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     5e8:	a1 2c       	mov	r10, r1
     5ea:	b1 2c       	mov	r11, r1
     5ec:	c1 2c       	mov	r12, r1
     5ee:	d1 2c       	mov	r13, r1
     5f0:	ce 01       	movw	r24, r28
     5f2:	01 96       	adiw	r24, 0x01	; 1
     5f4:	7c 01       	movw	r14, r24
     5f6:	01 e0       	ldi	r16, 0x01	; 1
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	45 e5       	ldi	r20, 0x55	; 85
     5fe:	50 e0       	ldi	r21, 0x00	; 0
     600:	6c e0       	ldi	r22, 0x0C	; 12
     602:	72 e0       	ldi	r23, 0x02	; 2
     604:	81 e3       	ldi	r24, 0x31	; 49
     606:	91 e0       	ldi	r25, 0x01	; 1
     608:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xTaskGenericCreate>
		//xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     60c:	ce 01       	movw	r24, r28
     60e:	03 96       	adiw	r24, 0x03	; 3
     610:	7c 01       	movw	r14, r24
     612:	04 e0       	ldi	r16, 0x04	; 4
     614:	9c 01       	movw	r18, r24
     616:	49 e6       	ldi	r20, 0x69	; 105
     618:	50 e0       	ldi	r21, 0x00	; 0
     61a:	63 e1       	ldi	r22, 0x13	; 19
     61c:	72 e0       	ldi	r23, 0x02	; 2
     61e:	8e e2       	ldi	r24, 0x2E	; 46
     620:	91 e0       	ldi	r25, 0x01	; 1
     622:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     626:	ce 01       	movw	r24, r28
     628:	09 96       	adiw	r24, 0x09	; 9
     62a:	7c 01       	movw	r14, r24
     62c:	02 e0       	ldi	r16, 0x02	; 2
     62e:	20 e0       	ldi	r18, 0x00	; 0
     630:	30 e0       	ldi	r19, 0x00	; 0
     632:	4f e4       	ldi	r20, 0x4F	; 79
     634:	51 e0       	ldi	r21, 0x01	; 1
     636:	6b e1       	ldi	r22, 0x1B	; 27
     638:	72 e0       	ldi	r23, 0x02	; 2
     63a:	86 e4       	ldi	r24, 0x46	; 70
     63c:	92 e0       	ldi	r25, 0x02	; 2
     63e:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     642:	ce 01       	movw	r24, r28
     644:	07 96       	adiw	r24, 0x07	; 7
     646:	7c 01       	movw	r14, r24
     648:	03 e0       	ldi	r16, 0x03	; 3
     64a:	20 e0       	ldi	r18, 0x00	; 0
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	47 e8       	ldi	r20, 0x87	; 135
     650:	50 e0       	ldi	r21, 0x00	; 0
     652:	64 e2       	ldi	r22, 0x24	; 36
     654:	72 e0       	ldi	r23, 0x02	; 2
     656:	84 ed       	ldi	r24, 0xD4	; 212
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     65e:	ce 01       	movw	r24, r28
     660:	05 96       	adiw	r24, 0x05	; 5
     662:	7c 01       	movw	r14, r24
     664:	01 e0       	ldi	r16, 0x01	; 1
     666:	20 e0       	ldi	r18, 0x00	; 0
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	47 e8       	ldi	r20, 0x87	; 135
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	60 e3       	ldi	r22, 0x30	; 48
     670:	72 e0       	ldi	r23, 0x02	; 2
     672:	8a ee       	ldi	r24, 0xEA	; 234
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	0e 94 e6 0c 	call	0x19cc	; 0x19cc <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     67a:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <vTaskStartScheduler>
     67e:	b3 cf       	rjmp	.-154    	; 0x5e6 <main+0x14>

00000680 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     680:	cf 93       	push	r28
     682:	df 93       	push	r29
     684:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     686:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     68a:	80 91 44 02 	lds	r24, 0x0244
     68e:	90 91 45 02 	lds	r25, 0x0245
     692:	89 2b       	or	r24, r25
     694:	31 f4       	brne	.+12     	; 0x6a2 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     696:	89 e4       	ldi	r24, 0x49	; 73
     698:	92 e0       	ldi	r25, 0x02	; 2
     69a:	90 93 45 02 	sts	0x0245, r25
     69e:	80 93 44 02 	sts	0x0244, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6a2:	40 91 46 02 	lds	r20, 0x0246
     6a6:	50 91 47 02 	lds	r21, 0x0247
     6aa:	9e 01       	movw	r18, r28
     6ac:	24 0f       	add	r18, r20
     6ae:	35 1f       	adc	r19, r21
     6b0:	2b 3d       	cpi	r18, 0xDB	; 219
     6b2:	85 e0       	ldi	r24, 0x05	; 5
     6b4:	38 07       	cpc	r19, r24
     6b6:	70 f4       	brcc	.+28     	; 0x6d4 <pvPortMalloc+0x54>
     6b8:	42 17       	cp	r20, r18
     6ba:	53 07       	cpc	r21, r19
     6bc:	70 f4       	brcc	.+28     	; 0x6da <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     6be:	c0 91 44 02 	lds	r28, 0x0244
     6c2:	d0 91 45 02 	lds	r29, 0x0245
     6c6:	c4 0f       	add	r28, r20
     6c8:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     6ca:	30 93 47 02 	sts	0x0247, r19
     6ce:	20 93 46 02 	sts	0x0246, r18
     6d2:	05 c0       	rjmp	.+10     	; 0x6de <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6d4:	c0 e0       	ldi	r28, 0x00	; 0
     6d6:	d0 e0       	ldi	r29, 0x00	; 0
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <pvPortMalloc+0x5e>
     6da:	c0 e0       	ldi	r28, 0x00	; 0
     6dc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6de:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6e2:	ce 01       	movw	r24, r28
     6e4:	df 91       	pop	r29
     6e6:	cf 91       	pop	r28
     6e8:	08 95       	ret

000006ea <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ea:	08 95       	ret

000006ec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6ec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ee:	03 96       	adiw	r24, 0x03	; 3
     6f0:	92 83       	std	Z+2, r25	; 0x02
     6f2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6f4:	2f ef       	ldi	r18, 0xFF	; 255
     6f6:	3f ef       	ldi	r19, 0xFF	; 255
     6f8:	34 83       	std	Z+4, r19	; 0x04
     6fa:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6fc:	96 83       	std	Z+6, r25	; 0x06
     6fe:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     700:	90 87       	std	Z+8, r25	; 0x08
     702:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     704:	10 82       	st	Z, r1
     706:	08 95       	ret

00000708 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     708:	fc 01       	movw	r30, r24
     70a:	11 86       	std	Z+9, r1	; 0x09
     70c:	10 86       	std	Z+8, r1	; 0x08
     70e:	08 95       	ret

00000710 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	9c 01       	movw	r18, r24
     716:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     718:	dc 01       	movw	r26, r24
     71a:	11 96       	adiw	r26, 0x01	; 1
     71c:	cd 91       	ld	r28, X+
     71e:	dc 91       	ld	r29, X
     720:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     722:	d3 83       	std	Z+3, r29	; 0x03
     724:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     726:	8c 81       	ldd	r24, Y+4	; 0x04
     728:	9d 81       	ldd	r25, Y+5	; 0x05
     72a:	95 83       	std	Z+5, r25	; 0x05
     72c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     72e:	8c 81       	ldd	r24, Y+4	; 0x04
     730:	9d 81       	ldd	r25, Y+5	; 0x05
     732:	dc 01       	movw	r26, r24
     734:	13 96       	adiw	r26, 0x03	; 3
     736:	7c 93       	st	X, r23
     738:	6e 93       	st	-X, r22
     73a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     73c:	7d 83       	std	Y+5, r23	; 0x05
     73e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     740:	31 87       	std	Z+9, r19	; 0x09
     742:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     744:	f9 01       	movw	r30, r18
     746:	80 81       	ld	r24, Z
     748:	8f 5f       	subi	r24, 0xFF	; 255
     74a:	80 83       	st	Z, r24
}
     74c:	df 91       	pop	r29
     74e:	cf 91       	pop	r28
     750:	08 95       	ret

00000752 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     752:	cf 93       	push	r28
     754:	df 93       	push	r29
     756:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     758:	48 81       	ld	r20, Y
     75a:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     75c:	4f 3f       	cpi	r20, 0xFF	; 255
     75e:	2f ef       	ldi	r18, 0xFF	; 255
     760:	52 07       	cpc	r21, r18
     762:	21 f4       	brne	.+8      	; 0x76c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     764:	fc 01       	movw	r30, r24
     766:	a7 81       	ldd	r26, Z+7	; 0x07
     768:	b0 85       	ldd	r27, Z+8	; 0x08
     76a:	0d c0       	rjmp	.+26     	; 0x786 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     76c:	dc 01       	movw	r26, r24
     76e:	13 96       	adiw	r26, 0x03	; 3
     770:	12 96       	adiw	r26, 0x02	; 2
     772:	ed 91       	ld	r30, X+
     774:	fc 91       	ld	r31, X
     776:	13 97       	sbiw	r26, 0x03	; 3
     778:	20 81       	ld	r18, Z
     77a:	31 81       	ldd	r19, Z+1	; 0x01
     77c:	42 17       	cp	r20, r18
     77e:	53 07       	cpc	r21, r19
     780:	10 f0       	brcs	.+4      	; 0x786 <vListInsert+0x34>
     782:	df 01       	movw	r26, r30
     784:	f5 cf       	rjmp	.-22     	; 0x770 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     786:	12 96       	adiw	r26, 0x02	; 2
     788:	ed 91       	ld	r30, X+
     78a:	fc 91       	ld	r31, X
     78c:	13 97       	sbiw	r26, 0x03	; 3
     78e:	fb 83       	std	Y+3, r31	; 0x03
     790:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     792:	d5 83       	std	Z+5, r29	; 0x05
     794:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     796:	bd 83       	std	Y+5, r27	; 0x05
     798:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     79a:	13 96       	adiw	r26, 0x03	; 3
     79c:	dc 93       	st	X, r29
     79e:	ce 93       	st	-X, r28
     7a0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7a2:	99 87       	std	Y+9, r25	; 0x09
     7a4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     7a6:	fc 01       	movw	r30, r24
     7a8:	20 81       	ld	r18, Z
     7aa:	2f 5f       	subi	r18, 0xFF	; 255
     7ac:	20 83       	st	Z, r18
}
     7ae:	df 91       	pop	r29
     7b0:	cf 91       	pop	r28
     7b2:	08 95       	ret

000007b4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     7ba:	a0 85       	ldd	r26, Z+8	; 0x08
     7bc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7be:	c2 81       	ldd	r28, Z+2	; 0x02
     7c0:	d3 81       	ldd	r29, Z+3	; 0x03
     7c2:	84 81       	ldd	r24, Z+4	; 0x04
     7c4:	95 81       	ldd	r25, Z+5	; 0x05
     7c6:	9d 83       	std	Y+5, r25	; 0x05
     7c8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7ca:	c4 81       	ldd	r28, Z+4	; 0x04
     7cc:	d5 81       	ldd	r29, Z+5	; 0x05
     7ce:	82 81       	ldd	r24, Z+2	; 0x02
     7d0:	93 81       	ldd	r25, Z+3	; 0x03
     7d2:	9b 83       	std	Y+3, r25	; 0x03
     7d4:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7d6:	11 96       	adiw	r26, 0x01	; 1
     7d8:	cd 91       	ld	r28, X+
     7da:	dc 91       	ld	r29, X
     7dc:	12 97       	sbiw	r26, 0x02	; 2
     7de:	ce 17       	cp	r28, r30
     7e0:	df 07       	cpc	r29, r31
     7e2:	31 f4       	brne	.+12     	; 0x7f0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7e4:	8c 81       	ldd	r24, Y+4	; 0x04
     7e6:	9d 81       	ldd	r25, Y+5	; 0x05
     7e8:	12 96       	adiw	r26, 0x02	; 2
     7ea:	9c 93       	st	X, r25
     7ec:	8e 93       	st	-X, r24
     7ee:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7f0:	11 86       	std	Z+9, r1	; 0x09
     7f2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7f4:	8c 91       	ld	r24, X
     7f6:	81 50       	subi	r24, 0x01	; 1
     7f8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7fa:	df 91       	pop	r29
     7fc:	cf 91       	pop	r28
     7fe:	08 95       	ret

00000800 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     800:	1f 92       	push	r1
     802:	0f 92       	push	r0
     804:	0f b6       	in	r0, 0x3f	; 63
     806:	0f 92       	push	r0
     808:	11 24       	eor	r1, r1
     80a:	0b b6       	in	r0, 0x3b	; 59
     80c:	0f 92       	push	r0
     80e:	2f 93       	push	r18
     810:	3f 93       	push	r19
     812:	4f 93       	push	r20
     814:	5f 93       	push	r21
     816:	6f 93       	push	r22
     818:	7f 93       	push	r23
     81a:	8f 93       	push	r24
     81c:	9f 93       	push	r25
     81e:	af 93       	push	r26
     820:	bf 93       	push	r27
     822:	ef 93       	push	r30
     824:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     826:	1b 9b       	sbis	0x03, 3	; 3
     828:	0d c0       	rjmp	.+26     	; 0x844 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     82a:	80 d1       	rcall	.+768    	; 0xb2c <myTimer_Read>
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	90 93 98 08 	sts	0x0898, r25
     832:	80 93 97 08 	sts	0x0897, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     836:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCountFromISR>
     83a:	90 93 94 08 	sts	0x0894, r25
     83e:	80 93 93 08 	sts	0x0893, r24
     842:	55 c0       	rjmp	.+170    	; 0x8ee <__vector_9+0xee>
	}	
	else if (!(HC_Echo_Read))
     844:	1b 99       	sbic	0x03, 3	; 3
     846:	53 c0       	rjmp	.+166    	; 0x8ee <__vector_9+0xee>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     848:	0e 94 7f 0e 	call	0x1cfe	; 0x1cfe <xTaskGetTickCountFromISR>
     84c:	90 93 9e 08 	sts	0x089E, r25
     850:	80 93 9d 08 	sts	0x089D, r24
     854:	20 91 93 08 	lds	r18, 0x0893
     858:	30 91 94 08 	lds	r19, 0x0894
     85c:	82 17       	cp	r24, r18
     85e:	93 07       	cpc	r25, r19
     860:	4c f4       	brge	.+18     	; 0x874 <__vector_9+0x74>
			ms_tickEnd += 65535;
     862:	80 91 9d 08 	lds	r24, 0x089D
     866:	90 91 9e 08 	lds	r25, 0x089E
     86a:	01 97       	sbiw	r24, 0x01	; 1
     86c:	90 93 9e 08 	sts	0x089E, r25
     870:	80 93 9d 08 	sts	0x089D, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     874:	5b d1       	rcall	.+694    	; 0xb2c <myTimer_Read>
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	90 93 a0 08 	sts	0x08A0, r25
     87c:	80 93 9f 08 	sts	0x089F, r24
     880:	20 91 97 08 	lds	r18, 0x0897
     884:	30 91 98 08 	lds	r19, 0x0898
     888:	82 17       	cp	r24, r18
     88a:	93 07       	cpc	r25, r19
     88c:	54 f4       	brge	.+20     	; 0x8a2 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     88e:	80 91 9f 08 	lds	r24, 0x089F
     892:	90 91 a0 08 	lds	r25, 0x08A0
     896:	86 50       	subi	r24, 0x06	; 6
     898:	9f 4f       	sbci	r25, 0xFF	; 255
     89a:	90 93 a0 08 	sts	0x08A0, r25
     89e:	80 93 9f 08 	sts	0x089F, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     8a2:	80 91 9f 08 	lds	r24, 0x089F
     8a6:	90 91 a0 08 	lds	r25, 0x08A0
     8aa:	20 91 97 08 	lds	r18, 0x0897
     8ae:	30 91 98 08 	lds	r19, 0x0898
     8b2:	82 1b       	sub	r24, r18
     8b4:	93 0b       	sbc	r25, r19
     8b6:	90 93 9a 08 	sts	0x089A, r25
     8ba:	80 93 99 08 	sts	0x0899, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     8be:	80 91 9d 08 	lds	r24, 0x089D
     8c2:	90 91 9e 08 	lds	r25, 0x089E
     8c6:	20 91 93 08 	lds	r18, 0x0893
     8ca:	30 91 94 08 	lds	r19, 0x0894
     8ce:	82 1b       	sub	r24, r18
     8d0:	93 0b       	sbc	r25, r19
     8d2:	90 93 96 08 	sts	0x0896, r25
     8d6:	80 93 95 08 	sts	0x0895, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     8da:	20 e0       	ldi	r18, 0x00	; 0
     8dc:	40 e0       	ldi	r20, 0x00	; 0
     8de:	50 e0       	ldi	r21, 0x00	; 0
     8e0:	60 e0       	ldi	r22, 0x00	; 0
     8e2:	70 e0       	ldi	r23, 0x00	; 0
     8e4:	80 91 9b 08 	lds	r24, 0x089B
     8e8:	90 91 9c 08 	lds	r25, 0x089C
     8ec:	e3 d6       	rcall	.+3526   	; 0x16b4 <xQueueGenericSendFromISR>
	}	
}
     8ee:	ff 91       	pop	r31
     8f0:	ef 91       	pop	r30
     8f2:	bf 91       	pop	r27
     8f4:	af 91       	pop	r26
     8f6:	9f 91       	pop	r25
     8f8:	8f 91       	pop	r24
     8fa:	7f 91       	pop	r23
     8fc:	6f 91       	pop	r22
     8fe:	5f 91       	pop	r21
     900:	4f 91       	pop	r20
     902:	3f 91       	pop	r19
     904:	2f 91       	pop	r18
     906:	0f 90       	pop	r0
     908:	0b be       	out	0x3b, r0	; 59
     90a:	0f 90       	pop	r0
     90c:	0f be       	out	0x3f, r0	; 63
     90e:	0f 90       	pop	r0
     910:	1f 90       	pop	r1
     912:	18 95       	reti

00000914 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     914:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     916:	23 98       	cbi	0x04, 3	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     918:	e8 e6       	ldi	r30, 0x68	; 104
     91a:	f0 e0       	ldi	r31, 0x00	; 0
     91c:	80 81       	ld	r24, Z
     91e:	81 60       	ori	r24, 0x01	; 1
     920:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     922:	eb e6       	ldi	r30, 0x6B	; 107
     924:	f0 e0       	ldi	r31, 0x00	; 0
     926:	80 81       	ld	r24, Z
     928:	88 60       	ori	r24, 0x08	; 8
     92a:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     92c:	43 e0       	ldi	r20, 0x03	; 3
     92e:	60 e0       	ldi	r22, 0x00	; 0
     930:	81 e0       	ldi	r24, 0x01	; 1
     932:	db d5       	rcall	.+2998   	; 0x14ea <xQueueGenericCreate>
     934:	90 93 9c 08 	sts	0x089C, r25
     938:	80 93 9b 08 	sts	0x089B, r24
     93c:	08 95       	ret

0000093e <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     93e:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     940:	89 e1       	ldi	r24, 0x19	; 25
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	f5 d0       	rcall	.+490    	; 0xb30 <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     946:	a1 98       	cbi	0x14, 1	; 20
     948:	08 95       	ret

0000094a <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     94a:	ab d0       	rcall	.+342    	; 0xaa2 <myADC_analogRead>
     94c:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     94e:	63 e0       	ldi	r22, 0x03	; 3
     950:	70 e0       	ldi	r23, 0x00	; 0
     952:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <__divmodhi4>
	reading += adcReading; // add the exact adcReading
	
	return reading;
}
     956:	cb 01       	movw	r24, r22
     958:	82 0f       	add	r24, r18
     95a:	93 1f       	adc	r25, r19
     95c:	08 95       	ret

0000095e <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     95e:	1f 92       	push	r1
     960:	0f 92       	push	r0
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	0f 92       	push	r0
     966:	11 24       	eor	r1, r1
     968:	0b b6       	in	r0, 0x3b	; 59
     96a:	0f 92       	push	r0
     96c:	2f 93       	push	r18
     96e:	3f 93       	push	r19
     970:	4f 93       	push	r20
     972:	5f 93       	push	r21
     974:	6f 93       	push	r22
     976:	7f 93       	push	r23
     978:	8f 93       	push	r24
     97a:	9f 93       	push	r25
     97c:	af 93       	push	r26
     97e:	bf 93       	push	r27
     980:	ef 93       	push	r30
     982:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     984:	80 91 78 00 	lds	r24, 0x0078
     988:	80 93 a1 08 	sts	0x08A1, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     98c:	80 91 79 00 	lds	r24, 0x0079
     990:	80 93 a2 08 	sts	0x08A2, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     994:	20 e0       	ldi	r18, 0x00	; 0
     996:	40 e0       	ldi	r20, 0x00	; 0
     998:	50 e0       	ldi	r21, 0x00	; 0
     99a:	60 e0       	ldi	r22, 0x00	; 0
     99c:	70 e0       	ldi	r23, 0x00	; 0
     99e:	80 91 a5 08 	lds	r24, 0x08A5
     9a2:	90 91 a6 08 	lds	r25, 0x08A6
     9a6:	86 d6       	rcall	.+3340   	; 0x16b4 <xQueueGenericSendFromISR>
}
     9a8:	ff 91       	pop	r31
     9aa:	ef 91       	pop	r30
     9ac:	bf 91       	pop	r27
     9ae:	af 91       	pop	r26
     9b0:	9f 91       	pop	r25
     9b2:	8f 91       	pop	r24
     9b4:	7f 91       	pop	r23
     9b6:	6f 91       	pop	r22
     9b8:	5f 91       	pop	r21
     9ba:	4f 91       	pop	r20
     9bc:	3f 91       	pop	r19
     9be:	2f 91       	pop	r18
     9c0:	0f 90       	pop	r0
     9c2:	0b be       	out	0x3b, r0	; 59
     9c4:	0f 90       	pop	r0
     9c6:	0f be       	out	0x3f, r0	; 63
     9c8:	0f 90       	pop	r0
     9ca:	1f 90       	pop	r1
     9cc:	18 95       	reti

000009ce <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     9ce:	8f e8       	ldi	r24, 0x8F	; 143
     9d0:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     9d4:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     9d8:	80 e4       	ldi	r24, 0x40	; 64
     9da:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     9de:	43 e0       	ldi	r20, 0x03	; 3
     9e0:	60 e0       	ldi	r22, 0x00	; 0
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	82 d5       	rcall	.+2820   	; 0x14ea <xQueueGenericCreate>
     9e6:	90 93 a6 08 	sts	0x08A6, r25
     9ea:	80 93 a5 08 	sts	0x08A5, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	39 d6       	rcall	.+3186   	; 0x1664 <xQueueCreateMutex>
     9f2:	90 93 a4 08 	sts	0x08A4, r25
     9f6:	80 93 a3 08 	sts	0x08A3, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     9fa:	20 e0       	ldi	r18, 0x00	; 0
     9fc:	40 e0       	ldi	r20, 0x00	; 0
     9fe:	50 e0       	ldi	r21, 0x00	; 0
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	9c c5       	rjmp	.+2872   	; 0x153e <xQueueGenericSend>
     a06:	08 95       	ret

00000a08 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a08:	cf 93       	push	r28
     a0a:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a0c:	20 e0       	ldi	r18, 0x00	; 0
     a0e:	4f ef       	ldi	r20, 0xFF	; 255
     a10:	5f ef       	ldi	r21, 0xFF	; 255
     a12:	60 e0       	ldi	r22, 0x00	; 0
     a14:	70 e0       	ldi	r23, 0x00	; 0
     a16:	80 91 a3 08 	lds	r24, 0x08A3
     a1a:	90 91 a4 08 	lds	r25, 0x08A4
     a1e:	84 d6       	rcall	.+3336   	; 0x1728 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     a20:	ec e7       	ldi	r30, 0x7C	; 124
     a22:	f0 e0       	ldi	r31, 0x00	; 0
     a24:	80 81       	ld	r24, Z
     a26:	9c 2f       	mov	r25, r28
     a28:	9f 71       	andi	r25, 0x1F	; 31
     a2a:	80 76       	andi	r24, 0x60	; 96
     a2c:	89 2b       	or	r24, r25
     a2e:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     a30:	eb e7       	ldi	r30, 0x7B	; 123
     a32:	f0 e0       	ldi	r31, 0x00	; 0
     a34:	20 81       	ld	r18, Z
     a36:	c0 72       	andi	r28, 0x20	; 32
     a38:	8c 2f       	mov	r24, r28
     a3a:	90 e0       	ldi	r25, 0x00	; 0
     a3c:	95 95       	asr	r25
     a3e:	87 95       	ror	r24
     a40:	95 95       	asr	r25
     a42:	87 95       	ror	r24
     a44:	92 2f       	mov	r25, r18
     a46:	90 76       	andi	r25, 0x60	; 96
     a48:	89 2b       	or	r24, r25
     a4a:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     a4c:	ea e7       	ldi	r30, 0x7A	; 122
     a4e:	f0 e0       	ldi	r31, 0x00	; 0
     a50:	80 81       	ld	r24, Z
     a52:	80 64       	ori	r24, 0x40	; 64
     a54:	80 83       	st	Z, r24
}
     a56:	cf 91       	pop	r28
     a58:	08 95       	ret

00000a5a <myADC_readADC>:

int myADC_readADC(char channel)
{
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     a5e:	20 e0       	ldi	r18, 0x00	; 0
     a60:	4f ef       	ldi	r20, 0xFF	; 255
     a62:	5f ef       	ldi	r21, 0xFF	; 255
     a64:	60 e0       	ldi	r22, 0x00	; 0
     a66:	70 e0       	ldi	r23, 0x00	; 0
     a68:	80 91 a5 08 	lds	r24, 0x08A5
     a6c:	90 91 a6 08 	lds	r25, 0x08A6
     a70:	5b d6       	rcall	.+3254   	; 0x1728 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     a72:	c0 91 a2 08 	lds	r28, 0x08A2
     a76:	c3 70       	andi	r28, 0x03	; 3
     a78:	d0 e0       	ldi	r29, 0x00	; 0
     a7a:	dc 2f       	mov	r29, r28
     a7c:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     a7e:	80 91 a1 08 	lds	r24, 0x08A1
     a82:	c8 0f       	add	r28, r24
     a84:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     a86:	20 e0       	ldi	r18, 0x00	; 0
     a88:	40 e0       	ldi	r20, 0x00	; 0
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	60 e0       	ldi	r22, 0x00	; 0
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	80 91 a3 08 	lds	r24, 0x08A3
     a94:	90 91 a4 08 	lds	r25, 0x08A4
     a98:	52 d5       	rcall	.+2724   	; 0x153e <xQueueGenericSend>
	
	return adcReading;
     a9a:	ce 01       	movw	r24, r28
     a9c:	df 91       	pop	r29
     a9e:	cf 91       	pop	r28
     aa0:	08 95       	ret

00000aa2 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     aa2:	cf 93       	push	r28
     aa4:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     aa6:	b0 df       	rcall	.-160    	; 0xa08 <myADC_startADC>
	return myADC_readADC(channel);
     aa8:	8c 2f       	mov	r24, r28
     aaa:	d7 df       	rcall	.-82     	; 0xa5a <myADC_readADC>
}
     aac:	cf 91       	pop	r28
     aae:	08 95       	ret

00000ab0 <mySharpIR_Read>:
#include <math.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     ab0:	f8 df       	rcall	.-16     	; 0xaa2 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     ab2:	bc 01       	movw	r22, r24
     ab4:	88 27       	eor	r24, r24
     ab6:	77 fd       	sbrc	r23, 7
     ab8:	80 95       	com	r24
     aba:	98 2f       	mov	r25, r24
     abc:	0e 94 02 13 	call	0x2604	; 0x2604 <__floatsisf>
     ac0:	29 e2       	ldi	r18, 0x29	; 41
     ac2:	3c e5       	ldi	r19, 0x5C	; 92
     ac4:	4f e6       	ldi	r20, 0x6F	; 111
     ac6:	5f eb       	ldi	r21, 0xBF	; 191
     ac8:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <pow>
     acc:	22 e5       	ldi	r18, 0x52	; 82
     ace:	38 e6       	ldi	r19, 0x68	; 104
     ad0:	46 e2       	ldi	r20, 0x26	; 38
     ad2:	56 e4       	ldi	r21, 0x46	; 70
     ad4:	0e 94 8e 13 	call	0x271c	; 0x271c <__mulsf3>
     ad8:	20 e0       	ldi	r18, 0x00	; 0
     ada:	30 e0       	ldi	r19, 0x00	; 0
     adc:	40 e2       	ldi	r20, 0x20	; 32
     ade:	51 e4       	ldi	r21, 0x41	; 65
     ae0:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <__subsf3>
     ae4:	0e 94 cf 12 	call	0x259e	; 0x259e <__fixsfsi>
     ae8:	cb 01       	movw	r24, r22
     aea:	68 3e       	cpi	r22, 0xE8	; 232
     aec:	23 e0       	ldi	r18, 0x03	; 3
     aee:	72 07       	cpc	r23, r18
     af0:	14 f0       	brlt	.+4      	; 0xaf6 <mySharpIR_Read+0x46>
     af2:	87 ee       	ldi	r24, 0xE7	; 231
     af4:	93 e0       	ldi	r25, 0x03	; 3
	if(adcReading > 999)
		adcReading = 999;
	
	return adcReading;
     af6:	08 95       	ret

00000af8 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     af8:	90 93 ac 08 	sts	0x08AC, r25
     afc:	80 93 ab 08 	sts	0x08AB, r24
     b00:	fc 01       	movw	r30, r24
     b02:	80 81       	ld	r24, Z
     b04:	91 81       	ldd	r25, Z+1	; 0x01
     b06:	0e 94 b4 10 	call	0x2168	; 0x2168 <vTaskSuspend>
     b0a:	43 e0       	ldi	r20, 0x03	; 3
     b0c:	60 e0       	ldi	r22, 0x00	; 0
     b0e:	81 e0       	ldi	r24, 0x01	; 1
     b10:	ec d4       	rcall	.+2520   	; 0x14ea <xQueueGenericCreate>
     b12:	90 93 a8 08 	sts	0x08A8, r25
     b16:	80 93 a7 08 	sts	0x08A7, r24
     b1a:	43 e0       	ldi	r20, 0x03	; 3
     b1c:	60 e0       	ldi	r22, 0x00	; 0
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	e4 d4       	rcall	.+2504   	; 0x14ea <xQueueGenericCreate>
     b22:	90 93 aa 08 	sts	0x08AA, r25
     b26:	80 93 a9 08 	sts	0x08A9, r24
     b2a:	08 95       	ret

00000b2c <myTimer_Read>:
     b2c:	86 b5       	in	r24, 0x26	; 38
     b2e:	08 95       	ret

00000b30 <myTimer_DelayMicro>:
     b30:	46 b5       	in	r20, 0x26	; 38
     b32:	50 e0       	ldi	r21, 0x00	; 0
     b34:	9c 01       	movw	r18, r24
     b36:	99 23       	and	r25, r25
     b38:	14 f4       	brge	.+4      	; 0xb3e <myTimer_DelayMicro+0xe>
     b3a:	2d 5f       	subi	r18, 0xFD	; 253
     b3c:	3f 4f       	sbci	r19, 0xFF	; 255
     b3e:	35 95       	asr	r19
     b40:	27 95       	ror	r18
     b42:	35 95       	asr	r19
     b44:	27 95       	ror	r18
     b46:	24 0f       	add	r18, r20
     b48:	35 1f       	adc	r19, r21
     b4a:	30 93 03 02 	sts	0x0203, r19
     b4e:	20 93 02 02 	sts	0x0202, r18
     b52:	e0 91 ab 08 	lds	r30, 0x08AB
     b56:	f0 91 ac 08 	lds	r31, 0x08AC
     b5a:	80 81       	ld	r24, Z
     b5c:	91 81       	ldd	r25, Z+1	; 0x01
     b5e:	0e 94 fb 0d 	call	0x1bf6	; 0x1bf6 <vTaskResume>
     b62:	20 e0       	ldi	r18, 0x00	; 0
     b64:	42 e0       	ldi	r20, 0x02	; 2
     b66:	50 e0       	ldi	r21, 0x00	; 0
     b68:	60 e0       	ldi	r22, 0x00	; 0
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	80 91 a7 08 	lds	r24, 0x08A7
     b70:	90 91 a8 08 	lds	r25, 0x08A8
     b74:	d9 c5       	rjmp	.+2994   	; 0x1728 <xQueueGenericReceive>
     b76:	08 95       	ret

00000b78 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     b7c:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     b7e:	c1 11       	cpse	r28, r1
     b80:	22 c0       	rjmp	.+68     	; 0xbc6 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     b82:	80 91 02 02 	lds	r24, 0x0202
     b86:	90 91 03 02 	lds	r25, 0x0203
     b8a:	88 38       	cpi	r24, 0x88	; 136
     b8c:	93 41       	sbci	r25, 0x13	; 19
     b8e:	51 f0       	breq	.+20     	; 0xba4 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     b90:	80 91 02 02 	lds	r24, 0x0202
     b94:	90 91 03 02 	lds	r25, 0x0203
     b98:	8a 5f       	subi	r24, 0xFA	; 250
     b9a:	91 09       	sbc	r25, r1
     b9c:	90 93 03 02 	sts	0x0203, r25
     ba0:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     ba4:	80 91 00 02 	lds	r24, 0x0200
     ba8:	90 91 01 02 	lds	r25, 0x0201
     bac:	88 38       	cpi	r24, 0x88	; 136
     bae:	93 41       	sbci	r25, 0x13	; 19
     bb0:	51 f0       	breq	.+20     	; 0xbc6 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     bb2:	80 91 00 02 	lds	r24, 0x0200
     bb6:	90 91 01 02 	lds	r25, 0x0201
     bba:	8a 5f       	subi	r24, 0xFA	; 250
     bbc:	91 09       	sbc	r25, r1
     bbe:	90 93 01 02 	sts	0x0201, r25
     bc2:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     bc6:	d0 e0       	ldi	r29, 0x00	; 0
     bc8:	80 91 02 02 	lds	r24, 0x0202
     bcc:	90 91 03 02 	lds	r25, 0x0203
     bd0:	8c 17       	cp	r24, r28
     bd2:	9d 07       	cpc	r25, r29
     bd4:	84 f4       	brge	.+32     	; 0xbf6 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     bd6:	88 e8       	ldi	r24, 0x88	; 136
     bd8:	93 e1       	ldi	r25, 0x13	; 19
     bda:	90 93 03 02 	sts	0x0203, r25
     bde:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     be2:	20 e0       	ldi	r18, 0x00	; 0
     be4:	40 e0       	ldi	r20, 0x00	; 0
     be6:	50 e0       	ldi	r21, 0x00	; 0
     be8:	60 e0       	ldi	r22, 0x00	; 0
     bea:	70 e0       	ldi	r23, 0x00	; 0
     bec:	80 91 a7 08 	lds	r24, 0x08A7
     bf0:	90 91 a8 08 	lds	r25, 0x08A8
     bf4:	a4 d4       	rcall	.+2376   	; 0x153e <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     bf6:	80 91 00 02 	lds	r24, 0x0200
     bfa:	90 91 01 02 	lds	r25, 0x0201
     bfe:	8c 17       	cp	r24, r28
     c00:	9d 07       	cpc	r25, r29
     c02:	84 f4       	brge	.+32     	; 0xc24 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     c04:	88 e8       	ldi	r24, 0x88	; 136
     c06:	93 e1       	ldi	r25, 0x13	; 19
     c08:	90 93 01 02 	sts	0x0201, r25
     c0c:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     c10:	20 e0       	ldi	r18, 0x00	; 0
     c12:	40 e0       	ldi	r20, 0x00	; 0
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	60 e0       	ldi	r22, 0x00	; 0
     c18:	70 e0       	ldi	r23, 0x00	; 0
     c1a:	80 91 a9 08 	lds	r24, 0x08A9
     c1e:	90 91 aa 08 	lds	r25, 0x08AA
     c22:	8d d4       	rcall	.+2330   	; 0x153e <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     c24:	80 91 02 02 	lds	r24, 0x0202
     c28:	90 91 03 02 	lds	r25, 0x0203
     c2c:	88 38       	cpi	r24, 0x88	; 136
     c2e:	93 41       	sbci	r25, 0x13	; 19
     c30:	79 f4       	brne	.+30     	; 0xc50 <myTimer_DelayChecker+0xd8>
     c32:	80 91 00 02 	lds	r24, 0x0200
     c36:	90 91 01 02 	lds	r25, 0x0201
     c3a:	88 38       	cpi	r24, 0x88	; 136
     c3c:	93 41       	sbci	r25, 0x13	; 19
     c3e:	41 f4       	brne	.+16     	; 0xc50 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     c40:	e0 91 ab 08 	lds	r30, 0x08AB
     c44:	f0 91 ac 08 	lds	r31, 0x08AC
     c48:	80 81       	ld	r24, Z
     c4a:	91 81       	ldd	r25, Z+1	; 0x01
     c4c:	0e 94 b4 10 	call	0x2168	; 0x2168 <vTaskSuspend>
	}
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	08 95       	ret

00000c56 <__vector_36>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
}
     c56:	1f 92       	push	r1
     c58:	0f 92       	push	r0
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	0f 92       	push	r0
     c5e:	11 24       	eor	r1, r1
     c60:	0b b6       	in	r0, 0x3b	; 59
     c62:	0f 92       	push	r0
     c64:	2f 93       	push	r18
     c66:	3f 93       	push	r19
     c68:	4f 93       	push	r20
     c6a:	5f 93       	push	r21
     c6c:	6f 93       	push	r22
     c6e:	7f 93       	push	r23
     c70:	8f 93       	push	r24
     c72:	9f 93       	push	r25
     c74:	af 93       	push	r26
     c76:	bf 93       	push	r27
     c78:	ef 93       	push	r30
     c7a:	ff 93       	push	r31
     c7c:	60 91 ce 00 	lds	r22, 0x00CE
     c80:	82 e4       	ldi	r24, 0x42	; 66
     c82:	99 e0       	ldi	r25, 0x09	; 9
     c84:	27 d6       	rcall	.+3150   	; 0x18d4 <ringBufferPush>
     c86:	20 e0       	ldi	r18, 0x00	; 0
     c88:	40 e0       	ldi	r20, 0x00	; 0
     c8a:	50 e0       	ldi	r21, 0x00	; 0
     c8c:	60 e0       	ldi	r22, 0x00	; 0
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	80 91 36 09 	lds	r24, 0x0936
     c94:	90 91 37 09 	lds	r25, 0x0937
     c98:	0d d5       	rcall	.+2586   	; 0x16b4 <xQueueGenericSendFromISR>
     c9a:	82 e4       	ldi	r24, 0x42	; 66
     c9c:	99 e0       	ldi	r25, 0x09	; 9
     c9e:	31 d6       	rcall	.+3170   	; 0x1902 <ringBufferFull>
     ca0:	ff 91       	pop	r31
     ca2:	ef 91       	pop	r30
     ca4:	bf 91       	pop	r27
     ca6:	af 91       	pop	r26
     ca8:	9f 91       	pop	r25
     caa:	8f 91       	pop	r24
     cac:	7f 91       	pop	r23
     cae:	6f 91       	pop	r22
     cb0:	5f 91       	pop	r21
     cb2:	4f 91       	pop	r20
     cb4:	3f 91       	pop	r19
     cb6:	2f 91       	pop	r18
     cb8:	0f 90       	pop	r0
     cba:	0b be       	out	0x3b, r0	; 59
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63
     cc0:	0f 90       	pop	r0
     cc2:	1f 90       	pop	r1
     cc4:	18 95       	reti

00000cc6 <__vector_25>:
     cc6:	1f 92       	push	r1
     cc8:	0f 92       	push	r0
     cca:	0f b6       	in	r0, 0x3f	; 63
     ccc:	0f 92       	push	r0
     cce:	11 24       	eor	r1, r1
     cd0:	0b b6       	in	r0, 0x3b	; 59
     cd2:	0f 92       	push	r0
     cd4:	2f 93       	push	r18
     cd6:	3f 93       	push	r19
     cd8:	4f 93       	push	r20
     cda:	5f 93       	push	r21
     cdc:	6f 93       	push	r22
     cde:	7f 93       	push	r23
     ce0:	8f 93       	push	r24
     ce2:	9f 93       	push	r25
     ce4:	af 93       	push	r26
     ce6:	bf 93       	push	r27
     ce8:	ef 93       	push	r30
     cea:	ff 93       	push	r31
     cec:	60 91 c6 00 	lds	r22, 0x00C6
     cf0:	8d ec       	ldi	r24, 0xCD	; 205
     cf2:	98 e0       	ldi	r25, 0x08	; 8
     cf4:	ef d5       	rcall	.+3038   	; 0x18d4 <ringBufferPush>
     cf6:	20 e0       	ldi	r18, 0x00	; 0
     cf8:	40 e0       	ldi	r20, 0x00	; 0
     cfa:	50 e0       	ldi	r21, 0x00	; 0
     cfc:	60 e0       	ldi	r22, 0x00	; 0
     cfe:	70 e0       	ldi	r23, 0x00	; 0
     d00:	80 91 36 09 	lds	r24, 0x0936
     d04:	90 91 37 09 	lds	r25, 0x0937
     d08:	d5 d4       	rcall	.+2474   	; 0x16b4 <xQueueGenericSendFromISR>
     d0a:	8d ec       	ldi	r24, 0xCD	; 205
     d0c:	98 e0       	ldi	r25, 0x08	; 8
     d0e:	f9 d5       	rcall	.+3058   	; 0x1902 <ringBufferFull>
     d10:	ff 91       	pop	r31
     d12:	ef 91       	pop	r30
     d14:	bf 91       	pop	r27
     d16:	af 91       	pop	r26
     d18:	9f 91       	pop	r25
     d1a:	8f 91       	pop	r24
     d1c:	7f 91       	pop	r23
     d1e:	6f 91       	pop	r22
     d20:	5f 91       	pop	r21
     d22:	4f 91       	pop	r20
     d24:	3f 91       	pop	r19
     d26:	2f 91       	pop	r18
     d28:	0f 90       	pop	r0
     d2a:	0b be       	out	0x3b, r0	; 59
     d2c:	0f 90       	pop	r0
     d2e:	0f be       	out	0x3f, r0	; 63
     d30:	0f 90       	pop	r0
     d32:	1f 90       	pop	r1
     d34:	18 95       	reti

00000d36 <__vector_37>:
     d36:	1f 92       	push	r1
     d38:	0f 92       	push	r0
     d3a:	0f b6       	in	r0, 0x3f	; 63
     d3c:	0f 92       	push	r0
     d3e:	11 24       	eor	r1, r1
     d40:	0b b6       	in	r0, 0x3b	; 59
     d42:	0f 92       	push	r0
     d44:	2f 93       	push	r18
     d46:	3f 93       	push	r19
     d48:	4f 93       	push	r20
     d4a:	5f 93       	push	r21
     d4c:	6f 93       	push	r22
     d4e:	7f 93       	push	r23
     d50:	8f 93       	push	r24
     d52:	9f 93       	push	r25
     d54:	af 93       	push	r26
     d56:	bf 93       	push	r27
     d58:	ef 93       	push	r30
     d5a:	ff 93       	push	r31
     d5c:	88 e3       	ldi	r24, 0x38	; 56
     d5e:	99 e0       	ldi	r25, 0x09	; 9
     d60:	d7 d5       	rcall	.+2990   	; 0x1910 <ringBufferNotEmpty>
     d62:	88 23       	and	r24, r24
     d64:	31 f0       	breq	.+12     	; 0xd72 <__vector_37+0x3c>
     d66:	88 e3       	ldi	r24, 0x38	; 56
     d68:	99 e0       	ldi	r25, 0x09	; 9
     d6a:	a2 d5       	rcall	.+2884   	; 0x18b0 <ringBufferPop>
     d6c:	80 93 ce 00 	sts	0x00CE, r24
     d70:	05 c0       	rjmp	.+10     	; 0xd7c <__vector_37+0x46>
     d72:	e9 ec       	ldi	r30, 0xC9	; 201
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	8f 7d       	andi	r24, 0xDF	; 223
     d7a:	80 83       	st	Z, r24
     d7c:	ff 91       	pop	r31
     d7e:	ef 91       	pop	r30
     d80:	bf 91       	pop	r27
     d82:	af 91       	pop	r26
     d84:	9f 91       	pop	r25
     d86:	8f 91       	pop	r24
     d88:	7f 91       	pop	r23
     d8a:	6f 91       	pop	r22
     d8c:	5f 91       	pop	r21
     d8e:	4f 91       	pop	r20
     d90:	3f 91       	pop	r19
     d92:	2f 91       	pop	r18
     d94:	0f 90       	pop	r0
     d96:	0b be       	out	0x3b, r0	; 59
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	0f 90       	pop	r0
     d9e:	1f 90       	pop	r1
     da0:	18 95       	reti

00000da2 <__vector_26>:
     da2:	1f 92       	push	r1
     da4:	0f 92       	push	r0
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	0f 92       	push	r0
     daa:	11 24       	eor	r1, r1
     dac:	0b b6       	in	r0, 0x3b	; 59
     dae:	0f 92       	push	r0
     db0:	2f 93       	push	r18
     db2:	3f 93       	push	r19
     db4:	4f 93       	push	r20
     db6:	5f 93       	push	r21
     db8:	6f 93       	push	r22
     dba:	7f 93       	push	r23
     dbc:	8f 93       	push	r24
     dbe:	9f 93       	push	r25
     dc0:	af 93       	push	r26
     dc2:	bf 93       	push	r27
     dc4:	ef 93       	push	r30
     dc6:	ff 93       	push	r31
     dc8:	8d e3       	ldi	r24, 0x3D	; 61
     dca:	99 e0       	ldi	r25, 0x09	; 9
     dcc:	a1 d5       	rcall	.+2882   	; 0x1910 <ringBufferNotEmpty>
     dce:	88 23       	and	r24, r24
     dd0:	31 f0       	breq	.+12     	; 0xdde <__vector_26+0x3c>
     dd2:	8d e3       	ldi	r24, 0x3D	; 61
     dd4:	99 e0       	ldi	r25, 0x09	; 9
     dd6:	6c d5       	rcall	.+2776   	; 0x18b0 <ringBufferPop>
     dd8:	80 93 c6 00 	sts	0x00C6, r24
     ddc:	05 c0       	rjmp	.+10     	; 0xde8 <__vector_26+0x46>
     dde:	e1 ec       	ldi	r30, 0xC1	; 193
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	80 81       	ld	r24, Z
     de4:	8f 7d       	andi	r24, 0xDF	; 223
     de6:	80 83       	st	Z, r24
     de8:	ff 91       	pop	r31
     dea:	ef 91       	pop	r30
     dec:	bf 91       	pop	r27
     dee:	af 91       	pop	r26
     df0:	9f 91       	pop	r25
     df2:	8f 91       	pop	r24
     df4:	7f 91       	pop	r23
     df6:	6f 91       	pop	r22
     df8:	5f 91       	pop	r21
     dfa:	4f 91       	pop	r20
     dfc:	3f 91       	pop	r19
     dfe:	2f 91       	pop	r18
     e00:	0f 90       	pop	r0
     e02:	0b be       	out	0x3b, r0	; 59
     e04:	0f 90       	pop	r0
     e06:	0f be       	out	0x3f, r0	; 63
     e08:	0f 90       	pop	r0
     e0a:	1f 90       	pop	r1
     e0c:	18 95       	reti

00000e0e <myUSART_USART0_Init>:
     e0e:	10 92 c5 00 	sts	0x00C5, r1
     e12:	87 e6       	ldi	r24, 0x67	; 103
     e14:	80 93 c4 00 	sts	0x00C4, r24
     e18:	88 eb       	ldi	r24, 0xB8	; 184
     e1a:	80 93 c1 00 	sts	0x00C1, r24
     e1e:	86 e0       	ldi	r24, 0x06	; 6
     e20:	80 93 c2 00 	sts	0x00C2, r24
     e24:	40 e2       	ldi	r20, 0x20	; 32
     e26:	64 ef       	ldi	r22, 0xF4	; 244
     e28:	78 e0       	ldi	r23, 0x08	; 8
     e2a:	8d ec       	ldi	r24, 0xCD	; 205
     e2c:	98 e0       	ldi	r25, 0x08	; 8
     e2e:	2f d5       	rcall	.+2654   	; 0x188e <ringBufferInit>
     e30:	40 e2       	ldi	r20, 0x20	; 32
     e32:	62 ed       	ldi	r22, 0xD2	; 210
     e34:	78 e0       	ldi	r23, 0x08	; 8
     e36:	8d e3       	ldi	r24, 0x3D	; 61
     e38:	99 e0       	ldi	r25, 0x09	; 9
     e3a:	29 d5       	rcall	.+2642   	; 0x188e <ringBufferInit>
     e3c:	43 e0       	ldi	r20, 0x03	; 3
     e3e:	60 e0       	ldi	r22, 0x00	; 0
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	53 d3       	rcall	.+1702   	; 0x14ea <xQueueGenericCreate>
     e44:	90 93 35 09 	sts	0x0935, r25
     e48:	80 93 34 09 	sts	0x0934, r24
     e4c:	08 95       	ret

00000e4e <myUSART_USART1_Init>:
     e4e:	10 92 cd 00 	sts	0x00CD, r1
     e52:	87 e6       	ldi	r24, 0x67	; 103
     e54:	80 93 cc 00 	sts	0x00CC, r24
     e58:	88 eb       	ldi	r24, 0xB8	; 184
     e5a:	80 93 c9 00 	sts	0x00C9, r24
     e5e:	86 e0       	ldi	r24, 0x06	; 6
     e60:	80 93 ca 00 	sts	0x00CA, r24
     e64:	40 e2       	ldi	r20, 0x20	; 32
     e66:	6d ea       	ldi	r22, 0xAD	; 173
     e68:	78 e0       	ldi	r23, 0x08	; 8
     e6a:	82 e4       	ldi	r24, 0x42	; 66
     e6c:	99 e0       	ldi	r25, 0x09	; 9
     e6e:	0f d5       	rcall	.+2590   	; 0x188e <ringBufferInit>
     e70:	40 e2       	ldi	r20, 0x20	; 32
     e72:	64 e1       	ldi	r22, 0x14	; 20
     e74:	79 e0       	ldi	r23, 0x09	; 9
     e76:	88 e3       	ldi	r24, 0x38	; 56
     e78:	99 e0       	ldi	r25, 0x09	; 9
     e7a:	09 d5       	rcall	.+2578   	; 0x188e <ringBufferInit>
     e7c:	43 e0       	ldi	r20, 0x03	; 3
     e7e:	60 e0       	ldi	r22, 0x00	; 0
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	33 d3       	rcall	.+1638   	; 0x14ea <xQueueGenericCreate>
     e84:	90 93 37 09 	sts	0x0937, r25
     e88:	80 93 36 09 	sts	0x0936, r24
     e8c:	43 e0       	ldi	r20, 0x03	; 3
     e8e:	60 e0       	ldi	r22, 0x00	; 0
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	2b d3       	rcall	.+1622   	; 0x14ea <xQueueGenericCreate>
     e94:	90 93 f3 08 	sts	0x08F3, r25
     e98:	80 93 f2 08 	sts	0x08F2, r24
     e9c:	08 95       	ret

00000e9e <myUSART_transmitUSART0_c>:
     e9e:	cf 93       	push	r28
     ea0:	c8 2f       	mov	r28, r24
     ea2:	8d e3       	ldi	r24, 0x3D	; 61
     ea4:	99 e0       	ldi	r25, 0x09	; 9
     ea6:	2d d5       	rcall	.+2650   	; 0x1902 <ringBufferFull>
     ea8:	81 11       	cpse	r24, r1
     eaa:	fb cf       	rjmp	.-10     	; 0xea2 <myUSART_transmitUSART0_c+0x4>
     eac:	6c 2f       	mov	r22, r28
     eae:	8d e3       	ldi	r24, 0x3D	; 61
     eb0:	99 e0       	ldi	r25, 0x09	; 9
     eb2:	10 d5       	rcall	.+2592   	; 0x18d4 <ringBufferPush>
     eb4:	e1 ec       	ldi	r30, 0xC1	; 193
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	80 81       	ld	r24, Z
     eba:	80 62       	ori	r24, 0x20	; 32
     ebc:	80 83       	st	Z, r24
     ebe:	e0 ec       	ldi	r30, 0xC0	; 192
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	80 64       	ori	r24, 0x40	; 64
     ec6:	80 83       	st	Z, r24
     ec8:	cf 91       	pop	r28
     eca:	08 95       	ret

00000ecc <myUSART_transmitUSART1_c>:
     ecc:	cf 93       	push	r28
     ece:	c8 2f       	mov	r28, r24
     ed0:	88 e3       	ldi	r24, 0x38	; 56
     ed2:	99 e0       	ldi	r25, 0x09	; 9
     ed4:	16 d5       	rcall	.+2604   	; 0x1902 <ringBufferFull>
     ed6:	81 11       	cpse	r24, r1
     ed8:	fb cf       	rjmp	.-10     	; 0xed0 <myUSART_transmitUSART1_c+0x4>
     eda:	6c 2f       	mov	r22, r28
     edc:	88 e3       	ldi	r24, 0x38	; 56
     ede:	99 e0       	ldi	r25, 0x09	; 9
     ee0:	f9 d4       	rcall	.+2546   	; 0x18d4 <ringBufferPush>
     ee2:	e9 ec       	ldi	r30, 0xC9	; 201
     ee4:	f0 e0       	ldi	r31, 0x00	; 0
     ee6:	80 81       	ld	r24, Z
     ee8:	80 62       	ori	r24, 0x20	; 32
     eea:	80 83       	st	Z, r24
     eec:	e8 ec       	ldi	r30, 0xC8	; 200
     eee:	f0 e0       	ldi	r31, 0x00	; 0
     ef0:	80 81       	ld	r24, Z
     ef2:	80 64       	ori	r24, 0x40	; 64
     ef4:	80 83       	st	Z, r24
     ef6:	cf 91       	pop	r28
     ef8:	08 95       	ret

00000efa <myUSART_transmitUSART1>:
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	ec 01       	movw	r28, r24
     f00:	88 81       	ld	r24, Y
     f02:	88 23       	and	r24, r24
     f04:	29 f0       	breq	.+10     	; 0xf10 <myUSART_transmitUSART1+0x16>
     f06:	21 96       	adiw	r28, 0x01	; 1
     f08:	e1 df       	rcall	.-62     	; 0xecc <myUSART_transmitUSART1_c>
     f0a:	89 91       	ld	r24, Y+
     f0c:	81 11       	cpse	r24, r1
     f0e:	fc cf       	rjmp	.-8      	; 0xf08 <myUSART_transmitUSART1+0xe>
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	08 95       	ret

00000f16 <myUSART_transmitUSART0>:
     f16:	cf 93       	push	r28
     f18:	df 93       	push	r29
     f1a:	ec 01       	movw	r28, r24
     f1c:	88 81       	ld	r24, Y
     f1e:	88 23       	and	r24, r24
     f20:	29 f0       	breq	.+10     	; 0xf2c <myUSART_transmitUSART0+0x16>
     f22:	21 96       	adiw	r28, 0x01	; 1
     f24:	bc df       	rcall	.-136    	; 0xe9e <myUSART_transmitUSART0_c>
     f26:	89 91       	ld	r24, Y+
     f28:	81 11       	cpse	r24, r1
     f2a:	fc cf       	rjmp	.-8      	; 0xf24 <myUSART_transmitUSART0+0xe>
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret

00000f32 <myUSART_receiveUSART1>:
     f32:	cf 93       	push	r28
     f34:	20 e0       	ldi	r18, 0x00	; 0
     f36:	4f ef       	ldi	r20, 0xFF	; 255
     f38:	5f ef       	ldi	r21, 0xFF	; 255
     f3a:	60 e0       	ldi	r22, 0x00	; 0
     f3c:	70 e0       	ldi	r23, 0x00	; 0
     f3e:	80 91 36 09 	lds	r24, 0x0936
     f42:	90 91 37 09 	lds	r25, 0x0937
     f46:	f0 d3       	rcall	.+2016   	; 0x1728 <xQueueGenericReceive>
     f48:	82 e4       	ldi	r24, 0x42	; 66
     f4a:	99 e0       	ldi	r25, 0x09	; 9
     f4c:	b1 d4       	rcall	.+2402   	; 0x18b0 <ringBufferPop>
     f4e:	c8 2f       	mov	r28, r24
     f50:	82 e4       	ldi	r24, 0x42	; 66
     f52:	99 e0       	ldi	r25, 0x09	; 9
     f54:	dd d4       	rcall	.+2490   	; 0x1910 <ringBufferNotEmpty>
     f56:	88 23       	and	r24, r24
     f58:	51 f0       	breq	.+20     	; 0xf6e <myUSART_receiveUSART1+0x3c>
     f5a:	20 e0       	ldi	r18, 0x00	; 0
     f5c:	40 e0       	ldi	r20, 0x00	; 0
     f5e:	50 e0       	ldi	r21, 0x00	; 0
     f60:	60 e0       	ldi	r22, 0x00	; 0
     f62:	70 e0       	ldi	r23, 0x00	; 0
     f64:	80 91 36 09 	lds	r24, 0x0936
     f68:	90 91 37 09 	lds	r25, 0x0937
     f6c:	e8 d2       	rcall	.+1488   	; 0x153e <xQueueGenericSend>
     f6e:	8c 2f       	mov	r24, r28
     f70:	cf 91       	pop	r28
     f72:	08 95       	ret

00000f74 <myUSART_waitForHandshake>:
     f74:	de df       	rcall	.-68     	; 0xf32 <myUSART_receiveUSART1>
     f76:	86 31       	cpi	r24, 0x16	; 22
     f78:	51 f4       	brne	.+20     	; 0xf8e <myUSART_waitForHandshake+0x1a>
     f7a:	85 e0       	ldi	r24, 0x05	; 5
     f7c:	a7 df       	rcall	.-178    	; 0xecc <myUSART_transmitUSART1_c>
     f7e:	d9 df       	rcall	.-78     	; 0xf32 <myUSART_receiveUSART1>
     f80:	91 e0       	ldi	r25, 0x01	; 1
     f82:	86 31       	cpi	r24, 0x16	; 22
     f84:	09 f4       	brne	.+2      	; 0xf88 <myUSART_waitForHandshake+0x14>
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	89 2f       	mov	r24, r25
     f8a:	81 95       	neg	r24
     f8c:	08 95       	ret
     f8e:	8f ef       	ldi	r24, 0xFF	; 255
     f90:	08 95       	ret

00000f92 <myUSART_completeHandShake>:
     f92:	20 e0       	ldi	r18, 0x00	; 0
     f94:	40 e0       	ldi	r20, 0x00	; 0
     f96:	50 e0       	ldi	r21, 0x00	; 0
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	70 e0       	ldi	r23, 0x00	; 0
     f9c:	80 91 f2 08 	lds	r24, 0x08F2
     fa0:	90 91 f3 08 	lds	r25, 0x08F3
     fa4:	cc c2       	rjmp	.+1432   	; 0x153e <xQueueGenericSend>
     fa6:	08 95       	ret

00000fa8 <myUSART_receiveHandShakeAck>:
     fa8:	91 e0       	ldi	r25, 0x01	; 1
     faa:	85 30       	cpi	r24, 0x05	; 5
     fac:	09 f0       	breq	.+2      	; 0xfb0 <myUSART_receiveHandShakeAck+0x8>
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	89 2f       	mov	r24, r25
     fb2:	08 95       	ret

00000fb4 <myUSART_receiveHandShakeStart>:
     fb4:	91 e0       	ldi	r25, 0x01	; 1
     fb6:	86 31       	cpi	r24, 0x16	; 22
     fb8:	09 f0       	breq	.+2      	; 0xfbc <myUSART_receiveHandShakeStart+0x8>
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	89 2f       	mov	r24, r25
     fbe:	08 95       	ret

00000fc0 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
     fc0:	91 e0       	ldi	r25, 0x01	; 1
     fc2:	86 30       	cpi	r24, 0x06	; 6
     fc4:	09 f0       	breq	.+2      	; 0xfc8 <myUSART_receiveMessageACK+0x8>
     fc6:	90 e0       	ldi	r25, 0x00	; 0
}
     fc8:	89 2f       	mov	r24, r25
     fca:	08 95       	ret

00000fcc <myUSART_peekReceiveUSART1>:


unsigned char myUSART_peekReceiveUSART1()
{
     fcc:	cf 93       	push	r28
	unsigned char data;
	
	xSemaphoreTake(semaUsart1Receive, portMAX_DELAY);
     fce:	20 e0       	ldi	r18, 0x00	; 0
     fd0:	4f ef       	ldi	r20, 0xFF	; 255
     fd2:	5f ef       	ldi	r21, 0xFF	; 255
     fd4:	60 e0       	ldi	r22, 0x00	; 0
     fd6:	70 e0       	ldi	r23, 0x00	; 0
     fd8:	80 91 36 09 	lds	r24, 0x0936
     fdc:	90 91 37 09 	lds	r25, 0x0937
     fe0:	a3 d3       	rcall	.+1862   	; 0x1728 <xQueueGenericReceive>
	data = ringBufferPeek(&uart1_rxRingBuffer);
     fe2:	82 e4       	ldi	r24, 0x42	; 66
     fe4:	99 e0       	ldi	r25, 0x09	; 9
     fe6:	5a d4       	rcall	.+2228   	; 0x189c <ringBufferPeek>
     fe8:	c8 2f       	mov	r28, r24
	
	//need?
	if(ringBufferNotEmpty(&uart1_rxRingBuffer))
     fea:	82 e4       	ldi	r24, 0x42	; 66
     fec:	99 e0       	ldi	r25, 0x09	; 9
     fee:	90 d4       	rcall	.+2336   	; 0x1910 <ringBufferNotEmpty>
     ff0:	88 23       	and	r24, r24
     ff2:	51 f0       	breq	.+20     	; 0x1008 <myUSART_peekReceiveUSART1+0x3c>
	{
		xSemaphoreGive(semaUsart1Receive);
     ff4:	20 e0       	ldi	r18, 0x00	; 0
     ff6:	40 e0       	ldi	r20, 0x00	; 0
     ff8:	50 e0       	ldi	r21, 0x00	; 0
     ffa:	60 e0       	ldi	r22, 0x00	; 0
     ffc:	70 e0       	ldi	r23, 0x00	; 0
     ffe:	80 91 36 09 	lds	r24, 0x0936
    1002:	90 91 37 09 	lds	r25, 0x0937
    1006:	9b d2       	rcall	.+1334   	; 0x153e <xQueueGenericSend>
	}
	
	return data;
    1008:	8c 2f       	mov	r24, r28
    100a:	cf 91       	pop	r28
    100c:	08 95       	ret

0000100e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    100e:	31 e1       	ldi	r19, 0x11	; 17
    1010:	fc 01       	movw	r30, r24
    1012:	30 83       	st	Z, r19
    1014:	31 97       	sbiw	r30, 0x01	; 1
    1016:	22 e2       	ldi	r18, 0x22	; 34
    1018:	20 83       	st	Z, r18
    101a:	31 97       	sbiw	r30, 0x01	; 1
    101c:	a3 e3       	ldi	r26, 0x33	; 51
    101e:	a0 83       	st	Z, r26
    1020:	31 97       	sbiw	r30, 0x01	; 1
    1022:	60 83       	st	Z, r22
    1024:	31 97       	sbiw	r30, 0x01	; 1
    1026:	70 83       	st	Z, r23
    1028:	31 97       	sbiw	r30, 0x01	; 1
    102a:	10 82       	st	Z, r1
    102c:	31 97       	sbiw	r30, 0x01	; 1
    102e:	10 82       	st	Z, r1
    1030:	31 97       	sbiw	r30, 0x01	; 1
    1032:	60 e8       	ldi	r22, 0x80	; 128
    1034:	60 83       	st	Z, r22
    1036:	31 97       	sbiw	r30, 0x01	; 1
    1038:	10 82       	st	Z, r1
    103a:	31 97       	sbiw	r30, 0x01	; 1
    103c:	10 82       	st	Z, r1
    103e:	31 97       	sbiw	r30, 0x01	; 1
    1040:	10 82       	st	Z, r1
    1042:	31 97       	sbiw	r30, 0x01	; 1
    1044:	62 e0       	ldi	r22, 0x02	; 2
    1046:	60 83       	st	Z, r22
    1048:	31 97       	sbiw	r30, 0x01	; 1
    104a:	63 e0       	ldi	r22, 0x03	; 3
    104c:	60 83       	st	Z, r22
    104e:	31 97       	sbiw	r30, 0x01	; 1
    1050:	64 e0       	ldi	r22, 0x04	; 4
    1052:	60 83       	st	Z, r22
    1054:	31 97       	sbiw	r30, 0x01	; 1
    1056:	65 e0       	ldi	r22, 0x05	; 5
    1058:	60 83       	st	Z, r22
    105a:	31 97       	sbiw	r30, 0x01	; 1
    105c:	66 e0       	ldi	r22, 0x06	; 6
    105e:	60 83       	st	Z, r22
    1060:	31 97       	sbiw	r30, 0x01	; 1
    1062:	67 e0       	ldi	r22, 0x07	; 7
    1064:	60 83       	st	Z, r22
    1066:	31 97       	sbiw	r30, 0x01	; 1
    1068:	68 e0       	ldi	r22, 0x08	; 8
    106a:	60 83       	st	Z, r22
    106c:	31 97       	sbiw	r30, 0x01	; 1
    106e:	69 e0       	ldi	r22, 0x09	; 9
    1070:	60 83       	st	Z, r22
    1072:	31 97       	sbiw	r30, 0x01	; 1
    1074:	60 e1       	ldi	r22, 0x10	; 16
    1076:	60 83       	st	Z, r22
    1078:	31 97       	sbiw	r30, 0x01	; 1
    107a:	30 83       	st	Z, r19
    107c:	31 97       	sbiw	r30, 0x01	; 1
    107e:	32 e1       	ldi	r19, 0x12	; 18
    1080:	30 83       	st	Z, r19
    1082:	31 97       	sbiw	r30, 0x01	; 1
    1084:	33 e1       	ldi	r19, 0x13	; 19
    1086:	30 83       	st	Z, r19
    1088:	31 97       	sbiw	r30, 0x01	; 1
    108a:	34 e1       	ldi	r19, 0x14	; 20
    108c:	30 83       	st	Z, r19
    108e:	31 97       	sbiw	r30, 0x01	; 1
    1090:	35 e1       	ldi	r19, 0x15	; 21
    1092:	30 83       	st	Z, r19
    1094:	31 97       	sbiw	r30, 0x01	; 1
    1096:	36 e1       	ldi	r19, 0x16	; 22
    1098:	30 83       	st	Z, r19
    109a:	31 97       	sbiw	r30, 0x01	; 1
    109c:	37 e1       	ldi	r19, 0x17	; 23
    109e:	30 83       	st	Z, r19
    10a0:	31 97       	sbiw	r30, 0x01	; 1
    10a2:	38 e1       	ldi	r19, 0x18	; 24
    10a4:	30 83       	st	Z, r19
    10a6:	31 97       	sbiw	r30, 0x01	; 1
    10a8:	39 e1       	ldi	r19, 0x19	; 25
    10aa:	30 83       	st	Z, r19
    10ac:	31 97       	sbiw	r30, 0x01	; 1
    10ae:	30 e2       	ldi	r19, 0x20	; 32
    10b0:	30 83       	st	Z, r19
    10b2:	31 97       	sbiw	r30, 0x01	; 1
    10b4:	31 e2       	ldi	r19, 0x21	; 33
    10b6:	30 83       	st	Z, r19
    10b8:	31 97       	sbiw	r30, 0x01	; 1
    10ba:	20 83       	st	Z, r18
    10bc:	31 97       	sbiw	r30, 0x01	; 1
    10be:	23 e2       	ldi	r18, 0x23	; 35
    10c0:	20 83       	st	Z, r18
    10c2:	31 97       	sbiw	r30, 0x01	; 1
    10c4:	40 83       	st	Z, r20
    10c6:	31 97       	sbiw	r30, 0x01	; 1
    10c8:	50 83       	st	Z, r21
    10ca:	31 97       	sbiw	r30, 0x01	; 1
    10cc:	26 e2       	ldi	r18, 0x26	; 38
    10ce:	20 83       	st	Z, r18
    10d0:	31 97       	sbiw	r30, 0x01	; 1
    10d2:	27 e2       	ldi	r18, 0x27	; 39
    10d4:	20 83       	st	Z, r18
    10d6:	31 97       	sbiw	r30, 0x01	; 1
    10d8:	28 e2       	ldi	r18, 0x28	; 40
    10da:	20 83       	st	Z, r18
    10dc:	31 97       	sbiw	r30, 0x01	; 1
    10de:	29 e2       	ldi	r18, 0x29	; 41
    10e0:	20 83       	st	Z, r18
    10e2:	31 97       	sbiw	r30, 0x01	; 1
    10e4:	20 e3       	ldi	r18, 0x30	; 48
    10e6:	20 83       	st	Z, r18
    10e8:	31 97       	sbiw	r30, 0x01	; 1
    10ea:	21 e3       	ldi	r18, 0x31	; 49
    10ec:	20 83       	st	Z, r18
    10ee:	89 97       	sbiw	r24, 0x29	; 41
    10f0:	08 95       	ret

000010f2 <xPortStartScheduler>:
    10f2:	82 e0       	ldi	r24, 0x02	; 2
    10f4:	84 bd       	out	0x24, r24	; 36
    10f6:	16 bc       	out	0x26, r1	; 38
    10f8:	80 e3       	ldi	r24, 0x30	; 48
    10fa:	87 bd       	out	0x27, r24	; 39
    10fc:	ee e6       	ldi	r30, 0x6E	; 110
    10fe:	f0 e0       	ldi	r31, 0x00	; 0
    1100:	80 81       	ld	r24, Z
    1102:	82 60       	ori	r24, 0x02	; 2
    1104:	80 83       	st	Z, r24
    1106:	83 e0       	ldi	r24, 0x03	; 3
    1108:	85 bd       	out	0x25, r24	; 37
    110a:	a0 91 8d 08 	lds	r26, 0x088D
    110e:	b0 91 8e 08 	lds	r27, 0x088E
    1112:	cd 91       	ld	r28, X+
    1114:	cd bf       	out	0x3d, r28	; 61
    1116:	dd 91       	ld	r29, X+
    1118:	de bf       	out	0x3e, r29	; 62
    111a:	ff 91       	pop	r31
    111c:	ef 91       	pop	r30
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	bf 91       	pop	r27
    1124:	af 91       	pop	r26
    1126:	9f 91       	pop	r25
    1128:	8f 91       	pop	r24
    112a:	7f 91       	pop	r23
    112c:	6f 91       	pop	r22
    112e:	5f 91       	pop	r21
    1130:	4f 91       	pop	r20
    1132:	3f 91       	pop	r19
    1134:	2f 91       	pop	r18
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	ff 90       	pop	r15
    113c:	ef 90       	pop	r14
    113e:	df 90       	pop	r13
    1140:	cf 90       	pop	r12
    1142:	bf 90       	pop	r11
    1144:	af 90       	pop	r10
    1146:	9f 90       	pop	r9
    1148:	8f 90       	pop	r8
    114a:	7f 90       	pop	r7
    114c:	6f 90       	pop	r6
    114e:	5f 90       	pop	r5
    1150:	4f 90       	pop	r4
    1152:	3f 90       	pop	r3
    1154:	2f 90       	pop	r2
    1156:	1f 90       	pop	r1
    1158:	0f 90       	pop	r0
    115a:	0c be       	out	0x3c, r0	; 60
    115c:	0f 90       	pop	r0
    115e:	0b be       	out	0x3b, r0	; 59
    1160:	0f 90       	pop	r0
    1162:	0f be       	out	0x3f, r0	; 63
    1164:	0f 90       	pop	r0
    1166:	08 95       	ret
    1168:	81 e0       	ldi	r24, 0x01	; 1
    116a:	08 95       	ret

0000116c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    116c:	0f 92       	push	r0
    116e:	0f b6       	in	r0, 0x3f	; 63
    1170:	f8 94       	cli
    1172:	0f 92       	push	r0
    1174:	0b b6       	in	r0, 0x3b	; 59
    1176:	0f 92       	push	r0
    1178:	0c b6       	in	r0, 0x3c	; 60
    117a:	0f 92       	push	r0
    117c:	1f 92       	push	r1
    117e:	11 24       	eor	r1, r1
    1180:	2f 92       	push	r2
    1182:	3f 92       	push	r3
    1184:	4f 92       	push	r4
    1186:	5f 92       	push	r5
    1188:	6f 92       	push	r6
    118a:	7f 92       	push	r7
    118c:	8f 92       	push	r8
    118e:	9f 92       	push	r9
    1190:	af 92       	push	r10
    1192:	bf 92       	push	r11
    1194:	cf 92       	push	r12
    1196:	df 92       	push	r13
    1198:	ef 92       	push	r14
    119a:	ff 92       	push	r15
    119c:	0f 93       	push	r16
    119e:	1f 93       	push	r17
    11a0:	2f 93       	push	r18
    11a2:	3f 93       	push	r19
    11a4:	4f 93       	push	r20
    11a6:	5f 93       	push	r21
    11a8:	6f 93       	push	r22
    11aa:	7f 93       	push	r23
    11ac:	8f 93       	push	r24
    11ae:	9f 93       	push	r25
    11b0:	af 93       	push	r26
    11b2:	bf 93       	push	r27
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	ef 93       	push	r30
    11ba:	ff 93       	push	r31
    11bc:	a0 91 8d 08 	lds	r26, 0x088D
    11c0:	b0 91 8e 08 	lds	r27, 0x088E
    11c4:	0d b6       	in	r0, 0x3d	; 61
    11c6:	0d 92       	st	X+, r0
    11c8:	0e b6       	in	r0, 0x3e	; 62
    11ca:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    11cc:	6f d7       	rcall	.+3806   	; 0x20ac <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    11ce:	a0 91 8d 08 	lds	r26, 0x088D
    11d2:	b0 91 8e 08 	lds	r27, 0x088E
    11d6:	cd 91       	ld	r28, X+
    11d8:	cd bf       	out	0x3d, r28	; 61
    11da:	dd 91       	ld	r29, X+
    11dc:	de bf       	out	0x3e, r29	; 62
    11de:	ff 91       	pop	r31
    11e0:	ef 91       	pop	r30
    11e2:	df 91       	pop	r29
    11e4:	cf 91       	pop	r28
    11e6:	bf 91       	pop	r27
    11e8:	af 91       	pop	r26
    11ea:	9f 91       	pop	r25
    11ec:	8f 91       	pop	r24
    11ee:	7f 91       	pop	r23
    11f0:	6f 91       	pop	r22
    11f2:	5f 91       	pop	r21
    11f4:	4f 91       	pop	r20
    11f6:	3f 91       	pop	r19
    11f8:	2f 91       	pop	r18
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
    1200:	ef 90       	pop	r14
    1202:	df 90       	pop	r13
    1204:	cf 90       	pop	r12
    1206:	bf 90       	pop	r11
    1208:	af 90       	pop	r10
    120a:	9f 90       	pop	r9
    120c:	8f 90       	pop	r8
    120e:	7f 90       	pop	r7
    1210:	6f 90       	pop	r6
    1212:	5f 90       	pop	r5
    1214:	4f 90       	pop	r4
    1216:	3f 90       	pop	r3
    1218:	2f 90       	pop	r2
    121a:	1f 90       	pop	r1
    121c:	0f 90       	pop	r0
    121e:	0c be       	out	0x3c, r0	; 60
    1220:	0f 90       	pop	r0
    1222:	0b be       	out	0x3b, r0	; 59
    1224:	0f 90       	pop	r0
    1226:	0f be       	out	0x3f, r0	; 63
    1228:	0f 90       	pop	r0

	asm volatile ( "ret" );
    122a:	08 95       	ret

0000122c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    122c:	0f 92       	push	r0
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	0f 92       	push	r0
    1234:	0b b6       	in	r0, 0x3b	; 59
    1236:	0f 92       	push	r0
    1238:	0c b6       	in	r0, 0x3c	; 60
    123a:	0f 92       	push	r0
    123c:	1f 92       	push	r1
    123e:	11 24       	eor	r1, r1
    1240:	2f 92       	push	r2
    1242:	3f 92       	push	r3
    1244:	4f 92       	push	r4
    1246:	5f 92       	push	r5
    1248:	6f 92       	push	r6
    124a:	7f 92       	push	r7
    124c:	8f 92       	push	r8
    124e:	9f 92       	push	r9
    1250:	af 92       	push	r10
    1252:	bf 92       	push	r11
    1254:	cf 92       	push	r12
    1256:	df 92       	push	r13
    1258:	ef 92       	push	r14
    125a:	ff 92       	push	r15
    125c:	0f 93       	push	r16
    125e:	1f 93       	push	r17
    1260:	2f 93       	push	r18
    1262:	3f 93       	push	r19
    1264:	4f 93       	push	r20
    1266:	5f 93       	push	r21
    1268:	6f 93       	push	r22
    126a:	7f 93       	push	r23
    126c:	8f 93       	push	r24
    126e:	9f 93       	push	r25
    1270:	af 93       	push	r26
    1272:	bf 93       	push	r27
    1274:	cf 93       	push	r28
    1276:	df 93       	push	r29
    1278:	ef 93       	push	r30
    127a:	ff 93       	push	r31
    127c:	a0 91 8d 08 	lds	r26, 0x088D
    1280:	b0 91 8e 08 	lds	r27, 0x088E
    1284:	0d b6       	in	r0, 0x3d	; 61
    1286:	0d 92       	st	X+, r0
    1288:	0e b6       	in	r0, 0x3e	; 62
    128a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    128c:	3d d5       	rcall	.+2682   	; 0x1d08 <xTaskIncrementTick>
    128e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1290:	0d d7       	rcall	.+3610   	; 0x20ac <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1292:	a0 91 8d 08 	lds	r26, 0x088D
    1296:	b0 91 8e 08 	lds	r27, 0x088E
    129a:	cd 91       	ld	r28, X+
    129c:	cd bf       	out	0x3d, r28	; 61
    129e:	dd 91       	ld	r29, X+
    12a0:	de bf       	out	0x3e, r29	; 62
    12a2:	ff 91       	pop	r31
    12a4:	ef 91       	pop	r30
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	bf 91       	pop	r27
    12ac:	af 91       	pop	r26
    12ae:	9f 91       	pop	r25
    12b0:	8f 91       	pop	r24
    12b2:	7f 91       	pop	r23
    12b4:	6f 91       	pop	r22
    12b6:	5f 91       	pop	r21
    12b8:	4f 91       	pop	r20
    12ba:	3f 91       	pop	r19
    12bc:	2f 91       	pop	r18
    12be:	1f 91       	pop	r17
    12c0:	0f 91       	pop	r16
    12c2:	ff 90       	pop	r15
    12c4:	ef 90       	pop	r14
    12c6:	df 90       	pop	r13
    12c8:	cf 90       	pop	r12
    12ca:	bf 90       	pop	r11
    12cc:	af 90       	pop	r10
    12ce:	9f 90       	pop	r9
    12d0:	8f 90       	pop	r8
    12d2:	7f 90       	pop	r7
    12d4:	6f 90       	pop	r6
    12d6:	5f 90       	pop	r5
    12d8:	4f 90       	pop	r4
    12da:	3f 90       	pop	r3
    12dc:	2f 90       	pop	r2
    12de:	1f 90       	pop	r1
    12e0:	0f 90       	pop	r0
    12e2:	0c be       	out	0x3c, r0	; 60
    12e4:	0f 90       	pop	r0
    12e6:	0b be       	out	0x3b, r0	; 59
    12e8:	0f 90       	pop	r0
    12ea:	0f be       	out	0x3f, r0	; 63
    12ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12ee:	08 95       	ret

000012f0 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    12f0:	9d df       	rcall	.-198    	; 0x122c <vPortYieldFromTick>
		 asm volatile ("reti");
    12f2:	18 95       	reti

000012f4 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    12f4:	1f 93       	push	r17
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	ec 01       	movw	r28, r24
    12fc:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    12fe:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1300:	81 11       	cpse	r24, r1
    1302:	0c c0       	rjmp	.+24     	; 0x131c <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1304:	88 81       	ld	r24, Y
    1306:	99 81       	ldd	r25, Y+1	; 0x01
    1308:	89 2b       	or	r24, r25
    130a:	09 f0       	breq	.+2      	; 0x130e <prvCopyDataToQueue+0x1a>
    130c:	47 c0       	rjmp	.+142    	; 0x139c <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    130e:	8a 81       	ldd	r24, Y+2	; 0x02
    1310:	9b 81       	ldd	r25, Y+3	; 0x03
    1312:	0e 94 19 12 	call	0x2432	; 0x2432 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1316:	1b 82       	std	Y+3, r1	; 0x03
    1318:	1a 82       	std	Y+2, r1	; 0x02
    131a:	47 c0       	rjmp	.+142    	; 0x13aa <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    131c:	41 11       	cpse	r20, r1
    131e:	18 c0       	rjmp	.+48     	; 0x1350 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1320:	48 2f       	mov	r20, r24
    1322:	50 e0       	ldi	r21, 0x00	; 0
    1324:	8c 81       	ldd	r24, Y+4	; 0x04
    1326:	9d 81       	ldd	r25, Y+5	; 0x05
    1328:	0e 94 e5 15 	call	0x2bca	; 0x2bca <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    132c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    132e:	8c 81       	ldd	r24, Y+4	; 0x04
    1330:	9d 81       	ldd	r25, Y+5	; 0x05
    1332:	82 0f       	add	r24, r18
    1334:	91 1d       	adc	r25, r1
    1336:	9d 83       	std	Y+5, r25	; 0x05
    1338:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    133a:	2a 81       	ldd	r18, Y+2	; 0x02
    133c:	3b 81       	ldd	r19, Y+3	; 0x03
    133e:	82 17       	cp	r24, r18
    1340:	93 07       	cpc	r25, r19
    1342:	70 f1       	brcs	.+92     	; 0x13a0 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1344:	88 81       	ld	r24, Y
    1346:	99 81       	ldd	r25, Y+1	; 0x01
    1348:	9d 83       	std	Y+5, r25	; 0x05
    134a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	2d c0       	rjmp	.+90     	; 0x13aa <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1350:	48 2f       	mov	r20, r24
    1352:	50 e0       	ldi	r21, 0x00	; 0
    1354:	8e 81       	ldd	r24, Y+6	; 0x06
    1356:	9f 81       	ldd	r25, Y+7	; 0x07
    1358:	0e 94 e5 15 	call	0x2bca	; 0x2bca <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    135c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	31 95       	neg	r19
    1362:	21 95       	neg	r18
    1364:	31 09       	sbc	r19, r1
    1366:	8e 81       	ldd	r24, Y+6	; 0x06
    1368:	9f 81       	ldd	r25, Y+7	; 0x07
    136a:	82 0f       	add	r24, r18
    136c:	93 1f       	adc	r25, r19
    136e:	9f 83       	std	Y+7, r25	; 0x07
    1370:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1372:	68 81       	ld	r22, Y
    1374:	79 81       	ldd	r23, Y+1	; 0x01
    1376:	86 17       	cp	r24, r22
    1378:	97 07       	cpc	r25, r23
    137a:	30 f4       	brcc	.+12     	; 0x1388 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	9b 81       	ldd	r25, Y+3	; 0x03
    1380:	28 0f       	add	r18, r24
    1382:	39 1f       	adc	r19, r25
    1384:	3f 83       	std	Y+7, r19	; 0x07
    1386:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1388:	12 30       	cpi	r17, 0x02	; 2
    138a:	61 f4       	brne	.+24     	; 0x13a4 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    138c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    138e:	88 23       	and	r24, r24
    1390:	59 f0       	breq	.+22     	; 0x13a8 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1392:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1394:	81 50       	subi	r24, 0x01	; 1
    1396:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1398:	80 e0       	ldi	r24, 0x00	; 0
    139a:	07 c0       	rjmp	.+14     	; 0x13aa <prvCopyDataToQueue+0xb6>
    139c:	80 e0       	ldi	r24, 0x00	; 0
    139e:	05 c0       	rjmp	.+10     	; 0x13aa <prvCopyDataToQueue+0xb6>
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	03 c0       	rjmp	.+6      	; 0x13aa <prvCopyDataToQueue+0xb6>
    13a4:	80 e0       	ldi	r24, 0x00	; 0
    13a6:	01 c0       	rjmp	.+2      	; 0x13aa <prvCopyDataToQueue+0xb6>
    13a8:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    13aa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    13ac:	9f 5f       	subi	r25, 0xFF	; 255
    13ae:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    13b0:	df 91       	pop	r29
    13b2:	cf 91       	pop	r28
    13b4:	1f 91       	pop	r17
    13b6:	08 95       	ret

000013b8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    13b8:	fc 01       	movw	r30, r24
    13ba:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    13bc:	44 8d       	ldd	r20, Z+28	; 0x1c
    13be:	44 23       	and	r20, r20
    13c0:	a1 f0       	breq	.+40     	; 0x13ea <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    13c2:	50 e0       	ldi	r21, 0x00	; 0
    13c4:	26 81       	ldd	r18, Z+6	; 0x06
    13c6:	37 81       	ldd	r19, Z+7	; 0x07
    13c8:	24 0f       	add	r18, r20
    13ca:	35 1f       	adc	r19, r21
    13cc:	37 83       	std	Z+7, r19	; 0x07
    13ce:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    13d0:	62 81       	ldd	r22, Z+2	; 0x02
    13d2:	73 81       	ldd	r23, Z+3	; 0x03
    13d4:	26 17       	cp	r18, r22
    13d6:	37 07       	cpc	r19, r23
    13d8:	20 f0       	brcs	.+8      	; 0x13e2 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    13da:	20 81       	ld	r18, Z
    13dc:	31 81       	ldd	r19, Z+1	; 0x01
    13de:	37 83       	std	Z+7, r19	; 0x07
    13e0:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    13e2:	66 81       	ldd	r22, Z+6	; 0x06
    13e4:	77 81       	ldd	r23, Z+7	; 0x07
    13e6:	0c 94 e5 15 	jmp	0x2bca	; 0x2bca <memcpy>
    13ea:	08 95       	ret

000013ec <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    13ec:	0f 93       	push	r16
    13ee:	1f 93       	push	r17
    13f0:	cf 93       	push	r28
    13f2:	df 93       	push	r29
    13f4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	f8 94       	cli
    13fa:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13fe:	18 16       	cp	r1, r24
    1400:	a4 f4       	brge	.+40     	; 0x142a <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1402:	89 89       	ldd	r24, Y+17	; 0x11
    1404:	88 23       	and	r24, r24
    1406:	89 f0       	breq	.+34     	; 0x142a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1408:	8e 01       	movw	r16, r28
    140a:	0f 5e       	subi	r16, 0xEF	; 239
    140c:	1f 4f       	sbci	r17, 0xFF	; 255
    140e:	03 c0       	rjmp	.+6      	; 0x1416 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1410:	89 89       	ldd	r24, Y+17	; 0x11
    1412:	88 23       	and	r24, r24
    1414:	51 f0       	breq	.+20     	; 0x142a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1416:	c8 01       	movw	r24, r16
    1418:	1f d7       	rcall	.+3646   	; 0x2258 <xTaskRemoveFromEventList>
    141a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    141c:	a8 d7       	rcall	.+3920   	; 0x236e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    141e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1420:	81 50       	subi	r24, 0x01	; 1
    1422:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1424:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1426:	18 16       	cp	r1, r24
    1428:	9c f3       	brlt	.-26     	; 0x1410 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    142a:	8f ef       	ldi	r24, 0xFF	; 255
    142c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    142e:	0f 90       	pop	r0
    1430:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1432:	0f b6       	in	r0, 0x3f	; 63
    1434:	f8 94       	cli
    1436:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1438:	8d 8d       	ldd	r24, Y+29	; 0x1d
    143a:	18 16       	cp	r1, r24
    143c:	a4 f4       	brge	.+40     	; 0x1466 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    143e:	88 85       	ldd	r24, Y+8	; 0x08
    1440:	88 23       	and	r24, r24
    1442:	89 f0       	breq	.+34     	; 0x1466 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1444:	8e 01       	movw	r16, r28
    1446:	08 5f       	subi	r16, 0xF8	; 248
    1448:	1f 4f       	sbci	r17, 0xFF	; 255
    144a:	03 c0       	rjmp	.+6      	; 0x1452 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    144c:	88 85       	ldd	r24, Y+8	; 0x08
    144e:	88 23       	and	r24, r24
    1450:	51 f0       	breq	.+20     	; 0x1466 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1452:	c8 01       	movw	r24, r16
    1454:	01 d7       	rcall	.+3586   	; 0x2258 <xTaskRemoveFromEventList>
    1456:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1458:	8a d7       	rcall	.+3860   	; 0x236e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    145a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    145c:	81 50       	subi	r24, 0x01	; 1
    145e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1460:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1462:	18 16       	cp	r1, r24
    1464:	9c f3       	brlt	.-26     	; 0x144c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1466:	8f ef       	ldi	r24, 0xFF	; 255
    1468:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    146a:	0f 90       	pop	r0
    146c:	0f be       	out	0x3f, r0	; 63
}
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	1f 91       	pop	r17
    1474:	0f 91       	pop	r16
    1476:	08 95       	ret

00001478 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1484:	88 81       	ld	r24, Y
    1486:	99 81       	ldd	r25, Y+1	; 0x01
    1488:	2c 8d       	ldd	r18, Y+28	; 0x1c
    148a:	30 e0       	ldi	r19, 0x00	; 0
    148c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    148e:	72 9f       	mul	r23, r18
    1490:	a0 01       	movw	r20, r0
    1492:	73 9f       	mul	r23, r19
    1494:	50 0d       	add	r21, r0
    1496:	11 24       	eor	r1, r1
    1498:	fc 01       	movw	r30, r24
    149a:	e4 0f       	add	r30, r20
    149c:	f5 1f       	adc	r31, r21
    149e:	fb 83       	std	Y+3, r31	; 0x03
    14a0:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    14a2:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    14a4:	9d 83       	std	Y+5, r25	; 0x05
    14a6:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    14a8:	42 1b       	sub	r20, r18
    14aa:	53 0b       	sbc	r21, r19
    14ac:	84 0f       	add	r24, r20
    14ae:	95 1f       	adc	r25, r21
    14b0:	9f 83       	std	Y+7, r25	; 0x07
    14b2:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    14b4:	8f ef       	ldi	r24, 0xFF	; 255
    14b6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    14b8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    14ba:	61 11       	cpse	r22, r1
    14bc:	0a c0       	rjmp	.+20     	; 0x14d2 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14be:	88 85       	ldd	r24, Y+8	; 0x08
    14c0:	88 23       	and	r24, r24
    14c2:	69 f0       	breq	.+26     	; 0x14de <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    14c4:	ce 01       	movw	r24, r28
    14c6:	08 96       	adiw	r24, 0x08	; 8
    14c8:	c7 d6       	rcall	.+3470   	; 0x2258 <xTaskRemoveFromEventList>
    14ca:	81 30       	cpi	r24, 0x01	; 1
    14cc:	41 f4       	brne	.+16     	; 0x14de <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    14ce:	4e de       	rcall	.-868    	; 0x116c <vPortYield>
    14d0:	06 c0       	rjmp	.+12     	; 0x14de <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    14d2:	ce 01       	movw	r24, r28
    14d4:	08 96       	adiw	r24, 0x08	; 8
    14d6:	0a d9       	rcall	.-3564   	; 0x6ec <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    14d8:	ce 01       	movw	r24, r28
    14da:	41 96       	adiw	r24, 0x11	; 17
    14dc:	07 d9       	rcall	.-3570   	; 0x6ec <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    14de:	0f 90       	pop	r0
    14e0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	08 95       	ret

000014ea <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	cf 93       	push	r28
    14f0:	df 93       	push	r29
    14f2:	18 2f       	mov	r17, r24
    14f4:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    14f6:	88 23       	and	r24, r24
    14f8:	d1 f0       	breq	.+52     	; 0x152e <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    14fa:	8f e1       	ldi	r24, 0x1F	; 31
    14fc:	90 e0       	ldi	r25, 0x00	; 0
    14fe:	c0 d8       	rcall	.-3712   	; 0x680 <pvPortMalloc>
    1500:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1502:	00 97       	sbiw	r24, 0x00	; 0
    1504:	b1 f0       	breq	.+44     	; 0x1532 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1506:	10 9f       	mul	r17, r16
    1508:	c0 01       	movw	r24, r0
    150a:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    150c:	01 96       	adiw	r24, 0x01	; 1
    150e:	b8 d8       	rcall	.-3728   	; 0x680 <pvPortMalloc>
    1510:	99 83       	std	Y+1, r25	; 0x01
    1512:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1514:	89 2b       	or	r24, r25
    1516:	31 f0       	breq	.+12     	; 0x1524 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1518:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    151a:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    151c:	61 e0       	ldi	r22, 0x01	; 1
    151e:	ce 01       	movw	r24, r28
    1520:	ab df       	rcall	.-170    	; 0x1478 <xQueueGenericReset>
    1522:	07 c0       	rjmp	.+14     	; 0x1532 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1524:	ce 01       	movw	r24, r28
    1526:	e1 d8       	rcall	.-3646   	; 0x6ea <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1528:	c0 e0       	ldi	r28, 0x00	; 0
    152a:	d0 e0       	ldi	r29, 0x00	; 0
    152c:	02 c0       	rjmp	.+4      	; 0x1532 <xQueueGenericCreate+0x48>
    152e:	c0 e0       	ldi	r28, 0x00	; 0
    1530:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1532:	ce 01       	movw	r24, r28
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	08 95       	ret

0000153e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    153e:	9f 92       	push	r9
    1540:	af 92       	push	r10
    1542:	bf 92       	push	r11
    1544:	cf 92       	push	r12
    1546:	df 92       	push	r13
    1548:	ef 92       	push	r14
    154a:	ff 92       	push	r15
    154c:	0f 93       	push	r16
    154e:	1f 93       	push	r17
    1550:	cf 93       	push	r28
    1552:	df 93       	push	r29
    1554:	00 d0       	rcall	.+0      	; 0x1556 <xQueueGenericSend+0x18>
    1556:	1f 92       	push	r1
    1558:	1f 92       	push	r1
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
    155e:	8c 01       	movw	r16, r24
    1560:	6b 01       	movw	r12, r22
    1562:	5d 83       	std	Y+5, r21	; 0x05
    1564:	4c 83       	std	Y+4, r20	; 0x04
    1566:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1568:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    156a:	99 24       	eor	r9, r9
    156c:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    156e:	7c 01       	movw	r14, r24
    1570:	88 e0       	ldi	r24, 0x08	; 8
    1572:	e8 0e       	add	r14, r24
    1574:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	f8 94       	cli
    157a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    157c:	f8 01       	movw	r30, r16
    157e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1580:	83 8d       	ldd	r24, Z+27	; 0x1b
    1582:	98 17       	cp	r25, r24
    1584:	18 f0       	brcs	.+6      	; 0x158c <xQueueGenericSend+0x4e>
    1586:	f2 e0       	ldi	r31, 0x02	; 2
    1588:	af 12       	cpse	r10, r31
    158a:	15 c0       	rjmp	.+42     	; 0x15b6 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    158c:	4a 2d       	mov	r20, r10
    158e:	b6 01       	movw	r22, r12
    1590:	c8 01       	movw	r24, r16
    1592:	b0 de       	rcall	.-672    	; 0x12f4 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1594:	f8 01       	movw	r30, r16
    1596:	91 89       	ldd	r25, Z+17	; 0x11
    1598:	99 23       	and	r25, r25
    159a:	39 f0       	breq	.+14     	; 0x15aa <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    159c:	c8 01       	movw	r24, r16
    159e:	41 96       	adiw	r24, 0x11	; 17
    15a0:	5b d6       	rcall	.+3254   	; 0x2258 <xTaskRemoveFromEventList>
    15a2:	81 30       	cpi	r24, 0x01	; 1
    15a4:	21 f4       	brne	.+8      	; 0x15ae <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    15a6:	e2 dd       	rcall	.-1084   	; 0x116c <vPortYield>
    15a8:	02 c0       	rjmp	.+4      	; 0x15ae <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    15aa:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    15ac:	df dd       	rcall	.-1090   	; 0x116c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    15ae:	0f 90       	pop	r0
    15b0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	46 c0       	rjmp	.+140    	; 0x1642 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15b6:	ec 81       	ldd	r30, Y+4	; 0x04
    15b8:	fd 81       	ldd	r31, Y+5	; 0x05
    15ba:	ef 2b       	or	r30, r31
    15bc:	21 f4       	brne	.+8      	; 0x15c6 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    15be:	0f 90       	pop	r0
    15c0:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    15c2:	80 e0       	ldi	r24, 0x00	; 0
    15c4:	3e c0       	rjmp	.+124    	; 0x1642 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    15c6:	b1 10       	cpse	r11, r1
    15c8:	04 c0       	rjmp	.+8      	; 0x15d2 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15ca:	ce 01       	movw	r24, r28
    15cc:	01 96       	adiw	r24, 0x01	; 1
    15ce:	8c d6       	rcall	.+3352   	; 0x22e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    15d0:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15d6:	83 d3       	rcall	.+1798   	; 0x1cde <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	0f 92       	push	r0
    15de:	f8 01       	movw	r30, r16
    15e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    15e2:	8f 3f       	cpi	r24, 0xFF	; 255
    15e4:	09 f4       	brne	.+2      	; 0x15e8 <xQueueGenericSend+0xaa>
    15e6:	15 8e       	std	Z+29, r1	; 0x1d
    15e8:	f8 01       	movw	r30, r16
    15ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ec:	8f 3f       	cpi	r24, 0xFF	; 255
    15ee:	09 f4       	brne	.+2      	; 0x15f2 <xQueueGenericSend+0xb4>
    15f0:	16 8e       	std	Z+30, r1	; 0x1e
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15f6:	be 01       	movw	r22, r28
    15f8:	6c 5f       	subi	r22, 0xFC	; 252
    15fa:	7f 4f       	sbci	r23, 0xFF	; 255
    15fc:	ce 01       	movw	r24, r28
    15fe:	01 96       	adiw	r24, 0x01	; 1
    1600:	7e d6       	rcall	.+3324   	; 0x22fe <xTaskCheckForTimeOut>
    1602:	81 11       	cpse	r24, r1
    1604:	1a c0       	rjmp	.+52     	; 0x163a <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1606:	0f b6       	in	r0, 0x3f	; 63
    1608:	f8 94       	cli
    160a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    160c:	f8 01       	movw	r30, r16
    160e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1610:	0f 90       	pop	r0
    1612:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1614:	f8 01       	movw	r30, r16
    1616:	83 8d       	ldd	r24, Z+27	; 0x1b
    1618:	98 13       	cpse	r25, r24
    161a:	0b c0       	rjmp	.+22     	; 0x1632 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    161c:	6c 81       	ldd	r22, Y+4	; 0x04
    161e:	7d 81       	ldd	r23, Y+5	; 0x05
    1620:	c7 01       	movw	r24, r14
    1622:	ef d5       	rcall	.+3038   	; 0x2202 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1624:	c8 01       	movw	r24, r16
    1626:	e2 de       	rcall	.-572    	; 0x13ec <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1628:	2d d4       	rcall	.+2138   	; 0x1e84 <xTaskResumeAll>
    162a:	81 11       	cpse	r24, r1
    162c:	a4 cf       	rjmp	.-184    	; 0x1576 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    162e:	9e dd       	rcall	.-1220   	; 0x116c <vPortYield>
    1630:	a2 cf       	rjmp	.-188    	; 0x1576 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1632:	c8 01       	movw	r24, r16
    1634:	db de       	rcall	.-586    	; 0x13ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1636:	26 d4       	rcall	.+2124   	; 0x1e84 <xTaskResumeAll>
    1638:	9e cf       	rjmp	.-196    	; 0x1576 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    163a:	c8 01       	movw	r24, r16
    163c:	d7 de       	rcall	.-594    	; 0x13ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    163e:	22 d4       	rcall	.+2116   	; 0x1e84 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1640:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1642:	0f 90       	pop	r0
    1644:	0f 90       	pop	r0
    1646:	0f 90       	pop	r0
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	ff 90       	pop	r15
    1656:	ef 90       	pop	r14
    1658:	df 90       	pop	r13
    165a:	cf 90       	pop	r12
    165c:	bf 90       	pop	r11
    165e:	af 90       	pop	r10
    1660:	9f 90       	pop	r9
    1662:	08 95       	ret

00001664 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1664:	cf 93       	push	r28
    1666:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1668:	8f e1       	ldi	r24, 0x1F	; 31
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	09 d8       	rcall	.-4078   	; 0x680 <pvPortMalloc>
    166e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1670:	00 97       	sbiw	r24, 0x00	; 0
    1672:	e1 f0       	breq	.+56     	; 0x16ac <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    1674:	1b 82       	std	Y+3, r1	; 0x03
    1676:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    1678:	19 82       	std	Y+1, r1	; 0x01
    167a:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    167c:	1d 82       	std	Y+5, r1	; 0x05
    167e:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    1680:	1f 82       	std	Y+7, r1	; 0x07
    1682:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1684:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    168a:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    168c:	8f ef       	ldi	r24, 0xFF	; 255
    168e:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    1690:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1692:	ce 01       	movw	r24, r28
    1694:	08 96       	adiw	r24, 0x08	; 8
    1696:	2a d8       	rcall	.-4012   	; 0x6ec <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1698:	ce 01       	movw	r24, r28
    169a:	41 96       	adiw	r24, 0x11	; 17
    169c:	27 d8       	rcall	.-4018   	; 0x6ec <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    169e:	20 e0       	ldi	r18, 0x00	; 0
    16a0:	40 e0       	ldi	r20, 0x00	; 0
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	60 e0       	ldi	r22, 0x00	; 0
    16a6:	70 e0       	ldi	r23, 0x00	; 0
    16a8:	ce 01       	movw	r24, r28
    16aa:	49 df       	rcall	.-366    	; 0x153e <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    16ac:	ce 01       	movw	r24, r28
    16ae:	df 91       	pop	r29
    16b0:	cf 91       	pop	r28
    16b2:	08 95       	ret

000016b4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    16b4:	0f 93       	push	r16
    16b6:	1f 93       	push	r17
    16b8:	cf 93       	push	r28
    16ba:	df 93       	push	r29
    16bc:	ec 01       	movw	r28, r24
    16be:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    16c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    16c2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    16c4:	98 17       	cp	r25, r24
    16c6:	10 f0       	brcs	.+4      	; 0x16cc <xQueueGenericSendFromISR+0x18>
    16c8:	22 30       	cpi	r18, 0x02	; 2
    16ca:	11 f5       	brne	.+68     	; 0x1710 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    16cc:	42 2f       	mov	r20, r18
    16ce:	ce 01       	movw	r24, r28
    16d0:	11 de       	rcall	.-990    	; 0x12f4 <prvCopyDataToQueue>
    16d2:	88 23       	and	r24, r24
    16d4:	31 f0       	breq	.+12     	; 0x16e2 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    16d6:	01 15       	cp	r16, r1
    16d8:	11 05       	cpc	r17, r1
    16da:	19 f0       	breq	.+6      	; 0x16e2 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	f8 01       	movw	r30, r16
    16e0:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    16e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16e4:	8f 3f       	cpi	r24, 0xFF	; 255
    16e6:	79 f4       	brne	.+30     	; 0x1706 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16e8:	89 89       	ldd	r24, Y+17	; 0x11
    16ea:	88 23       	and	r24, r24
    16ec:	99 f0       	breq	.+38     	; 0x1714 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16ee:	ce 01       	movw	r24, r28
    16f0:	41 96       	adiw	r24, 0x11	; 17
    16f2:	b2 d5       	rcall	.+2916   	; 0x2258 <xTaskRemoveFromEventList>
    16f4:	88 23       	and	r24, r24
    16f6:	81 f0       	breq	.+32     	; 0x1718 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16f8:	01 15       	cp	r16, r1
    16fa:	11 05       	cpc	r17, r1
    16fc:	79 f0       	breq	.+30     	; 0x171c <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	f8 01       	movw	r30, r16
    1702:	80 83       	st	Z, r24
    1704:	0c c0       	rjmp	.+24     	; 0x171e <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1706:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1708:	8f 5f       	subi	r24, 0xFF	; 255
    170a:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    170c:	81 e0       	ldi	r24, 0x01	; 1
    170e:	07 c0       	rjmp	.+14     	; 0x171e <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	05 c0       	rjmp	.+10     	; 0x171e <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1714:	81 e0       	ldi	r24, 0x01	; 1
    1716:	03 c0       	rjmp	.+6      	; 0x171e <xQueueGenericSendFromISR+0x6a>
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	01 c0       	rjmp	.+2      	; 0x171e <xQueueGenericSendFromISR+0x6a>
    171c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    171e:	df 91       	pop	r29
    1720:	cf 91       	pop	r28
    1722:	1f 91       	pop	r17
    1724:	0f 91       	pop	r16
    1726:	08 95       	ret

00001728 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1728:	9f 92       	push	r9
    172a:	af 92       	push	r10
    172c:	bf 92       	push	r11
    172e:	cf 92       	push	r12
    1730:	df 92       	push	r13
    1732:	ef 92       	push	r14
    1734:	ff 92       	push	r15
    1736:	0f 93       	push	r16
    1738:	1f 93       	push	r17
    173a:	cf 93       	push	r28
    173c:	df 93       	push	r29
    173e:	00 d0       	rcall	.+0      	; 0x1740 <xQueueGenericReceive+0x18>
    1740:	1f 92       	push	r1
    1742:	1f 92       	push	r1
    1744:	cd b7       	in	r28, 0x3d	; 61
    1746:	de b7       	in	r29, 0x3e	; 62
    1748:	8c 01       	movw	r16, r24
    174a:	6b 01       	movw	r12, r22
    174c:	5d 83       	std	Y+5, r21	; 0x05
    174e:	4c 83       	std	Y+4, r20	; 0x04
    1750:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1752:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1754:	99 24       	eor	r9, r9
    1756:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1758:	7c 01       	movw	r14, r24
    175a:	81 e1       	ldi	r24, 0x11	; 17
    175c:	e8 0e       	add	r14, r24
    175e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1766:	f8 01       	movw	r30, r16
    1768:	82 8d       	ldd	r24, Z+26	; 0x1a
    176a:	88 23       	and	r24, r24
    176c:	69 f1       	breq	.+90     	; 0x17c8 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    176e:	e6 80       	ldd	r14, Z+6	; 0x06
    1770:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1772:	b6 01       	movw	r22, r12
    1774:	c8 01       	movw	r24, r16
    1776:	20 de       	rcall	.-960    	; 0x13b8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1778:	b1 10       	cpse	r11, r1
    177a:	17 c0       	rjmp	.+46     	; 0x17aa <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    177c:	f8 01       	movw	r30, r16
    177e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1780:	81 50       	subi	r24, 0x01	; 1
    1782:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1784:	80 81       	ld	r24, Z
    1786:	91 81       	ldd	r25, Z+1	; 0x01
    1788:	89 2b       	or	r24, r25
    178a:	21 f4       	brne	.+8      	; 0x1794 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    178c:	91 d6       	rcall	.+3362   	; 0x24b0 <pvTaskIncrementMutexHeldCount>
    178e:	f8 01       	movw	r30, r16
    1790:	93 83       	std	Z+3, r25	; 0x03
    1792:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1794:	f8 01       	movw	r30, r16
    1796:	80 85       	ldd	r24, Z+8	; 0x08
    1798:	88 23       	and	r24, r24
    179a:	91 f0       	breq	.+36     	; 0x17c0 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    179c:	c8 01       	movw	r24, r16
    179e:	08 96       	adiw	r24, 0x08	; 8
    17a0:	5b d5       	rcall	.+2742   	; 0x2258 <xTaskRemoveFromEventList>
    17a2:	81 30       	cpi	r24, 0x01	; 1
    17a4:	69 f4       	brne	.+26     	; 0x17c0 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    17a6:	e2 dc       	rcall	.-1596   	; 0x116c <vPortYield>
    17a8:	0b c0       	rjmp	.+22     	; 0x17c0 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    17aa:	f8 01       	movw	r30, r16
    17ac:	f7 82       	std	Z+7, r15	; 0x07
    17ae:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17b0:	81 89       	ldd	r24, Z+17	; 0x11
    17b2:	88 23       	and	r24, r24
    17b4:	29 f0       	breq	.+10     	; 0x17c0 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17b6:	c8 01       	movw	r24, r16
    17b8:	41 96       	adiw	r24, 0x11	; 17
    17ba:	4e d5       	rcall	.+2716   	; 0x2258 <xTaskRemoveFromEventList>
    17bc:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    17be:	d6 dc       	rcall	.-1620   	; 0x116c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    17c0:	0f 90       	pop	r0
    17c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	52 c0       	rjmp	.+164    	; 0x186c <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17c8:	4c 81       	ldd	r20, Y+4	; 0x04
    17ca:	5d 81       	ldd	r21, Y+5	; 0x05
    17cc:	45 2b       	or	r20, r21
    17ce:	21 f4       	brne	.+8      	; 0x17d8 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17d0:	0f 90       	pop	r0
    17d2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	4a c0       	rjmp	.+148    	; 0x186c <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    17d8:	a1 10       	cpse	r10, r1
    17da:	04 c0       	rjmp	.+8      	; 0x17e4 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    17dc:	ce 01       	movw	r24, r28
    17de:	01 96       	adiw	r24, 0x01	; 1
    17e0:	83 d5       	rcall	.+2822   	; 0x22e8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17e2:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    17e4:	0f 90       	pop	r0
    17e6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17e8:	7a d2       	rcall	.+1268   	; 0x1cde <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17ea:	0f b6       	in	r0, 0x3f	; 63
    17ec:	f8 94       	cli
    17ee:	0f 92       	push	r0
    17f0:	f8 01       	movw	r30, r16
    17f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f4:	8f 3f       	cpi	r24, 0xFF	; 255
    17f6:	09 f4       	brne	.+2      	; 0x17fa <xQueueGenericReceive+0xd2>
    17f8:	15 8e       	std	Z+29, r1	; 0x1d
    17fa:	f8 01       	movw	r30, r16
    17fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    17fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1800:	09 f4       	brne	.+2      	; 0x1804 <xQueueGenericReceive+0xdc>
    1802:	16 8e       	std	Z+30, r1	; 0x1e
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1808:	be 01       	movw	r22, r28
    180a:	6c 5f       	subi	r22, 0xFC	; 252
    180c:	7f 4f       	sbci	r23, 0xFF	; 255
    180e:	ce 01       	movw	r24, r28
    1810:	01 96       	adiw	r24, 0x01	; 1
    1812:	75 d5       	rcall	.+2794   	; 0x22fe <xTaskCheckForTimeOut>
    1814:	81 11       	cpse	r24, r1
    1816:	26 c0       	rjmp	.+76     	; 0x1864 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    181e:	f8 01       	movw	r30, r16
    1820:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1826:	81 11       	cpse	r24, r1
    1828:	19 c0       	rjmp	.+50     	; 0x185c <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    182a:	f8 01       	movw	r30, r16
    182c:	80 81       	ld	r24, Z
    182e:	91 81       	ldd	r25, Z+1	; 0x01
    1830:	89 2b       	or	r24, r25
    1832:	49 f4       	brne	.+18     	; 0x1846 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1834:	0f b6       	in	r0, 0x3f	; 63
    1836:	f8 94       	cli
    1838:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    183a:	f8 01       	movw	r30, r16
    183c:	82 81       	ldd	r24, Z+2	; 0x02
    183e:	93 81       	ldd	r25, Z+3	; 0x03
    1840:	9a d5       	rcall	.+2868   	; 0x2376 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1842:	0f 90       	pop	r0
    1844:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1846:	6c 81       	ldd	r22, Y+4	; 0x04
    1848:	7d 81       	ldd	r23, Y+5	; 0x05
    184a:	c7 01       	movw	r24, r14
    184c:	da d4       	rcall	.+2484   	; 0x2202 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    184e:	c8 01       	movw	r24, r16
    1850:	cd dd       	rcall	.-1126   	; 0x13ec <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1852:	18 d3       	rcall	.+1584   	; 0x1e84 <xTaskResumeAll>
    1854:	81 11       	cpse	r24, r1
    1856:	84 cf       	rjmp	.-248    	; 0x1760 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1858:	89 dc       	rcall	.-1774   	; 0x116c <vPortYield>
    185a:	82 cf       	rjmp	.-252    	; 0x1760 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    185c:	c8 01       	movw	r24, r16
    185e:	c6 dd       	rcall	.-1140   	; 0x13ec <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1860:	11 d3       	rcall	.+1570   	; 0x1e84 <xTaskResumeAll>
    1862:	7e cf       	rjmp	.-260    	; 0x1760 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1864:	c8 01       	movw	r24, r16
    1866:	c2 dd       	rcall	.-1148   	; 0x13ec <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1868:	0d d3       	rcall	.+1562   	; 0x1e84 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    186a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    186c:	0f 90       	pop	r0
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	0f 90       	pop	r0
    1874:	0f 90       	pop	r0
    1876:	df 91       	pop	r29
    1878:	cf 91       	pop	r28
    187a:	1f 91       	pop	r17
    187c:	0f 91       	pop	r16
    187e:	ff 90       	pop	r15
    1880:	ef 90       	pop	r14
    1882:	df 90       	pop	r13
    1884:	cf 90       	pop	r12
    1886:	bf 90       	pop	r11
    1888:	af 90       	pop	r10
    188a:	9f 90       	pop	r9
    188c:	08 95       	ret

0000188e <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    188e:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    1890:	71 83       	std	Z+1, r23	; 0x01
    1892:	60 83       	st	Z, r22
	ring->rSize = size;
    1894:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1896:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1898:	13 82       	std	Z+3, r1	; 0x03
    189a:	08 95       	ret

0000189c <ringBufferPeek>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
    189c:	dc 01       	movw	r26, r24
    189e:	14 96       	adiw	r26, 0x04	; 4
    18a0:	2c 91       	ld	r18, X
    18a2:	14 97       	sbiw	r26, 0x04	; 4
    18a4:	ed 91       	ld	r30, X+
    18a6:	fc 91       	ld	r31, X
    18a8:	e2 0f       	add	r30, r18
    18aa:	f1 1d       	adc	r31, r1
}
    18ac:	80 81       	ld	r24, Z
    18ae:	08 95       	ret

000018b0 <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    18b0:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    18b2:	94 81       	ldd	r25, Z+4	; 0x04
    18b4:	a0 81       	ld	r26, Z
    18b6:	b1 81       	ldd	r27, Z+1	; 0x01
    18b8:	a9 0f       	add	r26, r25
    18ba:	b1 1d       	adc	r27, r1
    18bc:	8c 91       	ld	r24, X
            ring->rIndex ++;
    18be:	9f 5f       	subi	r25, 0xFF	; 255
    18c0:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    18c2:	22 81       	ldd	r18, Z+2	; 0x02
    18c4:	92 17       	cp	r25, r18
    18c6:	10 f0       	brcs	.+4      	; 0x18cc <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    18c8:	92 1b       	sub	r25, r18
    18ca:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    18cc:	93 81       	ldd	r25, Z+3	; 0x03
    18ce:	91 50       	subi	r25, 0x01	; 1
    18d0:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    18d2:	08 95       	ret

000018d4 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    18d4:	fc 01       	movw	r30, r24
    18d6:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    18d8:	83 81       	ldd	r24, Z+3	; 0x03
    18da:	22 81       	ldd	r18, Z+2	; 0x02
    18dc:	82 17       	cp	r24, r18
    18de:	80 f4       	brcc	.+32     	; 0x1900 <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    18e0:	34 81       	ldd	r19, Z+4	; 0x04
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	83 0f       	add	r24, r19
    18e6:	91 1d       	adc	r25, r1
    18e8:	62 2f       	mov	r22, r18
    18ea:	70 e0       	ldi	r23, 0x00	; 0
    18ec:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <__divmodhi4>
    18f0:	a0 81       	ld	r26, Z
    18f2:	b1 81       	ldd	r27, Z+1	; 0x01
    18f4:	a8 0f       	add	r26, r24
    18f6:	b9 1f       	adc	r27, r25
    18f8:	4c 93       	st	X, r20
            ring->rLength++;
    18fa:	83 81       	ldd	r24, Z+3	; 0x03
    18fc:	8f 5f       	subi	r24, 0xFF	; 255
    18fe:	83 83       	std	Z+3, r24	; 0x03
    1900:	08 95       	ret

00001902 <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1902:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1904:	81 e0       	ldi	r24, 0x01	; 1
    1906:	22 81       	ldd	r18, Z+2	; 0x02
    1908:	93 81       	ldd	r25, Z+3	; 0x03
    190a:	29 13       	cpse	r18, r25
    190c:	80 e0       	ldi	r24, 0x00	; 0
}
    190e:	08 95       	ret

00001910 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1910:	21 e0       	ldi	r18, 0x01	; 1
    1912:	fc 01       	movw	r30, r24
    1914:	83 81       	ldd	r24, Z+3	; 0x03
    1916:	81 11       	cpse	r24, r1
    1918:	01 c0       	rjmp	.+2      	; 0x191c <ringBufferNotEmpty+0xc>
    191a:	20 e0       	ldi	r18, 0x00	; 0
}
    191c:	82 2f       	mov	r24, r18
    191e:	08 95       	ret

00001920 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1920:	e0 91 4c 08 	lds	r30, 0x084C
    1924:	f0 91 4d 08 	lds	r31, 0x084D
    1928:	80 81       	ld	r24, Z
    192a:	81 11       	cpse	r24, r1
    192c:	07 c0       	rjmp	.+14     	; 0x193c <prvResetNextTaskUnblockTime+0x1c>
    192e:	8f ef       	ldi	r24, 0xFF	; 255
    1930:	9f ef       	ldi	r25, 0xFF	; 255
    1932:	90 93 05 02 	sts	0x0205, r25
    1936:	80 93 04 02 	sts	0x0204, r24
    193a:	08 95       	ret
    193c:	e0 91 4c 08 	lds	r30, 0x084C
    1940:	f0 91 4d 08 	lds	r31, 0x084D
    1944:	05 80       	ldd	r0, Z+5	; 0x05
    1946:	f6 81       	ldd	r31, Z+6	; 0x06
    1948:	e0 2d       	mov	r30, r0
    194a:	06 80       	ldd	r0, Z+6	; 0x06
    194c:	f7 81       	ldd	r31, Z+7	; 0x07
    194e:	e0 2d       	mov	r30, r0
    1950:	82 81       	ldd	r24, Z+2	; 0x02
    1952:	93 81       	ldd	r25, Z+3	; 0x03
    1954:	90 93 05 02 	sts	0x0205, r25
    1958:	80 93 04 02 	sts	0x0204, r24
    195c:	08 95       	ret

0000195e <prvAddCurrentTaskToDelayedList>:
    195e:	cf 93       	push	r28
    1960:	df 93       	push	r29
    1962:	ec 01       	movw	r28, r24
    1964:	e0 91 8d 08 	lds	r30, 0x088D
    1968:	f0 91 8e 08 	lds	r31, 0x088E
    196c:	93 83       	std	Z+3, r25	; 0x03
    196e:	82 83       	std	Z+2, r24	; 0x02
    1970:	80 91 2b 08 	lds	r24, 0x082B
    1974:	90 91 2c 08 	lds	r25, 0x082C
    1978:	c8 17       	cp	r28, r24
    197a:	d9 07       	cpc	r29, r25
    197c:	68 f4       	brcc	.+26     	; 0x1998 <prvAddCurrentTaskToDelayedList+0x3a>
    197e:	60 91 8d 08 	lds	r22, 0x088D
    1982:	70 91 8e 08 	lds	r23, 0x088E
    1986:	80 91 4a 08 	lds	r24, 0x084A
    198a:	90 91 4b 08 	lds	r25, 0x084B
    198e:	6e 5f       	subi	r22, 0xFE	; 254
    1990:	7f 4f       	sbci	r23, 0xFF	; 255
    1992:	0e 94 a9 03 	call	0x752	; 0x752 <vListInsert>
    1996:	17 c0       	rjmp	.+46     	; 0x19c6 <prvAddCurrentTaskToDelayedList+0x68>
    1998:	60 91 8d 08 	lds	r22, 0x088D
    199c:	70 91 8e 08 	lds	r23, 0x088E
    19a0:	80 91 4c 08 	lds	r24, 0x084C
    19a4:	90 91 4d 08 	lds	r25, 0x084D
    19a8:	6e 5f       	subi	r22, 0xFE	; 254
    19aa:	7f 4f       	sbci	r23, 0xFF	; 255
    19ac:	0e 94 a9 03 	call	0x752	; 0x752 <vListInsert>
    19b0:	80 91 04 02 	lds	r24, 0x0204
    19b4:	90 91 05 02 	lds	r25, 0x0205
    19b8:	c8 17       	cp	r28, r24
    19ba:	d9 07       	cpc	r29, r25
    19bc:	20 f4       	brcc	.+8      	; 0x19c6 <prvAddCurrentTaskToDelayedList+0x68>
    19be:	d0 93 05 02 	sts	0x0205, r29
    19c2:	c0 93 04 02 	sts	0x0204, r28
    19c6:	df 91       	pop	r29
    19c8:	cf 91       	pop	r28
    19ca:	08 95       	ret

000019cc <xTaskGenericCreate>:
    19cc:	4f 92       	push	r4
    19ce:	5f 92       	push	r5
    19d0:	6f 92       	push	r6
    19d2:	7f 92       	push	r7
    19d4:	8f 92       	push	r8
    19d6:	9f 92       	push	r9
    19d8:	af 92       	push	r10
    19da:	bf 92       	push	r11
    19dc:	cf 92       	push	r12
    19de:	df 92       	push	r13
    19e0:	ef 92       	push	r14
    19e2:	ff 92       	push	r15
    19e4:	0f 93       	push	r16
    19e6:	1f 93       	push	r17
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	4c 01       	movw	r8, r24
    19ee:	5b 01       	movw	r10, r22
    19f0:	2a 01       	movw	r4, r20
    19f2:	39 01       	movw	r6, r18
    19f4:	83 e2       	ldi	r24, 0x23	; 35
    19f6:	90 e0       	ldi	r25, 0x00	; 0
    19f8:	0e 94 40 03 	call	0x680	; 0x680 <pvPortMalloc>
    19fc:	ec 01       	movw	r28, r24
    19fe:	00 97       	sbiw	r24, 0x00	; 0
    1a00:	09 f4       	brne	.+2      	; 0x1a04 <xTaskGenericCreate+0x38>
    1a02:	e7 c0       	rjmp	.+462    	; 0x1bd2 <xTaskGenericCreate+0x206>
    1a04:	c1 14       	cp	r12, r1
    1a06:	d1 04       	cpc	r13, r1
    1a08:	09 f0       	breq	.+2      	; 0x1a0c <xTaskGenericCreate+0x40>
    1a0a:	cc c0       	rjmp	.+408    	; 0x1ba4 <xTaskGenericCreate+0x1d8>
    1a0c:	c2 01       	movw	r24, r4
    1a0e:	0e 94 40 03 	call	0x680	; 0x680 <pvPortMalloc>
    1a12:	98 8f       	std	Y+24, r25	; 0x18
    1a14:	8f 8b       	std	Y+23, r24	; 0x17
    1a16:	89 2b       	or	r24, r25
    1a18:	09 f0       	breq	.+2      	; 0x1a1c <xTaskGenericCreate+0x50>
    1a1a:	c6 c0       	rjmp	.+396    	; 0x1ba8 <xTaskGenericCreate+0x1dc>
    1a1c:	ce 01       	movw	r24, r28
    1a1e:	0e 94 75 03 	call	0x6ea	; 0x6ea <vPortFree>
    1a22:	d7 c0       	rjmp	.+430    	; 0x1bd2 <xTaskGenericCreate+0x206>
    1a24:	cf 01       	movw	r24, r30
    1a26:	31 91       	ld	r19, Z+
    1a28:	da 01       	movw	r26, r20
    1a2a:	3d 93       	st	X+, r19
    1a2c:	ad 01       	movw	r20, r26
    1a2e:	dc 01       	movw	r26, r24
    1a30:	8c 91       	ld	r24, X
    1a32:	88 23       	and	r24, r24
    1a34:	11 f0       	breq	.+4      	; 0x1a3a <xTaskGenericCreate+0x6e>
    1a36:	21 50       	subi	r18, 0x01	; 1
    1a38:	a9 f7       	brne	.-22     	; 0x1a24 <xTaskGenericCreate+0x58>
    1a3a:	18 a2       	std	Y+32, r1	; 0x20
    1a3c:	10 2f       	mov	r17, r16
    1a3e:	05 30       	cpi	r16, 0x05	; 5
    1a40:	08 f0       	brcs	.+2      	; 0x1a44 <xTaskGenericCreate+0x78>
    1a42:	14 e0       	ldi	r17, 0x04	; 4
    1a44:	1e 8b       	std	Y+22, r17	; 0x16
    1a46:	19 a3       	std	Y+33, r17	; 0x21
    1a48:	1a a2       	std	Y+34, r1	; 0x22
    1a4a:	5e 01       	movw	r10, r28
    1a4c:	b2 e0       	ldi	r27, 0x02	; 2
    1a4e:	ab 0e       	add	r10, r27
    1a50:	b1 1c       	adc	r11, r1
    1a52:	c5 01       	movw	r24, r10
    1a54:	0e 94 84 03 	call	0x708	; 0x708 <vListInitialiseItem>
    1a58:	ce 01       	movw	r24, r28
    1a5a:	0c 96       	adiw	r24, 0x0c	; 12
    1a5c:	0e 94 84 03 	call	0x708	; 0x708 <vListInitialiseItem>
    1a60:	d9 87       	std	Y+9, r29	; 0x09
    1a62:	c8 87       	std	Y+8, r28	; 0x08
    1a64:	85 e0       	ldi	r24, 0x05	; 5
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	81 1b       	sub	r24, r17
    1a6a:	91 09       	sbc	r25, r1
    1a6c:	9d 87       	std	Y+13, r25	; 0x0d
    1a6e:	8c 87       	std	Y+12, r24	; 0x0c
    1a70:	db 8b       	std	Y+19, r29	; 0x13
    1a72:	ca 8b       	std	Y+18, r28	; 0x12
    1a74:	a3 01       	movw	r20, r6
    1a76:	b4 01       	movw	r22, r8
    1a78:	c6 01       	movw	r24, r12
    1a7a:	c9 da       	rcall	.-2670   	; 0x100e <pxPortInitialiseStack>
    1a7c:	99 83       	std	Y+1, r25	; 0x01
    1a7e:	88 83       	st	Y, r24
    1a80:	e1 14       	cp	r14, r1
    1a82:	f1 04       	cpc	r15, r1
    1a84:	19 f0       	breq	.+6      	; 0x1a8c <xTaskGenericCreate+0xc0>
    1a86:	f7 01       	movw	r30, r14
    1a88:	d1 83       	std	Z+1, r29	; 0x01
    1a8a:	c0 83       	st	Z, r28
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	f8 94       	cli
    1a90:	0f 92       	push	r0
    1a92:	80 91 2d 08 	lds	r24, 0x082D
    1a96:	8f 5f       	subi	r24, 0xFF	; 255
    1a98:	80 93 2d 08 	sts	0x082D, r24
    1a9c:	80 91 8d 08 	lds	r24, 0x088D
    1aa0:	90 91 8e 08 	lds	r25, 0x088E
    1aa4:	89 2b       	or	r24, r25
    1aa6:	09 f0       	breq	.+2      	; 0x1aaa <xTaskGenericCreate+0xde>
    1aa8:	3f c0       	rjmp	.+126    	; 0x1b28 <xTaskGenericCreate+0x15c>
    1aaa:	d0 93 8e 08 	sts	0x088E, r29
    1aae:	c0 93 8d 08 	sts	0x088D, r28
    1ab2:	80 91 2d 08 	lds	r24, 0x082D
    1ab6:	81 30       	cpi	r24, 0x01	; 1
    1ab8:	09 f0       	breq	.+2      	; 0x1abc <xTaskGenericCreate+0xf0>
    1aba:	45 c0       	rjmp	.+138    	; 0x1b46 <xTaskGenericCreate+0x17a>
    1abc:	0f 2e       	mov	r0, r31
    1abe:	f0 e6       	ldi	r31, 0x60	; 96
    1ac0:	ef 2e       	mov	r14, r31
    1ac2:	f8 e0       	ldi	r31, 0x08	; 8
    1ac4:	ff 2e       	mov	r15, r31
    1ac6:	f0 2d       	mov	r31, r0
    1ac8:	0f 2e       	mov	r0, r31
    1aca:	fd e8       	ldi	r31, 0x8D	; 141
    1acc:	cf 2e       	mov	r12, r31
    1ace:	f8 e0       	ldi	r31, 0x08	; 8
    1ad0:	df 2e       	mov	r13, r31
    1ad2:	f0 2d       	mov	r31, r0
    1ad4:	c7 01       	movw	r24, r14
    1ad6:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1ada:	f9 e0       	ldi	r31, 0x09	; 9
    1adc:	ef 0e       	add	r14, r31
    1ade:	f1 1c       	adc	r15, r1
    1ae0:	ec 14       	cp	r14, r12
    1ae2:	fd 04       	cpc	r15, r13
    1ae4:	b9 f7       	brne	.-18     	; 0x1ad4 <xTaskGenericCreate+0x108>
    1ae6:	87 e5       	ldi	r24, 0x57	; 87
    1ae8:	98 e0       	ldi	r25, 0x08	; 8
    1aea:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1aee:	8e e4       	ldi	r24, 0x4E	; 78
    1af0:	98 e0       	ldi	r25, 0x08	; 8
    1af2:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1af6:	81 e4       	ldi	r24, 0x41	; 65
    1af8:	98 e0       	ldi	r25, 0x08	; 8
    1afa:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1afe:	88 e3       	ldi	r24, 0x38	; 56
    1b00:	98 e0       	ldi	r25, 0x08	; 8
    1b02:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1b06:	8e e2       	ldi	r24, 0x2E	; 46
    1b08:	98 e0       	ldi	r25, 0x08	; 8
    1b0a:	0e 94 76 03 	call	0x6ec	; 0x6ec <vListInitialise>
    1b0e:	87 e5       	ldi	r24, 0x57	; 87
    1b10:	98 e0       	ldi	r25, 0x08	; 8
    1b12:	90 93 4d 08 	sts	0x084D, r25
    1b16:	80 93 4c 08 	sts	0x084C, r24
    1b1a:	8e e4       	ldi	r24, 0x4E	; 78
    1b1c:	98 e0       	ldi	r25, 0x08	; 8
    1b1e:	90 93 4b 08 	sts	0x084B, r25
    1b22:	80 93 4a 08 	sts	0x084A, r24
    1b26:	0f c0       	rjmp	.+30     	; 0x1b46 <xTaskGenericCreate+0x17a>
    1b28:	80 91 29 08 	lds	r24, 0x0829
    1b2c:	81 11       	cpse	r24, r1
    1b2e:	0b c0       	rjmp	.+22     	; 0x1b46 <xTaskGenericCreate+0x17a>
    1b30:	e0 91 8d 08 	lds	r30, 0x088D
    1b34:	f0 91 8e 08 	lds	r31, 0x088E
    1b38:	86 89       	ldd	r24, Z+22	; 0x16
    1b3a:	08 17       	cp	r16, r24
    1b3c:	20 f0       	brcs	.+8      	; 0x1b46 <xTaskGenericCreate+0x17a>
    1b3e:	d0 93 8e 08 	sts	0x088E, r29
    1b42:	c0 93 8d 08 	sts	0x088D, r28
    1b46:	80 91 25 08 	lds	r24, 0x0825
    1b4a:	8f 5f       	subi	r24, 0xFF	; 255
    1b4c:	80 93 25 08 	sts	0x0825, r24
    1b50:	8e 89       	ldd	r24, Y+22	; 0x16
    1b52:	90 91 2a 08 	lds	r25, 0x082A
    1b56:	98 17       	cp	r25, r24
    1b58:	10 f4       	brcc	.+4      	; 0x1b5e <xTaskGenericCreate+0x192>
    1b5a:	80 93 2a 08 	sts	0x082A, r24
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	9c 01       	movw	r18, r24
    1b62:	22 0f       	add	r18, r18
    1b64:	33 1f       	adc	r19, r19
    1b66:	22 0f       	add	r18, r18
    1b68:	33 1f       	adc	r19, r19
    1b6a:	22 0f       	add	r18, r18
    1b6c:	33 1f       	adc	r19, r19
    1b6e:	82 0f       	add	r24, r18
    1b70:	93 1f       	adc	r25, r19
    1b72:	b5 01       	movw	r22, r10
    1b74:	80 5a       	subi	r24, 0xA0	; 160
    1b76:	97 4f       	sbci	r25, 0xF7	; 247
    1b78:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    1b7c:	0f 90       	pop	r0
    1b7e:	0f be       	out	0x3f, r0	; 63
    1b80:	80 91 29 08 	lds	r24, 0x0829
    1b84:	88 23       	and	r24, r24
    1b86:	51 f0       	breq	.+20     	; 0x1b9c <xTaskGenericCreate+0x1d0>
    1b88:	e0 91 8d 08 	lds	r30, 0x088D
    1b8c:	f0 91 8e 08 	lds	r31, 0x088E
    1b90:	86 89       	ldd	r24, Z+22	; 0x16
    1b92:	80 17       	cp	r24, r16
    1b94:	28 f4       	brcc	.+10     	; 0x1ba0 <xTaskGenericCreate+0x1d4>
    1b96:	ea da       	rcall	.-2604   	; 0x116c <vPortYield>
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	1c c0       	rjmp	.+56     	; 0x1bd4 <xTaskGenericCreate+0x208>
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	1a c0       	rjmp	.+52     	; 0x1bd4 <xTaskGenericCreate+0x208>
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	18 c0       	rjmp	.+48     	; 0x1bd4 <xTaskGenericCreate+0x208>
    1ba4:	d8 8e       	std	Y+24, r13	; 0x18
    1ba6:	cf 8a       	std	Y+23, r12	; 0x17
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	48 1a       	sub	r4, r24
    1bac:	51 08       	sbc	r5, r1
    1bae:	cf 88       	ldd	r12, Y+23	; 0x17
    1bb0:	d8 8c       	ldd	r13, Y+24	; 0x18
    1bb2:	c4 0c       	add	r12, r4
    1bb4:	d5 1c       	adc	r13, r5
    1bb6:	d5 01       	movw	r26, r10
    1bb8:	8c 91       	ld	r24, X
    1bba:	89 8f       	std	Y+25, r24	; 0x19
    1bbc:	8c 91       	ld	r24, X
    1bbe:	88 23       	and	r24, r24
    1bc0:	09 f4       	brne	.+2      	; 0x1bc4 <xTaskGenericCreate+0x1f8>
    1bc2:	3b cf       	rjmp	.-394    	; 0x1a3a <xTaskGenericCreate+0x6e>
    1bc4:	ae 01       	movw	r20, r28
    1bc6:	46 5e       	subi	r20, 0xE6	; 230
    1bc8:	5f 4f       	sbci	r21, 0xFF	; 255
    1bca:	f5 01       	movw	r30, r10
    1bcc:	31 96       	adiw	r30, 0x01	; 1
    1bce:	27 e0       	ldi	r18, 0x07	; 7
    1bd0:	29 cf       	rjmp	.-430    	; 0x1a24 <xTaskGenericCreate+0x58>
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	df 91       	pop	r29
    1bd6:	cf 91       	pop	r28
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	ff 90       	pop	r15
    1bde:	ef 90       	pop	r14
    1be0:	df 90       	pop	r13
    1be2:	cf 90       	pop	r12
    1be4:	bf 90       	pop	r11
    1be6:	af 90       	pop	r10
    1be8:	9f 90       	pop	r9
    1bea:	8f 90       	pop	r8
    1bec:	7f 90       	pop	r7
    1bee:	6f 90       	pop	r6
    1bf0:	5f 90       	pop	r5
    1bf2:	4f 90       	pop	r4
    1bf4:	08 95       	ret

00001bf6 <vTaskResume>:
    1bf6:	0f 93       	push	r16
    1bf8:	1f 93       	push	r17
    1bfa:	cf 93       	push	r28
    1bfc:	df 93       	push	r29
    1bfe:	ec 01       	movw	r28, r24
    1c00:	00 97       	sbiw	r24, 0x00	; 0
    1c02:	09 f4       	brne	.+2      	; 0x1c06 <vTaskResume+0x10>
    1c04:	3e c0       	rjmp	.+124    	; 0x1c82 <vTaskResume+0x8c>
    1c06:	80 91 8d 08 	lds	r24, 0x088D
    1c0a:	90 91 8e 08 	lds	r25, 0x088E
    1c0e:	c8 17       	cp	r28, r24
    1c10:	d9 07       	cpc	r29, r25
    1c12:	b9 f1       	breq	.+110    	; 0x1c82 <vTaskResume+0x8c>
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	f8 94       	cli
    1c18:	0f 92       	push	r0
    1c1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c1e:	8e 52       	subi	r24, 0x2E	; 46
    1c20:	98 40       	sbci	r25, 0x08	; 8
    1c22:	69 f5       	brne	.+90     	; 0x1c7e <vTaskResume+0x88>
    1c24:	8c 89       	ldd	r24, Y+20	; 0x14
    1c26:	9d 89       	ldd	r25, Y+21	; 0x15
    1c28:	28 e0       	ldi	r18, 0x08	; 8
    1c2a:	81 34       	cpi	r24, 0x41	; 65
    1c2c:	92 07       	cpc	r25, r18
    1c2e:	39 f1       	breq	.+78     	; 0x1c7e <vTaskResume+0x88>
    1c30:	89 2b       	or	r24, r25
    1c32:	29 f5       	brne	.+74     	; 0x1c7e <vTaskResume+0x88>
    1c34:	8e 01       	movw	r16, r28
    1c36:	0e 5f       	subi	r16, 0xFE	; 254
    1c38:	1f 4f       	sbci	r17, 0xFF	; 255
    1c3a:	c8 01       	movw	r24, r16
    1c3c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1c40:	8e 89       	ldd	r24, Y+22	; 0x16
    1c42:	90 91 2a 08 	lds	r25, 0x082A
    1c46:	98 17       	cp	r25, r24
    1c48:	10 f4       	brcc	.+4      	; 0x1c4e <vTaskResume+0x58>
    1c4a:	80 93 2a 08 	sts	0x082A, r24
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	9c 01       	movw	r18, r24
    1c52:	22 0f       	add	r18, r18
    1c54:	33 1f       	adc	r19, r19
    1c56:	22 0f       	add	r18, r18
    1c58:	33 1f       	adc	r19, r19
    1c5a:	22 0f       	add	r18, r18
    1c5c:	33 1f       	adc	r19, r19
    1c5e:	82 0f       	add	r24, r18
    1c60:	93 1f       	adc	r25, r19
    1c62:	b8 01       	movw	r22, r16
    1c64:	80 5a       	subi	r24, 0xA0	; 160
    1c66:	97 4f       	sbci	r25, 0xF7	; 247
    1c68:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    1c6c:	e0 91 8d 08 	lds	r30, 0x088D
    1c70:	f0 91 8e 08 	lds	r31, 0x088E
    1c74:	9e 89       	ldd	r25, Y+22	; 0x16
    1c76:	86 89       	ldd	r24, Z+22	; 0x16
    1c78:	98 17       	cp	r25, r24
    1c7a:	08 f0       	brcs	.+2      	; 0x1c7e <vTaskResume+0x88>
    1c7c:	77 da       	rcall	.-2834   	; 0x116c <vPortYield>
    1c7e:	0f 90       	pop	r0
    1c80:	0f be       	out	0x3f, r0	; 63
    1c82:	df 91       	pop	r29
    1c84:	cf 91       	pop	r28
    1c86:	1f 91       	pop	r17
    1c88:	0f 91       	pop	r16
    1c8a:	08 95       	ret

00001c8c <vTaskStartScheduler>:
    1c8c:	af 92       	push	r10
    1c8e:	bf 92       	push	r11
    1c90:	cf 92       	push	r12
    1c92:	df 92       	push	r13
    1c94:	ef 92       	push	r14
    1c96:	ff 92       	push	r15
    1c98:	0f 93       	push	r16
    1c9a:	a1 2c       	mov	r10, r1
    1c9c:	b1 2c       	mov	r11, r1
    1c9e:	c1 2c       	mov	r12, r1
    1ca0:	d1 2c       	mov	r13, r1
    1ca2:	e1 2c       	mov	r14, r1
    1ca4:	f1 2c       	mov	r15, r1
    1ca6:	00 e0       	ldi	r16, 0x00	; 0
    1ca8:	20 e0       	ldi	r18, 0x00	; 0
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	45 e5       	ldi	r20, 0x55	; 85
    1cae:	50 e0       	ldi	r21, 0x00	; 0
    1cb0:	69 e3       	ldi	r22, 0x39	; 57
    1cb2:	72 e0       	ldi	r23, 0x02	; 2
    1cb4:	8d e1       	ldi	r24, 0x1D	; 29
    1cb6:	90 e1       	ldi	r25, 0x10	; 16
    1cb8:	89 de       	rcall	.-750    	; 0x19cc <xTaskGenericCreate>
    1cba:	81 30       	cpi	r24, 0x01	; 1
    1cbc:	41 f4       	brne	.+16     	; 0x1cce <vTaskStartScheduler+0x42>
    1cbe:	f8 94       	cli
    1cc0:	80 93 29 08 	sts	0x0829, r24
    1cc4:	10 92 2c 08 	sts	0x082C, r1
    1cc8:	10 92 2b 08 	sts	0x082B, r1
    1ccc:	12 da       	rcall	.-3036   	; 0x10f2 <xPortStartScheduler>
    1cce:	0f 91       	pop	r16
    1cd0:	ff 90       	pop	r15
    1cd2:	ef 90       	pop	r14
    1cd4:	df 90       	pop	r13
    1cd6:	cf 90       	pop	r12
    1cd8:	bf 90       	pop	r11
    1cda:	af 90       	pop	r10
    1cdc:	08 95       	ret

00001cde <vTaskSuspendAll>:
    1cde:	80 91 24 08 	lds	r24, 0x0824
    1ce2:	8f 5f       	subi	r24, 0xFF	; 255
    1ce4:	80 93 24 08 	sts	0x0824, r24
    1ce8:	08 95       	ret

00001cea <xTaskGetTickCount>:
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	0f 92       	push	r0
    1cf0:	80 91 2b 08 	lds	r24, 0x082B
    1cf4:	90 91 2c 08 	lds	r25, 0x082C
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	08 95       	ret

00001cfe <xTaskGetTickCountFromISR>:
    1cfe:	80 91 2b 08 	lds	r24, 0x082B
    1d02:	90 91 2c 08 	lds	r25, 0x082C
    1d06:	08 95       	ret

00001d08 <xTaskIncrementTick>:
    1d08:	cf 92       	push	r12
    1d0a:	df 92       	push	r13
    1d0c:	ef 92       	push	r14
    1d0e:	ff 92       	push	r15
    1d10:	0f 93       	push	r16
    1d12:	1f 93       	push	r17
    1d14:	cf 93       	push	r28
    1d16:	df 93       	push	r29
    1d18:	80 91 24 08 	lds	r24, 0x0824
    1d1c:	81 11       	cpse	r24, r1
    1d1e:	99 c0       	rjmp	.+306    	; 0x1e52 <xTaskIncrementTick+0x14a>
    1d20:	80 91 2b 08 	lds	r24, 0x082B
    1d24:	90 91 2c 08 	lds	r25, 0x082C
    1d28:	01 96       	adiw	r24, 0x01	; 1
    1d2a:	90 93 2c 08 	sts	0x082C, r25
    1d2e:	80 93 2b 08 	sts	0x082B, r24
    1d32:	e0 90 2b 08 	lds	r14, 0x082B
    1d36:	f0 90 2c 08 	lds	r15, 0x082C
    1d3a:	e1 14       	cp	r14, r1
    1d3c:	f1 04       	cpc	r15, r1
    1d3e:	b1 f4       	brne	.+44     	; 0x1d6c <xTaskIncrementTick+0x64>
    1d40:	80 91 4c 08 	lds	r24, 0x084C
    1d44:	90 91 4d 08 	lds	r25, 0x084D
    1d48:	20 91 4a 08 	lds	r18, 0x084A
    1d4c:	30 91 4b 08 	lds	r19, 0x084B
    1d50:	30 93 4d 08 	sts	0x084D, r19
    1d54:	20 93 4c 08 	sts	0x084C, r18
    1d58:	90 93 4b 08 	sts	0x084B, r25
    1d5c:	80 93 4a 08 	sts	0x084A, r24
    1d60:	80 91 26 08 	lds	r24, 0x0826
    1d64:	8f 5f       	subi	r24, 0xFF	; 255
    1d66:	80 93 26 08 	sts	0x0826, r24
    1d6a:	da dd       	rcall	.-1100   	; 0x1920 <prvResetNextTaskUnblockTime>
    1d6c:	80 91 04 02 	lds	r24, 0x0204
    1d70:	90 91 05 02 	lds	r25, 0x0205
    1d74:	e8 16       	cp	r14, r24
    1d76:	f9 06       	cpc	r15, r25
    1d78:	08 f4       	brcc	.+2      	; 0x1d7c <xTaskIncrementTick+0x74>
    1d7a:	54 c0       	rjmp	.+168    	; 0x1e24 <xTaskIncrementTick+0x11c>
    1d7c:	d1 2c       	mov	r13, r1
    1d7e:	cc 24       	eor	r12, r12
    1d80:	c3 94       	inc	r12
    1d82:	01 c0       	rjmp	.+2      	; 0x1d86 <xTaskIncrementTick+0x7e>
    1d84:	dc 2c       	mov	r13, r12
    1d86:	e0 91 4c 08 	lds	r30, 0x084C
    1d8a:	f0 91 4d 08 	lds	r31, 0x084D
    1d8e:	80 81       	ld	r24, Z
    1d90:	81 11       	cpse	r24, r1
    1d92:	07 c0       	rjmp	.+14     	; 0x1da2 <xTaskIncrementTick+0x9a>
    1d94:	8f ef       	ldi	r24, 0xFF	; 255
    1d96:	9f ef       	ldi	r25, 0xFF	; 255
    1d98:	90 93 05 02 	sts	0x0205, r25
    1d9c:	80 93 04 02 	sts	0x0204, r24
    1da0:	42 c0       	rjmp	.+132    	; 0x1e26 <xTaskIncrementTick+0x11e>
    1da2:	e0 91 4c 08 	lds	r30, 0x084C
    1da6:	f0 91 4d 08 	lds	r31, 0x084D
    1daa:	05 80       	ldd	r0, Z+5	; 0x05
    1dac:	f6 81       	ldd	r31, Z+6	; 0x06
    1dae:	e0 2d       	mov	r30, r0
    1db0:	c6 81       	ldd	r28, Z+6	; 0x06
    1db2:	d7 81       	ldd	r29, Z+7	; 0x07
    1db4:	2a 81       	ldd	r18, Y+2	; 0x02
    1db6:	3b 81       	ldd	r19, Y+3	; 0x03
    1db8:	e2 16       	cp	r14, r18
    1dba:	f3 06       	cpc	r15, r19
    1dbc:	28 f4       	brcc	.+10     	; 0x1dc8 <xTaskIncrementTick+0xc0>
    1dbe:	30 93 05 02 	sts	0x0205, r19
    1dc2:	20 93 04 02 	sts	0x0204, r18
    1dc6:	2f c0       	rjmp	.+94     	; 0x1e26 <xTaskIncrementTick+0x11e>
    1dc8:	8e 01       	movw	r16, r28
    1dca:	0e 5f       	subi	r16, 0xFE	; 254
    1dcc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dce:	c8 01       	movw	r24, r16
    1dd0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1dd4:	8c 89       	ldd	r24, Y+20	; 0x14
    1dd6:	9d 89       	ldd	r25, Y+21	; 0x15
    1dd8:	89 2b       	or	r24, r25
    1dda:	21 f0       	breq	.+8      	; 0x1de4 <xTaskIncrementTick+0xdc>
    1ddc:	ce 01       	movw	r24, r28
    1dde:	0c 96       	adiw	r24, 0x0c	; 12
    1de0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1de4:	2e 89       	ldd	r18, Y+22	; 0x16
    1de6:	80 91 2a 08 	lds	r24, 0x082A
    1dea:	82 17       	cp	r24, r18
    1dec:	10 f4       	brcc	.+4      	; 0x1df2 <xTaskIncrementTick+0xea>
    1dee:	20 93 2a 08 	sts	0x082A, r18
    1df2:	30 e0       	ldi	r19, 0x00	; 0
    1df4:	c9 01       	movw	r24, r18
    1df6:	88 0f       	add	r24, r24
    1df8:	99 1f       	adc	r25, r25
    1dfa:	88 0f       	add	r24, r24
    1dfc:	99 1f       	adc	r25, r25
    1dfe:	88 0f       	add	r24, r24
    1e00:	99 1f       	adc	r25, r25
    1e02:	82 0f       	add	r24, r18
    1e04:	93 1f       	adc	r25, r19
    1e06:	b8 01       	movw	r22, r16
    1e08:	80 5a       	subi	r24, 0xA0	; 160
    1e0a:	97 4f       	sbci	r25, 0xF7	; 247
    1e0c:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    1e10:	e0 91 8d 08 	lds	r30, 0x088D
    1e14:	f0 91 8e 08 	lds	r31, 0x088E
    1e18:	9e 89       	ldd	r25, Y+22	; 0x16
    1e1a:	86 89       	ldd	r24, Z+22	; 0x16
    1e1c:	98 17       	cp	r25, r24
    1e1e:	08 f0       	brcs	.+2      	; 0x1e22 <xTaskIncrementTick+0x11a>
    1e20:	b1 cf       	rjmp	.-158    	; 0x1d84 <xTaskIncrementTick+0x7c>
    1e22:	b1 cf       	rjmp	.-158    	; 0x1d86 <xTaskIncrementTick+0x7e>
    1e24:	d1 2c       	mov	r13, r1
    1e26:	e0 91 8d 08 	lds	r30, 0x088D
    1e2a:	f0 91 8e 08 	lds	r31, 0x088E
    1e2e:	86 89       	ldd	r24, Z+22	; 0x16
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	fc 01       	movw	r30, r24
    1e34:	ee 0f       	add	r30, r30
    1e36:	ff 1f       	adc	r31, r31
    1e38:	ee 0f       	add	r30, r30
    1e3a:	ff 1f       	adc	r31, r31
    1e3c:	ee 0f       	add	r30, r30
    1e3e:	ff 1f       	adc	r31, r31
    1e40:	8e 0f       	add	r24, r30
    1e42:	9f 1f       	adc	r25, r31
    1e44:	fc 01       	movw	r30, r24
    1e46:	e0 5a       	subi	r30, 0xA0	; 160
    1e48:	f7 4f       	sbci	r31, 0xF7	; 247
    1e4a:	80 81       	ld	r24, Z
    1e4c:	82 30       	cpi	r24, 0x02	; 2
    1e4e:	40 f4       	brcc	.+16     	; 0x1e60 <xTaskIncrementTick+0x158>
    1e50:	09 c0       	rjmp	.+18     	; 0x1e64 <xTaskIncrementTick+0x15c>
    1e52:	80 91 28 08 	lds	r24, 0x0828
    1e56:	8f 5f       	subi	r24, 0xFF	; 255
    1e58:	80 93 28 08 	sts	0x0828, r24
    1e5c:	d1 2c       	mov	r13, r1
    1e5e:	02 c0       	rjmp	.+4      	; 0x1e64 <xTaskIncrementTick+0x15c>
    1e60:	dd 24       	eor	r13, r13
    1e62:	d3 94       	inc	r13
    1e64:	80 91 27 08 	lds	r24, 0x0827
    1e68:	88 23       	and	r24, r24
    1e6a:	11 f0       	breq	.+4      	; 0x1e70 <xTaskIncrementTick+0x168>
    1e6c:	dd 24       	eor	r13, r13
    1e6e:	d3 94       	inc	r13
    1e70:	8d 2d       	mov	r24, r13
    1e72:	df 91       	pop	r29
    1e74:	cf 91       	pop	r28
    1e76:	1f 91       	pop	r17
    1e78:	0f 91       	pop	r16
    1e7a:	ff 90       	pop	r15
    1e7c:	ef 90       	pop	r14
    1e7e:	df 90       	pop	r13
    1e80:	cf 90       	pop	r12
    1e82:	08 95       	ret

00001e84 <xTaskResumeAll>:
    1e84:	df 92       	push	r13
    1e86:	ef 92       	push	r14
    1e88:	ff 92       	push	r15
    1e8a:	0f 93       	push	r16
    1e8c:	1f 93       	push	r17
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	0f b6       	in	r0, 0x3f	; 63
    1e94:	f8 94       	cli
    1e96:	0f 92       	push	r0
    1e98:	80 91 24 08 	lds	r24, 0x0824
    1e9c:	81 50       	subi	r24, 0x01	; 1
    1e9e:	80 93 24 08 	sts	0x0824, r24
    1ea2:	80 91 24 08 	lds	r24, 0x0824
    1ea6:	81 11       	cpse	r24, r1
    1ea8:	5f c0       	rjmp	.+190    	; 0x1f68 <xTaskResumeAll+0xe4>
    1eaa:	80 91 2d 08 	lds	r24, 0x082D
    1eae:	88 23       	and	r24, r24
    1eb0:	09 f4       	brne	.+2      	; 0x1eb4 <xTaskResumeAll+0x30>
    1eb2:	5c c0       	rjmp	.+184    	; 0x1f6c <xTaskResumeAll+0xe8>
    1eb4:	0f 2e       	mov	r0, r31
    1eb6:	f1 e4       	ldi	r31, 0x41	; 65
    1eb8:	ef 2e       	mov	r14, r31
    1eba:	f8 e0       	ldi	r31, 0x08	; 8
    1ebc:	ff 2e       	mov	r15, r31
    1ebe:	f0 2d       	mov	r31, r0
    1ec0:	dd 24       	eor	r13, r13
    1ec2:	d3 94       	inc	r13
    1ec4:	30 c0       	rjmp	.+96     	; 0x1f26 <xTaskResumeAll+0xa2>
    1ec6:	e0 91 46 08 	lds	r30, 0x0846
    1eca:	f0 91 47 08 	lds	r31, 0x0847
    1ece:	c6 81       	ldd	r28, Z+6	; 0x06
    1ed0:	d7 81       	ldd	r29, Z+7	; 0x07
    1ed2:	ce 01       	movw	r24, r28
    1ed4:	0c 96       	adiw	r24, 0x0c	; 12
    1ed6:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1eda:	8e 01       	movw	r16, r28
    1edc:	0e 5f       	subi	r16, 0xFE	; 254
    1ede:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee0:	c8 01       	movw	r24, r16
    1ee2:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1ee6:	8e 89       	ldd	r24, Y+22	; 0x16
    1ee8:	90 91 2a 08 	lds	r25, 0x082A
    1eec:	98 17       	cp	r25, r24
    1eee:	10 f4       	brcc	.+4      	; 0x1ef4 <xTaskResumeAll+0x70>
    1ef0:	80 93 2a 08 	sts	0x082A, r24
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	9c 01       	movw	r18, r24
    1ef8:	22 0f       	add	r18, r18
    1efa:	33 1f       	adc	r19, r19
    1efc:	22 0f       	add	r18, r18
    1efe:	33 1f       	adc	r19, r19
    1f00:	22 0f       	add	r18, r18
    1f02:	33 1f       	adc	r19, r19
    1f04:	82 0f       	add	r24, r18
    1f06:	93 1f       	adc	r25, r19
    1f08:	b8 01       	movw	r22, r16
    1f0a:	80 5a       	subi	r24, 0xA0	; 160
    1f0c:	97 4f       	sbci	r25, 0xF7	; 247
    1f0e:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    1f12:	e0 91 8d 08 	lds	r30, 0x088D
    1f16:	f0 91 8e 08 	lds	r31, 0x088E
    1f1a:	9e 89       	ldd	r25, Y+22	; 0x16
    1f1c:	86 89       	ldd	r24, Z+22	; 0x16
    1f1e:	98 17       	cp	r25, r24
    1f20:	10 f0       	brcs	.+4      	; 0x1f26 <xTaskResumeAll+0xa2>
    1f22:	d0 92 27 08 	sts	0x0827, r13
    1f26:	f7 01       	movw	r30, r14
    1f28:	80 81       	ld	r24, Z
    1f2a:	81 11       	cpse	r24, r1
    1f2c:	cc cf       	rjmp	.-104    	; 0x1ec6 <xTaskResumeAll+0x42>
    1f2e:	80 91 28 08 	lds	r24, 0x0828
    1f32:	88 23       	and	r24, r24
    1f34:	91 f0       	breq	.+36     	; 0x1f5a <xTaskResumeAll+0xd6>
    1f36:	80 91 28 08 	lds	r24, 0x0828
    1f3a:	88 23       	and	r24, r24
    1f3c:	71 f0       	breq	.+28     	; 0x1f5a <xTaskResumeAll+0xd6>
    1f3e:	c1 e0       	ldi	r28, 0x01	; 1
    1f40:	e3 de       	rcall	.-570    	; 0x1d08 <xTaskIncrementTick>
    1f42:	81 11       	cpse	r24, r1
    1f44:	c0 93 27 08 	sts	0x0827, r28
    1f48:	80 91 28 08 	lds	r24, 0x0828
    1f4c:	81 50       	subi	r24, 0x01	; 1
    1f4e:	80 93 28 08 	sts	0x0828, r24
    1f52:	80 91 28 08 	lds	r24, 0x0828
    1f56:	81 11       	cpse	r24, r1
    1f58:	f3 cf       	rjmp	.-26     	; 0x1f40 <xTaskResumeAll+0xbc>
    1f5a:	80 91 27 08 	lds	r24, 0x0827
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	39 f4       	brne	.+14     	; 0x1f70 <xTaskResumeAll+0xec>
    1f62:	04 d9       	rcall	.-3576   	; 0x116c <vPortYield>
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	05 c0       	rjmp	.+10     	; 0x1f72 <xTaskResumeAll+0xee>
    1f68:	80 e0       	ldi	r24, 0x00	; 0
    1f6a:	03 c0       	rjmp	.+6      	; 0x1f72 <xTaskResumeAll+0xee>
    1f6c:	80 e0       	ldi	r24, 0x00	; 0
    1f6e:	01 c0       	rjmp	.+2      	; 0x1f72 <xTaskResumeAll+0xee>
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	0f 90       	pop	r0
    1f74:	0f be       	out	0x3f, r0	; 63
    1f76:	df 91       	pop	r29
    1f78:	cf 91       	pop	r28
    1f7a:	1f 91       	pop	r17
    1f7c:	0f 91       	pop	r16
    1f7e:	ff 90       	pop	r15
    1f80:	ef 90       	pop	r14
    1f82:	df 90       	pop	r13
    1f84:	08 95       	ret

00001f86 <vTaskDelayUntil>:
    1f86:	0f 93       	push	r16
    1f88:	1f 93       	push	r17
    1f8a:	cf 93       	push	r28
    1f8c:	df 93       	push	r29
    1f8e:	8c 01       	movw	r16, r24
    1f90:	eb 01       	movw	r28, r22
    1f92:	a5 de       	rcall	.-694    	; 0x1cde <vTaskSuspendAll>
    1f94:	80 91 2b 08 	lds	r24, 0x082B
    1f98:	90 91 2c 08 	lds	r25, 0x082C
    1f9c:	f8 01       	movw	r30, r16
    1f9e:	20 81       	ld	r18, Z
    1fa0:	31 81       	ldd	r19, Z+1	; 0x01
    1fa2:	c2 0f       	add	r28, r18
    1fa4:	d3 1f       	adc	r29, r19
    1fa6:	82 17       	cp	r24, r18
    1fa8:	93 07       	cpc	r25, r19
    1faa:	48 f4       	brcc	.+18     	; 0x1fbe <vTaskDelayUntil+0x38>
    1fac:	c2 17       	cp	r28, r18
    1fae:	d3 07       	cpc	r29, r19
    1fb0:	f8 f4       	brcc	.+62     	; 0x1ff0 <vTaskDelayUntil+0x6a>
    1fb2:	d1 83       	std	Z+1, r29	; 0x01
    1fb4:	c0 83       	st	Z, r28
    1fb6:	8c 17       	cp	r24, r28
    1fb8:	9d 07       	cpc	r25, r29
    1fba:	88 f4       	brcc	.+34     	; 0x1fde <vTaskDelayUntil+0x58>
    1fbc:	07 c0       	rjmp	.+14     	; 0x1fcc <vTaskDelayUntil+0x46>
    1fbe:	c2 17       	cp	r28, r18
    1fc0:	d3 07       	cpc	r29, r19
    1fc2:	90 f0       	brcs	.+36     	; 0x1fe8 <vTaskDelayUntil+0x62>
    1fc4:	8c 17       	cp	r24, r28
    1fc6:	9d 07       	cpc	r25, r29
    1fc8:	78 f0       	brcs	.+30     	; 0x1fe8 <vTaskDelayUntil+0x62>
    1fca:	12 c0       	rjmp	.+36     	; 0x1ff0 <vTaskDelayUntil+0x6a>
    1fcc:	80 91 8d 08 	lds	r24, 0x088D
    1fd0:	90 91 8e 08 	lds	r25, 0x088E
    1fd4:	02 96       	adiw	r24, 0x02	; 2
    1fd6:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    1fda:	ce 01       	movw	r24, r28
    1fdc:	c0 dc       	rcall	.-1664   	; 0x195e <prvAddCurrentTaskToDelayedList>
    1fde:	52 df       	rcall	.-348    	; 0x1e84 <xTaskResumeAll>
    1fe0:	81 11       	cpse	r24, r1
    1fe2:	0a c0       	rjmp	.+20     	; 0x1ff8 <vTaskDelayUntil+0x72>
    1fe4:	c3 d8       	rcall	.-3706   	; 0x116c <vPortYield>
    1fe6:	08 c0       	rjmp	.+16     	; 0x1ff8 <vTaskDelayUntil+0x72>
    1fe8:	f8 01       	movw	r30, r16
    1fea:	d1 83       	std	Z+1, r29	; 0x01
    1fec:	c0 83       	st	Z, r28
    1fee:	ee cf       	rjmp	.-36     	; 0x1fcc <vTaskDelayUntil+0x46>
    1ff0:	f8 01       	movw	r30, r16
    1ff2:	d1 83       	std	Z+1, r29	; 0x01
    1ff4:	c0 83       	st	Z, r28
    1ff6:	f3 cf       	rjmp	.-26     	; 0x1fde <vTaskDelayUntil+0x58>
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	08 95       	ret

00002002 <vTaskDelay>:
    2002:	cf 93       	push	r28
    2004:	df 93       	push	r29
    2006:	ec 01       	movw	r28, r24
    2008:	00 97       	sbiw	r24, 0x00	; 0
    200a:	99 f0       	breq	.+38     	; 0x2032 <vTaskDelay+0x30>
    200c:	68 de       	rcall	.-816    	; 0x1cde <vTaskSuspendAll>
    200e:	80 91 2b 08 	lds	r24, 0x082B
    2012:	90 91 2c 08 	lds	r25, 0x082C
    2016:	c8 0f       	add	r28, r24
    2018:	d9 1f       	adc	r29, r25
    201a:	80 91 8d 08 	lds	r24, 0x088D
    201e:	90 91 8e 08 	lds	r25, 0x088E
    2022:	02 96       	adiw	r24, 0x02	; 2
    2024:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    2028:	ce 01       	movw	r24, r28
    202a:	99 dc       	rcall	.-1742   	; 0x195e <prvAddCurrentTaskToDelayedList>
    202c:	2b df       	rcall	.-426    	; 0x1e84 <xTaskResumeAll>
    202e:	81 11       	cpse	r24, r1
    2030:	01 c0       	rjmp	.+2      	; 0x2034 <vTaskDelay+0x32>
    2032:	9c d8       	rcall	.-3784   	; 0x116c <vPortYield>
    2034:	df 91       	pop	r29
    2036:	cf 91       	pop	r28
    2038:	08 95       	ret

0000203a <prvIdleTask>:
    203a:	0f 2e       	mov	r0, r31
    203c:	f0 e6       	ldi	r31, 0x60	; 96
    203e:	ef 2e       	mov	r14, r31
    2040:	f8 e0       	ldi	r31, 0x08	; 8
    2042:	ff 2e       	mov	r15, r31
    2044:	f0 2d       	mov	r31, r0
    2046:	c8 e3       	ldi	r28, 0x38	; 56
    2048:	d8 e0       	ldi	r29, 0x08	; 8
    204a:	26 c0       	rjmp	.+76     	; 0x2098 <prvIdleTask+0x5e>
    204c:	48 de       	rcall	.-880    	; 0x1cde <vTaskSuspendAll>
    204e:	18 81       	ld	r17, Y
    2050:	19 df       	rcall	.-462    	; 0x1e84 <xTaskResumeAll>
    2052:	11 23       	and	r17, r17
    2054:	09 f1       	breq	.+66     	; 0x2098 <prvIdleTask+0x5e>
    2056:	0f b6       	in	r0, 0x3f	; 63
    2058:	f8 94       	cli
    205a:	0f 92       	push	r0
    205c:	e0 91 3d 08 	lds	r30, 0x083D
    2060:	f0 91 3e 08 	lds	r31, 0x083E
    2064:	06 81       	ldd	r16, Z+6	; 0x06
    2066:	17 81       	ldd	r17, Z+7	; 0x07
    2068:	c8 01       	movw	r24, r16
    206a:	02 96       	adiw	r24, 0x02	; 2
    206c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    2070:	80 91 2d 08 	lds	r24, 0x082D
    2074:	81 50       	subi	r24, 0x01	; 1
    2076:	80 93 2d 08 	sts	0x082D, r24
    207a:	80 91 37 08 	lds	r24, 0x0837
    207e:	81 50       	subi	r24, 0x01	; 1
    2080:	80 93 37 08 	sts	0x0837, r24
    2084:	0f 90       	pop	r0
    2086:	0f be       	out	0x3f, r0	; 63
    2088:	f8 01       	movw	r30, r16
    208a:	87 89       	ldd	r24, Z+23	; 0x17
    208c:	90 8d       	ldd	r25, Z+24	; 0x18
    208e:	0e 94 75 03 	call	0x6ea	; 0x6ea <vPortFree>
    2092:	c8 01       	movw	r24, r16
    2094:	0e 94 75 03 	call	0x6ea	; 0x6ea <vPortFree>
    2098:	80 91 37 08 	lds	r24, 0x0837
    209c:	81 11       	cpse	r24, r1
    209e:	d6 cf       	rjmp	.-84     	; 0x204c <prvIdleTask+0x12>
    20a0:	f7 01       	movw	r30, r14
    20a2:	80 81       	ld	r24, Z
    20a4:	82 30       	cpi	r24, 0x02	; 2
    20a6:	c0 f3       	brcs	.-16     	; 0x2098 <prvIdleTask+0x5e>
    20a8:	61 d8       	rcall	.-3902   	; 0x116c <vPortYield>
    20aa:	f6 cf       	rjmp	.-20     	; 0x2098 <prvIdleTask+0x5e>

000020ac <vTaskSwitchContext>:
    20ac:	80 91 24 08 	lds	r24, 0x0824
    20b0:	88 23       	and	r24, r24
    20b2:	21 f0       	breq	.+8      	; 0x20bc <vTaskSwitchContext+0x10>
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	80 93 27 08 	sts	0x0827, r24
    20ba:	08 95       	ret
    20bc:	10 92 27 08 	sts	0x0827, r1
    20c0:	80 91 2a 08 	lds	r24, 0x082A
    20c4:	90 e0       	ldi	r25, 0x00	; 0
    20c6:	fc 01       	movw	r30, r24
    20c8:	ee 0f       	add	r30, r30
    20ca:	ff 1f       	adc	r31, r31
    20cc:	ee 0f       	add	r30, r30
    20ce:	ff 1f       	adc	r31, r31
    20d0:	ee 0f       	add	r30, r30
    20d2:	ff 1f       	adc	r31, r31
    20d4:	8e 0f       	add	r24, r30
    20d6:	9f 1f       	adc	r25, r31
    20d8:	fc 01       	movw	r30, r24
    20da:	e0 5a       	subi	r30, 0xA0	; 160
    20dc:	f7 4f       	sbci	r31, 0xF7	; 247
    20de:	80 81       	ld	r24, Z
    20e0:	81 11       	cpse	r24, r1
    20e2:	17 c0       	rjmp	.+46     	; 0x2112 <vTaskSwitchContext+0x66>
    20e4:	80 91 2a 08 	lds	r24, 0x082A
    20e8:	81 50       	subi	r24, 0x01	; 1
    20ea:	80 93 2a 08 	sts	0x082A, r24
    20ee:	80 91 2a 08 	lds	r24, 0x082A
    20f2:	90 e0       	ldi	r25, 0x00	; 0
    20f4:	fc 01       	movw	r30, r24
    20f6:	ee 0f       	add	r30, r30
    20f8:	ff 1f       	adc	r31, r31
    20fa:	ee 0f       	add	r30, r30
    20fc:	ff 1f       	adc	r31, r31
    20fe:	ee 0f       	add	r30, r30
    2100:	ff 1f       	adc	r31, r31
    2102:	8e 0f       	add	r24, r30
    2104:	9f 1f       	adc	r25, r31
    2106:	fc 01       	movw	r30, r24
    2108:	e0 5a       	subi	r30, 0xA0	; 160
    210a:	f7 4f       	sbci	r31, 0xF7	; 247
    210c:	80 81       	ld	r24, Z
    210e:	88 23       	and	r24, r24
    2110:	49 f3       	breq	.-46     	; 0x20e4 <vTaskSwitchContext+0x38>
    2112:	e0 91 2a 08 	lds	r30, 0x082A
    2116:	f0 e0       	ldi	r31, 0x00	; 0
    2118:	cf 01       	movw	r24, r30
    211a:	88 0f       	add	r24, r24
    211c:	99 1f       	adc	r25, r25
    211e:	88 0f       	add	r24, r24
    2120:	99 1f       	adc	r25, r25
    2122:	88 0f       	add	r24, r24
    2124:	99 1f       	adc	r25, r25
    2126:	e8 0f       	add	r30, r24
    2128:	f9 1f       	adc	r31, r25
    212a:	e0 5a       	subi	r30, 0xA0	; 160
    212c:	f7 4f       	sbci	r31, 0xF7	; 247
    212e:	a1 81       	ldd	r26, Z+1	; 0x01
    2130:	b2 81       	ldd	r27, Z+2	; 0x02
    2132:	12 96       	adiw	r26, 0x02	; 2
    2134:	0d 90       	ld	r0, X+
    2136:	bc 91       	ld	r27, X
    2138:	a0 2d       	mov	r26, r0
    213a:	b2 83       	std	Z+2, r27	; 0x02
    213c:	a1 83       	std	Z+1, r26	; 0x01
    213e:	cf 01       	movw	r24, r30
    2140:	03 96       	adiw	r24, 0x03	; 3
    2142:	a8 17       	cp	r26, r24
    2144:	b9 07       	cpc	r27, r25
    2146:	31 f4       	brne	.+12     	; 0x2154 <vTaskSwitchContext+0xa8>
    2148:	12 96       	adiw	r26, 0x02	; 2
    214a:	8d 91       	ld	r24, X+
    214c:	9c 91       	ld	r25, X
    214e:	13 97       	sbiw	r26, 0x03	; 3
    2150:	92 83       	std	Z+2, r25	; 0x02
    2152:	81 83       	std	Z+1, r24	; 0x01
    2154:	01 80       	ldd	r0, Z+1	; 0x01
    2156:	f2 81       	ldd	r31, Z+2	; 0x02
    2158:	e0 2d       	mov	r30, r0
    215a:	86 81       	ldd	r24, Z+6	; 0x06
    215c:	97 81       	ldd	r25, Z+7	; 0x07
    215e:	90 93 8e 08 	sts	0x088E, r25
    2162:	80 93 8d 08 	sts	0x088D, r24
    2166:	08 95       	ret

00002168 <vTaskSuspend>:
    2168:	0f 93       	push	r16
    216a:	1f 93       	push	r17
    216c:	cf 93       	push	r28
    216e:	df 93       	push	r29
    2170:	ec 01       	movw	r28, r24
    2172:	0f b6       	in	r0, 0x3f	; 63
    2174:	f8 94       	cli
    2176:	0f 92       	push	r0
    2178:	00 97       	sbiw	r24, 0x00	; 0
    217a:	21 f4       	brne	.+8      	; 0x2184 <vTaskSuspend+0x1c>
    217c:	c0 91 8d 08 	lds	r28, 0x088D
    2180:	d0 91 8e 08 	lds	r29, 0x088E
    2184:	8e 01       	movw	r16, r28
    2186:	0e 5f       	subi	r16, 0xFE	; 254
    2188:	1f 4f       	sbci	r17, 0xFF	; 255
    218a:	c8 01       	movw	r24, r16
    218c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    2190:	8c 89       	ldd	r24, Y+20	; 0x14
    2192:	9d 89       	ldd	r25, Y+21	; 0x15
    2194:	89 2b       	or	r24, r25
    2196:	21 f0       	breq	.+8      	; 0x21a0 <vTaskSuspend+0x38>
    2198:	ce 01       	movw	r24, r28
    219a:	0c 96       	adiw	r24, 0x0c	; 12
    219c:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    21a0:	b8 01       	movw	r22, r16
    21a2:	8e e2       	ldi	r24, 0x2E	; 46
    21a4:	98 e0       	ldi	r25, 0x08	; 8
    21a6:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    21aa:	0f 90       	pop	r0
    21ac:	0f be       	out	0x3f, r0	; 63
    21ae:	80 91 8d 08 	lds	r24, 0x088D
    21b2:	90 91 8e 08 	lds	r25, 0x088E
    21b6:	c8 17       	cp	r28, r24
    21b8:	d9 07       	cpc	r29, r25
    21ba:	a1 f4       	brne	.+40     	; 0x21e4 <vTaskSuspend+0x7c>
    21bc:	80 91 29 08 	lds	r24, 0x0829
    21c0:	88 23       	and	r24, r24
    21c2:	19 f0       	breq	.+6      	; 0x21ca <vTaskSuspend+0x62>
    21c4:	0e 94 b6 08 	call	0x116c	; 0x116c <vPortYield>
    21c8:	17 c0       	rjmp	.+46     	; 0x21f8 <vTaskSuspend+0x90>
    21ca:	80 91 2d 08 	lds	r24, 0x082D
    21ce:	90 91 2e 08 	lds	r25, 0x082E
    21d2:	98 13       	cpse	r25, r24
    21d4:	05 c0       	rjmp	.+10     	; 0x21e0 <vTaskSuspend+0x78>
    21d6:	10 92 8e 08 	sts	0x088E, r1
    21da:	10 92 8d 08 	sts	0x088D, r1
    21de:	0c c0       	rjmp	.+24     	; 0x21f8 <vTaskSuspend+0x90>
    21e0:	65 df       	rcall	.-310    	; 0x20ac <vTaskSwitchContext>
    21e2:	0a c0       	rjmp	.+20     	; 0x21f8 <vTaskSuspend+0x90>
    21e4:	80 91 29 08 	lds	r24, 0x0829
    21e8:	88 23       	and	r24, r24
    21ea:	31 f0       	breq	.+12     	; 0x21f8 <vTaskSuspend+0x90>
    21ec:	0f b6       	in	r0, 0x3f	; 63
    21ee:	f8 94       	cli
    21f0:	0f 92       	push	r0
    21f2:	96 db       	rcall	.-2260   	; 0x1920 <prvResetNextTaskUnblockTime>
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63
    21f8:	df 91       	pop	r29
    21fa:	cf 91       	pop	r28
    21fc:	1f 91       	pop	r17
    21fe:	0f 91       	pop	r16
    2200:	08 95       	ret

00002202 <vTaskPlaceOnEventList>:
    2202:	cf 93       	push	r28
    2204:	df 93       	push	r29
    2206:	eb 01       	movw	r28, r22
    2208:	60 91 8d 08 	lds	r22, 0x088D
    220c:	70 91 8e 08 	lds	r23, 0x088E
    2210:	64 5f       	subi	r22, 0xF4	; 244
    2212:	7f 4f       	sbci	r23, 0xFF	; 255
    2214:	0e 94 a9 03 	call	0x752	; 0x752 <vListInsert>
    2218:	80 91 8d 08 	lds	r24, 0x088D
    221c:	90 91 8e 08 	lds	r25, 0x088E
    2220:	02 96       	adiw	r24, 0x02	; 2
    2222:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    2226:	cf 3f       	cpi	r28, 0xFF	; 255
    2228:	8f ef       	ldi	r24, 0xFF	; 255
    222a:	d8 07       	cpc	r29, r24
    222c:	59 f4       	brne	.+22     	; 0x2244 <vTaskPlaceOnEventList+0x42>
    222e:	60 91 8d 08 	lds	r22, 0x088D
    2232:	70 91 8e 08 	lds	r23, 0x088E
    2236:	6e 5f       	subi	r22, 0xFE	; 254
    2238:	7f 4f       	sbci	r23, 0xFF	; 255
    223a:	8e e2       	ldi	r24, 0x2E	; 46
    223c:	98 e0       	ldi	r25, 0x08	; 8
    223e:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    2242:	07 c0       	rjmp	.+14     	; 0x2252 <vTaskPlaceOnEventList+0x50>
    2244:	80 91 2b 08 	lds	r24, 0x082B
    2248:	90 91 2c 08 	lds	r25, 0x082C
    224c:	8c 0f       	add	r24, r28
    224e:	9d 1f       	adc	r25, r29
    2250:	86 db       	rcall	.-2292   	; 0x195e <prvAddCurrentTaskToDelayedList>
    2252:	df 91       	pop	r29
    2254:	cf 91       	pop	r28
    2256:	08 95       	ret

00002258 <xTaskRemoveFromEventList>:
    2258:	0f 93       	push	r16
    225a:	1f 93       	push	r17
    225c:	cf 93       	push	r28
    225e:	df 93       	push	r29
    2260:	dc 01       	movw	r26, r24
    2262:	15 96       	adiw	r26, 0x05	; 5
    2264:	ed 91       	ld	r30, X+
    2266:	fc 91       	ld	r31, X
    2268:	16 97       	sbiw	r26, 0x06	; 6
    226a:	c6 81       	ldd	r28, Z+6	; 0x06
    226c:	d7 81       	ldd	r29, Z+7	; 0x07
    226e:	8e 01       	movw	r16, r28
    2270:	04 5f       	subi	r16, 0xF4	; 244
    2272:	1f 4f       	sbci	r17, 0xFF	; 255
    2274:	c8 01       	movw	r24, r16
    2276:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    227a:	80 91 24 08 	lds	r24, 0x0824
    227e:	81 11       	cpse	r24, r1
    2280:	1c c0       	rjmp	.+56     	; 0x22ba <xTaskRemoveFromEventList+0x62>
    2282:	0a 50       	subi	r16, 0x0A	; 10
    2284:	11 09       	sbc	r17, r1
    2286:	c8 01       	movw	r24, r16
    2288:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    228c:	8e 89       	ldd	r24, Y+22	; 0x16
    228e:	90 91 2a 08 	lds	r25, 0x082A
    2292:	98 17       	cp	r25, r24
    2294:	10 f4       	brcc	.+4      	; 0x229a <xTaskRemoveFromEventList+0x42>
    2296:	80 93 2a 08 	sts	0x082A, r24
    229a:	90 e0       	ldi	r25, 0x00	; 0
    229c:	9c 01       	movw	r18, r24
    229e:	22 0f       	add	r18, r18
    22a0:	33 1f       	adc	r19, r19
    22a2:	22 0f       	add	r18, r18
    22a4:	33 1f       	adc	r19, r19
    22a6:	22 0f       	add	r18, r18
    22a8:	33 1f       	adc	r19, r19
    22aa:	82 0f       	add	r24, r18
    22ac:	93 1f       	adc	r25, r19
    22ae:	b8 01       	movw	r22, r16
    22b0:	80 5a       	subi	r24, 0xA0	; 160
    22b2:	97 4f       	sbci	r25, 0xF7	; 247
    22b4:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    22b8:	05 c0       	rjmp	.+10     	; 0x22c4 <xTaskRemoveFromEventList+0x6c>
    22ba:	b8 01       	movw	r22, r16
    22bc:	81 e4       	ldi	r24, 0x41	; 65
    22be:	98 e0       	ldi	r25, 0x08	; 8
    22c0:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    22c4:	e0 91 8d 08 	lds	r30, 0x088D
    22c8:	f0 91 8e 08 	lds	r31, 0x088E
    22cc:	9e 89       	ldd	r25, Y+22	; 0x16
    22ce:	86 89       	ldd	r24, Z+22	; 0x16
    22d0:	89 17       	cp	r24, r25
    22d2:	20 f4       	brcc	.+8      	; 0x22dc <xTaskRemoveFromEventList+0x84>
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	80 93 27 08 	sts	0x0827, r24
    22da:	01 c0       	rjmp	.+2      	; 0x22de <xTaskRemoveFromEventList+0x86>
    22dc:	80 e0       	ldi	r24, 0x00	; 0
    22de:	df 91       	pop	r29
    22e0:	cf 91       	pop	r28
    22e2:	1f 91       	pop	r17
    22e4:	0f 91       	pop	r16
    22e6:	08 95       	ret

000022e8 <vTaskSetTimeOutState>:
    22e8:	20 91 26 08 	lds	r18, 0x0826
    22ec:	fc 01       	movw	r30, r24
    22ee:	20 83       	st	Z, r18
    22f0:	20 91 2b 08 	lds	r18, 0x082B
    22f4:	30 91 2c 08 	lds	r19, 0x082C
    22f8:	32 83       	std	Z+2, r19	; 0x02
    22fa:	21 83       	std	Z+1, r18	; 0x01
    22fc:	08 95       	ret

000022fe <xTaskCheckForTimeOut>:
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
    2304:	40 91 2b 08 	lds	r20, 0x082B
    2308:	50 91 2c 08 	lds	r21, 0x082C
    230c:	db 01       	movw	r26, r22
    230e:	2d 91       	ld	r18, X+
    2310:	3c 91       	ld	r19, X
    2312:	2f 3f       	cpi	r18, 0xFF	; 255
    2314:	bf ef       	ldi	r27, 0xFF	; 255
    2316:	3b 07       	cpc	r19, r27
    2318:	11 f1       	breq	.+68     	; 0x235e <xTaskCheckForTimeOut+0x60>
    231a:	e0 91 26 08 	lds	r30, 0x0826
    231e:	dc 01       	movw	r26, r24
    2320:	fc 91       	ld	r31, X
    2322:	fe 17       	cp	r31, r30
    2324:	39 f0       	breq	.+14     	; 0x2334 <xTaskCheckForTimeOut+0x36>
    2326:	11 96       	adiw	r26, 0x01	; 1
    2328:	ed 91       	ld	r30, X+
    232a:	fc 91       	ld	r31, X
    232c:	12 97       	sbiw	r26, 0x02	; 2
    232e:	4e 17       	cp	r20, r30
    2330:	5f 07       	cpc	r21, r31
    2332:	b8 f4       	brcc	.+46     	; 0x2362 <xTaskCheckForTimeOut+0x64>
    2334:	dc 01       	movw	r26, r24
    2336:	11 96       	adiw	r26, 0x01	; 1
    2338:	ed 91       	ld	r30, X+
    233a:	fc 91       	ld	r31, X
    233c:	12 97       	sbiw	r26, 0x02	; 2
    233e:	da 01       	movw	r26, r20
    2340:	ae 1b       	sub	r26, r30
    2342:	bf 0b       	sbc	r27, r31
    2344:	a2 17       	cp	r26, r18
    2346:	b3 07       	cpc	r27, r19
    2348:	70 f4       	brcc	.+28     	; 0x2366 <xTaskCheckForTimeOut+0x68>
    234a:	e4 1b       	sub	r30, r20
    234c:	f5 0b       	sbc	r31, r21
    234e:	2e 0f       	add	r18, r30
    2350:	3f 1f       	adc	r19, r31
    2352:	fb 01       	movw	r30, r22
    2354:	31 83       	std	Z+1, r19	; 0x01
    2356:	20 83       	st	Z, r18
    2358:	c7 df       	rcall	.-114    	; 0x22e8 <vTaskSetTimeOutState>
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	05 c0       	rjmp	.+10     	; 0x2368 <xTaskCheckForTimeOut+0x6a>
    235e:	80 e0       	ldi	r24, 0x00	; 0
    2360:	03 c0       	rjmp	.+6      	; 0x2368 <xTaskCheckForTimeOut+0x6a>
    2362:	81 e0       	ldi	r24, 0x01	; 1
    2364:	01 c0       	rjmp	.+2      	; 0x2368 <xTaskCheckForTimeOut+0x6a>
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	0f 90       	pop	r0
    236a:	0f be       	out	0x3f, r0	; 63
    236c:	08 95       	ret

0000236e <vTaskMissedYield>:
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	80 93 27 08 	sts	0x0827, r24
    2374:	08 95       	ret

00002376 <vTaskPriorityInherit>:
    2376:	0f 93       	push	r16
    2378:	1f 93       	push	r17
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	ec 01       	movw	r28, r24
    2380:	00 97       	sbiw	r24, 0x00	; 0
    2382:	09 f4       	brne	.+2      	; 0x2386 <vTaskPriorityInherit+0x10>
    2384:	51 c0       	rjmp	.+162    	; 0x2428 <vTaskPriorityInherit+0xb2>
    2386:	8e 89       	ldd	r24, Y+22	; 0x16
    2388:	e0 91 8d 08 	lds	r30, 0x088D
    238c:	f0 91 8e 08 	lds	r31, 0x088E
    2390:	96 89       	ldd	r25, Z+22	; 0x16
    2392:	89 17       	cp	r24, r25
    2394:	08 f0       	brcs	.+2      	; 0x2398 <vTaskPriorityInherit+0x22>
    2396:	48 c0       	rjmp	.+144    	; 0x2428 <vTaskPriorityInherit+0xb2>
    2398:	2c 85       	ldd	r18, Y+12	; 0x0c
    239a:	3d 85       	ldd	r19, Y+13	; 0x0d
    239c:	33 23       	and	r19, r19
    239e:	5c f0       	brlt	.+22     	; 0x23b6 <vTaskPriorityInherit+0x40>
    23a0:	e0 91 8d 08 	lds	r30, 0x088D
    23a4:	f0 91 8e 08 	lds	r31, 0x088E
    23a8:	96 89       	ldd	r25, Z+22	; 0x16
    23aa:	25 e0       	ldi	r18, 0x05	; 5
    23ac:	30 e0       	ldi	r19, 0x00	; 0
    23ae:	29 1b       	sub	r18, r25
    23b0:	31 09       	sbc	r19, r1
    23b2:	3d 87       	std	Y+13, r19	; 0x0d
    23b4:	2c 87       	std	Y+12, r18	; 0x0c
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	9c 01       	movw	r18, r24
    23ba:	22 0f       	add	r18, r18
    23bc:	33 1f       	adc	r19, r19
    23be:	22 0f       	add	r18, r18
    23c0:	33 1f       	adc	r19, r19
    23c2:	22 0f       	add	r18, r18
    23c4:	33 1f       	adc	r19, r19
    23c6:	82 0f       	add	r24, r18
    23c8:	93 1f       	adc	r25, r19
    23ca:	80 5a       	subi	r24, 0xA0	; 160
    23cc:	97 4f       	sbci	r25, 0xF7	; 247
    23ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    23d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    23d2:	28 17       	cp	r18, r24
    23d4:	39 07       	cpc	r19, r25
    23d6:	11 f5       	brne	.+68     	; 0x241c <vTaskPriorityInherit+0xa6>
    23d8:	8e 01       	movw	r16, r28
    23da:	0e 5f       	subi	r16, 0xFE	; 254
    23dc:	1f 4f       	sbci	r17, 0xFF	; 255
    23de:	c8 01       	movw	r24, r16
    23e0:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    23e4:	e0 91 8d 08 	lds	r30, 0x088D
    23e8:	f0 91 8e 08 	lds	r31, 0x088E
    23ec:	86 89       	ldd	r24, Z+22	; 0x16
    23ee:	8e 8b       	std	Y+22, r24	; 0x16
    23f0:	90 91 2a 08 	lds	r25, 0x082A
    23f4:	98 17       	cp	r25, r24
    23f6:	10 f4       	brcc	.+4      	; 0x23fc <vTaskPriorityInherit+0x86>
    23f8:	80 93 2a 08 	sts	0x082A, r24
    23fc:	90 e0       	ldi	r25, 0x00	; 0
    23fe:	9c 01       	movw	r18, r24
    2400:	22 0f       	add	r18, r18
    2402:	33 1f       	adc	r19, r19
    2404:	22 0f       	add	r18, r18
    2406:	33 1f       	adc	r19, r19
    2408:	22 0f       	add	r18, r18
    240a:	33 1f       	adc	r19, r19
    240c:	82 0f       	add	r24, r18
    240e:	93 1f       	adc	r25, r19
    2410:	b8 01       	movw	r22, r16
    2412:	80 5a       	subi	r24, 0xA0	; 160
    2414:	97 4f       	sbci	r25, 0xF7	; 247
    2416:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    241a:	06 c0       	rjmp	.+12     	; 0x2428 <vTaskPriorityInherit+0xb2>
    241c:	e0 91 8d 08 	lds	r30, 0x088D
    2420:	f0 91 8e 08 	lds	r31, 0x088E
    2424:	86 89       	ldd	r24, Z+22	; 0x16
    2426:	8e 8b       	std	Y+22, r24	; 0x16
    2428:	df 91       	pop	r29
    242a:	cf 91       	pop	r28
    242c:	1f 91       	pop	r17
    242e:	0f 91       	pop	r16
    2430:	08 95       	ret

00002432 <xTaskPriorityDisinherit>:
    2432:	0f 93       	push	r16
    2434:	1f 93       	push	r17
    2436:	cf 93       	push	r28
    2438:	df 93       	push	r29
    243a:	ec 01       	movw	r28, r24
    243c:	00 97       	sbiw	r24, 0x00	; 0
    243e:	71 f1       	breq	.+92     	; 0x249c <xTaskPriorityDisinherit+0x6a>
    2440:	8a a1       	ldd	r24, Y+34	; 0x22
    2442:	81 50       	subi	r24, 0x01	; 1
    2444:	8a a3       	std	Y+34, r24	; 0x22
    2446:	2e 89       	ldd	r18, Y+22	; 0x16
    2448:	99 a1       	ldd	r25, Y+33	; 0x21
    244a:	29 17       	cp	r18, r25
    244c:	49 f1       	breq	.+82     	; 0x24a0 <xTaskPriorityDisinherit+0x6e>
    244e:	81 11       	cpse	r24, r1
    2450:	29 c0       	rjmp	.+82     	; 0x24a4 <xTaskPriorityDisinherit+0x72>
    2452:	8e 01       	movw	r16, r28
    2454:	0e 5f       	subi	r16, 0xFE	; 254
    2456:	1f 4f       	sbci	r17, 0xFF	; 255
    2458:	c8 01       	movw	r24, r16
    245a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <uxListRemove>
    245e:	89 a1       	ldd	r24, Y+33	; 0x21
    2460:	8e 8b       	std	Y+22, r24	; 0x16
    2462:	25 e0       	ldi	r18, 0x05	; 5
    2464:	30 e0       	ldi	r19, 0x00	; 0
    2466:	28 1b       	sub	r18, r24
    2468:	31 09       	sbc	r19, r1
    246a:	3d 87       	std	Y+13, r19	; 0x0d
    246c:	2c 87       	std	Y+12, r18	; 0x0c
    246e:	90 91 2a 08 	lds	r25, 0x082A
    2472:	98 17       	cp	r25, r24
    2474:	10 f4       	brcc	.+4      	; 0x247a <xTaskPriorityDisinherit+0x48>
    2476:	80 93 2a 08 	sts	0x082A, r24
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	9c 01       	movw	r18, r24
    247e:	22 0f       	add	r18, r18
    2480:	33 1f       	adc	r19, r19
    2482:	22 0f       	add	r18, r18
    2484:	33 1f       	adc	r19, r19
    2486:	22 0f       	add	r18, r18
    2488:	33 1f       	adc	r19, r19
    248a:	82 0f       	add	r24, r18
    248c:	93 1f       	adc	r25, r19
    248e:	b8 01       	movw	r22, r16
    2490:	80 5a       	subi	r24, 0xA0	; 160
    2492:	97 4f       	sbci	r25, 0xF7	; 247
    2494:	0e 94 88 03 	call	0x710	; 0x710 <vListInsertEnd>
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	05 c0       	rjmp	.+10     	; 0x24a6 <xTaskPriorityDisinherit+0x74>
    249c:	80 e0       	ldi	r24, 0x00	; 0
    249e:	03 c0       	rjmp	.+6      	; 0x24a6 <xTaskPriorityDisinherit+0x74>
    24a0:	80 e0       	ldi	r24, 0x00	; 0
    24a2:	01 c0       	rjmp	.+2      	; 0x24a6 <xTaskPriorityDisinherit+0x74>
    24a4:	80 e0       	ldi	r24, 0x00	; 0
    24a6:	df 91       	pop	r29
    24a8:	cf 91       	pop	r28
    24aa:	1f 91       	pop	r17
    24ac:	0f 91       	pop	r16
    24ae:	08 95       	ret

000024b0 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    24b0:	80 91 8d 08 	lds	r24, 0x088D
    24b4:	90 91 8e 08 	lds	r25, 0x088E
    24b8:	89 2b       	or	r24, r25
    24ba:	39 f0       	breq	.+14     	; 0x24ca <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    24bc:	e0 91 8d 08 	lds	r30, 0x088D
    24c0:	f0 91 8e 08 	lds	r31, 0x088E
    24c4:	82 a1       	ldd	r24, Z+34	; 0x22
    24c6:	8f 5f       	subi	r24, 0xFF	; 255
    24c8:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    24ca:	80 91 8d 08 	lds	r24, 0x088D
    24ce:	90 91 8e 08 	lds	r25, 0x088E
	}
    24d2:	08 95       	ret

000024d4 <__subsf3>:
    24d4:	50 58       	subi	r21, 0x80	; 128

000024d6 <__addsf3>:
    24d6:	bb 27       	eor	r27, r27
    24d8:	aa 27       	eor	r26, r26
    24da:	0e d0       	rcall	.+28     	; 0x24f8 <__addsf3x>
    24dc:	e5 c0       	rjmp	.+458    	; 0x26a8 <__fp_round>
    24de:	d6 d0       	rcall	.+428    	; 0x268c <__fp_pscA>
    24e0:	30 f0       	brcs	.+12     	; 0x24ee <__addsf3+0x18>
    24e2:	db d0       	rcall	.+438    	; 0x269a <__fp_pscB>
    24e4:	20 f0       	brcs	.+8      	; 0x24ee <__addsf3+0x18>
    24e6:	31 f4       	brne	.+12     	; 0x24f4 <__addsf3+0x1e>
    24e8:	9f 3f       	cpi	r25, 0xFF	; 255
    24ea:	11 f4       	brne	.+4      	; 0x24f0 <__addsf3+0x1a>
    24ec:	1e f4       	brtc	.+6      	; 0x24f4 <__addsf3+0x1e>
    24ee:	cb c0       	rjmp	.+406    	; 0x2686 <__fp_nan>
    24f0:	0e f4       	brtc	.+2      	; 0x24f4 <__addsf3+0x1e>
    24f2:	e0 95       	com	r30
    24f4:	e7 fb       	bst	r30, 7
    24f6:	c1 c0       	rjmp	.+386    	; 0x267a <__fp_inf>

000024f8 <__addsf3x>:
    24f8:	e9 2f       	mov	r30, r25
    24fa:	e7 d0       	rcall	.+462    	; 0x26ca <__fp_split3>
    24fc:	80 f3       	brcs	.-32     	; 0x24de <__addsf3+0x8>
    24fe:	ba 17       	cp	r27, r26
    2500:	62 07       	cpc	r22, r18
    2502:	73 07       	cpc	r23, r19
    2504:	84 07       	cpc	r24, r20
    2506:	95 07       	cpc	r25, r21
    2508:	18 f0       	brcs	.+6      	; 0x2510 <__addsf3x+0x18>
    250a:	71 f4       	brne	.+28     	; 0x2528 <__addsf3x+0x30>
    250c:	9e f5       	brtc	.+102    	; 0x2574 <__addsf3x+0x7c>
    250e:	ff c0       	rjmp	.+510    	; 0x270e <__fp_zero>
    2510:	0e f4       	brtc	.+2      	; 0x2514 <__addsf3x+0x1c>
    2512:	e0 95       	com	r30
    2514:	0b 2e       	mov	r0, r27
    2516:	ba 2f       	mov	r27, r26
    2518:	a0 2d       	mov	r26, r0
    251a:	0b 01       	movw	r0, r22
    251c:	b9 01       	movw	r22, r18
    251e:	90 01       	movw	r18, r0
    2520:	0c 01       	movw	r0, r24
    2522:	ca 01       	movw	r24, r20
    2524:	a0 01       	movw	r20, r0
    2526:	11 24       	eor	r1, r1
    2528:	ff 27       	eor	r31, r31
    252a:	59 1b       	sub	r21, r25
    252c:	99 f0       	breq	.+38     	; 0x2554 <__addsf3x+0x5c>
    252e:	59 3f       	cpi	r21, 0xF9	; 249
    2530:	50 f4       	brcc	.+20     	; 0x2546 <__addsf3x+0x4e>
    2532:	50 3e       	cpi	r21, 0xE0	; 224
    2534:	68 f1       	brcs	.+90     	; 0x2590 <__addsf3x+0x98>
    2536:	1a 16       	cp	r1, r26
    2538:	f0 40       	sbci	r31, 0x00	; 0
    253a:	a2 2f       	mov	r26, r18
    253c:	23 2f       	mov	r18, r19
    253e:	34 2f       	mov	r19, r20
    2540:	44 27       	eor	r20, r20
    2542:	58 5f       	subi	r21, 0xF8	; 248
    2544:	f3 cf       	rjmp	.-26     	; 0x252c <__addsf3x+0x34>
    2546:	46 95       	lsr	r20
    2548:	37 95       	ror	r19
    254a:	27 95       	ror	r18
    254c:	a7 95       	ror	r26
    254e:	f0 40       	sbci	r31, 0x00	; 0
    2550:	53 95       	inc	r21
    2552:	c9 f7       	brne	.-14     	; 0x2546 <__addsf3x+0x4e>
    2554:	7e f4       	brtc	.+30     	; 0x2574 <__addsf3x+0x7c>
    2556:	1f 16       	cp	r1, r31
    2558:	ba 0b       	sbc	r27, r26
    255a:	62 0b       	sbc	r22, r18
    255c:	73 0b       	sbc	r23, r19
    255e:	84 0b       	sbc	r24, r20
    2560:	ba f0       	brmi	.+46     	; 0x2590 <__addsf3x+0x98>
    2562:	91 50       	subi	r25, 0x01	; 1
    2564:	a1 f0       	breq	.+40     	; 0x258e <__addsf3x+0x96>
    2566:	ff 0f       	add	r31, r31
    2568:	bb 1f       	adc	r27, r27
    256a:	66 1f       	adc	r22, r22
    256c:	77 1f       	adc	r23, r23
    256e:	88 1f       	adc	r24, r24
    2570:	c2 f7       	brpl	.-16     	; 0x2562 <__addsf3x+0x6a>
    2572:	0e c0       	rjmp	.+28     	; 0x2590 <__addsf3x+0x98>
    2574:	ba 0f       	add	r27, r26
    2576:	62 1f       	adc	r22, r18
    2578:	73 1f       	adc	r23, r19
    257a:	84 1f       	adc	r24, r20
    257c:	48 f4       	brcc	.+18     	; 0x2590 <__addsf3x+0x98>
    257e:	87 95       	ror	r24
    2580:	77 95       	ror	r23
    2582:	67 95       	ror	r22
    2584:	b7 95       	ror	r27
    2586:	f7 95       	ror	r31
    2588:	9e 3f       	cpi	r25, 0xFE	; 254
    258a:	08 f0       	brcs	.+2      	; 0x258e <__addsf3x+0x96>
    258c:	b3 cf       	rjmp	.-154    	; 0x24f4 <__addsf3+0x1e>
    258e:	93 95       	inc	r25
    2590:	88 0f       	add	r24, r24
    2592:	08 f0       	brcs	.+2      	; 0x2596 <__addsf3x+0x9e>
    2594:	99 27       	eor	r25, r25
    2596:	ee 0f       	add	r30, r30
    2598:	97 95       	ror	r25
    259a:	87 95       	ror	r24
    259c:	08 95       	ret

0000259e <__fixsfsi>:
    259e:	04 d0       	rcall	.+8      	; 0x25a8 <__fixunssfsi>
    25a0:	68 94       	set
    25a2:	b1 11       	cpse	r27, r1
    25a4:	b5 c0       	rjmp	.+362    	; 0x2710 <__fp_szero>
    25a6:	08 95       	ret

000025a8 <__fixunssfsi>:
    25a8:	98 d0       	rcall	.+304    	; 0x26da <__fp_splitA>
    25aa:	88 f0       	brcs	.+34     	; 0x25ce <__fixunssfsi+0x26>
    25ac:	9f 57       	subi	r25, 0x7F	; 127
    25ae:	90 f0       	brcs	.+36     	; 0x25d4 <__fixunssfsi+0x2c>
    25b0:	b9 2f       	mov	r27, r25
    25b2:	99 27       	eor	r25, r25
    25b4:	b7 51       	subi	r27, 0x17	; 23
    25b6:	a0 f0       	brcs	.+40     	; 0x25e0 <__fixunssfsi+0x38>
    25b8:	d1 f0       	breq	.+52     	; 0x25ee <__fixunssfsi+0x46>
    25ba:	66 0f       	add	r22, r22
    25bc:	77 1f       	adc	r23, r23
    25be:	88 1f       	adc	r24, r24
    25c0:	99 1f       	adc	r25, r25
    25c2:	1a f0       	brmi	.+6      	; 0x25ca <__fixunssfsi+0x22>
    25c4:	ba 95       	dec	r27
    25c6:	c9 f7       	brne	.-14     	; 0x25ba <__fixunssfsi+0x12>
    25c8:	12 c0       	rjmp	.+36     	; 0x25ee <__fixunssfsi+0x46>
    25ca:	b1 30       	cpi	r27, 0x01	; 1
    25cc:	81 f0       	breq	.+32     	; 0x25ee <__fixunssfsi+0x46>
    25ce:	9f d0       	rcall	.+318    	; 0x270e <__fp_zero>
    25d0:	b1 e0       	ldi	r27, 0x01	; 1
    25d2:	08 95       	ret
    25d4:	9c c0       	rjmp	.+312    	; 0x270e <__fp_zero>
    25d6:	67 2f       	mov	r22, r23
    25d8:	78 2f       	mov	r23, r24
    25da:	88 27       	eor	r24, r24
    25dc:	b8 5f       	subi	r27, 0xF8	; 248
    25de:	39 f0       	breq	.+14     	; 0x25ee <__fixunssfsi+0x46>
    25e0:	b9 3f       	cpi	r27, 0xF9	; 249
    25e2:	cc f3       	brlt	.-14     	; 0x25d6 <__fixunssfsi+0x2e>
    25e4:	86 95       	lsr	r24
    25e6:	77 95       	ror	r23
    25e8:	67 95       	ror	r22
    25ea:	b3 95       	inc	r27
    25ec:	d9 f7       	brne	.-10     	; 0x25e4 <__fixunssfsi+0x3c>
    25ee:	3e f4       	brtc	.+14     	; 0x25fe <__fixunssfsi+0x56>
    25f0:	90 95       	com	r25
    25f2:	80 95       	com	r24
    25f4:	70 95       	com	r23
    25f6:	61 95       	neg	r22
    25f8:	7f 4f       	sbci	r23, 0xFF	; 255
    25fa:	8f 4f       	sbci	r24, 0xFF	; 255
    25fc:	9f 4f       	sbci	r25, 0xFF	; 255
    25fe:	08 95       	ret

00002600 <__floatunsisf>:
    2600:	e8 94       	clt
    2602:	09 c0       	rjmp	.+18     	; 0x2616 <__floatsisf+0x12>

00002604 <__floatsisf>:
    2604:	97 fb       	bst	r25, 7
    2606:	3e f4       	brtc	.+14     	; 0x2616 <__floatsisf+0x12>
    2608:	90 95       	com	r25
    260a:	80 95       	com	r24
    260c:	70 95       	com	r23
    260e:	61 95       	neg	r22
    2610:	7f 4f       	sbci	r23, 0xFF	; 255
    2612:	8f 4f       	sbci	r24, 0xFF	; 255
    2614:	9f 4f       	sbci	r25, 0xFF	; 255
    2616:	99 23       	and	r25, r25
    2618:	a9 f0       	breq	.+42     	; 0x2644 <__floatsisf+0x40>
    261a:	f9 2f       	mov	r31, r25
    261c:	96 e9       	ldi	r25, 0x96	; 150
    261e:	bb 27       	eor	r27, r27
    2620:	93 95       	inc	r25
    2622:	f6 95       	lsr	r31
    2624:	87 95       	ror	r24
    2626:	77 95       	ror	r23
    2628:	67 95       	ror	r22
    262a:	b7 95       	ror	r27
    262c:	f1 11       	cpse	r31, r1
    262e:	f8 cf       	rjmp	.-16     	; 0x2620 <__floatsisf+0x1c>
    2630:	fa f4       	brpl	.+62     	; 0x2670 <__floatsisf+0x6c>
    2632:	bb 0f       	add	r27, r27
    2634:	11 f4       	brne	.+4      	; 0x263a <__floatsisf+0x36>
    2636:	60 ff       	sbrs	r22, 0
    2638:	1b c0       	rjmp	.+54     	; 0x2670 <__floatsisf+0x6c>
    263a:	6f 5f       	subi	r22, 0xFF	; 255
    263c:	7f 4f       	sbci	r23, 0xFF	; 255
    263e:	8f 4f       	sbci	r24, 0xFF	; 255
    2640:	9f 4f       	sbci	r25, 0xFF	; 255
    2642:	16 c0       	rjmp	.+44     	; 0x2670 <__floatsisf+0x6c>
    2644:	88 23       	and	r24, r24
    2646:	11 f0       	breq	.+4      	; 0x264c <__floatsisf+0x48>
    2648:	96 e9       	ldi	r25, 0x96	; 150
    264a:	11 c0       	rjmp	.+34     	; 0x266e <__floatsisf+0x6a>
    264c:	77 23       	and	r23, r23
    264e:	21 f0       	breq	.+8      	; 0x2658 <__floatsisf+0x54>
    2650:	9e e8       	ldi	r25, 0x8E	; 142
    2652:	87 2f       	mov	r24, r23
    2654:	76 2f       	mov	r23, r22
    2656:	05 c0       	rjmp	.+10     	; 0x2662 <__floatsisf+0x5e>
    2658:	66 23       	and	r22, r22
    265a:	71 f0       	breq	.+28     	; 0x2678 <__floatsisf+0x74>
    265c:	96 e8       	ldi	r25, 0x86	; 134
    265e:	86 2f       	mov	r24, r22
    2660:	70 e0       	ldi	r23, 0x00	; 0
    2662:	60 e0       	ldi	r22, 0x00	; 0
    2664:	2a f0       	brmi	.+10     	; 0x2670 <__floatsisf+0x6c>
    2666:	9a 95       	dec	r25
    2668:	66 0f       	add	r22, r22
    266a:	77 1f       	adc	r23, r23
    266c:	88 1f       	adc	r24, r24
    266e:	da f7       	brpl	.-10     	; 0x2666 <__floatsisf+0x62>
    2670:	88 0f       	add	r24, r24
    2672:	96 95       	lsr	r25
    2674:	87 95       	ror	r24
    2676:	97 f9       	bld	r25, 7
    2678:	08 95       	ret

0000267a <__fp_inf>:
    267a:	97 f9       	bld	r25, 7
    267c:	9f 67       	ori	r25, 0x7F	; 127
    267e:	80 e8       	ldi	r24, 0x80	; 128
    2680:	70 e0       	ldi	r23, 0x00	; 0
    2682:	60 e0       	ldi	r22, 0x00	; 0
    2684:	08 95       	ret

00002686 <__fp_nan>:
    2686:	9f ef       	ldi	r25, 0xFF	; 255
    2688:	80 ec       	ldi	r24, 0xC0	; 192
    268a:	08 95       	ret

0000268c <__fp_pscA>:
    268c:	00 24       	eor	r0, r0
    268e:	0a 94       	dec	r0
    2690:	16 16       	cp	r1, r22
    2692:	17 06       	cpc	r1, r23
    2694:	18 06       	cpc	r1, r24
    2696:	09 06       	cpc	r0, r25
    2698:	08 95       	ret

0000269a <__fp_pscB>:
    269a:	00 24       	eor	r0, r0
    269c:	0a 94       	dec	r0
    269e:	12 16       	cp	r1, r18
    26a0:	13 06       	cpc	r1, r19
    26a2:	14 06       	cpc	r1, r20
    26a4:	05 06       	cpc	r0, r21
    26a6:	08 95       	ret

000026a8 <__fp_round>:
    26a8:	09 2e       	mov	r0, r25
    26aa:	03 94       	inc	r0
    26ac:	00 0c       	add	r0, r0
    26ae:	11 f4       	brne	.+4      	; 0x26b4 <__fp_round+0xc>
    26b0:	88 23       	and	r24, r24
    26b2:	52 f0       	brmi	.+20     	; 0x26c8 <__fp_round+0x20>
    26b4:	bb 0f       	add	r27, r27
    26b6:	40 f4       	brcc	.+16     	; 0x26c8 <__fp_round+0x20>
    26b8:	bf 2b       	or	r27, r31
    26ba:	11 f4       	brne	.+4      	; 0x26c0 <__fp_round+0x18>
    26bc:	60 ff       	sbrs	r22, 0
    26be:	04 c0       	rjmp	.+8      	; 0x26c8 <__fp_round+0x20>
    26c0:	6f 5f       	subi	r22, 0xFF	; 255
    26c2:	7f 4f       	sbci	r23, 0xFF	; 255
    26c4:	8f 4f       	sbci	r24, 0xFF	; 255
    26c6:	9f 4f       	sbci	r25, 0xFF	; 255
    26c8:	08 95       	ret

000026ca <__fp_split3>:
    26ca:	57 fd       	sbrc	r21, 7
    26cc:	90 58       	subi	r25, 0x80	; 128
    26ce:	44 0f       	add	r20, r20
    26d0:	55 1f       	adc	r21, r21
    26d2:	59 f0       	breq	.+22     	; 0x26ea <__fp_splitA+0x10>
    26d4:	5f 3f       	cpi	r21, 0xFF	; 255
    26d6:	71 f0       	breq	.+28     	; 0x26f4 <__fp_splitA+0x1a>
    26d8:	47 95       	ror	r20

000026da <__fp_splitA>:
    26da:	88 0f       	add	r24, r24
    26dc:	97 fb       	bst	r25, 7
    26de:	99 1f       	adc	r25, r25
    26e0:	61 f0       	breq	.+24     	; 0x26fa <__fp_splitA+0x20>
    26e2:	9f 3f       	cpi	r25, 0xFF	; 255
    26e4:	79 f0       	breq	.+30     	; 0x2704 <__fp_splitA+0x2a>
    26e6:	87 95       	ror	r24
    26e8:	08 95       	ret
    26ea:	12 16       	cp	r1, r18
    26ec:	13 06       	cpc	r1, r19
    26ee:	14 06       	cpc	r1, r20
    26f0:	55 1f       	adc	r21, r21
    26f2:	f2 cf       	rjmp	.-28     	; 0x26d8 <__fp_split3+0xe>
    26f4:	46 95       	lsr	r20
    26f6:	f1 df       	rcall	.-30     	; 0x26da <__fp_splitA>
    26f8:	08 c0       	rjmp	.+16     	; 0x270a <__fp_splitA+0x30>
    26fa:	16 16       	cp	r1, r22
    26fc:	17 06       	cpc	r1, r23
    26fe:	18 06       	cpc	r1, r24
    2700:	99 1f       	adc	r25, r25
    2702:	f1 cf       	rjmp	.-30     	; 0x26e6 <__fp_splitA+0xc>
    2704:	86 95       	lsr	r24
    2706:	71 05       	cpc	r23, r1
    2708:	61 05       	cpc	r22, r1
    270a:	08 94       	sec
    270c:	08 95       	ret

0000270e <__fp_zero>:
    270e:	e8 94       	clt

00002710 <__fp_szero>:
    2710:	bb 27       	eor	r27, r27
    2712:	66 27       	eor	r22, r22
    2714:	77 27       	eor	r23, r23
    2716:	cb 01       	movw	r24, r22
    2718:	97 f9       	bld	r25, 7
    271a:	08 95       	ret

0000271c <__mulsf3>:
    271c:	0b d0       	rcall	.+22     	; 0x2734 <__mulsf3x>
    271e:	c4 cf       	rjmp	.-120    	; 0x26a8 <__fp_round>
    2720:	b5 df       	rcall	.-150    	; 0x268c <__fp_pscA>
    2722:	28 f0       	brcs	.+10     	; 0x272e <__mulsf3+0x12>
    2724:	ba df       	rcall	.-140    	; 0x269a <__fp_pscB>
    2726:	18 f0       	brcs	.+6      	; 0x272e <__mulsf3+0x12>
    2728:	95 23       	and	r25, r21
    272a:	09 f0       	breq	.+2      	; 0x272e <__mulsf3+0x12>
    272c:	a6 cf       	rjmp	.-180    	; 0x267a <__fp_inf>
    272e:	ab cf       	rjmp	.-170    	; 0x2686 <__fp_nan>
    2730:	11 24       	eor	r1, r1
    2732:	ee cf       	rjmp	.-36     	; 0x2710 <__fp_szero>

00002734 <__mulsf3x>:
    2734:	ca df       	rcall	.-108    	; 0x26ca <__fp_split3>
    2736:	a0 f3       	brcs	.-24     	; 0x2720 <__mulsf3+0x4>

00002738 <__mulsf3_pse>:
    2738:	95 9f       	mul	r25, r21
    273a:	d1 f3       	breq	.-12     	; 0x2730 <__mulsf3+0x14>
    273c:	95 0f       	add	r25, r21
    273e:	50 e0       	ldi	r21, 0x00	; 0
    2740:	55 1f       	adc	r21, r21
    2742:	62 9f       	mul	r22, r18
    2744:	f0 01       	movw	r30, r0
    2746:	72 9f       	mul	r23, r18
    2748:	bb 27       	eor	r27, r27
    274a:	f0 0d       	add	r31, r0
    274c:	b1 1d       	adc	r27, r1
    274e:	63 9f       	mul	r22, r19
    2750:	aa 27       	eor	r26, r26
    2752:	f0 0d       	add	r31, r0
    2754:	b1 1d       	adc	r27, r1
    2756:	aa 1f       	adc	r26, r26
    2758:	64 9f       	mul	r22, r20
    275a:	66 27       	eor	r22, r22
    275c:	b0 0d       	add	r27, r0
    275e:	a1 1d       	adc	r26, r1
    2760:	66 1f       	adc	r22, r22
    2762:	82 9f       	mul	r24, r18
    2764:	22 27       	eor	r18, r18
    2766:	b0 0d       	add	r27, r0
    2768:	a1 1d       	adc	r26, r1
    276a:	62 1f       	adc	r22, r18
    276c:	73 9f       	mul	r23, r19
    276e:	b0 0d       	add	r27, r0
    2770:	a1 1d       	adc	r26, r1
    2772:	62 1f       	adc	r22, r18
    2774:	83 9f       	mul	r24, r19
    2776:	a0 0d       	add	r26, r0
    2778:	61 1d       	adc	r22, r1
    277a:	22 1f       	adc	r18, r18
    277c:	74 9f       	mul	r23, r20
    277e:	33 27       	eor	r19, r19
    2780:	a0 0d       	add	r26, r0
    2782:	61 1d       	adc	r22, r1
    2784:	23 1f       	adc	r18, r19
    2786:	84 9f       	mul	r24, r20
    2788:	60 0d       	add	r22, r0
    278a:	21 1d       	adc	r18, r1
    278c:	82 2f       	mov	r24, r18
    278e:	76 2f       	mov	r23, r22
    2790:	6a 2f       	mov	r22, r26
    2792:	11 24       	eor	r1, r1
    2794:	9f 57       	subi	r25, 0x7F	; 127
    2796:	50 40       	sbci	r21, 0x00	; 0
    2798:	8a f0       	brmi	.+34     	; 0x27bc <__mulsf3_pse+0x84>
    279a:	e1 f0       	breq	.+56     	; 0x27d4 <__mulsf3_pse+0x9c>
    279c:	88 23       	and	r24, r24
    279e:	4a f0       	brmi	.+18     	; 0x27b2 <__mulsf3_pse+0x7a>
    27a0:	ee 0f       	add	r30, r30
    27a2:	ff 1f       	adc	r31, r31
    27a4:	bb 1f       	adc	r27, r27
    27a6:	66 1f       	adc	r22, r22
    27a8:	77 1f       	adc	r23, r23
    27aa:	88 1f       	adc	r24, r24
    27ac:	91 50       	subi	r25, 0x01	; 1
    27ae:	50 40       	sbci	r21, 0x00	; 0
    27b0:	a9 f7       	brne	.-22     	; 0x279c <__mulsf3_pse+0x64>
    27b2:	9e 3f       	cpi	r25, 0xFE	; 254
    27b4:	51 05       	cpc	r21, r1
    27b6:	70 f0       	brcs	.+28     	; 0x27d4 <__mulsf3_pse+0x9c>
    27b8:	60 cf       	rjmp	.-320    	; 0x267a <__fp_inf>
    27ba:	aa cf       	rjmp	.-172    	; 0x2710 <__fp_szero>
    27bc:	5f 3f       	cpi	r21, 0xFF	; 255
    27be:	ec f3       	brlt	.-6      	; 0x27ba <__mulsf3_pse+0x82>
    27c0:	98 3e       	cpi	r25, 0xE8	; 232
    27c2:	dc f3       	brlt	.-10     	; 0x27ba <__mulsf3_pse+0x82>
    27c4:	86 95       	lsr	r24
    27c6:	77 95       	ror	r23
    27c8:	67 95       	ror	r22
    27ca:	b7 95       	ror	r27
    27cc:	f7 95       	ror	r31
    27ce:	e7 95       	ror	r30
    27d0:	9f 5f       	subi	r25, 0xFF	; 255
    27d2:	c1 f7       	brne	.-16     	; 0x27c4 <__mulsf3_pse+0x8c>
    27d4:	fe 2b       	or	r31, r30
    27d6:	88 0f       	add	r24, r24
    27d8:	91 1d       	adc	r25, r1
    27da:	96 95       	lsr	r25
    27dc:	87 95       	ror	r24
    27de:	97 f9       	bld	r25, 7
    27e0:	08 95       	ret

000027e2 <pow>:
    27e2:	fa 01       	movw	r30, r20
    27e4:	ee 0f       	add	r30, r30
    27e6:	ff 1f       	adc	r31, r31
    27e8:	30 96       	adiw	r30, 0x00	; 0
    27ea:	21 05       	cpc	r18, r1
    27ec:	31 05       	cpc	r19, r1
    27ee:	99 f1       	breq	.+102    	; 0x2856 <pow+0x74>
    27f0:	61 15       	cp	r22, r1
    27f2:	71 05       	cpc	r23, r1
    27f4:	61 f4       	brne	.+24     	; 0x280e <pow+0x2c>
    27f6:	80 38       	cpi	r24, 0x80	; 128
    27f8:	bf e3       	ldi	r27, 0x3F	; 63
    27fa:	9b 07       	cpc	r25, r27
    27fc:	49 f1       	breq	.+82     	; 0x2850 <pow+0x6e>
    27fe:	68 94       	set
    2800:	90 38       	cpi	r25, 0x80	; 128
    2802:	81 05       	cpc	r24, r1
    2804:	61 f0       	breq	.+24     	; 0x281e <pow+0x3c>
    2806:	80 38       	cpi	r24, 0x80	; 128
    2808:	bf ef       	ldi	r27, 0xFF	; 255
    280a:	9b 07       	cpc	r25, r27
    280c:	41 f0       	breq	.+16     	; 0x281e <pow+0x3c>
    280e:	99 23       	and	r25, r25
    2810:	42 f5       	brpl	.+80     	; 0x2862 <pow+0x80>
    2812:	ff 3f       	cpi	r31, 0xFF	; 255
    2814:	e1 05       	cpc	r30, r1
    2816:	31 05       	cpc	r19, r1
    2818:	21 05       	cpc	r18, r1
    281a:	11 f1       	breq	.+68     	; 0x2860 <pow+0x7e>
    281c:	e8 94       	clt
    281e:	08 94       	sec
    2820:	e7 95       	ror	r30
    2822:	d9 01       	movw	r26, r18
    2824:	aa 23       	and	r26, r26
    2826:	29 f4       	brne	.+10     	; 0x2832 <pow+0x50>
    2828:	ab 2f       	mov	r26, r27
    282a:	be 2f       	mov	r27, r30
    282c:	f8 5f       	subi	r31, 0xF8	; 248
    282e:	d0 f3       	brcs	.-12     	; 0x2824 <pow+0x42>
    2830:	10 c0       	rjmp	.+32     	; 0x2852 <pow+0x70>
    2832:	ff 5f       	subi	r31, 0xFF	; 255
    2834:	70 f4       	brcc	.+28     	; 0x2852 <pow+0x70>
    2836:	a6 95       	lsr	r26
    2838:	e0 f7       	brcc	.-8      	; 0x2832 <pow+0x50>
    283a:	f7 39       	cpi	r31, 0x97	; 151
    283c:	50 f0       	brcs	.+20     	; 0x2852 <pow+0x70>
    283e:	19 f0       	breq	.+6      	; 0x2846 <pow+0x64>
    2840:	ff 3a       	cpi	r31, 0xAF	; 175
    2842:	38 f4       	brcc	.+14     	; 0x2852 <pow+0x70>
    2844:	9f 77       	andi	r25, 0x7F	; 127
    2846:	9f 93       	push	r25
    2848:	0c d0       	rcall	.+24     	; 0x2862 <pow+0x80>
    284a:	0f 90       	pop	r0
    284c:	07 fc       	sbrc	r0, 7
    284e:	90 58       	subi	r25, 0x80	; 128
    2850:	08 95       	ret
    2852:	3e f0       	brts	.+14     	; 0x2862 <pow+0x80>
    2854:	18 cf       	rjmp	.-464    	; 0x2686 <__fp_nan>
    2856:	60 e0       	ldi	r22, 0x00	; 0
    2858:	70 e0       	ldi	r23, 0x00	; 0
    285a:	80 e8       	ldi	r24, 0x80	; 128
    285c:	9f e3       	ldi	r25, 0x3F	; 63
    285e:	08 95       	ret
    2860:	4f e7       	ldi	r20, 0x7F	; 127
    2862:	9f 77       	andi	r25, 0x7F	; 127
    2864:	5f 93       	push	r21
    2866:	4f 93       	push	r20
    2868:	3f 93       	push	r19
    286a:	2f 93       	push	r18
    286c:	9e d0       	rcall	.+316    	; 0x29aa <log>
    286e:	2f 91       	pop	r18
    2870:	3f 91       	pop	r19
    2872:	4f 91       	pop	r20
    2874:	5f 91       	pop	r21
    2876:	52 df       	rcall	.-348    	; 0x271c <__mulsf3>
    2878:	05 c0       	rjmp	.+10     	; 0x2884 <exp>
    287a:	19 f4       	brne	.+6      	; 0x2882 <pow+0xa0>
    287c:	0e f0       	brts	.+2      	; 0x2880 <pow+0x9e>
    287e:	fd ce       	rjmp	.-518    	; 0x267a <__fp_inf>
    2880:	46 cf       	rjmp	.-372    	; 0x270e <__fp_zero>
    2882:	01 cf       	rjmp	.-510    	; 0x2686 <__fp_nan>

00002884 <exp>:
    2884:	2a df       	rcall	.-428    	; 0x26da <__fp_splitA>
    2886:	c8 f3       	brcs	.-14     	; 0x287a <pow+0x98>
    2888:	96 38       	cpi	r25, 0x86	; 134
    288a:	c0 f7       	brcc	.-16     	; 0x287c <pow+0x9a>
    288c:	07 f8       	bld	r0, 7
    288e:	0f 92       	push	r0
    2890:	e8 94       	clt
    2892:	2b e3       	ldi	r18, 0x3B	; 59
    2894:	3a ea       	ldi	r19, 0xAA	; 170
    2896:	48 eb       	ldi	r20, 0xB8	; 184
    2898:	5f e7       	ldi	r21, 0x7F	; 127
    289a:	4e df       	rcall	.-356    	; 0x2738 <__mulsf3_pse>
    289c:	0f 92       	push	r0
    289e:	0f 92       	push	r0
    28a0:	0f 92       	push	r0
    28a2:	4d b7       	in	r20, 0x3d	; 61
    28a4:	5e b7       	in	r21, 0x3e	; 62
    28a6:	0f 92       	push	r0
    28a8:	c0 d0       	rcall	.+384    	; 0x2a2a <modf>
    28aa:	e4 ee       	ldi	r30, 0xE4	; 228
    28ac:	f0 e0       	ldi	r31, 0x00	; 0
    28ae:	16 d0       	rcall	.+44     	; 0x28dc <__fp_powser>
    28b0:	4f 91       	pop	r20
    28b2:	5f 91       	pop	r21
    28b4:	ef 91       	pop	r30
    28b6:	ff 91       	pop	r31
    28b8:	e5 95       	asr	r30
    28ba:	ee 1f       	adc	r30, r30
    28bc:	ff 1f       	adc	r31, r31
    28be:	49 f0       	breq	.+18     	; 0x28d2 <exp+0x4e>
    28c0:	fe 57       	subi	r31, 0x7E	; 126
    28c2:	e0 68       	ori	r30, 0x80	; 128
    28c4:	44 27       	eor	r20, r20
    28c6:	ee 0f       	add	r30, r30
    28c8:	44 1f       	adc	r20, r20
    28ca:	fa 95       	dec	r31
    28cc:	e1 f7       	brne	.-8      	; 0x28c6 <exp+0x42>
    28ce:	41 95       	neg	r20
    28d0:	55 0b       	sbc	r21, r21
    28d2:	32 d0       	rcall	.+100    	; 0x2938 <ldexp>
    28d4:	0f 90       	pop	r0
    28d6:	07 fe       	sbrs	r0, 7
    28d8:	26 c0       	rjmp	.+76     	; 0x2926 <inverse>
    28da:	08 95       	ret

000028dc <__fp_powser>:
    28dc:	df 93       	push	r29
    28de:	cf 93       	push	r28
    28e0:	1f 93       	push	r17
    28e2:	0f 93       	push	r16
    28e4:	ff 92       	push	r15
    28e6:	ef 92       	push	r14
    28e8:	df 92       	push	r13
    28ea:	7b 01       	movw	r14, r22
    28ec:	8c 01       	movw	r16, r24
    28ee:	68 94       	set
    28f0:	05 c0       	rjmp	.+10     	; 0x28fc <__fp_powser+0x20>
    28f2:	da 2e       	mov	r13, r26
    28f4:	ef 01       	movw	r28, r30
    28f6:	1e df       	rcall	.-452    	; 0x2734 <__mulsf3x>
    28f8:	fe 01       	movw	r30, r28
    28fa:	e8 94       	clt
    28fc:	a5 91       	lpm	r26, Z+
    28fe:	25 91       	lpm	r18, Z+
    2900:	35 91       	lpm	r19, Z+
    2902:	45 91       	lpm	r20, Z+
    2904:	55 91       	lpm	r21, Z+
    2906:	ae f3       	brts	.-22     	; 0x28f2 <__fp_powser+0x16>
    2908:	ef 01       	movw	r28, r30
    290a:	f6 dd       	rcall	.-1044   	; 0x24f8 <__addsf3x>
    290c:	fe 01       	movw	r30, r28
    290e:	97 01       	movw	r18, r14
    2910:	a8 01       	movw	r20, r16
    2912:	da 94       	dec	r13
    2914:	79 f7       	brne	.-34     	; 0x28f4 <__fp_powser+0x18>
    2916:	df 90       	pop	r13
    2918:	ef 90       	pop	r14
    291a:	ff 90       	pop	r15
    291c:	0f 91       	pop	r16
    291e:	1f 91       	pop	r17
    2920:	cf 91       	pop	r28
    2922:	df 91       	pop	r29
    2924:	08 95       	ret

00002926 <inverse>:
    2926:	9b 01       	movw	r18, r22
    2928:	ac 01       	movw	r20, r24
    292a:	60 e0       	ldi	r22, 0x00	; 0
    292c:	70 e0       	ldi	r23, 0x00	; 0
    292e:	80 e8       	ldi	r24, 0x80	; 128
    2930:	9f e3       	ldi	r25, 0x3F	; 63
    2932:	ae c0       	rjmp	.+348    	; 0x2a90 <__divsf3>
    2934:	a2 ce       	rjmp	.-700    	; 0x267a <__fp_inf>
    2936:	14 c1       	rjmp	.+552    	; 0x2b60 <__fp_mpack>

00002938 <ldexp>:
    2938:	d0 de       	rcall	.-608    	; 0x26da <__fp_splitA>
    293a:	e8 f3       	brcs	.-6      	; 0x2936 <inverse+0x10>
    293c:	99 23       	and	r25, r25
    293e:	d9 f3       	breq	.-10     	; 0x2936 <inverse+0x10>
    2940:	94 0f       	add	r25, r20
    2942:	51 1d       	adc	r21, r1
    2944:	bb f3       	brvs	.-18     	; 0x2934 <inverse+0xe>
    2946:	91 50       	subi	r25, 0x01	; 1
    2948:	50 40       	sbci	r21, 0x00	; 0
    294a:	94 f0       	brlt	.+36     	; 0x2970 <ldexp+0x38>
    294c:	59 f0       	breq	.+22     	; 0x2964 <ldexp+0x2c>
    294e:	88 23       	and	r24, r24
    2950:	32 f0       	brmi	.+12     	; 0x295e <ldexp+0x26>
    2952:	66 0f       	add	r22, r22
    2954:	77 1f       	adc	r23, r23
    2956:	88 1f       	adc	r24, r24
    2958:	91 50       	subi	r25, 0x01	; 1
    295a:	50 40       	sbci	r21, 0x00	; 0
    295c:	c1 f7       	brne	.-16     	; 0x294e <ldexp+0x16>
    295e:	9e 3f       	cpi	r25, 0xFE	; 254
    2960:	51 05       	cpc	r21, r1
    2962:	44 f7       	brge	.-48     	; 0x2934 <inverse+0xe>
    2964:	88 0f       	add	r24, r24
    2966:	91 1d       	adc	r25, r1
    2968:	96 95       	lsr	r25
    296a:	87 95       	ror	r24
    296c:	97 f9       	bld	r25, 7
    296e:	08 95       	ret
    2970:	5f 3f       	cpi	r21, 0xFF	; 255
    2972:	ac f0       	brlt	.+42     	; 0x299e <ldexp+0x66>
    2974:	98 3e       	cpi	r25, 0xE8	; 232
    2976:	9c f0       	brlt	.+38     	; 0x299e <ldexp+0x66>
    2978:	bb 27       	eor	r27, r27
    297a:	86 95       	lsr	r24
    297c:	77 95       	ror	r23
    297e:	67 95       	ror	r22
    2980:	b7 95       	ror	r27
    2982:	08 f4       	brcc	.+2      	; 0x2986 <ldexp+0x4e>
    2984:	b1 60       	ori	r27, 0x01	; 1
    2986:	93 95       	inc	r25
    2988:	c1 f7       	brne	.-16     	; 0x297a <ldexp+0x42>
    298a:	bb 0f       	add	r27, r27
    298c:	58 f7       	brcc	.-42     	; 0x2964 <ldexp+0x2c>
    298e:	11 f4       	brne	.+4      	; 0x2994 <ldexp+0x5c>
    2990:	60 ff       	sbrs	r22, 0
    2992:	e8 cf       	rjmp	.-48     	; 0x2964 <ldexp+0x2c>
    2994:	6f 5f       	subi	r22, 0xFF	; 255
    2996:	7f 4f       	sbci	r23, 0xFF	; 255
    2998:	8f 4f       	sbci	r24, 0xFF	; 255
    299a:	9f 4f       	sbci	r25, 0xFF	; 255
    299c:	e3 cf       	rjmp	.-58     	; 0x2964 <ldexp+0x2c>
    299e:	b8 ce       	rjmp	.-656    	; 0x2710 <__fp_szero>
    29a0:	0e f0       	brts	.+2      	; 0x29a4 <ldexp+0x6c>
    29a2:	de c0       	rjmp	.+444    	; 0x2b60 <__fp_mpack>
    29a4:	70 ce       	rjmp	.-800    	; 0x2686 <__fp_nan>
    29a6:	68 94       	set
    29a8:	68 ce       	rjmp	.-816    	; 0x267a <__fp_inf>

000029aa <log>:
    29aa:	97 de       	rcall	.-722    	; 0x26da <__fp_splitA>
    29ac:	c8 f3       	brcs	.-14     	; 0x29a0 <ldexp+0x68>
    29ae:	99 23       	and	r25, r25
    29b0:	d1 f3       	breq	.-12     	; 0x29a6 <ldexp+0x6e>
    29b2:	c6 f3       	brts	.-16     	; 0x29a4 <ldexp+0x6c>
    29b4:	df 93       	push	r29
    29b6:	cf 93       	push	r28
    29b8:	1f 93       	push	r17
    29ba:	0f 93       	push	r16
    29bc:	ff 92       	push	r15
    29be:	c9 2f       	mov	r28, r25
    29c0:	dd 27       	eor	r29, r29
    29c2:	88 23       	and	r24, r24
    29c4:	2a f0       	brmi	.+10     	; 0x29d0 <log+0x26>
    29c6:	21 97       	sbiw	r28, 0x01	; 1
    29c8:	66 0f       	add	r22, r22
    29ca:	77 1f       	adc	r23, r23
    29cc:	88 1f       	adc	r24, r24
    29ce:	da f7       	brpl	.-10     	; 0x29c6 <log+0x1c>
    29d0:	20 e0       	ldi	r18, 0x00	; 0
    29d2:	30 e0       	ldi	r19, 0x00	; 0
    29d4:	40 e8       	ldi	r20, 0x80	; 128
    29d6:	5f eb       	ldi	r21, 0xBF	; 191
    29d8:	9f e3       	ldi	r25, 0x3F	; 63
    29da:	88 39       	cpi	r24, 0x98	; 152
    29dc:	20 f0       	brcs	.+8      	; 0x29e6 <log+0x3c>
    29de:	80 3e       	cpi	r24, 0xE0	; 224
    29e0:	30 f0       	brcs	.+12     	; 0x29ee <log+0x44>
    29e2:	21 96       	adiw	r28, 0x01	; 1
    29e4:	8f 77       	andi	r24, 0x7F	; 127
    29e6:	77 dd       	rcall	.-1298   	; 0x24d6 <__addsf3>
    29e8:	ec e0       	ldi	r30, 0x0C	; 12
    29ea:	f1 e0       	ldi	r31, 0x01	; 1
    29ec:	03 c0       	rjmp	.+6      	; 0x29f4 <log+0x4a>
    29ee:	73 dd       	rcall	.-1306   	; 0x24d6 <__addsf3>
    29f0:	e9 e3       	ldi	r30, 0x39	; 57
    29f2:	f1 e0       	ldi	r31, 0x01	; 1
    29f4:	73 df       	rcall	.-282    	; 0x28dc <__fp_powser>
    29f6:	8b 01       	movw	r16, r22
    29f8:	be 01       	movw	r22, r28
    29fa:	ec 01       	movw	r28, r24
    29fc:	fb 2e       	mov	r15, r27
    29fe:	6f 57       	subi	r22, 0x7F	; 127
    2a00:	71 09       	sbc	r23, r1
    2a02:	75 95       	asr	r23
    2a04:	77 1f       	adc	r23, r23
    2a06:	88 0b       	sbc	r24, r24
    2a08:	99 0b       	sbc	r25, r25
    2a0a:	fc dd       	rcall	.-1032   	; 0x2604 <__floatsisf>
    2a0c:	28 e1       	ldi	r18, 0x18	; 24
    2a0e:	32 e7       	ldi	r19, 0x72	; 114
    2a10:	41 e3       	ldi	r20, 0x31	; 49
    2a12:	5f e3       	ldi	r21, 0x3F	; 63
    2a14:	8f de       	rcall	.-738    	; 0x2734 <__mulsf3x>
    2a16:	af 2d       	mov	r26, r15
    2a18:	98 01       	movw	r18, r16
    2a1a:	ae 01       	movw	r20, r28
    2a1c:	ff 90       	pop	r15
    2a1e:	0f 91       	pop	r16
    2a20:	1f 91       	pop	r17
    2a22:	cf 91       	pop	r28
    2a24:	df 91       	pop	r29
    2a26:	68 dd       	rcall	.-1328   	; 0x24f8 <__addsf3x>
    2a28:	3f ce       	rjmp	.-898    	; 0x26a8 <__fp_round>

00002a2a <modf>:
    2a2a:	fa 01       	movw	r30, r20
    2a2c:	dc 01       	movw	r26, r24
    2a2e:	aa 0f       	add	r26, r26
    2a30:	bb 1f       	adc	r27, r27
    2a32:	9b 01       	movw	r18, r22
    2a34:	ac 01       	movw	r20, r24
    2a36:	bf 57       	subi	r27, 0x7F	; 127
    2a38:	28 f4       	brcc	.+10     	; 0x2a44 <modf+0x1a>
    2a3a:	22 27       	eor	r18, r18
    2a3c:	33 27       	eor	r19, r19
    2a3e:	44 27       	eor	r20, r20
    2a40:	50 78       	andi	r21, 0x80	; 128
    2a42:	1f c0       	rjmp	.+62     	; 0x2a82 <modf+0x58>
    2a44:	b7 51       	subi	r27, 0x17	; 23
    2a46:	88 f4       	brcc	.+34     	; 0x2a6a <modf+0x40>
    2a48:	ab 2f       	mov	r26, r27
    2a4a:	00 24       	eor	r0, r0
    2a4c:	46 95       	lsr	r20
    2a4e:	37 95       	ror	r19
    2a50:	27 95       	ror	r18
    2a52:	01 1c       	adc	r0, r1
    2a54:	a3 95       	inc	r26
    2a56:	d2 f3       	brmi	.-12     	; 0x2a4c <modf+0x22>
    2a58:	00 20       	and	r0, r0
    2a5a:	69 f0       	breq	.+26     	; 0x2a76 <modf+0x4c>
    2a5c:	22 0f       	add	r18, r18
    2a5e:	33 1f       	adc	r19, r19
    2a60:	44 1f       	adc	r20, r20
    2a62:	b3 95       	inc	r27
    2a64:	da f3       	brmi	.-10     	; 0x2a5c <modf+0x32>
    2a66:	0d d0       	rcall	.+26     	; 0x2a82 <modf+0x58>
    2a68:	35 cd       	rjmp	.-1430   	; 0x24d4 <__subsf3>
    2a6a:	61 30       	cpi	r22, 0x01	; 1
    2a6c:	71 05       	cpc	r23, r1
    2a6e:	a0 e8       	ldi	r26, 0x80	; 128
    2a70:	8a 07       	cpc	r24, r26
    2a72:	b9 46       	sbci	r27, 0x69	; 105
    2a74:	30 f4       	brcc	.+12     	; 0x2a82 <modf+0x58>
    2a76:	9b 01       	movw	r18, r22
    2a78:	ac 01       	movw	r20, r24
    2a7a:	66 27       	eor	r22, r22
    2a7c:	77 27       	eor	r23, r23
    2a7e:	88 27       	eor	r24, r24
    2a80:	90 78       	andi	r25, 0x80	; 128
    2a82:	30 96       	adiw	r30, 0x00	; 0
    2a84:	21 f0       	breq	.+8      	; 0x2a8e <modf+0x64>
    2a86:	20 83       	st	Z, r18
    2a88:	31 83       	std	Z+1, r19	; 0x01
    2a8a:	42 83       	std	Z+2, r20	; 0x02
    2a8c:	53 83       	std	Z+3, r21	; 0x03
    2a8e:	08 95       	ret

00002a90 <__divsf3>:
    2a90:	0c d0       	rcall	.+24     	; 0x2aaa <__divsf3x>
    2a92:	0a ce       	rjmp	.-1004   	; 0x26a8 <__fp_round>
    2a94:	02 de       	rcall	.-1020   	; 0x269a <__fp_pscB>
    2a96:	40 f0       	brcs	.+16     	; 0x2aa8 <__divsf3+0x18>
    2a98:	f9 dd       	rcall	.-1038   	; 0x268c <__fp_pscA>
    2a9a:	30 f0       	brcs	.+12     	; 0x2aa8 <__divsf3+0x18>
    2a9c:	21 f4       	brne	.+8      	; 0x2aa6 <__divsf3+0x16>
    2a9e:	5f 3f       	cpi	r21, 0xFF	; 255
    2aa0:	19 f0       	breq	.+6      	; 0x2aa8 <__divsf3+0x18>
    2aa2:	eb cd       	rjmp	.-1066   	; 0x267a <__fp_inf>
    2aa4:	51 11       	cpse	r21, r1
    2aa6:	34 ce       	rjmp	.-920    	; 0x2710 <__fp_szero>
    2aa8:	ee cd       	rjmp	.-1060   	; 0x2686 <__fp_nan>

00002aaa <__divsf3x>:
    2aaa:	0f de       	rcall	.-994    	; 0x26ca <__fp_split3>
    2aac:	98 f3       	brcs	.-26     	; 0x2a94 <__divsf3+0x4>

00002aae <__divsf3_pse>:
    2aae:	99 23       	and	r25, r25
    2ab0:	c9 f3       	breq	.-14     	; 0x2aa4 <__divsf3+0x14>
    2ab2:	55 23       	and	r21, r21
    2ab4:	b1 f3       	breq	.-20     	; 0x2aa2 <__divsf3+0x12>
    2ab6:	95 1b       	sub	r25, r21
    2ab8:	55 0b       	sbc	r21, r21
    2aba:	bb 27       	eor	r27, r27
    2abc:	aa 27       	eor	r26, r26
    2abe:	62 17       	cp	r22, r18
    2ac0:	73 07       	cpc	r23, r19
    2ac2:	84 07       	cpc	r24, r20
    2ac4:	38 f0       	brcs	.+14     	; 0x2ad4 <__divsf3_pse+0x26>
    2ac6:	9f 5f       	subi	r25, 0xFF	; 255
    2ac8:	5f 4f       	sbci	r21, 0xFF	; 255
    2aca:	22 0f       	add	r18, r18
    2acc:	33 1f       	adc	r19, r19
    2ace:	44 1f       	adc	r20, r20
    2ad0:	aa 1f       	adc	r26, r26
    2ad2:	a9 f3       	breq	.-22     	; 0x2abe <__divsf3_pse+0x10>
    2ad4:	33 d0       	rcall	.+102    	; 0x2b3c <__divsf3_pse+0x8e>
    2ad6:	0e 2e       	mov	r0, r30
    2ad8:	3a f0       	brmi	.+14     	; 0x2ae8 <__divsf3_pse+0x3a>
    2ada:	e0 e8       	ldi	r30, 0x80	; 128
    2adc:	30 d0       	rcall	.+96     	; 0x2b3e <__divsf3_pse+0x90>
    2ade:	91 50       	subi	r25, 0x01	; 1
    2ae0:	50 40       	sbci	r21, 0x00	; 0
    2ae2:	e6 95       	lsr	r30
    2ae4:	00 1c       	adc	r0, r0
    2ae6:	ca f7       	brpl	.-14     	; 0x2ada <__divsf3_pse+0x2c>
    2ae8:	29 d0       	rcall	.+82     	; 0x2b3c <__divsf3_pse+0x8e>
    2aea:	fe 2f       	mov	r31, r30
    2aec:	27 d0       	rcall	.+78     	; 0x2b3c <__divsf3_pse+0x8e>
    2aee:	66 0f       	add	r22, r22
    2af0:	77 1f       	adc	r23, r23
    2af2:	88 1f       	adc	r24, r24
    2af4:	bb 1f       	adc	r27, r27
    2af6:	26 17       	cp	r18, r22
    2af8:	37 07       	cpc	r19, r23
    2afa:	48 07       	cpc	r20, r24
    2afc:	ab 07       	cpc	r26, r27
    2afe:	b0 e8       	ldi	r27, 0x80	; 128
    2b00:	09 f0       	breq	.+2      	; 0x2b04 <__divsf3_pse+0x56>
    2b02:	bb 0b       	sbc	r27, r27
    2b04:	80 2d       	mov	r24, r0
    2b06:	bf 01       	movw	r22, r30
    2b08:	ff 27       	eor	r31, r31
    2b0a:	93 58       	subi	r25, 0x83	; 131
    2b0c:	5f 4f       	sbci	r21, 0xFF	; 255
    2b0e:	2a f0       	brmi	.+10     	; 0x2b1a <__divsf3_pse+0x6c>
    2b10:	9e 3f       	cpi	r25, 0xFE	; 254
    2b12:	51 05       	cpc	r21, r1
    2b14:	68 f0       	brcs	.+26     	; 0x2b30 <__divsf3_pse+0x82>
    2b16:	b1 cd       	rjmp	.-1182   	; 0x267a <__fp_inf>
    2b18:	fb cd       	rjmp	.-1034   	; 0x2710 <__fp_szero>
    2b1a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b1c:	ec f3       	brlt	.-6      	; 0x2b18 <__divsf3_pse+0x6a>
    2b1e:	98 3e       	cpi	r25, 0xE8	; 232
    2b20:	dc f3       	brlt	.-10     	; 0x2b18 <__divsf3_pse+0x6a>
    2b22:	86 95       	lsr	r24
    2b24:	77 95       	ror	r23
    2b26:	67 95       	ror	r22
    2b28:	b7 95       	ror	r27
    2b2a:	f7 95       	ror	r31
    2b2c:	9f 5f       	subi	r25, 0xFF	; 255
    2b2e:	c9 f7       	brne	.-14     	; 0x2b22 <__divsf3_pse+0x74>
    2b30:	88 0f       	add	r24, r24
    2b32:	91 1d       	adc	r25, r1
    2b34:	96 95       	lsr	r25
    2b36:	87 95       	ror	r24
    2b38:	97 f9       	bld	r25, 7
    2b3a:	08 95       	ret
    2b3c:	e1 e0       	ldi	r30, 0x01	; 1
    2b3e:	66 0f       	add	r22, r22
    2b40:	77 1f       	adc	r23, r23
    2b42:	88 1f       	adc	r24, r24
    2b44:	bb 1f       	adc	r27, r27
    2b46:	62 17       	cp	r22, r18
    2b48:	73 07       	cpc	r23, r19
    2b4a:	84 07       	cpc	r24, r20
    2b4c:	ba 07       	cpc	r27, r26
    2b4e:	20 f0       	brcs	.+8      	; 0x2b58 <__divsf3_pse+0xaa>
    2b50:	62 1b       	sub	r22, r18
    2b52:	73 0b       	sbc	r23, r19
    2b54:	84 0b       	sbc	r24, r20
    2b56:	ba 0b       	sbc	r27, r26
    2b58:	ee 1f       	adc	r30, r30
    2b5a:	88 f7       	brcc	.-30     	; 0x2b3e <__divsf3_pse+0x90>
    2b5c:	e0 95       	com	r30
    2b5e:	08 95       	ret

00002b60 <__fp_mpack>:
    2b60:	9f 3f       	cpi	r25, 0xFF	; 255
    2b62:	31 f0       	breq	.+12     	; 0x2b70 <__fp_mpack_finite+0xc>

00002b64 <__fp_mpack_finite>:
    2b64:	91 50       	subi	r25, 0x01	; 1
    2b66:	20 f4       	brcc	.+8      	; 0x2b70 <__fp_mpack_finite+0xc>
    2b68:	87 95       	ror	r24
    2b6a:	77 95       	ror	r23
    2b6c:	67 95       	ror	r22
    2b6e:	b7 95       	ror	r27
    2b70:	88 0f       	add	r24, r24
    2b72:	91 1d       	adc	r25, r1
    2b74:	96 95       	lsr	r25
    2b76:	87 95       	ror	r24
    2b78:	97 f9       	bld	r25, 7
    2b7a:	08 95       	ret

00002b7c <__divmodhi4>:
    2b7c:	97 fb       	bst	r25, 7
    2b7e:	07 2e       	mov	r0, r23
    2b80:	16 f4       	brtc	.+4      	; 0x2b86 <__divmodhi4+0xa>
    2b82:	00 94       	com	r0
    2b84:	06 d0       	rcall	.+12     	; 0x2b92 <__divmodhi4_neg1>
    2b86:	77 fd       	sbrc	r23, 7
    2b88:	08 d0       	rcall	.+16     	; 0x2b9a <__divmodhi4_neg2>
    2b8a:	0b d0       	rcall	.+22     	; 0x2ba2 <__udivmodhi4>
    2b8c:	07 fc       	sbrc	r0, 7
    2b8e:	05 d0       	rcall	.+10     	; 0x2b9a <__divmodhi4_neg2>
    2b90:	3e f4       	brtc	.+14     	; 0x2ba0 <__divmodhi4_exit>

00002b92 <__divmodhi4_neg1>:
    2b92:	90 95       	com	r25
    2b94:	81 95       	neg	r24
    2b96:	9f 4f       	sbci	r25, 0xFF	; 255
    2b98:	08 95       	ret

00002b9a <__divmodhi4_neg2>:
    2b9a:	70 95       	com	r23
    2b9c:	61 95       	neg	r22
    2b9e:	7f 4f       	sbci	r23, 0xFF	; 255

00002ba0 <__divmodhi4_exit>:
    2ba0:	08 95       	ret

00002ba2 <__udivmodhi4>:
    2ba2:	aa 1b       	sub	r26, r26
    2ba4:	bb 1b       	sub	r27, r27
    2ba6:	51 e1       	ldi	r21, 0x11	; 17
    2ba8:	07 c0       	rjmp	.+14     	; 0x2bb8 <__udivmodhi4_ep>

00002baa <__udivmodhi4_loop>:
    2baa:	aa 1f       	adc	r26, r26
    2bac:	bb 1f       	adc	r27, r27
    2bae:	a6 17       	cp	r26, r22
    2bb0:	b7 07       	cpc	r27, r23
    2bb2:	10 f0       	brcs	.+4      	; 0x2bb8 <__udivmodhi4_ep>
    2bb4:	a6 1b       	sub	r26, r22
    2bb6:	b7 0b       	sbc	r27, r23

00002bb8 <__udivmodhi4_ep>:
    2bb8:	88 1f       	adc	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	5a 95       	dec	r21
    2bbe:	a9 f7       	brne	.-22     	; 0x2baa <__udivmodhi4_loop>
    2bc0:	80 95       	com	r24
    2bc2:	90 95       	com	r25
    2bc4:	bc 01       	movw	r22, r24
    2bc6:	cd 01       	movw	r24, r26
    2bc8:	08 95       	ret

00002bca <memcpy>:
    2bca:	fb 01       	movw	r30, r22
    2bcc:	dc 01       	movw	r26, r24
    2bce:	02 c0       	rjmp	.+4      	; 0x2bd4 <memcpy+0xa>
    2bd0:	01 90       	ld	r0, Z+
    2bd2:	0d 92       	st	X+, r0
    2bd4:	41 50       	subi	r20, 0x01	; 1
    2bd6:	50 40       	sbci	r21, 0x00	; 0
    2bd8:	d8 f7       	brcc	.-10     	; 0x2bd0 <memcpy+0x6>
    2bda:	08 95       	ret

00002bdc <__itoa_ncheck>:
    2bdc:	bb 27       	eor	r27, r27
    2bde:	4a 30       	cpi	r20, 0x0A	; 10
    2be0:	31 f4       	brne	.+12     	; 0x2bee <__itoa_ncheck+0x12>
    2be2:	99 23       	and	r25, r25
    2be4:	22 f4       	brpl	.+8      	; 0x2bee <__itoa_ncheck+0x12>
    2be6:	bd e2       	ldi	r27, 0x2D	; 45
    2be8:	90 95       	com	r25
    2bea:	81 95       	neg	r24
    2bec:	9f 4f       	sbci	r25, 0xFF	; 255
    2bee:	01 c0       	rjmp	.+2      	; 0x2bf2 <__utoa_common>

00002bf0 <__utoa_ncheck>:
    2bf0:	bb 27       	eor	r27, r27

00002bf2 <__utoa_common>:
    2bf2:	fb 01       	movw	r30, r22
    2bf4:	55 27       	eor	r21, r21
    2bf6:	aa 27       	eor	r26, r26
    2bf8:	88 0f       	add	r24, r24
    2bfa:	99 1f       	adc	r25, r25
    2bfc:	aa 1f       	adc	r26, r26
    2bfe:	a4 17       	cp	r26, r20
    2c00:	10 f0       	brcs	.+4      	; 0x2c06 <__utoa_common+0x14>
    2c02:	a4 1b       	sub	r26, r20
    2c04:	83 95       	inc	r24
    2c06:	50 51       	subi	r21, 0x10	; 16
    2c08:	b9 f7       	brne	.-18     	; 0x2bf8 <__utoa_common+0x6>
    2c0a:	a0 5d       	subi	r26, 0xD0	; 208
    2c0c:	aa 33       	cpi	r26, 0x3A	; 58
    2c0e:	08 f0       	brcs	.+2      	; 0x2c12 <__utoa_common+0x20>
    2c10:	a9 5d       	subi	r26, 0xD9	; 217
    2c12:	a1 93       	st	Z+, r26
    2c14:	00 97       	sbiw	r24, 0x00	; 0
    2c16:	79 f7       	brne	.-34     	; 0x2bf6 <__utoa_common+0x4>
    2c18:	b1 11       	cpse	r27, r1
    2c1a:	b1 93       	st	Z+, r27
    2c1c:	11 92       	st	Z+, r1
    2c1e:	cb 01       	movw	r24, r22
    2c20:	00 c0       	rjmp	.+0      	; 0x2c22 <strrev>

00002c22 <strrev>:
    2c22:	dc 01       	movw	r26, r24
    2c24:	fc 01       	movw	r30, r24
    2c26:	67 2f       	mov	r22, r23
    2c28:	71 91       	ld	r23, Z+
    2c2a:	77 23       	and	r23, r23
    2c2c:	e1 f7       	brne	.-8      	; 0x2c26 <strrev+0x4>
    2c2e:	32 97       	sbiw	r30, 0x02	; 2
    2c30:	04 c0       	rjmp	.+8      	; 0x2c3a <strrev+0x18>
    2c32:	7c 91       	ld	r23, X
    2c34:	6d 93       	st	X+, r22
    2c36:	70 83       	st	Z, r23
    2c38:	62 91       	ld	r22, -Z
    2c3a:	ae 17       	cp	r26, r30
    2c3c:	bf 07       	cpc	r27, r31
    2c3e:	c8 f3       	brcs	.-14     	; 0x2c32 <strrev+0x10>
    2c40:	08 95       	ret

00002c42 <_exit>:
    2c42:	f8 94       	cli

00002c44 <__stop_program>:
    2c44:	ff cf       	rjmp	.-2      	; 0x2c44 <__stop_program>
