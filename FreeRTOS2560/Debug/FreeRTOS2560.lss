
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000036  00800200  00002e84  00002f18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e84  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000708  00800236  00800236  00002f4e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f4e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000570  00000000  00000000  00002f7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000060d0  00000000  00000000  000034ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001657  00000000  00000000  000095be  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003a43  00000000  00000000  0000ac15  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000fb4  00000000  00000000  0000e658  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000182b  00000000  00000000  0000f60c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004546  00000000  00000000  00010e37  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000500  00000000  00000000  0001537d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	b2 c0       	rjmp	.+356    	; 0x166 <__ctors_end>
       2:	00 00       	nop
       4:	d0 c0       	rjmp	.+416    	; 0x1a6 <__bad_interrupt>
       6:	00 00       	nop
       8:	ce c0       	rjmp	.+412    	; 0x1a6 <__bad_interrupt>
       a:	00 00       	nop
       c:	cc c0       	rjmp	.+408    	; 0x1a6 <__bad_interrupt>
       e:	00 00       	nop
      10:	ca c0       	rjmp	.+404    	; 0x1a6 <__bad_interrupt>
      12:	00 00       	nop
      14:	c8 c0       	rjmp	.+400    	; 0x1a6 <__bad_interrupt>
      16:	00 00       	nop
      18:	c6 c0       	rjmp	.+396    	; 0x1a6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	c4 c0       	rjmp	.+392    	; 0x1a6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	c2 c0       	rjmp	.+388    	; 0x1a6 <__bad_interrupt>
      22:	00 00       	nop
      24:	de c3       	rjmp	.+1980   	; 0x7e2 <__vector_9>
      26:	00 00       	nop
      28:	be c0       	rjmp	.+380    	; 0x1a6 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	bc c0       	rjmp	.+376    	; 0x1a6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	ba c0       	rjmp	.+372    	; 0x1a6 <__bad_interrupt>
      32:	00 00       	nop
      34:	b8 c0       	rjmp	.+368    	; 0x1a6 <__bad_interrupt>
      36:	00 00       	nop
      38:	b6 c0       	rjmp	.+364    	; 0x1a6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	b4 c0       	rjmp	.+360    	; 0x1a6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	b2 c0       	rjmp	.+356    	; 0x1a6 <__bad_interrupt>
      42:	00 00       	nop
      44:	b0 c0       	rjmp	.+352    	; 0x1a6 <__bad_interrupt>
      46:	00 00       	nop
      48:	ae c0       	rjmp	.+348    	; 0x1a6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ac c0       	rjmp	.+344    	; 0x1a6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	aa c0       	rjmp	.+340    	; 0x1a6 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 18 0b 	jmp	0x1630	; 0x1630 <__vector_21>
      58:	a6 c0       	rjmp	.+332    	; 0x1a6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	a4 c0       	rjmp	.+328    	; 0x1a6 <__bad_interrupt>
      5e:	00 00       	nop
      60:	a2 c0       	rjmp	.+324    	; 0x1a6 <__bad_interrupt>
      62:	00 00       	nop
      64:	b2 c7       	rjmp	.+3940   	; 0xfca <__vector_25>
      66:	00 00       	nop
      68:	0c 94 5d 08 	jmp	0x10ba	; 0x10ba <__vector_26>
      6c:	9c c0       	rjmp	.+312    	; 0x1a6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	9a c0       	rjmp	.+308    	; 0x1a6 <__bad_interrupt>
      72:	00 00       	nop
      74:	bb c4       	rjmp	.+2422   	; 0x9ec <__vector_29>
      76:	00 00       	nop
      78:	96 c0       	rjmp	.+300    	; 0x1a6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	94 c0       	rjmp	.+296    	; 0x1a6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	92 c0       	rjmp	.+292    	; 0x1a6 <__bad_interrupt>
      82:	00 00       	nop
      84:	90 c0       	rjmp	.+288    	; 0x1a6 <__bad_interrupt>
      86:	00 00       	nop
      88:	8e c0       	rjmp	.+284    	; 0x1a6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	8c c0       	rjmp	.+280    	; 0x1a6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	64 c7       	rjmp	.+3784   	; 0xf5a <__vector_36>
      92:	00 00       	nop
      94:	d2 c7       	rjmp	.+4004   	; 0x103a <__vector_37>
      96:	00 00       	nop
      98:	86 c0       	rjmp	.+268    	; 0x1a6 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	84 c0       	rjmp	.+264    	; 0x1a6 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	82 c0       	rjmp	.+260    	; 0x1a6 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	80 c0       	rjmp	.+256    	; 0x1a6 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	7e c0       	rjmp	.+252    	; 0x1a6 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	7c c0       	rjmp	.+248    	; 0x1a6 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	7a c0       	rjmp	.+244    	; 0x1a6 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	78 c0       	rjmp	.+240    	; 0x1a6 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	76 c0       	rjmp	.+236    	; 0x1a6 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	74 c0       	rjmp	.+232    	; 0x1a6 <__bad_interrupt>
      be:	00 00       	nop
      c0:	72 c0       	rjmp	.+228    	; 0x1a6 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	70 c0       	rjmp	.+224    	; 0x1a6 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	6e c0       	rjmp	.+220    	; 0x1a6 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	6c c0       	rjmp	.+216    	; 0x1a6 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	6a c0       	rjmp	.+212    	; 0x1a6 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	68 c0       	rjmp	.+208    	; 0x1a6 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	66 c0       	rjmp	.+204    	; 0x1a6 <__bad_interrupt>
      da:	00 00       	nop
      dc:	64 c0       	rjmp	.+200    	; 0x1a6 <__bad_interrupt>
      de:	00 00       	nop
      e0:	62 c0       	rjmp	.+196    	; 0x1a6 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	std	Y+40, r29	; 0x28
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	std	Y+56, r1	; 0x38
      f2:	ba ab       	std	Y+50, r27	; 0x32
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	std	Y+51, r10	; 0x33
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	std	Y+54, r27	; 0x36
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	ldd	r30, Z+49	; 0x31
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <myMaxSonar_Stabilizer+0xe>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 e8       	ldi	r30, 0x84	; 132
     17e:	fe e2       	ldi	r31, 0x2E	; 46
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 33       	cpi	r26, 0x36	; 54
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	29 e0       	ldi	r18, 0x09	; 9
     192:	a6 e3       	ldi	r26, 0x36	; 54
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	ae 33       	cpi	r26, 0x3E	; 62
     19c:	b2 07       	cpc	r27, r18
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	dc d0       	rcall	.+440    	; 0x35a <main>
     1a2:	0c 94 40 17 	jmp	0x2e80	; 0x2e80 <_exit>

000001a6 <__bad_interrupt>:
     1a6:	2c cf       	rjmp	.-424    	; 0x0 <__vectors>

000001a8 <RPI_receiveTask>:
	}
}


void vApplicationIdleHook()
{
     1a8:	12 e0       	ldi	r17, 0x02	; 2
     1aa:	d1 e0       	ldi	r29, 0x01	; 1
     1ac:	0e 94 4f 09 	call	0x129e	; 0x129e <myUSART_receiveUSART1>
     1b0:	c8 2f       	mov	r28, r24
     1b2:	0e 94 8f 09 	call	0x131e	; 0x131e <myUSART_receiveHandShakeAck>
     1b6:	88 23       	and	r24, r24
     1b8:	19 f0       	breq	.+6      	; 0x1c0 <RPI_receiveTask+0x18>
     1ba:	0e 94 84 09 	call	0x1308	; 0x1308 <myUSART_completeHandShake>
     1be:	f6 cf       	rjmp	.-20     	; 0x1ac <RPI_receiveTask+0x4>
     1c0:	8c 2f       	mov	r24, r28
     1c2:	0e 94 a1 09 	call	0x1342	; 0x1342 <myUSART_receiveMessageACK>
     1c6:	81 11       	cpse	r24, r1
     1c8:	f1 cf       	rjmp	.-30     	; 0x1ac <RPI_receiveTask+0x4>
     1ca:	80 91 36 02 	lds	r24, 0x0236
     1ce:	81 11       	cpse	r24, r1
     1d0:	0b c0       	rjmp	.+22     	; 0x1e8 <RPI_receiveTask+0x40>
     1d2:	8c 2f       	mov	r24, r28
     1d4:	0e 94 95 09 	call	0x132a	; 0x132a <myUSART_receiveHandShakeStart>
     1d8:	88 23       	and	r24, r24
     1da:	41 f3       	breq	.-48     	; 0x1ac <RPI_receiveTask+0x4>
     1dc:	85 e0       	ldi	r24, 0x05	; 5
     1de:	0e 94 12 09 	call	0x1224	; 0x1224 <myUSART_transmitUSART1_c>
     1e2:	d0 93 36 02 	sts	0x0236, r29
     1e6:	e2 cf       	rjmp	.-60     	; 0x1ac <RPI_receiveTask+0x4>
     1e8:	81 30       	cpi	r24, 0x01	; 1
     1ea:	59 f4       	brne	.+22     	; 0x202 <RPI_receiveTask+0x5a>
     1ec:	8c 2f       	mov	r24, r28
     1ee:	0e 94 9b 09 	call	0x1336	; 0x1336 <myUSART_receiveHandShakeFin>
     1f2:	88 23       	and	r24, r24
     1f4:	19 f0       	breq	.+6      	; 0x1fc <RPI_receiveTask+0x54>
     1f6:	10 93 36 02 	sts	0x0236, r17
     1fa:	d8 cf       	rjmp	.-80     	; 0x1ac <RPI_receiveTask+0x4>
     1fc:	10 92 36 02 	sts	0x0236, r1
     200:	d5 cf       	rjmp	.-86     	; 0x1ac <RPI_receiveTask+0x4>
     202:	82 30       	cpi	r24, 0x02	; 2
     204:	99 f6       	brne	.-90     	; 0x1ac <RPI_receiveTask+0x4>
     206:	c8 31       	cpi	r28, 0x18	; 24
     208:	89 f6       	brne	.-94     	; 0x1ac <RPI_receiveTask+0x4>
     20a:	10 92 36 02 	sts	0x0236, r1
     20e:	ce cf       	rjmp	.-100    	; 0x1ac <RPI_receiveTask+0x4>

00000210 <RPI_sendTask>:
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	00 d0       	rcall	.+0      	; 0x216 <RPI_sendTask+0x6>
     216:	00 d0       	rcall	.+0      	; 0x218 <RPI_sendTask+0x8>
     218:	cd b7       	in	r28, 0x3d	; 61
     21a:	de b7       	in	r29, 0x3e	; 62
     21c:	0e 94 70 09 	call	0x12e0	; 0x12e0 <myUSART_startHandShake>
     220:	18 2f       	mov	r17, r24
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	4f ef       	ldi	r20, 0xFF	; 255
     226:	5f ef       	ldi	r21, 0xFF	; 255
     228:	be 01       	movw	r22, r28
     22a:	6a 5f       	subi	r22, 0xFA	; 250
     22c:	7f 4f       	sbci	r23, 0xFF	; 255
     22e:	80 91 8c 08 	lds	r24, 0x088C
     232:	90 91 8d 08 	lds	r25, 0x088D
     236:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xQueueGenericReceive>
     23a:	28 c0       	rjmp	.+80     	; 0x28c <RPI_sendTask+0x7c>
     23c:	20 e0       	ldi	r18, 0x00	; 0
     23e:	4f ef       	ldi	r20, 0xFF	; 255
     240:	5f ef       	ldi	r21, 0xFF	; 255
     242:	be 01       	movw	r22, r28
     244:	6f 5f       	subi	r22, 0xFF	; 255
     246:	7f 4f       	sbci	r23, 0xFF	; 255
     248:	80 91 8e 08 	lds	r24, 0x088E
     24c:	90 91 8f 08 	lds	r25, 0x088F
     250:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <xQueueGenericReceive>
     254:	89 81       	ldd	r24, Y+1	; 0x01
     256:	c5 d7       	rcall	.+3978   	; 0x11e2 <myUSART_transmitUSART0_c>
     258:	87 e0       	ldi	r24, 0x07	; 7
     25a:	92 e0       	ldi	r25, 0x02	; 2
     25c:	0e 94 41 09 	call	0x1282	; 0x1282 <myUSART_transmitUSART0>
     260:	ce 01       	movw	r24, r28
     262:	02 96       	adiw	r24, 0x02	; 2
     264:	0e 94 41 09 	call	0x1282	; 0x1282 <myUSART_transmitUSART0>
     268:	89 e0       	ldi	r24, 0x09	; 9
     26a:	92 e0       	ldi	r25, 0x02	; 2
     26c:	0e 94 41 09 	call	0x1282	; 0x1282 <myUSART_transmitUSART0>
     270:	11 23       	and	r17, r17
     272:	61 f0       	breq	.+24     	; 0x28c <RPI_sendTask+0x7c>
     274:	8e 81       	ldd	r24, Y+6	; 0x06
     276:	80 5d       	subi	r24, 0xD0	; 208
     278:	d5 d7       	rcall	.+4010   	; 0x1224 <myUSART_transmitUSART1_c>
     27a:	8a e0       	ldi	r24, 0x0A	; 10
     27c:	d3 d7       	rcall	.+4006   	; 0x1224 <myUSART_transmitUSART1_c>
     27e:	89 81       	ldd	r24, Y+1	; 0x01
     280:	d1 d7       	rcall	.+4002   	; 0x1224 <myUSART_transmitUSART1_c>
     282:	ce 01       	movw	r24, r28
     284:	02 96       	adiw	r24, 0x02	; 2
     286:	ef d7       	rcall	.+4062   	; 0x1266 <myUSART_transmitUSART1>
     288:	8a e0       	ldi	r24, 0x0A	; 10
     28a:	cc d7       	rcall	.+3992   	; 0x1224 <myUSART_transmitUSART1_c>
     28c:	9e 81       	ldd	r25, Y+6	; 0x06
     28e:	2f ef       	ldi	r18, 0xFF	; 255
     290:	29 0f       	add	r18, r25
     292:	2e 83       	std	Y+6, r18	; 0x06
     294:	91 11       	cpse	r25, r1
     296:	d2 cf       	rjmp	.-92     	; 0x23c <RPI_sendTask+0x2c>
     298:	8a e0       	ldi	r24, 0x0A	; 10
     29a:	a3 d7       	rcall	.+3910   	; 0x11e2 <myUSART_transmitUSART0_c>
     29c:	bf cf       	rjmp	.-130    	; 0x21c <RPI_sendTask+0xc>

0000029e <myTimerTask>:
     29e:	d2 d5       	rcall	.+2980   	; 0xe44 <myTimer_Init>
     2a0:	ed d5       	rcall	.+3034   	; 0xe7c <myTimer_DelayChecker>
     2a2:	fe cf       	rjmp	.-4      	; 0x2a0 <myTimerTask+0x2>

000002a4 <setDigitalInputPowerReduction>:


void setDigitalInputPowerReduction()
{
	// Set when confirm which ADC pin not used for digital..
	DIDR0 = 0b11111111; // all adc pin not used for digital
     2a4:	8f ef       	ldi	r24, 0xFF	; 255
     2a6:	80 93 7e 00 	sts	0x007E, r24
	DIDR1 |= (1<<AIN1D) | (1<<AIN0D);
     2aa:	ef e7       	ldi	r30, 0x7F	; 127
     2ac:	f0 e0       	ldi	r31, 0x00	; 0
     2ae:	90 81       	ld	r25, Z
     2b0:	93 60       	ori	r25, 0x03	; 3
     2b2:	90 83       	st	Z, r25
	DIDR2 = 0b11111111; // add adc pin not used for digital
     2b4:	80 93 7d 00 	sts	0x007D, r24
     2b8:	08 95       	ret

000002ba <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     2ba:	8c ec       	ldi	r24, 0xCC	; 204
     2bc:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     2c0:	8e e3       	ldi	r24, 0x3E	; 62
     2c2:	80 93 65 00 	sts	0x0065, r24
	
	setDigitalInputPowerReduction();
     2c6:	ee cf       	rjmp	.-36     	; 0x2a4 <setDigitalInputPowerReduction>
     2c8:	08 95       	ret

000002ca <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     2ca:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     2ce:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     2d2:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     2d6:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     2da:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2de:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2e2:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2e6:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2ea:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2ee:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2f2:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2f6:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2fa:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2fe:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     302:	10 92 73 00 	sts	0x0073, r1
     306:	08 95       	ret

00000308 <init>:
}

void init()
{
     308:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     30a:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     30c:	f8 94       	cli
	{
		clearTimer();
     30e:	dd df       	rcall	.-70     	; 0x2ca <clearTimer>
		setPowerReduction();
     310:	d4 df       	rcall	.-88     	; 0x2ba <setPowerReduction>
		myUSART_USART0_Init();
     312:	13 d7       	rcall	.+3622   	; 0x113a <myUSART_USART0_Init>
		myUSART_USART1_Init();
     314:	38 d7       	rcall	.+3696   	; 0x1186 <myUSART_USART1_Init>
		myADC_Init();
     316:	a2 d3       	rcall	.+1860   	; 0xa5c <myADC_Init>
		
		MaxSonar_Init();
     318:	83 b3       	in	r24, 0x13	; 19
     31a:	83 60       	ori	r24, 0x03	; 3
     31c:	83 bb       	out	0x13, r24	; 19
		
		//myHcSonar_Init();
		
		
		queueObstacleNumber = xQueueCreate(QUEUE_SIZE, sizeof (char)); // create queue
     31e:	40 e0       	ldi	r20, 0x00	; 0
     320:	61 e0       	ldi	r22, 0x01	; 1
     322:	85 e0       	ldi	r24, 0x05	; 5
     324:	0e 94 17 0c 	call	0x182e	; 0x182e <xQueueGenericCreate>
     328:	90 93 8d 08 	sts	0x088D, r25
     32c:	80 93 8c 08 	sts	0x088C, r24
		queueObstacleData = xQueueCreate( (QUEUE_SIZE*SENSOR_NUM), sizeof (obstacleStruct)); // create queue
     330:	40 e0       	ldi	r20, 0x00	; 0
     332:	65 e0       	ldi	r22, 0x05	; 5
     334:	8e e1       	ldi	r24, 0x1E	; 30
     336:	0e 94 17 0c 	call	0x182e	; 0x182e <xQueueGenericCreate>
     33a:	90 93 8f 08 	sts	0x088F, r25
     33e:	80 93 8e 08 	sts	0x088E, r24
		
		MOTOR_LEFT_INIT();
     342:	8d b1       	in	r24, 0x0d	; 13
     344:	88 61       	ori	r24, 0x18	; 24
     346:	8d b9       	out	0x0d, r24	; 13
		MOTOR_RIGHT_INIT();
     348:	e1 e0       	ldi	r30, 0x01	; 1
     34a:	f1 e0       	ldi	r31, 0x01	; 1
     34c:	80 81       	ld	r24, Z
     34e:	80 61       	ori	r24, 0x10	; 16
     350:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     352:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     354:	78 94       	sei
}
     356:	cf 91       	pop	r28
     358:	08 95       	ret

0000035a <main>:
	
	// do nth
}

int main(void)
{
     35a:	cf 93       	push	r28
     35c:	df 93       	push	r29
     35e:	cd b7       	in	r28, 0x3d	; 61
     360:	de b7       	in	r29, 0x3e	; 62
     362:	28 97       	sbiw	r28, 0x08	; 8
     364:	0f b6       	in	r0, 0x3f	; 63
     366:	f8 94       	cli
     368:	de bf       	out	0x3e, r29	; 62
     36a:	0f be       	out	0x3f, r0	; 63
     36c:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t_maxSonar, t_rx, t_tx, t_delay;
	
		init();
     36e:	cc df       	rcall	.-104    	; 0x308 <init>
	
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?		
     370:	a1 2c       	mov	r10, r1
     372:	b1 2c       	mov	r11, r1
     374:	c1 2c       	mov	r12, r1
     376:	d1 2c       	mov	r13, r1
     378:	ce 01       	movw	r24, r28
     37a:	01 96       	adiw	r24, 0x01	; 1
     37c:	7c 01       	movw	r14, r24
     37e:	04 e0       	ldi	r16, 0x04	; 4
     380:	9c 01       	movw	r18, r24
     382:	49 e6       	ldi	r20, 0x69	; 105
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	6b e0       	ldi	r22, 0x0B	; 11
     388:	72 e0       	ldi	r23, 0x02	; 2
     38a:	8f e4       	ldi	r24, 0x4F	; 79
     38c:	91 e0       	ldi	r25, 0x01	; 1
     38e:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <xTaskGenericCreate>
		xTaskCreate(Sonar_Task, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     392:	ce 01       	movw	r24, r28
     394:	07 96       	adiw	r24, 0x07	; 7
     396:	7c 01       	movw	r14, r24
     398:	03 e0       	ldi	r16, 0x03	; 3
     39a:	20 e0       	ldi	r18, 0x00	; 0
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	4d e6       	ldi	r20, 0x6D	; 109
     3a0:	51 e0       	ldi	r21, 0x01	; 1
     3a2:	63 e1       	ldi	r22, 0x13	; 19
     3a4:	72 e0       	ldi	r23, 0x02	; 2
     3a6:	8b e8       	ldi	r24, 0x8B	; 139
     3a8:	92 e0       	ldi	r25, 0x02	; 2
     3aa:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <xTaskGenericCreate>

		
		// Need fix receive concurrency issues.
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     3ae:	ce 01       	movw	r24, r28
     3b0:	05 96       	adiw	r24, 0x05	; 5
     3b2:	7c 01       	movw	r14, r24
     3b4:	01 e0       	ldi	r16, 0x01	; 1
     3b6:	20 e0       	ldi	r18, 0x00	; 0
     3b8:	30 e0       	ldi	r19, 0x00	; 0
     3ba:	47 e8       	ldi	r20, 0x87	; 135
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	6c e1       	ldi	r22, 0x1C	; 28
     3c0:	72 e0       	ldi	r23, 0x02	; 2
     3c2:	84 ed       	ldi	r24, 0xD4	; 212
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     3ca:	ce 01       	movw	r24, r28
     3cc:	03 96       	adiw	r24, 0x03	; 3
     3ce:	7c 01       	movw	r14, r24
     3d0:	02 e0       	ldi	r16, 0x02	; 2
     3d2:	20 e0       	ldi	r18, 0x00	; 0
     3d4:	30 e0       	ldi	r19, 0x00	; 0
     3d6:	47 e8       	ldi	r20, 0x87	; 135
     3d8:	50 e0       	ldi	r21, 0x00	; 0
     3da:	68 e2       	ldi	r22, 0x28	; 40
     3dc:	72 e0       	ldi	r23, 0x02	; 2
     3de:	88 e0       	ldi	r24, 0x08	; 8
     3e0:	91 e0       	ldi	r25, 0x01	; 1
     3e2:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3e6:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <vTaskStartScheduler>
     3ea:	c1 cf       	rjmp	.-126    	; 0x36e <main+0x14>

000003ec <myItoa>:
}


// either 2 or 3 digit +ve int
void myItoa(int input, char * buffer)
{
     3ec:	9c 01       	movw	r18, r24
     3ee:	fb 01       	movw	r30, r22
	int temp = input;
	input /= 100; // get 100s digit
     3f0:	64 e6       	ldi	r22, 0x64	; 100
     3f2:	70 e0       	ldi	r23, 0x00	; 0
     3f4:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__divmodhi4>
	
	if(input)
     3f8:	61 15       	cp	r22, r1
     3fa:	71 05       	cpc	r23, r1
     3fc:	21 f0       	breq	.+8      	; 0x406 <myItoa+0x1a>
		*buffer++ = input + '0';
     3fe:	80 e3       	ldi	r24, 0x30	; 48
     400:	86 0f       	add	r24, r22
     402:	80 83       	st	Z, r24
     404:	31 96       	adiw	r30, 0x01	; 1
		
	temp = temp - input * 100; // get remainder
     406:	4c e9       	ldi	r20, 0x9C	; 156
     408:	46 03       	mulsu	r20, r22
     40a:	c0 01       	movw	r24, r0
     40c:	47 9f       	mul	r20, r23
     40e:	90 0d       	add	r25, r0
     410:	11 24       	eor	r1, r1
     412:	28 0f       	add	r18, r24
     414:	39 1f       	adc	r19, r25
	
	
	input = temp / 10; // get 10s digit
     416:	c9 01       	movw	r24, r18
     418:	6a e0       	ldi	r22, 0x0A	; 10
     41a:	70 e0       	ldi	r23, 0x00	; 0
     41c:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__divmodhi4>
	*buffer++ = input + '0';
     420:	80 e3       	ldi	r24, 0x30	; 48
     422:	86 0f       	add	r24, r22
     424:	80 83       	st	Z, r24
	 
	 input = temp - input * 10; // get 1s digit
     426:	8a e0       	ldi	r24, 0x0A	; 10
     428:	68 9f       	mul	r22, r24
     42a:	20 19       	sub	r18, r0
     42c:	11 24       	eor	r1, r1
	 *buffer++ = input + '0';
     42e:	20 5d       	subi	r18, 0xD0	; 208
     430:	21 83       	std	Z+1, r18	; 0x01
	 
	 *buffer = '\0';
     432:	12 82       	std	Z+2, r1	; 0x02
     434:	08 95       	ret

00000436 <obstacleSend>:
	sei(); // enable interrupts..
}


void obstacleSend(char deviceBlocked, int reading)
{	
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
     43c:	00 d0       	rcall	.+0      	; 0x43e <obstacleSend+0x8>
     43e:	1f 92       	push	r1
     440:	1f 92       	push	r1
     442:	cd b7       	in	r28, 0x3d	; 61
     444:	de b7       	in	r29, 0x3e	; 62
     446:	18 2f       	mov	r17, r24
     448:	cb 01       	movw	r24, r22
	obstacleStruct obstacleInfo;
		
	if(deviceBlocked)
     44a:	11 23       	and	r17, r17
     44c:	89 f0       	breq	.+34     	; 0x470 <obstacleSend+0x3a>
	{
		myItoa(reading, obstacleInfo.data); // convert to ascii
     44e:	be 01       	movw	r22, r28
     450:	6e 5f       	subi	r22, 0xFE	; 254
     452:	7f 4f       	sbci	r23, 0xFF	; 255
     454:	cb df       	rcall	.-106    	; 0x3ec <myItoa>
		
		obstacleInfo.deviceID = deviceBlocked;
     456:	19 83       	std	Y+1, r17	; 0x01
		
		
		xQueueSendToBack(queueObstacleData, (void*) &obstacleInfo, portMAX_DELAY); // send data to queueData
     458:	20 e0       	ldi	r18, 0x00	; 0
     45a:	4f ef       	ldi	r20, 0xFF	; 255
     45c:	5f ef       	ldi	r21, 0xFF	; 255
     45e:	be 01       	movw	r22, r28
     460:	6f 5f       	subi	r22, 0xFF	; 255
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	80 91 8e 08 	lds	r24, 0x088E
     468:	90 91 8f 08 	lds	r25, 0x088F
     46c:	0e 94 44 0c 	call	0x1888	; 0x1888 <xQueueGenericSend>
	}
}
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	0f 90       	pop	r0
     476:	0f 90       	pop	r0
     478:	0f 90       	pop	r0
     47a:	df 91       	pop	r29
     47c:	cf 91       	pop	r28
     47e:	1f 91       	pop	r17
     480:	08 95       	ret

00000482 <sendObstacleDetected>:



// Queue the obstacle to send..
void sendObstacleDetected(char obstacleDetected, char * deviceBlocked, int frontSonar, int leftSonar, int rightSonar, int btmIR, int topSonar, int topIR)
{	
     482:	6f 92       	push	r6
     484:	7f 92       	push	r7
     486:	8f 92       	push	r8
     488:	9f 92       	push	r9
     48a:	af 92       	push	r10
     48c:	bf 92       	push	r11
     48e:	cf 92       	push	r12
     490:	df 92       	push	r13
     492:	ef 92       	push	r14
     494:	ff 92       	push	r15
     496:	0f 93       	push	r16
     498:	1f 93       	push	r17
     49a:	cf 93       	push	r28
     49c:	df 93       	push	r29
     49e:	1f 92       	push	r1
     4a0:	cd b7       	in	r28, 0x3d	; 61
     4a2:	de b7       	in	r29, 0x3e	; 62
     4a4:	89 83       	std	Y+1, r24	; 0x01
     4a6:	4b 01       	movw	r8, r22
     4a8:	39 01       	movw	r6, r18
	
	if(obstacleDetected > 0)
     4aa:	88 23       	and	r24, r24
     4ac:	21 f1       	breq	.+72     	; 0x4f6 <sendObstacleDetected+0x74>
	{
		
		obstacleSend(deviceBlocked[FRONT_DEVICE], frontSonar);
     4ae:	ba 01       	movw	r22, r20
     4b0:	f4 01       	movw	r30, r8
     4b2:	80 81       	ld	r24, Z
     4b4:	c0 df       	rcall	.-128    	; 0x436 <obstacleSend>

		obstacleSend(deviceBlocked[LEFT_DEVICE], leftSonar);
     4b6:	b3 01       	movw	r22, r6
     4b8:	f4 01       	movw	r30, r8
     4ba:	81 81       	ldd	r24, Z+1	; 0x01
     4bc:	bc df       	rcall	.-136    	; 0x436 <obstacleSend>

		obstacleSend(deviceBlocked[RIGHT_DEVICE], rightSonar);
     4be:	b8 01       	movw	r22, r16
     4c0:	f4 01       	movw	r30, r8
     4c2:	82 81       	ldd	r24, Z+2	; 0x02
     4c4:	b8 df       	rcall	.-144    	; 0x436 <obstacleSend>

		obstacleSend(deviceBlocked[BTM_DEVICE], btmIR);
     4c6:	b7 01       	movw	r22, r14
     4c8:	f4 01       	movw	r30, r8
     4ca:	83 81       	ldd	r24, Z+3	; 0x03
     4cc:	b4 df       	rcall	.-152    	; 0x436 <obstacleSend>
		
		obstacleSend(deviceBlocked[TOP_DEVICE], topSonar);
     4ce:	b6 01       	movw	r22, r12
     4d0:	f4 01       	movw	r30, r8
     4d2:	84 81       	ldd	r24, Z+4	; 0x04
     4d4:	b0 df       	rcall	.-160    	; 0x436 <obstacleSend>
		
		obstacleSend(deviceBlocked[HIGH_DEVICE], topIR);
     4d6:	b5 01       	movw	r22, r10
     4d8:	f4 01       	movw	r30, r8
     4da:	85 81       	ldd	r24, Z+5	; 0x05
     4dc:	ac df       	rcall	.-168    	; 0x436 <obstacleSend>
				//myUSART_transmitUSART0("p\n");
				//myUSART_transmitUSART0_c(totalObs + '0');
				//myUSART_transmitUSART0("M\n");
			//}
			
		xQueueSendToBack(queueObstacleNumber,  &obstacleDetected, portMAX_DELAY); // send obstacle...
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	4f ef       	ldi	r20, 0xFF	; 255
     4e2:	5f ef       	ldi	r21, 0xFF	; 255
     4e4:	be 01       	movw	r22, r28
     4e6:	6f 5f       	subi	r22, 0xFF	; 255
     4e8:	7f 4f       	sbci	r23, 0xFF	; 255
     4ea:	80 91 8c 08 	lds	r24, 0x088C
     4ee:	90 91 8d 08 	lds	r25, 0x088D
     4f2:	0e 94 44 0c 	call	0x1888	; 0x1888 <xQueueGenericSend>
		
	}
}
     4f6:	0f 90       	pop	r0
     4f8:	df 91       	pop	r29
     4fa:	cf 91       	pop	r28
     4fc:	1f 91       	pop	r17
     4fe:	0f 91       	pop	r16
     500:	ff 90       	pop	r15
     502:	ef 90       	pop	r14
     504:	df 90       	pop	r13
     506:	cf 90       	pop	r12
     508:	bf 90       	pop	r11
     50a:	af 90       	pop	r10
     50c:	9f 90       	pop	r9
     50e:	8f 90       	pop	r8
     510:	7f 90       	pop	r7
     512:	6f 90       	pop	r6
     514:	08 95       	ret

00000516 <Sonar_Task>:
	}
}


void Sonar_Task(void *p)
{
     516:	cf 93       	push	r28
     518:	df 93       	push	r29
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	ac 97       	sbiw	r28, 0x2c	; 44
     520:	0f b6       	in	r0, 0x3f	; 63
     522:	f8 94       	cli
     524:	de bf       	out	0x3e, r29	; 62
     526:	0f be       	out	0x3f, r0	; 63
     528:	cd bf       	out	0x3d, r28	; 61
	TickType_t xLastWakeTime;
	char obstacleDetected = 0;
     52a:	1b 82       	std	Y+3, r1	; 0x03
	int btmReference = 0, topReference = 0;
     52c:	1d 82       	std	Y+5, r1	; 0x05
     52e:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t btmSampleCount = 0, topSampleCount = 0;
     530:	1e 82       	std	Y+6, r1	; 0x06
	int topSonar, frontSonar, leftSonar, rightSonar, btmIR, topIR;
	int topSonarSample[SONAR_SAMPLE_SIZE] = {0}, frontSonarSample[SONAR_SAMPLE_SIZE] = {0}, leftSonarSample[SONAR_SAMPLE_SIZE] = {0}, rightSonarSample[SONAR_SAMPLE_SIZE] = {0};
     532:	86 e0       	ldi	r24, 0x06	; 6
     534:	fe 01       	movw	r30, r28
     536:	37 96       	adiw	r30, 0x07	; 7
     538:	df 01       	movw	r26, r30
     53a:	98 2f       	mov	r25, r24
     53c:	1d 92       	st	X+, r1
     53e:	9a 95       	dec	r25
     540:	e9 f7       	brne	.-6      	; 0x53c <Sonar_Task+0x26>
     542:	36 96       	adiw	r30, 0x06	; 6
     544:	df 01       	movw	r26, r30
     546:	98 2f       	mov	r25, r24
     548:	1d 92       	st	X+, r1
     54a:	9a 95       	dec	r25
     54c:	e9 f7       	brne	.-6      	; 0x548 <Sonar_Task+0x32>
     54e:	36 96       	adiw	r30, 0x06	; 6
     550:	df 01       	movw	r26, r30
     552:	98 2f       	mov	r25, r24
     554:	1d 92       	st	X+, r1
     556:	9a 95       	dec	r25
     558:	e9 f7       	brne	.-6      	; 0x554 <Sonar_Task+0x3e>
     55a:	36 96       	adiw	r30, 0x06	; 6
     55c:	df 01       	movw	r26, r30
     55e:	98 2f       	mov	r25, r24
     560:	1d 92       	st	X+, r1
     562:	9a 95       	dec	r25
     564:	e9 f7       	brne	.-6      	; 0x560 <Sonar_Task+0x4a>
	char deviceBlocked[SENSOR_NUM] = {0}; // flag to indicate if we should send the reading to RPI
     566:	36 96       	adiw	r30, 0x06	; 6
     568:	df 01       	movw	r26, r30
     56a:	1d 92       	st	X+, r1
     56c:	8a 95       	dec	r24
     56e:	e9 f7       	brne	.-6      	; 0x56a <Sonar_Task+0x54>
	
	
	int calibratedTopIR = mySharpIR_Read(AN10); // get first value...
     570:	82 e2       	ldi	r24, 0x22	; 34
     572:	c0 d3       	rcall	.+1920   	; 0xcf4 <mySharpIR_Read>
	int calibratedBtmIR = mySharpIR_Read(AN12); // get first value...
     574:	84 e2       	ldi	r24, 0x24	; 36
     576:	be d3       	rcall	.+1916   	; 0xcf4 <mySharpIR_Read>
     578:	9e a3       	std	Y+38, r25	; 0x26
     57a:	8d a3       	std	Y+37, r24	; 0x25
	
	xLastWakeTime = xTaskGetTickCount(); // get tick count
     57c:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <xTaskGetTickCount>
     580:	9a 83       	std	Y+2, r25	; 0x02
     582:	89 83       	std	Y+1, r24	; 0x01
		
	while(1)
	{
					
		myMaxSonar_BtmStart();
     584:	b9 d1       	rcall	.+882    	; 0x8f8 <myMaxSonar_BtmStart>
		frontSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN15), frontSonarSample);
     586:	87 e2       	ldi	r24, 0x27	; 39
     588:	1f d2       	rcall	.+1086   	; 0x9c8 <myMaxSonar_Read>
     58a:	be 01       	movw	r22, r28
     58c:	63 5f       	subi	r22, 0xF3	; 243
     58e:	7f 4f       	sbci	r23, 0xFF	; 255
     590:	12 d2       	rcall	.+1060   	; 0x9b6 <myMaxSonar_getFilteredReading>
     592:	2c 01       	movw	r4, r24
		leftSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN14), leftSonarSample);
     594:	86 e2       	ldi	r24, 0x26	; 38
     596:	18 d2       	rcall	.+1072   	; 0x9c8 <myMaxSonar_Read>
     598:	be 01       	movw	r22, r28
     59a:	6d 5e       	subi	r22, 0xED	; 237
     59c:	7f 4f       	sbci	r23, 0xFF	; 255
     59e:	0b d2       	rcall	.+1046   	; 0x9b6 <myMaxSonar_getFilteredReading>
     5a0:	98 a7       	std	Y+40, r25	; 0x28
     5a2:	8f a3       	std	Y+39, r24	; 0x27
		rightSonar	= myMaxSonar_getFilteredReading(myMaxSonar_Read(AN13), rightSonarSample); 	
     5a4:	85 e2       	ldi	r24, 0x25	; 37
     5a6:	10 d2       	rcall	.+1056   	; 0x9c8 <myMaxSonar_Read>
     5a8:	be 01       	movw	r22, r28
     5aa:	67 5e       	subi	r22, 0xE7	; 231
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	03 d2       	rcall	.+1030   	; 0x9b6 <myMaxSonar_getFilteredReading>
     5b0:	1c 01       	movw	r2, r24
		
		myMaxSonar_TopStart();
     5b2:	a9 d1       	rcall	.+850    	; 0x906 <myMaxSonar_TopStart>
		topSonar = myMaxSonar_getFilteredReading(myMaxSonar_Read(AN11), topSonarSample);
     5b4:	83 e2       	ldi	r24, 0x23	; 35
     5b6:	08 d2       	rcall	.+1040   	; 0x9c8 <myMaxSonar_Read>
     5b8:	be 01       	movw	r22, r28
     5ba:	69 5f       	subi	r22, 0xF9	; 249
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	fb d1       	rcall	.+1014   	; 0x9b6 <myMaxSonar_getFilteredReading>
     5c0:	9a a7       	std	Y+42, r25	; 0x2a
     5c2:	89 a7       	std	Y+41, r24	; 0x29
			
			
		btmIR	= mySharpIR_Read(AN12);
     5c4:	84 e2       	ldi	r24, 0x24	; 36
     5c6:	96 d3       	rcall	.+1836   	; 0xcf4 <mySharpIR_Read>
     5c8:	3c 01       	movw	r6, r24
		mySharpIR_ReCalibrate(&calibratedBtmIR, &btmReference, &btmSampleCount, btmIR, CALIBRATE_BTM_HIGH_THRESHOLD, CALIBRATE_BTM_LOW_THRESHOLD); // attempt to re-calibrate btm ir sensor if stable enough..
     5ca:	0f 2e       	mov	r0, r31
     5cc:	f9 e1       	ldi	r31, 0x19	; 25
     5ce:	ef 2e       	mov	r14, r31
     5d0:	f1 2c       	mov	r15, r1
     5d2:	f0 2d       	mov	r31, r0
     5d4:	0d e2       	ldi	r16, 0x2D	; 45
     5d6:	10 e0       	ldi	r17, 0x00	; 0
     5d8:	9c 01       	movw	r18, r24
     5da:	ae 01       	movw	r20, r28
     5dc:	4a 5f       	subi	r20, 0xFA	; 250
     5de:	5f 4f       	sbci	r21, 0xFF	; 255
     5e0:	be 01       	movw	r22, r28
     5e2:	6c 5f       	subi	r22, 0xFC	; 252
     5e4:	7f 4f       	sbci	r23, 0xFF	; 255
     5e6:	ce 01       	movw	r24, r28
     5e8:	85 96       	adiw	r24, 0x25	; 37
     5ea:	bd d3       	rcall	.+1914   	; 0xd66 <mySharpIR_ReCalibrate>
	
		topIR = mySharpIR_Read(AN10);
     5ec:	82 e2       	ldi	r24, 0x22	; 34
     5ee:	82 d3       	rcall	.+1796   	; 0xcf4 <mySharpIR_Read>
     5f0:	9c a7       	std	Y+44, r25	; 0x2c
     5f2:	8b a7       	std	Y+43, r24	; 0x2b
		//mySharpIR_ReCalibrate(&calibratedTopIR, &topReference, &topSampleCount, topIR, CALIBRATE_TOP_HIGH_THRESHOLD, CALIBRATE_TOP_LOW_THRESHOLD); // attempt to re-calibrate btm ir sensor if stable enough..
		
		
		obstacleDetected = obstacleDetection(frontSonar, obstacleDetected, deviceBlocked, leftSonar, rightSonar, topSonar, calibratedBtmIR, btmIR, topIR);
     5f4:	cd a0       	ldd	r12, Y+37	; 0x25
     5f6:	de a0       	ldd	r13, Y+38	; 0x26
     5f8:	4c 01       	movw	r8, r24
     5fa:	53 01       	movw	r10, r6
     5fc:	e9 a4       	ldd	r14, Y+41	; 0x29
     5fe:	fa a4       	ldd	r15, Y+42	; 0x2a
     600:	81 01       	movw	r16, r2
     602:	2f a1       	ldd	r18, Y+39	; 0x27
     604:	38 a5       	ldd	r19, Y+40	; 0x28
     606:	ae 01       	movw	r20, r28
     608:	41 5e       	subi	r20, 0xE1	; 225
     60a:	5f 4f       	sbci	r21, 0xFF	; 255
     60c:	6b 81       	ldd	r22, Y+3	; 0x03
     60e:	c2 01       	movw	r24, r4
     610:	19 d3       	rcall	.+1586   	; 0xc44 <obstacleDetection>
     612:	8b 83       	std	Y+3, r24	; 0x03
		obstacleAvoidance(frontSonar, topSonar, leftSonar, rightSonar, btmIR, topIR, deviceBlocked);
     614:	ce 01       	movw	r24, r28
     616:	4f 96       	adiw	r24, 0x1f	; 31
     618:	6c 01       	movw	r12, r24
     61a:	eb a4       	ldd	r14, Y+43	; 0x2b
     61c:	fc a4       	ldd	r15, Y+44	; 0x2c
     61e:	83 01       	movw	r16, r6
     620:	91 01       	movw	r18, r2
     622:	4f a1       	ldd	r20, Y+39	; 0x27
     624:	58 a5       	ldd	r21, Y+40	; 0x28
     626:	69 a5       	ldd	r22, Y+41	; 0x29
     628:	7a a5       	ldd	r23, Y+42	; 0x2a
     62a:	c2 01       	movw	r24, r4
     62c:	98 d2       	rcall	.+1328   	; 0xb5e <obstacleAvoidance>

		
		// for debuggin to print all...
		cheatPrintAll(deviceBlocked, &obstacleDetected); 
     62e:	be 01       	movw	r22, r28
     630:	6d 5f       	subi	r22, 0xFD	; 253
     632:	7f 4f       	sbci	r23, 0xFF	; 255
     634:	c6 01       	movw	r24, r12
     636:	f5 d2       	rcall	.+1514   	; 0xc22 <cheatPrintAll>
		// remove top statement... when not debuggin..
		
		
		
		sendObstacleDetected(obstacleDetected, deviceBlocked, frontSonar, leftSonar, rightSonar, btmIR, topSonar, topIR);
     638:	ab a4       	ldd	r10, Y+43	; 0x2b
     63a:	bc a4       	ldd	r11, Y+44	; 0x2c
     63c:	c9 a4       	ldd	r12, Y+41	; 0x29
     63e:	da a4       	ldd	r13, Y+42	; 0x2a
     640:	73 01       	movw	r14, r6
     642:	81 01       	movw	r16, r2
     644:	2f a1       	ldd	r18, Y+39	; 0x27
     646:	38 a5       	ldd	r19, Y+40	; 0x28
     648:	a2 01       	movw	r20, r4
     64a:	be 01       	movw	r22, r28
     64c:	61 5e       	subi	r22, 0xE1	; 225
     64e:	7f 4f       	sbci	r23, 0xFF	; 255
     650:	8b 81       	ldd	r24, Y+3	; 0x03
     652:	17 df       	rcall	.-466    	; 0x482 <sendObstacleDetected>
	
		
		vTaskDelayUntil( &xLastWakeTime, MAXSONAR_CHAIN_WAIT);  // delay 150 ms for 3 sonar chain...
     654:	66 e9       	ldi	r22, 0x96	; 150
     656:	70 e0       	ldi	r23, 0x00	; 0
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskDelayUntil>
     660:	91 cf       	rjmp	.-222    	; 0x584 <Sonar_Task+0x6e>

00000662 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     662:	cf 93       	push	r28
     664:	df 93       	push	r29
     666:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     668:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     66c:	80 91 37 02 	lds	r24, 0x0237
     670:	90 91 38 02 	lds	r25, 0x0238
     674:	89 2b       	or	r24, r25
     676:	31 f4       	brne	.+12     	; 0x684 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     678:	8c e3       	ldi	r24, 0x3C	; 60
     67a:	92 e0       	ldi	r25, 0x02	; 2
     67c:	90 93 38 02 	sts	0x0238, r25
     680:	80 93 37 02 	sts	0x0237, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     684:	40 91 39 02 	lds	r20, 0x0239
     688:	50 91 3a 02 	lds	r21, 0x023A
     68c:	9e 01       	movw	r18, r28
     68e:	24 0f       	add	r18, r20
     690:	35 1f       	adc	r19, r21
     692:	2b 3d       	cpi	r18, 0xDB	; 219
     694:	85 e0       	ldi	r24, 0x05	; 5
     696:	38 07       	cpc	r19, r24
     698:	70 f4       	brcc	.+28     	; 0x6b6 <pvPortMalloc+0x54>
     69a:	42 17       	cp	r20, r18
     69c:	53 07       	cpc	r21, r19
     69e:	70 f4       	brcc	.+28     	; 0x6bc <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     6a0:	c0 91 37 02 	lds	r28, 0x0237
     6a4:	d0 91 38 02 	lds	r29, 0x0238
     6a8:	c4 0f       	add	r28, r20
     6aa:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     6ac:	30 93 3a 02 	sts	0x023A, r19
     6b0:	20 93 39 02 	sts	0x0239, r18
     6b4:	05 c0       	rjmp	.+10     	; 0x6c0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6b6:	c0 e0       	ldi	r28, 0x00	; 0
     6b8:	d0 e0       	ldi	r29, 0x00	; 0
     6ba:	02 c0       	rjmp	.+4      	; 0x6c0 <pvPortMalloc+0x5e>
     6bc:	c0 e0       	ldi	r28, 0x00	; 0
     6be:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6c0:	0e 94 95 10 	call	0x212a	; 0x212a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6c4:	ce 01       	movw	r24, r28
     6c6:	df 91       	pop	r29
     6c8:	cf 91       	pop	r28
     6ca:	08 95       	ret

000006cc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6cc:	08 95       	ret

000006ce <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     6ce:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6d0:	03 96       	adiw	r24, 0x03	; 3
     6d2:	92 83       	std	Z+2, r25	; 0x02
     6d4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6d6:	2f ef       	ldi	r18, 0xFF	; 255
     6d8:	3f ef       	ldi	r19, 0xFF	; 255
     6da:	34 83       	std	Z+4, r19	; 0x04
     6dc:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6de:	96 83       	std	Z+6, r25	; 0x06
     6e0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6e2:	90 87       	std	Z+8, r25	; 0x08
     6e4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     6e6:	10 82       	st	Z, r1
     6e8:	08 95       	ret

000006ea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6ea:	fc 01       	movw	r30, r24
     6ec:	11 86       	std	Z+9, r1	; 0x09
     6ee:	10 86       	std	Z+8, r1	; 0x08
     6f0:	08 95       	ret

000006f2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
     6f6:	9c 01       	movw	r18, r24
     6f8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     6fa:	dc 01       	movw	r26, r24
     6fc:	11 96       	adiw	r26, 0x01	; 1
     6fe:	cd 91       	ld	r28, X+
     700:	dc 91       	ld	r29, X
     702:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     704:	d3 83       	std	Z+3, r29	; 0x03
     706:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     708:	8c 81       	ldd	r24, Y+4	; 0x04
     70a:	9d 81       	ldd	r25, Y+5	; 0x05
     70c:	95 83       	std	Z+5, r25	; 0x05
     70e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     710:	8c 81       	ldd	r24, Y+4	; 0x04
     712:	9d 81       	ldd	r25, Y+5	; 0x05
     714:	dc 01       	movw	r26, r24
     716:	13 96       	adiw	r26, 0x03	; 3
     718:	7c 93       	st	X, r23
     71a:	6e 93       	st	-X, r22
     71c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     71e:	7d 83       	std	Y+5, r23	; 0x05
     720:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     722:	31 87       	std	Z+9, r19	; 0x09
     724:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     726:	f9 01       	movw	r30, r18
     728:	80 81       	ld	r24, Z
     72a:	8f 5f       	subi	r24, 0xFF	; 255
     72c:	80 83       	st	Z, r24
}
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	08 95       	ret

00000734 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     73a:	48 81       	ld	r20, Y
     73c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     73e:	4f 3f       	cpi	r20, 0xFF	; 255
     740:	2f ef       	ldi	r18, 0xFF	; 255
     742:	52 07       	cpc	r21, r18
     744:	21 f4       	brne	.+8      	; 0x74e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     746:	fc 01       	movw	r30, r24
     748:	a7 81       	ldd	r26, Z+7	; 0x07
     74a:	b0 85       	ldd	r27, Z+8	; 0x08
     74c:	0d c0       	rjmp	.+26     	; 0x768 <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     74e:	dc 01       	movw	r26, r24
     750:	13 96       	adiw	r26, 0x03	; 3
     752:	12 96       	adiw	r26, 0x02	; 2
     754:	ed 91       	ld	r30, X+
     756:	fc 91       	ld	r31, X
     758:	13 97       	sbiw	r26, 0x03	; 3
     75a:	20 81       	ld	r18, Z
     75c:	31 81       	ldd	r19, Z+1	; 0x01
     75e:	42 17       	cp	r20, r18
     760:	53 07       	cpc	r21, r19
     762:	10 f0       	brcs	.+4      	; 0x768 <vListInsert+0x34>
     764:	df 01       	movw	r26, r30
     766:	f5 cf       	rjmp	.-22     	; 0x752 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     768:	12 96       	adiw	r26, 0x02	; 2
     76a:	ed 91       	ld	r30, X+
     76c:	fc 91       	ld	r31, X
     76e:	13 97       	sbiw	r26, 0x03	; 3
     770:	fb 83       	std	Y+3, r31	; 0x03
     772:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     774:	d5 83       	std	Z+5, r29	; 0x05
     776:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     778:	bd 83       	std	Y+5, r27	; 0x05
     77a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     77c:	13 96       	adiw	r26, 0x03	; 3
     77e:	dc 93       	st	X, r29
     780:	ce 93       	st	-X, r28
     782:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     784:	99 87       	std	Y+9, r25	; 0x09
     786:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     788:	fc 01       	movw	r30, r24
     78a:	20 81       	ld	r18, Z
     78c:	2f 5f       	subi	r18, 0xFF	; 255
     78e:	20 83       	st	Z, r18
}
     790:	df 91       	pop	r29
     792:	cf 91       	pop	r28
     794:	08 95       	ret

00000796 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     79c:	a0 85       	ldd	r26, Z+8	; 0x08
     79e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7a0:	c2 81       	ldd	r28, Z+2	; 0x02
     7a2:	d3 81       	ldd	r29, Z+3	; 0x03
     7a4:	84 81       	ldd	r24, Z+4	; 0x04
     7a6:	95 81       	ldd	r25, Z+5	; 0x05
     7a8:	9d 83       	std	Y+5, r25	; 0x05
     7aa:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7ac:	c4 81       	ldd	r28, Z+4	; 0x04
     7ae:	d5 81       	ldd	r29, Z+5	; 0x05
     7b0:	82 81       	ldd	r24, Z+2	; 0x02
     7b2:	93 81       	ldd	r25, Z+3	; 0x03
     7b4:	9b 83       	std	Y+3, r25	; 0x03
     7b6:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7b8:	11 96       	adiw	r26, 0x01	; 1
     7ba:	cd 91       	ld	r28, X+
     7bc:	dc 91       	ld	r29, X
     7be:	12 97       	sbiw	r26, 0x02	; 2
     7c0:	ce 17       	cp	r28, r30
     7c2:	df 07       	cpc	r29, r31
     7c4:	31 f4       	brne	.+12     	; 0x7d2 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7c6:	8c 81       	ldd	r24, Y+4	; 0x04
     7c8:	9d 81       	ldd	r25, Y+5	; 0x05
     7ca:	12 96       	adiw	r26, 0x02	; 2
     7cc:	9c 93       	st	X, r25
     7ce:	8e 93       	st	-X, r24
     7d0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     7d2:	11 86       	std	Z+9, r1	; 0x09
     7d4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     7d6:	8c 91       	ld	r24, X
     7d8:	81 50       	subi	r24, 0x01	; 1
     7da:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     7e2:	1f 92       	push	r1
     7e4:	0f 92       	push	r0
     7e6:	0f b6       	in	r0, 0x3f	; 63
     7e8:	0f 92       	push	r0
     7ea:	11 24       	eor	r1, r1
     7ec:	0b b6       	in	r0, 0x3b	; 59
     7ee:	0f 92       	push	r0
     7f0:	2f 93       	push	r18
     7f2:	3f 93       	push	r19
     7f4:	4f 93       	push	r20
     7f6:	5f 93       	push	r21
     7f8:	6f 93       	push	r22
     7fa:	7f 93       	push	r23
     7fc:	8f 93       	push	r24
     7fe:	9f 93       	push	r25
     800:	af 93       	push	r26
     802:	bf 93       	push	r27
     804:	ef 93       	push	r30
     806:	ff 93       	push	r31
		
	if(HC_Echo_Read)
     808:	1b 9b       	sbis	0x03, 3	; 3
     80a:	0d c0       	rjmp	.+26     	; 0x826 <__vector_9+0x44>
	{
		us_tickStart = myTimer_Read();
     80c:	35 d3       	rcall	.+1642   	; 0xe78 <myTimer_Read>
     80e:	90 e0       	ldi	r25, 0x00	; 0
     810:	90 93 95 08 	sts	0x0895, r25
     814:	80 93 94 08 	sts	0x0894, r24
		ms_tickStart = xTaskGetTickCountFromISR();
     818:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <xTaskGetTickCountFromISR>
     81c:	90 93 91 08 	sts	0x0891, r25
     820:	80 93 90 08 	sts	0x0890, r24
     824:	56 c0       	rjmp	.+172    	; 0x8d2 <__vector_9+0xf0>
	}	
	else if (!(HC_Echo_Read))
     826:	1b 99       	sbic	0x03, 3	; 3
     828:	54 c0       	rjmp	.+168    	; 0x8d2 <__vector_9+0xf0>
	{

		if ((ms_tickEnd = xTaskGetTickCountFromISR()) < ms_tickStart)
     82a:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <xTaskGetTickCountFromISR>
     82e:	90 93 9b 08 	sts	0x089B, r25
     832:	80 93 9a 08 	sts	0x089A, r24
     836:	20 91 90 08 	lds	r18, 0x0890
     83a:	30 91 91 08 	lds	r19, 0x0891
     83e:	82 17       	cp	r24, r18
     840:	93 07       	cpc	r25, r19
     842:	4c f4       	brge	.+18     	; 0x856 <__vector_9+0x74>
			ms_tickEnd += 65535;
     844:	80 91 9a 08 	lds	r24, 0x089A
     848:	90 91 9b 08 	lds	r25, 0x089B
     84c:	01 97       	sbiw	r24, 0x01	; 1
     84e:	90 93 9b 08 	sts	0x089B, r25
     852:	80 93 9a 08 	sts	0x089A, r24
		
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     856:	10 d3       	rcall	.+1568   	; 0xe78 <myTimer_Read>
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	90 93 9d 08 	sts	0x089D, r25
     85e:	80 93 9c 08 	sts	0x089C, r24
     862:	20 91 94 08 	lds	r18, 0x0894
     866:	30 91 95 08 	lds	r19, 0x0895
     86a:	82 17       	cp	r24, r18
     86c:	93 07       	cpc	r25, r19
     86e:	54 f4       	brge	.+20     	; 0x884 <__vector_9+0xa2>
			us_tickEnd += MAX_TICKS;
     870:	80 91 9c 08 	lds	r24, 0x089C
     874:	90 91 9d 08 	lds	r25, 0x089D
     878:	86 50       	subi	r24, 0x06	; 6
     87a:	9f 4f       	sbci	r25, 0xFF	; 255
     87c:	90 93 9d 08 	sts	0x089D, r25
     880:	80 93 9c 08 	sts	0x089C, r24
		
			
			
		us_tickLapsed = us_tickEnd - us_tickStart;
     884:	80 91 9c 08 	lds	r24, 0x089C
     888:	90 91 9d 08 	lds	r25, 0x089D
     88c:	20 91 94 08 	lds	r18, 0x0894
     890:	30 91 95 08 	lds	r19, 0x0895
     894:	82 1b       	sub	r24, r18
     896:	93 0b       	sbc	r25, r19
     898:	90 93 97 08 	sts	0x0897, r25
     89c:	80 93 96 08 	sts	0x0896, r24
		ms_tickLapsed = ms_tickEnd - ms_tickStart;
     8a0:	80 91 9a 08 	lds	r24, 0x089A
     8a4:	90 91 9b 08 	lds	r25, 0x089B
     8a8:	20 91 90 08 	lds	r18, 0x0890
     8ac:	30 91 91 08 	lds	r19, 0x0891
     8b0:	82 1b       	sub	r24, r18
     8b2:	93 0b       	sbc	r25, r19
     8b4:	90 93 93 08 	sts	0x0893, r25
     8b8:	80 93 92 08 	sts	0x0892, r24
		
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     8bc:	20 e0       	ldi	r18, 0x00	; 0
     8be:	40 e0       	ldi	r20, 0x00	; 0
     8c0:	50 e0       	ldi	r21, 0x00	; 0
     8c2:	60 e0       	ldi	r22, 0x00	; 0
     8c4:	70 e0       	ldi	r23, 0x00	; 0
     8c6:	80 91 98 08 	lds	r24, 0x0898
     8ca:	90 91 99 08 	lds	r25, 0x0899
     8ce:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <xQueueGenericSendFromISR>
	}	
}
     8d2:	ff 91       	pop	r31
     8d4:	ef 91       	pop	r30
     8d6:	bf 91       	pop	r27
     8d8:	af 91       	pop	r26
     8da:	9f 91       	pop	r25
     8dc:	8f 91       	pop	r24
     8de:	7f 91       	pop	r23
     8e0:	6f 91       	pop	r22
     8e2:	5f 91       	pop	r21
     8e4:	4f 91       	pop	r20
     8e6:	3f 91       	pop	r19
     8e8:	2f 91       	pop	r18
     8ea:	0f 90       	pop	r0
     8ec:	0b be       	out	0x3b, r0	; 59
     8ee:	0f 90       	pop	r0
     8f0:	0f be       	out	0x3f, r0	; 63
     8f2:	0f 90       	pop	r0
     8f4:	1f 90       	pop	r1
     8f6:	18 95       	reti

000008f8 <myMaxSonar_BtmStart>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_BtmStart()
{
	MaxSonar_BtmTriggerStart();
     8f8:	a1 9a       	sbi	0x14, 1	; 20
	
	//myTimer_DelayMicro(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	90 e0       	ldi	r25, 0x00	; 0
     8fe:	0e 94 54 11 	call	0x22a8	; 0x22a8 <vTaskDelay>
	
	MaxSonar_BtmTriggerStop();
     902:	a1 98       	cbi	0x14, 1	; 20
     904:	08 95       	ret

00000906 <myMaxSonar_TopStart>:
}

void myMaxSonar_TopStart()
{
	MaxSonar_TopTriggerStart();
     906:	a0 9a       	sbi	0x14, 0	; 20
	
	//myTimer_DelayMicro2(25); // delay 25 micro seconds...
	vTaskDelay(1);	// delay 1ms using vTaskDelay
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 54 11 	call	0x22a8	; 0x22a8 <vTaskDelay>
	
	MaxSonar_TopTriggerStop();
     910:	a0 98       	cbi	0x14, 0	; 20
     912:	08 95       	ret

00000914 <myMaxSonar_extractMedian>:
}

// extract the median of 3 values in the sample array
int myMaxSonar_extractMedian(int * sample)
{
     914:	fc 01       	movw	r30, r24
	if (sample[0] > sample[1])
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	22 81       	ldd	r18, Z+2	; 0x02
     91c:	33 81       	ldd	r19, Z+3	; 0x03
     91e:	28 17       	cp	r18, r24
     920:	39 07       	cpc	r19, r25
     922:	54 f4       	brge	.+20     	; 0x938 <myMaxSonar_extractMedian+0x24>
	{
		if (sample[1] > sample[2])
     924:	44 81       	ldd	r20, Z+4	; 0x04
     926:	55 81       	ldd	r21, Z+5	; 0x05
     928:	42 17       	cp	r20, r18
     92a:	53 07       	cpc	r21, r19
     92c:	84 f0       	brlt	.+32     	; 0x94e <myMaxSonar_extractMedian+0x3a>
     92e:	48 17       	cp	r20, r24
     930:	59 07       	cpc	r21, r25
     932:	74 f4       	brge	.+28     	; 0x950 <myMaxSonar_extractMedian+0x3c>
     934:	ca 01       	movw	r24, r20
     936:	08 95       	ret
			return sample[0];
		}
	}
	else 
	{
		if (sample[0] > sample[2])
     938:	44 81       	ldd	r20, Z+4	; 0x04
     93a:	55 81       	ldd	r21, Z+5	; 0x05
     93c:	48 17       	cp	r20, r24
     93e:	59 07       	cpc	r21, r25
     940:	3c f0       	brlt	.+14     	; 0x950 <myMaxSonar_extractMedian+0x3c>
     942:	ca 01       	movw	r24, r20
     944:	24 17       	cp	r18, r20
     946:	35 07       	cpc	r19, r21
     948:	1c f4       	brge	.+6      	; 0x950 <myMaxSonar_extractMedian+0x3c>
     94a:	c9 01       	movw	r24, r18
     94c:	08 95       	ret
{
	if (sample[0] > sample[1])
	{
		if (sample[1] > sample[2])
		{
			return sample[1];
     94e:	c9 01       	movw	r24, r18
		else 
		{
			return sample[1];
		}
	}
}
     950:	08 95       	ret

00000952 <myMaxSonar_Stabilizer>:
}

// return currentReading if it is more than the noise threshold..
int myMaxSonar_Stabilizer(const int currentReading, int prevReading)
{
	if(currentReading > (prevReading + NOISE_THRESHOLD) || currentReading < (prevReading - NOISE_THRESHOLD))
     952:	9b 01       	movw	r18, r22
     954:	28 5f       	subi	r18, 0xF8	; 248
     956:	3f 4f       	sbci	r19, 0xFF	; 255
     958:	28 17       	cp	r18, r24
     95a:	39 07       	cpc	r19, r25
     95c:	3c f0       	brlt	.+14     	; 0x96c <myMaxSonar_Stabilizer+0x1a>
     95e:	20 51       	subi	r18, 0x10	; 16
     960:	31 09       	sbc	r19, r1
     962:	82 17       	cp	r24, r18
     964:	93 07       	cpc	r25, r19
     966:	14 f0       	brlt	.+4      	; 0x96c <myMaxSonar_Stabilizer+0x1a>
	{
		return currentReading; // when current reading exceed noise range.... return current reading
	}
	else
		return prevReading; // return prevReading if in noise range..
     968:	86 2f       	mov	r24, r22
     96a:	97 2f       	mov	r25, r23
}
     96c:	08 95       	ret

0000096e <myMaxSonar_AddSample>:

}

// Add sample circular buffer way...
void myMaxSonar_AddSample(int currentReading ,int *sample)
{
     96e:	0f 93       	push	r16
     970:	1f 93       	push	r17
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	eb 01       	movw	r28, r22
	static uint8_t i = SONAR_SAMPLE_SIZE; // start with prev reading index first.. 
	 
	currentReading = myMaxSonar_Stabilizer(currentReading, sample[i]);
     978:	00 91 00 02 	lds	r16, 0x0200
     97c:	10 e0       	ldi	r17, 0x00	; 0
     97e:	f8 01       	movw	r30, r16
     980:	ee 0f       	add	r30, r30
     982:	ff 1f       	adc	r31, r31
     984:	e6 0f       	add	r30, r22
     986:	f7 1f       	adc	r31, r23
     988:	60 81       	ld	r22, Z
     98a:	71 81       	ldd	r23, Z+1	; 0x01
     98c:	e2 df       	rcall	.-60     	; 0x952 <myMaxSonar_Stabilizer>
     98e:	9c 01       	movw	r18, r24
	
	i = (i+1) % SONAR_SAMPLE_SIZE; // at correct index already..
     990:	c8 01       	movw	r24, r16
     992:	01 96       	adiw	r24, 0x01	; 1
     994:	63 e0       	ldi	r22, 0x03	; 3
     996:	70 e0       	ldi	r23, 0x00	; 0
     998:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__divmodhi4>
     99c:	80 93 00 02 	sts	0x0200, r24
	
	sample[i] = currentReading; //store..
     9a0:	88 0f       	add	r24, r24
     9a2:	99 1f       	adc	r25, r25
     9a4:	c8 0f       	add	r28, r24
     9a6:	d9 1f       	adc	r29, r25
     9a8:	39 83       	std	Y+1, r19	; 0x01
     9aa:	28 83       	st	Y, r18
}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	1f 91       	pop	r17
     9b2:	0f 91       	pop	r16
     9b4:	08 95       	ret

000009b6 <myMaxSonar_getFilteredReading>:
}


// Return filtered reading of maxSonar (Median of 3 values, with noise eliminated)
int myMaxSonar_getFilteredReading(int currentReading, int *sample)
{
     9b6:	cf 93       	push	r28
     9b8:	df 93       	push	r29
     9ba:	eb 01       	movw	r28, r22
	//currentReading = myMaxSonar_Stabilizer(currentReading, prevReading);
	myMaxSonar_AddSample(currentReading, sample);
     9bc:	d8 df       	rcall	.-80     	; 0x96e <myMaxSonar_AddSample>
	return myMaxSonar_extractMedian(sample);
     9be:	ce 01       	movw	r24, r28
     9c0:	a9 df       	rcall	.-174    	; 0x914 <myMaxSonar_extractMedian>

}
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	08 95       	ret

000009c8 <myMaxSonar_Read>:
// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	int reading = 0;
	
	int adcReading = myADC_analogRead(analogChannel);
     9c8:	b3 d0       	rcall	.+358    	; 0xb30 <myADC_analogRead>
     9ca:	9c 01       	movw	r18, r24
	reading = adcReading /FLOAT_TO_CM; // get the decimal point of ADC
     9cc:	63 e0       	ldi	r22, 0x03	; 3
     9ce:	70 e0       	ldi	r23, 0x00	; 0
     9d0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__divmodhi4>
	reading += adcReading; // add the exact adcReading
     9d4:	26 0f       	add	r18, r22
     9d6:	37 1f       	adc	r19, r23
	
	if(reading > 1000)
     9d8:	29 3e       	cpi	r18, 0xE9	; 233
     9da:	83 e0       	ldi	r24, 0x03	; 3
     9dc:	38 07       	cpc	r19, r24
     9de:	1c f0       	brlt	.+6      	; 0x9e6 <myMaxSonar_Read+0x1e>
		return 999;
     9e0:	87 ee       	ldi	r24, 0xE7	; 231
     9e2:	93 e0       	ldi	r25, 0x03	; 3
     9e4:	08 95       	ret
	
	return reading;
     9e6:	82 2f       	mov	r24, r18
     9e8:	93 2f       	mov	r25, r19
}
     9ea:	08 95       	ret

000009ec <__vector_29>:
volatile unsigned char adcReading_L;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     9ec:	1f 92       	push	r1
     9ee:	0f 92       	push	r0
     9f0:	0f b6       	in	r0, 0x3f	; 63
     9f2:	0f 92       	push	r0
     9f4:	11 24       	eor	r1, r1
     9f6:	0b b6       	in	r0, 0x3b	; 59
     9f8:	0f 92       	push	r0
     9fa:	2f 93       	push	r18
     9fc:	3f 93       	push	r19
     9fe:	4f 93       	push	r20
     a00:	5f 93       	push	r21
     a02:	6f 93       	push	r22
     a04:	7f 93       	push	r23
     a06:	8f 93       	push	r24
     a08:	9f 93       	push	r25
     a0a:	af 93       	push	r26
     a0c:	bf 93       	push	r27
     a0e:	ef 93       	push	r30
     a10:	ff 93       	push	r31
	adcReading_L = ADCL; // dont change the ORDER L first then H!!! Reading L will hold H value.
     a12:	80 91 78 00 	lds	r24, 0x0078
     a16:	80 93 9e 08 	sts	0x089E, r24
	adcReading_H = ADCH; // read value of H (not used, 640cm and 1280cm for the resolution)
     a1a:	80 91 79 00 	lds	r24, 0x0079
     a1e:	80 93 9f 08 	sts	0x089F, r24
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     a22:	20 e0       	ldi	r18, 0x00	; 0
     a24:	40 e0       	ldi	r20, 0x00	; 0
     a26:	50 e0       	ldi	r21, 0x00	; 0
     a28:	60 e0       	ldi	r22, 0x00	; 0
     a2a:	70 e0       	ldi	r23, 0x00	; 0
     a2c:	80 91 a2 08 	lds	r24, 0x08A2
     a30:	90 91 a3 08 	lds	r25, 0x08A3
     a34:	e7 d7       	rcall	.+4046   	; 0x1a04 <xQueueGenericSendFromISR>
}
     a36:	ff 91       	pop	r31
     a38:	ef 91       	pop	r30
     a3a:	bf 91       	pop	r27
     a3c:	af 91       	pop	r26
     a3e:	9f 91       	pop	r25
     a40:	8f 91       	pop	r24
     a42:	7f 91       	pop	r23
     a44:	6f 91       	pop	r22
     a46:	5f 91       	pop	r21
     a48:	4f 91       	pop	r20
     a4a:	3f 91       	pop	r19
     a4c:	2f 91       	pop	r18
     a4e:	0f 90       	pop	r0
     a50:	0b be       	out	0x3b, r0	; 59
     a52:	0f 90       	pop	r0
     a54:	0f be       	out	0x3f, r0	; 63
     a56:	0f 90       	pop	r0
     a58:	1f 90       	pop	r1
     a5a:	18 95       	reti

00000a5c <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     a5c:	8f e8       	ldi	r24, 0x8F	; 143
     a5e:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     a62:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) ; // use AVCC as reference, right adjust (take LSB but not 2 MSB)
     a66:	80 e4       	ldi	r24, 0x40	; 64
     a68:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     a6c:	43 e0       	ldi	r20, 0x03	; 3
     a6e:	60 e0       	ldi	r22, 0x00	; 0
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	dd d6       	rcall	.+3514   	; 0x182e <xQueueGenericCreate>
     a74:	90 93 a3 08 	sts	0x08A3, r25
     a78:	80 93 a2 08 	sts	0x08A2, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	97 d7       	rcall	.+3886   	; 0x19ae <xQueueCreateMutex>
     a80:	90 93 a1 08 	sts	0x08A1, r25
     a84:	80 93 a0 08 	sts	0x08A0, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     a88:	20 e0       	ldi	r18, 0x00	; 0
     a8a:	40 e0       	ldi	r20, 0x00	; 0
     a8c:	50 e0       	ldi	r21, 0x00	; 0
     a8e:	60 e0       	ldi	r22, 0x00	; 0
     a90:	70 e0       	ldi	r23, 0x00	; 0
     a92:	fa c6       	rjmp	.+3572   	; 0x1888 <xQueueGenericSend>
     a94:	08 95       	ret

00000a96 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     a96:	cf 93       	push	r28
     a98:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY); // guard against concurrent task starting adc at same time
     a9a:	20 e0       	ldi	r18, 0x00	; 0
     a9c:	4f ef       	ldi	r20, 0xFF	; 255
     a9e:	5f ef       	ldi	r21, 0xFF	; 255
     aa0:	60 e0       	ldi	r22, 0x00	; 0
     aa2:	70 e0       	ldi	r23, 0x00	; 0
     aa4:	80 91 a0 08 	lds	r24, 0x08A0
     aa8:	90 91 a1 08 	lds	r25, 0x08A1
     aac:	e5 d7       	rcall	.+4042   	; 0x1a78 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     aae:	ec e7       	ldi	r30, 0x7C	; 124
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	80 81       	ld	r24, Z
     ab4:	9c 2f       	mov	r25, r28
     ab6:	9f 71       	andi	r25, 0x1F	; 31
     ab8:	80 76       	andi	r24, 0x60	; 96
     aba:	89 2b       	or	r24, r25
     abc:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     abe:	eb e7       	ldi	r30, 0x7B	; 123
     ac0:	f0 e0       	ldi	r31, 0x00	; 0
     ac2:	20 81       	ld	r18, Z
     ac4:	c0 72       	andi	r28, 0x20	; 32
     ac6:	8c 2f       	mov	r24, r28
     ac8:	90 e0       	ldi	r25, 0x00	; 0
     aca:	95 95       	asr	r25
     acc:	87 95       	ror	r24
     ace:	95 95       	asr	r25
     ad0:	87 95       	ror	r24
     ad2:	92 2f       	mov	r25, r18
     ad4:	90 76       	andi	r25, 0x60	; 96
     ad6:	89 2b       	or	r24, r25
     ad8:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     ada:	ea e7       	ldi	r30, 0x7A	; 122
     adc:	f0 e0       	ldi	r31, 0x00	; 0
     ade:	80 81       	ld	r24, Z
     ae0:	80 64       	ori	r24, 0x40	; 64
     ae2:	80 83       	st	Z, r24
}
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <myADC_readADC>:

int myADC_readADC(char channel)
{
     ae8:	cf 93       	push	r28
     aea:	df 93       	push	r29
	int adcReading=0;
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     aec:	20 e0       	ldi	r18, 0x00	; 0
     aee:	4f ef       	ldi	r20, 0xFF	; 255
     af0:	5f ef       	ldi	r21, 0xFF	; 255
     af2:	60 e0       	ldi	r22, 0x00	; 0
     af4:	70 e0       	ldi	r23, 0x00	; 0
     af6:	80 91 a2 08 	lds	r24, 0x08A2
     afa:	90 91 a3 08 	lds	r25, 0x08A3
     afe:	bc d7       	rcall	.+3960   	; 0x1a78 <xQueueGenericReceive>

	adcReading = ((adcReading_H & 0b11) << 8);
     b00:	c0 91 9f 08 	lds	r28, 0x089F
     b04:	c3 70       	andi	r28, 0x03	; 3
     b06:	d0 e0       	ldi	r29, 0x00	; 0
     b08:	dc 2f       	mov	r29, r28
     b0a:	cc 27       	eor	r28, r28
	adcReading += adcReading_L;
     b0c:	80 91 9e 08 	lds	r24, 0x089E
     b10:	c8 0f       	add	r28, r24
     b12:	d1 1d       	adc	r29, r1

	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     b14:	20 e0       	ldi	r18, 0x00	; 0
     b16:	40 e0       	ldi	r20, 0x00	; 0
     b18:	50 e0       	ldi	r21, 0x00	; 0
     b1a:	60 e0       	ldi	r22, 0x00	; 0
     b1c:	70 e0       	ldi	r23, 0x00	; 0
     b1e:	80 91 a0 08 	lds	r24, 0x08A0
     b22:	90 91 a1 08 	lds	r25, 0x08A1
     b26:	b0 d6       	rcall	.+3424   	; 0x1888 <xQueueGenericSend>
	
	return adcReading;
     b28:	ce 01       	movw	r24, r28
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	08 95       	ret

00000b30 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


int myADC_analogRead(char channel)
{
     b30:	cf 93       	push	r28
     b32:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     b34:	b0 df       	rcall	.-160    	; 0xa96 <myADC_startADC>
	return myADC_readADC(channel);
     b36:	8c 2f       	mov	r24, r28
     b38:	d7 df       	rcall	.-82     	; 0xae8 <myADC_readADC>
}
     b3a:	cf 91       	pop	r28
     b3c:	08 95       	ret

00000b3e <detectStairs>:
	if(frontSonar < FRONT_OBSTACLE_DISTANCE && topSonar < STAIRS_TOP_LIMIT_H && topSonar > STAIRS_TOP_LIMIT_L)
		return 1;
	else 
		return 0;
	
}
     b3e:	9c 01       	movw	r18, r24
     b40:	28 5f       	subi	r18, 0xF8	; 248
     b42:	3f 4f       	sbci	r19, 0xFF	; 255
     b44:	26 17       	cp	r18, r22
     b46:	37 07       	cpc	r19, r23
     b48:	44 f0       	brlt	.+16     	; 0xb5a <detectStairs+0x1c>
     b4a:	20 51       	subi	r18, 0x10	; 16
     b4c:	31 09       	sbc	r19, r1
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	62 17       	cp	r22, r18
     b52:	73 07       	cpc	r23, r19
     b54:	1c f0       	brlt	.+6      	; 0xb5c <detectStairs+0x1e>
     b56:	80 e0       	ldi	r24, 0x00	; 0
     b58:	08 95       	ret
     b5a:	81 e0       	ldi	r24, 0x01	; 1
     b5c:	08 95       	ret

00000b5e <obstacleAvoidance>:
     b5e:	cf 92       	push	r12
     b60:	df 92       	push	r13
     b62:	f6 01       	movw	r30, r12
     b64:	83 81       	ldd	r24, Z+3	; 0x03
     b66:	88 23       	and	r24, r24
     b68:	41 f0       	breq	.+16     	; 0xb7a <obstacleAvoidance+0x1c>
     b6a:	74 9a       	sbi	0x0e, 4	; 14
     b6c:	e2 e0       	ldi	r30, 0x02	; 2
     b6e:	f1 e0       	ldi	r31, 0x01	; 1
     b70:	80 81       	ld	r24, Z
     b72:	80 61       	ori	r24, 0x10	; 16
     b74:	80 83       	st	Z, r24
     b76:	73 98       	cbi	0x0e, 3	; 14
     b78:	51 c0       	rjmp	.+162    	; 0xc1c <obstacleAvoidance+0xbe>
     b7a:	80 81       	ld	r24, Z
     b7c:	81 11       	cpse	r24, r1
     b7e:	06 c0       	rjmp	.+12     	; 0xb8c <obstacleAvoidance+0x2e>
     b80:	84 81       	ldd	r24, Z+4	; 0x04
     b82:	81 11       	cpse	r24, r1
     b84:	03 c0       	rjmp	.+6      	; 0xb8c <obstacleAvoidance+0x2e>
     b86:	85 81       	ldd	r24, Z+5	; 0x05
     b88:	88 23       	and	r24, r24
     b8a:	39 f1       	breq	.+78     	; 0xbda <obstacleAvoidance+0x7c>
     b8c:	81 81       	ldd	r24, Z+1	; 0x01
     b8e:	81 11       	cpse	r24, r1
     b90:	07 c0       	rjmp	.+14     	; 0xba0 <obstacleAvoidance+0x42>
     b92:	82 81       	ldd	r24, Z+2	; 0x02
     b94:	81 11       	cpse	r24, r1
     b96:	14 c0       	rjmp	.+40     	; 0xbc0 <obstacleAvoidance+0x62>
     b98:	73 9a       	sbi	0x0e, 3	; 14
     b9a:	81 81       	ldd	r24, Z+1	; 0x01
     b9c:	88 23       	and	r24, r24
     b9e:	d9 f1       	breq	.+118    	; 0xc16 <obstacleAvoidance+0xb8>
     ba0:	82 81       	ldd	r24, Z+2	; 0x02
     ba2:	81 11       	cpse	r24, r1
     ba4:	3b c0       	rjmp	.+118    	; 0xc1c <obstacleAvoidance+0xbe>
     ba6:	24 1b       	sub	r18, r20
     ba8:	35 0b       	sbc	r19, r21
     baa:	28 30       	cpi	r18, 0x08	; 8
     bac:	31 05       	cpc	r19, r1
     bae:	b4 f1       	brlt	.+108    	; 0xc1c <obstacleAvoidance+0xbe>
     bb0:	73 98       	cbi	0x0e, 3	; 14
     bb2:	74 98       	cbi	0x0e, 4	; 14
     bb4:	e2 e0       	ldi	r30, 0x02	; 2
     bb6:	f1 e0       	ldi	r31, 0x01	; 1
     bb8:	80 81       	ld	r24, Z
     bba:	80 61       	ori	r24, 0x10	; 16
     bbc:	80 83       	st	Z, r24
     bbe:	2e c0       	rjmp	.+92     	; 0xc1c <obstacleAvoidance+0xbe>
     bc0:	42 1b       	sub	r20, r18
     bc2:	53 0b       	sbc	r21, r19
     bc4:	48 30       	cpi	r20, 0x08	; 8
     bc6:	51 05       	cpc	r21, r1
     bc8:	4c f1       	brlt	.+82     	; 0xc1c <obstacleAvoidance+0xbe>
     bca:	73 98       	cbi	0x0e, 3	; 14
     bcc:	74 9a       	sbi	0x0e, 4	; 14
     bce:	e2 e0       	ldi	r30, 0x02	; 2
     bd0:	f1 e0       	ldi	r31, 0x01	; 1
     bd2:	80 81       	ld	r24, Z
     bd4:	8f 7e       	andi	r24, 0xEF	; 239
     bd6:	80 83       	st	Z, r24
     bd8:	21 c0       	rjmp	.+66     	; 0xc1c <obstacleAvoidance+0xbe>
     bda:	4e 31       	cpi	r20, 0x1E	; 30
     bdc:	51 05       	cpc	r21, r1
     bde:	44 f4       	brge	.+16     	; 0xbf0 <obstacleAvoidance+0x92>
     be0:	73 98       	cbi	0x0e, 3	; 14
     be2:	74 98       	cbi	0x0e, 4	; 14
     be4:	e2 e0       	ldi	r30, 0x02	; 2
     be6:	f1 e0       	ldi	r31, 0x01	; 1
     be8:	80 81       	ld	r24, Z
     bea:	80 61       	ori	r24, 0x10	; 16
     bec:	80 83       	st	Z, r24
     bee:	16 c0       	rjmp	.+44     	; 0xc1c <obstacleAvoidance+0xbe>
     bf0:	28 31       	cpi	r18, 0x18	; 24
     bf2:	31 05       	cpc	r19, r1
     bf4:	44 f4       	brge	.+16     	; 0xc06 <obstacleAvoidance+0xa8>
     bf6:	73 98       	cbi	0x0e, 3	; 14
     bf8:	74 9a       	sbi	0x0e, 4	; 14
     bfa:	e2 e0       	ldi	r30, 0x02	; 2
     bfc:	f1 e0       	ldi	r31, 0x01	; 1
     bfe:	80 81       	ld	r24, Z
     c00:	8f 7e       	andi	r24, 0xEF	; 239
     c02:	80 83       	st	Z, r24
     c04:	0b c0       	rjmp	.+22     	; 0xc1c <obstacleAvoidance+0xbe>
     c06:	73 98       	cbi	0x0e, 3	; 14
     c08:	74 98       	cbi	0x0e, 4	; 14
     c0a:	e2 e0       	ldi	r30, 0x02	; 2
     c0c:	f1 e0       	ldi	r31, 0x01	; 1
     c0e:	80 81       	ld	r24, Z
     c10:	8f 7e       	andi	r24, 0xEF	; 239
     c12:	80 83       	st	Z, r24
     c14:	03 c0       	rjmp	.+6      	; 0xc1c <obstacleAvoidance+0xbe>
     c16:	82 81       	ldd	r24, Z+2	; 0x02
     c18:	81 11       	cpse	r24, r1
     c1a:	d2 cf       	rjmp	.-92     	; 0xbc0 <obstacleAvoidance+0x62>
     c1c:	df 90       	pop	r13
     c1e:	cf 90       	pop	r12
     c20:	08 95       	ret

00000c22 <cheatPrintAll>:
     c22:	fc 01       	movw	r30, r24
     c24:	86 e0       	ldi	r24, 0x06	; 6
     c26:	db 01       	movw	r26, r22
     c28:	8c 93       	st	X, r24
     c2a:	86 e4       	ldi	r24, 0x46	; 70
     c2c:	80 83       	st	Z, r24
     c2e:	8c e4       	ldi	r24, 0x4C	; 76
     c30:	81 83       	std	Z+1, r24	; 0x01
     c32:	82 e5       	ldi	r24, 0x52	; 82
     c34:	82 83       	std	Z+2, r24	; 0x02
     c36:	82 e4       	ldi	r24, 0x42	; 66
     c38:	83 83       	std	Z+3, r24	; 0x03
     c3a:	84 e5       	ldi	r24, 0x54	; 84
     c3c:	84 83       	std	Z+4, r24	; 0x04
     c3e:	88 e4       	ldi	r24, 0x48	; 72
     c40:	85 83       	std	Z+5, r24	; 0x05
     c42:	08 95       	ret

00000c44 <obstacleDetection>:

// return number of obstacle detected...
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
     c44:	6f 92       	push	r6
     c46:	7f 92       	push	r7
     c48:	8f 92       	push	r8
     c4a:	9f 92       	push	r9
     c4c:	af 92       	push	r10
     c4e:	bf 92       	push	r11
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	0f 93       	push	r16
     c5a:	1f 93       	push	r17
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	cd b7       	in	r28, 0x3d	; 61
     c62:	de b7       	in	r29, 0x3e	; 62
     c64:	3a 01       	movw	r6, r20
     c66:	b5 01       	movw	r22, r10
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
     c68:	fa 01       	movw	r30, r20
     c6a:	15 82       	std	Z+5, r1	; 0x05
     c6c:	14 82       	std	Z+4, r1	; 0x04
     c6e:	13 82       	std	Z+3, r1	; 0x03
     c70:	12 82       	std	Z+2, r1	; 0x02
     c72:	11 82       	std	Z+1, r1	; 0x01
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
     c74:	c2 97       	sbiw	r24, 0x32	; 50
     c76:	1c f0       	brlt	.+6      	; 0xc7e <obstacleDetection+0x3a>
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
     c78:	10 82       	st	Z, r1
// implicitly return the device to send.
char obstacleDetection(int frontSonar, char obstacleDetected, char * deviceBlocked, int leftSonar, int rightSonar, int topSonar, int calibratedBtmIR, int btmIR, int topIR)
{
	// Commented out when debuggin..

	obstacleDetected = 0;
     c7a:	b1 2c       	mov	r11, r1
     c7c:	05 c0       	rjmp	.+10     	; 0xc88 <obstacleDetection+0x44>
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
     c7e:	86 e4       	ldi	r24, 0x46	; 70
     c80:	fa 01       	movw	r30, r20
     c82:	80 83       	st	Z, r24
	obstacleDetected = 0;
	deviceBlocked[FRONT_DEVICE] = deviceBlocked[LEFT_DEVICE] = deviceBlocked[RIGHT_DEVICE] = deviceBlocked[BTM_DEVICE] = deviceBlocked[TOP_DEVICE] = deviceBlocked[HIGH_DEVICE] = 0;
	
	if(frontSonar < FRONT_OBSTACLE_DISTANCE)
	{
		obstacleDetected ++;
     c84:	bb 24       	eor	r11, r11
     c86:	b3 94       	inc	r11
		deviceBlocked[FRONT_DEVICE] = FRONT_SONAR_ID;
	}
	if (leftSonar < LEFT_OBSTACLE_DISTANCE)
     c88:	2e 31       	cpi	r18, 0x1E	; 30
     c8a:	31 05       	cpc	r19, r1
     c8c:	24 f4       	brge	.+8      	; 0xc96 <obstacleDetection+0x52>
	{
		obstacleDetected ++;
     c8e:	b3 94       	inc	r11
		deviceBlocked[LEFT_DEVICE] = LEFT_SONAR_ID;
     c90:	8c e4       	ldi	r24, 0x4C	; 76
     c92:	f3 01       	movw	r30, r6
     c94:	81 83       	std	Z+1, r24	; 0x01
	}
	if (rightSonar < RIGHT_OBSTACLE_DISTANCE)
     c96:	0e 31       	cpi	r16, 0x1E	; 30
     c98:	11 05       	cpc	r17, r1
     c9a:	24 f4       	brge	.+8      	; 0xca4 <obstacleDetection+0x60>
	{
		obstacleDetected++;
     c9c:	b3 94       	inc	r11
		deviceBlocked[RIGHT_DEVICE] = RIGHT_SONAR_ID;
     c9e:	82 e5       	ldi	r24, 0x52	; 82
     ca0:	f3 01       	movw	r30, r6
     ca2:	82 83       	std	Z+2, r24	; 0x02
	}
	if (detectStairs(calibratedBtmIR, btmIR))
     ca4:	c6 01       	movw	r24, r12
     ca6:	4b df       	rcall	.-362    	; 0xb3e <detectStairs>
     ca8:	88 23       	and	r24, r24
     caa:	21 f0       	breq	.+8      	; 0xcb4 <obstacleDetection+0x70>
	{
		obstacleDetected++;
     cac:	b3 94       	inc	r11
		deviceBlocked[BTM_DEVICE] = BTM_SONAR_ID;
     cae:	82 e4       	ldi	r24, 0x42	; 66
     cb0:	f3 01       	movw	r30, r6
     cb2:	83 83       	std	Z+3, r24	; 0x03
	}
	 if (topSonar < TOP_OBSTACLE_DISTANCE)
     cb4:	f7 e3       	ldi	r31, 0x37	; 55
     cb6:	ef 16       	cp	r14, r31
     cb8:	f1 04       	cpc	r15, r1
     cba:	24 f4       	brge	.+8      	; 0xcc4 <obstacleDetection+0x80>
	{
		obstacleDetected++;
     cbc:	b3 94       	inc	r11
		deviceBlocked[TOP_DEVICE] = TOP_SONAR_ID;
     cbe:	84 e5       	ldi	r24, 0x54	; 84
     cc0:	f3 01       	movw	r30, r6
     cc2:	84 83       	std	Z+4, r24	; 0x04
	}
	
	if(topIR < HIGH_OBSTACLE_DISTANCE)
     cc4:	f0 e5       	ldi	r31, 0x50	; 80
     cc6:	8f 16       	cp	r8, r31
     cc8:	91 04       	cpc	r9, r1
     cca:	24 f4       	brge	.+8      	; 0xcd4 <obstacleDetection+0x90>
	{
		obstacleDetected++;
     ccc:	b3 94       	inc	r11
		deviceBlocked[HIGH_DEVICE] = HIGH_SONAR_ID;
     cce:	88 e4       	ldi	r24, 0x48	; 72
     cd0:	f3 01       	movw	r30, r6
     cd2:	85 83       	std	Z+5, r24	; 0x05
	}
	
	return obstacleDetected;
}
     cd4:	8b 2d       	mov	r24, r11
     cd6:	df 91       	pop	r29
     cd8:	cf 91       	pop	r28
     cda:	1f 91       	pop	r17
     cdc:	0f 91       	pop	r16
     cde:	ff 90       	pop	r15
     ce0:	ef 90       	pop	r14
     ce2:	df 90       	pop	r13
     ce4:	cf 90       	pop	r12
     ce6:	bf 90       	pop	r11
     ce8:	af 90       	pop	r10
     cea:	9f 90       	pop	r9
     cec:	8f 90       	pop	r8
     cee:	7f 90       	pop	r7
     cf0:	6f 90       	pop	r6
     cf2:	08 95       	ret

00000cf4 <mySharpIR_Read>:
#include <myUSART.h>

// Return distance in cm
int mySharpIR_Read(char analogChannel)
{
	int adcReading = myADC_analogRead(analogChannel);
     cf4:	1d df       	rcall	.-454    	; 0xb30 <myADC_analogRead>
	adcReading = 10650.08 * pow(adcReading,-0.935) - 10;
     cf6:	bc 01       	movw	r22, r24
     cf8:	88 27       	eor	r24, r24
     cfa:	77 fd       	sbrc	r23, 7
     cfc:	80 95       	com	r24
     cfe:	98 2f       	mov	r25, r24
     d00:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__floatsisf>
     d04:	29 e2       	ldi	r18, 0x29	; 41
     d06:	3c e5       	ldi	r19, 0x5C	; 92
     d08:	4f e6       	ldi	r20, 0x6F	; 111
     d0a:	5f eb       	ldi	r21, 0xBF	; 191
     d0c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <pow>
     d10:	22 e5       	ldi	r18, 0x52	; 82
     d12:	38 e6       	ldi	r19, 0x68	; 104
     d14:	46 e2       	ldi	r20, 0x26	; 38
     d16:	56 e4       	ldi	r21, 0x46	; 70
     d18:	0e 94 e0 14 	call	0x29c0	; 0x29c0 <__mulsf3>
     d1c:	20 e0       	ldi	r18, 0x00	; 0
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	40 e2       	ldi	r20, 0x20	; 32
     d22:	51 e4       	ldi	r21, 0x41	; 65
     d24:	0e 94 bc 13 	call	0x2778	; 0x2778 <__subsf3>
     d28:	0e 94 21 14 	call	0x2842	; 0x2842 <__fixsfsi>
     d2c:	cb 01       	movw	r24, r22
	if(adcReading > IR_MAX_VALUE || adcReading < IR_MIN_VALUE)
     d2e:	68 3e       	cpi	r22, 0xE8	; 232
     d30:	23 e0       	ldi	r18, 0x03	; 3
     d32:	72 07       	cpc	r23, r18
     d34:	10 f0       	brcs	.+4      	; 0xd3a <mySharpIR_Read+0x46>
		adcReading = IR_MAX_VALUE;
     d36:	87 ee       	ldi	r24, 0xE7	; 231
     d38:	93 e0       	ldi	r25, 0x03	; 3
	
	return adcReading;
}
     d3a:	08 95       	ret

00000d3c <checkOutOfRange>:

// return 1 if out of range..
char checkOutOfRange(int reading, int * checkReading, const char range)
{
	return reading > (*checkReading + range) || reading < (*checkReading - range);
     d3c:	fb 01       	movw	r30, r22
     d3e:	20 81       	ld	r18, Z
     d40:	31 81       	ldd	r19, Z+1	; 0x01
     d42:	50 e0       	ldi	r21, 0x00	; 0
     d44:	b9 01       	movw	r22, r18
     d46:	64 0f       	add	r22, r20
     d48:	75 1f       	adc	r23, r21
     d4a:	68 17       	cp	r22, r24
     d4c:	79 07       	cpc	r23, r25
     d4e:	4c f0       	brlt	.+18     	; 0xd62 <checkOutOfRange+0x26>
     d50:	24 1b       	sub	r18, r20
     d52:	35 0b       	sbc	r19, r21
     d54:	41 e0       	ldi	r20, 0x01	; 1
     d56:	82 17       	cp	r24, r18
     d58:	93 07       	cpc	r25, r19
     d5a:	0c f0       	brlt	.+2      	; 0xd5e <checkOutOfRange+0x22>
     d5c:	40 e0       	ldi	r20, 0x00	; 0
     d5e:	84 2f       	mov	r24, r20
     d60:	08 95       	ret
     d62:	81 e0       	ldi	r24, 0x01	; 1
}
     d64:	08 95       	ret

00000d66 <mySharpIR_ReCalibrate>:
// final reading = btmIR reading (i = CALIBRATE_COUNT)
// firstCheck reading = btmIR reading ( i = CALIBRATE_COUNT/2)
// initial reading  = btmIR reading (i = 0)
// Write new calibrate value if all matches..
void mySharpIR_ReCalibrate(int* calibratedReading, int * referenceReading, uint8_t * sampleCount, int reading, const int highThreshold, const int lowThreshold)
{
     d66:	8f 92       	push	r8
     d68:	9f 92       	push	r9
     d6a:	af 92       	push	r10
     d6c:	bf 92       	push	r11
     d6e:	cf 92       	push	r12
     d70:	df 92       	push	r13
     d72:	ef 92       	push	r14
     d74:	ff 92       	push	r15
     d76:	0f 93       	push	r16
     d78:	1f 93       	push	r17
     d7a:	cf 93       	push	r28
     d7c:	df 93       	push	r29
     d7e:	5c 01       	movw	r10, r24
     d80:	4b 01       	movw	r8, r22
     d82:	6a 01       	movw	r12, r20
     d84:	e9 01       	movw	r28, r18
	//static int testPrint = 0;
	
	if(!checkOutOfRange(reading, calibratedReading, CALIBRATE_RANGE) && *sampleCount == 0)
     d86:	45 e0       	ldi	r20, 0x05	; 5
     d88:	bc 01       	movw	r22, r24
     d8a:	c9 01       	movw	r24, r18
     d8c:	d7 df       	rcall	.-82     	; 0xd3c <checkOutOfRange>
     d8e:	81 11       	cpse	r24, r1
     d90:	05 c0       	rjmp	.+10     	; 0xd9c <mySharpIR_ReCalibrate+0x36>
     d92:	f6 01       	movw	r30, r12
     d94:	80 81       	ld	r24, Z
     d96:	88 23       	and	r24, r24
     d98:	09 f4       	brne	.+2      	; 0xd9c <mySharpIR_ReCalibrate+0x36>
     d9a:	47 c0       	rjmp	.+142    	; 0xe2a <mySharpIR_ReCalibrate+0xc4>
		// if current reading and calibratedReading is within range and no checking in progess
		// skip the calibration process... not needed
		return;
	}
	
	if(reading < lowThreshold || reading > highThreshold)
     d9c:	ce 15       	cp	r28, r14
     d9e:	df 05       	cpc	r29, r15
     da0:	1c f0       	brlt	.+6      	; 0xda8 <mySharpIR_ReCalibrate+0x42>
     da2:	0c 17       	cp	r16, r28
     da4:	1d 07       	cpc	r17, r29
     da6:	24 f4       	brge	.+8      	; 0xdb0 <mySharpIR_ReCalibrate+0x4a>
	{
		// Too low or Too high for it to be ground..
		*referenceReading = 0;
     da8:	f4 01       	movw	r30, r8
     daa:	11 82       	std	Z+1, r1	; 0x01
     dac:	10 82       	st	Z, r1
		return;		
     dae:	3d c0       	rjmp	.+122    	; 0xe2a <mySharpIR_ReCalibrate+0xc4>
	}
	
	
	if (*sampleCount == 0)
     db0:	f6 01       	movw	r30, r12
     db2:	80 81       	ld	r24, Z
     db4:	81 11       	cpse	r24, r1
     db6:	04 c0       	rjmp	.+8      	; 0xdc0 <mySharpIR_ReCalibrate+0x5a>
	{
		// Possible calibration... take reference from reading
		//testPrint = 0;
		*referenceReading = reading;
     db8:	f4 01       	movw	r30, r8
     dba:	d1 83       	std	Z+1, r29	; 0x01
     dbc:	c0 83       	st	Z, r28
     dbe:	31 c0       	rjmp	.+98     	; 0xe22 <mySharpIR_ReCalibrate+0xbc>
		//myUSART_transmitUSART0("\n-----RS----\n");

	}
	else if ((*sampleCount % CALIBRATE_SAMPLE_RATE) == 0) // when count reach 
     dc0:	9d ec       	ldi	r25, 0xCD	; 205
     dc2:	89 9f       	mul	r24, r25
     dc4:	91 2d       	mov	r25, r1
     dc6:	11 24       	eor	r1, r1
     dc8:	96 95       	lsr	r25
     dca:	96 95       	lsr	r25
     dcc:	29 2f       	mov	r18, r25
     dce:	22 0f       	add	r18, r18
     dd0:	22 0f       	add	r18, r18
     dd2:	92 0f       	add	r25, r18
     dd4:	89 13       	cpse	r24, r25
     dd6:	10 c0       	rjmp	.+32     	; 0xdf8 <mySharpIR_ReCalibrate+0x92>
	{
		//testPrint++;
		//myUSART_transmitUSART0_c(testPrint + '0');
		//myUSART_transmitUSART0("\n");
		if(checkOutOfRange(reading, referenceReading, CALIBRATE_RANGE))
     dd8:	45 e0       	ldi	r20, 0x05	; 5
     dda:	b4 01       	movw	r22, r8
     ddc:	ce 01       	movw	r24, r28
     dde:	ae df       	rcall	.-164    	; 0xd3c <checkOutOfRange>
     de0:	88 23       	and	r24, r24
     de2:	31 f0       	breq	.+12     	; 0xdf0 <mySharpIR_ReCalibrate+0x8a>
		{
			// Out of range.. restart to find new calibration point..
			*referenceReading = 0;
     de4:	f4 01       	movw	r30, r8
     de6:	11 82       	std	Z+1, r1	; 0x01
     de8:	10 82       	st	Z, r1
			*sampleCount = 0; // reset to count...
     dea:	f6 01       	movw	r30, r12
     dec:	10 82       	st	Z, r1
			return;
     dee:	1d c0       	rjmp	.+58     	; 0xe2a <mySharpIR_ReCalibrate+0xc4>
		}
		else
		{	// within range.. need more confirmation, update reference point..
			*referenceReading = reading;
     df0:	f4 01       	movw	r30, r8
     df2:	d1 83       	std	Z+1, r29	; 0x01
     df4:	c0 83       	st	Z, r28
     df6:	15 c0       	rjmp	.+42     	; 0xe22 <mySharpIR_ReCalibrate+0xbc>
		}
	}
	else if (*sampleCount >= CALIBRATE_SAMPLE_REQUIRE)
     df8:	82 32       	cpi	r24, 0x22	; 34
     dfa:	98 f0       	brcs	.+38     	; 0xe22 <mySharpIR_ReCalibrate+0xbc>
	{
		// Sample long enough...
		*sampleCount = 0; // reset to count..
     dfc:	f6 01       	movw	r30, r12
     dfe:	10 82       	st	Z, r1

		if(checkOutOfRange(reading, referenceReading, CALIBRATE_RANGE))
     e00:	45 e0       	ldi	r20, 0x05	; 5
     e02:	b4 01       	movw	r22, r8
     e04:	ce 01       	movw	r24, r28
     e06:	9a df       	rcall	.-204    	; 0xd3c <checkOutOfRange>
     e08:	88 23       	and	r24, r24
     e0a:	21 f0       	breq	.+8      	; 0xe14 <mySharpIR_ReCalibrate+0xae>
		{
			// Out of range.. restart to find new calibration point..
			*referenceReading = 0;
     e0c:	f4 01       	movw	r30, r8
     e0e:	11 82       	std	Z+1, r1	; 0x01
     e10:	10 82       	st	Z, r1
			return;
     e12:	0b c0       	rjmp	.+22     	; 0xe2a <mySharpIR_ReCalibrate+0xc4>
		}
		else
		{
			// all readings within range... can calibrate as new stable.
			*calibratedReading = *referenceReading; // btmIR is calibrated..
     e14:	f4 01       	movw	r30, r8
     e16:	80 81       	ld	r24, Z
     e18:	91 81       	ldd	r25, Z+1	; 0x01
     e1a:	f5 01       	movw	r30, r10
     e1c:	91 83       	std	Z+1, r25	; 0x01
     e1e:	80 83       	st	Z, r24
			//myUSART_transmitUSART0("\nACK\n");
			return;
     e20:	04 c0       	rjmp	.+8      	; 0xe2a <mySharpIR_ReCalibrate+0xc4>
		}
	}
	
	(*sampleCount)++;
     e22:	f6 01       	movw	r30, r12
     e24:	80 81       	ld	r24, Z
     e26:	8f 5f       	subi	r24, 0xFF	; 255
     e28:	80 83       	st	Z, r24
}
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	1f 91       	pop	r17
     e30:	0f 91       	pop	r16
     e32:	ff 90       	pop	r15
     e34:	ef 90       	pop	r14
     e36:	df 90       	pop	r13
     e38:	cf 90       	pop	r12
     e3a:	bf 90       	pop	r11
     e3c:	af 90       	pop	r10
     e3e:	9f 90       	pop	r9
     e40:	8f 90       	pop	r8
     e42:	08 95       	ret

00000e44 <myTimer_Init>:
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
	vTaskResume( *timerTask ); // resume delayMicroCheck..
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     e44:	90 93 a9 08 	sts	0x08A9, r25
     e48:	80 93 a8 08 	sts	0x08A8, r24
     e4c:	fc 01       	movw	r30, r24
     e4e:	80 81       	ld	r24, Z
     e50:	91 81       	ldd	r25, Z+1	; 0x01
     e52:	0e 94 07 12 	call	0x240e	; 0x240e <vTaskSuspend>
     e56:	43 e0       	ldi	r20, 0x03	; 3
     e58:	60 e0       	ldi	r22, 0x00	; 0
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	e8 d4       	rcall	.+2512   	; 0x182e <xQueueGenericCreate>
     e5e:	90 93 a5 08 	sts	0x08A5, r25
     e62:	80 93 a4 08 	sts	0x08A4, r24
     e66:	43 e0       	ldi	r20, 0x03	; 3
     e68:	60 e0       	ldi	r22, 0x00	; 0
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	e0 d4       	rcall	.+2496   	; 0x182e <xQueueGenericCreate>
     e6e:	90 93 a7 08 	sts	0x08A7, r25
     e72:	80 93 a6 08 	sts	0x08A6, r24
     e76:	08 95       	ret

00000e78 <myTimer_Read>:
     e78:	86 b5       	in	r24, 0x26	; 38
     e7a:	08 95       	ret

00000e7c <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     e80:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     e82:	c1 11       	cpse	r28, r1
     e84:	22 c0       	rjmp	.+68     	; 0xeca <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     e86:	80 91 03 02 	lds	r24, 0x0203
     e8a:	90 91 04 02 	lds	r25, 0x0204
     e8e:	88 38       	cpi	r24, 0x88	; 136
     e90:	93 41       	sbci	r25, 0x13	; 19
     e92:	51 f0       	breq	.+20     	; 0xea8 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     e94:	80 91 03 02 	lds	r24, 0x0203
     e98:	90 91 04 02 	lds	r25, 0x0204
     e9c:	8a 5f       	subi	r24, 0xFA	; 250
     e9e:	91 09       	sbc	r25, r1
     ea0:	90 93 04 02 	sts	0x0204, r25
     ea4:	80 93 03 02 	sts	0x0203, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     ea8:	80 91 01 02 	lds	r24, 0x0201
     eac:	90 91 02 02 	lds	r25, 0x0202
     eb0:	88 38       	cpi	r24, 0x88	; 136
     eb2:	93 41       	sbci	r25, 0x13	; 19
     eb4:	51 f0       	breq	.+20     	; 0xeca <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     eb6:	80 91 01 02 	lds	r24, 0x0201
     eba:	90 91 02 02 	lds	r25, 0x0202
     ebe:	8a 5f       	subi	r24, 0xFA	; 250
     ec0:	91 09       	sbc	r25, r1
     ec2:	90 93 02 02 	sts	0x0202, r25
     ec6:	80 93 01 02 	sts	0x0201, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     eca:	d0 e0       	ldi	r29, 0x00	; 0
     ecc:	80 91 03 02 	lds	r24, 0x0203
     ed0:	90 91 04 02 	lds	r25, 0x0204
     ed4:	8c 17       	cp	r24, r28
     ed6:	9d 07       	cpc	r25, r29
     ed8:	84 f4       	brge	.+32     	; 0xefa <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     eda:	88 e8       	ldi	r24, 0x88	; 136
     edc:	93 e1       	ldi	r25, 0x13	; 19
     ede:	90 93 04 02 	sts	0x0204, r25
     ee2:	80 93 03 02 	sts	0x0203, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     ee6:	20 e0       	ldi	r18, 0x00	; 0
     ee8:	40 e0       	ldi	r20, 0x00	; 0
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	60 e0       	ldi	r22, 0x00	; 0
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	80 91 a4 08 	lds	r24, 0x08A4
     ef4:	90 91 a5 08 	lds	r25, 0x08A5
     ef8:	c7 d4       	rcall	.+2446   	; 0x1888 <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     efa:	80 91 01 02 	lds	r24, 0x0201
     efe:	90 91 02 02 	lds	r25, 0x0202
     f02:	8c 17       	cp	r24, r28
     f04:	9d 07       	cpc	r25, r29
     f06:	84 f4       	brge	.+32     	; 0xf28 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     f08:	88 e8       	ldi	r24, 0x88	; 136
     f0a:	93 e1       	ldi	r25, 0x13	; 19
     f0c:	90 93 02 02 	sts	0x0202, r25
     f10:	80 93 01 02 	sts	0x0201, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	40 e0       	ldi	r20, 0x00	; 0
     f18:	50 e0       	ldi	r21, 0x00	; 0
     f1a:	60 e0       	ldi	r22, 0x00	; 0
     f1c:	70 e0       	ldi	r23, 0x00	; 0
     f1e:	80 91 a6 08 	lds	r24, 0x08A6
     f22:	90 91 a7 08 	lds	r25, 0x08A7
     f26:	b0 d4       	rcall	.+2400   	; 0x1888 <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     f28:	80 91 03 02 	lds	r24, 0x0203
     f2c:	90 91 04 02 	lds	r25, 0x0204
     f30:	88 38       	cpi	r24, 0x88	; 136
     f32:	93 41       	sbci	r25, 0x13	; 19
     f34:	79 f4       	brne	.+30     	; 0xf54 <myTimer_DelayChecker+0xd8>
     f36:	80 91 01 02 	lds	r24, 0x0201
     f3a:	90 91 02 02 	lds	r25, 0x0202
     f3e:	88 38       	cpi	r24, 0x88	; 136
     f40:	93 41       	sbci	r25, 0x13	; 19
     f42:	41 f4       	brne	.+16     	; 0xf54 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     f44:	e0 91 a8 08 	lds	r30, 0x08A8
     f48:	f0 91 a9 08 	lds	r31, 0x08A9
     f4c:	80 81       	ld	r24, Z
     f4e:	91 81       	ldd	r25, Z+1	; 0x01
     f50:	0e 94 07 12 	call	0x240e	; 0x240e <vTaskSuspend>
	}
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	08 95       	ret

00000f5a <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     f5a:	1f 92       	push	r1
     f5c:	0f 92       	push	r0
     f5e:	0f b6       	in	r0, 0x3f	; 63
     f60:	0f 92       	push	r0
     f62:	11 24       	eor	r1, r1
     f64:	0b b6       	in	r0, 0x3b	; 59
     f66:	0f 92       	push	r0
     f68:	2f 93       	push	r18
     f6a:	3f 93       	push	r19
     f6c:	4f 93       	push	r20
     f6e:	5f 93       	push	r21
     f70:	6f 93       	push	r22
     f72:	7f 93       	push	r23
     f74:	8f 93       	push	r24
     f76:	9f 93       	push	r25
     f78:	af 93       	push	r26
     f7a:	bf 93       	push	r27
     f7c:	ef 93       	push	r30
     f7e:	ff 93       	push	r31
     f80:	60 91 ce 00 	lds	r22, 0x00CE
     f84:	89 e3       	ldi	r24, 0x39	; 57
     f86:	99 e0       	ldi	r25, 0x09	; 9
     f88:	43 d6       	rcall	.+3206   	; 0x1c10 <ringBufferPush>
     f8a:	20 e0       	ldi	r18, 0x00	; 0
     f8c:	40 e0       	ldi	r20, 0x00	; 0
     f8e:	50 e0       	ldi	r21, 0x00	; 0
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	70 e0       	ldi	r23, 0x00	; 0
     f94:	80 91 1f 08 	lds	r24, 0x081F
     f98:	90 91 20 08 	lds	r25, 0x0820
     f9c:	33 d5       	rcall	.+2662   	; 0x1a04 <xQueueGenericSendFromISR>
     f9e:	89 e3       	ldi	r24, 0x39	; 57
     fa0:	99 e0       	ldi	r25, 0x09	; 9
     fa2:	4d d6       	rcall	.+3226   	; 0x1c3e <ringBufferFull>
     fa4:	ff 91       	pop	r31
     fa6:	ef 91       	pop	r30
     fa8:	bf 91       	pop	r27
     faa:	af 91       	pop	r26
     fac:	9f 91       	pop	r25
     fae:	8f 91       	pop	r24
     fb0:	7f 91       	pop	r23
     fb2:	6f 91       	pop	r22
     fb4:	5f 91       	pop	r21
     fb6:	4f 91       	pop	r20
     fb8:	3f 91       	pop	r19
     fba:	2f 91       	pop	r18
     fbc:	0f 90       	pop	r0
     fbe:	0b be       	out	0x3b, r0	; 59
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
     fc4:	0f 90       	pop	r0
     fc6:	1f 90       	pop	r1
     fc8:	18 95       	reti

00000fca <__vector_25>:
     fca:	1f 92       	push	r1
     fcc:	0f 92       	push	r0
     fce:	0f b6       	in	r0, 0x3f	; 63
     fd0:	0f 92       	push	r0
     fd2:	11 24       	eor	r1, r1
     fd4:	0b b6       	in	r0, 0x3b	; 59
     fd6:	0f 92       	push	r0
     fd8:	2f 93       	push	r18
     fda:	3f 93       	push	r19
     fdc:	4f 93       	push	r20
     fde:	5f 93       	push	r21
     fe0:	6f 93       	push	r22
     fe2:	7f 93       	push	r23
     fe4:	8f 93       	push	r24
     fe6:	9f 93       	push	r25
     fe8:	af 93       	push	r26
     fea:	bf 93       	push	r27
     fec:	ef 93       	push	r30
     fee:	ff 93       	push	r31
     ff0:	60 91 c6 00 	lds	r22, 0x00C6
     ff4:	8a ec       	ldi	r24, 0xCA	; 202
     ff6:	98 e0       	ldi	r25, 0x08	; 8
     ff8:	0b d6       	rcall	.+3094   	; 0x1c10 <ringBufferPush>
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	40 e0       	ldi	r20, 0x00	; 0
     ffe:	50 e0       	ldi	r21, 0x00	; 0
    1000:	60 e0       	ldi	r22, 0x00	; 0
    1002:	70 e0       	ldi	r23, 0x00	; 0
    1004:	80 91 1f 08 	lds	r24, 0x081F
    1008:	90 91 20 08 	lds	r25, 0x0820
    100c:	fb d4       	rcall	.+2550   	; 0x1a04 <xQueueGenericSendFromISR>
    100e:	8a ec       	ldi	r24, 0xCA	; 202
    1010:	98 e0       	ldi	r25, 0x08	; 8
    1012:	15 d6       	rcall	.+3114   	; 0x1c3e <ringBufferFull>
    1014:	ff 91       	pop	r31
    1016:	ef 91       	pop	r30
    1018:	bf 91       	pop	r27
    101a:	af 91       	pop	r26
    101c:	9f 91       	pop	r25
    101e:	8f 91       	pop	r24
    1020:	7f 91       	pop	r23
    1022:	6f 91       	pop	r22
    1024:	5f 91       	pop	r21
    1026:	4f 91       	pop	r20
    1028:	3f 91       	pop	r19
    102a:	2f 91       	pop	r18
    102c:	0f 90       	pop	r0
    102e:	0b be       	out	0x3b, r0	; 59
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63
    1034:	0f 90       	pop	r0
    1036:	1f 90       	pop	r1
    1038:	18 95       	reti

0000103a <__vector_37>:
    103a:	1f 92       	push	r1
    103c:	0f 92       	push	r0
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	0f 92       	push	r0
    1042:	11 24       	eor	r1, r1
    1044:	0b b6       	in	r0, 0x3b	; 59
    1046:	0f 92       	push	r0
    1048:	2f 93       	push	r18
    104a:	3f 93       	push	r19
    104c:	4f 93       	push	r20
    104e:	5f 93       	push	r21
    1050:	6f 93       	push	r22
    1052:	7f 93       	push	r23
    1054:	8f 93       	push	r24
    1056:	9f 93       	push	r25
    1058:	af 93       	push	r26
    105a:	bf 93       	push	r27
    105c:	ef 93       	push	r30
    105e:	ff 93       	push	r31
    1060:	8f e2       	ldi	r24, 0x2F	; 47
    1062:	99 e0       	ldi	r25, 0x09	; 9
    1064:	f3 d5       	rcall	.+3046   	; 0x1c4c <ringBufferNotEmpty>
    1066:	88 23       	and	r24, r24
    1068:	31 f0       	breq	.+12     	; 0x1076 <__vector_37+0x3c>
    106a:	8f e2       	ldi	r24, 0x2F	; 47
    106c:	99 e0       	ldi	r25, 0x09	; 9
    106e:	be d5       	rcall	.+2940   	; 0x1bec <ringBufferPop>
    1070:	80 93 ce 00 	sts	0x00CE, r24
    1074:	0f c0       	rjmp	.+30     	; 0x1094 <__vector_37+0x5a>
    1076:	e9 ec       	ldi	r30, 0xC9	; 201
    1078:	f0 e0       	ldi	r31, 0x00	; 0
    107a:	80 81       	ld	r24, Z
    107c:	8f 7d       	andi	r24, 0xDF	; 223
    107e:	80 83       	st	Z, r24
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	40 e0       	ldi	r20, 0x00	; 0
    1084:	50 e0       	ldi	r21, 0x00	; 0
    1086:	60 e0       	ldi	r22, 0x00	; 0
    1088:	70 e0       	ldi	r23, 0x00	; 0
    108a:	80 91 17 08 	lds	r24, 0x0817
    108e:	90 91 18 08 	lds	r25, 0x0818
    1092:	b8 d4       	rcall	.+2416   	; 0x1a04 <xQueueGenericSendFromISR>
    1094:	ff 91       	pop	r31
    1096:	ef 91       	pop	r30
    1098:	bf 91       	pop	r27
    109a:	af 91       	pop	r26
    109c:	9f 91       	pop	r25
    109e:	8f 91       	pop	r24
    10a0:	7f 91       	pop	r23
    10a2:	6f 91       	pop	r22
    10a4:	5f 91       	pop	r21
    10a6:	4f 91       	pop	r20
    10a8:	3f 91       	pop	r19
    10aa:	2f 91       	pop	r18
    10ac:	0f 90       	pop	r0
    10ae:	0b be       	out	0x3b, r0	; 59
    10b0:	0f 90       	pop	r0
    10b2:	0f be       	out	0x3f, r0	; 63
    10b4:	0f 90       	pop	r0
    10b6:	1f 90       	pop	r1
    10b8:	18 95       	reti

000010ba <__vector_26>:
    10ba:	1f 92       	push	r1
    10bc:	0f 92       	push	r0
    10be:	0f b6       	in	r0, 0x3f	; 63
    10c0:	0f 92       	push	r0
    10c2:	11 24       	eor	r1, r1
    10c4:	0b b6       	in	r0, 0x3b	; 59
    10c6:	0f 92       	push	r0
    10c8:	2f 93       	push	r18
    10ca:	3f 93       	push	r19
    10cc:	4f 93       	push	r20
    10ce:	5f 93       	push	r21
    10d0:	6f 93       	push	r22
    10d2:	7f 93       	push	r23
    10d4:	8f 93       	push	r24
    10d6:	9f 93       	push	r25
    10d8:	af 93       	push	r26
    10da:	bf 93       	push	r27
    10dc:	ef 93       	push	r30
    10de:	ff 93       	push	r31
    10e0:	84 e3       	ldi	r24, 0x34	; 52
    10e2:	99 e0       	ldi	r25, 0x09	; 9
    10e4:	b3 d5       	rcall	.+2918   	; 0x1c4c <ringBufferNotEmpty>
    10e6:	88 23       	and	r24, r24
    10e8:	31 f0       	breq	.+12     	; 0x10f6 <__vector_26+0x3c>
    10ea:	84 e3       	ldi	r24, 0x34	; 52
    10ec:	99 e0       	ldi	r25, 0x09	; 9
    10ee:	7e d5       	rcall	.+2812   	; 0x1bec <ringBufferPop>
    10f0:	80 93 c6 00 	sts	0x00C6, r24
    10f4:	0f c0       	rjmp	.+30     	; 0x1114 <__vector_26+0x5a>
    10f6:	e1 ec       	ldi	r30, 0xC1	; 193
    10f8:	f0 e0       	ldi	r31, 0x00	; 0
    10fa:	80 81       	ld	r24, Z
    10fc:	8f 7d       	andi	r24, 0xDF	; 223
    10fe:	80 83       	st	Z, r24
    1100:	20 e0       	ldi	r18, 0x00	; 0
    1102:	40 e0       	ldi	r20, 0x00	; 0
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	60 e0       	ldi	r22, 0x00	; 0
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	80 91 19 08 	lds	r24, 0x0819
    110e:	90 91 1a 08 	lds	r25, 0x081A
    1112:	78 d4       	rcall	.+2288   	; 0x1a04 <xQueueGenericSendFromISR>
    1114:	ff 91       	pop	r31
    1116:	ef 91       	pop	r30
    1118:	bf 91       	pop	r27
    111a:	af 91       	pop	r26
    111c:	9f 91       	pop	r25
    111e:	8f 91       	pop	r24
    1120:	7f 91       	pop	r23
    1122:	6f 91       	pop	r22
    1124:	5f 91       	pop	r21
    1126:	4f 91       	pop	r20
    1128:	3f 91       	pop	r19
    112a:	2f 91       	pop	r18
    112c:	0f 90       	pop	r0
    112e:	0b be       	out	0x3b, r0	; 59
    1130:	0f 90       	pop	r0
    1132:	0f be       	out	0x3f, r0	; 63
    1134:	0f 90       	pop	r0
    1136:	1f 90       	pop	r1
    1138:	18 95       	reti

0000113a <myUSART_USART0_Init>:
    113a:	10 92 c5 00 	sts	0x00C5, r1
    113e:	87 e6       	ldi	r24, 0x67	; 103
    1140:	80 93 c4 00 	sts	0x00C4, r24
    1144:	88 eb       	ldi	r24, 0xB8	; 184
    1146:	80 93 c1 00 	sts	0x00C1, r24
    114a:	86 e0       	ldi	r24, 0x06	; 6
    114c:	80 93 c2 00 	sts	0x00C2, r24
    1150:	40 e2       	ldi	r20, 0x20	; 32
    1152:	6f ee       	ldi	r22, 0xEF	; 239
    1154:	78 e0       	ldi	r23, 0x08	; 8
    1156:	8a ec       	ldi	r24, 0xCA	; 202
    1158:	98 e0       	ldi	r25, 0x08	; 8
    115a:	41 d5       	rcall	.+2690   	; 0x1bde <ringBufferInit>
    115c:	40 e2       	ldi	r20, 0x20	; 32
    115e:	6f ec       	ldi	r22, 0xCF	; 207
    1160:	78 e0       	ldi	r23, 0x08	; 8
    1162:	84 e3       	ldi	r24, 0x34	; 52
    1164:	99 e0       	ldi	r25, 0x09	; 9
    1166:	3b d5       	rcall	.+2678   	; 0x1bde <ringBufferInit>
    1168:	43 e0       	ldi	r20, 0x03	; 3
    116a:	60 e0       	ldi	r22, 0x00	; 0
    116c:	81 e0       	ldi	r24, 0x01	; 1
    116e:	5f d3       	rcall	.+1726   	; 0x182e <xQueueGenericCreate>
    1170:	90 93 1e 08 	sts	0x081E, r25
    1174:	80 93 1d 08 	sts	0x081D, r24
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	19 d4       	rcall	.+2098   	; 0x19ae <xQueueCreateMutex>
    117c:	90 93 1a 08 	sts	0x081A, r25
    1180:	80 93 19 08 	sts	0x0819, r24
    1184:	08 95       	ret

00001186 <myUSART_USART1_Init>:
    1186:	10 92 cd 00 	sts	0x00CD, r1
    118a:	87 e6       	ldi	r24, 0x67	; 103
    118c:	80 93 cc 00 	sts	0x00CC, r24
    1190:	88 eb       	ldi	r24, 0xB8	; 184
    1192:	80 93 c9 00 	sts	0x00C9, r24
    1196:	86 e0       	ldi	r24, 0x06	; 6
    1198:	80 93 ca 00 	sts	0x00CA, r24
    119c:	40 e2       	ldi	r20, 0x20	; 32
    119e:	6a ea       	ldi	r22, 0xAA	; 170
    11a0:	78 e0       	ldi	r23, 0x08	; 8
    11a2:	89 e3       	ldi	r24, 0x39	; 57
    11a4:	99 e0       	ldi	r25, 0x09	; 9
    11a6:	1b d5       	rcall	.+2614   	; 0x1bde <ringBufferInit>
    11a8:	40 e2       	ldi	r20, 0x20	; 32
    11aa:	6f e0       	ldi	r22, 0x0F	; 15
    11ac:	79 e0       	ldi	r23, 0x09	; 9
    11ae:	8f e2       	ldi	r24, 0x2F	; 47
    11b0:	99 e0       	ldi	r25, 0x09	; 9
    11b2:	15 d5       	rcall	.+2602   	; 0x1bde <ringBufferInit>
    11b4:	43 e0       	ldi	r20, 0x03	; 3
    11b6:	60 e0       	ldi	r22, 0x00	; 0
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	39 d3       	rcall	.+1650   	; 0x182e <xQueueGenericCreate>
    11bc:	90 93 20 08 	sts	0x0820, r25
    11c0:	80 93 1f 08 	sts	0x081F, r24
    11c4:	43 e0       	ldi	r20, 0x03	; 3
    11c6:	60 e0       	ldi	r22, 0x00	; 0
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	31 d3       	rcall	.+1634   	; 0x182e <xQueueGenericCreate>
    11cc:	90 93 1c 08 	sts	0x081C, r25
    11d0:	80 93 1b 08 	sts	0x081B, r24
    11d4:	81 e0       	ldi	r24, 0x01	; 1
    11d6:	eb d3       	rcall	.+2006   	; 0x19ae <xQueueCreateMutex>
    11d8:	90 93 18 08 	sts	0x0818, r25
    11dc:	80 93 17 08 	sts	0x0817, r24
    11e0:	08 95       	ret

000011e2 <myUSART_transmitUSART0_c>:
    11e2:	cf 93       	push	r28
    11e4:	c8 2f       	mov	r28, r24
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	4f ef       	ldi	r20, 0xFF	; 255
    11ea:	5f ef       	ldi	r21, 0xFF	; 255
    11ec:	60 e0       	ldi	r22, 0x00	; 0
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	80 91 19 08 	lds	r24, 0x0819
    11f4:	90 91 1a 08 	lds	r25, 0x081A
    11f8:	3f d4       	rcall	.+2174   	; 0x1a78 <xQueueGenericReceive>
    11fa:	84 e3       	ldi	r24, 0x34	; 52
    11fc:	99 e0       	ldi	r25, 0x09	; 9
    11fe:	1f d5       	rcall	.+2622   	; 0x1c3e <ringBufferFull>
    1200:	81 11       	cpse	r24, r1
    1202:	fb cf       	rjmp	.-10     	; 0x11fa <myUSART_transmitUSART0_c+0x18>
    1204:	6c 2f       	mov	r22, r28
    1206:	84 e3       	ldi	r24, 0x34	; 52
    1208:	99 e0       	ldi	r25, 0x09	; 9
    120a:	02 d5       	rcall	.+2564   	; 0x1c10 <ringBufferPush>
    120c:	e1 ec       	ldi	r30, 0xC1	; 193
    120e:	f0 e0       	ldi	r31, 0x00	; 0
    1210:	80 81       	ld	r24, Z
    1212:	80 62       	ori	r24, 0x20	; 32
    1214:	80 83       	st	Z, r24
    1216:	e0 ec       	ldi	r30, 0xC0	; 192
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	80 81       	ld	r24, Z
    121c:	80 64       	ori	r24, 0x40	; 64
    121e:	80 83       	st	Z, r24
    1220:	cf 91       	pop	r28
    1222:	08 95       	ret

00001224 <myUSART_transmitUSART1_c>:
    1224:	cf 93       	push	r28
    1226:	c8 2f       	mov	r28, r24
    1228:	20 e0       	ldi	r18, 0x00	; 0
    122a:	4f ef       	ldi	r20, 0xFF	; 255
    122c:	5f ef       	ldi	r21, 0xFF	; 255
    122e:	60 e0       	ldi	r22, 0x00	; 0
    1230:	70 e0       	ldi	r23, 0x00	; 0
    1232:	80 91 17 08 	lds	r24, 0x0817
    1236:	90 91 18 08 	lds	r25, 0x0818
    123a:	1e d4       	rcall	.+2108   	; 0x1a78 <xQueueGenericReceive>
    123c:	8f e2       	ldi	r24, 0x2F	; 47
    123e:	99 e0       	ldi	r25, 0x09	; 9
    1240:	fe d4       	rcall	.+2556   	; 0x1c3e <ringBufferFull>
    1242:	81 11       	cpse	r24, r1
    1244:	fb cf       	rjmp	.-10     	; 0x123c <myUSART_transmitUSART1_c+0x18>
    1246:	6c 2f       	mov	r22, r28
    1248:	8f e2       	ldi	r24, 0x2F	; 47
    124a:	99 e0       	ldi	r25, 0x09	; 9
    124c:	e1 d4       	rcall	.+2498   	; 0x1c10 <ringBufferPush>
    124e:	e9 ec       	ldi	r30, 0xC9	; 201
    1250:	f0 e0       	ldi	r31, 0x00	; 0
    1252:	80 81       	ld	r24, Z
    1254:	80 62       	ori	r24, 0x20	; 32
    1256:	80 83       	st	Z, r24
    1258:	e8 ec       	ldi	r30, 0xC8	; 200
    125a:	f0 e0       	ldi	r31, 0x00	; 0
    125c:	80 81       	ld	r24, Z
    125e:	80 64       	ori	r24, 0x40	; 64
    1260:	80 83       	st	Z, r24
    1262:	cf 91       	pop	r28
    1264:	08 95       	ret

00001266 <myUSART_transmitUSART1>:
    1266:	cf 93       	push	r28
    1268:	df 93       	push	r29
    126a:	ec 01       	movw	r28, r24
    126c:	88 81       	ld	r24, Y
    126e:	88 23       	and	r24, r24
    1270:	29 f0       	breq	.+10     	; 0x127c <myUSART_transmitUSART1+0x16>
    1272:	21 96       	adiw	r28, 0x01	; 1
    1274:	d7 df       	rcall	.-82     	; 0x1224 <myUSART_transmitUSART1_c>
    1276:	89 91       	ld	r24, Y+
    1278:	81 11       	cpse	r24, r1
    127a:	fc cf       	rjmp	.-8      	; 0x1274 <myUSART_transmitUSART1+0xe>
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	08 95       	ret

00001282 <myUSART_transmitUSART0>:
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	ec 01       	movw	r28, r24
    1288:	88 81       	ld	r24, Y
    128a:	88 23       	and	r24, r24
    128c:	29 f0       	breq	.+10     	; 0x1298 <myUSART_transmitUSART0+0x16>
    128e:	21 96       	adiw	r28, 0x01	; 1
    1290:	a8 df       	rcall	.-176    	; 0x11e2 <myUSART_transmitUSART0_c>
    1292:	89 91       	ld	r24, Y+
    1294:	81 11       	cpse	r24, r1
    1296:	fc cf       	rjmp	.-8      	; 0x1290 <myUSART_transmitUSART0+0xe>
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	08 95       	ret

0000129e <myUSART_receiveUSART1>:
    129e:	cf 93       	push	r28
    12a0:	20 e0       	ldi	r18, 0x00	; 0
    12a2:	4f ef       	ldi	r20, 0xFF	; 255
    12a4:	5f ef       	ldi	r21, 0xFF	; 255
    12a6:	60 e0       	ldi	r22, 0x00	; 0
    12a8:	70 e0       	ldi	r23, 0x00	; 0
    12aa:	80 91 1f 08 	lds	r24, 0x081F
    12ae:	90 91 20 08 	lds	r25, 0x0820
    12b2:	e2 d3       	rcall	.+1988   	; 0x1a78 <xQueueGenericReceive>
    12b4:	89 e3       	ldi	r24, 0x39	; 57
    12b6:	99 e0       	ldi	r25, 0x09	; 9
    12b8:	99 d4       	rcall	.+2354   	; 0x1bec <ringBufferPop>
    12ba:	c8 2f       	mov	r28, r24
    12bc:	89 e3       	ldi	r24, 0x39	; 57
    12be:	99 e0       	ldi	r25, 0x09	; 9
    12c0:	c5 d4       	rcall	.+2442   	; 0x1c4c <ringBufferNotEmpty>
    12c2:	88 23       	and	r24, r24
    12c4:	51 f0       	breq	.+20     	; 0x12da <myUSART_receiveUSART1+0x3c>
    12c6:	20 e0       	ldi	r18, 0x00	; 0
    12c8:	40 e0       	ldi	r20, 0x00	; 0
    12ca:	50 e0       	ldi	r21, 0x00	; 0
    12cc:	60 e0       	ldi	r22, 0x00	; 0
    12ce:	70 e0       	ldi	r23, 0x00	; 0
    12d0:	80 91 1f 08 	lds	r24, 0x081F
    12d4:	90 91 20 08 	lds	r25, 0x0820
    12d8:	d7 d2       	rcall	.+1454   	; 0x1888 <xQueueGenericSend>
    12da:	8c 2f       	mov	r24, r28
    12dc:	cf 91       	pop	r28
    12de:	08 95       	ret

000012e0 <myUSART_startHandShake>:

// 0 if fail, 1 success
char myUSART_startHandShake()
{
	
	myUSART_transmitUSART1_c(HANDSHAKE_START);
    12e0:	86 e1       	ldi	r24, 0x16	; 22
    12e2:	a0 df       	rcall	.-192    	; 0x1224 <myUSART_transmitUSART1_c>

	if( xSemaphoreTake( semaUsart1HandShake, ( TickType_t ) HANDSHAKE_TIMEOUT ) == pdTRUE )
    12e4:	20 e0       	ldi	r18, 0x00	; 0
    12e6:	44 ef       	ldi	r20, 0xF4	; 244
    12e8:	51 e0       	ldi	r21, 0x01	; 1
    12ea:	60 e0       	ldi	r22, 0x00	; 0
    12ec:	70 e0       	ldi	r23, 0x00	; 0
    12ee:	80 91 1b 08 	lds	r24, 0x081B
    12f2:	90 91 1c 08 	lds	r25, 0x081C
    12f6:	c0 d3       	rcall	.+1920   	; 0x1a78 <xQueueGenericReceive>
    12f8:	81 30       	cpi	r24, 0x01	; 1
    12fa:	21 f4       	brne	.+8      	; 0x1304 <myUSART_startHandShake+0x24>
	{	
		// got the semaphore
		myUSART_transmitUSART1_c(HANDSHAKE_FIN);
    12fc:	82 e0       	ldi	r24, 0x02	; 2
    12fe:	92 df       	rcall	.-220    	; 0x1224 <myUSART_transmitUSART1_c>
		return 1;
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	08 95       	ret
	}
	else
	{
		return 0;
    1304:	80 e0       	ldi	r24, 0x00	; 0
	}

}
    1306:	08 95       	ret

00001308 <myUSART_completeHandShake>:


void myUSART_completeHandShake()
{
	xSemaphoreGive(semaUsart1HandShake);	
    1308:	20 e0       	ldi	r18, 0x00	; 0
    130a:	40 e0       	ldi	r20, 0x00	; 0
    130c:	50 e0       	ldi	r21, 0x00	; 0
    130e:	60 e0       	ldi	r22, 0x00	; 0
    1310:	70 e0       	ldi	r23, 0x00	; 0
    1312:	80 91 1b 08 	lds	r24, 0x081B
    1316:	90 91 1c 08 	lds	r25, 0x081C
    131a:	b6 c2       	rjmp	.+1388   	; 0x1888 <xQueueGenericSend>
    131c:	08 95       	ret

0000131e <myUSART_receiveHandShakeAck>:
}

char myUSART_receiveHandShakeAck(unsigned char message)
{
	return (message == HANDSHAKE_ACK);
    131e:	91 e0       	ldi	r25, 0x01	; 1
    1320:	85 30       	cpi	r24, 0x05	; 5
    1322:	09 f0       	breq	.+2      	; 0x1326 <myUSART_receiveHandShakeAck+0x8>
    1324:	90 e0       	ldi	r25, 0x00	; 0
}
    1326:	89 2f       	mov	r24, r25
    1328:	08 95       	ret

0000132a <myUSART_receiveHandShakeStart>:

char myUSART_receiveHandShakeStart(unsigned char message)
{
	return (message == HANDSHAKE_START);
    132a:	91 e0       	ldi	r25, 0x01	; 1
    132c:	86 31       	cpi	r24, 0x16	; 22
    132e:	09 f0       	breq	.+2      	; 0x1332 <myUSART_receiveHandShakeStart+0x8>
    1330:	90 e0       	ldi	r25, 0x00	; 0
}
    1332:	89 2f       	mov	r24, r25
    1334:	08 95       	ret

00001336 <myUSART_receiveHandShakeFin>:


char myUSART_receiveHandShakeFin(unsigned char message)
{
	return (message == HANDSHAKE_FIN);
    1336:	91 e0       	ldi	r25, 0x01	; 1
    1338:	82 30       	cpi	r24, 0x02	; 2
    133a:	09 f0       	breq	.+2      	; 0x133e <myUSART_receiveHandShakeFin+0x8>
    133c:	90 e0       	ldi	r25, 0x00	; 0
}
    133e:	89 2f       	mov	r24, r25
    1340:	08 95       	ret

00001342 <myUSART_receiveMessageACK>:


char myUSART_receiveMessageACK(unsigned char message)
{
	return (message == MESSAGE_ACK);
    1342:	91 e0       	ldi	r25, 0x01	; 1
    1344:	86 30       	cpi	r24, 0x06	; 6
    1346:	09 f0       	breq	.+2      	; 0x134a <myUSART_receiveMessageACK+0x8>
    1348:	90 e0       	ldi	r25, 0x00	; 0
}
    134a:	89 2f       	mov	r24, r25
    134c:	08 95       	ret

0000134e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    134e:	31 e1       	ldi	r19, 0x11	; 17
    1350:	fc 01       	movw	r30, r24
    1352:	30 83       	st	Z, r19
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	22 e2       	ldi	r18, 0x22	; 34
    1358:	20 83       	st	Z, r18
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	a3 e3       	ldi	r26, 0x33	; 51
    135e:	a0 83       	st	Z, r26
    1360:	31 97       	sbiw	r30, 0x01	; 1
    1362:	60 83       	st	Z, r22
    1364:	31 97       	sbiw	r30, 0x01	; 1
    1366:	70 83       	st	Z, r23
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	10 82       	st	Z, r1
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	10 82       	st	Z, r1
    1370:	31 97       	sbiw	r30, 0x01	; 1
    1372:	60 e8       	ldi	r22, 0x80	; 128
    1374:	60 83       	st	Z, r22
    1376:	31 97       	sbiw	r30, 0x01	; 1
    1378:	10 82       	st	Z, r1
    137a:	31 97       	sbiw	r30, 0x01	; 1
    137c:	10 82       	st	Z, r1
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	10 82       	st	Z, r1
    1382:	31 97       	sbiw	r30, 0x01	; 1
    1384:	62 e0       	ldi	r22, 0x02	; 2
    1386:	60 83       	st	Z, r22
    1388:	31 97       	sbiw	r30, 0x01	; 1
    138a:	63 e0       	ldi	r22, 0x03	; 3
    138c:	60 83       	st	Z, r22
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	64 e0       	ldi	r22, 0x04	; 4
    1392:	60 83       	st	Z, r22
    1394:	31 97       	sbiw	r30, 0x01	; 1
    1396:	65 e0       	ldi	r22, 0x05	; 5
    1398:	60 83       	st	Z, r22
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	66 e0       	ldi	r22, 0x06	; 6
    139e:	60 83       	st	Z, r22
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	67 e0       	ldi	r22, 0x07	; 7
    13a4:	60 83       	st	Z, r22
    13a6:	31 97       	sbiw	r30, 0x01	; 1
    13a8:	68 e0       	ldi	r22, 0x08	; 8
    13aa:	60 83       	st	Z, r22
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	69 e0       	ldi	r22, 0x09	; 9
    13b0:	60 83       	st	Z, r22
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	60 e1       	ldi	r22, 0x10	; 16
    13b6:	60 83       	st	Z, r22
    13b8:	31 97       	sbiw	r30, 0x01	; 1
    13ba:	30 83       	st	Z, r19
    13bc:	31 97       	sbiw	r30, 0x01	; 1
    13be:	32 e1       	ldi	r19, 0x12	; 18
    13c0:	30 83       	st	Z, r19
    13c2:	31 97       	sbiw	r30, 0x01	; 1
    13c4:	33 e1       	ldi	r19, 0x13	; 19
    13c6:	30 83       	st	Z, r19
    13c8:	31 97       	sbiw	r30, 0x01	; 1
    13ca:	34 e1       	ldi	r19, 0x14	; 20
    13cc:	30 83       	st	Z, r19
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	35 e1       	ldi	r19, 0x15	; 21
    13d2:	30 83       	st	Z, r19
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	36 e1       	ldi	r19, 0x16	; 22
    13d8:	30 83       	st	Z, r19
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	37 e1       	ldi	r19, 0x17	; 23
    13de:	30 83       	st	Z, r19
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	38 e1       	ldi	r19, 0x18	; 24
    13e4:	30 83       	st	Z, r19
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	39 e1       	ldi	r19, 0x19	; 25
    13ea:	30 83       	st	Z, r19
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	30 e2       	ldi	r19, 0x20	; 32
    13f0:	30 83       	st	Z, r19
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	31 e2       	ldi	r19, 0x21	; 33
    13f6:	30 83       	st	Z, r19
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	20 83       	st	Z, r18
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	23 e2       	ldi	r18, 0x23	; 35
    1400:	20 83       	st	Z, r18
    1402:	31 97       	sbiw	r30, 0x01	; 1
    1404:	40 83       	st	Z, r20
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	50 83       	st	Z, r21
    140a:	31 97       	sbiw	r30, 0x01	; 1
    140c:	26 e2       	ldi	r18, 0x26	; 38
    140e:	20 83       	st	Z, r18
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	27 e2       	ldi	r18, 0x27	; 39
    1414:	20 83       	st	Z, r18
    1416:	31 97       	sbiw	r30, 0x01	; 1
    1418:	28 e2       	ldi	r18, 0x28	; 40
    141a:	20 83       	st	Z, r18
    141c:	31 97       	sbiw	r30, 0x01	; 1
    141e:	29 e2       	ldi	r18, 0x29	; 41
    1420:	20 83       	st	Z, r18
    1422:	31 97       	sbiw	r30, 0x01	; 1
    1424:	20 e3       	ldi	r18, 0x30	; 48
    1426:	20 83       	st	Z, r18
    1428:	31 97       	sbiw	r30, 0x01	; 1
    142a:	21 e3       	ldi	r18, 0x31	; 49
    142c:	20 83       	st	Z, r18
    142e:	89 97       	sbiw	r24, 0x29	; 41
    1430:	08 95       	ret

00001432 <xPortStartScheduler>:
    1432:	82 e0       	ldi	r24, 0x02	; 2
    1434:	84 bd       	out	0x24, r24	; 36
    1436:	16 bc       	out	0x26, r1	; 38
    1438:	80 e3       	ldi	r24, 0x30	; 48
    143a:	87 bd       	out	0x27, r24	; 39
    143c:	ee e6       	ldi	r30, 0x6E	; 110
    143e:	f0 e0       	ldi	r31, 0x00	; 0
    1440:	80 81       	ld	r24, Z
    1442:	82 60       	ori	r24, 0x02	; 2
    1444:	80 83       	st	Z, r24
    1446:	83 e0       	ldi	r24, 0x03	; 3
    1448:	85 bd       	out	0x25, r24	; 37
    144a:	a0 91 8a 08 	lds	r26, 0x088A
    144e:	b0 91 8b 08 	lds	r27, 0x088B
    1452:	cd 91       	ld	r28, X+
    1454:	cd bf       	out	0x3d, r28	; 61
    1456:	dd 91       	ld	r29, X+
    1458:	de bf       	out	0x3e, r29	; 62
    145a:	ff 91       	pop	r31
    145c:	ef 91       	pop	r30
    145e:	df 91       	pop	r29
    1460:	cf 91       	pop	r28
    1462:	bf 91       	pop	r27
    1464:	af 91       	pop	r26
    1466:	9f 91       	pop	r25
    1468:	8f 91       	pop	r24
    146a:	7f 91       	pop	r23
    146c:	6f 91       	pop	r22
    146e:	5f 91       	pop	r21
    1470:	4f 91       	pop	r20
    1472:	3f 91       	pop	r19
    1474:	2f 91       	pop	r18
    1476:	1f 91       	pop	r17
    1478:	0f 91       	pop	r16
    147a:	ff 90       	pop	r15
    147c:	ef 90       	pop	r14
    147e:	df 90       	pop	r13
    1480:	cf 90       	pop	r12
    1482:	bf 90       	pop	r11
    1484:	af 90       	pop	r10
    1486:	9f 90       	pop	r9
    1488:	8f 90       	pop	r8
    148a:	7f 90       	pop	r7
    148c:	6f 90       	pop	r6
    148e:	5f 90       	pop	r5
    1490:	4f 90       	pop	r4
    1492:	3f 90       	pop	r3
    1494:	2f 90       	pop	r2
    1496:	1f 90       	pop	r1
    1498:	0f 90       	pop	r0
    149a:	0c be       	out	0x3c, r0	; 60
    149c:	0f 90       	pop	r0
    149e:	0b be       	out	0x3b, r0	; 59
    14a0:	0f 90       	pop	r0
    14a2:	0f be       	out	0x3f, r0	; 63
    14a4:	0f 90       	pop	r0
    14a6:	08 95       	ret
    14a8:	81 e0       	ldi	r24, 0x01	; 1
    14aa:	08 95       	ret

000014ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14ac:	0f 92       	push	r0
    14ae:	0f b6       	in	r0, 0x3f	; 63
    14b0:	f8 94       	cli
    14b2:	0f 92       	push	r0
    14b4:	0b b6       	in	r0, 0x3b	; 59
    14b6:	0f 92       	push	r0
    14b8:	0c b6       	in	r0, 0x3c	; 60
    14ba:	0f 92       	push	r0
    14bc:	1f 92       	push	r1
    14be:	11 24       	eor	r1, r1
    14c0:	2f 92       	push	r2
    14c2:	3f 92       	push	r3
    14c4:	4f 92       	push	r4
    14c6:	5f 92       	push	r5
    14c8:	6f 92       	push	r6
    14ca:	7f 92       	push	r7
    14cc:	8f 92       	push	r8
    14ce:	9f 92       	push	r9
    14d0:	af 92       	push	r10
    14d2:	bf 92       	push	r11
    14d4:	cf 92       	push	r12
    14d6:	df 92       	push	r13
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	2f 93       	push	r18
    14e2:	3f 93       	push	r19
    14e4:	4f 93       	push	r20
    14e6:	5f 93       	push	r21
    14e8:	6f 93       	push	r22
    14ea:	7f 93       	push	r23
    14ec:	8f 93       	push	r24
    14ee:	9f 93       	push	r25
    14f0:	af 93       	push	r26
    14f2:	bf 93       	push	r27
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	ef 93       	push	r30
    14fa:	ff 93       	push	r31
    14fc:	a0 91 8a 08 	lds	r26, 0x088A
    1500:	b0 91 8b 08 	lds	r27, 0x088B
    1504:	0d b6       	in	r0, 0x3d	; 61
    1506:	0d 92       	st	X+, r0
    1508:	0e b6       	in	r0, 0x3e	; 62
    150a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    150c:	22 d7       	rcall	.+3652   	; 0x2352 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    150e:	a0 91 8a 08 	lds	r26, 0x088A
    1512:	b0 91 8b 08 	lds	r27, 0x088B
    1516:	cd 91       	ld	r28, X+
    1518:	cd bf       	out	0x3d, r28	; 61
    151a:	dd 91       	ld	r29, X+
    151c:	de bf       	out	0x3e, r29	; 62
    151e:	ff 91       	pop	r31
    1520:	ef 91       	pop	r30
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	bf 91       	pop	r27
    1528:	af 91       	pop	r26
    152a:	9f 91       	pop	r25
    152c:	8f 91       	pop	r24
    152e:	7f 91       	pop	r23
    1530:	6f 91       	pop	r22
    1532:	5f 91       	pop	r21
    1534:	4f 91       	pop	r20
    1536:	3f 91       	pop	r19
    1538:	2f 91       	pop	r18
    153a:	1f 91       	pop	r17
    153c:	0f 91       	pop	r16
    153e:	ff 90       	pop	r15
    1540:	ef 90       	pop	r14
    1542:	df 90       	pop	r13
    1544:	cf 90       	pop	r12
    1546:	bf 90       	pop	r11
    1548:	af 90       	pop	r10
    154a:	9f 90       	pop	r9
    154c:	8f 90       	pop	r8
    154e:	7f 90       	pop	r7
    1550:	6f 90       	pop	r6
    1552:	5f 90       	pop	r5
    1554:	4f 90       	pop	r4
    1556:	3f 90       	pop	r3
    1558:	2f 90       	pop	r2
    155a:	1f 90       	pop	r1
    155c:	0f 90       	pop	r0
    155e:	0c be       	out	0x3c, r0	; 60
    1560:	0f 90       	pop	r0
    1562:	0b be       	out	0x3b, r0	; 59
    1564:	0f 90       	pop	r0
    1566:	0f be       	out	0x3f, r0	; 63
    1568:	0f 90       	pop	r0

	asm volatile ( "ret" );
    156a:	08 95       	ret

0000156c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    156c:	0f 92       	push	r0
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
    1574:	0b b6       	in	r0, 0x3b	; 59
    1576:	0f 92       	push	r0
    1578:	0c b6       	in	r0, 0x3c	; 60
    157a:	0f 92       	push	r0
    157c:	1f 92       	push	r1
    157e:	11 24       	eor	r1, r1
    1580:	2f 92       	push	r2
    1582:	3f 92       	push	r3
    1584:	4f 92       	push	r4
    1586:	5f 92       	push	r5
    1588:	6f 92       	push	r6
    158a:	7f 92       	push	r7
    158c:	8f 92       	push	r8
    158e:	9f 92       	push	r9
    1590:	af 92       	push	r10
    1592:	bf 92       	push	r11
    1594:	cf 92       	push	r12
    1596:	df 92       	push	r13
    1598:	ef 92       	push	r14
    159a:	ff 92       	push	r15
    159c:	0f 93       	push	r16
    159e:	1f 93       	push	r17
    15a0:	2f 93       	push	r18
    15a2:	3f 93       	push	r19
    15a4:	4f 93       	push	r20
    15a6:	5f 93       	push	r21
    15a8:	6f 93       	push	r22
    15aa:	7f 93       	push	r23
    15ac:	8f 93       	push	r24
    15ae:	9f 93       	push	r25
    15b0:	af 93       	push	r26
    15b2:	bf 93       	push	r27
    15b4:	cf 93       	push	r28
    15b6:	df 93       	push	r29
    15b8:	ef 93       	push	r30
    15ba:	ff 93       	push	r31
    15bc:	a0 91 8a 08 	lds	r26, 0x088A
    15c0:	b0 91 8b 08 	lds	r27, 0x088B
    15c4:	0d b6       	in	r0, 0x3d	; 61
    15c6:	0d 92       	st	X+, r0
    15c8:	0e b6       	in	r0, 0x3e	; 62
    15ca:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    15cc:	f0 d4       	rcall	.+2528   	; 0x1fae <xTaskIncrementTick>
    15ce:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    15d0:	c0 d6       	rcall	.+3456   	; 0x2352 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    15d2:	a0 91 8a 08 	lds	r26, 0x088A
    15d6:	b0 91 8b 08 	lds	r27, 0x088B
    15da:	cd 91       	ld	r28, X+
    15dc:	cd bf       	out	0x3d, r28	; 61
    15de:	dd 91       	ld	r29, X+
    15e0:	de bf       	out	0x3e, r29	; 62
    15e2:	ff 91       	pop	r31
    15e4:	ef 91       	pop	r30
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	bf 91       	pop	r27
    15ec:	af 91       	pop	r26
    15ee:	9f 91       	pop	r25
    15f0:	8f 91       	pop	r24
    15f2:	7f 91       	pop	r23
    15f4:	6f 91       	pop	r22
    15f6:	5f 91       	pop	r21
    15f8:	4f 91       	pop	r20
    15fa:	3f 91       	pop	r19
    15fc:	2f 91       	pop	r18
    15fe:	1f 91       	pop	r17
    1600:	0f 91       	pop	r16
    1602:	ff 90       	pop	r15
    1604:	ef 90       	pop	r14
    1606:	df 90       	pop	r13
    1608:	cf 90       	pop	r12
    160a:	bf 90       	pop	r11
    160c:	af 90       	pop	r10
    160e:	9f 90       	pop	r9
    1610:	8f 90       	pop	r8
    1612:	7f 90       	pop	r7
    1614:	6f 90       	pop	r6
    1616:	5f 90       	pop	r5
    1618:	4f 90       	pop	r4
    161a:	3f 90       	pop	r3
    161c:	2f 90       	pop	r2
    161e:	1f 90       	pop	r1
    1620:	0f 90       	pop	r0
    1622:	0c be       	out	0x3c, r0	; 60
    1624:	0f 90       	pop	r0
    1626:	0b be       	out	0x3b, r0	; 59
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63
    162c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    162e:	08 95       	ret

00001630 <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
    1630:	9d df       	rcall	.-198    	; 0x156c <vPortYieldFromTick>
		 asm volatile ("reti");
    1632:	18 95       	reti

00001634 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1634:	1f 93       	push	r17
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	ec 01       	movw	r28, r24
    163c:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    163e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1640:	81 11       	cpse	r24, r1
    1642:	0c c0       	rjmp	.+24     	; 0x165c <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1644:	88 81       	ld	r24, Y
    1646:	99 81       	ldd	r25, Y+1	; 0x01
    1648:	89 2b       	or	r24, r25
    164a:	09 f0       	breq	.+2      	; 0x164e <prvCopyDataToQueue+0x1a>
    164c:	47 c0       	rjmp	.+142    	; 0x16dc <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    164e:	8a 81       	ldd	r24, Y+2	; 0x02
    1650:	9b 81       	ldd	r25, Y+3	; 0x03
    1652:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    1656:	1b 82       	std	Y+3, r1	; 0x03
    1658:	1a 82       	std	Y+2, r1	; 0x02
    165a:	47 c0       	rjmp	.+142    	; 0x16ea <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    165c:	41 11       	cpse	r20, r1
    165e:	18 c0       	rjmp	.+48     	; 0x1690 <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    1660:	48 2f       	mov	r20, r24
    1662:	50 e0       	ldi	r21, 0x00	; 0
    1664:	8c 81       	ldd	r24, Y+4	; 0x04
    1666:	9d 81       	ldd	r25, Y+5	; 0x05
    1668:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    166c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    166e:	8c 81       	ldd	r24, Y+4	; 0x04
    1670:	9d 81       	ldd	r25, Y+5	; 0x05
    1672:	82 0f       	add	r24, r18
    1674:	91 1d       	adc	r25, r1
    1676:	9d 83       	std	Y+5, r25	; 0x05
    1678:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    167a:	2a 81       	ldd	r18, Y+2	; 0x02
    167c:	3b 81       	ldd	r19, Y+3	; 0x03
    167e:	82 17       	cp	r24, r18
    1680:	93 07       	cpc	r25, r19
    1682:	70 f1       	brcs	.+92     	; 0x16e0 <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1684:	88 81       	ld	r24, Y
    1686:	99 81       	ldd	r25, Y+1	; 0x01
    1688:	9d 83       	std	Y+5, r25	; 0x05
    168a:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	2d c0       	rjmp	.+90     	; 0x16ea <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1690:	48 2f       	mov	r20, r24
    1692:	50 e0       	ldi	r21, 0x00	; 0
    1694:	8e 81       	ldd	r24, Y+6	; 0x06
    1696:	9f 81       	ldd	r25, Y+7	; 0x07
    1698:	0e 94 37 17 	call	0x2e6e	; 0x2e6e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    169c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	31 95       	neg	r19
    16a2:	21 95       	neg	r18
    16a4:	31 09       	sbc	r19, r1
    16a6:	8e 81       	ldd	r24, Y+6	; 0x06
    16a8:	9f 81       	ldd	r25, Y+7	; 0x07
    16aa:	82 0f       	add	r24, r18
    16ac:	93 1f       	adc	r25, r19
    16ae:	9f 83       	std	Y+7, r25	; 0x07
    16b0:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    16b2:	68 81       	ld	r22, Y
    16b4:	79 81       	ldd	r23, Y+1	; 0x01
    16b6:	86 17       	cp	r24, r22
    16b8:	97 07       	cpc	r25, r23
    16ba:	30 f4       	brcc	.+12     	; 0x16c8 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    16bc:	8a 81       	ldd	r24, Y+2	; 0x02
    16be:	9b 81       	ldd	r25, Y+3	; 0x03
    16c0:	28 0f       	add	r18, r24
    16c2:	39 1f       	adc	r19, r25
    16c4:	3f 83       	std	Y+7, r19	; 0x07
    16c6:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    16c8:	12 30       	cpi	r17, 0x02	; 2
    16ca:	61 f4       	brne	.+24     	; 0x16e4 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    16cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16ce:	88 23       	and	r24, r24
    16d0:	59 f0       	breq	.+22     	; 0x16e8 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    16d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    16d4:	81 50       	subi	r24, 0x01	; 1
    16d6:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	07 c0       	rjmp	.+14     	; 0x16ea <prvCopyDataToQueue+0xb6>
    16dc:	80 e0       	ldi	r24, 0x00	; 0
    16de:	05 c0       	rjmp	.+10     	; 0x16ea <prvCopyDataToQueue+0xb6>
    16e0:	80 e0       	ldi	r24, 0x00	; 0
    16e2:	03 c0       	rjmp	.+6      	; 0x16ea <prvCopyDataToQueue+0xb6>
    16e4:	80 e0       	ldi	r24, 0x00	; 0
    16e6:	01 c0       	rjmp	.+2      	; 0x16ea <prvCopyDataToQueue+0xb6>
    16e8:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    16ec:	9f 5f       	subi	r25, 0xFF	; 255
    16ee:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	1f 91       	pop	r17
    16f6:	08 95       	ret

000016f8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    16f8:	fc 01       	movw	r30, r24
    16fa:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    16fc:	44 8d       	ldd	r20, Z+28	; 0x1c
    16fe:	44 23       	and	r20, r20
    1700:	a1 f0       	breq	.+40     	; 0x172a <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	26 81       	ldd	r18, Z+6	; 0x06
    1706:	37 81       	ldd	r19, Z+7	; 0x07
    1708:	24 0f       	add	r18, r20
    170a:	35 1f       	adc	r19, r21
    170c:	37 83       	std	Z+7, r19	; 0x07
    170e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1710:	62 81       	ldd	r22, Z+2	; 0x02
    1712:	73 81       	ldd	r23, Z+3	; 0x03
    1714:	26 17       	cp	r18, r22
    1716:	37 07       	cpc	r19, r23
    1718:	20 f0       	brcs	.+8      	; 0x1722 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    171a:	20 81       	ld	r18, Z
    171c:	31 81       	ldd	r19, Z+1	; 0x01
    171e:	37 83       	std	Z+7, r19	; 0x07
    1720:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1722:	66 81       	ldd	r22, Z+6	; 0x06
    1724:	77 81       	ldd	r23, Z+7	; 0x07
    1726:	0c 94 37 17 	jmp	0x2e6e	; 0x2e6e <memcpy>
    172a:	08 95       	ret

0000172c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    172c:	0f 93       	push	r16
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    173c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    173e:	18 16       	cp	r1, r24
    1740:	a4 f4       	brge	.+40     	; 0x176a <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1742:	89 89       	ldd	r24, Y+17	; 0x11
    1744:	88 23       	and	r24, r24
    1746:	89 f0       	breq	.+34     	; 0x176a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1748:	8e 01       	movw	r16, r28
    174a:	0f 5e       	subi	r16, 0xEF	; 239
    174c:	1f 4f       	sbci	r17, 0xFF	; 255
    174e:	03 c0       	rjmp	.+6      	; 0x1756 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1750:	89 89       	ldd	r24, Y+17	; 0x11
    1752:	88 23       	and	r24, r24
    1754:	51 f0       	breq	.+20     	; 0x176a <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1756:	c8 01       	movw	r24, r16
    1758:	d1 d6       	rcall	.+3490   	; 0x24fc <xTaskRemoveFromEventList>
    175a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    175c:	5a d7       	rcall	.+3764   	; 0x2612 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    175e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1760:	81 50       	subi	r24, 0x01	; 1
    1762:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1764:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1766:	18 16       	cp	r1, r24
    1768:	9c f3       	brlt	.-26     	; 0x1750 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    176a:	8f ef       	ldi	r24, 0xFF	; 255
    176c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1772:	0f b6       	in	r0, 0x3f	; 63
    1774:	f8 94       	cli
    1776:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1778:	8d 8d       	ldd	r24, Y+29	; 0x1d
    177a:	18 16       	cp	r1, r24
    177c:	a4 f4       	brge	.+40     	; 0x17a6 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    177e:	88 85       	ldd	r24, Y+8	; 0x08
    1780:	88 23       	and	r24, r24
    1782:	89 f0       	breq	.+34     	; 0x17a6 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1784:	8e 01       	movw	r16, r28
    1786:	08 5f       	subi	r16, 0xF8	; 248
    1788:	1f 4f       	sbci	r17, 0xFF	; 255
    178a:	03 c0       	rjmp	.+6      	; 0x1792 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    178c:	88 85       	ldd	r24, Y+8	; 0x08
    178e:	88 23       	and	r24, r24
    1790:	51 f0       	breq	.+20     	; 0x17a6 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1792:	c8 01       	movw	r24, r16
    1794:	b3 d6       	rcall	.+3430   	; 0x24fc <xTaskRemoveFromEventList>
    1796:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    1798:	3c d7       	rcall	.+3704   	; 0x2612 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    179a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    179c:	81 50       	subi	r24, 0x01	; 1
    179e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    17a2:	18 16       	cp	r1, r24
    17a4:	9c f3       	brlt	.-26     	; 0x178c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
}
    17ae:	df 91       	pop	r29
    17b0:	cf 91       	pop	r28
    17b2:	1f 91       	pop	r17
    17b4:	0f 91       	pop	r16
    17b6:	08 95       	ret

000017b8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    17b8:	cf 93       	push	r28
    17ba:	df 93       	push	r29
    17bc:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    17be:	0f b6       	in	r0, 0x3f	; 63
    17c0:	f8 94       	cli
    17c2:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    17c4:	88 81       	ld	r24, Y
    17c6:	99 81       	ldd	r25, Y+1	; 0x01
    17c8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17ca:	30 e0       	ldi	r19, 0x00	; 0
    17cc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    17ce:	72 9f       	mul	r23, r18
    17d0:	a0 01       	movw	r20, r0
    17d2:	73 9f       	mul	r23, r19
    17d4:	50 0d       	add	r21, r0
    17d6:	11 24       	eor	r1, r1
    17d8:	fc 01       	movw	r30, r24
    17da:	e4 0f       	add	r30, r20
    17dc:	f5 1f       	adc	r31, r21
    17de:	fb 83       	std	Y+3, r31	; 0x03
    17e0:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    17e2:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    17e4:	9d 83       	std	Y+5, r25	; 0x05
    17e6:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    17e8:	42 1b       	sub	r20, r18
    17ea:	53 0b       	sbc	r21, r19
    17ec:	84 0f       	add	r24, r20
    17ee:	95 1f       	adc	r25, r21
    17f0:	9f 83       	std	Y+7, r25	; 0x07
    17f2:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    17f4:	8f ef       	ldi	r24, 0xFF	; 255
    17f6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    17f8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    17fa:	61 11       	cpse	r22, r1
    17fc:	0a c0       	rjmp	.+20     	; 0x1812 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17fe:	88 85       	ldd	r24, Y+8	; 0x08
    1800:	88 23       	and	r24, r24
    1802:	79 f0       	breq	.+30     	; 0x1822 <xQueueGenericReset+0x6a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1804:	ce 01       	movw	r24, r28
    1806:	08 96       	adiw	r24, 0x08	; 8
    1808:	79 d6       	rcall	.+3314   	; 0x24fc <xTaskRemoveFromEventList>
    180a:	81 30       	cpi	r24, 0x01	; 1
    180c:	51 f4       	brne	.+20     	; 0x1822 <xQueueGenericReset+0x6a>
				{
					queueYIELD_IF_USING_PREEMPTION();
    180e:	4e de       	rcall	.-868    	; 0x14ac <vPortYield>
    1810:	08 c0       	rjmp	.+16     	; 0x1822 <xQueueGenericReset+0x6a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1812:	ce 01       	movw	r24, r28
    1814:	08 96       	adiw	r24, 0x08	; 8
    1816:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    181a:	ce 01       	movw	r24, r28
    181c:	41 96       	adiw	r24, 0x11	; 17
    181e:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	df 91       	pop	r29
    182a:	cf 91       	pop	r28
    182c:	08 95       	ret

0000182e <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    182e:	0f 93       	push	r16
    1830:	1f 93       	push	r17
    1832:	cf 93       	push	r28
    1834:	df 93       	push	r29
    1836:	18 2f       	mov	r17, r24
    1838:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    183a:	88 23       	and	r24, r24
    183c:	e9 f0       	breq	.+58     	; 0x1878 <xQueueGenericCreate+0x4a>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    183e:	8f e1       	ldi	r24, 0x1F	; 31
    1840:	90 e0       	ldi	r25, 0x00	; 0
    1842:	0e 94 31 03 	call	0x662	; 0x662 <pvPortMalloc>
    1846:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1848:	00 97       	sbiw	r24, 0x00	; 0
    184a:	c1 f0       	breq	.+48     	; 0x187c <xQueueGenericCreate+0x4e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    184c:	10 9f       	mul	r17, r16
    184e:	c0 01       	movw	r24, r0
    1850:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    1852:	01 96       	adiw	r24, 0x01	; 1
    1854:	0e 94 31 03 	call	0x662	; 0x662 <pvPortMalloc>
    1858:	99 83       	std	Y+1, r25	; 0x01
    185a:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    185c:	89 2b       	or	r24, r25
    185e:	31 f0       	breq	.+12     	; 0x186c <xQueueGenericCreate+0x3e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1860:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1862:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1864:	61 e0       	ldi	r22, 0x01	; 1
    1866:	ce 01       	movw	r24, r28
    1868:	a7 df       	rcall	.-178    	; 0x17b8 <xQueueGenericReset>
    186a:	08 c0       	rjmp	.+16     	; 0x187c <xQueueGenericCreate+0x4e>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    186c:	ce 01       	movw	r24, r28
    186e:	0e 94 66 03 	call	0x6cc	; 0x6cc <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    1872:	c0 e0       	ldi	r28, 0x00	; 0
    1874:	d0 e0       	ldi	r29, 0x00	; 0
    1876:	02 c0       	rjmp	.+4      	; 0x187c <xQueueGenericCreate+0x4e>
    1878:	c0 e0       	ldi	r28, 0x00	; 0
    187a:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    187c:	ce 01       	movw	r24, r28
    187e:	df 91       	pop	r29
    1880:	cf 91       	pop	r28
    1882:	1f 91       	pop	r17
    1884:	0f 91       	pop	r16
    1886:	08 95       	ret

00001888 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1888:	9f 92       	push	r9
    188a:	af 92       	push	r10
    188c:	bf 92       	push	r11
    188e:	cf 92       	push	r12
    1890:	df 92       	push	r13
    1892:	ef 92       	push	r14
    1894:	ff 92       	push	r15
    1896:	0f 93       	push	r16
    1898:	1f 93       	push	r17
    189a:	cf 93       	push	r28
    189c:	df 93       	push	r29
    189e:	00 d0       	rcall	.+0      	; 0x18a0 <xQueueGenericSend+0x18>
    18a0:	1f 92       	push	r1
    18a2:	1f 92       	push	r1
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
    18a8:	8c 01       	movw	r16, r24
    18aa:	6b 01       	movw	r12, r22
    18ac:	5d 83       	std	Y+5, r21	; 0x05
    18ae:	4c 83       	std	Y+4, r20	; 0x04
    18b0:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    18b2:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    18b4:	99 24       	eor	r9, r9
    18b6:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    18b8:	7c 01       	movw	r14, r24
    18ba:	88 e0       	ldi	r24, 0x08	; 8
    18bc:	e8 0e       	add	r14, r24
    18be:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18c0:	0f b6       	in	r0, 0x3f	; 63
    18c2:	f8 94       	cli
    18c4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18c6:	f8 01       	movw	r30, r16
    18c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18ca:	83 8d       	ldd	r24, Z+27	; 0x1b
    18cc:	98 17       	cp	r25, r24
    18ce:	18 f0       	brcs	.+6      	; 0x18d6 <xQueueGenericSend+0x4e>
    18d0:	f2 e0       	ldi	r31, 0x02	; 2
    18d2:	af 12       	cpse	r10, r31
    18d4:	15 c0       	rjmp	.+42     	; 0x1900 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18d6:	4a 2d       	mov	r20, r10
    18d8:	b6 01       	movw	r22, r12
    18da:	c8 01       	movw	r24, r16
    18dc:	ab de       	rcall	.-682    	; 0x1634 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18de:	f8 01       	movw	r30, r16
    18e0:	91 89       	ldd	r25, Z+17	; 0x11
    18e2:	99 23       	and	r25, r25
    18e4:	39 f0       	breq	.+14     	; 0x18f4 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    18e6:	c8 01       	movw	r24, r16
    18e8:	41 96       	adiw	r24, 0x11	; 17
    18ea:	08 d6       	rcall	.+3088   	; 0x24fc <xTaskRemoveFromEventList>
    18ec:	81 30       	cpi	r24, 0x01	; 1
    18ee:	21 f4       	brne	.+8      	; 0x18f8 <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    18f0:	dd dd       	rcall	.-1094   	; 0x14ac <vPortYield>
    18f2:	02 c0       	rjmp	.+4      	; 0x18f8 <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    18f4:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    18f6:	da dd       	rcall	.-1100   	; 0x14ac <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	46 c0       	rjmp	.+140    	; 0x198c <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1900:	ec 81       	ldd	r30, Y+4	; 0x04
    1902:	fd 81       	ldd	r31, Y+5	; 0x05
    1904:	ef 2b       	or	r30, r31
    1906:	21 f4       	brne	.+8      	; 0x1910 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1908:	0f 90       	pop	r0
    190a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    190c:	80 e0       	ldi	r24, 0x00	; 0
    190e:	3e c0       	rjmp	.+124    	; 0x198c <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1910:	b1 10       	cpse	r11, r1
    1912:	04 c0       	rjmp	.+8      	; 0x191c <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1914:	ce 01       	movw	r24, r28
    1916:	01 96       	adiw	r24, 0x01	; 1
    1918:	39 d6       	rcall	.+3186   	; 0x258c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    191a:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1920:	31 d3       	rcall	.+1634   	; 0x1f84 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1922:	0f b6       	in	r0, 0x3f	; 63
    1924:	f8 94       	cli
    1926:	0f 92       	push	r0
    1928:	f8 01       	movw	r30, r16
    192a:	85 8d       	ldd	r24, Z+29	; 0x1d
    192c:	8f 3f       	cpi	r24, 0xFF	; 255
    192e:	09 f4       	brne	.+2      	; 0x1932 <xQueueGenericSend+0xaa>
    1930:	15 8e       	std	Z+29, r1	; 0x1d
    1932:	f8 01       	movw	r30, r16
    1934:	86 8d       	ldd	r24, Z+30	; 0x1e
    1936:	8f 3f       	cpi	r24, 0xFF	; 255
    1938:	09 f4       	brne	.+2      	; 0x193c <xQueueGenericSend+0xb4>
    193a:	16 8e       	std	Z+30, r1	; 0x1e
    193c:	0f 90       	pop	r0
    193e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1940:	be 01       	movw	r22, r28
    1942:	6c 5f       	subi	r22, 0xFC	; 252
    1944:	7f 4f       	sbci	r23, 0xFF	; 255
    1946:	ce 01       	movw	r24, r28
    1948:	01 96       	adiw	r24, 0x01	; 1
    194a:	2b d6       	rcall	.+3158   	; 0x25a2 <xTaskCheckForTimeOut>
    194c:	81 11       	cpse	r24, r1
    194e:	1a c0       	rjmp	.+52     	; 0x1984 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1956:	f8 01       	movw	r30, r16
    1958:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    195a:	0f 90       	pop	r0
    195c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    195e:	f8 01       	movw	r30, r16
    1960:	83 8d       	ldd	r24, Z+27	; 0x1b
    1962:	98 13       	cpse	r25, r24
    1964:	0b c0       	rjmp	.+22     	; 0x197c <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1966:	6c 81       	ldd	r22, Y+4	; 0x04
    1968:	7d 81       	ldd	r23, Y+5	; 0x05
    196a:	c7 01       	movw	r24, r14
    196c:	9c d5       	rcall	.+2872   	; 0x24a6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    196e:	c8 01       	movw	r24, r16
    1970:	dd de       	rcall	.-582    	; 0x172c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1972:	db d3       	rcall	.+1974   	; 0x212a <xTaskResumeAll>
    1974:	81 11       	cpse	r24, r1
    1976:	a4 cf       	rjmp	.-184    	; 0x18c0 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    1978:	99 dd       	rcall	.-1230   	; 0x14ac <vPortYield>
    197a:	a2 cf       	rjmp	.-188    	; 0x18c0 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    197c:	c8 01       	movw	r24, r16
    197e:	d6 de       	rcall	.-596    	; 0x172c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1980:	d4 d3       	rcall	.+1960   	; 0x212a <xTaskResumeAll>
    1982:	9e cf       	rjmp	.-196    	; 0x18c0 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1984:	c8 01       	movw	r24, r16
    1986:	d2 de       	rcall	.-604    	; 0x172c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1988:	d0 d3       	rcall	.+1952   	; 0x212a <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    198a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    198c:	0f 90       	pop	r0
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	1f 91       	pop	r17
    199c:	0f 91       	pop	r16
    199e:	ff 90       	pop	r15
    19a0:	ef 90       	pop	r14
    19a2:	df 90       	pop	r13
    19a4:	cf 90       	pop	r12
    19a6:	bf 90       	pop	r11
    19a8:	af 90       	pop	r10
    19aa:	9f 90       	pop	r9
    19ac:	08 95       	ret

000019ae <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    19ae:	cf 93       	push	r28
    19b0:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    19b2:	8f e1       	ldi	r24, 0x1F	; 31
    19b4:	90 e0       	ldi	r25, 0x00	; 0
    19b6:	0e 94 31 03 	call	0x662	; 0x662 <pvPortMalloc>
    19ba:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    19bc:	00 97       	sbiw	r24, 0x00	; 0
    19be:	f1 f0       	breq	.+60     	; 0x19fc <xQueueCreateMutex+0x4e>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    19c0:	1b 82       	std	Y+3, r1	; 0x03
    19c2:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    19c4:	19 82       	std	Y+1, r1	; 0x01
    19c6:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    19c8:	1d 82       	std	Y+5, r1	; 0x05
    19ca:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    19cc:	1f 82       	std	Y+7, r1	; 0x07
    19ce:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    19d0:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    19d2:	81 e0       	ldi	r24, 0x01	; 1
    19d4:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    19d6:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    19d8:	8f ef       	ldi	r24, 0xFF	; 255
    19da:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    19dc:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    19de:	ce 01       	movw	r24, r28
    19e0:	08 96       	adiw	r24, 0x08	; 8
    19e2:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    19e6:	ce 01       	movw	r24, r28
    19e8:	41 96       	adiw	r24, 0x11	; 17
    19ea:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    19ee:	20 e0       	ldi	r18, 0x00	; 0
    19f0:	40 e0       	ldi	r20, 0x00	; 0
    19f2:	50 e0       	ldi	r21, 0x00	; 0
    19f4:	60 e0       	ldi	r22, 0x00	; 0
    19f6:	70 e0       	ldi	r23, 0x00	; 0
    19f8:	ce 01       	movw	r24, r28
    19fa:	46 df       	rcall	.-372    	; 0x1888 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    19fc:	ce 01       	movw	r24, r28
    19fe:	df 91       	pop	r29
    1a00:	cf 91       	pop	r28
    1a02:	08 95       	ret

00001a04 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1a04:	0f 93       	push	r16
    1a06:	1f 93       	push	r17
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	ec 01       	movw	r28, r24
    1a0e:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a10:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a12:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a14:	98 17       	cp	r25, r24
    1a16:	10 f0       	brcs	.+4      	; 0x1a1c <xQueueGenericSendFromISR+0x18>
    1a18:	22 30       	cpi	r18, 0x02	; 2
    1a1a:	11 f5       	brne	.+68     	; 0x1a60 <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    1a1c:	42 2f       	mov	r20, r18
    1a1e:	ce 01       	movw	r24, r28
    1a20:	09 de       	rcall	.-1006   	; 0x1634 <prvCopyDataToQueue>
    1a22:	88 23       	and	r24, r24
    1a24:	31 f0       	breq	.+12     	; 0x1a32 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1a26:	01 15       	cp	r16, r1
    1a28:	11 05       	cpc	r17, r1
    1a2a:	19 f0       	breq	.+6      	; 0x1a32 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    1a2c:	81 e0       	ldi	r24, 0x01	; 1
    1a2e:	f8 01       	movw	r30, r16
    1a30:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1a32:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a34:	8f 3f       	cpi	r24, 0xFF	; 255
    1a36:	79 f4       	brne	.+30     	; 0x1a56 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a38:	89 89       	ldd	r24, Y+17	; 0x11
    1a3a:	88 23       	and	r24, r24
    1a3c:	99 f0       	breq	.+38     	; 0x1a64 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a3e:	ce 01       	movw	r24, r28
    1a40:	41 96       	adiw	r24, 0x11	; 17
    1a42:	5c d5       	rcall	.+2744   	; 0x24fc <xTaskRemoveFromEventList>
    1a44:	88 23       	and	r24, r24
    1a46:	81 f0       	breq	.+32     	; 0x1a68 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1a48:	01 15       	cp	r16, r1
    1a4a:	11 05       	cpc	r17, r1
    1a4c:	79 f0       	breq	.+30     	; 0x1a6c <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	f8 01       	movw	r30, r16
    1a52:	80 83       	st	Z, r24
    1a54:	0c c0       	rjmp	.+24     	; 0x1a6e <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a56:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a58:	8f 5f       	subi	r24, 0xFF	; 255
    1a5a:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	07 c0       	rjmp	.+14     	; 0x1a6e <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    1a62:	05 c0       	rjmp	.+10     	; 0x1a6e <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	03 c0       	rjmp	.+6      	; 0x1a6e <xQueueGenericSendFromISR+0x6a>
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	01 c0       	rjmp	.+2      	; 0x1a6e <xQueueGenericSendFromISR+0x6a>
    1a6c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a6e:	df 91       	pop	r29
    1a70:	cf 91       	pop	r28
    1a72:	1f 91       	pop	r17
    1a74:	0f 91       	pop	r16
    1a76:	08 95       	ret

00001a78 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1a78:	9f 92       	push	r9
    1a7a:	af 92       	push	r10
    1a7c:	bf 92       	push	r11
    1a7e:	cf 92       	push	r12
    1a80:	df 92       	push	r13
    1a82:	ef 92       	push	r14
    1a84:	ff 92       	push	r15
    1a86:	0f 93       	push	r16
    1a88:	1f 93       	push	r17
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	00 d0       	rcall	.+0      	; 0x1a90 <xQueueGenericReceive+0x18>
    1a90:	1f 92       	push	r1
    1a92:	1f 92       	push	r1
    1a94:	cd b7       	in	r28, 0x3d	; 61
    1a96:	de b7       	in	r29, 0x3e	; 62
    1a98:	8c 01       	movw	r16, r24
    1a9a:	6b 01       	movw	r12, r22
    1a9c:	5d 83       	std	Y+5, r21	; 0x05
    1a9e:	4c 83       	std	Y+4, r20	; 0x04
    1aa0:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1aa2:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1aa4:	99 24       	eor	r9, r9
    1aa6:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1aa8:	7c 01       	movw	r14, r24
    1aaa:	81 e1       	ldi	r24, 0x11	; 17
    1aac:	e8 0e       	add	r14, r24
    1aae:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ab0:	0f b6       	in	r0, 0x3f	; 63
    1ab2:	f8 94       	cli
    1ab4:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aba:	88 23       	and	r24, r24
    1abc:	69 f1       	breq	.+90     	; 0x1b18 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1abe:	e6 80       	ldd	r14, Z+6	; 0x06
    1ac0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ac2:	b6 01       	movw	r22, r12
    1ac4:	c8 01       	movw	r24, r16
    1ac6:	18 de       	rcall	.-976    	; 0x16f8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ac8:	b1 10       	cpse	r11, r1
    1aca:	17 c0       	rjmp	.+46     	; 0x1afa <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1acc:	f8 01       	movw	r30, r16
    1ace:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ad0:	81 50       	subi	r24, 0x01	; 1
    1ad2:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ad4:	80 81       	ld	r24, Z
    1ad6:	91 81       	ldd	r25, Z+1	; 0x01
    1ad8:	89 2b       	or	r24, r25
    1ada:	21 f4       	brne	.+8      	; 0x1ae4 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1adc:	3b d6       	rcall	.+3190   	; 0x2754 <pvTaskIncrementMutexHeldCount>
    1ade:	f8 01       	movw	r30, r16
    1ae0:	93 83       	std	Z+3, r25	; 0x03
    1ae2:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ae4:	f8 01       	movw	r30, r16
    1ae6:	80 85       	ldd	r24, Z+8	; 0x08
    1ae8:	88 23       	and	r24, r24
    1aea:	91 f0       	breq	.+36     	; 0x1b10 <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1aec:	c8 01       	movw	r24, r16
    1aee:	08 96       	adiw	r24, 0x08	; 8
    1af0:	05 d5       	rcall	.+2570   	; 0x24fc <xTaskRemoveFromEventList>
    1af2:	81 30       	cpi	r24, 0x01	; 1
    1af4:	69 f4       	brne	.+26     	; 0x1b10 <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1af6:	da dc       	rcall	.-1612   	; 0x14ac <vPortYield>
    1af8:	0b c0       	rjmp	.+22     	; 0x1b10 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1afa:	f8 01       	movw	r30, r16
    1afc:	f7 82       	std	Z+7, r15	; 0x07
    1afe:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b00:	81 89       	ldd	r24, Z+17	; 0x11
    1b02:	88 23       	and	r24, r24
    1b04:	29 f0       	breq	.+10     	; 0x1b10 <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b06:	c8 01       	movw	r24, r16
    1b08:	41 96       	adiw	r24, 0x11	; 17
    1b0a:	f8 d4       	rcall	.+2544   	; 0x24fc <xTaskRemoveFromEventList>
    1b0c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1b0e:	ce dc       	rcall	.-1636   	; 0x14ac <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	52 c0       	rjmp	.+164    	; 0x1bbc <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1b18:	4c 81       	ldd	r20, Y+4	; 0x04
    1b1a:	5d 81       	ldd	r21, Y+5	; 0x05
    1b1c:	45 2b       	or	r20, r21
    1b1e:	21 f4       	brne	.+8      	; 0x1b28 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1b24:	80 e0       	ldi	r24, 0x00	; 0
    1b26:	4a c0       	rjmp	.+148    	; 0x1bbc <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1b28:	a1 10       	cpse	r10, r1
    1b2a:	04 c0       	rjmp	.+8      	; 0x1b34 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	01 96       	adiw	r24, 0x01	; 1
    1b30:	2d d5       	rcall	.+2650   	; 0x258c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1b32:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1b34:	0f 90       	pop	r0
    1b36:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1b38:	25 d2       	rcall	.+1098   	; 0x1f84 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
    1b40:	f8 01       	movw	r30, r16
    1b42:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b44:	8f 3f       	cpi	r24, 0xFF	; 255
    1b46:	09 f4       	brne	.+2      	; 0x1b4a <xQueueGenericReceive+0xd2>
    1b48:	15 8e       	std	Z+29, r1	; 0x1d
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <xQueueGenericReceive+0xdc>
    1b52:	16 8e       	std	Z+30, r1	; 0x1e
    1b54:	0f 90       	pop	r0
    1b56:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b58:	be 01       	movw	r22, r28
    1b5a:	6c 5f       	subi	r22, 0xFC	; 252
    1b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5e:	ce 01       	movw	r24, r28
    1b60:	01 96       	adiw	r24, 0x01	; 1
    1b62:	1f d5       	rcall	.+2622   	; 0x25a2 <xTaskCheckForTimeOut>
    1b64:	81 11       	cpse	r24, r1
    1b66:	26 c0       	rjmp	.+76     	; 0x1bb4 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b68:	0f b6       	in	r0, 0x3f	; 63
    1b6a:	f8 94       	cli
    1b6c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1b6e:	f8 01       	movw	r30, r16
    1b70:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b72:	0f 90       	pop	r0
    1b74:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b76:	81 11       	cpse	r24, r1
    1b78:	19 c0       	rjmp	.+50     	; 0x1bac <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b7a:	f8 01       	movw	r30, r16
    1b7c:	80 81       	ld	r24, Z
    1b7e:	91 81       	ldd	r25, Z+1	; 0x01
    1b80:	89 2b       	or	r24, r25
    1b82:	49 f4       	brne	.+18     	; 0x1b96 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	f8 94       	cli
    1b88:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	82 81       	ldd	r24, Z+2	; 0x02
    1b8e:	93 81       	ldd	r25, Z+3	; 0x03
    1b90:	44 d5       	rcall	.+2696   	; 0x261a <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1b92:	0f 90       	pop	r0
    1b94:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b96:	6c 81       	ldd	r22, Y+4	; 0x04
    1b98:	7d 81       	ldd	r23, Y+5	; 0x05
    1b9a:	c7 01       	movw	r24, r14
    1b9c:	84 d4       	rcall	.+2312   	; 0x24a6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b9e:	c8 01       	movw	r24, r16
    1ba0:	c5 dd       	rcall	.-1142   	; 0x172c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ba2:	c3 d2       	rcall	.+1414   	; 0x212a <xTaskResumeAll>
    1ba4:	81 11       	cpse	r24, r1
    1ba6:	84 cf       	rjmp	.-248    	; 0x1ab0 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    1ba8:	81 dc       	rcall	.-1790   	; 0x14ac <vPortYield>
    1baa:	82 cf       	rjmp	.-252    	; 0x1ab0 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1bac:	c8 01       	movw	r24, r16
    1bae:	be dd       	rcall	.-1156   	; 0x172c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1bb0:	bc d2       	rcall	.+1400   	; 0x212a <xTaskResumeAll>
    1bb2:	7e cf       	rjmp	.-260    	; 0x1ab0 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	ba dd       	rcall	.-1164   	; 0x172c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1bb8:	b8 d2       	rcall	.+1392   	; 0x212a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1bba:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	0f 90       	pop	r0
    1bc2:	0f 90       	pop	r0
    1bc4:	0f 90       	pop	r0
    1bc6:	df 91       	pop	r29
    1bc8:	cf 91       	pop	r28
    1bca:	1f 91       	pop	r17
    1bcc:	0f 91       	pop	r16
    1bce:	ff 90       	pop	r15
    1bd0:	ef 90       	pop	r14
    1bd2:	df 90       	pop	r13
    1bd4:	cf 90       	pop	r12
    1bd6:	bf 90       	pop	r11
    1bd8:	af 90       	pop	r10
    1bda:	9f 90       	pop	r9
    1bdc:	08 95       	ret

00001bde <ringBufferInit>:
}

unsigned char ringBufferPeek(ringBuffer *ring)
{
	   return ring->rBuffer[ ring->rIndex ];	
}
    1bde:	fc 01       	movw	r30, r24
    1be0:	71 83       	std	Z+1, r23	; 0x01
    1be2:	60 83       	st	Z, r22
    1be4:	42 83       	std	Z+2, r20	; 0x02
    1be6:	14 82       	std	Z+4, r1	; 0x04
    1be8:	13 82       	std	Z+3, r1	; 0x03
    1bea:	08 95       	ret

00001bec <ringBufferPop>:

// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    1bec:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    1bee:	94 81       	ldd	r25, Z+4	; 0x04
    1bf0:	a0 81       	ld	r26, Z
    1bf2:	b1 81       	ldd	r27, Z+1	; 0x01
    1bf4:	a9 0f       	add	r26, r25
    1bf6:	b1 1d       	adc	r27, r1
    1bf8:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1bfa:	9f 5f       	subi	r25, 0xFF	; 255
    1bfc:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    1bfe:	22 81       	ldd	r18, Z+2	; 0x02
    1c00:	92 17       	cp	r25, r18
    1c02:	10 f0       	brcs	.+4      	; 0x1c08 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1c04:	92 1b       	sub	r25, r18
    1c06:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1c08:	93 81       	ldd	r25, Z+3	; 0x03
    1c0a:	91 50       	subi	r25, 0x01	; 1
    1c0c:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    1c0e:	08 95       	ret

00001c10 <ringBufferPush>:



void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    1c10:	fc 01       	movw	r30, r24
    1c12:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1c14:	83 81       	ldd	r24, Z+3	; 0x03
    1c16:	22 81       	ldd	r18, Z+2	; 0x02
    1c18:	82 17       	cp	r24, r18
    1c1a:	80 f4       	brcc	.+32     	; 0x1c3c <ringBufferPush+0x2c>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    1c1c:	34 81       	ldd	r19, Z+4	; 0x04
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	83 0f       	add	r24, r19
    1c22:	91 1d       	adc	r25, r1
    1c24:	62 2f       	mov	r22, r18
    1c26:	70 e0       	ldi	r23, 0x00	; 0
    1c28:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__divmodhi4>
    1c2c:	a0 81       	ld	r26, Z
    1c2e:	b1 81       	ldd	r27, Z+1	; 0x01
    1c30:	a8 0f       	add	r26, r24
    1c32:	b9 1f       	adc	r27, r25
    1c34:	4c 93       	st	X, r20
            ring->rLength++;
    1c36:	83 81       	ldd	r24, Z+3	; 0x03
    1c38:	8f 5f       	subi	r24, 0xFF	; 255
    1c3a:	83 83       	std	Z+3, r24	; 0x03
    1c3c:	08 95       	ret

00001c3e <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    1c3e:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    1c40:	81 e0       	ldi	r24, 0x01	; 1
    1c42:	22 81       	ldd	r18, Z+2	; 0x02
    1c44:	93 81       	ldd	r25, Z+3	; 0x03
    1c46:	29 13       	cpse	r18, r25
    1c48:	80 e0       	ldi	r24, 0x00	; 0
}
    1c4a:	08 95       	ret

00001c4c <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1c4c:	21 e0       	ldi	r18, 0x01	; 1
    1c4e:	fc 01       	movw	r30, r24
    1c50:	83 81       	ldd	r24, Z+3	; 0x03
    1c52:	81 11       	cpse	r24, r1
    1c54:	01 c0       	rjmp	.+2      	; 0x1c58 <ringBufferNotEmpty+0xc>
    1c56:	20 e0       	ldi	r18, 0x00	; 0
}
    1c58:	82 2f       	mov	r24, r18
    1c5a:	08 95       	ret

00001c5c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1c5c:	e0 91 49 08 	lds	r30, 0x0849
    1c60:	f0 91 4a 08 	lds	r31, 0x084A
    1c64:	80 81       	ld	r24, Z
    1c66:	81 11       	cpse	r24, r1
    1c68:	07 c0       	rjmp	.+14     	; 0x1c78 <prvResetNextTaskUnblockTime+0x1c>
    1c6a:	8f ef       	ldi	r24, 0xFF	; 255
    1c6c:	9f ef       	ldi	r25, 0xFF	; 255
    1c6e:	90 93 06 02 	sts	0x0206, r25
    1c72:	80 93 05 02 	sts	0x0205, r24
    1c76:	08 95       	ret
    1c78:	e0 91 49 08 	lds	r30, 0x0849
    1c7c:	f0 91 4a 08 	lds	r31, 0x084A
    1c80:	05 80       	ldd	r0, Z+5	; 0x05
    1c82:	f6 81       	ldd	r31, Z+6	; 0x06
    1c84:	e0 2d       	mov	r30, r0
    1c86:	06 80       	ldd	r0, Z+6	; 0x06
    1c88:	f7 81       	ldd	r31, Z+7	; 0x07
    1c8a:	e0 2d       	mov	r30, r0
    1c8c:	82 81       	ldd	r24, Z+2	; 0x02
    1c8e:	93 81       	ldd	r25, Z+3	; 0x03
    1c90:	90 93 06 02 	sts	0x0206, r25
    1c94:	80 93 05 02 	sts	0x0205, r24
    1c98:	08 95       	ret

00001c9a <prvAddCurrentTaskToDelayedList>:
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	ec 01       	movw	r28, r24
    1ca0:	e0 91 8a 08 	lds	r30, 0x088A
    1ca4:	f0 91 8b 08 	lds	r31, 0x088B
    1ca8:	93 83       	std	Z+3, r25	; 0x03
    1caa:	82 83       	std	Z+2, r24	; 0x02
    1cac:	80 91 28 08 	lds	r24, 0x0828
    1cb0:	90 91 29 08 	lds	r25, 0x0829
    1cb4:	c8 17       	cp	r28, r24
    1cb6:	d9 07       	cpc	r29, r25
    1cb8:	68 f4       	brcc	.+26     	; 0x1cd4 <prvAddCurrentTaskToDelayedList+0x3a>
    1cba:	60 91 8a 08 	lds	r22, 0x088A
    1cbe:	70 91 8b 08 	lds	r23, 0x088B
    1cc2:	80 91 47 08 	lds	r24, 0x0847
    1cc6:	90 91 48 08 	lds	r25, 0x0848
    1cca:	6e 5f       	subi	r22, 0xFE	; 254
    1ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    1cce:	0e 94 9a 03 	call	0x734	; 0x734 <vListInsert>
    1cd2:	17 c0       	rjmp	.+46     	; 0x1d02 <prvAddCurrentTaskToDelayedList+0x68>
    1cd4:	60 91 8a 08 	lds	r22, 0x088A
    1cd8:	70 91 8b 08 	lds	r23, 0x088B
    1cdc:	80 91 49 08 	lds	r24, 0x0849
    1ce0:	90 91 4a 08 	lds	r25, 0x084A
    1ce4:	6e 5f       	subi	r22, 0xFE	; 254
    1ce6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ce8:	0e 94 9a 03 	call	0x734	; 0x734 <vListInsert>
    1cec:	80 91 05 02 	lds	r24, 0x0205
    1cf0:	90 91 06 02 	lds	r25, 0x0206
    1cf4:	c8 17       	cp	r28, r24
    1cf6:	d9 07       	cpc	r29, r25
    1cf8:	20 f4       	brcc	.+8      	; 0x1d02 <prvAddCurrentTaskToDelayedList+0x68>
    1cfa:	d0 93 06 02 	sts	0x0206, r29
    1cfe:	c0 93 05 02 	sts	0x0205, r28
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	08 95       	ret

00001d08 <xTaskGenericCreate>:
    1d08:	4f 92       	push	r4
    1d0a:	5f 92       	push	r5
    1d0c:	6f 92       	push	r6
    1d0e:	7f 92       	push	r7
    1d10:	8f 92       	push	r8
    1d12:	9f 92       	push	r9
    1d14:	af 92       	push	r10
    1d16:	bf 92       	push	r11
    1d18:	cf 92       	push	r12
    1d1a:	df 92       	push	r13
    1d1c:	ef 92       	push	r14
    1d1e:	ff 92       	push	r15
    1d20:	0f 93       	push	r16
    1d22:	1f 93       	push	r17
    1d24:	cf 93       	push	r28
    1d26:	df 93       	push	r29
    1d28:	4c 01       	movw	r8, r24
    1d2a:	5b 01       	movw	r10, r22
    1d2c:	2a 01       	movw	r4, r20
    1d2e:	39 01       	movw	r6, r18
    1d30:	83 e2       	ldi	r24, 0x23	; 35
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	0e 94 31 03 	call	0x662	; 0x662 <pvPortMalloc>
    1d38:	ec 01       	movw	r28, r24
    1d3a:	00 97       	sbiw	r24, 0x00	; 0
    1d3c:	09 f4       	brne	.+2      	; 0x1d40 <xTaskGenericCreate+0x38>
    1d3e:	e7 c0       	rjmp	.+462    	; 0x1f0e <xTaskGenericCreate+0x206>
    1d40:	c1 14       	cp	r12, r1
    1d42:	d1 04       	cpc	r13, r1
    1d44:	09 f0       	breq	.+2      	; 0x1d48 <xTaskGenericCreate+0x40>
    1d46:	cc c0       	rjmp	.+408    	; 0x1ee0 <xTaskGenericCreate+0x1d8>
    1d48:	c2 01       	movw	r24, r4
    1d4a:	0e 94 31 03 	call	0x662	; 0x662 <pvPortMalloc>
    1d4e:	98 8f       	std	Y+24, r25	; 0x18
    1d50:	8f 8b       	std	Y+23, r24	; 0x17
    1d52:	89 2b       	or	r24, r25
    1d54:	09 f0       	breq	.+2      	; 0x1d58 <xTaskGenericCreate+0x50>
    1d56:	c6 c0       	rjmp	.+396    	; 0x1ee4 <xTaskGenericCreate+0x1dc>
    1d58:	ce 01       	movw	r24, r28
    1d5a:	0e 94 66 03 	call	0x6cc	; 0x6cc <vPortFree>
    1d5e:	d7 c0       	rjmp	.+430    	; 0x1f0e <xTaskGenericCreate+0x206>
    1d60:	cf 01       	movw	r24, r30
    1d62:	31 91       	ld	r19, Z+
    1d64:	da 01       	movw	r26, r20
    1d66:	3d 93       	st	X+, r19
    1d68:	ad 01       	movw	r20, r26
    1d6a:	dc 01       	movw	r26, r24
    1d6c:	8c 91       	ld	r24, X
    1d6e:	88 23       	and	r24, r24
    1d70:	11 f0       	breq	.+4      	; 0x1d76 <xTaskGenericCreate+0x6e>
    1d72:	21 50       	subi	r18, 0x01	; 1
    1d74:	a9 f7       	brne	.-22     	; 0x1d60 <xTaskGenericCreate+0x58>
    1d76:	18 a2       	std	Y+32, r1	; 0x20
    1d78:	10 2f       	mov	r17, r16
    1d7a:	05 30       	cpi	r16, 0x05	; 5
    1d7c:	08 f0       	brcs	.+2      	; 0x1d80 <xTaskGenericCreate+0x78>
    1d7e:	14 e0       	ldi	r17, 0x04	; 4
    1d80:	1e 8b       	std	Y+22, r17	; 0x16
    1d82:	19 a3       	std	Y+33, r17	; 0x21
    1d84:	1a a2       	std	Y+34, r1	; 0x22
    1d86:	5e 01       	movw	r10, r28
    1d88:	b2 e0       	ldi	r27, 0x02	; 2
    1d8a:	ab 0e       	add	r10, r27
    1d8c:	b1 1c       	adc	r11, r1
    1d8e:	c5 01       	movw	r24, r10
    1d90:	0e 94 75 03 	call	0x6ea	; 0x6ea <vListInitialiseItem>
    1d94:	ce 01       	movw	r24, r28
    1d96:	0c 96       	adiw	r24, 0x0c	; 12
    1d98:	0e 94 75 03 	call	0x6ea	; 0x6ea <vListInitialiseItem>
    1d9c:	d9 87       	std	Y+9, r29	; 0x09
    1d9e:	c8 87       	std	Y+8, r28	; 0x08
    1da0:	85 e0       	ldi	r24, 0x05	; 5
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	81 1b       	sub	r24, r17
    1da6:	91 09       	sbc	r25, r1
    1da8:	9d 87       	std	Y+13, r25	; 0x0d
    1daa:	8c 87       	std	Y+12, r24	; 0x0c
    1dac:	db 8b       	std	Y+19, r29	; 0x13
    1dae:	ca 8b       	std	Y+18, r28	; 0x12
    1db0:	a3 01       	movw	r20, r6
    1db2:	b4 01       	movw	r22, r8
    1db4:	c6 01       	movw	r24, r12
    1db6:	cb da       	rcall	.-2666   	; 0x134e <pxPortInitialiseStack>
    1db8:	99 83       	std	Y+1, r25	; 0x01
    1dba:	88 83       	st	Y, r24
    1dbc:	e1 14       	cp	r14, r1
    1dbe:	f1 04       	cpc	r15, r1
    1dc0:	19 f0       	breq	.+6      	; 0x1dc8 <xTaskGenericCreate+0xc0>
    1dc2:	f7 01       	movw	r30, r14
    1dc4:	d1 83       	std	Z+1, r29	; 0x01
    1dc6:	c0 83       	st	Z, r28
    1dc8:	0f b6       	in	r0, 0x3f	; 63
    1dca:	f8 94       	cli
    1dcc:	0f 92       	push	r0
    1dce:	80 91 2a 08 	lds	r24, 0x082A
    1dd2:	8f 5f       	subi	r24, 0xFF	; 255
    1dd4:	80 93 2a 08 	sts	0x082A, r24
    1dd8:	80 91 8a 08 	lds	r24, 0x088A
    1ddc:	90 91 8b 08 	lds	r25, 0x088B
    1de0:	89 2b       	or	r24, r25
    1de2:	09 f0       	breq	.+2      	; 0x1de6 <xTaskGenericCreate+0xde>
    1de4:	3f c0       	rjmp	.+126    	; 0x1e64 <xTaskGenericCreate+0x15c>
    1de6:	d0 93 8b 08 	sts	0x088B, r29
    1dea:	c0 93 8a 08 	sts	0x088A, r28
    1dee:	80 91 2a 08 	lds	r24, 0x082A
    1df2:	81 30       	cpi	r24, 0x01	; 1
    1df4:	09 f0       	breq	.+2      	; 0x1df8 <xTaskGenericCreate+0xf0>
    1df6:	45 c0       	rjmp	.+138    	; 0x1e82 <xTaskGenericCreate+0x17a>
    1df8:	0f 2e       	mov	r0, r31
    1dfa:	fd e5       	ldi	r31, 0x5D	; 93
    1dfc:	ef 2e       	mov	r14, r31
    1dfe:	f8 e0       	ldi	r31, 0x08	; 8
    1e00:	ff 2e       	mov	r15, r31
    1e02:	f0 2d       	mov	r31, r0
    1e04:	0f 2e       	mov	r0, r31
    1e06:	fa e8       	ldi	r31, 0x8A	; 138
    1e08:	cf 2e       	mov	r12, r31
    1e0a:	f8 e0       	ldi	r31, 0x08	; 8
    1e0c:	df 2e       	mov	r13, r31
    1e0e:	f0 2d       	mov	r31, r0
    1e10:	c7 01       	movw	r24, r14
    1e12:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e16:	f9 e0       	ldi	r31, 0x09	; 9
    1e18:	ef 0e       	add	r14, r31
    1e1a:	f1 1c       	adc	r15, r1
    1e1c:	ec 14       	cp	r14, r12
    1e1e:	fd 04       	cpc	r15, r13
    1e20:	b9 f7       	brne	.-18     	; 0x1e10 <xTaskGenericCreate+0x108>
    1e22:	84 e5       	ldi	r24, 0x54	; 84
    1e24:	98 e0       	ldi	r25, 0x08	; 8
    1e26:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e2a:	8b e4       	ldi	r24, 0x4B	; 75
    1e2c:	98 e0       	ldi	r25, 0x08	; 8
    1e2e:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e32:	8e e3       	ldi	r24, 0x3E	; 62
    1e34:	98 e0       	ldi	r25, 0x08	; 8
    1e36:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e3a:	85 e3       	ldi	r24, 0x35	; 53
    1e3c:	98 e0       	ldi	r25, 0x08	; 8
    1e3e:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e42:	8b e2       	ldi	r24, 0x2B	; 43
    1e44:	98 e0       	ldi	r25, 0x08	; 8
    1e46:	0e 94 67 03 	call	0x6ce	; 0x6ce <vListInitialise>
    1e4a:	84 e5       	ldi	r24, 0x54	; 84
    1e4c:	98 e0       	ldi	r25, 0x08	; 8
    1e4e:	90 93 4a 08 	sts	0x084A, r25
    1e52:	80 93 49 08 	sts	0x0849, r24
    1e56:	8b e4       	ldi	r24, 0x4B	; 75
    1e58:	98 e0       	ldi	r25, 0x08	; 8
    1e5a:	90 93 48 08 	sts	0x0848, r25
    1e5e:	80 93 47 08 	sts	0x0847, r24
    1e62:	0f c0       	rjmp	.+30     	; 0x1e82 <xTaskGenericCreate+0x17a>
    1e64:	80 91 26 08 	lds	r24, 0x0826
    1e68:	81 11       	cpse	r24, r1
    1e6a:	0b c0       	rjmp	.+22     	; 0x1e82 <xTaskGenericCreate+0x17a>
    1e6c:	e0 91 8a 08 	lds	r30, 0x088A
    1e70:	f0 91 8b 08 	lds	r31, 0x088B
    1e74:	86 89       	ldd	r24, Z+22	; 0x16
    1e76:	08 17       	cp	r16, r24
    1e78:	20 f0       	brcs	.+8      	; 0x1e82 <xTaskGenericCreate+0x17a>
    1e7a:	d0 93 8b 08 	sts	0x088B, r29
    1e7e:	c0 93 8a 08 	sts	0x088A, r28
    1e82:	80 91 22 08 	lds	r24, 0x0822
    1e86:	8f 5f       	subi	r24, 0xFF	; 255
    1e88:	80 93 22 08 	sts	0x0822, r24
    1e8c:	8e 89       	ldd	r24, Y+22	; 0x16
    1e8e:	90 91 27 08 	lds	r25, 0x0827
    1e92:	98 17       	cp	r25, r24
    1e94:	10 f4       	brcc	.+4      	; 0x1e9a <xTaskGenericCreate+0x192>
    1e96:	80 93 27 08 	sts	0x0827, r24
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	9c 01       	movw	r18, r24
    1e9e:	22 0f       	add	r18, r18
    1ea0:	33 1f       	adc	r19, r19
    1ea2:	22 0f       	add	r18, r18
    1ea4:	33 1f       	adc	r19, r19
    1ea6:	22 0f       	add	r18, r18
    1ea8:	33 1f       	adc	r19, r19
    1eaa:	82 0f       	add	r24, r18
    1eac:	93 1f       	adc	r25, r19
    1eae:	b5 01       	movw	r22, r10
    1eb0:	83 5a       	subi	r24, 0xA3	; 163
    1eb2:	97 4f       	sbci	r25, 0xF7	; 247
    1eb4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    1eb8:	0f 90       	pop	r0
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	80 91 26 08 	lds	r24, 0x0826
    1ec0:	88 23       	and	r24, r24
    1ec2:	51 f0       	breq	.+20     	; 0x1ed8 <xTaskGenericCreate+0x1d0>
    1ec4:	e0 91 8a 08 	lds	r30, 0x088A
    1ec8:	f0 91 8b 08 	lds	r31, 0x088B
    1ecc:	86 89       	ldd	r24, Z+22	; 0x16
    1ece:	80 17       	cp	r24, r16
    1ed0:	28 f4       	brcc	.+10     	; 0x1edc <xTaskGenericCreate+0x1d4>
    1ed2:	ec da       	rcall	.-2600   	; 0x14ac <vPortYield>
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	1c c0       	rjmp	.+56     	; 0x1f10 <xTaskGenericCreate+0x208>
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	1a c0       	rjmp	.+52     	; 0x1f10 <xTaskGenericCreate+0x208>
    1edc:	81 e0       	ldi	r24, 0x01	; 1
    1ede:	18 c0       	rjmp	.+48     	; 0x1f10 <xTaskGenericCreate+0x208>
    1ee0:	d8 8e       	std	Y+24, r13	; 0x18
    1ee2:	cf 8a       	std	Y+23, r12	; 0x17
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
    1ee6:	48 1a       	sub	r4, r24
    1ee8:	51 08       	sbc	r5, r1
    1eea:	cf 88       	ldd	r12, Y+23	; 0x17
    1eec:	d8 8c       	ldd	r13, Y+24	; 0x18
    1eee:	c4 0c       	add	r12, r4
    1ef0:	d5 1c       	adc	r13, r5
    1ef2:	d5 01       	movw	r26, r10
    1ef4:	8c 91       	ld	r24, X
    1ef6:	89 8f       	std	Y+25, r24	; 0x19
    1ef8:	8c 91       	ld	r24, X
    1efa:	88 23       	and	r24, r24
    1efc:	09 f4       	brne	.+2      	; 0x1f00 <xTaskGenericCreate+0x1f8>
    1efe:	3b cf       	rjmp	.-394    	; 0x1d76 <xTaskGenericCreate+0x6e>
    1f00:	ae 01       	movw	r20, r28
    1f02:	46 5e       	subi	r20, 0xE6	; 230
    1f04:	5f 4f       	sbci	r21, 0xFF	; 255
    1f06:	f5 01       	movw	r30, r10
    1f08:	31 96       	adiw	r30, 0x01	; 1
    1f0a:	27 e0       	ldi	r18, 0x07	; 7
    1f0c:	29 cf       	rjmp	.-430    	; 0x1d60 <xTaskGenericCreate+0x58>
    1f0e:	8f ef       	ldi	r24, 0xFF	; 255
    1f10:	df 91       	pop	r29
    1f12:	cf 91       	pop	r28
    1f14:	1f 91       	pop	r17
    1f16:	0f 91       	pop	r16
    1f18:	ff 90       	pop	r15
    1f1a:	ef 90       	pop	r14
    1f1c:	df 90       	pop	r13
    1f1e:	cf 90       	pop	r12
    1f20:	bf 90       	pop	r11
    1f22:	af 90       	pop	r10
    1f24:	9f 90       	pop	r9
    1f26:	8f 90       	pop	r8
    1f28:	7f 90       	pop	r7
    1f2a:	6f 90       	pop	r6
    1f2c:	5f 90       	pop	r5
    1f2e:	4f 90       	pop	r4
    1f30:	08 95       	ret

00001f32 <vTaskStartScheduler>:
    1f32:	af 92       	push	r10
    1f34:	bf 92       	push	r11
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	a1 2c       	mov	r10, r1
    1f42:	b1 2c       	mov	r11, r1
    1f44:	c1 2c       	mov	r12, r1
    1f46:	d1 2c       	mov	r13, r1
    1f48:	e1 2c       	mov	r14, r1
    1f4a:	f1 2c       	mov	r15, r1
    1f4c:	00 e0       	ldi	r16, 0x00	; 0
    1f4e:	20 e0       	ldi	r18, 0x00	; 0
    1f50:	30 e0       	ldi	r19, 0x00	; 0
    1f52:	45 e5       	ldi	r20, 0x55	; 85
    1f54:	50 e0       	ldi	r21, 0x00	; 0
    1f56:	61 e3       	ldi	r22, 0x31	; 49
    1f58:	72 e0       	ldi	r23, 0x02	; 2
    1f5a:	80 e7       	ldi	r24, 0x70	; 112
    1f5c:	91 e1       	ldi	r25, 0x11	; 17
    1f5e:	d4 de       	rcall	.-600    	; 0x1d08 <xTaskGenericCreate>
    1f60:	81 30       	cpi	r24, 0x01	; 1
    1f62:	41 f4       	brne	.+16     	; 0x1f74 <vTaskStartScheduler+0x42>
    1f64:	f8 94       	cli
    1f66:	80 93 26 08 	sts	0x0826, r24
    1f6a:	10 92 29 08 	sts	0x0829, r1
    1f6e:	10 92 28 08 	sts	0x0828, r1
    1f72:	5f da       	rcall	.-2882   	; 0x1432 <xPortStartScheduler>
    1f74:	0f 91       	pop	r16
    1f76:	ff 90       	pop	r15
    1f78:	ef 90       	pop	r14
    1f7a:	df 90       	pop	r13
    1f7c:	cf 90       	pop	r12
    1f7e:	bf 90       	pop	r11
    1f80:	af 90       	pop	r10
    1f82:	08 95       	ret

00001f84 <vTaskSuspendAll>:
    1f84:	80 91 21 08 	lds	r24, 0x0821
    1f88:	8f 5f       	subi	r24, 0xFF	; 255
    1f8a:	80 93 21 08 	sts	0x0821, r24
    1f8e:	08 95       	ret

00001f90 <xTaskGetTickCount>:
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	0f 92       	push	r0
    1f96:	80 91 28 08 	lds	r24, 0x0828
    1f9a:	90 91 29 08 	lds	r25, 0x0829
    1f9e:	0f 90       	pop	r0
    1fa0:	0f be       	out	0x3f, r0	; 63
    1fa2:	08 95       	ret

00001fa4 <xTaskGetTickCountFromISR>:
    1fa4:	80 91 28 08 	lds	r24, 0x0828
    1fa8:	90 91 29 08 	lds	r25, 0x0829
    1fac:	08 95       	ret

00001fae <xTaskIncrementTick>:
    1fae:	cf 92       	push	r12
    1fb0:	df 92       	push	r13
    1fb2:	ef 92       	push	r14
    1fb4:	ff 92       	push	r15
    1fb6:	0f 93       	push	r16
    1fb8:	1f 93       	push	r17
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
    1fbe:	80 91 21 08 	lds	r24, 0x0821
    1fc2:	81 11       	cpse	r24, r1
    1fc4:	99 c0       	rjmp	.+306    	; 0x20f8 <xTaskIncrementTick+0x14a>
    1fc6:	80 91 28 08 	lds	r24, 0x0828
    1fca:	90 91 29 08 	lds	r25, 0x0829
    1fce:	01 96       	adiw	r24, 0x01	; 1
    1fd0:	90 93 29 08 	sts	0x0829, r25
    1fd4:	80 93 28 08 	sts	0x0828, r24
    1fd8:	e0 90 28 08 	lds	r14, 0x0828
    1fdc:	f0 90 29 08 	lds	r15, 0x0829
    1fe0:	e1 14       	cp	r14, r1
    1fe2:	f1 04       	cpc	r15, r1
    1fe4:	b1 f4       	brne	.+44     	; 0x2012 <xTaskIncrementTick+0x64>
    1fe6:	80 91 49 08 	lds	r24, 0x0849
    1fea:	90 91 4a 08 	lds	r25, 0x084A
    1fee:	20 91 47 08 	lds	r18, 0x0847
    1ff2:	30 91 48 08 	lds	r19, 0x0848
    1ff6:	30 93 4a 08 	sts	0x084A, r19
    1ffa:	20 93 49 08 	sts	0x0849, r18
    1ffe:	90 93 48 08 	sts	0x0848, r25
    2002:	80 93 47 08 	sts	0x0847, r24
    2006:	80 91 23 08 	lds	r24, 0x0823
    200a:	8f 5f       	subi	r24, 0xFF	; 255
    200c:	80 93 23 08 	sts	0x0823, r24
    2010:	25 de       	rcall	.-950    	; 0x1c5c <prvResetNextTaskUnblockTime>
    2012:	80 91 05 02 	lds	r24, 0x0205
    2016:	90 91 06 02 	lds	r25, 0x0206
    201a:	e8 16       	cp	r14, r24
    201c:	f9 06       	cpc	r15, r25
    201e:	08 f4       	brcc	.+2      	; 0x2022 <xTaskIncrementTick+0x74>
    2020:	54 c0       	rjmp	.+168    	; 0x20ca <xTaskIncrementTick+0x11c>
    2022:	d1 2c       	mov	r13, r1
    2024:	cc 24       	eor	r12, r12
    2026:	c3 94       	inc	r12
    2028:	01 c0       	rjmp	.+2      	; 0x202c <xTaskIncrementTick+0x7e>
    202a:	dc 2c       	mov	r13, r12
    202c:	e0 91 49 08 	lds	r30, 0x0849
    2030:	f0 91 4a 08 	lds	r31, 0x084A
    2034:	80 81       	ld	r24, Z
    2036:	81 11       	cpse	r24, r1
    2038:	07 c0       	rjmp	.+14     	; 0x2048 <xTaskIncrementTick+0x9a>
    203a:	8f ef       	ldi	r24, 0xFF	; 255
    203c:	9f ef       	ldi	r25, 0xFF	; 255
    203e:	90 93 06 02 	sts	0x0206, r25
    2042:	80 93 05 02 	sts	0x0205, r24
    2046:	42 c0       	rjmp	.+132    	; 0x20cc <xTaskIncrementTick+0x11e>
    2048:	e0 91 49 08 	lds	r30, 0x0849
    204c:	f0 91 4a 08 	lds	r31, 0x084A
    2050:	05 80       	ldd	r0, Z+5	; 0x05
    2052:	f6 81       	ldd	r31, Z+6	; 0x06
    2054:	e0 2d       	mov	r30, r0
    2056:	c6 81       	ldd	r28, Z+6	; 0x06
    2058:	d7 81       	ldd	r29, Z+7	; 0x07
    205a:	2a 81       	ldd	r18, Y+2	; 0x02
    205c:	3b 81       	ldd	r19, Y+3	; 0x03
    205e:	e2 16       	cp	r14, r18
    2060:	f3 06       	cpc	r15, r19
    2062:	28 f4       	brcc	.+10     	; 0x206e <xTaskIncrementTick+0xc0>
    2064:	30 93 06 02 	sts	0x0206, r19
    2068:	20 93 05 02 	sts	0x0205, r18
    206c:	2f c0       	rjmp	.+94     	; 0x20cc <xTaskIncrementTick+0x11e>
    206e:	8e 01       	movw	r16, r28
    2070:	0e 5f       	subi	r16, 0xFE	; 254
    2072:	1f 4f       	sbci	r17, 0xFF	; 255
    2074:	c8 01       	movw	r24, r16
    2076:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    207a:	8c 89       	ldd	r24, Y+20	; 0x14
    207c:	9d 89       	ldd	r25, Y+21	; 0x15
    207e:	89 2b       	or	r24, r25
    2080:	21 f0       	breq	.+8      	; 0x208a <xTaskIncrementTick+0xdc>
    2082:	ce 01       	movw	r24, r28
    2084:	0c 96       	adiw	r24, 0x0c	; 12
    2086:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    208a:	2e 89       	ldd	r18, Y+22	; 0x16
    208c:	80 91 27 08 	lds	r24, 0x0827
    2090:	82 17       	cp	r24, r18
    2092:	10 f4       	brcc	.+4      	; 0x2098 <xTaskIncrementTick+0xea>
    2094:	20 93 27 08 	sts	0x0827, r18
    2098:	30 e0       	ldi	r19, 0x00	; 0
    209a:	c9 01       	movw	r24, r18
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	88 0f       	add	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	88 0f       	add	r24, r24
    20a6:	99 1f       	adc	r25, r25
    20a8:	82 0f       	add	r24, r18
    20aa:	93 1f       	adc	r25, r19
    20ac:	b8 01       	movw	r22, r16
    20ae:	83 5a       	subi	r24, 0xA3	; 163
    20b0:	97 4f       	sbci	r25, 0xF7	; 247
    20b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    20b6:	e0 91 8a 08 	lds	r30, 0x088A
    20ba:	f0 91 8b 08 	lds	r31, 0x088B
    20be:	9e 89       	ldd	r25, Y+22	; 0x16
    20c0:	86 89       	ldd	r24, Z+22	; 0x16
    20c2:	98 17       	cp	r25, r24
    20c4:	08 f0       	brcs	.+2      	; 0x20c8 <xTaskIncrementTick+0x11a>
    20c6:	b1 cf       	rjmp	.-158    	; 0x202a <xTaskIncrementTick+0x7c>
    20c8:	b1 cf       	rjmp	.-158    	; 0x202c <xTaskIncrementTick+0x7e>
    20ca:	d1 2c       	mov	r13, r1
    20cc:	e0 91 8a 08 	lds	r30, 0x088A
    20d0:	f0 91 8b 08 	lds	r31, 0x088B
    20d4:	86 89       	ldd	r24, Z+22	; 0x16
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	fc 01       	movw	r30, r24
    20da:	ee 0f       	add	r30, r30
    20dc:	ff 1f       	adc	r31, r31
    20de:	ee 0f       	add	r30, r30
    20e0:	ff 1f       	adc	r31, r31
    20e2:	ee 0f       	add	r30, r30
    20e4:	ff 1f       	adc	r31, r31
    20e6:	8e 0f       	add	r24, r30
    20e8:	9f 1f       	adc	r25, r31
    20ea:	fc 01       	movw	r30, r24
    20ec:	e3 5a       	subi	r30, 0xA3	; 163
    20ee:	f7 4f       	sbci	r31, 0xF7	; 247
    20f0:	80 81       	ld	r24, Z
    20f2:	82 30       	cpi	r24, 0x02	; 2
    20f4:	40 f4       	brcc	.+16     	; 0x2106 <xTaskIncrementTick+0x158>
    20f6:	09 c0       	rjmp	.+18     	; 0x210a <xTaskIncrementTick+0x15c>
    20f8:	80 91 25 08 	lds	r24, 0x0825
    20fc:	8f 5f       	subi	r24, 0xFF	; 255
    20fe:	80 93 25 08 	sts	0x0825, r24
    2102:	d1 2c       	mov	r13, r1
    2104:	02 c0       	rjmp	.+4      	; 0x210a <xTaskIncrementTick+0x15c>
    2106:	dd 24       	eor	r13, r13
    2108:	d3 94       	inc	r13
    210a:	80 91 24 08 	lds	r24, 0x0824
    210e:	88 23       	and	r24, r24
    2110:	11 f0       	breq	.+4      	; 0x2116 <xTaskIncrementTick+0x168>
    2112:	dd 24       	eor	r13, r13
    2114:	d3 94       	inc	r13
    2116:	8d 2d       	mov	r24, r13
    2118:	df 91       	pop	r29
    211a:	cf 91       	pop	r28
    211c:	1f 91       	pop	r17
    211e:	0f 91       	pop	r16
    2120:	ff 90       	pop	r15
    2122:	ef 90       	pop	r14
    2124:	df 90       	pop	r13
    2126:	cf 90       	pop	r12
    2128:	08 95       	ret

0000212a <xTaskResumeAll>:
    212a:	df 92       	push	r13
    212c:	ef 92       	push	r14
    212e:	ff 92       	push	r15
    2130:	0f 93       	push	r16
    2132:	1f 93       	push	r17
    2134:	cf 93       	push	r28
    2136:	df 93       	push	r29
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	0f 92       	push	r0
    213e:	80 91 21 08 	lds	r24, 0x0821
    2142:	81 50       	subi	r24, 0x01	; 1
    2144:	80 93 21 08 	sts	0x0821, r24
    2148:	80 91 21 08 	lds	r24, 0x0821
    214c:	81 11       	cpse	r24, r1
    214e:	5f c0       	rjmp	.+190    	; 0x220e <__stack+0xf>
    2150:	80 91 2a 08 	lds	r24, 0x082A
    2154:	88 23       	and	r24, r24
    2156:	09 f4       	brne	.+2      	; 0x215a <xTaskResumeAll+0x30>
    2158:	5c c0       	rjmp	.+184    	; 0x2212 <__stack+0x13>
    215a:	0f 2e       	mov	r0, r31
    215c:	fe e3       	ldi	r31, 0x3E	; 62
    215e:	ef 2e       	mov	r14, r31
    2160:	f8 e0       	ldi	r31, 0x08	; 8
    2162:	ff 2e       	mov	r15, r31
    2164:	f0 2d       	mov	r31, r0
    2166:	dd 24       	eor	r13, r13
    2168:	d3 94       	inc	r13
    216a:	30 c0       	rjmp	.+96     	; 0x21cc <xTaskResumeAll+0xa2>
    216c:	e0 91 43 08 	lds	r30, 0x0843
    2170:	f0 91 44 08 	lds	r31, 0x0844
    2174:	c6 81       	ldd	r28, Z+6	; 0x06
    2176:	d7 81       	ldd	r29, Z+7	; 0x07
    2178:	ce 01       	movw	r24, r28
    217a:	0c 96       	adiw	r24, 0x0c	; 12
    217c:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2180:	8e 01       	movw	r16, r28
    2182:	0e 5f       	subi	r16, 0xFE	; 254
    2184:	1f 4f       	sbci	r17, 0xFF	; 255
    2186:	c8 01       	movw	r24, r16
    2188:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    218c:	8e 89       	ldd	r24, Y+22	; 0x16
    218e:	90 91 27 08 	lds	r25, 0x0827
    2192:	98 17       	cp	r25, r24
    2194:	10 f4       	brcc	.+4      	; 0x219a <xTaskResumeAll+0x70>
    2196:	80 93 27 08 	sts	0x0827, r24
    219a:	90 e0       	ldi	r25, 0x00	; 0
    219c:	9c 01       	movw	r18, r24
    219e:	22 0f       	add	r18, r18
    21a0:	33 1f       	adc	r19, r19
    21a2:	22 0f       	add	r18, r18
    21a4:	33 1f       	adc	r19, r19
    21a6:	22 0f       	add	r18, r18
    21a8:	33 1f       	adc	r19, r19
    21aa:	82 0f       	add	r24, r18
    21ac:	93 1f       	adc	r25, r19
    21ae:	b8 01       	movw	r22, r16
    21b0:	83 5a       	subi	r24, 0xA3	; 163
    21b2:	97 4f       	sbci	r25, 0xF7	; 247
    21b4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    21b8:	e0 91 8a 08 	lds	r30, 0x088A
    21bc:	f0 91 8b 08 	lds	r31, 0x088B
    21c0:	9e 89       	ldd	r25, Y+22	; 0x16
    21c2:	86 89       	ldd	r24, Z+22	; 0x16
    21c4:	98 17       	cp	r25, r24
    21c6:	10 f0       	brcs	.+4      	; 0x21cc <xTaskResumeAll+0xa2>
    21c8:	d0 92 24 08 	sts	0x0824, r13
    21cc:	f7 01       	movw	r30, r14
    21ce:	80 81       	ld	r24, Z
    21d0:	81 11       	cpse	r24, r1
    21d2:	cc cf       	rjmp	.-104    	; 0x216c <xTaskResumeAll+0x42>
    21d4:	80 91 25 08 	lds	r24, 0x0825
    21d8:	88 23       	and	r24, r24
    21da:	91 f0       	breq	.+36     	; 0x2200 <__stack+0x1>
    21dc:	80 91 25 08 	lds	r24, 0x0825
    21e0:	88 23       	and	r24, r24
    21e2:	71 f0       	breq	.+28     	; 0x2200 <__stack+0x1>
    21e4:	c1 e0       	ldi	r28, 0x01	; 1
    21e6:	e3 de       	rcall	.-570    	; 0x1fae <xTaskIncrementTick>
    21e8:	81 11       	cpse	r24, r1
    21ea:	c0 93 24 08 	sts	0x0824, r28
    21ee:	80 91 25 08 	lds	r24, 0x0825
    21f2:	81 50       	subi	r24, 0x01	; 1
    21f4:	80 93 25 08 	sts	0x0825, r24
    21f8:	80 91 25 08 	lds	r24, 0x0825
    21fc:	81 11       	cpse	r24, r1
    21fe:	f3 cf       	rjmp	.-26     	; 0x21e6 <xTaskResumeAll+0xbc>
    2200:	80 91 24 08 	lds	r24, 0x0824
    2204:	81 30       	cpi	r24, 0x01	; 1
    2206:	39 f4       	brne	.+14     	; 0x2216 <__stack+0x17>
    2208:	51 d9       	rcall	.-3422   	; 0x14ac <vPortYield>
    220a:	81 e0       	ldi	r24, 0x01	; 1
    220c:	05 c0       	rjmp	.+10     	; 0x2218 <__stack+0x19>
    220e:	80 e0       	ldi	r24, 0x00	; 0
    2210:	03 c0       	rjmp	.+6      	; 0x2218 <__stack+0x19>
    2212:	80 e0       	ldi	r24, 0x00	; 0
    2214:	01 c0       	rjmp	.+2      	; 0x2218 <__stack+0x19>
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	0f 90       	pop	r0
    221a:	0f be       	out	0x3f, r0	; 63
    221c:	df 91       	pop	r29
    221e:	cf 91       	pop	r28
    2220:	1f 91       	pop	r17
    2222:	0f 91       	pop	r16
    2224:	ff 90       	pop	r15
    2226:	ef 90       	pop	r14
    2228:	df 90       	pop	r13
    222a:	08 95       	ret

0000222c <vTaskDelayUntil>:
    222c:	0f 93       	push	r16
    222e:	1f 93       	push	r17
    2230:	cf 93       	push	r28
    2232:	df 93       	push	r29
    2234:	8c 01       	movw	r16, r24
    2236:	eb 01       	movw	r28, r22
    2238:	a5 de       	rcall	.-694    	; 0x1f84 <vTaskSuspendAll>
    223a:	80 91 28 08 	lds	r24, 0x0828
    223e:	90 91 29 08 	lds	r25, 0x0829
    2242:	f8 01       	movw	r30, r16
    2244:	20 81       	ld	r18, Z
    2246:	31 81       	ldd	r19, Z+1	; 0x01
    2248:	c2 0f       	add	r28, r18
    224a:	d3 1f       	adc	r29, r19
    224c:	82 17       	cp	r24, r18
    224e:	93 07       	cpc	r25, r19
    2250:	48 f4       	brcc	.+18     	; 0x2264 <vTaskDelayUntil+0x38>
    2252:	c2 17       	cp	r28, r18
    2254:	d3 07       	cpc	r29, r19
    2256:	f8 f4       	brcc	.+62     	; 0x2296 <vTaskDelayUntil+0x6a>
    2258:	d1 83       	std	Z+1, r29	; 0x01
    225a:	c0 83       	st	Z, r28
    225c:	8c 17       	cp	r24, r28
    225e:	9d 07       	cpc	r25, r29
    2260:	88 f4       	brcc	.+34     	; 0x2284 <vTaskDelayUntil+0x58>
    2262:	07 c0       	rjmp	.+14     	; 0x2272 <vTaskDelayUntil+0x46>
    2264:	c2 17       	cp	r28, r18
    2266:	d3 07       	cpc	r29, r19
    2268:	90 f0       	brcs	.+36     	; 0x228e <vTaskDelayUntil+0x62>
    226a:	8c 17       	cp	r24, r28
    226c:	9d 07       	cpc	r25, r29
    226e:	78 f0       	brcs	.+30     	; 0x228e <vTaskDelayUntil+0x62>
    2270:	12 c0       	rjmp	.+36     	; 0x2296 <vTaskDelayUntil+0x6a>
    2272:	80 91 8a 08 	lds	r24, 0x088A
    2276:	90 91 8b 08 	lds	r25, 0x088B
    227a:	02 96       	adiw	r24, 0x02	; 2
    227c:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2280:	ce 01       	movw	r24, r28
    2282:	0b dd       	rcall	.-1514   	; 0x1c9a <prvAddCurrentTaskToDelayedList>
    2284:	52 df       	rcall	.-348    	; 0x212a <xTaskResumeAll>
    2286:	81 11       	cpse	r24, r1
    2288:	0a c0       	rjmp	.+20     	; 0x229e <vTaskDelayUntil+0x72>
    228a:	10 d9       	rcall	.-3552   	; 0x14ac <vPortYield>
    228c:	08 c0       	rjmp	.+16     	; 0x229e <vTaskDelayUntil+0x72>
    228e:	f8 01       	movw	r30, r16
    2290:	d1 83       	std	Z+1, r29	; 0x01
    2292:	c0 83       	st	Z, r28
    2294:	ee cf       	rjmp	.-36     	; 0x2272 <vTaskDelayUntil+0x46>
    2296:	f8 01       	movw	r30, r16
    2298:	d1 83       	std	Z+1, r29	; 0x01
    229a:	c0 83       	st	Z, r28
    229c:	f3 cf       	rjmp	.-26     	; 0x2284 <vTaskDelayUntil+0x58>
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	1f 91       	pop	r17
    22a4:	0f 91       	pop	r16
    22a6:	08 95       	ret

000022a8 <vTaskDelay>:
    22a8:	cf 93       	push	r28
    22aa:	df 93       	push	r29
    22ac:	ec 01       	movw	r28, r24
    22ae:	00 97       	sbiw	r24, 0x00	; 0
    22b0:	99 f0       	breq	.+38     	; 0x22d8 <vTaskDelay+0x30>
    22b2:	68 de       	rcall	.-816    	; 0x1f84 <vTaskSuspendAll>
    22b4:	80 91 28 08 	lds	r24, 0x0828
    22b8:	90 91 29 08 	lds	r25, 0x0829
    22bc:	c8 0f       	add	r28, r24
    22be:	d9 1f       	adc	r29, r25
    22c0:	80 91 8a 08 	lds	r24, 0x088A
    22c4:	90 91 8b 08 	lds	r25, 0x088B
    22c8:	02 96       	adiw	r24, 0x02	; 2
    22ca:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    22ce:	ce 01       	movw	r24, r28
    22d0:	e4 dc       	rcall	.-1592   	; 0x1c9a <prvAddCurrentTaskToDelayedList>
    22d2:	2b df       	rcall	.-426    	; 0x212a <xTaskResumeAll>
    22d4:	81 11       	cpse	r24, r1
    22d6:	01 c0       	rjmp	.+2      	; 0x22da <vTaskDelay+0x32>
    22d8:	e9 d8       	rcall	.-3630   	; 0x14ac <vPortYield>
    22da:	df 91       	pop	r29
    22dc:	cf 91       	pop	r28
    22de:	08 95       	ret

000022e0 <prvIdleTask>:
    22e0:	0f 2e       	mov	r0, r31
    22e2:	fd e5       	ldi	r31, 0x5D	; 93
    22e4:	ef 2e       	mov	r14, r31
    22e6:	f8 e0       	ldi	r31, 0x08	; 8
    22e8:	ff 2e       	mov	r15, r31
    22ea:	f0 2d       	mov	r31, r0
    22ec:	c5 e3       	ldi	r28, 0x35	; 53
    22ee:	d8 e0       	ldi	r29, 0x08	; 8
    22f0:	26 c0       	rjmp	.+76     	; 0x233e <prvIdleTask+0x5e>
    22f2:	48 de       	rcall	.-880    	; 0x1f84 <vTaskSuspendAll>
    22f4:	18 81       	ld	r17, Y
    22f6:	19 df       	rcall	.-462    	; 0x212a <xTaskResumeAll>
    22f8:	11 23       	and	r17, r17
    22fa:	09 f1       	breq	.+66     	; 0x233e <prvIdleTask+0x5e>
    22fc:	0f b6       	in	r0, 0x3f	; 63
    22fe:	f8 94       	cli
    2300:	0f 92       	push	r0
    2302:	e0 91 3a 08 	lds	r30, 0x083A
    2306:	f0 91 3b 08 	lds	r31, 0x083B
    230a:	06 81       	ldd	r16, Z+6	; 0x06
    230c:	17 81       	ldd	r17, Z+7	; 0x07
    230e:	c8 01       	movw	r24, r16
    2310:	02 96       	adiw	r24, 0x02	; 2
    2312:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2316:	80 91 2a 08 	lds	r24, 0x082A
    231a:	81 50       	subi	r24, 0x01	; 1
    231c:	80 93 2a 08 	sts	0x082A, r24
    2320:	80 91 34 08 	lds	r24, 0x0834
    2324:	81 50       	subi	r24, 0x01	; 1
    2326:	80 93 34 08 	sts	0x0834, r24
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63
    232e:	f8 01       	movw	r30, r16
    2330:	87 89       	ldd	r24, Z+23	; 0x17
    2332:	90 8d       	ldd	r25, Z+24	; 0x18
    2334:	0e 94 66 03 	call	0x6cc	; 0x6cc <vPortFree>
    2338:	c8 01       	movw	r24, r16
    233a:	0e 94 66 03 	call	0x6cc	; 0x6cc <vPortFree>
    233e:	80 91 34 08 	lds	r24, 0x0834
    2342:	81 11       	cpse	r24, r1
    2344:	d6 cf       	rjmp	.-84     	; 0x22f2 <prvIdleTask+0x12>
    2346:	f7 01       	movw	r30, r14
    2348:	80 81       	ld	r24, Z
    234a:	82 30       	cpi	r24, 0x02	; 2
    234c:	c0 f3       	brcs	.-16     	; 0x233e <prvIdleTask+0x5e>
    234e:	ae d8       	rcall	.-3748   	; 0x14ac <vPortYield>
    2350:	f6 cf       	rjmp	.-20     	; 0x233e <prvIdleTask+0x5e>

00002352 <vTaskSwitchContext>:
    2352:	80 91 21 08 	lds	r24, 0x0821
    2356:	88 23       	and	r24, r24
    2358:	21 f0       	breq	.+8      	; 0x2362 <vTaskSwitchContext+0x10>
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	80 93 24 08 	sts	0x0824, r24
    2360:	08 95       	ret
    2362:	10 92 24 08 	sts	0x0824, r1
    2366:	80 91 27 08 	lds	r24, 0x0827
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	fc 01       	movw	r30, r24
    236e:	ee 0f       	add	r30, r30
    2370:	ff 1f       	adc	r31, r31
    2372:	ee 0f       	add	r30, r30
    2374:	ff 1f       	adc	r31, r31
    2376:	ee 0f       	add	r30, r30
    2378:	ff 1f       	adc	r31, r31
    237a:	8e 0f       	add	r24, r30
    237c:	9f 1f       	adc	r25, r31
    237e:	fc 01       	movw	r30, r24
    2380:	e3 5a       	subi	r30, 0xA3	; 163
    2382:	f7 4f       	sbci	r31, 0xF7	; 247
    2384:	80 81       	ld	r24, Z
    2386:	81 11       	cpse	r24, r1
    2388:	17 c0       	rjmp	.+46     	; 0x23b8 <vTaskSwitchContext+0x66>
    238a:	80 91 27 08 	lds	r24, 0x0827
    238e:	81 50       	subi	r24, 0x01	; 1
    2390:	80 93 27 08 	sts	0x0827, r24
    2394:	80 91 27 08 	lds	r24, 0x0827
    2398:	90 e0       	ldi	r25, 0x00	; 0
    239a:	fc 01       	movw	r30, r24
    239c:	ee 0f       	add	r30, r30
    239e:	ff 1f       	adc	r31, r31
    23a0:	ee 0f       	add	r30, r30
    23a2:	ff 1f       	adc	r31, r31
    23a4:	ee 0f       	add	r30, r30
    23a6:	ff 1f       	adc	r31, r31
    23a8:	8e 0f       	add	r24, r30
    23aa:	9f 1f       	adc	r25, r31
    23ac:	fc 01       	movw	r30, r24
    23ae:	e3 5a       	subi	r30, 0xA3	; 163
    23b0:	f7 4f       	sbci	r31, 0xF7	; 247
    23b2:	80 81       	ld	r24, Z
    23b4:	88 23       	and	r24, r24
    23b6:	49 f3       	breq	.-46     	; 0x238a <vTaskSwitchContext+0x38>
    23b8:	e0 91 27 08 	lds	r30, 0x0827
    23bc:	f0 e0       	ldi	r31, 0x00	; 0
    23be:	cf 01       	movw	r24, r30
    23c0:	88 0f       	add	r24, r24
    23c2:	99 1f       	adc	r25, r25
    23c4:	88 0f       	add	r24, r24
    23c6:	99 1f       	adc	r25, r25
    23c8:	88 0f       	add	r24, r24
    23ca:	99 1f       	adc	r25, r25
    23cc:	e8 0f       	add	r30, r24
    23ce:	f9 1f       	adc	r31, r25
    23d0:	e3 5a       	subi	r30, 0xA3	; 163
    23d2:	f7 4f       	sbci	r31, 0xF7	; 247
    23d4:	a1 81       	ldd	r26, Z+1	; 0x01
    23d6:	b2 81       	ldd	r27, Z+2	; 0x02
    23d8:	12 96       	adiw	r26, 0x02	; 2
    23da:	0d 90       	ld	r0, X+
    23dc:	bc 91       	ld	r27, X
    23de:	a0 2d       	mov	r26, r0
    23e0:	b2 83       	std	Z+2, r27	; 0x02
    23e2:	a1 83       	std	Z+1, r26	; 0x01
    23e4:	cf 01       	movw	r24, r30
    23e6:	03 96       	adiw	r24, 0x03	; 3
    23e8:	a8 17       	cp	r26, r24
    23ea:	b9 07       	cpc	r27, r25
    23ec:	31 f4       	brne	.+12     	; 0x23fa <vTaskSwitchContext+0xa8>
    23ee:	12 96       	adiw	r26, 0x02	; 2
    23f0:	8d 91       	ld	r24, X+
    23f2:	9c 91       	ld	r25, X
    23f4:	13 97       	sbiw	r26, 0x03	; 3
    23f6:	92 83       	std	Z+2, r25	; 0x02
    23f8:	81 83       	std	Z+1, r24	; 0x01
    23fa:	01 80       	ldd	r0, Z+1	; 0x01
    23fc:	f2 81       	ldd	r31, Z+2	; 0x02
    23fe:	e0 2d       	mov	r30, r0
    2400:	86 81       	ldd	r24, Z+6	; 0x06
    2402:	97 81       	ldd	r25, Z+7	; 0x07
    2404:	90 93 8b 08 	sts	0x088B, r25
    2408:	80 93 8a 08 	sts	0x088A, r24
    240c:	08 95       	ret

0000240e <vTaskSuspend>:
    240e:	0f 93       	push	r16
    2410:	1f 93       	push	r17
    2412:	cf 93       	push	r28
    2414:	df 93       	push	r29
    2416:	ec 01       	movw	r28, r24
    2418:	0f b6       	in	r0, 0x3f	; 63
    241a:	f8 94       	cli
    241c:	0f 92       	push	r0
    241e:	00 97       	sbiw	r24, 0x00	; 0
    2420:	21 f4       	brne	.+8      	; 0x242a <vTaskSuspend+0x1c>
    2422:	c0 91 8a 08 	lds	r28, 0x088A
    2426:	d0 91 8b 08 	lds	r29, 0x088B
    242a:	8e 01       	movw	r16, r28
    242c:	0e 5f       	subi	r16, 0xFE	; 254
    242e:	1f 4f       	sbci	r17, 0xFF	; 255
    2430:	c8 01       	movw	r24, r16
    2432:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2436:	8c 89       	ldd	r24, Y+20	; 0x14
    2438:	9d 89       	ldd	r25, Y+21	; 0x15
    243a:	89 2b       	or	r24, r25
    243c:	21 f0       	breq	.+8      	; 0x2446 <vTaskSuspend+0x38>
    243e:	ce 01       	movw	r24, r28
    2440:	0c 96       	adiw	r24, 0x0c	; 12
    2442:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2446:	b8 01       	movw	r22, r16
    2448:	8b e2       	ldi	r24, 0x2B	; 43
    244a:	98 e0       	ldi	r25, 0x08	; 8
    244c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63
    2454:	80 91 8a 08 	lds	r24, 0x088A
    2458:	90 91 8b 08 	lds	r25, 0x088B
    245c:	c8 17       	cp	r28, r24
    245e:	d9 07       	cpc	r29, r25
    2460:	99 f4       	brne	.+38     	; 0x2488 <vTaskSuspend+0x7a>
    2462:	80 91 26 08 	lds	r24, 0x0826
    2466:	88 23       	and	r24, r24
    2468:	11 f0       	breq	.+4      	; 0x246e <vTaskSuspend+0x60>
    246a:	20 d8       	rcall	.-4032   	; 0x14ac <vPortYield>
    246c:	17 c0       	rjmp	.+46     	; 0x249c <vTaskSuspend+0x8e>
    246e:	80 91 2a 08 	lds	r24, 0x082A
    2472:	90 91 2b 08 	lds	r25, 0x082B
    2476:	98 13       	cpse	r25, r24
    2478:	05 c0       	rjmp	.+10     	; 0x2484 <vTaskSuspend+0x76>
    247a:	10 92 8b 08 	sts	0x088B, r1
    247e:	10 92 8a 08 	sts	0x088A, r1
    2482:	0c c0       	rjmp	.+24     	; 0x249c <vTaskSuspend+0x8e>
    2484:	66 df       	rcall	.-308    	; 0x2352 <vTaskSwitchContext>
    2486:	0a c0       	rjmp	.+20     	; 0x249c <vTaskSuspend+0x8e>
    2488:	80 91 26 08 	lds	r24, 0x0826
    248c:	88 23       	and	r24, r24
    248e:	31 f0       	breq	.+12     	; 0x249c <vTaskSuspend+0x8e>
    2490:	0f b6       	in	r0, 0x3f	; 63
    2492:	f8 94       	cli
    2494:	0f 92       	push	r0
    2496:	e2 db       	rcall	.-2108   	; 0x1c5c <prvResetNextTaskUnblockTime>
    2498:	0f 90       	pop	r0
    249a:	0f be       	out	0x3f, r0	; 63
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	08 95       	ret

000024a6 <vTaskPlaceOnEventList>:
    24a6:	cf 93       	push	r28
    24a8:	df 93       	push	r29
    24aa:	eb 01       	movw	r28, r22
    24ac:	60 91 8a 08 	lds	r22, 0x088A
    24b0:	70 91 8b 08 	lds	r23, 0x088B
    24b4:	64 5f       	subi	r22, 0xF4	; 244
    24b6:	7f 4f       	sbci	r23, 0xFF	; 255
    24b8:	0e 94 9a 03 	call	0x734	; 0x734 <vListInsert>
    24bc:	80 91 8a 08 	lds	r24, 0x088A
    24c0:	90 91 8b 08 	lds	r25, 0x088B
    24c4:	02 96       	adiw	r24, 0x02	; 2
    24c6:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    24ca:	cf 3f       	cpi	r28, 0xFF	; 255
    24cc:	8f ef       	ldi	r24, 0xFF	; 255
    24ce:	d8 07       	cpc	r29, r24
    24d0:	59 f4       	brne	.+22     	; 0x24e8 <vTaskPlaceOnEventList+0x42>
    24d2:	60 91 8a 08 	lds	r22, 0x088A
    24d6:	70 91 8b 08 	lds	r23, 0x088B
    24da:	6e 5f       	subi	r22, 0xFE	; 254
    24dc:	7f 4f       	sbci	r23, 0xFF	; 255
    24de:	8b e2       	ldi	r24, 0x2B	; 43
    24e0:	98 e0       	ldi	r25, 0x08	; 8
    24e2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    24e6:	07 c0       	rjmp	.+14     	; 0x24f6 <vTaskPlaceOnEventList+0x50>
    24e8:	80 91 28 08 	lds	r24, 0x0828
    24ec:	90 91 29 08 	lds	r25, 0x0829
    24f0:	8c 0f       	add	r24, r28
    24f2:	9d 1f       	adc	r25, r29
    24f4:	d2 db       	rcall	.-2140   	; 0x1c9a <prvAddCurrentTaskToDelayedList>
    24f6:	df 91       	pop	r29
    24f8:	cf 91       	pop	r28
    24fa:	08 95       	ret

000024fc <xTaskRemoveFromEventList>:
    24fc:	0f 93       	push	r16
    24fe:	1f 93       	push	r17
    2500:	cf 93       	push	r28
    2502:	df 93       	push	r29
    2504:	dc 01       	movw	r26, r24
    2506:	15 96       	adiw	r26, 0x05	; 5
    2508:	ed 91       	ld	r30, X+
    250a:	fc 91       	ld	r31, X
    250c:	16 97       	sbiw	r26, 0x06	; 6
    250e:	c6 81       	ldd	r28, Z+6	; 0x06
    2510:	d7 81       	ldd	r29, Z+7	; 0x07
    2512:	8e 01       	movw	r16, r28
    2514:	04 5f       	subi	r16, 0xF4	; 244
    2516:	1f 4f       	sbci	r17, 0xFF	; 255
    2518:	c8 01       	movw	r24, r16
    251a:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    251e:	80 91 21 08 	lds	r24, 0x0821
    2522:	81 11       	cpse	r24, r1
    2524:	1c c0       	rjmp	.+56     	; 0x255e <xTaskRemoveFromEventList+0x62>
    2526:	0a 50       	subi	r16, 0x0A	; 10
    2528:	11 09       	sbc	r17, r1
    252a:	c8 01       	movw	r24, r16
    252c:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2530:	8e 89       	ldd	r24, Y+22	; 0x16
    2532:	90 91 27 08 	lds	r25, 0x0827
    2536:	98 17       	cp	r25, r24
    2538:	10 f4       	brcc	.+4      	; 0x253e <xTaskRemoveFromEventList+0x42>
    253a:	80 93 27 08 	sts	0x0827, r24
    253e:	90 e0       	ldi	r25, 0x00	; 0
    2540:	9c 01       	movw	r18, r24
    2542:	22 0f       	add	r18, r18
    2544:	33 1f       	adc	r19, r19
    2546:	22 0f       	add	r18, r18
    2548:	33 1f       	adc	r19, r19
    254a:	22 0f       	add	r18, r18
    254c:	33 1f       	adc	r19, r19
    254e:	82 0f       	add	r24, r18
    2550:	93 1f       	adc	r25, r19
    2552:	b8 01       	movw	r22, r16
    2554:	83 5a       	subi	r24, 0xA3	; 163
    2556:	97 4f       	sbci	r25, 0xF7	; 247
    2558:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    255c:	05 c0       	rjmp	.+10     	; 0x2568 <xTaskRemoveFromEventList+0x6c>
    255e:	b8 01       	movw	r22, r16
    2560:	8e e3       	ldi	r24, 0x3E	; 62
    2562:	98 e0       	ldi	r25, 0x08	; 8
    2564:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    2568:	e0 91 8a 08 	lds	r30, 0x088A
    256c:	f0 91 8b 08 	lds	r31, 0x088B
    2570:	9e 89       	ldd	r25, Y+22	; 0x16
    2572:	86 89       	ldd	r24, Z+22	; 0x16
    2574:	89 17       	cp	r24, r25
    2576:	20 f4       	brcc	.+8      	; 0x2580 <xTaskRemoveFromEventList+0x84>
    2578:	81 e0       	ldi	r24, 0x01	; 1
    257a:	80 93 24 08 	sts	0x0824, r24
    257e:	01 c0       	rjmp	.+2      	; 0x2582 <xTaskRemoveFromEventList+0x86>
    2580:	80 e0       	ldi	r24, 0x00	; 0
    2582:	df 91       	pop	r29
    2584:	cf 91       	pop	r28
    2586:	1f 91       	pop	r17
    2588:	0f 91       	pop	r16
    258a:	08 95       	ret

0000258c <vTaskSetTimeOutState>:
    258c:	20 91 23 08 	lds	r18, 0x0823
    2590:	fc 01       	movw	r30, r24
    2592:	20 83       	st	Z, r18
    2594:	20 91 28 08 	lds	r18, 0x0828
    2598:	30 91 29 08 	lds	r19, 0x0829
    259c:	32 83       	std	Z+2, r19	; 0x02
    259e:	21 83       	std	Z+1, r18	; 0x01
    25a0:	08 95       	ret

000025a2 <xTaskCheckForTimeOut>:
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	0f 92       	push	r0
    25a8:	40 91 28 08 	lds	r20, 0x0828
    25ac:	50 91 29 08 	lds	r21, 0x0829
    25b0:	db 01       	movw	r26, r22
    25b2:	2d 91       	ld	r18, X+
    25b4:	3c 91       	ld	r19, X
    25b6:	2f 3f       	cpi	r18, 0xFF	; 255
    25b8:	bf ef       	ldi	r27, 0xFF	; 255
    25ba:	3b 07       	cpc	r19, r27
    25bc:	11 f1       	breq	.+68     	; 0x2602 <xTaskCheckForTimeOut+0x60>
    25be:	e0 91 23 08 	lds	r30, 0x0823
    25c2:	dc 01       	movw	r26, r24
    25c4:	fc 91       	ld	r31, X
    25c6:	fe 17       	cp	r31, r30
    25c8:	39 f0       	breq	.+14     	; 0x25d8 <xTaskCheckForTimeOut+0x36>
    25ca:	11 96       	adiw	r26, 0x01	; 1
    25cc:	ed 91       	ld	r30, X+
    25ce:	fc 91       	ld	r31, X
    25d0:	12 97       	sbiw	r26, 0x02	; 2
    25d2:	4e 17       	cp	r20, r30
    25d4:	5f 07       	cpc	r21, r31
    25d6:	b8 f4       	brcc	.+46     	; 0x2606 <xTaskCheckForTimeOut+0x64>
    25d8:	dc 01       	movw	r26, r24
    25da:	11 96       	adiw	r26, 0x01	; 1
    25dc:	ed 91       	ld	r30, X+
    25de:	fc 91       	ld	r31, X
    25e0:	12 97       	sbiw	r26, 0x02	; 2
    25e2:	da 01       	movw	r26, r20
    25e4:	ae 1b       	sub	r26, r30
    25e6:	bf 0b       	sbc	r27, r31
    25e8:	a2 17       	cp	r26, r18
    25ea:	b3 07       	cpc	r27, r19
    25ec:	70 f4       	brcc	.+28     	; 0x260a <xTaskCheckForTimeOut+0x68>
    25ee:	e4 1b       	sub	r30, r20
    25f0:	f5 0b       	sbc	r31, r21
    25f2:	2e 0f       	add	r18, r30
    25f4:	3f 1f       	adc	r19, r31
    25f6:	fb 01       	movw	r30, r22
    25f8:	31 83       	std	Z+1, r19	; 0x01
    25fa:	20 83       	st	Z, r18
    25fc:	c7 df       	rcall	.-114    	; 0x258c <vTaskSetTimeOutState>
    25fe:	80 e0       	ldi	r24, 0x00	; 0
    2600:	05 c0       	rjmp	.+10     	; 0x260c <xTaskCheckForTimeOut+0x6a>
    2602:	80 e0       	ldi	r24, 0x00	; 0
    2604:	03 c0       	rjmp	.+6      	; 0x260c <xTaskCheckForTimeOut+0x6a>
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	01 c0       	rjmp	.+2      	; 0x260c <xTaskCheckForTimeOut+0x6a>
    260a:	81 e0       	ldi	r24, 0x01	; 1
    260c:	0f 90       	pop	r0
    260e:	0f be       	out	0x3f, r0	; 63
    2610:	08 95       	ret

00002612 <vTaskMissedYield>:
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	80 93 24 08 	sts	0x0824, r24
    2618:	08 95       	ret

0000261a <vTaskPriorityInherit>:
    261a:	0f 93       	push	r16
    261c:	1f 93       	push	r17
    261e:	cf 93       	push	r28
    2620:	df 93       	push	r29
    2622:	ec 01       	movw	r28, r24
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	09 f4       	brne	.+2      	; 0x262a <vTaskPriorityInherit+0x10>
    2628:	51 c0       	rjmp	.+162    	; 0x26cc <vTaskPriorityInherit+0xb2>
    262a:	8e 89       	ldd	r24, Y+22	; 0x16
    262c:	e0 91 8a 08 	lds	r30, 0x088A
    2630:	f0 91 8b 08 	lds	r31, 0x088B
    2634:	96 89       	ldd	r25, Z+22	; 0x16
    2636:	89 17       	cp	r24, r25
    2638:	08 f0       	brcs	.+2      	; 0x263c <vTaskPriorityInherit+0x22>
    263a:	48 c0       	rjmp	.+144    	; 0x26cc <vTaskPriorityInherit+0xb2>
    263c:	2c 85       	ldd	r18, Y+12	; 0x0c
    263e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2640:	33 23       	and	r19, r19
    2642:	5c f0       	brlt	.+22     	; 0x265a <vTaskPriorityInherit+0x40>
    2644:	e0 91 8a 08 	lds	r30, 0x088A
    2648:	f0 91 8b 08 	lds	r31, 0x088B
    264c:	96 89       	ldd	r25, Z+22	; 0x16
    264e:	25 e0       	ldi	r18, 0x05	; 5
    2650:	30 e0       	ldi	r19, 0x00	; 0
    2652:	29 1b       	sub	r18, r25
    2654:	31 09       	sbc	r19, r1
    2656:	3d 87       	std	Y+13, r19	; 0x0d
    2658:	2c 87       	std	Y+12, r18	; 0x0c
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	9c 01       	movw	r18, r24
    265e:	22 0f       	add	r18, r18
    2660:	33 1f       	adc	r19, r19
    2662:	22 0f       	add	r18, r18
    2664:	33 1f       	adc	r19, r19
    2666:	22 0f       	add	r18, r18
    2668:	33 1f       	adc	r19, r19
    266a:	82 0f       	add	r24, r18
    266c:	93 1f       	adc	r25, r19
    266e:	83 5a       	subi	r24, 0xA3	; 163
    2670:	97 4f       	sbci	r25, 0xF7	; 247
    2672:	2a 85       	ldd	r18, Y+10	; 0x0a
    2674:	3b 85       	ldd	r19, Y+11	; 0x0b
    2676:	28 17       	cp	r18, r24
    2678:	39 07       	cpc	r19, r25
    267a:	11 f5       	brne	.+68     	; 0x26c0 <vTaskPriorityInherit+0xa6>
    267c:	8e 01       	movw	r16, r28
    267e:	0e 5f       	subi	r16, 0xFE	; 254
    2680:	1f 4f       	sbci	r17, 0xFF	; 255
    2682:	c8 01       	movw	r24, r16
    2684:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2688:	e0 91 8a 08 	lds	r30, 0x088A
    268c:	f0 91 8b 08 	lds	r31, 0x088B
    2690:	86 89       	ldd	r24, Z+22	; 0x16
    2692:	8e 8b       	std	Y+22, r24	; 0x16
    2694:	90 91 27 08 	lds	r25, 0x0827
    2698:	98 17       	cp	r25, r24
    269a:	10 f4       	brcc	.+4      	; 0x26a0 <vTaskPriorityInherit+0x86>
    269c:	80 93 27 08 	sts	0x0827, r24
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	9c 01       	movw	r18, r24
    26a4:	22 0f       	add	r18, r18
    26a6:	33 1f       	adc	r19, r19
    26a8:	22 0f       	add	r18, r18
    26aa:	33 1f       	adc	r19, r19
    26ac:	22 0f       	add	r18, r18
    26ae:	33 1f       	adc	r19, r19
    26b0:	82 0f       	add	r24, r18
    26b2:	93 1f       	adc	r25, r19
    26b4:	b8 01       	movw	r22, r16
    26b6:	83 5a       	subi	r24, 0xA3	; 163
    26b8:	97 4f       	sbci	r25, 0xF7	; 247
    26ba:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    26be:	06 c0       	rjmp	.+12     	; 0x26cc <vTaskPriorityInherit+0xb2>
    26c0:	e0 91 8a 08 	lds	r30, 0x088A
    26c4:	f0 91 8b 08 	lds	r31, 0x088B
    26c8:	86 89       	ldd	r24, Z+22	; 0x16
    26ca:	8e 8b       	std	Y+22, r24	; 0x16
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
    26d0:	1f 91       	pop	r17
    26d2:	0f 91       	pop	r16
    26d4:	08 95       	ret

000026d6 <xTaskPriorityDisinherit>:
    26d6:	0f 93       	push	r16
    26d8:	1f 93       	push	r17
    26da:	cf 93       	push	r28
    26dc:	df 93       	push	r29
    26de:	ec 01       	movw	r28, r24
    26e0:	00 97       	sbiw	r24, 0x00	; 0
    26e2:	71 f1       	breq	.+92     	; 0x2740 <xTaskPriorityDisinherit+0x6a>
    26e4:	8a a1       	ldd	r24, Y+34	; 0x22
    26e6:	81 50       	subi	r24, 0x01	; 1
    26e8:	8a a3       	std	Y+34, r24	; 0x22
    26ea:	2e 89       	ldd	r18, Y+22	; 0x16
    26ec:	99 a1       	ldd	r25, Y+33	; 0x21
    26ee:	29 17       	cp	r18, r25
    26f0:	49 f1       	breq	.+82     	; 0x2744 <xTaskPriorityDisinherit+0x6e>
    26f2:	81 11       	cpse	r24, r1
    26f4:	29 c0       	rjmp	.+82     	; 0x2748 <xTaskPriorityDisinherit+0x72>
    26f6:	8e 01       	movw	r16, r28
    26f8:	0e 5f       	subi	r16, 0xFE	; 254
    26fa:	1f 4f       	sbci	r17, 0xFF	; 255
    26fc:	c8 01       	movw	r24, r16
    26fe:	0e 94 cb 03 	call	0x796	; 0x796 <uxListRemove>
    2702:	89 a1       	ldd	r24, Y+33	; 0x21
    2704:	8e 8b       	std	Y+22, r24	; 0x16
    2706:	25 e0       	ldi	r18, 0x05	; 5
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	28 1b       	sub	r18, r24
    270c:	31 09       	sbc	r19, r1
    270e:	3d 87       	std	Y+13, r19	; 0x0d
    2710:	2c 87       	std	Y+12, r18	; 0x0c
    2712:	90 91 27 08 	lds	r25, 0x0827
    2716:	98 17       	cp	r25, r24
    2718:	10 f4       	brcc	.+4      	; 0x271e <xTaskPriorityDisinherit+0x48>
    271a:	80 93 27 08 	sts	0x0827, r24
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	9c 01       	movw	r18, r24
    2722:	22 0f       	add	r18, r18
    2724:	33 1f       	adc	r19, r19
    2726:	22 0f       	add	r18, r18
    2728:	33 1f       	adc	r19, r19
    272a:	22 0f       	add	r18, r18
    272c:	33 1f       	adc	r19, r19
    272e:	82 0f       	add	r24, r18
    2730:	93 1f       	adc	r25, r19
    2732:	b8 01       	movw	r22, r16
    2734:	83 5a       	subi	r24, 0xA3	; 163
    2736:	97 4f       	sbci	r25, 0xF7	; 247
    2738:	0e 94 79 03 	call	0x6f2	; 0x6f2 <vListInsertEnd>
    273c:	81 e0       	ldi	r24, 0x01	; 1
    273e:	05 c0       	rjmp	.+10     	; 0x274a <xTaskPriorityDisinherit+0x74>
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	03 c0       	rjmp	.+6      	; 0x274a <xTaskPriorityDisinherit+0x74>
    2744:	80 e0       	ldi	r24, 0x00	; 0
    2746:	01 c0       	rjmp	.+2      	; 0x274a <xTaskPriorityDisinherit+0x74>
    2748:	80 e0       	ldi	r24, 0x00	; 0
    274a:	df 91       	pop	r29
    274c:	cf 91       	pop	r28
    274e:	1f 91       	pop	r17
    2750:	0f 91       	pop	r16
    2752:	08 95       	ret

00002754 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2754:	80 91 8a 08 	lds	r24, 0x088A
    2758:	90 91 8b 08 	lds	r25, 0x088B
    275c:	89 2b       	or	r24, r25
    275e:	39 f0       	breq	.+14     	; 0x276e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2760:	e0 91 8a 08 	lds	r30, 0x088A
    2764:	f0 91 8b 08 	lds	r31, 0x088B
    2768:	82 a1       	ldd	r24, Z+34	; 0x22
    276a:	8f 5f       	subi	r24, 0xFF	; 255
    276c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    276e:	80 91 8a 08 	lds	r24, 0x088A
    2772:	90 91 8b 08 	lds	r25, 0x088B
	}
    2776:	08 95       	ret

00002778 <__subsf3>:
    2778:	50 58       	subi	r21, 0x80	; 128

0000277a <__addsf3>:
    277a:	bb 27       	eor	r27, r27
    277c:	aa 27       	eor	r26, r26
    277e:	0e d0       	rcall	.+28     	; 0x279c <__addsf3x>
    2780:	e5 c0       	rjmp	.+458    	; 0x294c <__fp_round>
    2782:	d6 d0       	rcall	.+428    	; 0x2930 <__fp_pscA>
    2784:	30 f0       	brcs	.+12     	; 0x2792 <__addsf3+0x18>
    2786:	db d0       	rcall	.+438    	; 0x293e <__fp_pscB>
    2788:	20 f0       	brcs	.+8      	; 0x2792 <__addsf3+0x18>
    278a:	31 f4       	brne	.+12     	; 0x2798 <__addsf3+0x1e>
    278c:	9f 3f       	cpi	r25, 0xFF	; 255
    278e:	11 f4       	brne	.+4      	; 0x2794 <__addsf3+0x1a>
    2790:	1e f4       	brtc	.+6      	; 0x2798 <__addsf3+0x1e>
    2792:	cb c0       	rjmp	.+406    	; 0x292a <__fp_nan>
    2794:	0e f4       	brtc	.+2      	; 0x2798 <__addsf3+0x1e>
    2796:	e0 95       	com	r30
    2798:	e7 fb       	bst	r30, 7
    279a:	c1 c0       	rjmp	.+386    	; 0x291e <__fp_inf>

0000279c <__addsf3x>:
    279c:	e9 2f       	mov	r30, r25
    279e:	e7 d0       	rcall	.+462    	; 0x296e <__fp_split3>
    27a0:	80 f3       	brcs	.-32     	; 0x2782 <__addsf3+0x8>
    27a2:	ba 17       	cp	r27, r26
    27a4:	62 07       	cpc	r22, r18
    27a6:	73 07       	cpc	r23, r19
    27a8:	84 07       	cpc	r24, r20
    27aa:	95 07       	cpc	r25, r21
    27ac:	18 f0       	brcs	.+6      	; 0x27b4 <__addsf3x+0x18>
    27ae:	71 f4       	brne	.+28     	; 0x27cc <__addsf3x+0x30>
    27b0:	9e f5       	brtc	.+102    	; 0x2818 <__addsf3x+0x7c>
    27b2:	ff c0       	rjmp	.+510    	; 0x29b2 <__fp_zero>
    27b4:	0e f4       	brtc	.+2      	; 0x27b8 <__addsf3x+0x1c>
    27b6:	e0 95       	com	r30
    27b8:	0b 2e       	mov	r0, r27
    27ba:	ba 2f       	mov	r27, r26
    27bc:	a0 2d       	mov	r26, r0
    27be:	0b 01       	movw	r0, r22
    27c0:	b9 01       	movw	r22, r18
    27c2:	90 01       	movw	r18, r0
    27c4:	0c 01       	movw	r0, r24
    27c6:	ca 01       	movw	r24, r20
    27c8:	a0 01       	movw	r20, r0
    27ca:	11 24       	eor	r1, r1
    27cc:	ff 27       	eor	r31, r31
    27ce:	59 1b       	sub	r21, r25
    27d0:	99 f0       	breq	.+38     	; 0x27f8 <__addsf3x+0x5c>
    27d2:	59 3f       	cpi	r21, 0xF9	; 249
    27d4:	50 f4       	brcc	.+20     	; 0x27ea <__addsf3x+0x4e>
    27d6:	50 3e       	cpi	r21, 0xE0	; 224
    27d8:	68 f1       	brcs	.+90     	; 0x2834 <__addsf3x+0x98>
    27da:	1a 16       	cp	r1, r26
    27dc:	f0 40       	sbci	r31, 0x00	; 0
    27de:	a2 2f       	mov	r26, r18
    27e0:	23 2f       	mov	r18, r19
    27e2:	34 2f       	mov	r19, r20
    27e4:	44 27       	eor	r20, r20
    27e6:	58 5f       	subi	r21, 0xF8	; 248
    27e8:	f3 cf       	rjmp	.-26     	; 0x27d0 <__addsf3x+0x34>
    27ea:	46 95       	lsr	r20
    27ec:	37 95       	ror	r19
    27ee:	27 95       	ror	r18
    27f0:	a7 95       	ror	r26
    27f2:	f0 40       	sbci	r31, 0x00	; 0
    27f4:	53 95       	inc	r21
    27f6:	c9 f7       	brne	.-14     	; 0x27ea <__addsf3x+0x4e>
    27f8:	7e f4       	brtc	.+30     	; 0x2818 <__addsf3x+0x7c>
    27fa:	1f 16       	cp	r1, r31
    27fc:	ba 0b       	sbc	r27, r26
    27fe:	62 0b       	sbc	r22, r18
    2800:	73 0b       	sbc	r23, r19
    2802:	84 0b       	sbc	r24, r20
    2804:	ba f0       	brmi	.+46     	; 0x2834 <__addsf3x+0x98>
    2806:	91 50       	subi	r25, 0x01	; 1
    2808:	a1 f0       	breq	.+40     	; 0x2832 <__addsf3x+0x96>
    280a:	ff 0f       	add	r31, r31
    280c:	bb 1f       	adc	r27, r27
    280e:	66 1f       	adc	r22, r22
    2810:	77 1f       	adc	r23, r23
    2812:	88 1f       	adc	r24, r24
    2814:	c2 f7       	brpl	.-16     	; 0x2806 <__addsf3x+0x6a>
    2816:	0e c0       	rjmp	.+28     	; 0x2834 <__addsf3x+0x98>
    2818:	ba 0f       	add	r27, r26
    281a:	62 1f       	adc	r22, r18
    281c:	73 1f       	adc	r23, r19
    281e:	84 1f       	adc	r24, r20
    2820:	48 f4       	brcc	.+18     	; 0x2834 <__addsf3x+0x98>
    2822:	87 95       	ror	r24
    2824:	77 95       	ror	r23
    2826:	67 95       	ror	r22
    2828:	b7 95       	ror	r27
    282a:	f7 95       	ror	r31
    282c:	9e 3f       	cpi	r25, 0xFE	; 254
    282e:	08 f0       	brcs	.+2      	; 0x2832 <__addsf3x+0x96>
    2830:	b3 cf       	rjmp	.-154    	; 0x2798 <__addsf3+0x1e>
    2832:	93 95       	inc	r25
    2834:	88 0f       	add	r24, r24
    2836:	08 f0       	brcs	.+2      	; 0x283a <__addsf3x+0x9e>
    2838:	99 27       	eor	r25, r25
    283a:	ee 0f       	add	r30, r30
    283c:	97 95       	ror	r25
    283e:	87 95       	ror	r24
    2840:	08 95       	ret

00002842 <__fixsfsi>:
    2842:	04 d0       	rcall	.+8      	; 0x284c <__fixunssfsi>
    2844:	68 94       	set
    2846:	b1 11       	cpse	r27, r1
    2848:	b5 c0       	rjmp	.+362    	; 0x29b4 <__fp_szero>
    284a:	08 95       	ret

0000284c <__fixunssfsi>:
    284c:	98 d0       	rcall	.+304    	; 0x297e <__fp_splitA>
    284e:	88 f0       	brcs	.+34     	; 0x2872 <__fixunssfsi+0x26>
    2850:	9f 57       	subi	r25, 0x7F	; 127
    2852:	90 f0       	brcs	.+36     	; 0x2878 <__fixunssfsi+0x2c>
    2854:	b9 2f       	mov	r27, r25
    2856:	99 27       	eor	r25, r25
    2858:	b7 51       	subi	r27, 0x17	; 23
    285a:	a0 f0       	brcs	.+40     	; 0x2884 <__fixunssfsi+0x38>
    285c:	d1 f0       	breq	.+52     	; 0x2892 <__fixunssfsi+0x46>
    285e:	66 0f       	add	r22, r22
    2860:	77 1f       	adc	r23, r23
    2862:	88 1f       	adc	r24, r24
    2864:	99 1f       	adc	r25, r25
    2866:	1a f0       	brmi	.+6      	; 0x286e <__fixunssfsi+0x22>
    2868:	ba 95       	dec	r27
    286a:	c9 f7       	brne	.-14     	; 0x285e <__fixunssfsi+0x12>
    286c:	12 c0       	rjmp	.+36     	; 0x2892 <__fixunssfsi+0x46>
    286e:	b1 30       	cpi	r27, 0x01	; 1
    2870:	81 f0       	breq	.+32     	; 0x2892 <__fixunssfsi+0x46>
    2872:	9f d0       	rcall	.+318    	; 0x29b2 <__fp_zero>
    2874:	b1 e0       	ldi	r27, 0x01	; 1
    2876:	08 95       	ret
    2878:	9c c0       	rjmp	.+312    	; 0x29b2 <__fp_zero>
    287a:	67 2f       	mov	r22, r23
    287c:	78 2f       	mov	r23, r24
    287e:	88 27       	eor	r24, r24
    2880:	b8 5f       	subi	r27, 0xF8	; 248
    2882:	39 f0       	breq	.+14     	; 0x2892 <__fixunssfsi+0x46>
    2884:	b9 3f       	cpi	r27, 0xF9	; 249
    2886:	cc f3       	brlt	.-14     	; 0x287a <__fixunssfsi+0x2e>
    2888:	86 95       	lsr	r24
    288a:	77 95       	ror	r23
    288c:	67 95       	ror	r22
    288e:	b3 95       	inc	r27
    2890:	d9 f7       	brne	.-10     	; 0x2888 <__fixunssfsi+0x3c>
    2892:	3e f4       	brtc	.+14     	; 0x28a2 <__fixunssfsi+0x56>
    2894:	90 95       	com	r25
    2896:	80 95       	com	r24
    2898:	70 95       	com	r23
    289a:	61 95       	neg	r22
    289c:	7f 4f       	sbci	r23, 0xFF	; 255
    289e:	8f 4f       	sbci	r24, 0xFF	; 255
    28a0:	9f 4f       	sbci	r25, 0xFF	; 255
    28a2:	08 95       	ret

000028a4 <__floatunsisf>:
    28a4:	e8 94       	clt
    28a6:	09 c0       	rjmp	.+18     	; 0x28ba <__floatsisf+0x12>

000028a8 <__floatsisf>:
    28a8:	97 fb       	bst	r25, 7
    28aa:	3e f4       	brtc	.+14     	; 0x28ba <__floatsisf+0x12>
    28ac:	90 95       	com	r25
    28ae:	80 95       	com	r24
    28b0:	70 95       	com	r23
    28b2:	61 95       	neg	r22
    28b4:	7f 4f       	sbci	r23, 0xFF	; 255
    28b6:	8f 4f       	sbci	r24, 0xFF	; 255
    28b8:	9f 4f       	sbci	r25, 0xFF	; 255
    28ba:	99 23       	and	r25, r25
    28bc:	a9 f0       	breq	.+42     	; 0x28e8 <__floatsisf+0x40>
    28be:	f9 2f       	mov	r31, r25
    28c0:	96 e9       	ldi	r25, 0x96	; 150
    28c2:	bb 27       	eor	r27, r27
    28c4:	93 95       	inc	r25
    28c6:	f6 95       	lsr	r31
    28c8:	87 95       	ror	r24
    28ca:	77 95       	ror	r23
    28cc:	67 95       	ror	r22
    28ce:	b7 95       	ror	r27
    28d0:	f1 11       	cpse	r31, r1
    28d2:	f8 cf       	rjmp	.-16     	; 0x28c4 <__floatsisf+0x1c>
    28d4:	fa f4       	brpl	.+62     	; 0x2914 <__floatsisf+0x6c>
    28d6:	bb 0f       	add	r27, r27
    28d8:	11 f4       	brne	.+4      	; 0x28de <__floatsisf+0x36>
    28da:	60 ff       	sbrs	r22, 0
    28dc:	1b c0       	rjmp	.+54     	; 0x2914 <__floatsisf+0x6c>
    28de:	6f 5f       	subi	r22, 0xFF	; 255
    28e0:	7f 4f       	sbci	r23, 0xFF	; 255
    28e2:	8f 4f       	sbci	r24, 0xFF	; 255
    28e4:	9f 4f       	sbci	r25, 0xFF	; 255
    28e6:	16 c0       	rjmp	.+44     	; 0x2914 <__floatsisf+0x6c>
    28e8:	88 23       	and	r24, r24
    28ea:	11 f0       	breq	.+4      	; 0x28f0 <__floatsisf+0x48>
    28ec:	96 e9       	ldi	r25, 0x96	; 150
    28ee:	11 c0       	rjmp	.+34     	; 0x2912 <__floatsisf+0x6a>
    28f0:	77 23       	and	r23, r23
    28f2:	21 f0       	breq	.+8      	; 0x28fc <__floatsisf+0x54>
    28f4:	9e e8       	ldi	r25, 0x8E	; 142
    28f6:	87 2f       	mov	r24, r23
    28f8:	76 2f       	mov	r23, r22
    28fa:	05 c0       	rjmp	.+10     	; 0x2906 <__floatsisf+0x5e>
    28fc:	66 23       	and	r22, r22
    28fe:	71 f0       	breq	.+28     	; 0x291c <__floatsisf+0x74>
    2900:	96 e8       	ldi	r25, 0x86	; 134
    2902:	86 2f       	mov	r24, r22
    2904:	70 e0       	ldi	r23, 0x00	; 0
    2906:	60 e0       	ldi	r22, 0x00	; 0
    2908:	2a f0       	brmi	.+10     	; 0x2914 <__floatsisf+0x6c>
    290a:	9a 95       	dec	r25
    290c:	66 0f       	add	r22, r22
    290e:	77 1f       	adc	r23, r23
    2910:	88 1f       	adc	r24, r24
    2912:	da f7       	brpl	.-10     	; 0x290a <__floatsisf+0x62>
    2914:	88 0f       	add	r24, r24
    2916:	96 95       	lsr	r25
    2918:	87 95       	ror	r24
    291a:	97 f9       	bld	r25, 7
    291c:	08 95       	ret

0000291e <__fp_inf>:
    291e:	97 f9       	bld	r25, 7
    2920:	9f 67       	ori	r25, 0x7F	; 127
    2922:	80 e8       	ldi	r24, 0x80	; 128
    2924:	70 e0       	ldi	r23, 0x00	; 0
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	08 95       	ret

0000292a <__fp_nan>:
    292a:	9f ef       	ldi	r25, 0xFF	; 255
    292c:	80 ec       	ldi	r24, 0xC0	; 192
    292e:	08 95       	ret

00002930 <__fp_pscA>:
    2930:	00 24       	eor	r0, r0
    2932:	0a 94       	dec	r0
    2934:	16 16       	cp	r1, r22
    2936:	17 06       	cpc	r1, r23
    2938:	18 06       	cpc	r1, r24
    293a:	09 06       	cpc	r0, r25
    293c:	08 95       	ret

0000293e <__fp_pscB>:
    293e:	00 24       	eor	r0, r0
    2940:	0a 94       	dec	r0
    2942:	12 16       	cp	r1, r18
    2944:	13 06       	cpc	r1, r19
    2946:	14 06       	cpc	r1, r20
    2948:	05 06       	cpc	r0, r21
    294a:	08 95       	ret

0000294c <__fp_round>:
    294c:	09 2e       	mov	r0, r25
    294e:	03 94       	inc	r0
    2950:	00 0c       	add	r0, r0
    2952:	11 f4       	brne	.+4      	; 0x2958 <__fp_round+0xc>
    2954:	88 23       	and	r24, r24
    2956:	52 f0       	brmi	.+20     	; 0x296c <__fp_round+0x20>
    2958:	bb 0f       	add	r27, r27
    295a:	40 f4       	brcc	.+16     	; 0x296c <__fp_round+0x20>
    295c:	bf 2b       	or	r27, r31
    295e:	11 f4       	brne	.+4      	; 0x2964 <__fp_round+0x18>
    2960:	60 ff       	sbrs	r22, 0
    2962:	04 c0       	rjmp	.+8      	; 0x296c <__fp_round+0x20>
    2964:	6f 5f       	subi	r22, 0xFF	; 255
    2966:	7f 4f       	sbci	r23, 0xFF	; 255
    2968:	8f 4f       	sbci	r24, 0xFF	; 255
    296a:	9f 4f       	sbci	r25, 0xFF	; 255
    296c:	08 95       	ret

0000296e <__fp_split3>:
    296e:	57 fd       	sbrc	r21, 7
    2970:	90 58       	subi	r25, 0x80	; 128
    2972:	44 0f       	add	r20, r20
    2974:	55 1f       	adc	r21, r21
    2976:	59 f0       	breq	.+22     	; 0x298e <__fp_splitA+0x10>
    2978:	5f 3f       	cpi	r21, 0xFF	; 255
    297a:	71 f0       	breq	.+28     	; 0x2998 <__fp_splitA+0x1a>
    297c:	47 95       	ror	r20

0000297e <__fp_splitA>:
    297e:	88 0f       	add	r24, r24
    2980:	97 fb       	bst	r25, 7
    2982:	99 1f       	adc	r25, r25
    2984:	61 f0       	breq	.+24     	; 0x299e <__fp_splitA+0x20>
    2986:	9f 3f       	cpi	r25, 0xFF	; 255
    2988:	79 f0       	breq	.+30     	; 0x29a8 <__fp_splitA+0x2a>
    298a:	87 95       	ror	r24
    298c:	08 95       	ret
    298e:	12 16       	cp	r1, r18
    2990:	13 06       	cpc	r1, r19
    2992:	14 06       	cpc	r1, r20
    2994:	55 1f       	adc	r21, r21
    2996:	f2 cf       	rjmp	.-28     	; 0x297c <__fp_split3+0xe>
    2998:	46 95       	lsr	r20
    299a:	f1 df       	rcall	.-30     	; 0x297e <__fp_splitA>
    299c:	08 c0       	rjmp	.+16     	; 0x29ae <__fp_splitA+0x30>
    299e:	16 16       	cp	r1, r22
    29a0:	17 06       	cpc	r1, r23
    29a2:	18 06       	cpc	r1, r24
    29a4:	99 1f       	adc	r25, r25
    29a6:	f1 cf       	rjmp	.-30     	; 0x298a <__fp_splitA+0xc>
    29a8:	86 95       	lsr	r24
    29aa:	71 05       	cpc	r23, r1
    29ac:	61 05       	cpc	r22, r1
    29ae:	08 94       	sec
    29b0:	08 95       	ret

000029b2 <__fp_zero>:
    29b2:	e8 94       	clt

000029b4 <__fp_szero>:
    29b4:	bb 27       	eor	r27, r27
    29b6:	66 27       	eor	r22, r22
    29b8:	77 27       	eor	r23, r23
    29ba:	cb 01       	movw	r24, r22
    29bc:	97 f9       	bld	r25, 7
    29be:	08 95       	ret

000029c0 <__mulsf3>:
    29c0:	0b d0       	rcall	.+22     	; 0x29d8 <__mulsf3x>
    29c2:	c4 cf       	rjmp	.-120    	; 0x294c <__fp_round>
    29c4:	b5 df       	rcall	.-150    	; 0x2930 <__fp_pscA>
    29c6:	28 f0       	brcs	.+10     	; 0x29d2 <__mulsf3+0x12>
    29c8:	ba df       	rcall	.-140    	; 0x293e <__fp_pscB>
    29ca:	18 f0       	brcs	.+6      	; 0x29d2 <__mulsf3+0x12>
    29cc:	95 23       	and	r25, r21
    29ce:	09 f0       	breq	.+2      	; 0x29d2 <__mulsf3+0x12>
    29d0:	a6 cf       	rjmp	.-180    	; 0x291e <__fp_inf>
    29d2:	ab cf       	rjmp	.-170    	; 0x292a <__fp_nan>
    29d4:	11 24       	eor	r1, r1
    29d6:	ee cf       	rjmp	.-36     	; 0x29b4 <__fp_szero>

000029d8 <__mulsf3x>:
    29d8:	ca df       	rcall	.-108    	; 0x296e <__fp_split3>
    29da:	a0 f3       	brcs	.-24     	; 0x29c4 <__mulsf3+0x4>

000029dc <__mulsf3_pse>:
    29dc:	95 9f       	mul	r25, r21
    29de:	d1 f3       	breq	.-12     	; 0x29d4 <__mulsf3+0x14>
    29e0:	95 0f       	add	r25, r21
    29e2:	50 e0       	ldi	r21, 0x00	; 0
    29e4:	55 1f       	adc	r21, r21
    29e6:	62 9f       	mul	r22, r18
    29e8:	f0 01       	movw	r30, r0
    29ea:	72 9f       	mul	r23, r18
    29ec:	bb 27       	eor	r27, r27
    29ee:	f0 0d       	add	r31, r0
    29f0:	b1 1d       	adc	r27, r1
    29f2:	63 9f       	mul	r22, r19
    29f4:	aa 27       	eor	r26, r26
    29f6:	f0 0d       	add	r31, r0
    29f8:	b1 1d       	adc	r27, r1
    29fa:	aa 1f       	adc	r26, r26
    29fc:	64 9f       	mul	r22, r20
    29fe:	66 27       	eor	r22, r22
    2a00:	b0 0d       	add	r27, r0
    2a02:	a1 1d       	adc	r26, r1
    2a04:	66 1f       	adc	r22, r22
    2a06:	82 9f       	mul	r24, r18
    2a08:	22 27       	eor	r18, r18
    2a0a:	b0 0d       	add	r27, r0
    2a0c:	a1 1d       	adc	r26, r1
    2a0e:	62 1f       	adc	r22, r18
    2a10:	73 9f       	mul	r23, r19
    2a12:	b0 0d       	add	r27, r0
    2a14:	a1 1d       	adc	r26, r1
    2a16:	62 1f       	adc	r22, r18
    2a18:	83 9f       	mul	r24, r19
    2a1a:	a0 0d       	add	r26, r0
    2a1c:	61 1d       	adc	r22, r1
    2a1e:	22 1f       	adc	r18, r18
    2a20:	74 9f       	mul	r23, r20
    2a22:	33 27       	eor	r19, r19
    2a24:	a0 0d       	add	r26, r0
    2a26:	61 1d       	adc	r22, r1
    2a28:	23 1f       	adc	r18, r19
    2a2a:	84 9f       	mul	r24, r20
    2a2c:	60 0d       	add	r22, r0
    2a2e:	21 1d       	adc	r18, r1
    2a30:	82 2f       	mov	r24, r18
    2a32:	76 2f       	mov	r23, r22
    2a34:	6a 2f       	mov	r22, r26
    2a36:	11 24       	eor	r1, r1
    2a38:	9f 57       	subi	r25, 0x7F	; 127
    2a3a:	50 40       	sbci	r21, 0x00	; 0
    2a3c:	8a f0       	brmi	.+34     	; 0x2a60 <__mulsf3_pse+0x84>
    2a3e:	e1 f0       	breq	.+56     	; 0x2a78 <__mulsf3_pse+0x9c>
    2a40:	88 23       	and	r24, r24
    2a42:	4a f0       	brmi	.+18     	; 0x2a56 <__mulsf3_pse+0x7a>
    2a44:	ee 0f       	add	r30, r30
    2a46:	ff 1f       	adc	r31, r31
    2a48:	bb 1f       	adc	r27, r27
    2a4a:	66 1f       	adc	r22, r22
    2a4c:	77 1f       	adc	r23, r23
    2a4e:	88 1f       	adc	r24, r24
    2a50:	91 50       	subi	r25, 0x01	; 1
    2a52:	50 40       	sbci	r21, 0x00	; 0
    2a54:	a9 f7       	brne	.-22     	; 0x2a40 <__mulsf3_pse+0x64>
    2a56:	9e 3f       	cpi	r25, 0xFE	; 254
    2a58:	51 05       	cpc	r21, r1
    2a5a:	70 f0       	brcs	.+28     	; 0x2a78 <__mulsf3_pse+0x9c>
    2a5c:	60 cf       	rjmp	.-320    	; 0x291e <__fp_inf>
    2a5e:	aa cf       	rjmp	.-172    	; 0x29b4 <__fp_szero>
    2a60:	5f 3f       	cpi	r21, 0xFF	; 255
    2a62:	ec f3       	brlt	.-6      	; 0x2a5e <__mulsf3_pse+0x82>
    2a64:	98 3e       	cpi	r25, 0xE8	; 232
    2a66:	dc f3       	brlt	.-10     	; 0x2a5e <__mulsf3_pse+0x82>
    2a68:	86 95       	lsr	r24
    2a6a:	77 95       	ror	r23
    2a6c:	67 95       	ror	r22
    2a6e:	b7 95       	ror	r27
    2a70:	f7 95       	ror	r31
    2a72:	e7 95       	ror	r30
    2a74:	9f 5f       	subi	r25, 0xFF	; 255
    2a76:	c1 f7       	brne	.-16     	; 0x2a68 <__mulsf3_pse+0x8c>
    2a78:	fe 2b       	or	r31, r30
    2a7a:	88 0f       	add	r24, r24
    2a7c:	91 1d       	adc	r25, r1
    2a7e:	96 95       	lsr	r25
    2a80:	87 95       	ror	r24
    2a82:	97 f9       	bld	r25, 7
    2a84:	08 95       	ret

00002a86 <pow>:
    2a86:	fa 01       	movw	r30, r20
    2a88:	ee 0f       	add	r30, r30
    2a8a:	ff 1f       	adc	r31, r31
    2a8c:	30 96       	adiw	r30, 0x00	; 0
    2a8e:	21 05       	cpc	r18, r1
    2a90:	31 05       	cpc	r19, r1
    2a92:	99 f1       	breq	.+102    	; 0x2afa <pow+0x74>
    2a94:	61 15       	cp	r22, r1
    2a96:	71 05       	cpc	r23, r1
    2a98:	61 f4       	brne	.+24     	; 0x2ab2 <pow+0x2c>
    2a9a:	80 38       	cpi	r24, 0x80	; 128
    2a9c:	bf e3       	ldi	r27, 0x3F	; 63
    2a9e:	9b 07       	cpc	r25, r27
    2aa0:	49 f1       	breq	.+82     	; 0x2af4 <pow+0x6e>
    2aa2:	68 94       	set
    2aa4:	90 38       	cpi	r25, 0x80	; 128
    2aa6:	81 05       	cpc	r24, r1
    2aa8:	61 f0       	breq	.+24     	; 0x2ac2 <pow+0x3c>
    2aaa:	80 38       	cpi	r24, 0x80	; 128
    2aac:	bf ef       	ldi	r27, 0xFF	; 255
    2aae:	9b 07       	cpc	r25, r27
    2ab0:	41 f0       	breq	.+16     	; 0x2ac2 <pow+0x3c>
    2ab2:	99 23       	and	r25, r25
    2ab4:	42 f5       	brpl	.+80     	; 0x2b06 <pow+0x80>
    2ab6:	ff 3f       	cpi	r31, 0xFF	; 255
    2ab8:	e1 05       	cpc	r30, r1
    2aba:	31 05       	cpc	r19, r1
    2abc:	21 05       	cpc	r18, r1
    2abe:	11 f1       	breq	.+68     	; 0x2b04 <pow+0x7e>
    2ac0:	e8 94       	clt
    2ac2:	08 94       	sec
    2ac4:	e7 95       	ror	r30
    2ac6:	d9 01       	movw	r26, r18
    2ac8:	aa 23       	and	r26, r26
    2aca:	29 f4       	brne	.+10     	; 0x2ad6 <pow+0x50>
    2acc:	ab 2f       	mov	r26, r27
    2ace:	be 2f       	mov	r27, r30
    2ad0:	f8 5f       	subi	r31, 0xF8	; 248
    2ad2:	d0 f3       	brcs	.-12     	; 0x2ac8 <pow+0x42>
    2ad4:	10 c0       	rjmp	.+32     	; 0x2af6 <pow+0x70>
    2ad6:	ff 5f       	subi	r31, 0xFF	; 255
    2ad8:	70 f4       	brcc	.+28     	; 0x2af6 <pow+0x70>
    2ada:	a6 95       	lsr	r26
    2adc:	e0 f7       	brcc	.-8      	; 0x2ad6 <pow+0x50>
    2ade:	f7 39       	cpi	r31, 0x97	; 151
    2ae0:	50 f0       	brcs	.+20     	; 0x2af6 <pow+0x70>
    2ae2:	19 f0       	breq	.+6      	; 0x2aea <pow+0x64>
    2ae4:	ff 3a       	cpi	r31, 0xAF	; 175
    2ae6:	38 f4       	brcc	.+14     	; 0x2af6 <pow+0x70>
    2ae8:	9f 77       	andi	r25, 0x7F	; 127
    2aea:	9f 93       	push	r25
    2aec:	0c d0       	rcall	.+24     	; 0x2b06 <pow+0x80>
    2aee:	0f 90       	pop	r0
    2af0:	07 fc       	sbrc	r0, 7
    2af2:	90 58       	subi	r25, 0x80	; 128
    2af4:	08 95       	ret
    2af6:	3e f0       	brts	.+14     	; 0x2b06 <pow+0x80>
    2af8:	18 cf       	rjmp	.-464    	; 0x292a <__fp_nan>
    2afa:	60 e0       	ldi	r22, 0x00	; 0
    2afc:	70 e0       	ldi	r23, 0x00	; 0
    2afe:	80 e8       	ldi	r24, 0x80	; 128
    2b00:	9f e3       	ldi	r25, 0x3F	; 63
    2b02:	08 95       	ret
    2b04:	4f e7       	ldi	r20, 0x7F	; 127
    2b06:	9f 77       	andi	r25, 0x7F	; 127
    2b08:	5f 93       	push	r21
    2b0a:	4f 93       	push	r20
    2b0c:	3f 93       	push	r19
    2b0e:	2f 93       	push	r18
    2b10:	9e d0       	rcall	.+316    	; 0x2c4e <log>
    2b12:	2f 91       	pop	r18
    2b14:	3f 91       	pop	r19
    2b16:	4f 91       	pop	r20
    2b18:	5f 91       	pop	r21
    2b1a:	52 df       	rcall	.-348    	; 0x29c0 <__mulsf3>
    2b1c:	05 c0       	rjmp	.+10     	; 0x2b28 <exp>
    2b1e:	19 f4       	brne	.+6      	; 0x2b26 <pow+0xa0>
    2b20:	0e f0       	brts	.+2      	; 0x2b24 <pow+0x9e>
    2b22:	fd ce       	rjmp	.-518    	; 0x291e <__fp_inf>
    2b24:	46 cf       	rjmp	.-372    	; 0x29b2 <__fp_zero>
    2b26:	01 cf       	rjmp	.-510    	; 0x292a <__fp_nan>

00002b28 <exp>:
    2b28:	2a df       	rcall	.-428    	; 0x297e <__fp_splitA>
    2b2a:	c8 f3       	brcs	.-14     	; 0x2b1e <pow+0x98>
    2b2c:	96 38       	cpi	r25, 0x86	; 134
    2b2e:	c0 f7       	brcc	.-16     	; 0x2b20 <pow+0x9a>
    2b30:	07 f8       	bld	r0, 7
    2b32:	0f 92       	push	r0
    2b34:	e8 94       	clt
    2b36:	2b e3       	ldi	r18, 0x3B	; 59
    2b38:	3a ea       	ldi	r19, 0xAA	; 170
    2b3a:	48 eb       	ldi	r20, 0xB8	; 184
    2b3c:	5f e7       	ldi	r21, 0x7F	; 127
    2b3e:	4e df       	rcall	.-356    	; 0x29dc <__mulsf3_pse>
    2b40:	0f 92       	push	r0
    2b42:	0f 92       	push	r0
    2b44:	0f 92       	push	r0
    2b46:	4d b7       	in	r20, 0x3d	; 61
    2b48:	5e b7       	in	r21, 0x3e	; 62
    2b4a:	0f 92       	push	r0
    2b4c:	c0 d0       	rcall	.+384    	; 0x2cce <modf>
    2b4e:	e4 ee       	ldi	r30, 0xE4	; 228
    2b50:	f0 e0       	ldi	r31, 0x00	; 0
    2b52:	16 d0       	rcall	.+44     	; 0x2b80 <__fp_powser>
    2b54:	4f 91       	pop	r20
    2b56:	5f 91       	pop	r21
    2b58:	ef 91       	pop	r30
    2b5a:	ff 91       	pop	r31
    2b5c:	e5 95       	asr	r30
    2b5e:	ee 1f       	adc	r30, r30
    2b60:	ff 1f       	adc	r31, r31
    2b62:	49 f0       	breq	.+18     	; 0x2b76 <exp+0x4e>
    2b64:	fe 57       	subi	r31, 0x7E	; 126
    2b66:	e0 68       	ori	r30, 0x80	; 128
    2b68:	44 27       	eor	r20, r20
    2b6a:	ee 0f       	add	r30, r30
    2b6c:	44 1f       	adc	r20, r20
    2b6e:	fa 95       	dec	r31
    2b70:	e1 f7       	brne	.-8      	; 0x2b6a <exp+0x42>
    2b72:	41 95       	neg	r20
    2b74:	55 0b       	sbc	r21, r21
    2b76:	32 d0       	rcall	.+100    	; 0x2bdc <ldexp>
    2b78:	0f 90       	pop	r0
    2b7a:	07 fe       	sbrs	r0, 7
    2b7c:	26 c0       	rjmp	.+76     	; 0x2bca <inverse>
    2b7e:	08 95       	ret

00002b80 <__fp_powser>:
    2b80:	df 93       	push	r29
    2b82:	cf 93       	push	r28
    2b84:	1f 93       	push	r17
    2b86:	0f 93       	push	r16
    2b88:	ff 92       	push	r15
    2b8a:	ef 92       	push	r14
    2b8c:	df 92       	push	r13
    2b8e:	7b 01       	movw	r14, r22
    2b90:	8c 01       	movw	r16, r24
    2b92:	68 94       	set
    2b94:	05 c0       	rjmp	.+10     	; 0x2ba0 <__fp_powser+0x20>
    2b96:	da 2e       	mov	r13, r26
    2b98:	ef 01       	movw	r28, r30
    2b9a:	1e df       	rcall	.-452    	; 0x29d8 <__mulsf3x>
    2b9c:	fe 01       	movw	r30, r28
    2b9e:	e8 94       	clt
    2ba0:	a5 91       	lpm	r26, Z+
    2ba2:	25 91       	lpm	r18, Z+
    2ba4:	35 91       	lpm	r19, Z+
    2ba6:	45 91       	lpm	r20, Z+
    2ba8:	55 91       	lpm	r21, Z+
    2baa:	ae f3       	brts	.-22     	; 0x2b96 <__fp_powser+0x16>
    2bac:	ef 01       	movw	r28, r30
    2bae:	f6 dd       	rcall	.-1044   	; 0x279c <__addsf3x>
    2bb0:	fe 01       	movw	r30, r28
    2bb2:	97 01       	movw	r18, r14
    2bb4:	a8 01       	movw	r20, r16
    2bb6:	da 94       	dec	r13
    2bb8:	79 f7       	brne	.-34     	; 0x2b98 <__fp_powser+0x18>
    2bba:	df 90       	pop	r13
    2bbc:	ef 90       	pop	r14
    2bbe:	ff 90       	pop	r15
    2bc0:	0f 91       	pop	r16
    2bc2:	1f 91       	pop	r17
    2bc4:	cf 91       	pop	r28
    2bc6:	df 91       	pop	r29
    2bc8:	08 95       	ret

00002bca <inverse>:
    2bca:	9b 01       	movw	r18, r22
    2bcc:	ac 01       	movw	r20, r24
    2bce:	60 e0       	ldi	r22, 0x00	; 0
    2bd0:	70 e0       	ldi	r23, 0x00	; 0
    2bd2:	80 e8       	ldi	r24, 0x80	; 128
    2bd4:	9f e3       	ldi	r25, 0x3F	; 63
    2bd6:	ae c0       	rjmp	.+348    	; 0x2d34 <__divsf3>
    2bd8:	a2 ce       	rjmp	.-700    	; 0x291e <__fp_inf>
    2bda:	14 c1       	rjmp	.+552    	; 0x2e04 <__fp_mpack>

00002bdc <ldexp>:
    2bdc:	d0 de       	rcall	.-608    	; 0x297e <__fp_splitA>
    2bde:	e8 f3       	brcs	.-6      	; 0x2bda <inverse+0x10>
    2be0:	99 23       	and	r25, r25
    2be2:	d9 f3       	breq	.-10     	; 0x2bda <inverse+0x10>
    2be4:	94 0f       	add	r25, r20
    2be6:	51 1d       	adc	r21, r1
    2be8:	bb f3       	brvs	.-18     	; 0x2bd8 <inverse+0xe>
    2bea:	91 50       	subi	r25, 0x01	; 1
    2bec:	50 40       	sbci	r21, 0x00	; 0
    2bee:	94 f0       	brlt	.+36     	; 0x2c14 <ldexp+0x38>
    2bf0:	59 f0       	breq	.+22     	; 0x2c08 <ldexp+0x2c>
    2bf2:	88 23       	and	r24, r24
    2bf4:	32 f0       	brmi	.+12     	; 0x2c02 <ldexp+0x26>
    2bf6:	66 0f       	add	r22, r22
    2bf8:	77 1f       	adc	r23, r23
    2bfa:	88 1f       	adc	r24, r24
    2bfc:	91 50       	subi	r25, 0x01	; 1
    2bfe:	50 40       	sbci	r21, 0x00	; 0
    2c00:	c1 f7       	brne	.-16     	; 0x2bf2 <ldexp+0x16>
    2c02:	9e 3f       	cpi	r25, 0xFE	; 254
    2c04:	51 05       	cpc	r21, r1
    2c06:	44 f7       	brge	.-48     	; 0x2bd8 <inverse+0xe>
    2c08:	88 0f       	add	r24, r24
    2c0a:	91 1d       	adc	r25, r1
    2c0c:	96 95       	lsr	r25
    2c0e:	87 95       	ror	r24
    2c10:	97 f9       	bld	r25, 7
    2c12:	08 95       	ret
    2c14:	5f 3f       	cpi	r21, 0xFF	; 255
    2c16:	ac f0       	brlt	.+42     	; 0x2c42 <ldexp+0x66>
    2c18:	98 3e       	cpi	r25, 0xE8	; 232
    2c1a:	9c f0       	brlt	.+38     	; 0x2c42 <ldexp+0x66>
    2c1c:	bb 27       	eor	r27, r27
    2c1e:	86 95       	lsr	r24
    2c20:	77 95       	ror	r23
    2c22:	67 95       	ror	r22
    2c24:	b7 95       	ror	r27
    2c26:	08 f4       	brcc	.+2      	; 0x2c2a <ldexp+0x4e>
    2c28:	b1 60       	ori	r27, 0x01	; 1
    2c2a:	93 95       	inc	r25
    2c2c:	c1 f7       	brne	.-16     	; 0x2c1e <ldexp+0x42>
    2c2e:	bb 0f       	add	r27, r27
    2c30:	58 f7       	brcc	.-42     	; 0x2c08 <ldexp+0x2c>
    2c32:	11 f4       	brne	.+4      	; 0x2c38 <ldexp+0x5c>
    2c34:	60 ff       	sbrs	r22, 0
    2c36:	e8 cf       	rjmp	.-48     	; 0x2c08 <ldexp+0x2c>
    2c38:	6f 5f       	subi	r22, 0xFF	; 255
    2c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c3c:	8f 4f       	sbci	r24, 0xFF	; 255
    2c3e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c40:	e3 cf       	rjmp	.-58     	; 0x2c08 <ldexp+0x2c>
    2c42:	b8 ce       	rjmp	.-656    	; 0x29b4 <__fp_szero>
    2c44:	0e f0       	brts	.+2      	; 0x2c48 <ldexp+0x6c>
    2c46:	de c0       	rjmp	.+444    	; 0x2e04 <__fp_mpack>
    2c48:	70 ce       	rjmp	.-800    	; 0x292a <__fp_nan>
    2c4a:	68 94       	set
    2c4c:	68 ce       	rjmp	.-816    	; 0x291e <__fp_inf>

00002c4e <log>:
    2c4e:	97 de       	rcall	.-722    	; 0x297e <__fp_splitA>
    2c50:	c8 f3       	brcs	.-14     	; 0x2c44 <ldexp+0x68>
    2c52:	99 23       	and	r25, r25
    2c54:	d1 f3       	breq	.-12     	; 0x2c4a <ldexp+0x6e>
    2c56:	c6 f3       	brts	.-16     	; 0x2c48 <ldexp+0x6c>
    2c58:	df 93       	push	r29
    2c5a:	cf 93       	push	r28
    2c5c:	1f 93       	push	r17
    2c5e:	0f 93       	push	r16
    2c60:	ff 92       	push	r15
    2c62:	c9 2f       	mov	r28, r25
    2c64:	dd 27       	eor	r29, r29
    2c66:	88 23       	and	r24, r24
    2c68:	2a f0       	brmi	.+10     	; 0x2c74 <log+0x26>
    2c6a:	21 97       	sbiw	r28, 0x01	; 1
    2c6c:	66 0f       	add	r22, r22
    2c6e:	77 1f       	adc	r23, r23
    2c70:	88 1f       	adc	r24, r24
    2c72:	da f7       	brpl	.-10     	; 0x2c6a <log+0x1c>
    2c74:	20 e0       	ldi	r18, 0x00	; 0
    2c76:	30 e0       	ldi	r19, 0x00	; 0
    2c78:	40 e8       	ldi	r20, 0x80	; 128
    2c7a:	5f eb       	ldi	r21, 0xBF	; 191
    2c7c:	9f e3       	ldi	r25, 0x3F	; 63
    2c7e:	88 39       	cpi	r24, 0x98	; 152
    2c80:	20 f0       	brcs	.+8      	; 0x2c8a <log+0x3c>
    2c82:	80 3e       	cpi	r24, 0xE0	; 224
    2c84:	30 f0       	brcs	.+12     	; 0x2c92 <log+0x44>
    2c86:	21 96       	adiw	r28, 0x01	; 1
    2c88:	8f 77       	andi	r24, 0x7F	; 127
    2c8a:	77 dd       	rcall	.-1298   	; 0x277a <__addsf3>
    2c8c:	ec e0       	ldi	r30, 0x0C	; 12
    2c8e:	f1 e0       	ldi	r31, 0x01	; 1
    2c90:	03 c0       	rjmp	.+6      	; 0x2c98 <log+0x4a>
    2c92:	73 dd       	rcall	.-1306   	; 0x277a <__addsf3>
    2c94:	e9 e3       	ldi	r30, 0x39	; 57
    2c96:	f1 e0       	ldi	r31, 0x01	; 1
    2c98:	73 df       	rcall	.-282    	; 0x2b80 <__fp_powser>
    2c9a:	8b 01       	movw	r16, r22
    2c9c:	be 01       	movw	r22, r28
    2c9e:	ec 01       	movw	r28, r24
    2ca0:	fb 2e       	mov	r15, r27
    2ca2:	6f 57       	subi	r22, 0x7F	; 127
    2ca4:	71 09       	sbc	r23, r1
    2ca6:	75 95       	asr	r23
    2ca8:	77 1f       	adc	r23, r23
    2caa:	88 0b       	sbc	r24, r24
    2cac:	99 0b       	sbc	r25, r25
    2cae:	fc dd       	rcall	.-1032   	; 0x28a8 <__floatsisf>
    2cb0:	28 e1       	ldi	r18, 0x18	; 24
    2cb2:	32 e7       	ldi	r19, 0x72	; 114
    2cb4:	41 e3       	ldi	r20, 0x31	; 49
    2cb6:	5f e3       	ldi	r21, 0x3F	; 63
    2cb8:	8f de       	rcall	.-738    	; 0x29d8 <__mulsf3x>
    2cba:	af 2d       	mov	r26, r15
    2cbc:	98 01       	movw	r18, r16
    2cbe:	ae 01       	movw	r20, r28
    2cc0:	ff 90       	pop	r15
    2cc2:	0f 91       	pop	r16
    2cc4:	1f 91       	pop	r17
    2cc6:	cf 91       	pop	r28
    2cc8:	df 91       	pop	r29
    2cca:	68 dd       	rcall	.-1328   	; 0x279c <__addsf3x>
    2ccc:	3f ce       	rjmp	.-898    	; 0x294c <__fp_round>

00002cce <modf>:
    2cce:	fa 01       	movw	r30, r20
    2cd0:	dc 01       	movw	r26, r24
    2cd2:	aa 0f       	add	r26, r26
    2cd4:	bb 1f       	adc	r27, r27
    2cd6:	9b 01       	movw	r18, r22
    2cd8:	ac 01       	movw	r20, r24
    2cda:	bf 57       	subi	r27, 0x7F	; 127
    2cdc:	28 f4       	brcc	.+10     	; 0x2ce8 <modf+0x1a>
    2cde:	22 27       	eor	r18, r18
    2ce0:	33 27       	eor	r19, r19
    2ce2:	44 27       	eor	r20, r20
    2ce4:	50 78       	andi	r21, 0x80	; 128
    2ce6:	1f c0       	rjmp	.+62     	; 0x2d26 <modf+0x58>
    2ce8:	b7 51       	subi	r27, 0x17	; 23
    2cea:	88 f4       	brcc	.+34     	; 0x2d0e <modf+0x40>
    2cec:	ab 2f       	mov	r26, r27
    2cee:	00 24       	eor	r0, r0
    2cf0:	46 95       	lsr	r20
    2cf2:	37 95       	ror	r19
    2cf4:	27 95       	ror	r18
    2cf6:	01 1c       	adc	r0, r1
    2cf8:	a3 95       	inc	r26
    2cfa:	d2 f3       	brmi	.-12     	; 0x2cf0 <modf+0x22>
    2cfc:	00 20       	and	r0, r0
    2cfe:	69 f0       	breq	.+26     	; 0x2d1a <modf+0x4c>
    2d00:	22 0f       	add	r18, r18
    2d02:	33 1f       	adc	r19, r19
    2d04:	44 1f       	adc	r20, r20
    2d06:	b3 95       	inc	r27
    2d08:	da f3       	brmi	.-10     	; 0x2d00 <modf+0x32>
    2d0a:	0d d0       	rcall	.+26     	; 0x2d26 <modf+0x58>
    2d0c:	35 cd       	rjmp	.-1430   	; 0x2778 <__subsf3>
    2d0e:	61 30       	cpi	r22, 0x01	; 1
    2d10:	71 05       	cpc	r23, r1
    2d12:	a0 e8       	ldi	r26, 0x80	; 128
    2d14:	8a 07       	cpc	r24, r26
    2d16:	b9 46       	sbci	r27, 0x69	; 105
    2d18:	30 f4       	brcc	.+12     	; 0x2d26 <modf+0x58>
    2d1a:	9b 01       	movw	r18, r22
    2d1c:	ac 01       	movw	r20, r24
    2d1e:	66 27       	eor	r22, r22
    2d20:	77 27       	eor	r23, r23
    2d22:	88 27       	eor	r24, r24
    2d24:	90 78       	andi	r25, 0x80	; 128
    2d26:	30 96       	adiw	r30, 0x00	; 0
    2d28:	21 f0       	breq	.+8      	; 0x2d32 <modf+0x64>
    2d2a:	20 83       	st	Z, r18
    2d2c:	31 83       	std	Z+1, r19	; 0x01
    2d2e:	42 83       	std	Z+2, r20	; 0x02
    2d30:	53 83       	std	Z+3, r21	; 0x03
    2d32:	08 95       	ret

00002d34 <__divsf3>:
    2d34:	0c d0       	rcall	.+24     	; 0x2d4e <__divsf3x>
    2d36:	0a ce       	rjmp	.-1004   	; 0x294c <__fp_round>
    2d38:	02 de       	rcall	.-1020   	; 0x293e <__fp_pscB>
    2d3a:	40 f0       	brcs	.+16     	; 0x2d4c <__divsf3+0x18>
    2d3c:	f9 dd       	rcall	.-1038   	; 0x2930 <__fp_pscA>
    2d3e:	30 f0       	brcs	.+12     	; 0x2d4c <__divsf3+0x18>
    2d40:	21 f4       	brne	.+8      	; 0x2d4a <__divsf3+0x16>
    2d42:	5f 3f       	cpi	r21, 0xFF	; 255
    2d44:	19 f0       	breq	.+6      	; 0x2d4c <__divsf3+0x18>
    2d46:	eb cd       	rjmp	.-1066   	; 0x291e <__fp_inf>
    2d48:	51 11       	cpse	r21, r1
    2d4a:	34 ce       	rjmp	.-920    	; 0x29b4 <__fp_szero>
    2d4c:	ee cd       	rjmp	.-1060   	; 0x292a <__fp_nan>

00002d4e <__divsf3x>:
    2d4e:	0f de       	rcall	.-994    	; 0x296e <__fp_split3>
    2d50:	98 f3       	brcs	.-26     	; 0x2d38 <__divsf3+0x4>

00002d52 <__divsf3_pse>:
    2d52:	99 23       	and	r25, r25
    2d54:	c9 f3       	breq	.-14     	; 0x2d48 <__divsf3+0x14>
    2d56:	55 23       	and	r21, r21
    2d58:	b1 f3       	breq	.-20     	; 0x2d46 <__divsf3+0x12>
    2d5a:	95 1b       	sub	r25, r21
    2d5c:	55 0b       	sbc	r21, r21
    2d5e:	bb 27       	eor	r27, r27
    2d60:	aa 27       	eor	r26, r26
    2d62:	62 17       	cp	r22, r18
    2d64:	73 07       	cpc	r23, r19
    2d66:	84 07       	cpc	r24, r20
    2d68:	38 f0       	brcs	.+14     	; 0x2d78 <__divsf3_pse+0x26>
    2d6a:	9f 5f       	subi	r25, 0xFF	; 255
    2d6c:	5f 4f       	sbci	r21, 0xFF	; 255
    2d6e:	22 0f       	add	r18, r18
    2d70:	33 1f       	adc	r19, r19
    2d72:	44 1f       	adc	r20, r20
    2d74:	aa 1f       	adc	r26, r26
    2d76:	a9 f3       	breq	.-22     	; 0x2d62 <__divsf3_pse+0x10>
    2d78:	33 d0       	rcall	.+102    	; 0x2de0 <__divsf3_pse+0x8e>
    2d7a:	0e 2e       	mov	r0, r30
    2d7c:	3a f0       	brmi	.+14     	; 0x2d8c <__divsf3_pse+0x3a>
    2d7e:	e0 e8       	ldi	r30, 0x80	; 128
    2d80:	30 d0       	rcall	.+96     	; 0x2de2 <__divsf3_pse+0x90>
    2d82:	91 50       	subi	r25, 0x01	; 1
    2d84:	50 40       	sbci	r21, 0x00	; 0
    2d86:	e6 95       	lsr	r30
    2d88:	00 1c       	adc	r0, r0
    2d8a:	ca f7       	brpl	.-14     	; 0x2d7e <__divsf3_pse+0x2c>
    2d8c:	29 d0       	rcall	.+82     	; 0x2de0 <__divsf3_pse+0x8e>
    2d8e:	fe 2f       	mov	r31, r30
    2d90:	27 d0       	rcall	.+78     	; 0x2de0 <__divsf3_pse+0x8e>
    2d92:	66 0f       	add	r22, r22
    2d94:	77 1f       	adc	r23, r23
    2d96:	88 1f       	adc	r24, r24
    2d98:	bb 1f       	adc	r27, r27
    2d9a:	26 17       	cp	r18, r22
    2d9c:	37 07       	cpc	r19, r23
    2d9e:	48 07       	cpc	r20, r24
    2da0:	ab 07       	cpc	r26, r27
    2da2:	b0 e8       	ldi	r27, 0x80	; 128
    2da4:	09 f0       	breq	.+2      	; 0x2da8 <__divsf3_pse+0x56>
    2da6:	bb 0b       	sbc	r27, r27
    2da8:	80 2d       	mov	r24, r0
    2daa:	bf 01       	movw	r22, r30
    2dac:	ff 27       	eor	r31, r31
    2dae:	93 58       	subi	r25, 0x83	; 131
    2db0:	5f 4f       	sbci	r21, 0xFF	; 255
    2db2:	2a f0       	brmi	.+10     	; 0x2dbe <__divsf3_pse+0x6c>
    2db4:	9e 3f       	cpi	r25, 0xFE	; 254
    2db6:	51 05       	cpc	r21, r1
    2db8:	68 f0       	brcs	.+26     	; 0x2dd4 <__divsf3_pse+0x82>
    2dba:	b1 cd       	rjmp	.-1182   	; 0x291e <__fp_inf>
    2dbc:	fb cd       	rjmp	.-1034   	; 0x29b4 <__fp_szero>
    2dbe:	5f 3f       	cpi	r21, 0xFF	; 255
    2dc0:	ec f3       	brlt	.-6      	; 0x2dbc <__divsf3_pse+0x6a>
    2dc2:	98 3e       	cpi	r25, 0xE8	; 232
    2dc4:	dc f3       	brlt	.-10     	; 0x2dbc <__divsf3_pse+0x6a>
    2dc6:	86 95       	lsr	r24
    2dc8:	77 95       	ror	r23
    2dca:	67 95       	ror	r22
    2dcc:	b7 95       	ror	r27
    2dce:	f7 95       	ror	r31
    2dd0:	9f 5f       	subi	r25, 0xFF	; 255
    2dd2:	c9 f7       	brne	.-14     	; 0x2dc6 <__divsf3_pse+0x74>
    2dd4:	88 0f       	add	r24, r24
    2dd6:	91 1d       	adc	r25, r1
    2dd8:	96 95       	lsr	r25
    2dda:	87 95       	ror	r24
    2ddc:	97 f9       	bld	r25, 7
    2dde:	08 95       	ret
    2de0:	e1 e0       	ldi	r30, 0x01	; 1
    2de2:	66 0f       	add	r22, r22
    2de4:	77 1f       	adc	r23, r23
    2de6:	88 1f       	adc	r24, r24
    2de8:	bb 1f       	adc	r27, r27
    2dea:	62 17       	cp	r22, r18
    2dec:	73 07       	cpc	r23, r19
    2dee:	84 07       	cpc	r24, r20
    2df0:	ba 07       	cpc	r27, r26
    2df2:	20 f0       	brcs	.+8      	; 0x2dfc <__divsf3_pse+0xaa>
    2df4:	62 1b       	sub	r22, r18
    2df6:	73 0b       	sbc	r23, r19
    2df8:	84 0b       	sbc	r24, r20
    2dfa:	ba 0b       	sbc	r27, r26
    2dfc:	ee 1f       	adc	r30, r30
    2dfe:	88 f7       	brcc	.-30     	; 0x2de2 <__divsf3_pse+0x90>
    2e00:	e0 95       	com	r30
    2e02:	08 95       	ret

00002e04 <__fp_mpack>:
    2e04:	9f 3f       	cpi	r25, 0xFF	; 255
    2e06:	31 f0       	breq	.+12     	; 0x2e14 <__fp_mpack_finite+0xc>

00002e08 <__fp_mpack_finite>:
    2e08:	91 50       	subi	r25, 0x01	; 1
    2e0a:	20 f4       	brcc	.+8      	; 0x2e14 <__fp_mpack_finite+0xc>
    2e0c:	87 95       	ror	r24
    2e0e:	77 95       	ror	r23
    2e10:	67 95       	ror	r22
    2e12:	b7 95       	ror	r27
    2e14:	88 0f       	add	r24, r24
    2e16:	91 1d       	adc	r25, r1
    2e18:	96 95       	lsr	r25
    2e1a:	87 95       	ror	r24
    2e1c:	97 f9       	bld	r25, 7
    2e1e:	08 95       	ret

00002e20 <__divmodhi4>:
    2e20:	97 fb       	bst	r25, 7
    2e22:	07 2e       	mov	r0, r23
    2e24:	16 f4       	brtc	.+4      	; 0x2e2a <__divmodhi4+0xa>
    2e26:	00 94       	com	r0
    2e28:	06 d0       	rcall	.+12     	; 0x2e36 <__divmodhi4_neg1>
    2e2a:	77 fd       	sbrc	r23, 7
    2e2c:	08 d0       	rcall	.+16     	; 0x2e3e <__divmodhi4_neg2>
    2e2e:	0b d0       	rcall	.+22     	; 0x2e46 <__udivmodhi4>
    2e30:	07 fc       	sbrc	r0, 7
    2e32:	05 d0       	rcall	.+10     	; 0x2e3e <__divmodhi4_neg2>
    2e34:	3e f4       	brtc	.+14     	; 0x2e44 <__divmodhi4_exit>

00002e36 <__divmodhi4_neg1>:
    2e36:	90 95       	com	r25
    2e38:	81 95       	neg	r24
    2e3a:	9f 4f       	sbci	r25, 0xFF	; 255
    2e3c:	08 95       	ret

00002e3e <__divmodhi4_neg2>:
    2e3e:	70 95       	com	r23
    2e40:	61 95       	neg	r22
    2e42:	7f 4f       	sbci	r23, 0xFF	; 255

00002e44 <__divmodhi4_exit>:
    2e44:	08 95       	ret

00002e46 <__udivmodhi4>:
    2e46:	aa 1b       	sub	r26, r26
    2e48:	bb 1b       	sub	r27, r27
    2e4a:	51 e1       	ldi	r21, 0x11	; 17
    2e4c:	07 c0       	rjmp	.+14     	; 0x2e5c <__udivmodhi4_ep>

00002e4e <__udivmodhi4_loop>:
    2e4e:	aa 1f       	adc	r26, r26
    2e50:	bb 1f       	adc	r27, r27
    2e52:	a6 17       	cp	r26, r22
    2e54:	b7 07       	cpc	r27, r23
    2e56:	10 f0       	brcs	.+4      	; 0x2e5c <__udivmodhi4_ep>
    2e58:	a6 1b       	sub	r26, r22
    2e5a:	b7 0b       	sbc	r27, r23

00002e5c <__udivmodhi4_ep>:
    2e5c:	88 1f       	adc	r24, r24
    2e5e:	99 1f       	adc	r25, r25
    2e60:	5a 95       	dec	r21
    2e62:	a9 f7       	brne	.-22     	; 0x2e4e <__udivmodhi4_loop>
    2e64:	80 95       	com	r24
    2e66:	90 95       	com	r25
    2e68:	bc 01       	movw	r22, r24
    2e6a:	cd 01       	movw	r24, r26
    2e6c:	08 95       	ret

00002e6e <memcpy>:
    2e6e:	fb 01       	movw	r30, r22
    2e70:	dc 01       	movw	r26, r24
    2e72:	02 c0       	rjmp	.+4      	; 0x2e78 <memcpy+0xa>
    2e74:	01 90       	ld	r0, Z+
    2e76:	0d 92       	st	X+, r0
    2e78:	41 50       	subi	r20, 0x01	; 1
    2e7a:	50 40       	sbci	r21, 0x00	; 0
    2e7c:	d8 f7       	brcc	.-10     	; 0x2e74 <memcpy+0x6>
    2e7e:	08 95       	ret

00002e80 <_exit>:
    2e80:	f8 94       	cli

00002e82 <__stop_program>:
    2e82:	ff cf       	rjmp	.-2      	; 0x2e82 <__stop_program>
