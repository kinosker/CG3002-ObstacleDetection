
FreeRTOS2560.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000094  00800200  00002206  0000229a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002206  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006fa  00800294  00800294  0000232e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000232e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000004b8  00000000  00000000  0000235e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000532c  00000000  00000000  00002816  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000013a3  00000000  00000000  00007b42  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003276  00000000  00000000  00008ee5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000d40  00000000  00000000  0000c15c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000014b6  00000000  00000000  0000ce9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000368f  00000000  00000000  0000e352  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000468  00000000  00000000  000119e1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	87 c2       	rjmp	.+1294   	; 0x534 <__vector_9>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	8c c7       	rjmp	.+3864   	; 0xf6e <__vector_21>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	b8 c4       	rjmp	.+2416   	; 0x9d6 <__vector_25>
      66:	00 00       	nop
      68:	24 c5       	rjmp	.+2632   	; 0xab2 <__vector_26>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	0e c3       	rjmp	.+1564   	; 0x692 <__vector_29>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	6a c4       	rjmp	.+2260   	; 0x966 <__vector_36>
      92:	00 00       	nop
      94:	d8 c4       	rjmp	.+2480   	; 0xa46 <__vector_37>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 e0       	ldi	r30, 0x06	; 6
      fc:	f2 e2       	ldi	r31, 0x22	; 34
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a4 39       	cpi	r26, 0x94	; 148
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	29 e0       	ldi	r18, 0x09	; 9
     110:	a4 e9       	ldi	r26, 0x94	; 148
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ae 38       	cpi	r26, 0x8E	; 142
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	e6 d0       	rcall	.+460    	; 0x2ec <main>
     120:	0c 94 01 11 	jmp	0x2202	; 0x2202 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <task1>:
}



void setDigitalInputPowerReduction()
{
     126:	2e 9a       	sbi	0x05, 6	; 5
     128:	88 ee       	ldi	r24, 0xE8	; 232
     12a:	93 e0       	ldi	r25, 0x03	; 3
     12c:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskDelay>
     130:	85 b1       	in	r24, 0x05	; 5
     132:	15 b8       	out	0x05, r1	; 5
     134:	88 ee       	ldi	r24, 0xE8	; 232
     136:	93 e0       	ldi	r25, 0x03	; 3
     138:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskDelay>
     13c:	f4 cf       	rjmp	.-24     	; 0x126 <task1>

0000013e <task2>:
     13e:	2f 9a       	sbi	0x05, 7	; 5
     140:	84 ef       	ldi	r24, 0xF4	; 244
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskDelay>
     148:	85 b1       	in	r24, 0x05	; 5
     14a:	15 b8       	out	0x05, r1	; 5
     14c:	84 ef       	ldi	r24, 0xF4	; 244
     14e:	91 e0       	ldi	r25, 0x01	; 1
     150:	0e 94 35 0e 	call	0x1c6a	; 0x1c6a <vTaskDelay>
     154:	f4 cf       	rjmp	.-24     	; 0x13e <task2>

00000156 <RPI_receiveTask>:
     156:	8b d5       	rcall	.+2838   	; 0xc6e <myUSART_waitForHandshake>
     158:	86 e0       	ldi	r24, 0x06	; 6
     15a:	92 e0       	ldi	r25, 0x02	; 2
     15c:	4e c5       	rjmp	.+2716   	; 0xbfa <myUSART_transmitUSART0>
     15e:	08 95       	ret

00000160 <RPI_sendTask>:
     160:	7b d5       	rcall	.+2806   	; 0xc58 <myUSART_startHandShake>
     162:	8d e1       	ldi	r24, 0x1D	; 29
     164:	92 e0       	ldi	r25, 0x02	; 2
     166:	49 c5       	rjmp	.+2706   	; 0xbfa <myUSART_transmitUSART0>
     168:	08 95       	ret

0000016a <maxSonarTask>:
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
     16e:	cd b7       	in	r28, 0x3d	; 61
     170:	de b7       	in	r29, 0x3e	; 62
     172:	a8 97       	sbiw	r28, 0x28	; 40
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	f8 94       	cli
     178:	de bf       	out	0x3e, r29	; 62
     17a:	0f be       	out	0x3f, r0	; 63
     17c:	cd bf       	out	0x3d, r28	; 61
     17e:	88 e0       	ldi	r24, 0x08	; 8
     180:	e9 e3       	ldi	r30, 0x39	; 57
     182:	f2 e0       	ldi	r31, 0x02	; 2
     184:	de 01       	movw	r26, r28
     186:	17 96       	adiw	r26, 0x07	; 7
     188:	01 90       	ld	r0, Z+
     18a:	0d 92       	st	X+, r0
     18c:	8a 95       	dec	r24
     18e:	e1 f7       	brne	.-8      	; 0x188 <maxSonarTask+0x1e>
     190:	87 e0       	ldi	r24, 0x07	; 7
     192:	e1 e4       	ldi	r30, 0x41	; 65
     194:	f2 e0       	ldi	r31, 0x02	; 2
     196:	de 01       	movw	r26, r28
     198:	1f 96       	adiw	r26, 0x0f	; 15
     19a:	01 90       	ld	r0, Z+
     19c:	0d 92       	st	X+, r0
     19e:	8a 95       	dec	r24
     1a0:	e1 f7       	brne	.-8      	; 0x19a <maxSonarTask+0x30>
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e8 e4       	ldi	r30, 0x48	; 72
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	de 01       	movw	r26, r28
     1aa:	56 96       	adiw	r26, 0x16	; 22
     1ac:	01 90       	ld	r0, Z+
     1ae:	0d 92       	st	X+, r0
     1b0:	8a 95       	dec	r24
     1b2:	e1 f7       	brne	.-8      	; 0x1ac <maxSonarTask+0x42>
     1b4:	86 e0       	ldi	r24, 0x06	; 6
     1b6:	e0 e5       	ldi	r30, 0x50	; 80
     1b8:	f2 e0       	ldi	r31, 0x02	; 2
     1ba:	de 01       	movw	r26, r28
     1bc:	5e 96       	adiw	r26, 0x1e	; 30
     1be:	01 90       	ld	r0, Z+
     1c0:	0d 92       	st	X+, r0
     1c2:	8a 95       	dec	r24
     1c4:	e1 f7       	brne	.-8      	; 0x1be <maxSonarTask+0x54>
     1c6:	85 e0       	ldi	r24, 0x05	; 5
     1c8:	e6 e5       	ldi	r30, 0x56	; 86
     1ca:	f2 e0       	ldi	r31, 0x02	; 2
     1cc:	de 01       	movw	r26, r28
     1ce:	94 96       	adiw	r26, 0x24	; 36
     1d0:	01 90       	ld	r0, Z+
     1d2:	0d 92       	st	X+, r0
     1d4:	8a 95       	dec	r24
     1d6:	e1 f7       	brne	.-8      	; 0x1d0 <maxSonarTask+0x66>
     1d8:	0e 94 a9 0c 	call	0x1952	; 0x1952 <xTaskGetTickCount>
     1dc:	9a 83       	std	Y+2, r25	; 0x02
     1de:	89 83       	std	Y+1, r24	; 0x01
     1e0:	47 d2       	rcall	.+1166   	; 0x670 <myMaxSonar_Start>
     1e2:	87 e2       	ldi	r24, 0x27	; 39
     1e4:	4c d2       	rcall	.+1176   	; 0x67e <myMaxSonar_Read>
     1e6:	4a e0       	ldi	r20, 0x0A	; 10
     1e8:	be 01       	movw	r22, r28
     1ea:	6d 5f       	subi	r22, 0xFD	; 253
     1ec:	7f 4f       	sbci	r23, 0xFF	; 255
     1ee:	0e 94 ce 10 	call	0x219c	; 0x219c <__itoa_ncheck>
     1f2:	ce 01       	movw	r24, r28
     1f4:	07 96       	adiw	r24, 0x07	; 7
     1f6:	01 d5       	rcall	.+2562   	; 0xbfa <myUSART_transmitUSART0>
     1f8:	ce 01       	movw	r24, r28
     1fa:	03 96       	adiw	r24, 0x03	; 3
     1fc:	fe d4       	rcall	.+2556   	; 0xbfa <myUSART_transmitUSART0>
     1fe:	ce 01       	movw	r24, r28
     200:	4e 96       	adiw	r24, 0x1e	; 30
     202:	fb d4       	rcall	.+2550   	; 0xbfa <myUSART_transmitUSART0>
     204:	86 e2       	ldi	r24, 0x26	; 38
     206:	3b d2       	rcall	.+1142   	; 0x67e <myMaxSonar_Read>
     208:	4a e0       	ldi	r20, 0x0A	; 10
     20a:	be 01       	movw	r22, r28
     20c:	6d 5f       	subi	r22, 0xFD	; 253
     20e:	7f 4f       	sbci	r23, 0xFF	; 255
     210:	0e 94 ce 10 	call	0x219c	; 0x219c <__itoa_ncheck>
     214:	ce 01       	movw	r24, r28
     216:	0f 96       	adiw	r24, 0x0f	; 15
     218:	f0 d4       	rcall	.+2528   	; 0xbfa <myUSART_transmitUSART0>
     21a:	ce 01       	movw	r24, r28
     21c:	03 96       	adiw	r24, 0x03	; 3
     21e:	ed d4       	rcall	.+2522   	; 0xbfa <myUSART_transmitUSART0>
     220:	ce 01       	movw	r24, r28
     222:	4e 96       	adiw	r24, 0x1e	; 30
     224:	ea d4       	rcall	.+2516   	; 0xbfa <myUSART_transmitUSART0>
     226:	85 e2       	ldi	r24, 0x25	; 37
     228:	2a d2       	rcall	.+1108   	; 0x67e <myMaxSonar_Read>
     22a:	4a e0       	ldi	r20, 0x0A	; 10
     22c:	be 01       	movw	r22, r28
     22e:	6d 5f       	subi	r22, 0xFD	; 253
     230:	7f 4f       	sbci	r23, 0xFF	; 255
     232:	0a 97       	sbiw	r24, 0x0a	; 10
     234:	0e 94 ce 10 	call	0x219c	; 0x219c <__itoa_ncheck>
     238:	ce 01       	movw	r24, r28
     23a:	46 96       	adiw	r24, 0x16	; 22
     23c:	de d4       	rcall	.+2492   	; 0xbfa <myUSART_transmitUSART0>
     23e:	ce 01       	movw	r24, r28
     240:	03 96       	adiw	r24, 0x03	; 3
     242:	db d4       	rcall	.+2486   	; 0xbfa <myUSART_transmitUSART0>
     244:	ce 01       	movw	r24, r28
     246:	84 96       	adiw	r24, 0x24	; 36
     248:	d8 d4       	rcall	.+2480   	; 0xbfa <myUSART_transmitUSART0>
     24a:	66 e9       	ldi	r22, 0x96	; 150
     24c:	70 e0       	ldi	r23, 0x00	; 0
     24e:	ce 01       	movw	r24, r28
     250:	01 96       	adiw	r24, 0x01	; 1
     252:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vTaskDelayUntil>
     256:	ec d1       	rcall	.+984    	; 0x630 <myHcSonar_Read>
     258:	4a e0       	ldi	r20, 0x0A	; 10
     25a:	be 01       	movw	r22, r28
     25c:	6d 5f       	subi	r22, 0xFD	; 253
     25e:	7f 4f       	sbci	r23, 0xFF	; 255
     260:	0e 94 ce 10 	call	0x219c	; 0x219c <__itoa_ncheck>
     264:	83 e3       	ldi	r24, 0x33	; 51
     266:	92 e0       	ldi	r25, 0x02	; 2
     268:	c8 d4       	rcall	.+2448   	; 0xbfa <myUSART_transmitUSART0>
     26a:	ce 01       	movw	r24, r28
     26c:	03 96       	adiw	r24, 0x03	; 3
     26e:	c5 d4       	rcall	.+2442   	; 0xbfa <myUSART_transmitUSART0>
     270:	ce 01       	movw	r24, r28
     272:	84 96       	adiw	r24, 0x24	; 36
     274:	c2 d4       	rcall	.+2436   	; 0xbfa <myUSART_transmitUSART0>
     276:	b4 cf       	rjmp	.-152    	; 0x1e0 <maxSonarTask+0x76>

00000278 <myTimerTask>:
     278:	a4 d2       	rcall	.+1352   	; 0x7c2 <myTimer_Init>
     27a:	06 d3       	rcall	.+1548   	; 0x888 <myTimer_DelayChecker>
     27c:	fe cf       	rjmp	.-4      	; 0x27a <myTimerTask+0x2>

0000027e <setPowerReduction>:
}

// Shut down unused...
void setPowerReduction()
{
	PRR0 = (1<<PRTWI) | (1<<PRTIM2) | (1<<PRTIM1) | (1<<PRSPI); // Shut down I2C, timer2, timer 1, SPI
     27e:	8c ec       	ldi	r24, 0xCC	; 204
     280:	80 93 64 00 	sts	0x0064, r24
	// Include USART0 after finish debugging using usb.... (1<<PRUSART0)
	
	PRR1 = (1<<PRTIM5) | (1<<PRTIM4) | (1<<PRTIM3) | (1<<PRUSART3) | (1<<PRUSART2); // Shut down timer5, timer4, timer3, USART3, USART2
     284:	8e e3       	ldi	r24, 0x3E	; 62
     286:	80 93 65 00 	sts	0x0065, r24
     28a:	08 95       	ret

0000028c <clearTimer>:
}

void clearTimer()
{
	// Clear Timer1
	TCCR1A = 0;     // Clear all settings
     28c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = 0;     // Clear all settings
     290:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = 0;     // Disable all interrupts
     294:	10 92 6f 00 	sts	0x006F, r1

	// Clear Timer2
	TCCR2A = 0;     // Clear all settings
     298:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B = 0;     // Clear all settings
     29c:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2 = 0;     // Disable all interrupts
     2a0:	10 92 70 00 	sts	0x0070, r1
	
	// Clear Timer3
	TCCR3A = 0;     // Clear all settings
     2a4:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = 0;     // Clear all settings
     2a8:	10 92 91 00 	sts	0x0091, r1
	TIMSK3 = 0;     // Disable all interrupts
     2ac:	10 92 71 00 	sts	0x0071, r1

	// Clear Timer4
	TCCR4A = 0;     // Clear all settings
     2b0:	10 92 a0 00 	sts	0x00A0, r1
	TCCR4B = 0;     // Clear all settings
     2b4:	10 92 a1 00 	sts	0x00A1, r1
	TIMSK4 = 0;     // Disable all interrupts
     2b8:	10 92 72 00 	sts	0x0072, r1

	// Clear Timer5
	TCCR5A = 0;     // Clear all settings
     2bc:	10 92 20 01 	sts	0x0120, r1
	TCCR5B = 0;     // Clear all settings
     2c0:	10 92 21 01 	sts	0x0121, r1
	TIMSK5 = 0;     // Disable all interrupts
     2c4:	10 92 73 00 	sts	0x0073, r1
     2c8:	08 95       	ret

000002ca <init>:
}

void init()
{
     2ca:	cf 93       	push	r28
	// Ensure atomic...
	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
     2cc:	cf b7       	in	r28, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     2ce:	f8 94       	cli
	{
		clearTimer();
     2d0:	dd df       	rcall	.-70     	; 0x28c <clearTimer>
		setPowerReduction();
     2d2:	d5 df       	rcall	.-86     	; 0x27e <setPowerReduction>
		myUSART_USART0_Init();
     2d4:	24 d4       	rcall	.+2120   	; 0xb1e <myUSART_USART0_Init>
		myUSART_USART1_Init();
     2d6:	43 d4       	rcall	.+2182   	; 0xb5e <myUSART_USART1_Init>
		myADC_Init();
     2d8:	10 d2       	rcall	.+1056   	; 0x6fa <myADC_Init>
		MaxSonar_Init();
     2da:	99 9a       	sbi	0x13, 1	; 19
		myHcSonar_Init();
     2dc:	8c d1       	rcall	.+792    	; 0x5f6 <myHcSonar_Init>
		
		DDRB |= (1 << DDB6) | (1 << DDB7); // set direction...
     2de:	84 b1       	in	r24, 0x04	; 4
     2e0:	80 6c       	ori	r24, 0xC0	; 192
     2e2:	84 b9       	out	0x04, r24	; 4
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     2e4:	cf bf       	out	0x3f, r28	; 63
		
		
	}
	
	sei(); // enable interrupts..
     2e6:	78 94       	sei
}
     2e8:	cf 91       	pop	r28
     2ea:	08 95       	ret

000002ec <main>:
	
	// do nth
}

int main(void)
{
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	cd b7       	in	r28, 0x3d	; 61
     2f2:	de b7       	in	r29, 0x3e	; 62
     2f4:	2c 97       	sbiw	r28, 0x0c	; 12
     2f6:	0f b6       	in	r0, 0x3f	; 63
     2f8:	f8 94       	cli
     2fa:	de bf       	out	0x3e, r29	; 62
     2fc:	0f be       	out	0x3f, r0	; 63
     2fe:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		TaskHandle_t t1,t2, t_maxSonar, t_rx, t_tx, t_delay;
		
		init();
     300:	e4 df       	rcall	.-56     	; 0x2ca <init>
		
		xTaskCreate(myTimerTask, "myTimer", MY_TIMER_STACK, (&t_delay) , MY_TIMER_PRIORITY, &t_delay); // danger?!?
     302:	a1 2c       	mov	r10, r1
     304:	b1 2c       	mov	r11, r1
     306:	c1 2c       	mov	r12, r1
     308:	d1 2c       	mov	r13, r1
     30a:	ce 01       	movw	r24, r28
     30c:	01 96       	adiw	r24, 0x01	; 1
     30e:	7c 01       	movw	r14, r24
     310:	04 e0       	ldi	r16, 0x04	; 4
     312:	9c 01       	movw	r18, r24
     314:	49 e6       	ldi	r20, 0x69	; 105
     316:	50 e0       	ldi	r21, 0x00	; 0
     318:	6b e5       	ldi	r22, 0x5B	; 91
     31a:	72 e0       	ldi	r23, 0x02	; 2
     31c:	8c e3       	ldi	r24, 0x3C	; 60
     31e:	91 e0       	ldi	r25, 0x01	; 1
     320:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
		
		xTaskCreate(maxSonarTask, "maxSonar", MAXSONAR_STACK, NULL, MAXSONAR_PRIORITY, &t_maxSonar);
     324:	ce 01       	movw	r24, r28
     326:	07 96       	adiw	r24, 0x07	; 7
     328:	7c 01       	movw	r14, r24
     32a:	02 e0       	ldi	r16, 0x02	; 2
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	4d e1       	ldi	r20, 0x1D	; 29
     332:	51 e0       	ldi	r21, 0x01	; 1
     334:	63 e6       	ldi	r22, 0x63	; 99
     336:	72 e0       	ldi	r23, 0x02	; 2
     338:	85 eb       	ldi	r24, 0xB5	; 181
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
		xTaskCreate(task1, "Task 1", BLINK_1_STACK, NULL, BLINK_1_PRIORITY, &t1);
     340:	ce 01       	movw	r24, r28
     342:	0b 96       	adiw	r24, 0x0b	; 11
     344:	7c 01       	movw	r14, r24
     346:	01 e0       	ldi	r16, 0x01	; 1
     348:	20 e0       	ldi	r18, 0x00	; 0
     34a:	30 e0       	ldi	r19, 0x00	; 0
     34c:	49 e6       	ldi	r20, 0x69	; 105
     34e:	50 e0       	ldi	r21, 0x00	; 0
     350:	6c e6       	ldi	r22, 0x6C	; 108
     352:	72 e0       	ldi	r23, 0x02	; 2
     354:	83 e9       	ldi	r24, 0x93	; 147
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
		xTaskCreate(task2, "Task 2", BLINK_2_STACK, NULL, BLINK_2_PRIORITY, &t2);
     35c:	ce 01       	movw	r24, r28
     35e:	09 96       	adiw	r24, 0x09	; 9
     360:	7c 01       	movw	r14, r24
     362:	20 e0       	ldi	r18, 0x00	; 0
     364:	30 e0       	ldi	r19, 0x00	; 0
     366:	49 e6       	ldi	r20, 0x69	; 105
     368:	50 e0       	ldi	r21, 0x00	; 0
     36a:	63 e7       	ldi	r22, 0x73	; 115
     36c:	72 e0       	ldi	r23, 0x02	; 2
     36e:	8f e9       	ldi	r24, 0x9F	; 159
     370:	90 e0       	ldi	r25, 0x00	; 0
     372:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
		
		xTaskCreate(RPI_receiveTask, "RPI_Receive", RPI_RECEIVE_STACK, NULL, RPI_RECEIVE_PRIORITY, &t_rx);
     376:	ce 01       	movw	r24, r28
     378:	05 96       	adiw	r24, 0x05	; 5
     37a:	7c 01       	movw	r14, r24
     37c:	03 e0       	ldi	r16, 0x03	; 3
     37e:	20 e0       	ldi	r18, 0x00	; 0
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	47 e8       	ldi	r20, 0x87	; 135
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	6a e7       	ldi	r22, 0x7A	; 122
     388:	72 e0       	ldi	r23, 0x02	; 2
     38a:	8b ea       	ldi	r24, 0xAB	; 171
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
		xTaskCreate(RPI_sendTask, "RPI_Send", RPI_SEND_STACK, NULL, RPI_SEND_PRIORITY, &t_tx);
     392:	ce 01       	movw	r24, r28
     394:	03 96       	adiw	r24, 0x03	; 3
     396:	7c 01       	movw	r14, r24
     398:	02 e0       	ldi	r16, 0x02	; 2
     39a:	20 e0       	ldi	r18, 0x00	; 0
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	47 e8       	ldi	r20, 0x87	; 135
     3a0:	50 e0       	ldi	r21, 0x00	; 0
     3a2:	66 e8       	ldi	r22, 0x86	; 134
     3a4:	72 e0       	ldi	r23, 0x02	; 2
     3a6:	80 eb       	ldi	r24, 0xB0	; 176
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskGenericCreate>
	

		
		vTaskStartScheduler();
     3ae:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <vTaskStartScheduler>
     3b2:	a6 cf       	rjmp	.-180    	; 0x300 <main+0x14>

000003b4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3b4:	cf 93       	push	r28
     3b6:	df 93       	push	r29
     3b8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3ba:	0e 94 a3 0c 	call	0x1946	; 0x1946 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3be:	80 91 94 02 	lds	r24, 0x0294
     3c2:	90 91 95 02 	lds	r25, 0x0295
     3c6:	89 2b       	or	r24, r25
     3c8:	31 f4       	brne	.+12     	; 0x3d6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3ca:	89 e9       	ldi	r24, 0x99	; 153
     3cc:	92 e0       	ldi	r25, 0x02	; 2
     3ce:	90 93 95 02 	sts	0x0295, r25
     3d2:	80 93 94 02 	sts	0x0294, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3d6:	40 91 96 02 	lds	r20, 0x0296
     3da:	50 91 97 02 	lds	r21, 0x0297
     3de:	9e 01       	movw	r18, r28
     3e0:	24 0f       	add	r18, r20
     3e2:	35 1f       	adc	r19, r21
     3e4:	2b 3d       	cpi	r18, 0xDB	; 219
     3e6:	85 e0       	ldi	r24, 0x05	; 5
     3e8:	38 07       	cpc	r19, r24
     3ea:	70 f4       	brcc	.+28     	; 0x408 <pvPortMalloc+0x54>
     3ec:	42 17       	cp	r20, r18
     3ee:	53 07       	cpc	r21, r19
     3f0:	70 f4       	brcc	.+28     	; 0x40e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3f2:	c0 91 94 02 	lds	r28, 0x0294
     3f6:	d0 91 95 02 	lds	r29, 0x0295
     3fa:	c4 0f       	add	r28, r20
     3fc:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     3fe:	30 93 97 02 	sts	0x0297, r19
     402:	20 93 96 02 	sts	0x0296, r18
     406:	05 c0       	rjmp	.+10     	; 0x412 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     408:	c0 e0       	ldi	r28, 0x00	; 0
     40a:	d0 e0       	ldi	r29, 0x00	; 0
     40c:	02 c0       	rjmp	.+4      	; 0x412 <pvPortMalloc+0x5e>
     40e:	c0 e0       	ldi	r28, 0x00	; 0
     410:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     412:	0e 94 76 0d 	call	0x1aec	; 0x1aec <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     416:	ce 01       	movw	r24, r28
     418:	df 91       	pop	r29
     41a:	cf 91       	pop	r28
     41c:	08 95       	ret

0000041e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     41e:	08 95       	ret

00000420 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     420:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     422:	03 96       	adiw	r24, 0x03	; 3
     424:	92 83       	std	Z+2, r25	; 0x02
     426:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     428:	2f ef       	ldi	r18, 0xFF	; 255
     42a:	3f ef       	ldi	r19, 0xFF	; 255
     42c:	34 83       	std	Z+4, r19	; 0x04
     42e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     430:	96 83       	std	Z+6, r25	; 0x06
     432:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     434:	90 87       	std	Z+8, r25	; 0x08
     436:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     438:	10 82       	st	Z, r1
     43a:	08 95       	ret

0000043c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     43c:	fc 01       	movw	r30, r24
     43e:	11 86       	std	Z+9, r1	; 0x09
     440:	10 86       	std	Z+8, r1	; 0x08
     442:	08 95       	ret

00000444 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     444:	cf 93       	push	r28
     446:	df 93       	push	r29
     448:	9c 01       	movw	r18, r24
     44a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     44c:	dc 01       	movw	r26, r24
     44e:	11 96       	adiw	r26, 0x01	; 1
     450:	cd 91       	ld	r28, X+
     452:	dc 91       	ld	r29, X
     454:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     456:	d3 83       	std	Z+3, r29	; 0x03
     458:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     45a:	8c 81       	ldd	r24, Y+4	; 0x04
     45c:	9d 81       	ldd	r25, Y+5	; 0x05
     45e:	95 83       	std	Z+5, r25	; 0x05
     460:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     462:	8c 81       	ldd	r24, Y+4	; 0x04
     464:	9d 81       	ldd	r25, Y+5	; 0x05
     466:	dc 01       	movw	r26, r24
     468:	13 96       	adiw	r26, 0x03	; 3
     46a:	7c 93       	st	X, r23
     46c:	6e 93       	st	-X, r22
     46e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     470:	7d 83       	std	Y+5, r23	; 0x05
     472:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     474:	31 87       	std	Z+9, r19	; 0x09
     476:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     478:	f9 01       	movw	r30, r18
     47a:	80 81       	ld	r24, Z
     47c:	8f 5f       	subi	r24, 0xFF	; 255
     47e:	80 83       	st	Z, r24
}
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     48c:	48 81       	ld	r20, Y
     48e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     490:	4f 3f       	cpi	r20, 0xFF	; 255
     492:	2f ef       	ldi	r18, 0xFF	; 255
     494:	52 07       	cpc	r21, r18
     496:	21 f4       	brne	.+8      	; 0x4a0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     498:	fc 01       	movw	r30, r24
     49a:	a7 81       	ldd	r26, Z+7	; 0x07
     49c:	b0 85       	ldd	r27, Z+8	; 0x08
     49e:	0d c0       	rjmp	.+26     	; 0x4ba <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4a0:	dc 01       	movw	r26, r24
     4a2:	13 96       	adiw	r26, 0x03	; 3
     4a4:	12 96       	adiw	r26, 0x02	; 2
     4a6:	ed 91       	ld	r30, X+
     4a8:	fc 91       	ld	r31, X
     4aa:	13 97       	sbiw	r26, 0x03	; 3
     4ac:	20 81       	ld	r18, Z
     4ae:	31 81       	ldd	r19, Z+1	; 0x01
     4b0:	42 17       	cp	r20, r18
     4b2:	53 07       	cpc	r21, r19
     4b4:	10 f0       	brcs	.+4      	; 0x4ba <vListInsert+0x34>
     4b6:	df 01       	movw	r26, r30
     4b8:	f5 cf       	rjmp	.-22     	; 0x4a4 <vListInsert+0x1e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4ba:	12 96       	adiw	r26, 0x02	; 2
     4bc:	ed 91       	ld	r30, X+
     4be:	fc 91       	ld	r31, X
     4c0:	13 97       	sbiw	r26, 0x03	; 3
     4c2:	fb 83       	std	Y+3, r31	; 0x03
     4c4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4c6:	d5 83       	std	Z+5, r29	; 0x05
     4c8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4ca:	bd 83       	std	Y+5, r27	; 0x05
     4cc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4ce:	13 96       	adiw	r26, 0x03	; 3
     4d0:	dc 93       	st	X, r29
     4d2:	ce 93       	st	-X, r28
     4d4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4d6:	99 87       	std	Y+9, r25	; 0x09
     4d8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4da:	fc 01       	movw	r30, r24
     4dc:	20 81       	ld	r18, Z
     4de:	2f 5f       	subi	r18, 0xFF	; 255
     4e0:	20 83       	st	Z, r18
}
     4e2:	df 91       	pop	r29
     4e4:	cf 91       	pop	r28
     4e6:	08 95       	ret

000004e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4e8:	cf 93       	push	r28
     4ea:	df 93       	push	r29
     4ec:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4ee:	a0 85       	ldd	r26, Z+8	; 0x08
     4f0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4f2:	c2 81       	ldd	r28, Z+2	; 0x02
     4f4:	d3 81       	ldd	r29, Z+3	; 0x03
     4f6:	84 81       	ldd	r24, Z+4	; 0x04
     4f8:	95 81       	ldd	r25, Z+5	; 0x05
     4fa:	9d 83       	std	Y+5, r25	; 0x05
     4fc:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4fe:	c4 81       	ldd	r28, Z+4	; 0x04
     500:	d5 81       	ldd	r29, Z+5	; 0x05
     502:	82 81       	ldd	r24, Z+2	; 0x02
     504:	93 81       	ldd	r25, Z+3	; 0x03
     506:	9b 83       	std	Y+3, r25	; 0x03
     508:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     50a:	11 96       	adiw	r26, 0x01	; 1
     50c:	cd 91       	ld	r28, X+
     50e:	dc 91       	ld	r29, X
     510:	12 97       	sbiw	r26, 0x02	; 2
     512:	ce 17       	cp	r28, r30
     514:	df 07       	cpc	r29, r31
     516:	31 f4       	brne	.+12     	; 0x524 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     518:	8c 81       	ldd	r24, Y+4	; 0x04
     51a:	9d 81       	ldd	r25, Y+5	; 0x05
     51c:	12 96       	adiw	r26, 0x02	; 2
     51e:	9c 93       	st	X, r25
     520:	8e 93       	st	-X, r24
     522:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     524:	11 86       	std	Z+9, r1	; 0x09
     526:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     528:	8c 91       	ld	r24, X
     52a:	81 50       	subi	r24, 0x01	; 1
     52c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     52e:	df 91       	pop	r29
     530:	cf 91       	pop	r28
     532:	08 95       	ret

00000534 <__vector_9>:
volatile int us_tickLapsed;
SemaphoreHandle_t semaReadReady;


ISR(PCINT0_vect) //Digital pin 50
{
     534:	1f 92       	push	r1
     536:	0f 92       	push	r0
     538:	0f b6       	in	r0, 0x3f	; 63
     53a:	0f 92       	push	r0
     53c:	11 24       	eor	r1, r1
     53e:	0b b6       	in	r0, 0x3b	; 59
     540:	0f 92       	push	r0
     542:	2f 93       	push	r18
     544:	3f 93       	push	r19
     546:	4f 93       	push	r20
     548:	5f 93       	push	r21
     54a:	6f 93       	push	r22
     54c:	7f 93       	push	r23
     54e:	8f 93       	push	r24
     550:	9f 93       	push	r25
     552:	af 93       	push	r26
     554:	bf 93       	push	r27
     556:	ef 93       	push	r30
     558:	ff 93       	push	r31
	if(HC_Echo_Read == 1)
     55a:	83 b1       	in	r24, 0x03	; 3
     55c:	13 b8       	out	0x03, r1	; 3
		us_tickStart = myTimer_Read();
		ms_tickStart = xTaskGetTickCountFromISR();
	}	
	else
	{
		if ((us_tickEnd = myTimer_Read()) < us_tickStart) // if smaller then add...
     55e:	4b d1       	rcall	.+662    	; 0x7f6 <myTimer_Read>
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	90 93 ea 08 	sts	0x08EA, r25
     566:	80 93 e9 08 	sts	0x08E9, r24
     56a:	20 91 e3 08 	lds	r18, 0x08E3
     56e:	30 91 e4 08 	lds	r19, 0x08E4
     572:	82 17       	cp	r24, r18
     574:	93 07       	cpc	r25, r19
     576:	54 f4       	brge	.+20     	; 0x58c <__vector_9+0x58>
			us_tickEnd += MAX_TICKS;
     578:	80 91 e9 08 	lds	r24, 0x08E9
     57c:	90 91 ea 08 	lds	r25, 0x08EA
     580:	86 50       	subi	r24, 0x06	; 6
     582:	9f 4f       	sbci	r25, 0xFF	; 255
     584:	90 93 ea 08 	sts	0x08EA, r25
     588:	80 93 e9 08 	sts	0x08E9, r24
			
		us_tickLapsed = myTimer_Read() - us_tickStart;
     58c:	34 d1       	rcall	.+616    	; 0x7f6 <myTimer_Read>
     58e:	20 91 e3 08 	lds	r18, 0x08E3
     592:	30 91 e4 08 	lds	r19, 0x08E4
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	82 1b       	sub	r24, r18
     59a:	93 0b       	sbc	r25, r19
     59c:	90 93 e6 08 	sts	0x08E6, r25
     5a0:	80 93 e5 08 	sts	0x08E5, r24
		ms_tickLapsed = xTaskGetTickCountFromISR() - ms_tickStart;
     5a4:	0e 94 b3 0c 	call	0x1966	; 0x1966 <xTaskGetTickCountFromISR>
     5a8:	20 91 df 08 	lds	r18, 0x08DF
     5ac:	30 91 e0 08 	lds	r19, 0x08E0
     5b0:	82 1b       	sub	r24, r18
     5b2:	93 0b       	sbc	r25, r19
     5b4:	90 93 e2 08 	sts	0x08E2, r25
     5b8:	80 93 e1 08 	sts	0x08E1, r24
		xSemaphoreGiveFromISR(semaReadReady, pdFALSE);
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	40 e0       	ldi	r20, 0x00	; 0
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	60 e0       	ldi	r22, 0x00	; 0
     5c4:	70 e0       	ldi	r23, 0x00	; 0
     5c6:	80 91 e7 08 	lds	r24, 0x08E7
     5ca:	90 91 e8 08 	lds	r25, 0x08E8
     5ce:	b1 d6       	rcall	.+3426   	; 0x1332 <xQueueGenericSendFromISR>
	}	
}
     5d0:	ff 91       	pop	r31
     5d2:	ef 91       	pop	r30
     5d4:	bf 91       	pop	r27
     5d6:	af 91       	pop	r26
     5d8:	9f 91       	pop	r25
     5da:	8f 91       	pop	r24
     5dc:	7f 91       	pop	r23
     5de:	6f 91       	pop	r22
     5e0:	5f 91       	pop	r21
     5e2:	4f 91       	pop	r20
     5e4:	3f 91       	pop	r19
     5e6:	2f 91       	pop	r18
     5e8:	0f 90       	pop	r0
     5ea:	0b be       	out	0x3b, r0	; 59
     5ec:	0f 90       	pop	r0
     5ee:	0f be       	out	0x3f, r0	; 63
     5f0:	0f 90       	pop	r0
     5f2:	1f 90       	pop	r1
     5f4:	18 95       	reti

000005f6 <myHcSonar_Init>:

void myHcSonar_Init()
{
	HC_Trigger_Init(); // set trigger as output
     5f6:	22 9a       	sbi	0x04, 2	; 4
	HC_Echo_Init(); // set echo as input
     5f8:	84 b1       	in	r24, 0x04	; 4
     5fa:	14 b8       	out	0x04, r1	; 4
		
	PCICR |= (1<<PCIE0); // enable control for PCINT 7:0
     5fc:	e8 e6       	ldi	r30, 0x68	; 104
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	80 81       	ld	r24, Z
     602:	81 60       	ori	r24, 0x01	; 1
     604:	80 83       	st	Z, r24
	PCMSK0 |= (1<<PCINT3); // set interrupt for PCINT3
     606:	eb e6       	ldi	r30, 0x6B	; 107
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	80 81       	ld	r24, Z
     60c:	88 60       	ori	r24, 0x08	; 8
     60e:	80 83       	st	Z, r24
	
	semaReadReady = xSemaphoreCreateBinary();
     610:	43 e0       	ldi	r20, 0x03	; 3
     612:	60 e0       	ldi	r22, 0x00	; 0
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	a8 d5       	rcall	.+2896   	; 0x1168 <xQueueGenericCreate>
     618:	90 93 e8 08 	sts	0x08E8, r25
     61c:	80 93 e7 08 	sts	0x08E7, r24
     620:	08 95       	ret

00000622 <myHcSonar_Start>:
}

void myHcSonar_Start()
{
	HcSonar_TriggerStart();
     622:	2a 9a       	sbi	0x05, 2	; 5
	
	myTimer_DelayMicro2(20); // delay 20 micro seconds for the pulse
     624:	84 e1       	ldi	r24, 0x14	; 20
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0c d1       	rcall	.+536    	; 0x842 <myTimer_DelayMicro2>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	HcSonar_TriggerStop();
     62a:	85 b1       	in	r24, 0x05	; 5
     62c:	15 b8       	out	0x05, r1	; 5
     62e:	08 95       	ret

00000630 <myHcSonar_Read>:

int myHcSonar_Read()
{
	int usLength, msLength;
	
	myHcSonar_Start();	
     630:	f8 df       	rcall	.-16     	; 0x622 <myHcSonar_Start>
	xSemaphoreTake(semaReadReady, 200);
     632:	20 e0       	ldi	r18, 0x00	; 0
     634:	48 ec       	ldi	r20, 0xC8	; 200
     636:	50 e0       	ldi	r21, 0x00	; 0
     638:	60 e0       	ldi	r22, 0x00	; 0
     63a:	70 e0       	ldi	r23, 0x00	; 0
     63c:	80 91 e7 08 	lds	r24, 0x08E7
     640:	90 91 e8 08 	lds	r25, 0x08E8
     644:	b0 d6       	rcall	.+3424   	; 0x13a6 <xQueueGenericReceive>
	
	usLength = us_tickLapsed / 14;
     646:	80 91 e5 08 	lds	r24, 0x08E5
     64a:	90 91 e6 08 	lds	r25, 0x08E6
	msLength = ms_tickLapsed * 17;
     64e:	20 91 e1 08 	lds	r18, 0x08E1
     652:	30 91 e2 08 	lds	r19, 0x08E2
	int usLength, msLength;
	
	myHcSonar_Start();	
	xSemaphoreTake(semaReadReady, 200);
	
	usLength = us_tickLapsed / 14;
     656:	6e e0       	ldi	r22, 0x0E	; 14
     658:	70 e0       	ldi	r23, 0x00	; 0
     65a:	0e 94 9e 10 	call	0x213c	; 0x213c <__divmodhi4>
	msLength = ms_tickLapsed * 17;
     65e:	41 e1       	ldi	r20, 0x11	; 17
     660:	42 9f       	mul	r20, r18
     662:	c0 01       	movw	r24, r0
     664:	43 9f       	mul	r20, r19
     666:	90 0d       	add	r25, r0
     668:	11 24       	eor	r1, r1
	return usLength + msLength;
	
     66a:	86 0f       	add	r24, r22
     66c:	97 1f       	adc	r25, r23
     66e:	08 95       	ret

00000670 <myMaxSonar_Start>:
#include <myADC.h>
#include <myTimer.h>

void myMaxSonar_Start()
{
	MaxSonar_TriggerStart();
     670:	a1 9a       	sbi	0x14, 1	; 20
	
	myTimer_DelayMicro(25); // delay 25 micro seconds...
     672:	89 e1       	ldi	r24, 0x19	; 25
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	c1 d0       	rcall	.+386    	; 0x7fa <myTimer_DelayMicro>
	//vTaskDelay(1);	// delay 1ms using vTaskDelay
	
	MaxSonar_TriggerStop();
     678:	84 b3       	in	r24, 0x14	; 20
     67a:	14 ba       	out	0x14, r1	; 20
     67c:	08 95       	ret

0000067e <myMaxSonar_Read>:
}

// Return distance in cm
int myMaxSonar_Read(char analogChannel)
{
	return myADC_analogRead(analogChannel) * valueToCM;
     67e:	9a d0       	rcall	.+308    	; 0x7b4 <myADC_analogRead>
     680:	90 e0       	ldi	r25, 0x00	; 0
     682:	9c 01       	movw	r18, r24
     684:	22 0f       	add	r18, r18
     686:	33 1f       	adc	r19, r19
     688:	22 0f       	add	r18, r18
     68a:	33 1f       	adc	r19, r19
}
     68c:	82 0f       	add	r24, r18
     68e:	93 1f       	adc	r25, r19
     690:	08 95       	ret

00000692 <__vector_29>:
volatile unsigned char adcReading;


/*ADC Conversion Complete Interrupt Service Routine (ISR)*/
ISR(ADC_vect)
{	
     692:	1f 92       	push	r1
     694:	0f 92       	push	r0
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	0f 92       	push	r0
     69a:	11 24       	eor	r1, r1
     69c:	0b b6       	in	r0, 0x3b	; 59
     69e:	0f 92       	push	r0
     6a0:	2f 93       	push	r18
     6a2:	3f 93       	push	r19
     6a4:	4f 93       	push	r20
     6a6:	5f 93       	push	r21
     6a8:	6f 93       	push	r22
     6aa:	7f 93       	push	r23
     6ac:	8f 93       	push	r24
     6ae:	9f 93       	push	r25
     6b0:	af 93       	push	r26
     6b2:	bf 93       	push	r27
     6b4:	ef 93       	push	r30
     6b6:	ff 93       	push	r31
	adcReading = ADCH; // read value
     6b8:	80 91 79 00 	lds	r24, 0x0079
     6bc:	80 93 eb 08 	sts	0x08EB, r24
	
	// give semaphore, dont run block task immediately..
	xSemaphoreGiveFromISR(semaReadADC, pdFALSE);
     6c0:	20 e0       	ldi	r18, 0x00	; 0
     6c2:	40 e0       	ldi	r20, 0x00	; 0
     6c4:	50 e0       	ldi	r21, 0x00	; 0
     6c6:	60 e0       	ldi	r22, 0x00	; 0
     6c8:	70 e0       	ldi	r23, 0x00	; 0
     6ca:	80 91 ee 08 	lds	r24, 0x08EE
     6ce:	90 91 ef 08 	lds	r25, 0x08EF
     6d2:	2f d6       	rcall	.+3166   	; 0x1332 <xQueueGenericSendFromISR>
}
     6d4:	ff 91       	pop	r31
     6d6:	ef 91       	pop	r30
     6d8:	bf 91       	pop	r27
     6da:	af 91       	pop	r26
     6dc:	9f 91       	pop	r25
     6de:	8f 91       	pop	r24
     6e0:	7f 91       	pop	r23
     6e2:	6f 91       	pop	r22
     6e4:	5f 91       	pop	r21
     6e6:	4f 91       	pop	r20
     6e8:	3f 91       	pop	r19
     6ea:	2f 91       	pop	r18
     6ec:	0f 90       	pop	r0
     6ee:	0b be       	out	0x3b, r0	; 59
     6f0:	0f 90       	pop	r0
     6f2:	0f be       	out	0x3f, r0	; 63
     6f4:	0f 90       	pop	r0
     6f6:	1f 90       	pop	r1
     6f8:	18 95       	reti

000006fa <myADC_Init>:

void myADC_Init()
{
	
	ADCSRA = ( 1<<ADEN ) | ( 1<<ADIE ) | ADC_PRESCALER; // enable ADC, enable interrupt, set prescaler
     6fa:	8f e8       	ldi	r24, 0x8F	; 143
     6fc:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0; // No auto trigger (0 for ADATE), No analog compare... 
     700:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = ( 1 << REFS0 ) | (1 << ADLAR ); // use AVCC as reference, Left adjust (dont need 2 LSB)
     704:	80 e6       	ldi	r24, 0x60	; 96
     706:	80 93 7c 00 	sts	0x007C, r24
	
	// initialize semaphore..
	semaReadADC = xSemaphoreCreateBinary();
     70a:	43 e0       	ldi	r20, 0x03	; 3
     70c:	60 e0       	ldi	r22, 0x00	; 0
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	2b d5       	rcall	.+2646   	; 0x1168 <xQueueGenericCreate>
     712:	90 93 ef 08 	sts	0x08EF, r25
     716:	80 93 ee 08 	sts	0x08EE, r24
	semaGuardStartADC = xSemaphoreCreateMutex();
     71a:	81 e0       	ldi	r24, 0x01	; 1
     71c:	e2 d5       	rcall	.+3012   	; 0x12e2 <xQueueCreateMutex>
     71e:	90 93 ed 08 	sts	0x08ED, r25
     722:	80 93 ec 08 	sts	0x08EC, r24
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
     726:	20 e0       	ldi	r18, 0x00	; 0
     728:	40 e0       	ldi	r20, 0x00	; 0
     72a:	50 e0       	ldi	r21, 0x00	; 0
     72c:	60 e0       	ldi	r22, 0x00	; 0
     72e:	70 e0       	ldi	r23, 0x00	; 0
     730:	45 c5       	rjmp	.+2698   	; 0x11bc <xQueueGenericSend>
     732:	08 95       	ret

00000734 <myADC_startADC>:
	return myADC_readADC(channel);
}

// channel = AN0 to AN15, use the macro...
void myADC_startADC(char channel)
{
     734:	cf 93       	push	r28
     736:	c8 2f       	mov	r28, r24
	
	 //char buffer [10];
	
	
	xSemaphoreTake(semaGuardStartADC, portMAX_DELAY);
     738:	20 e0       	ldi	r18, 0x00	; 0
     73a:	4f ef       	ldi	r20, 0xFF	; 255
     73c:	5f ef       	ldi	r21, 0xFF	; 255
     73e:	60 e0       	ldi	r22, 0x00	; 0
     740:	70 e0       	ldi	r23, 0x00	; 0
     742:	80 91 ec 08 	lds	r24, 0x08EC
     746:	90 91 ed 08 	lds	r25, 0x08ED
     74a:	2d d6       	rcall	.+3162   	; 0x13a6 <xQueueGenericReceive>
    ADMUX = ( ADMUX & 11100000 ) | ( channel & 0b00011111 ); // keep bit 5:7, set bit 0:4 as Mux
     74c:	ec e7       	ldi	r30, 0x7C	; 124
     74e:	f0 e0       	ldi	r31, 0x00	; 0
     750:	80 81       	ld	r24, Z
     752:	9c 2f       	mov	r25, r28
     754:	9f 71       	andi	r25, 0x1F	; 31
     756:	80 76       	andi	r24, 0x60	; 96
     758:	89 2b       	or	r24, r25
     75a:	80 83       	st	Z, r24
	
	//transmitUSART0("ADMUX = ");
	//transmitUSART0(itoa(ADMUX, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	
	ADCSRB = ( ADCSRB & 11100000 ) | (( channel & 0b00100000 ) >> 2); // keep all bits except bit 3, set Mux @ bit 3
     75c:	eb e7       	ldi	r30, 0x7B	; 123
     75e:	f0 e0       	ldi	r31, 0x00	; 0
     760:	20 81       	ld	r18, Z
     762:	c0 72       	andi	r28, 0x20	; 32
     764:	8c 2f       	mov	r24, r28
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	95 95       	asr	r25
     76a:	87 95       	ror	r24
     76c:	95 95       	asr	r25
     76e:	87 95       	ror	r24
     770:	92 2f       	mov	r25, r18
     772:	90 76       	andi	r25, 0x60	; 96
     774:	89 2b       	or	r24, r25
     776:	80 83       	st	Z, r24
	//transmitUSART0(itoa(ADCSRB, buffer, 2)); // debugging...
	//transmitUSART0(" \n");
	//
	
	//vTaskDelay(1);
	ADCSRA |= ( 1 << ADSC );	// READY TO SEND!!
     778:	ea e7       	ldi	r30, 0x7A	; 122
     77a:	f0 e0       	ldi	r31, 0x00	; 0
     77c:	80 81       	ld	r24, Z
     77e:	80 64       	ori	r24, 0x40	; 64
     780:	80 83       	st	Z, r24
}
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <myADC_readADC>:

unsigned char myADC_readADC(char channel)
{
	xSemaphoreTake(semaReadADC, portMAX_DELAY); // wait for reading...
     786:	20 e0       	ldi	r18, 0x00	; 0
     788:	4f ef       	ldi	r20, 0xFF	; 255
     78a:	5f ef       	ldi	r21, 0xFF	; 255
     78c:	60 e0       	ldi	r22, 0x00	; 0
     78e:	70 e0       	ldi	r23, 0x00	; 0
     790:	80 91 ee 08 	lds	r24, 0x08EE
     794:	90 91 ef 08 	lds	r25, 0x08EF
     798:	06 d6       	rcall	.+3084   	; 0x13a6 <xQueueGenericReceive>
	xSemaphoreGive(semaGuardStartADC); // reading done, nxt task can start ADC
     79a:	20 e0       	ldi	r18, 0x00	; 0
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	60 e0       	ldi	r22, 0x00	; 0
     7a2:	70 e0       	ldi	r23, 0x00	; 0
     7a4:	80 91 ec 08 	lds	r24, 0x08EC
     7a8:	90 91 ed 08 	lds	r25, 0x08ED
     7ac:	07 d5       	rcall	.+2574   	; 0x11bc <xQueueGenericSend>
	return adcReading;
     7ae:	80 91 eb 08 	lds	r24, 0x08EB
     7b2:	08 95       	ret

000007b4 <myADC_analogRead>:
	xSemaphoreGive(semaGuardStartADC); // free to read at start.
}


unsigned char myADC_analogRead(char channel)
{
     7b4:	cf 93       	push	r28
     7b6:	c8 2f       	mov	r28, r24
	myADC_startADC(channel);
     7b8:	bd df       	rcall	.-134    	; 0x734 <myADC_startADC>
	return myADC_readADC(channel);
     7ba:	8c 2f       	mov	r24, r28
     7bc:	e4 df       	rcall	.-56     	; 0x786 <myADC_readADC>
}
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <myTimer_Init>:

// timer task should be the highest priority....
// set taskHandle...
void myTimer_Init(TaskHandle_t *task)
{
	timerTask = task;
     7c2:	90 93 f5 08 	sts	0x08F5, r25
     7c6:	80 93 f4 08 	sts	0x08F4, r24
	vTaskSuspend(*timerTask); // suspend first not using delay micro
     7ca:	fc 01       	movw	r30, r24
     7cc:	80 81       	ld	r24, Z
     7ce:	91 81       	ldd	r25, Z+1	; 0x01
     7d0:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vTaskSuspend>
	semaDelayMicro = xSemaphoreCreateBinary();
     7d4:	43 e0       	ldi	r20, 0x03	; 3
     7d6:	60 e0       	ldi	r22, 0x00	; 0
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	c6 d4       	rcall	.+2444   	; 0x1168 <xQueueGenericCreate>
     7dc:	90 93 f1 08 	sts	0x08F1, r25
     7e0:	80 93 f0 08 	sts	0x08F0, r24
	semaDelayMicro2 = xSemaphoreCreateBinary();
     7e4:	43 e0       	ldi	r20, 0x03	; 3
     7e6:	60 e0       	ldi	r22, 0x00	; 0
     7e8:	81 e0       	ldi	r24, 0x01	; 1
     7ea:	be d4       	rcall	.+2428   	; 0x1168 <xQueueGenericCreate>
     7ec:	90 93 f3 08 	sts	0x08F3, r25
     7f0:	80 93 f2 08 	sts	0x08F2, r24
     7f4:	08 95       	ret

000007f6 <myTimer_Read>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7f6:	86 b5       	in	r24, 0x26	; 38
}
     7f8:	08 95       	ret

000007fa <myTimer_DelayMicro>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     7fa:	46 b5       	in	r20, 0x26	; 38
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick = currentTick + delay; 	
     7fc:	50 e0       	ldi	r21, 0x00	; 0
{
	// NOTE : Tick here refer to timer0 tick not FreeRtos tick (1ms)
	unsigned char currentTick = myTimer_Read();


	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     7fe:	9c 01       	movw	r18, r24
     800:	99 23       	and	r25, r25
     802:	14 f4       	brge	.+4      	; 0x808 <myTimer_DelayMicro+0xe>
     804:	2d 5f       	subi	r18, 0xFD	; 253
     806:	3f 4f       	sbci	r19, 0xFF	; 255
     808:	35 95       	asr	r19
     80a:	27 95       	ror	r18
     80c:	35 95       	asr	r19
     80e:	27 95       	ror	r18
	expectedTick = currentTick + delay; 	
     810:	24 0f       	add	r18, r20
     812:	35 1f       	adc	r19, r21
     814:	30 93 03 02 	sts	0x0203, r19
     818:	20 93 02 02 	sts	0x0202, r18
	
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     81c:	e0 91 f4 08 	lds	r30, 0x08F4
     820:	f0 91 f5 08 	lds	r31, 0x08F5
     824:	80 81       	ld	r24, Z
     826:	91 81       	ldd	r25, Z+1	; 0x01
     828:	0e 94 2f 0c 	call	0x185e	; 0x185e <vTaskResume>
	xSemaphoreTake(semaDelayMicro, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     82c:	20 e0       	ldi	r18, 0x00	; 0
     82e:	42 e0       	ldi	r20, 0x02	; 2
     830:	50 e0       	ldi	r21, 0x00	; 0
     832:	60 e0       	ldi	r22, 0x00	; 0
     834:	70 e0       	ldi	r23, 0x00	; 0
     836:	80 91 f0 08 	lds	r24, 0x08F0
     83a:	90 91 f1 08 	lds	r25, 0x08F1
     83e:	b3 c5       	rjmp	.+2918   	; 0x13a6 <xQueueGenericReceive>
     840:	08 95       	ret

00000842 <myTimer_DelayMicro2>:
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     842:	46 b5       	in	r20, 0x26	; 38
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
	expectedTick2 = currentTick + delay; 
     844:	50 e0       	ldi	r21, 0x00	; 0
// duplicate of delayMicro....
void myTimer_DelayMicro2(int delay)
{
	unsigned char currentTick = myTimer_Read();

	delay /= MICROSECONDS_PER_TICK; // convert delay into ticks..
     846:	9c 01       	movw	r18, r24
     848:	99 23       	and	r25, r25
     84a:	14 f4       	brge	.+4      	; 0x850 <myTimer_DelayMicro2+0xe>
     84c:	2d 5f       	subi	r18, 0xFD	; 253
     84e:	3f 4f       	sbci	r19, 0xFF	; 255
     850:	35 95       	asr	r19
     852:	27 95       	ror	r18
     854:	35 95       	asr	r19
     856:	27 95       	ror	r18
	expectedTick2 = currentTick + delay; 
     858:	24 0f       	add	r18, r20
     85a:	35 1f       	adc	r19, r21
     85c:	30 93 01 02 	sts	0x0201, r19
     860:	20 93 00 02 	sts	0x0200, r18
	vTaskResume( *timerTask ); // resume delayMicroCheck..
     864:	e0 91 f4 08 	lds	r30, 0x08F4
     868:	f0 91 f5 08 	lds	r31, 0x08F5
     86c:	80 81       	ld	r24, Z
     86e:	91 81       	ldd	r25, Z+1	; 0x01
     870:	f6 d7       	rcall	.+4076   	; 0x185e <vTaskResume>
	xSemaphoreTake(semaDelayMicro2, MAX_SEMA_WAIT);	// delay for the micro here... safety mech: max wait for 2 ms... cannot be more than tht..
     872:	20 e0       	ldi	r18, 0x00	; 0
     874:	42 e0       	ldi	r20, 0x02	; 2
     876:	50 e0       	ldi	r21, 0x00	; 0
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	70 e0       	ldi	r23, 0x00	; 0
     87c:	80 91 f2 08 	lds	r24, 0x08F2
     880:	90 91 f3 08 	lds	r25, 0x08F3
     884:	90 c5       	rjmp	.+2848   	; 0x13a6 <xQueueGenericReceive>
     886:	08 95       	ret

00000888 <myTimer_DelayChecker>:
}

// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
}

// Return timer 0 value
unsigned char myTimer_Read()
{
	return TCNT0;
     88c:	c6 b5       	in	r28, 0x26	; 38
// Semaphore on sale if u match lucky number ...
void myTimer_DelayChecker()
{
	unsigned char currentTick = myTimer_Read();
	
	if(currentTick == 0) // overflow happened
     88e:	c1 11       	cpse	r28, r1
     890:	22 c0       	rjmp	.+68     	; 0x8d6 <myTimer_DelayChecker+0x4e>
	{
		if(expectedTick != IMPOSSIBLE_RANGE)
     892:	80 91 02 02 	lds	r24, 0x0202
     896:	90 91 03 02 	lds	r25, 0x0203
     89a:	88 38       	cpi	r24, 0x88	; 136
     89c:	93 41       	sbci	r25, 0x13	; 19
     89e:	51 f0       	breq	.+20     	; 0x8b4 <myTimer_DelayChecker+0x2c>
			expectedTick -= MAX_TICKS;
     8a0:	80 91 02 02 	lds	r24, 0x0202
     8a4:	90 91 03 02 	lds	r25, 0x0203
     8a8:	8a 5f       	subi	r24, 0xFA	; 250
     8aa:	91 09       	sbc	r25, r1
     8ac:	90 93 03 02 	sts	0x0203, r25
     8b0:	80 93 02 02 	sts	0x0202, r24

		if(expectedTick2 != IMPOSSIBLE_RANGE)
     8b4:	80 91 00 02 	lds	r24, 0x0200
     8b8:	90 91 01 02 	lds	r25, 0x0201
     8bc:	88 38       	cpi	r24, 0x88	; 136
     8be:	93 41       	sbci	r25, 0x13	; 19
     8c0:	51 f0       	breq	.+20     	; 0x8d6 <myTimer_DelayChecker+0x4e>
			expectedTick2 -= MAX_TICKS;
     8c2:	80 91 00 02 	lds	r24, 0x0200
     8c6:	90 91 01 02 	lds	r25, 0x0201
     8ca:	8a 5f       	subi	r24, 0xFA	; 250
     8cc:	91 09       	sbc	r25, r1
     8ce:	90 93 01 02 	sts	0x0201, r25
     8d2:	80 93 00 02 	sts	0x0200, r24
	}
	
	if( currentTick > expectedTick) // more than => 1 more tick => positive error..
     8d6:	d0 e0       	ldi	r29, 0x00	; 0
     8d8:	80 91 02 02 	lds	r24, 0x0202
     8dc:	90 91 03 02 	lds	r25, 0x0203
     8e0:	8c 17       	cp	r24, r28
     8e2:	9d 07       	cpc	r25, r29
     8e4:	84 f4       	brge	.+32     	; 0x906 <myTimer_DelayChecker+0x7e>
	{
		expectedTick = IMPOSSIBLE_RANGE; // set back to impossible range.
     8e6:	88 e8       	ldi	r24, 0x88	; 136
     8e8:	93 e1       	ldi	r25, 0x13	; 19
     8ea:	90 93 03 02 	sts	0x0203, r25
     8ee:	80 93 02 02 	sts	0x0202, r24
		xSemaphoreGive(semaDelayMicro); // give the semaphore to resume...	
     8f2:	20 e0       	ldi	r18, 0x00	; 0
     8f4:	40 e0       	ldi	r20, 0x00	; 0
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	80 91 f0 08 	lds	r24, 0x08F0
     900:	90 91 f1 08 	lds	r25, 0x08F1
     904:	5b d4       	rcall	.+2230   	; 0x11bc <xQueueGenericSend>
	}
	
	
	if( currentTick > expectedTick2) // more than => 1 more tick => positive error..
     906:	80 91 00 02 	lds	r24, 0x0200
     90a:	90 91 01 02 	lds	r25, 0x0201
     90e:	8c 17       	cp	r24, r28
     910:	9d 07       	cpc	r25, r29
     912:	84 f4       	brge	.+32     	; 0x934 <myTimer_DelayChecker+0xac>
	{
		expectedTick2 = IMPOSSIBLE_RANGE; // set back to impossible range.
     914:	88 e8       	ldi	r24, 0x88	; 136
     916:	93 e1       	ldi	r25, 0x13	; 19
     918:	90 93 01 02 	sts	0x0201, r25
     91c:	80 93 00 02 	sts	0x0200, r24
		xSemaphoreGive(semaDelayMicro2); // give the semaphore to resume...
     920:	20 e0       	ldi	r18, 0x00	; 0
     922:	40 e0       	ldi	r20, 0x00	; 0
     924:	50 e0       	ldi	r21, 0x00	; 0
     926:	60 e0       	ldi	r22, 0x00	; 0
     928:	70 e0       	ldi	r23, 0x00	; 0
     92a:	80 91 f2 08 	lds	r24, 0x08F2
     92e:	90 91 f3 08 	lds	r25, 0x08F3
     932:	44 d4       	rcall	.+2184   	; 0x11bc <xQueueGenericSend>
	}
	
	if(expectedTick == IMPOSSIBLE_RANGE && expectedTick2 == IMPOSSIBLE_RANGE)
     934:	80 91 02 02 	lds	r24, 0x0202
     938:	90 91 03 02 	lds	r25, 0x0203
     93c:	88 38       	cpi	r24, 0x88	; 136
     93e:	93 41       	sbci	r25, 0x13	; 19
     940:	79 f4       	brne	.+30     	; 0x960 <myTimer_DelayChecker+0xd8>
     942:	80 91 00 02 	lds	r24, 0x0200
     946:	90 91 01 02 	lds	r25, 0x0201
     94a:	88 38       	cpi	r24, 0x88	; 136
     94c:	93 41       	sbci	r25, 0x13	; 19
     94e:	41 f4       	brne	.+16     	; 0x960 <myTimer_DelayChecker+0xd8>
	{
		vTaskSuspend(*timerTask); // suspend when both is done..
     950:	e0 91 f4 08 	lds	r30, 0x08F4
     954:	f0 91 f5 08 	lds	r31, 0x08F5
     958:	80 81       	ld	r24, Z
     95a:	91 81       	ldd	r25, Z+1	; 0x01
     95c:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vTaskSuspend>
	}
     960:	df 91       	pop	r29
     962:	cf 91       	pop	r28
     964:	08 95       	ret

00000966 <__vector_36>:
	{
		xSemaphoreGive(semaUsart0Receive);
	}
	
	return data;
}
     966:	1f 92       	push	r1
     968:	0f 92       	push	r0
     96a:	0f b6       	in	r0, 0x3f	; 63
     96c:	0f 92       	push	r0
     96e:	11 24       	eor	r1, r1
     970:	0b b6       	in	r0, 0x3b	; 59
     972:	0f 92       	push	r0
     974:	2f 93       	push	r18
     976:	3f 93       	push	r19
     978:	4f 93       	push	r20
     97a:	5f 93       	push	r21
     97c:	6f 93       	push	r22
     97e:	7f 93       	push	r23
     980:	8f 93       	push	r24
     982:	9f 93       	push	r25
     984:	af 93       	push	r26
     986:	bf 93       	push	r27
     988:	ef 93       	push	r30
     98a:	ff 93       	push	r31
     98c:	60 91 ce 00 	lds	r22, 0x00CE
     990:	89 e8       	ldi	r24, 0x89	; 137
     992:	99 e0       	ldi	r25, 0x09	; 9
     994:	d4 d5       	rcall	.+2984   	; 0x153e <ringBufferPush>
     996:	20 e0       	ldi	r18, 0x00	; 0
     998:	40 e0       	ldi	r20, 0x00	; 0
     99a:	50 e0       	ldi	r21, 0x00	; 0
     99c:	60 e0       	ldi	r22, 0x00	; 0
     99e:	70 e0       	ldi	r23, 0x00	; 0
     9a0:	80 91 7d 09 	lds	r24, 0x097D
     9a4:	90 91 7e 09 	lds	r25, 0x097E
     9a8:	c4 d4       	rcall	.+2440   	; 0x1332 <xQueueGenericSendFromISR>
     9aa:	89 e8       	ldi	r24, 0x89	; 137
     9ac:	99 e0       	ldi	r25, 0x09	; 9
     9ae:	dd d5       	rcall	.+3002   	; 0x156a <ringBufferFull>
     9b0:	ff 91       	pop	r31
     9b2:	ef 91       	pop	r30
     9b4:	bf 91       	pop	r27
     9b6:	af 91       	pop	r26
     9b8:	9f 91       	pop	r25
     9ba:	8f 91       	pop	r24
     9bc:	7f 91       	pop	r23
     9be:	6f 91       	pop	r22
     9c0:	5f 91       	pop	r21
     9c2:	4f 91       	pop	r20
     9c4:	3f 91       	pop	r19
     9c6:	2f 91       	pop	r18
     9c8:	0f 90       	pop	r0
     9ca:	0b be       	out	0x3b, r0	; 59
     9cc:	0f 90       	pop	r0
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	0f 90       	pop	r0
     9d2:	1f 90       	pop	r1
     9d4:	18 95       	reti

000009d6 <__vector_25>:
     9d6:	1f 92       	push	r1
     9d8:	0f 92       	push	r0
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	0f 92       	push	r0
     9de:	11 24       	eor	r1, r1
     9e0:	0b b6       	in	r0, 0x3b	; 59
     9e2:	0f 92       	push	r0
     9e4:	2f 93       	push	r18
     9e6:	3f 93       	push	r19
     9e8:	4f 93       	push	r20
     9ea:	5f 93       	push	r21
     9ec:	6f 93       	push	r22
     9ee:	7f 93       	push	r23
     9f0:	8f 93       	push	r24
     9f2:	9f 93       	push	r25
     9f4:	af 93       	push	r26
     9f6:	bf 93       	push	r27
     9f8:	ef 93       	push	r30
     9fa:	ff 93       	push	r31
     9fc:	60 91 c6 00 	lds	r22, 0x00C6
     a00:	86 e1       	ldi	r24, 0x16	; 22
     a02:	99 e0       	ldi	r25, 0x09	; 9
     a04:	9c d5       	rcall	.+2872   	; 0x153e <ringBufferPush>
     a06:	20 e0       	ldi	r18, 0x00	; 0
     a08:	40 e0       	ldi	r20, 0x00	; 0
     a0a:	50 e0       	ldi	r21, 0x00	; 0
     a0c:	60 e0       	ldi	r22, 0x00	; 0
     a0e:	70 e0       	ldi	r23, 0x00	; 0
     a10:	80 91 7d 09 	lds	r24, 0x097D
     a14:	90 91 7e 09 	lds	r25, 0x097E
     a18:	8c d4       	rcall	.+2328   	; 0x1332 <xQueueGenericSendFromISR>
     a1a:	86 e1       	ldi	r24, 0x16	; 22
     a1c:	99 e0       	ldi	r25, 0x09	; 9
     a1e:	a5 d5       	rcall	.+2890   	; 0x156a <ringBufferFull>
     a20:	ff 91       	pop	r31
     a22:	ef 91       	pop	r30
     a24:	bf 91       	pop	r27
     a26:	af 91       	pop	r26
     a28:	9f 91       	pop	r25
     a2a:	8f 91       	pop	r24
     a2c:	7f 91       	pop	r23
     a2e:	6f 91       	pop	r22
     a30:	5f 91       	pop	r21
     a32:	4f 91       	pop	r20
     a34:	3f 91       	pop	r19
     a36:	2f 91       	pop	r18
     a38:	0f 90       	pop	r0
     a3a:	0b be       	out	0x3b, r0	; 59
     a3c:	0f 90       	pop	r0
     a3e:	0f be       	out	0x3f, r0	; 63
     a40:	0f 90       	pop	r0
     a42:	1f 90       	pop	r1
     a44:	18 95       	reti

00000a46 <__vector_37>:
     a46:	1f 92       	push	r1
     a48:	0f 92       	push	r0
     a4a:	0f b6       	in	r0, 0x3f	; 63
     a4c:	0f 92       	push	r0
     a4e:	11 24       	eor	r1, r1
     a50:	0b b6       	in	r0, 0x3b	; 59
     a52:	0f 92       	push	r0
     a54:	2f 93       	push	r18
     a56:	3f 93       	push	r19
     a58:	4f 93       	push	r20
     a5a:	5f 93       	push	r21
     a5c:	6f 93       	push	r22
     a5e:	7f 93       	push	r23
     a60:	8f 93       	push	r24
     a62:	9f 93       	push	r25
     a64:	af 93       	push	r26
     a66:	bf 93       	push	r27
     a68:	ef 93       	push	r30
     a6a:	ff 93       	push	r31
     a6c:	8f e7       	ldi	r24, 0x7F	; 127
     a6e:	99 e0       	ldi	r25, 0x09	; 9
     a70:	83 d5       	rcall	.+2822   	; 0x1578 <ringBufferNotEmpty>
     a72:	88 23       	and	r24, r24
     a74:	31 f0       	breq	.+12     	; 0xa82 <__vector_37+0x3c>
     a76:	8f e7       	ldi	r24, 0x7F	; 127
     a78:	99 e0       	ldi	r25, 0x09	; 9
     a7a:	4f d5       	rcall	.+2718   	; 0x151a <ringBufferPop>
     a7c:	80 93 ce 00 	sts	0x00CE, r24
     a80:	05 c0       	rjmp	.+10     	; 0xa8c <__vector_37+0x46>
     a82:	e9 ec       	ldi	r30, 0xC9	; 201
     a84:	f0 e0       	ldi	r31, 0x00	; 0
     a86:	80 81       	ld	r24, Z
     a88:	8f 7d       	andi	r24, 0xDF	; 223
     a8a:	80 83       	st	Z, r24
     a8c:	ff 91       	pop	r31
     a8e:	ef 91       	pop	r30
     a90:	bf 91       	pop	r27
     a92:	af 91       	pop	r26
     a94:	9f 91       	pop	r25
     a96:	8f 91       	pop	r24
     a98:	7f 91       	pop	r23
     a9a:	6f 91       	pop	r22
     a9c:	5f 91       	pop	r21
     a9e:	4f 91       	pop	r20
     aa0:	3f 91       	pop	r19
     aa2:	2f 91       	pop	r18
     aa4:	0f 90       	pop	r0
     aa6:	0b be       	out	0x3b, r0	; 59
     aa8:	0f 90       	pop	r0
     aaa:	0f be       	out	0x3f, r0	; 63
     aac:	0f 90       	pop	r0
     aae:	1f 90       	pop	r1
     ab0:	18 95       	reti

00000ab2 <__vector_26>:
     ab2:	1f 92       	push	r1
     ab4:	0f 92       	push	r0
     ab6:	0f b6       	in	r0, 0x3f	; 63
     ab8:	0f 92       	push	r0
     aba:	11 24       	eor	r1, r1
     abc:	0b b6       	in	r0, 0x3b	; 59
     abe:	0f 92       	push	r0
     ac0:	2f 93       	push	r18
     ac2:	3f 93       	push	r19
     ac4:	4f 93       	push	r20
     ac6:	5f 93       	push	r21
     ac8:	6f 93       	push	r22
     aca:	7f 93       	push	r23
     acc:	8f 93       	push	r24
     ace:	9f 93       	push	r25
     ad0:	af 93       	push	r26
     ad2:	bf 93       	push	r27
     ad4:	ef 93       	push	r30
     ad6:	ff 93       	push	r31
     ad8:	84 e8       	ldi	r24, 0x84	; 132
     ada:	99 e0       	ldi	r25, 0x09	; 9
     adc:	4d d5       	rcall	.+2714   	; 0x1578 <ringBufferNotEmpty>
     ade:	88 23       	and	r24, r24
     ae0:	31 f0       	breq	.+12     	; 0xaee <__vector_26+0x3c>
     ae2:	84 e8       	ldi	r24, 0x84	; 132
     ae4:	99 e0       	ldi	r25, 0x09	; 9
     ae6:	19 d5       	rcall	.+2610   	; 0x151a <ringBufferPop>
     ae8:	80 93 c6 00 	sts	0x00C6, r24
     aec:	05 c0       	rjmp	.+10     	; 0xaf8 <__vector_26+0x46>
     aee:	e1 ec       	ldi	r30, 0xC1	; 193
     af0:	f0 e0       	ldi	r31, 0x00	; 0
     af2:	80 81       	ld	r24, Z
     af4:	8f 7d       	andi	r24, 0xDF	; 223
     af6:	80 83       	st	Z, r24
     af8:	ff 91       	pop	r31
     afa:	ef 91       	pop	r30
     afc:	bf 91       	pop	r27
     afe:	af 91       	pop	r26
     b00:	9f 91       	pop	r25
     b02:	8f 91       	pop	r24
     b04:	7f 91       	pop	r23
     b06:	6f 91       	pop	r22
     b08:	5f 91       	pop	r21
     b0a:	4f 91       	pop	r20
     b0c:	3f 91       	pop	r19
     b0e:	2f 91       	pop	r18
     b10:	0f 90       	pop	r0
     b12:	0b be       	out	0x3b, r0	; 59
     b14:	0f 90       	pop	r0
     b16:	0f be       	out	0x3f, r0	; 63
     b18:	0f 90       	pop	r0
     b1a:	1f 90       	pop	r1
     b1c:	18 95       	reti

00000b1e <myUSART_USART0_Init>:
     b1e:	10 92 c5 00 	sts	0x00C5, r1
     b22:	87 e6       	ldi	r24, 0x67	; 103
     b24:	80 93 c4 00 	sts	0x00C4, r24
     b28:	88 eb       	ldi	r24, 0xB8	; 184
     b2a:	80 93 c1 00 	sts	0x00C1, r24
     b2e:	86 e0       	ldi	r24, 0x06	; 6
     b30:	80 93 c2 00 	sts	0x00C2, r24
     b34:	40 e2       	ldi	r20, 0x20	; 32
     b36:	6b e3       	ldi	r22, 0x3B	; 59
     b38:	79 e0       	ldi	r23, 0x09	; 9
     b3a:	86 e1       	ldi	r24, 0x16	; 22
     b3c:	99 e0       	ldi	r25, 0x09	; 9
     b3e:	e6 d4       	rcall	.+2508   	; 0x150c <ringBufferInit>
     b40:	40 e2       	ldi	r20, 0x20	; 32
     b42:	6b e1       	ldi	r22, 0x1B	; 27
     b44:	79 e0       	ldi	r23, 0x09	; 9
     b46:	84 e8       	ldi	r24, 0x84	; 132
     b48:	99 e0       	ldi	r25, 0x09	; 9
     b4a:	e0 d4       	rcall	.+2496   	; 0x150c <ringBufferInit>
     b4c:	43 e0       	ldi	r20, 0x03	; 3
     b4e:	60 e0       	ldi	r22, 0x00	; 0
     b50:	81 e0       	ldi	r24, 0x01	; 1
     b52:	0a d3       	rcall	.+1556   	; 0x1168 <xQueueGenericCreate>
     b54:	90 93 7c 09 	sts	0x097C, r25
     b58:	80 93 7b 09 	sts	0x097B, r24
     b5c:	08 95       	ret

00000b5e <myUSART_USART1_Init>:
     b5e:	10 92 cd 00 	sts	0x00CD, r1
     b62:	87 e6       	ldi	r24, 0x67	; 103
     b64:	80 93 cc 00 	sts	0x00CC, r24
     b68:	88 eb       	ldi	r24, 0xB8	; 184
     b6a:	80 93 c9 00 	sts	0x00C9, r24
     b6e:	86 e0       	ldi	r24, 0x06	; 6
     b70:	80 93 ca 00 	sts	0x00CA, r24
     b74:	40 e2       	ldi	r20, 0x20	; 32
     b76:	66 ef       	ldi	r22, 0xF6	; 246
     b78:	78 e0       	ldi	r23, 0x08	; 8
     b7a:	89 e8       	ldi	r24, 0x89	; 137
     b7c:	99 e0       	ldi	r25, 0x09	; 9
     b7e:	c6 d4       	rcall	.+2444   	; 0x150c <ringBufferInit>
     b80:	40 e2       	ldi	r20, 0x20	; 32
     b82:	6b e5       	ldi	r22, 0x5B	; 91
     b84:	79 e0       	ldi	r23, 0x09	; 9
     b86:	8f e7       	ldi	r24, 0x7F	; 127
     b88:	99 e0       	ldi	r25, 0x09	; 9
     b8a:	c0 d4       	rcall	.+2432   	; 0x150c <ringBufferInit>
     b8c:	43 e0       	ldi	r20, 0x03	; 3
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	81 e0       	ldi	r24, 0x01	; 1
     b92:	ea d2       	rcall	.+1492   	; 0x1168 <xQueueGenericCreate>
     b94:	90 93 7e 09 	sts	0x097E, r25
     b98:	80 93 7d 09 	sts	0x097D, r24
     b9c:	08 95       	ret

00000b9e <myUSART_transmitUSART0_c>:
     b9e:	cf 93       	push	r28
     ba0:	c8 2f       	mov	r28, r24
     ba2:	84 e8       	ldi	r24, 0x84	; 132
     ba4:	99 e0       	ldi	r25, 0x09	; 9
     ba6:	e1 d4       	rcall	.+2498   	; 0x156a <ringBufferFull>
     ba8:	81 11       	cpse	r24, r1
     baa:	fb cf       	rjmp	.-10     	; 0xba2 <myUSART_transmitUSART0_c+0x4>
     bac:	6c 2f       	mov	r22, r28
     bae:	84 e8       	ldi	r24, 0x84	; 132
     bb0:	99 e0       	ldi	r25, 0x09	; 9
     bb2:	c5 d4       	rcall	.+2442   	; 0x153e <ringBufferPush>
     bb4:	e1 ec       	ldi	r30, 0xC1	; 193
     bb6:	f0 e0       	ldi	r31, 0x00	; 0
     bb8:	80 81       	ld	r24, Z
     bba:	80 62       	ori	r24, 0x20	; 32
     bbc:	80 83       	st	Z, r24
     bbe:	e0 ec       	ldi	r30, 0xC0	; 192
     bc0:	f0 e0       	ldi	r31, 0x00	; 0
     bc2:	80 81       	ld	r24, Z
     bc4:	80 64       	ori	r24, 0x40	; 64
     bc6:	80 83       	st	Z, r24
     bc8:	cf 91       	pop	r28
     bca:	08 95       	ret

00000bcc <myUSART_transmitUSART1_c>:
     bcc:	cf 93       	push	r28
     bce:	c8 2f       	mov	r28, r24
     bd0:	8f e7       	ldi	r24, 0x7F	; 127
     bd2:	99 e0       	ldi	r25, 0x09	; 9
     bd4:	ca d4       	rcall	.+2452   	; 0x156a <ringBufferFull>
     bd6:	81 11       	cpse	r24, r1
     bd8:	fb cf       	rjmp	.-10     	; 0xbd0 <myUSART_transmitUSART1_c+0x4>
     bda:	6c 2f       	mov	r22, r28
     bdc:	8f e7       	ldi	r24, 0x7F	; 127
     bde:	99 e0       	ldi	r25, 0x09	; 9
     be0:	ae d4       	rcall	.+2396   	; 0x153e <ringBufferPush>
     be2:	e9 ec       	ldi	r30, 0xC9	; 201
     be4:	f0 e0       	ldi	r31, 0x00	; 0
     be6:	80 81       	ld	r24, Z
     be8:	80 62       	ori	r24, 0x20	; 32
     bea:	80 83       	st	Z, r24
     bec:	e8 ec       	ldi	r30, 0xC8	; 200
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	80 81       	ld	r24, Z
     bf2:	80 64       	ori	r24, 0x40	; 64
     bf4:	80 83       	st	Z, r24
     bf6:	cf 91       	pop	r28
     bf8:	08 95       	ret

00000bfa <myUSART_transmitUSART0>:
     bfa:	cf 93       	push	r28
     bfc:	df 93       	push	r29
     bfe:	ec 01       	movw	r28, r24
     c00:	88 81       	ld	r24, Y
     c02:	88 23       	and	r24, r24
     c04:	29 f0       	breq	.+10     	; 0xc10 <myUSART_transmitUSART0+0x16>
     c06:	21 96       	adiw	r28, 0x01	; 1
     c08:	ca df       	rcall	.-108    	; 0xb9e <myUSART_transmitUSART0_c>
     c0a:	89 91       	ld	r24, Y+
     c0c:	81 11       	cpse	r24, r1
     c0e:	fc cf       	rjmp	.-8      	; 0xc08 <myUSART_transmitUSART0+0xe>
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	08 95       	ret

00000c16 <myUSART_receiveUSART1>:
     c16:	cf 93       	push	r28
     c18:	20 e0       	ldi	r18, 0x00	; 0
     c1a:	4f ef       	ldi	r20, 0xFF	; 255
     c1c:	5f ef       	ldi	r21, 0xFF	; 255
     c1e:	60 e0       	ldi	r22, 0x00	; 0
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	80 91 7b 09 	lds	r24, 0x097B
     c26:	90 91 7c 09 	lds	r25, 0x097C
     c2a:	bd d3       	rcall	.+1914   	; 0x13a6 <xQueueGenericReceive>
     c2c:	89 e8       	ldi	r24, 0x89	; 137
     c2e:	99 e0       	ldi	r25, 0x09	; 9
     c30:	74 d4       	rcall	.+2280   	; 0x151a <ringBufferPop>
     c32:	c8 2f       	mov	r28, r24
     c34:	89 e8       	ldi	r24, 0x89	; 137
     c36:	99 e0       	ldi	r25, 0x09	; 9
     c38:	9f d4       	rcall	.+2366   	; 0x1578 <ringBufferNotEmpty>
     c3a:	88 23       	and	r24, r24
     c3c:	51 f0       	breq	.+20     	; 0xc52 <myUSART_receiveUSART1+0x3c>
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	40 e0       	ldi	r20, 0x00	; 0
     c42:	50 e0       	ldi	r21, 0x00	; 0
     c44:	60 e0       	ldi	r22, 0x00	; 0
     c46:	70 e0       	ldi	r23, 0x00	; 0
     c48:	80 91 7b 09 	lds	r24, 0x097B
     c4c:	90 91 7c 09 	lds	r25, 0x097C
     c50:	b5 d2       	rcall	.+1386   	; 0x11bc <xQueueGenericSend>
     c52:	8c 2f       	mov	r24, r28
     c54:	cf 91       	pop	r28
     c56:	08 95       	ret

00000c58 <myUSART_startHandShake>:

// -1 if fail, 0 success
char myUSART_startHandShake()
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	b8 df       	rcall	.-144    	; 0xbcc <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
     c5c:	dc df       	rcall	.-72     	; 0xc16 <myUSART_receiveUSART1>
     c5e:	85 35       	cpi	r24, 0x55	; 85
     c60:	21 f4       	brne	.+8      	; 0xc6a <myUSART_startHandShake+0x12>
	{
		return -1; //error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
     c62:	8f ef       	ldi	r24, 0xFF	; 255
     c64:	b3 df       	rcall	.-154    	; 0xbcc <myUSART_transmitUSART1_c>
	
	return 0;
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	08 95       	ret
{
	myUSART_transmitUSART1_c(HANDSHAKE_START);
	
	if (! myUSART_receiveHandShakeAck(myUSART_receiveUSART1()))
	{
		return -1; //error handling
     c6a:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_FIN);
	
	return 0;
}
     c6c:	08 95       	ret

00000c6e <myUSART_waitForHandshake>:


// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c6e:	d3 df       	rcall	.-90     	; 0xc16 <myUSART_receiveUSART1>
     c70:	81 11       	cpse	r24, r1
     c72:	0a c0       	rjmp	.+20     	; 0xc88 <myUSART_waitForHandshake+0x1a>
	{
		return -1; // error handling
	}
	
	myUSART_transmitUSART1_c(HANDSHAKE_ACK);
     c74:	85 e5       	ldi	r24, 0x55	; 85
     c76:	aa df       	rcall	.-172    	; 0xbcc <myUSART_transmitUSART1_c>
	
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
     c78:	ce df       	rcall	.-100    	; 0xc16 <myUSART_receiveUSART1>
     c7a:	91 e0       	ldi	r25, 0x01	; 1
     c7c:	81 11       	cpse	r24, r1
     c7e:	01 c0       	rjmp	.+2      	; 0xc82 <myUSART_waitForHandshake+0x14>
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	89 2f       	mov	r24, r25
     c84:	81 95       	neg	r24
     c86:	08 95       	ret
// -1 if fail, 0 success
char myUSART_waitForHandshake()
{
	if (! myUSART_receiveHandShakeStart(myUSART_receiveUSART1()))
	{
		return -1; // error handling
     c88:	8f ef       	ldi	r24, 0xFF	; 255
	{
		return -1; // error handling
	}
	
	return 0;		
}
     c8a:	08 95       	ret

00000c8c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c8c:	31 e1       	ldi	r19, 0x11	; 17
     c8e:	fc 01       	movw	r30, r24
     c90:	30 83       	st	Z, r19
     c92:	31 97       	sbiw	r30, 0x01	; 1
     c94:	22 e2       	ldi	r18, 0x22	; 34
     c96:	20 83       	st	Z, r18
     c98:	31 97       	sbiw	r30, 0x01	; 1
     c9a:	a3 e3       	ldi	r26, 0x33	; 51
     c9c:	a0 83       	st	Z, r26
     c9e:	31 97       	sbiw	r30, 0x01	; 1
     ca0:	60 83       	st	Z, r22
     ca2:	31 97       	sbiw	r30, 0x01	; 1
     ca4:	70 83       	st	Z, r23
     ca6:	31 97       	sbiw	r30, 0x01	; 1
     ca8:	10 82       	st	Z, r1
     caa:	31 97       	sbiw	r30, 0x01	; 1
     cac:	10 82       	st	Z, r1
     cae:	31 97       	sbiw	r30, 0x01	; 1
     cb0:	60 e8       	ldi	r22, 0x80	; 128
     cb2:	60 83       	st	Z, r22
     cb4:	31 97       	sbiw	r30, 0x01	; 1
     cb6:	10 82       	st	Z, r1
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	10 82       	st	Z, r1
     cbc:	31 97       	sbiw	r30, 0x01	; 1
     cbe:	10 82       	st	Z, r1
     cc0:	31 97       	sbiw	r30, 0x01	; 1
     cc2:	62 e0       	ldi	r22, 0x02	; 2
     cc4:	60 83       	st	Z, r22
     cc6:	31 97       	sbiw	r30, 0x01	; 1
     cc8:	63 e0       	ldi	r22, 0x03	; 3
     cca:	60 83       	st	Z, r22
     ccc:	31 97       	sbiw	r30, 0x01	; 1
     cce:	64 e0       	ldi	r22, 0x04	; 4
     cd0:	60 83       	st	Z, r22
     cd2:	31 97       	sbiw	r30, 0x01	; 1
     cd4:	65 e0       	ldi	r22, 0x05	; 5
     cd6:	60 83       	st	Z, r22
     cd8:	31 97       	sbiw	r30, 0x01	; 1
     cda:	66 e0       	ldi	r22, 0x06	; 6
     cdc:	60 83       	st	Z, r22
     cde:	31 97       	sbiw	r30, 0x01	; 1
     ce0:	67 e0       	ldi	r22, 0x07	; 7
     ce2:	60 83       	st	Z, r22
     ce4:	31 97       	sbiw	r30, 0x01	; 1
     ce6:	68 e0       	ldi	r22, 0x08	; 8
     ce8:	60 83       	st	Z, r22
     cea:	31 97       	sbiw	r30, 0x01	; 1
     cec:	69 e0       	ldi	r22, 0x09	; 9
     cee:	60 83       	st	Z, r22
     cf0:	31 97       	sbiw	r30, 0x01	; 1
     cf2:	60 e1       	ldi	r22, 0x10	; 16
     cf4:	60 83       	st	Z, r22
     cf6:	31 97       	sbiw	r30, 0x01	; 1
     cf8:	30 83       	st	Z, r19
     cfa:	31 97       	sbiw	r30, 0x01	; 1
     cfc:	32 e1       	ldi	r19, 0x12	; 18
     cfe:	30 83       	st	Z, r19
     d00:	31 97       	sbiw	r30, 0x01	; 1
     d02:	33 e1       	ldi	r19, 0x13	; 19
     d04:	30 83       	st	Z, r19
     d06:	31 97       	sbiw	r30, 0x01	; 1
     d08:	34 e1       	ldi	r19, 0x14	; 20
     d0a:	30 83       	st	Z, r19
     d0c:	31 97       	sbiw	r30, 0x01	; 1
     d0e:	35 e1       	ldi	r19, 0x15	; 21
     d10:	30 83       	st	Z, r19
     d12:	31 97       	sbiw	r30, 0x01	; 1
     d14:	36 e1       	ldi	r19, 0x16	; 22
     d16:	30 83       	st	Z, r19
     d18:	31 97       	sbiw	r30, 0x01	; 1
     d1a:	37 e1       	ldi	r19, 0x17	; 23
     d1c:	30 83       	st	Z, r19
     d1e:	31 97       	sbiw	r30, 0x01	; 1
     d20:	38 e1       	ldi	r19, 0x18	; 24
     d22:	30 83       	st	Z, r19
     d24:	31 97       	sbiw	r30, 0x01	; 1
     d26:	39 e1       	ldi	r19, 0x19	; 25
     d28:	30 83       	st	Z, r19
     d2a:	31 97       	sbiw	r30, 0x01	; 1
     d2c:	30 e2       	ldi	r19, 0x20	; 32
     d2e:	30 83       	st	Z, r19
     d30:	31 97       	sbiw	r30, 0x01	; 1
     d32:	31 e2       	ldi	r19, 0x21	; 33
     d34:	30 83       	st	Z, r19
     d36:	31 97       	sbiw	r30, 0x01	; 1
     d38:	20 83       	st	Z, r18
     d3a:	31 97       	sbiw	r30, 0x01	; 1
     d3c:	23 e2       	ldi	r18, 0x23	; 35
     d3e:	20 83       	st	Z, r18
     d40:	31 97       	sbiw	r30, 0x01	; 1
     d42:	40 83       	st	Z, r20
     d44:	31 97       	sbiw	r30, 0x01	; 1
     d46:	50 83       	st	Z, r21
     d48:	31 97       	sbiw	r30, 0x01	; 1
     d4a:	26 e2       	ldi	r18, 0x26	; 38
     d4c:	20 83       	st	Z, r18
     d4e:	31 97       	sbiw	r30, 0x01	; 1
     d50:	27 e2       	ldi	r18, 0x27	; 39
     d52:	20 83       	st	Z, r18
     d54:	31 97       	sbiw	r30, 0x01	; 1
     d56:	28 e2       	ldi	r18, 0x28	; 40
     d58:	20 83       	st	Z, r18
     d5a:	31 97       	sbiw	r30, 0x01	; 1
     d5c:	29 e2       	ldi	r18, 0x29	; 41
     d5e:	20 83       	st	Z, r18
     d60:	31 97       	sbiw	r30, 0x01	; 1
     d62:	20 e3       	ldi	r18, 0x30	; 48
     d64:	20 83       	st	Z, r18
     d66:	31 97       	sbiw	r30, 0x01	; 1
     d68:	21 e3       	ldi	r18, 0x31	; 49
     d6a:	20 83       	st	Z, r18
     d6c:	89 97       	sbiw	r24, 0x29	; 41
     d6e:	08 95       	ret

00000d70 <xPortStartScheduler>:
     d70:	82 e0       	ldi	r24, 0x02	; 2
     d72:	84 bd       	out	0x24, r24	; 36
     d74:	16 bc       	out	0x26, r1	; 38
     d76:	80 e3       	ldi	r24, 0x30	; 48
     d78:	87 bd       	out	0x27, r24	; 39
     d7a:	ee e6       	ldi	r30, 0x6E	; 110
     d7c:	f0 e0       	ldi	r31, 0x00	; 0
     d7e:	80 81       	ld	r24, Z
     d80:	82 60       	ori	r24, 0x02	; 2
     d82:	80 83       	st	Z, r24
     d84:	83 e0       	ldi	r24, 0x03	; 3
     d86:	85 bd       	out	0x25, r24	; 37
     d88:	a0 91 dd 08 	lds	r26, 0x08DD
     d8c:	b0 91 de 08 	lds	r27, 0x08DE
     d90:	cd 91       	ld	r28, X+
     d92:	cd bf       	out	0x3d, r28	; 61
     d94:	dd 91       	ld	r29, X+
     d96:	de bf       	out	0x3e, r29	; 62
     d98:	ff 91       	pop	r31
     d9a:	ef 91       	pop	r30
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	bf 91       	pop	r27
     da2:	af 91       	pop	r26
     da4:	9f 91       	pop	r25
     da6:	8f 91       	pop	r24
     da8:	7f 91       	pop	r23
     daa:	6f 91       	pop	r22
     dac:	5f 91       	pop	r21
     dae:	4f 91       	pop	r20
     db0:	3f 91       	pop	r19
     db2:	2f 91       	pop	r18
     db4:	1f 91       	pop	r17
     db6:	0f 91       	pop	r16
     db8:	ff 90       	pop	r15
     dba:	ef 90       	pop	r14
     dbc:	df 90       	pop	r13
     dbe:	cf 90       	pop	r12
     dc0:	bf 90       	pop	r11
     dc2:	af 90       	pop	r10
     dc4:	9f 90       	pop	r9
     dc6:	8f 90       	pop	r8
     dc8:	7f 90       	pop	r7
     dca:	6f 90       	pop	r6
     dcc:	5f 90       	pop	r5
     dce:	4f 90       	pop	r4
     dd0:	3f 90       	pop	r3
     dd2:	2f 90       	pop	r2
     dd4:	1f 90       	pop	r1
     dd6:	0f 90       	pop	r0
     dd8:	0c be       	out	0x3c, r0	; 60
     dda:	0f 90       	pop	r0
     ddc:	0b be       	out	0x3b, r0	; 59
     dde:	0f 90       	pop	r0
     de0:	0f be       	out	0x3f, r0	; 63
     de2:	0f 90       	pop	r0
     de4:	08 95       	ret
     de6:	81 e0       	ldi	r24, 0x01	; 1
     de8:	08 95       	ret

00000dea <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dea:	0f 92       	push	r0
     dec:	0f b6       	in	r0, 0x3f	; 63
     dee:	f8 94       	cli
     df0:	0f 92       	push	r0
     df2:	0b b6       	in	r0, 0x3b	; 59
     df4:	0f 92       	push	r0
     df6:	0c b6       	in	r0, 0x3c	; 60
     df8:	0f 92       	push	r0
     dfa:	1f 92       	push	r1
     dfc:	11 24       	eor	r1, r1
     dfe:	2f 92       	push	r2
     e00:	3f 92       	push	r3
     e02:	4f 92       	push	r4
     e04:	5f 92       	push	r5
     e06:	6f 92       	push	r6
     e08:	7f 92       	push	r7
     e0a:	8f 92       	push	r8
     e0c:	9f 92       	push	r9
     e0e:	af 92       	push	r10
     e10:	bf 92       	push	r11
     e12:	cf 92       	push	r12
     e14:	df 92       	push	r13
     e16:	ef 92       	push	r14
     e18:	ff 92       	push	r15
     e1a:	0f 93       	push	r16
     e1c:	1f 93       	push	r17
     e1e:	2f 93       	push	r18
     e20:	3f 93       	push	r19
     e22:	4f 93       	push	r20
     e24:	5f 93       	push	r21
     e26:	6f 93       	push	r22
     e28:	7f 93       	push	r23
     e2a:	8f 93       	push	r24
     e2c:	9f 93       	push	r25
     e2e:	af 93       	push	r26
     e30:	bf 93       	push	r27
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	ef 93       	push	r30
     e38:	ff 93       	push	r31
     e3a:	a0 91 dd 08 	lds	r26, 0x08DD
     e3e:	b0 91 de 08 	lds	r27, 0x08DE
     e42:	0d b6       	in	r0, 0x3d	; 61
     e44:	0d 92       	st	X+, r0
     e46:	0e b6       	in	r0, 0x3e	; 62
     e48:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e4a:	64 d7       	rcall	.+3784   	; 0x1d14 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e4c:	a0 91 dd 08 	lds	r26, 0x08DD
     e50:	b0 91 de 08 	lds	r27, 0x08DE
     e54:	cd 91       	ld	r28, X+
     e56:	cd bf       	out	0x3d, r28	; 61
     e58:	dd 91       	ld	r29, X+
     e5a:	de bf       	out	0x3e, r29	; 62
     e5c:	ff 91       	pop	r31
     e5e:	ef 91       	pop	r30
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	bf 91       	pop	r27
     e66:	af 91       	pop	r26
     e68:	9f 91       	pop	r25
     e6a:	8f 91       	pop	r24
     e6c:	7f 91       	pop	r23
     e6e:	6f 91       	pop	r22
     e70:	5f 91       	pop	r21
     e72:	4f 91       	pop	r20
     e74:	3f 91       	pop	r19
     e76:	2f 91       	pop	r18
     e78:	1f 91       	pop	r17
     e7a:	0f 91       	pop	r16
     e7c:	ff 90       	pop	r15
     e7e:	ef 90       	pop	r14
     e80:	df 90       	pop	r13
     e82:	cf 90       	pop	r12
     e84:	bf 90       	pop	r11
     e86:	af 90       	pop	r10
     e88:	9f 90       	pop	r9
     e8a:	8f 90       	pop	r8
     e8c:	7f 90       	pop	r7
     e8e:	6f 90       	pop	r6
     e90:	5f 90       	pop	r5
     e92:	4f 90       	pop	r4
     e94:	3f 90       	pop	r3
     e96:	2f 90       	pop	r2
     e98:	1f 90       	pop	r1
     e9a:	0f 90       	pop	r0
     e9c:	0c be       	out	0x3c, r0	; 60
     e9e:	0f 90       	pop	r0
     ea0:	0b be       	out	0x3b, r0	; 59
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
     ea6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ea8:	08 95       	ret

00000eaa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eaa:	0f 92       	push	r0
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	0f 92       	push	r0
     eb2:	0b b6       	in	r0, 0x3b	; 59
     eb4:	0f 92       	push	r0
     eb6:	0c b6       	in	r0, 0x3c	; 60
     eb8:	0f 92       	push	r0
     eba:	1f 92       	push	r1
     ebc:	11 24       	eor	r1, r1
     ebe:	2f 92       	push	r2
     ec0:	3f 92       	push	r3
     ec2:	4f 92       	push	r4
     ec4:	5f 92       	push	r5
     ec6:	6f 92       	push	r6
     ec8:	7f 92       	push	r7
     eca:	8f 92       	push	r8
     ecc:	9f 92       	push	r9
     ece:	af 92       	push	r10
     ed0:	bf 92       	push	r11
     ed2:	cf 92       	push	r12
     ed4:	df 92       	push	r13
     ed6:	ef 92       	push	r14
     ed8:	ff 92       	push	r15
     eda:	0f 93       	push	r16
     edc:	1f 93       	push	r17
     ede:	2f 93       	push	r18
     ee0:	3f 93       	push	r19
     ee2:	4f 93       	push	r20
     ee4:	5f 93       	push	r21
     ee6:	6f 93       	push	r22
     ee8:	7f 93       	push	r23
     eea:	8f 93       	push	r24
     eec:	9f 93       	push	r25
     eee:	af 93       	push	r26
     ef0:	bf 93       	push	r27
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	ef 93       	push	r30
     ef8:	ff 93       	push	r31
     efa:	a0 91 dd 08 	lds	r26, 0x08DD
     efe:	b0 91 de 08 	lds	r27, 0x08DE
     f02:	0d b6       	in	r0, 0x3d	; 61
     f04:	0d 92       	st	X+, r0
     f06:	0e b6       	in	r0, 0x3e	; 62
     f08:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f0a:	32 d5       	rcall	.+2660   	; 0x1970 <xTaskIncrementTick>
     f0c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     f0e:	02 d7       	rcall	.+3588   	; 0x1d14 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f10:	a0 91 dd 08 	lds	r26, 0x08DD
     f14:	b0 91 de 08 	lds	r27, 0x08DE
     f18:	cd 91       	ld	r28, X+
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	dd 91       	ld	r29, X+
     f1e:	de bf       	out	0x3e, r29	; 62
     f20:	ff 91       	pop	r31
     f22:	ef 91       	pop	r30
     f24:	df 91       	pop	r29
     f26:	cf 91       	pop	r28
     f28:	bf 91       	pop	r27
     f2a:	af 91       	pop	r26
     f2c:	9f 91       	pop	r25
     f2e:	8f 91       	pop	r24
     f30:	7f 91       	pop	r23
     f32:	6f 91       	pop	r22
     f34:	5f 91       	pop	r21
     f36:	4f 91       	pop	r20
     f38:	3f 91       	pop	r19
     f3a:	2f 91       	pop	r18
     f3c:	1f 91       	pop	r17
     f3e:	0f 91       	pop	r16
     f40:	ff 90       	pop	r15
     f42:	ef 90       	pop	r14
     f44:	df 90       	pop	r13
     f46:	cf 90       	pop	r12
     f48:	bf 90       	pop	r11
     f4a:	af 90       	pop	r10
     f4c:	9f 90       	pop	r9
     f4e:	8f 90       	pop	r8
     f50:	7f 90       	pop	r7
     f52:	6f 90       	pop	r6
     f54:	5f 90       	pop	r5
     f56:	4f 90       	pop	r4
     f58:	3f 90       	pop	r3
     f5a:	2f 90       	pop	r2
     f5c:	1f 90       	pop	r1
     f5e:	0f 90       	pop	r0
     f60:	0c be       	out	0x3c, r0	; 60
     f62:	0f 90       	pop	r0
     f64:	0b be       	out	0x3b, r0	; 59
     f66:	0f 90       	pop	r0
     f68:	0f be       	out	0x3f, r0	; 63
     f6a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f6c:	08 95       	ret

00000f6e <__vector_21>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	 ISR(TIMER0_COMPA_vect, ISR_NAKED)
	 {
		 vPortYieldFromTick();
     f6e:	9d df       	rcall	.-198    	; 0xeaa <vPortYieldFromTick>
		 asm volatile ("reti");
     f70:	18 95       	reti

00000f72 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     f72:	1f 93       	push	r17
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
     f78:	ec 01       	movw	r28, r24
     f7a:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     f7c:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f7e:	81 11       	cpse	r24, r1
     f80:	0c c0       	rjmp	.+24     	; 0xf9a <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     f82:	88 81       	ld	r24, Y
     f84:	99 81       	ldd	r25, Y+1	; 0x01
     f86:	89 2b       	or	r24, r25
     f88:	09 f0       	breq	.+2      	; 0xf8c <prvCopyDataToQueue+0x1a>
     f8a:	47 c0       	rjmp	.+142    	; 0x101a <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     f8c:	8a 81       	ldd	r24, Y+2	; 0x02
     f8e:	9b 81       	ldd	r25, Y+3	; 0x03
     f90:	0e 94 4d 10 	call	0x209a	; 0x209a <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     f94:	1b 82       	std	Y+3, r1	; 0x03
     f96:	1a 82       	std	Y+2, r1	; 0x02
     f98:	47 c0       	rjmp	.+142    	; 0x1028 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     f9a:	41 11       	cpse	r20, r1
     f9c:	18 c0       	rjmp	.+48     	; 0xfce <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     f9e:	48 2f       	mov	r20, r24
     fa0:	50 e0       	ldi	r21, 0x00	; 0
     fa2:	8c 81       	ldd	r24, Y+4	; 0x04
     fa4:	9d 81       	ldd	r25, Y+5	; 0x05
     fa6:	0e 94 c5 10 	call	0x218a	; 0x218a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     faa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fac:	8c 81       	ldd	r24, Y+4	; 0x04
     fae:	9d 81       	ldd	r25, Y+5	; 0x05
     fb0:	82 0f       	add	r24, r18
     fb2:	91 1d       	adc	r25, r1
     fb4:	9d 83       	std	Y+5, r25	; 0x05
     fb6:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     fb8:	2a 81       	ldd	r18, Y+2	; 0x02
     fba:	3b 81       	ldd	r19, Y+3	; 0x03
     fbc:	82 17       	cp	r24, r18
     fbe:	93 07       	cpc	r25, r19
     fc0:	70 f1       	brcs	.+92     	; 0x101e <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     fc2:	88 81       	ld	r24, Y
     fc4:	99 81       	ldd	r25, Y+1	; 0x01
     fc6:	9d 83       	std	Y+5, r25	; 0x05
     fc8:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     fca:	80 e0       	ldi	r24, 0x00	; 0
     fcc:	2d c0       	rjmp	.+90     	; 0x1028 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     fce:	48 2f       	mov	r20, r24
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	8e 81       	ldd	r24, Y+6	; 0x06
     fd4:	9f 81       	ldd	r25, Y+7	; 0x07
     fd6:	0e 94 c5 10 	call	0x218a	; 0x218a <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     fda:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fdc:	30 e0       	ldi	r19, 0x00	; 0
     fde:	31 95       	neg	r19
     fe0:	21 95       	neg	r18
     fe2:	31 09       	sbc	r19, r1
     fe4:	8e 81       	ldd	r24, Y+6	; 0x06
     fe6:	9f 81       	ldd	r25, Y+7	; 0x07
     fe8:	82 0f       	add	r24, r18
     fea:	93 1f       	adc	r25, r19
     fec:	9f 83       	std	Y+7, r25	; 0x07
     fee:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ff0:	68 81       	ld	r22, Y
     ff2:	79 81       	ldd	r23, Y+1	; 0x01
     ff4:	86 17       	cp	r24, r22
     ff6:	97 07       	cpc	r25, r23
     ff8:	30 f4       	brcc	.+12     	; 0x1006 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     ffa:	8a 81       	ldd	r24, Y+2	; 0x02
     ffc:	9b 81       	ldd	r25, Y+3	; 0x03
     ffe:	28 0f       	add	r18, r24
    1000:	39 1f       	adc	r19, r25
    1002:	3f 83       	std	Y+7, r19	; 0x07
    1004:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1006:	12 30       	cpi	r17, 0x02	; 2
    1008:	61 f4       	brne	.+24     	; 0x1022 <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    100a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    100c:	88 23       	and	r24, r24
    100e:	59 f0       	breq	.+22     	; 0x1026 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1010:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1012:	81 50       	subi	r24, 0x01	; 1
    1014:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	07 c0       	rjmp	.+14     	; 0x1028 <prvCopyDataToQueue+0xb6>
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	05 c0       	rjmp	.+10     	; 0x1028 <prvCopyDataToQueue+0xb6>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	03 c0       	rjmp	.+6      	; 0x1028 <prvCopyDataToQueue+0xb6>
    1022:	80 e0       	ldi	r24, 0x00	; 0
    1024:	01 c0       	rjmp	.+2      	; 0x1028 <prvCopyDataToQueue+0xb6>
    1026:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1028:	9a 8d       	ldd	r25, Y+26	; 0x1a
    102a:	9f 5f       	subi	r25, 0xFF	; 255
    102c:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	1f 91       	pop	r17
    1034:	08 95       	ret

00001036 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1036:	fc 01       	movw	r30, r24
    1038:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    103a:	44 8d       	ldd	r20, Z+28	; 0x1c
    103c:	44 23       	and	r20, r20
    103e:	a1 f0       	breq	.+40     	; 0x1068 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1040:	50 e0       	ldi	r21, 0x00	; 0
    1042:	26 81       	ldd	r18, Z+6	; 0x06
    1044:	37 81       	ldd	r19, Z+7	; 0x07
    1046:	24 0f       	add	r18, r20
    1048:	35 1f       	adc	r19, r21
    104a:	37 83       	std	Z+7, r19	; 0x07
    104c:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    104e:	62 81       	ldd	r22, Z+2	; 0x02
    1050:	73 81       	ldd	r23, Z+3	; 0x03
    1052:	26 17       	cp	r18, r22
    1054:	37 07       	cpc	r19, r23
    1056:	20 f0       	brcs	.+8      	; 0x1060 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1058:	20 81       	ld	r18, Z
    105a:	31 81       	ldd	r19, Z+1	; 0x01
    105c:	37 83       	std	Z+7, r19	; 0x07
    105e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1060:	66 81       	ldd	r22, Z+6	; 0x06
    1062:	77 81       	ldd	r23, Z+7	; 0x07
    1064:	0c 94 c5 10 	jmp	0x218a	; 0x218a <memcpy>
    1068:	08 95       	ret

0000106a <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    106a:	0f 93       	push	r16
    106c:	1f 93       	push	r17
    106e:	cf 93       	push	r28
    1070:	df 93       	push	r29
    1072:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1074:	0f b6       	in	r0, 0x3f	; 63
    1076:	f8 94       	cli
    1078:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    107a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    107c:	18 16       	cp	r1, r24
    107e:	a4 f4       	brge	.+40     	; 0x10a8 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1080:	89 89       	ldd	r24, Y+17	; 0x11
    1082:	88 23       	and	r24, r24
    1084:	89 f0       	breq	.+34     	; 0x10a8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1086:	8e 01       	movw	r16, r28
    1088:	0f 5e       	subi	r16, 0xEF	; 239
    108a:	1f 4f       	sbci	r17, 0xFF	; 255
    108c:	03 c0       	rjmp	.+6      	; 0x1094 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    108e:	89 89       	ldd	r24, Y+17	; 0x11
    1090:	88 23       	and	r24, r24
    1092:	51 f0       	breq	.+20     	; 0x10a8 <prvUnlockQueue+0x3e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1094:	c8 01       	movw	r24, r16
    1096:	14 d7       	rcall	.+3624   	; 0x1ec0 <xTaskRemoveFromEventList>
    1098:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    109a:	9d d7       	rcall	.+3898   	; 0x1fd6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    109c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    109e:	81 50       	subi	r24, 0x01	; 1
    10a0:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    10a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10a4:	18 16       	cp	r1, r24
    10a6:	9c f3       	brlt	.-26     	; 0x108e <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    10a8:	8f ef       	ldi	r24, 0xFF	; 255
    10aa:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    10ac:	0f 90       	pop	r0
    10ae:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    10b0:	0f b6       	in	r0, 0x3f	; 63
    10b2:	f8 94       	cli
    10b4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    10b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10b8:	18 16       	cp	r1, r24
    10ba:	a4 f4       	brge	.+40     	; 0x10e4 <prvUnlockQueue+0x7a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10bc:	88 85       	ldd	r24, Y+8	; 0x08
    10be:	88 23       	and	r24, r24
    10c0:	89 f0       	breq	.+34     	; 0x10e4 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10c2:	8e 01       	movw	r16, r28
    10c4:	08 5f       	subi	r16, 0xF8	; 248
    10c6:	1f 4f       	sbci	r17, 0xFF	; 255
    10c8:	03 c0       	rjmp	.+6      	; 0x10d0 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ca:	88 85       	ldd	r24, Y+8	; 0x08
    10cc:	88 23       	and	r24, r24
    10ce:	51 f0       	breq	.+20     	; 0x10e4 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10d0:	c8 01       	movw	r24, r16
    10d2:	f6 d6       	rcall	.+3564   	; 0x1ec0 <xTaskRemoveFromEventList>
    10d4:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    10d6:	7f d7       	rcall	.+3838   	; 0x1fd6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    10d8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10da:	81 50       	subi	r24, 0x01	; 1
    10dc:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    10de:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10e0:	18 16       	cp	r1, r24
    10e2:	9c f3       	brlt	.-26     	; 0x10ca <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    10e4:	8f ef       	ldi	r24, 0xFF	; 255
    10e6:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    10e8:	0f 90       	pop	r0
    10ea:	0f be       	out	0x3f, r0	; 63
}
    10ec:	df 91       	pop	r29
    10ee:	cf 91       	pop	r28
    10f0:	1f 91       	pop	r17
    10f2:	0f 91       	pop	r16
    10f4:	08 95       	ret

000010f6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    10fc:	0f b6       	in	r0, 0x3f	; 63
    10fe:	f8 94       	cli
    1100:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1102:	88 81       	ld	r24, Y
    1104:	99 81       	ldd	r25, Y+1	; 0x01
    1106:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1108:	30 e0       	ldi	r19, 0x00	; 0
    110a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    110c:	72 9f       	mul	r23, r18
    110e:	a0 01       	movw	r20, r0
    1110:	73 9f       	mul	r23, r19
    1112:	50 0d       	add	r21, r0
    1114:	11 24       	eor	r1, r1
    1116:	fc 01       	movw	r30, r24
    1118:	e4 0f       	add	r30, r20
    111a:	f5 1f       	adc	r31, r21
    111c:	fb 83       	std	Y+3, r31	; 0x03
    111e:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1120:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1122:	9d 83       	std	Y+5, r25	; 0x05
    1124:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    1126:	42 1b       	sub	r20, r18
    1128:	53 0b       	sbc	r21, r19
    112a:	84 0f       	add	r24, r20
    112c:	95 1f       	adc	r25, r21
    112e:	9f 83       	std	Y+7, r25	; 0x07
    1130:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1132:	8f ef       	ldi	r24, 0xFF	; 255
    1134:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1136:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1138:	61 11       	cpse	r22, r1
    113a:	0a c0       	rjmp	.+20     	; 0x1150 <xQueueGenericReset+0x5a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    113c:	88 85       	ldd	r24, Y+8	; 0x08
    113e:	88 23       	and	r24, r24
    1140:	69 f0       	breq	.+26     	; 0x115c <xQueueGenericReset+0x66>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1142:	ce 01       	movw	r24, r28
    1144:	08 96       	adiw	r24, 0x08	; 8
    1146:	bc d6       	rcall	.+3448   	; 0x1ec0 <xTaskRemoveFromEventList>
    1148:	81 30       	cpi	r24, 0x01	; 1
    114a:	41 f4       	brne	.+16     	; 0x115c <xQueueGenericReset+0x66>
				{
					queueYIELD_IF_USING_PREEMPTION();
    114c:	4e de       	rcall	.-868    	; 0xdea <vPortYield>
    114e:	06 c0       	rjmp	.+12     	; 0x115c <xQueueGenericReset+0x66>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1150:	ce 01       	movw	r24, r28
    1152:	08 96       	adiw	r24, 0x08	; 8
    1154:	65 d9       	rcall	.-3382   	; 0x420 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1156:	ce 01       	movw	r24, r28
    1158:	41 96       	adiw	r24, 0x11	; 17
    115a:	62 d9       	rcall	.-3388   	; 0x420 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	08 95       	ret

00001168 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1168:	0f 93       	push	r16
    116a:	1f 93       	push	r17
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	18 2f       	mov	r17, r24
    1172:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1174:	88 23       	and	r24, r24
    1176:	d1 f0       	breq	.+52     	; 0x11ac <xQueueGenericCreate+0x44>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1178:	8f e1       	ldi	r24, 0x1F	; 31
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	1b d9       	rcall	.-3530   	; 0x3b4 <pvPortMalloc>
    117e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1180:	00 97       	sbiw	r24, 0x00	; 0
    1182:	b1 f0       	breq	.+44     	; 0x11b0 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1184:	10 9f       	mul	r17, r16
    1186:	c0 01       	movw	r24, r0
    1188:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    118a:	01 96       	adiw	r24, 0x01	; 1
    118c:	13 d9       	rcall	.-3546   	; 0x3b4 <pvPortMalloc>
    118e:	99 83       	std	Y+1, r25	; 0x01
    1190:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1192:	89 2b       	or	r24, r25
    1194:	31 f0       	breq	.+12     	; 0x11a2 <xQueueGenericCreate+0x3a>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1196:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1198:	0c 8f       	std	Y+28, r16	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    119a:	61 e0       	ldi	r22, 0x01	; 1
    119c:	ce 01       	movw	r24, r28
    119e:	ab df       	rcall	.-170    	; 0x10f6 <xQueueGenericReset>
    11a0:	07 c0       	rjmp	.+14     	; 0x11b0 <xQueueGenericCreate+0x48>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    11a2:	ce 01       	movw	r24, r28
    11a4:	3c d9       	rcall	.-3464   	; 0x41e <vPortFree>

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    11a6:	c0 e0       	ldi	r28, 0x00	; 0
    11a8:	d0 e0       	ldi	r29, 0x00	; 0
    11aa:	02 c0       	rjmp	.+4      	; 0x11b0 <xQueueGenericCreate+0x48>
    11ac:	c0 e0       	ldi	r28, 0x00	; 0
    11ae:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    11b0:	ce 01       	movw	r24, r28
    11b2:	df 91       	pop	r29
    11b4:	cf 91       	pop	r28
    11b6:	1f 91       	pop	r17
    11b8:	0f 91       	pop	r16
    11ba:	08 95       	ret

000011bc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    11bc:	9f 92       	push	r9
    11be:	af 92       	push	r10
    11c0:	bf 92       	push	r11
    11c2:	cf 92       	push	r12
    11c4:	df 92       	push	r13
    11c6:	ef 92       	push	r14
    11c8:	ff 92       	push	r15
    11ca:	0f 93       	push	r16
    11cc:	1f 93       	push	r17
    11ce:	cf 93       	push	r28
    11d0:	df 93       	push	r29
    11d2:	00 d0       	rcall	.+0      	; 0x11d4 <xQueueGenericSend+0x18>
    11d4:	1f 92       	push	r1
    11d6:	1f 92       	push	r1
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
    11dc:	8c 01       	movw	r16, r24
    11de:	6b 01       	movw	r12, r22
    11e0:	5d 83       	std	Y+5, r21	; 0x05
    11e2:	4c 83       	std	Y+4, r20	; 0x04
    11e4:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    11e6:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    11e8:	99 24       	eor	r9, r9
    11ea:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11ec:	7c 01       	movw	r14, r24
    11ee:	88 e0       	ldi	r24, 0x08	; 8
    11f0:	e8 0e       	add	r14, r24
    11f2:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    11fa:	f8 01       	movw	r30, r16
    11fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    11fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1200:	98 17       	cp	r25, r24
    1202:	18 f0       	brcs	.+6      	; 0x120a <xQueueGenericSend+0x4e>
    1204:	f2 e0       	ldi	r31, 0x02	; 2
    1206:	af 12       	cpse	r10, r31
    1208:	15 c0       	rjmp	.+42     	; 0x1234 <xQueueGenericSend+0x78>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    120a:	4a 2d       	mov	r20, r10
    120c:	b6 01       	movw	r22, r12
    120e:	c8 01       	movw	r24, r16
    1210:	b0 de       	rcall	.-672    	; 0xf72 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1212:	f8 01       	movw	r30, r16
    1214:	91 89       	ldd	r25, Z+17	; 0x11
    1216:	99 23       	and	r25, r25
    1218:	39 f0       	breq	.+14     	; 0x1228 <xQueueGenericSend+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    121a:	c8 01       	movw	r24, r16
    121c:	41 96       	adiw	r24, 0x11	; 17
    121e:	50 d6       	rcall	.+3232   	; 0x1ec0 <xTaskRemoveFromEventList>
    1220:	81 30       	cpi	r24, 0x01	; 1
    1222:	21 f4       	brne	.+8      	; 0x122c <xQueueGenericSend+0x70>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1224:	e2 dd       	rcall	.-1084   	; 0xdea <vPortYield>
    1226:	02 c0       	rjmp	.+4      	; 0x122c <xQueueGenericSend+0x70>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1228:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    122a:	df dd       	rcall	.-1090   	; 0xdea <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    122c:	0f 90       	pop	r0
    122e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1230:	81 e0       	ldi	r24, 0x01	; 1
    1232:	46 c0       	rjmp	.+140    	; 0x12c0 <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1234:	ec 81       	ldd	r30, Y+4	; 0x04
    1236:	fd 81       	ldd	r31, Y+5	; 0x05
    1238:	ef 2b       	or	r30, r31
    123a:	21 f4       	brne	.+8      	; 0x1244 <xQueueGenericSend+0x88>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    123c:	0f 90       	pop	r0
    123e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1240:	80 e0       	ldi	r24, 0x00	; 0
    1242:	3e c0       	rjmp	.+124    	; 0x12c0 <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
    1244:	b1 10       	cpse	r11, r1
    1246:	04 c0       	rjmp	.+8      	; 0x1250 <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1248:	ce 01       	movw	r24, r28
    124a:	01 96       	adiw	r24, 0x01	; 1
    124c:	81 d6       	rcall	.+3330   	; 0x1f50 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    124e:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1250:	0f 90       	pop	r0
    1252:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1254:	78 d3       	rcall	.+1776   	; 0x1946 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1256:	0f b6       	in	r0, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	0f 92       	push	r0
    125c:	f8 01       	movw	r30, r16
    125e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1260:	8f 3f       	cpi	r24, 0xFF	; 255
    1262:	09 f4       	brne	.+2      	; 0x1266 <xQueueGenericSend+0xaa>
    1264:	15 8e       	std	Z+29, r1	; 0x1d
    1266:	f8 01       	movw	r30, r16
    1268:	86 8d       	ldd	r24, Z+30	; 0x1e
    126a:	8f 3f       	cpi	r24, 0xFF	; 255
    126c:	09 f4       	brne	.+2      	; 0x1270 <xQueueGenericSend+0xb4>
    126e:	16 8e       	std	Z+30, r1	; 0x1e
    1270:	0f 90       	pop	r0
    1272:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1274:	be 01       	movw	r22, r28
    1276:	6c 5f       	subi	r22, 0xFC	; 252
    1278:	7f 4f       	sbci	r23, 0xFF	; 255
    127a:	ce 01       	movw	r24, r28
    127c:	01 96       	adiw	r24, 0x01	; 1
    127e:	73 d6       	rcall	.+3302   	; 0x1f66 <xTaskCheckForTimeOut>
    1280:	81 11       	cpse	r24, r1
    1282:	1a c0       	rjmp	.+52     	; 0x12b8 <xQueueGenericSend+0xfc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1284:	0f b6       	in	r0, 0x3f	; 63
    1286:	f8 94       	cli
    1288:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    128a:	f8 01       	movw	r30, r16
    128c:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1292:	f8 01       	movw	r30, r16
    1294:	83 8d       	ldd	r24, Z+27	; 0x1b
    1296:	98 13       	cpse	r25, r24
    1298:	0b c0       	rjmp	.+22     	; 0x12b0 <xQueueGenericSend+0xf4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    129a:	6c 81       	ldd	r22, Y+4	; 0x04
    129c:	7d 81       	ldd	r23, Y+5	; 0x05
    129e:	c7 01       	movw	r24, r14
    12a0:	e4 d5       	rcall	.+3016   	; 0x1e6a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    12a2:	c8 01       	movw	r24, r16
    12a4:	e2 de       	rcall	.-572    	; 0x106a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12a6:	22 d4       	rcall	.+2116   	; 0x1aec <xTaskResumeAll>
    12a8:	81 11       	cpse	r24, r1
    12aa:	a4 cf       	rjmp	.-184    	; 0x11f4 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
    12ac:	9e dd       	rcall	.-1220   	; 0xdea <vPortYield>
    12ae:	a2 cf       	rjmp	.-188    	; 0x11f4 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12b0:	c8 01       	movw	r24, r16
    12b2:	db de       	rcall	.-586    	; 0x106a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12b4:	1b d4       	rcall	.+2102   	; 0x1aec <xTaskResumeAll>
    12b6:	9e cf       	rjmp	.-196    	; 0x11f4 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12b8:	c8 01       	movw	r24, r16
    12ba:	d7 de       	rcall	.-594    	; 0x106a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12bc:	17 d4       	rcall	.+2094   	; 0x1aec <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    12be:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    12c0:	0f 90       	pop	r0
    12c2:	0f 90       	pop	r0
    12c4:	0f 90       	pop	r0
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	df 91       	pop	r29
    12cc:	cf 91       	pop	r28
    12ce:	1f 91       	pop	r17
    12d0:	0f 91       	pop	r16
    12d2:	ff 90       	pop	r15
    12d4:	ef 90       	pop	r14
    12d6:	df 90       	pop	r13
    12d8:	cf 90       	pop	r12
    12da:	bf 90       	pop	r11
    12dc:	af 90       	pop	r10
    12de:	9f 90       	pop	r9
    12e0:	08 95       	ret

000012e2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    12e2:	cf 93       	push	r28
    12e4:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    12e6:	8f e1       	ldi	r24, 0x1F	; 31
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	64 d8       	rcall	.-3896   	; 0x3b4 <pvPortMalloc>
    12ec:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    12ee:	00 97       	sbiw	r24, 0x00	; 0
    12f0:	e1 f0       	breq	.+56     	; 0x132a <xQueueCreateMutex+0x48>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    12f2:	1b 82       	std	Y+3, r1	; 0x03
    12f4:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    12f6:	19 82       	std	Y+1, r1	; 0x01
    12f8:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    12fa:	1d 82       	std	Y+5, r1	; 0x05
    12fc:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->u.pcReadFrom = NULL;
    12fe:	1f 82       	std	Y+7, r1	; 0x07
    1300:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1302:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    1308:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    130a:	8f ef       	ldi	r24, 0xFF	; 255
    130c:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    130e:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1310:	ce 01       	movw	r24, r28
    1312:	08 96       	adiw	r24, 0x08	; 8
    1314:	85 d8       	rcall	.-3830   	; 0x420 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1316:	ce 01       	movw	r24, r28
    1318:	41 96       	adiw	r24, 0x11	; 17
    131a:	82 d8       	rcall	.-3836   	; 0x420 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    131c:	20 e0       	ldi	r18, 0x00	; 0
    131e:	40 e0       	ldi	r20, 0x00	; 0
    1320:	50 e0       	ldi	r21, 0x00	; 0
    1322:	60 e0       	ldi	r22, 0x00	; 0
    1324:	70 e0       	ldi	r23, 0x00	; 0
    1326:	ce 01       	movw	r24, r28
    1328:	49 df       	rcall	.-366    	; 0x11bc <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    132a:	ce 01       	movw	r24, r28
    132c:	df 91       	pop	r29
    132e:	cf 91       	pop	r28
    1330:	08 95       	ret

00001332 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1332:	0f 93       	push	r16
    1334:	1f 93       	push	r17
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	ec 01       	movw	r28, r24
    133c:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    133e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1340:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1342:	98 17       	cp	r25, r24
    1344:	10 f0       	brcs	.+4      	; 0x134a <xQueueGenericSendFromISR+0x18>
    1346:	22 30       	cpi	r18, 0x02	; 2
    1348:	11 f5       	brne	.+68     	; 0x138e <xQueueGenericSendFromISR+0x5c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    134a:	42 2f       	mov	r20, r18
    134c:	ce 01       	movw	r24, r28
    134e:	11 de       	rcall	.-990    	; 0xf72 <prvCopyDataToQueue>
    1350:	88 23       	and	r24, r24
    1352:	31 f0       	breq	.+12     	; 0x1360 <xQueueGenericSendFromISR+0x2e>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    1354:	01 15       	cp	r16, r1
    1356:	11 05       	cpc	r17, r1
    1358:	19 f0       	breq	.+6      	; 0x1360 <xQueueGenericSendFromISR+0x2e>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	f8 01       	movw	r30, r16
    135e:	80 83       	st	Z, r24
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1360:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1362:	8f 3f       	cpi	r24, 0xFF	; 255
    1364:	79 f4       	brne	.+30     	; 0x1384 <xQueueGenericSendFromISR+0x52>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1366:	89 89       	ldd	r24, Y+17	; 0x11
    1368:	88 23       	and	r24, r24
    136a:	99 f0       	breq	.+38     	; 0x1392 <xQueueGenericSendFromISR+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    136c:	ce 01       	movw	r24, r28
    136e:	41 96       	adiw	r24, 0x11	; 17
    1370:	a7 d5       	rcall	.+2894   	; 0x1ec0 <xTaskRemoveFromEventList>
    1372:	88 23       	and	r24, r24
    1374:	81 f0       	breq	.+32     	; 0x1396 <xQueueGenericSendFromISR+0x64>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1376:	01 15       	cp	r16, r1
    1378:	11 05       	cpc	r17, r1
    137a:	79 f0       	breq	.+30     	; 0x139a <xQueueGenericSendFromISR+0x68>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	f8 01       	movw	r30, r16
    1380:	80 83       	st	Z, r24
    1382:	0c c0       	rjmp	.+24     	; 0x139c <xQueueGenericSendFromISR+0x6a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1384:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1386:	8f 5f       	subi	r24, 0xFF	; 255
    1388:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	07 c0       	rjmp	.+14     	; 0x139c <xQueueGenericSendFromISR+0x6a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	05 c0       	rjmp	.+10     	; 0x139c <xQueueGenericSendFromISR+0x6a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	03 c0       	rjmp	.+6      	; 0x139c <xQueueGenericSendFromISR+0x6a>
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	01 c0       	rjmp	.+2      	; 0x139c <xQueueGenericSendFromISR+0x6a>
    139a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	08 95       	ret

000013a6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    13a6:	9f 92       	push	r9
    13a8:	af 92       	push	r10
    13aa:	bf 92       	push	r11
    13ac:	cf 92       	push	r12
    13ae:	df 92       	push	r13
    13b0:	ef 92       	push	r14
    13b2:	ff 92       	push	r15
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	00 d0       	rcall	.+0      	; 0x13be <xQueueGenericReceive+0x18>
    13be:	1f 92       	push	r1
    13c0:	1f 92       	push	r1
    13c2:	cd b7       	in	r28, 0x3d	; 61
    13c4:	de b7       	in	r29, 0x3e	; 62
    13c6:	8c 01       	movw	r16, r24
    13c8:	6b 01       	movw	r12, r22
    13ca:	5d 83       	std	Y+5, r21	; 0x05
    13cc:	4c 83       	std	Y+4, r20	; 0x04
    13ce:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    13d0:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    13d2:	99 24       	eor	r9, r9
    13d4:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13d6:	7c 01       	movw	r14, r24
    13d8:	81 e1       	ldi	r24, 0x11	; 17
    13da:	e8 0e       	add	r14, r24
    13dc:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    13de:	0f b6       	in	r0, 0x3f	; 63
    13e0:	f8 94       	cli
    13e2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    13e4:	f8 01       	movw	r30, r16
    13e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    13e8:	88 23       	and	r24, r24
    13ea:	69 f1       	breq	.+90     	; 0x1446 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    13ec:	e6 80       	ldd	r14, Z+6	; 0x06
    13ee:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    13f0:	b6 01       	movw	r22, r12
    13f2:	c8 01       	movw	r24, r16
    13f4:	20 de       	rcall	.-960    	; 0x1036 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13f6:	b1 10       	cpse	r11, r1
    13f8:	17 c0       	rjmp	.+46     	; 0x1428 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    13fa:	f8 01       	movw	r30, r16
    13fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    13fe:	81 50       	subi	r24, 0x01	; 1
    1400:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1402:	80 81       	ld	r24, Z
    1404:	91 81       	ldd	r25, Z+1	; 0x01
    1406:	89 2b       	or	r24, r25
    1408:	21 f4       	brne	.+8      	; 0x1412 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    140a:	86 d6       	rcall	.+3340   	; 0x2118 <pvTaskIncrementMutexHeldCount>
    140c:	f8 01       	movw	r30, r16
    140e:	93 83       	std	Z+3, r25	; 0x03
    1410:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1412:	f8 01       	movw	r30, r16
    1414:	80 85       	ldd	r24, Z+8	; 0x08
    1416:	88 23       	and	r24, r24
    1418:	91 f0       	breq	.+36     	; 0x143e <xQueueGenericReceive+0x98>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    141a:	c8 01       	movw	r24, r16
    141c:	08 96       	adiw	r24, 0x08	; 8
    141e:	50 d5       	rcall	.+2720   	; 0x1ec0 <xTaskRemoveFromEventList>
    1420:	81 30       	cpi	r24, 0x01	; 1
    1422:	69 f4       	brne	.+26     	; 0x143e <xQueueGenericReceive+0x98>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1424:	e2 dc       	rcall	.-1596   	; 0xdea <vPortYield>
    1426:	0b c0       	rjmp	.+22     	; 0x143e <xQueueGenericReceive+0x98>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1428:	f8 01       	movw	r30, r16
    142a:	f7 82       	std	Z+7, r15	; 0x07
    142c:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    142e:	81 89       	ldd	r24, Z+17	; 0x11
    1430:	88 23       	and	r24, r24
    1432:	29 f0       	breq	.+10     	; 0x143e <xQueueGenericReceive+0x98>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1434:	c8 01       	movw	r24, r16
    1436:	41 96       	adiw	r24, 0x11	; 17
    1438:	43 d5       	rcall	.+2694   	; 0x1ec0 <xTaskRemoveFromEventList>
    143a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    143c:	d6 dc       	rcall	.-1620   	; 0xdea <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    143e:	0f 90       	pop	r0
    1440:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1442:	81 e0       	ldi	r24, 0x01	; 1
    1444:	52 c0       	rjmp	.+164    	; 0x14ea <xQueueGenericReceive+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1446:	4c 81       	ldd	r20, Y+4	; 0x04
    1448:	5d 81       	ldd	r21, Y+5	; 0x05
    144a:	45 2b       	or	r20, r21
    144c:	21 f4       	brne	.+8      	; 0x1456 <xQueueGenericReceive+0xb0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    144e:	0f 90       	pop	r0
    1450:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	4a c0       	rjmp	.+148    	; 0x14ea <xQueueGenericReceive+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1456:	a1 10       	cpse	r10, r1
    1458:	04 c0       	rjmp	.+8      	; 0x1462 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    145a:	ce 01       	movw	r24, r28
    145c:	01 96       	adiw	r24, 0x01	; 1
    145e:	78 d5       	rcall	.+2800   	; 0x1f50 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1460:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1462:	0f 90       	pop	r0
    1464:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1466:	6f d2       	rcall	.+1246   	; 0x1946 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	0f 92       	push	r0
    146e:	f8 01       	movw	r30, r16
    1470:	85 8d       	ldd	r24, Z+29	; 0x1d
    1472:	8f 3f       	cpi	r24, 0xFF	; 255
    1474:	09 f4       	brne	.+2      	; 0x1478 <xQueueGenericReceive+0xd2>
    1476:	15 8e       	std	Z+29, r1	; 0x1d
    1478:	f8 01       	movw	r30, r16
    147a:	86 8d       	ldd	r24, Z+30	; 0x1e
    147c:	8f 3f       	cpi	r24, 0xFF	; 255
    147e:	09 f4       	brne	.+2      	; 0x1482 <xQueueGenericReceive+0xdc>
    1480:	16 8e       	std	Z+30, r1	; 0x1e
    1482:	0f 90       	pop	r0
    1484:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1486:	be 01       	movw	r22, r28
    1488:	6c 5f       	subi	r22, 0xFC	; 252
    148a:	7f 4f       	sbci	r23, 0xFF	; 255
    148c:	ce 01       	movw	r24, r28
    148e:	01 96       	adiw	r24, 0x01	; 1
    1490:	6a d5       	rcall	.+2772   	; 0x1f66 <xTaskCheckForTimeOut>
    1492:	81 11       	cpse	r24, r1
    1494:	26 c0       	rjmp	.+76     	; 0x14e2 <xQueueGenericReceive+0x13c>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1496:	0f b6       	in	r0, 0x3f	; 63
    1498:	f8 94       	cli
    149a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    149c:	f8 01       	movw	r30, r16
    149e:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    14a0:	0f 90       	pop	r0
    14a2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14a4:	81 11       	cpse	r24, r1
    14a6:	19 c0       	rjmp	.+50     	; 0x14da <xQueueGenericReceive+0x134>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14a8:	f8 01       	movw	r30, r16
    14aa:	80 81       	ld	r24, Z
    14ac:	91 81       	ldd	r25, Z+1	; 0x01
    14ae:	89 2b       	or	r24, r25
    14b0:	49 f4       	brne	.+18     	; 0x14c4 <xQueueGenericReceive+0x11e>
					{
						taskENTER_CRITICAL();
    14b2:	0f b6       	in	r0, 0x3f	; 63
    14b4:	f8 94       	cli
    14b6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    14b8:	f8 01       	movw	r30, r16
    14ba:	82 81       	ldd	r24, Z+2	; 0x02
    14bc:	93 81       	ldd	r25, Z+3	; 0x03
    14be:	8f d5       	rcall	.+2846   	; 0x1fde <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14c4:	6c 81       	ldd	r22, Y+4	; 0x04
    14c6:	7d 81       	ldd	r23, Y+5	; 0x05
    14c8:	c7 01       	movw	r24, r14
    14ca:	cf d4       	rcall	.+2462   	; 0x1e6a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14cc:	c8 01       	movw	r24, r16
    14ce:	cd dd       	rcall	.-1126   	; 0x106a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14d0:	0d d3       	rcall	.+1562   	; 0x1aec <xTaskResumeAll>
    14d2:	81 11       	cpse	r24, r1
    14d4:	84 cf       	rjmp	.-248    	; 0x13de <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
    14d6:	89 dc       	rcall	.-1774   	; 0xdea <vPortYield>
    14d8:	82 cf       	rjmp	.-252    	; 0x13de <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14da:	c8 01       	movw	r24, r16
    14dc:	c6 dd       	rcall	.-1140   	; 0x106a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14de:	06 d3       	rcall	.+1548   	; 0x1aec <xTaskResumeAll>
    14e0:	7e cf       	rjmp	.-260    	; 0x13de <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    14e2:	c8 01       	movw	r24, r16
    14e4:	c2 dd       	rcall	.-1148   	; 0x106a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14e6:	02 d3       	rcall	.+1540   	; 0x1aec <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14e8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    14ea:	0f 90       	pop	r0
    14ec:	0f 90       	pop	r0
    14ee:	0f 90       	pop	r0
    14f0:	0f 90       	pop	r0
    14f2:	0f 90       	pop	r0
    14f4:	df 91       	pop	r29
    14f6:	cf 91       	pop	r28
    14f8:	1f 91       	pop	r17
    14fa:	0f 91       	pop	r16
    14fc:	ff 90       	pop	r15
    14fe:	ef 90       	pop	r14
    1500:	df 90       	pop	r13
    1502:	cf 90       	pop	r12
    1504:	bf 90       	pop	r11
    1506:	af 90       	pop	r10
    1508:	9f 90       	pop	r9
    150a:	08 95       	ret

0000150c <ringBufferInit>:

#include <ringBuffer.h>


void ringBufferInit(ringBuffer *ring, unsigned char* buffer, unsigned char size)
{
    150c:	fc 01       	movw	r30, r24
	ring->rBuffer = buffer;
    150e:	71 83       	std	Z+1, r23	; 0x01
    1510:	60 83       	st	Z, r22
	ring->rSize = size;
    1512:	42 83       	std	Z+2, r20	; 0x02
	ring->rIndex = 0;
    1514:	14 82       	std	Z+4, r1	; 0x04
	ring->rLength = 0;	 
    1516:	13 82       	std	Z+3, r1	; 0x03
    1518:	08 95       	ret

0000151a <ringBufferPop>:
}


// int?
unsigned char ringBufferPop(ringBuffer *ring)
{
    151a:	fc 01       	movw	r30, r24
    unsigned char element;
	
            element = ring->rBuffer[ ring->rIndex ];
    151c:	94 81       	ldd	r25, Z+4	; 0x04
    151e:	a0 81       	ld	r26, Z
    1520:	b1 81       	ldd	r27, Z+1	; 0x01
    1522:	a9 0f       	add	r26, r25
    1524:	b1 1d       	adc	r27, r1
    1526:	8c 91       	ld	r24, X
            ring->rIndex ++;
    1528:	9f 5f       	subi	r25, 0xFF	; 255
    152a:	94 83       	std	Z+4, r25	; 0x04
            if ( ring->rIndex >= ring->rSize )
    152c:	22 81       	ldd	r18, Z+2	; 0x02
    152e:	92 17       	cp	r25, r18
    1530:	10 f0       	brcs	.+4      	; 0x1536 <ringBufferPop+0x1c>
            {
                ring->rIndex -= ring->rSize;
    1532:	92 1b       	sub	r25, r18
    1534:	94 83       	std	Z+4, r25	; 0x04
            }
            ring->rLength --;
    1536:	93 81       	ldd	r25, Z+3	; 0x03
    1538:	91 50       	subi	r25, 0x01	; 1
    153a:	93 83       	std	Z+3, r25	; 0x03
    
    return element;
}
    153c:	08 95       	ret

0000153e <ringBufferPush>:


void ringBufferPush( ringBuffer *ring, unsigned char element )
{
    153e:	fc 01       	movw	r30, r24
    1540:	46 2f       	mov	r20, r22
    
        if ( ring->rLength < ring->rSize )
    1542:	83 81       	ldd	r24, Z+3	; 0x03
    1544:	22 81       	ldd	r18, Z+2	; 0x02
    1546:	82 17       	cp	r24, r18
    1548:	78 f4       	brcc	.+30     	; 0x1568 <ringBufferPush+0x2a>
        {
            ring->rBuffer[ ( ring->rIndex + ring->rLength ) % ring->rSize ] = element;
    154a:	34 81       	ldd	r19, Z+4	; 0x04
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	83 0f       	add	r24, r19
    1550:	91 1d       	adc	r25, r1
    1552:	62 2f       	mov	r22, r18
    1554:	70 e0       	ldi	r23, 0x00	; 0
    1556:	f2 d5       	rcall	.+3044   	; 0x213c <__divmodhi4>
    1558:	a0 81       	ld	r26, Z
    155a:	b1 81       	ldd	r27, Z+1	; 0x01
    155c:	a8 0f       	add	r26, r24
    155e:	b9 1f       	adc	r27, r25
    1560:	4c 93       	st	X, r20
            ring->rLength++;
    1562:	83 81       	ldd	r24, Z+3	; 0x03
    1564:	8f 5f       	subi	r24, 0xFF	; 255
    1566:	83 83       	std	Z+3, r24	; 0x03
    1568:	08 95       	ret

0000156a <ringBufferFull>:


// return 1 if full
// return 0 if not full
char ringBufferFull(ringBuffer *ring)
{
    156a:	fc 01       	movw	r30, r24
   return (ring->rSize == ring->rLength);
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	22 81       	ldd	r18, Z+2	; 0x02
    1570:	93 81       	ldd	r25, Z+3	; 0x03
    1572:	29 13       	cpse	r18, r25
    1574:	80 e0       	ldi	r24, 0x00	; 0
}
    1576:	08 95       	ret

00001578 <ringBufferNotEmpty>:

// return 1 if not empty
// return 0 if empty
char ringBufferNotEmpty(ringBuffer *ring)
{
	return (ring->rLength > 0);
    1578:	21 e0       	ldi	r18, 0x01	; 1
    157a:	fc 01       	movw	r30, r24
    157c:	83 81       	ldd	r24, Z+3	; 0x03
    157e:	81 11       	cpse	r24, r1
    1580:	01 c0       	rjmp	.+2      	; 0x1584 <ringBufferNotEmpty+0xc>
    1582:	20 e0       	ldi	r18, 0x00	; 0
}
    1584:	82 2f       	mov	r24, r18
    1586:	08 95       	ret

00001588 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1588:	e0 91 9c 08 	lds	r30, 0x089C
    158c:	f0 91 9d 08 	lds	r31, 0x089D
    1590:	80 81       	ld	r24, Z
    1592:	81 11       	cpse	r24, r1
    1594:	07 c0       	rjmp	.+14     	; 0x15a4 <prvResetNextTaskUnblockTime+0x1c>
    1596:	8f ef       	ldi	r24, 0xFF	; 255
    1598:	9f ef       	ldi	r25, 0xFF	; 255
    159a:	90 93 05 02 	sts	0x0205, r25
    159e:	80 93 04 02 	sts	0x0204, r24
    15a2:	08 95       	ret
    15a4:	e0 91 9c 08 	lds	r30, 0x089C
    15a8:	f0 91 9d 08 	lds	r31, 0x089D
    15ac:	05 80       	ldd	r0, Z+5	; 0x05
    15ae:	f6 81       	ldd	r31, Z+6	; 0x06
    15b0:	e0 2d       	mov	r30, r0
    15b2:	06 80       	ldd	r0, Z+6	; 0x06
    15b4:	f7 81       	ldd	r31, Z+7	; 0x07
    15b6:	e0 2d       	mov	r30, r0
    15b8:	82 81       	ldd	r24, Z+2	; 0x02
    15ba:	93 81       	ldd	r25, Z+3	; 0x03
    15bc:	90 93 05 02 	sts	0x0205, r25
    15c0:	80 93 04 02 	sts	0x0204, r24
    15c4:	08 95       	ret

000015c6 <prvAddCurrentTaskToDelayedList>:
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	ec 01       	movw	r28, r24
    15cc:	e0 91 dd 08 	lds	r30, 0x08DD
    15d0:	f0 91 de 08 	lds	r31, 0x08DE
    15d4:	93 83       	std	Z+3, r25	; 0x03
    15d6:	82 83       	std	Z+2, r24	; 0x02
    15d8:	80 91 7b 08 	lds	r24, 0x087B
    15dc:	90 91 7c 08 	lds	r25, 0x087C
    15e0:	c8 17       	cp	r28, r24
    15e2:	d9 07       	cpc	r29, r25
    15e4:	68 f4       	brcc	.+26     	; 0x1600 <prvAddCurrentTaskToDelayedList+0x3a>
    15e6:	60 91 dd 08 	lds	r22, 0x08DD
    15ea:	70 91 de 08 	lds	r23, 0x08DE
    15ee:	80 91 9a 08 	lds	r24, 0x089A
    15f2:	90 91 9b 08 	lds	r25, 0x089B
    15f6:	6e 5f       	subi	r22, 0xFE	; 254
    15f8:	7f 4f       	sbci	r23, 0xFF	; 255
    15fa:	0e 94 43 02 	call	0x486	; 0x486 <vListInsert>
    15fe:	17 c0       	rjmp	.+46     	; 0x162e <prvAddCurrentTaskToDelayedList+0x68>
    1600:	60 91 dd 08 	lds	r22, 0x08DD
    1604:	70 91 de 08 	lds	r23, 0x08DE
    1608:	80 91 9c 08 	lds	r24, 0x089C
    160c:	90 91 9d 08 	lds	r25, 0x089D
    1610:	6e 5f       	subi	r22, 0xFE	; 254
    1612:	7f 4f       	sbci	r23, 0xFF	; 255
    1614:	0e 94 43 02 	call	0x486	; 0x486 <vListInsert>
    1618:	80 91 04 02 	lds	r24, 0x0204
    161c:	90 91 05 02 	lds	r25, 0x0205
    1620:	c8 17       	cp	r28, r24
    1622:	d9 07       	cpc	r29, r25
    1624:	20 f4       	brcc	.+8      	; 0x162e <prvAddCurrentTaskToDelayedList+0x68>
    1626:	d0 93 05 02 	sts	0x0205, r29
    162a:	c0 93 04 02 	sts	0x0204, r28
    162e:	df 91       	pop	r29
    1630:	cf 91       	pop	r28
    1632:	08 95       	ret

00001634 <xTaskGenericCreate>:
    1634:	4f 92       	push	r4
    1636:	5f 92       	push	r5
    1638:	6f 92       	push	r6
    163a:	7f 92       	push	r7
    163c:	8f 92       	push	r8
    163e:	9f 92       	push	r9
    1640:	af 92       	push	r10
    1642:	bf 92       	push	r11
    1644:	cf 92       	push	r12
    1646:	df 92       	push	r13
    1648:	ef 92       	push	r14
    164a:	ff 92       	push	r15
    164c:	0f 93       	push	r16
    164e:	1f 93       	push	r17
    1650:	cf 93       	push	r28
    1652:	df 93       	push	r29
    1654:	4c 01       	movw	r8, r24
    1656:	5b 01       	movw	r10, r22
    1658:	2a 01       	movw	r4, r20
    165a:	39 01       	movw	r6, r18
    165c:	83 e2       	ldi	r24, 0x23	; 35
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	0e 94 da 01 	call	0x3b4	; 0x3b4 <pvPortMalloc>
    1664:	ec 01       	movw	r28, r24
    1666:	00 97       	sbiw	r24, 0x00	; 0
    1668:	09 f4       	brne	.+2      	; 0x166c <xTaskGenericCreate+0x38>
    166a:	e7 c0       	rjmp	.+462    	; 0x183a <xTaskGenericCreate+0x206>
    166c:	c1 14       	cp	r12, r1
    166e:	d1 04       	cpc	r13, r1
    1670:	09 f0       	breq	.+2      	; 0x1674 <xTaskGenericCreate+0x40>
    1672:	cc c0       	rjmp	.+408    	; 0x180c <xTaskGenericCreate+0x1d8>
    1674:	c2 01       	movw	r24, r4
    1676:	0e 94 da 01 	call	0x3b4	; 0x3b4 <pvPortMalloc>
    167a:	98 8f       	std	Y+24, r25	; 0x18
    167c:	8f 8b       	std	Y+23, r24	; 0x17
    167e:	89 2b       	or	r24, r25
    1680:	09 f0       	breq	.+2      	; 0x1684 <xTaskGenericCreate+0x50>
    1682:	c6 c0       	rjmp	.+396    	; 0x1810 <xTaskGenericCreate+0x1dc>
    1684:	ce 01       	movw	r24, r28
    1686:	0e 94 0f 02 	call	0x41e	; 0x41e <vPortFree>
    168a:	d7 c0       	rjmp	.+430    	; 0x183a <xTaskGenericCreate+0x206>
    168c:	cf 01       	movw	r24, r30
    168e:	31 91       	ld	r19, Z+
    1690:	da 01       	movw	r26, r20
    1692:	3d 93       	st	X+, r19
    1694:	ad 01       	movw	r20, r26
    1696:	dc 01       	movw	r26, r24
    1698:	8c 91       	ld	r24, X
    169a:	88 23       	and	r24, r24
    169c:	11 f0       	breq	.+4      	; 0x16a2 <xTaskGenericCreate+0x6e>
    169e:	21 50       	subi	r18, 0x01	; 1
    16a0:	a9 f7       	brne	.-22     	; 0x168c <xTaskGenericCreate+0x58>
    16a2:	18 a2       	std	Y+32, r1	; 0x20
    16a4:	10 2f       	mov	r17, r16
    16a6:	05 30       	cpi	r16, 0x05	; 5
    16a8:	08 f0       	brcs	.+2      	; 0x16ac <xTaskGenericCreate+0x78>
    16aa:	14 e0       	ldi	r17, 0x04	; 4
    16ac:	1e 8b       	std	Y+22, r17	; 0x16
    16ae:	19 a3       	std	Y+33, r17	; 0x21
    16b0:	1a a2       	std	Y+34, r1	; 0x22
    16b2:	5e 01       	movw	r10, r28
    16b4:	b2 e0       	ldi	r27, 0x02	; 2
    16b6:	ab 0e       	add	r10, r27
    16b8:	b1 1c       	adc	r11, r1
    16ba:	c5 01       	movw	r24, r10
    16bc:	0e 94 1e 02 	call	0x43c	; 0x43c <vListInitialiseItem>
    16c0:	ce 01       	movw	r24, r28
    16c2:	0c 96       	adiw	r24, 0x0c	; 12
    16c4:	0e 94 1e 02 	call	0x43c	; 0x43c <vListInitialiseItem>
    16c8:	d9 87       	std	Y+9, r29	; 0x09
    16ca:	c8 87       	std	Y+8, r28	; 0x08
    16cc:	85 e0       	ldi	r24, 0x05	; 5
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	81 1b       	sub	r24, r17
    16d2:	91 09       	sbc	r25, r1
    16d4:	9d 87       	std	Y+13, r25	; 0x0d
    16d6:	8c 87       	std	Y+12, r24	; 0x0c
    16d8:	db 8b       	std	Y+19, r29	; 0x13
    16da:	ca 8b       	std	Y+18, r28	; 0x12
    16dc:	a3 01       	movw	r20, r6
    16de:	b4 01       	movw	r22, r8
    16e0:	c6 01       	movw	r24, r12
    16e2:	d4 da       	rcall	.-2648   	; 0xc8c <pxPortInitialiseStack>
    16e4:	99 83       	std	Y+1, r25	; 0x01
    16e6:	88 83       	st	Y, r24
    16e8:	e1 14       	cp	r14, r1
    16ea:	f1 04       	cpc	r15, r1
    16ec:	19 f0       	breq	.+6      	; 0x16f4 <xTaskGenericCreate+0xc0>
    16ee:	f7 01       	movw	r30, r14
    16f0:	d1 83       	std	Z+1, r29	; 0x01
    16f2:	c0 83       	st	Z, r28
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	0f 92       	push	r0
    16fa:	80 91 7d 08 	lds	r24, 0x087D
    16fe:	8f 5f       	subi	r24, 0xFF	; 255
    1700:	80 93 7d 08 	sts	0x087D, r24
    1704:	80 91 dd 08 	lds	r24, 0x08DD
    1708:	90 91 de 08 	lds	r25, 0x08DE
    170c:	89 2b       	or	r24, r25
    170e:	09 f0       	breq	.+2      	; 0x1712 <xTaskGenericCreate+0xde>
    1710:	3f c0       	rjmp	.+126    	; 0x1790 <xTaskGenericCreate+0x15c>
    1712:	d0 93 de 08 	sts	0x08DE, r29
    1716:	c0 93 dd 08 	sts	0x08DD, r28
    171a:	80 91 7d 08 	lds	r24, 0x087D
    171e:	81 30       	cpi	r24, 0x01	; 1
    1720:	09 f0       	breq	.+2      	; 0x1724 <xTaskGenericCreate+0xf0>
    1722:	45 c0       	rjmp	.+138    	; 0x17ae <xTaskGenericCreate+0x17a>
    1724:	0f 2e       	mov	r0, r31
    1726:	f0 eb       	ldi	r31, 0xB0	; 176
    1728:	ef 2e       	mov	r14, r31
    172a:	f8 e0       	ldi	r31, 0x08	; 8
    172c:	ff 2e       	mov	r15, r31
    172e:	f0 2d       	mov	r31, r0
    1730:	0f 2e       	mov	r0, r31
    1732:	fd ed       	ldi	r31, 0xDD	; 221
    1734:	cf 2e       	mov	r12, r31
    1736:	f8 e0       	ldi	r31, 0x08	; 8
    1738:	df 2e       	mov	r13, r31
    173a:	f0 2d       	mov	r31, r0
    173c:	c7 01       	movw	r24, r14
    173e:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    1742:	f9 e0       	ldi	r31, 0x09	; 9
    1744:	ef 0e       	add	r14, r31
    1746:	f1 1c       	adc	r15, r1
    1748:	ec 14       	cp	r14, r12
    174a:	fd 04       	cpc	r15, r13
    174c:	b9 f7       	brne	.-18     	; 0x173c <xTaskGenericCreate+0x108>
    174e:	87 ea       	ldi	r24, 0xA7	; 167
    1750:	98 e0       	ldi	r25, 0x08	; 8
    1752:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    1756:	8e e9       	ldi	r24, 0x9E	; 158
    1758:	98 e0       	ldi	r25, 0x08	; 8
    175a:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    175e:	81 e9       	ldi	r24, 0x91	; 145
    1760:	98 e0       	ldi	r25, 0x08	; 8
    1762:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    1766:	88 e8       	ldi	r24, 0x88	; 136
    1768:	98 e0       	ldi	r25, 0x08	; 8
    176a:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    176e:	8e e7       	ldi	r24, 0x7E	; 126
    1770:	98 e0       	ldi	r25, 0x08	; 8
    1772:	0e 94 10 02 	call	0x420	; 0x420 <vListInitialise>
    1776:	87 ea       	ldi	r24, 0xA7	; 167
    1778:	98 e0       	ldi	r25, 0x08	; 8
    177a:	90 93 9d 08 	sts	0x089D, r25
    177e:	80 93 9c 08 	sts	0x089C, r24
    1782:	8e e9       	ldi	r24, 0x9E	; 158
    1784:	98 e0       	ldi	r25, 0x08	; 8
    1786:	90 93 9b 08 	sts	0x089B, r25
    178a:	80 93 9a 08 	sts	0x089A, r24
    178e:	0f c0       	rjmp	.+30     	; 0x17ae <xTaskGenericCreate+0x17a>
    1790:	80 91 79 08 	lds	r24, 0x0879
    1794:	81 11       	cpse	r24, r1
    1796:	0b c0       	rjmp	.+22     	; 0x17ae <xTaskGenericCreate+0x17a>
    1798:	e0 91 dd 08 	lds	r30, 0x08DD
    179c:	f0 91 de 08 	lds	r31, 0x08DE
    17a0:	86 89       	ldd	r24, Z+22	; 0x16
    17a2:	08 17       	cp	r16, r24
    17a4:	20 f0       	brcs	.+8      	; 0x17ae <xTaskGenericCreate+0x17a>
    17a6:	d0 93 de 08 	sts	0x08DE, r29
    17aa:	c0 93 dd 08 	sts	0x08DD, r28
    17ae:	80 91 75 08 	lds	r24, 0x0875
    17b2:	8f 5f       	subi	r24, 0xFF	; 255
    17b4:	80 93 75 08 	sts	0x0875, r24
    17b8:	8e 89       	ldd	r24, Y+22	; 0x16
    17ba:	90 91 7a 08 	lds	r25, 0x087A
    17be:	98 17       	cp	r25, r24
    17c0:	10 f4       	brcc	.+4      	; 0x17c6 <xTaskGenericCreate+0x192>
    17c2:	80 93 7a 08 	sts	0x087A, r24
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	9c 01       	movw	r18, r24
    17ca:	22 0f       	add	r18, r18
    17cc:	33 1f       	adc	r19, r19
    17ce:	22 0f       	add	r18, r18
    17d0:	33 1f       	adc	r19, r19
    17d2:	22 0f       	add	r18, r18
    17d4:	33 1f       	adc	r19, r19
    17d6:	82 0f       	add	r24, r18
    17d8:	93 1f       	adc	r25, r19
    17da:	b5 01       	movw	r22, r10
    17dc:	80 55       	subi	r24, 0x50	; 80
    17de:	97 4f       	sbci	r25, 0xF7	; 247
    17e0:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    17e4:	0f 90       	pop	r0
    17e6:	0f be       	out	0x3f, r0	; 63
    17e8:	80 91 79 08 	lds	r24, 0x0879
    17ec:	88 23       	and	r24, r24
    17ee:	51 f0       	breq	.+20     	; 0x1804 <xTaskGenericCreate+0x1d0>
    17f0:	e0 91 dd 08 	lds	r30, 0x08DD
    17f4:	f0 91 de 08 	lds	r31, 0x08DE
    17f8:	86 89       	ldd	r24, Z+22	; 0x16
    17fa:	80 17       	cp	r24, r16
    17fc:	28 f4       	brcc	.+10     	; 0x1808 <xTaskGenericCreate+0x1d4>
    17fe:	f5 da       	rcall	.-2582   	; 0xdea <vPortYield>
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	1c c0       	rjmp	.+56     	; 0x183c <xTaskGenericCreate+0x208>
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	1a c0       	rjmp	.+52     	; 0x183c <xTaskGenericCreate+0x208>
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	18 c0       	rjmp	.+48     	; 0x183c <xTaskGenericCreate+0x208>
    180c:	d8 8e       	std	Y+24, r13	; 0x18
    180e:	cf 8a       	std	Y+23, r12	; 0x17
    1810:	81 e0       	ldi	r24, 0x01	; 1
    1812:	48 1a       	sub	r4, r24
    1814:	51 08       	sbc	r5, r1
    1816:	cf 88       	ldd	r12, Y+23	; 0x17
    1818:	d8 8c       	ldd	r13, Y+24	; 0x18
    181a:	c4 0c       	add	r12, r4
    181c:	d5 1c       	adc	r13, r5
    181e:	d5 01       	movw	r26, r10
    1820:	8c 91       	ld	r24, X
    1822:	89 8f       	std	Y+25, r24	; 0x19
    1824:	8c 91       	ld	r24, X
    1826:	88 23       	and	r24, r24
    1828:	09 f4       	brne	.+2      	; 0x182c <xTaskGenericCreate+0x1f8>
    182a:	3b cf       	rjmp	.-394    	; 0x16a2 <xTaskGenericCreate+0x6e>
    182c:	ae 01       	movw	r20, r28
    182e:	46 5e       	subi	r20, 0xE6	; 230
    1830:	5f 4f       	sbci	r21, 0xFF	; 255
    1832:	f5 01       	movw	r30, r10
    1834:	31 96       	adiw	r30, 0x01	; 1
    1836:	27 e0       	ldi	r18, 0x07	; 7
    1838:	29 cf       	rjmp	.-430    	; 0x168c <xTaskGenericCreate+0x58>
    183a:	8f ef       	ldi	r24, 0xFF	; 255
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	df 90       	pop	r13
    184a:	cf 90       	pop	r12
    184c:	bf 90       	pop	r11
    184e:	af 90       	pop	r10
    1850:	9f 90       	pop	r9
    1852:	8f 90       	pop	r8
    1854:	7f 90       	pop	r7
    1856:	6f 90       	pop	r6
    1858:	5f 90       	pop	r5
    185a:	4f 90       	pop	r4
    185c:	08 95       	ret

0000185e <vTaskResume>:
    185e:	0f 93       	push	r16
    1860:	1f 93       	push	r17
    1862:	cf 93       	push	r28
    1864:	df 93       	push	r29
    1866:	ec 01       	movw	r28, r24
    1868:	00 97       	sbiw	r24, 0x00	; 0
    186a:	09 f4       	brne	.+2      	; 0x186e <vTaskResume+0x10>
    186c:	3e c0       	rjmp	.+124    	; 0x18ea <vTaskResume+0x8c>
    186e:	80 91 dd 08 	lds	r24, 0x08DD
    1872:	90 91 de 08 	lds	r25, 0x08DE
    1876:	c8 17       	cp	r28, r24
    1878:	d9 07       	cpc	r29, r25
    187a:	b9 f1       	breq	.+110    	; 0x18ea <vTaskResume+0x8c>
    187c:	0f b6       	in	r0, 0x3f	; 63
    187e:	f8 94       	cli
    1880:	0f 92       	push	r0
    1882:	8a 85       	ldd	r24, Y+10	; 0x0a
    1884:	9b 85       	ldd	r25, Y+11	; 0x0b
    1886:	8e 57       	subi	r24, 0x7E	; 126
    1888:	98 40       	sbci	r25, 0x08	; 8
    188a:	69 f5       	brne	.+90     	; 0x18e6 <vTaskResume+0x88>
    188c:	8c 89       	ldd	r24, Y+20	; 0x14
    188e:	9d 89       	ldd	r25, Y+21	; 0x15
    1890:	28 e0       	ldi	r18, 0x08	; 8
    1892:	81 39       	cpi	r24, 0x91	; 145
    1894:	92 07       	cpc	r25, r18
    1896:	39 f1       	breq	.+78     	; 0x18e6 <vTaskResume+0x88>
    1898:	89 2b       	or	r24, r25
    189a:	29 f5       	brne	.+74     	; 0x18e6 <vTaskResume+0x88>
    189c:	8e 01       	movw	r16, r28
    189e:	0e 5f       	subi	r16, 0xFE	; 254
    18a0:	1f 4f       	sbci	r17, 0xFF	; 255
    18a2:	c8 01       	movw	r24, r16
    18a4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    18a8:	8e 89       	ldd	r24, Y+22	; 0x16
    18aa:	90 91 7a 08 	lds	r25, 0x087A
    18ae:	98 17       	cp	r25, r24
    18b0:	10 f4       	brcc	.+4      	; 0x18b6 <vTaskResume+0x58>
    18b2:	80 93 7a 08 	sts	0x087A, r24
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	9c 01       	movw	r18, r24
    18ba:	22 0f       	add	r18, r18
    18bc:	33 1f       	adc	r19, r19
    18be:	22 0f       	add	r18, r18
    18c0:	33 1f       	adc	r19, r19
    18c2:	22 0f       	add	r18, r18
    18c4:	33 1f       	adc	r19, r19
    18c6:	82 0f       	add	r24, r18
    18c8:	93 1f       	adc	r25, r19
    18ca:	b8 01       	movw	r22, r16
    18cc:	80 55       	subi	r24, 0x50	; 80
    18ce:	97 4f       	sbci	r25, 0xF7	; 247
    18d0:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    18d4:	e0 91 dd 08 	lds	r30, 0x08DD
    18d8:	f0 91 de 08 	lds	r31, 0x08DE
    18dc:	9e 89       	ldd	r25, Y+22	; 0x16
    18de:	86 89       	ldd	r24, Z+22	; 0x16
    18e0:	98 17       	cp	r25, r24
    18e2:	08 f0       	brcs	.+2      	; 0x18e6 <vTaskResume+0x88>
    18e4:	82 da       	rcall	.-2812   	; 0xdea <vPortYield>
    18e6:	0f 90       	pop	r0
    18e8:	0f be       	out	0x3f, r0	; 63
    18ea:	df 91       	pop	r29
    18ec:	cf 91       	pop	r28
    18ee:	1f 91       	pop	r17
    18f0:	0f 91       	pop	r16
    18f2:	08 95       	ret

000018f4 <vTaskStartScheduler>:
    18f4:	af 92       	push	r10
    18f6:	bf 92       	push	r11
    18f8:	cf 92       	push	r12
    18fa:	df 92       	push	r13
    18fc:	ef 92       	push	r14
    18fe:	ff 92       	push	r15
    1900:	0f 93       	push	r16
    1902:	a1 2c       	mov	r10, r1
    1904:	b1 2c       	mov	r11, r1
    1906:	c1 2c       	mov	r12, r1
    1908:	d1 2c       	mov	r13, r1
    190a:	e1 2c       	mov	r14, r1
    190c:	f1 2c       	mov	r15, r1
    190e:	00 e0       	ldi	r16, 0x00	; 0
    1910:	20 e0       	ldi	r18, 0x00	; 0
    1912:	30 e0       	ldi	r19, 0x00	; 0
    1914:	45 e5       	ldi	r20, 0x55	; 85
    1916:	50 e0       	ldi	r21, 0x00	; 0
    1918:	6f e8       	ldi	r22, 0x8F	; 143
    191a:	72 e0       	ldi	r23, 0x02	; 2
    191c:	81 e5       	ldi	r24, 0x51	; 81
    191e:	9e e0       	ldi	r25, 0x0E	; 14
    1920:	89 de       	rcall	.-750    	; 0x1634 <xTaskGenericCreate>
    1922:	81 30       	cpi	r24, 0x01	; 1
    1924:	41 f4       	brne	.+16     	; 0x1936 <vTaskStartScheduler+0x42>
    1926:	f8 94       	cli
    1928:	80 93 79 08 	sts	0x0879, r24
    192c:	10 92 7c 08 	sts	0x087C, r1
    1930:	10 92 7b 08 	sts	0x087B, r1
    1934:	1d da       	rcall	.-3014   	; 0xd70 <xPortStartScheduler>
    1936:	0f 91       	pop	r16
    1938:	ff 90       	pop	r15
    193a:	ef 90       	pop	r14
    193c:	df 90       	pop	r13
    193e:	cf 90       	pop	r12
    1940:	bf 90       	pop	r11
    1942:	af 90       	pop	r10
    1944:	08 95       	ret

00001946 <vTaskSuspendAll>:
    1946:	80 91 74 08 	lds	r24, 0x0874
    194a:	8f 5f       	subi	r24, 0xFF	; 255
    194c:	80 93 74 08 	sts	0x0874, r24
    1950:	08 95       	ret

00001952 <xTaskGetTickCount>:
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	0f 92       	push	r0
    1958:	80 91 7b 08 	lds	r24, 0x087B
    195c:	90 91 7c 08 	lds	r25, 0x087C
    1960:	0f 90       	pop	r0
    1962:	0f be       	out	0x3f, r0	; 63
    1964:	08 95       	ret

00001966 <xTaskGetTickCountFromISR>:
    1966:	80 91 7b 08 	lds	r24, 0x087B
    196a:	90 91 7c 08 	lds	r25, 0x087C
    196e:	08 95       	ret

00001970 <xTaskIncrementTick>:
    1970:	cf 92       	push	r12
    1972:	df 92       	push	r13
    1974:	ef 92       	push	r14
    1976:	ff 92       	push	r15
    1978:	0f 93       	push	r16
    197a:	1f 93       	push	r17
    197c:	cf 93       	push	r28
    197e:	df 93       	push	r29
    1980:	80 91 74 08 	lds	r24, 0x0874
    1984:	81 11       	cpse	r24, r1
    1986:	99 c0       	rjmp	.+306    	; 0x1aba <xTaskIncrementTick+0x14a>
    1988:	80 91 7b 08 	lds	r24, 0x087B
    198c:	90 91 7c 08 	lds	r25, 0x087C
    1990:	01 96       	adiw	r24, 0x01	; 1
    1992:	90 93 7c 08 	sts	0x087C, r25
    1996:	80 93 7b 08 	sts	0x087B, r24
    199a:	e0 90 7b 08 	lds	r14, 0x087B
    199e:	f0 90 7c 08 	lds	r15, 0x087C
    19a2:	e1 14       	cp	r14, r1
    19a4:	f1 04       	cpc	r15, r1
    19a6:	b1 f4       	brne	.+44     	; 0x19d4 <xTaskIncrementTick+0x64>
    19a8:	80 91 9c 08 	lds	r24, 0x089C
    19ac:	90 91 9d 08 	lds	r25, 0x089D
    19b0:	20 91 9a 08 	lds	r18, 0x089A
    19b4:	30 91 9b 08 	lds	r19, 0x089B
    19b8:	30 93 9d 08 	sts	0x089D, r19
    19bc:	20 93 9c 08 	sts	0x089C, r18
    19c0:	90 93 9b 08 	sts	0x089B, r25
    19c4:	80 93 9a 08 	sts	0x089A, r24
    19c8:	80 91 76 08 	lds	r24, 0x0876
    19cc:	8f 5f       	subi	r24, 0xFF	; 255
    19ce:	80 93 76 08 	sts	0x0876, r24
    19d2:	da dd       	rcall	.-1100   	; 0x1588 <prvResetNextTaskUnblockTime>
    19d4:	80 91 04 02 	lds	r24, 0x0204
    19d8:	90 91 05 02 	lds	r25, 0x0205
    19dc:	e8 16       	cp	r14, r24
    19de:	f9 06       	cpc	r15, r25
    19e0:	08 f4       	brcc	.+2      	; 0x19e4 <xTaskIncrementTick+0x74>
    19e2:	54 c0       	rjmp	.+168    	; 0x1a8c <xTaskIncrementTick+0x11c>
    19e4:	d1 2c       	mov	r13, r1
    19e6:	cc 24       	eor	r12, r12
    19e8:	c3 94       	inc	r12
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <xTaskIncrementTick+0x7e>
    19ec:	dc 2c       	mov	r13, r12
    19ee:	e0 91 9c 08 	lds	r30, 0x089C
    19f2:	f0 91 9d 08 	lds	r31, 0x089D
    19f6:	80 81       	ld	r24, Z
    19f8:	81 11       	cpse	r24, r1
    19fa:	07 c0       	rjmp	.+14     	; 0x1a0a <xTaskIncrementTick+0x9a>
    19fc:	8f ef       	ldi	r24, 0xFF	; 255
    19fe:	9f ef       	ldi	r25, 0xFF	; 255
    1a00:	90 93 05 02 	sts	0x0205, r25
    1a04:	80 93 04 02 	sts	0x0204, r24
    1a08:	42 c0       	rjmp	.+132    	; 0x1a8e <xTaskIncrementTick+0x11e>
    1a0a:	e0 91 9c 08 	lds	r30, 0x089C
    1a0e:	f0 91 9d 08 	lds	r31, 0x089D
    1a12:	05 80       	ldd	r0, Z+5	; 0x05
    1a14:	f6 81       	ldd	r31, Z+6	; 0x06
    1a16:	e0 2d       	mov	r30, r0
    1a18:	c6 81       	ldd	r28, Z+6	; 0x06
    1a1a:	d7 81       	ldd	r29, Z+7	; 0x07
    1a1c:	2a 81       	ldd	r18, Y+2	; 0x02
    1a1e:	3b 81       	ldd	r19, Y+3	; 0x03
    1a20:	e2 16       	cp	r14, r18
    1a22:	f3 06       	cpc	r15, r19
    1a24:	28 f4       	brcc	.+10     	; 0x1a30 <xTaskIncrementTick+0xc0>
    1a26:	30 93 05 02 	sts	0x0205, r19
    1a2a:	20 93 04 02 	sts	0x0204, r18
    1a2e:	2f c0       	rjmp	.+94     	; 0x1a8e <xTaskIncrementTick+0x11e>
    1a30:	8e 01       	movw	r16, r28
    1a32:	0e 5f       	subi	r16, 0xFE	; 254
    1a34:	1f 4f       	sbci	r17, 0xFF	; 255
    1a36:	c8 01       	movw	r24, r16
    1a38:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1a3c:	8c 89       	ldd	r24, Y+20	; 0x14
    1a3e:	9d 89       	ldd	r25, Y+21	; 0x15
    1a40:	89 2b       	or	r24, r25
    1a42:	21 f0       	breq	.+8      	; 0x1a4c <xTaskIncrementTick+0xdc>
    1a44:	ce 01       	movw	r24, r28
    1a46:	0c 96       	adiw	r24, 0x0c	; 12
    1a48:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1a4c:	2e 89       	ldd	r18, Y+22	; 0x16
    1a4e:	80 91 7a 08 	lds	r24, 0x087A
    1a52:	82 17       	cp	r24, r18
    1a54:	10 f4       	brcc	.+4      	; 0x1a5a <xTaskIncrementTick+0xea>
    1a56:	20 93 7a 08 	sts	0x087A, r18
    1a5a:	30 e0       	ldi	r19, 0x00	; 0
    1a5c:	c9 01       	movw	r24, r18
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	88 0f       	add	r24, r24
    1a64:	99 1f       	adc	r25, r25
    1a66:	88 0f       	add	r24, r24
    1a68:	99 1f       	adc	r25, r25
    1a6a:	82 0f       	add	r24, r18
    1a6c:	93 1f       	adc	r25, r19
    1a6e:	b8 01       	movw	r22, r16
    1a70:	80 55       	subi	r24, 0x50	; 80
    1a72:	97 4f       	sbci	r25, 0xF7	; 247
    1a74:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1a78:	e0 91 dd 08 	lds	r30, 0x08DD
    1a7c:	f0 91 de 08 	lds	r31, 0x08DE
    1a80:	9e 89       	ldd	r25, Y+22	; 0x16
    1a82:	86 89       	ldd	r24, Z+22	; 0x16
    1a84:	98 17       	cp	r25, r24
    1a86:	08 f0       	brcs	.+2      	; 0x1a8a <xTaskIncrementTick+0x11a>
    1a88:	b1 cf       	rjmp	.-158    	; 0x19ec <xTaskIncrementTick+0x7c>
    1a8a:	b1 cf       	rjmp	.-158    	; 0x19ee <xTaskIncrementTick+0x7e>
    1a8c:	d1 2c       	mov	r13, r1
    1a8e:	e0 91 dd 08 	lds	r30, 0x08DD
    1a92:	f0 91 de 08 	lds	r31, 0x08DE
    1a96:	86 89       	ldd	r24, Z+22	; 0x16
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	ee 0f       	add	r30, r30
    1a9e:	ff 1f       	adc	r31, r31
    1aa0:	ee 0f       	add	r30, r30
    1aa2:	ff 1f       	adc	r31, r31
    1aa4:	ee 0f       	add	r30, r30
    1aa6:	ff 1f       	adc	r31, r31
    1aa8:	8e 0f       	add	r24, r30
    1aaa:	9f 1f       	adc	r25, r31
    1aac:	fc 01       	movw	r30, r24
    1aae:	e0 55       	subi	r30, 0x50	; 80
    1ab0:	f7 4f       	sbci	r31, 0xF7	; 247
    1ab2:	80 81       	ld	r24, Z
    1ab4:	82 30       	cpi	r24, 0x02	; 2
    1ab6:	40 f4       	brcc	.+16     	; 0x1ac8 <xTaskIncrementTick+0x158>
    1ab8:	09 c0       	rjmp	.+18     	; 0x1acc <xTaskIncrementTick+0x15c>
    1aba:	80 91 78 08 	lds	r24, 0x0878
    1abe:	8f 5f       	subi	r24, 0xFF	; 255
    1ac0:	80 93 78 08 	sts	0x0878, r24
    1ac4:	d1 2c       	mov	r13, r1
    1ac6:	02 c0       	rjmp	.+4      	; 0x1acc <xTaskIncrementTick+0x15c>
    1ac8:	dd 24       	eor	r13, r13
    1aca:	d3 94       	inc	r13
    1acc:	80 91 77 08 	lds	r24, 0x0877
    1ad0:	88 23       	and	r24, r24
    1ad2:	11 f0       	breq	.+4      	; 0x1ad8 <xTaskIncrementTick+0x168>
    1ad4:	dd 24       	eor	r13, r13
    1ad6:	d3 94       	inc	r13
    1ad8:	8d 2d       	mov	r24, r13
    1ada:	df 91       	pop	r29
    1adc:	cf 91       	pop	r28
    1ade:	1f 91       	pop	r17
    1ae0:	0f 91       	pop	r16
    1ae2:	ff 90       	pop	r15
    1ae4:	ef 90       	pop	r14
    1ae6:	df 90       	pop	r13
    1ae8:	cf 90       	pop	r12
    1aea:	08 95       	ret

00001aec <xTaskResumeAll>:
    1aec:	df 92       	push	r13
    1aee:	ef 92       	push	r14
    1af0:	ff 92       	push	r15
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	cf 93       	push	r28
    1af8:	df 93       	push	r29
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	0f 92       	push	r0
    1b00:	80 91 74 08 	lds	r24, 0x0874
    1b04:	81 50       	subi	r24, 0x01	; 1
    1b06:	80 93 74 08 	sts	0x0874, r24
    1b0a:	80 91 74 08 	lds	r24, 0x0874
    1b0e:	81 11       	cpse	r24, r1
    1b10:	5f c0       	rjmp	.+190    	; 0x1bd0 <xTaskResumeAll+0xe4>
    1b12:	80 91 7d 08 	lds	r24, 0x087D
    1b16:	88 23       	and	r24, r24
    1b18:	09 f4       	brne	.+2      	; 0x1b1c <xTaskResumeAll+0x30>
    1b1a:	5c c0       	rjmp	.+184    	; 0x1bd4 <xTaskResumeAll+0xe8>
    1b1c:	0f 2e       	mov	r0, r31
    1b1e:	f1 e9       	ldi	r31, 0x91	; 145
    1b20:	ef 2e       	mov	r14, r31
    1b22:	f8 e0       	ldi	r31, 0x08	; 8
    1b24:	ff 2e       	mov	r15, r31
    1b26:	f0 2d       	mov	r31, r0
    1b28:	dd 24       	eor	r13, r13
    1b2a:	d3 94       	inc	r13
    1b2c:	30 c0       	rjmp	.+96     	; 0x1b8e <xTaskResumeAll+0xa2>
    1b2e:	e0 91 96 08 	lds	r30, 0x0896
    1b32:	f0 91 97 08 	lds	r31, 0x0897
    1b36:	c6 81       	ldd	r28, Z+6	; 0x06
    1b38:	d7 81       	ldd	r29, Z+7	; 0x07
    1b3a:	ce 01       	movw	r24, r28
    1b3c:	0c 96       	adiw	r24, 0x0c	; 12
    1b3e:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1b42:	8e 01       	movw	r16, r28
    1b44:	0e 5f       	subi	r16, 0xFE	; 254
    1b46:	1f 4f       	sbci	r17, 0xFF	; 255
    1b48:	c8 01       	movw	r24, r16
    1b4a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1b4e:	8e 89       	ldd	r24, Y+22	; 0x16
    1b50:	90 91 7a 08 	lds	r25, 0x087A
    1b54:	98 17       	cp	r25, r24
    1b56:	10 f4       	brcc	.+4      	; 0x1b5c <xTaskResumeAll+0x70>
    1b58:	80 93 7a 08 	sts	0x087A, r24
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	9c 01       	movw	r18, r24
    1b60:	22 0f       	add	r18, r18
    1b62:	33 1f       	adc	r19, r19
    1b64:	22 0f       	add	r18, r18
    1b66:	33 1f       	adc	r19, r19
    1b68:	22 0f       	add	r18, r18
    1b6a:	33 1f       	adc	r19, r19
    1b6c:	82 0f       	add	r24, r18
    1b6e:	93 1f       	adc	r25, r19
    1b70:	b8 01       	movw	r22, r16
    1b72:	80 55       	subi	r24, 0x50	; 80
    1b74:	97 4f       	sbci	r25, 0xF7	; 247
    1b76:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1b7a:	e0 91 dd 08 	lds	r30, 0x08DD
    1b7e:	f0 91 de 08 	lds	r31, 0x08DE
    1b82:	9e 89       	ldd	r25, Y+22	; 0x16
    1b84:	86 89       	ldd	r24, Z+22	; 0x16
    1b86:	98 17       	cp	r25, r24
    1b88:	10 f0       	brcs	.+4      	; 0x1b8e <xTaskResumeAll+0xa2>
    1b8a:	d0 92 77 08 	sts	0x0877, r13
    1b8e:	f7 01       	movw	r30, r14
    1b90:	80 81       	ld	r24, Z
    1b92:	81 11       	cpse	r24, r1
    1b94:	cc cf       	rjmp	.-104    	; 0x1b2e <xTaskResumeAll+0x42>
    1b96:	80 91 78 08 	lds	r24, 0x0878
    1b9a:	88 23       	and	r24, r24
    1b9c:	91 f0       	breq	.+36     	; 0x1bc2 <xTaskResumeAll+0xd6>
    1b9e:	80 91 78 08 	lds	r24, 0x0878
    1ba2:	88 23       	and	r24, r24
    1ba4:	71 f0       	breq	.+28     	; 0x1bc2 <xTaskResumeAll+0xd6>
    1ba6:	c1 e0       	ldi	r28, 0x01	; 1
    1ba8:	e3 de       	rcall	.-570    	; 0x1970 <xTaskIncrementTick>
    1baa:	81 11       	cpse	r24, r1
    1bac:	c0 93 77 08 	sts	0x0877, r28
    1bb0:	80 91 78 08 	lds	r24, 0x0878
    1bb4:	81 50       	subi	r24, 0x01	; 1
    1bb6:	80 93 78 08 	sts	0x0878, r24
    1bba:	80 91 78 08 	lds	r24, 0x0878
    1bbe:	81 11       	cpse	r24, r1
    1bc0:	f3 cf       	rjmp	.-26     	; 0x1ba8 <xTaskResumeAll+0xbc>
    1bc2:	80 91 77 08 	lds	r24, 0x0877
    1bc6:	81 30       	cpi	r24, 0x01	; 1
    1bc8:	39 f4       	brne	.+14     	; 0x1bd8 <xTaskResumeAll+0xec>
    1bca:	0f d9       	rcall	.-3554   	; 0xdea <vPortYield>
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	05 c0       	rjmp	.+10     	; 0x1bda <xTaskResumeAll+0xee>
    1bd0:	80 e0       	ldi	r24, 0x00	; 0
    1bd2:	03 c0       	rjmp	.+6      	; 0x1bda <xTaskResumeAll+0xee>
    1bd4:	80 e0       	ldi	r24, 0x00	; 0
    1bd6:	01 c0       	rjmp	.+2      	; 0x1bda <xTaskResumeAll+0xee>
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	0f 90       	pop	r0
    1bdc:	0f be       	out	0x3f, r0	; 63
    1bde:	df 91       	pop	r29
    1be0:	cf 91       	pop	r28
    1be2:	1f 91       	pop	r17
    1be4:	0f 91       	pop	r16
    1be6:	ff 90       	pop	r15
    1be8:	ef 90       	pop	r14
    1bea:	df 90       	pop	r13
    1bec:	08 95       	ret

00001bee <vTaskDelayUntil>:
    1bee:	0f 93       	push	r16
    1bf0:	1f 93       	push	r17
    1bf2:	cf 93       	push	r28
    1bf4:	df 93       	push	r29
    1bf6:	8c 01       	movw	r16, r24
    1bf8:	eb 01       	movw	r28, r22
    1bfa:	a5 de       	rcall	.-694    	; 0x1946 <vTaskSuspendAll>
    1bfc:	80 91 7b 08 	lds	r24, 0x087B
    1c00:	90 91 7c 08 	lds	r25, 0x087C
    1c04:	f8 01       	movw	r30, r16
    1c06:	20 81       	ld	r18, Z
    1c08:	31 81       	ldd	r19, Z+1	; 0x01
    1c0a:	c2 0f       	add	r28, r18
    1c0c:	d3 1f       	adc	r29, r19
    1c0e:	82 17       	cp	r24, r18
    1c10:	93 07       	cpc	r25, r19
    1c12:	48 f4       	brcc	.+18     	; 0x1c26 <vTaskDelayUntil+0x38>
    1c14:	c2 17       	cp	r28, r18
    1c16:	d3 07       	cpc	r29, r19
    1c18:	f8 f4       	brcc	.+62     	; 0x1c58 <vTaskDelayUntil+0x6a>
    1c1a:	d1 83       	std	Z+1, r29	; 0x01
    1c1c:	c0 83       	st	Z, r28
    1c1e:	8c 17       	cp	r24, r28
    1c20:	9d 07       	cpc	r25, r29
    1c22:	88 f4       	brcc	.+34     	; 0x1c46 <vTaskDelayUntil+0x58>
    1c24:	07 c0       	rjmp	.+14     	; 0x1c34 <vTaskDelayUntil+0x46>
    1c26:	c2 17       	cp	r28, r18
    1c28:	d3 07       	cpc	r29, r19
    1c2a:	90 f0       	brcs	.+36     	; 0x1c50 <vTaskDelayUntil+0x62>
    1c2c:	8c 17       	cp	r24, r28
    1c2e:	9d 07       	cpc	r25, r29
    1c30:	78 f0       	brcs	.+30     	; 0x1c50 <vTaskDelayUntil+0x62>
    1c32:	12 c0       	rjmp	.+36     	; 0x1c58 <vTaskDelayUntil+0x6a>
    1c34:	80 91 dd 08 	lds	r24, 0x08DD
    1c38:	90 91 de 08 	lds	r25, 0x08DE
    1c3c:	02 96       	adiw	r24, 0x02	; 2
    1c3e:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1c42:	ce 01       	movw	r24, r28
    1c44:	c0 dc       	rcall	.-1664   	; 0x15c6 <prvAddCurrentTaskToDelayedList>
    1c46:	52 df       	rcall	.-348    	; 0x1aec <xTaskResumeAll>
    1c48:	81 11       	cpse	r24, r1
    1c4a:	0a c0       	rjmp	.+20     	; 0x1c60 <vTaskDelayUntil+0x72>
    1c4c:	ce d8       	rcall	.-3684   	; 0xdea <vPortYield>
    1c4e:	08 c0       	rjmp	.+16     	; 0x1c60 <vTaskDelayUntil+0x72>
    1c50:	f8 01       	movw	r30, r16
    1c52:	d1 83       	std	Z+1, r29	; 0x01
    1c54:	c0 83       	st	Z, r28
    1c56:	ee cf       	rjmp	.-36     	; 0x1c34 <vTaskDelayUntil+0x46>
    1c58:	f8 01       	movw	r30, r16
    1c5a:	d1 83       	std	Z+1, r29	; 0x01
    1c5c:	c0 83       	st	Z, r28
    1c5e:	f3 cf       	rjmp	.-26     	; 0x1c46 <vTaskDelayUntil+0x58>
    1c60:	df 91       	pop	r29
    1c62:	cf 91       	pop	r28
    1c64:	1f 91       	pop	r17
    1c66:	0f 91       	pop	r16
    1c68:	08 95       	ret

00001c6a <vTaskDelay>:
    1c6a:	cf 93       	push	r28
    1c6c:	df 93       	push	r29
    1c6e:	ec 01       	movw	r28, r24
    1c70:	00 97       	sbiw	r24, 0x00	; 0
    1c72:	99 f0       	breq	.+38     	; 0x1c9a <vTaskDelay+0x30>
    1c74:	68 de       	rcall	.-816    	; 0x1946 <vTaskSuspendAll>
    1c76:	80 91 7b 08 	lds	r24, 0x087B
    1c7a:	90 91 7c 08 	lds	r25, 0x087C
    1c7e:	c8 0f       	add	r28, r24
    1c80:	d9 1f       	adc	r29, r25
    1c82:	80 91 dd 08 	lds	r24, 0x08DD
    1c86:	90 91 de 08 	lds	r25, 0x08DE
    1c8a:	02 96       	adiw	r24, 0x02	; 2
    1c8c:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1c90:	ce 01       	movw	r24, r28
    1c92:	99 dc       	rcall	.-1742   	; 0x15c6 <prvAddCurrentTaskToDelayedList>
    1c94:	2b df       	rcall	.-426    	; 0x1aec <xTaskResumeAll>
    1c96:	81 11       	cpse	r24, r1
    1c98:	01 c0       	rjmp	.+2      	; 0x1c9c <vTaskDelay+0x32>
    1c9a:	a7 d8       	rcall	.-3762   	; 0xdea <vPortYield>
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <prvIdleTask>:
    1ca2:	0f 2e       	mov	r0, r31
    1ca4:	f0 eb       	ldi	r31, 0xB0	; 176
    1ca6:	ef 2e       	mov	r14, r31
    1ca8:	f8 e0       	ldi	r31, 0x08	; 8
    1caa:	ff 2e       	mov	r15, r31
    1cac:	f0 2d       	mov	r31, r0
    1cae:	c8 e8       	ldi	r28, 0x88	; 136
    1cb0:	d8 e0       	ldi	r29, 0x08	; 8
    1cb2:	26 c0       	rjmp	.+76     	; 0x1d00 <prvIdleTask+0x5e>
    1cb4:	48 de       	rcall	.-880    	; 0x1946 <vTaskSuspendAll>
    1cb6:	18 81       	ld	r17, Y
    1cb8:	19 df       	rcall	.-462    	; 0x1aec <xTaskResumeAll>
    1cba:	11 23       	and	r17, r17
    1cbc:	09 f1       	breq	.+66     	; 0x1d00 <prvIdleTask+0x5e>
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	0f 92       	push	r0
    1cc4:	e0 91 8d 08 	lds	r30, 0x088D
    1cc8:	f0 91 8e 08 	lds	r31, 0x088E
    1ccc:	06 81       	ldd	r16, Z+6	; 0x06
    1cce:	17 81       	ldd	r17, Z+7	; 0x07
    1cd0:	c8 01       	movw	r24, r16
    1cd2:	02 96       	adiw	r24, 0x02	; 2
    1cd4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1cd8:	80 91 7d 08 	lds	r24, 0x087D
    1cdc:	81 50       	subi	r24, 0x01	; 1
    1cde:	80 93 7d 08 	sts	0x087D, r24
    1ce2:	80 91 87 08 	lds	r24, 0x0887
    1ce6:	81 50       	subi	r24, 0x01	; 1
    1ce8:	80 93 87 08 	sts	0x0887, r24
    1cec:	0f 90       	pop	r0
    1cee:	0f be       	out	0x3f, r0	; 63
    1cf0:	f8 01       	movw	r30, r16
    1cf2:	87 89       	ldd	r24, Z+23	; 0x17
    1cf4:	90 8d       	ldd	r25, Z+24	; 0x18
    1cf6:	0e 94 0f 02 	call	0x41e	; 0x41e <vPortFree>
    1cfa:	c8 01       	movw	r24, r16
    1cfc:	0e 94 0f 02 	call	0x41e	; 0x41e <vPortFree>
    1d00:	80 91 87 08 	lds	r24, 0x0887
    1d04:	81 11       	cpse	r24, r1
    1d06:	d6 cf       	rjmp	.-84     	; 0x1cb4 <prvIdleTask+0x12>
    1d08:	f7 01       	movw	r30, r14
    1d0a:	80 81       	ld	r24, Z
    1d0c:	82 30       	cpi	r24, 0x02	; 2
    1d0e:	c0 f3       	brcs	.-16     	; 0x1d00 <prvIdleTask+0x5e>
    1d10:	6c d8       	rcall	.-3880   	; 0xdea <vPortYield>
    1d12:	f6 cf       	rjmp	.-20     	; 0x1d00 <prvIdleTask+0x5e>

00001d14 <vTaskSwitchContext>:
    1d14:	80 91 74 08 	lds	r24, 0x0874
    1d18:	88 23       	and	r24, r24
    1d1a:	21 f0       	breq	.+8      	; 0x1d24 <vTaskSwitchContext+0x10>
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	80 93 77 08 	sts	0x0877, r24
    1d22:	08 95       	ret
    1d24:	10 92 77 08 	sts	0x0877, r1
    1d28:	80 91 7a 08 	lds	r24, 0x087A
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	fc 01       	movw	r30, r24
    1d30:	ee 0f       	add	r30, r30
    1d32:	ff 1f       	adc	r31, r31
    1d34:	ee 0f       	add	r30, r30
    1d36:	ff 1f       	adc	r31, r31
    1d38:	ee 0f       	add	r30, r30
    1d3a:	ff 1f       	adc	r31, r31
    1d3c:	8e 0f       	add	r24, r30
    1d3e:	9f 1f       	adc	r25, r31
    1d40:	fc 01       	movw	r30, r24
    1d42:	e0 55       	subi	r30, 0x50	; 80
    1d44:	f7 4f       	sbci	r31, 0xF7	; 247
    1d46:	80 81       	ld	r24, Z
    1d48:	81 11       	cpse	r24, r1
    1d4a:	17 c0       	rjmp	.+46     	; 0x1d7a <vTaskSwitchContext+0x66>
    1d4c:	80 91 7a 08 	lds	r24, 0x087A
    1d50:	81 50       	subi	r24, 0x01	; 1
    1d52:	80 93 7a 08 	sts	0x087A, r24
    1d56:	80 91 7a 08 	lds	r24, 0x087A
    1d5a:	90 e0       	ldi	r25, 0x00	; 0
    1d5c:	fc 01       	movw	r30, r24
    1d5e:	ee 0f       	add	r30, r30
    1d60:	ff 1f       	adc	r31, r31
    1d62:	ee 0f       	add	r30, r30
    1d64:	ff 1f       	adc	r31, r31
    1d66:	ee 0f       	add	r30, r30
    1d68:	ff 1f       	adc	r31, r31
    1d6a:	8e 0f       	add	r24, r30
    1d6c:	9f 1f       	adc	r25, r31
    1d6e:	fc 01       	movw	r30, r24
    1d70:	e0 55       	subi	r30, 0x50	; 80
    1d72:	f7 4f       	sbci	r31, 0xF7	; 247
    1d74:	80 81       	ld	r24, Z
    1d76:	88 23       	and	r24, r24
    1d78:	49 f3       	breq	.-46     	; 0x1d4c <vTaskSwitchContext+0x38>
    1d7a:	e0 91 7a 08 	lds	r30, 0x087A
    1d7e:	f0 e0       	ldi	r31, 0x00	; 0
    1d80:	cf 01       	movw	r24, r30
    1d82:	88 0f       	add	r24, r24
    1d84:	99 1f       	adc	r25, r25
    1d86:	88 0f       	add	r24, r24
    1d88:	99 1f       	adc	r25, r25
    1d8a:	88 0f       	add	r24, r24
    1d8c:	99 1f       	adc	r25, r25
    1d8e:	e8 0f       	add	r30, r24
    1d90:	f9 1f       	adc	r31, r25
    1d92:	e0 55       	subi	r30, 0x50	; 80
    1d94:	f7 4f       	sbci	r31, 0xF7	; 247
    1d96:	a1 81       	ldd	r26, Z+1	; 0x01
    1d98:	b2 81       	ldd	r27, Z+2	; 0x02
    1d9a:	12 96       	adiw	r26, 0x02	; 2
    1d9c:	0d 90       	ld	r0, X+
    1d9e:	bc 91       	ld	r27, X
    1da0:	a0 2d       	mov	r26, r0
    1da2:	b2 83       	std	Z+2, r27	; 0x02
    1da4:	a1 83       	std	Z+1, r26	; 0x01
    1da6:	cf 01       	movw	r24, r30
    1da8:	03 96       	adiw	r24, 0x03	; 3
    1daa:	a8 17       	cp	r26, r24
    1dac:	b9 07       	cpc	r27, r25
    1dae:	31 f4       	brne	.+12     	; 0x1dbc <vTaskSwitchContext+0xa8>
    1db0:	12 96       	adiw	r26, 0x02	; 2
    1db2:	8d 91       	ld	r24, X+
    1db4:	9c 91       	ld	r25, X
    1db6:	13 97       	sbiw	r26, 0x03	; 3
    1db8:	92 83       	std	Z+2, r25	; 0x02
    1dba:	81 83       	std	Z+1, r24	; 0x01
    1dbc:	01 80       	ldd	r0, Z+1	; 0x01
    1dbe:	f2 81       	ldd	r31, Z+2	; 0x02
    1dc0:	e0 2d       	mov	r30, r0
    1dc2:	86 81       	ldd	r24, Z+6	; 0x06
    1dc4:	97 81       	ldd	r25, Z+7	; 0x07
    1dc6:	90 93 de 08 	sts	0x08DE, r25
    1dca:	80 93 dd 08 	sts	0x08DD, r24
    1dce:	08 95       	ret

00001dd0 <vTaskSuspend>:
    1dd0:	0f 93       	push	r16
    1dd2:	1f 93       	push	r17
    1dd4:	cf 93       	push	r28
    1dd6:	df 93       	push	r29
    1dd8:	ec 01       	movw	r28, r24
    1dda:	0f b6       	in	r0, 0x3f	; 63
    1ddc:	f8 94       	cli
    1dde:	0f 92       	push	r0
    1de0:	00 97       	sbiw	r24, 0x00	; 0
    1de2:	21 f4       	brne	.+8      	; 0x1dec <vTaskSuspend+0x1c>
    1de4:	c0 91 dd 08 	lds	r28, 0x08DD
    1de8:	d0 91 de 08 	lds	r29, 0x08DE
    1dec:	8e 01       	movw	r16, r28
    1dee:	0e 5f       	subi	r16, 0xFE	; 254
    1df0:	1f 4f       	sbci	r17, 0xFF	; 255
    1df2:	c8 01       	movw	r24, r16
    1df4:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1df8:	8c 89       	ldd	r24, Y+20	; 0x14
    1dfa:	9d 89       	ldd	r25, Y+21	; 0x15
    1dfc:	89 2b       	or	r24, r25
    1dfe:	21 f0       	breq	.+8      	; 0x1e08 <vTaskSuspend+0x38>
    1e00:	ce 01       	movw	r24, r28
    1e02:	0c 96       	adiw	r24, 0x0c	; 12
    1e04:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1e08:	b8 01       	movw	r22, r16
    1e0a:	8e e7       	ldi	r24, 0x7E	; 126
    1e0c:	98 e0       	ldi	r25, 0x08	; 8
    1e0e:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1e12:	0f 90       	pop	r0
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	80 91 dd 08 	lds	r24, 0x08DD
    1e1a:	90 91 de 08 	lds	r25, 0x08DE
    1e1e:	c8 17       	cp	r28, r24
    1e20:	d9 07       	cpc	r29, r25
    1e22:	a1 f4       	brne	.+40     	; 0x1e4c <vTaskSuspend+0x7c>
    1e24:	80 91 79 08 	lds	r24, 0x0879
    1e28:	88 23       	and	r24, r24
    1e2a:	19 f0       	breq	.+6      	; 0x1e32 <vTaskSuspend+0x62>
    1e2c:	0e 94 f5 06 	call	0xdea	; 0xdea <vPortYield>
    1e30:	17 c0       	rjmp	.+46     	; 0x1e60 <vTaskSuspend+0x90>
    1e32:	80 91 7d 08 	lds	r24, 0x087D
    1e36:	90 91 7e 08 	lds	r25, 0x087E
    1e3a:	98 13       	cpse	r25, r24
    1e3c:	05 c0       	rjmp	.+10     	; 0x1e48 <vTaskSuspend+0x78>
    1e3e:	10 92 de 08 	sts	0x08DE, r1
    1e42:	10 92 dd 08 	sts	0x08DD, r1
    1e46:	0c c0       	rjmp	.+24     	; 0x1e60 <vTaskSuspend+0x90>
    1e48:	65 df       	rcall	.-310    	; 0x1d14 <vTaskSwitchContext>
    1e4a:	0a c0       	rjmp	.+20     	; 0x1e60 <vTaskSuspend+0x90>
    1e4c:	80 91 79 08 	lds	r24, 0x0879
    1e50:	88 23       	and	r24, r24
    1e52:	31 f0       	breq	.+12     	; 0x1e60 <vTaskSuspend+0x90>
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	0f 92       	push	r0
    1e5a:	96 db       	rcall	.-2260   	; 0x1588 <prvResetNextTaskUnblockTime>
    1e5c:	0f 90       	pop	r0
    1e5e:	0f be       	out	0x3f, r0	; 63
    1e60:	df 91       	pop	r29
    1e62:	cf 91       	pop	r28
    1e64:	1f 91       	pop	r17
    1e66:	0f 91       	pop	r16
    1e68:	08 95       	ret

00001e6a <vTaskPlaceOnEventList>:
    1e6a:	cf 93       	push	r28
    1e6c:	df 93       	push	r29
    1e6e:	eb 01       	movw	r28, r22
    1e70:	60 91 dd 08 	lds	r22, 0x08DD
    1e74:	70 91 de 08 	lds	r23, 0x08DE
    1e78:	64 5f       	subi	r22, 0xF4	; 244
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	0e 94 43 02 	call	0x486	; 0x486 <vListInsert>
    1e80:	80 91 dd 08 	lds	r24, 0x08DD
    1e84:	90 91 de 08 	lds	r25, 0x08DE
    1e88:	02 96       	adiw	r24, 0x02	; 2
    1e8a:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1e8e:	cf 3f       	cpi	r28, 0xFF	; 255
    1e90:	8f ef       	ldi	r24, 0xFF	; 255
    1e92:	d8 07       	cpc	r29, r24
    1e94:	59 f4       	brne	.+22     	; 0x1eac <vTaskPlaceOnEventList+0x42>
    1e96:	60 91 dd 08 	lds	r22, 0x08DD
    1e9a:	70 91 de 08 	lds	r23, 0x08DE
    1e9e:	6e 5f       	subi	r22, 0xFE	; 254
    1ea0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea2:	8e e7       	ldi	r24, 0x7E	; 126
    1ea4:	98 e0       	ldi	r25, 0x08	; 8
    1ea6:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1eaa:	07 c0       	rjmp	.+14     	; 0x1eba <vTaskPlaceOnEventList+0x50>
    1eac:	80 91 7b 08 	lds	r24, 0x087B
    1eb0:	90 91 7c 08 	lds	r25, 0x087C
    1eb4:	8c 0f       	add	r24, r28
    1eb6:	9d 1f       	adc	r25, r29
    1eb8:	86 db       	rcall	.-2292   	; 0x15c6 <prvAddCurrentTaskToDelayedList>
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	08 95       	ret

00001ec0 <xTaskRemoveFromEventList>:
    1ec0:	0f 93       	push	r16
    1ec2:	1f 93       	push	r17
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	dc 01       	movw	r26, r24
    1eca:	15 96       	adiw	r26, 0x05	; 5
    1ecc:	ed 91       	ld	r30, X+
    1ece:	fc 91       	ld	r31, X
    1ed0:	16 97       	sbiw	r26, 0x06	; 6
    1ed2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ed4:	d7 81       	ldd	r29, Z+7	; 0x07
    1ed6:	8e 01       	movw	r16, r28
    1ed8:	04 5f       	subi	r16, 0xF4	; 244
    1eda:	1f 4f       	sbci	r17, 0xFF	; 255
    1edc:	c8 01       	movw	r24, r16
    1ede:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1ee2:	80 91 74 08 	lds	r24, 0x0874
    1ee6:	81 11       	cpse	r24, r1
    1ee8:	1c c0       	rjmp	.+56     	; 0x1f22 <xTaskRemoveFromEventList+0x62>
    1eea:	0a 50       	subi	r16, 0x0A	; 10
    1eec:	11 09       	sbc	r17, r1
    1eee:	c8 01       	movw	r24, r16
    1ef0:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    1ef4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ef6:	90 91 7a 08 	lds	r25, 0x087A
    1efa:	98 17       	cp	r25, r24
    1efc:	10 f4       	brcc	.+4      	; 0x1f02 <xTaskRemoveFromEventList+0x42>
    1efe:	80 93 7a 08 	sts	0x087A, r24
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	9c 01       	movw	r18, r24
    1f06:	22 0f       	add	r18, r18
    1f08:	33 1f       	adc	r19, r19
    1f0a:	22 0f       	add	r18, r18
    1f0c:	33 1f       	adc	r19, r19
    1f0e:	22 0f       	add	r18, r18
    1f10:	33 1f       	adc	r19, r19
    1f12:	82 0f       	add	r24, r18
    1f14:	93 1f       	adc	r25, r19
    1f16:	b8 01       	movw	r22, r16
    1f18:	80 55       	subi	r24, 0x50	; 80
    1f1a:	97 4f       	sbci	r25, 0xF7	; 247
    1f1c:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1f20:	05 c0       	rjmp	.+10     	; 0x1f2c <xTaskRemoveFromEventList+0x6c>
    1f22:	b8 01       	movw	r22, r16
    1f24:	81 e9       	ldi	r24, 0x91	; 145
    1f26:	98 e0       	ldi	r25, 0x08	; 8
    1f28:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    1f2c:	e0 91 dd 08 	lds	r30, 0x08DD
    1f30:	f0 91 de 08 	lds	r31, 0x08DE
    1f34:	9e 89       	ldd	r25, Y+22	; 0x16
    1f36:	86 89       	ldd	r24, Z+22	; 0x16
    1f38:	89 17       	cp	r24, r25
    1f3a:	20 f4       	brcc	.+8      	; 0x1f44 <xTaskRemoveFromEventList+0x84>
    1f3c:	81 e0       	ldi	r24, 0x01	; 1
    1f3e:	80 93 77 08 	sts	0x0877, r24
    1f42:	01 c0       	rjmp	.+2      	; 0x1f46 <xTaskRemoveFromEventList+0x86>
    1f44:	80 e0       	ldi	r24, 0x00	; 0
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	08 95       	ret

00001f50 <vTaskSetTimeOutState>:
    1f50:	20 91 76 08 	lds	r18, 0x0876
    1f54:	fc 01       	movw	r30, r24
    1f56:	20 83       	st	Z, r18
    1f58:	20 91 7b 08 	lds	r18, 0x087B
    1f5c:	30 91 7c 08 	lds	r19, 0x087C
    1f60:	32 83       	std	Z+2, r19	; 0x02
    1f62:	21 83       	std	Z+1, r18	; 0x01
    1f64:	08 95       	ret

00001f66 <xTaskCheckForTimeOut>:
    1f66:	0f b6       	in	r0, 0x3f	; 63
    1f68:	f8 94       	cli
    1f6a:	0f 92       	push	r0
    1f6c:	40 91 7b 08 	lds	r20, 0x087B
    1f70:	50 91 7c 08 	lds	r21, 0x087C
    1f74:	db 01       	movw	r26, r22
    1f76:	2d 91       	ld	r18, X+
    1f78:	3c 91       	ld	r19, X
    1f7a:	2f 3f       	cpi	r18, 0xFF	; 255
    1f7c:	bf ef       	ldi	r27, 0xFF	; 255
    1f7e:	3b 07       	cpc	r19, r27
    1f80:	11 f1       	breq	.+68     	; 0x1fc6 <xTaskCheckForTimeOut+0x60>
    1f82:	e0 91 76 08 	lds	r30, 0x0876
    1f86:	dc 01       	movw	r26, r24
    1f88:	fc 91       	ld	r31, X
    1f8a:	fe 17       	cp	r31, r30
    1f8c:	39 f0       	breq	.+14     	; 0x1f9c <xTaskCheckForTimeOut+0x36>
    1f8e:	11 96       	adiw	r26, 0x01	; 1
    1f90:	ed 91       	ld	r30, X+
    1f92:	fc 91       	ld	r31, X
    1f94:	12 97       	sbiw	r26, 0x02	; 2
    1f96:	4e 17       	cp	r20, r30
    1f98:	5f 07       	cpc	r21, r31
    1f9a:	b8 f4       	brcc	.+46     	; 0x1fca <xTaskCheckForTimeOut+0x64>
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	11 96       	adiw	r26, 0x01	; 1
    1fa0:	ed 91       	ld	r30, X+
    1fa2:	fc 91       	ld	r31, X
    1fa4:	12 97       	sbiw	r26, 0x02	; 2
    1fa6:	da 01       	movw	r26, r20
    1fa8:	ae 1b       	sub	r26, r30
    1faa:	bf 0b       	sbc	r27, r31
    1fac:	a2 17       	cp	r26, r18
    1fae:	b3 07       	cpc	r27, r19
    1fb0:	70 f4       	brcc	.+28     	; 0x1fce <xTaskCheckForTimeOut+0x68>
    1fb2:	e4 1b       	sub	r30, r20
    1fb4:	f5 0b       	sbc	r31, r21
    1fb6:	2e 0f       	add	r18, r30
    1fb8:	3f 1f       	adc	r19, r31
    1fba:	fb 01       	movw	r30, r22
    1fbc:	31 83       	std	Z+1, r19	; 0x01
    1fbe:	20 83       	st	Z, r18
    1fc0:	c7 df       	rcall	.-114    	; 0x1f50 <vTaskSetTimeOutState>
    1fc2:	80 e0       	ldi	r24, 0x00	; 0
    1fc4:	05 c0       	rjmp	.+10     	; 0x1fd0 <xTaskCheckForTimeOut+0x6a>
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	03 c0       	rjmp	.+6      	; 0x1fd0 <xTaskCheckForTimeOut+0x6a>
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	01 c0       	rjmp	.+2      	; 0x1fd0 <xTaskCheckForTimeOut+0x6a>
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	0f 90       	pop	r0
    1fd2:	0f be       	out	0x3f, r0	; 63
    1fd4:	08 95       	ret

00001fd6 <vTaskMissedYield>:
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 93 77 08 	sts	0x0877, r24
    1fdc:	08 95       	ret

00001fde <vTaskPriorityInherit>:
    1fde:	0f 93       	push	r16
    1fe0:	1f 93       	push	r17
    1fe2:	cf 93       	push	r28
    1fe4:	df 93       	push	r29
    1fe6:	ec 01       	movw	r28, r24
    1fe8:	00 97       	sbiw	r24, 0x00	; 0
    1fea:	09 f4       	brne	.+2      	; 0x1fee <vTaskPriorityInherit+0x10>
    1fec:	51 c0       	rjmp	.+162    	; 0x2090 <vTaskPriorityInherit+0xb2>
    1fee:	8e 89       	ldd	r24, Y+22	; 0x16
    1ff0:	e0 91 dd 08 	lds	r30, 0x08DD
    1ff4:	f0 91 de 08 	lds	r31, 0x08DE
    1ff8:	96 89       	ldd	r25, Z+22	; 0x16
    1ffa:	89 17       	cp	r24, r25
    1ffc:	08 f0       	brcs	.+2      	; 0x2000 <vTaskPriorityInherit+0x22>
    1ffe:	48 c0       	rjmp	.+144    	; 0x2090 <vTaskPriorityInherit+0xb2>
    2000:	2c 85       	ldd	r18, Y+12	; 0x0c
    2002:	3d 85       	ldd	r19, Y+13	; 0x0d
    2004:	33 23       	and	r19, r19
    2006:	5c f0       	brlt	.+22     	; 0x201e <vTaskPriorityInherit+0x40>
    2008:	e0 91 dd 08 	lds	r30, 0x08DD
    200c:	f0 91 de 08 	lds	r31, 0x08DE
    2010:	96 89       	ldd	r25, Z+22	; 0x16
    2012:	25 e0       	ldi	r18, 0x05	; 5
    2014:	30 e0       	ldi	r19, 0x00	; 0
    2016:	29 1b       	sub	r18, r25
    2018:	31 09       	sbc	r19, r1
    201a:	3d 87       	std	Y+13, r19	; 0x0d
    201c:	2c 87       	std	Y+12, r18	; 0x0c
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	9c 01       	movw	r18, r24
    2022:	22 0f       	add	r18, r18
    2024:	33 1f       	adc	r19, r19
    2026:	22 0f       	add	r18, r18
    2028:	33 1f       	adc	r19, r19
    202a:	22 0f       	add	r18, r18
    202c:	33 1f       	adc	r19, r19
    202e:	82 0f       	add	r24, r18
    2030:	93 1f       	adc	r25, r19
    2032:	80 55       	subi	r24, 0x50	; 80
    2034:	97 4f       	sbci	r25, 0xF7	; 247
    2036:	2a 85       	ldd	r18, Y+10	; 0x0a
    2038:	3b 85       	ldd	r19, Y+11	; 0x0b
    203a:	28 17       	cp	r18, r24
    203c:	39 07       	cpc	r19, r25
    203e:	11 f5       	brne	.+68     	; 0x2084 <vTaskPriorityInherit+0xa6>
    2040:	8e 01       	movw	r16, r28
    2042:	0e 5f       	subi	r16, 0xFE	; 254
    2044:	1f 4f       	sbci	r17, 0xFF	; 255
    2046:	c8 01       	movw	r24, r16
    2048:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    204c:	e0 91 dd 08 	lds	r30, 0x08DD
    2050:	f0 91 de 08 	lds	r31, 0x08DE
    2054:	86 89       	ldd	r24, Z+22	; 0x16
    2056:	8e 8b       	std	Y+22, r24	; 0x16
    2058:	90 91 7a 08 	lds	r25, 0x087A
    205c:	98 17       	cp	r25, r24
    205e:	10 f4       	brcc	.+4      	; 0x2064 <vTaskPriorityInherit+0x86>
    2060:	80 93 7a 08 	sts	0x087A, r24
    2064:	90 e0       	ldi	r25, 0x00	; 0
    2066:	9c 01       	movw	r18, r24
    2068:	22 0f       	add	r18, r18
    206a:	33 1f       	adc	r19, r19
    206c:	22 0f       	add	r18, r18
    206e:	33 1f       	adc	r19, r19
    2070:	22 0f       	add	r18, r18
    2072:	33 1f       	adc	r19, r19
    2074:	82 0f       	add	r24, r18
    2076:	93 1f       	adc	r25, r19
    2078:	b8 01       	movw	r22, r16
    207a:	80 55       	subi	r24, 0x50	; 80
    207c:	97 4f       	sbci	r25, 0xF7	; 247
    207e:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    2082:	06 c0       	rjmp	.+12     	; 0x2090 <vTaskPriorityInherit+0xb2>
    2084:	e0 91 dd 08 	lds	r30, 0x08DD
    2088:	f0 91 de 08 	lds	r31, 0x08DE
    208c:	86 89       	ldd	r24, Z+22	; 0x16
    208e:	8e 8b       	std	Y+22, r24	; 0x16
    2090:	df 91       	pop	r29
    2092:	cf 91       	pop	r28
    2094:	1f 91       	pop	r17
    2096:	0f 91       	pop	r16
    2098:	08 95       	ret

0000209a <xTaskPriorityDisinherit>:
    209a:	0f 93       	push	r16
    209c:	1f 93       	push	r17
    209e:	cf 93       	push	r28
    20a0:	df 93       	push	r29
    20a2:	ec 01       	movw	r28, r24
    20a4:	00 97       	sbiw	r24, 0x00	; 0
    20a6:	71 f1       	breq	.+92     	; 0x2104 <xTaskPriorityDisinherit+0x6a>
    20a8:	8a a1       	ldd	r24, Y+34	; 0x22
    20aa:	81 50       	subi	r24, 0x01	; 1
    20ac:	8a a3       	std	Y+34, r24	; 0x22
    20ae:	2e 89       	ldd	r18, Y+22	; 0x16
    20b0:	99 a1       	ldd	r25, Y+33	; 0x21
    20b2:	29 17       	cp	r18, r25
    20b4:	49 f1       	breq	.+82     	; 0x2108 <xTaskPriorityDisinherit+0x6e>
    20b6:	81 11       	cpse	r24, r1
    20b8:	29 c0       	rjmp	.+82     	; 0x210c <xTaskPriorityDisinherit+0x72>
    20ba:	8e 01       	movw	r16, r28
    20bc:	0e 5f       	subi	r16, 0xFE	; 254
    20be:	1f 4f       	sbci	r17, 0xFF	; 255
    20c0:	c8 01       	movw	r24, r16
    20c2:	0e 94 74 02 	call	0x4e8	; 0x4e8 <uxListRemove>
    20c6:	89 a1       	ldd	r24, Y+33	; 0x21
    20c8:	8e 8b       	std	Y+22, r24	; 0x16
    20ca:	25 e0       	ldi	r18, 0x05	; 5
    20cc:	30 e0       	ldi	r19, 0x00	; 0
    20ce:	28 1b       	sub	r18, r24
    20d0:	31 09       	sbc	r19, r1
    20d2:	3d 87       	std	Y+13, r19	; 0x0d
    20d4:	2c 87       	std	Y+12, r18	; 0x0c
    20d6:	90 91 7a 08 	lds	r25, 0x087A
    20da:	98 17       	cp	r25, r24
    20dc:	10 f4       	brcc	.+4      	; 0x20e2 <xTaskPriorityDisinherit+0x48>
    20de:	80 93 7a 08 	sts	0x087A, r24
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	9c 01       	movw	r18, r24
    20e6:	22 0f       	add	r18, r18
    20e8:	33 1f       	adc	r19, r19
    20ea:	22 0f       	add	r18, r18
    20ec:	33 1f       	adc	r19, r19
    20ee:	22 0f       	add	r18, r18
    20f0:	33 1f       	adc	r19, r19
    20f2:	82 0f       	add	r24, r18
    20f4:	93 1f       	adc	r25, r19
    20f6:	b8 01       	movw	r22, r16
    20f8:	80 55       	subi	r24, 0x50	; 80
    20fa:	97 4f       	sbci	r25, 0xF7	; 247
    20fc:	0e 94 22 02 	call	0x444	; 0x444 <vListInsertEnd>
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	05 c0       	rjmp	.+10     	; 0x210e <xTaskPriorityDisinherit+0x74>
    2104:	80 e0       	ldi	r24, 0x00	; 0
    2106:	03 c0       	rjmp	.+6      	; 0x210e <xTaskPriorityDisinherit+0x74>
    2108:	80 e0       	ldi	r24, 0x00	; 0
    210a:	01 c0       	rjmp	.+2      	; 0x210e <xTaskPriorityDisinherit+0x74>
    210c:	80 e0       	ldi	r24, 0x00	; 0
    210e:	df 91       	pop	r29
    2110:	cf 91       	pop	r28
    2112:	1f 91       	pop	r17
    2114:	0f 91       	pop	r16
    2116:	08 95       	ret

00002118 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2118:	80 91 dd 08 	lds	r24, 0x08DD
    211c:	90 91 de 08 	lds	r25, 0x08DE
    2120:	89 2b       	or	r24, r25
    2122:	39 f0       	breq	.+14     	; 0x2132 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2124:	e0 91 dd 08 	lds	r30, 0x08DD
    2128:	f0 91 de 08 	lds	r31, 0x08DE
    212c:	82 a1       	ldd	r24, Z+34	; 0x22
    212e:	8f 5f       	subi	r24, 0xFF	; 255
    2130:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2132:	80 91 dd 08 	lds	r24, 0x08DD
    2136:	90 91 de 08 	lds	r25, 0x08DE
	}
    213a:	08 95       	ret

0000213c <__divmodhi4>:
    213c:	97 fb       	bst	r25, 7
    213e:	07 2e       	mov	r0, r23
    2140:	16 f4       	brtc	.+4      	; 0x2146 <__divmodhi4+0xa>
    2142:	00 94       	com	r0
    2144:	06 d0       	rcall	.+12     	; 0x2152 <__divmodhi4_neg1>
    2146:	77 fd       	sbrc	r23, 7
    2148:	08 d0       	rcall	.+16     	; 0x215a <__divmodhi4_neg2>
    214a:	0b d0       	rcall	.+22     	; 0x2162 <__udivmodhi4>
    214c:	07 fc       	sbrc	r0, 7
    214e:	05 d0       	rcall	.+10     	; 0x215a <__divmodhi4_neg2>
    2150:	3e f4       	brtc	.+14     	; 0x2160 <__divmodhi4_exit>

00002152 <__divmodhi4_neg1>:
    2152:	90 95       	com	r25
    2154:	81 95       	neg	r24
    2156:	9f 4f       	sbci	r25, 0xFF	; 255
    2158:	08 95       	ret

0000215a <__divmodhi4_neg2>:
    215a:	70 95       	com	r23
    215c:	61 95       	neg	r22
    215e:	7f 4f       	sbci	r23, 0xFF	; 255

00002160 <__divmodhi4_exit>:
    2160:	08 95       	ret

00002162 <__udivmodhi4>:
    2162:	aa 1b       	sub	r26, r26
    2164:	bb 1b       	sub	r27, r27
    2166:	51 e1       	ldi	r21, 0x11	; 17
    2168:	07 c0       	rjmp	.+14     	; 0x2178 <__udivmodhi4_ep>

0000216a <__udivmodhi4_loop>:
    216a:	aa 1f       	adc	r26, r26
    216c:	bb 1f       	adc	r27, r27
    216e:	a6 17       	cp	r26, r22
    2170:	b7 07       	cpc	r27, r23
    2172:	10 f0       	brcs	.+4      	; 0x2178 <__udivmodhi4_ep>
    2174:	a6 1b       	sub	r26, r22
    2176:	b7 0b       	sbc	r27, r23

00002178 <__udivmodhi4_ep>:
    2178:	88 1f       	adc	r24, r24
    217a:	99 1f       	adc	r25, r25
    217c:	5a 95       	dec	r21
    217e:	a9 f7       	brne	.-22     	; 0x216a <__udivmodhi4_loop>
    2180:	80 95       	com	r24
    2182:	90 95       	com	r25
    2184:	bc 01       	movw	r22, r24
    2186:	cd 01       	movw	r24, r26
    2188:	08 95       	ret

0000218a <memcpy>:
    218a:	fb 01       	movw	r30, r22
    218c:	dc 01       	movw	r26, r24
    218e:	02 c0       	rjmp	.+4      	; 0x2194 <memcpy+0xa>
    2190:	01 90       	ld	r0, Z+
    2192:	0d 92       	st	X+, r0
    2194:	41 50       	subi	r20, 0x01	; 1
    2196:	50 40       	sbci	r21, 0x00	; 0
    2198:	d8 f7       	brcc	.-10     	; 0x2190 <memcpy+0x6>
    219a:	08 95       	ret

0000219c <__itoa_ncheck>:
    219c:	bb 27       	eor	r27, r27
    219e:	4a 30       	cpi	r20, 0x0A	; 10
    21a0:	31 f4       	brne	.+12     	; 0x21ae <__itoa_ncheck+0x12>
    21a2:	99 23       	and	r25, r25
    21a4:	22 f4       	brpl	.+8      	; 0x21ae <__itoa_ncheck+0x12>
    21a6:	bd e2       	ldi	r27, 0x2D	; 45
    21a8:	90 95       	com	r25
    21aa:	81 95       	neg	r24
    21ac:	9f 4f       	sbci	r25, 0xFF	; 255
    21ae:	01 c0       	rjmp	.+2      	; 0x21b2 <__utoa_common>

000021b0 <__utoa_ncheck>:
    21b0:	bb 27       	eor	r27, r27

000021b2 <__utoa_common>:
    21b2:	fb 01       	movw	r30, r22
    21b4:	55 27       	eor	r21, r21
    21b6:	aa 27       	eor	r26, r26
    21b8:	88 0f       	add	r24, r24
    21ba:	99 1f       	adc	r25, r25
    21bc:	aa 1f       	adc	r26, r26
    21be:	a4 17       	cp	r26, r20
    21c0:	10 f0       	brcs	.+4      	; 0x21c6 <__utoa_common+0x14>
    21c2:	a4 1b       	sub	r26, r20
    21c4:	83 95       	inc	r24
    21c6:	50 51       	subi	r21, 0x10	; 16
    21c8:	b9 f7       	brne	.-18     	; 0x21b8 <__utoa_common+0x6>
    21ca:	a0 5d       	subi	r26, 0xD0	; 208
    21cc:	aa 33       	cpi	r26, 0x3A	; 58
    21ce:	08 f0       	brcs	.+2      	; 0x21d2 <__utoa_common+0x20>
    21d0:	a9 5d       	subi	r26, 0xD9	; 217
    21d2:	a1 93       	st	Z+, r26
    21d4:	00 97       	sbiw	r24, 0x00	; 0
    21d6:	79 f7       	brne	.-34     	; 0x21b6 <__utoa_common+0x4>
    21d8:	b1 11       	cpse	r27, r1
    21da:	b1 93       	st	Z+, r27
    21dc:	11 92       	st	Z+, r1
    21de:	cb 01       	movw	r24, r22
    21e0:	00 c0       	rjmp	.+0      	; 0x21e2 <strrev>

000021e2 <strrev>:
    21e2:	dc 01       	movw	r26, r24
    21e4:	fc 01       	movw	r30, r24
    21e6:	67 2f       	mov	r22, r23
    21e8:	71 91       	ld	r23, Z+
    21ea:	77 23       	and	r23, r23
    21ec:	e1 f7       	brne	.-8      	; 0x21e6 <strrev+0x4>
    21ee:	32 97       	sbiw	r30, 0x02	; 2
    21f0:	04 c0       	rjmp	.+8      	; 0x21fa <strrev+0x18>
    21f2:	7c 91       	ld	r23, X
    21f4:	6d 93       	st	X+, r22
    21f6:	70 83       	st	Z, r23
    21f8:	62 91       	ld	r22, -Z
    21fa:	ae 17       	cp	r26, r30
    21fc:	bf 07       	cpc	r27, r31
    21fe:	c8 f3       	brcs	.-14     	; 0x21f2 <strrev+0x10>
    2200:	08 95       	ret

00002202 <_exit>:
    2202:	f8 94       	cli

00002204 <__stop_program>:
    2204:	ff cf       	rjmp	.-2      	; 0x2204 <__stop_program>
